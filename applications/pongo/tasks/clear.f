      SUBROUTINE CLEAR( STATUS )
*+
*  Name:
*     CLEAR

*  Purpose:
*     Clear plotting attributes.

*  Language:
*     FORTRAN

*  Type of Module:
*     ADAM A-task

*  Arguments:
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Description:
*     Clear or reset various PONGO plotting attributes. Several or all
*     of these plotting attributes can be specified on the command line.

*  Usage:
*     clear

*  ADAM Parameters:
*     SCREEN = _LOGICAL (Read)
*        If TRUE, the plotting surface will be cleared.
*        [FALSE]
*     DATA = _LOGICAL (Read)
*        If TRUE, the data arrays will be cleared. This can be useful
*        if there is still unwanted data left in some of the data
*        areas: for example, the READF command does not automatically
*        clear columns that it does not read in. Even if the
*        appropriate READF parameters have been set to 0 to inhibit
*        reading error columns from the second file, the values from
*        the first file will remain in the data areas. This behaviour is
*        designed to allow columns to be read from separate files and
*        combined in one plot. However, it can cause the automatic axis
*        limit finding routines to appear to fail because of data left
*        in error columns. This most commonly occurs when a file not
*        containing error values is read immediately after one that
*        does.
*        [FALSE]
*     LIMITS = _LOGICAL (Read)
*        If TRUE, the data limits will be cleared and the data
*        re-examined in order to determine the axis limits. This
*        command is often necessary if a complicated function has been
*        performed on the data using the CCMATH command, because the
*        current PONGO parameters may no longer be applicable to the
*        data.
*        [FALSE]
*     LABLST = _LOGICAL (Read)
*        If TRUE, the internal label list generated by the CURSE
*        command will be cleared.
*        [FALSE]
*     AGI = _LOGICAL (Read)
*        If TRUE, the AGI database is cleared for the current device.
*        [FALSE]
*     ERSCALE = _REAL (Read)
*        The scale factor by which the errors are to be multiplied.
*        (Can only be set when LIMITS are cleared.)
*
*        The value of the global parameter PONGO_ERSCALE is used. If
*        PONGO_ERSCALE is not defined, the default value 1.0 is used.

*  Authors:
*     JBVAD::PAH: Paul Harrison (Jodrell Bank)
*     PCTR: P.C.T. Rees (STARLINK)
*     PDRAPER: P.W. Draper (STARLINK - Durham University)
*     {enter_new_authors_here}

*  History:
*     28-NOV-1990 (JBVAD::PAH):
*        Original version.
*     19-OCT-1992 (PCTR):
*        Added contextual error report on exit.
*     6-JUN-1994 (PDRAPER):
*        Changed DCV_PAR to PRM_PAR.
*     17-JUN-1994 (PDRAPER):
*        Changed help on ERSCALE to point out that setting this is only
*        possible when clearing LIMITS.
*     20-JUN-1994 (PDRAPER):
*        Added checks for PGPLOT device being open.
*     12-JUL-1994 (PDRAPER):
*        Now clears the X and Y logarithm flags when the data areas are
*        cleared.
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}

*-

*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants
      INCLUDE 'PONGO_PAR'        ! PONGO global constants
      INCLUDE 'PRM_PAR'          ! PRIMDAT constants

*  Global Variables:
      INCLUDE 'PONGO_CMN'        ! PONGO global variables

*  Status:
      INTEGER STATUS             ! Global status

*  External References:
      EXTERNAL PON_DEVOP
      LOGICAL PON_DEVOP          ! PGPLOT is active

*  Local Variables:
      LOGICAL ACTION             ! Action to be taken
      LOGICAL DONE               ! Flag to show that something has been done

      INTEGER BASEID             ! AGI base picture ID
      INTEGER IDAT               ! Counter
      INTEGER PICID              ! AGI current picture ID

      REAL SCALE
      REAL SSS

*.

*  Check inherited global status.
      IF ( STATUS .NE. SAI__OK ) RETURN

*  Initialise the DONE flag.
      DONE = .FALSE.

*  Clear the plotting device.
      CALL PAR_GET0L( 'SCREEN', ACTION, STATUS )
      IF ( ACTION ) THEN
         DONE = .TRUE.
         IF ( PON_DEVOP( .FALSE., STATUS ) ) THEN
            CALL PGADVANCE
         ELSE
            IF ( STATUS .EQ. SAI__OK ) THEN
               STATUS = SAI__ERROR
               CALL ERR_REP( 'CLEAR_DEVNOTOPN', 'Plotting device is ' //
     :              'not open use BEGPLOT', STATUS )
            END IF
            GO TO 99
         END IF
      END IF

*  Clear the internal data arrays.
      CALL PAR_GET0L( 'DATA', ACTION, STATUS )
      IF ( ACTION ) THEN
         DONE = .TRUE.
         DO IDAT = 1,NDATMAX
            XDATA( IDAT ) = 0.0D+00
            YDATA( IDAT ) = 0.0D+00
            ERRX( IDAT ) = 0.0
            ERRY( IDAT ) = 0.0
            ZDATA( IDAT ) = 0.0
            CLABELS( IDAT ) = ' '
         END DO
         NDAT = 0

*  Reset the logarithm flags.
         LXLOG = .FALSE.
         LYLOG = .FALSE.
      END IF

*  Reset the limits.
      CALL PAR_GET0L( 'LIMITS', ACTION, STATUS )
      IF ( ACTION ) THEN
         DONE = .TRUE.
         CALL PAR_GET0R( 'ERSCALE', SCALE, STATUS )
         SSS = SQRT( SCALE )
         XMIN = VAL__MAXR
         XMAX = VAL__MINR
         YMIN = VAL__MAXR
         YMAX = VAL__MINR
         DO IDAT = 1, NDAT
            XMAX = MAX( XMAX,
     :                  REAL( XDATA( IDAT ) ) + SSS * ERRX( IDAT ) )
            XMIN = MIN( XMIN,
     :                  REAL( XDATA( IDAT ) ) - SSS * ERRX( IDAT ) )
            YMAX = MAX( YMAX,
     :                  REAL( YDATA( IDAT ) ) + SSS * ERRY( IDAT ) )
            YMIN = MIN( YMIN,
     :                  REAL( YDATA( IDAT ) ) - SSS * ERRY( IDAT ) )
         END DO
      END IF

*  Clear the internal label list.
      CALL PAR_GET0L( 'LABLST', ACTION, STATUS )
      IF ( ACTION ) THEN
         DONE = .TRUE.
         ILABPTR = 0
      END IF

*  Clear the AGI database.
      CALL PAR_GET0L( 'AGI', ACTION, STATUS )
      IF ( ACTION ) THEN
         DONE = .TRUE.
         IF ( PON_DEVOP( .FALSE., STATUS ) ) THEN

*  Finish previous AGI context.
            CALL AGI_END( -1, STATUS )

*  Find out the current and base pictures.
            CALL AGI_ICURP( PICID, STATUS )
            CALL AGI_IBASE( BASEID, STATUS )
            IF ( PICID .NE. BASEID ) THEN

*  Make the base picture current and annul the previous ID.
               CALL AGI_SELP( BASEID, STATUS )
               CALL AGI_ANNUL( PICID, STATUS )
            END IF
            CALL AGI_PDEL( STATUS )

*  Begin a new AGI context
            CALL AGI_BEGIN
         ELSE
            GO TO 99
         END IF
      END IF

*  Report a message if no action was taken.
      IF ( ( .NOT. DONE )
     :     .AND. ( STATUS .EQ. SAI__OK ) ) CALL MSG_OUT( ' ',
     :                                        'No action has been ' //
     :                                        'taken.', STATUS )

*  Check the returned status and report a contextual error message if
*  necessary.
 99   CONTINUE
      IF ( STATUS .NE. SAI__OK ) CALL ERR_REP( 'CLEAR_END',
     :                              'CLEAR: Unable to clear ' //
     :                              'plotting attributes.', STATUS )

      END
* $Id$
