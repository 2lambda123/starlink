0 Help
 Welcome to the online-help system for CONVERT, a data-format conversion
 package.  Here you can display details about a specific CONVERT command
 or more-general information  such how to use application parameters and 
 how to respond to prompts.

 If you need assistance using this help system,  enter "Using_help" in
 response to the "Topic?" prompt.
1 ASCII2NDF
Converts a text file to an NDF.

Usage:

   ascii2ndf in out [comp] [skip] shape [type]

Description:

   This application converts a text file to an NDF.  Only one of
   the array components may be created from the input file.
   Preceding the input data there may be an optional header.  This
   header may be skipped, or may consist of a simple FITS header.
   In the former case the shape of the NDF has be to be supplied.
2 Parameters
For information on individual parameters, select from the list below:
3 COMP
COMP = LITERAL (Read)
   The NDF component to be copied.  It may be "Data", "Quality"
   or "Variance".  To create a variance or quality array the NDF
   must already exist. ["Data"]
3 FITS
FITS = _LOGICAL (Read)
   If TRUE, the initial records of the formatted file are
   interpreted as a FITS header (with one card image per record)
   from which the shape, data type, and axis centres are derived.
   The last record of the FITS-like header must be terminated by
   an END keyword; subsequent records in the input file are
   treated as an array component given by COMP.  [FALSE]
3 IN
IN = FILENAME (Read)
   Name of the input Fortran text file.  The file will normally
   have variable-length records when there is a header, but
   always fixed-length records when there is no header.  The
   maximum record length allowed is 512 bytes.
3 MAXLEN
MAXLEN = _INTEGER (Read)
   The maximum record length in bytes of records within the input
   text file.  Unless the records are longer than 512 bytes, you
   can use the default value.  The suggested value is the current
   value. [512]
3 OUT
OUT = NDF (Read and Write)
   Output NDF data structure.  When COMP is not "Data" the NDF
   is modified rather than a new NDF created.   It becomes the
   new current NDF.
3 SHAPE
SHAPE = _INTEGER (Read)
   The shape of the NDF to be created.  For example, [40,30,20]
   would create 40 columns by 30 lines by 10 bands.  It is only
   accessed when FITS is FALSE.
3 SKIP
SKIP = INTEGER (Read)
   The number of header records to be skipped at the start of the
   input file before finding the data array or FITS-like header.
   [0]
3 TYPE
TYPE = LITERAL (Read)
   The data type of the output NDF.  It must be one of the
   following HDS types: "_BYTE", "_WORD", "_REAL", "_INTEGER",
   "_DOUBLE", "_UBYTE", "_UWORD" corresponding to signed byte,
   signed word, real, integer, double precision, unsigned byte,
   and unsigned word.  See SUN/92 for further details.  An
   unambiguous abbreviation may be given.  TYPE is ignored when
   COMP = "Quality" since the QUALITY component must comprise
   unsigned bytes (equivalent to TYPE = "_UBYTE") to be a valid
   NDF.  The suggested default is the current value.  TYPE is only
   accessed when FITS is FALSE. ["_REAL"]
2 Examples
ascii2ndf ngc253.dat ngc253 shape=[100,60]
   This copies a data array from the text file ngc253.dat to the
   NDF called ngc253.  The input file does not contain a header
   section.  The NDF is two-dimensional: 100 elements in x by 60
   in y.  Its data array has type _REAL.

ascii2ndf ngc253q.dat ngc253 q shape=[100,60]
   This copies a quality array from the text file ngc253q.dat to
   an existing NDF called ngc253 (such as created in the first
   example).  The input file does not contain a header section.
   The NDF is two-dimensional: 100 elements in x by 60 in y.  Its
   data array has type _UBYTE.

ascii2ndf ngc253.dat ngc253 fits
   This copies a data array from the text file ngc253.dat
   to the NDF called ngc253.  The input file contains a FITS-like
   header section, which is copied to the FITS extension of the
   NDF.  The shape of the NDF is controlled by the mandatory FITS
   keywords NAXIS, AXIS1, ..., AXISn, and the data type by
   keywords BITPIX and UNSIGNED.

ascii2ndf type='_uword' in=ngc253.dat out=ngc253 maxlen=4000 \
   This copies a data array from the text file ngc253.dat to the
   NDF called ngc253.  The input file does not contain a header
   section.  The NDF has the current shape and data type is
   unsigned word.  The maximum record length is 4000 bytes.

ascii2ndf spectrum zz skip=2 shape=200
   This copies a data array from the text file spectrum to
   the NDF called zz.  The input file contains two header records
   that are ignored.  The NDF is one-dimensional comprising 200
   elements of type _REAL.

ascii2ndf spectrum.lis ZZ skip=1 fits
   This copies a data array from the text file spectrum.lis to
   the NDF called ZZ.  The input file contains one header record,
   that is ignored, followed by a FITS-like header section, which
   is copied to the FITS extension of the NDF.  The shape of the
   NDF is controlled by the mandatory FITS keywords NAXIS, AXIS1,
   ..., AXISn, and the data type by keywords BITPIX and UNSIGNED.
2 Notes
The details of the conversion are as follows:

   -  the text-file array is written to the NDF array as
   selected by COMP.  When the NDF is being modified, the shape
   of the new component must match that of the NDF.

   -  If the input file contains a FITS-like header, and a new
   NDF is created, i.e. COMP = "Data", the header records are
   placed within the NDF's FITS extension.  This enables more
   than one array (input file) to be used to form an NDF.  Note
   that the data array must be created first to make a valid NDF,
   and it's the FITS structure associated with that array that is
   wanted.  Indeed the application prevents you from doing
   otherwise.

   -  The FITS-like header defines the properties of the NDF as
   follows:
      o  BITPIX defines the data type: 8 gives _BYTE, 16 produces
      _WORD, 32 makes _INTEGER, -32 gives _REAL, and -64 generates
      _DOUBLE.  For the first two, if there is an extra header
      record with the keyword UNSIGNED and logical value T, these
      types become _UBYTE and _UWORD respectively.  UNSIGNED is
      non-standard, since unsigned integers would not follow in a
      proper FITS file.  However, here it is useful to enable
      unsigned types to be input into an NDF.  UNSIGNED may be
      created by this application's sister, NDF2ASCII.  BITPIX is
      ignored for QUALITY data; type _UBYTE is used.
      o  NAXIS, and NAXISn define the shape of the NDF.
      o  The TITLE, LABEL, and BUNIT are copied to the NDF
      TITLE, LABEL, and UNITS NDF components respectively.
      o  The CDELTn, CRVALn, CTYPEn, and CUNITn keywords make
      linear axis structures within the NDF.  CUNITn define the
      axis units, and the axis labels are assigned to CTYPEn.
      If some are missing, pixel co-ordinates are used for those
      axes.
      o  BSCALE and BZERO in a FITS extension are ignored.
      o  BLANK is not used to indicate which input array values
      should be assigned to a standard bad value.
      o  END indicates the last header record unless it
      terminates a dummy header, and the actual data is in an
      extension.

   -  Other data item such as HISTORY, data ORIGIN, and axis
   widths are not supported, because the text file has a simple
   structure to enable a diverse set of input files to be
   converted to NDFs, and to limitations of the standard FITS
   header.
2 Related_Applications
   CONVERT: NDF2ASCII; KAPPA: TRANDAT; FIGARO: ASCIN and ASCOUT.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1992 September 18 (MJC):
    Original version.

 1993 July 29 (MJC):
    Used lowercase examples and filenames with UNIX in mind.

 1996 September 16 (MJC):
    Corrected usage of CTYPEn (was CRTYPEn) and introduced CUNITn
    for axis units.

 1997 December 2 (MJC):
    Added MAXLEN parameter to permit long input records without
    impacting the efficiency of processing short records.
1 AST2NDF
Converts an Asterix data cube into a simple NDF.

Usage:

   ast2ndf in out

Description:

   This application converts an Asterix data cube into a standard
   NDF.  See Section 'Notes' (below) for details of the conversion.
2 Parameters
For information on individual parameters, select from the list below:
3 IN
IN  =  NDF (Read)
   The name of the input Asterix data cube.  The file extension
   ('.sdf') should not be included since it is appended automatically
   by the application.
3 OUT
OUT  =  NDF (Write)
   The name of the output NDF containing the data cube written
   by the application.  The file extension ('.sdf') should not be
   included since it is appended automatically by the application.
2 Examples
ast2ndf  ast_cube  ndf_cube
   This example generates data cube NDF ndf_cube (in file
   ndf_cube.sdf) from Asterix cube ast_cube (in file ast_cube.sdf).
2 Notes
This application accepts data in the format used by the Asterix
package (see SUN/98).  These data are cubes, with two axes
comprising a regular grid of positions on the sky and the third
corresponding to energy or wavelength.  The data are Starlink HDS
files which are very similar in format to a standard NDF.  The
following points apply.

- The Asterix QUALITY array is non-standard.  There is no QUALITY
  component in the output NDF.  Instead 'bad' or 'null' values
  are used to indicate missing or suspect values.

- The VARIANCE component is copied if it is present.

- The non-standard Asterix axis components are replaced with
  standard ones.

- The order of the axes is rearranged.
2 References
   D.J. Allan and R.J. Vallance, 1995, in SUN/98: 'ASTERIX -- X-ray
     Data Processing System', Starlink.
2 Related_Applications
   KAPPA:AXCONV
2 Authors
ACD: A C Davenhall (Edinburgh)
2 History
 13/7/97 (ACD): Original version.

 8/1/98  (ACD): First stable version.
1 Changes_to_CONVERT

2 V0.4

The original purpose of this release was to fix bugs, however, it
was convenient to include some new applications for handling ordinary
files. There are five new commands.

3 Global_changes

  o  The documentation has largely been rewritten.  Application
     descriptions are expanded, and standardised; they include
     examples and usage.

  o  Online help is provided.

  o  From DCL, CONVERT commands must be enabled by entering 
     CONVERTSTART.

  o  Compiled interface files are provided for efficiency.

  o  The parameter names are consistent.  IN is used for the input
     file, OUT for the output file, and the data type is TYPE.
     In the previous version there was a mismatch between the
     application, which used parameter FORMAT, and the documentation.

  o  The global parameter GLOBAL.DATA_ARRAY (current NDF) is used to
     suggest a default for the name of an input NDF, and it is
     updated when an output NDF is created.

  o  NDF sections may be used when converting from an NDF.

  o  Many bugs have been fixed, particularly in the area of FITS
     headers, and descriptors.

  o  Corrected the error reporting to adhere to Starlink standards.


3 New_applications

There are five new applications.

   ASCII2NDF converts an ASCII file to an NDF. 
   NDF2ASCII converts an NDF to an ASCII file. 
   NDF2IRAF converts an NDF to an IRAF (OIF) image. 
   NDF2UNF converts an NDF to a sequential unformatted file. 
   UNF2NDF converts a sequential unformatted file to an NDF.

3 Extended_and_corrected_applications
  
Here is a summary of the main modifications.

  o BDF2NDF and NDF2BDF can handle La Palma ING-style FITS headers.
    They process NDF units, and axis labels.

  o BDF2NDF and NDF2BDF parameter TYPE has a dynamic default
    equivalent to the data type of the input BDF or NDF, rather than
    being defaulted to R or _REAL respectively.

  o The NDF axis structure will now always be valid when made by
    BDF2NDF.  Missing axis centres are filled with pixel co-ordinates.

  o NDF2BDF prevents special keywords from being copied from the FITS
    header when there are overriding objects present in the
    NDF; these objects are formatted into FITS-like descriptors.

  o BDF2NDF and DST2NDF will now generate card images in the FITS
    extension that conform to the FITS standard.  Long strings
    (>18 characters) are only truncated at the end of the card.
    NDF2DST correctly processes character-valued card-images in the
    FITS extension; it searches for the comment delimiter rather
    than assuming where the comment is located.  NDF2DST does not
    propagate FITS header cards with blank keywords.

  o DST2NDF and NDF2DST will process axis arrays with greater than
    one dimension.  They are situated in the axis Figaro extension.
    Both applications can process axis variance.

  o In DST2NDF certain objects in the DST are relocated in the NDF
    to be where the Figaro DSA_ library expects them.  NDF2DST moves
    them from their new locations.  The objects are .OBS.SECZ,
    .OBS.TIME, .Z.MAGFLAG, .Z.RANGE and they now reside in the
    top-level Figaro extension of an NDF.

  o DST2NDF preserves the type of the OBS structure within the NDF.
    It can process up to 7 dimensions.  Axis width is processed as
    a numeric array, rather than a character scalar.

  o The DST2NDF no longer creates a phantom two-dimensional FITS
    structure when there is an empty FITS structure within the DST
    file.

  o The bad-pixel processing has changed in DST2NDF.  Quality is
    only copied if the bad-pixel flag is false or absent.  In this
    case a simple NDF is made with its bad-pixel flag likewise set
    to false.

  o NDF2DST preserves the type of extensions in the FIGARO.MORE
    structure.  It writes the FLAGGED value to the DST file, as
    Figaro (DSA_) makes the opposite assumption, compared with
    the NDF, about the presence of bad pixels when the bad-pixel
    flag is absent.

  o NDF2DST propagates axis-variance and width arrays, and the
    contents of any axis Figaro extension.  If there is only one
    object in the Figaro extension, it is now copied to the DST.


2 V0.5

This the first release where CONVERT is available on UNIX platforms.
There are four new commands.

3 Global_changes

  o  CONVERT is available on UNIX platforms SUN/SunOS, SUN/Solaris,
     DEC/Ultrix, Alpha/OSF1 with the following exceptions:

     - BDF2NDF and NDF2BDF are not available because the Interim
       library is not being ported.

     - DIPSO2NDF and NDF2DIPSO are not required because UNIX DIPSO
       processes NDFs.

     - IRAF2NDF and NDF2IRAF are currently not available under OSF/1
       and Solaris, because at the time of development there were no
       IRAF IMFORT libraries available for these platforms.  However,
       the SunOS versions are provided for use in the compatibility
       mode of Solaris 2.3.

  o  CONHELP runs an application on UNIX platforms and accesses a
     portable-help library.

  o  The documentation is revised to reflect the lowercase usage and
     examples under UNIX.

  o  Special handling of some pathological datafiles have been made,
     mostly in BDF2NDF.


3 New_applications

There are four new applications.

   GASP2NDF converts an image in GASP format to an NDF.
   IRAF2NDF converts an IRAF image to an NDF.
   IRCAM2NDF converts an IRCAM data file to a series of NDFs.
   NDF2GASP converts a two-dimensional NDF into a GASP image.

3 Extended_and_corrected_applications
  
Here is a summary of the main modifications.

  o  BDF2NDF now ignores deleted descriptors rather than propagating
     them to the NDF's FITS extension.

  o  DST2NDF has a FORM parameter to select the NDF storage form of
     the output NDF.  It defaults to the simple form.  Previously,
     the quality and bad-pixel values decided.

  o  DST2NDF permits the output NDF to be placed inside an arbitrary
     HDS structure, rather than just being the sole top-level
     structure in the HDS container file.

  o  DST2NDF has had a number of bug fixes applied.  In V0.4 it was
     possible for an axis data array to have the wrong number of
     elements in certain circumstances; the FLAGGED value could have
     been set incorrectly when the FITS structure preceded the .Z
     structure within the DST file.

  o  DST2NDF and NDF2DST now handle quotes in FITS character values.

  o  NDF2ASCII and NDF2UNF ensure that a SIMPLE card appears first in
     the FITS header.

  o  NDF2BDF has better handling of rotated axes.  These are restored
     from the FITS extension, by overwriting the descriptors derived
     from the NDF AXIS.  (An NDF AXIS does not support rotated axes,
     so BDF2NDF makes a default axis with pixel co-ordinates.  A
     subsequent invocation of the old NDF2BDF would lose the original
     axis information from the destination NDF.  This change prevents
     that hysteresis.)

  o  NDF2BDF has had a number of bug fixes applied.  It is now not
     possible to generate erroneous CRTYPEn and CTYPEn values, when
     the NDF AXIS does not contain LABEL or UNITS.  The application
     reprompts if an invalid Interim type is given.  Lowercase types
     may now be entered.  An NDF with a FITS extension containing
     only the mandatory BDF descriptors (NAXIS,NAXISn) will now
     produce a valid IMAGE BDF, i.e. NAXIS, NAXISn derived from the
     NDF's shape are no longer missing from the BDF descriptors.

  o  NDF2DST has improved handling of FITS headers, particularly
     character strings.  Duplicated keywords are ignored.  HISTORY
     and COMMENT cards are processed correctly.

  o  NDF2IRAF can now convert one- and three-dimensional NDFs.

  o  NDF2IRAF has a FILLBAD parameter to allow NDF bad values to
     be replaced.  FILLBAD defaults to null, meaning do not perform
     bad-value substitution.

  o  NDF2IRAF can produce a signed-word IRAF image.  The output data
     type depends on the data type of the NDF's data array.

2 V0.6

3 New_applications
There are six new applications.
  o  NDF2FITS -- Converts an NDF to FITS format.

                 Conversion from FITS to NDF format can be done with
                 the FITS readers in the KAPPA package.

  o  GIF2NDF and NDF2GIF -- Convert between GIF files and NDFs.

  o  TIFF2NDF and NDF2TIFF -- Convert between TIF files and NDFs.

  o  NDF2PGM  -- Converts an NDF into a PBMPLUS PGM file.

In addition, SUN/55 now describes how to convert NDFs to IDL format.

3 Withdrawn_Applications

  BDF2NDF, NDF2BDF, DIPSO2NDF, and NDF2DIPSO.  See topic 
  "VMS_differences".

3 Changed_Applications
  o  IRAF2NDF and NDF2IRAF utilities are now available for alpha
     OSF/1 and sun4 Solaris platforms.  The libraries necessary to
     build them for sunOS and Ultrix are no longer distributed. 
     The availability on different systems is now documented.

  o  ASCII2NDF, NDF2ASCII, NDF2UNF, and UNF2NDF have no upper-limit
     restriction on parameter NOPEREC.

  o  Fixed bugs in DST2NDF.  A Figaro n-dimensional array of axis
     centres is now placed into AXIS.MORE.FIGARO.DATA_ARRAY.
     The component name was previously called DATA.  DST2NDF now
     allows the axis width to be a scalar in the DST file, expanding
     it to a vector in the NDF.  Missing axes in the DST are always
     created in the NDF; formerly this step would be omitted if
     there were no FITS extension to write.

  o  Fixed bugs in NDF2DST.  An n-dimensional axis now uses the
     component name DATA rather than DATA_ARRAY for the pixel
     centres.  If AXIS().MORE.FIGARO.DATA_ARRAY is primitive, its
     DATA component becomes the new n-dimensional axis array in the
     Figaro file.  It was previously renamed from DATA_ARRAY to DATA.
     NDF2DST now also checks whether or not AXIS().MORE.FIGARO.WIDTH
     is primitive, and if it is, its DATA component becomes the new
     n-dimnensional axis-width array in the Figaro file.

3 Global_changes
  o  NDF Support -- CONVERT startup will now define sensible default
           values for the environment variables associated with the
           format-conversion facilities of the NDF library, so that
           NDF library calls may do `on the fly' conversion of
           `foreign' formats using the CONVERT utilities.

  o  Documentation -- SUN/55 now describes the use of CONVERT on UNIX
           platforms.  There is some residual reference to VMS,
           particularly in application specifications, and an appendix
           which points the reader at further information on the
           VMS release.

           A hypertext version of this document is available.

  o  Platform Support -- CONVERT is no longer supported on sunOS or
           Ultrix.  The VMS release is frozen at version 0.5.


2 V1.0

3 New_applications

  o  DA2NDF -- This converts an unformatted stream file to
     an NDF.  Such files will originate from C or Pascal unformatted
     output (data streams), or from Fortran unformatted direct-access.

  o  FITS2NDF -- This is a much improved reader compared with
     KAPPA's FITSDIN.  It has support for binary table and image
     extensions in the FITS file.  It recognises many special data
     products too.  FITS2NDF can regenerate most NDFs from
     files made by its sister application, NDF2FITS.

  o  NDF2DA -- This provides the inverse operation to DA2NDF.
     It permits you to process such files wuth standard packages
     through the automatic-conversion system.

3 Global_changes

  o  Automatic Conversion -- There are two new formats defined that
     operate within the NDF automatic format-conversion system.
     GZIP is similar to COMPRESSED, as it operates on gzip-compressed
     NDFs with extension .sdf.gz.  STREAM operates on Fortran
     unformatted direct-access files or C unformatted data whose file
     extension is .das.  FITS2NDF is used for the forward conversion
     of FITS data instead of KAPPA's FITSDIN.  There are several
     file-extension synonyms, mostly for FITS, and .str for STREAM
     data.  The priority order in environment variables
     NDF_FORMATS_IN and NDF_FORMATS_OUT has changed, with GASP
     appearing later, and STREAM taking GASP's place.

  o  Documentation -- The documentation has been updated to match this
     version of the software.  Additional hyperlinks are introduced,
     including ones for the related applications.  There are
     additional notes in SUN/55 Appendix C.1 on how to process BDF
     files on STADAT.  The messages in the startup scripts mention
     how to obtain the hypertext documentation.  Several application
     modules missing from the online help are now present.

  o  FITS keywords -- In several places, the CRTYPEn and CTYPEn
     keywords were confused.  Likewise, a BUNITS keywords was
     erroneously recognised instead of BUNIT.  The standard header
     names are now used.  A new CUNITn keyword is added to store axis
     units.  Some tasks omitted to write CRPIXn for linear axis centres
     when the reference position was at the centre of the first
     element.  The origin information is exported through LBOUNDn
     keywords.

  o  Linearity of axes -- The improved and more-robust KAPPA
     subroutine is now used to test whether or not the elements of
     axis-centre arrays are equally spaced.

3 Changed_Applications

  o  ASCII2NDF -- Made far more efficient, mostly due to a change in
     the CHR library, but also because the maximum record length is
     now reduced to 512 bytes.  The default RECLEN is 132.

  o  DST2NDF -- Allows for non-standard .FITS structures.

  o  GIF2NDF -- Removed the KAPPA dependency.  It uses one less
     conversion stage, so is more efficient.  The documentation has
     been improved .

  o  IRAF2NDF --  This has undergone a major upgrade with support for
     axis propagation from eleven variants, control of the
     creation of NDF HISTORY records and FITS extension from the
     headers in the file.  The pixel origin is transferred from
     LBOUNDn headers.  The NDF label and units are created from
     OBJECT and BUNIT headers.  The documentation has been
     corrected and improved.

  o  NDF2ASCII --  Reduced the maximum record length to 512 bytes.
     The default RECLEN is 132.

  o  NDF2DST --  Moves imaginary component of a complex array to
     .Z.IMAGINARY.  There is a simplified error message when the
     FITS file already exists.

     There was a bug, now fixed, which could result in .OBS and .Z
     structures of the FIGARO extension being lost.  This occurred
     when FIGARO extension components SECZ or TIME (for OBS), and
     MAGFLAG or RANGE (for Z) were present and were physically
     stored following their respective structure.

  o  NDF2FITS -- BITPIX=-1 is allowed to enable the original FITS
     data type to be restored during automatic conversion.  NDF2FITS
     use a better algorithm to decide the required precision of
     floating-point header values.

     Sensible defaults are used for the scale and offset when
     converting a constant floating-point array to an integer array
     in the FITS file.

     Extensions within 2dF NDFs are recognised, and appropriate
     binary tables are created in the FITS file.

  o  NDF2GIF -- It is now available for alpha_OSF1.

  o  NDF2IRAF --  This has undergone a major upgrade with support for
     axis propagation including a multispec format for non-linear
     axis centres.  There is control of the export of NDF HISTORY
     records and FITS extension information to the headers in the
     IRAF file.  Header duplication is prevented.  The documentation
     has been corrected and improved.  Parameter FILLBAD defaults to
     0.  IRAF filenames are no longer converted to lowercase.
     The pixel origin is transferred from LBOUNDn headers.  The NDF
     label and units are progagated to OBJECT and BUNIT headers. 

  o  TIFF2NDF --  Removed KAPPA dependency.  It uses one less
     conversion stage, so is more efficient.  It is now available for
     alpha_OSF1.  Improved the documentation.
2 V1.1

3 New_applications
There are two new applications:

  o AST2NDF -- This converts an Asterix data-cube to a standard NDF.

  o SPECX2NDF -- This converts a SPECX map to a standard NDF.

3 Changed_applications

  o ASCII2NDF Added MAXLEN parameter to permit long input records 
    without impacting the efficiency of processing short records.

  o FITS2NDF
    - Propagates the NDF WCS component. 
    - Filters out NDF-style history from the FITS airlock.  
    - Fixed bug which prevented the creation of NDF extensions which
      are arrays of structures.  
    - Processes the revised 2dF formats, and allows arbitrary additional 
      extensions; all 2dF extensions can now be an arbitrary order.  
    - Fixed bug which occurred when replacing negative errors in IUE 
      MXLO data. 
    - It now recognises logical binary-table columns.
    - Corrected validating Log file by record length on Solaris.
    - Processes IUE MXHI format.
    - Changed the scheme for naming multiple IUE MXLO NDFs within the 
      output container file; previously the row number was used, but 
      NDF names cannot start with numeric characters and an error was 
      consequently reported. The names LARGE and SMALL are now used.


  o IRAF2NDF
    - Sets the bounds of the NDF according to LBOUNDn keywords, 
      if present.
    - It no longer crashes when closing the IRAF file, if there
      was a problem opening the IRAF file.  
    - Propagates all IRAF history records (including blanks) to the
      FITS airlock when PROFITS=TRUE.  
    - IRAF HISTORY lines which are too long for a FITS header are 
      truncated with an ellipsis.

  o NDF2FITS
    - Creates a WCS component within the output NDFs (if possible), 
      based on FITS-WCS keywords (CRVAL, CRPIX, etc.), DSS keywords 
      (PLTRAH, PLTRAM, etc.), or AST Native keywords (see SUN/210).
    - Modified to propagate the revised 2dF extensions.  Thus the 
      OBJECT extension generates wider binary tables (from 210 to 
      224 bytes).  
    - Now propagates primitive NDF extensions to binary tables.  
    - Does not transfer the LBOUNDn headers in the FITS airlock.
    - Correct handling of null values.
    - Added TDISPn cards for better formatting of tables.
    - Handle ORIGIN as intended.

  o NDF2IRAF Does not transfer the LBOUNDn headers in the FITS
    airlock.
3 IRAF_Versions
  The CONVERT utilities NDF2IRAF and IRAF2NDF are built using copies of
  relevant IRAF libraries (which are included in the CONVERT release) 
  so they exhibit the same behaviour as the IRAF version from which the
  libraries were extracted. There are also some IRAF dependencies in the 
  so-called SPP routines of CONVERT. (These originate written in the 
  IRAF SPP language and include header files defining the layout of the
  IRAF image.) The versions of IRAF2NDF and NDF2IRAF which you use must 
  therefore be compatible with the version of IRAF which you are using.

  A new version of the IRAF image format has been developed for IRAF
  Version 2.11 onwards but at the time of writing this is not available 
  for all platforms.
  IRAF Version 2.11 will read either the old or new image formats but 
  will produce the new format by default. (It can be made to produce
  old-format images by setting environment variable oifversion=1.)
  Appropriate versions of the IRAF libraries and the SPP routines are 
  required for IRAF2NDF and NDF2IRAF to handle the new image format.

  CONVERT Version 1.1 contains IRAF V2.11 compatible versions of the
  SPP routines and the IRAF libraries Version 2.11.1. If you are still
  running IRAF V2.10, set environment variable oifversion=1 before 
  running NDF2IRAF. (This includes when running Starlink programs from 
  IRAF cl if an output image is produced by `on-the-fly' conversion.)

3 Documentation
  HELP and SUN/55 have been updated to include the new applications
  and to reflect the changes in behaviour listed above.

2 V1.1-1
  This fixes some bugs including NDF2FITS handling of UWORD and BYTE format
  to correct scaling and prevent overflows.

  It also outputs warning messages on header record errors and prevents
  overwriting of the final record.

  The automatic NDF conversion system has been altered so that the
  production of 'error' messages, preceded by !, by the conversion program
  will no longer be taken to mean that the conversion has failed.
  
2 V1.1-2
  FITS2NDF and NDF2FITS now allow the FITS-IRAF encoding. 

  NDF2FITS will no longer produce 'native' encoding by default. To this
    end, parameter ENCODINGS has been replaced by parameter NATIVE.

  TIFF2NDF, GIF2NDF and NDF2GIF have been altered to use a common release
  of Netpbm on all platforms, rather than a mixture of PBMPLUS and Netpbm.
  The relevant utilities of Netpbm must appear on your PATH if these
  CONVERT applications are to be used.

  SUN/55 and CONVERT help has been modified to reflect these changes and
  to improve the description of FITS2NDF's handling of Binary tables.
2 V1.1-3
  NDF2FITS  Corrected failure to propagate an extension containing a 
    character array.

  FITS2NDF
    Correct action if FMTCNV is TRUE and there is no BSCALE or BZERO
    in the FITS file.

    The number of characters in the NDF\_CLASS string is increased
    from 8 to 10.
2 V1.2
  New applications to run in IDL:
  READ_NDF An IDL functionn to read an NDF component into an IDL array.

  WRITE_NDF An IDL procedure to write an IDL array to an  NDF component.

  Changed Applications:
  NDF2TIFF Various alternative methods of scaling the NDF data are 
    provided.

  NDF2GIF Various alternative methods of scaling the NDF data are 
    provided (the scaling is performed by NDF2TIFF).

  NDF2FITS Now has an additional parameter, ENCODING, to control the
    way WCS information is encoded within the FITS header.

  Documentation:
  SUN/55 and CONVERT help have been updated to describe the changes.
2 V1.2-4
 All the converters which are ADAM tasks have been combined into a 
 monolith to save disk space.

 The FITS converters now use the CFITSIO library.

 FITS2NDF will now report an error but continue to create the output
 NDF if an error occurs in creating history records.  It will also
 display  warnings if it finds projections which include unsupported
 IRAF extensions.

 A problem causing error
   "!! FTPSCL: Error defining the scale and offset."
 when running NDF2FITS has been corrected.

 Libraries from IRAF release V2.11.3 are used in this release for
 building NDF2IRAF and IRAF2NDF.

 SUN/55 has been updated to include these release notes and a
 copyright statement, and to correct some bugs in the HTML version
 header.
2 V1.3-2
 Two new converters, HDS2IDL and IDL2HDS, are provided for IDL users.
 They handle complete structures, unlike READ_NDF and WRITE_NDF which
 only handle the main arrays of NDFs. 

 NDF2FITS and FITS2NDF have been enhanced by the addition of FITS-AIPS
 and FITS-PC encodings. Also, appropriate messages are output if there
 are no valid input files.

 FITS2NDF has also been enhanced to allow more flexibility over the
 handling of multi-extension FITS files. Syntax such as filename.fit[1]
 or  "filename.fit[extname=im2]" can be used to specify a single FITS
 extension to be converted, and additional parameters EXTABLE and
 CONTAINER allow FITS extensions to be combined to produce a single NDF
 or a series of components of a top-level HDS container file.

 The scripts associated with the NDF on-the-fly conversion system have
 been modified to allow a single extension from a multi-extension FITS
 file to be specified This feature requires applications to have been
 built with NDF V1.5-6 or later.

 Different numbers of axes in the BaseFrames of the NDF and FitsChan FrameSets
 are now allowed when creating the NDF's WCS component.

 NDF2FITS now uses the NDG library to allow conversion of NDFs stored as
 sub-components within an HDS container file (eg scuba data, etc).

 SUN/55 has been updated to describe the new applications 
 and to include the 'IRAF Versions' section. Early release-note sections
 have been removed. On installation, only a link to the installed LaTeX
 document is now retained in the source directory.
2 V1.3-3
 Corrects a problem with NDF2FITS if there is garbage beyond the END header
 record in the NDF's FITS airlock, and stops a second ORIGIN header being
 output (copied from the airlock) if the ORIGIN parameter has been used to
 specify a non-default ORIGIN.
2 V1.3-4

  Corrects a bug in FITS2NDF so that NAXIS > 0 and NAXISn = 0 is equivalent
  to NAXIS = 0.

  Corrects a bug in NDF2PGM which causes the image to be offset by 3 bytes.
2 V1.3-5
 FITS2NDF creates a component of type FITS_HEADER, not NDF, in a container
 file for multi-extension FITS files if the FITS extension does not contain
 a data array.
2 V1.3-6
 FITS2NDF:
  o Improve error reporting if no WCS encoding can be used.

  o Don't handle WCS if NDIM less than or = 0.

  o Correct handling of NDF history records in the FITS header.
2 CONVERT_Version_1.3-7
 NDF2FITS Corrects inappropriate axis symbols being used for CTYPE keywords.
2 CONVERT_Version_1.3-8
 Corrects bugs in ASCII2NDF which caused segmentation violation.
2 CONVERT_Version_1.4
 MTFITS2NDF added - a tcsh script to convert FITS tapes to NDF using FITS2NDF.
2 CONVERT_Version_1.4-1
 Updated the IDL converters to work with IDL 5.5. Fix a problem causing a
 crash on Linux and document the fact that the Starlink IDL converters
 cannot be used with the 64-bit Solaris version of IDL - terminate gracefully
 where possible.

 Corrected an error in the section of this document describing the easy
 way to do IDL/NDF conversions. WRITE_NDF was described as if it were a
 function rather than a procedure.  
 2 CONVERT_Version_1.4-2
 Parameter WCSATTRS is added to FITS2NDF. This enables users to modify 
 the way WCS information is extracted from the FITS headers. This can
 be useful when the headers do not conform to conventions. 
2 CONVERT_Version_1.4-3
 Fixed a problem in NDF2FITS caused by a mismatch of conventions used in the
 TFORMn and TDIMn header cards for multi-dimensional character arrays.
 A corresponding fix was required for FITS2NDF.
2 CONVERT_Version_1.4-4
 Fixed a bug in FITS2NDF caused by a missing END card on a merged header.
2 CONVERT_Version_1.5

 SPECX2NDF has been revamped so that it now uses the new AST SpecFrame
 functionality allowing translation between spectral frames without
 re-running SPECX2NDF.  The SPECTRUM parameter (and associated
 parameters SOR, DOPPLER) are no longer required since they can be
 changed after conversion using the KAPPA:WCSATTRIB application. 
 **Scripts using SPECX2NDF may therefore need modification.**  In
 addition to dealing with map files, SPECX2NDF has now been extended
 to deal with SPECX data files; each spectrum in the file is
 translated to an NDF spectrum in the output HDS container file.

 FITS2NDF converts INES archive IUE spectra.

 Improved propagation of existing world co-ordinate system (WCS)
 headers in NDF2FITS partially from improvements to the AST
 subroutine library.  For example, long-slit spectra with a
 three-dimensional WCS, but stored in a two-dimensional image, retain
 their three-dimensional WCS headers.  Comments are preserved where
 values have not changed significantly.

1 CONVERT
 The CONVERT package contains some of the numerous format-conversion
 routines which are necessary to translate data files to and from the
 Starlink standard n-Dimensional-data format--the NDF---described in
 SUN/33 and SGP/38.  CONVERT commands are available from ICL and UNIX
 shell.

 The commands available are:

     ASCII2NDF -- Converts an ASCII file to an NDF.
     AST2NDF   -- Converts an Asterix data-cube to an NDF.
     DA2NDF    -- Converts a direct-access unformatted file to an NDF.
     DST2NDF   -- Converts a Figaro (Version 2) DST file to an NDF.
     FITS2NDF  -- Converts FITS files into NDFs.
     GASP2NDF  -- Converts an image in GASP format to an NDF.
     GIF2NDF   -- Converts a GIF file to an NDF.
     IRAF2NDF  -- Converts an IRAF image to an NDF.
     IRCAM2NDF -- Converts an IRCAM data file to a series of NDFs.
     NDF2ASCII -- Converts an NDF to an ASCII file.
     NDF2DA    -- Converts an NDF to a direct-access unformatted file.
     NDF2DST   -- Converts an NDF to a Figaro (Version 2) DST file.
     NDF2FITS  -- Converts an NDF to a FITS file.
     NDF2GASP  -- Converts a two-dimensional NDF into a GASP image.
     NDF2GIF   -- Converts a two-dimensional NDF into a GIF file.
     NDF2IRAF  -- Converts an NDF to an IRAF (OIF) image.
     NDF2PGM   -- Converts a two-dimensional NDF into a PGM file.
     NDF2TIFF  -- Converts a two-dimensional NDF into a TIFF file.
     NDF2UNF   -- Converts an NDF to a sequential unformatted file.
     SPECX2NDF -- Converts a SPECX map into a simple data cube, or
                  SPECX data files to individual spectra. 
     TIFF2NDF  -- Converts a TIFF file to an NDF.
     UNF2NDF   -- Converts a sequential unformatted file to an NDF.

 In addition there are four IDL procedures:
     READ_NDF  -- Reads an NDF into an IDL array.
     WRITE_NDF -- Writes an IDL array to an NDF.
     HDS2IDL   -- Creates an IDL structure from an HDS file
     IDL2HDS   -- Creates an HDS file from an IDL structure

 Full details can be found in SUN/55.

 To make all the format-conversion routines available, type

     ICL> convert

 from ICL, or 

     % convert

 from the UNIX shell.  Then type the appropriate command to perform the
 conversion.
1 DA2NDF
Converts a direct-access unformatted file to an NDF.

Usage:

   da2ndf in out [comp] noperec shape [type]

Description:

   This application converts a direct-access (fixed-length records)
   unformatted file to an NDF.  It can therefore also process
   unformatted data files generated by C routines.  Only one of the
   array components may be created from the input file.   The shape
   of the NDF has be to be supplied.
2 Parameters
For information on individual parameters, select from the list below:
3 COMP
COMP = LITERAL (Read)
   The NDF component to be copied.  It may be "Data", "Quality"
   or "Variance".  To create a variance or quality array the NDF
   must already exist. ["Data"]
3 IN
IN = FILENAME (Read)
   Name of the input direct-access unformatted file.
3 NOPEREC
NOPEREC = _INTEGER (Read)
   The number of data values per record of the input file.  It
   must be positive.  The suggested default is the size of the
   first dimension of the array.  A null (!) value for NOPEREC
   causes the size of first dimension to be used.
3 OUT
OUT = NDF (Read and Write)
   Output NDF data structure.  When COMP is not "Data" the NDF
   is modified rather than a new NDF created.  It becomes the new
   current NDF.  Unusually for an output NDF, there is a suggested
   default---the current value---to facilitate the inclusion of
   variance and quality arrays.
3 SHAPE
SHAPE = _INTEGER (Read)
   The shape of the NDF to be created.  For example, [40,30,20]
   would create 40 columns by 30 lines by 10 bands.
3 TYPE
TYPE = LITERAL (Read)
   The data type of the direct-access file and the NDF.  It must
   be one of the following HDS types: "_BYTE", "_WORD", "_REAL",
   "_INTEGER", "_DOUBLE", "_UBYTE", "_UWORD" corresponding to
   signed byte, signed word, real, integer, double precision,
   unsigned byte, and unsigned word respectively.  See SUN/92 for
   further details.  An unambiguous abbreviation may be given.
   TYPE is ignored when COMP = "Quality" since the QUALITY
   component must comprise unsigned bytes (equivalent to TYPE =
   "_UBYTE") to be a valid NDF. The suggested default is the
   current value. ["_REAL"]
2 Examples
da2ndf ngc253.dat ngc253 shape=[100,60] noperec=8
   This copies a data array from the direct-access file ngc253.dat
   to the NDF called ngc253.  The NDF is two-dimensional: 100
   elements in x by 60 in y.  Its data array has type _REAL.  The
   data records each have 8 real values.

da2ndf ngc253q.dat ngc253 q 100 [100,60]
   This copies a quality array from the direct-access file
   ngc253q.dat to an existing NDF called ngc253 (such as created
   in the first example).  The NDF is two-dimensional: 100
   elements in x by 60 in y.  Its data array has type _UBYTE.
   The data records each have 100 unsigned-byte values.

da2ndf type="_uword" in=ngc253.dat out=ngc253 \
   This copies a data array from the direct-access file ngc253.dat
   to the NDF called ngc253.  The NDF has the current shape and
   data type is unsigned word.  The current number of values per
   record is used.
2 Notes
The details of the conversion are as follows:

   -  the direct-access file's array is written to the NDF array
   as selected by COMP.  When the NDF is being modified, the
   shape of the new component must match that of the NDF.  This
   enables more than one array (input file) to be used to form an
   NDF.  Note that the data array must be created first to make a
   valid NDF.  Indeed the application prevents you from doing
   otherwise.

   -  Other data items such as axes are not supported, because of
   the direct-access file's simple structure.
2 Related_Applications
   CONVERT: NDF2DA.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1996 October 19 (MJC):
    Original version.
1 DST2NDF
Converts a Figaro (Version 2) DST file to an NDF.

Usage:

   dst2ndf in out [form]

Description:

   This application converts a Figaro Version-2 DST file to a
   Version-3 file, i.e. to an NDF.  The rules for converting the
   various components of a DST are listed in the notes.  Since
   both are hierarchical formats most files can be be converted with
   little or no information lost.
2 Parameters
For information on individual parameters, select from the list below:
3 FORM
FORM = LITERAL (Read)
   The storage form of the NDF's data and variance arrays.
   FORM = "Simple" gives the simple form, where the array of data
   and variance values is located in an ARRAY structure.  Here it
   can have ancillary data like the origin.  This is the normal
   form for an NDF.  FORM = "Primitive" offers compatibility with
   earlier formats, such as IMAGE.  In the primitive form the
   data and variance arrays are primitive components at the top
   level of the NDF structure, and hence it cannot have
   ancillary information. ["Simple"]
3 IN
IN = Figaro file (Read)
   The file name of the version 2 file.  A file extension must
   not be given after the name, since ".dst" is appended by the
   application.  The file name is limited to 80 characters.
3 OUT
OUT = NDF (Write)
   The file name of the output NDF file.  A file extension must
   not be given after the name, since ".sdf" is appended by the
   application.  Since the NDF_ library is not used, a section
   definition may not be given following the name.  The file
   name is limited to 80 characters.
2 Examples
dst2ndf old new
   This converts the Figaro file old.dst to the NDF called new
   (in file new.sdf).  The NDF has the simple form.

dst2ndf horse horse p
   This converts the Figaro file horse.dst to the NDF called
   horse (in file HORSE.SDF).  The NDF has the primitive form.
2 Notes
The rules for the conversion of the various components are as
follows:
_________________________________________________________________
       Figaro file          NDF

-----------------------------------------------------------------
       .Z.DATA         ->   .DATA_ARRAY.DATA (when FORM =
                            "SIMPLE")
       .Z.DATA         ->   .DATA_ARRAY (when FORM = "PRIMITIVE")
       .Z.ERRORS       ->   .VARIANCE.DATA (after processing when
                            FORM = "SIMPLE")
       .Z.ERRORS       ->   .VARIANCE (after processing when
                            FORM = "PRIMITIVE")
       .Z.QUALITY      ->   .QUALITY.QUALITY (must be BYTE array)
                            (see Bad-pixel handling below).

                       ->   .QUALITY.BADBITS = 255
       .Z.LABEL        ->   .LABEL
       .Z.UNITS        ->   .UNITS
       .Z.IMAGINARY    ->   .DATA_ARRAY.IMAGINARY_DATA
       .Z.MAGFLAG      ->   .MORE.FIGARO.MAGFLAG
       .Z.RANGE        ->   .MORE.FIGARO.RANGE
       .Z.xxxx         ->   .MORE.FIGARO.Z.xxxx

       .X.DATA         ->   .AXIS(1).DATA_ARRAY
       .X.ERRORS       ->   .AXIS(1).VARIANCE  (after processing)
       .X.WIDTH        ->   .AXIS(1).WIDTH
       .X.LABEL        ->   .AXIS(1).LABEL
       .X.UNITS        ->   .AXIS(1).UNITS
       .X.LOG          ->   .AXIS(1).MORE.FIGARO.LOG
       .X.xxxx         ->   .AXIS(1).MORE.FIGARO.xxxx
       (Similarly for .Y .T .U .V or .W structures which are
        renamed to AXIS(2), ..., AXIS(6) in the NDF.)

       .OBS.OBJECT     ->   .TITLE
       .OBS.SECZ       ->   .MORE.FIGARO.SECZ
       .OBS.TIME       ->   .MORE.FIGARO.TIME
       .OBS.xxxx       ->   .MORE.FIGARO.OBS.xxxx

       .FITS.xxxx      ->   .MORE.FITS(n)  (into value part of
                                            the string)
       .COMMENTS.xxxx  ->   .MORE.FITS(n)  (into comment part of
                                            the string)
       .FITS.xxxx.DATA ->   .MORE.FITS(n)  (into value part of
                                            the string)
       .FITS.xxxx.DESCRIPTION -> .MORE.FITS(n) (into comment part
                                            of the string)
       .FITS.xxxx.yyyy ->   .MORE.FITS(n)  (into blank-keyword
                                            comment containing
                                            yyyy=value)

       .MORE.xxxx      ->   .MORE.xxxx

       .TABLE          ->   .MORE.FIGARO.TABLE
       .xxxx           ->   .MORE.FIGARO.xxxx

-  Axis arrays with dimensionality greater than one are not
supported by the NDF.  Therefore, if the application encounters
such an axis array, it processes the array using the following
rules, rather than those given above.

       .X.DATA         ->   .AXIS(1).MORE.FIGARO.DATA_ARRAY
                            (AXIS(1).DATA_ARRAY is filled with
                            pixel co-ordinates)
       .X.ERRORS       ->   .AXIS(1).MORE.FIGARO.VARIANCE (after
                            processing)
       .X.WIDTH        ->   .AXIS(1).MORE.FIGARO.WIDTH

-  In addition to creating a blank-keyword NDF FITS-extension
header for each component of a non-standard DST FITS structure
(.FITS.xxxx.yyyy where yyyy is not DATA or DESCRIPTION), this set
of related headers are bracketed by blank lines and a comment
containing the name of the structure (i.e. xxxx).
2 Bad-pixel_handling
   The QUALITY array is only copied if the bad-pixel flag
   (.Z.FLAGGED) is false or absent.  A simple NDF with the bad-pixel
   flag set to false (meaning that there are no bad-pixels present)
   is created when .Z.FLAGGED is absent or false and FORM = "SIMPLE".
2 Related_Applications
   CONVERT: NDF2DST.
2 Authors
JM: Jo Murray (STARLINK)

MJC: Malcolm J. Currie (STARLINK)
2 History
 29-June-1989 (JM):
    Original version.  See the history of DSA_CONVERT_FORMAT.

 1992 January 31 (MJC):
    Greatly expanded the prologue into a form suitable for
    documentation.  Fixed bugs in the generation of card images
    in the FITS extension, notably the inclusion of quotes around
    character strings.  Made the OBS structure preserve its type,
    namely OBS, within the NDF.

 1992 February 4 (MJC):
    The location of the FITS comment is not hardwired for long
    (>18) character values.  Improved efficiency by removing
    unnecessary code from a second-level loop.  Made the maximum
    number of dimensions 7.  Handled axis width as a numeric
    array, rather than a character scalar.

 1992 August 15 (MJC):
    Fixed bug that caused a phantom 2-d FITS structure to be
    created when there is an empty FITS structure within the DST
    file.

 1992 September 3 (MJC):
    Made provision for the FLAGGED component, also affecting
    whether or not quality is propagated.  Creates simple NDF where
    required.  Fixed another occurrence of a logical being used for
    a data type 'STRUCT'.

 1992 September 8 (MJC):
    Improved the documentation and added the rules for
    non-1-dimensional axis arrays.   Handles axis variance in
    addition to axis errors.

 1992 September 10 (MJC):
    Moved special cases of .OBS.SECZ, .OBS.TIME, .Z.MAGFLAG,
    .Z.RANGE to the top-level Figaro extension as this is where
    DSA_ now expects to find them in an NDF.

 1992 September 28 (MJC):
    Obtained NDF by SUBPAR calls, not PAR so that the global value
    is not written in quotes, and thus may be accepted by other
    applications.  Corrected the closedown sequence of DTA-error
    reporting.  Added message tokens for the filenames to clarify
    some error reports.

 1992 October 13 (MJC):
    Fixed a bug where given a DST that has a non-empty FITS
    structure, and an axis array that is missing from the first or
    second axis, the corresponding NDF axis-centre array is given
    a dimension equal to the number of FITS headers.

 1993 October 25 (MJC):
    Added FORM parameter to control the NDF's storage form rather
    than use the value of the bad-pixel flag to decide.

 1993 November 10 (MJC):
    Allowed the output NDF to be written to an arbitrary structure.
    Used NDF_ library to access the NDF to enable NDF automatic
    conversion to work.

 1995 December 19 (MJC):
    Places an n-dimensional axis into AXIS.MORE.FIGARO.DATA_ARRAY.
    Previously, the component name was DATA.

 1996 February 10 (MJC):
    Allowed for scalar width in DST.  Fixed bug which prevented a
    missing axis being created whenever there was no FITS extension
    to write.

 1996 September 21 (MJC):
    ING-style hierarchical keywords may be written when the DST's
    FITS structure contains non-standard structures.
2 Implementation_Status
   -  The maximum number of dimensions is 6.
1 FITS2NDF
Converts FITS files into NDFs.

Usage:

   fits2ndf in out

Description:

   This application converts one or more files in the FITS format
   into NDFs.  It can process an arbitrary FITS file to produce an
   NDF, using NDF extensions to store information conveyed in table
   and image components of the FITS file.  While no information is
   lost, in many common cases this would prove inconvenient
   especially as no meaning is attached to the NDF extension
   components.  Therefore, FITS2NDF recognises certain data products
   (currently IUE Final Archive, ISO, and 2dF), and provides
   tailored conversions that map the FITS data better on to the NDF
   components.  For instance, a FITS IMAGE extension storing data
   errors will have its data array transferred to the NDF's VARIANCE
   (after being squared).  In addition, FITS2NDF can restore NDFs
   converted to FITS by the sister task NDF2FITS.

   A more general facility is also provided to associate specified
   FITS extensions with NDF components by means of entries in a text
   file (see the EXTABLE parameter).

   Details of the supported special formats and rules for processing
   them are given in topic "Special Formats"; the general-case
   processing rules are described in the "Notes".

   Both NDF and FITS use the term extension, and they mean different
   things. Thus to avoid confusion in the descriptions below, the term
   `sub-file' is used to refer to a FITS IMAGE, TABLE or BINTABLE
   Header and Data Unit (HDU).
2 Parameters
For information on individual parameters, select from the list below:
3 CONTAINER
CONTAINER = _LOGICAL (Read)
   If TRUE causes each HDU from the FITS file to be written as
   a component of the HDS container file specified by the OUT
   parameter.  Each component will be named HDU_n, where n is the
   FITS HDU number.  The primary HDU is numbered 0.  Primary and
   IMAGE HDUs will become NDFs and if the PROFITS parameter is
   TRUE, each NDF's FITS extension will be created from the
   header of the FITS sub-file.  It will have the form of a
   primary header and may include cards inherited from the
   primary header.  If the FITS HDU has no data array, an NDF
   will not be created---if PROFITS is TRUE, a structure of type
   FITS_HEADER, containing the FITS header as an array of type
   _CHAR*80, is created; if PROFITS is FALSE, no component is
   created.  Binary and ASCII tables become components of type
   'TABLE', formatted as in the general rules under "Notes" below.
   [FALSE]
3 ENCODINGS
ENCODINGS = LITERAL (Read)
   Determines which FITS keywords should be used to define the
   world co-ordinate systems to be stored in the NDF's WCS
   component.  The allowed values (case-insensitive) are:

   "FITS-IRAF" --- This uses keywords CRVALi CRPIXi, CDi_j, and is
      the system commonly used by IRAF. It is described in the
      document "World Coordinate Systems Representations Within
      the FITS Format"  by R.J. Hanisch and D.G. Wells, 1988,
      available by ftp from fits.cv.nrao.edu
      /fits/documents/wcs/wcs88.ps.Z.

   "FITS-WCS" --- This is the proposed FITS standard WCS encoding
      scheme described in the paper "Representation of celestial
      co-ordinates in FITS"
      (http://www.cv.nrao.edu/fits/documents/wcs/wcs.html).  It
      is very similar to \texttt{"FITS-IRAF"} but supports a wider range of
      projections and co-ordinate systems.  Once the standard has
      been agreed, this encoding should be understood by any
      FITS-WCS  compliant software and it is likely to be adopted
      widely for FITS data in future.

   "FITS-PC" --- This uses keywords CRVALi, CDELTi, CRPIXi,
      PCiiijjj,  etc, as described in a previous (now superseded)
      draft of the above FITS world co-ordinate system paper by
      E.W.Greisen and  M.Calabretta.

   "FITS-AIPS" --- This uses conventions described in the document
      "Non-linear Coordinate Systems in AIPS" by Eric W. Greisen
      (revised 9th September, 1994), available by ftp from
      fits.cv.nrao.edu /fits/documents/wcs/aips27.ps.Z.  It is
      currently employed by the AIPS data-analysis facility
      (amongst others), so its use will facilitate data exchange
      with AIPS.  This encoding uses CROTAi and CDELTi keywords to
      describe axis rotation and scaling.

   "DSS" --- This is the system used by the Digital Sky Survey,
      and uses keywords AMDXn, AMDYn, PLTRAH, etc.

   "NATIVE" --- This is the native system used by the AST library
      (see SUN/210) and provides a loss-free method for
      transferring WCS information between AST-based applications.
      It allows more complicated WCS information to be stored and
      retrieved than any of the other encodings.

   A comma-separated list of up to six values may be supplied,
   in which case the value actually used is the first in the
   list for which corresponding keywords can be found in the FITS
   header.

   A FITS header may contain keywords from more than one of these
   encodings, in which case it is possible for the encodings to
   be inconsistent with each other.  This may happen for instance
   if an application modifies the keyword associated with one
   encoding but fails to make equivalent modifications to the
   others.

   If a null parameter value (!) is supplied for
   ENCODINGS, then an attempt is made to determine the most
   reliable encoding to use as follows.  If both native and
   non-native encodings are available, then the first non-native
   encoding to be found which is inconsistent with the native
   encoding is used.  If all encodings are consistent, then the
   native encoding is used (if present). [!]
3 EXTABLE
EXTABLE = FILE (Read)
   This specifies the name of a text file containing a table
   associating sub-files from a multi-extension FITS file with
   specific NDF components.  If the null value (!) is given for
   EXTABLE, FITS sub-files are treated as determined by the
   PROEXTS parameter (see below).

   An EXTABLE file contains records which may be:

   'component specifier records', which associate FITS sub-files
     with NDF components;
   'NDFNAMES records', which specify the names of the NDFs to be
     created. Normally they will be created within the top-level
     HDS container file specified by the OUT parameter;
   'directive records', which inform the table file parser.

   Spaces are allowed between elements within records and blank
   records are ignored.

   Component specifier records have the form:

     component; sub-file_specifiers; transformation_code

     Where:
      'component' (case-insensitive) specifies the NDF component
         and is DATA, VARIANCE, QUALITY or EXTNi.name.  The
         EXTNi.name form specifies the name 'name' of an NDF
         extension to be created.  'name' may be omitted in which
         case 'FITS_EXT_n' is assumed,  where n is the FITS
         sub-file number. 'i' compries any characters and may be
         omitted; it serves to differentiate component specifiers
         where the default name is to be used.
      'sub-file_specifiers' is a list of FITS sub-file specifiers,
         separated by commas. The nth sub-file specifier from each
         component specifier record forms an 'sub-file  set' and
         each sub-file set will be used to create one NDF in the
         output file.

         Each sub-file specifier may be:
         1. An integer specifying the FITS Header and Data Unit
            (HDU) number.  The primary HDU number is 0.
         2. keyword=value (case-insensitive), specifying a FITS
            HDU where the specified keyword has the specified
            value, e.g. EXTNAME=IM2.  The 'keyword=' may be
            omitted, in which case EXTNAME is assumed.
            Multiple keyword=value pairs separated by commas and
            enclosed in [] may be given as a single sub-file
            specifier.  All the given keywords must match the
            sub-file header values.
         3. Omitted to indicate that the component is not required
            for the corresponding NDF.  (Commas may be needed to
            maintain correct sub-file set alignment for later
            sub-file specifiers.)  If the last character of
            'sub-file_specifiers' is comma, it indicates an
            omitted specifier at the end.  Note that if a sub-file
            is not specified for the DATA component of an NDF, an
            error will be reported at closedown.
      'transformation_code' (case-insensitive) is a character
         string specifying a  transformation to be applied to the
         FITS data before it is written into the NDF component.
         The code and preceding ";" may be omitted in which case
         "NONE" (no transformation) is assumed.  Currently the
         only permitted code is "NONE".
     There may be more than one component specifier record for a
     given component, the sub-file specifiers will be
     concatenated.  A sub-file specifier may not span records and
     only the transformation code specified by the last record
     for the component will be effective.

   An NDFNAMES record has the format:
     NDFNAMES name_list
      Where name_list is a list of names for the NDFs to be
      created, one for each sub-file set specified by the
      component specifier lines.  The names are separated by
      commas.  If any of the names are omitted, the last name
      specified is assumed to be a root name to which an integer
      counter is to be added until a new name is found.  If no
      names are specified, 'EXTN_SET' is used as the root name.
      For example, NDFNAMES NDF,,SET_ would result in NDFs named
      NDF1, NDF2, SET_1, SET_2 etc. up to the given number of
      sub-file sets.

      There may be multiple NDFNAMES records, the names will be
      concatenated.  A name may not span records and a comma as
      the last non-blank character indicates an omitted name.

      If there is only one sub-file set, the name_list may be '*',
      in which case the NDF will be created at the top level of
      the output file.

   Directive records have # in column 1 and will generally be
      treated as comments and ignored.  An exception is a record
      starting with '#END', which may optionally be used to
      terminate the file.

   Each HDU of the FITS file is processed in turn.  If it matches
   on of the sub-file specifiers in the table, it is used to
   create the  specified component of the appropriate NDF in the
   output file; otherwise the next HDU is processed.  The table is
   searched in sub-file set order.  If a table entry is matched it
   is removed from the table; this means that the same FITS
   sub-file specifier may be repeated for another NDF component
   but each FITS HDU can only be used once.  If sub-file
   specifiers remain unmatched at the end, a warning message is
   displayed.

   A simple example of an EXTABLE is:

     # A simple example
     DATA;0,1,2,3,4,5,6
     #END

   The primary HDU and sub-files 1--6 of the FITS file will be
   written as the DATA components of NDFs EXTN_SET1--EXTN_SET7
   within the HDS container file specified by the OUT parameter.

   A contrived example,showing more of the facilities, is:

     # A contrived example
     NDFNAMES obs_
     DATA; 1, EXTNAME=IM4, IM7; none
     VARIANCE; 2,im5, im8
     EXTN.CAL;3 ,,[extname=cal_3,extver=2]
     #END

   The HDS container file specified by the OUT parameter will
   contain three NDFs, the NDFNAMES record specifies that they
   will be named OBS_1, OBS_2 and OBS_3.

   NDF OBS_1 will have its DATA component created from the first
   extension  (HDU 1) of the FITS file specified by the IN
   parameter, and its VARIANCE from the second.  NDF OBS_1 will
   have an extension named CAL created from the third FITS
   extension.

   NDF OBS_2 has DATA and VARIANCE components created from the
   FITS sub-files whose EXTNAME keywords have the value IM4 and
   IM5 respectively; no CAL extension is created in OBS_2.

   OBS_3 DATA and VARIANCE are created from FITS sub-files named
   IM7 and IM8 and the CAL extension from the FITS sub-file whose
   EXTNAME and EXTVER keywords have values "CAL" and "2"
   respectively.

   In all cases, if the PROFITS parameter is TRUE, the NDF's FITS
   extension will be created from the header of the sub-file
   associated with the DATA component of the NDF.  It will have
   the form of a primary header and may include cards inherited
   from the primary header [!]
3 FMTCNV
FMTCNV = LITERAL (Read)
   This specifies whether or not format conversion will occur.
   The conversion applies the values of the FITS keywords BSCALE
   and BZERO to the FITS data to generate the "true" data values.
   This applies to IMAGE extensions, as well as the primary data
   array.  If BSCALE and BZERO are not given in the FITS header,
   they are taken to be 1.0 and 0.0 respectively.

   If FMTCNV=FALSE, the HDS type of the data array in the NDF
   will be the equivalent of the FITS data format on tape (e.g.
   BITPIX = 16 creates a _WORD array).  If TRUE, the data array
   in the NDF will be converted from the FITS data type on tape
   to _REAL or _DOUBLE in the NDF.  The choice of floating-point
   data type depends on the number of significant digits in the
   BSCALE and BZERO keywords.

   FMTCNV must be enclosed in double quotes and may be a list of
   comma-separated values to be applied to each conversion in
   turn.  An error results if more values than the number of
   input FITS files are supplied.  If too few are given, the last
   value in the list applied to all the conversions; thus a
   single value is applied to all the input files.  If more than
   one line is required to enter the information at a prompt then
   place a "-" at the end of each line where a continuation line
   is desired.  ["TRUE"]
3 IN
IN = LITERAL (Read)
   The names of the FITS-format files to be converted to NDFs.
   It may be a list of file names or indirection specifications
   separated by commas and enclosed in double quotes.  FITS file
   names may include the regular expressions ("*", "?", "[a-z]"
   etc.) but a "[]" construct at the end of the name is assumed to
   be a sub-file specifier to specify a particular FITS sub-file
   to be converted.  (See the description of an EXTABLE file
   above for allowed sub-file specifiers, but note that only a
   single keyword=value pair is allowed here.  Note also that if a
   specifier contains a keyword=value pair, the name(s) must be
   enclosed in double quotes.)  If you really want to have an
   [a-z]-type regular expression at the end of the filename, you
   can put a null sub-file specifier "[]" after it.

   Indirection may occur through text files (nested up to seven
   deep).  The indirection character is "^".  If extra prompt
   lines are required, append the continuation character "-" to
   the end of the line.  Comments in the indirection file begin
   with the character "#".
3 OUT
OUT = LITERAL (Write)
   The names for the output NDFs.  These may be enclosed in
   double quotes and specified as a list of comma-separated names,
   OR, using modification elements to specify output NDF names
   based on the input filenames.  Indirection may be used if
   required.

   The simplest modification element is the asterisk "*", which
   means call the output NDF files the same name (without any
   directory specification) as the corresponding input FITS file,
   but with file extension ".sdf".

   Other types of modification can also occur so OUT = "x*" would
   mean that the output files would have the same name as the
   input FITS files except for an "x" prefix.  You can also
   replace a specified string in the output filename, for example
   OUT="x*|cal|Starlink|" replaces the string "cal" with
   "Starlink" in any of the output names "x*".

   Some of the options create a series of NDFs in the original
   NDF, which becomes just an HDS container and no longer an NDF.
3 PROEXTS
PROEXTS = _LOGICAL (Read)
   This governs how any extensions within the FITS file are
   processed in the general case.  If TRUE, any FITS-file extension
   is propagated to the NDF as an NDF extension called FITS_EXT_n,
   where n is the number of the extension.  If FALSE, any FITS-file
   extensions are ignored.  The "Notes" of the general conversion
   contain details of where and in what form the various FITS-file
   extensions are stored in the NDF.

   This parameter is ignored when the supplied FITS file is one
   of the special formats, including one defined by an EXTABLE but
   excluding NDF2FITS-created files, whose structure in terms of
   multiple FITS objects is defined.  Specialist NDF extensions
   may be created in this case.  See topic "Special Formats" for
   details.

   It is also ignored if a sub-file is specified as the IN
   parameter, or parameter CONTAINER is TRUE.  [TRUE]
3 PROFITS
PROFITS = _LOGICAL (Read)
   If TRUE, the headers of the FITS file are written to the NDF's
   FITS extension.  If a specific FITS sub-file has been specified
   or parameter CONTAINER is TRUE or an EXTABLE is in use, the
   FITS extension will appear as a primary header and may include
   cards inherited from the primary HDU; otherwise the FITS header
   is written verbatim.  [TRUE]
3 WCSATTRS
WCSATTRS = LITERAL (Read)
   A comma-separated list of keyword=value pairs which modify
   the way WCS information is extracted from the FITS headers.
   Each of the keywords should be an attribute of an AST
   FitsChan.  This is the object which is responsible for
   interpreting the FITS WCS headers, and is described full in
   the documentation for the AST library (see SUN/210).  For
   instance, to force CAR projections to be interpreted as simple
   linear mappings from pixel co-ordinates to celestial
   co-ordinates (rather than the non-linear mapping  implied by
   the FITS-WCS conventions), use WCSATTRS="CarLin=1".  A null
   value (!) results in all attributes using default values.  [!]
2 Examples
fits2ndf 256.fit f256 fmtcnv=f
   This converts the FITS file called 256.fit to the NDF called
   f256.  The data type of the NDF's data array matches that of
   the FITS primary data array.  A FITS extension is created in
   f256, and FITS sub-files are propagated to NDF extensions.

fits2ndf 256.fit f256 noprofits noproexts
   As the previous example except there will be a format
   conversion from a FITS integer data type to floating point in
   the NDF using the BSCALE and BZERO keywords, and there will be
   no extensions written within f256.

fits2ndf "*.fit,p*.fits" *
   This converts a set of FITS files given by the list
   "*.fit,p*.fits", where * is the match-any-character wildcard.
   The resultant NDFs take the filenames of the FITS files, so if
   one of the FITS files was parker.fits, the resultant NDF would
   be called parker.  Format conversion is performed on integer
   data types.  A FITS extension is created in each NDF and any
   FITS sub-files present are propagated to NDF extensions.

fits2ndf swp25000.mxlo mxlo25000
   This converts the IUE MXLO FITS file called swp25000.mxlo to
   the NDF called mxlo25000.  Should the dataset comprise both
   the large- and small-aperture spectra, they will be found in
   NDFs mxlo25000.large and mxlo25000.small respectively.

fits2ndf SWP19966.MXHI mxhi19966
   This converts the IUE MXHI FITS file called SWP19966.MXHI to a
   series of NDFs within a file mxhi19966.sdf.  Each NDF
   corresponds to an order.  Thus for instance the one hundredth
   order will be in the NDF called mxhi19966.order100.

fits2ndf data/*.silo silo*|swp|| noprofits
   This converts all the IUE SILO FITS files with file extension
   .silo in directory data to NDFs in the current directory.
   Each name of an NDF is derived from the corresponding FITS
   filename; the original name has the "swp" removed and "silo"
   is prefixed.  So for example, swp25000.silo would become
   an NDF called silo25000.  No FITS extension is created.

fits2ndf "abc.fit,def.fts" "fgh,ijk" fmtcnv="F,T" noproexts
   This converts the FITS files abc.fit and def.fts to the NDFs
   called fgh and ijk respectively.  Format conversion is applied
   to abc.fit but not to def.fts.  FITS extensions are created
   in the NDFs but there are no extensions for any FITS sub-files
   that may be present.

fits2ndf 256.fit f256 fmtcnv=f encodings=DSS
   This is the same as the first example except that it is
   specified that the co-ordinate system information to be stored
   in the WCS component of the NDF must be based on the FITS
   keywords written with Digitised Sky Survey (DSS) images.  If
   these keywords are not present in the FITS header then no WCS
   component will be created.  All the earlier examples retained
   the default null value for the ENCODINGS parameter, resulting
   in the choice of keywords being based on the contents of the
   FITS header (see the description of the ENCODINGS parameter
   for details).

fits2ndf 256.fit f256 fmtcnv=f encodings="DSS,native"
   This is the same as the previous example except that if no
   DSS keywords are available, then the co-ordinate system
   information stored in the NDF's WCS component will be based on
   keywords written by applications which use the AST library (see
   SUN/210).  One such application is NDF2FITS.  This `native'
   encoding provides a `loss-free' means of transferring
   information about co-ordinate systems (i.e. no information is
   lost; this may not be the case with other encodings).  If the
   file 256.fit contains neither DSS nor native AST keywords, then
   no WCS component will be created.

fits2ndf "multifile.fit[extname=im3]" *
   This will create an NDF, multifile, from the first FITS
    extension in file multifile.fit whose EXTNAME keyword has the
    value "im3".

fits2ndf multifile.fit multifile extable=table1
   This will create a series of NDFs in the container file
   multifile.sdf according to the specifications in the
   EXTABLE-format file, table1.
2 Notes
-  Some sources of FITS files that require special conversion
rules, particularly because they use binary tables, are
recognised.  Details of the processing for these is given within
topic "Special Formats".

Two other special cases are when a particular sub-file is
specified by the IN parameter and when conversion is driven by an
EXTABLE file.

The general rules for the conversion apply if the FITS file is not
one of the "Special Formats" (including one defined by an EXTABLE)
and parameter CONTAINER is not TRUE.

The general rules are as follows.

-  The primary data array of the FITS file becomes the NDF's data
array. There is an option using parameter FMTCNV to convert
integer data to floating point using the values of FITS keywords
BSCALE and BZERO.

-  Any integer array elements with value equal to the FITS
keyword BLANK become bad values in the NDF data array.  Likewise
any floating-point data set to an IEEE not-a-number value also
become bad values in the NDF's data array.  The BAD_PIXEL flag is
set appropriately.

-  NDF quality and variance arrays are not created.

-  A verbatim copy of the FITS primary header is placed in the
NDF's FITS extension when parameter PROFITS is TRUE.

-  Here are details of the processing of standard items from the
the FITS header, listed by FITS keyword.
   CRVALn, CDELTn, CRPIXn, CTYPEn, CUNITn --- define the NDF's
     WCS component (see parameter ENCODINGS).
   OBJECT, LABEL, BUNIT --- if present are equated to the NDF's
     title, label, and units components respectively.
   LBOUNDn --- if present, this specifies the pixel origin for
     the nth dimension.

-  Additional sub-files within the FITS files are converted into
extensions within the NDF if parameter PROEXTS is TRUE.  These
extensions are named FITS_EXT_m for the mth sub-file.

-  An IMAGE sub-file is treated like the primary data array, and
follows the rules give above.  However, the resultant NDF is an
extension of the main NDF.

-  A BINTABLE or TABLE sub-file are converted into a structure
of type TABLE ().  This has a NROWS component specifying the
number of rows, and a COLUMNS structure containing a series of
further structures, each of which takes its name from the label
of the corresponding column in the FITS table.  If there is no
label for the nth column, the structure is called COLUMNn.
These COLUMN structures contain a column of table data values in
component DATA, preserving the original data type; and optional
UNITS and COMMENT components which specify the column's units and
the meaning of the column.  Thus for example, for the third
sub-file of NDF called ABC, the data for column called RA would
be located in ABC.MORE.FITS_EXT_3.COLUMNS.RA.DATA.

-  A random-group FITS file creates an NDF for each group.  As
they are related observations the series of NDFs are stored in a
single HDS container file whose name is still given by parameter
OUT.  Each group NDF has component name FITS_Gn, where n is the
group number.

Each group NDF contains the full header in the FITS extension,
appended by the set of group parameters.  The group parameters
are evaluated using their scales and offsets, and made to look
like FITS cards.  The keywords of these FITS cards are derived
from the values of PTYPEm in the main header, where m is the
number of the group parameter.
2 Special_Formats
   o  NDF2FITS

   -  This is recognised by the presence of an HDUCLAS1 keyword set
   to 'NDF'.  The conversion is similar to the general case, except
   the processing of FITS sub-files and HISTORY headers.

   -  An IMAGE sub-file converts to an NDF variance-array component,
   provided the HDUCLAS2 keyword is present and has a value that is
   either 'VARIANCE' or 'ERROR'.

   -  An IMAGE sub-file converts to an NDF quality-array component,
   provided the HDUCLAS2 keyword is present and has value 'QUALITY'.

   -  FITS ASCII and binary tables become NDF extensions, however,
   the original structure path and data type are restored using
   the values of the EXTNAME and EXTTYPE keywords respectively.  An
   extension may be an array of structures, the shape being stored
   in the EXTSHAPE keyword.  The shapes of multi-dimensional arrays
   within the extensions are also restored.

   -  HISTORY cards in a special format created by NDF2FITS are
   converted back into NDF history records.  This will only work
   provided the HISTORY headers have not been tampered.  Such
   headers are not transferred to the FITS airlock, when
   PROFITS=TRUE.

   o  IUE Final Archive LILO, LIHI, SILO, SIHI

   -  This converts an IUE LI or SI product stored as a FITS primary
   data array and IMAGE extension containing the quality into an
   NDF.  Other FITS headers are used to create AXIS structures (SI
   products only), and character components.

   -  Details of the conversion are:

      -  The primary data array of the FITS file becomes NDF main
      data array.  The value of parameter FMTCNV controls whether
      keywords BSCALE and BZERO are applied to scale the data;
      FMTCNV along with the number of significant characters in the
      keywords decide the data type of the array.  It is expected
      that this will be _REAL if FMTCNV is TRUE, and _WORD
      otherwise.

      -  The quality array comes from the IMAGE extension of the
      FITS file.  The twos complement values are divided by -128 to
      obtain the most-significant 8 bits of the 14 in use.  There is
      no check that the dimension and axis-defining FITS headers in
      this extension match those of the main data array.  The
      standard indicates that they will be the same.

      -  The FILENAME header value becomes the NDF's TITLE component.

      -  The BUNIT header value becomes the NDF's UNITS component.

      -  The CDELTn, CRPIXn, and CRVALn define the axis centres.
      CTYPEn defines the axis labels.  Axis information is only
      available for the SILO and SIHI products.

      -  The primary headers may be written to the NDF's FITS
      extension when parameter PROFITS is TRUE.

   o  IUE Final Archive MXLO

   -  This will usually be a single 1-dimensional NDF, however, if
   the binary table contains two rows, a pair of NDFs are stored in
   a single HDS container file whose name is specified by parameter
   OUT.  The name of each NDF is either SMALL or LARGE depending on
   the size of the aperture used.  Thus for OUT=ABC, the
   small-aperture observation will be in an NDF called ABC.SMALL.

   -  Only the most-significant 8 bits of the quality flags are
   transferred to the NDF.

   -  The primary headers may be written to the standard FITS
   airlock extension when PROFITS is TRUE.

   -  The conversion from binary-table columns and headers to NDF
   objects is as follows:

      NPOINTS                Number of elements
      WAVELENGTH             Start wavelength, axis label and units
      DELTAW                 Incremental wavelength
      FLUX                   Data array, label, units, bad-pixel flag
      SIGMA                  Data-error array
      QUALITY                Quality array
      remaining columns      Component in IUE_MX extension (NET and
                             BACKGROUND are NDFs)

   o  IUE Final Archive MXHI

   -  This creates a series of NDFs within a single HDS container
   file whose name is specified by parameter OUT.  Each NDF
   corresponds to a spectral order, and may be accessed individually.
   The name of each NDF is ORDER followed by the spectral-order
   number.  For instance, when OUT=SWP, the 85th-order spectrum will
   be in an NDF called SWP.ORDER85.

   -  Only the most-significant 8 bits of the quality flags are
   transferred to the NDF.

   -  The primary headers may be written to the standard FITS
   airlock extension when PROFITS is TRUE.  To save space, this
   appears once in the NDF specified by parameter OUT.

   -  The conversion from binary-table columns and headers to NDF
   objects is as follows:

      NPOINTS                Number of non-zero elements
      WAVELENGTH             Start wavelength of the non-zero
                             elements, label, and units
      STARTPIX               Lower bound of the non-zero elements
      DELTAW                 Incremental wavelength
      ABS_CAL                Data array, label, and units
      QUALITY                Quality array
      remaining columns      Component in IUE_MH extension (NOISE,
       (except 14-17)        NET, BACKGROUND, and RIPPLE are NDFs
                             each comprising a data array, label,
                             units and wavelength axis)

   -  It may be possible to evaluate an approximate error array for
   the absolutely calibrated data (ABS_CAL), by multiplying the
   NOISE by the ratio ABS_CAL / NET for each element.

   -  The Chebyshev coefficients, limits, and scale factor in
   columns 14 to 17 are omitted as the evaluated background fit is
   propagated in BACKGROUND.

   o  IUE INES reduced spectra

   -  This generates a single 1-dimensional NDF.

   -  Only the most-significant 8 bits of the quality flags are
   transferred to the NDF.

   -  The primary headers may be written to the standard FITS
   airlock extension when PROFITS is TRUE.

   -  The conversion from binary-table columns and headers to NDF
   objects is as follows:

      WAVELENGTH             Start wavelength, axis label and units
      FLUX                   Data array, label, units, bad-pixel flag
      SIGMA                  Data-error array
      QUALITY                Quality array

   o  ISO CAM auto-analysis (CMAP, CMOS)

   -  The CAM auto-analysis FITS products have a binary table using
   the "Green Bank" convention, where rows of the table represent a
   series of observations, and each row is equivalent to a normal
   simple header and data unit.  Thus most of the columns have the
   same names as the standard FITS keywords.

   -  If there is only one observation, a normal NDF is produced; if
   there are more than one, the HDS container file of the supplied
   NDF is used to store a series of NDFs---one for each
   observation---called OBSn, where n is the observation number.
   Each observation comprises three rows in the binary table
   corresponding to the flux, the r.m.s. errors, and the integration
   times.

   -  The conversion from binary-table columns to NDF objects is as
   follows:

      ARRAY                  Data, error, exposure arrays depending
                             on the value of column TYPE
      BLANK                  Data blank (i.e. undefined value)
      BUNIT                  Data units
      BSCALE                 Data scale factor
      BZERO                  Data offset
      CDELTn                 Pixel increment along axis n
      CRPIXn                 Axis n reference pixel
      CRVALn                 Axis n co-ordinate of reference pixel
      CTYPEn                 Label for axis n
      CUNITn                 Units for axis n
      NAXIS                  Number of dimensions
      NAXISn                 Dimension of axis n
      remaining columns      keyword in FITS extension

      Some of these remaining columns overwrite the (global) values
      in the primary headers.  The integration times are stored as
      an NDF within an extension called EXPOSURE.

      The creation of axis information and extensions does not occur
      for the error array, as these are already generated when the
      data-array row in the binary table is processed.

      The BITPIX column is ignored as the data type is determined
      through the use the TFORMn keyword and the value of FMTCNV in
      conjunction with the BSCALE and BZERO columns.

   o  ISO LWS auto-analysis (LWS AN)

   -  The conversion from binary-table columns to NDF objects is as
   follows:

      LSANFLX                Data array, label, and units
      LSANFLXU               Data errors, hence variance
      LSANDET                Quality (bits 1 to 4)
      LSANSDIR               Quality (bit 5)
      LSANRPID               Axis centres, labels, and units
                             (x-y positions---dimensions 1 and 2)
      LSANSCNT               Axis centre, label, and unit (scan
                             count index---dimension 4)
      LSANWAV                Axis centre, label, and unit
                             (wavelength---dimension 3)
      LSANWAVU               Axis errors (wavelength---dimension 3)
      LSANFILL               not copied
      remaining columns      column name in LWSAN extension

   o ISO SWS auto-analysis (SWS AA)

   -  The conversion from binary-table columns to NDF objects is as
   follows:

      SWAAWAVE               Axis centres, label, and units
      SWAAFLUX               Data array, label, and units
      SWAASTDV               Data errors, hence variance
      SWAADETN               Quality
      SWAARPID               not copied
      SWAASPAR               not copied
      remaining columns      column name in SWSAA extension

   o AAO 2dF

   -  The conversion is restricted to a 2dF archive FITS file
   created by task NDF2FITS.  FITS2NDF restores the original NDF.
   It creates the 2dF FIBRES extension and its constituent
   structures, and NDF_CLASS extension.  In addition the variance,
   axes, and HISTORY records are converted.

   -  The HISTORY propagation assumes that the FITS HISTORY headers
   have not been tampered.

   -  Details of the conversion are:

      -  The primary data array becomes the NDF's data array.  Any
      NaN values present become bad values in the NDF.

      -  The keywords CRVALn, CDELTn, CRPIXn, CTYPEn, CUNITn are
      used to create the NDF axis centres, labels, and units.

      -  The OBJECT, LABEL, BUNIT keywords define the NDF's title,
      label, and units components respectively, if they are defined.

      -  HISTORY cards in a special format created by NDF2FITS are
      converted back into NDF history records.

      -  The NDF variance is derived from the data array of an
      IMAGE extension (usually the first), if present, provided the
      IMAGE extension headers have an HDUCLAS2 keyword whose value
      is either 'VARIANCE' or 'ERROR'.

      -  The NDF_CLASS extension within the NDF is filled using the
      a FITS binary-table extension whose EXTNAME keyword's value is
      NDF_CLASS.  Note: no error is reported if this extension does
      not exist within the FITS file.

      -  The FIBRES extension is created from another FITS binary
      table whose EXTNAME keyword's value is FIBRES.  The OBJECT
      substructure's component names, data types, and values are
      taken from the binary-table columns themselves, and the
      components of the FIELD substructure are extracted from
      recognised keywords in the binary-table's header.  Note: no
      error is reported if this extension does not exist within the
      FITS file.

      -  Other IMAGE and BINTABLE extensions are propagated to the
      NDF extension.  It uses the extension name and type found in
      the EXTNAME and EXTTYPE keywords, or names it FITS_EXT_n for
      the nth FITS extension.

      -  A FITS extension in the NDF may be written to store the
      primary data unit's headers when parameter PROFITS is TRUE.
      This FITS airlock will not contain any NDF-style HISTORY
      records.
2 References
   Bailey, J.A. 1997, 2dF Software Report 14, version 0.5.
   NASA Office of Standards and Technology, 1994, "A User's Guide
     for the Flexible Image Transport System (FITS)", version 3.1.
   NASA Office of Standards and Technology, 1995, "Definition of
     the Flexible Image Transport System (FITS)", version 1.1.
2 Related_Applications
   CONVERT: NDF2FITS; CURSA/xcatview; KAPPA: FITSDIN, FITSIN.
2 Authors
MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)

AJC: Alan J. Chipperfield (STARLINK)
2 History
 1994 June 3 (MJC):
    Original version.

 1997 March 7 (MJC):
    Added the documentation for conversion of the special FITS
    products, included more examples and made other improvements
    to the documentation.

 1997 March 24 (MJC):
    Can recreate NDFs produced by NDF2FITS.

 1997 November 16 (MJC):
    Filters out NDF-style history from the FITS airlock.  Fixed bug
    creating NDF extensions which are arrays of structures.

 18-DEC-1997 (DSB):
    Added support for the NDF WCS component.

 22-JAN-1998 (DSB):
    Changed the scheme for naming multiple IUE MXLO NDFs within
    the output container file; previously the row number was used,
    but NDF names cannot start with numeric characters and an
    error was consequently reported.  The word "ROW" is now
    prepended to the row number.

 1998 January 26 (MJC):
      Added IUE MXHI format.  Tidied the prologue.  Changed the
      MXLO NDF names to LARGE and SMALL instead of ROW1 and ROW2.
    2-FEB-1998 (DSB):
      Add ENCODING examples.

 1998 August 16 (MJC)
    Improved Notes on BINTABLE conversion and added CURSA to
    Related Applications.

 9-NOV-1998 (DSB):
    Added FITS-IRAF encoding.

 7-MAR-2000 (DSB):
    Report an error if no input FITS files are supplied.

 11-APR-2000 (DSB):
    Added FITS-PC and FITS-AIPS WCS encodings.

 12-APR-2000 (AJC):
    Allow FITS extension specifier in FITS filenames
    Correctly comment getting FMTCNV values (not BITPIX)

 13-APR-2000 (AJC):
    Added EXTABLE parameter

 17-APR-2000 (AJC):
      Annul errors before call MSG_OUT on illegal FMTCNV value
    9-MAY-2000 (AJC):
      Add NDF names to COF_EXTAB

 12-JUN-2000 (AJC):
    Major revision of EXTABLE description

 12-JUL-2000 (AJC)
    More tweaks to description

 30-AUG-2000 (AJC):
    Correct description FITS_EXT_n not NDF_EXT_n
    Add the CONTAINER parameter
    Tweak description of EXTABLE EXTN.name

 20-FEB-2002 (DSB):
    Added WCSATTRS parameter, mainly to deal with non-standard CAR
    projections.
1 GASP2NDF
Converts an image in GASP format to an NDF.

Usage:

   gasp2ndf in out shape=?

Description:

   This application converts a GAlaxy Surface Photometry (GASP)
   format file into an NDF.
2 Parameters
For information on individual parameters, select from the list below:
3 IN
IN = LITERAL (Read)
   A character string containing the name of GASP file to convert.
   The extension should not be given, since ".dat" is assumed.
3 OUT
OUT = NDF (Write)
   The name of the output NDF.
3 SHAPE
SHAPE( 2 ) = _INTEGER (Read)
   The dimensions of the GASP image (the number of columns
   followed by the number of rows).  Each dimension must be in the
   range 1 to 1024.  This parameter is only used if supplied on
   the command line, or if the header file corresponding to the
   GASP image does not exist or cannot be opened.
2 Examples
gasp2ndf m31_gasp m31
   Convert a GASP file called m31_gasp.dat into an NDF called m31.
   The dimensions of the image are taken from the header file
   m31_gasp.hdr.

gasp2ndf n1068 ngc1068 shape=[256,512]
   Take the pixel values in the GASP file n1068.dat and create
   the NDF ngc1068 with dimensions 256 columns by 512 rows.
2 Notes
-  A GASP image is limited to a maximum of 1024 by 1024 elements.
It must be two dimensional.

-  The GASP image is written to the NDF's data array.  The data
array has type _WORD.  No other NDF components are created.

-  If the header file is corrupted, you must remove the offending
".hdr" file or specify the shape of the GASP image on the command
line, otherwise the application will continually abort.
2 Related_Applications
   CONVERT: NDF2GASP.
2 References
   GASP documentation (MUD/66).
2 Keywords
   CONVERT, GASP
2 Authors
RAHM: Rhys Morris (STARLINK, University of Wales, Cardiff)

MJC: Malcolm J. Currie (STARLINK)
2 History
 18-JAN-1993 (RAHM):
    Original version.

 12-JUL-1993 (RAHM):
    Tidied up code ready for release in CONVERT package.

 1993 July 27 (MJC):
    Removed PSX calls and used RIO.  Used one shape parameter.
    Tidied the prologue and code.  Improved method for deciding
    whether to use the header file or not.
1 GIF2NDF
Converts a GIF file into an NDF.

Usage:

   gif2ndf in [out]

Description:

   This Bourne-shell script converts a Graphics Interchange Format
   (GIF) file into an unsigned-byte (256 grey-level) NDF format file.
   It handles one- or two-dimensional images.  The script uses
   various Netpbm utilities to produce a FITS file, flipped top
   to bottom, and then FITS2NDF to produce the final NDF.  Error
   messages are converted into Starlink style (preceded by !).
2 Parameters
For information on individual parameters, select from the list below:
3 IN
   IN = FILENAME (Read)
      The name of the GIF file to be converted. (A .gif name extension,
      is assumed if omitted.)
3 OUT
   OUT = NDF (Write)
      The name of the NDF to be generated (without the .sdf extension).
      If the OUT parameter is omitted, the value of the IN parameter
      is used.
2 Examples
gif2ndf old new
   This converts the GIF file old.gif into an NDF called new
   (in file new.sdf).

gif2ndf horse
   This converts the GIF file horse.gif into an NDF called horse
   (in file horse.sdf).
2 Notes
This initial version of the script generates images with at 256 grey
levels.  It does not use the image colour lookup table.

Input image filenames must have the extension .gif.

The Netpbm utilities giftopnm, ppmtopgm, pnmflip and pnmtofits must
be available on your PATH.
2 Related_Applications
   CONVERT: NDF2GIF, NDF2TIFF
2 Authors
MJC: Malcolm J. Currie (STARLINK)

GJP: G.J.Privett (Starlink - UWCC)

AJC: A.J.Chipperfield (Starlink - RAL)
2 History
 28-NOV-1995 (AJC):
    Original version, based on work by MJC and GJP.

 1997 August 1 (MJC):
    Removed KAPPA dependencies.  Reworded and reordered the
    description.  Added some comments.

 1997 October 3 (MJC):
    Improved the parameter handling to allow for no arguments, and
    to remove any .gif that may be present in the first argument.

 1998 November 17 (AJC):
    Use Netpbm - common for all platforms
      Use giftopnm not giftoppm
      Use pnmtofits not pgmtofits 

 1999 March 11 (AJC):
    Correct removal of .gif from name

1 IDL_Converters
IDL function READ_NDF is available to convert a component of an NDF
to an IDL array, and IDL procedure WRITE_NDF will create an NDF 
component from an IDL array. So, for example:

   IDL> tv,read_ndf('comwest')

will display the data array of the NDF, comwest.sdf, using the IDL
command, TV, and:

   IDL> write_ndf(field,'stars')

will create an NDF, stars.sdf, of a suitable type and size, and write
the IDL array, field, to its DATA_ARRAY component.

   IDL> write_ndf(q,'stars','QUALITY')

will write the IDL array, q, to the QUALITY component of an 
existing NDF, stars.sdf.

Both READ_NDF and WRITE_NDF can take special action on bad
values. 

2 Setting_up
When convert is installed, READ_NDF and WRITE_NDF are
placed in $CONVERT_DIR, so in order to make them available to IDL,
that directory must be added to the IDL search path. This will be done
if the environment variable IDL_PATH has been set (by the idl_setup
script) when you start the CONVERT package by typing:

   % convert

Note that convert must be run after sourcing the idl_setup script.

Note also that having started CONVERT, the NDF library, ultimately used
by the procedures, will allow on-the-fly conversion of any files given 
as parameters. This opens up the possibility of using almost any data 
format with IDL.

As an example:

   IDL> tv,read_ndf('moon.tif')

will display the TIFF file moon.tif.
        
2 READ_NDF
Description:
   This IDL function will convert a Starlink NDF file of up to seven
   dimensions to an IDL array of an appropriate type and shape. Bad values
   in the NDF may be converted to specific values in the IDL array.

   If NDF on-the-fly conversion has been activated, the given filename may
   refer to a file of a different data format which is to be converted.

Usage:
   Result = READ_NDF( Ndf_name[, Bad_value][,COMPONENT=Comp_name])

Returned Value:
   An IDL array of a size and type corresponding with the NDF. The type
   correspondence is as follows:

   _REAL -> floating
   _DOUBLE -> double-precision
   _UBYTE ->  byte
   _WORD ->  integer
   _INTEGER ->  longword integer

Deficiencies:
   No conversion of the given bad value to the appropriate type for
   the array will be attempted; instead an error will be reported.

Related Applications:
   CONVERT: WRITE_NDF

3 Arguments
Arguments:
   Ndf_name
      A string expression specifying name of the NDF to be read.

   Bad_value
      Optional - A value to replace in the IDL array any occurrence of
      the PRIMDAT bad value in the NDF component.  The value must be the 
      same type as the array.

Keywords:
   COMPONENT
      Set this to a string expression specifying the NDF component to be 
      read.  It may be 'DATA', 'VARIANCE' or 'QUALITY' and defaults to 
      'DATA'. The case of the string does not matter and it may be 
      abbreviated to one or more characters.

3 Examples
Assuming \texttt{my_ndf.sdf} is an NDF of type _REAL,

  IDL> data_array = read_ndf('my_ndf')

creates an IDL floating array, data_array, with the same dimensions
as the NDF and containing the values from its DATA component.

  IDL> data_array = read_ndf('my_ndf', !values.f_nan)

As above except that any occurrence of a bad value (VAL__BADR as 
defined by the Starlink PRIMDAT package) in the NDF will be replaced
by NaN in the IDL array.

  IDL> quality = read_ndf('my_ndf',comp='q')

creates an IDL byte array from the QUALITY component of the same NDF.
(The QUALITY component is always type _UBYTE.)
Note that the keyword 'component' and the value 'QUALITY' are 
case-independent and can be abbreviated.

2 WRITE_NDF
Description:
      This IDL procedure will write an IDL array of up to seven dimensions
      to a Starlink NDF. If NDF on-the-fly conversion has been activated,
      the given filename may refer to a file of a different data format in
      which case the NDF is then automatically converted to the required
      file type.

Usage:
   IDL> write_ndf, IDL_array, Ndf_name[, Bad_value][, COMPONENT=Comp_name]

Deficiencies:
   No conversion of the given bad value to the appropriate type for
   the array will be attempted; instead an error will be reported.

Related Applications:
   CONVERT: READ_NDF

3 Arguments
Arguments:
   IDL_array
      The IDL array to be converted. This may be an array name or
      constant of up to seven dimensions. The type of the NDF component
      created will depend on the type of the given array:
      
      floating -> _REAL
      double-precision -> _DOUBLE
      byte -> _UBYTE
      integer -> _WORD
      longword integer -> _INTEGER

      No other types are allowed.

   Ndf_name
      A string expression specifying name of the NDF to be written.

   Bad_value
      Optional - A value any occurrence of which in the IDL array is to
      be replaced by the appropriate PRIMDAT bad value in the NDF
      component. If no such value is found, the NDF bad pixel flag for
      the component is set FALSE.  The value must be the same type as
      the array.

Keywords:
   COMPONENT
      Set this to a string expression specifying the NDF component to be 
      written.  The following values are allowed:
      
      'DATA'  A new NDF is created with the same dimensions as the
              IDL array, and the DATA component written.
      'VARIANCE' An existing NDF is opened and a new component 
              written. The size of the given array must be the same
              as the NDF.
      'QUALITY' An existing NDF is opened and a new component 
              written. The size of the given array must be the same
              as the NDF and the type of the IDL array must be Byte.

      The case of the string does not matter and it may be abbreviated
      to one or more characters.
3 Examples
Assuming \texttt{my_data} is an IDL floating array,

   IDL> write_ndf, my_data, 'my_ndf'

creates the NDF 'my_ndf.sdf' with the same dimensions as the IDL
array 'my_data', and writes the array to its DATA component (of
type _REAL). No checks on bad values are made.

   IDL> write_ndf, my_data, 'my_ndf', !values.f_nan

As above except that any occurrence of the value NaN in the array
will be replaced by the VAL__BADR value as defined by the Starlink
PRIMDAT package.

   IDL> write_ndf, my_variances, 'my_ndf', comp='v'

Writes the IDL array 'my_variances' to the VARIANCES component of
the NDF created above. A check is made that the size of the array 
corresponds with the size of the NDF. (Note that the keyword 
'COMPONENT' and the value 'VARIANCE' are case-independent and can 
be abbreviated.)
1 IRAF2NDF
Converts an IRAF image to an NDF.

Usage:

   iraf2ndf in out

Description:

   This application converts an IRAF image to an NDF.  See the Notes
   for details of the conversion.
2 Parameters
For information on individual parameters, select from the list below:
3 IN
IN = LITERAL (Read)
   The name of the IRAF image.  Note that this excludes the
   ".imh" file extension.
3 OUT
OUT = NDF (Write)
   The name of the NDF to be produced.
3 PROFITS
PROFITS = _LOGICAL (Read)
   If TRUE, the user headers of the IRAF file are written
   verbatim to the NDF's FITS extension.  Any IRAF history
   records are also appended to the FITS extension.  The FITS
   extension is not created if there are no user headers
   present in the IRAF file. [TRUE]
3 PROHIS
PROHIS = _LOGICAL (Read)
   This parameter decides whether or not to create NDF HISTORY
   records.  Only the IRAF headers with keyword HISTORY, and
   which originated from NDF HISTORY records are used.  If
   PROHIS=TRUE, NDF HISTORY records are created.  [TRUE]
2 Examples
iraf2ndf ell_galaxy new_galaxy
   Converts the IRAF image ell_galaxy (comprising files
   ell_galaxy.imh and ell_galaxy.pix) to an NDF called new_galaxy.

iraf2ndf ell_galaxy new_galaxy noprofits noprohis
   As above, except no FITS extension is created, and NDF-style
   HISTORY lines in ell_galaxy.imh are not transferred to HISTORY
   records in NDF new_galaxy.
2 Notes
The rules for the conversion are as follows:

-  The NDF is created with bounds determined by any LBOUNDn keywords
   in the IRAF image header.

-  The NDF data array is copied from the ".pix" file.

-  The title of the IRAF image (object i_title in the ".imh"
header file) becomes the NDF title.  Likewise headers OBJECT and
BUNIT become the NDF label and units respectively.

-  The pixel origin is set if any LBOUNDn headers are present.

-  Lines from the IRAF image header file may be transferred to
the FITS extension of the NDF, when PROFITS=TRUE.  Any
compulsory FITS keywords that are missing are added.  Certain
other keywords are not propagated.  These are the IRAF "Mini
World Co-ordinate System" (MWCS) keywords WCSDIM, DC_FLAG,
WATd_nnn (d is dimension, nnn is the line number).  Certain
NDF-style HISTORY lines in the header are also be ignored when
PROHIS=TRUE (see two notes below).

-  When PROFITS=TRUE, lines from the HISTORY section of the IRAF
image are also extracted and added to the NDF's FITS extension as
FITS HISTORY lines.  Two extra HISTORY lines are added to record
the original name of the image and the date of the format
conversion.

-  When PROHIS=TRUE, any HISTORY lines in the IRAF headers, which
originated from an NDF2IRAF conversion of NDF HISTORY records.
Such headers are not transferred to the FITS airlock, when
PROFITS=TRUE.

-  Most axis information can be propagated either from standard
FITS-like keywords, or certain MCWS headers.  Supported systems
and formats are listed below.
   o  FITS

      - linear

      - log-linear
   o  Equispec

      - linear

      - log-linear
   o  Multispec

      - linear

      - log-linear

      - Chebyshev and Legendre polynomials

      - Linear and cubic Spline

      - Explicit list of co-ordinates

However, for Multispec axes, only the first (spec1) axis
co-ordinates are transferred to the NDF AXIS centres.  Any
spec2...specn co-ordinates, present when the data array is not
one-dimensional or multiple fits have been stored, are ignored.
The weights for multiple fits are thus also ignored.  The data
type of the axis centres is _REAL or _DOUBLE depending on the
number of significant digits in the co-ordinates or coefficients.

The axis labels and units are also propagated, where present, to
the NDF AXIS structure.  In the FITS system, these are derived
from the CTYPEn and CUNITn keywords.  In the MWCS, these
components originate in the label and units parameters.

The redshift correction, when present, is applied to the MCWS
axis co-ordinates.
2 Related_Applications
   CONVERT: NDF2IRAF.
2 Pitfalls
   -  Bad pixels in the IRAF image are not replaced.

   -  Some of the routines required for accessing the IRAF header
   file are written in SPP.  Macros are used to find the start of the
   header line section, this constitutes an `Interface violation' as
   these macros are not part of the IMFORT interface specification.
   It is possible that these may be changed in the future, so
   beware.
2 References
   IRAF User Handbook Volume 1A: "A User's Guide to FORTRAN
   Programming in IRAF, the IMFORT Interface", by Doug Tody.
2 Keywords
   CONVERT, IRAF
2 Authors
RAHM: Rhys Morris (STARLINK, University of Wales, Cardiff)

GJP: Grant Privett (STARLINK, University of Wales, Cardiff)

MJC: Malcolm J. Currie (STARLINK)

AJC: Alan Chipperfield (STARLINK)
2 History
 20-SEP-1992 (RAHM):
    Original version.

 23-NOV-1992 (RAHM):
    Produces NDFs of type UWORD from IRAF short integer
    type images.

 9-JUL-1993 (RAHM):
    Added VERBOSE parameter and tidied up.

 1993 July 23 (MJC):
    Reworked the prologue to a standard arrangement.  Tidied, made
    to conform to SGP/16.  Made to work for cubes.  Fixed some
    bugs.

 1993 July 28 (MJC):
    Removed the VERBOSE parameter.  This functionality should be
    provided by a global parameter.

 1993 September 30 (MJC):
    Do not copy standard FITS headers already added to the FITS
    extension.

 08-AUG-1995 (GJP):
    Modified the method used to obtain the date/time string to
    avoid the use of pointer.  Gave up PSX_ASCTIME and used
    PSX_CTIME instead.

 09-AUG 1995 (GJP):
    Removed erroneous mention of LIN2MAP, PREFITS and PUTLIN.

 09-AUG-1995 (GJP):
    Added the ability to generate a sensible error message when
    IMOPEN fails - as would happen if the file requested did
    not exist.

 11-AUG-1995 (GJP):
    Added a check to see if any header lines were found before
    calling GETLIN to obtain them.

 1997 April and July (MJC):
    Added PROFITS and PROHIS facilities.  Now propagates axis
    information, and the NDF label and units.  Expanded and
    corrected the documentation, including a second example.
    Improved the code structure.  Removed the conversion of the
    IRAF filename to lowercase.

 1997 September 25 (MJC):
    Protect against case where PROFITS=TRUE but there are no
    headers.

 13-NOV-1997 (AJC):
    Set bounds of NDF according to LBOUNDn keywords if any.
    Correct number of arguments to CON_CI2DW/CI2DR.

 1997 November 17 (MJC):
    No longer attempts to close the IRAF file if the open-file
    subroutine fails.  IMCLOS crashes otherwise.  Propagates all
    IRAF history records (including blanks) to the FITS airlock
    when PROFITS=TRUE.  IRAF HISTORY lines which are too long for
    a FITS header are truncated with an ellipsis.
2 Implementation_Status
   -  Only handles one-, two-, and three-dimensional IRAF files.

   -  The NDF produced has type _WORD or _REAL corresponding to the
   type of the IRAF image.  (The IRAF imfort FORTRAN subroutine
   library only supports these data types: signed words and real.)
   The pixel type of the image can be changed from within IRAF using
   the 'chpixtype' task in the 'images' package.

   -  See "Release Notes" for IRAF Version compatibility.
1 IRCAM2NDF
Converts an IRCAM data file to a series of NDFs.

Usage:

   ircam2ndf in prefix obs [config]

Description:

   This applications converts an HDS file in the IRCAM format listed
   in IRCAM User Note 11 to one or more NDFs.  See the Notes for a
   detailed list of the rules of the conversion.
2 Parameters
For information on individual parameters, select from the list below:
3 CONFIG
CONFIG = LITERAL (Read)
   The choice of data array to place in the NDF.  It can have one
   of the following configuration values:
      "STARE"    --- the image of the object or sky;
      "CHOP"     --- the chopped image of the sky;
      "KTCSTARE" --- the electronic pedestal or bias associated
                     with the stare image of the object or sky;
      "KTCCHOP"  --- the electronic pedestal or bias associated
                     with the chopped image of the sky.
   Note that at the time of writing chopping has not been
   implemented for IRCAM.  For practical purposes CONFIG="STARE"
   should be used.  The suggested default is the current value.
   ["STARE"]
3 FMTCNV
FMTCNV = _LOGICAL (Read)
   This specifies whether or not format conversion may occur.
   If FMTCNV is FALSE, the data type of the data array in the NDF
   will be the same as that in the IRCAM file, and there is no
   scale factor and offset applied.  If FMTCNV is TRUE, whenever
   the IRCAM observation has non-null scale and offset values,
   the observation data array will be converted to type _REAL in
   the NDF, and the scale and offset applied to the input data
   values to give the `true' data values.  A null scale factor is
   1 and a null offset is 0. [FALSE]
3 IN
IN = IRCAM (Read)
   The name of the input IRCAM file to convert to NDFs.  The
   suggested value is the current value.
3 OBS
OBS()  = LITERAL (Read)
   A list of the observation numbers to be converted into NDFs.
   Observations are numbered consecutively from 1 up to the
   actual number of observations in the IRCAM file.  Single
   observations or a set of adjacent observations may be
   specified, e.g. entering [4,6-9,12,14-16] will read
   observations 4,6,7,8,9,12,14,15,16.  (Note that the brackets
   are required to distinguish this array of characters from a
   single string including commas.  The brackets are unnecessary
   when there is only one item.)

   If you wish to extract all the observations enter the wildcard
   *.  5-* will read from 5 to the last observation.  The
   processing will continue until the last observation is
   converted.  The suggested value is the current value.
3 PREFIX
PREFIX = LITERAL (Read)
   The prefix of the output NDFs.  The name of an NDF is the
   prefix followed by the observation number.  The suggested
   value is the current value.
2 Examples
ircam2ndf ircam_27aug89_1cl rhooph obs=*
   This converts the IRCAM data file called ircam_27aug89_1cl into
   a series of NDFs called rhooph1, rhooph2 etc.  There is no
   format conversion applied.

ircam2ndf ircam_27aug89_1cl rhooph [32,34-36] fmtcnv
   This converts four observations in the IRCAM data file called
   ircam_27aug89_1cl into NDFs called rhooph32, rhooph34,
   rhooph35, rhooph36.  The scale and offset are applied.

ircam2ndf in=ircam_04nov90_1c config="KTC" obs=5 prefix=bias
   This converts the fifth observation in the IRCAM data file
   called ircam_04nov90_1c into an NDF called bias5 containing
   the electronic pedestal in its data array.  There is no format
   conversion applied.
2 Notes
- The rules for the conversion of the various components are as
follows:
_________________________________________________________________
  IRCAM file                 NDF

-----------------------------------------------------------------
  .OBS.PHASEA.DATA_ARRAY ->  .DATA_ARRAY
                             when parameter CONFIG="STARE"
  .OBS.PHASEB.DATA_ARRAY ->  .DATA_ARRAY
                             when parameter CONFIG="CHOP"
  .OBS.KTCA.DATA_ARRAY   ->  .DATA_ARRAY
                             when parameter CONFIG="KTCSTARE"
  .OBS.KTCB.DATA_ARRAY   ->  .DATA_ARRAY
                             when parameter CONFIG="KTCCHOP"

  .OBS.DATA_LABEL        ->  .LABEL
  .OBS.DATA_UNITS        ->  .UNITS
  .OBS.TITLE             ->  .TITLE
                             If .OBS.TITLE is a blank string,
                             OBS.DATA_OBJECT is copied to the
                             NDF title instead.

  .OBS.AXIS1_LABEL       ->  .AXIS(1).LABEL
  .OBS.AXIS2_LABEL       ->  .AXIS(2).LABEL
  .OBS.AXIS1_UNITS       ->  .AXIS(1).UNITS
  .OBS.AXIS2_UNITS       ->  .AXIS(2).UNITS
  .GENERAL.INSTRUMENT.PLATE_SCALE becomes the increment between
                             the axis centres, with co-ordinate
                             (0.0,0.0) located at the image
                             centre.  The NDF axis units both
                             become "arcseconds".

  .GENERAL               ->  .MORE.IRCAM.GENERAL
  .GENERAL.x             ->  .MORE.IRCAM.GENERAL.x
  .GENERAL.x.y           ->  .MORE.IRCAM.GENERAL.x.y

  .OBS.x                 ->  .MORE.IRCAM.OBS.x
                             This excludes the components of OBS
                             already listed above and DATA_BLANK.

- The data types of the IRCAM GENERAL structures have not been
propagated to the NDF IRCAM extensions, because it would violate
the rules of SGP/38.  In the IRCAM file these all have the same
type STRUCTURE.  The new data types are as follows:
_________________________________________________________________
  Extension Name               Data type

-----------------------------------------------------------------
  IRCAM.GENERAL                IRCAM_GENERAL
  IRCAM.GENERAL.INSTRUMENT     IRCAM_INSTRUM
  IRCAM.GENERAL.ID             IRCAM_ID
  IRCAM.GENERAL.TELESCOPE      IRCAM_TELESCOPE

-  Upon completion the number of observations successfully
converted to NDFs is reported.
2 Bad-pixel_Handling
   Elements of the data array equal to the IRCAM component
   .OBS.DATA_BLANK are replaced by the standard bad value.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1993 August 22 (MJC):
    Original version.
2 Implementation_Status
   - The data array in the NDF is in the primitive form.

   - The application aborts if the data array chosen by parameter
   CONFIG does not exist in the observation.
1 MTFITS2NDF
Converts FITS magnetic tape files into NDFs.

Usage:
   mtfits2ndf in out block=n [of=fits_file] [<fits2ndf_pars>]


Description:
   This application converts files from a FITS tape into NDFs by
   using shell commands mt and dd to position the tape and convert the
   selected tape files into FITS disk files and then using FITS2NDF to
   produce the NDFs.  The intermediate FITS files may be saved.
2 Parameters:
For information on individual parameters, select from the list below:
3 BLOCK = _INTEGER
   The the FITS blocking factor - i.e. the block size on the tape is
   this value multiplied by the standard FITS block size.
3 IN = Tape device name
   The name of a tape device.  For correct tape positioning, a no-rewind
   device must be used. The device name may be have a file specifiers
   appended, separated by commas and enclosed in [].  The file
   specifiers indicate which files from the tape are to be processed.
   For example:
      [2] indicates the second file on the tape.
      [4-6] indicates files 4 to 6.
      [5-] indicates file 5 to the last file on the tape.
      [1,3-5,7-] indicates files 1,3,4,5 and 7 to the end of the tape.
      If no file specifiers are given, all files on the tape will be 
      processed.
3 OF = FITS file name
   Set this if you want to save the intermediate FITS file(s).  If a
   number of files are being produced, the name should contain a *,
   which will be replaced by the corresponding FITS tape file number.
   If OF is not specified, fitsmtin#.fits will be used and deleted.
   (See also Note 1).
3 OUT = NDF
   The name of the NDF(s) to be produced by FITS2NDF.  This is passed
   FITS2NDF but only a single element string can be specified.  It can
   contain the matching patterns allowed for FITS2NDF, for example '*'.
3  <fits2ndf_pars>
   Other parameters will be passed to FITS2NDF---see the description of
   FITS2NDF.

2 Notes:
   1. This application is a tcsh script which calls an ADAM A-task.
      CONVERT startup sets alias mtfits2ndf to 'tcsh mtfits2ndf.tcsh',
      and tcsh must be on the user's PATH.
   2. The string specified for the intermediate FITS file name(s) will be
      presented as the IN parameter for the FITS2NDF call.  All files
      matching the string will be used, whether or not they were produced
      in this run. (See the FITS2NDF description for details.)

2 Examples:
   Note that []* etc must be protected from the shell

   mtfits2ndf '/dev/nst0[2]' f256 block=10 fmtcnv=f
      This converts the second file on the tape on device /dev/nst0 to
      an NDF called f256.  The FITS blocking factor of the tape is 10.
      As a result of the parameters passed to FITS2NDF, the data type of
      the NDF's data array matches that of the FITS primary data array,
      a FITS extension is created in f256, and FITS sub-files are
      propagated to NDF extensions.
   mtfits2ndf /dev/nst0 '*' block=1 of='ral256_*.fit'
      Will convert each file on the tape on device /dev/nst0 (with a
      blocking factor of 1) to FITS disk files named ral256_*.fit,
      where * is replaced by each tape file number.  The FITS files
      will be converted to NDFs named ral256_*.sdf and retained.
   mtfits2ndf
     The user is prompted for the input device, the output NDF name and
     the FITS blocking factor.  All other parameters are defaulted.
2 References:
   NASA Office of Standards and Technology, 1997, "A User's Guide
     for the Flexible Image Transport System (FITS)", version 4.0.
   NASA Office of Standards and Technology, 1999, "Definition of
     the Flexible Image Transport System (FITS)".

2 Related Applications:
   CONVERT: FITS2NDF; KAPPA: FITSDIN, FITSIN.

2 Deficiencies:
   1. Facilities for naming multiple output files are limited.

   2. The command is not available from ICL, nor as an option in the 
      automatic (on-the-fly) conversion system

   3. Extensions within a FITS file may not be specified.  However, it
      is possible to pass an EXTABLE parameter to the FITS2NDF
      operation to select extensions.

   4. Only tape devices for which the mt and dd commands will work may
      be used.

2 Authors:
   AJC: Alan J. Chipperfield (Starlink)

2 History:
   29-OCT-2001 (AJC):
      Original version.
1 NDF2ASCII
Converts an NDF to a text file.

Usage:

   ndf2ascii in out [comp] [reclen] noperec=?

Description:

   This application converts an NDF to a Fortran formatted text
   file.  Only one of the array components may be copied to the
   output file.  Preceding the data there is an optional header
   consisting of either the FITS extension with the values of
   certain keywords replaced by information derived from the NDF, or
   a minimal FITS header also derived from the NDF.  The output file
   uses LIST carriagecontrol.
2 Parameters
For information on individual parameters, select from the list below:
3 COMP
COMP = LITERAL (Read)
   The NDF component to be copied.  It may be "Data", "Quality"
   or "Variance". ["Data"]
3 FITS
FITS = _LOGICAL (Read)
   If TRUE, any FITS extension is written to start of the output
   file, unless there is no extension whereupon a minimal FITS
   header is written to the text file. [FALSE]
3 FIXED
FIXED = _LOGICAL (Read)
   When FIXED is TRUE, the output file allocates a fixed number
   of characters per data value.  The number of characters chosen
   is the minimum that prevents any loss of precision, and hence
   is dependent on the data type of the NDF array.  These widths
   in characters for each HDS data type are as follows: _UBYTE, 3;
   _BYTE, 4; _UWORD, 5; _WORD, 6; _INTEGER, 11; _REAL, 16; and
   _DOUBLE, 24.  The record length is the product of the number
   of characters per value plus one (for a delimiting space),
   times the number of values per record given by parameter
   NOPEREC, up to a maximum of 512.

   When FIXED is FALSE, data values are packed as efficiently as
   possible within each record.  The length of each record is
   given by parameter RECLEN.  [FALSE]
3 IN
IN = NDF (Read)
   Input NDF data structure. The suggested default is the current
   NDF if one exists, otherwise it is the current value.
3 NOPEREC
NOPEREC = _INTEGER (Read)
   The number of data values per record of the output file, when
   FIXED is TRUE.  It should be positive on UNIX platforms.
   The suggested default is the current value, or 8 when there
   is not one.  The upper limit is given by 512 divided by the
   number of characters per value plus 1 (see parameter FIXED).
3 OUT
OUT = FILENAME (Write)
   Name of the output formatted Fortran file.  The file will
   normally have variable-length records when there is a header,
   but always fixed-length records when there is no header.
3 RECLEN
RECLEN = _INTEGER (Read)
   The maximum record length in bytes (characters) of the output
   file.  This has a maximum length of 512 (for efficiency
   reasons), and must be greater than 31 on UNIX systems.  The
   lower limit is further increased to 80 when there is a FITS
   header to be copied.  It is only used when FIXED is FALSE and
   will default to the current value, or 132 if there is no
   current value.
   []
2 Examples
ndf2ascii cluster cluster.dat
   This copies the data array of the NDF called cluster to a text
   file called cluster.dat.  The maximum recordlength of
   cluster.dat is 132 bytes, and the data values are packed into
   these records as efficiently as possible.

ndf2ascii cluster cluster.dat v
   This copies the variance of the NDF called cluster to a text
   file called cluster.dat.  The maximum recordlength of
   cluster.dat is 132 bytes, and the variance values are packed
   into these records as efficiently as possible.

ndf2ascii cluster cluster.dat fixed noperec=12
   This copies the data array of the NDF called cluster to a text
   file called cluster.dat.  There are twelve data values per
   record in cluster.dat.

ndf2ascii out=ndf234.dat fits reclen=80 in=@234
   This copies the data array of the NDF called 234 to a text
   file called ndf234.dat.  The maximum recordlength of
   ndf234.dat is 80 bytes, and the data values are packed into
   these records as efficiently as possible.  If there is a FITS
   extension, it is copied to ndf234.dat with substitution of
   certain keywords, otherwise a minimal FITS header is produced.
2 Notes
The details of the conversion are as follows:

   -  the NDF array as selected by COMP is written to the text
   file in records following an optional header.  When FIXED is
   FALSE all records are padded out to the recordlength.

   -  HISTORY is not propagated.

   -  ORIGIN information is lost.

When a header is to be made, it is composed of FITS-like card
images as follows:

   -  The number of dimensions of the data array is written
   to the keyword NAXIS, and the actual dimensions to NAXIS1,
   NAXIS2 etc. as appropriate.

   -  If the NDF contains any linear axis structures the
   information necessary to generate these structures is
   written to the FITS-like headers. For example, if a linear
   AXIS(1) structure exists in the input NDF the value of the
   first data point is stored with the keyword CRVAL1,
   and the incremental value between successive axis data is
   stored in keyword CDELT1.  By definition the reference pixel is
   1.0 and is stored in keyword CRPIX1.  If there is an axis label
   it is written to keyword CTYPE1, and axis unit is written to
   CUNIT1.  (Similarly for AXIS(2) structures etc.) FITS does not
   have a standard method of storing axis widths and variances,
   so these NDF components will not be propagated to the header.
   Non-linear axis data arrays cannot be represented by CRVALn
   and CDELTn, and must be ignored.

   -  If the input NDF contains TITLE, LABEL or UNITS components
   these are stored with the keywords TITLE, LABEL or BUNIT
   respectively.

   -  If the input NDF contains a FITS extension, the FITS items
   may be written to the FITS-like header, with the following
   exceptions:
      o  BITPIX is derived from the type of the NDF data array,
      and so it is not copied from the NDF FITS extension.
      o  NAXIS, and NAXISn are derived from the dimensions of the
      NDF data array as described above, so these items are not
      copied from the NDF FITS extension.
      o  The TITLE, LABEL, and BUNIT descriptors are only copied
      if no TITLE, LABEL, and UNITS NDF components respectively
      have already been copied into these headers.
      o  The CDELTn, CRVALn, CTYPEn, CUNITn, and CRTYPEn
      descriptors in the FITS extension are only copied if the
      input NDF contained no linear axis structures.
      o  The standard order of the FITS keywords is preserved,
      thus BITPIX, NAXIS and NAXISn appear immediately after the
      first card image, which should be SIMPLE.
      o  BSCALE and BZERO in a FITS extension are copied when
      BITPIX is positive, i.e. the array is not floating-point.

   -  An extra header record with keyword UNSIGNED and logical
   value T is added when the array data type is one of the HDS
   unsigned integer types.  This is done because standard FITS
   does not support unsigned integers, and allows (in conjunction
   with BITPIX) applications reading the text file to determine
   the data type of the array.

   -  The last header record card will be the standard FITS END.

   -  Other extensions are not propagated.
2 Related_Applications
   CONVERT: ASCII2NDF; KAPPA: TRANDAT; FIGARO: ASCIN and ASCOUT.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1991 January 28 (MJC):
    Original version.

 1992 September 15 (MJC):
    Added more control of the formatting of the output file.

 1996 September 16 (MJC):
    Corrected usage of CTYPEn (was CRTYPEn) and introduced CUNITn
    for axis units.  Also writes CRPIXn FITS keyword when the NDF
    has linear axis centres.

 1997 January 22 (MJC):
    Reduced the maximum record length to 512, and the default
    RECLEN to 132.
2 Implementation_Status
   -  All non-complex numeric data types are supported.

   -  The value of bad pixels is not written to a FITS-like header
   record with keyword BLANK.
1 NDF2DA
Converts an NDF to a direct-access unformatted file.

Usage:

   ndf2da in out [comp] [noperec]

Description:

   This application converts an NDF to a direct-access unformatted
   file, which is equivalent to fixed-length records, or a data
   stream suitable for reading by C routines.  Only one of the array
   components may be copied to the output file.
2 Parameters
For information on individual parameters, select from the list below:
3 COMP
COMP = LITERAL (Read)
   The NDF component to be copied.  It may be "Data", "Quality"
   or "Variance". ["Data"]
3 IN
IN = NDF (Read)
   Input NDF data structure.  The suggested default is the current
   NDF if one exists, otherwise it is the current value.
3 NOPEREC
NOPEREC = _INTEGER (Read)
   The number of data values per record of the output file.  It
   must be positive.  The suggested default is the current value.
   [The first dimension of the NDF]
3 OUT
OUT = FILENAME (Write)
   Name of the output direct-access unformatted file.
2 Examples
ndf2da cluster cluster.dat
   This copies the data array of the NDF called cluster to a
   direct-access unformatted file called cluster.dat.  The number
   of data values per record is equal to the size of the first
   dimension of the NDF.

ndf2da cluster cluster.dat v
   This copies the variance of the NDF called cluster to a
   direct-access unformatted file called cluster.dat.  The number
   of variance values per record is equal to the size of the
   first dimension of the NDF.

ndf2da cluster cluster.dat noperec=12
   This copies the data array of the NDF called cluster to a
   direct-access unformatted file called {\tt cluster.dat}.  There are
   twelve data values per record in cluster.dat.
2 Notes
The details of the conversion are as follows:

   -  the NDF array as selected by COMP is written to the
   unformatted file in records.

   -  all other NDF components are lost.
2 Related_Applications
   CONVERT: DA2NDF.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1996 October 20 (MJC):
    Original version.
1 NDF2DST
Converts an NDF to a Figaro (Version 2) DST file.

Usage:

   ndf2dst in out

Description:

   This application converts an NDF to a Figaro (Version 2) `DST'
   file.  The rules for converting the various components of a DST
   are listed in the Notes.  Since both are hierarchical formats
   most files can be be converted with little or no information
   lost.
2 Parameters
For information on individual parameters, select from the list below:
3 IN
IN = NDF (Read)
   Input NDF data structure.  The suggested default is the
   current NDF if one exists, otherwise it is the current value.
3 OUT
OUT = Figaro (Write)
   Output Figaro file name.  This excludes the file extension.
   The file created will be given extension ".dst".
2 Examples
ndf2dst old new
   This converts the NDF called old (in file old.sdf) to the
   Figaro file new.dst.

ndf2dst spectre spectre
   This converts the NDF called spectre (in file spectre.sdf) to
   the Figaro file spectre.dst.
2 Notes
The rules for the conversion are as follows:
_________________________________________________________________
     NDF                   Figaro file

-----------------------------------------------------------------
     Main data array     -> .Z.DATA
     Imaginary array     -> .Z.IMAGINARY
     Bad-pixel flag      -> .Z.FLAGGED
     Units               -> .Z.UNITS
     Label               -> .Z.LABEL
     Variance            -> .Z.ERRORS (after processing)
     Quality             -> It is not copied directly though bad
                            values indicated by QUALITY flags will
                            be flagged in .Z.DATA in addition to
                            any flagged values actually in the
                            input main data array.  .Z.FLAGGED is
                            set accordingly.
     Title               -> .OBS.OBJECT

     AXIS(1) structure   -> .X
        AXIS(1) Data     -> .X.DATA  (unless there is a DATA_ARRAY
                            component of AXIS(1).MORE.FIGARO to
                            allow for a non-1-dimensional array)
        AXIS(1) Variance -> .X.VARIANCE  (unless there is a
                            VARIANCE component of
                            AXIS(1).MORE.FIGARO to allow for a
                            non-1-dimensional array)
        AXIS(1) Width    -> .X.WIDTH  (unless there is a WIDTH
                            component of AXIS(1).MORE.FIGARO to
                            allow for a non-1-dimensional array)
        AXIS(1) Units    -> .X.UNITS
        AXIS(1) Label    -> .X.LABEL
        AXIS(1).MORE.FIGARO.xxx -> .X.xxx
     (Similarly for AXIS(2), ..., AXIS(6) which are renamed to
     .Y .T .U .V or .W)

     FIGARO extension:
     .MORE.FIGARO.MAGFLAG -> .Z.MAGFLAG
     .MORE.FIGARO.RANGE -> .Z.RANGE
     .MORE.FIGARO.SECZ  -> .OBS.SECZ
     .MORE.FIGARO.TIME  -> .OBS.TIME
     .MORE.FIGARO.xxx    -> .xxx   (recursively)

     FITS extension:
     .MORE.FITS
              Items      -> .FITS.xxx
              Comments   -> .COMMENTS.xxx

     Other extensions:
     .MORE.other         -> .MORE.other
2 Related_Applications
   CONVERT: DST2NDF.
2 Authors
JM: Jo Murray (STARLINK)

MJC: Malcolm J. Currie (STARLINK)
2 History
 1991 February 1 (JM):
    Original version.

 1991 March 22 (JM):
    The NDF quality array is no longer copied to the output Figaro
    file. This is because Figaro does not supports the use of both
    flagged values and a quality array in the same data structure.
    Extensions in the NDF are copied from NDF.MORE to Figaro.MORE.

 1991 September 25 (MJC):
    Corrected looping bug, when an extension is empty.

 1992 January 30 (MJC):
    Added further comments to the code.  Modified to preserve the
    type of extensions in the FIGARO.MORE structure.  Added route
    for other extensions to the prologue.  Made the file parameters
    IN and OUT, as given in SUN/55.  Corrected the processing of
    character-valued card-images in the FITS extension.  Searches
    for the comment delimiter rather than assuming where the
    comment is located.  Reordered the annulling of the comments
    locator to prevent an error.

 1992 June 2 (MJC):
    Checks for a blank FITS keyword: if found the card image is
    omitted from the DST.

 1992 September 2 (MJC):
    Write FLAGGED value to DST as Figaro (DSA_) makes the opposite
    assumption about the presence of bad pixels compared with
    NDF_.

 1992 September 9 (MJC):
    Propagated axis variance and width, and the contents of any
    axis Figaro extension.  Fixed bug whereby if there was only
    one object in the Figaro extension, it was not copied to the
    DST.

 1992 September 10 (MJC):
    Moved special cases of .OBS.SECZ, .OBS.TIME, .Z.MAGFLAG,
    .Z.RANGE from the top-level Figaro extension as this is where
    DSA_ now expects to find them in an NDF.

 1995 July 25 (MJC):
    Fixed bug when n-dimensional axis is present: it was getting
    pixel co-ordinate DATA component and a DATA_ARRAY component
    for the n-dimensional array.  Made the latter the DATA
    component.

 1996 February 7 (MJC):
    Checked whether or not AXIS().MORE.FIGARO.DATA_ARRAY is
    primitive.  If it is, its DATA component becomes the new
    n-D axis array, rather than renaming DATA_ARRAY to DATA, in
    the Figaro file.

 1996 February 9 (MJC):
    Checked whether or not AXIS().MORE.FIGARO.WIDTH is primitive.
    If it is, its DATA component becomes the new n-D axis-width
    array in the Figaro file.

 1996 July 17 (MJC):
    Transfers the DATA_ARRAY.IMAGINARY_DATA component to
    .Z.IMAGINARY

 1997 April 24 (MJC):
    Fixed bug that could result in .OBS and .Z structures of the
    FIGARO extension being lost.  This occurred when FIGARO
    extension components SECZ or TIME (for OBS), and MAGFLAG or
    RANGE (for Z) are present and are physically stored following
    their respective structure.
1 NDF2FITS
Converts NDFs into FITS files.

Usage:

   ndf2fits in out [comp] [bitpix] [origin]

Description:

   This application converts one or more NDF datasets into
   FITS-format files.  NDF2FITS stores any variance and quality
   information in IMAGE extensions (`sub-files') within the FITS
   file; and it uses binary tables to hold any NDF-extension data
   present, except for the FITS-airlock extension, which may be
   merged into the output FITS file's headers.

   You can select which NDF array components to export to the FITS
   file, and choose the data type of the data and variance arrays.
   You can control whether or not to propagate extensions and
   history information.
2 Parameters
For information on individual parameters, select from the list below:
3 BITPIX
BITPIX = LITERAL (Read)
   The FITS bits-per-pixel (BITPIX) value for each conversion.
   This specifies the data type of the output FITS file.
   Permitted values are: 8 for unsigned byte, 16 for signed word,
   32 for integer, -32 for real, -64 for double precision.  There
   are two other special values.  BITPIX=0 will cause the output
   file to have the data type equivalent to that of the input
   NDF.  BITPIX=-1 requests that the output file has the data
   type corresponding to the value of the BITPIX keyword in the
   NDF's FITS extension.  If the extension or BITPIX keyword is
   absent, the output file takes the data type of the input
   array.

   BITPIX must be enclosed in double quotes and may be a list of
   comma-separated values to be applied to each conversion in
   turn.  An error results if more values than the number of input
   NDFs  are supplied.  If too few are given, the last value in
   the list applied to all the conversions.  The given values must
   be in the file may be used.  If more than one line is required
   to enter the information at a prompt then place a "-" at the
   end of each line where a continuation line is desired.  [0]
3 COMP
COMP = LITERAL (Read)
   The list of array components to attempt to transfer to each
   FITS file.  The acceptable values are "D" for the main data
   array "V" for variance, "Q" for quality, or any permutation
   thereof.  The special value "A" means all components, i.e.
   COMP="DVQ". Thus COMP="VD" requests that both the data array
   and variance are to be converted if present.  During
   processing at least one, if not all, of the requested
   components must be present, otherwise an error is reported and
   processing turns to the next input NDF.  If the data component
   is in the list, it will always be processed first into the
   FITS primary array.  The order of the variance and quality
   in COMP decides the order they will appear in the FITS file.

   COMP may be a list of comma-separated values to be applied to
   each conversion in turn.  The list must be enclosed in double
   quotes.  An error results if more values than the number of
   input NDFs are supplied.  If too few are given, the last value
   in the list is applied to the remainder of the NDFs; thus a
   single value is applied to all the conversions.  The given
   values must be in the same order as that of the input NDFs.
   Indirection through a text file may be used.  If more than one
   line is required to enter the information at a prompt then
   place a "-" at the end of each line where a continuation line
   is desired.  ["A"]
3 ENCODING
ENCODING = LITERAL (Read)
   Controls the FITS keywords which will be used to encode the
   World Co-ordinate System (WCS) information within the FITS
   header. The value supplied should be one of the encodings listed
   in the "World Co-ordinate Systems" section below. In addition,
   the value "Auto" may also be supplied, in which case a suitable
   default encoding is chosen based on the contents of the NDFs
   FITS extension and WCS component.  ["Auto"]
3 IN
IN = LITERAL (Read)
   The names of the NDFs to be converted into FITS format.  It
   may be a list of NDF names or direction specifications
   separated by commas and enclosed in double quotes.  NDF names
   may include wild-cards ("*", "?").  Indirection may occur
   through text files (nested up to seven deep).  The indirection
   character is "^".  If extra prompt lines are required, append
   the continuation character "-" to the end of the line.
   Comments in the indirection file begin with the character "#".
3 NATIVE
NATIVE = _LOGICAL (Read)
   If a TRUE value is given for parameter NATIVE, then World
   Co-ordinate System (WCS) information will be written to the
   FITS header in the form of a `native' encoding (see "World
   Co-ordinate Systems" below).  This will be in addition to the
   encoding specified using parameter ENCODING, and will usually
   result in two descriptions of the WCS information being stored
   in the FITS header (unless the ENCODING parameter produces a
   native encoding in which case only one native encoding is
   stored in the header).  Including a native encoding in the
   header will enable other AST-based software (such as FITS2NDF)
   to reconstruct the full details of the WCS information.  The
   other non-native encodings will usually result in some
   information being lost.  [FALSE]
3 ORIGIN
ORIGIN = LITERAL (Read)
   The origin of the FITS files.  This becomes the value of the
   ORIGIN keyword in the FITS headers.  If a null value is given
   it defaults to "Starlink Project, U.K.".
   [!]
3 OUT
OUT = LITERAL (Write)
   The names for the output FITS files.  These may be enclosed in
   double quotes and specified as a list of comma-separated names,
   or they may be created automatically on the basis of the input
   NDF names. To do this, the string supplied for this parameter
   should include an asterisk "*". This character is a token which
   represents the name of the corresponding input NDF, but with a
   file type of ".fit" instead of ".sdf", and with no directory
   specification. Thus, simply supplying "*" for this parameter
   will create a group of output files in the current directory
   with the same names as the input NDFs, but with file type
   ".fit". You can also specify some simple editing to be
   performed.  For instance, "new-*|.fit|.fits|" will add the
   string "new-" to the start of every file name, and will
   substitute the string ".fits" for the original string ".fit".
3 PROEXTS
PROEXTS = _LOGICAL (Read)
   If TRUE, the NDF extensions (other than the FITS extension)
   are propagated to the FITS files as FITS binary-table
   extensions, one per structure of the hierarchy.  [FALSE]
3 PROFITS
PROFITS = _LOGICAL (Read)
   If TRUE, the contents of the FITS extension of the NDF are
   merged with the header information derived from the standard
   NDF components.  See the Notes for details of the merger.
   [TRUE]
3 PROHIS
PROHIS = _LOGICAL (Read)
   If TRUE, any NDF history records are written to the primary
   FITS header as HISTORY cards.  These follow the mandatory
   headers and any merged FITS-extension headers (see parameter
   PROFITS).  [TRUE]
2 Examples
ndf2fits horse logo.fit d
   This converts the NDF called horse to the FITS file called
   logo.fit.  The data type of the FITS primary data array matches
   that of the NDF's data array.  The FITS extension in the NDF
   is merged into the FITS header of logo.fit.

ndf2fits horse logo.fit d proexts
   This converts the NDF called horse to the FITS file called
   logo.fit.  The data type of the FITS primary data array matches
   that of the NDF's data array.  The FITS extension in the NDF
   is merged into the FITS header of logo.fit.  In addition any
   NDF extensions (apart from FITS) are turned into binary tables.
   that follow the primary header and data unit.

ndf2fits horse logo.fit noprohis
   This converts the NDF called horse to the FITS file called
   logo.fit.  The data type of the FITS primary data array matches
   that of the NDF's data array.  The FITS extension in the NDF
   is merged into the FITS header of logo.fit.  Should horse
   contain variance and quality arrays, these are written in IMAGE
   extensions.  Any history information in the NDF is not relayed
   to the FITS file.

ndf2fits "data/a*z" * comp=v noprofits bitpix=-32
   This converts the NDFs with names beginning with "a" and ending
   in "z" in the directory called data into FITS files of the same
   name and with a file extension called .fit.  The variance
   array becomes the data array of each FITS file.  The data type
   of the FITS primary data array single-precision floating
   point.  Any FITS extension in the NDF is ignored.

ndf2fits "abc,def" "jvp1.fit,jvp2.fit" comp=d  bitpix="16,-64"
   This converts the NDFs called abc and def into FITS files
   called jvp1.fit and jvp2.fit respectively.  The data type of
   the FITS primary data array is signed integer words in
   jvp1.fit, and double-precision floating point in jvp2.fit.  The
   FITS extension in each NDFs is merged into the FITS header of
   the corresponding FITS file.

ndf2fits horse logo.fit d native encoding="fits-wcs"
   This is the same as the first example except that the
   co-ordinate system information stored in the NDF's WCS
   component is written to the FITS file twice; once using the
   FITS-WCS headers, and once using a special set of `native'
   keywords recognised by the AST library (see SUN/210).  The
   native encoding provides a `loss-free' means of transferring
   co-ordinate system information (i.e. no information is lost;
   other encodings may cause information to be lost).  Only
   applications based on the AST library (such as FITS2NDF)
   are able to interpret native encodings.
2 Notes
The rules for the conversion are as follows:

-  The NDF main data array becomes the primary data array of the
FITS file if it is in value of parameter COMP, otherwise the first
array defined by parameter COMP will become the primary data
array.  A conversion from floating point to integer or to a
shorter integer type will cause the output array to be scaled and
offset, the values being recorded in keywords BSCALE and BZERO.
There is an offset (keyword BZERO) applied to signed byte and
unsigned word types to make them unsigned-byte and signed-word
values respectively in the FITS array (this is because FITS does
not support these data types).

-  The FITS keyword BLANK records the bad values for integer
output types.  Bad values in floating-point output arrays are
denoted by IEEE not-a-number values.

-  The NDF's quality and variance arrays appear in individual
FITS IMAGE extensions immediately following the primary header
and data unit, unless that component already appears as the
primary data array.  The quality array will always be written as
an unsigned-byte array in the FITS file, regardless of the value
of the parameter BITPIX.

-  Here are details of the processing of standard items from the
NDF into the FITS header, listed by FITS keyword.
   SIMPLE, EXTEND, PCOUNT, GCOUNT --- all take their default
     values.
   BITPIX, NAXIS, NAXISn --- are derived directly from the NDF
     data array;
   CRVALn, CDELTn, CRPIXn, CTYPEn, CUNITn --- are derived from
     the NDF WCS component if possible (see "World Co-ordinate
     Systems").  If this is not possible, and if PROFITS is TRUE,
     then they are copied from the NDF FITS extension.
   OBJECT, LABEL, BUNIT --- the values held in the NDF's title,
     label, and units components respectively are used if
     they are defined; otherwise any values found in the FITS
     extension are used (provided parameter PROFITS is TRUE).
   DATE --- is created automatically.
   ORIGIN --- inherits any existing ORIGIN card in the NDF FITS
     extension, unless you supply a value through parameter
     ORIGIN other than the default "Starlink Project, U.K."
   EXTNAME --- is the array-component name when the EXTNAME
     appears in the primary header or an IMAGE extension.  In a
     binary-table derived from an NDF extension, EXTNAME is the
     path of the extension within the NDF, the path separator
     being the usual dot.  The path includes the indices to
     elements of any array structures present; the indices are in
     a comma-separated list within parentheses.
   EXTLEVEL --- is the level in the hierarchical structure of the
     extensions.  Thus a top-level extension has value 1,
     sub-components of this extension have value 2 and so on.
   EXTTYPE --- is the data type of the NDF extension used to
     create a binary table.
   EXTSHAPE --- is the shape of the NDF extension used to
     create a binary table.  It is a comma-separated list of the
     dimensions, and is 0 when the extension is not an array.
   HDUCLAS1, HDUCLASn --- "NDF" and the array-component name
     respectively.
   LBOUNDn --- is the pixel origin for the nth dimension when
     any of the pixel origins is not equal to 1.  (This is not a
     standard FITS keyword.)
   XTENSION, BSCALE, BZERO, BLANK and END --- are not propagated
     from the NDF's FITS extension.  XTENSION will be set for
     any extension.  BSCALE and BZERO will be defined based on
     the chosen output data type in comparison with the NDF
     array's type, but cards with values 1.0 and 0.0 respectively
     are written to reserve places in the header section.  These
     `reservation' cards are for efficiency and they can always
     be deleted later.  BLANK is set to the Starlink standard bad
     value corresponding to the type specified by BITPIX, but only
     for integer types and not for the quality array.  It appears
     regardless of whether or not there are bad values actually
     present in the array; this is for the same efficiency reasons
     as before.  The END card terminates the FITS header.
  HISTORY headers are propagated from the FITS extension when
     PROFITS is TRUE, and from the NDF history component when
     PROHIS is TRUE.

-  Extension information may be transferred to the FITS file when
PROEXTS is TRUE.  The whole hierarchy of extensions is propagated
in order.  This includes substructures, and arrays of extensions
and substructures.  However, at present, any extension structure
containing only substructures is not propagated itself (as
zero-column tables are not permitted), although its
substructures may be converted.

Each extension or substructure creates a one-row binary table,
where the columns of the table correspond to the primitive
(non-structure) components.  The name of each column is the
component name.  The column order is the same as the component
order.  The shapes of multi-dimensional arrays are recorded using
the TDIMn keyword, where n is the column number.  The HEASARCH
convention for specifying the width of character arrays (keyword
TFORMn='rAw', where r is the total number of characters in the
column and w is the width of an element) is used.  The EXTNAME,
EXTTYPE, EXTSHAPE and EXTLEVEL keywords (see above) are written
to the binary-table header.
2 World_Co-ordinate_Systems
   Any co-ordinate system information stored in the WCS component of
   the NDF is written to the FITS header using one of the following
   encoding systems (the encodings used are determined by parameters
   ENCODING and NATIVE):

      "FITS-IRAF" --- This uses keywords CRVALi CRPIXi, CDi_j, and
      the system commonly used by IRAF.  It is described in the
      document "World Coordinate Systems Representations Within the
      FITS Format" by R.J. Hanisch and D.G. Wells, 1988, available by
      ftp from fits.cv.nrao.edu /fits/documents/wcs/wcs88.ps.Z.

      "FITS-WCS" --- This is the proposed FITS standard WCS encoding
      scheme described in the paper "Representation of celestial
      coordinates in FITS"
      (http://www.cv.nrao.edu/fits/documents/wcs/wcs.html).  It is
      very similar to "FITS-IRAF" but supports a wider range of
      projections and co-ordinate systems.  Once the standard has
      been agreed, this encoding should be understood by any
      FITS-WCS compliant software and it is likely to be adopted
      widely for FITS data in future.

      "FITS-PC" --- This uses keywords CRVALi, CDELTi, CRPIXi,
      PCiiijjj, etc., as described in a previous (now superseded)
      draft of the above FITS world co-ordinate system paper by
      E.W.Greisen and M.Calabretta.

      "FITS-AIPS" --- This uses conventions described in the document
      "Non-linear Coordinate Systems in AIPS" by Eric W. Greisen
      (revised 9th September, 1994), available by ftp from
      fits.cv.nrao.edu /fits/documents/wcs/aips27.ps.Z.  It is
      currently employed by the AIPS data-analysis facility (amongst
      others), so its use will facilitate data exchange with AIPS.
      This encoding uses CROTAi and CDELTi keywords to describe axis
      rotation and scaling.

      "DSS" --- This is the system used by the Digital Sky Survey,
      and uses keywords AMDXn, AMDYn, PLTRAH, etc.

      "NATIVE" --- This is the native system used by the AST library
      (see SUN/210) and provides a loss-free method for transferring
      WCS information between AST-based application.  It allows more
      complicated WCS information to be stored and retrieved than any
      of the other encodings.

   Values for FITS keywords generated by the above encodings will
   always be used in preference to any corresponding keywords found
   in the FITS extension (even if PROFITS is TRUE). If this is not
   what is required, the WCS component of the NDF should be erased
   using the KAPPA command ERASE before running NDF2FITS.  Note, if
   PROFITS is TRUE, then any WCS-related keywords in the FITS
   extension which are not replaced by keywords derived from the WCS
   component may appear in the output FITS file.  If this causes a
   problem, then PROFITS should be set to FALSE or the offending
   keywords removed using KAPPA FITSEDIT, for example.
2 Special_Formats
   In the general case, NDF extensions (excluding the FITS extension)
   may be converted to one-row binary tables in the FITS file when
   parameter PROEXTS is TRUE.  This preserves the information, but it
   may not be accessible to the recipient's FITS reader.  Therefore,
   in some cases it is desirable to understand the meanings of
   certain NDF extensions, and create standard FITS products for
   compatibility.

   At present only one product is supported, but others may be added
   as required.

   o AAO 2dF

   Standard processing is used except for the 2dF FIBRES extension
   and its constituent structures.  The NDF may be restored from the
   created FITS file using FITS2NDF.  The FIBRES extension converts
   to the second binary table in the FITS file (the NDF_CLASS
   extension appears in the first).

   To propagate the OBJECT substructure, NDF2FITS creates a binary
   table of constant width (224 bytes) with one row per fibre.  The
   total number of rows is obtained from component NUM_FIBRES.  If a
   possible OBJECT component is missing from the NDF, a null column
   is written for that component.  The columns inherit the data
   types of the OBJECT structure's components.  Column meanings and
   units are assigned based upon information in the reference given
   below.

   The FIELD structure components are converted into additional
   keywords of the same name in the binary-table header, with the
   exception that components with names longer than 8 characters
   have abbreviated keywords: UNALLOCxxx become UNAL-xxx (xxx=OBJ,
   GUI, or SKY), CONFIGMJD becomes CONFMJD, and xSWITCHOFF become
   xSWTCHOF (x=X or Y).  If any FIELD component is missing it is
   ignored.

   Keywords for the extension level, name, and type appear in the
   binary-table header.
2 References
   Bailey, J.A. 1997, 2dF Software Report 14, version 0.5.
   NASA Office of Standards and Technology, 1994, "A User's Guide
     for the Flexible Image Transport System (FITS)", version 3.1.
   NASA Office of Standards and Technology, 1995, "Definition of
     the Flexible Image Transport System (FITS)", version 1.1.
2 Related_Applications
   CONVERT: FITS2NDF; KAPPA: FITSDIN, FITSIN.
2 Authors
MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 1994 June 3 (MJC):
    Original version.

 1996 September 16 (MJC):
    Corrected usage of CTYPEn (was CRTYPEn) and introduced CUNITn
    for axis units.  Also writes CRPIXn FITS keyword when the NDF
    has linear axis centres.

 1997 January 13 (MJC):
    Added PROHIS parameter and hence the ability to propagate
    history information from the HISTORY component of the NDF
    to the FITS headers.  NDFs from AAO's 2dF instrument are
    recognised and the NDF extensions are converted into a
    special binary table with one row per fibre.

 1997 November 16 (MJC):
    Modified to propagate the revised 2dF extensions.  Thus the
    OBJECT extension generates wider binary tables (from 210 to
    224 bytes).  Now propagates primitive NDF extensions to binary
    tables.

 18-DEC-1997 (DSB):
    Added support for the NDF WCS component.

 1997 January 6 (MJC):
      Correct prologe for DATE and ORIGIN.
    2-FEB-1998 (DSB):
      Add ENCODING examples
    9-NOV-1998 (DSB):
      Added FITS-IRAF encoding. Replaced the ENCODINGS parameter with
      the NATIVE parameter.

 22-JUN-1999 (DSB):
    Added ENCODING parameter

 7-MAR-2000 (DSB):
    Report an error if no usable input NDFs are supplied.

 11-APR-2000 (DSB):
    Added FITS-PC and FITS-AIPS encodings. Default encoding (if
    ENCODING=AUTO) is now chosen on the basis of the contents of
    the FITS extension (because DSS and FITS-WCS can both now
    be used to encode a TAN projection and so we need to look at
    what encoding was used in the original data to make the choice).

 21-AUG-2000 (DSB):
    Converted to use NDG to access the input NDFs.
2 Implementation_Status
   - All NDF data types are supported.
1 NDF2GASP
Converts a two-dimensional NDF into a GASP image.

Usage:

   ndf2gasp in out [fillbad]

Description:

   This application converts a two-dimensional NDF into the Galaxy
   Surface Photometry (GASP) package's format.  See the Notes for the
   details of the conversion.
2 Parameters
For information on individual parameters, select from the list below:
3 IN
IN = NDF (Read)
   The input NDF data structure. The suggested default is the
   current NDF if one exists, otherwise it is the current value.
3 FILLBAD
FILLBAD = _INTEGER (Read)
   The value used to replace bad pixels in the NDF's data array
   before it is copied to the GASP file.  The value must be in the
   range of signed words (-32768 to 32767).  A null value (!)
   means no replacements are to be made.  This parameter is
   ignored if there are no bad values.  [!]
3 OUT
OUT = LITERAL (Write)
   The name of the output GASP image.  Two files are produced
   with the same name but different extensions.  The ".dat" file
   contains the data array, and ".hdr" is the associated header
   file that specifies the dimensions of the image.  The
   suggested default is the current value.
2 Examples
ndf2gasp abell1367 a1367
   Converts an NDF called abell1367 into the GASP image comprising
   the pixel file a1367.dat and the header file a1367.hdr.  If
   there are any bad values present they are copied verbatim to
   the GASP image.

ndf2gasp ngc253 ngc253 fillbad=-1
   Converts the NDF called ngc253 to a GASP image comprising the
   pixel file ngc253.dat and the header file ngc253.hdr.  Any bad
   values in the data array are replaced by minus one.
2 Notes
The rules for the conversion are as follows:

-  The NDF data array is copied to the ".dat" file.

-  The dimensions of the NDF data array is written to the ".hdr"
header file.

-  All other NDF components are ignored.
2 Related_Applications
   CONVERT: GASP2NDF.
2 References
   GASP documentation (MUD/66).
2 Keywords
   CONVERT, GASP
2 Authors
RAHM: Rhys Morris (STARLINK, University of Wales, Cardiff)

MJC: Malcolm J. Currie (STARLINK)
2 History
 18-JAN-1993 (RAHM):
    Original version.

 12-JUL-1993 (RAHM):
    Tidied up code ready for submission to CONVERT package.

 1993 July 28 (MJC):
    Largely rewritten.  Tidied to prologue to the standard style.
2 Implementation_Status
   -  The GASP image produced has by definition type SIGNED WORD.
   There is type conversion of the data array to this type.

   -  Bad values may arise due to type conversion.  These too are
   substituted by the (non-null) value of FILLBAD.

   -  For an NDF with an odd number of columns, the last column from
   the GASP image is trimmed.
1 NDF2GIF
Converts an NDF into a GIF file.

Usage:

   ndf2gif in [out] [scale] {high=? low=?
                            {percentiles=[?,?], [numbin=?]
                            {sigmas=[?,?]

Description:

   This Bourne shell script converts an NDF into a 256 grey-level
   Graphics Interchange Format (GIF) file.  One or two-dimensional
   images can be handled and various methods of scaling the data are
   provided.  The script uses the CONVERT utility NDF2TIFF to produce
   a TIFF file and then various Netpbm utilities to convert the TIFF
   file into a GIF file.

   Error messages are converted into Starlink style (preceded by !).
2 Parameters
For information on individual parameters, select from the list below:
3 IN
   IN = NDF (Read)
      The name of the input NDF (the .sdf extension is not required).
3 OUT
   OUT = FILENAME (Write)
      The name of the GIF file to be generated. (a .gif name extension
      is added if it is omitted.) If OUT is omitted, the value of the 
      IN parameter is used.  Any existing file with the same name will
      be overwritten.

   The following parameters are actually parameters of the ADAM task
   NDF2TIFF. Their values on the NDF2GIF command line are just passed 
   through to NDF2TIFF, which may prompt for other required values.
   The output parameters SCAHIGH and SCALOW will be found in NDF2TIFF's 
   parameter file.

   SCALE = LITERAL (Read)
      The type of scaling to be applied to the array.  [Range]
      The options, which may be abbreviated to an unambiguous string
      and are case-insensitive, are described below:
        "Range"       - The image is scaled between the minimum and
                        maximum data values. (This is the default.)
        "Faint"       - The image is scaled from the mean minus one
                        standard deviation to the mean plus seven
                        standard deviations.
        "Percentiles" - The image is scaled between the values
                        corresponding to two percentiles.
        "Scale"       - You define the upper and lower limits
                        between which the image is to be scaled.  The
                        application suggests the maximum and the
                        minimum values when prompting.
        "Sigmas"      - The image is scaled between two standard-
                        deviation limits.
   HIGH = _DOUBLE (Read)
      Only required if SCALE is "scale".
      The array value that scales to 255 in the TIFF file.
      All larger array values are set to 255 when HIGH is greater than
      LOW, otherwise all array values less than HIGH are set to 255.
      The dynamic default is the maximum data value.  There is an
      efficiency gain when both LOW and HIGH are given on the
      command line, because the extreme values need not be computed.
      The highest data value is suggested in prompts.
   LOW = _DOUBLE (Read)
      Only required if SCALE is "scale".
      The array value that scales to 0 in the TIFF file.
      All smaller array values are also set to 0 when LOW is less than
      HIGH, otherwise all array values greater than LOW are set to 0.
      The dynamic default is the minimum data value.  There is an
      efficiency gain when both LOW and HIGH are given on the
      command line, because the extreme values need not be computed.
      The lowest data value is suggested in prompts.
   NUMBIN  =  _INTEGER (Read)
      Only used if SCALE is "Percentiles".
      The number of histogram bins used to compute percentiles for
      scaling. [2048]
   PERCENTILES( 2 ) = _REAL (Read)
      Only required if SCALE is "Percentiles".
      The percentiles that define the scaling limits. For example,
      [25,75] would scale between the quartile values.
   SIGMAS( 2 ) = _REAL (Read)
      Only required if SCALE is "Sigmas".
      The standard-deviation bounds that define the scaling limits.
      To obtain values either side of the mean both a negative and
      a positive value are required.  Thus [-2,3] would scale
      between the mean minus two and the mean plus three standard
      deviations.  [3,-2] would give the negative of that.
   SCAHIGH = _DOUBLE (Write)
      The array value scaled to the maximum colour index.
   SCALOW = _DOUBLE (Write)
      The array value scaled to the minimum colour index.
   MSG_FILTER = The output message filtering level, QUIET, NORMAL or
      VERBOSE. If set to verbose, the scaling limits used will be
      displayed. [NORMAL]

2 Examples
ndf2gif old new
   This converts the NDF called old (in file old.sdf)
   into a GIF file new.gif

ndf2gif horse scale=percentiles
   This converts the NDF called horse (in file horse.sdf)
   into a GIF file horse.gif using percentile scaling.
   The user will be prompted for the percentiles to use.
2 Notes
- This initial version of the script handles only 256 grey levels
and does not use the image colour lookup table so absolutes data
values may be lost.

- The Netpbm utilities tifftopnm and ppmtogif must be available on 
your PATH.

2 Related_Applications
   CONVERT: GIF2NDF
2 Authors
MJC: Malcolm J. Currie (STARLINK)

GJP: G.J.Privett (Starlink - UWCC)

AJC: A.J.Chipperfield (Starlink - RAL)
2 History
 1995 March 2 (MJC):
    Original conversion.

 1995 October 24 (GJP):
    Added prologue and revised to avoid using KAPPA.

 1995 November 13 (AJC):
    Added default output file, and error reporting and exit at each
    stage.

 1997 July 15 (MJC):
    Used a special tifftopnm for alpha_OSF1.

 1997 October 3 (MJC):
    Improved the parameter handling to allow for no arguments, and
    to remove any .sdf that may be present in the first argument.
    Fixed bug that gave incorrect extraction of the base name.

 1998 November 17 (AJC):
    Rationalise for Netpbm on all platforms.

 1999 March 08 (AJC):
    Added scaling parameters passed to NDF2TIFF
    Use task exit value for NDF2TIFF error checking
    Correct removal of .sdf from end of name
1 NDF2IRAF
Converts an NDF to an IRAF image.

Usage:

   ndf2iraf in out [fillbad]

Description:

   This application converts an NDF to an IRAF image.  See the Notes
   for details of the conversion.
2 Parameters
For information on individual parameters, select from the list below:
3 IN
IN = NDF (Read)
   The input NDF data structure.  The suggested default is the
   current NDF if one exists, otherwise it is the current value.
3 FILLBAD
FILLBAD = _REAL (Read)
   The value used to replace bad pixels in the NDF's data array
   before it is copied to the IRAF file.  A null value (!) means
   no replacements are to be made.  This parameter is ignored if
   there are no bad values.  [0]
3 OUT
OUT = LITERAL (Write)
   The name of the output IRAF image.  Two files are produced
   with the same name but different extensions. The ".pix" file
   contains the data array, and ".imh" is the associated header
   file that may contain a copy of the NDF's FITS extension.
   The suggested default is the current value.
3 PROFITS
PROFITS = _LOGICAL (Read)
   If TRUE, the contents of the FITS extension of the NDF are
   merged with the header information derived from the standard
   NDF components.  See the Notes for details of the merger.
   [TRUE]
3 PROHIS
PROHIS = _LOGICAL (Read)
   If TRUE, any NDF history records are written to the primary
   FITS header as HISTORY cards.  These follow the mandatory
   headers and any merged FITS-extension headers (see parameter
   PROFITS).  [TRUE]
2 Examples
ndf2iraf abell119 a119
   Converts an NDF called abell119 into the IRAF image comprising
   the pixel file a119.pix and the header file a119.imh.  If there
   are any bad values present they are copied verbatim to the IRAF
   image.

ndf2iraf abell119 a119 noprohis
   As the previous example, except that NDF HISTORY records are
   not transferred to the headers in a119.imh.

ndf2iraf qsospe qsospe fillbad=0
   Converts the NDF called qsospe to an IRAF image comprising the
   pixel file qsospe.imh and the header file qsospe.pix.  Any bad
   values in the data array are replaced by zero.

ndf2iraf qsospe qsospe fillbad=0 profits=f
   As the previous example, except that any FITS airlock
   information in the NDF are not transferred to the headers in
   qsospe.imh.
2 Notes
The rules for the conversion are as follows:

-  The NDF data array is copied to the ".pix" file.  Ancillary
information listed below is written to the ".imh" header file in
FITS-like headers.

-  The IRAF "Mini World Co-ordinate System" (MWCS) is used to
record axis information whenever one of the following criteria is
satisfied:

   1) the dataset has some linear axes (system=world);

   2) the dataset is one-dimensional with a non-linear axis, or is
      two-dimensional with the first axis non-linear and the
      second being some aperture number or index
      (system=multispec);

   3) the dataset has a linear spectral/dispersion axis along the
      first dimension and all other dimensions are pixel indices
      (system=equispec).

-  The NDF title, label, units are written to the header keywords
TITLE, OBJECT, and BUNIT respectively if they are defined.
Otherwise any values for these keywords found in the FITS
extension are used (provided parameter PROFITS is TRUE).  There
is a limit of twenty characters for each.

-  The NDF pixel origins are stored in keywords LBOUNDn for the
nth dimension when any of the pixel origins is not equal to 1.

-  Keywords HDUCLAS1, HDUCLASn are set to "NDF" and the
array-component name respectively.

-  The BLANK keyword is set to the Starlink standard bad value,
but only for the _WORD data type and not for a quality array.  It
appears regardless of whether or not there are bad values
actually present in the array.

-  HISTORY headers are propagated from the FITS extension when
PROFITS is TRUE, and from the NDF history component when PROHIS
is TRUE.

-  If there is a FITS extension in the NDF, then the elements up
to the first END keyword of this are added to the `user area' of
the IRAF header file, when PROFITS=TRUE.  However, certain
keywords are excluded: SIMPLE, NAXIS, NAXISn, BITPIX, EXTEND,
PCOUNT, GCOUNT, BSCALE, BZERO, END, and any already created from
standard components of the NDF listed above.

-  A HISTORY record is added to the IRAF header file indicating
that it originated in the named NDF and was converted by
NDF2IRAF.

-  All other NDF components are not propagated.
2 Related_Applications
   CONVERT: IRAF2NDF.
2 Pitfalls
   The IMFORT routines refuse to overwrite an IRAF image if an image
   with the same name exists.  The application then aborts.

   Some of the routines required for accessing the IRAF header image
   are written in SPP. Macros are used to find the start of the
   header line section, this constitutes an `Interface violation' as
   these macros are not part of the IMFORT interface specification.
   It is possible that these may be changed in the future, so
   beware.
2 External_Routines_Used
   IRAF IMFORT subroutine library.
2 References
   IRAF User Handbook Volume 1A: "A User's Guide to FORTRAN
   Programming in IRAF, the IMFORT Interface", by Doug Tody.
2 Keywords
   CONVERT, IRAF
2 Authors
RAHM: Rhys Morris (STARLINK, University of Wales, Cardiff)

MJC: Malcolm J. Currie (STARLINK)
2 History
 21-AUG-1992 (RAHM):
    Original version.

 1992 September 29 (MJC):
    Standardised the prologue.  Corrected the error reporting and
    closedown.  Made the data copying more efficient.  Corrected
    some minor bugs.

 1993 July 21 (MJC):
    Added FILLBAD option, full support for one-dimensional NDFs,
    allow conversion of cubes, and able to make a signed-word IRAF
    image.

 1997 March 28 (MJC):
    Writes keywords for the label, units, axes, history, origin,
    bad value, and class.  Avoid duplication of keywords when merging
    the FITS extension.  Control of propagation of the history
    records and the FITS extension.  Used more efficient workspace
    mechanism.  Restriction to lowercase IRAF file names removed.
    Parameter FILLBAD defaults to 0.

 1997 July 31 (MJC):
    No longer write an END header.  The END keyword is not
    significant in the IRAF headers, and additional headers may be
    written following it.  Added examples.
2 Implementation_Status
   -  Only handles one-, two-, and three-dimensional NDFs.

   -  Of the NDF's array components only the data array may be
   copied.

   -  The IRAF image produced has type SIGNED WORD or REAL dependent
   of the type of the NDF's data array.  (The IRAF IMFORT FORTRAN
   subroutine library only supports these data types.)  For _BYTE,
   _UBYTE, and _WORD data arrays the IRAF image will have type
   SIGNED WORD; for all other data types of the NDF data array a
   REAL IRAF image is made.  The pixel type of the image can be
   changed from within IRAF using the 'chpixtype' task in the
   'images' package.

   -  Bad values may arise due to type conversion.  These too are
   substituted by the (non-null) value of FILLBAD.

   -  See "Release Notes" for IRAF Version compatibility.

1 NDF2PGM
Converts an NDF into a PBMPLUS-style PGM-format file.

Usage:

   ndf2pgm in out

Description:

   This application converts an NDF to a PBMPLUS PGM-format file.
   The programme first finds the brightest and darkest pixel values
   in the image.  It then uses these to determine suitable scaling
   factors convert the image into an 8-bit representation.  These
   are then to a simple greyscale PBMPLUS PGM file.
2 Parameters
For information on individual parameters, select from the list below:
3 IN
IN = NDF (Read)
   The name of the input NDF data structure (without the .sdf
   extension).  The suggested default is the current NDF if one
   exists, otherwise it is the current value.
3 OUT
OUT = _CHAR (Read)
   The name of the PGM file be generated.  The .pgm name
   extension is added to any output filename that does not
   contain it.
2 Examples
ndf2pgm old new
   This converts the NDF called old (in file old.sdf) to the
   PGM file new.pgm.

ndf2pgm in=spectre out=spectre.pgm
   This converts the NDF called spectre (in file spectre.sdf)
   to the PGM file spectre.pgm.
2 Authors
GJP: Grant Privett (STARLINK)

MJC: Malcolm J. Currie (STARLINK)
2 History
 22-Nov-1995 (GJP)
    Original version.

 1996 February 12 (MJC):
    Tidied to standard style.
2 Implementation_Status
   Bad values in the data array are replaced with zero in the output
   PGM file.
1 NDF2TIFF
Converts an NDF into an 8-bit TIFF-6.0-format file.

Usage:

   ndf2tiff in out [scale] {high=? low=?
                           {percentiles=[?,?], [numbin=?]
                           {sigmas=[?,?]

Description:

   This application converts an NDF to a Image File Format (TIFF).
   One- or two-dimensional arrays can be handled and various methods
   of scaling the data are provided.

   The routine first finds the brightest and darkest pixel values
   required by the particular scaling method in use. It then uses
   these to determine suitable scaling factors and converts the image
   into an 8-bit representation which is then output to a simple
   greyscale TIFF-6.0 file.

   If the 'high' scaling value is less than the 'low' value, the output
   image will be a negative. Bad values are set to 0 for positives and
   255 for negatives.
2 Examples
ndf2tiff old new
   This converts the NDF called old (in file old.sdf)
   into a TIFF file new.tif.

ndf2tiff horse horse pe
   This converts the NDF called horse (in file horse.sdf)
   into a TIFF file horse.tif using percentile scaling.
   The user will be prompted for the percentiles to use.
2 Parameters
   IN = NDF (Read)
      Input NDF data structure containing the image to be displayed.
   OUT = _CHAR (Read)
      The name of the TIFF file to be generated.  (A .tif name
      extension is added if it is omitted. Any existing file with
      the same name will be overwritten.
   SCALE = LITERAL (Read)
      The type of scaling to be applied to the array.  [Range]
      The options, which may be abbreviated to an unambiguous string
      and are case-insensitive, are described below:
        "Range"       - The image is scaled between the minimum and
                        maximum data values. (This is the default.)
        "Faint"       - The image is scaled from the mean minus one
                        standard deviation to the mean plus seven
                        standard deviations.
        "Percentiles" - The image is scaled between the values
                        corresponding to two percentiles.
        "Scale"       - You define the upper and lower limits
                        between which the image is to be scaled.  The
                        application suggests the maximum and the
                        minimum values when prompting.
        "Sigmas"      - The image is scaled between two standard-
                        deviation limits.
   HIGH = _DOUBLE (Read)
      Only required if SCALE is "scale".
      The array value that scales to 255 in the TIFF file.
      All larger array values are set to 255 when HIGH is greater than
      LOW, otherwise all array values less than HIGH are set to 255.
      The dynamic default is the maximum data value.  There is an
      efficiency gain when both LOW and HIGH are given on the
      command line, because the extreme values need not be computed.
      The highest data value is suggested in prompts.
   LOW = _DOUBLE (Read)
      Only required if SCALE is "scale".
      The array value that scales to 0 in the TIFF file.
      All smaller array values are also set to 0 when LOW is less than
      HIGH, otherwise all array values greater than LOW are set to 0.
      The dynamic default is the minimum data value.  There is an
      efficiency gain when both LOW and HIGH are given on the
      command line, because the extreme values need not be computed.
      The lowest data value is suggested in prompts.
   NUMBIN  =  _INTEGER (Read)
      Only used if SCALE is "Percentiles".
      The number of histogram bins used to compute percentiles for
      scaling. [2048]
   PERCENTILES( 2 ) = _REAL (Read)
      Only required if SCALE is "Percentiles".
      The percentiles that define the scaling limits. For example,
      [25,75] would scale between the quartile values.
   SIGMAS( 2 ) = _REAL (Read)
      Only required if SCALE is "Sigmas".
      The standard-deviation bounds that define the scaling limits.
      To obtain values either side of the mean both a negative and
      a positive value are required.  Thus [-2,3] would scale
      between the mean minus two and the mean plus three standard
      deviations.  [3,-2] would give the negative of that.
   SCAHIGH = _DOUBLE (Write)
      The array value scaled to the maximum colour index.
   SCALOW = _DOUBLE (Write)
      The array value scaled to the minimum colour index.
   MSG_FILTER = The output message filtering level, QUIET, NORMAL or
      VERBOSE. If set to verbose, the scaling limits used will be
      displayed. [NORMAL]
2 Related_Applications
   TIFF2NDF
2 Authors
GJP: Grant Privett (STARLINK)

MJC: Malcolm J. Currie (STARLINK)

AJC: A.J.Chipperfield (STARLINK)
2 History
 22-Nov-1995 (GJP):
    Original version.

 19-FEB-1996 (MJC):
    Tidied to standard style.

 04-FEB-1999 (AJC):
    Revised version based on KAPPA DISPLAY.
1 NDF2UNF
Converts an NDF to a sequential unformatted file.

Usage:

   ndf2unf in out [comp] [noperec]

Description:

   This application converts an NDF to a sequential unformatted
   Fortran file.  Only one of the array components may be copied to
   the output file.  Preceding the data there is an optional header
   consisting of either the FITS extension with the values of
   certain keywords replaced by information derived from the NDF, or
   a minimal FITS header also derived from the NDF.
2 Parameters
For information on individual parameters, select from the list below:
3 COMP
COMP = LITERAL (Read)
   The NDF component to be copied.  It may be "Data", "Quality"
   or "Variance". ["Data"]
3 FITS
FITS = _LOGICAL (Read)
   If TRUE, any FITS extension is written to start of the output
   file, unless there is no extension whereupon a minimal FITS
   header is written to the unformatted file. [FALSE]
3 IN
IN = NDF (Read)
   Input NDF data structure.  The suggested default is the current
   NDF if one exists, otherwise it is the current value.
3 NOPEREC
NOPEREC = _INTEGER (Read)
   The number of data values per record of the output file.  It
   must be positive.  The suggested default is the current value.
   [The first dimension of the NDF]
3 OUT
OUT = FILENAME (Write)
   Name of the output sequential unformatted file.  The file will
   normally have variable-length records when there is a header,
   but always fixed-length records when there is no header.
2 Examples
ndf2unf cluster cluster.dat
   This copies the data array of the NDF called cluster to an
   unformatted file called cluster.dat.  The number of data values
   per record is equal to the size of the first dimension of the
   NDF.

ndf2unf cluster cluster.dat v
   This copies the variance of the NDF called cluster to an
   unformatted file called cluster.dat.  The number of variance
   values per record is equal to the size of the first dimension
   of the NDF.

ndf2unf cluster cluster.dat noperec=12
   This copies the data array of the NDF called cluster to an
   unformatted file called cluster.dat.  There are twelve data
   values per record in cluster.dat.

ndf2unf out=ndf234.dat fits in=@234
   This copies the data array of the NDF called 234 to an
   unformatted file called ndf234.dat.  The number of data values
   per record is equal to the size of the first dimension of the
   NDF.  If there is a FITS extension, it is copied to ndf234.dat
   with substitution of certain keywords, otherwise a minimal
   FITS header is produced.
2 Notes
The details of the conversion are as follows:

   -  the NDF array as selected by COMP is written to the
   unformatted file in records following an optional header.

   -  HISTORY is not propagated.

   -  ORIGIN information is lost.

   - When a header is to be made, it is composed of FITS-like card
   images as follows:

      -  The number of dimensions of the data array is written
      to the keyword NAXIS, and the actual dimensions to NAXIS1,
      NAXIS2 etc. as appropriate.

      -  If the NDF contains any linear axis structures the
      information necessary to generate these structures is
      written to the FITS-like headers. For example, if a linear
      AXIS(1) structure exists in the input NDF the value of the
      first data point is stored with the keyword CRVAL1,
      and the incremental value between successive axis data is
      stored in keyword CDELT1.  By definition the reference
      pixel is 1.0 and is stored in keyword CRPIX1.  If there is
      an axis label it is written to keyword CTYPE1, and axis
      unit is written to CUNIT1.  (Similarly for AXIS(2)
      structures etc.) FITS does not have a standard method of
      storing axis widths and variances, so these NDF components
      will not be propagated to the header.  Non-linear axis data
      arrays cannot be represented by CRVALn and CDELTn, and must
      be ignored.

      -  If the input NDF contains TITLE, LABEL or UNITS
      components these are stored with the keywords TITLE, LABEL
      or BUNIT respectively.

      -  If the input NDF contains a FITS extension, the FITS
      items may be written to the FITS-like header, with the
      following exceptions:
         o  BITPIX is derived from the type of the NDF data array,
         and so it is not copied from the NDF FITS extension.
         o  NAXIS, and NAXISn are derived from the dimensions of
         the NDF data array as described above, so these items
         are not copied from the NDF FITS extension.
         o  The TITLE, LABEL, and BUNIT descriptors are only
         copied if no TITLE, LABEL, and UNITS NDF components
         respectively have already been copied into these
         headers.
         o  The CDELTn, CRVALn, CTYPEn, CUNITn, and CRTYPEn
         descriptors in the FITS extension are only copied if the
         input NDF contained no linear axis structures.
         o  The standard order of the FITS keywords is preserved,
         thus BITPIX, NAXIS and NAXISn appear immediately after
         the first card image, which should be SIMPLE.
         o  BSCALE and BZERO in a FITS extension are copied when
         BITPIX is positive, i.e. the array is not floating-point.

      -  An extra header record with keyword UNSIGNED and logical
      value T is added when the array data type is one of the HDS
      unsigned integer types.  This is done because standard FITS
      does not support unsigned integers, and allows (in
      conjunction with BITPIX) applications reading the
      unformatted file to determine the data type of the array.

      -  The last header record card will be the standard FITS
      END.

   -  Other extensions are not propagated.
2 Related_Applications
   CONVERT: UNF2NDF.
2 Authors
MJC: Malcolm J. Currie (STARLINK)

AJC: Alan J. Chipperfield (STARLINK)
2 History
 1992 September 16 (MJC):
    Original version.

 1993 August 25 (MJC):
    Corrected the calculations of record lengths.

 1995 November 8 (AJC):
    Set RECMIN to be 80 in all cases where header is required.

 1996 September 16 (MJC):
    Corrected usage of CTYPEn (was CRTYPEn) and introduced CUNITn
    for axis units.  Also writes CRPIXn FITS keyword when the NDF
    has linear axis centres.
2 Implementation_Status
   -  The value of bad pixels is not written to a FITS-like header
   record with keyword BLANK.
1 Parameters
CONVERT is a command-driven package.  Commands have parameters by
which you can qualify their behaviour.  Parameters are obtained in
response to prompts or supplied on a command line.

For convenience, the main aspects of the Starlink parameter system
as seen by a user of CONVERT are described below, but note that most
of what follows is applicable to any Starlink application.

2 Defaults
Command-line values are used mostly for those parameters that are
normally defaulted by the application.   Defaulted parameters enable
applications to have many options, say for controlling the format of
the output file, without making routine operations tedious because
of a large number of prompts.  The values of normally defaulted
parameters are given in the help for each parameter within each
application.  They are enclosed in square brackets at the end of the
parameter descriptions. 
 
     ICL> HELP NDF2DST PARAM * 
 
gives details of all parameters in application NDF2DST.  If you want
to override one of these defaults, then you must specify the
parameter's value on the command line. 

When you are prompted you will usually be given a suggested default
value in / / delimiters.  You can choose to accept the default by
pressing carriage return.  For example, FALSE is the suggested
value below.
 
     DESCRIP - Write the BDF descriptors to the screen? /FALSE/ >
 
Alternatively, enter a different value
 
     DESCRIP - Write the BDF descriptors to the screen? /FALSE/ > T
 
to override the default.  Some defaults begin with an @.
 
     IN - NDF to be converted /@starfield/ > 
 
These are associated with files.  If you want to override the default
given, you do not have to prefix your value with an @, e.g.
 
     IN - NDF to be converted /@starfield/ > horse
 
There are rare cases when the syntax is ambiguous, and it is then
that you need to include the @.  One occasion where you would need
it is when the filename is a number, e.g. if your NDF was called 234
you must enter @234, otherwise the parameter system will think you
are giving the integer 234.  Note that the file extension must not
be included when giving the name of an NDF file.  Otherwise HDS will
look for an object called SDF nested within the file. 

From ICL, the default value can be edited to save typing by first
pressing the <TAB> key.  The editor behaves like the DCL
command-line editor.  Defaults may change as data are processed by
CONVERT.  Often the current (last) value of the parameter will be
substituted, or a dynamic value is suggested depending on the
values of other parameters.

Current values of CONVERT parameters are stored in the HDS file
$ADAM_USER/<application>.sdf, where <application> is the name of
the CONVERT command.  (If the environment variable $ADAM_USER is
not defined the parameter file is situated in $HOME/adam).  Current
values enable the defaults to persist between CONVERT sessions. 
These files should not be deleted unless CONVERT parameters are to
be completely reset. 

2 Globals
CONVERT uses the KAPPA global parameter that records the last NDF
accessed or created, in order to reduce typing in response to
prompts.  Global means that it is shared between applications. 
Thus the suggested input NDF for NDF2x applications is the value of
that global parameter.  If you just press <CR> to the prompt for an
input NDF, the global value is unchanged.  Only when you modify the
parameter and the application completes without error is the global
value updated, and so becomes the suggested default value for the
next prompt for an NDF.  Similarly an x2NDF application updates the
global parameter with the name of the NDF it has just made.

All global parameters are stored in HDS file $ADAM_USER/GLOBAL.sdf
(or $HOME/adam/GLOBAL.sdf when $ADAM_USER is not defined).

2 Strings
The apostrophes around strings given in response to prompts for a
character parameter can be omitted.  Responses to prompts are case
insensitive. 

2 Arrays
If a parameter requires an array of values, the series should be in
brackets separated by commas or spaces.  For example, 

     SHAPE - Shape of the output NDF > [3,5,4]

would input three values: 3, 5 and 4 into the integer parameter
SHAPE.  There is one exception where you can omit the brackets---a
fairly common one---and that is in response to a prompt for a
one-dimensional array as above. 

2 Abort_and_Null
Responding to a prompt with a null value ! will not necessarily
cause the application to abort, but it can force a suitable default
to be used, where this is the most-sensible action.

Responding to a prompt with an abort request !! will abort the
application.  This process includes the various tidying operations
such as the unmapping and closing of files.  Any other method of
stopping a task prematurely can leave files mapped or corrupted.

2 Help
To get help about a parameter enter ?.  This will give access to the
help-library information for that parameter, for example,
 
     RECLEN - Maximum recordsize of the ASCII file. /512/ > ?

     NDF2ASCII

       Parameters

         RECLEN = _INTEGER (Read)
            The maximum record length in bytes of the output file.  This
            must be greater than 31 on UNIX systems.  The lower limit is
            further increased to 80 when there is a FITS header to be
            copied.  It is only used when FIXED is FALSE and will default
            to the current value, or 512 if there is no current value.
            When FIXED is TRUE the application creates data records whose
            length is the product of the number of bytes per value plus
            one (for the space), times the number of values per record.
            []

     RECLEN - Maximum recordsize of the ASCII file. /512/ > 
 
and then immediately reprompt you for the parameter.  There are
occasions when information about the parameter is insufficient; you
may require to examine the examples or the description of related
parameters.  This can be achieved via entering ?? at the prompt.
You can then delve anywhere in the help information.  When you exit
the help system you're reprompted for the parameter.

2 Menus
Some CONVERT parameters are menus from which you select an option.
You do not have to enter the full option string, but merely a string
that selects a choice unambiguously.  In many cases this can be as
little as a single character.  Here is an example.

     TYPE - HDS data type required for NDF /'_REAL'/ ?

     ASCII2NDF

       Parameters

         TYPE = LITERAL (Read)
            The data type of the output NDF.  It must be one of the
            following HDS types: "_BYTE", "_WORD", "_REAL", "_INTEGER",
            "_DOUBLE", "_UBYTE", "_UWORD" corresponding to signed byte,
            signed word, real, integer, double precision, unsigned byte,
            and unsigned word.  See SUN/92 for further details.  An
            unambiguous abbreviation may be given.  TYPE is ignored when
            COMP = "Quality" since the QUALITY component must comprise
            unsigned bytes (equivalent to TYPE = "_UBYTE") to be a valid
            NDF.  The suggested default is the current value.  TYPE is only
            accessed when FITS is FALSE. ["_REAL"]

 
where an _R would be sufficient to select the _REAL type, but at
least two characters would be needed if you wanted unsigned byte
or unsigned word.

2 Environment_Variables
Environment variables operate both on the command line and prompts,
and both from the shell and ICL.  Thus if IMAGEDIR is an environment
variable pointing to a directory containing the NDF called ngc1365,
you could access it at a prompt as shown below.

     IN - Input NDF /@starfield/ > $IMAGEDIR/ngc1365
 
2 Specifying_Parameter_Values_on_Command_Lines
Parameters may be assigned values on the command line. This is
useful for running CONVERT in batch mode and in procedures, and for
specifying the values of parameters that would otherwise be
defaulted.  A command-line parameter will prevent prompting for that
parameter unless there is an error with the given value, say giving
an alphabetic character string where a floating-point value is
demanded.

There are two ways in which parameter values may be given on the
command line: by keyword and by position.  The two forms may be
mixed with care.  The parser looks for positional parameters then
keywords, so you can have some positional values followed by
keyword values.  See some of the "Examples" sub-topics presented in
the help on individual applications.

3 Keyword
Keywords may appear in any order.  Here is an example of
command-line defaults using keywords: 
 
     % ascii2ndf fits type=_real
 
TYPE is a literal parameter.  FITS is a logical parameter; by
giving just its name it is given the value TRUE.  FITS=T would
have the same effect.  To obtain a FALSE value for a logical
parameter add a NO prefix to keyword, for example,
 
     % ascii2ndf nofits
 
would be equivalent to

     % ascii2ndf fits=false

3 Abbreviations
There is an experimental system that allows you to abbreviate
parameter keywords to the minimum unambiguous length.  To use it,
you must first create an environment variable called ADAM_ABBRV
with an arbitrary value.

So for example

     % setenv ADAM_ABBRV true
     % ndf2fits bit=32 co=v 

would convert the variance array of an NDF to FITS using a BITPIX of
32.

If you give an ambiguous keyword, the parameter system will present
the list of possible keywords and ask you to select the one you
intended.  Suppose you want to ensure that ndf2fits merges the
contents of an NDF's FITS extension into the header of the FIT file,
and you think that there is only one paramewter starting with P.

     % ndf2fits p
     !! Ambiguous keyword P used on the command line
     !  Matches with PROEXTS
     !           and PROFITS
       - Specify the keyword unambiguously > PROF

When reprompted you just give an unambiguous abbreviation for the
desired parameter, that being PROFITS in this example.

3 Position
Alternatively, you can specify command-line values by position:
 
     % dst2ndf mydst myndf
 
The application converts the Figaro DST file called mydst.dst to the
NDF called myndf (in file myndf.sdf).  Note that trailing parameters
may be omitted but intermediate ones may not.  The position of a
parameter can be found in the "Usage" topic for the application.

Another consideration is that some parameters do not have defined
positions because they are normally defaulted.  Thus the keyword
technique is recommended for most parameters.

2 Special Keywords:_ACCEPT,_PROMPT,_RESET
Another way in which prompts and default values can be controlled
is by use of the keywords ACCEPT, PROMPT and RESET.

The RESET keyword causes the suggested default value of all
parameters (apart from those already specified before it on the
command line) to be set to the original values specified by the
application or its interface file.  In other words global and
current values are ignored. 

The PROMPT keyword forces a prompt to appear for every application
parameter.  This can be useful if you cannot remember the name of a
defaulted parameter or there would be too much to type on the
command line.  

The ACCEPT keyword forces the parameter system to accept the
suggested default values either for every application parameter if
the keyword appears on the command line, or all subsequent
parameters if it is supplied to a prompt.  In other words, those
parameters which would normally be prompted with a value between
"/ /" delimiters take the value between those delimiters.
Parameters that are normally defaulted behave as usual.  The ACCEPT
keyword needs to be used with care in scripts because not every
parameter has a default, and therefore must be given on the command
line for the application to work properly.

There is a shorthand for ACCEPT---a backslash at the end of the
command line.

     ICL> unf2ndf \

though you would still be prompted for the name of output NDF.

How do you find out which parameters have suggested defaults, as
opposed to those that are normally defaulted?  Well, a good rule of
thumb is that parameters for output files (images, lookup tables and
text) will not have a default, but the remainder will.  Consulting
the description of the parameters should give the suggested
defaults, where appropriate.  If you want to use ACCEPT for an
automatic procedure or batch job you could do some tests to find
which parameters get prompted and then put them on the command line
in your procedure. 

In command lines from the shell, the backslash is a metacharacter
and has to be escaped.  The easiest way to do that is to double the
backslash. 

     % unf2ndf \\
 
The RESET and ACCEPT keywords will work in tandem.  So for instance,

     ICL> ircam2ndf reset accept

will reset the suggested defaults of IRCAM2NDF to their original,
preset values, and accept these as the parameter values.

These special keywords may be abbreviated to no fewer than two
characters, if you have enabled keyword-abbreviation. 
1 SPECX2NDF
Converts a SPECX map into a simple data cube, or SPECX data files
to individual spectra.

Usage:

   specx2ndf in out [gridfile] [telescope] [latitude] [longitude]

Description:

   This application converts a SPECX map file into a simple data cube
   formatted as a standard NDF.  It works on map files in version 4.2
   or later of the SPECX format.  It can optionally write a schematic
   of the map grid to a text file.

   In addition, it will also convert an HDS container file containing
   an array of one-dimensional NDFs holding SPECX spectra into a
   similar container file holding individual, scalar NDFs each
   holding a single spectrum from the supplied array.

   In both cases, WCS components are added to the output NDFs
   describing the spectral and spatial axes.
2 Parameters
For information on individual parameters, select from the list below:
3 GRIDFILE
GRIDFILE  =  LITERAL (Read)
   The name of a text file to which a schematic of the SPECX map
   will be written.  This schematic shows those positions in the
   map grid where spectra were observed.  To indicate that a file
   containing the schematic is not to be written reply with an
   exclamation mark ("!").  See Section 'Schematic of the map
   grid' (below) for further details.  [!]
3 IN
IN  =  NDF (Read)
   The name of the input SPECX map, or container file.  The file
   extension ('.sdf') should not be included since it is appended
   automatically by the application.
3 LATITUDE
LATITUDE  =  LITERAL (Read)
   The geodetic (geographic) latitude of the telescope where the
   observation was made.  The value should be specified in
   sexagesimal degrees, with a colon (':') to separate the
   degrees, minutes and seconds and no embedded spaces.  Values in
   the northern hemisphere are positive.  The default corresponds
   to the latitude of the JCMT.  ["19:49:33"]
3 LONGITUDE
LONGITUDE  =  LITERAL (Read)
   The geodetic (geographic) longitude of the telescope where the
   observation was made.  The value should be specified in
   sexagesimal degrees, with a colon (':') to separate the
   degrees, minutes and seconds and no embedded spaces.  Following
   the usual geographic convention longitudes west of Greenwich
   are positive.  The default corresponds to the longitude of the
   JCMT.  ["155:28:47"]
3 OUT
OUT  =  NDF (Write)
   The name of the output NDF containing the data cube or spectra
   written by the application.  The file extension ('.sdf') should
   not be included since it is appended automatically by the
   application.
3 TELESCOPE
TELESCOPE  =  LITERAL (Read)
   The name of the telescope where the observation was made.
   This parameter is used to look up the geodetic (geographical)
   latitude and longitude of the telescope.  See the documentation
   of subroutine SLA_OBS in SUN/67 for a list of permitted values.
   Alternatively, if you wish to explicitly enter the latitude and
   longitude enter 'COORDS'.  The values are not case sensitive.
   ["JCMT"]
2 Examples
specx2ndf  specx_map  specx_cube
   This example generates an NDF data cube called specx_cube (in
   file specx_cube.sdf) from the NDF SPECX map called specx_map
   (in file specx_map.sdf).  A text file containing a schematic
   of the map grid will not be produced.

specx2ndf  specx_map  specx_cube  gridfile=map.grid
   This example generates an NDF data cube called specx_cube (in
   file specx_cube.sdf) from the NDF SPECX map called specx_map
   (in file specx_map.sdf).  A text file containing a schematic
   of the map grid will be written to file map.grid.
2 Input_and_output_map_formats
   SPECX map files are written by the SPECX package (see SUN/17) for
   reducing spectra observed with heterodyne receivers operating in
   the mm and sub-mm wavelength range of the electromagnetic
   spectrum.  SPECX is usually used to process observations obtained
   with the James Clerk Maxwell Telescope (JCMT) in Hawaii.

   A SPECX map file comprises a regular 'rectangular' two-dimensional
   grid of map positions on the sky, with spectra observed at the
   grid points.  However, a spectrum is not necessarily available at
   every grid position; at some positions a spectrum is not observed
   in order to save observing time.  For example, for a grid centred
   on a typical, roughly circular, object spectra may be omitted for
   the positions at the corners of the grid.  SPECX map files are
   standard Starlink NDF HDS structures.  The principal array of the
   NDF is a two-dimensional array of the grid positions.  The value
   of each element is either a pointer to the spectrum observed there
   (in practice the number of the spectrum in the array where they
   are stored) or a value indicating that a spectrum was not observed
   at this point.  In effect the SPECX map structure is an
   implementation of a sparse array.

   SPECX2NDF expands a SPECX map file into a simple three-dimensional
   data cube, again formatted as a standard NDF, in which the first
   and second pixel axes corresponds to the spatial axes and the
   third axes correspond to the spectral axis.  The advantage of
   this approach is that the converted file can be examined with
   standard applications, such as those in KAPPA (see SUN/95) and
   easily imported into visualisation packages, such as Data Explorer
   (DX, see SUN/203 and SC/2).  When the output data cube is created
   the columns corresponding to the positions on the sky grid where
   spectra were not observed are filled with  'bad' values (sometimes
   called 'magic' or 'null' values), to indicate that valid data are
   not available at these positions.  The standard Starlink bad value
   is used.  Because of the presence of these bad values the expanded
   cube is usually larger than the original map file.

   The created NDF cube has a WCS component in which axes 1 and 2 are
   RA and DEC, and axis 3 is frequency in units of GHz.  The nature of
   these axes can be changed if necessary by subsequent use of the
   WCSATTRIB application within the KAPPA package.  For compatibility
   with older applications, AXIS structures are also added to the
   output cube. Axes 1 and 2 are offsets from the central position of
   the map, with units of seconds of arc, and axis 3 is frequency
   offset in GHz relative to the central frequency.  The pixel origin
   is placed at the source position on axes 1 and 2, and the central
   frequency on axis 3.

   SPECX2NDF reads map files in version 4.2 or later of the SPECX
   data format.  If it is given a map file in an earlier version of
   the data format it will terminate with an error message.  Note,
   however, that SPECX itself can read map files in earlier versions
   of the SPECX format and convert them to version 4.2.
2 Schematic_of_the_map_grid
   SPECX2NDF has an optional facility to write a crude schematic of
   the grid of points observed on the sky to an ASCII text file
   suitable for printing or viewing on a terminal screen.  This
   schematic can be useful in interpreting displays of the data cube.
   It shows the positions on the grid where spectra were observed.
   Each spectrum is numbered within the SPECX map structure and the
   first nine are shown using the digits one to nine.  The remaining
   spectra are shown using an asterisk ('*').  You specify the name
   of the file to which the schematic is written.  The following is
   an example of a schematic:

   Schematic map grid for CO21

      +---------+
     9|         |
     8| 8765432 |
     7|*******9 |
     6|******** |
     5|****1*** |
     4|******** |
     3|******** |
     2|******** |
     1|         |
      +---------+
       123456789
2 Auxiliary_information
   SPECX2NDF copies all the auxiliary information present in the
   original map file to the output data cube.  However, the arrays
   holding the original spectra are not copied in order to save
   disk space.
2 Input_and_output_spectra_formats
   In addition to converting SPECX map files, this application can
   also convert HDS files which hold an array of one-dimensional NDF
   structures, each being a single spectrum extracted by SPECX.
   Since arrays of NDFs are not easily accessed, this application
   extracts each NDF from the array and creates a new scalar NDF
   holding the same data within the output container file.  The name
   of the new NDF is "SPECTRUM<n>" where "<n>" is its index within
   the original array of NDFs.  Each new scalar NDF is actually
   three-dimensional and has the format described above for
   an output cube (i.e. axes 1 and 2 are RA and DEC, and axis 3 is
   frequency). However, pixel axes 1 and 2 span only a single pixel
   (the size of this single spatial pixel is assumed to be half the
   size of the resolution of the JCMT at the central frequency).
   Inclusion of three-dimensional WCS information allows the
   individual spectra to be aligned on the sky (for instance using
   the KAPPA WCSALIGN task).
2 Authors
ACD: A C Davenhall (Edinburgh)

DSB: David S. Berry (STARLINK)
2 History
 25/6/97 (ACD):
    Original version.

 8/1/98  (ACD):
    First stable version.

 17-FEB-2003 (DSB):
    Extensive modifications to replace the original spectral axis
    code by code which adds a WCS component to the output, including
    a SpecFrame. Changed axis order to make spectral axis, axis 3.
1 TIFF2NDF
Converts a TIFF file into an NDF.

Usage:

   tiff2ndf in [out]

Description:

   This Bourne-shell script converts a 256 grey-level or
   black-and-white dithered Tag Image File Format (TIFF) into an
   unsigned-byte NDF file.  It handles one- or two-dimensional
   images.  The script uses various Netpbm utilities to produce a
   FITS file, flipped top to bottom, and then FITS2NDF to produce
   the final NDF.  Error messages are converted into Starlink style
   (preceded by !).
2 Parameters
For information on individual parameters, select from the list below:
3 IN
   IN = FILENAME (Read)
      The name of the TIFF file to be converted. (A .tif name extension
      is assumed if omitted.)
3 OUT
   OUT = NDF (Write)
      The name of the NDF to be generated (without the .sdf extension).
      If the OUT parameter is omitted, the value of the IN parameter
      is used.
2 Examples
tiff2ndf old new
   This converts the TIFF file old.tif into an NDF called old
   (in file old.sdf).

tiff2ndf horse
   This converts the TIFF file horse.tif into an NDF called horse
   (in file horse.sdf).
2 Notes
   This initial version of the script handles only greyscale
   or b/w dithered images.  You are responsible for conversion
   of your images to this format prior to use, including the
   conversion of RGB values to brightness values.

   Input image file names must have the extension .tif

   The Netpbm utilities tifftopnm, ppmtopgm, pnmflip and pnmtofits
   must be available on your PATH.
2 Related_Applications
   CONVERT: NDF2TIFF
2 Authors
MJC: Malcolm J. Currie (STARLINK)

GJP: G.J.Privett (Starlink - UWCC)

AJC: A.J.Chipperfield (Starlink - RAL)
2 History
 1995 March 3 (MJC):
    Original version (GIFs).

 1995 November 2 (GJP):
    Converted to TIFF requirements from GIF.

 1995 November 13 (AJC):
    Added fileout parameter, and error reporting and exit at each
    stage.  Use long temporary filenames.

 1997 August 1 (MJC):
    Removed KAPPA dependencies.  Reworded and reordered the
    description.  Added some comments.  Used a special tifftopnm
    for alpha_OSF1.

 1997 October 3 (MJC):
    Improved the parameter handling to allow for no arguments, and
    to remove any .tif that may be present in the first argument.

 1998 November 17 (AJC):
    Use Netpbm - common for all platforms
      Use pnmtofits not pgmtofits 

 1999 March 11 (AJC):
    Only remove .tif if at end of name
1 UNF2NDF
Converts a sequential unformatted file to an NDF.

Usage:

   unf2ndf in out [comp] noperec [skip] shape [type]

Description:

   This application converts a sequential unformatted Fortran file
   to an NDF.  Only one of the array components may be created from
   the input file.  Preceding the input data there may be an
   optional header.  This header may be skipped, or may consist of a
   simple FITS header.  In the former case the shape of the NDF has
   be to be supplied.
2 Parameters
For information on individual parameters, select from the list below:
3 COMP
COMP = LITERAL (Read)
   The NDF component to be copied.  It may be "Data", "Quality"
   or "Variance".  To create a variance or quality array the NDF
   must already exist. ["Data"]
3 FITS
FITS = _LOGICAL (Read)
   If TRUE, the initial records of the unformatted file are
   interpreted as a FITS header (with one card image per record)
   from which the shape, data type, and axis centres are derived.
   The last record of the FITS-like header must be terminated by
   an END keyword; subsequent records in the input file are
   treated as an array component given by COMP.  [FALSE]
3 IN
IN = FILENAME (Read)
   Name of the input sequential unformatted Fortran file.  The
   file will normally have variable-length records when there is
   a header, but always fixed-length records when there is no
   header.
3 NOPEREC
NOPEREC = _INTEGER (Read)
   The number of data values per record of the input file.  It
   must be positive on UNIX systems.  The suggested default is
   the size of the first dimension of the array if there is no
   current value.  A null (!) value for NOPEREC causes the size
   of first dimension to be used.
3 OUT
OUT = NDF (Read and Write)
   Output NDF data structure.  When COMP is not "Data" the NDF
   is modified rather than a new NDF created.  It becomes the new
   current NDF.
3 SHAPE
SHAPE = _INTEGER (Read)
   The shape of the NDF to be created.  For example, [40,30,20]
   would create 40 columns by 30 lines by 10 bands.  It is only
   accessed when FITS is FALSE.
3 SKIP
SKIP = INTEGER (Read)
   The number of header records to be skipped at the start of the
   input file before finding the data array or FITS-like header.
   [0]
3 TYPE
TYPE = LITERAL (Read)
   The data type of the output NDF.  It must be one of the
   following HDS types: "_BYTE", "_WORD", "_REAL", "_INTEGER",
   "_DOUBLE", "_UBYTE", "_UWORD" corresponding to signed byte,
   signed word, real, integer, double precision, unsigned byte,
   and unsigned word.  See SUN/92 for further details.  An
   unambiguous abbreviation may be given.  TYPE is ignored when
   COMP = "Quality" since the QUALITY component must comprise
   unsigned bytes (equivalent to TYPE = "_UBYTE") to be a valid
   NDF. The suggested default is the current value.  TYPE is only
   accessed when FITS is FALSE. ["_REAL"]
2 Examples
unf2ndf ngc253.dat ngc253 shape=[100,60] noperec=8
   This copies a data array from the unformatted file ngc253.dat
   to the NDF called ngc253.  The input file does not contain a
   header section.  The NDF is two-dimensional: 100 elements in x
   by 60 in y.  Its data array has type _REAL.  The data records
   each have 8 values.

unf2ndf ngc253q.dat ngc253 q 100 shape=[100,60]
   This copies a quality array from the unformatted file
   ngc253q.dat to an existing NDF called ngc253 (such as created
   in the first example).  The input file does not contain a header
   section.  The NDF is two-dimensional: 100 elements in x by 60
   in y.  Its data array has type _UBYTE.  The data records
   each have 100 values.

unf2ndf ngc253.dat ngc253 fits noperec=!
   This copies a data array from the unformatted file ngc253.dat
   to the NDF called ngc253.  The input file contains a FITS-like
   header section, which is copied to the FITS extension of the
   NDF.  The shape of the NDF is controlled by the mandatory FITS
   keywords NAXIS, AXIS1, ..., AXISn, and the data type by
   keywords BITPIX and UNSIGNED.  Each data record has AXIS1
   values (except perhaps for the last).

unf2ndf type="_uword" in=ngc253.dat out=ngc253 \
   This copies a data array from the unformatted file ngc253.dat
   to the NDF called ngc253.  The input file does not contain a
   header section.  The NDF has the current shape and data type
   is unsigned word.  The current number of values per record is
   used.

unf2ndf spectrum zz skip=2 shape=200 noperec=!
   This copies a data array from the unformatted file spectrum to
   the NDF called zz.  The input file contains two header records that
   are ignored.  The NDF is one-dimensional comprising 200
   elements of type _REAL.  There is one data record containing
   the whole array.

unf2ndf spectrum.lis ZZ skip=1 fits noperec=20
   This copies a data array from the unformatted file spectrum.lis
   to the NDF called ZZ.  The input file contains one header
   record, that is ignored, followed by a FITS-like header
   section, which is copied to the FITS extension of the NDF.
   The shape of the NDF is controlled by the mandatory FITS
   keywords NAXIS, AXIS1, ..., AXISn, and the data type by
   keywords BITPIX and UNSIGNED.  Each data record has AXIS1
   values (except perhaps for the last).
2 Notes
The details of the conversion are as follows:

   -  the unformatted-file array is written to the NDF array as
   selected by COMP.  When the NDF is being modified, the shape
   of the new component must match that of the NDF.

   -  If the input file contains a FITS-like header, and a new
   NDF is created, i.e. COMP = "Data", the header records are
   placed within the NDF's FITS extension.  This enables more
   than one array (input file) to be used to form an NDF.  Note
   that the data array must be created first to make a valid NDF,
   and it's the FITS structure associated with that array that is
   wanted.  Indeed the application prevents you from doing
   otherwise.

   -  The FITS-like header defines the properties of the NDF as
   follows:
      o  BITPIX defines the data type: 8 gives _BYTE, 16 produces
      _WORD, 32 makes _INTEGER, -32 gives _REAL, and -64 generates
      _DOUBLE.  For the first two, if there is an extra header
      record with the keyword UNSIGNED and logical value T, these
      types become _UBYTE and _UWORD respectively.  UNSIGNED is
      non-standard, since unsigned integers would not follow in a
      proper FITS file.  However, here it is useful to enable
      unsigned types to be input into an NDF.  UNSIGNED may be
      created by this application's sister, NDF2UNF.  BITPIX is
      ignored for QUALITY data; type _UBYTE is used.
      o  NAXIS, and NAXISn define the shape of the NDF.
      o  The TITLE, LABEL, and BUNIT are copied to the NDF
      TITLE, LABEL, and UNITS NDF components respectively.
      o  The CDELTn, CRVALn, CTYPEn, and CUNITn keywords make
      linear axis structures within the NDF.  CUNITn define the
      axis units, and the axis labels are assigned to CTYPEn If
      some are missing, pixel co-ordinates are used for those
      axes.
      o  BSCALE and BZERO in a FITS extension are ignored.
      o  BLANK is not used to indicate which input array values
      should be assigned to a standard bad value.
      o  END indicates the last header record unless it
      terminates a dummy header, and the actual data is in an
      extension.

   -  Other data item such as HISTORY, data ORIGIN, and axis
   widths are not supported, because the unformatted file has a
   simple structure to enable a diverse set of input files to be
   converted to NDFs, and to limitations of the standard FITS
   header.
2 Related_Applications
   CONVERT: NDF2UNF.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1992 September 18 (MJC):
    Original version.

 1996 September 16 (MJC):
    Corrected usage of CTYPEn (was CRTYPEn) and introduced CUNITn
    for axis units.
1 UNIX_differences

Although the UNIX and VMS implementations of CONVERT are similar, there
are differences, and these are described in the various subtopics
below.

2 Running_applications

To start you must issue the usual CONVERT command, but note that
it must be in lowercase.

     convert

All commands must be given in full and in lowercase.  ICL is not
available and hence there is no ADAM monolith version of CONVERT.  One
consequence is that ADAM parameters cannot be passed easily between
applications using ICL variables.  Since commands are invoked from the
shell some command syntax is interpreted as shell metacharacters.  These
include parenthesis, bracket, quote, double quote and backslash.  A
backslash is needed before each metacharacter for these characters
to be taken literally.  Here are some examples: 

     ndf2gasp image\(100:199,~100\)

or equivalently

     ndf2gasp image"(100:199,~100)"

converts the section of an NDF to a GASP-format file; while

     ascii2ndf picture.dat picture type=_BYTE \\

converts a text file called picture.dat to an NDF called picture with
data type "_BYTE", accepting the suggested defaults for other parameters;
and

     unf2ndf radiant.dat geminid shape=\[70,60\]

copies the data array from the sequential unformatted file radiant.dat
to the NDF called geminid.  The NDF is two-dimensional: 70 elements
in x by 60 in y.

When responding to prompts neither the <TAB> function for editing the
default nor command-line recall is available.

Parameter values are case insensitive except for graphics devices
and filenames.  No file extension is assumed for text or unformatted
sequential files.  (On VMS ".DAT" is assumed if no extension is given.)

2 Help

There is no help command.  You must use conhelp to obtain CONVERT
help.  For example, you should enter

     conhelp dst2ndf

to obtain help on CONVERT's dst2ndf command.

2 Missing_applications

The following applications are not available on UNIX:

   Application    Reason
   -----------    ------

   BDF2NDF        Interim library will not be ported to UNIX
   NDF2BDF            "      "      "      "     "     "

2 HDS_files

Although HDS files are portable you are recommended to copy them to
the host machine, and run KAPPA application native on them for
significant efficiency gains. 

1 Using_Help
 You are situated in a portable HELP library which contains help
 information about CONVERT arranged in an hierarchical structure.  The
 help system enables you to navigate the library by prompting when it
 has completed displaying the previously requested help.  The
 information displayed by the help system on a particular topic
 includes a description of the topic and a list of subtopics that
 further describe the topic.  These topic names are called keywords. 

 At a prompt you may enter:

   o  a topic or subtopic name to display the help for that topic or
      subtopic,

   o  just a <CR> to move up one level in the hierarchy, and if you
      are at the top level it will terminate the help session,

   o  a CTRL/Z on VMS or a CTRL/D on UNIX will terminate the help
      session,

   o  a question mark "?" to redisplay the text for the current topic,
      including the list of topic or subtopic names, or

   o  an ellipsis "..." to display all the text below the current point 
      in the hierarchy.  For example, "GLITCH..." displays information 
      on the GLITCH topic as well as information on all the subtopics
      under GLITCH.

 You can abbreviate any keyword using the following rules:

   1) Just give the first few characters, e.g. 'PARA' for 'Parameters'.

   2) Some keywords are composed of several words separated by
   underscores.  Each word of the keyword may be abbreviated,
   e.g. "Colour_Set" can be shortened to "C_S".

   3) The characters "%" and "*" act as wildcards, where the percent
   sign matches any single character, and asterisk matches any
   sequence of characters.  Thus to display information on all
   available topics, type an asterisk (*) in reply to a prompt.

   4) If a word contains but does end with an asterisk wildcard, it
   must not be truncated.

   5) The entered string must not contain leading or embedded spaces.

 Ambiguous abbreviations result in all matches being displayed. 
 
2 Help_Parameters

 keyword ...

  Specifies one or more keywords that refer to the topic  or  subtopic
  on  which you  want  information from the help library.  Information
  within the help library is arranged in a hierarchical  manner.   The
  levels are:

  1.  None--- If you do not specify a keyword,  CONHELP introduces the 
      help system  and  lists the  top-level topics.  Each item in the
      list is a keyword in the first level of the hierarchy.

  2.  Topic-name---If you specify  a keyword  by naming  a topic,  the
      help facility  describes  the  topic.  Keywords  for  additional
      information available on this topic are listed.

  3.  Topic-name subtopic---If you  specify  a  subtopic  following  a
      topic, the help facility provides a description of the specified
      subtopic.
