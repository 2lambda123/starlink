\newpage
\sstroutine{
   NDF2FITS
}{
   Converts NDFs into FITS files
}{
   \sstdescription{
      This application converts one or more NDF datasets into
      FITS-format files.  NDF2FITS stores any variance and quality
      information in IMAGE extensions (`sub-files') within the FITS
      file; and it uses binary tables to hold any NDF-extension data
      present, except for the FITS-airlock extension, which may be
      merged into the output FITS file's headers.

      You can select which NDF array components to export to the FITS
      file, and choose the data type of the data and variance arrays.
      You can control whether or not to propagate extensions and
      history information.
   }
   \sstusage{
      ndf2fits in out [comp] [bitpix] [origin]
   }
   \sstparameters{
      \sstsubsection{
         BITPIX = LITERAL (Read)
      }{
         The FITS bits-per-pixel (BITPIX) value for each conversion.
         This specifies the data type of the output FITS file.  Permitted
         values are: {\tt 8} for unsigned byte, {\tt 16} for signed word,
         {\tt 32} for integer, {\tt -32} for real, {\tt -64} for double
         precision.  There are two other special values.  BITPIX={\tt 0}
         will cause the output file to have the data type equivalent to
         that of the input NDF.  BITPIX={\tt -1} requests that the
         output file has the data type corresponding to the value of the
         BITPIX keyword in the NDF's FITS extension.  If the extension
         or BITPIX keyword is absent, the output file takes the data
         type of the input array.

         BITPIX values must be enclosed in double quotes and may be a list 
         of comma-separated values to be applied to each conversion in turn.
         An error results if more values than the number of input NDFs are
         supplied.  If too few are given, the last value in the list is
         applied to the remainder of the NDFs; thus a single value is 
         applied to all the conversions.  
         The given values must be in the same order as that of the input NDFs.
         Indirection through a text file may be used.
         If more than one line is required to enter the information at a prompt
         then type a {\tt "-"} at the end of each line where a
         continuation line is desired.
         {\tt [0]}
      }
      \sstsubsection{
         COMP = LITERAL (Read)
      }{
         The list of array components to attempt to transfer to each
         FITS file.  The acceptable values are {\tt "D"} for the main data
         array {\tt "V"} for variance, {\tt "Q"} for quality, or any permutation
         thereof.  The special value {\tt "A"} means all components,
         {\it i.e.}\ COMP=\dqt{DVQ}. Thus COMP=\dqt{VD} requests that 
         both the data array and variance are to be converted if present.  
         During processing at least one, if not all, of the requested
         components must be present, otherwise an error is reported and
         processing turns to the next input NDF.  If the data component
         is in the list, it will always be processed first into the
         FITS primary array.  The order of the variance and quality
         in COMP decides the order they will appear in the FITS file.

         COMP may be a list of comma-separated values to be applied to
         each conversion in turn.  The list must be enclosed in double quotes.
         An error results if more values than
         the number of input NDFs are supplied.  If too few are given,
         the last value in the list is applied to the remainder of the
         NDFs; thus a single value is applied to all the conversions.
         The given values must be in the same order as that of the
         input NDFs.  Indirection through a text file may be used.  If
         more than one line is required to enter the information at a prompt
         then type a {\tt "-"} at the end of each line where a continuation 
         line is desired.  {\tt ["A"]}
      }
      \sstsubsection{
         IN = LITERAL (Read)
      }{
         The names of the NDFs to be converted into FITS format.  It
         may be a list of NDF names or direction specifications
         separated by commas and enclosed in double quotes.  
         NDF names may include the regular
         expressions ({\tt "$*$"}, {\tt "?"}, {\tt "[a-z]"} {\it etc.}).
         Indirection may occur through text files (nested up to seven
         deep).  The indirection character is {\tt "$\wedge$"}.  If extra prompt
         lines are required, append the continuation character {\tt "-"} to
         the end of the line.  Comments in the indirection file begin
         with the character \hash.
      }
      \sstsubsection{
         OUT = LITERAL (Write)
      }{
         The names for the output FITS files.  These may be enclosed in double
         quotes and specified as a list of comma-separated names, OR, using 
         modification elements to specify output filenames based on the input
         NDF filenames.  Indirection may be used if required. 

         The simplest modification element is the asterisk {\tt "$*$"}, which
         means call the output FITS files the same name (without any directory
         specification) as the corresponding input NDF, but with file 
         extension {\tt ".fit"} instead of the NDF's extension of {\tt ".sdf"}.

         Other types of modification can also occur so OUT=\dqt{x$*$}
         would mean that the output files would have the same name
         as the input NDFs except for an {\tt "x"} prefix and the
         file extension of {\tt ".fit"}.  You can also replace a specified
         string in the output filename, for example OUT=\dqt{x$*$|cal|Starlink|}
         replaces the string {\tt "cal"} with {\tt "Starlink"} in any of
         the output names {\tt "x$*$.fit"}.
      }
      \sstsubsection{
         ORIGIN = LITERAL (Read)
      }{
         The origin of the FITS files.  This becomes the value of the
         ORIGIN keyword in the FITS headers.  If a null value is given
         it defaults to {\tt "Starlink Project, U.K."}.
         {\tt [!]}
      }
      \sstsubsection{
         PROEXTS = \_LOGICAL (Read)
      }{
         If {\tt TRUE}, the NDF extensions (other than the FITS extension)
         are propagated to the FITS files as FITS binary-table
         extensions, one per structure of the hierarchy. {\tt [FALSE]}
      }
      \sstsubsection{
         PROFITS = \_LOGICAL (Read)
      }{
         If {\tt TRUE}, the contents of the FITS extension of the NDF are
         merged with the header information derived from the standard
         NDF components.  See the Notes for details of the merger.
         {\tt [TRUE]}
      }
      \sstsubsection{
         PROHIS = \_LOGICAL (Read)
      }{
         If {\tt TRUE}, any NDF history records are written to the primary
         FITS header as HISTORY cards.  These follow the mandatory
         headers and any merged FITS-extension headers (see parameter
         PROFITS). {\tt [TRUE]}
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         ndf2fits horse logo.fit d
      }{
         This converts the NDF called horse to the FITS file called
         {\tt logo.fit}.  The data type of the FITS primary data array matches
         that of the NDF's data array.  The FITS extension in the NDF
         is merged into the FITS header of {\tt logo.fit}.
      }
      \sstexamplesubsection{
         ndf2fits horse logo.fit d proexts
      }{
         This converts the NDF called horse to the FITS file called
         {\tt logo.fit}.  The data type of the FITS primary data array matches
         that of the NDF's data array.  The FITS extension in the NDF
         is merged into the FITS header of {\tt logo.fit}.  In addition any
         NDF extensions (apart from FITS) are turned into binary tables
         that follow the primary header and data unit.
      }
      \sstexamplesubsection{
         ndf2fits horse logo.fit noprohis
      }{
         This converts the NDF called horse to the FITS file called
         {\tt logo.fit}.  The data type of the FITS primary data array matches
         that of the NDF's data array.  The FITS extension in the NDF
         is merged into the FITS header of {\tt logo.fit}.  Should horse
         contain variance and quality arrays, these are written in IMAGE
         extensions.  Any history information in the NDF is not relayed
         to the FITS file.
      }
      \sstexamplesubsection{
         ndf2fits "data/a$*$z" $*$ comp=v noprofits bitpix=-32
      }{
         This converts the NDFs with names beginning with {\tt "a"} and ending
         in {\tt "z"} in the directory called {\tt data} into FITS files of the
         same name and with a file extension of {\tt ".fit"}.  The variance
         array becomes the data array of each FITS file.  The data type
         of the FITS primary data array single-precision floating
         point.  Any FITS extension in the NDF is ignored.
      }
      \sstexamplesubsection{
         ndf2fits "abc,def" "jvp1.fit,jvp2.fit" comp=d  bitpix="16,-64"
      }{
         This converts the NDFs called abc and def into FITS files
         called {\tt jvp1.fit} and {\tt jvp2.fit} respectively.  
         The data type of the FITS primary data array is signed integer words
         in {\tt jvp1.fit}, and double-precision floating point in
         {\tt jvp2.fit}. The FITS extension in each NDFs is merged into the
         FITS header of the corresponding FITS file.
      }
   }
   \sstnotes{
      The rules for the conversion are as follows:
      \ssthitemlist{

         \sstitem
         The NDF main data array becomes the primary data array of the
         FITS file if it is in value of parameter COMP, otherwise the first
         array defined by parameter COMP will become the primary data
         array.  A conversion from floating point to integer or to a
         shorter integer type will cause the output array to be scaled and
         offset, the values being recorded in keywords BSCALE and BZERO.
         There is an offset (keyword BZERO) applied to signed byte and
         unsigned word types to make them unsigned-byte and signed-word
         values respectively in the FITS array (this is because FITS does
         not support these data types).

         \sstitem
         The FITS keyword BLANK records the bad values for integer
         output types.  Bad values in floating-point output arrays are
         denoted by IEEE not-a-number values.

         \sstitem
         The NDF's quality and variance arrays appear in individual
         FITS IMAGE extensions immediately following the primary header
         and data unit, unless that component already appears as the
         primary data array.  The quality array will always be written as
         an unsigned-byte array in the FITS file, regardless of the value
         of the parameter BITPIX.

         \sstitem
         Here are details of the processing of standard items from the
         NDF into the FITS header, listed by FITS keyword.

         \ssthitemlist{

            \sstitem
            SIMPLE, EXTEND, PCOUNT, GCOUNT -- all take their default
              values.

            \sstitem
            BITPIX, NAXIS, NAXISn -- are derived directly from the NDF
              data array;

            \sstitem
            CRVAL{\em{n}}, CDELT{\em{n}}, CRPIX{\em{n}}, CTYPE{\em{n}}, CUNIT{\em{n}} -- are derived from
              the NDF axis structures if possible.  If no linear NDF axis
              structures are present, the values in the NDF FITS extension
              are copied (when parameter PROFITS is {\tt TRUE}).  If any axes
              are non-linear, all FITS axis information is lost.

            \sstitem
            OBJECT, LABEL, BUNIT -- the values held in the NDF's title,
              label, and units components respectively are used if
              they are defined; otherwise any values found in the FITS
              extension are used (provided parameter PROFITS is {\tt TRUE}).

            \sstitem
            ORIGIN and DATE -- are created automatically.  However, the
              former may be overridden by an ORIGIN card in the NDF
              extension.

            \sstitem
            EXTNAME --- is the array-component name when the EXTNAME
              appears in the primary header or an IMAGE extension.  In a
              binary-table derived from an NDF extension, EXTNAME is the
              path of the extension within the NDF, the path separator
              being the usual dot.  The path includes the indices to
              elements of any array structures present; the indices are in
              a comma-separated list within parentheses.

            \sstitem
            EXTLEVEL --- is the level in the hierarchical structure of the
              extensions.  Thus a top-level extension has value 1,
              sub-components of this extension have value 2 and so on.

            \sstitem
            EXTTYPE --- is the data type of the NDF extension used to
              create a binary table.

            \sstitem
            EXTSHAPE --- is the shape of the NDF extension used to
            create a binary table.  It is a comma-separated list of the
            dimensions, and is 0 when the extension is not an array.

            \sstitem
            HDUCLAS1, HDUCLAS{\em{n}} -- {\tt "NDF"} and the
              array-component name respectively.

            \sstitem
            LBOUND{\em{n}} -- is the pixel origin for the $n^{\rm th}$ dimension
              when any of the pixel origins is not equal to 1.  (This is not a
              standard FITS keyword.)

            \sstitem
            XTENSION, BSCALE, BZERO, BLANK and END -- are not propagated
              from the NDF's FITS extension.  XTENSION will be set for
              any extension.  BSCALE and BZERO will be defined based on
              the chosen output data type in comparison with the NDF
              array's type, but cards with values 1.0 and 0.0 respectively
              are written to reserve places in the header section.  These
              `reservation' cards are for efficiency and they can always
              be deleted later.  BLANK is set to the Starlink standard bad
              value corresponding to the type specified by BITPIX, but only
              for integer types and not for the quality array.  It appears
              regardless of whether or not there are bad values actually
              present in the array; this is for the same efficiency reasons
              as before.  The END card terminates the FITS header.

           \sstitem
              HISTORY -- HISTORY headers are propagated from the FITS
              extension when PROFITS is {\tt TRUE}, and from the NDF
              history component when PROHIS is {\tt TRUE}.

         }

         \sstitem
         Extension information may be transferred to the FITS file when
         PROEXTS is {\tt TRUE}.  The whole hierarchy of extensions is propagated
         in order.  This includes substructures, and arrays of extensions
         and substructures.  However, at present, any extension structure
         containing only substructures is not propagated itself (as
         zero-column tables are not permitted), although its
         substructures may be converted.
 
         Each extension or substructure creates a one-row binary table,
         where the columns of the table correspond to the primitive
         (non-structure) components.  The name of each column is the
         component name.  The column order is the same as the component
         order.  The shapes of multi-dimensional arrays are recorded using
         the TDIM$n$ keyword, where $n$ is the column number.  The HEASARCH
         convention for specifying the width of character arrays (keyword
         TFORM$n$='$r$A$w$', where $r$ is the total number of characters in the
         column and $w$ is the width of an element) is used.  The EXTNAME,
         EXTTYPE, EXTSHAPE and EXTLEVEL keywords (see above) are written
         to the binary-table header.

      }
   }
   \sstdiytopic{
      Special Formats
   }{
      In the general case, NDF extensions (excluding the FITS extension)
      may be converted to one-row binary tables in the FITS file when
      parameter PROEXTS is {\tt TRUE}.  This preserves the information, but it
      may not be accessible to the recipient's FITS reader.  Therefore,
      in some cases it is desirable to understand the meanings of
      certain NDF extensions, and create standard FITS products for
      compatibility.

      At present only one product is supported, but others may be added
      as required.

      \sstitemlist{

         \sstitem
         AAO 2dF

         Standard processing is used except for the 2dF FIBRES extension
         and its constituent structures.  The NDF may be restored from the
         created FITS file using FITS2NDF.  The FIBRES extension converts
         to the second binary table in the FITS file (the NDF\_CLASS
         extension appears in the first).

         To propagate the OBJECT substructure, NDF2FITS creates a binary
         table of constant width (210 bytes) with one row per fibre.  The
         total number of rows is obtained from component NUM\_FIBRES.  If a
         possible OBJECT component is missing from the NDF, a null column
         is written for that component.  The columns inherit the data
         types of the OBJECT structure's components.  Column meanings and
         units are assigned based upon information in the reference given
         below.

         The FIELD structure components are converted into additional
         keywords of the same name in the binary-table header, with the
         exception that components with names longer than 8 characters
         have abbreviated keywords: UNALLOC$xxx$ become UNAL-$xxx$ ($xxx$=OBJ,
         GUI, or SKY), CONFIGMJD becomes CONFMJD, and $x$SWITCHOFF become
         $x$SWTCHOF ($x$=X or Y).  If any FIELD component is missing it is
         ignored.

         Keywords for the extension level, name, and type appear in the
         binary-table header.
      }
   }
   \sstdiytopic{
      References
   }{
      \begin{refs}
      \item Bailey, J.A. 1996, 2dF Software Report 14, version 0.3.
      \item NASA Office of Standards and Technology, 1994, {\it A User's Guide
       for the Flexible Image Transport System (FITS)}, version 3.1.
      \item NASA Office of Standards and Technology, 1995, {\it Definition of
       the Flexible Image Transport System (FITS)}, version 1.1.
      \end{refs}
   }
   \sstdiytopic{
      Related Applications
   }{
      \CONVERT: \htmlref{FITS2NDF}{FITS2NDF};
      \KAPPA: \xref{FITSDIN}{sun95}{FITSDIN}, \xref{FITSIN}{sun95}{FITSIN}.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         All NDF data types are supported.
      }
   }
}

