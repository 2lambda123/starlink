#include "sae_par.h"
#include "cupid.h"
#include "star/pda.h"
#include <math.h>

/* Local constants: */
#define LV 71+CUPID__GCNP3*(CUPID__GCNP3+15)/2
#define LIV 60

/* Global Variables: */
/* ================= */
/* A structure holding the global parameters of the GaussClump algorithm 
   needed by this function. These are set by function cupidGaussClumps. */
extern CupidGC cupidGC;


int CGEN_FUNCTION(cupidGCFit)( CGEN_TYPE *res, int imax, double *x,
                               double *chisq ){
/*
*  Name:
*     cupidGCFit<X>

*  Purpose:
*     Fit a Gaussian to a supplied peak in a supplied array.

*  Synopsis:
*     int cupidGCFit<X>( CGEN_TYPE *res, int imax, double *x, double *chisq );

*  Description:
*     This function fits a Gaussian to a peak in the supplied residuals
*     array.

*  Parameters:
*     res
*        Pointer to the start of the 1D array containing the current
*        residuals. 
*     imax
*        The index within the supplied array of the element with the largest 
*        value. 
*     x 
*        A pointer to an array containing the initial guess at the
*        Gaussian parameters. The array is returned holding the best fit
*        parameter values. How many of these are used depends on the number
*        of pixel axes in the data "ndim": if ndim is 1 only elements 0 to 
*        3 are used, if ndim is 2 only elements 0 to 6 are used, if ndim
*        is 3 all elements are used. All axis values are represented in GRID 
*        pixels: 
*
*           x[0]: Peak intensity of clump ("a0" in Stutski & Gusten)
*           x[1]: Constant intensity offset ("b0" in Stutski & Gusten)
*           x[2]: Model centre on axis 0 ("x1_0" in Stutski & Gusten)
*           x[3]: Intrinsic FWHM on axis 0 ("D_xi_1" in Stutski & Gusten)
*           x[4]: Model centre on axis 1 ("x2_0" in Stutski & Gusten)
*           x[5]: Intrinsic FWHM on axis 1 ("D_xi_2" in Stutski & Gusten)
*           x[6]: Spatial orientation angle ("phi" in Stutski & Gusten)
*                 In rads, positive from +ve GRID1 axis to +ve GRID2 axis.
*           x[7]: Model centre on velocity axis ("v_0" in Stutski & Gusten)
*           x[8]: Intrinsic FWHM on velocity axis ("D_xi_v" in Stutski & 
*                                                   Gusten)
*           x[9]: Axis 0 of internal velocity gradient vector ("alpha_0" 
*                 in Stutski & Gusten), in vel. pixels per spatial pixel.
*           x[10]: Axis 1 of internal velocity gradient vector ("alpha_1" 
*                 in Stutski & Gusten), in vel. pixels per spatial pixel.
*     chisq
*        A pointer to a location at which to return the chi-squared
*        associated with the returned fit.

*  Returned Value:
*     Non-zero if the fit was succesfully completed.

*  Notes:
*     - The peak intensity and background offset values returned in "x" 
*     are in units of the RMS noise within the data.
*     - This function can be invoked using the generic cupidGCFit macro 
*     defined in cupid.h. This macro has the same parameter list as 
*     cupidGCFit<X> except that an extra parameter is added to the start 
*     of the parameter list indicating the data type of the specific 
*     cupidGCFit... function to be invoked. This extra parameter should
*     be an integer and should be one of CUPID__DOUBLE, CUPID__FLOAT, etc.

*  Authors:
*     DSB: David S. Berry
*     {enter_new_authors_here}

*  History:
*     18-OCT-2005 (DSB):
*        Original version.
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}
*/      

/* Local Variables: */
   double d[ CUPID__GCNP3 ]; /* Scale factors for each parameter */
   int n;                    /* Number of free parameters */
   int ret;                  /* Returned value */
   int i;                    /* Loop count */
   int iv[ LIV ];            /* Flags controlling pdsSumsl */
   double v[ LV ];           /* Work array and control values for pdaSumsl */


/* Initialise. */
   ret = 0;

/* Abort if an error has already occurred. */
   if( *status != SAI__OK ) return ret;

/* Set the number of parameters for the Gaussian, depending on the
   dimensionality of the data. Also, set up an array of scale values 
   for each parameter being fitted. */
   if( cupidGC.ndim == 1 ) {
      n = CUPID__GCNP1;

   } else if( cupidGC.ndim == 2 ) {
      n = CUPID__GCNP2;

   } else {
      n = CUPID__GCNP3;
   }

/* This block of code is used for testing the calculation of gradients by
   cupidGCcalg. Uncomment it when debugging gradient mis-calculations. 
   {  double f;
      double f0;
      double g[ CUPID__GCNP3 ];
      int nf;
      double dx;

      nf = 1;
      cupidGCcalcf( n, x, &nf, &f0 );
      cupidGCcalcg( n, x, &nf, g );
      
      for( i = 0; i < n; i++ ) {
         nf++;
         dx = 0.000001*x[ i ];
         if( dx == 0.0 ) dx = 1.0E-6;
         x[ i ] += dx;
         cupidGCcalcf( n, x, &nf, &f );
         printf("Par %d: %g %g %g\n", i, f, f0, dx );
         printf("        %g %g\n", (f - f0)/dx, g[ i ] );
         x[ i ] -= dx;
      }
      
      return 0;
   }
*/

/* Initialise an array of scale values for each parameter being fitted. */
   for( i = 0; i < n; i++ ) d[ i ] = 1.0;

/* Set default values for the configuration parameters in "iv". */
   iv[ 0 ] = 0;
   pdaDeflt( 2, iv, LIV, LV, v);

/* Override the default for the maximum number of function evaluations allow. */
   iv[ 16 ] = cupidGC.maxnf;

/* Call the minimisation function. */
   pdaSumsl( n, d, x, cupidGCcalcf, cupidGCcalcg, iv, LIV, LV, v );

/* See if convergence was achieved. */
   ret = ( iv[ 0 ] < 7 );

/* Check none of the parameters are Nan */
   for( i = 0; i < n; i++ ) {
      if( !finite( x[ i ] ) ) {
         ret = 0;
         break;
      }
   }

/* Return the final chi-squared value */
   *chisq = v[ 9 ];

/* Return the result */
   return ret;  
}

