#include "sae_par.h"
#include "ast.h"
#include "cupid.h"
#include <string.h>

/* A structure used to describe a filter box. The "slabs" refered to are
   the single pixel thick slabs forming the 6 faces of the 3D filter box. */
typedef struct CGEN_FUNCTION(MeanFilterBox) {
   int lbndxu[ 3 ];    /* Lower grid index bounds of upper x slab */
   int ubndxu[ 3 ];    /* Upper grid index bounds of upper x slab */
   int lbndyu[ 3 ];    /* Lower grid index bounds of upper y slab */
   int ubndyu[ 3 ];    /* Upper grid index bounds of upper y slab */
   int lbndzu[ 3 ];    /* Lower grid index bounds of upper z slab */
   int ubndzu[ 3 ];    /* Upper grid index bounds of upper z slab */
   int lbndxl[ 3 ];    /* Lower grid index bounds of lower x slab */
   int ubndxl[ 3 ];    /* Upper grid index bounds of lower x slab */
   int lbndyl[ 3 ];    /* Lower grid index bounds of lower y slab */
   int ubndyl[ 3 ];    /* Upper grid index bounds of lower y slab */
   int lbndzl[ 3 ];    /* Lower grid index bounds of lower z slab */
   int ubndzl[ 3 ];    /* Upper grid index bounds of lower z slab */
   CGEN_TYPE total;    /* Sum of all good data values in box */
   int ngood;          /* Number of good data values in box */
} CGEN_FUNCTION(MeanFilterBox);


CGEN_TYPE *CGEN_FUNCTION(cupidFindback4)( int dim[3], int box[3],
                                          CGEN_TYPE *din, CGEN_TYPE *dout, 
                                          int *status ){
/*
*+
*  Name:
*     cupidFindback4<X>

*  Purpose:
*     Apply a mean box filter to a supplied array.

*  Language:
*     Starlink C

*  Synopsis:
*     CGEN_TYPE *cupidFindback4<X>( int dim[3], int box[3],
*                                   CGEN_TYPE *din, CGEN_TYPE *dout, 
*                                   int *status )

*  Description:
*     This function smooths the supplied array with a filter that
*     replaces every input pixel with the mean of the good input pixels 
*     within a box of specified size centred on the pixel being replaced.

*  Parameters:
*     dim
*        The length of each pixel axis in the supplied array.
*     box
*        The dimensions of the the box filter, in pixels.
*     din
*        Pointer to the start of the supplied data array. 
*     dout
*        Pointer to the start of the output data array. May be NULL, in
*        which case a new array will be allocated, and a pointer returned
*        as the function value. Note, the "din" value should not be
*        supplied for "dout" (i.e. the input array cannot also be used as
*        the output array).
*     status
*        Pointer to the inherited status value.

*  Returned Value:
*     A pointer to a (possibly new) array holding the smoothed output
*     values.

*  Copyright:
*     Copyright (C) 2006 Particle Physics & Astronomy Research Council.
*     All Rights Reserved.

*  Licence:
*     This program is free software; you can redistribute it and/or
*     modify it under the terms of the GNU General Public License as
*     published by the Free Software Foundation; either version 2 of
*     the License, or (at your option) any later version.
*
*     This program is distributed in the hope that it will be
*     useful, but WITHOUT ANY WARRANTY; without even the implied
*     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
*     PURPOSE. See the GNU General Public License for more details.
*
*     You should have received a copy of the GNU General Public License
*     along with this program; if not, write to the Free Software
*     Foundation, Inc., 59 Temple Place,Suite 330, Boston, MA
*     02111-1307, USA

*  Authors:
*     DSB: David S. Berry
*     {enter_new_authors_here}

*  History:
*     13-SEP-2006 (DSB):
*        Original version.
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}

*-
*/

/* Local Variables: */
   CGEN_FUNCTION(MeanFilterBox) *xbox; /* Structure describing x axis filter box */
   CGEN_FUNCTION(MeanFilterBox) *ybox; /* Structure describing y axis filter box */
   CGEN_FUNCTION(MeanFilterBox) *zbox; /* Structure describing z axis filter box */
   CGEN_TYPE *p;               /* Pointer to next returned pixel */
   CGEN_TYPE *result;          /* Returned array */
   CGEN_TYPE val;              /* Input pixel value */
   CupidBoxIter *iter;         /* Structure for iterating round pixels */
   int bk1;                    /* Half the x box width */
   int bk2;                    /* Half the y box width */
   int bk3;                    /* Half the z box width */
   int iv;                     /* 1D vector index of current pixel */
   int ix;                     /* X axis grid index for current output pixel */
   int iy;                     /* Y axis grid index for current output pixel */
   int iz;                     /* Z axis grid index for current output pixel */
   int lbnd[ 3 ];              /* Lower bounds of box centred on (0,0,0) */
   int nel;                    /* Number of pixel in supplied array */
   int ubnd[ 3 ];              /* Upper bounds of box centred on (0,0,0) */
   int xx[ 3 ];                /* Grid indices of current pixel */

/* Abort if an error has already occurred. */
   if( *status != SAI__OK ) return NULL;

/* Form useful constants. */
   bk1 = box[ 0 ]/2;
   bk2 = box[ 1 ]/2;
   bk3 = box[ 2 ]/2;

/* Indicate we do not yet have a CupidBoxIter structure. */
   iter = NULL;

/* Allocate the memory for the output array if needed. */
   if( !dout ) {
      nel = dim[ 0 ]*dim[ 1 ]*dim[ 2 ];
      result = astMalloc( sizeof( CGEN_TYPE )*nel );
   } else {
      result = dout;
   }

/* Create a MeanFilterBox structure to describe a filter box that progress
   up the Z axis at (x=0,y=0). */
   zbox = astMalloc( sizeof( CGEN_FUNCTION(MeanFilterBox) ) );

/* Create a MeanFilterBox structure to describe a filter box that progress
   up the Y axis at (x=0). */
   ybox = astMalloc( sizeof( CGEN_FUNCTION(MeanFilterBox) ) );

/* Create a MeanFilterBox structure to describe a filter box that progress
   up the X axis. */
   xbox = astMalloc( sizeof( CGEN_FUNCTION(MeanFilterBox) ) );

/* Check the pointers can be used safely. */
   if( xbox ) {

/* We first initialise the zbox to describe the contents of a filter box
   centred on pixel (0,0,0). First set up the bounds of the box centred
   on pixel (0,0,0). */
      lbnd[ 0 ] = -bk1;
      ubnd[ 0 ] = bk1;
      lbnd[ 1 ] = -bk2;
      ubnd[ 1 ] = bk2;
      lbnd[ 2 ] = -bk3;
      ubnd[ 2 ] = bk3;

/* Now form the bounds of the slab of pixels forming the ZY face at the
   upper bound on the X axis. */
      zbox->lbndxu[ 0 ] = ubnd[ 0 ];
      zbox->lbndxu[ 1 ] = lbnd[ 1 ];
      zbox->lbndxu[ 2 ] = lbnd[ 2 ];
      zbox->ubndxu[ 0 ] = ubnd[ 0 ];
      zbox->ubndxu[ 1 ] = ubnd[ 1 ];
      zbox->ubndxu[ 2 ] = ubnd[ 2 ];

/* Now form the bounds of the slab of pixels forming the ZY face at the
   lower bound on the X axis. */
      zbox->lbndxl[ 0 ] = lbnd[ 0 ];
      zbox->lbndxl[ 1 ] = lbnd[ 1 ];
      zbox->lbndxl[ 2 ] = lbnd[ 2 ];
      zbox->ubndxl[ 0 ] = lbnd[ 0 ];
      zbox->ubndxl[ 1 ] = ubnd[ 1 ];
      zbox->ubndxl[ 2 ] = ubnd[ 2 ];

/* Now form the bounds of the slab of pixels forming the XZ face at the
   upper bound on the Y axis. */
      zbox->lbndyu[ 0 ] = lbnd[ 0 ];
      zbox->lbndyu[ 1 ] = ubnd[ 1 ];
      zbox->lbndyu[ 2 ] = lbnd[ 2 ];
      zbox->ubndyu[ 0 ] = ubnd[ 0 ];
      zbox->ubndyu[ 1 ] = ubnd[ 1 ];
      zbox->ubndyu[ 2 ] = ubnd[ 2 ];

/* Now form the bounds of the slab of pixels forming the XZ face at the
   lower bound on the Y axis. */
      zbox->lbndyl[ 0 ] = lbnd[ 0 ];
      zbox->lbndyl[ 1 ] = lbnd[ 1 ];
      zbox->lbndyl[ 2 ] = lbnd[ 2 ];
      zbox->ubndyl[ 0 ] = ubnd[ 0 ];
      zbox->ubndyl[ 1 ] = lbnd[ 1 ];
      zbox->ubndyl[ 2 ] = ubnd[ 2 ];

/* Now form the bounds of the slab of pixels forming the ZY face at the
   upper bound on the Z axis. */
      zbox->lbndzu[ 0 ] = lbnd[ 0 ];
      zbox->lbndzu[ 1 ] = lbnd[ 1 ];
      zbox->lbndzu[ 2 ] = ubnd[ 2 ];
      zbox->ubndzu[ 0 ] = ubnd[ 0 ];
      zbox->ubndzu[ 1 ] = ubnd[ 1 ];
      zbox->ubndzu[ 2 ] = ubnd[ 2 ];

/* Now form the bounds of the slab of pixels forming the XY face at the
   lower bound on the Z axis. */
      zbox->lbndzl[ 0 ] = lbnd[ 0 ];
      zbox->lbndzl[ 1 ] = lbnd[ 1 ];
      zbox->lbndzl[ 2 ] = lbnd[ 2 ];
      zbox->ubndzl[ 0 ] = ubnd[ 0 ];
      zbox->ubndzl[ 1 ] = ubnd[ 1 ];
      zbox->ubndzl[ 2 ] = lbnd[ 2 ];

/* Loop round all the pixels in this initial box, adding the good pixel 
   values into the filter box. */
      zbox->total = 0.0;
      zbox->ngood = 0;
      iter = cupidBoxIterator( iter, dim, lbnd, ubnd, 1, status );
      while( cupidNextIt( iter, xx, &iv, status ) ) {
         val = din[ iv ];
         if( val != CGEN_BAD ) {
            zbox->total += val;
            zbox->ngood++;
         }
      }

/* Store a pointer to the next output pixel to be assigned a value. */
      p = result;

/* Now loop through all the xy planes in the cube. */
      for( iz = 1; iz <= dim[ 2 ]; iz++ ) {

/* Increment the Z axis bounds of the volume containing the new pixels to be 
   added to the filter box. This volume is a slab of pixels in the xy plane, 
   one pixel thick in the z direction. It forms the slab of pixels just
   above the upper face of the current z box volume. */
         zbox->lbndzu[ 2 ]++;
         zbox->ubndzu[ 2 ]++;

/* Loop through the pixels in this slab, adding the good pixel values into 
   the filter box. */
         iter = cupidBoxIterator( iter, dim, zbox->lbndzu, zbox->ubndzu, 1, 
                              status );
         while( cupidNextIt( iter, xx, &iv, status ) ) {
            val = din[ iv ];
            if( val != CGEN_BAD ) {
               zbox->total += val;
               zbox->ngood++;
            }
         }

/* Loop through the pixels in the volume containing the old pixels to be 
   removed from the filter box. This volume is a slab of pixels in the xy 
   plane, one pixel thick in the z direction. It forms the slab of pixels 
   that form the lower face of the current z box volume. */
         iter = cupidBoxIterator( iter, dim, zbox->lbndzl, zbox->ubndzl, 1, 
                              status );
         while( cupidNextIt( iter, xx, &iv, status ) ) {
            val = din[ iv ];
            if( val != CGEN_BAD ) {
               zbox->total -= val;
               zbox->ngood--;
            }
         }

/* Increment the Z axis bounds of this slab. */
         zbox->lbndzl[ 2 ]++;
         zbox->ubndzl[ 2 ]++;

/* Modify the z value of the other bounds (not used above but used
   below). */
         zbox->lbndxu[ 2 ]++;
         zbox->ubndxu[ 2 ]++;
         zbox->lbndyu[ 2 ]++;
         zbox->ubndyu[ 2 ]++;

         zbox->lbndxl[ 2 ]++;
         zbox->ubndxl[ 2 ]++;
         zbox->lbndyl[ 2 ]++;
         zbox->ubndyl[ 2 ]++;

/* Initialise the Y filter box for this xy plane to be a copy of the z
   filter box. */
         memcpy( ybox, zbox, sizeof( CGEN_FUNCTION(MeanFilterBox) ) );

/* Now loop through the rows in this xy plane. */
         for( iy = 1; iy <= dim[ 1 ]; iy++ ) {

/* Increment the Y axis bounds of the volume containing the new pixels to be 
   added to the filter box (this volume is a slab of pixels in the xz plane, 
   one pixel thick in the y direction). */
            ybox->lbndyu[ 1 ]++;
            ybox->ubndyu[ 1 ]++;

/* Loop through the pixels in this slab, adding the good pixel values into 
   the filter box. */
            iter = cupidBoxIterator( iter, dim, ybox->lbndyu, ybox->ubndyu, 1, 
                                 status );
            while( cupidNextIt( iter, xx, &iv, status ) ) {
               val = din[ iv ];
               if( val != CGEN_BAD ) {
                  ybox->total += val;
                  ybox->ngood++;
               }
            }

/* Loop through the pixels in the volume containing the old pixels to be 
   removed from the filter box (a slab of pixels in the xz plane, one pixel 
   thick in the y direction), removing the good pixel values from the 
   filter box. */
            iter = cupidBoxIterator( iter, dim, ybox->lbndyl, ybox->ubndyl, 1, 
                                 status );
            while( cupidNextIt( iter, xx, &iv, status ) ) {
               val = din[ iv ];
               if( val != CGEN_BAD ) {
                  ybox->total -= val;
                  ybox->ngood--;
               }
            }

/* Increment the Y axis bounds of this slab. */
            ybox->lbndyl[ 1 ]++;
            ybox->ubndyl[ 1 ]++;

/* Modify the y value of the other bounds (not used above but used
   below). */
            ybox->lbndxu[ 1 ]++;
            ybox->ubndxu[ 1 ]++;
            ybox->lbndxl[ 1 ]++;
            ybox->ubndxl[ 1 ]++;

/* Initialise the x box  to be a copy of the modified y box. */
            memcpy( xbox, ybox, sizeof( CGEN_FUNCTION(MeanFilterBox) ) );

/* Now loop through the pixels in this new x row. */
            for( ix = 1; ix <= dim[ 0 ]; ix++ ) {

/* Increment the X axis bounds of the volume containing the new pixels to be 
   added to the filter box (this volume is a slab of pixels in the zy plane, 
   one pixel thick in the x direction). */
               ( xbox->lbndxu[ 0 ] )++;
               ( xbox->ubndxu[ 0 ] )++;

/* Loop through the pixels in this slab, adding the good pixel values into 
   the filter box. */
               iter = cupidBoxIterator( iter, dim, xbox->lbndxu, xbox->ubndxu, 1, 
                                    status );
               while( cupidNextIt( iter, xx, &iv, status ) ) {
                  val = din[ iv ];
                  if( val != CGEN_BAD ) {
                     xbox->total += val;
                     xbox->ngood++;
                  }
               }

/* Loop through the pixels in the volume containing the old pixels to be 
   removed from the filter box (a slab of pixels in the zy plane, one pixel 
   thick in the x direction), removing the good pixel values from the 
   filter box. */
               iter = cupidBoxIterator( iter, dim, xbox->lbndxl, xbox->ubndxl, 1, 
                                    status );
               while( cupidNextIt( iter, xx, &iv, status ) ) {
                  val = din[ iv ];
                  if( val != CGEN_BAD ) {
                     xbox->total -= val;
                     xbox->ngood--;
                  }
               }

/* Increment the X axis bounds of this slab. */
               ( xbox->lbndxl[ 0 ] )++;
               ( xbox->ubndxl[ 0 ] )++;

/* Store the output value. */
               if( xbox->ngood > 0 ) {
                  *(p++) = xbox->total/xbox->ngood;
               } else {
                  *(p++) = CGEN_BAD;
               }
            }
         }
      }
   }

/* Free resources. */
   xbox = astFree( xbox );
   ybox = astFree( ybox );
   zbox = astFree( zbox );
   iter = astFree( iter );

/* Return the result. */
   return result;

}
