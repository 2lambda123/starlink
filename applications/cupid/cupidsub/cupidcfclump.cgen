#include "sae_par.h"
#include "cupid.h"
#include "ast.h"
#include "mers.h"

/* Global Variables: */
/* ================= */
/* A structure holding the global parameters of the GaussClump algorithm 
   used to communicate with the service functions cupidGCcalcf and
   cupidGCcalcg called by the PDA minimisation function. The contents of
   this structure are initialised in cupidSetInit. */
CupidGC cupidGC;

int CGEN_FUNCTION(cupidCFClump)( CGEN_TYPE *ipd, double *ipv, int *ipa, 
                                 double rms, int velax, int nel, int ndim, 
                                 int dims[3], int skip[3], int *slbnd, 
                                 int ilevel, CupidPixelSet *ps, double *sum, 
                                 double *par, int *list_size, double **mlist, 
                                 int **plist ){
/*
*  Name:
*     cupidCFClump<X>

*  Purpose:
*     Gather the information needed to produce an HDS clump structure.

*  Synopsis:
*     int cupidCFClump<X>( CGEN_TYPE *ipd, double *ipv, int *ipa, double rms, 
*                          int velax, int nel, int ndim, int dims[3], 
*                          int skip[3], int *slbnd, int ilevel, 
*                          CupidPixelSet *ps, double *sum, double *par, 
*                          int *list_size, double **mlist, int **plist )

*  Description:
*     This function gathers the information needed to produce an HDS clump 
*     structure from a PixelSet describing a clump.

*  Parameters:
*     ipd
*        Pointer to the start of the supplied data array. 
*     ipa
*        Pointer to the start of the array holding the integer index
*        (if any) associated with each pixel in the data array. This
*        shows which clump each pixel belongs to (each clump is identified 
*        by a unique integer index). The array should be the same shape and 
*        size as the data array. Pixels which have not yet been assigned
*        to a clump are marked with the integer value CUPID__CFNULL.
*     nel
*        The total number of elements in the data array. 
*     ndim
*        The number of pixel axes in the data array.
*     dims
*        The number of pixels on each pixel axis of the data array. This
*        array should have 3 elements even if "ndim" is less than 3, and
*        the extra elements should be filled with 1's.
*     skip
*        The increment in 1D vector index required to move a distance of 1 
*        pixel along each axis. This allows conversion between indexing
*        the array using a single 1D vector index and using nD coords. This
*        array should have 3 elements even if "ndim" is less than 3, and
*        the extra elements should be filled with zero's.
*     slbnd
*        Pointer to an array holding the lower pixel index bound of the
*        data array on each axis.
*     ilevel
*        Diagnostic information level.
*     ps
*        Pointer to the PixelSet from which an HDS clump is to be created.
*     sum
*        Location at which to return the total data sum in the clump.
*        This excludes the background level returned in "par[1]".
*     par
*        Pointer to an array in which to return the parameters of a Gaussian
*        approximation to the clump. How many of these are used depends on 
*        the value of "ndim": if "ndim" is 1 only elements 0 to 3 are used, 
*        if "ndim" is 2 only elements 0 to 6 are used, if "ndim" is 3 all 
*        elements are used. All axis values are represented in GRID pixels: 
*
*           par[0]: The actual peak intensity of the supplied data (note, 
*                   NOT the peak of the fitted Gaussian) above the
*                   background
*           par[1]: Constant background level
*           par[2]: Grid coord of actual peak value (NOT fitted peak) on axis 0
*           par[3]: Intrinsic FWHM on axis 0 (in pixels)
*           par[4]: Grid coord of actual peak value (NOT fitted peak) on axis 1
*           par[5]: Intrinsic FWHM on axis 1 (in pixels)
*           par[6]: Spatial orientation angle (in radians, positive from 
*                   +ve GRID1 axis to +ve GRID2 axis).
*           par[7]: Model centre on internal axis 3 (velocity) (in pixels)
*           par[7]: Grid coord of actual peak value (NOT fitted peak) on axis 2
*           par[8]: Intrinsic FWHM on velocity axis (in pixels)
*           par[9]: Axis 0 of internal velocity gradient vector (in velocity
*                   pixels per spatial pixel).
*           par[10]: Axis 1 of internal velocity gradient vector (in
*                   velocity pixels per spatial pixel).
*     list_size
*        A location in which to return the number of pixels described n
*        the the "mlist" and "plist" arrays.
*     mlist
*        A location at which to return a pointer to a dynamically
*        allocated array holding the clump data value at each pixel in
*        the clump. If this is not NULL on entry, then the memory located
*        will be re-used.
*     plist
*        A location at which to return a pointer to a dynamically allocated 
*        array holding the grid coords at each pixel in the clump. If this is 
*        not NULL on entry, then the memory located will be re-used. The
*        grid coords of each pixel are stored in "ndim" consecutive elements 
*        of this array.

*  Returned Value:
*     Non-zero if a clump structure was created. 

*  Notes:
*     - This function can be invoked using the generic cupidCFClump macro 
*     defined in cupid.h. This macro has the same parameter list as 
*     cupidCFClump<X> except that an extra parameter is added to the start 
*     of the parameter list indicating the data type of the specific 
*     cupidCFClump... function to be invoked. This extra parameter should
*     be an integer and should be one of CUPID__DOUBLE, CUPID__FLOAT, etc.

*  Authors:
*     DSB: David S. Berry
*     {enter_new_authors_here}

*  History:
*     5-DEC-2005 (DSB):
*        Original version.
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}
*/      

/* Local Variables: */
   double *pm;      /* Pointer to next value in "mlist" */
   double chisq;    /* Chi squared value for gaussian fit. */
   double d;        /* Pixel value */
   int *pp;         /* Pointer to next value in "plist" */
   int *v1;         /* Pointer to element at start of this row */
   int *v2;         /* Pointer to element at start of this plane */
   int *v;          /* Pointer to next array element */
   int bel;         /* No. of elements in PixelSet bounding box */
   int i;           /* GRID axis 1 value of next array element */
   int imax;        /* 1D vector index of peak pixel value */
   int index;       /* Index value of the supplied PixelSet */
   int j;           /* GRID axis 2 value of next array element */
   int k;           /* GRID axis 3 value of next array element */
   int ret;         /* Returned value */

/* Initialise */
   *list_size = 0;
   *sum = 0;
   ret = 0;

/* Abort if an error has already occurred. */
   if( *status != SAI__OK ) return ret;

/* Note the index value used to identify pixels within the PixelSet.*/
   index = ps->index;

/* Get the number of pixels in the bounding box of the PixelSet. */
   bel = ( ps->ubnd[ 0 ] - ps->lbnd[ 0 ] + 1 )*
         ( ps->ubnd[ 1 ] - ps->lbnd[ 1 ] + 1 )*
         ( ps->ubnd[ 2 ] - ps->lbnd[ 2 ] + 1 );

/* Allocate memory for the returned arrays. Ensure the arrays are the
   largest possible size needed. */
   *mlist = astGrow( *mlist, bel, sizeof( double ) );
   *plist = astGrow( *plist, bel*ndim, sizeof( int ) );
   if( *plist ) {

/* Get a pointer to the assignment value of the first pixel in the PixelSet 
   bounding box. If the data  has less than 3 axes, the unused upper and 
   lower bounds will be set to [1,1] and so we can always pretend there are 
   3 axes. */ 
      v = ipa + ( ps->lbnd[ 0 ] - 1 ) + ( ps->lbnd[ 1 ] - 1 )*skip[ 1 ] + 
                ( ps->lbnd[ 2 ] - 1 )*skip[ 2 ];

/* Pointers to the next elements in *mlist and *plist. */
      pm = *mlist;
      pp = *plist;

/* Loop round the pixels in the PixelSet bounding box. */
      for( k = ps->lbnd[ 2 ]; k <= ps->ubnd[ 2 ]; k++ ) {
         v2 = v;
         for( j = ps->lbnd[ 1 ]; j <= ps->ubnd[ 1 ]; j++ ) {
            v1 = v;
            for( i = ps->lbnd[ 0 ]; i <= ps->ubnd[ 0 ]; i++ ) {

/* If this pixel is in the PixelSet, store its value and grid coords
   within the returned lists and update the data sum. */
               if( *v == index ) {
                  d = ipd[ v - ipa ];
                  *(pm++) = d;
                  *(pp++) = i;
                  if( ndim > 1 ) {
                     *(pp++) = j;
                     if( ndim > 2 ) *(pp++) = k;
                  }

/* Increment the list size. */
                  (*list_size)++;

/* Increment the total data sum in the clump. */
                  *sum += d;
               }
               
/* Get the pointer to the next pixel in the PixelSet bounding box. */
               v++;
            }
            v = v1 + skip[ 1 ];
         }
         v = v2 + skip[ 2 ];
      }

/* Get the 1D vector indexof the peak valuein the PixelSet. */
      imax = ps->peak[ 0 ];
      if( ndim > 1 ) {
         imax += ps->peak[ 1 ]*skip[ 1 ];
         if( ndim > 2 ) imax += ps->peak[ 2 ]*skip[ 2 ];
      }

/* Store the information level in the cupidGC structure, from where it
   can be accessed from the service routines which evaluate the objective
   function for the fitting routine. */
      cupidGC.ilevel = ilevel;

/* Fit a Gaussian to the data in the clump. First make an initial guess at the 
   Gaussian clump parameters centred on the current peak. */
      CGEN_FUNCTION(cupidGCSetInit)( ipd, ipv, ndim, dims, imax, rms,
                                     NULL, 1, velax, par, slbnd );

/* Find the best fitting parameters, starting from the above initial guess. 
   This returns a function value of zero if no fit could be performed. */
      if( CGEN_FUNCTION(cupidGCFit)( ipd, imax, par, &chisq ) ) {
         ret = 1;

/* Convert the background value from a multiple of the RMS noise, to an
   absolute data value. */
         par[ 1 ] *= rms;

/* Subtract the background level from the returned data sum. */
         *sum -= (*list_size)*par[ 1 ];

/* Store the peak value minus the background level. This is the actual
   peak value, not the peak of the fitted gaussian. */
         par[ 0 ] = ps->vpeak - par[ 1 ];

/* Store the grid coords at the peak value. This is the actual peak
   position, not the position of the peak of the fitted gaussian. */
         par[ 2 ] = ps->peak[ 0 ];
         if( ndim > 1 ) {
            par[ 4 ] = ps->peak[ 1 ];
            if( ndim > 2 ) par[ 7 ] = ps->peak[ 2 ];
         }

/* Tell the user clump properties. */
         if( ilevel > 2 ) {
            msgSetd( "P", par[ 0 ] );
            msgOut( "", "   Peak value: ^P", status );
      
            msgSetd( "P", par[ 1 ] );
            msgOut( "", "   Background value: ^P", status );
      
            msgSetd( "P", *sum );
            msgOut( "", "   Integrated peak data sum: ^P", status );
      
            msgSeti( "P", ps->peak[ 0 ] + slbnd[ 0 ] - 1 );
            for( j = 1; j < ndim; j++ ) {
               msgSetc( "P", "," );
               msgSeti( "P", ps->peak[ j ] + slbnd[ j ] - 1 );
            }
            msgOut( "", "   Peak centre: (^P)", status );
      
            msgSetd( "P", ps->pop );
            msgOut( "", "   Population: ^P pixels", status );
      
            msgBlank( status );
         }
   
      } else if( ilevel > 2 ) {
         msgOut( "", "   No Gaussian fit can be made to this clump.", status );
      }

/* Free resources */
      cupidGC.data = astFree( cupidGC.data );
      cupidGC.weight = astFree( cupidGC.weight );
      cupidGC.res = astFree( cupidGC.res );
      cupidGC.resu = astFree( cupidGC.resu );
      cupidGC.initmodel = astFree( cupidGC.initmodel );
      cupidGC.model = astFree( cupidGC.model );
      cupidGC.resids = astFree( cupidGC.resids );
   }

/* Return the flag indicating if the gaussian was fitted succesfully. */
   return ret;

}

