#include "sae_par.h"
#include "cupid.h"
#include "mers.h"
#include "ast.h"
#include "ndf.h"
#include <math.h>
#include <stdio.h>

/* Global Variables: */
/* ================= */
/* A structure holding the global parameters of the GaussClump algorithm 
   needed by the service functions cupidGCcalcf and cupidGCcalcg called
   by the PDA minimisation function. This structure is declared in
   cupidGaussClumps, and its contents are initialised by this function. */
extern CupidGC cupidGC;

void CGEN_FUNCTION(cupidGCUpdateArrays)( CGEN_TYPE *res, CGEN_TYPE *ipd, int nel, int ndim,
                                         int *dims, double *par, double rms,
                                         double mlim, int imax, int ilevel, 
                                         int *lbnd, HDSLoc **ndfs, int iclump, 
                                         int diag, double mean_peak ){
/*
*  Name:
*     cupidGCUpdateArrays<X>

*  Purpose:
*     Remove the fit from the residuals array.

*  Synopsis:
*     void cupidGCUpdateArrays<X>( CGEN_TYPE *res, CGEN_TYPE *ipd, int nel, 
*                                  int ndim, int *dims, double *par, 
*                                  double rms, double mlim, int imax, 
*                                  int ilevel, int *lbnd, HDSLoc **ndfs, 
*                                  int iclump, int diag, double mean_peak )

*  Description:
*     This function removes the supplied Gaussian from the residuals array
*     (it does not remove the backgroudd level). It also creates an NDF
*     holding the data values associated with the clump.

*  Parameters:
*     res
*        Pointer to the start of the residuals array. May be NULL.
*     ipd
*        Pointer to the start of the supplied data array. May be NULL.
*     nel
*        The number of elements in the supplied array. 
*     ndim
*        The number of pixel axes in the array.
*     dims
*        The number of pixels on each pixel axis of the array, using
*        external axis ordering (i.e. the axis ordering within the data file).
*     par
*        Pointer to an array holding the parameters describing thw Gaussian 
*        clump to be removed from the residuals array. 
*     rms
*        The RMS noise level.
*     mlim
*        The lowest value (normalised to the RMS noise level) at which
*        model Gaussian should be evaluated.
*     imax
*        Index within "res" of highest value (only used if "res" is not
*        NULL).
*     ilevel
*        Level of information to display on standard output.
*     lbnd
*        Pointer to array holding the pixel indices of the first pixel in
*        the user-supplied NDF.
*     ndfs
*        Pointer to a location containing an HDS locator for an array of
*        NDF structures. If the HDS locator is NULL on entry a new HDS
*        object is created and its locator stored in place of the NULL 
*        pointer. The array of NDF structures is extended by one, and the
*        new NDF in thre array describes the supplied clump. If the
*        supplied pointer is NULL, no HDS array or NDF is created.
*     iclump
*        Clump index.
*     diag
*        Include extra diagnostic information in output catalogue?
*     mean_peak
*        The mean value of the most recent fitted peak values.

*  Notes:
*     - This function can be invoked using the generic cupidGCUpdateArrays macro 
*     defined in cupid.h. This macro has the same parameter list as 
*     cupidGCUpdateArrays<X> except that an extra parameter is added to the start 
*     of the parameter list indicating the data type of the specific 
*     cupidGCUpdateArrays... function to be invoked. This extra parameter should
*     be an integer and should be one of CUPID__DOUBLE, CUPID__FLOAT, etc.

*  Authors:
*     DSB: David S. Berry
*     {enter_new_authors_here}

*  History:
*     5-OCT-2005 (DSB):
*        Original version.
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}
*/      

/* Local Variables: */
   AstKeyMap *extra;      /* Keymap holding extra diagnostic information */
   CGEN_TYPE r0;          /* Supplied residual at initial peak */
   CGEN_TYPE r;           /* Current residual value */
   char name[ 40 ];       /* Buffer for NDF name to receive dumped residuals */
   double *mlist;         /* Pointer to list holding model valus */
   double bg;             /* Background for model */
   double d;              /* Displacement from initial peak position */
   double m;              /* Model value */
   double maxr;           /* Maximum remaining residual value */
   double meanr;          /* Mean of remaining residual values */
   double minr;           /* Minimum remaining residual value */
   double shiftsq;        /* Square of displacement from initial peak position */
   double sigr;           /* Std dev of remaining residual values */
   double sum;            /* Integrated clump intensity */
   double sumr2;          /* Sum of squares of remaining residual values */
   double sumr;           /* Sum of remaining residual values */
   double xx[ 3 ];        /* Internal coords of current pixel */
   double yy[ 3 ];        /* External coords of current pixel */
   int *plist;            /* Pointer to list holding pixel indices */
   int *pnext;            /* Pointer to next element in plist */
   int area;              /* Total area of clump in pixels */
   int area_off;          /* Area of clump outside the data array, in pixels */
   int extend[ 3 ][ 2 ];  /* Flags indicating which box faces to extend */
   int face_done;         /* Has the face been evaluated? */
   int first;             /* Is this is the first model evaluation? */
   int i;                 /* Element index */
   int iax;               /* Axis index */
   int iedge;             /* Consider the upper limit on current axis? */
   int ilist;             /* Index into the plist and mlist arrays */
   int j;                 /* Vector index within input array */
   int jax;               /* Axis index */
   int lbox[ 3 ];         /* Lower bounds of model evaluation box */
   int lface[ 3 ];        /* Lower bounds of face being evaluated */
   int list_size;         /* Number of values stored in plist and mlist */
   int more;              /* Does the evaluation box need to be extended? */
   int nr;                /* Number of remaining residual values */
   int ok;                /* Is the pixel within the bounds of the NDF? */
   int peakok;            /* Is some of the peak usable? */
   int ubox[ 3 ];         /* Upper bounds of model evaluation box */
   int uface[ 3 ];        /* Upper bounds of face being evaluated */
   size_t psize;          /* Bytes required for one pixel position */

/* Abort if an error has already occurred. */
   if( *status != SAI__OK ) return;

/* Note the original value at the initial peak position. */
   r0 = res ? res[ imax ] : 1.0;

/* Temporaily set the backgound of the model clump to zero. */
   bg = par[ 1 ];
   par[ 1 ] = 0.0;

/* Initialise the GRID bounds of the box over which the model Gaussian is to
   be evaluated so that it covers only the pixel containing the peak of
   the model. */
   ubox[ 0 ] = lbox[ 0 ] = (int)( par[ 2 ] + 0.5 );
   if( ndim > 1 ) {
      ubox[ 1 ] = lbox[ 1 ] = (int)( par[ 4 ] + 0.5 );
      if( ndim > 2 ) {
         ubox[ 2 ] = lbox[ 2 ] = (int)( par[ 7 ] + 0.5 );
      }
   }

/* Reduce the upper bound on the first axis by one so that the central
   pixel is evaluated on the first pass through the following algorithm. */
   ubox[ 0 ]--;

/* We evaluate the model at increasing radii, like the layers of an onion,
   until a "layer" is found for which the model Gaussian does not exceed
   a given user-supplied value at any point on the layer. This particular 
   onion is cuboid rather than spherical. That is, each "layer" is actually 
   a box, with faces parallel to the pixel axes. The "extend" array is
   used to hold flags saying whether we need to extend each individual face
   to a larger radius. Initially, assume all faces need to be extended. */
   for( jax = 0; jax < ndim; jax++ ) {
      for( iedge = 0; iedge < 2; iedge++ ) extend[ jax ][ iedge ] = 1;
   }

/* Reserve memory for a list of model values and associated pixel indices.
   These arrays will be extended as necessary.  */
   mlist = astMalloc( sizeof( double )*cupidGC.nel );
   psize = sizeof( int )*ndim;
   plist = astMalloc( psize*cupidGC.nel );
   list_size = 0;

/* Now loop over increasingly larger layers until a layer is found over which 
   the model Gaussian does not exceed the user-supplied limit. */   
   more = 1;
   first = 1;
   peakok = 0;
   sum = 0.0;
   area = 0;
   area_off = 0;
   while( more ){
      more = 0;

/* Consider each surface of the box forming the current layer. */
      for( iax = 0; iax < ndim; iax++ ) {
         for( iedge = 0; iedge < 2; iedge++ ) {

/* If this face does not need to be extended, pass on to the next face.
   If it does, we extend it by 1 pixel now. Assume to begin with that it
   will not need to be extended any further. */
            if( extend[ iax ][ iedge ] ) {
               more = 1;
               extend[ iax ][ iedge ] = 0;

               if( iedge ) {
                  lbox[ iax ]--;
               } else {
                  ubox[ iax ]++;
               }

/* Set up the GRID bounds of the section representing this face. Also set
   the GRID coords of the first point to test. Also, get the corresponding 
   N-dimensional GRID indices in the input array. This allows for any 
   permutation of the pixels axes necessary to make the velocity axis the 
   third axis. */
               for( jax = 0; jax < ndim; jax++ ) {
                  yy[ cupidGC.dax[ jax ] ] = xx[ jax ] = lface[ jax ] = lbox[ jax ];
                  uface[ jax ] = ubox[ jax ];
               }

               if( iedge ) {
                  uface[ iax ] = lface[ iax ];
               } else {
                  yy[ cupidGC.dax[ iax ] ] = xx[ iax ] = lface[ iax ] = uface[ iax ];
               }

/* Now loop round all the pixels on the face. */
               face_done = 0;
               while( !face_done ){

/* Get the corresponding 1-dimensional index into the input array. Also check
   it is within the bounds of the array. */
                  ok = 1;
                  j = 0;
                  for( jax = ndim - 1; jax >= 0; jax-- ) {
                     if( yy[ jax ] < 1 || yy[ jax ] > dims[ jax ] ) {
                        ok = 0;
                        break;
                     } else {
                        j = yy[ jax ] + j*dims[ jax ] - 1;
                     }
                  }         

/* Find the Gaussian model value at the current pixel. This excludes any 
   background level because the background value in "par" was set to zero 
   before entring this loop. */
                  m = cupidGCModel( ndim, xx, par, -1, 1, first );
                  first = 0;

/* If the model value is higher than the supplied limit, indicate that the
   face needs to be extended further. */
                  if( m > mlim ) {
                     extend[ iax ][ iedge ] = 1;

/* Scale the model using the RMS noise so that it has the same normalisation 
   as the residuals and input data, and then add it to the total clump sum. */
                     m *= rms;
                     sum += m;

/* Count the total number of pixels contributing to the peak. */
                     area++;

/* If this pixel is within the data array, update the residuals array. */
                     if( ok ) {

/* Indicate the peak is usable */
                        peakok = 1;

/* Subtract the model value from the residuals (if good). */
                        if( res && res[ j ] != CGEN_BAD ) res[ j ] -= (CGEN_TYPE) m;

/* Add this model value and its associated pixel indices into the lists */
                        ilist = list_size++;
                        mlist = astGrow( mlist, list_size, sizeof( double ) );
                        plist = astGrow( plist, list_size, psize );
                        mlist[ ilist ] = m;
                        pnext = plist + ilist*ndim;
                        for( jax = 0; jax < ndim; jax ++ ) {
                           pnext[ jax ] = (int) ( yy[ jax ] + 0.5 );
                        }

/* If this pixel is not within the data array, count the number of
   off-image pixels encountered. */
                     } else {
                        area_off++;
                     }
                  }

/* Get the grid coords of the next pixel in the section currently being 
   fitted. This assumes fortran ordering of the elements in the arrays, and 
   assumes the velocity axis (if any) is axis 3. */
                  jax = 0;
                  xx[ jax ] += 1.0;
                  yy[ cupidGC.dax[ jax ] ] = xx[ jax ];
                  while( xx[ jax ] > uface[ jax ] ) {
                     xx[ jax ] = lface[ jax ];
                     yy[ cupidGC.dax[ jax ] ] = xx[ jax ];

                     if( ++jax == ndim ) {
                        face_done = 1;
                        break;
                     }
                     xx[ jax ] += 1.0;
                     yy[ cupidGC.dax[ jax ] ] = xx[ jax ];
                  }
               }
            }
         }
      }
   }

/* Set the specified element of the residuals array bad if the fit was
   unusable.  This prevents the any subsequent attempt to fit a Gaussian 
   to the same peak value.*/
   if( res && ( !peakok || res[ imax ] == r0  ) ) res[ imax ] = CGEN_BAD;

/* Re-instate the original backgound value. */
   par[ 1 ] = bg;

/* Get the statistics of the modified residuals. */
   minr = VAL__MAXD;
   maxr = -VAL__MAXD;
   sumr = 0.0;
   sumr2 = 0.0;
   nr = 0;

   if( res && ipd ) {
      for( i = 0; i < nel; i++ ) {
         if( res[ i ] != CGEN_BAD ) {
            r = res[ i ];
            if( r < minr ) minr = r;
            if( r > maxr ) maxr = r;
            sumr += r;
            sumr2 += r*r;
            nr++;

         }
      }
   
      meanr = sumr/nr;
      sigr = sqrt( sumr2/nr - meanr*meanr );

   } else {
      meanr = 0.0;
      sigr = 0.0;
   }

/* Display info */
   if( ilevel > 3 ) {
      msgSetd( "V", sum );
      msgSeti( "N", area );
      msgOut( "", "   Integrated clump intensity: ^V (in ^N pixels)", status );

      if( area_off ) {
         msgSeti( "N", area_off );
         msgOut( "", "   (the clump overlaps the edge of the data array)", status );
      }
   }

/* Dump the residuals to disk if required. */
   if( ilevel > 4 ) {
      sprintf( name, "clump_residuals%d", iclump ); 
      CGEN_FUNCTION(cupidGCDump)( res, ndim, dims, name );   
   }

/* If required, create an NDF holding the clump data values. */
   if( ndfs ) {

/* Modify the box to exclude the border of bad pixels. */
      for( jax = 0; jax < ndim; jax++ ) {
         if( ubox[ jax ] - lbox[ jax ] > 1 ) {
            lbox[ jax ]++;
            ubox[ jax ]--;
         }
      }

/* Create extra diagnostic info if required (meant for debugging). */
      if( diag ) {
         extra = astKeyMap( "" );
         astMapPut0D( extra, "NITFIT", (double) cupidGC.nf, NULL );
         astMapPut0D( extra, "CHISQ", cupidGC.chisq, NULL );
         astMapPut0D( extra, "INITPEAK", cupidGC.initpars[0]*rms, NULL );
         astMapPut0D( extra, "INITBACK", cupidGC.initpars[1]*rms, NULL );

         d = par[ 2 ] - cupidGC.initpars[ 2 ];
         shiftsq = d*d;

         astMapPut0D( extra, "INITFWHM1", cupidGC.initpars[3], NULL );
         if( ndim > 1 ) {
            d = par[ 5 ] - cupidGC.initpars[ 5 ];
            shiftsq += d*d;
            astMapPut0D( extra, "INITFWHM2", cupidGC.initpars[5], NULL );
            if( ndim > 2 ) {
               d = par[ 7 ] - cupidGC.initpars[ 7 ];
               shiftsq += d*d;
               astMapPut0D( extra, "INITFWHM3", cupidGC.initpars[8], NULL );
            }
         }

         astMapPut0D( extra, "SHIFT", sqrt(shiftsq), NULL );
         astMapPut0D( extra, "BG", bg, NULL );
         astMapPut0D( extra, "MAXR", maxr, NULL );
         astMapPut0D( extra, "SUMR", sumr, NULL );
         astMapPut0D( extra, "MEANR", meanr, NULL );
         astMapPut0D( extra, "SIGMAR", sigr, NULL );
         astMapPut0D( extra, "MEANPEAK", mean_peak, NULL );

      } else {
         extra = NULL;
      }

/* Create the NDF. */
      cupidGCNdfClump( ndfs, sum, diag ? par : NULL, rms, ndim, lbox, ubox, 
                       list_size, mlist, plist, lbnd, iclump, cupidGC.dax, 
                       extra );

/* Free resources */
      if( extra ) extra = astAnnul( extra );
   }

   mlist = astFree( mlist );
   plist = astFree( plist );

}

