#include "sae_par.h"
#include "cupid.h"
#include "mers.h"

/* Global Variables: */
/* ================= */
/* A structure holding the global parameters of the GaussClump algorithm 
   needed by the service functions cupidGCcalcf and cupidGCcalcg called
   by the PDA minimisation function. This structure is declared in
   cupidGaussClumps, and its contents are initialised by this function. */
extern CupidGC cupidGC;

void CGEN_FUNCTION(cupidGCUpdateArrays)( CGEN_TYPE *res, int nel, int ndim,
                                         int *dims, double *par, double rms,
                                         double mlim, int imax, CGEN_TYPE *out,
                                         int ilevel, float *rmask, char *cloc ){

/*
*  Name:
*     cupidGCUpdateArrays<X>

*  Purpose:
*     Remove the fit from the residuals array, and add it onto the total
*     fit array.

*  Synopsis:
*     void cupidGCUpdateArrays<X>( CGEN_TYPE *res, int nel, int ndim,
*                                  int *dims, double *par, double rms,
*                                  double mlim, int imax, CGEN_TYPE *out,
*                                  int ilevel, float *rmask, char *cloc )

*  Description:
*     This function removes the supplied Gaussian from the residuals array.

*  Parameters:
*     res
*        Pointer to the start of the residuals array. May be NULL.
*     nel
*        The number of elements in the supplied array. 
*     ndim
*        The number of pixel axes in the array.
*     dims
*        The number of pixels on each pixel axis of the array, using
*        external axis ordering (i.e. the axis ordering within the data file).
*     par
*        Pointer to an array holding the parameters describing thw Gaussian 
*        clump to be removed from the residuals array. 
*     rms
*        The RMS noise level.
*     mlim
*        The lowest value (normalised to the RMS noise level) at which
*        model Gaussian should be evaluated.
*     imax
*        Index within "res" of highest value (only used if "res" is not
*        NULL).
*     out
*        Pointer to the output array to receive the sum of the Gaussian
*        models, or NULL if no output is required.
*     ilevel
*        Level of information to display on standard output.
*     rmask
*        Pointer to a mask array. The elements should be stored in
*        Fortran order. If this is not NULL, then pixels which fall
*        within any clump are set to 1.0 (all other pixels are left 
*        unchanged).
*     cloc
*        Pointer to a string to recieve an HDS locator for a newly
*        created structure describing the clump. This pointer may be NULL
*        in which case no HDS structure is created.

*  Notes:
*     - This function can be invoked using the generic cupidGCUpdateArrays macro 
*     defined in cupid.h. This macro has the same parameter list as 
*     cupidGCUpdateArrays<X> except that an extra parameter is added to the start 
*     of the parameter list indicating the data type of the specific 
*     cupidGCUpdateArrays... function to be invoked. This extra parameter should
*     be an integer and should be one of CUPID__DOUBLE, CUPID__FLOAT, etc.

*  Authors:
*     DSB: David S. Berry
*     {enter_new_authors_here}

*  History:
*     5-OCT-2005 (DSB):
*        Original version.
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}
*/      

/* Local Variables: */
   CGEN_TYPE r0;          /* Supplied residual at initial peak */
   double *mlist;         /* Pointer to list holding model valus */
   double bg;             /* Background for model */
   double m;              /* Model value */
   double sum;            /* Integrated clump intensity */
   double xx[ 3 ];        /* Internal coords of current pixel */
   double yy[ 3 ];        /* External coords of current pixel */
   int *plist;            /* Pointer to list holding pixel indices */
   int *pnext;            /* Pointer to next element in plist */
   int area;              /* Used area of clump in pixels */
   int extend[ 3 ][ 2 ];  /* Flags indicating which box faces to extend */
   int face_done;         /* Has the face been evaluated? */
   int first;             /* Is this is the first model evaluation? */
   int iax;               /* Axis index */
   int iedge;             /* Consider the upper limit on current axis? */
   int ilist;             /* Index into the plist and mlist arrays */
   int j;                 /* Vector index within input array */
   int jax;               /* Axis index */
   int lbox[ 3 ];         /* Lower bounds of model evaluation box */
   int lface[ 3 ];        /* Lower bounds of face being evaluated */
   int list_size;         /* Number of values stored in plist and mlist */
   int more;              /* Does the evaluation box need to be extended? */
   int ok;                /* Is the pixel within the bounds of the NDF? */
   int peakok;            /* Is some of the peak usable? */
   int ubox[ 3 ];         /* Upper bounds of model evaluation box */
   int uface[ 3 ];        /* Upper bounds of face being evaluated */
   size_t psize;          /* Bytes required for one pixel position */

/* Abort if an error has already occurred. */
   if( *status != SAI__OK ) return;

/* Note the original value at the initial peak position. */
   r0 = res ? res[ imax ] : 1.0;

/* Temporaily set the backgound of the model clump to zero. */
   bg = par[ 1 ];
   par[ 1 ] = 0.0;

/* Initialise the GRID bounds of the box over which the model Gaussian is to
   be evaluated so that it covers only the pixel containing the peak of
   the model. */
   ubox[ 0 ] = lbox[ 0 ] = (int)( par[ 2 ] + 0.5 );
   if( ndim > 1 ) {
      ubox[ 1 ] = lbox[ 1 ] = (int)( par[ 4 ] + 0.5 );
      if( ndim > 2 ) {
         ubox[ 2 ] = lbox[ 2 ] = (int)( par[ 7 ] + 0.5 );
      }
   }

/* Reduce the upper bound on the first axis by one so that the central
   pixel is evaluated on the first pass through the following algorithm. */
   ubox[ 0 ]--;

/* We evaluate the model at increasing radii, like the layers of an onion,
   until a "layer" is found for which the model Gaussian does not exceed
   a given user-supplied value at any point on the layer. This particular 
   onion is cuboid rather than spherical. That is, each "layer" is actually 
   a box, with faces parallel to the pixel axes. The "extend" array is
   used to hold flags saying whether we need to extend each individual face
   to a larger radius. Initially, assume all faces need to be extended. */
   for( jax = 0; jax < ndim; jax++ ) {
      for( iedge = 0; iedge < 2; iedge++ ) extend[ jax ][ iedge ] = 1;
   }

/* Reserve memory for a list of model values and associated pixel indices */
   mlist = astMalloc( sizeof( double )*cupidGC.nel );
   psize = sizeof( int )*ndim;
   plist = astMalloc( psize*cupidGC.nel );
   list_size = 0;

/* Now loop over increasingly larger layers until a layer is found over which 
   the model Gaussian does not exceed the user-supplied limit. */   
   more = 1;
   first = 1;
   peakok = 0;
   sum = 0.0;
   area = 0;
   while( more ){
      more = 0;

/* Consider each surface of the box forming the current layer. */
      for( iax = 0; iax < ndim; iax++ ) {
         for( iedge = 0; iedge < 2; iedge++ ) {

/* If this face does not need to be extended, pass on to the next face.
   If it does, we extend it by 1 pixel now. Assume to begin with that it
   will not need to be extended any further. */
            if( extend[ iax ][ iedge ] ) {
               more = 1;

               if( iedge ) {
                  lbox[ iax ]--;
               } else {
                  ubox[ iax ]++;
               }

               extend[ iax ][ iedge ] = 0;

/* Set up the GRID bounds of the section representing this face. Also set
   the GRID coords of the first point to test. Also, get the corresponding 
   N-dimensional GRID indices in the input array. This allows for any 
   permutation of the pixels axes necessary to make the velocity axis the 
   third axis. */
               for( jax = 0; jax < ndim; jax++ ) {
                  yy[ cupidGC.dax[ jax ] ] = xx[ jax ] = lface[ jax ] = lbox[ jax ];
                  uface[ jax ] = ubox[ jax ];
               }

               if( iedge ) {
                  uface[ iax ] = lface[ iax ];
               } else {
                  yy[ cupidGC.dax[ iax ] ] = xx[ iax ] = lface[ iax ] = uface[ iax ];
               }

/* Now loop round all the pixels on the face. */
               face_done = 0;
               while( !face_done ){

/* Get the corresponding 1-dimensional index into the input array. Also check
   it is within the bounds of the array. */
                  ok = 1;
                  j = 0;
                  for( jax = ndim - 1; jax >= 0; jax-- ) {
                     if( yy[ jax ] < 1 || yy[ jax ] > dims[ jax ] ) {
                        ok = 0;
                        break;
                     } else {
                        j = yy[ jax ] + j*dims[ jax ] - 1;
                     }
                  }         

/* Pass on if the current pixel is not within the bounds of the input
   array. */
                  if( ok ) {
                     area++;

/* If the supplied residual is bad at this point, we leave it unchanged
   and set the corresponding output pixel (if any) bad. */
                     if( res && res[ j ] == CGEN_BAD ) {
                        if( out ) out[ j ] = CGEN_BAD;

/* If the supplied residual is not bad, find the Gaussian model value at
   the current pixel. This excludes any background level because the
   background value in "par" was set to zero before entring this loop. */
                     } else {
                        m = cupidGCModel( ndim, xx, par, -1, 1, first );
                        first = 0;

/* If the model value is higher than the supplied limit, indicate that the
   face needs to be extended further. Indicate that some of the peak at
   least is above the threshold and on the image. Also indicate that the
   pixel is within a clumpo in any returned mask. */
                        if( m > mlim ) {
                           extend[ iax ][ iedge ] = 1;
                           peakok = 1;
                           if( rmask ) rmask[ j ] = 1.0;
                        }

/* Scale the model using the RMS noise so that it has the same
   normalisation as the residuals and input data, and then subtract it
   from the residuals and add it to the output (if any). */
                        m *= rms;
                        if( res ) res[ j ] -= (CGEN_TYPE) m;
                        if( out ) out[ j ] += (CGEN_TYPE) m;
                        sum += m;

/* Add this model value and its associated pixel indices into the lists */
                        ilist = list_size++;
                        mlist = astGrow( mlist, list_size, sizeof( double ) );
                        plist = astGrow( plist, list_size, psize );
                        mlist[ ilist ] = m;
                        pnext = plist + ilist*psize;
                        for( jax = 0; jax < ndim; jax ++ ) {
                           pnext[ jax ] = (int) ( yy[ jax ] + 0.5 );
                        }
                     }
                  }

/* Get the grid coords of the next pixel in the section currently being 
   fitted. This assumes fortran ordering of the elements in the arrays, and 
   assumes the velocity axis (if any) is axis 3. */
                  jax = 0;
                  xx[ jax ] += 1.0;
                  yy[ cupidGC.dax[ jax ] ] = xx[ jax ];
                  while( xx[ jax ] > uface[ jax ] ) {
                     xx[ jax ] = lface[ jax ];
                     yy[ cupidGC.dax[ jax ] ] = xx[ jax ];

                     if( ++jax == ndim ) {
                        face_done = 1;
                        break;
                     }
                     xx[ jax ] += 1.0;
                     yy[ cupidGC.dax[ jax ] ] = xx[ jax ];
                  }

               }
            }
         }
      }
   }

/* Set the specified element of the residuals array bad if the fit was
   unusable.  This prevents the any subsequent attempt to fit a Gaussian 
   to the same peak value.*/
   if( res && ( !peakok || res[ imax ] == r0  ) ) res[ imax ] = CGEN_BAD;

/* Re-instate the original backgound value. */
   par[ 1 ] = bg;

/* Remove the background level from the residuals and add it to the model. */
   bg *= rms;
   if( res ) for( j = 0; j < nel; j++ ) if( res[ j ] != CGEN_BAD ) res[ j ] -= bg;
   if( out ) for( j = 0; j < nel; j++ ) if( out[ j ] != CGEN_BAD ) out[ j ] += bg;

/* Display info */
   if( ilevel > 3 ) {
      msgSetd( "V", sum );
      msgSeti( "N", area );
      msgOut( "", "   Integrated clump intensity: ^V (in ^N pixels)", status );

      msgSetd( "V", bg*nel );
      msgSeti( "N", nel );
      msgOut( "", "   Integrated background intensity: ^V (in ^N pixels)", status );
   }

/* If required, create an HDS structure holding information about the
   clump. */
   if( cloc ) {

/* Create the structure. */


/* Create an NDF containing the model values calculated abovem with bad
   values at all other pixels. The size of this NDF is the minimum needed
   to contain the clump. */
      ndfOpen( loc, name, mode, stat, indf, place, status )




   }

/* Free resources */
   mlist = astFree( mlist );
   plist = astFree( plist );

/*   if( res ) CGEN_FUNCTION(cupidGCDump)( res, ndim, dims );  */

}

