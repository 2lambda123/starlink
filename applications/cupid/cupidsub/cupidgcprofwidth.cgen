#include "sae_par.h"
#include "cupid.h"
#include "mers.h"
#include <math.h>

double CGEN_FUNCTION(cupidGCProfWidth)( CGEN_TYPE *array, int ndim, int *dims, 
                                        int imax, int *ax_max, int ax, 
                                        double rms, double *off, double *cen ){
/*
*  Name:
*     cupidGCProfWidth<X>

*  Purpose:
*     Find the width of a clump from its radial profile.

*  Synopsis:
*     double cupidGCProfWidth<X>( CGEN_TYPE *array, int ndim, int *dims, 
*                                 int imax, int *ax_max, int ax, double rms, 
*                                 double *off, double *cen )

*  Description:
*     This functions forms a radial profile of a clump in the supplied
*     data array, measured along a specified pixel axis. It then looks
*     for the first significant minimum in the profile, and estimates the 
*     FWHM of the clump from the position of this minimum. It also adds
*     the minimum data value in the profile onto a supplied value and
*     returns the sum.

*  Parameters:
*     array
*        The array containing the data to be fitted. The elements should
*        be ordered according to Fortran order (first axis varying most 
*        rapidly). 
*     ndim
*        The number of pixel axes in the array.
*     dims
*        The number of pixels on each pixel axis of the array.
*     imax
*        The 1D vectorised index of the pixel with the highest value in
*        the array. This is used as the start position for the
*        radial profile.
*     ax_max
*        The N-d GRID coordinates corresponding to "imax".
*     ax
*        The zero-based index of the pixel axis along which the profile
*        is to be taken.
*     rms
*        The RMS noise level in the array.
*     off
*        Address of a location containing a double value to which to add
*        the estimate of the background data value (i.e. the minimum value 
*        in the profile).
*     cen
*        A location at which to return an improved estimate of the 
*        GRID coordinate of the profile peak, on axis "ax".

*  Returned Value:
*     The FWHM of the profile, in pixels.

*  Notes:
*     - This function can be invoked using the generic cupidGCProfWidth macro 
*     defined in cupid.h. This macro has the same parameter list as 
*     cupidGCProfWidth<X> except that an extra parameter is added to the start 
*     of the parameter list indicating the data type of the specific 
*     cupidGCProfWidth... function to be invoked. This extra parameter should
*     be an integer and should be one of CUPID__DOUBLE, CUPID__FLOAT, etc.

*  Authors:
*     DSB: David S. Berry
*     {enter_new_authors_here}

*  History:
*     5-OCT-2005 (DSB):
*        Original version.
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}
*/      

/* Local Variables: */
   double *profile;      /* Pointer to the profile array */
   double cs1;           /* Sum of products of pixel index and value */
   double cs2;           /* Sum of pixel values */
   double cs3;           /* Sum of pixel indicies */
   double cs4;           /* Number of values summed in cs1, 2 and 3 */
   double ret;           /* Sum of weighted axis values */
   double rlow;          /* Radius at lowest pixel */
   double target;        /* The half-max profile value */
   double v1;            /* Value at lower of two profile points */
   double v2;            /* Value at upper of two profile points */
   double v;             /* Mean value at two profile points */
   double vlow;          /* Lowest data value found so far */
   int i1;               /* Vector index at lower of two profile points */
   int i2;               /* Vector index at upper of two profile points */
   int j1;               /* Axis value at lower of two profile points */
   int j2;               /* Axis value at upper of two profile points */
   int nv;               /* Number of good values summed in "v" */
   int pel;              /* Index of last profile element to be written to */
   int step;             /* Vector step between adjacent pixels on an axis */

/* Abort if an error has already occurred. */
   if( *status != SAI__OK ) return 10;

/* Allocate space for a copy of teh data row or lumn containing the
   maximum pixel value. */
   profile = astMalloc( sizeof( double )*dims[ ax ] );

/* Initialise the lowest value found so far in the profile. */
   vlow1 = profile[ 0 ];
   rlow1 = 0;
   vlow2 = profile[ 0 ];
   rlow2 = 0;

/* Initialise the GRID axis values of the two pixels which are equi-distant
   from the profile centre along the specified axis.*/
   j1 = ax_max[ ax ];
   j2 = j1;

/* Initialise the vector indicies of the two pixels which are equi-distant
   from the profile centre along the specified axis.*/
   i1 = imax;
   i2 = i1;

/* Put the maximum data value into the profile array. */
   profile[ j1 ] = (double) array[ imax ];

/* Save the 1D vector step between adjacent pixels on the axis. */
   if( ax == 0 ) {
      step = 1;

   } else if( ax == 1 ) {
      step = dims[ 0 ];

   } else {
      step = dims[ 0 ]*dims[ 1 ];

   }

/* Loop round extending the profile to larger radii until the first 
   significant minimum is found in the profile. */
   while( j1 >= 0 || j2 < dims[ ax ] ) {

/* Increment the GRID axis value of the two pixels which are equi-distant from
   the profile centre. */
      j1--;
      j2++;

/* Increment the vector index of the two pixels which are equi-distant from
   the profile centre. */
      i1 -= step;
      i2 += step;

/* If the lower of the two equi-distant points is still within the GRID
   bounds of the array... */
      if( j1 > 0 ) {

/* Store the value in the profile. */
         v1 = array[ i1 ];
         profile[ j1 ] = v1;

/* If this value is less than any other value found on this side of the
   peak, then remember it. */
         if( v1 < vlow1 ) {
            vlow1 = v1;
            rlow1 = j1;

/* Otherwise, if this value is more than 3 times the RMS noise higher
   than the lowest value found so far, we assume that the lowest value
   found so far is the minimum point in the profile. */
      } else if( v1 > vlow1 + 3*rms ){
         j1 = -1;

/* Otherwise, if the lowest pixel has not changed for the past 10 pixels, 
   assume we have reached the flat bit of the profile. */
      } else if( rlow1 - j1 > 10 ) {
         j1 = -1;
      }




      } else {
         v1 = CGEN_BAD;
      }

      if( j2 <= dims[ ax ] ) {
         v2 = array[ i2 ];
         profile[ j2 ] = v2;
         if( v1 < vlow1 ) {
            vlow1 = v1;
            rlow1 = j1;
         }

      } else {
         v2 = CGEN_BAD;
      }


/* If this value is lower than the previous lowest value, remember it. */
      if( v == VAL__BADD ) {

      } else if( v < vlow ) {
         vlow = v;
         rlow = pel;

/* Otherwise, if this value is more than 3 times the RMS noise higher
   than the lowest value found so far, we assume that the lowest value
   found so far is the minimum point in the profile. */
      } else if( v > vlow + 3*rms ){
         break;

/* Otherwise, if the lowest pixel has not changed for the past 10 pixels, 
   assume we have reached the flat bit of the profile. */
      } else if( pel - rlow > 10 ) {
         break;
      }
   }








/* If both values are good, increment the sums needed to estimate the
   centroid of the peak (we require both values to be good in order to
   keep the centroid unbiased). */
      if( nv == 2 ) {
         cs1 += j1*v1 + j2*v2;
         cs2 += v1 + v2;
         cs3 += j1 + j2;
         cs4 += 2.0;
      }



/* Find the radius at half the maximum value. */
   target = 0.5*( profile[ 0 ] - vlow ) + vlow;
   for( i2 = 0; i2 <= rlow; i2++ ) {
      if( profile[ i2 ] != VAL__BADD ) {
         if( profile[ i2 ] < target ) {
            ret = 2*i2;
            break;
         }
      }
   }





/* Initialise the sums needed to estimate the centroid of the peak */
   cs1 = ax_max[ ax ]*profile[ 0 ];
   cs2 = profile[ 0 ];
   cs3 = ax_max[ ax ];
   cs4 = 1.0;





/* Increment the supplied offset value. */
   *off += vlow;

/* Return the centroid position. */
   if( cs2 != cs4*vlow ) {   
      *cen = ( cs1 - vlow*cs3 )/( cs2 - cs4*vlow );

      if( fabs( *cen - ax_max[ ax ] ) > 5 ) {
         *status = SAI__ERROR;
         msgSeti( "AX", ax );
         msgSeti( "AXM", ax_max[ ax ] );
         msgSetd( "C", *cen );
         errRep( "", "cupidGCProfWidth: Peak has drifted from ^AXM to ^C"
                 " on axis ^AX.", status );
      }

   } else {
      *status = SAI__ERROR;
      errRep( "", "cupidGCProfWidth: No peak found", status );
   }

/* Free resources */
   profile = astFree( profile );

/* Return the result. */
   return ret;

}

