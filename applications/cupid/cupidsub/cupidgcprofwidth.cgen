#include "sae_par.h"
#include "cupid.h"
#include "math.h"

double CGEN_FUNCTION(cupidGCProfWidth)( CGEN_TYPE *array, int ndim, int *dims, 
                                        int imax, int *ax_max, int ax, 
                                        double rms, double *off, double *cen ){
/*
*+
*  Name:
*     cupidGCProfWidth<X>

*  Purpose:
*     Find the width of a clump from its radial profile.

*  Language:
*     Starlink C

*  Synopsis:
*     double cupidGCProfWidth<X>( CGEN_TYPE *array, int ndim, int *dims, 
*                                 int imax, int *ax_max, int ax, double rms, 
*                                 double *off, double *cen )

*  Description:
*     This functions produces an initial estimate of the width and
*     background value of a Gaussian clump, along a specified pixel axis.
*     If first finds the minima on either side of the specified peak
*     position, and then find the weighted mean and standard deviation of
*     the pixel positions between these minima, using the data values as 
*     weights. A sloping background is removed from the data when
*     calculating the weighted mean and standard deviation. This
*     background is a straight line between the two minima.

*  Parameters:
*     array
*        The array containing the data to be fitted. The elements should
*        be ordered according to Fortran order (first axis varying most 
*        rapidly). 
*     ndim
*        The number of pixel axes in the array.
*     dims
*        The number of pixels on each pixel axis of the array.
*     imax
*        The 1D vectorised index of the pixel with the highest value in
*        the array. This is used as the start position for the
*        radial profile.
*     ax_max
*        The N-d GRID coordinates corresponding to "imax".
*     ax
*        The zero-based index of the pixel axis along which the profile
*        is to be taken.
*     rms
*        The RMS noise level in the array.
*     off
*        Address of a location containing a double value to which to add
*        the estimate of the background data value (i.e. the mean of the
*        two minima).
*     cen
*        A location at which to return an improved estimate of the 
*        GRID coordinate of the profile peak, on axis "ax".
*        >>>>>  CURRENTLY THIS IS UNDER REVIEW. EXTRA CODE IS NEEDED TO
*        CALCULATE THIS PROPERLY, AND IT MAY NOT HAVE MUCH EFFECT <<<<<<

*  Returned Value:
*     The FWHM of the profile, in pixels.

*  Notes:
*     - This function can be invoked using the generic cupidGCProfWidth macro 
*     defined in cupid.h. This macro has the same parameter list as 
*     cupidGCProfWidth<X> except that an extra parameter is added to the start 
*     of the parameter list indicating the data type of the specific 
*     cupidGCProfWidth... function to be invoked. This extra parameter should
*     be an integer and should be one of CUPID__DOUBLE, CUPID__FLOAT, etc.

*  Copyright:
*     Copyright (C) 2005 Particle Physics & Astronomy Research Council.
*     All Rights Reserved.

*  Licence:
*     This program is free software; you can redistribute it and/or
*     modify it under the terms of the GNU General Public License as
*     published by the Free Software Foundation; either version 2 of
*     the License, or (at your option) any later version.
*
*     This program is distributed in the hope that it will be
*     useful, but WITHOUT ANY WARRANTY; without even the implied
*     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
*     PURPOSE. See the GNU General Public License for more details.
*
*     You should have received a copy of the GNU General Public License
*     along with this program; if not, write to the Free Software
*     Foundation, Inc., 59 Temple Place,Suite 330, Boston, MA
*     02111-1307, USA

*  Authors:
*     DSB: David S. Berry
*     {enter_new_authors_here}

*  History:
*     5-OCT-2005 (DSB):
*        Original version.
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}

*-
*/

/* Local Variables: */
   double ret;           /* Sum of weighted axis values */
   double v1low;         /* Lowest data value found so far */
   double v2low;         /* Lowest data value found so far */
   double v;             /* Mean value at two profile points */
   double vlim;          /* Data value at half maximum */
   int hiwid;            /* Half width on higher axis values */
   int i1;               /* Vector index at lower of two profile points */
   int i1low;            /* Vtecor index at lowest pixel */
   int i2;               /* Vector index at upper of two profile points */
   int i2low;            /* Vtecor index at lowest pixel */
   int j1;               /* Axis value at lower of two profile points */
   int j1low;            /* Radius at lowest pixel */
   int j2;               /* Axis value at upper of two profile points */
   int j2low;            /* Radius at lowest pixel */
   int lowid;            /* Half width on lower axis values */
   int step;             /* Vector step between adjacent pixels on an axis */

/* Initialise */
   ret = 10;

/* Abort if an error has already occurred. */
   if( *status != SAI__OK ) return ret;

/* Save the 1D vector step between adjacent pixels on the axis. */
   if( ax == 0) {
      step = 1;

   } else if( ax == 1 ) {
      step = dims[ 0 ];

   } else {
      step = dims[ 0 ]*dims[ 1 ];

   }

/* First move out away from the peak to higher axis values, looking for a
   significant minimum in the data value along the axis. Initialise the GRID 
   axis value and vector index of the current pixel to be the pixelnext
   to the peak pixel. */
   j2 = ax_max[ ax ] + 1;
   i2 = imax + 1;

/* Initialise the lowest value found so far in the profile. */
   v2low = (double) array[ imax ];
   j2low = 0;

/* Loop round extending the profile to larger radii until the first 
   significant minimum is found in the profile. */
   while( j2 <= dims[ ax ] ) {

/* Ignore bad pixels */
      if( array[ i2 ] != CGEN_BAD ) {

/* Get the pixel value. */
         v = (double) array[ i2 ];

/* If this value is lower than the previous lowest value, remember it. */
         if( v < v2low ) {
            v2low = v;
            j2low = j2;
            i2low = i2;

/* Otherwise, if this value is more than the RMS noise higher
   than the lowest value found so far, we assume that the lowest value
   found so far is the minimum point in the profile. */
         } else if( v > v2low + rms ){
            break;

/* Otherwise, if the lowest pixel has not changed for the past 3 pixels, 
   assume we have reached the flat bit of the profile. */
         } else if( j2 - j2low > 3 ) {
            break;
         }
      }

/* Increment the GRID axis value and vector index of the current pixel. */
      j2++;
      i2 += step;
   }

/* Determine the data value at half max on the upper side of the peak. */
   v2low += rms;
   vlim = 0.5*( (double) array[ imax ] - v2low ) + v2low;

/* Now rescan the same pixels looking for the first pixel which is less
   than this half max value. Note the distance in pixels from this point
   to the peak. */
   j2 = ax_max[ ax ] + 1;
   i2 = imax + 1;
   hiwid = 5;
   while( j2 <= dims[ ax ] ) {
      if( array[ i2 ] != CGEN_BAD ) {
         v = (double) array[ i2 ];
         if( v < vlim ) {
            hiwid = j2 - ax_max[ ax ];
            break;
         }
      }
      j2++;
      i2 += step;
   }

/* Do the same working downwards from the peak to lower axis values. */
   j1 = ax_max[ ax ] - 1;
   i1 = imax - 1;

   v1low = (double) array[ imax ];
   j1low = 0;

   while( j1 > 0 ) {

      if( array[ i1 ] != CGEN_BAD ) {
         v = (double) array[ i1 ];

         if( v < v1low ) {
            v1low = v;
            j1low = j1;
            i1low = i1;

         } else if( v > v1low + 3*rms ){
            break;

         } else if( j1 - j1low > 10 ) {
            break;
         }
      }

      j1--;
      i1 -= step;
   }

   v1low += rms;
   vlim = 0.5*( (double) array[ imax ] - v1low ) + v1low;

   j1 = ax_max[ ax ] - 1;
   i1 = imax - 1;
   lowid = 5;
   while( j1 > 0 ) {
      if( array[ i1 ] != CGEN_BAD ) {
         v = (double) array[ i1 ];
         if( v < vlim ) {
            lowid = ax_max[ ax ] - j1;
            break;
         }
      }
      j1--;
      i1 -= step;
   }

/* Form the total width at half max. */   
   ret = lowid + hiwid;

/* Increment the sum of hte offsets using the mean of the two minimum
   values. */
   *off += 0.5*( v1low + v2low );

/* Return the supplied central position. */
   *cen = ax_max[ ax ];

/* Return the result. */
   return ret;

}
