#include "sae_par.h"
#include "cupid.h"
#include "math.h"

double CGEN_FUNCTION(cupidGCProfWidth)( CGEN_TYPE *array, int ndim, int *dims, 
                                        int imax, int *ax_max, int ax, 
                                        double rms, double *off, double *cen ){
/*
*  Name:
*     cupidGCProfWidth<X>

*  Purpose:
*     Find the width of a clump from its radial profile.

*  Synopsis:
*     double cupidGCProfWidth<X>( CGEN_TYPE *array, int ndim, int *dims, 
*                                 int imax, int *ax_max, int ax, double rms, 
*                                 double *off, double *cen )

*  Description:
*     This functions forms a radial profile of a clump in the supplied
*     data array, measured along a specified pixel axis. It then looks
*     for the first significant minimum in the profile, and finds the 
*     FWHM of the clump from the value of this minimum. It also adds
*     the minimum data value in the profile onto a supplied value and
*     returns the sum.
*
*     The radial profile is formed by working out from the supplied
*     peak position along the specified axis in both directions (+ve and
*     -ve). At each radial distance the two axis values (one above and
*     one below the peak axis value) are averaged to find the radial
*     profile value. This greatly reduces the effect of any sloping
*     background.

*  Parameters:
*     array
*        The array containing the data to be fitted. The elements should
*        be ordered according to Fortran order (first axis varying most 
*        rapidly). 
*     ndim
*        The number of pixel axes in the array.
*     dims
*        The number of pixels on each pixel axis of the array.
*     imax
*        The 1D vectorised index of the pixel with the highest value in
*        the array. This is used as the start position for the
*        radial profile.
*     ax_max
*        The N-d GRID coordinates corresponding to "imax".
*     ax
*        The zero-based index of the pixel axis along which the profile
*        is to be taken.
*     rms
*        The RMS noise level in the array.
*     off
*        Address of a location containing a double value to which to add
*        the estimate of the background data value (i.e. the minimum value 
*        in the profile).
*     cen
*        A location at which to return an improved estimate of the 
*        GRID coordinate of the profile peak, on axis "ax".
*        >>>>>  CURRENTLY THIS IS UNDER REVIEW. EXTRA CODE IS NEEDED TO
*        CALCULATE THIS PROPERLY, AND IT MAY NOT HAVE MUCH EFFECT <<<<<<

*  Returned Value:
*     The FWHM of the profile, in pixels.

*  Notes:
*     - This function can be invoked using the generic cupidGCProfWidth macro 
*     defined in cupid.h. This macro has the same parameter list as 
*     cupidGCProfWidth<X> except that an extra parameter is added to the start 
*     of the parameter list indicating the data type of the specific 
*     cupidGCProfWidth... function to be invoked. This extra parameter should
*     be an integer and should be one of CUPID__DOUBLE, CUPID__FLOAT, etc.

*  Authors:
*     DSB: David S. Berry
*     {enter_new_authors_here}

*  History:
*     5-OCT-2005 (DSB):
*        Original version.
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}
*/      

/* Local Variables: */
   double *profile;      /* Pointer to the profile array */
   double cs1;           /* Sum of products of pixel index and value */
   double cs2;           /* Sum of pixel values */
   double ret;           /* Sum of weighted axis values */
   double rlow;          /* Radius at lowest pixel */
   double target;        /* The half-max profile value */
   double v1;            /* Value at lower of two profile points */
   double v2;            /* Value at upper of two profile points */
   double v;             /* Mean value at two profile points */
   double vlow;          /* Lowest data value found so far */
   int i1;               /* Vector index at lower of two profile points */
   int i2;               /* Vector index at upper of two profile points */
   int j1;               /* Axis value at lower of two profile points */
   int j2;               /* Axis value at upper of two profile points */
   int nv;               /* Number of good values summed in "v" */
   int pel;              /* Index of last profile element to be written to */
   int step;             /* Vector step between adjacent pixels on an axis */

/* Abort if an error has already occurred. */
   if( *status != SAI__OK ) return 10;

/* Allocate space for the profile making it the largest it could possibly
   need to be. */
   profile = astMalloc( sizeof( double )*dims[ ax ] );

/* Put the maximum data value in the first element of the profile, and 
   initialise the index of the last element written to. */
   profile[ 0 ] = (double) array[ imax ];
   pel = 0;

/* Initialise the sums needed to estimate the centroid of the peak */
   cs1 = ax_max[ ax ]*profile[ 0 ];
   cs2 = profile[ 0 ];

/* Initialise the lowest value found so far in the profile. */
   vlow = profile[ 0 ];
   rlow = 0;

/* Initialise the GRID axis values of the two pixels which are equi-distant
   from the profile centre along the specified axis.*/
   j1 = ax_max[ ax ];
   j2 = j1;

/* Initialise the vector indicies of the two pixels which are equi-distant
   from the profile centre along the specified axis.*/
   i1 = imax;
   i2 = i1;

/* Save the 1D vector step between adjacent pixels on the axis. */
   if( ax == 0) {
      step = 1;

   } else if( ax == 1 ) {
      step = dims[ 0 ];

   } else {
      step = dims[ 0 ]*dims[ 1 ];

   }

/* Loop round extending the profile to larger radii until the first 
   significant minimum is found in the profile. */
   while( j1 > 0 || j2 <= dims[ ax ] ) {

/* Increment the GRID axis value of the two pixels which are equi-distant from
   the profile centre. */
      j1--;
      j2++;

/* Increment the vector index of the two pixels which are equi-distant from
   the profile centre. */
      i1 -= step;
      i2 += step;

/* Get the two pixel values. */
      v1 = ( j1 > 0 ) ? array[ i1 ] : CGEN_BAD;
      v2 = ( j2 <= dims[ ax ] ) ? array[ i2 ] : CGEN_BAD;

/* Find the mean of the two values, and store it in the profile. */
      if( v1 != CGEN_BAD ) {
         v = (double) v1;
         nv = 1;

      } else {
         v = 0.0;
         nv = 0;
      }
      
      if( v2 != CGEN_BAD ) {
         v += (double) v2;
         nv++;
      } 
      
      v = ( nv > 0 ) ? v/nv : VAL__BADD;
      profile[ ++pel ] = v;

/* If both values are good, increment the sums needed to estimate the
   centroid of the peak (we require both values to be good in order to
   keep the centroid unbiased). */
      if( nv == 2 ) {
         cs1 += j1*v1 + j2*v2;
         cs2 += v1 + v2;
      }

/* If this value is lower than the previous lowest value, remember it. */
      if( v == VAL__BADD ) {

      } else if( v < vlow ) {
         vlow = v;
         rlow = pel;

/* Otherwise, if this value is more than 3 times the RMS noise higher
   than the lowest value found so far, we assume that the lowest value
   found so far is the minimum point in the profile. */
      } else if( v > vlow + 3*rms ){
         break;

/* Otherwise, if the lowest pixel has not changed for the past 10 pixels, 
   assume we have reached the flat bit of the profile. */
      } else if( pel - rlow > 10 ) {
         break;
      }
   }

/* Find the radius at half the maximum value. */
   target = 0.5*( profile[ 0 ] - vlow ) + vlow;
   for( i2 = 0; i2 <= rlow; i2++ ) {
      if( profile[ i2 ] != VAL__BADD ) {
         if( profile[ i2 ] < target ) {
            ret = 2*i2;
            break;
         }
      }
   }

/* Increment the supplied offset value. */
   *off += vlow;

/* Return the centroid position. */
/*   *cen = cs1/cs2; */
   *cen = ax_max[ ax ];

/* Free resources */
   profile = astFree( profile );

/* Return the result. */
   return ret;

}

