#include "sae_par.h"
#include "ndf.h"
#include "cupid.h"
#include "prm_par.h"
#include "mers.h"
#include <string.h>

/* Local Constants: */
#define CLUMPFIND   1
#define GAUSSCLUMPS 2
#define REINHOLD    3
#define FELLWALKER  4

void CGEN_FUNCTION(cupidSumClumps)( CGEN_TYPE *in, int ilevel, int ndim, 
                                    int *lbnd, int *ubnd, int nel, HDSLoc *obj,
                                    int nclump, float *rmask, void *out, 
                                    char *method, double *bg ){
/*
*  Name:
*     cupidSumClumps

*  Purpose:
*     Create an image holding the sum of the supplied clumps, and another
*     holding a mask.

*  Synopsis:
*     void cupidSumClumps<X>( CGEN_TYPE *in, int ilevel, int ndim, int *lbnd, 
*                             int *ubnd, int nel, HDSLoc *obj, int nclump,
*                             float *rmask, void *out, char *method,
*                             double *bg )

*  Description:
*     This function stores an image of the sum of all the found clumps
*     in "out", and stores a mask in "rmask" identifying the pixels which
*     are inside a clump. In the case of the GaussClumps algorithm, a constant 
*     background value is added to the returned "out" array so that the mean 
*     value in "out" equals the mean of the corresponding pixels in "in".
*     If "in" is not supplied then the background value added is the
*     supplied value of "*bg".

*  Parameters:
*     in
*        Pointer to the start of the input data array. May be null.
*     ilevel
*        The level of screen information required.
*     ndim
*        The number of pixel axes in the "out" array.
*     lbnd
*        The lower bounds on the pixel axes of "out".
*     ubnd
*        The upper bounds on the pixel axes of "out".
*     nel
*        Number of pixels in each of "out" and "rmask".
*     obj
*        A locator for an HDS array containing "nclump" NDF structures.
*     nclump
*        The number of NDFs in "obj".
*     rmask
*        The array to receive the mask. A value of 1.0 will be stored in
*        every pixel which inside a clump. All other pixels will be set
*        to VAL__BADR. The supplied array must be the same size and shape as 
*        "out" and the pixels are assumed to be in fortran order. May be NULL.
*     out
*        Pointer to the start of the array to receive the sum of the clump 
*        intensities plus (for GaussClumps) a constant background value. The 
*        supplied array must be the same size as the user supplied NDF ("in") 
*        and the pixels are assumed to be in fortran order. May be NULL.
*        Note the data type for this array is determined by the algorithm in 
*        use ("_DOUBLE" for gaussclumps, "_INTEGER" for others), and need not 
*        be the same as the data type of "in".
*     method
*        The name of the algorithm being used (e.g. "CLUMPFIND",
*        "GAUSSCLUMPS", etc)
*     bg
*        Pointer to double in which to store the background value added
*        onto the output array (this will be zero unless the GaussClumps 
*        algorithm is being used). If "in" is NULL, then the value on
*        entry is used as the background value.

*  Notes:
*     - This function can be invoked using the generic cupidSumClumps macro 
*     defined in cupid.h. This macro has the same parameter list as 
*     cupidSumClumps<X> except that an extra parameter is added to the start 
*     of the parameter list indicating the data type of the "in" array (i.e. 
*     the specific cupidSumClumps... function to be invoked). This extra 
*     parameter should be an integer and should be one of CUPID__DOUBLE, 
*     CUPID__FLOAT, etc.

*  Authors:
*     DSB: David S. Berry
*     {enter_new_authors_here}

*  History:
*     15-NOV-2005 (DSB):
*        Original version.
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}
*/      

/* Local Variables: */
   CGEN_TYPE *pd;       /* Pointer to next element of the "out" array */
   HDSLoc *cloc;        /* Locator for a cell of the NDF array */
   double *ipd;         /* Pointer to data array in clump NDF */
   double *m;           /* Pointer to next clump data value */
   double sumi;         /* Sum of input data values */
   double sumo;         /* Sum of output data values */
   float *r;            /* Pointer to next element of the "rmask" array */
   int *pi;             /* Pointer to next element of the "out" array */
   int alg;             /* Specifies the algorithm */
   int cdim[ 3 ];       /* Pixel axis dimensions within clump NDF */
   int clbnd[ 3 ];      /* Lower pixel bounds of clump NDF */
   int cndim;           /* Number of pixel axes in clump NDF */
   int cubnd[ 3 ];      /* Upper pixel bounds of clump NDF */
   int el;              /* Number of pixels in clump NDF */
   int i;               /* 1D vector index loop count */
   int ii;              /* 1D vector index of current "out" pixel */
   int indf;            /* NDF identifier for clump image */
   int j;               /* Clump loop count */
   int k;               /* Axis loop count */
   int nsum;            /* Number of values summed in sumi and sumo */
   int step[ 3 ];       /* 1D step between adjacent pixels on each axis */
   int yy[ 3 ];         /* nD pixel coords of current "out" pixel */


/* Abort if an error has already occurred. */
   if( *status != SAI__OK ) return;

/* Identify the algorithm. */
   if( !strcmp( method, "CLUMPFIND" ) ) {
      alg = CLUMPFIND;

   } else if( !strcmp( method, "GAUSSCLUMPS" ) ) {
      alg = GAUSSCLUMPS;

   } else if( !strcmp( method, "REINHOLD" ) ) {
      alg = REINHOLD;

   } else if( !strcmp( method, "FELLWALKER" ) ) {
      alg = FELLWALKER;

   } else {
      *status = SAI__ERROR;
      msgSetc( "ALG", method );
      errRep( " ", "CupidSumClumps: Unknown algorithm \"^ALG\" (internal "
              "CUPID programming error).", status );
      return;
   }

/* If supplied, initialise the "out" array to hold zero or bad values. */
   if( out ) {
      if( alg == GAUSSCLUMPS ) {
         pd = (CGEN_TYPE *) out;
         for( i = 0; i < nel; i++ ) *(pd++) = 0.0;

      } else {
         pi = (int *) out;
         for( i = 0; i < nel; i++ ) *(pi++) = VAL__BADI;
      }
   }

/* If supplied, fill the "rmask" array with bad values. */
   if( rmask ) {
      r = rmask;
      for( i = 0; i < nel; i++ ) *(r++) = VAL__BADR;
   }

/* Set up the 1D vector step size for stepping between adjacent pixels on each 
   axis of "in/out/rmask". */
   step[ 0 ] = 1;   
   for( k = 1; k < ndim; k++ ) {
      step[ k ] = step[ k - 1 ]*( ubnd[ k - 1 ] - lbnd[ k - 1 ] + 1 );
   }

/* Store a pointer of the relevant type to the output array. */
   if( alg == GAUSSCLUMPS ) {
      pd = (CGEN_TYPE *) out;

   } else {
      pi = (int *) out;
   }

/* Loop round all non-NULL clumps. */
   for( j = 1; j <= nclump; j++ ) {
      cloc = NULL;
      datCell( obj, 1, &j, &cloc, status );
      errBegin( status );
      ndfFind( cloc, " ", &indf, status );
      errEnd( status );
      datAnnul( &cloc, status );

      if( indf == NDF__NOID ) continue;

/* Get the bounds and dimensions of the clump's NDF. */
      ndfBound( indf, 3, clbnd, cubnd, &cndim, status );
      for( k = 0; k < ndim; k++ ) cdim[ k ] = cubnd[ k ] - clbnd[ k ] + 1;

/* Map its DATA component. */
      ndfMap( indf, "DATA", "_DOUBLE", "READ", (void *) &ipd, &el, status );
      if( ipd ) {

/* Initialise the n-D pixel coords of the first pixel in "ipd". Also, set 
   the 1D vector index within "in/out/rmask" of the first pixel in 
   "ipd". This assumes fortran pixel ordering. */
         ii = 0;
         for( k = 0; k < ndim; k++ ) {
            yy[ k ] = clbnd[ k ];
            ii += ( clbnd[ k ] - lbnd[ k ] )*step[ k ];
         }

/* Loop round every pixel in the clump image. */
         m = ipd;
         for( i = 0; i < el; i++, m++ ) {

/* Skip bad pixels */
            if( *m != VAL__BADD ) {

/* If we are producing an output array and if the input pixel is good, 
   modify the corresponding output pixel. */
               if( out && ( !in || in[ ii ] != CGEN_BAD ) ) {

/* For GaussClumps, increment the current output pixel value by the model 
   value. */
                  if( alg == GAUSSCLUMPS ) {
                     pd[ ii ] += *m;

/* For ClumpFind, etc, store the clump index. */
                  } else {
                     pi[ ii ] = j;
                  }               
               }
         
/* If required, store 1.0 in the "rmask" array. */
               if( rmask ) rmask[ ii ] = 1.0;
            }

/* Move on to the next pixel. */
            k = 0;
            yy[ 0 ]++;
            ii++;
            while( yy[ k ] > cubnd[ k ] ) {
               yy[ k ] = clbnd[ k ];
               ii -= cdim[ k ]*step[ k ];
               k++;
               if( k == ndim ) break;
               yy[ k ]++;
               ii += step[ k ];
            }
         }
      }

/* Annul the NDF identifier. */
      ndfAnnul( &indf, status );
   }

/* The GaussClumps algorithm requires a constant background to be added
   to the output model. This is chosen so that the mean of the good model
   values equals the mean of the corresponding input values. */
   if( alg == GAUSSCLUMPS && out ) {

      if( in ) {
         sumi = 0.0;
         sumo = 0.0; 
         nsum = 0;
      
         pd = (CGEN_TYPE *) out;
         for( i = 0; i < nel; i++, pd++ ) {
            if( in[ i ] != CGEN_BAD ) {
               sumi += in[ i ];
               sumo += *pd;
               nsum++;
            } else {
               *pd = CGEN_BAD;
            }
         }

         if( nsum > 0 ) *bg = ( sumi - sumo )/nsum;

         if( ilevel > 2 ) {
            msgSetd( "BG", *bg );
            msgOut( "", "Estimated background level = ^BG", status );
         }

      }

      pd = (CGEN_TYPE *) out;
      for( i = 0; i < nel; i++, pd++ ) {
         if( *pd != CGEN_BAD ) *pd += *bg;
      }
   }
}

/* Undefine Local Constants: */
#undef CLUMPFIND
#undef GAUSSCLUMPS
#undef REINHOLD
#undef FELLWALKER

