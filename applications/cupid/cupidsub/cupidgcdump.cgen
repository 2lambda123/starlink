#include "sae_par.h"
#include "prm_par.h"
#include "ndf.h"
#include "ast.h"
#include "dat_par.h"
#include "cupid.h"
#include <stdio.h>

/* Global Variables: */
/* ================= */
/* A structure holding the global parameters of the GaussClump algorithm 
   needed by this function. These are set by function cupidGaussClumps. */
extern CupidGC cupidGC;


void CGEN_FUNCTION(cupidGCDump)( CGEN_TYPE *array, int ndim, int *dims ){
/*
*  Name:
*     cupidGCDump<X>

*  Purpose:
*     Dump the contents of the cupidGC structure.

*  Synopsis:
*     void cupidGCDump<X>( CGEN_TYPE *array, int ndim, int *dims )

*  Description:
*     This function is a diagnostic function which dumps the supplied
*     array, or the contents of the cupidGC structure.

*  Parameters:
*     array
*        Pointer to the array to be dumped. If NULL, then the contents of
*        the cupidGC structure is dumped.
*     ndim
*        The number of pixel axes.
*     dims
*        Pointer to the size of each pixel axis.

*  Authors:
*     DSB: David S. Berry
*     {enter_new_authors_here}

*  History:
*     21-OCT-2005 (DSB):
*        Original version.
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}
*/      

/* Local Variables: */
   CGEN_TYPE *adata;
   int indf, place, i, el, lbnd[3], ubnd[3], np;
   double *data;
   static int ii = 0;
   static int jj = 0;
   char name[ 100 ];
   FILE *fd;

   if( array ) {

      for( i = 0; i < cupidGC.ndim; i++ ) {
         lbnd[ i ] = cupidGC.slbnd[ i ];
         ubnd[ i ] = dims[ i ] + cupidGC.slbnd[ i ] - 1;
      }

      sprintf( name, "array%d", ++ii );
      printf("Dumping %s\n", name );
      ndfOpen( DAT__ROOT, name, "WRITE", "NEW", &indf, &place, status );
      ndfNew( CGEN_HDS_TYPE, ndim, lbnd, ubnd, &place, &indf, status );
      ndfMap( indf, "DATA", CGEN_HDS_TYPE, "WRITE", (void *) &adata, &el, status );
      for( i = 0; i < el; i++ ) adata[ i ] = array[ i ];
      ndfAnnul( &indf, status );


   } else {
      jj++;

      sprintf( name, "ard%d", jj );
      fd = fopen( name, "w" );
      if( jj == 1 ) {
         fprintf( fd, "ellipse(%1f,%1f,%1f,%1f,%1f)\n", 
                  cupidGC.initpars[2] - 1 + cupidGC.slbnd[ 0 ], 
                  cupidGC.initpars[4] - 1 + cupidGC.slbnd[ 1 ], 
                  0.5*cupidGC.initpars[3], 0.5*cupidGC.initpars[5], 
                  cupidGC.initpars[6]*AST__DR2D );
      } else {
         fprintf( fd, "ellipse(%1f,%1f,%1f,%1f,%1f)\n", cupidGC.pars[2], 
               cupidGC.pars[4], 0.5*cupidGC.pars[3], 0.5*cupidGC.pars[5], 
               cupidGC.pars[6]*AST__DR2D );
      }
      fclose( fd );


      np = (cupidGC.ndim==1) ? CUPID__GCNP1 : 
           ( (cupidGC.ndim==2) ? CUPID__GCNP2 : CUPID__GCNP3 ); 


      for( i = 0; i < cupidGC.ndim; i++ ) {
         lbnd[ i ] = cupidGC.lbnd[ i ] - 1 + cupidGC.slbnd[ i ];
         ubnd[ i ] = cupidGC.ubnd[ i ] - 1 + cupidGC.slbnd[ i ];
      }

      sprintf( name, "data%d", jj );
      ndfOpen( DAT__ROOT, name, "WRITE", "NEW", &indf, &place, status );
      ndfNew( "_DOUBLE", cupidGC.ndim, lbnd, ubnd, &place, &indf, status );
      ndfMap( indf, "DATA", "_DOUBLE", "WRITE", (void *) &data, &el, status );
      for( i = 0; i < el; i++ ) data[ i ] = cupidGC.data[ i ];
      ndfAnnul( &indf, status );
   
      sprintf( name, "sqresw%d", jj );
      ndfOpen( DAT__ROOT, name, "WRITE", "NEW", &indf, &place, status );
      ndfNew( "_DOUBLE", cupidGC.ndim, lbnd, ubnd, &place, &indf, status );
      ndfMap( indf, "DATA", "_DOUBLE", "WRITE", (void *) &data, &el, status );
      for( i = 0; i < el; i++ ) data[ i ] = cupidGC.resids[ i ]/cupidGC.wsum;
      ndfAnnul( &indf, status );

      sprintf( name, "res%d", jj );
      ndfOpen( DAT__ROOT, name, "WRITE", "NEW", &indf, &place, status );
      ndfNew( "_DOUBLE", cupidGC.ndim, lbnd, ubnd, &place, &indf, status );
      ndfMap( indf, "DATA", "_DOUBLE", "WRITE", (void *) &data, &el, status );
      for( i = 0; i < el; i++ ) data[ i ] = cupidGC.resu[ i ];
      ndfAnnul( &indf, status );

      sprintf( name, "wgt%d", jj );
      ndfOpen( DAT__ROOT, name, "WRITE", "NEW", &indf, &place, status );
      ndfNew( "_DOUBLE", cupidGC.ndim, lbnd, ubnd, &place, &indf, status );
      ndfMap( indf, "DATA", "_DOUBLE", "WRITE", (void *) &data, &el, status );
      for( i = 0; i < el; i++ ) data[ i ] = cupidGC.weight[ i ];
      ndfAnnul( &indf, status );

      sprintf( name, "initmodel%d", jj );
      ndfOpen( DAT__ROOT, name, "WRITE", "NEW", &indf, &place, status );
      ndfNew( "_DOUBLE", cupidGC.ndim, lbnd, ubnd, &place, &indf, status );
      ndfMap( indf, "DATA", "_DOUBLE", "WRITE", (void *) &data, &el, status );
      for( i = 0; i < el; i++ ) data[ i ] = cupidGC.initmodel[ i ];
      ndfAnnul( &indf, status );

      sprintf( name, "model%d", jj );
      ndfOpen( DAT__ROOT, name, "WRITE", "NEW", &indf, &place, status );
      ndfNew( "_DOUBLE", cupidGC.ndim, lbnd, ubnd, &place, &indf, status );
      ndfMap( indf, "DATA", "_DOUBLE", "WRITE", (void *) &data, &el, status );
      for( i = 0; i < el; i++ ) data[ i ] = cupidGC.model[ i ];
      ndfAnnul( &indf, status );
   }

}


