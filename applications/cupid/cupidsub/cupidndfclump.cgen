#include "sae_par.h"
#include "cupid.h"
#include "ast.h"
#include "mers.h"
#include "ndf.h"
#include "star/hds.h"

int CGEN_FUNCTION(cupidNdfClump)( CGEN_TYPE *ipd, int *ipa, int nel, 
                                  int ndim, int dims[ 3 ], int skip[ 3 ], 
                                  int slbnd[ 3 ], int index, int clbnd[ 3 ], 
                                  int cubnd[ 3 ], AstKeyMap *extra ){
/*
*  Name:
*     cupidNdfClump<X>

*  Purpose:
*     Create an NDF containing a description of a single clump.

*  Synopsis:
*     int cupidNdfClump<X>( CGEN_TYPE *ipd, int *ipa, int nel, int ndim, 
*                           int dims[ 3 ], int skip[ 3 ], int slbnd[ 3 ], 
*                           int index, int clbnd[ 3 ], int cubnd[ 3 ], 
*                           AstKeyMap *extra )

*  Description:
*     This function cannot be used with algorithms such as GaussClumps
*     which support overlapping clumps. Each pixel must either be associated
*     with a single clump, or with no clump. It creates a temporary NDF and 
*     stores the clump intensist in its Data component. The bounds of the NDF 
*     will be the smallest possible which still encompass the clump. In 
*     addition, if required it will create a Cupid extension in the NDF 
*     containing any supplied extra information.

*  Parameters:
*     ipd
*        Pointer to the start of the supplied data array. 
*     ipa
*        Pointer to the start of the array holding the integer index
*        (if any) associated with each pixel in the data array. This
*        shows which clump each pixel belongs to (each clump is identified 
*        by a unique integer index). The array should be the same shape and 
*        size as the data array. Pixels which have not yet been assigned
*        to a clump are marked with the integer value CUPID__CFNULL.
*     nel
*        The total number of elements in the data array. 
*     ndim
*        The number of pixel axes in the data array.
*     dims
*        The number of pixels on each pixel axis of the data array. This
*        array should have 3 elements even if "ndim" is less than 3, and
*        the extra elements should be filled with 1's.
*     skip
*        The increment in 1D vector index required to move a distance of 1 
*        pixel along each axis. This allows conversion between indexing
*        the array using a single 1D vector index and using nD coords. This
*        array should have 3 elements even if "ndim" is less than 3, and
*        the extra elements should be filled with zero's.
*     slbnd
*        An array holding the lower pixel index bound of the data array on 
*        each axis, padded with trailing 1's.
*     index
*        The integer value used to represent the clump within "ipa".
*     clbnd
*        The lower grid index bounds of the clump.
*     cubnd
*        The upper grid index bounds of the clump.
*     extra
*        An AstKeyMap holding extra diagnositic information to add to the
*        clump structure.

*  Returned Value:
*     The NDF identifier for the new NDF.

*  Notes:
*     - This function can be invoked using the generic cupidNdfClump macro 
*     defined in cupid.h. This macro has the same parameter list as 
*     cupidNdfClump<X> except that an extra parameter is added to the start 
*     of the parameter list indicating the data type of the specific 
*     cupidNdfClump... function to be invoked. This extra parameter should
*     be an integer and should be one of CUPID__DOUBLE, CUPID__FLOAT, etc.

*  Authors:
*     DSB: David S. Berry
*     {enter_new_authors_here}

*  History:
*     3-FEB-2006 (DSB):
*        Original version.
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}
*/      

/* Local Variables: */
   HDSLoc *dloc;             /* Component locator */
   HDSLoc *xloc;             /* Extension locator */
   const char *key;          /* KeyMap key name */
   double *out;              /* Pointer to output NDF Data array */
   double *pout;             /* Pointer to next output pixel */
   double dval;              /* Double value to store */
   int el;                   /* Number of elements mapped */
   int i;                    /* KeyMap index */
   int ivinx;                /* Index of input pixel */
   int iviny;                /* Index of start of input row */
   int ivinz;                /* Index of start of input plane */
   int ix;                   /* GRID axis 1 value of next clump element */
   int iy;                   /* GRID axis 2 value of next clump element */
   int iz;                   /* GRID axis 3 value of next clump element */
   int lb[ 3 ];              /* Lower pixel index bounds of NDF */
   int nex;                  /* No. of extra items of information */
   int place;                /* NDF place holder */
   int ret;                  /* The returned NDF identifier */
   int ub[ 3 ];              /* Upper pixel index bounds of NDF */

/* Initialise */
   ret = NDF__NOID;

/* Abort if an error has already occurred. */
   if( *status != SAI__OK ) return ret;

/* Find the pixel index bounds of the NDF. */
   for( i = 0; i < ndim; i++ ) {
      lb[ i ] = clbnd[ i ] - 1 + slbnd[ i ];
      ub[ i ] = cubnd[ i ] - 1 + slbnd[ i ];
   }

/* Create a place holder for a temporary NDF. The NDF will be copied to a 
   permanent location before the program exits. */
   ndfTemp( &place, status );

/* Create the NDF covering the clump bounding box to receive the clump 
   values. */
   ndfNew( "_DOUBLE", ndim, lb, ub, &place, &ret, status );

/* Map the NDFs Data array. */
   ndfMap( ret, "DATA", "_DOUBLE", "WRITE", (void *) &out, &el, status );
   if( out ) {

/* Find the 1D vector index within the input array of the first pixel in the 
   clump bounding box. */
      ivinz = ( clbnd[ 0 ] - 1 ) + dims[ 0 ]*( ( clbnd[ 1 ] - 1 ) + 
                                    dims[ 1 ]*( clbnd[ 2 ] - 1 ) );

/* Store a pointer to the next output pixel value */
      pout = out;

/* Step round every pixel within the clump bounding box. (ix,iy,iz)
   represent GRID indices within the input array. */
      for( iz = clbnd[ 2 ]; iz <= cubnd[ 2 ]; iz++ ) {
         iviny = ivinz;
         for( iy = clbnd[ 1 ]; iy <= cubnd[ 1 ]; iy++ ) {
            ivinx = iviny;
            for( ix = clbnd[ 0 ]; ix <= cubnd[ 0 ]; ix++ ) {

/* If this pixel is in the clump, store the input data in the output.*/
               if( ipa[ ivinx ] == index ) {
                  *pout = ipd[ ivinx ];
               } else {                  
                  *pout = VAL__BADD;
               }

/* Move on to the next output pixel. */
               pout++;

/* Move on to the next input pixel. */
               ivinx++;
            }
            iviny += skip[ 1 ];
         }
         ivinz += skip[ 2 ];
      }

/* Unmap the NDFs Data array. */
      ndfUnmap( ret, "DATA", status );
   }

/* If required, create a Cupid extension in the NDF, storing any extra 
   supplied diagnostic information. */
   if( extra ) {
      xloc = NULL;  
      ndfXnew( ret, "CUPID", "CUPID_EXT", 0, NULL, &xloc, status );
      nex = astMapSize( extra );
      for( i = 0; i < nex; i++ ) {
         key = astMapKey( extra, i );
         if( astMapGet0D( extra, key, &dval ) ) {
            datNew( xloc, (char *) key, "_DOUBLE", 0, NULL, status );
            datFind( xloc, (char *) key, &dloc, status );
            datPutD( dloc, 0, NULL, &dval, status );
            datAnnul( &dloc, status );
         }
      }

/* Release the extension locator. */
      datAnnul( &xloc, status );
   }

/* Return the NDF identifier */
   return ret;

}

