#include "sae_par.h"
#include "cupid.h"
#include "ast.h"
#include "mers.h"

CupidPixelSet **CGEN_FUNCTION(cupidCFScan)( CGEN_TYPE *ipd, int *ipa, int nel, 
                                            int ndim, int dims[3], int skip[3],
                                            CupidPixelSet **clumps, 
                                            double clevel, int *index,
                                            int naxis, int ilevel, 
                                            int *slbnd, double *maxpd ){
/*
*  Name:
*     cupidCFScan<X>

*  Purpose:
*     Scan the data array for clumps at a new contour level.

*  Synopsis:
*     CupidPixelSet **cupidCFScan<X>( CGEN_TYPE *ipd, int *ipa, int nel, 
*                                     int ndim, int dims[3], int skip[3], 
*                                     CupidPixelSet **clumps, 
*                                     double clevel, int *index, int naxis,
*                                     int ilevel, int *slbnd, double *maxpd )

*  Description:
*     This function scans the data array for pixels at or above the
*     specified contour level which have not already been assigned to a
*     clump. Such pixels are either added to one of the existing clumps 
*     supplied in "clumps" or are used to create a new clump. An array of 
*     PixelSets is returned which contains the supplied clumps (suitably 
*     extended to contain the pixels at the new contour level) and any new 
*     clumps found at this contour level.

*  Parameters:
*     ipd
*        Pointer to the start of the supplied data array. 
*     ipa
*        Pointer to the start of the array holding the integer index
*        (if any) associated with each pixel in the data array. This
*        shows which clump each pixel belongs to (each clump is identified 
*        by a unique integer index). The array should be the same shape and 
*        size as the data array. Pixels which have not yet been assigned
*        to a clump are marked with the integer value CUPID__CFNULL.
*     nel
*        The total number of elements in the data array. 
*     ndim
*        The number of pixel axes in the data array.
*     dims
*        The number of pixels on each pixel axis of the data array. This
*        array should have 3 elements even if "ndim" is less than 3, and
*        the extra elements should be filled with 1's.
*     skip
*        The increment in 1D vector index required to move a distance of 1 
*        pixel along each axis. This allows conversion between indexing
*        the array using a single 1D vector index and using nD coords. This
*        array should have 3 elements even if "ndim" is less than 3, and
*        the extra elements should be filled with zero's.
*     clumps
*        An array of pointers, each locating a PixelSet structure. The
*        number of pointers in the array is given by the supplied value 
*        of "*index". Each PixelSet describes one clump found at a higher
*        contour level. Ignored (and consequently may be NULL) if "*index"
*        is zero. The index within this array at which a pointer to a
*        particular PixelSet is stored should equal the index value
*        stored within the PixelSet structure (this makes it easy and
*        fast to get a pointer to aPixelSet with a particular index value).
*        Elements of the array which are not used should hold NULL.
*     clevel
*        The data value at which to scan the supplied data array.
*     index
*        Pointer to an int holding the next free PixelSet index value 
*        (or in other words, the number of PixelSets defined at higher
*        contour levels). The index value is the value stored in the "ipa" 
*        array to identify all the pixels within a set of contiguous pixels. 
*        The same value is stored within the PixelSet structure describing 
*        the set of contiguous pixels. Updated on exit to take account of any 
*        newly issued index values. The supplied value also specifies the 
*        length of the supplied "clumps" array, and the returned value 
*        specifies the length of the array returned as the function value.
*     naxis
*        Determines which adjoining pixels are considered to be "neighbours" 
*        of a specified central pixel. Should be in the range 1 to "ndim". 
*        For a pixel to be considered to be a neighbour of another pixel,
*        the two pixels must be no more than 1 pixel away along no more than 
*        "naxis" axes.
*     ilevel
*        Diagnostic information level.
*     slbnd
*        Pointer to an array holding the lower pixel index bound of the
*        data array on each axis.
*     maxpd
*        Pointer to a double in which to return the largest data value
*        which has not yet been incorporated into a clump.

*  Returned Value:
*     A pointer to a possibly new array in which each element is a 
*     pointer to a PixelSet structure (this may be the same as the
*     supplied "clumps" pointer). The number of pointers in the 
*     array is returned in "*index". These are the PixelSets defining the
*     clumps at the given contour level. All the supplied clump pointers
*     will be present in the returned array, but additional new pointers
*     may be added to describe new clumps which appear at this contour level.
*     The original clump PixelSets will usually have been extended to
*     include the extra pixels found at this contour level. The index within 
*     this array at which a pointer to a particular PixelSet is stored 
*     will equal the index value stored within the PixelSet structure.
*     Elements of the array which are not used are set to NULL.

*  Notes:
*     - If a new array of PixelSets is created and returned, the original 
*     array given by the "clumps" parameter will be freed.
*     - This function can be invoked using the generic cupidCFScan macro 
*     defined in cupid.h. This macro has the same parameter list as 
*     cupidCFScan<X> except that an extra parameter is added to the start 
*     of the parameter list indicating the data type of the specific 
*     cupidCFScan... function to be invoked. This extra parameter should
*     be an integer and should be one of CUPID__DOUBLE, CUPID__FLOAT, etc.

*  Authors:
*     DSB: David S. Berry
*     {enter_new_authors_here}

*  History:
*     24-NOV-2005 (DSB):
*        Original version.
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}
*/      

/* Local Variables: */
   CGEN_TYPE *pd;        /* Pointer to next data pixel */
   CupidPixelSet **ret;  /* The returned pointer */
   CupidPixelSet *ops;   /* Pointer to neighbouring PixelSet */
   CupidPixelSet *ps;    /* Pointer to new PixelSet */
   CupidPixelSet *psn;   /* Pointer to neighbouring PixelSet */
   int *pa;              /* Pointer to next index value */
   int dec_index;        /* Decrement last used index? */
   int edge;             /* Pixel at upper or lower bound on any axis? */
   int hindex;           /* Next available index on entry */
   int i1[27];           /* List of adjoining PixelSet indices at this level */
   int i;                /* Loop count */
   int ii;               /* Loop count */
   int il1;              /* Lowest index of adjoining PixelSets at this level */
   int il2;              /* Index of adjoining PixelSets at higher level */
   int ix;               /* GRID index on 1st axis */
   int iy;               /* GRID index on 2nd axis */
   int iz;               /* GRID index on 3rd axis */
   int j;                /* Loop count */
   int more;             /* Should we continue looping? */
   int n1;               /* No. of adjoining PixelSets at this level */
   int new_clumps;       /* Number of new clumps found at this level */
   int total_pop;        /* Number of pixels checked at this level */
   int x[3];             /* GRID coords of current pixel */
   int yedge;            /* Pixel at upper or lower bound on 2nd axis? */
   int zedge;            /* Pixel at upper or lower bound on 3rd axis? */

/* Initialise */
   ret = clumps;

/* Abort if an error has already occurred. */
   if( *status != SAI__OK ) return ret;

/* Note the next available index value. This value is used to
   differentiate between PixelSets created at the current contour level
   and those created at higher contour levels (PixelSets created at higher 
   contour levels will have indices less than hindex). */
   hindex = *index;   

/* Scan the data array for good pixels which are above (or at) the supplied 
   contour level and have not yet been assigned to a PixelSet (i.e. have a 
   null index in the "ipa" array). Keep a check on whether the pixel is
   an edge pixel or not. */
   *maxpd = VAL__MIND;
   pd = ipd - 1;
   pa = ipa - 1;
   i = -1;

   for( iz = 1; iz <= dims[ 2 ]; iz++ ) {
      x[ 2 ] = iz;
      zedge = ( ndim > 2 && ( iz == 1 || iz == dims[ 2 ] ) );

      for( iy = 1; iy <= dims[ 1 ]; iy++ ) {
         x[ 1 ] = iy;
         yedge = ( ndim > 1 && ( iy == 1 || iy == dims[ 1 ] ) );

         for( ix = 1; ix <= dims[ 0 ]; ix++ ) {
            x[ 0 ] = ix;
            edge = yedge || zedge || ( ix == 1 || ix == dims[ 0 ] );

            i++;
            pd++;
            pa++;

            if( *pa == CUPID__CFNULL ) {
               if( *pd != CGEN_BAD ) {
                  if( *pd >= clevel ) {

/* When such a pixel is found, have a look at its immediate neighbours and 
   see if any of them have already been assigned to a PixelSet. If they
   have, identify which PixelSet they are assigned to. We distinguish two
   different types of PixelSets; those which were identified at this contour
   level, and those which were identified at higher contour levels. */
                     cupidCFNebs( ipa, i, x, ndim, dims, skip, hindex, 
                                  naxis, &n1, &il1,  i1, &il2, ret );

/* If this pixel adjoins a PixelSet defined at a higher contour level,
   save a pointer to the adjoining PixelSet. */
                     psn = ( il2 != CUPID__CFNULL ) ? ret[ il2 ] : NULL;

/* If none of the neighbours of this pixel are assigned to a PixelSet
   which was identified at this contour level, then start a new PixelSet. */
                     if( n1 == 0 ) {

/* Find the index value to use. We re-use indices for any PixelSets which
   have been transferred into some other PixelSet. This keeps the size of
   the "ret" array to a minimum and prevents us exceeding the largest allowed
   index value. */
                        while( *index > hindex && !ret[ *index - 1 ] ) (*index)--;

/* Abort if we are using too many PixelSets. The limit is set by the need 
   to be able to pack two indices into a single "int" in order to store the 
   actual PixelSet index plus a neighbouring PixelSet index in a single
   "int". The packing and unpacking are handled by macros cupidMergeSet, 
   cupidMergeNeb and cupidMergeIndex. The lower 14 bits of a packed "int" 
   hold the index of the PixelSet containing the pixel. Therefore, the index 
   of any PixelSet cannot exceed 2^14. */
                        if( *index >= CUPID__MAXINDEX ) {

                           for( ii = 0; ii < *index; ii++ ) {
                              ret[ ii ] = cupidCFFreePS( ret[ ii ], NULL, nel );
                           }

                           *status = SAI__ERROR;
                           errRep( "CUPIDCFSCAN_ERR1", "Too many contiguous pixel "
                                   "sets needed. Try using larger contour intervals "
                                   "or a higher minimum contour level.", status );
                           goto L999;

/* Otherwise, allocate memory for a new PixelSet structure and initialise
   it. Also, put the new PixelSet pointer into the relevant element of the
   returned array, extending the array if necessary. */
                        } else {
                           ps = cupidCFMakePS( *index );
                           ret = astGrow( ret, ++(*index), sizeof( CupidPixelSet * ) );
   
                           if( ret && ps ) {
                              ret[ ps->index ] = ps;
   
/* Add the current pixel to this new PixelSet. */
                              cupidCFAddPixel( ipa, ps, i, x, (double ) *pd, 
                                               edge, psn );
                           }
                        }

/* If one or more of the neighbours of this pixel are assigned to PixelSets
   which were identified at this contour level, then add this pixel into
   the PixelSet with the lowest index. */
                     } else {
                        ps = ret[ il1 ];
                        cupidCFAddPixel( ipa, ps, i, x, (double ) *pd, edge, 
                                         psn );

/* If this pixel touches other PixelSets identified at this contour level, 
   then transfer the pixels contained in them all into the PixelSet with 
   lowest index, and then free the memory used to hold them. */
                        if( n1 > 1 ) {
                           for( ii = 0; ii < n1; ii++ ) {
                              ops = ret[ i1[ ii ] ];
                              if( ops && ops != ps ) {
                                 cupidCFXfer( ops, ps, ipa, skip );
                                 ret[ i1[ ii ] ] = cupidCFFreePS( ops, NULL, nel );
                              }
                           }
                        }
                     }

/* If the current pixel data value is good but is lower than the current
   contour level (and has so not been assigned to a clump), note the
   largest such data value. This will tell us if we can skip some of the
   following contour levels due to them being empty. */
                  } else if( *pd > *maxpd ) {
                     *maxpd = *pd;
                  } 
               }
            }
         }
      }
   }

/* Now check each of the new PixelSets created above. If the last used
   index is freed, then decrement the last used index in "*index" so that we
   can re-use the index. This keeps the size of the "ret" array down. */
   dec_index = 1;
   new_clumps = 0;
   total_pop = 0;
   for( i = *index - 1; i >= hindex; i-- ) {
      ps = ret[ i ];
      if( ps ) {
         total_pop += ps->pop;

/* Tell the user about the new PixelSet. */
         if( ilevel > 3 ) {
            msgSeti( "I", ps->index );
            msgSeti( "P", ps->pop );
            msgOut( "", "   New PixelSet: index ^I population ^P", status );
         }

/* If the new PixelSet does not touch any of the existing PixelSets (i.e. the 
   clumps found at higher contour levels), then it is a new clump, so
   tell the user and leave it in the returned list of clumps. */
         if( ps->nnb == 0 ) {
            if( ilevel > 3 ) {
               msgSetd( "V", ps->vpeak );
               msgSeti( "C", ps->peak[ 0 ] + slbnd[ 0 ] - 1 );
               for( j = 1; j < ndim; j++ ) {
                  msgSetc( "C", "," );
                  msgSeti( "C", ps->peak[ j ] + slbnd[ j ] - 1 );
               }
               msgOut( "", "      Retained as a new peak: pos (^C): value ^V", 
                       status );
            }
            dec_index = 0;
            new_clumps++;
   
/* If the new PixelSet touches just one of the existing PixelSets, then 
   it is an extension of that clump. Transfer all the pixels in the new 
   PixelSet into the existing clump. */
         } else if( ps->nnb == 1 ) {

            if( ilevel > 3 ) {
               msgSeti( "J", ps->nb[ 0 ]->index );
               msgSeti( "P", ps->nb[ 0 ]->pop );
               msgOut( "", "      Transferred to index ^J: new population ^P", status );
            }

            cupidCFXfer( ps, ps->nb[ 0 ], ipa, skip );
   
/* Release the resources used by the PixelSet structure. */
            ret[ i ] = cupidCFFreePS( ps, NULL, nel );
            if( dec_index ) (*index)--;
   
/* If a new PixelSet has been created which touches two or more of the 
   existing PixelSets, then we loop round extending each of the existing 
   clumps by one pixel on each pass. The pixels in the new PixelSet
   which are encompassed by such a clump extension are move from the new 
   PixelSet to the extended clump. Finally, release the resources used by
   the PixelSet structure. */
         } else {
            more = 1;
            while( more ) {
               more = 0;
               for( j = 0; j < ps->nnb; j++ ) {
                  ops = ps->nb[ j ];
                  if( CGEN_FUNCTION(cupidCFXtend)( ps, ops, ipd, ipa, ndim, dims, 
                                                   skip, 3, ret ) ) more = 1;
                  if( ilevel > 3 && ops ) {
                     msgSeti( "I", ps->index );
                     msgSeti( "J", ops->index );
                     msgOut( "", "      Index ^J extended into index ^I:", status );
                     msgSeti( "P", ps->pop );
                     msgSeti( "I", ps->index );
                     msgOut( "", "         Index ^I now contains ^P pixels", status );
                     msgSeti( "P", ops->pop );
                     msgSeti( "J", ops->index );
                     msgOut( "", "         Index ^J now contains ^P pixels", status );
                  }
               }
            }
            ret[ i ] = cupidCFFreePS( ps, NULL, nel );
            if( dec_index ) (*index)--;
         } 
      }
   }

/* Issue summary information for this contour level. */
   if( ilevel > 2 ) {
      msgSeti( "P", total_pop );
      msgSetc( "P", (total_pop == 1) ? " pixel" : " pixels" );
      msgSeti( "N", new_clumps );
      msgSetc( "N", (new_clumps == 1) ? " new clump" : " new clumps" );
      msgOut( "", "   ^P checked, ^N found", status );
      msgBlank( status );
   }

L999:

/* Return the expanded list of clumps. */
   return ret;

}


