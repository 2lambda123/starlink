#include "sae_par.h"
#include "cupid.h"
#include "ast.h"
#include "mers.h"

CupidPixelSet **CGEN_FUNCTION(cupidCFScan)( CGEN_TYPE *ipd, int *ipa, int nel, 
                                            int ndim, int dims[3], int skip[3],
                                            CupidPixelSet **clumps, 
                                            double clevel, int *index,
                                            int naxis, int ilevel, 
                                            int *slbnd ){
/*
*  Name:
*     cupidCFScan<X>

*  Purpose:
*     Scan the data array for clumps at a new contour level.

*  Synopsis:
*     CupidPixelSet **cupidCFScan<X>( CGEN_TYPE *ipd, int *ipa, int nel, 
*                                     int ndim, int dims[3], int skip[3], 
*                                     CupidPixelSet **clumps, 
*                                     double clevel, int *index, int naxis,
*                                     int ilevel, int *slbnd )

*  Description:
*     This function scans the data array for pixels at or above the
*     specified contour level which have not already been assigned to a
*     clump. Such pixels are either added to one of the existing clumps 
*     supplied in "clumps" or are used to create a new clump. An array of 
*     PixelSets is returned which contains the supplied clumps (suitably 
*     extended to contain the pixels at the new contour level) and any new 
*     clumps found at this contour level.

*  Parameters:
*     ipd
*        Pointer to the start of the supplied data array. 
*     ipa
*        Pointer to the start of the array holding the integer index
*        (if any) associated with each pixel in the data array. This
*        shows which clump each pixel belongs to (each clump is identified 
*        by a unique integer index). The array should be the same shape and 
*        size as the data array. Pixels which have not yet been assigned
*        to a clump are marked with the integer value CUPID__CFNULL.
*     nel
*        The total number of elements in the data array. 
*     ndim
*        The number of pixel axes in the data array.
*     dims
*        The number of pixels on each pixel axis of the data array. This
*        array should have 3 elements even if "ndim" is less than 3, and
*        the extra elements should be filled with 1's.
*     skip
*        The increment in 1D vector index required to move a distance of 1 
*        pixel along each axis. This allows conversion between indexing
*        the array using a single 1D vector index and using nD coords. This
*        array should have 3 elements even if "ndim" is less than 3, and
*        the extra elements should be filled with zero's.
*     clumps
*        An array of pointers, each locating a PixelSet structure. The
*        number of pointers in the array is given by the supplied value 
*        of "*index". Each PixelSet describes one clump found at a higher
*        contour level. Ignored (and consequently may be NULL) if "*index"
*        is zero. The index within this array at which a pointer to a
*        particular PixelSet is stored should equal the index value
*        stored within the PixelSet structure (this makes it easy and
*        fast to get a pointer to aPixelSet with a particular index value).
*        Elements of the array which are not used should hold NULL.
*     clevel
*        The data value at which to scan the supplied data array.
*     index
*        Pointer to an int holding the next free pixel index value. The
*        index value is the value stored in the "ipa" array to identify all
*        the pixels within a set of contiguous pixels. The same value is
*        stored within the PixelSet structure describing the set of contiguous
*        pixels. Updated on exit to take account of any newly issued index 
*        values. The supplied value also specifies the length of the
*        supplied "clumps" array, and the returned value specifies the length 
*        of the array returned as the function value.
*     naxis
*        Determines which adjoining pixels are considered to be "neighbours" 
*        of a specified central pixel. Should be in the range 1 to "ndim". 
*        For a pixel to be considered to be a neighbour of another pixel,
*        the two pixels must be no more than 1 pixel away along no more than 
*        "naxis" axes.
*     ilevel
*        Diagnostic information level.
*     slbnd
*        Pointer to an array holding the lower pixel index bound of the
*        data array on each axis.
*     

*  Returned Value:
*     A pointer to a possibly new array in which each element is a 
*     pointer to a PixelSet structure (this may be the same as the
*     supplied "clumps" pointer). The number of pointers in the 
*     array is returned in "*index". These are the PixelSets defining the
*     clumps at the given contour level. All the supplied clump pointers
*     will be present in the returned array, but additional new pointers
*     may be added to describe new clumps which appear at this contour level.
*     The original clump PixelSets will usually have been extended to
*     include the extra pixels found at this contour level. The index within 
*     this array at which a pointer to a particular PixelSet is stored 
*     will equal the index value stored within the PixelSet structure.
*     Elements of the array which are not used are set to NULL.

*  Notes:
*     - If a new array of PixelSets is created and returned, the original 
*     array given by the "clumps" parameter will be freed.
*     - This function can be invoked using the generic cupidCFScan macro 
*     defined in cupid.h. This macro has the same parameter list as 
*     cupidCFScan<X> except that an extra parameter is added to the start 
*     of the parameter list indicating the data type of the specific 
*     cupidCFScan... function to be invoked. This extra parameter should
*     be an integer and should be one of CUPID__DOUBLE, CUPID__FLOAT, etc.

*  Authors:
*     DSB: David S. Berry
*     {enter_new_authors_here}

*  History:
*     24-NOV-2005 (DSB):
*        Original version.
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}
*/      

/* Local Variables: */
   CGEN_TYPE *pd;        /* Pointer to next data pixel */
   CupidPixelSet **ret;  /* The returned pointer */
   CupidPixelSet *ops;   /* Pointer to neighbouring PixelSet */
   CupidPixelSet *ps;    /* Pointer to new PixelSet */
   int **w2;             /* Pointer to array of neighbour lists */
   int *pa;              /* Pointer to next index value */
   int *w1;              /* Pointer to array of neighbour population sizes */
   int dec_index;        /* Decrement last used index? */
   int exceed;           /* Too many pixelsets? */
   int hindex;           /* Next available index on entry */
   int i;                /* Loop count */
   int j;                /* Loop count */
   int k;                /* Loop count */
   int more;             /* Should we continue looping? */
   int new_clumps;       /* Number of new clumps found at this level */
   int rem;              /* Remaining count of pixels */
   int total_pop;        /* Number of pixels checked at this level */
   int x[3];             /* GRID coords of current pixel */

/* Initialise */
   ret = clumps;

/* Abort if an error has already occurred. */
   if( *status != SAI__OK ) return ret;

/* Note the next available index value. */
   hindex = *index;   

/* Indicate we have not exceeded the maximumnumber of pixelsets. */
   exceed = 0;

/* Allocate workspace. These are both array with an element for every
   index value used so far. Element "i" of "w1" holds the number of
   pixels in the new PixelSet which have been found to touch the existing
   PointSet with index "i". Element "i" of "w2" holds a pointer to a
   secondary array of ints which stores the 1D vector indices of the
   pixels in the new PixelSet which have been found to touch the existing
   PointSet with index "i". Thus, element "i" of "w1" gives the length
   of the secondary array for which a pointer is stored at element "i" 
   of "w2". */
   w1 = astMalloc( sizeof( int )*hindex );
   w2 = astMalloc( sizeof( int * )*hindex );
   if( ( w1 && w2 ) || !hindex ) {

/* Fill work array "w1" with zeros and "w2" with NULL to indicate that the 
   new PixelSet has not yet been found to touch any of the existing clumps. */
      for( j = 0; j < hindex; j++ ) {
         w1[ j ] = 0;   
         w2[ j ] = NULL;   
      }

/* Scan the data array for pixels which are above (or at) the supplied contour
   level and have not yet been assigned to a PixelSet (i.e. have a null 
   index in the "ipa" array). */
      pd = ipd;
      pa = ipa;
      for( i = 0; i < nel; i++, pd++, pa++ ) {
         if( *pd != CGEN_BAD && *pd >= clevel && *pa == CUPID__CFNULL ) {

/* Break out of hte loop if we are using too many PixelSets. The limit is set
   by the need to be able to pack two indices into a single "int" in
   order to store the actual PixelSet index plus a neighbouring PixelSet
   index in a single "int". The packing and unpacking are handled by
   macros cupidMergeSet, cupidMergeNeb and cupidMergeIndex. The lower 13
   bits of a packed "int" hold the index of the PixelSet containing the
   pixel. Therefore, the index of any PixelSet cannot exceed 2^13. */
            if( *index >= CUPID__MAXINDEX ) {
               exceed = 1;
               ps = NULL;

/* When such a pixel is found, create and initialise a new PixelSet to 
   decribe the contiguous set of adjoining pixels which are above the contour 
   level but which have not yet been assigned to a PixelSet, giving the 
   new PixelSet the next available index value. */
            } else {
               ps = astMalloc( sizeof( CupidPixelSet ) );
               ret = astGrow( ret, ++(*index), sizeof( CupidPixelSet * ) );
            }

            if( ret && ps ) {
               ps->index = (*index) - 1;
               ps->nnb = 0;
               ps->pop = 0;
               ps->nb = NULL;
               ps->sznbl = NULL;
               ps->nbl = NULL;
               ps->vpeak = -DBL_MAX;
               ret[ ps->index ] = ps;
   
/* Get the n-dimensional grid coords of the current pixel. */
               if( ndim > 2 ) {
                  x[ 2 ] = i/skip[ 2 ];
                  rem = i - x[ 2 ]*skip[ 2 ];
                  x[ 2 ]++;
               } else {
                  x[ 2 ] = 1;
                  rem = i;
               }
            
               if( ndim > 1 ) {
                  x[ 1 ] = rem/skip[ 1 ];
                  x[ 0 ] = rem - x[ 1 ]*skip[ 1 ] + 1;
                  x[ 1 ]++;
               } else {
                  x[ 1 ] = 1;
                  x[ 0 ] = i + 1;
               }     

/* Initialise the bounding box for the PixelSet so that it encompasses just 
   this one pixel. */
               ps->lbnd[ 2 ] = ps->ubnd[ 2 ] = x[ 2 ];
               ps->lbnd[ 1 ] = ps->ubnd[ 1 ] = x[ 1 ];
               ps->lbnd[ 0 ] = ps->ubnd[ 0 ] = x[ 0 ];

/* Locate all the adjoining pixels which are at or above the required contour 
   level and have not yet been assigned to a PixelSet. Add them to the
   PixelSet just created and give them the above index value in the "ipa" 
   array. As this search through the adjoining pixels is performed, note if 
   any pixel adjoins another existing PixelSet. */
               CGEN_FUNCTION(cupidCFCont)( ipd, ipa, nel, ndim, dims, skip,
                                           x, i, ps, clevel, w1, w2, naxis,
                                           hindex, ret );

/* Tell the user about the new PixelSet. */
               if( ilevel > 3 ) {
                  msgSeti( "I", ps->index );
                  msgSeti( "P", ps->pop );
                  msgOut( "", "   New PixelSet: index ^I population ^P", status );
               }

/* Count how many of the old PixelSets are neighbours to the new PixelSet. */
               for( j = 0; j < hindex; j++ ) {
                  if( w1[ j ] ) (ps->nnb)++;
               }

/* Allocate memory in the new PixelSet structure for a list holding pointers
   to the neighbouring PixelSets. */
               ps->nb = astMalloc( sizeof( CupidPixelSet *)*ps->nnb );

/* Allocate memory in the new PixelSet structure for a list of pointers
   to arrays that identify the pixels which adjoin each of the neighbouring 
   PixelSets. */
               ps->nbl = astMalloc( sizeof( int *)*ps->nnb );
               ps->sznbl = astMalloc( sizeof( int )*ps->nnb );

/* If OK, initialise the number of neighbouring clumps found so far, and loop 
   round each of the supplied clumps. */
               if( ps->sznbl ) {
                  k = 0;
                  for( j = 0; j < hindex; j++ ) {

/* Check to see if this supplied clump is a neighbour of the new clump.
   If it is, its element in the "w1" array will hold the number of pixels
   in the new PixelSet which adjoin it. If this number is zero, none of
   the pixels in the new PixelSet adjoin the supplied clump and so the
   supplied clump is not a neighbour of the new PixelSet. */
                     if( w1[ j ] ) {

/* If clump "j" is a neighbour of the new PixelSet store a pointer to
   clump "j" in the new PixelSet structure, and also store a pointer to
   the list which holds the 1D vector indices of the pixels in the new
   PixelSet which adjoin clump "j". */
                        (ps->nb)[ k ] = ret[ j ];
                        (ps->nbl)[ k ] = w2[ j ];
                        (ps->sznbl)[ k ] = w1[ j ];

/* Increment the number of clumps which are neighbours to the new
   PixelSet. */
                        k++;

/* Prepare the "w1" and "w2" arrays for the next pass thorugh this loop by 
   resetting them to hold zero and NULL. */
                        w1[ j ] = 0;
                        w2[ j ] = NULL;
                     }
                  }
               }

/* Abort if an error occurred. */
            } else {
               break;
            }
         }
      }
   }

/* Free the work arrays. */
   w1 = astFree( w1 );

   if( w2 ) {
      for( j = 0; j < hindex; j++ ) {
         if( w2[ j ] ) w2[ j ] = astFree( w2[ j ] );
      }
      w2 = astFree( w2 );
   }

/* Now check each of the new PixelSets created above. If the last used
   index is freed, then decrement the last used index in "*index" so that we
   can re-use the index. This keeps the size of the "ret" array down. */
   dec_index = 1;
   new_clumps = 0;
   total_pop = 0;
   for( i = *index - 1; i >= hindex; i-- ) {
      ps = ret[ i ];
      total_pop += ps->pop;

/* If the new PixelSet does not touch any of the existing PixelSets (i.e. the 
   clumps found at higher contour levels), then it is a new clump, so
   tell the user and leave it in the returned list of clumps. */
      if( ps->nnb == 0 ) {
         if( ilevel > 3 ) {
            msgSetd( "V", ps->vpeak );
            msgSeti( "C", ps->peak[ 0 ] + slbnd[ 0 ] - 1 );
            for( j = 1; j < ndim; j++ ) {
               msgSetc( "C", "," );
               msgSeti( "C", ps->peak[ j ] + slbnd[ j ] - 1 );
            }
            msgSeti( "I", ps->index );
            msgSeti( "P", ps->pop );
            msgOut( "", "   Peak found at (^C): peak ^V, index ^I, "
                    "population ^P", status );
         }
         dec_index = 0;
         new_clumps++;

/* If the new PixelSet touches just one of the existing PixelSets, then 
   it is an extension of that clump. Transfer all the pixels in the new 
   PixelSet into the existing clump. */
      } else if( ps->nnb == 1 ) {
         cupidCFXfer( ps, ps->nb[ 0 ], ipa, skip );

/* Inform user of how many pixels are now in the clump. */
         if( ilevel > 3 ) {
            msgSeti( "I", ps->index );
            msgSeti( "J", ps->nb[ 0 ]->index );
            msgSeti( "P", ps->nb[ 0 ]->pop );
            msgOut( "", "   Index ^I transfered to index ^J: new clump population ^P", status );
         }

/* Release the resources used by the PixelSet structure. */
         ret[ i ] = cupidCFFreePS( ps, NULL, nel );
         if( dec_index ) (*index)--;


/* If a new PixelSet has been created which touches two or more of the 
   existing PixelSets, then we loop round extending each of the existing 
   clumps by one pixel on each pass. The pixels in the new PixelSet
   which are encompassed by such a clump extension are move from the new 
   PixelSet to the extended clump. Finally, release the resources used by
   the PixelSet structure. */
      } else {
         more = 1;
         while( more ) {
            more = 0;
            for( j = 0; j < ps->nnb; j++ ) {
               ops = ps->nb[ j ];
               if( cupidCFXtend( ps, ops, ipa, ndim, dims, skip, 
                                 3, ret ) ) more = 1;
               if( ilevel > 3 && ops ) {
                  msgSeti( "I", ps->index );
                  msgSeti( "J", ops->index );
                  msgOut( "", "   Index ^J extended into index ^I:", status );
                  msgSeti( "P", ps->pop );
                  msgSeti( "I", ps->index );
                  msgOut( "", "      Index ^I now contains ^P pixels", status );
                  msgSeti( "P", ops->pop );
                  msgSeti( "J", ops->index );
                  msgOut( "", "      Index ^J now contains ^P pixels", status );
               }
            }
         }
         ret[ i ] = cupidCFFreePS( ps, NULL, nel );
         if( dec_index ) (*index)--;
      } 
   }

/* Issue summary information for this contour level. */
   if( ilevel > 2 ) {
      msgSeti( "P", total_pop );
      msgSetc( "P", (total_pop == 1) ? " pixel" : " pixels" );
      msgSeti( "N", new_clumps );
      msgSetc( "N", (new_clumps == 1) ? " new clump" : " new clumps" );
      msgOut( "", "   ^P checked, ^N found", status );
      msgBlank( status );
   }

/* Report an error if too many PixelSets have been used. */
   if( exceed && *status == SAI__OK ) {
      *status = SAI__ERROR;
      errRep( "CUPIDCFSCAN_ERR1", "Too many contiguous pixel "
              "sets needed. Try using larger contour intervals "
              "or a higher minimum contour level.", status );
   }

/* Return the expanded list of clumps. */
   return ret;

}


