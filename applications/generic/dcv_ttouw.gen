      INTEGER*2 FUNCTION DCV_<T>TOUW( VAL )
*+
*  Name:
*     DCV_<T>TOUW

*  Purpose:
*     Convert variable of type <COMM> to UNSIGNED WORD

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     RESULT = DCV_<T>TOUW( VAL )
*        There are functions to convert from B, UB, D, I, R and W.

*  Description:
*     This is a generic routine which converts a variable of type
*     <COMM> to UNSIGNED WORD. The routine is meant to complement the
*     file 'DCV_FUN', which cannot convert variables to UNSIGNED WORD
*     using statement functions (with the exception of UNSIGNED WORD to
*     UNSIGNED WORD).

*  Arguments:
*     VAL = <TYPE> (Given)
*        Variable to be converted to UNSIGNED WORD

*  Returned Value:
*     DCV_<T>TOUW = INTEGER*2
*        The UNSIGNED WORD value produced from VAL

*  Pitfalls:
*     -  This routine will crash (deliberately) if the argument cannot
*        be stored as an UNSIGNED BYTE value. To prevent this, use a
*        PRIMDAT routine instead.

*  Algorithm:
*     -  The function uses the DCV_<T>TOI function to convert the value
*        given to an INTEGER.
*     -  Check that the value is in range.
*     -  If it is, copy the input value to the output value, converting
*        it if necessary.
*     -  If it is not in range, generate a trap if we can or stop with
*        an error message.

*  External Routines Used:
*     DCV:
*        DCV_ITOUB

*  Implementation Deficiencies:
*     -  Because this routine has to mimic the statement functions,
*        there is no STATUS argument. If an overflow is detected, the
*        routine will simply abort.

*  Machine-specific features used:
*     -  This routine uses BYTE and INTEGER*2 variables, which are not
*        standard FORTRAN.

*  Copyright:
*     Copyright (C) 1993 Science & Engineering Research Council

*  Authors:
*     SMB: Steven Beard (ROE)
*     PMA: Peter Allan (Starlink, RAL)
*        {enter_new_authors_here}

*  History:
*     03-APR-1987 (SMB):
*        Original version.
*     15-APR-1987 (SMB):
*        Overflow check included
*     27-JAN-1993 (PMA):
*        Convert prologue to new ADAM style.
*        Remove the use of EQUIVALENCEing one element of a 2 word array
*        to an integer. This is not portable. Replace it with suitable
*        arithmetic.
*        Remove the call to LIB$STOP and replace it with a STOP
*        statement. This will no longer produce a stack dump on VMS,
*        but this is not possible on Unix anyway.
*     28-JAN-1993 (PMA):
*        Add some arithmetic that will generate a fault on machines that
*        trap integer overflow. On machines that do not, the STOP
*        statement will still be executed.
*     {enter_further_changes_here}


*  Bugs:
*     {note_any_bugs_here}

*-
      
*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'DCV_PAR'          ! DCV global range parameters

*  Arguments Given:
      <TYPE> VAL

*  External References:
      EXTERNAL DCV_ITOUB
      BYTE DCV_ITOUB             ! Convert an integer to a byte

*  Local Variables:
      INTEGER IVAL               ! An intermdiate variable

*  Internal references:
      INCLUDE 'DCV_FUN'          ! The DCV statement functions

*.

*  Convert the imported variable to integer.
      IVAL = DCV_<T>TOI( VAL )

*   Check the integer is in the correct range for conversion to
*   UNSIGNED WORD.
      IF( ( IVAL .GE. DCV__UWMIN ) .AND. ( IVAL .LE. DCV__UWMAX ) ) THEN

*  IVAL is in range - return the value.
*  Check to see if the value can be treated as a signed WORD value or
*  whether in needs special treatment.
         IF ( IVAL .LE. DCV__WMAX ) THEN
            DCV_<T>TOUW = IVAL
         ELSE

*  Subtract a constant to convert the UNSIGNED WORD value to an
*  equivalent one that fits into a signed WORD variable.
*  The rather strange constant copes with ones complement machines as
*  well as the more common two complement (except that it might not
*  generate -0).
            DCV_<T>TOUW = IVAL + DCV__WMIN - DCV__WMAX - 1
         END IF
      ELSE

*  IVAL is out of range.
*  Generate an integer overflow if the machine traps them, otherwise
*  just stop the program. The call to DCV_ITOUB and the test on IVAL is
*  to prevent an optimizer removing the assignment that generates the
*  overflow.
         IVAL = DCV_ITOUB( 1 )
         IVAL = IVAL + DCV__IMAX
         IF ( IVAL .NE. 0 ) THEN
            STOP 'Integer overflow trapped by DCV_<T>TOUW'
         END IF
      END IF


      END
