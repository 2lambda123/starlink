\documentclass[twoside,11pt]{article}
\pagestyle{myheadings}

%------------------------------------------------------------------------------
\newcommand{\stardoccategory}  {Starlink User Note}
\newcommand{\stardocinitials}  {SUN}
\newcommand{\stardocsource}    {sun7.5}
\newcommand{\stardocnumber}    {7.5}
\newcommand{\stardocauthors}   {S M Beard \\ P M Allan\\ Malcolm J. Currie\\ Peter W. Draper}
\newcommand{\stardocdate}      {2006 May 8}
\newcommand{\stardoctitle}     {GENERIC --- A Utility for Preprocessing Generic
				\\ Fortran and C Subroutines}
\newcommand{\stardocversion}   {1.2}
\newcommand{\stardocmanual}    {User's Guide}

%------------------------------------------------------------------------------

\newcommand{\stardocname}{\stardocinitials /\stardocnumber}
\renewcommand{\_}{{\tt\char'137}}     % re-centres the underscore
\markright{\stardocname}
\setlength{\textwidth}{160mm}
\setlength{\textheight}{230mm}
\setlength{\topmargin}{-2mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\setlength{\unitlength}{1mm}

% -----------------------------------------------------------------------------
%  Hypertext definitions.
%  ======================
%  These are used by the LaTeX2HTML translator in conjunction with star2html.

%  Comment.sty: version 2.0, 19 June 1992
%  Selectively in/exclude pieces of text.
%
%  Author
%    Victor Eijkhout                                      <eijkhout@cs.utk.edu>
%    Department of Computer Science
%    University Tennessee at Knoxville
%    104 Ayres Hall
%    Knoxville, TN 37996
%    USA

%  Do not remove the %\begin{rawtex} and %\end{rawtex} lines (used by
%  star2html to signify raw TeX that latex2html cannot process).
%\begin{rawtex}
\makeatletter
\def\makeinnocent#1{\catcode`#1=12 }
\def\csarg#1#2{\expandafter#1\csname#2\endcsname}

\def\ThrowAwayComment#1{\begingroup
    \def\CurrentComment{#1}%
    \let\do\makeinnocent \dospecials
    \makeinnocent\^^L% and whatever other special cases
    \endlinechar`\^^M \catcode`\^^M=12 \xComment}
{\catcode`\^^M=12 \endlinechar=-1 %
 \gdef\xComment#1^^M{\def\test{#1}
      \csarg\ifx{PlainEnd\CurrentComment Test}\test
          \let\html@next\endgroup
      \else \csarg\ifx{LaLaEnd\CurrentComment Test}\test
            \edef\html@next{\endgroup\noexpand\end{\CurrentComment}}
      \else \let\html@next\xComment
      \fi \fi \html@next}
}
\makeatother

\def\includecomment
 #1{\expandafter\def\csname#1\endcsname{}%
    \expandafter\def\csname end#1\endcsname{}}
\def\excludecomment
 #1{\expandafter\def\csname#1\endcsname{\ThrowAwayComment{#1}}%
    {\escapechar=-1\relax
     \csarg\xdef{PlainEnd#1Test}{\string\\end#1}%
     \csarg\xdef{LaLaEnd#1Test}{\string\\end\string\{#1\string\}}%
    }}

%  Define environments that ignore their contents.
\excludecomment{comment}
\excludecomment{rawhtml}
\excludecomment{htmlonly}
%\end{rawtex}

%  Hypertext commands etc. This is a condensed version of the html.sty
%  file supplied with LaTeX2HTML by: Nikos Drakos <nikos@cbl.leeds.ac.uk> &
%  Jelle van Zeijl <jvzeijl@isou17.estec.esa.nl>. The LaTeX2HTML documentation
%  should be consulted about all commands (and the environments defined above)
%  except \xref and \xlabel which are Starlink specific.

\newcommand{\htmladdnormallinkfoot}[2]{#1\footnote{#2}}
\newcommand{\htmladdnormallink}[2]{#1}
\newcommand{\htmladdimg}[1]{}
\newenvironment{latexonly}{}{}
\newcommand{\hyperref}[4]{#2\ref{#4}#3}
\newcommand{\htmlref}[2]{#1}
\newcommand{\htmlimage}[1]{}
\newcommand{\htmladdtonavigation}[1]{}

%  Starlink cross-references and labels.
\newcommand{\xref}[3]{#1}
\newcommand{\xlabel}[1]{}

%  LaTeX2HTML symbol.
\newcommand{\latextohtml}{{\bf LaTeX}{2}{\tt{HTML}}}

%  Define command to re-centre underscore for Latex and leave as normal
%  for HTML (severe problems with \_ in tabbing environments and \_\_
%  generally otherwise).
\newcommand{\latex}[1]{#1}
\newcommand{\setunderscore}{\renewcommand{\_}{{\tt\symbol{95}}}}
\latex{\setunderscore}

%  Redefine the \tableofcontents command. This procrastination is necessary
%  to stop the automatic creation of a second table of contents page
%  by latex2html.
\newcommand{\latexonlytoc}[0]{\tableofcontents}

% -----------------------------------------------------------------------------
%  Debugging.
%  =========
%  Remove % on the following to debug links in the HTML version using Latex.

% \newcommand{\hotlink}[2]{\fbox{\begin{tabular}[t]{@{}c@{}}#1\\\hline{\footnotesize #2}\end{tabular}}}
% \renewcommand{\htmladdnormallinkfoot}[2]{\hotlink{#1}{#2}}
% \renewcommand{\htmladdnormallink}[2]{\hotlink{#1}{#2}}
% \renewcommand{\hyperref}[4]{\hotlink{#1}{\S\ref{#4}}}
% \renewcommand{\htmlref}[2]{\hotlink{#1}{\S\ref{#2}}}
% \renewcommand{\xref}[3]{\hotlink{#1}{#2 -- #3}}

% -----------------------------------------------------------------------------
% ? Document-specific \newcommand or \newenvironment commands.

% Shorthands for hypertext links.
% -------------------------------
\newcommand{\ASTERIX}{{\footnotesize ASTERIX}\normalsize}
\newcommand{\ASTERIXref}{\xref{\ASTERIX}{sun98}{}}
\newcommand{\GENERIC}{{\footnotesize GENERIC}\normalsize}
\newcommand{\HDS}{{\footnotesize HDS}\normalsize}
\newcommand{\HDSref}{\xref{\HDS}{sun92}{}~}
\newcommand{\PRIMDAT}{{\footnotesize PRIMDAT}\normalsize}
\newcommand{\PRIMDATref}{\xref{\PRIMDAT}{sun39}{}~}

%------------------------------------------------------------------------------
% Add any \newcommand or \newenvironment commands here

% conditional text
\newcommand{\latexelsehtml}[2]{#1}
\begin{htmlonly}
  \renewcommand{\latexelsehtml}[2]{#2}
\end{htmlonly}

%------------------------------------------------------------------------------

% ? End of document specific commands
%------------------------------------------------------------------------------

%  Title Page.
%  ===========
\renewcommand{\thepage}{\roman{page}}
\begin{document}
\thispagestyle{empty}

%  Latex document header.
%  ======================
\begin{latexonly}
   CCLRC / {\sc Rutherford Appleton Laboratory} \hfill {\bf \stardocname}\\
   {\large Particle Physics \& Astronomy Research Council}\\
   {\large Starlink Project\\}
   {\large \stardoccategory\ \stardocnumber}
   \begin{flushright}
   \stardocauthors\\
   \stardocdate
   \end{flushright}
   \vspace{-4mm}
   \rule{\textwidth}{0.5mm}
   \vspace{5mm}
   \begin{center}
   {\Huge\bf  \stardoctitle \\ [2.5ex]}
   {\LARGE\bf \stardocversion \\ [4ex]}
   {\Huge\bf  \stardocmanual}
   \end{center}
   \vspace{5mm}

% ? Heading for abstract if used.
   \vspace{10mm}
   \begin{center}
      {\Large\bf Abstract}
   \end{center}
% ? End of heading for abstract.
\end{latexonly}

%  HTML documentation header.
%  ==========================
\begin{htmlonly}
   \xlabel{}
   \begin{rawhtml} <H1> \end{rawhtml}
      \stardoctitle\\
      \stardocversion\\
      \stardocmanual
   \begin{rawhtml} </H1> \end{rawhtml}

% ? Add picture here if required.
%  \htmladdimg{sun95_cover.gif}
% ? End of picture

   \begin{rawhtml} <P> <I> \end{rawhtml}
   \stardoccategory \stardocnumber \\
   \stardocauthors \\
   \stardocdate
   \begin{rawhtml} </I> </P> <H3> \end{rawhtml}
      \htmladdnormallink{CCLRC}{http://www.cclrc.ac.uk} /
      \htmladdnormallink{Rutherford Appleton Laboratory}
                        {http://www.cclrc.ac.uk/ral} \\
      \htmladdnormallink{Particle Physics \& Astronomy Research Council}
                        {http://www.pparc.ac.uk} \\
   \begin{rawhtml} </H3> <H2> \end{rawhtml}
      \htmladdnormallink{Starlink Project}{http://www.starlink.rl.ac.uk/}
   \begin{rawhtml} </H2> \end{rawhtml}
   \htmladdnormallink{\htmladdimg{source.gif} Retrieve hardcopy}
      {http://www.starlink.rl.ac.uk/cgi-bin/hcserver?\stardocsource}\\

%  HTML document table of contents.
%  ================================
%  Add table of contents header and a navigation button to return to this
%  point in the document (this should always go before the abstract \section).
  \label{stardoccontents}
  \begin{rawhtml}
    <HR>
    <H2>Contents</H2>
  \end{rawhtml}
  \renewcommand{\latexonlytoc}[0]{}
  \htmladdtonavigation{\htmlref{\htmladdimg{contents_motif.gif}}
        {stardoccontents}}

% ? New section for abstract if used.
  \section{\xlabel{abstract}Abstract}
% ? End of new section for abstract
\end{htmlonly}

% -----------------------------------------------------------------------------
% ? Document Abstract. (if used)
%   ==================
\GENERIC\ is tool for Fortran 77 and C developers to create type-specific
code from a generic source that includes tokens for type-dependent
elements.  This saves effort supporting multiple versions of the
source code.

% ? End of document abstract
% -----------------------------------------------------------------------------
% ? Latex document Table of Contents (if used).
%  ===========================================
 \newpage
 \begin{latexonly}
   \setlength{\parskip}{0mm}
   \latexonlytoc
   \setlength{\parskip}{\medskipamount}
   \markboth{\stardocname}{\stardocname}
%  \markright{\stardocname}
 \end{latexonly}
% ? End of Latex document table of contents
% -----------------------------------------------------------------------------
% \newpage
\cleardoublepage
\renewcommand{\thepage}{\arabic{page}}
\setcounter{page}{1}

% The main text begins here.
% -----------------------------------------------------------------------------

\section{Introduction}

\GENERIC\ is a utility which preprocesses a generic Fortran subroutine
into its different types and concatenates these routines into a file.
The file can then be compiled with the appropriate compiler to produce an
object module.

It also supports standardized C generic programming by providing a suitable
set of include files and rules for using them

\section{GENERIC Fortran Subroutines---an Example}

A generic subroutine is one which has an argument (or arguments)
which may be one of a number of different Fortran data types.

As an example, consider a subroutine which initialises every
element in an array to zero.
One might want a different version of the routine for initializing
a double precision array, an integer array and a real array.
The following subroutines would need to be written:

\begin{verbatim}
      ZEROD( N, DARR )   Zero every element in a DOUBLE PRECISION array
      ZEROI( N, IARR )   Zero every element in an INTEGER array
      ZEROR( N, RARR )   Zero every element in a REAL array
\end{verbatim}

The integer routine might contain the following code (in a file
called {\tt zeroi.f}):

\begin{verbatim}
          SUBROUTINE ZEROI( N, ARRAY )
    *+
    *  Name:
    *     ZEROI
    *  Purpose:
    *     Zero all the elements of an4 INTEGER array
    *  Invocation :
    *     CALL ZEROI( N, ARRAY )
    *  Description :
    *     This sets all the elements of an INTEGER array to zero
    *  Arguments:
    *     N = INTEGER( Given )
    *        Dimension of array
    *     ARRAY( N ) = INTEGER( Given and Returned )
    *        The array to be zeroed
    *                   "
    *     (the rest of the standard prologue)
    *                   "
    *  Type Definitions:
          IMPLICIT NONE
    *  Arguments Given:
          INTEGER N
    *  Arguments Given and Returned:
          INTEGER ARRAY( N )
    *  Local Variables:
          INTEGER I                   ! Array index
    *-

          DO I = 1, N
             ARRAY( I ) = 0
          END DO
          END
\end{verbatim}

The REAL and DOUBLE PRECISION versions of the routine would have to be
written in a similar way, and this obviously involves a lot of
duplication of effort.
The situation gets even worse if other versions of the routine
(such as BYTE, INTEGER*2) are needed.
Also, it is very difficult and tedious to keep all the versions
in step if they have to be edited individually when the routines
are changed.

The \GENERIC\ utility is a labour-saving device which enables all the
various types of routines to be constructed automatically from
one master routine.
If any changes become necessary, only this one master routine needs
to be edited.

To use the \GENERIC\ utility, the routine listed above is replaced by
the following (in a file called {\tt zero.gen}):

\begin{verbatim}
          SUBROUTINE ZERO<T>( N, ARRAY )
    *+
    *  Name:
    *     ZERO<T>
    *  Purpose:
    *     Zero all the elements of a <COMM> array
    *  Invocation :
    *     CALL ZERO<T>( N, ARRAY )
    *  Description :
    *     This sets all the elements of a <COMM> array to zero
    *  Argument:
    *     N = INTEGER( Given )
    *        Dimension of array
    *     ARRAY( N ) = <TYPE>( Given and Returned )
    *        The array to be zeroed
    *                   "
    *     (the rest of the standard prologue)
    *                   "
    *  Type Definitions:
          IMPLICIT NONE
    *  Arguments Given:
          INTEGER N
    *  Arguments Given and Returned:
          <TYPE> ARRAY( N )
    *  Local Variables:
          INTEGER I                  ! Array index
    *-

          DO I = 1, N
             ARRAY( I ) = 0<CONST>
          END DO
          END
\end{verbatim}

This is a ``generic routine.''
Other examples of generic routines include the DAT\_ routines in
the \xref{Hierarchical Data System}{sun92}{} (SUN/92) and the
\xref{PAR\_ routines}{sun114}{} of the \xref{ADAM parameter
system}{ssn29}{} (SSN/29).

The items in angle brackets, $<>$ , are ``tokens'' which the
\GENERIC\ utility replaces when it converts the routine into one
of a given type.
In the above example, the tokens would be replaced
as follows.

\begin{verbatim}
       Token       Double precision    Integer       Real
                   replacement         replacement   replacement

       <T>         D                   I             R
       <TYPE>      DOUBLE PRECISION    INTEGER       REAL
       <COMM>      DOUBLE PRECISION    INTEGER       REAL
       <CONST>     .0D0                (blank)       .0E0
\end{verbatim}

The types are generated by issuing the following command.

\begin{quote}{\tt
\% generic -t dir zero.gen
}
\end{quote}

More details on the use of the \GENERIC\ utility, and a full list of
tokens and types, are given in the rest of this document.

\section{Generic C programming}

To use \GENERIC\ for C routines follow the recipe described below. Note that
in this case we use the C preprocessor to create the necessary code, not the
{\tt generic} program. Clearly there are many ways to do this task, what is
presented here is just a standardized method tuned for working with Starlink
libraries.

First create your generic code routines. These actually go into an include
file that is conventionally named with extension {\tt .cgen}. There are four
macros defined for use when defining generic functions.

\begin{itemize}
\item {\tt CGEN\_FUNCTION}
\item {\tt CGEN\_TYPE}
\item {\tt CGEN\_BAD}
\item {\tt CGEN\_PRM\_TYPE}
\end{itemize}

You need to use {\tt CGEN\_FUNCTION} as part of the normal function
declaration so that generic forms of the function name can be generated on
inclusion. Each routine in a generic include file should start:

\begin{verbatim}
    return_type CGEN_FUNCTION(function_name) ( arg decs )
\end{verbatim}

So a routine called {\tt kpg1\_bad} that returned an int and accepted a
{\tt CGEN\_CTYPE} pointer, called {\tt value}, would be defined as:

\begin{verbatim}
    int CGEN_FUNCTION(kpg1_bad) (CGEN_CTYPE *value) {
        if ( value[0] == CGEN_BAD ) {
           return 1;
        }
        return 0;
    }
\end{verbatim}

with the trivial job of testing the first element of an array against the BAD
value constant.

The value of {\tt CGEN\_TYPE} will be set to the C type, that is
{\tt double}, {\tt float}, {\tt int}, {\tt short int},
{\tt unsigned short int}, {\tt char} and {\tt unsigned char}, as
appropriate.

The value of {\tt CGEN\_BAD} will be set to one of the \PRIMDAT\ constants
{\tt VAL\_\_BADD},
{\tt VAL\_\_BADR},
{\tt VAL\_\_BADI},
{\tt VAL\_\_BADW},
{\tt VAL\_\_BADUW},
{\tt VAL\_\_BADB} or
{\tt VAL\_\_BADUB}
as appropriate, and the value of {\tt CGEN\_HDS\_TYPE} will be set to the HDS
type, one of
{\tt \_DOUBLE},
{\tt \_REAL},
{\tt \_INTEGER},
{\tt \_WORD},
{\tt \_UWORD},
{\tt \_BYTE} or
{\tt \_UBYTE}.

Now create a C file to includes the generic code. The include file is included
once for each of the data types you want to support (this file can also
contain related non-generic code).  To do this define the macro
{\tt CGEN\_CODE\_TYPE} to be one of the values:

\begin{verbatim}
    CGEN_DOUBLE_TYPE, CGEN_FLOAT_TYPE, CGEN_INT_TYPE, CGEN_WORD_TYPE, 
    CGEN_UWORD_TYPE, CGEN_BYTE_TYPE, CGEN_UBYTE_TYPE
\end{verbatim}

which selects the data type. Then include the file {\tt cgeneric\_defs.h}
followed by your generic include file, (called {\tt mygenerics.cgen} in the
following example):

\begin{verbatim}
    #include <prm_par.h>
    #include <cgeneric.h>

    #define CGEN_CODE_TYPE CGEN_DOUBLE_TYPE
    #include "cgeneric_defs.h"
    #include "mygenerics.cgen"
    #undef CGEN_CODE_TYPE

    #define CGEN_CODE_TYPE CGEN_INT_TYPE
    #include "cgeneric_defs.h"
    #include "mygenerics.cgen"
    #undef CGEN_CODE_TYPE
\end{verbatim}

when compiled this will generate code for {\tt double precision}
and {\tt integer} versions of the generic functions defined in
{\tt mygeneric.cgen}.

When you want to call the generic forms of a function, the name you supply to
the {\tt CGEN\_FUNCTION} macro has one of character codes {\tt D}, {\tt F},
{\tt I}, {\tt W}, {\tt UW},  {\tt B}, and {\tt UB} appended.  So for our
example {\tt kpg1\_bad}, we have the two functions {\tt kpg1\_badD} and
{\tt kpg1\_badI}.


\section{Features of the GENERIC Utility}

\subsection{The KERNEL Tokens}

The following tokens are recognised by the \GENERIC\ utility:

\newlength{\numlen}
\settowidth{\numlen}{000000000000}
\settowidth{\labelsep}{000}

\begin{list}{}{\setlength{\labelwidth}{\numlen}\setlength{\leftmargin}{\numlen}
\addtolength{\leftmargin}{\labelsep}}

\item[{\tt $<$T$>$}] To be replaced by a single character representation
of the specified type.

\item[{\tt $<$TYPE$>$}] To be replaced by the string used to declare variables
of the specified type when they are passed as arguments to
the subroutine.

\item[{\tt $<$LTYPE$>$}] To be replaced by the string used to declare variables
of the specified type when they are defined as local variables
in the subroutine.

\item[{\tt $<$CONST$>$}] To be replaced by the string appended to numeric
constants of the specified type.

\item[{\tt $<$HTYPE$>$}] To be replaced by the \HDSref\ name for the specified
type.

\item[{\tt $<$COMM$>$}] To be replaced by a comment describing the specified type
in plain English.

\end{list}

A full table of the translation of these tokens for each variable type
is given in
\latexelsehtml{Appendix~\ref{ap_a}}{the
\htmlref{token translations}{ap_a}}
at the end of this document.

\subsection{The ASTERIX Tokens}

As well as the kernel tokens, there are an additional set of
tokens which will be translated if the {\tt -a} option is specified
with the \GENERIC\ command (see below).

These tokens are available to allow \GENERIC\ to process existing
\ASTERIXref\ software (SUN/98) which uses them.
They are {\em not}\ recommended for use by new software.
A list of the \ASTERIX\ tokens is given in
\latexelsehtml{Appendix~\ref{ap_a}}{the
\htmlref{token translations}{ap_a}}.

\subsection{The Local CHARACTER Size}

The \verb+<LTYPE>+ token is used for declaring a variable which is local
to the subroutine in which it is used, whereas \verb+<TYPE>+ is used
to declare a variable which is passed to the routine as an argument.
In practice, the translation for both of these tokens is identical
for all types except CHARACTER.

In the CHARACTER type, a variable passed as an argument is declared
CHARACTER*(*), but a local variable is declared CHARACTER*\verb+<CHASIZ>+.
\verb+<CHASIZ>+ is replaced by the ``local character size.''
If not told otherwise, \GENERIC\ will replace \verb+<CHASIZ>+ by 200,
making local character variables CHARACTER*200.

It is possible to override this default character size
if it is unsuitable.  You can define the environment4 variable
GENERIC\_CHASIZ or you can use the {\tt -c} flag on the
{\bf generic} command.

\subsection{The Fortran Maximum Record Length}

The \GENERIC\ utility assumes it is dealing with Fortran 77
source code which cannot go beyond column 72.
If the substitution of a token results in a line becoming longer
than 72 characters, it will be broken automatically at column 72
and continued on the next line, using a ``:'' continuation character
in column 6 of the next line.

It is recommended that source lines in generic routines be kept
well below 72 characters in length to prevent this from happening.

{\bf NOTE:}~{\it Comment lines (~{\rm i.e.} those beginning `C', `c', `D', `d'
or `*') which are longer than 72 characters are unaltered by \GENERIC.
So are lines of code with an in-line comment (~\emph{i.e.} those containing
a ``!'' character).}

This algorithm is not perfect and it is possible to fool it with end
of line comments on long lines or exclamation marks in character
strings.  However, this seems not to have proven a problem in practice.

\section{Using the GENERIC Utility}

The \GENERIC\ utility is executed by typing the following command:

\begin{quote}{\tt
\% generic [-t <types>] [-a] [-c <chasiz>] [-s] [-sc <char>] [-u] [-x] \\
           file1 [file2...]}
\end{quote}

Arguments in square brackets are optional and items in angle brackets are
descriptive terms for the actual string that would be given.  The simplest form
of the {\bf generic} command is:

\begin{quote}{\tt
\% generic prog.gen
}
\end{quote}

which will produce a file called {\tt prog.f} containing routines for
all of the supported data types.  Likewise for C

\begin{quote}{\tt
\% generic prog.cgen
}
\end{quote}
will create a file {\tt prog.c}.

A softlink called {\bf fgeneric} is also provided to avoid a clash
with the IRAF generic preprocessor.

All generic input Fortran files must have a suffix of {\tt .gen}, or
{\tt .g\verb+<types>+} where \verb+<types>+ is a list of data types
(see option {\tt -t} below for a list).  The latter was introduced to
simplify building using GNU tools, and is the recommended naming
convention.  For C files the file extension should be {\tt .cgen}.

You can specify multiple input files explicitly or with wild cards.
All output Fortran files have a suffix of {\tt .f}, and output C files
have suffix {\tt .c}.

The {\bf generic} command accepts the following command-line options.

\begin{description}

\item[-t] This must be followed by a list of the data types to be
processed. The list should be separated from the {\tt -t} by a space,
and should consist of one or more of the letters {\tt a, b, B, c, d, i, l,
n, r, w or W}.  The letters have the following meanings:
\begin{center}
\begin{tabular}{ll}
{\tt a} & all data types \\
{\tt b} & BYTE \\
{\tt B} & unsigned BYTE \\
{\tt c} & CHARACTER \\
{\tt d} & DOUBLE PRECISION \\
{\tt i} & INTEGER \\
{\tt l} & LOGICAL \\
{\tt n} & all numeric types (\emph{i.e.} everything except CHARACTER and LOGICAL)\\
{\tt r} & REAL \\
{\tt w} & WORD (\emph{i.e.} INTEGER*2) \\
{\tt W} & unsigned WORD \\
\end{tabular}
\end{center}

For example, to generate routines for all of the standard Fortran numeric data
types, type the command:

\begin{quote}{\tt
\% generic -t dir prog.gen
}
\end{quote}

(Using {\tt n} instead of {\tt dir} would generate byte and word versions as
well.)

\item[-c] This should be followed by a space and then an integer
giving the value of the local character size required.  The default
value is 200. This value can be specified by the environment variable
{\tt GENERIC\_CHASIZ}.  If {\tt GENERIC\_CHASIZ} is defined and the
{\tt -c} argument is present, the {\tt -c} argument takes precedence.

\item[-s] Generate the output in separate files for each data type
with the single character type specifier appended to the base name of
the file.  The default is to generate one output file for each input
file.  For example, if the input file is {\tt sub1.gen} and the {\tt
-t} flag is set to {\tt dir}, then specifying the {\tt -s} flag will
cause output files called {\tt sub1d.f}, {\tt sub1i.f} and {\tt
sub1r.f} to be generated.  This option is provided as it is usual on
Unix systems to have all Fortran routines in separate source files.

\item[-sc] This flag allows the user to specify one or more characters
that will be used to separate the base file name from the appended
character when generating separate output files for each data type.
The {\tt -sc} should be followed by a space and then the character(s)
to be used as the separator.  For example, the command:

\begin{quote}{\tt
\% generic -t dir -sc \_ func2.gen
}
\end{quote}

will generate files called {\tt func2\_d.f}, {\tt func2\_i.f} and {\tt
func2\_r.f}.  If the {\tt -sc} flag is given, then the {\tt -s} flag can be
omitted.

\item[-a] This will cause the \ASTERIX\ tokens to be interpreted as well as the
standard ones.  Its use is deprecated.

\item[-u]  The B and W types substitute {\tt ub} and {\tt uw} tokens
respectively in the code and in generated filenames.  This is for
compability with the original VMS version when most generic routines were
developed.  However, note that the {\tt -t} values of BW should still be
used to obtain unsigned byte and unsigned-word instantiations.

\item[-x]  Removes the last {\tt x} from the file name before generating the
names of the output files.  This is provided for compatability
with early generic files in the VMS era files that had a final {\tt x} in the
name to indicate where the token would be replaced in the
instantiated files.  In modern usage the trailing {\tt x} is absent, and
this option is not required.

\end{description}

It is possible to specify the list of data types to be processed and the local
character size by setting environment variables {\tt GENERIC\_TYPES} and {\tt
GENERIC\_CHASIZ}, \emph{e.g.}

\begin{quote}{\tt
\% setenv GENERIC\_TYPES cdilr \\
\% setenv GENERIC\_CHASIZ 300
}
\end{quote}

\section{Data Type Conversions---the DCV Routines}

\subsection{Introduction}

Occasionally, it may be necessary to convert data passed into a
generic routine in a generic variable into another data type. A
general set of conversion functions was originally provided within
\GENERIC\ to make this possible.  However, \emph{new code requiring such
conversions should invoke the \PRIMDATref\ library of functions}.
\PRIMDAT\ also provides many other instrinsic functions that are
amenable to inclusion in generic code.  This section remains
only to interpret legacy code that still calls DCV routines.

A naming convention is used so that the function
DCV\_\verb+<T1>TO<T2>+ converts data type \verb+<T1>+ into \verb+<T2>+.

The functions which can be are defined using Fortran statement
functions in a file which may be included in a program by

\begin{quote}{\tt
INCLUDE 'DCV\_FUN'
}
\end{quote}

which should come after any data type definitions, but before
any DATA initialisation or executable code.
In the standard prologue of SGP/16, it should go in the
``Internal References'' section.

Conversions which cannot be defined as statement functions are
provided as external functions in an object library ({\tt
/star/lib/dcv.a} on a Starlink system).  Programs requiring these
functions should be compiled

\begin{quote}{\tt
\% f77 prog.f -L/star/lib `dcv\_link`
}
\end{quote}

on Unix.

The types of these functions can be declared in a program by including

\begin{quote}{\tt
INCLUDE 'DCV\_EXT'
}
\end{quote}

(in the ``External References'' section of the standard prologue).

{\bf NOTE:}~{\it Statement functions are considerably faster than external
functions, so programs which use the common conversions defined in `DCV\_FUN'
will execute a lot faster.}

Only numeric conversions are supported at present, and
there are no DCV\_ functions for conversions involving CHARACTER and
LOGICAL data types.
A full list of the functions, the conversion performed, and their
location and restrictions, is given in
\latexelsehtml{Appendix~\ref{ap_b}}{the
\htmlref{conversion functions}{ap_b}}.

\subsection{An Example of Data Type Conversion}

As an example, a generic subroutine for finding the mean of the data
contained in an array, where the array is of varying type but the mean is
always REAL, might look like the following routine.

\begin{verbatim}
          SUBROUTINE MEAN<T>( N, ARRAY, MEAN )
    *+
    *  Name:
    *     MEAN<T>
    *  Purpose:
    *     Calculate the mean value contained in a <COMM> array.
    *  Invocation :
    *     CALL MEAN<T>( N, ARRAY, MEAN )
    *  Description :
    *     This calculates the mean value of then data contained in the given
    *     <COMM> array, and returns the value in the REAL variable MEAN.
    *  Arguments:
    *     N = INTEGER( Given )
    *        The dimension of the array.
    *     ARRAY( N ) = <TYPE>( Given )
    *        The array containing the data to be averaged.
    *     MEAN = REAL( Returned )
    *        The mean of the values contained in the array.
    *                   "
    *     (the rest of the standard prologue)
    *                   "
    *  Type Definitions:
          IMPLICIT NONE
    *  Arguments Given:
          INTEGER N
          <TYPE> ARRAY( N )
    *  Arguments Returned:
          REAL MEAN
    *  External References:
          INCLUDE 'DCV_EXT'          ! Data conversion external functions
    *  Local Variables:
          INTEGER I                  ! Array index
          <LTYPE> SUM                ! Sum of the data in the array
    *  Internal References:
          INCLUDE 'DCV_FUN'          ! Data conversion statement functions
    *-

    *  Initialise the sum to zero.
          SUM = 0<CONST>

    *  Accumulate the sum of the contents of the array.
          DO I = 1, N
            SUM = SUM + ARRAY( N )
          END DO

    *  Divide by the dimension of the array to obtain the mean, using
    *  DCV_<T>TOR to convert from <COMM> into REAL.
          MEAN = DCV_<T>TOR( SUM ) / REAL( N )

          END
\end{verbatim}

In the above example, for the INTEGER version of the routine for
instance, the {\tt DCV\_ITOR(~SUM~)} statement will be converted to
{\tt REAL(~SUM~)} by the statement function in {\tt DCV\_FUN}.

\subsection{Range Checking}

The DCV\_\verb+<T1>+TO\verb+<T2>+ functions will not check the range of the
values given to them, and overflow errors are possible from some conversions
(\emph{e.g.} INTEGER to BYTE).
It is recommended that an application check the range of any value
given to a DCV function, to ensure it is within the allowed range.
Global parameters of the form DCV\_\_\verb+<T>+MIN and DCV\_\_\verb+<T>+MAX
are available for this purpose, which give the allowed range for type
\verb+<T>+ (\emph{e.g.} $-128$ to $+127$ for a BYTE).
These by may included in a program using the following line.

\begin{quote}{\tt
INCLUDE 'DCV\_PAR'
}
\end{quote}

(in the ``Global Parameters'' section of the standard prologue).

Here is an example of the use of these parameters (for instance
converting an INTEGER to another type).

\begin{verbatim}
    *             "
    *     (standard prologue)
    *             "
    *  Global Parameters:
          INCLUDE 'DCV_PAR'          ! DCV global parameters giving allowed
                                     ! ranges
    *             "
    *  External References:
          INCLUDE 'DCV_EXT'          ! DCV external function definitions
    *             "
    *  Local Variables:
          INTEGER IVAL               ! Integer value to be converted
          <TYPE> VAL                 ! Destination variable of type <COMM>
                    "
    *  Internal References:
          INCLUDE 'DCV_FUN'          ! DCV in-line statement functions
    *-
                  "
                  "
          IF ( ( IVAL .GE. DCV__<T>MIN ) .AND.
         :     ( IVAL .LE. DCV__<T>MAX ) ) THEN

    *  Value within range. The conversion is allowed.
             VAL = DCV_ITO<T>( IVAL )

          ELSE

    *  Error. Value out of range ...
             <take appropriate action>
          END IF
                  "
                  "
\end{verbatim}

Note that ranges are only provided for numeric data types.

An alternative (and easier) way of preventing numerical overflow from
causing problems is to use the \PRIMDAT\ routines instead of the
DCV ones.  The \PRIMDAT\ routines will not crash your program if an
overflow occurs.  See \xref{SUN/39}{sun39}{} for details.

\appendix
\newpage
\section{\xlabel{ap_a}A Full Table of Token Translations\label{ap_a}}

This appendix gives the translations of all the tokens
made by \GENERIC\ for each of the data types.
If a translation is illegal, the result will be ``?''
(and \GENERIC\ will give a warning message).

To produce the BYTE version of a program, the following substitutions
are made.
%bytekernal
\begin{tabbing}
xxxxxx\=xxxxxxxxxxxxx\=xxx\=xxxxxxxxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxx\kill
\>{\bf Kernel} tokens (translated by default): \\
\\
\>TOKEN  \>SUBSTITUTE  \>\>COMMENT \\
\\
\>$<$T$>$       \>\>{\tt "B"}       \>{\em Subroutine name extension} \\
\>$<$TYPE$>$    \>\>{\tt "BYTE"}    \>{\em Argument type definition} \\
\>$<$LTYPE$>$   \>\>{\tt "BYTE"}    \>{\em Local type definition} \\
\>$<$CONST$>$   \>\>{\tt " "}       \>{\em String to be appended to constant} \\
\>$<$HTYPE$>$   \>\>{\tt "\_BYTE"}  \>{\em \HDSref\ type} \\
\>$<$COMM$>$    \>\>{\tt "BYTE"}    \>{\em Comment describing type} \\
\\
\>{\bf ASTERIX} tokens (translated when {\tt -a} is specified): \\
%byteasterix
\\
\>TOKEN  \>SUBSTITUTE  \>\>COMMENT \\
\\
\>$<$CONV$>$    \>\>{\tt " "} \>{\em BYTE to REAL conversion} \\
\>$<$EXT$>$     \>\>{\tt " "} \>{\em BYTE to REAL conversion extension} \\
\>$<$BRAK$>$    \>\>{\tt " "} \>{\em Brackets for BYTE to REAL conversion} \\
\>$<$ICONV$>$   \>\>{\tt " "} \>{\em BYTE to INTEGER conversion} \\
\>$<$IEXT$>$    \>\>{\tt " "} \>{\em BYTE to INTEGER conversion extension} \\
\>$<$IBRAK$>$   \>\>{\tt " "} \>{\em Brackets for BYTE to INTEGER conversion} \\
\>$<$REV$>$     \>\>{\tt " "} \>{\em REAL to BYTE conversion} \\
\>$<$RVBRAK$>$  \>\>{\tt " "} \>{\em Brackets for REAL to BYTE conversion} \\
\>$<$IREV$>$    \>\>{\tt " "} \>{\em INTEGER to BYTE conversion} \\
\>$<$IRVBRAK$>$ \>\>{\tt " "} \>{\em Brackets for INTEGER to BYTE conversion} \\
\end{tabbing}
To produce the UNSIGNED BYTE version of a program, the following
substitutions are made.
%usbytekernal
\begin{tabbing}
xxxxxx\=xxxxxxxxxxxxx\=xxx\=xxxxxxxxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxx\kill
\>{\bf Kernel} tokens (translated by default): \\
\\
\>TOKEN     \>SUBSTITUTE     \>\>COMMENT \\
\\
\>$<$T$>$       \>\>{\tt "UB"}     \>{\em Subroutine name extension} \\
\>$<$TYPE$>$    \>\>{\tt "BYTE"}   \>{\em Argument type definition} \\
\>$<$LTYPE$>$   \>\>{\tt "BYTE"}   \>{\em Local type definition} \\
\>$<$CONST$>$   \>\>{\tt " "}      \>{\em String to be appended to constant}\\
\>$<$HTYPE$>$   \>\>{\tt "\_UBYTE"}  \>{\em \HDS\ type} \\
\>$<$COMM$>$    \>\>{\tt "UNSIGNED BYTE"} \>{\em Comment describing type} \\
\\
\>{\bf ASTERIX} tokens (translated when {\tt -a} is specified):\\
%usbyteasterix
xxxxxx\=xxxxxxxxxxxxx\=xxx\=xxxxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxx\kill
\\
\>TOKEN     \>SUBSTITUTE     \>\>COMMENT \\
\\
\>$<$CONV$>$  \>\>{\tt "REAL("} \>{\em UNSIGNED BYTE to REAL conversion} \\
\>$<$EXT$>$   \>\>{\tt "ZEXT("} \>{\em UNSIGNED BYTE to REAL conversion
extension}\\
\>$<$BRAK$>$  \>\>{\tt "))"} \>{\em Brackets for UNSIGNED BYTE to REAL
conversion}\\
\>$<$ICONV$>$ \>\>{\tt "INT("}  \>{\em UNSIGNED BYTE to INTEGER conversion} \\
\>$<$IEXT$>$  \>\>{\tt "ZEXT("} \>{\em UNSIGNED BYTE to INTEGER conversion
extension}\\
\>$<$IBRAK$>$   \>\>{\tt "))"}    \>{\em Brackets for UNSIGNED BYTE to INTEGER
conversion}\\
\>$<$REV$>$     \>\>{\tt "NINT("} \>{\em REAL to UNSIGNED BYTE conversion} \\
\>$<$RVBRAK$>$  \>\>{\tt ")"}     \>{\em Brackets for REAL to UNSIGNED BYTE
conversion} \\
\>$<$IREV$>$    \>\>{\tt " "} \>{\em INTEGER to UNSIGNED BYTE conversion} \\
\>$<$IRVBRAK$>$ \>\>{\tt " "} \>{\em Brackets for INTEGER to UNSIGNED BYTE
conversion}\\
\\
\end{tabbing}
To produce the CHARACTER version of a program, the following
substitutions are made.
%cHarkernal
\begin{tabbing}
xxxxxx\=xxxxxxxxxxxxx\=xxx\=xxxxxxxxxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxx\kill
\>{\bf Kernel} tokens (translated by default):\\
\\
\>TOKEN      \>SUBSTITUTE     \>\> COMMENT \\
\\
\>$<$T$>$     \>{\tt "C"}             \>\>{\em Subroutine name extension} \\
\>$<$TYPE$>$  \>{\tt "CHARACTER*(*)"} \>\>{\em Argument type definition} \\
\>$<$LTYPE$>$ \>{\tt "CHARACTER*$<$CHASIZ$>$"} \>\>{\em Local type definition (CHASIZ = 200 by default)} \\
\>$<$CONST$>$ \>{\tt "?"}            \>\>{\em String to be appended to
constant} \\
\>$<$HTYPE$>$ \>{\tt "\_CHAR"}       \>\>{\em \HDS\ type} \\
\>$<$COMM$>$  \>{\tt "CHARACTER"}    \>\>{\em Comment describing type} \\
\\
\>{\bf ASTERIX} tokens (translated when {\tt -a} is specified): \\
%charasterix
\\
\>TOKEN      \>SUBSTITUTE     \>\> COMMENT \\
\\
\>$<$CONV$>$  \>\>{\tt "?"} \>{\em CHARACTER to REAL conversion}\\
\>$<$EXT$>$   \>\>{\tt "?"} \>{\em CHARACTER to REAL conversion extension}\\
\>$<$BRAK$>$  \>\>{\tt "?"} \>{\em Brackets for CHARACTER to REAL conversion}\\
\>$<$ICONV$>$ \>\>{\tt "?"} \>{\em CHARACTER to INTEGER conversion}\\
\>$<$IEXT$>$  \>\>{\tt "?"} \>{\em CHARACTER to INTEGER conversion extension}\\
\>$<$IBRAK$>$ \>\>{\tt "?"} \>{\em Brackets for CHARACTER to INTEGER
conversion} \\
\>$<$REV$>$   \>\>{\tt "?"} \>{\em REAL to CHARACTER conversion} \\
\>$<$RVBRAK$>$ \>\>{\tt "?"} \>{\em Brackets for REAL to CHARACTER
conversion}\\
\>$<$IREV$>$  \>\>{\tt "?"} \>{\em INTEGER to CHARACTER conversion}\\
\>$<$IRVBRAK$>$ \>\>{\tt "?"} \>{\em Brackets for INTEGER to CHARACTER
conversion} \\
\end{tabbing}
To produce the DOUBLE PRECISION version of a program, the following
substitutions are made.
%dpkernal
\begin{tabbing}
xxxxxx\=xxxxxxxxxxxxx\=xxx\=xxxxxxxxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxx\kill
\>{\bf Kernel} tokens (translated by default):\\
\\
\>TOKEN     \>SUBSTITUTE  \>\>COMMENT \\
\\
\>$<$T$>$     \>{\tt "D"}               \>\>{\em Subroutine name extension}\\
\>$<$TYPE$>$  \>{\tt "DOUBLE PRECISION"}\>\>{\em Argument type definition}\\
\>$<$LTYPE$>$ \>{\tt "DOUBLE PRECISION"}\>\>{\em Local type definition}\\
\>$<$CONST$>$ \>{\tt ".0D0"}            \>\>{\em String to be appended to
constant} \\
\>$<$HTYPE$>$ \>{\tt "\_DOUBLE"}        \>\>{\em \HDS\ type}\\
\>$<$COMM$>$  \>{\tt "DOUBLE PRECISION"}\>\>{\em Comment describing type}\\
\end{tabbing}
%\newpage
\begin{tabbing}
xxxxxx\=xxxxxxxxxxxxx\=xxx\=xxxxxxxxxxx\=xxxxxxxxxxxxxxxxxx\kill
\>{\bf ASTERIX} tokens (translated when {\tt -a} is specified):\\
%dpasterix
\\
\>TOKEN  \>SUBSTITUTE  \>\>COMMENT \\
\\
\>$<$CONV$>$ \>\>{\tt "SNGL("} \>{\em DOUBLE PRECISION to REAL conversion}\\
\>$<$EXT$>$  \>\>{\tt " "}     \>{\em DOUBLE PRECISION to REAL conversion
extension}\\
\>$<$BRAK$>$ \>\>{\tt ")"}     \>{\em Brackets for DOUBLE PRECISION to
REAL conversion}\\
\>$<$ICONV$>$ \>\>{\tt "NINT("} \>{\em DOUBLE PRECISION to INTEGER conversion}\\
\>$<$IEXT$>$  \>\>{\tt " "}   \>{\em DOUBLE PRECISION to INTEGER conversion
extension}\\
\>$<$IBRAK$>$ \>\>{\tt ")"} \>{\em Brackets for DOUBLE PRECISION to INTEGER
conversion}\\
\>$<$REV$>$   \>\>{\tt "DBLE("} \>{\em REAL to DOUBLE PRECISION conversion}\\
\>$<$RVBRAK$>$ \>\>{\tt ")"}    \>{\em Brackets for REAL to DOUBLE PRECISION
conversion}\\
\>$<$IREV$>$  \>\>{\tt "DBLE("} \>{\em INTEGER to DOUBLE PRECISION
conversion}\\
\>$<$IRVBRAK$>$ \>\>{\tt ")"} \>{\em Brackets for INTEGER to DOUBLE
PRECISION conversion}\\
\end{tabbing}
To produce the INTEGER version of a program, the following substitutions
are made.
%intkernal
\begin{tabbing}
xxxxxx\=xxxxxxxxxxxxx\=xxx\=xxxxxxxxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxx\kill
\>{\bf Kernel} tokens (translated by default):\\
\\
\>TOKEN  \>SUBSTITUTE   \>\>COMMENT\\
\\
\>$<$T$>$     \>\>{\tt "I"}         \>{\em Subroutine name extension}\\
\>$<$TYPE$>$  \>\>{\tt "INTEGER"}   \>{\em Argument type definition}\\
\>$<$LTYPE$>$ \>\>{\tt "INTEGER"}   \>{\em Local type definition}\\
\>$<$CONST$>$ \>\>{\tt " "}         \>{\em String to be appended to constant}\\
\>$<$HTYPE$>$ \>\>{\tt "\_INTEGER"} \>{\em \HDS\ type}\\
\>$<$COMM$>$  \>\>{\tt "INTEGER"}   \>{\em Comment describing type}\\
\\
\>{\bf ASTERIX} tokens (translated when {\tt -a} is specified).\\
%intasterix
\\
\>TOKEN  \>SUBSTITUTE   \>\>COMMENT\\
\\
\>$<$CONV$>$     \>\>{\tt "REAL("} \>{\em INTEGER to REAL conversion}\\
\>$<$EXT$>$      \>\>{\tt " "}   \>{\em INTEGER to REAL conversion extension}\\
\>$<$BRAK$>$     \>\>{\tt ")"}     \>{\em Brackets for INTEGER to REAL
conversion}\\
\>$<$ICONV$>$    \>\>{\tt " "}     \>{\em INTEGER to INTEGER conversion}\\
\>$<$IEXT$>$     \>\>{\tt " "}     \>{\em INTEGER to INTEGER conversion
extension}\\
\>$<$IBRAK$>$    \>\>{\tt " "}     \>{\em Brackets for INTEGER to INTEGER
conversion}\\
\>$<$REV$>$      \>\>{\tt "NINT("} \>{\em REAL to INTEGER conversion}\\
\>$<$RVBRAK$>$   \>\>{\tt ")"}     \>{\em Brackets for REAL to INTEGER
conversion}\\
\>$<$IREV$>$     \>\>{\tt " "}     \>{\em INTEGER to INTEGER conversion}\\
\>$<$IRVBRAK$>$  \>\>{\tt " "}     \>{\em Brackets for INTEGER to INTEGER
conversion}\\
\end{tabbing}
To produce the LOGICAL version of a program, the following substitutions
are made.
%logkernal
\begin{tabbing}
xxxxxx\=xxxxxxxxxxxxx\=xxx\=xxxxxxxxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxx\kill
\>{\bf Kernel} tokens (translated by default):\\
\\
\>TOKEN      \>SUBSTITUTE      \>\>COMMENT \\
\\
\>$<$T$>$        \>\>{\tt "L"}         \>{\em Subroutine name extension}\\
\>$<$TYPE$>$     \>\>{\tt "LOGICAL"}   \>{\em Argument type definition}\\
\>$<$LTYPE$>$    \>\>{\tt "LOGICAL"}   \>{\em Local type definition}\\
\>$<$CONST$>$    \>\>{\tt " "}         \>{\em String to be appended to
constant}\\
\>$<$HTYPE$>$    \>\>{\tt "\_LOGICAL"} \>{\em \HDS\ type}\\
\>$<$COMM$>$     \>\>{\tt "LOGICAL"}   \>{\em Comment describing type}\\
\\
\>{\bf ASTERIX} tokens (translated when {\tt -a} is specified).\\
%logasterix
\\
\>TOKEN      \>SUBSTITUTE      \>\>COMMENT\\
\\
\>$<$CONV$>$     \>\>{\tt "?"} \>{\em LOGICAL to REAL conversion}\\
\>$<$EXT$>$      \>\>{\tt "?"} \>{\em LOGICAL to REAL conversion extension}\\
\>$<$BRAK$>$     \>\>{\tt "?"} \>{\em Brackets for LOGICAL to REAL conversion}\\
\>$<$ICONV$>$    \>\>{\tt "?"} \>{\em LOGICAL to INTEGER conversion}\\
\>$<$IEXT$>$     \>\>{\tt "?"} \>{\em LOGICAL to INTEGER conversion extension}\\
\>$<$IBRAK$>$    \>\>{\tt "?"} \>{\em Brackets for LOGICAL to INTEGER
conversion}\\
\>$<$REV$>$      \>\>{\tt "?"} \>{\em REAL to LOGICAL conversion}\\
\>$<$RVBRAK$>$   \>\>{\tt "?"} \>{\em Brackets for REAL to LOGICAL conversion}\\
\>$<$IREV$>$     \>\>{\tt "?"} \>{\em INTEGER to LOGICAL conversion}\\
\>$<$IRVBRAK$>$  \>\>{\tt "?"} \>{\em Brackets for INTEGER to LOGICAL
conversion}\\
\end{tabbing}
To produce the REAL version of a program, the following substitutions
are made.
%realkernal
\begin{tabbing}
xxxxxx\=xxxxxxxxxxxxx\=xxx\=xxxxxxxxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxx\kill
\>{\bf Kernel} tokens (translated by default):\\
\\
\>TOKEN      \>SUBSTITUTE      \>\>COMMENT\\
\\
\>$<$T$>$     \>\>{\tt "R"}     \>{\em Subroutine name extension}\\
\>$<$TYPE$>$  \>\>{\tt "REAL"}  \>{\em Argument type definition}\\
\>$<$LTYPE$>$ \>\>{\tt "REAL"}  \>{\em Local type definition}\\
\>$<$CONST$>$ \>\>{\tt ".0E0"}  \>{\em String to be appended to constant}\\
\>$<$HTYPE$>$ \>\>{\tt "\_REAL"} \>{\em \HDS\ type}\\
\>$<$COMM$>$  \>\>{\tt "REAL"}  \>{\em Comment describing type}\\
\\
\>{\bf ASTERIX} tokens (translated when {\tt -a} is specified).\\
%realasterix
\\
\>TOKEN      \>SUBSTITUTE      \>\>COMMENT\\
\\
\>$<$CONV$>$     \>\>{\tt " "}     \>{\em REAL to REAL conversion}\\
\>$<$EXT$>$      \>\>{\tt " "}     \>{\em REAL to REAL conversion extension}\\
\>$<$BRAK$>$     \>\>{\tt " "}  \>{\em Brackets for REAL to REAL conversion}\\
\>$<$ICONV$>$    \>\>{\tt "NINT("} \>{\em REAL to INTEGER conversion}\\
\>$<$IEXT$>$     \>\>{\tt " "}  \>{\em REAL to INTEGER conversion extension}\\
\>$<$IBRAK$>$    \>\>{\tt ")"} \>{\em Brackets for REAL to INTEGER conversion}\\
\>$<$REV$>$      \>\>{\tt " "}     \>{\em REAL to REAL conversion}\\
\>$<$RVBRAK$>$   \>\>{\tt " "}   \>{\em Brackets for REAL to REAL conversion}\\
\>$<$IREV$>$     \>\>{\tt "REAL("} \>{\em INTEGER to REAL conversion}\\
\>$<$IRVBRAK$>$  \>\>{\tt ")"} \>{\em Brackets for INTEGER to REAL conversion}\\
\end{tabbing}
To produce the WORD version of a program, the following substitutions
are made.
%wordkernal
\begin{tabbing}
xxxxxx\=xxxxxxxxxxxxx\=xxx\=xxxxxxxxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxx\kill
\>{\bf Kernel} tokens (translated by default):\\
\\
\>TOKEN      \>SUBSTITUTE     \>\>COMMENT\\
\\
\>$<$T$>$     \>\>{\tt "W"}         \>{\em Subroutine name extension}\\
\>$<$TYPE$>$  \>\>{\tt "INTEGER*2"} \>{\em Argument type definition}\\
\>$<$LTYPE$>$ \>\>{\tt "INTEGER*2"} \>{\em Local type definition}\\
\>$<$CONST$>$ \>\>{\tt " "}         \>{\em String to be appended to constant}\\
\>$<$HTYPE$>$ \>\>{\tt "\_WORD"}    \>{\em \HDS\ type}\\
\>$<$COMM$>$  \>\>{\tt "WORD"}      \>{\em Comment describing type}\\
\\
\>{\bf ASTERIX} tokens (translated when {\tt -a} is specified).\\
%wordasterix
\\
\>TOKEN      \>SUBSTITUTE      \>\>COMMENT\\
\\
\>$<$CONV$>$     \>\>{\tt "REAL("} \>{\em WORD to REAL conversion}\\
\>$<$EXT$>$      \>\>{\tt " "}     \>{\em WORD to REAL conversion extension}\\
\>$<$BRAK$>$     \>\>{\tt ")"}   \>{\em Brackets for WORD to REAL conversion}\\
\>$<$ICONV$>$    \>\>{\tt " "}     \>{\em WORD to INTEGER conversion}\\
\>$<$IEXT$>$     \>\>{\tt " "}   \>{\em WORD to INTEGER conversion extension}\\
\>$<$IBRAK$>$    \>\>{\tt " "} \>{\em Brackets for WORD to INTEGER conversion}\\
\>$<$REV$>$      \>\>{\tt "NINT("} \>{\em REAL to WORD conversion}\\
\>$<$RVBRAK$>$   \>\>{\tt ")"}  \>{\em Brackets for REAL to WORD conversion}\\
\>$<$IREV$>$     \>\>{\tt " "}     \>{\em INTEGER to WORD conversion}\\
\>$<$IRVBRAK$>$  \>\>{\tt " "} \>{\em Brackets for INTEGER to WORD conversion}\\
\end{tabbing}
To produce the UNSIGNED WORD version of a program, the following
substitutions are made.
%uswordkernal
\begin{tabbing}
xxxxxx\=xxxxxxxxxxxxx\=xxx\=xxxxxxxxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxx\kill
\>{\bf Kernel} tokens (translated by default):\\
\\
\>TOKEN      \>SUBSTITUTE     \>\>COMMENT\\
\\
\>$<$T$>$     \>\>{\tt "UW"}            \>{\em Subroutine name extension}\\
\>$<$TYPE$>$  \>\>{\tt "INTEGER*2"}     \>{\em Argument type definition}\\
\>$<$LTYPE$>$ \>\>{\tt "INTEGER*2"}     \>{\em Local type definition}\\
\>$<$CONST$>$ \>\>{\tt " "}         \>{\em String to be appended to constant}\\
\>$<$HTYPE$>$ \>\>{\tt "\_UWORD"}       \>{\em \HDS\ type}\\
\>$<$COMM$>$  \>\>{\tt "UNSIGNED WORD"} \>{\em Comment describing type}\\
\\
\>{\bf ASTERIX} tokens (translated when {\tt -a} is specified).\\
%uswordasterix
xxxxxx\=xxxxxxxxxxxxx\=xxx\=xxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxx\kill
\\
\>TOKEN      \>SUBSTITUTE      \>\>COMMENT\\
\\
\>$<$CONV$>$     \>\>{\tt "REAL("} \>{\em UNSIGNED WORD to REAL conversion}\\
\>$<$EXT$>$      \>\>{\tt "ZEXT("} \>{\em UNSIGNED WORD to REAL conversion
extension}\\
\>$<$BRAK$>$     \>\>{\tt "))"}    \>{\em Brackets for UNSIGNED WORD to REAL
conversion}\\
\>$<$ICONV$>$    \>\>{\tt " "}     \>{\em UNSIGNED WORD to INTEGER conversion}\\
\>$<$IEXT$>$     \>\>{\tt "ZEXT("} \>{\em UNSIGNED WORD to INTEGER conversion
extension}\\
\>$<$IBRAK$>$    \>\>{\tt ")"}     \>{\em Brackets for UNSIGNED WORD to INTEGER
 conversion}\\
\>$<$REV$>$      \>\>{\tt "NINT("} \>{\em REAL to UNSIGNED WORD conversion}\\
\>$<$RVBRAK$>$   \>\>{\tt ")"}     \>{\em Brackets for REAL to UNSIGNED WORD
conversion}\\
\>$<$IREV$>$     \>\>{\tt " "}     \>{\em INTEGER to UNSIGNED WORD conversion}\\
\>$<$IRVBRAK$>$  \>\>{\tt " "}     \>{\em Brackets for INTEGER to UNSIGNED WORD
 conversion}\\
\end{tabbing}
\newpage

\section{\xlabel{ap_b}A Full List of Conversion Functions\label{ap_b}}

This appendix gives the conversion functions which are available using
the DCV utility, and describes which ones are statement functions and
which ones are external.

The following conversions are defined as in-line statement functions in
`DCV\_FUN'. (They are either trivial, or are mentioned in the Fortran
manual as legal conversions).

\begin{tabbing}
xxxx\=xxxxxxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\=xxx\kill
\>{\bf Function name}   \>{\bf Conversion}\\
\\
\>DCV\_BTOB   \>BYTE to BYTE \\
\>DCV\_UBTOUB \>UNSIGNED BYTE to UNSIGNED BYTE \\
\>DCV\_UBTOD  \>UNSIGNED BYTE to DOUBLE PRECISION \\
\>DCV\_DTOD   \>DOUBLE PRECISION to DOUBLE PRECISION \\
\>DCV\_ITOD   \>INTEGER to DOUBLE PRECISION \\
\>DCV\_RTOD   \>REAL to DOUBLE PRECISION \\
\>DCV\_WTOD   \>WORD to DOUBLE PRECISION \\
\>DCV\_UWTOD  \>UNSIGNED WORD to DOUBLE PRECISION \\
\>DCV\_UBTOI  \>UNSIGNED BYTE to INTEGER \\
\>DCV\_DTOI   \>DOUBLE PRECISION to INTEGER \\
\>DCV\_ITOI   \>INTEGER to INTEGER \\
\>DCV\_RTOI   \>REAL to INTEGER \\
\>DCV\_UWTOI  \>UNSIGNED WORD to INTEGER \\
\>DCV\_UBTOR  \>UNSIGNED BYTE to REAL \\
\>DCV\_DTOR   \>DOUBLE PRECISION to REAL \\
\>DCV\_ITOR   \>INTEGER to REAL \\
\>DCV\_RTOR   \>REAL to REAL \\
\>DCV\_WTOR   \>WORD to REAL \\
\>DCV\_UWTOR  \>UNSIGNED WORD to REAL \\
\>DCV\_UBTOW  \>UNSIGNED BYTE to WORD \\
\>DCV\_DTOW   \>DOUBLE PRECISION to WORD       \>*** \\
\>DCV\_RTOW   \>REAL to WORD                   \>*** \\
\>DCV\_WTOW   \>WORD to WORD \\
\>DCV\_UBTOUW \>UNSIGNED BYTE to UNSIGNED WORD \\
\>DCV\_UWTOUW \>UNSIGNED WORD to UNSIGNED WORD \\
\end{tabbing}
Overflow errors are possible from the conversions marked ``***''

\newpage

The following conversions are also defined as in-line statement functions in
`DCV\_FUN'. However, they are not mentioned in the Fortran manual and should be
used with caution. Trial and error has shown that the Fortran compliers on all
Starlink supported systems will make the conversions successfully :-

\begin{tabbing}
xxxx\=xxxxxxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\=xxx\kill
\>{\bf Function name}      \>{\bf Conversion}\\
\\
\>DCV\_UBTOB \>UNSIGNED BYTE to BYTE          \>*** \\
\>DCV\_DTOB  \>DOUBLE PRECISION to BYTE       \>*** \\
\>DCV\_ITOB  \>INTEGER to BYTE                \>*** \\
\>DCV\_RTOB  \>REAL to BYTE                   \>*** \\
\>DCV\_WTOB  \>WORD to BYTE                   \>*** \\
\>DCV\_UWTOB \>UNSIGNED WORD to BYTE          \>*** \\
\>DCV\_BTOD  \>BYTE to DOUBLE PRECISION \\
\>DCV\_BTOI  \>BYTE to INTEGER \\
\>DCV\_WTOI  \>WORD to INTEGER \\
\>DCV\_BTOR  \>BYTE to REAL \\
\>DCV\_BTOW  \>BYTE to WORD \\
\>DCV\_ITOW  \>INTEGER to WORD                \>*** \\
\end{tabbing}
Overflow errors are possible from the conversions marked ``***''

The following conversions are defined as external
functions in the DCV object library :-
\begin{tabbing}
xxxx\=xxxxxxxxxxxxxxxx\=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\=xxx\kill
\>{\bf Function name}     \>{\bf Conversion}\\
\\
\>DCV\_BTOUB  \>BYTE to UNSIGNED BYTE \\
\>DCV\_DTOUB  \>DOUBLE PRECISION to UNSIGNED BYTE \\
\>DCV\_ITOUB  \>INTEGER to UNSIGNED BYTE \\
\>DCV\_RTOUB  \>REAL to UNSIGNED BYTE \\
\>DCV\_WTOUB  \>WORD to UNSIGNED BYTE \\
\>DCV\_UWTOUB \>UNSIGNED WORD to UNSIGNED BYTE \\
\>DCV\_BTOUW  \>BYTE to UNSIGNED WORD \\
\>DCV\_UBTOUW \>UNSIGNED BYTE to UNSIGNED WORD \\
\>DCV\_DTOUW  \>DOUBLE PRECISION to UNSIGNED WORD \\
\>DCV\_ITOUW  \>INTEGER to UNSIGNED WORD \\
\>DCV\_RTOUW  \>REAL to UNSIGNED WORD \\
\>DCV\_WTOUW  \>WORD to UNSIGNED WORD \\
\end{tabbing}
Overflow errors are possible in ALL these conversions, so range checking is
essential.

\end{document}
