      BYTE FUNCTION DCV_<T>TOUB( VAL )
*+
*  Name:
*     DCV_<T>TOUB

*  Purpose:
*     Convert variable of type <COMM> to UNSIGNED BYTE

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     RESULT = DCV_<T>TOUB( VAL )
*        There are functions to convert from B, D, I, R, W and UW

*  Description:
*     This is a generic routine which converts a variable of type
*     <COMM> to UNSIGNED BYTE. The routine is meant to complement the
*     file 'DCV_FUN', which cannot convert variables to UNSIGNED BYTE
*     using statement function (with the exception of UNSIGNED BYTE to
*     UNSIGNED BYTE).

*  Arguments:
*     VAL = <TYPE> (Given)
*        Variable to be converted to UNSIGNED BYTE

*  Returned Value:
*     DCV_<T>TOUB = BYTE
*        The UNSIGNED BYTE value produced from VAL

*  Algorithm:
*     -  The function uses the DCV_<T>TOI function to convert the value
*        given to an INTEGER.
*     -  Check that the value is in range.
*     -  If it is, copy the input value to the output value, converting
*        it if necessary.
*     -  If it is not in range, generate a trap if we can or stop with
*        an error message.

*  Implementation Deficiencies:
*     -  Because this routine has to mimic the statement functions,
*        there is no STATUS argument. If an overflow is detected, the
*        routine will simply abort.
*
*     Machine-specific features used:
*     -  This routine uses BYTE and INTEGER*2 variables, which are not
*        standard FORTRAN.
*
*     Sun-specific features used:
*     -  OFFSET needs to be declared as a separate INTEGER constant as
*        doing arithmetic with IVAL and the explicit BYTE constants
*        (DCV__MIN and DCV__MAX) fails on the Sun.

*  External Routines Used:
*     DCV:
*        DCV_ITOUW

*  Pitfalls:
*     -  This routine will crash (deliberately) if the argument cannot
*        be stored as an UNSIGNED BYTE value. To prevent this, use a
*        PRIMDAT routine instead.

*  Copyright:
*     Copyright (C) 1993 Science & Engineering Research Council

*  Licence:
*     This program is free software; you can redistribute it and/or
*     modify it under the terms of the GNU General Public License as
*     published by the Free Software Foundation; either version 2 of
*     the License, or (at your option) any later version.
*
*     This program is distributed in the hope that it will be
*     useful, but WITHOUT ANY WARRANTY; without even the implied
*     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
*     PURPOSE. See the GNU General Public License for more details.
*
*     You should have received a copy of the GNU General Public License
*     along with this program; if not, write to the Free Software
*     Foundation, Inc., 51 Franklin Street,Fifth Floor, Boston, MA
*     02110-1301, USA

*  Authors:
*     SMB: Steven Beard (ROE)
*     PMA: Peter Allan (Starlink, RAL)
*     {enter_new_authors_here}

*  History:
*     03-MAR-1987 (SMB):
*        Original version.
*     15-APR-1987 (SMB):
*        Overflow check included
*     25-JAN-1993 (PMA):
*        Convert prologue to new ADAM style.
*     27-JAN-1993 (PMA):
*        Remove the use of EQUIVALENCEing one element of a 4 byte array
*        to an integer. This is not portable. Replace it with suitable
*        arithmetic.
*        Remove the call to LIB$STOP and replace it with a STOP
*        statement. This will no longer produce a stack dump on VMS,
*        but this is not possible on Unix anyway.
*     28-JAN-1993 (PMA):
*        Add some arithmetic that will generate a fault on machines that
*        trap integer overflow. On machines that do not, the STOP
*        statement will still be executed.
*     {enter_further_changes_here}

*-
      
*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'DCV_PAR'          ! DCV global range parameters

*  Arguments Given:
      <TYPE> VAL

*  External References:
      EXTERNAL DCV_ITOUW
      INTEGER*2 DCV_ITOUW        ! Convert an integer to a word

*  Local Constants:
      INTEGER IMIN               ! An integer copy of DCV__MIN
      PARAMETER ( IMIN = DCV__BMIN )
      INTEGER IMAX               ! An integer copy of DCV__MAX
      PARAMETER ( IMAX = DCV__BMAX )
      INTEGER OFFSET             ! DCV__MAX - DCV__MIN + 1
      PARAMETER ( OFFSET = IMAX - IMIN + 1 )

*  Local Variables:
      INTEGER IVAL               ! An intermediate variable

*  Internal references:
      INCLUDE 'DCV_FUN'          ! The DCV statement functions

*.

*  Convert the imported variable to integer.
      IVAL = DCV_<T>TOI( VAL )

*  Check the integer is in the correct range for conversion to
*  UNSIGNED BYTE.
      IF( ( IVAL .GE. DCV__UBMIN ) .AND. ( IVAL .LE. DCV__UBMAX ) ) THEN

*  IVAL is in range - return the value.
*  Check to see if the value can be treated as a signed BYTE value or
*  whether in needs special treatment.
         IF ( IVAL .LE. DCV__BMAX ) THEN
            DCV_<T>TOUB = IVAL
         ELSE

*  Subtract a constant to convert the UNSIGNED BYTE value to an
*  equivalent one that fits into a signed BYTE variable.
*  The rather strange constant copes with ones complement machines as
*  well as the more common two complement (except that it might not
*  generate -0).
            DCV_<T>TOUB = IVAL - OFFSET
         END IF
      ELSE

*  IVAL is out of range.
*  Generate an integer overflow if the machine traps them, otherwise
*  just stop the program. The call to DCV_ITOUW and the test on IVAL is
*  to prevent an optimizer removing the assignment that generates the
*  overflow.
         IVAL = DCV_ITOUW( 1 )
         IVAL = IVAL + DCV__IMAX
         IF ( IVAL .NE. 0 ) THEN
            STOP 'Integer overflow trapped by DCV_<T>TOUB'
         END IF
      END IF

      END
