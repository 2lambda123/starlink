#!/star/bin/awish

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#  Name:
#     PolMap.tcl
#
#  Purpose:
#     The main PolMap tcl script. This is a shell which display the 
#     vector map over a greyscale or contoured background image.
#
#  Invocation:
#     1) From the command line:
#        PolMap.tcl <Stokes cube> <background image>
#
#     2) From the PolMap A-task. 
#        See the A-task documentation.
#
#  Command Line Arguments:
#     in    - The input image
#  
#-----------------------------------------------------------------------

#  As a debugging tool, you can uncomment the following block to see 
#  the name of each procedure as it is entered. The only problem is 
#  that the "exit" command is upset by this, so you have to control-C 
#  to quit the program. This will leave some child processes running, 
#  and will leave the temporary ADAM directory in place. You should 
#  kill the child processes by hand (using ps and kill), and remove 
#  the temporary ADAM directory (i.e. rm -rf ~/adam/PolMap_*).

#rename proc tclproc
#tclproc proc {name args body} {
#   set newbody "puts \"Entering $name...\""
#   append newbody $body
#   tclproc $name $args $newbody
#}

#-----------------------------------------------------------------------

# Display a label asking the user to wait while the main interface is
# constructed.
   set wait [label .wait -text "  Please Wait...  " -bd 3 -relief sunken \
                               -background #c0c0c0]
   pack $wait -ipadx 4m -ipady 4m -padx 4m -pady 2m -fill y -expand 1

# Ensure any X events generated by the user trying to interact with the
# screen while the GUI is being created get delivered to the above label 
# widget (which will just ignore them). See procedure WaitFor.
   set SAFE $wait

# Obtain the input Stokes vector cube. If this script is invoked by 
# the A-task then the image name will be available in variable "cube".
# Otherwise, it should have been supplied on the command line (it will be 
# stored in argv - a list of command line parameters). Store the full cube
# specification in global variable CUBE. Also set a flag (ATASK) indicating if 
# the script was started from the atask or not.
   if { ![info exists cube] } {
      if { $argc == 0 } {
         puts "No Stokes vector cube supplied"
         exit
      } {
         set CUBE [lindex "$argv" 0]
         set ATASK 0
      }
   } {
      set CUBE $cube
      set ATASK 1
   }

# Obtain any background image to be displayed. If this script is invoked by 
# the A-task then the image name will be available in variable in_list. 
# Otherwise, if an image has been supplied on the command line it will be 
# stored in argv (a list of command line parameters). Store the full image
# specification in global variable IMSEC (which will be blank if no
# background image is available). 
   if { ![info exists in_list] } {
      if { $argc == 1 } {
         set IMSEC ""
      } {
         set IMSEC [lindex "$argv" 1]
      }
   } {
      set IMSEC $in_list
   }

# Set the number of digits used by tcl to represent floating point values as
# strings.
   set tcl_precision 15

# Get the pixels per inch on the screen. If a value has been supplied
# by the A-task in variable "dpi" use it. Otherwise, use the Tcl winfo
# command to get a value. NB, the winfo value appears to be incorrect 
# on some X servers (which is why the user can specify it through the 
# atask).
   if { ![info exists dpi] } {
      set dpi [winfo fpixels . "1i"]
   }       

# Set the dimension of the square GWM canvas item (in scren pixels).
   set size [expr round( ( 350.0 * $dpi ) / 88.0 ) ]

# Get the process id for the current process.
   set PID [pid]

# Initialise global constants. These are documented in the prologues of
# the procedures which use them (see file PolMap_procs.tcl).
   set BACKCOL "#c0c0c0"
   set CB_COL yellow
   set CHAR_LIST {0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ}
   set CHAR_STOP {.}
   set MENUBACK "#b0b0b0"
   set RB_COL red
   set RTOD 57.29578

# Initialise other PolMap global variables. These are documented in the 
# prologues of the procedures which use them (see file PolMap_procs.tcl).
   set ADAM_TASKS ""
   set CANCEL_OP 0
   set CURRENT_INFO ""
   set CURSOR_STACK ""
   set DEFAULT_INFO ""
   set DOING_DOUBLE 0
   set INFO_TEXT ""
   set F3 ""
   set F4 ""
   set HELP ""
   set IFILE 0
   set IFILE_STACK ""
   set LOGFILE_ID ""
   set POINTER_PXY ""
   set POINTER_CXY ""
   set RESAVE 1
   set SAREA 1
   set SEQ_STOP ""
   set STOP_BLINK ""

# Get the name of the directory containing the polpack files. This TCL
# variable should have been set in the calling ADAM A-task, but if it
# wasn't (for instance if this script is called directly rather than by the
# A-task), then use the environment variable value to set it. If there
# is no environment variable, use a default of /star/bin/polpack.
   if { ![info exists POLPACK_DIR] } {
      if { [info exists env(POLPACK_DIR)] } {
         set POLPACK_DIR $env(POLPACK_DIR)
      } {
         set POLPACK_DIR /star/bin/polpack
      }
   }

# Save the path to the directory containing POLPACK hypertext documents.
# This assumes that they have been installed in the standard place
# relative to the other POLPACK files.
   set POLPACK_HELP $POLPACK_DIR/../../help/polpack

# Get the path to the KAPPA directory from the corresponding
# environment variables, or use a default of /star/bin/kappa.
   if { [info exists env(KAPPA_DIR)] } {
      set KAPPA_DIR $env(KAPPA_DIR)
   } else {
      set KAPPA_DIR /star/bin/kappa
   }

#  Name this application (for xresources etc.)
   tk appname PolMap

# Rename the "exit" command so that it calls a procedure which cleans up,
# and then calls the built-in shut-down commands. 
   rename exit tcl_exit

# Define the procedures which form part of the PolMap application.
   source $POLPACK_DIR/dialog.tcl
   source $POLPACK_DIR/PolMap_procs.tcl
   source $POLPACK_DIR/CCDShowHelp.tcl

# If the variable START_HELP has been defined (by the a-task) then
# start up a hyper-text browser displaying the on-line help contents page.
   if { [info exists START_HELP] } { ShowHelp POLMAP_CONTENTS }

# Quit when control-c is pressed.
   bind . <Control-c> {Finish 0}

# Set the font pixel sizes, so that he fonts are the same physical size
# independant of the screen resolution.
   set px140 [expr round( ( 14.0 * $dpi ) / 88.0 ) ]   
   set px120 [expr round( ( 12.0 * $dpi ) / 88.0 ) ]   
   set px100 [expr round( ( 10.0 * $dpi ) / 88.0 ) ]   

# Attempt to find suitable fonts. Issue a warning and use default fonts
# if the fonts cannot be found.
   set FONT [SelectFont "-*-*-bold-r-*-*-$px140-*-*-*-*-*-*-*"]
   set HLP_FONT [SelectFont "-*-*-medium-r-*-*-$px120-*-*-*-*-*-*-*"]
   set B_FONT [SelectFont "-*-*-bold-r-*-*-$px120-*-*-*-*-*-*-*"]
   set RB_FONT [SelectFont "-*-*-medium-r-*-*-$px120-*-*-*-*-*-*-*"]
   set S_BFONT [SelectFont "-*-*-bold-r-*-*-$px120-*-*-*-*-*-*-*"]
   set S_FONT [SelectFont "-*-*-medium-r-*-*-$px120-*-*-*-*-*-*-*"]

   if { $FONT == "" || $HLP_FONT == "" || $RB_FONT == "" || $S_BFONT == "" || $S_FONT == "" || $B_FONT == "" } {
      set FONT ""
      set HLP_FONT ""
      set B_FONT ""
      set RB_FONT ""
      set S_BFONT ""
      set S_FONT ""
      Message "The preferred fonts for use on a $dpi pixels per inch screen cannot be found. Using default fonts..."
   }

# Try to stop problems with the AMS (ADAM Message System) rendevous files 
# by creating a new directory as ADAM_USER.
   if { [info exists env(ADAM_USER)] } {
      set OLD_ADAM_USER $env(ADAM_USER)
      set ADAM_USER "$OLD_ADAM_USER/PolMap_[pid]"
   } {
      set OLD_ADAM_USER ""
      set ADAM_USER "$env(HOME)/adam/PolMap_[pid]"
   }
   set env(ADAM_USER) $ADAM_USER

# Make sure this new directory exists (delete any existing version).
   if { [file exists $ADAM_USER] } {
      catch {exec rm -r -f $ADAM_USER}
   }
   catch {exec mkdir -p $ADAM_USER}

# Avoid messing up the main AGI database by using a new AGI database.
# Create it in the ADAM_USER directory created above.
   if { [info exists env(AGI_USER)] } {
      set OLD_AGI_USER $env(AGI_USER)
   } {
      set OLD_AGI_USER ""
   }
   set env(AGI_USER) $ADAM_USER

# Ensure that default plotting styles are obtained from the user's
# existing Options DataBase file, rather than creating a new one in 
# the temporary ADAM_USER directory.
   if { ![info exists env(ODB_USER)] } {
      if { $OLD_ADAM_USER == "" } {
         set env(ODB_USER) "$env(HOME)/adam"
      } {
         set env(ODB_USER) $OLD_ADAM_USER
      }
   }

# Record the process id's of any existing KAPPA processes. All new processes
# are killed on exit, but processes active on entry are not killed.
   if { ![ catch {exec ps | grep kappa | grep -v grep | \
                  awk {{print $1}} } OLDKAPPA ] } { 
      set OLDKAPPA {}
   }

# Define Startcl procedures (this must be done after the ADAM_USER
# directory has been set up).
   source $POLPACK_DIR/adamtask.tcl

# The adamtask.tcl file creates a binding which causes the application to
# terminate whenever a window is destroyed. This is a pain because it
# causes the A-task to die in an uncontrolled manner! Also, we cannot
# delete any widgets without the whole thing dying! Do away with it.
   bind . <Destroy> ""

# Load the required ADAM monoliths. 
   LoadTask kapview  $KAPPA_DIR/kapview_mon
   LoadTask kappa    $KAPPA_DIR/kappa_mon
   LoadTask ndfpack  $KAPPA_DIR/ndfpack_mon
   LoadTask polpack  $POLPACK_DIR/polpack_mon

# If a background image has been supplied, prepare to use it.
   if { $IMSEC != "" } {

# Save the current value of environment variable NDF_FORMATS_OUT (if any),
# and ensure that NDF applications will create output NDFs, rather than
# any other data format.
      if { [info exists env(NDF_FORMATS_OUT)] } {
         set ndf_formats_out $env(NDF_FORMATS_OUT)
      }
      set env(NDF_FORMATS_OUT) "."

# Make a copy of the supplied background image, ensuring it is in NDF format.
# The copy is stored in the temporary adam user directory.
      set NDF_IMAGE [UniqueFile]
      Obey ndfpack ndfcopy "in=$IMSEC out=$NDF_IMAGE" 1

# Re-instate the original value of environment variable NDF_FORMATS_OUT 
# (if any).
      if { [info exists ndf_formats_out] } {
         set env(NDF_FORMATS_OUT) $ndf_formats_out
      }

# Extract the image name and section specifier (if any) from the supplied image
# section string. Store the image name in global variable IMAGE.
      GetSec $IMSEC IMAGE section

# Ensure we have a standard version of the section specifier expressed as 
# ranges of pixel indices. 
      set SECTION [PixIndSection $IMSEC]
      set STD_IMSEC "${IMAGE}${SECTION}"

# Store the lengths of the image section and image name.
      set maximwid [string length $IMSEC]
      set maxrimwid [string length $IMAGE]

# Store the state for the widgets related to the display of the
# background image.
      set BACKSTATE "normal"

# Set null values for the above variables if no background image was
# supplied.
   } {
      set NDF_IMAGE ""
      set IMAGE ""
      set SECTION "(1:100,1:100)"
      set STD_IMSEC ""
      set maximwid 0
      set maxrimwid 0
      set BACKSTATE "disabled"
   }

# >>>>>>>>>>>>>>>>>  SET UP THE SCREEN LAYOUT <<<<<<<<<<<<<<<<<<<<

# Ensure that closing the window from the window manager is like pressing
# the Quit button in the File menu.
   wm protocol . WM_DELETE_WINDOW {Finish 0}

# Set the default colour for all backgrounds.
   . configure -background $BACKCOL
   option add *background $BACKCOL

# Set the default font.
   if { $FONT != "" } { option add *font $FONT }

# Set the default font for radiobuttons and checkbuttons.
   if { $RB_FONT != "" } { 
      option add *Radiobutton.font $RB_FONT 
      option add *Checkbutton.font $RB_FONT 
   }

# Set the default font for buttons and menus.
   if { $B_FONT != "" } { 
      option add *Button.font $B_FONT 
      option add *Menubutton.font $B_FONT 
      option add *Menu.font $B_FONT 
   }

# Ensure that menus do not have "tear-off" marks.
   option add *Menu.tearOff 0

# Radiobuttons and Checkbuttons do not have a highlighted border.
   option add *Radiobutton.highlightThickness 0 
   option add *Checkbutton.highlightThickness 0 

# Ensure that listbox entries are white on black when selected.
   option add *Listbox.selectForeground white
   option add *Listbox.selectBackground black

# Create binding which result in the Helper procedure being called
# whenever a widget is entered, left, or destroyed. Helper stores
# the appropriate message for display in the dynamic help area.
   bind all <Enter> "+Helper %X %Y"
   bind all <Leave> "+Helper %X %Y"
   bind all <Destroy> "+Helper %X %Y"

# When the F1 button is pressed, display help on the object under the
# pointer.
   bind all <F1> {ShowHelp [FindHelp %X %Y]}

# Create an all encompassing frame. Give it a new colour map if requested.
   if { [info exists NEWCOLMAP] } {
      set usingnewcmap 1
      set TOP [frame .top -relief raised -bd 2 -colormap new]
      wm colormapwindows . "$TOP ."
   } {
      set usingnewcmap 0
      set TOP [frame .top -relief raised -bd 2]
   }
   pack $TOP -padx 2m -pady 2m 

# Create a frame which goes at the top of the screen but contains nothing. 
# X events will be directed to this window during any pauses
# (see procedure WaitFor). The window has no user controls and so is
# "safe" (i.e. it will just ignore any button presses, mouse movements, etc). 
# This ensures that new commands cannot be initiated by the user before 
# previous ones have finished.
   set SAFE [frame $TOP.dummy ]
   pack $SAFE

# Divide the top window into four horizontal frames. The top one is the
# menu bar. The next contains the GWM canvas and controls. The next displays
# status information. The bottom one displays dynamic help on the object
# under the cursor. The bottom two frames may or may not be displayed,
# depending on the options slected by the user. The display of the two
# bottom frames is controlled by procedures HelpArea and StatusArea.
   set F1 [frame $TOP.menubar -relief raised -bd 2 -background $MENUBACK ]
   set F2 [frame $TOP.main ]
   pack $F1 $F2 -fill x -expand 1

# Build the menu bar and menus.
   set file [menubutton $F1.file -text File -menu $F1.file.menu -background $MENUBACK ]
   set filemenu [menu $file.menu]
   SetHelp $file ".  Menu of commands for exiting, saving, loading, etc..." POLMAP_FILE_MENU

   set edit [menubutton $F1.edit -text Edit -menu $F1.edit.menu -background $MENUBACK ]
   set editmenu [menu $edit.menu]
   SetHelp $edit ".  Menu of commands for editing objects and information." POLMAP_EDIT_MENU

   set opts [menubutton $F1.opts -text Options -menu $F1.opts.menu -background $MENUBACK]
   set OPTSMENU [menu $opts.menu]
   SetHelp $opts ".  Menu of commands to set up various options..." POLMAP_OPTIONS_MENU

   set help [menubutton $F1.help -text Help -menu $F1.help.menu -background $MENUBACK ]
   set helpmenu [menu $help.menu]
   SetHelp $help ".  Display further help information..." POLMAP_HELP_MENU

# If the preferred fonts could not be found, find which font was used
# in the above menubuttons and use that font for everything else.
   if { $FONT == "" } {
      set FONT [$file cget -font]
      set HLP_FONT $FONT
      set RB_FONT $FONT
      set S_BFONT $FONT
      set S_FONT $FONT
      set B_FONT $FONT
   }

# Add menu items to the Help menu.
   $helpmenu add command -label "Contents" -command {ShowHelp "POLMAP_CONTENTS"}
   $helpmenu add command -label "Controls" -command {ShowHelp "POLMAP_CONTROLS"}
   $helpmenu add command -label "How do I..." -command {ShowHelp "POLMAP_HOW_DO_I"}
   $helpmenu add command -label "Tutorial" -command {ShowHelp "POLMAP_TUTORIAL"}
   $helpmenu add command -label "Using Help" -command {ShowHelp "POLMAP_USING_HELP"}

   $helpmenu add separator
   $helpmenu add command -label "Pointer..." -command {ShowHelp "pointer"}

   MenuHelp $helpmenu "Contents"    ".  Display the main table of contents for the PolMap documentation."
   MenuHelp $helpmenu "Controls"    ".  Display help on the controls available in the GUI."
   MenuHelp $helpmenu "How do I..." ".  Display help on common questions."
   MenuHelp $helpmenu "Tutorial"    ".  Display a simple step-by-step guide to the use of PolMap."
   MenuHelp $helpmenu "Using Help"  ".  Display help on how to use the PolMap help system."
   MenuHelp $helpmenu "Pointer..."  ".  Select this menu item, and then click with the pointer over a widget to see help on the widget."

# Add menu items to the File menu.
   $filemenu add command -label "Save        " -command Save
   $filemenu add command -label "Exit        " -command {Finish 1}
   $filemenu add command -label "Quit        " -command {Finish 0} -accelerator "Ctrl+C"

   MenuHelp $filemenu "Save        " ".  Create and save the output images."
   MenuHelp $filemenu "Exit        " ".  Create and save the output images, and then exit the application."
   MenuHelp $filemenu "Quit        " ".  Quit the application, without saving the output images."

# Add menu items to options menu.
   $OPTSMENU add cascade -label "Background" -menu $OPTSMENU.back -state $BACKSTATE
   $OPTSMENU add cascade -label "Colours" -menu $OPTSMENU.cols
   $OPTSMENU add cascade -label "Contours" -menu $OPTSMENU.conts -state $BACKSTATE
   $OPTSMENU add command -label "Status Items..." -command GetItems
   $OPTSMENU add separator
   $OPTSMENU add checkbutton -label "Use Cross-hair" -variable GWM_XHAIR -selectcolor $CB_COL
   $OPTSMENU add checkbutton -label "Display Help Area" -variable HAREA -command HelpArea -selectcolor $CB_COL
   $OPTSMENU add checkbutton -label "Display Status Area" -variable SAREA -command "StatusArea \$SAREA" -selectcolor $CB_COL
   $OPTSMENU add separator
   $OPTSMENU add command -label "Save Options" -command SaveOptions 

   MenuHelp $OPTSMENU "Background"      ".  Set the method use to display the background image."
   MenuHelp $OPTSMENU "Colours"         ".  Change the colours used for various parts of the display."
   MenuHelp $OPTSMENU "Contours"        ".  The number of contours to use when displaying the background as a contour map."
   MenuHelp $OPTSMENU "Status Items..." ".  Select which items of information to display in the status area."

   MenuHelp $OPTSMENU "Use Cross-hair"  ".  Should a cross-hair be used instead of a pointer over the image display area?"
   MenuHelp $OPTSMENU "Display Help Area"    ".  Toggle the display of help information at the bottom of the main window."
   MenuHelp $OPTSMENU "Display Status Area"  ".  Toggle the display of status information underneath the displayed image."

   MenuHelp $OPTSMENU "Save Options"    ".  Save the current option values."

# Add items to the "Background" sub-menu.
   set backmenu [menu $OPTSMENU.back]
   $backmenu add radiobutton -label "Grey-scale image" -variable GWM_BACK \
                 -selectcolor $RB_COL -value "GREY" -command GwmUpdate
   $backmenu add radiobutton -label "Contour map" -variable GWM_BACK \
                 -selectcolor $RB_COL -value "CONTOUR" -command GwmUpdate
   $backmenu add radiobutton -label "None" -variable GWM_BACK \
                 -selectcolor $RB_COL -value "" -command GwmUpdate

# Add items to the Colours sub-menu.
   set colsmenu [menu $OPTSMENU.cols]
   ColMenu $colsmenu "Contours"          GWM_CONCOL
   ColMenu $colsmenu "Cross-hair"        GWM_XHRCOL
   ColMenu $colsmenu "Background"        GWM_BADCOL
   ColMenu $colsmenu "Polygon Outlines"  GWM_POLCOL
   ColMenu $colsmenu "Selection Box"     GWM_SELCOL

# Add items to the "Contours" sub-menu.
   set contsmenu [menu $OPTSMENU.conts]
   foreach nc "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15" {
      $contsmenu add radiobutton -label "$nc" -variable GWM_NCONT \
                 -selectcolor $RB_COL -value $nc -command GwmUpdate
   }

   SetHelp $contsmenu ".  The number of contours to use when displaying the background as a contour map."

# Pack the menu buttons.
   pack $file $edit $opts -side left 
   pack $help -side right

# Create the GWM display.
   set gwm_frame [GwmCreate $F2.gwm $size 64 PolMap]
   if { $gwm_frame == "" } {
      if { $usingnewcmap } {
         Message "Failed to create the image display.\n\nIt may be possible to overcome this problem by closing down some other X applications, and then re-running polmap."
      } {
         Message "Failed to create the image display.\n\nIt may be possible to overcome this problem by re-running polmap giving a true value for the NEWCOLMAP parameter."
      }
      exit
   }
   pack $gwm_frame -side right -padx 2m -expand 1 -fill both

# -------------- DEMO FEATURE -------------------------------------------
# Create radio button which allows the user to enter and edit polygons.
   set rb1 [radiobutton $F2.rb1 -text "Edit an existing mask" -variable job \
                     -value 0 -state disabled -command "
                  set type(GWM_CURRENT_LIST) \"_CHOICE\"
                  set label(GWM_CURRENT_LIST) \"Enter the name of the mask to edit\"
                  set choices(GWM_CURRENT_LIST) \$lists
                  if { \[GetPars GWM_CURRENT_LIST type label choices \"Mask name\" \"\" \"Give the name of the mask to edit\"\] } {
                     SetMode 1
                  } {
                     set job 2
                  }" ]

   set rb2 [radiobutton $F2.rb2 -text "Create a new mask" -variable job \
                     -value 1 -command " 
                  set type(GWM_CURRENT_LIST) \"_CHAR*20\"
                  set label(GWM_CURRENT_LIST) \"Enter the name of the mask to create\"
                  if { \[GetPars GWM_CURRENT_LIST type label \"\" \"Mask name\" \"\" \"Give the name of the mask to create\"\] } {
                     SetMode 1
                     lappend lists \$GWM_CURRENT_LIST
                     $rb1 configure -state normal
                  } {
                     set job 2
                  }" ]

   set rb3 [radiobutton $F2.rb3 -text "No masks" -variable job \
                     -value 2 -command {SetMode 0}] 

   set lb [label $F2.lb1 -text "Application-specific\ncontrols go here."]

   pack $lb $rb1 $rb2 $rb3 -side top -anchor w -padx 2m -pady 3m 
   set job 2
# -----------------------------------------------

# Identify all the status items which can be displayed in the status area.
   StatusItem IMAGE        "Background image: "    "The name of the background image." $maxrimwid
   StatusItem GWM_SCALO    "Black data value: "    "The data value corresponding to black in the background image.\n(To change the black and white values, use the \"\% black\" and \"\% not white\" widget.)" 11
   StatusItem GWM_SECTION  "Displayed bounds: "    "The bounds of the background image.\n(To change the bounds of the background image, use the Zoom, Unzoom and Centre buttons.)" 25
   StatusItem GWM_SCAHI    "White data value: "    "The data value corresponding to white in the background image.\n(To change the black and white values, use the \"\% black\" and \"\% not white\" widget.)" 11
   StatusItem GWM_NCONT    "No. of contours: "     "The number of contours to use when displaying the background image as a contour map." 2
   StatusItem ACTION       "Current action: "      "The name of any Starlink program currently being executed." 20
   StatusItem POINTER_PXY  "Pointer coordinates: " "The pixel coordinates of the pointer (only displayed while the pointer is over the image)." 20
#   StatusItem POINTER_CXY  "Canvas coordinates: "  "The pixel coordinates of the pointer (only displayed while the pointer is over the image)." 20

# Load the options supplied by the atask.
   LoadOptions

# Destroy the "please wait" label, displayed while the main interface is
# being created.
   destroy $wait

# Create the status area if required.
   StatusArea $SAREA

# Create the help area if required.
   HelpArea

# Create a binding which calls MenuMotionBind whenever the pointer moves
# over any menu. This is used to determine the help information to display.
   bind Menu <Motion> {+MenuMotionBind %W %y}

# Create the catalogue of polarisation catalogues from the supplied Stokes 
# vectors.
   MakeCat

# Display the image.
   set GWM_IMAGE $NDF_IMAGE
   set GWM_SECTION $SECTION
   GwmUpdate

   update idletasks
   wm  title . PolMap
