      SUBROUTINE GRAPHS(STATUS)
*+
*  Name:
*     GRAPHS

*  Purpose:
*     Displays/analyses the results generated using SECTOR, 
*     ELLFOU or ELLPRO.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL GRAPHS( STATUS )

*  Arguments:   
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Description: 
*
*     Displays galaxy profiles and performs scale length analysis.
*     The data used comes from an ASCII text input file generated by 
*     ESP application ELLPRO, ELLFOU or SECTOR.
*
*     The application can be operated in two modes; interactive and file.
*
*     INTERACTIVE - The user can select whether the radius
*                   range used to calculate the scale length values
*                   are input via a keyboard (CURSOR=FALSE) or via the
*                   mouse/ball (CURSOR=TRUE). 
* 
*     FILE -        The user inputs the name of the text 
*                   file output by ELLPRO, ELLFOU or SECTOR and the 
*                   radius range over which isophotes will be employed 
*                   to calculate the galaxy scale length.
*
*     In the file mode, graphs are not displayed. Once the input 
*     filename has been entered, no further user interaction is 
*     required. The input file should contain the contents of a 
*     single file output from ELLFOU, ELLPRO, SECTOR, or, 
*     alternatively, several such files concatenated together.
*     In both modes, the name of the text file created by GRAPHS to 
*     store results in, is supplied by the user.
*
*     The X and Y co-ordinates output by SECTOR, ELLFOU and ELLPRO,
*     and hence those plotted by GRAPHS, are in the Base frame
*     coordinate system (units pixels) of the processed NDF images.
             
*  Usage:
*     GRAPHS MODE INFILE OUT RRANGE [AGAIN] [CURSOR] [DEVICE]
*            [FITLIM] [RADISP] [WHATD] (LOWLIM) (ANGCON) (ANGOFF)
 
*  ADAM Parameters:
*     AGAIN = _LOGICAL(Read)
*        Should the profile be displayed/analysed again?
*     ANGCON = _LOGICAL (Read)
*        Position angle rotation convention. TRUE=clockwise positive.
*     ANGOFF = _REAL (Read)
*        Position angle offset. Units degrees.
*     CURSOR = _LOGICAL (Read)
*        Whether the radius value range is to be identified using the 
*        graphics cursor or the keyboard. Only values within the user 
*        defined range will be used to determine the scale length.
*     DEVICE = _LOGICAL (Read) 
*        Name of the graphics device on which to display the
*        results graph.
*     FITLIM = _REAL (Read)
*        The range of radius values over which the scale length 'fits' 
*        are to be calculated. Units arc seconds.
*     INFILE = _CHAR (Read)
*        Name of the text file containing the galaxy profile.
*     LOWLIM = _REAL (Read)
*        The radius below which a profile will not be included 
*        in the automatic radius calculation. Units arc seconds.
*     MODE = LOGICAL (Read)
*        Is the application to be used interactively or in file mode?
*        TRUE = interactive. FALSE = file mode.
*     OUT = _CHAR (Read)
*        File name for the output text file containing the 
*        scale length data.
*     RADISP = _CHAR (Read)
*        The display mode used for the radius axis of the graphs.
*        - Q = quarter power
*        - L = logarithmic 
*        - S = square root 
*        - R = linear 
*        The radius values displayed are the equivalent radius
*        (R*) when using ELLPRO/ELLFOU input files and distance 
*        from the galaxy origin when using SECTOR derived files. 
*     RRANGE =_CHAR (Read)
*        Should the radius range be selected automatically? 
*     WHATD = _CHAR (Read)
*        What will be displayed against radius on the graphs.
*        -   B   = Brightness of the profile in terms of sky i.e. (I-Back)/Sigma
*        -   C   = Count value of the profile 
*        -   E   = Ellipticity of the profile
*        -   FC1 = First cosine Fourier descriptor
*        -   FC2 = First sine Fourier descriptor
*        -   FC3 = Second cosine Fourier descriptor
*        -   FC4 = Second sine Fourier descriptor
*        -   FS1 = Third cosine Fourier descriptor
*        -   FS2 = Third sine Fourier descriptor
*        -   FS3 = Fourth cosine Fourier descriptor
*        -   FS4 = Fourth sine Fourier descriptor
*        -   P   = Position angle of the profile
*        -   S   = Surface brightness of the profile
*        -   X   = X co-ordinate (Base frame)
*        -   Y   = Y co-ordinate (Base frame)
 
*  Examples:
*     graphs mode=true infile=results.dat out=scales.dat rrange=true 
*            cursor=true whatd=s radisp=r device=xwindows 
*
*         The file RESULTS.DAT is examined and its contents displayed
*         graphically as required. The first display will be of linear
*         radius versus surface brightness and will be shown on
*         device XWINDOWS. The radius range for the isophotes to be 
*         employed in the scale length calculation are selected 
*         interactively via the mouse/ball.     
*
*     graphs mode=true infile=profs.dat out=lengths.dat rrange=false
*            fitlim=1,20 cursor=false whatd=p radisp=l 
*            device=x2windows 
*
*         The results stored in file PROFS.DAT are read one after the.
*         other The profiles and 'fits' may be observed interactively as
*         graphs on device X2WINDOWS. The first display will be of 
*         log(radius) versus position angle. The radius range used
*         when calculating the scale length is 1 to 20 arc seconds.
*         results are output to file LENGTHS.DAT.
*
*     graphs mode=false infile=elf1.dat out=lengths.dat rrange=true
*
*        The profile data required is read in from file ELF1.DAT.
*        Data from isophotes chosen by the application
*        are selected for use in the scale length analysis. 
*        The results are output to file LENGTHS.DAT.
*
*     graphs mode=false infile=profs.dat out=scales.dat rrange=false
*            fitlim=0.5,7 
*     
*        Profile data read in from file PROFS.DAT is analysed to
*        determine the scale length using isophotes with a radius in 
*        the range 0.5 to 7 arc seconds. The results are output into
*        text file SCALES.DAT.

*  Notes:
*     Parameters surrounded by curved brackets may only be adjusted 
*     via the command line.
* 
*     Within ESP the scale lengths are calculated by assuming an
*     exponential brightness profile for spiral galaxies and an
*     exponential modified by a quarter power law for elliptical 
*     galaxies. The scale length
*     value given is derived from the decay constant of the 
*     exponential functions.

*  Authors:
*     GJP: Grant Privett (STARLINK)
*     MBT: Mark Taylor (STARLINK)
*     {enter_new_authors_here}

*  History:
*     04-DEC-1993 (GJP)
*     (Original version)
*     10-JAN-1997 (GJP)
*     Modified output file format to cope with big images.
*     10-NOV-1999 (MBT)
*     Modified for World Coordinate System awareness.
*      

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE

*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
         
*  Status:     
      INTEGER STATUS                  ! Global status

*  Local Variables:      
      LOGICAL MODE                    ! Interactive or file mode?
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   Show that the application is running.
      CALL MSG_BLANK(STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999
      CALL MSG_OUT(' ','ESP GRAPHS running.',STATUS)

*   Select interactive input or file input.
      CALL PAR_GET0L('MODE',MODE,STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999

*   Pass control to the appropriate subroutines.
      IF (MODE) THEN

*   Pass control to KCMODE.
         CALL GRA1_KCMODE(STATUS)

      ELSE

*   ASCII file input.
         CALL GRA1_FMODE(STATUS)

      END IF

*   Abort the program.
 9999 CONTINUE

      END 

      
      SUBROUTINE GRA1_LTYPE(BUFFER,LTYPE,STATUS) 
*+
*  Name:
*     GRA1_LTYPE

*  Purpose:
*     Determines what sort of text line has been found by the most 
*     recent attempt to read from the input text file.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*      CALL GRA1_LTYPE(BUFFER,LTYPE,STATUS)  

*  Description:
*     The contents of character string BUFFER are examined for
*     their meanings in the context of an ESP output file format.
*     
*     The program checks for the limits of the file by searching for
*     '## ESP' at the start and '## END' at the end, subheadings by seeking
*     any other lines starting with '##' and comments beginning with '!'. 
*
*     A code is returned showing what was found:
*
*     LTYPE=0 - For comments or very short lines.
*           1 - For the first line in a ELLFOU, ELLPRO or SECTOR file.
*           2 - For subheadings in the input file
*           3 - For the last line in ELLFOU, ELLPRO or SECTOR file.
*           4 - Everything else. Is generally assumed to contain numbers.

*  Arguments:               
*     BUFFER *(256) = CHARACTER (Given)
*        The character string read from the input.
*     LTYPE = INTEGER (Given)
*        The type of information within BUFFER. 
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     12-DEC-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants

*  Arguments Given:         
      CHARACTER *(80) BUFFER          ! Character string input from the file
                                      ! and to be examined
*  Arguments Returned:
      INTEGER LTYPE                   ! Type of line

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variables:
      CHARACTER *(80) STRING          ! Temporary string
      INTEGER I                       ! Temporary pointer
      INTEGER J                       ! Temporary pointer
      INTEGER LEN                     ! Length of BUFFER

*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN

*   Set default value.
      LTYPE=0

*   Get the length of the BUFFER.
      CALL CHR_FANDL(BUFFER,I,J)
      LEN=J-I+1

*   Check for comments or blank lines.
      IF ((BUFFER(1:1).EQ.'!').OR.(LEN.EQ.0)) GOTO 9999

*   Check for header line identifying which ESP application stored the data.
      STRING=BUFFER(1:6)
      CALL CHR_UCASE(STRING)
      IF (STRING.EQ.'## ESP') THEN 
         STRING=BUFFER(8:13)
         IF ((STRING.EQ.'SECTOR').OR.(STRING.EQ.'ELLFOU')
     :         .OR.(STRING.EQ.'ELLPRO')) THEN
            LTYPE=1 
            BUFFER=STRING
            GOTO 9999
         END IF
      END IF

*   Check for sub-heading line identifying what is stored on the next line.
*   Set LTYPE to distinguish between file terminators and normal sub-headings.
      STRING=BUFFER(1:3)
      IF ((STRING.EQ.'## ').AND.(LEN.GT.4)) THEN 

*      Remove the '## ' at the start, convert to upper case,
*      then locate first and last non-blank characters.
         STRING=BUFFER(4:J)       
         CALL CHR_UCASE(STRING)
         CALL CHR_FANDL(STRING,I,J)

*      Construct a string from the characters within those limits and
*      find the first word from that string. retain only its first 3
*      characters.
         BUFFER=STRING(I:J)
         CALL CHR_FIWE(BUFFER,I,STATUS)
         STRING=BUFFER(1:3)

         IF (STRING.EQ.'END') THEN
            LTYPE=3
            BUFFER='END'
         ELSE
            LTYPE=2
            BUFFER=STRING
         END IF
         GOTO 9999

      END IF

*   Whatever is left over should be a string or numbers.
      LTYPE=4

 9999 CONTINUE

      END 


      SUBROUTINE GRA1_RANGE(POINTS,PSIZE,RESULT,LOR,HIR,NUMB,STATUS)
*+
*  Name:
*     GRA1_RANGE

*  Purpose:
*     Determines the number of isophotes that are within the radius range 
*     specified by LOR and HIR.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*      CALL GRA1_RANGE(POINTS,PSIZE,RESULT,LOR,HIR,NUMB,STATUS)  

*  Description:
*      The results array is examined to check how many of the radii
*      values are within the radius range specified by the user (LOR, HIR).
*      NUMB is used to return that number.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     12-DEC-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'gra_par'               ! GRAPHS constants

*  Arguments Given:         
      INTEGER POINTS                  ! The number of isophotes
      REAL LOR                        ! Low limit for radius
      REAL HIR                        ! Upper limit for radius
      REAL PSIZE                      ! Pixel size
      REAL RESULT(GRA__RESUL,17)      ! Results array read from file

*  Arguments Returned:
      INTEGER NUMB                    ! Number of isophotes in the 
                                      ! required radius range

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variables:
      INTEGER I                       ! Loop variables
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   Initialise the useful data point counter.
      NUMB=0
      
*   Look through all the result isophotal radii values.
      DO 100 I=1,POINTS
       
*      Is it within the range required?
*      Increment the counter if true.
         IF ((PSIZE*RESULT(I,4).GE.LOR).AND.
     :             (PSIZE*RESULT(I,4).LE.HIR)) NUMB=NUMB+1

 100  CONTINUE
     
*   Display a message if too few points are present.
      IF (NUMB.LT.3) THEN
         CALL MSG_BLANK(STATUS)
         CALL MSG_OUT(' ','The radius range supplied,'//
     :                ' is too narrow to be used.',STATUS)
         CALL MSG_BLANK(STATUS)
      END IF

 9999 CONTINUE

      END 


      SUBROUTINE GRA1_SORT(POINTS,RESULT,STATUS)
*+
*  Name:
*     GRA1_SORT

*  Purpose:
*     Sort the results found into order of ascending radius.
*     Also, remove all elements that had counts below zero.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL GRA1_SORT(POINTS,RESULT,STATUS)  

*  Description:
*     The results array is searched for the isophote with the lowest radius
*     value. The results for that isophote are transfered to the next
*     vacant element of the temporary storage array. The results array
*     is then searched again and the next smallest radius treated similarly.
*
*     When all the values have been extracted from the results array,
*     the values storeed in the temporary array are transferred back to
*     the results array.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     15-DEC-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'gra_par'               ! GRAPHS constants

*  Arguments Given:         
      INTEGER POINTS                  ! Total number of isophotes

*  Arguments Given and Returned:
      REAL RESULT(GRA__RESUL,17)      ! Results array read from file

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variables:
      INTEGER DUFF                    ! Bad element counter
      INTEGER I                       ! Loop variable
      INTEGER J                       ! Temporary storage 
      INTEGER K                       ! Temporary storage
      INTEGER L                       ! Loop variable
      REAL LOWEST                     ! Lowest radius value found
      REAL NEGAT                      ! A small negative number
      REAL ARRAY(GRA__RESUL,17)       ! Temporary Results
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   Look through the results array to see how many count values
*   Create variable of very small negative value.
      NEGAT=-GRA__VSMAL

*   are at or below zero. Also, tag them so they may be ignored later.
      DUFF=0
      DO 100 I=1,POINTS
         IF (RESULT(I,5).LT.GRA__VSMAL) THEN
            DUFF=DUFF+1
            RESULT(I,4)=NEGAT
         END IF
 100  CONTINUE         

*   Tell the user that duff values were found.
      IF (DUFF.GT.0) THEN 

         CALL MSG_BLANK(STATUS)
         CALL MSG_OUT(' ','Some count values were found to be '/
     :                /'below zero. These will be deleted.',STATUS)
      END IF

*   General message to the user. Only if there are lots of profiles.
      IF(POINTS.GT.100) THEN
         CALL MSG_BLANK(STATUS)
         CALL MSG_OUT(' ','Sorting the results.',STATUS)
         CALL MSG_BLANK(STATUS)
      END IF

*   Find the lowest value in the radius column of the results array.
*   Transfer the value found into the new results array.
      DO 20 K=1,POINTS

         LOWEST=1E20
         DO 10 I=1,POINTS

*         Is the latest radius lower?
            IF ((RESULT(I,4).LT.LOWEST)
     :                  .AND.(RESULT(I,4).GT.NEGAT)) THEN

*            Update the lowest value.
               J=I
               LOWEST=RESULT(I,4)

            END IF

 10      CONTINUE

*      Place the results for the required isophote into
*      the new new results array.
         DO 30 L=1,17
            ARRAY(K,L)=RESULT(J,L)
 30      CONTINUE
         
*      Place a value in the original array that will make sure its ignored 
*      next time round.
         RESULT(J,4)=NEGAT

 20   CONTINUE

*   Correct the number of pixels to allow for the negative counts.
      POINTS=POINTS-DUFF

*   Transfer all the values in the temporary array back into the 
*   results array.
      DO 40 I=1,POINTS
         DO 50 L=1,17
            RESULT(I,L)=ARRAY(I,L)
 50      CONTINUE
 40   CONTINUE

 9999 CONTINUE

      END


      SUBROUTINE GRA1_SECT(FIOID,RFAIL,POINTS,RESULT,
     :               FILEN,BACK,SIGMA,PSIZE,XCO,YCO,CURCO,ZEROP,STATUS)
*+
*  Name:
*     GRA1_SECT

*  Purpose:
*     Read in the data found in a text file created by SECTOR.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL GRA1_SECT(FIOID,RFAIL,POINTS,RESULT,
*                    FILEN,BACK,SIGMA,PSIZE,XCO,YCO,CURCO,ZEROP,STATUS) 

*  Description:
*     Reads in the lines of a text file until either '## END' or
*     an end of file message is encountered. The lines found are
*     examined to determine which mubers correspond to which 
*     values such as pixel size in the original image. This is acheived 
*     using subheadings (line starting ##) which tell the routine
*     which number(s) is on the next line.
*
*     A simple check is made on value (where) possible to ensure that
*     it is not absurd (i.e. negative background count value).

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     12-DEC-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'gra_par'               ! GRAPHS constants
      INCLUDE 'FIO_ERR'               ! FIO error definitions
      INCLUDE 'SAE_PAR'               ! Standard SAE constants

*  Arguments Given:         
      INTEGER FIOID                   ! FIO identifier for the input file
      INTEGER RFAIL                   ! Has the end of the file been found?

*  Arguments Returned:
      CHARACTER *(80) CURCO           ! Current coordinates fo galaxy
      CHARACTER *(80) FILEN           ! Name of the image on which the profiled
                                      ! galaxy is to be found
      INTEGER POINTS                  ! Total number of isophotes
      REAL PSIZE                      ! Pixel size
      REAL SIGMA                      ! Standard deviationof background count
      REAL BACK                       ! Sky background count
      REAL XCO                        ! X co-ordinate of galaxy
      REAL YCO                        ! Y co-ordinate of galaxy
      REAL RESULT(GRA__RESUL,17)      ! Results array read from file
      REAL ZEROP                      ! Magnitude scale zero point

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variables:
      CHARACTER *(80) BUFFER          ! Contents of a line read from the text
                                      ! input file
      CHARACTER *(80) STRING          ! Temporary storage
      INTEGER FAIL                    ! Has there been a problem with the
                                      ! values read from the file
      INTEGER FOUND(10)               ! Flags used to show if any of the
                                      ! numbers in the file were corrupt
      INTEGER I                       ! Loop variable
      INTEGER LTYPE                   ! Type of line found
      INTEGER N                       ! Counter
      INTEGER NUMW                    ! Number of words found in a string
      REAL TEMP(20)                   ! Numbers read from the current line

*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   Set default values.
      POINTS=0
      FAIL=0
      FILEN=' '
      XCO=-1
      DO 10 I=1,8
         FOUND(I)=0
 10   CONTINUE

*   Read from a file. Stop if the end of file is reached or if the file is
*   corrupted or if the file header has been found.
      LTYPE=0
      BUFFER=' '
      DO WHILE ((RFAIL.EQ.SAI__OK).AND.(LTYPE.NE.3).AND.(FAIL.EQ.0))

*       Read a line from the steering file.
         CALL GRA1_GETLINE(FIOID,BUFFER,RFAIL,STATUS)

*       Proceed since successfully read file.
         IF (RFAIL.EQ.SAI__OK) THEN

*         Determine the line type.
            CALL GRA1_LTYPE(BUFFER,LTYPE,STATUS)

*         Handle each type of possible format.
            IF ((LTYPE.EQ.2).AND.(STATUS.EQ.SAI__OK)) THEN
        
*            Filename.   
               STRING=BUFFER
               IF ((STRING.EQ.'FIL').AND.(FAIL.EQ.0)) THEN
                  CALL GRA1_RCHAR(FIOID,RFAIL,BUFFER,STATUS)
                  CALL CHR_RMBLK(BUFFER)
                  FILEN=BUFFER
                  IF (FILEN.EQ.' ') THEN
                     FAIL=1
                     FOUND(1)=1
                  ELSE
                     CALL MSG_OUT(' ','Source image was:'/
     :                            /FILEN,STATUS)
                  END IF
               END IF

*            Background.
               IF ((STRING.EQ.'BAC').AND.(FAIL.EQ.0)) THEN 
                  CALL GRA1_RNUMBS(FIOID,RFAIL,TEMP,NUMW,STATUS)
                  BACK=TEMP(1)
               END IF

*            Sigma.
               IF ((STRING.EQ.'SIG').AND.(FAIL.EQ.0)) THEN 
                  CALL GRA1_RNUMBS(FIOID,RFAIL,TEMP,NUMW,STATUS)
                  SIGMA=TEMP(1)
                  IF (SIGMA.LT.GRA__VSMAL) THEN 
                     FAIL=3
                     FOUND(3)=1
                  END IF
               END IF
    
*            Pixel size.
               IF ((STRING.EQ.'PIX').AND.(FAIL.EQ.0)) THEN 
                  CALL GRA1_RNUMBS(FIOID,RFAIL,TEMP,NUMW,STATUS)
                  PSIZE=TEMP(1)
                  IF (PSIZE.LT.GRA__VSMAL) THEN 
                     FAIL=4
                     FOUND(4)=1
                  END IF
               END IF

*            Initial galaxy centre co-ordinates.
               IF ((STRING.EQ.'X/Y').AND.(FAIL.EQ.0)) THEN 
                  IF (XCO.LT.0.0) THEN 
                     CALL GRA1_RNUMBS(FIOID,RFAIL,TEMP,NUMW,STATUS)
                     XCO=TEMP(1)
                     YCO=TEMP(2)
                  ELSE
                     CALL GRA1_RCHAR(FIOID,RFAIL,BUFFER,STATUS)
                     CURCO=BUFFER
                  END IF
              END IF

*            Number of profiles.
               IF ((STRING.EQ.'NUM').AND.(FAIL.EQ.0)) THEN 
                  CALL GRA1_RNUMBS(FIOID,RFAIL,TEMP,NUMW,STATUS)
                  POINTS=TEMP(1)
                  IF (POINTS.LT.GRA__VSMAL) THEN
                     FAIL=6
                     FOUND(6)=1
                  END IF
               END IF

*            Magnitude scale zero point.
               IF ((STRING.EQ.'ZER').AND.(FAIL.EQ.0)) THEN 
                  CALL GRA1_RNUMBS(FIOID,RFAIL,TEMP,NUMW,STATUS)
                  ZEROP=TEMP(1)
                  IF (ZEROP.LT.GRA__VSMAL) THEN
                     FAIL=8
                     FOUND(8)=1
                  END IF
               END IF

*            Profile results.
               IF ((POINTS.GT.0).AND.(STRING.EQ.'PRO')
     :               .AND.(FAIL.EQ.0)) THEN
                  FAIL=0
                  N=0
                  DO WHILE ((FAIL.EQ.0).AND.(N.NE.POINTS))
                     CALL GRA1_RNUMBS(FIOID,RFAIL,TEMP,NUMW,STATUS)
                     IF ((RFAIL.EQ.0).AND.(NUMW.EQ.4)) THEN
                        N=N+1
                        RESULT(N,4)=TEMP(1)
                        RESULT(N,5)=TEMP(2)
                     ELSE
                        FAIL=7
                        FOUND(7)=1
                     END IF
                  END DO
               END IF

            END IF 

         END IF

      END DO


*   Check that all the required entries were found.
      FAIL=0
      DO 300 I=8,1,-1
         IF (FOUND(I).EQ.1) FAIL=I
 300  CONTINUE

*   Check the defaults. Set a flag if one of them has not been 
*   assigned a value from the file.
      IF (RFAIL.EQ.FIO__EOF) THEN 
         CALL MSG_OUT(' ','End-of-file found.',STATUS)        
         CALL MSG_BLANK(STATUS)
         RFAIL=-1
      END IF
      IF (LTYPE.EQ.3) THEN 
         CALL MSG_OUT(' ','End of filename report.',STATUS)
         CALL MSG_BLANK(STATUS)
         RFAIL=0
      END IF
      IF (FAIL.NE.0) THEN 
         CALL GRA1_EMSG(FAIL,STATUS)
         CALL MSG_BLANK(STATUS)
         RFAIL=1
      END IF

 9999 CONTINUE

      END 


      SUBROUTINE GRA1_ELLS(FIOID,RFAIL,POINTS,RESULT,
     :               FILEN,BACK,SIGMA,PSIZE,XCO,YCO,CURCO,ZEROP,STATUS)
*+
*  Name:
*     GRA1_ELLS
*
*  Purpose:
*     Read in the data found in a text file created by ELLPRO or ELLFOU.
*
*  Language:
*     Starlink Fortran 77
*
*  Invocation:
*     CALL GRA1_ELLS(FIOID,RFAIL,POINTS,RESULT,
*                    FILEN,BACK,SIGMA,PSIZE,XCO,YCO,CURCO,ZEROP,STATUS) 
*
*  Description:
*     Reads in the lines of a text file until either '## END' or
*     an end of file message is encountered. The lines found are
*     examined to determine which mubers correspond to which 
*     values such as pixel size in the original image. This is acheived 
*     using subheadings (line starting ##) which tell the routine
*     which number(s) is on the next line.
*
*     A simple check is made on value (where) possible to ensure that
*     it is not absurd (i.e. negative background count value).
*
*  Authors:
*     GJP: Grant Privett (STARLINK)
*     NG: Norman Gray (Starlink, Glasgow)
*
*  History:
*     12-DEC-1993 (GJP)
*       (Original version)
*     11-Nov-1999 (NG)
*       Modified so that the reading of ellipse parameters will allow
*       (but ignore) columns beyond column 9.  See below for explanation.
*  
*
*  Bugs:
*     None known.
*
*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'gra_par'               ! GRAPHS constants
      INCLUDE 'FIO_ERR'               ! FIO error definitions
      INCLUDE 'SAE_PAR'               ! Standard SAE constants

*  Arguments Given:         
      INTEGER FIOID                   ! FIO identifier for the input file
      INTEGER RFAIL                   ! Has the end of the file been found?

*  Arguments Returned:
      CHARACTER *(80) CURCO           ! Current coordinates of the galaxy
      CHARACTER *(80) FILEN           ! Name of the image on which the profiled
                                      ! galaxy is to be found
      INTEGER POINTS                  ! Total number of isophotes
      REAL PSIZE                      ! Pixel size
      REAL SIGMA                      ! Standard deviation of the background count
      REAL BACK                       ! Sky background count
      REAL XCO                        ! X co-ordinate of galaxy
      REAL YCO                        ! Y co-ordinate of galaxy
      REAL RESULT(GRA__RESUL,17)      ! Results array read from file
      REAL ZEROP                      ! Magnitude scale zero point

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variables:
      CHARACTER *(80) BUFFER          ! Contents of a line read from the text
                                      ! input file
      CHARACTER *(80) STRING          ! Temporary storage
      INTEGER FAIL                    ! Has there been a problem with the
                                      ! values read from the file
      INTEGER FOUND(10)               ! Flags used to show if any of the
                                      ! numbers in the file were corrupt
      INTEGER I                       ! Loop variable
      INTEGER LTYPE                   ! Type of line found
      INTEGER N                       ! Counter
      INTEGER NUMW                    ! Number of words found in a string
      REAL TEMP(20)                   ! Numbers read from the current line
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   Set default values.
      POINTS=0
      FAIL=0
      FILEN=' '
      XCO=-1
      DO 10 I=1,9
         FOUND(I)=0
 10   CONTINUE

*   Read from a file. Stop if the end of file is reached or if the file is
*   corrupted or if the file header has been found.
      LTYPE=0
      BUFFER=' '
      DO WHILE ((RFAIL.EQ.SAI__OK).AND.(LTYPE.NE.3).AND.(FAIL.EQ.0))

*       Read a line from the steering file.
         CALL GRA1_GETLINE(FIOID,BUFFER,RFAIL,STATUS)
       
*       Proceed since successfully read file.
         IF (RFAIL.EQ.SAI__OK) THEN

*         Determine the line type.
            CALL GRA1_LTYPE(BUFFER,LTYPE,STATUS)

*         Handle each type of possible format.
            IF ((LTYPE.EQ.2).AND.(STATUS.EQ.SAI__OK)) THEN
        
*            Filename.   
               STRING=BUFFER
               IF ((STRING.EQ.'FIL').AND.(FAIL.EQ.0)) THEN
                  CALL GRA1_RCHAR(FIOID,RFAIL,BUFFER,STATUS)
                  CALL CHR_RMBLK(BUFFER)
                  FILEN=BUFFER
                  IF (FILEN.EQ.' ') THEN
                     FAIL=1
                     FOUND(1)=1
                  ELSE
                     CALL MSG_OUT(' ','Source image was:'/
     :                            /FILEN,STATUS)
                  END IF
               END IF

*            Background.
               IF ((STRING.EQ.'BAC').AND.(FAIL.EQ.0)) THEN 
                  CALL GRA1_RNUMBS(FIOID,RFAIL,TEMP,NUMW,STATUS)
                  BACK=TEMP(1)
               END IF

*            Sigma.
               IF ((STRING.EQ.'SIG').AND.(FAIL.EQ.0)) THEN 
                  CALL GRA1_RNUMBS(FIOID,RFAIL,TEMP,NUMW,STATUS)
                  SIGMA=TEMP(1)
                  IF (SIGMA.LT.GRA__VSMAL) THEN 
                     FAIL=3
                     FOUND(3)=1
                  END IF
               END IF
    
*            Pixel size.
               IF ((STRING.EQ.'PIX').AND.(FAIL.EQ.0)) THEN 
                  CALL GRA1_RNUMBS(FIOID,RFAIL,TEMP,NUMW,STATUS)
                  PSIZE=TEMP(1)
                  IF (PSIZE.LT.GRA__VSMAL) THEN 
                     FAIL=4
                     FOUND(4)=1
                  END IF
               END IF

*            Initial galaxy centre co-ordinates.
               IF ((STRING.EQ.'X/Y').AND.(FAIL.EQ.0)) THEN 
                  IF (XCO.LT.0.0) THEN 
                     CALL GRA1_RNUMBS(FIOID,RFAIL,TEMP,NUMW,STATUS)
                     XCO=TEMP(1)
                     YCO=TEMP(2)
                  ELSE
                     CALL GRA1_RCHAR(FIOID,RFAIL,BUFFER,STATUS)
                     CURCO=BUFFER
                  END IF
              END IF

*            Number of profiles.
               IF ((STRING.EQ.'NUM').AND.(FAIL.EQ.0)) THEN 
                  CALL GRA1_RNUMBS(FIOID,RFAIL,TEMP,NUMW,STATUS)
                  POINTS=TEMP(1)
                  IF (POINTS.LT.GRA__VSMAL) THEN
                     FAIL=6
                     FOUND(6)=1
                  END IF
               END IF

*            Magnitude scale zero point.
               IF ((STRING.EQ.'ZER').AND.(FAIL.EQ.0)) THEN 
                  CALL GRA1_RNUMBS(FIOID,RFAIL,TEMP,NUMW,STATUS)
                  ZEROP=TEMP(1)
                  IF (ZEROP.LT.GRA__VSMAL) THEN
                     FAIL=9
                     FOUND(9)=1
                  END IF
               END IF

*            Profile results.
               IF ((POINTS.GT.0).AND.(STRING.EQ.'ELL')
     :               .AND.(FAIL.EQ.0)) THEN
                  FAIL=0
                  N=0
                  DO WHILE ((FAIL.EQ.0).AND.(N.NE.POINTS))
                     CALL GRA1_RNUMBS(FIOID,RFAIL,TEMP,NUMW,STATUS)
*                  Accept, but ignore, any columns beyond column 9.
*                  This used to fail unless NUMW was .eq.9, but this prevents
*                  other applications (specifically gaufit) from adding further
*                  columns, without really gaining anything.
                     IF ((RFAIL.EQ.0).AND.(NUMW.GE.9)) THEN
                        N=N+1
                        DO 100 I=1,9
                           RESULT(N,I)=TEMP(I)
 100                    CONTINUE
                     ELSE
                        FAIL=7
                        FOUND(7)=1
                     END IF
                  END DO
               END IF

*            Fourier descriptor results.
               IF ((POINTS.GT.0).AND.(STRING.EQ.'FOU')
     :               .AND.(FAIL.EQ.0)) THEN 
                  FAIL=0
                  N=0
                  DO WHILE ((FAIL.EQ.0).AND.(N.NE.POINTS)) 
                     CALL GRA1_RNUMBS(FIOID,FAIL,TEMP,NUMW,STATUS)
                     IF ((FAIL.EQ.0).AND.(NUMW.EQ.9)) THEN
                        N=N+1
                        DO 200 I=2,9
                           RESULT(N,8+I)=TEMP(I)
 200                    CONTINUE
                     ELSE
                        FAIL=8
                        FOUND(8)=1
                     END IF
                  END DO

               END IF

            END IF 

         END IF

      END DO


*   Check that all the required entries were found.
      FAIL=0
      DO 300 I=9,1,-1
         IF (FOUND(I).EQ.1) FAIL=I
 300  CONTINUE
          
*   Check the defaults. Set a flag if one of them has not been 
*   assigned a value from the file.
      IF (RFAIL.EQ.FIO__EOF) THEN 
         CALL MSG_OUT(' ','End-of-file found.',STATUS)        
         CALL MSG_BLANK(STATUS)
         RFAIL=-1
      END IF
      IF (LTYPE.EQ.3) THEN 
         CALL MSG_OUT(' ','End of filename report.',STATUS)
         CALL MSG_BLANK(STATUS)
         RFAIL=0
      END IF
      IF (FAIL.NE.0) THEN 
         CALL GRA1_EMSG(FAIL,STATUS)
         CALL MSG_BLANK(STATUS)
         RFAIL=1
      END IF

 9999 CONTINUE

      END 


      SUBROUTINE GRA1_RNUMBS(FIOID,FAIL,TEMP,NUMW,STATUS)
*+
*  Name:
*     GRA1_RNUMBS

*  Purpose:
*     Read in a line from the text file and try to find the numbers in it.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL GRA1_RNUMBS(FIOID,FAIL,TEMP,NUMW,STATUS)

*  Description:
*     A line of text from the input file is read in. If the end of file 
*     was not found, it is examined to see how many words are
*     contained in it. The words found are then converted into their
*     numeric equivalents. Values for the words found (TEMP) and the 
*     number of words found (NUMW) are returned.   

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     12-DEC-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants

*  Arguments Given:         
      INTEGER FIOID                   ! FIO identifier for the input file

*  Arguments Returned:
      INTEGER FAIL                    ! Has the end of the file been found?

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variables:
      CHARACTER *(80) BUFFER          ! Contents of a line read from the text
                                      ! input file
      CHARACTER *(80) STRING          ! Temporary storage
      LOGICAL OKAY                    ! Was the line of text read in
                                      ! the type of data expected?
      LOGICAL NUMBOK                  ! Did word extraction fail?
      INTEGER I                       ! Loop variable
      INTEGER J                       ! Temporary storage
      INTEGER INDEXE                  ! Index of the end of a word
      INTEGER INDEX(2,20)             ! Locations of words in the string
      INTEGER INDEXS                  ! Index of the start of a word
      INTEGER LTYPE                   ! Line type 
      INTEGER NUMW                    ! Number of words found in a string
      INTEGER RFAIL                   ! Was the end of file found?
      INTEGER VALNUM                  ! Temporary storage
      REAL TEMP(20)                   ! Numbers read from the current line
      REAL TEMPR                      ! Temporary storage of a real value
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   Loop round reading lines of the file until a non-comment or number are
*   encountered.
      OKAY=.FALSE.
      FAIL=0
      DO WHILE ((FAIL.EQ.0).AND.(.NOT.OKAY))

*      Get the next line.
         CALL GRA1_GETLINE(FIOID,BUFFER,RFAIL,STATUS)

*      Only proceed if not the end of the file.
         IF (RFAIL.EQ.SAI__OK) THEN

*         Determine whether the line is a number.
            CALL GRA1_LTYPE(BUFFER,LTYPE,STATUS)

*         Abandon the attempt if the required input was found.
            IF (LTYPE.EQ.4) OKAY=.TRUE.

         ELSE

*         Also abandon the loop if an eof was found.
            FAIL=1

         END IF

      END DO

*   Search the string received for numbers and place those found in 
*   the TEMP array.
      IF (OKAY) THEN

*      Truncate the buffer.
         CALL CHR_FANDL(BUFFER,I,J)
         STRING=BUFFER(I:J)

         INDEXE=-1
         NUMBOK=.TRUE.
         NUMW=0
         DO WHILE (NUMBOK)

*         Create a new error context.
            CALL ERR_MARK

*         Look for the words.
            INDEXS=INDEXE+1
            CALL CHR_FIWS(BUFFER,INDEXS,STATUS)
            INDEXE=INDEXS
            CALL CHR_FIWE(BUFFER,INDEXE,STATUS)

*         Set the fail flag if the word extraction failed.
            IF (STATUS.NE.SAI__OK) THEN

*            Reset the status value.
               NUMBOK=.FALSE.
               CALL ERR_ANNUL(STATUS)

            ELSE

*            Increment the word counter.
               NUMW=NUMW+1
               IF (NUMW.GT.20) NUMW=20

*            Retain the locations of words.
               INDEX(1,NUMW)=INDEXS
               INDEX(2,NUMW)=INDEXE

            END IF

*         End error context.
            CALL ERR_RLSE

         END DO
      
*      Convert the words that were found.
         IF (NUMW.GT.0) THEN
            
*         Look at each number in turn.
            VALNUM=0
            DO 10 I=1,NUMW
          
*            Create new error context.
               CALL ERR_MARK
              
*            Examine the word and convert to a number.
               STRING=BUFFER(INDEX(1,I):INDEX(2,I))
               CALL CHR_CTOR(STRING,TEMPR,STATUS)

*            Display the cause of the problem.
               IF (STATUS.NE.SAI__OK) THEN
                  CALL ERR_ANNUL(STATUS)
                  CALL MSG_OUT(' ','Characters found where'/
     :                         /' a number was expected.',STATUS)
               
               ELSE

*               Increment the valid number counter and store 
*               the numbers that were found.
                  VALNUM=VALNUM+1
                  TEMP(VALNUM)=TEMPR
               
               END IF

*            Finish the error context.
               CALL ERR_RLSE

 10         CONTINUE

         ELSE
            
*         Indicate that no numbers were found.
            CALL MSG_OUT(' ','Bad text line.',STATUS)

         END IF

      END IF
     
 9999 CONTINUE
      
      END


      SUBROUTINE GRA1_RCHAR(FIOID,FAIL,BUFFER,STATUS) 
*+
*  Name:
*     GRA1_RCHAR

*  Purpose:
*     Read lines in from a file until the end of file is found
*     or a non-comment line is obtained.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL GRA1_RCHAR(FIOID,FAIL,BUFFER,STATUS) 

*  Description:
*     Reads a line in from the input text file and determines what 
*     type of information it contains. Loops round until a non-comment
*     non-blank line is found or until the end of file is found.

*  Authors:
*     GJP: Grant Privett (STARLINK)
*     MBT: Mark Taylor (STARLINK)

*  History:
*     12-DEC-1993 (GJP)
*     (Original version)
*     10-NOV-1999 (MBT)
*     Modified so it doesn't remove blanks.

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'FIO_ERR'               ! FIO error definitions

*  Arguments Given:         
      INTEGER FIOID                   ! FIO identifier for the input file

*  Arguments Returned:
      INTEGER FAIL                    ! Has the end of the file been found?
      CHARACTER *(80) BUFFER          ! Contents of a line read from the text
                                      ! input file

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variables:
      LOGICAL OKAY                    ! Was an error found reading the text
      INTEGER LTYPE                   ! Line type
      INTEGER NCHAR                   ! Number of characters in text line

*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   Loop round reading lines of the file until a non-comment is encountered.
      OKAY=.FALSE.
      FAIL=0
      DO WHILE ((FAIL.EQ.0).AND.(.NOT.OKAY))

*      Set up error context.
         CALL ERR_MARK

*      Get the next line.
         CALL FIO_READ(FIOID,BUFFER,NCHAR,STATUS)

*      Determine what the line is.
         CALL GRA1_LTYPE(BUFFER,LTYPE,STATUS)

*      Abandon the attempt if the required input was not found
*      or if it was. Set different flags accordingly.
         IF (STATUS.NE.SAI__OK) THEN 
            FAIL=1
            CALL ERR_ANNUL(STATUS)
         ELSE
            OKAY=.TRUE.
         END IF

*      End error context.
         CALL ERR_RLSE

      END DO
       
*   Check for an empty buffer.
      IF (BUFFER.EQ.' ') FAIL=1

 9999 CONTINUE
      
      END


      SUBROUTINE GRA1_EMSG(FAIL,STATUS)
*+
*  Name:
*     GRA1_EMSG

*  Purpose:
*     Outputs a message to the screen about the problem found
*     when reading the SECTOR, ELLFOU or ELLPRO file.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL GRA1_EMSG(FAIL,STATUS) 

*  Description:
*     Using the value of FAIL, the routine displays the name of the
*     parameter that was not found (or was corrupt).

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     12-DEC-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants

*  Arguments Given:         
      INTEGER FAIL                    ! Identifies the part of the text file
                                      ! that was absent/corrupt
*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variable:
      CHARACTER *(80) BUFFER          ! A text mesage
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   Set up the buffer with the appropriate error message.

*   Initial value.
      BUFFER=' '

*   Miscellaneous error messages
      IF (FAIL.EQ.1) BUFFER='Filename unusable.'
      IF (FAIL.EQ.2) BUFFER='Background value unusable.'
      IF (FAIL.EQ.3) BUFFER='Sigma value unusable.'
      IF (FAIL.EQ.4) BUFFER='Pixel size unusable'
      IF (FAIL.EQ.5) BUFFER='Initial co-ordinates unusable.'
      IF (FAIL.EQ.6) BUFFER='Number of profiles unusable.'
      IF (FAIL.EQ.7) BUFFER='Profiles unusable.'
      IF (FAIL.EQ.8) BUFFER='Fourier descriptors unusable.'
      IF (FAIL.EQ.9) BUFFER='Zero point value unusable.'

*   Display the appropriate error message.
      CALL MSG_OUT(' ',
     : 'Errors found with some of the file parameters!!',STATUS)
      CALL MSG_OUT(' ',BUFFER,STATUS)
      CALL MSG_OUT(' ',' ',STATUS)

 9999 CONTINUE
      
      END

     
      SUBROUTINE GRA1_GETLINE(FIOID,BUFFER,RFAIL,STATUS)
*+
*  Name:
*     GRA1_GETLINE

*  Purpose:
*     Reads a line of text from the input file.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL GRA1_GETLINE(FIOID,BUFFER,RFAIL,STATUS)

*  Description:
*     Reads a line of text in from the text file and checks to see
*     if the end of file was not found. If it was then RFAIL is set.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     12-DEC-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'FIO_ERR'               ! FIO error definitions
      INCLUDE 'SAE_PAR'               ! Standard SAE constants

*  Arguments Given:         
      INTEGER FIOID                   ! FIO identifier

*  Arguments Returned:
      CHARACTER *(80) BUFFER          ! The text read from the file
      INTEGER RFAIL                   ! Was the end of file found?

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variables:
      INTEGER NCHAR                   ! Length of string returned
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   Set default error value.
      RFAIL=0

*   Create  a new error context.
      CALL ERR_MARK

*      Get the next line.
         CALL FIO_READ(FIOID,BUFFER,NCHAR,STATUS)

*      Display a message.
         IF (STATUS.NE.SAI__OK) THEN
            IF (STATUS.EQ.FIO__EOF) THEN
               CALL ERR_ANNUL(STATUS)
               CALL MSG_BLANK(STATUS)
               CALL MSG_OUT(' ','End of file found.',STATUS)
               RFAIL=FIO__EOF
            ELSE
               CALL ERR_ANNUL(STATUS)
               RFAIL=STATUS
               CALL MSG_OUT(' ','Problems reading the file.',STATUS)
            END IF

         END IF

*   Finish the error context.
      CALL ERR_RLSE

 9999 CONTINUE

      END 



      SUBROUTINE GRA1_GRLIMS(POINTS,RESULT,CURSOR,PSIZE,RADISP,
     :                       LOR,HIR,STATUS)    
*+
*  Name:
*     GRA1_GRLIMS

*  Purpose:
*     Depending on the value of CURSOR, radius range limits are defined
*     by either keyboard entry or via a graphics cursor.
      
*  Language:
*     Starlink Fortran 77

*  Invocation:
*      CALL GRA1_GRLIMS(CURSOR,PSIZE,RADISP,LOR,HIR,STATUS)    

*  Description:

*  Arguments:               
*     POINTS = INTEGER (Given)
*        The number of isophotes available.
*     RESULT(GRA__RESUL,17) = REAL (Returned)
*        The profiling results input from the text file.
*     CURSOR = LOGICAL (Given)
*        Defines whether the radii limits are to be determined via 
*        keyboard or the graphics cursor. 
*     PSIZE = REAL (Read)
*        Size of the image pixels in arc seconds.
*     RADISP = CHAR (Read)
*        The display mode used for the radius axis of the graphs.
*        (Q=quarter power, L=logarithmic, S=square root, R=linear) 
*     LOR = REAL (Returned)
*        Lowest acceptable radius value.
*     HIR = REAL (Returned)
*        Highest acceptable radius value.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     23-FEB-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'gra_par'               ! GRAPHS constants

*  Arguments Given:                              
      LOGICAL CURSOR                  ! Defines keyboard or cursor as input
                                      ! route
      CHARACTER *(256) RADISP         ! Defines the type of radius
                                      ! transformation used on the graph
      INTEGER POINTS                  ! The number of isophotes
      REAL PSIZE                      ! Size of the pixels
      REAL RESULT(GRA__RESUL,17)      ! Profiling results
    
*  Arguments Returned:
      REAL HIR                        ! Highest radius value
      REAL LOR                        ! Lowest radius value

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variables:
      LOGICAL INOKAY                  ! Has a sensible radius range
                                      ! been set?
      INTEGER IND                     ! Number of inputs expected
      INTEGER IND2                    ! Number of inputs received
      INTEGER NUMB                    ! Number of isophotes in the 
                                      ! radius range provided
      REAL INP(2)                     ! Storage for inputs
      REAL X1                         ! X co-ordinate from screen
      REAL X2                         ! X co-ordinate from screen
      REAL Y                          ! X co-ordinate from screen
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   Get radii limits via cursor if so requested by the user.
      IF (CURSOR) THEN

*      Loop around until two reasonable value have been selected
*      for the minimum and maximum radii.
         INOKAY=.FALSE.
         DO WHILE ((.NOT.INOKAY).AND.(STATUS.EQ.SAI__OK))

*         Display a cursor in the new window and get back the 
*         range of radius values the user is interested in.
            CALL GRA1_CURSO(1,X1,Y,STATUS)
            CALL GRA1_CURSO(2,X2,Y,STATUS)
            LOR=MIN(X1,X2)
            HIR=MAX(X1,X2)

*         Transfer the radius values for conversion.
            CALL GRA1_UNCON(RADISP,LOR,HIR,STATUS)         

*         Check to see if it is possible for there to be two 
*         data points in the radius range required.
            CALL GRA1_RANGE(POINTS,PSIZE,RESULT,LOR,HIR,NUMB,STATUS)
            IF (NUMB.GT.2) THEN
               INOKAY=.TRUE.
            ELSE
               CALL PAR_CANCL('FITLIM',STATUS)
            END IF

         END DO

      ELSE
         
*      Loop round until two sensible radius values are input.
         INOKAY=.FALSE.
         DO WHILE ((.NOT.INOKAY).AND.(STATUS.EQ.SAI__OK))

*         Get the two values from the keyboard.
            IND=2
            CALL PAR_GET1R('FITLIM',IND,INP,IND2,STATUS)

*         Check that the values were not inadvertantly 
*         reversed and swop them round so that the 
*         result can be sensible.
            IF (INP(1).LT.INP(2)) THEN
               LOR=INP(1)
               HIR=INP(2)
            ELSE
               CALL MSG_BLANK(STATUS)
               CALL MSG_OUT(' ','WARNING!!!',STATUS)
               CALL MSG_OUT(' ','The low and high values'/
     :                      /' were swapped.',STATUS)
               CALL MSG_BLANK(STATUS)
               LOR=INP(2)
               HIR=INP(1)
            END IF

*         Check to see if it is possible for there to be two 
*         data points in the radius range required.
            CALL GRA1_RANGE(POINTS,PSIZE,RESULT,LOR,HIR,NUMB,STATUS)
            IF (NUMB.GT.2) THEN 
               INOKAY=.TRUE.
            ELSE
               CALL PAR_CANCL('FITLIM',STATUS)
            END IF

         END DO
         IF (STATUS.NE.SAI__OK) GOTO 9999 

      END IF
      
 9999 CONTINUE
     
      END


      SUBROUTINE GRA1_KCMODE(STATUS)
*+
*  Name:
*     GRA1_KCMODE

*  Purpose:
*     Allows the data found in ELLFOU, ELLPRO or SECTOR output text
*     files to be displayed in a graphical form. The parameters are 
*     displayed (brightness etc) versus the radius.
*
*     The profile properties displayed depend on the application that 
*     generated the text file being examined. Fourier descriptors,
*     position angle etc are not available for SECTOR files.
*
*     If more than 2 isophotes were found in the current file, then a 
*     scale length calculation is attempted. The points used are taken 
*     from a user defined range.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL GRA1_KCMODE(STATUS)

*  Arguments:   
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Description: 
*     Looks through the contents of the text file specified by the
*     user. Finds any ESP format entries created by SECTOR, ELLPRO
*     or ELLFOU. 
*
*     When one has been found, the contents are read and checked.
*     If they appear to be sensible, they are displayed in the form 
*     requested by the user i.e. parameter vs radius.
*
*     If data for a sufficient number of isophotes has been found 
*     a scale length calculation is attempted. The spiral and 
*     elliptical galaxy fits are displayed with the raw data.
*
*     The scale length determined for a given data set is stored
*     in an output file. The input text file is then re-examined to
*     see if any more valid ESP format files are contained therein.
*     If there are, they are similarly processed.
*.

*  Implementation Status:
*     Under development

*  Authors:
*     GJP: Grant Privett (STARLINK)
*     {enter_new_authors_here}

*  History:                                       
*     16-Nov-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE

*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'PRM_PAR'               ! PRIMDAT primitive data constants
      INCLUDE 'gra_par'               ! GRAPHS constants
      INCLUDE 'SUBPAR_PAR'            ! SUBPAR constants
          
*  Status:     
      INTEGER STATUS                  ! Global status

*  Local Variables:
      CHARACTER *(80) CURCO           ! Current coordinates of galaxy centre
      CHARACTER *(80) FILEN           ! Image on which the galaxy was found   
      CHARACTER *(80) FILEN2          ! Temporary storage of FILEN  
      CHARACTER *(3) FTYPE            ! The type of record being read
      CHARACTER *(256) RADISP         ! Option choice defining how the
                                      ! radius data is to be displayed
      CHARACTER *(256) WHATD          ! Which parameter from the results
                                      ! file is to be examined
      LOGICAL ANGCON                  ! Position angle convention
      LOGICAL EXCLAIM                 ! Was the cursor an exclaimation?
      LOGICAL RRANGE                  ! Automatic range selection?
      LOGICAL CURSOR                  ! Keyboard or cursor radii selection
      LOGICAL AGAIN                   ! Look at another part of the image?
      LOGICAL GRAPH                   ! Is a graph to be plotted
      LOGICAL OKAY                    ! Was the value of WHATD sensible?
      LOGICAL OPENF                   ! Was the output text file opened okay?
      INTEGER AGIID                   ! AGI identifier
      INTEGER FIOD2                   ! Output file identifer
      INTEGER NUMBP(2)                ! The number of data points used in the
                                      ! scale length regression
      INTEGER FIOID                   ! FIO input file descriptor
      INTEGER FLAG                    ! Can the central pixel value be found?
      INTEGER FSTAT                   ! Has the end of the input file been
                                      ! found
      INTEGER I                       ! Temporary storage
      INTEGER POINTS                  ! The number of valid data points found
      REAL ANGOFF                     ! Position angle offset
      REAL BACK                       ! Background count value
      REAL CONS(2)                    ! Constant terms of the curves used 
                                      ! to find the scale length
      REAL GRAD(2)                    ! Gradients of the curves used
                                      ! to find out the scale length
      REAL HIR                        ! Highest radius value used in the fit
                                      ! calculated
      REAL LOR                        ! Lowest radius value employed in
                                      ! the fit calculated
      REAL LOWLIM                     ! Low radius limit
      REAL PSIZE                      ! Size of the image pixels in arc sec
      REAL REG(2)                     ! Regression coefficient squared 
      REAL SIGMA                      ! Standard deviation of the background value
      REAL SLEN(2)                    ! Scale length of the galaxy
      REAL RESULT(GRA__RESUL,17)      ! Sum of the pixel counts for all pixels
                                      ! at a given distance from the origin
      REAL XCO                        ! X index of the sector origin
      REAL YCO                        ! Y index of the sector origin
      REAL ZEROP                      ! Zero point of the surface 
                                      ! brightness graphs
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   Choose between cursor or keyboard selection of 
*   radii.
      CALL PAR_GET0L('CURSOR',CURSOR,STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999

*   Determine the input ELLPRO, SECTOR or ELLFOU file name.
      CALL FIO_ASSOC('INFILE','READ','LIST',80,FIOID,STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999

*   Look at the command line value for LOWLIM.
*   Otherwise, use the default.
      CALL PAR_STATE('LOWLIM',I,STATUS )
      IF (STATUS.NE.SAI__OK) GOTO 9999
      IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
         CALL PAR_GET0R('LOWLIM',LOWLIM,STATUS)
         CALL MSG_OUT(' ','Command line LOWLIM value used.',STATUS)
      ELSE
         LOWLIM=0.5
      END IF

*   Look at the command line value for ANGCON.
*   Otherwise, use the default.
      CALL PAR_STATE('ANGCON',I,STATUS )
      IF (STATUS.NE.SAI__OK) GOTO 9999
      IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
         CALL PAR_GET0L('ANGCON',ANGCON,STATUS)
         CALL MSG_OUT(' ','Command line ANGCON value used.',STATUS)
      ELSE
         ANGCON=.TRUE.
      END IF
 
*   Look at the command line value for ANGOFF.
*   Otherwise, use the default.
      CALL PAR_STATE('ANGOFF',I,STATUS )
      IF (STATUS.NE.SAI__OK) GOTO 9999
      IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
         CALL PAR_GET0R('ANGOFF',ANGOFF,STATUS)
         CALL MSG_OUT(' ','Command line ANGOFF value used.',STATUS)
      ELSE
         ANGOFF=0.0
      END IF

*   Create a text file containing the latest profile/fit results.
      CALL GRA1_TEXTO(0,FILEN,REG,XCO,YCO,CURCO,SLEN,CONS,ZEROP,
     :                OPENF,FIOD2,EXCLAIM,STATUS)
      FILEN2=' '

*   Look at all the entries in the text file.
      FSTAT=-1
      DO WHILE (FSTAT.LT.1)

*      Obtain the results from the file.
         CALL GRA1_FILER(FSTAT,FIOID,FLAG,POINTS,RESULT,
     :                   BACK,SIGMA,PSIZE,XCO,YCO,CURCO,FILEN,
     :                   FTYPE,ZEROP,STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9999

*      Only allow fitting when more than two data points are present.
         IF ((POINTS.GT.2).AND.(FSTAT.EQ.0)) THEN
          
*         Loop round to redisplay the results as required.
            AGAIN=.TRUE.
            DO WHILE ((AGAIN).AND.(STATUS.EQ.SAI__OK))  

*            Enquire what is to be displayed versus the radius.
               OKAY=.FALSE.
               DO WHILE ((.NOT.OKAY).AND.(STATUS.EQ.SAI__OK))

*               Clear the values for scale length, regression coeff,
*               gradient and slope.
                  DO 27 I=1,2
                     SLEN(I)=0.0
                     CONS(I)=0.0
                     GRAD(I)=0.0
                     REG(I)=0.0
 27               CONTINUE

*               Get the parameters code name.
                  CALL PAR_GET0C('WHATD',WHATD,STATUS)
                  IF (STATUS.NE.SAI__OK) GOTO 9999
                  CALL CHR_UCASE(WHATD)

*               Determine if the input is acceptable.

*               Brightness parameters.
                  IF ((WHATD.EQ.'S').OR.(WHATD.EQ.'B').OR.
     :                (WHATD.EQ.'C')) OKAY=.TRUE.

                  IF ((FTYPE.EQ.'ELF').OR.(FTYPE.EQ.'ELP')) THEN

*                  Other normal parameters.
                     IF ((WHATD.EQ.'E').OR.(WHATD.EQ.'P').OR.
     :                   (WHATD.EQ.'X').OR.(WHATD.EQ.'Y')) OKAY=.TRUE.

*                  Fourier descriptors.
                     IF ((WHATD.EQ.'FS1').OR.(WHATD.EQ.'FC1').OR.
     :                   (WHATD.EQ.'FS2').OR.(WHATD.EQ.'FC2').OR.
     :                   (WHATD.EQ.'FS3').OR.(WHATD.EQ.'FC3').OR.
     :                   (WHATD.EQ.'FS4').OR.(WHATD.EQ.'FC4'))
     :                    OKAY=.TRUE.

                  END IF

*               Cancel the parameter.
                  IF (.NOT.OKAY) THEN
                     CALL PAR_CANCL('WHATD',STATUS)
                     CALL MSG_OUT(' ' ,'That option is not valid.',
     :                                  STATUS)
                  END IF

               END DO

*            Get the radius display type mode and convert to upper case.
               CALL PAR_GET0C('RADISP',RADISP,STATUS)
               IF (STATUS.NE.SAI__OK) GOTO 9999
               CALL CHR_UCASE(RADISP)

*            Ask user for device name.
               AGIID=0
               GRAPH=.TRUE.
               CALL ERR_MARK
               CALL GRA1_AGICO(0,0,0,AGIID,STATUS)
               IF (STATUS.NE.SAI__OK) THEN
                  GRAPH=.FALSE.
                  CALL ERR_ANNUL(STATUS)
               END IF
               CALL ERR_RLSE

*            Display the un-analysed data as a graphical plot of 
*            radius (in some form) versus intensity (in some form).
               IF (GRAPH) THEN              
            
                  CALL GRA1_GRAPH(1,ANGCON,ANGOFF,FTYPE,ZEROP,RADISP,
     :                            WHATD,POINTS,PSIZE,SIGMA,RESULT,
     :                            CONS,GRAD,STATUS)  
                  IF (STATUS.NE.SAI__OK) GOTO 9999

*               Turn off the AGI/PGPLOT interface.
                  CALL GRA1_AGICO(1,0,0,AGIID,STATUS)

               ELSE
                  CALL MSG_OUT(' ','The attempt to use a '/
     :                         /'display failed.',STATUS)
                  GOTO 9999
               END IF

*            Only allow fitting when more than two data points are present.
               IF (POINTS.GT.2) THEN

*                Is the radius range selection to be automatic.
                  CALL PAR_GET0L('RRANGE',RRANGE,STATUS)
                  IF (STATUS.NE.SAI__OK) GOTO 9999
 
                  IF (.NOT.RRANGE) THEN

*                  Find the radius range from which data points are
*                  taken when calculating the scale lengths.
                     CALL GRA1_GRLIMS(POINTS,RESULT,CURSOR,PSIZE,RADISP,
     :                                 LOR,HIR,STATUS)    
                     IF (STATUS.NE.SAI__OK) GOTO 9999
                     
                  END IF
                 
*               Calculate the scale length assuming spiral or elliptical.

*               Obtain the 'fit' parameters for linear fits to the 
*               brightness versus radius data (suitably transformed). 
                  CALL GRA1_LINRE(POINTS,LOWLIM,FTYPE,RRANGE,LOR,
     :                            HIR,RESULT,PSIZE,GRAD,CONS,SLEN,
     :                            NUMBP,REG,STATUS)
                  IF (STATUS.NE.SAI__OK) GOTO 9999

*               Display the fit plots if a graphics device was selected
*               and if brightness is being displayed versus radius.
                  IF ((GRAPH).AND.((WHATD.EQ.'S').OR.
     :                 (WHATD.EQ.'B').OR.(WHATD.EQ.'C'))) THEN

*                  Open up the AGI/PGPLOT interface again.
                     CALL GRA1_AGICO(0,0,1,AGIID,STATUS)

                     CALL GRA1_GRAPH(2,ANGCON,ANGOFF,FTYPE,ZEROP,
     :                               RADISP,WHATD,POINTS,PSIZE,
     :                               SIGMA,RESULT,CONS,
     :                               GRAD,STATUS) 

*                     Turn off the AGI/PGPLOT interface.
                        CALL GRA1_AGICO(1,0,1,AGIID,STATUS)
                        IF (STATUS.NE.SAI__OK) GOTO 9999

                  END IF

*               Display the results on the default display.
                  CALL GRA1_TEXTD(FLAG,POINTS,XCO,YCO,CURCO,BACK,SIGMA,
     :                            CONS,GRAD,PSIZE,NUMBP,ZEROP,SLEN,
     :                            LOR,HIR,REG,STATUS)    

               END IF           
               
*            Interactive display the profile again?
               CALL MSG_BLANK(STATUS)
               CALL PAR_GET0L('AGAIN',AGAIN,STATUS)
               IF (STATUS.NE.SAI__OK) GOTO 9999

*            Create a text file header (if the filename has changed).
               IF (FILEN.NE.FILEN2) THEN 
                  CALL GRA1_TEXTO(1,FILEN,REG,XCO,YCO,CURCO,SLEN,
     :                            CONS,ZEROP,OPENF,FIOD2,
     :                            EXCLAIM,STATUS)
                  FILEN2=FILEN
               END IF

*            Store the latest profile/fit results 
               IF (.NOT.EXCLAIM) THEN
                  CALL GRA1_TEXTO(2,FILEN,REG,XCO,YCO,CURCO,SLEN,
     :                            CONS,ZEROP,OPENF,
     :                            FIOD2,EXCLAIM,STATUS)
               END IF

*            Cancel the parameters so that they must be reinput when
*            looping round.
               CALL GRA1_CANCL(0,STATUS)

            END DO

         ELSE

*            Too few isophotes in the input text file.
               IF (FSTAT.EQ.0) THEN
                   CALL MSG_BLANK(STATUS)
                   CALL MSG_OUT(' ','Too few isophotes to'//
     :                        ' calculate scale length.',STATUS)
                   CALL MSG_BLANK(STATUS)
               END IF
               
         END IF

      END DO

*   Close the results file.
      IF (.NOT.EXCLAIM) THEN
         CALL GRA1_TEXTO(3,FILEN,REG,XCO,YCO,CURCO,SLEN,CONS,ZEROP,
     :                   OPENF,FIOD2,EXCLAIM,STATUS)
      END IF
                   
 9999 CONTINUE

      END 
