      SUBROUTINE GRAPHS(STATUS)
*+
*  Name:
*     GRAPHS

*  Purpose:
*     Displays/analyses the results generated using SECTOR, 
*     ELLFOU or ELLPRO.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL GRAPHS( STATUS )

*  Arguments:   
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Description: 
*
*     Displays galaxy profiles and performs scale length analysis.
*     The data used comes from an ASCII text input file generated by 
*     ESP application ELLPRO, ELLFOU or SECTOR.
*
*     The application can be operated in two modes; interactive and file.
*
*     INTERACTIVE - The user can select whether the radius
*                   range used to calculate the scale length values
*                   are input via a keyboard (CURSOR=FALSE) or via the
*                   mouse/ball (CURSOR=TRUE). 
* 
*     FILE -        The user inputs the name of the text 
*                   file output by ELLPRO, ELLFOU or SECTOR and the 
*                   radius range over which isophotes will be employed 
*                   to calculate the galaxy scale length.
*
*     In the file mode, graphs are not displayed. Once the input 
*     filename has been entered, no further user interaction is 
*     required. The input file should contain the contents of a 
*     single file output from ELLFOU, ELLPRO, SECTOR, or, 
*     alternatively, several such files concatenated together.
*     In both modes, the name of the text file created by GRAPHS to 
*     store results in, is supplied by the user.
*
*     The X and Y co-ordinates output by SECTOR, ELLFOU and ELLPRO,
*     and hence those plotted by GRAPHS, are in the Base frame
*     coordinate system (units pixels) of the processed NDF images.
             
*  Usage:
*     GRAPHS MODE INFILE OUT RRANGE [AGAIN] [CURSOR] [DEVICE]
*            [FITLIM] [RADISP] [WHATD] (LOWLIM) (ANGCON) (ANGOFF)
 
*  ADAM Parameters:
*     AGAIN = _LOGICAL(Read)
*        Should the profile be displayed/analysed again?
*     ANGCON = _LOGICAL (Read)
*        Position angle rotation convention. TRUE=clockwise positive.
*     ANGOFF = _REAL (Read)
*        Position angle offset. Units degrees.
*     CURSOR = _LOGICAL (Read)
*        Whether the radius value range is to be identified using the 
*        graphics cursor or the keyboard. Only values within the user 
*        defined range will be used to determine the scale length.
*     DEVICE = _LOGICAL (Read) 
*        Name of the graphics device on which to display the
*        results graph.
*     FITLIM = _REAL (Read)
*        The range of radius values over which the scale length 'fits' 
*        are to be calculated.
*     INFILE = _CHAR (Read)
*        Name of the text file containing the galaxy profile.
*     LOWLIM = _REAL (Read)
*        The radius below which a profile will not be included 
*        in the automatic radius calculation.
*     MODE = LOGICAL (Read)
*        Is the application to be used interactively or in file mode?
*        TRUE = interactive. FALSE = file mode.
*     OUT = _CHAR (Read)
*        File name for the output text file containing the 
*        scale length data.
*     RADISP = _CHAR (Read)
*        The display mode used for the radius axis of the graphs.
*        - Q = quarter power
*        - L = logarithmic 
*        - S = square root 
*        - R = linear 
*        The radius values displayed are the equivalent radius
*        (R*) when using ELLPRO/ELLFOU input files and distance 
*        from the galaxy origin when using SECTOR derived files. 
*     RRANGE =_CHAR (Read)
*        Should the radius range be selected automatically? 
*     WHATD = _CHAR (Read)
*        What will be displayed against radius on the graphs.
*        -   B   = Brightness of the profile in terms of sky i.e. (I-Back)/Sigma
*        -   C   = Count value of the profile 
*        -   E   = Ellipticity of the profile
*        -   FC1 = First cosine Fourier descriptor
*        -   FC2 = First sine Fourier descriptor
*        -   FC3 = Second cosine Fourier descriptor
*        -   FC4 = Second sine Fourier descriptor
*        -   FS1 = Third cosine Fourier descriptor
*        -   FS2 = Third sine Fourier descriptor
*        -   FS3 = Fourth cosine Fourier descriptor
*        -   FS4 = Fourth sine Fourier descriptor
*        -   P   = Position angle of the profile
*        -   S   = Surface brightness of the profile
*        -   X   = X co-ordinate (Base frame)
*        -   Y   = Y co-ordinate (Base frame)
 
*  Examples:
*     graphs mode=true infile=results.dat out=scales.dat rrange=true 
*            cursor=true whatd=s radisp=r device=xwindows 
*
*         The file RESULTS.DAT is examined and its contents displayed
*         graphically as required. The first display will be of linear
*         radius versus surface brightness and will be shown on
*         device XWINDOWS. The radius range for the isophotes to be 
*         employed in the scale length calculation are selected 
*         interactively via the mouse/ball.     
*
*     graphs mode=true infile=profs.dat out=lengths.dat rrange=false
*            fitlim=1,20 cursor=false whatd=p radisp=l 
*            device=x2windows 
*
*         The results stored in file PROFS.DAT are read one after the.
*         other The profiles and 'fits' may be observed interactively as
*         graphs on device X2WINDOWS. The first display will be of 
*         log(radius) versus position angle. The radius range used
*         when calculating the scale length is 1 to 20 arc seconds.
*         results are output to file LENGTHS.DAT.
*
*     graphs mode=false infile=elf1.dat out=lengths.dat rrange=true
*
*        The profile data required is read in from file ELF1.DAT.
*        Data from isophotes chosen by the application
*        are selected for use in the scale length analysis. 
*        The results are output to file LENGTHS.DAT.
*
*     graphs mode=false infile=profs.dat out=scales.dat rrange=false
*            fitlim=0.5,7 
*     
*        Profile data read in from file PROFS.DAT is analysed to
*        determine the scale length using isophotes with a radius in 
*        the range 0.5 to 7 arc seconds. The results are output into
*        text file SCALES.DAT.

*  Notes:
*     Parameters surrounded by curved brackets may only be adjusted 
*     via the command line.
* 
*     Within ESP the scale lengths are calculated by assuming an
*     exponential brightness profile for spiral galaxies and an
*     exponential modified by a quarter power law for elliptical 
*     galaxies. The scale length
*     value given is derived from the decay constant of the 
*     exponential functions.

*  Authors:
*     GJP: Grant Privett (STARLINK)
*     MBT: Mark Taylor (STARLINK)
*     {enter_new_authors_here}

*  History:
*     04-DEC-1993 (GJP)
*     (Original version)
*     10-JAN-1997 (GJP)
*     Modified output file format to cope with big images.
*     10-NOV-1999 (MBT)
*     Modified for World Coordinate System awareness.
*      

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE

*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
         
*  Status:     
      INTEGER STATUS                  ! Global status

*  Local Variables:      
      LOGICAL MODE                    ! Interactive or file mode?
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   Show that the application is running.
      CALL MSG_BLANK(STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999
      CALL MSG_OUT(' ','ESP GRAPHS running.',STATUS)

*   Select interactive input or file input.
      CALL PAR_GET0L('MODE',MODE,STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999

*   Pass control to the appropriate subroutines.
      IF (MODE) THEN

*   Pass control to KCMODE.
         CALL GRA1_KCMODE(STATUS)

      ELSE

*   ASCII file input.
         CALL GRA1_FMODE(STATUS)

      END IF

*   Abort the program.
 9999 CONTINUE

      END 
      

      SUBROUTINE GRA1_FILER(FSTAT,FIOID,RFAIL,POINTS,RESULT,
     :                      BACK,SIGMA,PSIZE,XCO,YCO,CURCO,
     :                      FILEN,FTYPE,ZEROP,STATUS)    
*+
*  Name:
*     GRA1_FILER

*  Purpose:
*     Opens a user specified text file and reads from it the results output
*     from ESP application SECTOR, ELLPRO or ELLFOU.
*

*  Language:
*     Starlink Fortran 77

*  Invocation:
*      CALL GRA1_FILER(FSTAT,FIOID,RFAIL,POINTS,RESULT,
*     :                BACK,SIGMA,PSIZE,XCO,YCO,CURCO,
*     :                FILEN,FTYPE,ZEROP,STATUS)    
                      
*  Description:
*     Looks at each line of the required file in turn.
*     Ignores blank lines and those starting with ! since these
*     are assumed to be comments. Lines beginning ## describe
*     what data is contained on the next line and may be thought
*     of as subheadings. The following line in each case is examined 
*     for numbers or text depending on the nature of the subheading.

*  Arguments:               
*     FSTAT = INTEGER (Given)
*        Used to indicate whether an error was reported while reading
*        the file.
*     FIOID = INTEGER (Given)
*        FIO identifier for the input file.
*     RFAIL = INTEGER (Returned)
*        Reflects the file status following the last read.
*        RFAIL=SAI__OK means the file end has not been reached and
*        the last file entry was complete, RFAIL=FIO__EOF means an
*        end of file message has been found.
*     POINTS = INTEGER (Returned)
*        The number of isophotes for which data should be found in the file.
*     RESULT(GRA__RESUL,17) = REAL (Returned)
*        An array containing the profiling results output by the SECTOR, 
*        ELLFOU or ELLPRO file being used as input.
*     BACK = REAL (Returned)
*        The background sky count for the image used to generate
*        the current profile. Units counts.
*     SIGMA = REAL (Returned)
*        Standard deviation value of background count value. Units counts.
*     PSIZE = REAL (Returned)
*        Pixel size for the image used to create the current profile.
*        Units arc seconds.
*     XCO = REAL (Returned)
*        X co-ordinate of the galaxy on the source image (Base frame).
*     YCO = REAL (Returned)
*        Y co-ordinate of the galaxy on the source image (Base frame).
*     CURCO *(80) = CHARACTER (Returned)
*        Coordinates of the galaxy on the source image (Current frame).
*     FILEN *(80) = CHARACTER (Returned)
*        Name of the image from which the data was obtained.
*     FTYPE *(3) = CHARACTER (Returned)
*        The record type found in the results file. ELF=ELLFOU,
*        SEC=SECTOR and ELP=ELLPRO.
*     ZEROP = REAL (Returned)
*        The zero point of the magnitude scale on the source image.
*        Units magnitude per square arc second.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     9-JUL-1993 (GJP)
*     (Original version)

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'FIO_ERR'               ! FIO error definitions
      INCLUDE 'gra_par'               ! GRAPHS constants

*  Arguments Given:                              
      INTEGER FIOID                   ! FIO identifier for the input file

*  Arguments Returned:
      CHARACTER *(80) CURCO           ! Current coordinates of galaxy centre
      CHARACTER *(80) FILEN           ! Image on which galaxy was found
      CHARACTER *(3) FTYPE            ! File header type
      INTEGER FSTAT                   ! Indicates if an error was found
                                      ! while reading the file
      INTEGER POINTS                  ! Number of profiles found
      REAL RESULT(GRA__RESUL,17)      ! Profile results generated by ELLFOU
                                      ! ELLPRO or SECTOR and now read from a
                                      ! file
      REAL BACK                       ! Background count value
      REAL SIGMA                      ! Background count standard deviation
      REAL PSIZE                      ! Pixel size
      REAL XCO                        ! Galaxy x co-ordinates
      REAL YCO                        ! Galaxy y co-ordinates
      REAL ZEROP                      ! Magnitude zero point

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variables:
      INTEGER LTYPE                   ! What sort of information did the 
                                      ! most recent line contain?
      INTEGER FAIL                    ! Used to show if the data was in the
                                      ! format/layout expected
      INTEGER FOUND                   ! Flag used to show if an ELLPRO,
                                      ! ELLFOU or SECTOR record has 
                                      ! been found in the input text file
      INTEGER RFAIL                   ! Used to indicate if the end of the 
                                      ! the file has been found    
      CHARACTER *(80) BUFFER          ! Character string input from the file
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   Read from a file. Stop if the end of file is reached or if the file is
*   corrupted or if the file header has been found.
      FSTAT=0
      RFAIL=0
      FOUND=0
      FAIL=0
      DO WHILE ((RFAIL.EQ.0).AND.(FOUND.EQ.0))

*       Read a line from the steering file.
         CALL GRA1_GETLINE(FIOID,BUFFER,RFAIL,STATUS)
         
*       Proceed since input was succesful.
         IF ((RFAIL.EQ.SAI__OK).AND.(STATUS.EQ.SAI__OK)) THEN

*          Determine whether the line is a file header.
            CALL GRA1_LTYPE(BUFFER,LTYPE,STATUS)

*          Handle header lines.
            IF ((LTYPE.GT.0).AND.(LTYPE.NE.3).AND.
     :                  (STATUS.EQ.SAI__OK)) THEN

*             Handle each type of possible file format.
               IF (LTYPE.EQ.1) THEN

*               SECTOR files.
                  IF (BUFFER.EQ.'SECTOR') THEN
                      CALL MSG_BLANK(STATUS)
                      CALL MSG_OUT(' ','SECTOR Header found.',STATUS)
                      CALL GRA1_SECT(FIOID,FAIL,POINTS,RESULT,
     :                               FILEN,BACK,SIGMA,PSIZE,
     :                               XCO,YCO,CURCO,ZEROP,STATUS)
                      FOUND=1
                      FTYPE='SEC'
                  END IF

*               ELLPRO files.
                  IF (BUFFER.EQ.'ELLPRO') THEN 
                      CALL MSG_BLANK(STATUS)
                      CALL MSG_OUT(' ','ELLPRO Header found.',STATUS)
                      CALL GRA1_ELLS(FIOID,FAIL,POINTS,RESULT,
     :                               FILEN,BACK,SIGMA,PSIZE,
     :                               XCO,YCO,CURCO,ZEROP,STATUS)
                      FOUND=1
                      FTYPE='ELP'
                  END IF

*               ELLFOU files.
                  IF (BUFFER.EQ.'ELLFOU') THEN
                      CALL MSG_BLANK(STATUS)
                      CALL MSG_OUT(' ','ELLFOU Header found.',STATUS)
                      CALL GRA1_ELLS(FIOID,FAIL,POINTS,RESULT,
     :                         FILEN,BACK,SIGMA,PSIZE,
     :                         XCO,YCO,CURCO,ZEROP,STATUS)
                      FOUND=1
                      FTYPE='ELF'
                  END IF

*               Check the status after the file was read.
                  IF (FAIL.NE.0) THEN
                     FSTAT=1
                  ELSE
                     FSTAT=0
                  END IF

               END IF

            END IF

         END IF

      END DO
     
*   Indicate that the file was flawed or its end has been reached.
      IF (RFAIL.NE.SAI__OK) FSTAT=1
      IF (((RFAIL.NE.SAI__OK).AND.(RFAIL.NE.FIO__EOF)).OR.
     :   (STATUS.NE.SAI__OK)) THEN

         CALL MSG_BLANK(STATUS)
         CALL MSG_OUT(' ','Problems found reading the file.',
     :                STATUS)
         CALL MSG_BLANK(STATUS)

      END IF

*   Sort the data.
      IF (RFAIL.EQ.SAI__OK) CALL GRA1_SORT(POINTS,RESULT,STATUS)

 9999 CONTINUE

      END 

      
      SUBROUTINE GRA1_LTYPE(BUFFER,LTYPE,STATUS) 
*+
*  Name:
*     GRA1_LTYPE

*  Purpose:
*     Determines what sort of text line has been found by the most 
*     recent attempt to read from the input text file.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*      CALL GRA1_LTYPE(BUFFER,LTYPE,STATUS)  

*  Description:
*     The contents of character string BUFFER are examined for
*     their meanings in the context of an ESP output file format.
*     
*     The program checks for the limits of the file by searching for
*     '## ESP' at the start and '## END' at the end, subheadings by seeking
*     any other lines starting with '##' and comments beginning with '!'. 
*
*     A code is returned showing what was found:
*
*     LTYPE=0 - For comments or very short lines.
*           1 - For the first line in a ELLFOU, ELLPRO or SECTOR file.
*           2 - For subheadings in the input file
*           3 - For the last line in ELLFOU, ELLPRO or SECTOR file.
*           4 - Everything else. Is generally assumed to contain numbers.

*  Arguments:               
*     BUFFER *(256) = CHARACTER (Given)
*        The character string read from the input.
*     LTYPE = INTEGER (Given)
*        The type of information within BUFFER. 
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     12-DEC-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants

*  Arguments Given:         
      CHARACTER *(80) BUFFER          ! Character string input from the file
                                      ! and to be examined
*  Arguments Returned:
      INTEGER LTYPE                   ! Type of line

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variables:
      CHARACTER *(80) STRING          ! Temporary string
      INTEGER I                       ! Temporary pointer
      INTEGER J                       ! Temporary pointer
      INTEGER LEN                     ! Length of BUFFER

*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN

*   Set default value.
      LTYPE=0

*   Get the length of the BUFFER.
      CALL CHR_FANDL(BUFFER,I,J)
      LEN=J-I+1

*   Check for comments or blank lines.
      IF ((BUFFER(1:1).EQ.'!').OR.(LEN.EQ.0)) GOTO 9999

*   Check for header line identifying which ESP application stored the data.
      STRING=BUFFER(1:6)
      CALL CHR_UCASE(STRING)
      IF (STRING.EQ.'## ESP') THEN 
         STRING=BUFFER(8:13)
         IF ((STRING.EQ.'SECTOR').OR.(STRING.EQ.'ELLFOU')
     :         .OR.(STRING.EQ.'ELLPRO')) THEN
            LTYPE=1 
            BUFFER=STRING
            GOTO 9999
         END IF
      END IF

*   Check for sub-heading line identifying what is stored on the next line.
*   Set LTYPE to distinguish between file terminators and normal sub-headings.
      STRING=BUFFER(1:3)
      IF ((STRING.EQ.'## ').AND.(LEN.GT.4)) THEN 

*      Remove the '## ' at the start, convert to upper case,
*      then locate first and last non-blank characters.
         STRING=BUFFER(4:J)       
         CALL CHR_UCASE(STRING)
         CALL CHR_FANDL(STRING,I,J)

*      Construct a string from the characters within those limits and
*      find the first word from that string. retain only its first 3
*      characters.
         BUFFER=STRING(I:J)
         CALL CHR_FIWE(BUFFER,I,STATUS)
         STRING=BUFFER(1:3)

         IF (STRING.EQ.'END') THEN
            LTYPE=3
            BUFFER='END'
         ELSE
            LTYPE=2
            BUFFER=STRING
         END IF
         GOTO 9999

      END IF

*   Whatever is left over should be a string or numbers.
      LTYPE=4

 9999 CONTINUE

      END 


      SUBROUTINE GRA1_RANGE(POINTS,PSIZE,RESULT,LOR,HIR,NUMB,STATUS)
*+
*  Name:
*     GRA1_RANGE

*  Purpose:
*     Determines the number of isophotes that are within the radius range 
*     specified by LOR and HIR.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*      CALL GRA1_RANGE(POINTS,PSIZE,RESULT,LOR,HIR,NUMB,STATUS)  

*  Description:
*      The results array is examined to check how many of the radii
*      values are within the radius range specified by the user (LOR, HIR).
*      NUMB is used to return that number.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     12-DEC-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'gra_par'               ! GRAPHS constants

*  Arguments Given:         
      INTEGER POINTS                  ! The number of isophotes
      REAL LOR                        ! Low limit for radius
      REAL HIR                        ! Upper limit for radius
      REAL PSIZE                      ! Pixel size
      REAL RESULT(GRA__RESUL,17)      ! Results array read from file

*  Arguments Returned:
      INTEGER NUMB                    ! Number of isophotes in the 
                                      ! required radius range

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variables:
      INTEGER I                       ! Loop variables
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   Initialise the useful data point counter.
      NUMB=0
      
*   Look through all the result isophotal radii values.
      DO 100 I=1,POINTS
       
*      Is it within the range required?
*      Increment the counter if true.
         IF ((PSIZE*RESULT(I,4).GE.LOR).AND.
     :             (PSIZE*RESULT(I,4).LE.HIR)) NUMB=NUMB+1

 100  CONTINUE
     
*   Display a message if too few points are present.
      IF (NUMB.LT.3) THEN
         CALL MSG_BLANK(STATUS)
         CALL MSG_OUT(' ','The radius range supplied,'//
     :                ' is too narrow to be used.',STATUS)
         CALL MSG_BLANK(STATUS)
      END IF

 9999 CONTINUE

      END 


      SUBROUTINE GRA1_SORT(POINTS,RESULT,STATUS)
*+
*  Name:
*     GRA1_SORT

*  Purpose:
*     Sort the results found into order of ascending radius.
*     Also, remove all elements that had counts below zero.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL GRA1_SORT(POINTS,RESULT,STATUS)  

*  Description:
*     The results array is searched for the isophote with the lowest radius
*     value. The results for that isophote are transfered to the next
*     vacant element of the temporary storage array. The results array
*     is then searched again and the next smallest radius treated similarly.
*
*     When all the values have been extracted from the results array,
*     the values storeed in the temporary array are transferred back to
*     the results array.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     15-DEC-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'gra_par'               ! GRAPHS constants

*  Arguments Given:         
      INTEGER POINTS                  ! Total number of isophotes

*  Arguments Given and Returned:
      REAL RESULT(GRA__RESUL,17)      ! Results array read from file

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variables:
      INTEGER DUFF                    ! Bad element counter
      INTEGER I                       ! Loop variable
      INTEGER J                       ! Temporary storage 
      INTEGER K                       ! Temporary storage
      INTEGER L                       ! Loop variable
      REAL LOWEST                     ! Lowest radius value found
      REAL NEGAT                      ! A small negative number
      REAL ARRAY(GRA__RESUL,17)       ! Temporary Results
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   Look through the results array to see how many count values
*   Create variable of very small negative value.
      NEGAT=-GRA__VSMAL

*   are at or below zero. Also, tag them so they may be ignored later.
      DUFF=0
      DO 100 I=1,POINTS
         IF (RESULT(I,5).LT.GRA__VSMAL) THEN
            DUFF=DUFF+1
            RESULT(I,4)=NEGAT
         END IF
 100  CONTINUE         

*   Tell the user that duff values were found.
      IF (DUFF.GT.0) THEN 

         CALL MSG_BLANK(STATUS)
         CALL MSG_OUT(' ','Some count values were found to be '/
     :                /'below zero. These will be deleted.',STATUS)
      END IF

*   General message to the user. Only if there are lots of profiles.
      IF(POINTS.GT.100) THEN
         CALL MSG_BLANK(STATUS)
         CALL MSG_OUT(' ','Sorting the results.',STATUS)
         CALL MSG_BLANK(STATUS)
      END IF

*   Find the lowest value in the radius column of the results array.
*   Transfer the value found into the new results array.
      DO 20 K=1,POINTS

         LOWEST=1E20
         DO 10 I=1,POINTS

*         Is the latest radius lower?
            IF ((RESULT(I,4).LT.LOWEST)
     :                  .AND.(RESULT(I,4).GT.NEGAT)) THEN

*            Update the lowest value.
               J=I
               LOWEST=RESULT(I,4)

            END IF

 10      CONTINUE

*      Place the results for the required isophote into
*      the new new results array.
         DO 30 L=1,17
            ARRAY(K,L)=RESULT(J,L)
 30      CONTINUE
         
*      Place a value in the original array that will make sure its ignored 
*      next time round.
         RESULT(J,4)=NEGAT

 20   CONTINUE

*   Correct the number of pixels to allow for the negative counts.
      POINTS=POINTS-DUFF

*   Transfer all the values in the temporary array back into the 
*   results array.
      DO 40 I=1,POINTS
         DO 50 L=1,17
            RESULT(I,L)=ARRAY(I,L)
 50      CONTINUE
 40   CONTINUE

 9999 CONTINUE

      END


      SUBROUTINE GRA1_SECT(FIOID,RFAIL,POINTS,RESULT,
     :               FILEN,BACK,SIGMA,PSIZE,XCO,YCO,CURCO,ZEROP,STATUS)
*+
*  Name:
*     GRA1_SECT

*  Purpose:
*     Read in the data found in a text file created by SECTOR.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL GRA1_SECT(FIOID,RFAIL,POINTS,RESULT,
*                    FILEN,BACK,SIGMA,PSIZE,XCO,YCO,CURCO,ZEROP,STATUS) 

*  Description:
*     Reads in the lines of a text file until either '## END' or
*     an end of file message is encountered. The lines found are
*     examined to determine which mubers correspond to which 
*     values such as pixel size in the original image. This is acheived 
*     using subheadings (line starting ##) which tell the routine
*     which number(s) is on the next line.
*
*     A simple check is made on value (where) possible to ensure that
*     it is not absurd (i.e. negative background count value).

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     12-DEC-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'gra_par'               ! GRAPHS constants
      INCLUDE 'FIO_ERR'               ! FIO error definitions
      INCLUDE 'SAE_PAR'               ! Standard SAE constants

*  Arguments Given:         
      INTEGER FIOID                   ! FIO identifier for the input file
      INTEGER RFAIL                   ! Has the end of the file been found?

*  Arguments Returned:
      CHARACTER *(80) CURCO           ! Current coordinates fo galaxy
      CHARACTER *(80) FILEN           ! Name of the image on which the profiled
                                      ! galaxy is to be found
      INTEGER POINTS                  ! Total number of isophotes
      REAL PSIZE                      ! Pixel size
      REAL SIGMA                      ! Standard deviationof background count
      REAL BACK                       ! Sky background count
      REAL XCO                        ! X co-ordinate of galaxy
      REAL YCO                        ! Y co-ordinate of galaxy
      REAL RESULT(GRA__RESUL,17)      ! Results array read from file
      REAL ZEROP                      ! Magnitude scale zero point

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variables:
      CHARACTER *(80) BUFFER          ! Contents of a line read from the text
                                      ! input file
      CHARACTER *(80) STRING          ! Temporary storage
      INTEGER FAIL                    ! Has there been a problem with the
                                      ! values read from the file
      INTEGER FOUND(10)               ! Flags used to show if any of the
                                      ! numbers in the file were corrupt
      INTEGER I                       ! Loop variable
      INTEGER LTYPE                   ! Type of line found
      INTEGER N                       ! Counter
      INTEGER NUMW                    ! Number of words found in a string
      REAL TEMP(20)                   ! Numbers read from the current line

*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   Set default values.
      POINTS=0
      FAIL=0
      FILEN=' '
      XCO=-1
      DO 10 I=1,8
         FOUND(I)=0
 10   CONTINUE

*   Read from a file. Stop if the end of file is reached or if the file is
*   corrupted or if the file header has been found.
      LTYPE=0
      BUFFER=' '
      DO WHILE ((RFAIL.EQ.SAI__OK).AND.(LTYPE.NE.3).AND.(FAIL.EQ.0))

*       Read a line from the steering file.
         CALL GRA1_GETLINE(FIOID,BUFFER,RFAIL,STATUS)

*       Proceed since successfully read file.
         IF (RFAIL.EQ.SAI__OK) THEN

*         Determine the line type.
            CALL GRA1_LTYPE(BUFFER,LTYPE,STATUS)

*         Handle each type of possible format.
            IF ((LTYPE.EQ.2).AND.(STATUS.EQ.SAI__OK)) THEN
        
*            Filename.   
               STRING=BUFFER
               IF ((STRING.EQ.'FIL').AND.(FAIL.EQ.0)) THEN
                  CALL GRA1_RCHAR(FIOID,RFAIL,BUFFER,STATUS)
                  CALL CHR_RMBLK(BUFFER)
                  FILEN=BUFFER
                  IF (FILEN.EQ.' ') THEN
                     FAIL=1
                     FOUND(1)=1
                  ELSE
                     CALL MSG_OUT(' ','Source image was:'/
     :                            /FILEN,STATUS)
                  END IF
               END IF

*            Background.
               IF ((STRING.EQ.'BAC').AND.(FAIL.EQ.0)) THEN 
                  CALL GRA1_RNUMBS(FIOID,RFAIL,TEMP,NUMW,STATUS)
                  BACK=TEMP(1)
               END IF

*            Sigma.
               IF ((STRING.EQ.'SIG').AND.(FAIL.EQ.0)) THEN 
                  CALL GRA1_RNUMBS(FIOID,RFAIL,TEMP,NUMW,STATUS)
                  SIGMA=TEMP(1)
                  IF (SIGMA.LT.GRA__VSMAL) THEN 
                     FAIL=3
                     FOUND(3)=1
                  END IF
               END IF
    
*            Pixel size.
               IF ((STRING.EQ.'PIX').AND.(FAIL.EQ.0)) THEN 
                  CALL GRA1_RNUMBS(FIOID,RFAIL,TEMP,NUMW,STATUS)
                  PSIZE=TEMP(1)
                  IF (PSIZE.LT.GRA__VSMAL) THEN 
                     FAIL=4
                     FOUND(4)=1
                  END IF
               END IF

*            Initial galaxy centre co-ordinates.
               IF ((STRING.EQ.'X/Y').AND.(FAIL.EQ.0)) THEN 
                  IF (XCO.LT.0.0) THEN 
                     CALL GRA1_RNUMBS(FIOID,RFAIL,TEMP,NUMW,STATUS)
                     XCO=TEMP(1)
                     YCO=TEMP(2)
                  ELSE
                     CALL GRA1_RCHAR(FIOID,RFAIL,BUFFER,STATUS)
                     CURCO=BUFFER
                  END IF
              END IF

*            Number of profiles.
               IF ((STRING.EQ.'NUM').AND.(FAIL.EQ.0)) THEN 
                  CALL GRA1_RNUMBS(FIOID,RFAIL,TEMP,NUMW,STATUS)
                  POINTS=TEMP(1)
                  IF (POINTS.LT.GRA__VSMAL) THEN
                     FAIL=6
                     FOUND(6)=1
                  END IF
               END IF

*            Magnitude scale zero point.
               IF ((STRING.EQ.'ZER').AND.(FAIL.EQ.0)) THEN 
                  CALL GRA1_RNUMBS(FIOID,RFAIL,TEMP,NUMW,STATUS)
                  ZEROP=TEMP(1)
                  IF (ZEROP.LT.GRA__VSMAL) THEN
                     FAIL=8
                     FOUND(8)=1
                  END IF
               END IF

*            Profile results.
               IF ((POINTS.GT.0).AND.(STRING.EQ.'PRO')
     :               .AND.(FAIL.EQ.0)) THEN
                  FAIL=0
                  N=0
                  DO WHILE ((FAIL.EQ.0).AND.(N.NE.POINTS))
                     CALL GRA1_RNUMBS(FIOID,RFAIL,TEMP,NUMW,STATUS)
                     IF ((RFAIL.EQ.0).AND.(NUMW.EQ.4)) THEN
                        N=N+1
                        RESULT(N,4)=TEMP(1)
                        RESULT(N,5)=TEMP(2)
                     ELSE
                        FAIL=7
                        FOUND(7)=1
                     END IF
                  END DO
               END IF

            END IF 

         END IF

      END DO


*   Check that all the required entries were found.
      FAIL=0
      DO 300 I=8,1,-1
         IF (FOUND(I).EQ.1) FAIL=I
 300  CONTINUE

*   Check the defaults. Set a flag if one of them has not been 
*   assigned a value from the file.
      IF (RFAIL.EQ.FIO__EOF) THEN 
         CALL MSG_OUT(' ','End-of-file found.',STATUS)        
         CALL MSG_BLANK(STATUS)
         RFAIL=-1
      END IF
      IF (LTYPE.EQ.3) THEN 
         CALL MSG_OUT(' ','End of filename report.',STATUS)
         CALL MSG_BLANK(STATUS)
         RFAIL=0
      END IF
      IF (FAIL.NE.0) THEN 
         CALL GRA1_EMSG(FAIL,STATUS)
         CALL MSG_BLANK(STATUS)
         RFAIL=1
      END IF

 9999 CONTINUE

      END 


      SUBROUTINE GRA1_ELLS(FIOID,RFAIL,POINTS,RESULT,
     :               FILEN,BACK,SIGMA,PSIZE,XCO,YCO,CURCO,ZEROP,STATUS)
*+
*  Name:
*     GRA1_ELLS
*
*  Purpose:
*     Read in the data found in a text file created by ELLPRO or ELLFOU.
*
*  Language:
*     Starlink Fortran 77
*
*  Invocation:
*     CALL GRA1_ELLS(FIOID,RFAIL,POINTS,RESULT,
*                    FILEN,BACK,SIGMA,PSIZE,XCO,YCO,CURCO,ZEROP,STATUS) 
*
*  Description:
*     Reads in the lines of a text file until either '## END' or
*     an end of file message is encountered. The lines found are
*     examined to determine which mubers correspond to which 
*     values such as pixel size in the original image. This is acheived 
*     using subheadings (line starting ##) which tell the routine
*     which number(s) is on the next line.
*
*     A simple check is made on value (where) possible to ensure that
*     it is not absurd (i.e. negative background count value).
*
*  Authors:
*     GJP: Grant Privett (STARLINK)
*     NG: Norman Gray (Starlink, Glasgow)
*
*  History:
*     12-DEC-1993 (GJP)
*       (Original version)
*     11-Nov-1999 (NG)
*       Modified so that the reading of ellipse parameters will allow
*       (but ignore) columns beyond column 9.  See below for explanation.
*  
*
*  Bugs:
*     None known.
*
*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'gra_par'               ! GRAPHS constants
      INCLUDE 'FIO_ERR'               ! FIO error definitions
      INCLUDE 'SAE_PAR'               ! Standard SAE constants

*  Arguments Given:         
      INTEGER FIOID                   ! FIO identifier for the input file
      INTEGER RFAIL                   ! Has the end of the file been found?

*  Arguments Returned:
      CHARACTER *(80) CURCO           ! Current coordinates of the galaxy
      CHARACTER *(80) FILEN           ! Name of the image on which the profiled
                                      ! galaxy is to be found
      INTEGER POINTS                  ! Total number of isophotes
      REAL PSIZE                      ! Pixel size
      REAL SIGMA                      ! Standard deviation of the background count
      REAL BACK                       ! Sky background count
      REAL XCO                        ! X co-ordinate of galaxy
      REAL YCO                        ! Y co-ordinate of galaxy
      REAL RESULT(GRA__RESUL,17)      ! Results array read from file
      REAL ZEROP                      ! Magnitude scale zero point

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variables:
      CHARACTER *(80) BUFFER          ! Contents of a line read from the text
                                      ! input file
      CHARACTER *(80) STRING          ! Temporary storage
      INTEGER FAIL                    ! Has there been a problem with the
                                      ! values read from the file
      INTEGER FOUND(10)               ! Flags used to show if any of the
                                      ! numbers in the file were corrupt
      INTEGER I                       ! Loop variable
      INTEGER LTYPE                   ! Type of line found
      INTEGER N                       ! Counter
      INTEGER NUMW                    ! Number of words found in a string
      REAL TEMP(20)                   ! Numbers read from the current line
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   Set default values.
      POINTS=0
      FAIL=0
      FILEN=' '
      XCO=-1
      DO 10 I=1,9
         FOUND(I)=0
 10   CONTINUE

*   Read from a file. Stop if the end of file is reached or if the file is
*   corrupted or if the file header has been found.
      LTYPE=0
      BUFFER=' '
      DO WHILE ((RFAIL.EQ.SAI__OK).AND.(LTYPE.NE.3).AND.(FAIL.EQ.0))

*       Read a line from the steering file.
         CALL GRA1_GETLINE(FIOID,BUFFER,RFAIL,STATUS)
       
*       Proceed since successfully read file.
         IF (RFAIL.EQ.SAI__OK) THEN

*         Determine the line type.
            CALL GRA1_LTYPE(BUFFER,LTYPE,STATUS)

*         Handle each type of possible format.
            IF ((LTYPE.EQ.2).AND.(STATUS.EQ.SAI__OK)) THEN
        
*            Filename.   
               STRING=BUFFER
               IF ((STRING.EQ.'FIL').AND.(FAIL.EQ.0)) THEN
                  CALL GRA1_RCHAR(FIOID,RFAIL,BUFFER,STATUS)
                  CALL CHR_RMBLK(BUFFER)
                  FILEN=BUFFER
                  IF (FILEN.EQ.' ') THEN
                     FAIL=1
                     FOUND(1)=1
                  ELSE
                     CALL MSG_OUT(' ','Source image was:'/
     :                            /FILEN,STATUS)
                  END IF
               END IF

*            Background.
               IF ((STRING.EQ.'BAC').AND.(FAIL.EQ.0)) THEN 
                  CALL GRA1_RNUMBS(FIOID,RFAIL,TEMP,NUMW,STATUS)
                  BACK=TEMP(1)
               END IF

*            Sigma.
               IF ((STRING.EQ.'SIG').AND.(FAIL.EQ.0)) THEN 
                  CALL GRA1_RNUMBS(FIOID,RFAIL,TEMP,NUMW,STATUS)
                  SIGMA=TEMP(1)
                  IF (SIGMA.LT.GRA__VSMAL) THEN 
                     FAIL=3
                     FOUND(3)=1
                  END IF
               END IF
    
*            Pixel size.
               IF ((STRING.EQ.'PIX').AND.(FAIL.EQ.0)) THEN 
                  CALL GRA1_RNUMBS(FIOID,RFAIL,TEMP,NUMW,STATUS)
                  PSIZE=TEMP(1)
                  IF (PSIZE.LT.GRA__VSMAL) THEN 
                     FAIL=4
                     FOUND(4)=1
                  END IF
               END IF

*            Initial galaxy centre co-ordinates.
               IF ((STRING.EQ.'X/Y').AND.(FAIL.EQ.0)) THEN 
                  IF (XCO.LT.0.0) THEN 
                     CALL GRA1_RNUMBS(FIOID,RFAIL,TEMP,NUMW,STATUS)
                     XCO=TEMP(1)
                     YCO=TEMP(2)
                  ELSE
                     CALL GRA1_RCHAR(FIOID,RFAIL,BUFFER,STATUS)
                     CURCO=BUFFER
                  END IF
              END IF

*            Number of profiles.
               IF ((STRING.EQ.'NUM').AND.(FAIL.EQ.0)) THEN 
                  CALL GRA1_RNUMBS(FIOID,RFAIL,TEMP,NUMW,STATUS)
                  POINTS=TEMP(1)
                  IF (POINTS.LT.GRA__VSMAL) THEN
                     FAIL=6
                     FOUND(6)=1
                  END IF
               END IF

*            Magnitude scale zero point.
               IF ((STRING.EQ.'ZER').AND.(FAIL.EQ.0)) THEN 
                  CALL GRA1_RNUMBS(FIOID,RFAIL,TEMP,NUMW,STATUS)
                  ZEROP=TEMP(1)
                  IF (ZEROP.LT.GRA__VSMAL) THEN
                     FAIL=9
                     FOUND(9)=1
                  END IF
               END IF

*            Profile results.
               IF ((POINTS.GT.0).AND.(STRING.EQ.'ELL')
     :               .AND.(FAIL.EQ.0)) THEN
                  FAIL=0
                  N=0
                  DO WHILE ((FAIL.EQ.0).AND.(N.NE.POINTS))
                     CALL GRA1_RNUMBS(FIOID,RFAIL,TEMP,NUMW,STATUS)
*                  Accept, but ignore, any columns beyond column 9.
*                  This used to fail unless NUMW was .eq.9, but this prevents
*                  other applications (specifically gaufit) from adding further
*                  columns, without really gaining anything.
                     IF ((RFAIL.EQ.0).AND.(NUMW.GE.9)) THEN
                        N=N+1
                        DO 100 I=1,9
                           RESULT(N,I)=TEMP(I)
 100                    CONTINUE
                     ELSE
                        FAIL=7
                        FOUND(7)=1
                     END IF
                  END DO
               END IF

*            Fourier descriptor results.
               IF ((POINTS.GT.0).AND.(STRING.EQ.'FOU')
     :               .AND.(FAIL.EQ.0)) THEN 
                  FAIL=0
                  N=0
                  DO WHILE ((FAIL.EQ.0).AND.(N.NE.POINTS)) 
                     CALL GRA1_RNUMBS(FIOID,FAIL,TEMP,NUMW,STATUS)
                     IF ((FAIL.EQ.0).AND.(NUMW.EQ.9)) THEN
                        N=N+1
                        DO 200 I=2,9
                           RESULT(N,8+I)=TEMP(I)
 200                    CONTINUE
                     ELSE
                        FAIL=8
                        FOUND(8)=1
                     END IF
                  END DO

               END IF

            END IF 

         END IF

      END DO


*   Check that all the required entries were found.
      FAIL=0
      DO 300 I=9,1,-1
         IF (FOUND(I).EQ.1) FAIL=I
 300  CONTINUE
          
*   Check the defaults. Set a flag if one of them has not been 
*   assigned a value from the file.
      IF (RFAIL.EQ.FIO__EOF) THEN 
         CALL MSG_OUT(' ','End-of-file found.',STATUS)        
         CALL MSG_BLANK(STATUS)
         RFAIL=-1
      END IF
      IF (LTYPE.EQ.3) THEN 
         CALL MSG_OUT(' ','End of filename report.',STATUS)
         CALL MSG_BLANK(STATUS)
         RFAIL=0
      END IF
      IF (FAIL.NE.0) THEN 
         CALL GRA1_EMSG(FAIL,STATUS)
         CALL MSG_BLANK(STATUS)
         RFAIL=1
      END IF

 9999 CONTINUE

      END 


      SUBROUTINE GRA1_RNUMBS(FIOID,FAIL,TEMP,NUMW,STATUS)
*+
*  Name:
*     GRA1_RNUMBS

*  Purpose:
*     Read in a line from the text file and try to find the numbers in it.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL GRA1_RNUMBS(FIOID,FAIL,TEMP,NUMW,STATUS)

*  Description:
*     A line of text from the input file is read in. If the end of file 
*     was not found, it is examined to see how many words are
*     contained in it. The words found are then converted into their
*     numeric equivalents. Values for the words found (TEMP) and the 
*     number of words found (NUMW) are returned.   

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     12-DEC-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants

*  Arguments Given:         
      INTEGER FIOID                   ! FIO identifier for the input file

*  Arguments Returned:
      INTEGER FAIL                    ! Has the end of the file been found?

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variables:
      CHARACTER *(80) BUFFER          ! Contents of a line read from the text
                                      ! input file
      CHARACTER *(80) STRING          ! Temporary storage
      LOGICAL OKAY                    ! Was the line of text read in
                                      ! the type of data expected?
      LOGICAL NUMBOK                  ! Did word extraction fail?
      INTEGER I                       ! Loop variable
      INTEGER J                       ! Temporary storage
      INTEGER INDEXE                  ! Index of the end of a word
      INTEGER INDEX(2,20)             ! Locations of words in the string
      INTEGER INDEXS                  ! Index of the start of a word
      INTEGER LTYPE                   ! Line type 
      INTEGER NUMW                    ! Number of words found in a string
      INTEGER RFAIL                   ! Was the end of file found?
      INTEGER VALNUM                  ! Temporary storage
      REAL TEMP(20)                   ! Numbers read from the current line
      REAL TEMPR                      ! Temporary storage of a real value
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   Loop round reading lines of the file until a non-comment or number are
*   encountered.
      OKAY=.FALSE.
      FAIL=0
      DO WHILE ((FAIL.EQ.0).AND.(.NOT.OKAY))

*      Get the next line.
         CALL GRA1_GETLINE(FIOID,BUFFER,RFAIL,STATUS)

*      Only proceed if not the end of the file.
         IF (RFAIL.EQ.SAI__OK) THEN

*         Determine whether the line is a number.
            CALL GRA1_LTYPE(BUFFER,LTYPE,STATUS)

*         Abandon the attempt if the required input was found.
            IF (LTYPE.EQ.4) OKAY=.TRUE.

         ELSE

*         Also abandon the loop if an eof was found.
            FAIL=1

         END IF

      END DO

*   Search the string received for numbers and place those found in 
*   the TEMP array.
      IF (OKAY) THEN

*      Truncate the buffer.
         CALL CHR_FANDL(BUFFER,I,J)
         STRING=BUFFER(I:J)

         INDEXE=-1
         NUMBOK=.TRUE.
         NUMW=0
         DO WHILE (NUMBOK)

*         Create a new error context.
            CALL ERR_MARK

*         Look for the words.
            INDEXS=INDEXE+1
            CALL CHR_FIWS(BUFFER,INDEXS,STATUS)
            INDEXE=INDEXS
            CALL CHR_FIWE(BUFFER,INDEXE,STATUS)

*         Set the fail flag if the word extraction failed.
            IF (STATUS.NE.SAI__OK) THEN

*            Reset the status value.
               NUMBOK=.FALSE.
               CALL ERR_ANNUL(STATUS)

            ELSE

*            Increment the word counter.
               NUMW=NUMW+1
               IF (NUMW.GT.20) NUMW=20

*            Retain the locations of words.
               INDEX(1,NUMW)=INDEXS
               INDEX(2,NUMW)=INDEXE

            END IF

*         End error context.
            CALL ERR_RLSE

         END DO
      
*      Convert the words that were found.
         IF (NUMW.GT.0) THEN
            
*         Look at each number in turn.
            VALNUM=0
            DO 10 I=1,NUMW
          
*            Create new error context.
               CALL ERR_MARK
              
*            Examine the word and convert to a number.
               STRING=BUFFER(INDEX(1,I):INDEX(2,I))
               CALL CHR_CTOR(STRING,TEMPR,STATUS)

*            Display the cause of the problem.
               IF (STATUS.NE.SAI__OK) THEN
                  CALL ERR_ANNUL(STATUS)
                  CALL MSG_OUT(' ','Characters found where'/
     :                         /' a number was expected.',STATUS)
               
               ELSE

*               Increment the valid number counter and store 
*               the numbers that were found.
                  VALNUM=VALNUM+1
                  TEMP(VALNUM)=TEMPR
               
               END IF

*            Finish the error context.
               CALL ERR_RLSE

 10         CONTINUE

         ELSE
            
*         Indicate that no numbers were found.
            CALL MSG_OUT(' ','Bad text line.',STATUS)

         END IF

      END IF
     
 9999 CONTINUE
      
      END


      SUBROUTINE GRA1_RCHAR(FIOID,FAIL,BUFFER,STATUS) 
*+
*  Name:
*     GRA1_RCHAR

*  Purpose:
*     Read lines in from a file until the end of file is found
*     or a non-comment line is obtained.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL GRA1_RCHAR(FIOID,FAIL,BUFFER,STATUS) 

*  Description:
*     Reads a line in from the input text file and determines what 
*     type of information it contains. Loops round until a non-comment
*     non-blank line is found or until the end of file is found.

*  Authors:
*     GJP: Grant Privett (STARLINK)
*     MBT: Mark Taylor (STARLINK)

*  History:
*     12-DEC-1993 (GJP)
*     (Original version)
*     10-NOV-1999 (MBT)
*     Modified so it doesn't remove blanks.

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'FIO_ERR'               ! FIO error definitions

*  Arguments Given:         
      INTEGER FIOID                   ! FIO identifier for the input file

*  Arguments Returned:
      INTEGER FAIL                    ! Has the end of the file been found?
      CHARACTER *(80) BUFFER          ! Contents of a line read from the text
                                      ! input file

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variables:
      LOGICAL OKAY                    ! Was an error found reading the text
      INTEGER LTYPE                   ! Line type
      INTEGER NCHAR                   ! Number of characters in text line

*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   Loop round reading lines of the file until a non-comment is encountered.
      OKAY=.FALSE.
      FAIL=0
      DO WHILE ((FAIL.EQ.0).AND.(.NOT.OKAY))

*      Set up error context.
         CALL ERR_MARK

*      Get the next line.
         CALL FIO_READ(FIOID,BUFFER,NCHAR,STATUS)

*      Determine what the line is.
         CALL GRA1_LTYPE(BUFFER,LTYPE,STATUS)

*      Abandon the attempt if the required input was not found
*      or if it was. Set different flags accordingly.
         IF (STATUS.NE.SAI__OK) THEN 
            FAIL=1
            CALL ERR_ANNUL(STATUS)
         ELSE
            OKAY=.TRUE.
         END IF

*      End error context.
         CALL ERR_RLSE

      END DO
       
*   Check for an empty buffer.
      IF (BUFFER.EQ.' ') FAIL=1

 9999 CONTINUE
      
      END


      SUBROUTINE GRA1_EMSG(FAIL,STATUS)
*+
*  Name:
*     GRA1_EMSG

*  Purpose:
*     Outputs a message to the screen about the problem found
*     when reading the SECTOR, ELLFOU or ELLPRO file.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL GRA1_EMSG(FAIL,STATUS) 

*  Description:
*     Using the value of FAIL, the routine displays the name of the
*     parameter that was not found (or was corrupt).

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     12-DEC-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants

*  Arguments Given:         
      INTEGER FAIL                    ! Identifies the part of the text file
                                      ! that was absent/corrupt
*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variable:
      CHARACTER *(80) BUFFER          ! A text mesage
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   Set up the buffer with the appropriate error message.

*   Initial value.
      BUFFER=' '

*   Miscellaneous error messages
      IF (FAIL.EQ.1) BUFFER='Filename unusable.'
      IF (FAIL.EQ.2) BUFFER='Background value unusable.'
      IF (FAIL.EQ.3) BUFFER='Sigma value unusable.'
      IF (FAIL.EQ.4) BUFFER='Pixel size unusable'
      IF (FAIL.EQ.5) BUFFER='Initial co-ordinates unusable.'
      IF (FAIL.EQ.6) BUFFER='Number of profiles unusable.'
      IF (FAIL.EQ.7) BUFFER='Profiles unusable.'
      IF (FAIL.EQ.8) BUFFER='Fourier descriptors unusable.'
      IF (FAIL.EQ.9) BUFFER='Zero point value unusable.'

*   Display the appropriate error message.
      CALL MSG_OUT(' ',
     : 'Errors found with some of the file parameters!!',STATUS)
      CALL MSG_OUT(' ',BUFFER,STATUS)
      CALL MSG_OUT(' ',' ',STATUS)

 9999 CONTINUE
      
      END

     
      SUBROUTINE GRA1_GETLINE(FIOID,BUFFER,RFAIL,STATUS)
*+
*  Name:
*     GRA1_GETLINE

*  Purpose:
*     Reads a line of text from the input file.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL GRA1_GETLINE(FIOID,BUFFER,RFAIL,STATUS)

*  Description:
*     Reads a line of text in from the text file and checks to see
*     if the end of file was not found. If it was then RFAIL is set.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     12-DEC-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'FIO_ERR'               ! FIO error definitions
      INCLUDE 'SAE_PAR'               ! Standard SAE constants

*  Arguments Given:         
      INTEGER FIOID                   ! FIO identifier

*  Arguments Returned:
      CHARACTER *(80) BUFFER          ! The text read from the file
      INTEGER RFAIL                   ! Was the end of file found?

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variables:
      INTEGER NCHAR                   ! Length of string returned
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   Set default error value.
      RFAIL=0

*   Create  a new error context.
      CALL ERR_MARK

*      Get the next line.
         CALL FIO_READ(FIOID,BUFFER,NCHAR,STATUS)

*      Display a message.
         IF (STATUS.NE.SAI__OK) THEN
            IF (STATUS.EQ.FIO__EOF) THEN
               CALL ERR_ANNUL(STATUS)
               CALL MSG_BLANK(STATUS)
               CALL MSG_OUT(' ','End of file found.',STATUS)
               RFAIL=FIO__EOF
            ELSE
               CALL ERR_ANNUL(STATUS)
               RFAIL=STATUS
               CALL MSG_OUT(' ','Problems reading the file.',STATUS)
            END IF

         END IF

*   Finish the error context.
      CALL ERR_RLSE

 9999 CONTINUE

      END 


      SUBROUTINE GRA1_CANCL(MODE,STATUS)    
*+
*  Name:
*     GRA1_CANCL

*  Purpose:
*     Cancels a number of input parameters so that they are then in a
*     state where the user is again prompted for an input.
      
*  Language:
*     Starlink Fortran 77

*  Invocation:
*      CALL GRA1_CANCL(MODE,STATUS)    

*  Description:
*      Cancels the values of a number of input parameters so that they are
*      changed from active state to Ground state. This means that the next 
*      time values for them are required the user will be reprompted.
*
*      The MODE variable defines which parameters must be cancelled.
*

*  Arguments:               
*     MODE = INTEGER (Given)
*        Defines which parameters must be cancelled. MODE=0 those required
*        for the cursor input or (MODE=1) those for keyboard input. 
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     23-FEB-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants

*  Arguments Given:                              
      INTEGER MODE                    ! Defines which parameters are to be
                                      ! cancelled

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variables:

*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   Cancel those parameters required for keyboard input.
      IF (MODE.EQ.0) THEN
*      Device on which the image is displayed.
         CALL AGI_CANCL('DEVICE',STATUS)
*      Another profile.
         CALL PAR_CANCL('AGAIN',STATUS)
*      Display what?
         CALL PAR_CANCL('WHATD',STATUS)
*      Display radius mode.
         CALL PAR_CANCL('RADISP',STATUS)
*      Output text file name.
         CALL PAR_CANCL('OUT',STATUS)
*      Automatic selection of radii range.
         CALL PAR_CANCL('RRANGE',STATUS)
*      Range of radius over which the scale length calculations 
*      are performed.
         CALL PAR_CANCL('FITLIM',STATUS)
      END IF

*   Cancel those parameters required for cursor input.
      IF (MODE.EQ.1) THEN
*      Another profile.
         CALL PAR_CANCL('AGAIN',STATUS)
*      DISPLAY what?
         CALL PAR_CANCL('WHATD',STATUS)
*      Radius display mode.
         CALL PAR_CANCL('RADISP',STATUS)
*      Output text file name.
         CALL PAR_CANCL('OUT',STATUS)
*      Automatic selection of radii range.
         CALL PAR_CANCL('RRANGE',STATUS)
      END IF

 9999 CONTINUE

      END



      SUBROUTINE GRA1_GRLIMS(POINTS,RESULT,CURSOR,PSIZE,RADISP,
     :                       LOR,HIR,STATUS)    
*+
*  Name:
*     GRA1_GRLIMS

*  Purpose:
*     Depending on the value of CURSOR, radius range limits are defined
*     by either keyboard entry or via a graphics cursor.
      
*  Language:
*     Starlink Fortran 77

*  Invocation:
*      CALL GRA1_GRLIMS(CURSOR,PSIZE,RADISP,LOR,HIR,STATUS)    

*  Description:

*  Arguments:               
*     POINTS = INTEGER (Given)
*        The number of isophotes available.
*     RESULT(GRA__RESUL,17) = REAL (Returned)
*        The profiling results input from the text file.
*     CURSOR = LOGICAL (Given)
*        Defines whether the radii limits are to be determined via 
*        keyboard or the graphics cursor. 
*     PSIZE = REAL (Read)
*        Size of the image pixels in arc seconds.
*     RADISP = CHAR (Read)
*        The display mode used for the radius axis of the graphs.
*        (Q=quarter power, L=logarithmic, S=square root, R=linear) 
*     LOR = REAL (Returned)
*        Lowest acceptable radius value.
*     HIR = REAL (Returned)
*        Highest acceptable radius value.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     23-FEB-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'gra_par'               ! GRAPHS constants

*  Arguments Given:                              
      LOGICAL CURSOR                  ! Defines keyboard or cursor as input
                                      ! route
      CHARACTER *(256) RADISP         ! Defines the type of radius
                                      ! transformation used on the graph
      INTEGER POINTS                  ! The number of isophotes
      REAL PSIZE                      ! Size of the pixels
      REAL RESULT(GRA__RESUL,17)      ! Profiling results
    
*  Arguments Returned:
      REAL HIR                        ! Highest radius value
      REAL LOR                        ! Lowest radius value

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variables:
      LOGICAL INOKAY                  ! Has a sensible radius range
                                      ! been set?
      INTEGER IND                     ! Number of inputs expected
      INTEGER IND2                    ! Number of inputs received
      INTEGER NUMB                    ! Number of isophotes in the 
                                      ! radius range provided
      REAL INP(2)                     ! Storage for inputs
      REAL X1                         ! X co-ordinate from screen
      REAL X2                         ! X co-ordinate from screen
      REAL Y                          ! X co-ordinate from screen
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   Get radii limits via cursor if so requested by the user.
      IF (CURSOR) THEN

*      Loop around until two reasonable value have been selected
*      for the minimum and maximum radii.
         INOKAY=.FALSE.
         DO WHILE ((.NOT.INOKAY).AND.(STATUS.EQ.SAI__OK))

*         Display a cursor in the new window and get back the 
*         range of radius values the user is interested in.
            CALL GRA1_CURSO(1,X1,Y,STATUS)
            CALL GRA1_CURSO(2,X2,Y,STATUS)
            LOR=MIN(X1,X2)
            HIR=MAX(X1,X2)

*         Transfer the radius values for conversion.
            CALL GRA1_UNCON(RADISP,LOR,HIR,STATUS)         

*         Check to see if it is possible for there to be two 
*         data points in the radius range required.
            CALL GRA1_RANGE(POINTS,PSIZE,RESULT,LOR,HIR,NUMB,STATUS)
            IF (NUMB.GT.2) THEN
               INOKAY=.TRUE.
            ELSE
               CALL PAR_CANCL('FITLIM',STATUS)
            END IF

         END DO

      ELSE
         
*      Loop round until two sensible radius values are input.
         INOKAY=.FALSE.
         DO WHILE ((.NOT.INOKAY).AND.(STATUS.EQ.SAI__OK))

*         Get the two values from the keyboard.
            IND=2
            CALL PAR_GET1R('FITLIM',IND,INP,IND2,STATUS)

*         Check that the values were not inadvertantly 
*         reversed and swop them round so that the 
*         result can be sensible.
            IF (INP(1).LT.INP(2)) THEN
               LOR=INP(1)
               HIR=INP(2)
            ELSE
               CALL MSG_BLANK(STATUS)
               CALL MSG_OUT(' ','WARNING!!!',STATUS)
               CALL MSG_OUT(' ','The low and high values'/
     :                      /' were swapped.',STATUS)
               CALL MSG_BLANK(STATUS)
               LOR=INP(2)
               HIR=INP(1)
            END IF

*         Check to see if it is possible for there to be two 
*         data points in the radius range required.
            CALL GRA1_RANGE(POINTS,PSIZE,RESULT,LOR,HIR,NUMB,STATUS)
            IF (NUMB.GT.2) THEN 
               INOKAY=.TRUE.
            ELSE
               CALL PAR_CANCL('FITLIM',STATUS)
            END IF

         END DO
         IF (STATUS.NE.SAI__OK) GOTO 9999 

      END IF
      
 9999 CONTINUE
     
      END


      SUBROUTINE GRA1_KCMODE(STATUS)
*+
*  Name:
*     GRA1_KCMODE

*  Purpose:
*     Allows the data found in ELLFOU, ELLPRO or SECTOR output text
*     files to be displayed in a graphical form. The parameters are 
*     displayed (brightness etc) versus the radius.
*
*     The profile properties displayed depend on the application that 
*     generated the text file being examined. Fourier descriptors,
*     position angle etc are not available for SECTOR files.
*
*     If more than 2 isophotes were found in the current file, then a 
*     scale length calculation is attempted. The points used are taken 
*     from a user defined range.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL GRA1_KCMODE(STATUS)

*  Arguments:   
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Description: 
*     Looks through the contents of the text file specified by the
*     user. Finds any ESP format entries created by SECTOR, ELLPRO
*     or ELLFOU. 
*
*     When one has been found, the contents are read and checked.
*     If they appear to be sensible, they are displayed in the form 
*     requested by the user i.e. parameter vs radius.
*
*     If data for a sufficient number of isophotes has been found 
*     a scale length calculation is attempted. The spiral and 
*     elliptical galaxy fits are displayed with the raw data.
*
*     The scale length determined for a given data set is stored
*     in an output file. The input text file is then re-examined to
*     see if any more valid ESP format files are contained therein.
*     If there are, they are similarly processed.
*.

*  Implementation Status:
*     Under development

*  Authors:
*     GJP: Grant Privett (STARLINK)
*     {enter_new_authors_here}

*  History:                                       
*     16-Nov-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE

*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'PRM_PAR'               ! PRIMDAT primitive data constants
      INCLUDE 'gra_par'               ! GRAPHS constants
      INCLUDE 'SUBPAR_PAR'            ! SUBPAR constants
          
*  Status:     
      INTEGER STATUS                  ! Global status

*  Local Variables:
      CHARACTER *(80) CURCO           ! Current coordinates of galaxy centre
      CHARACTER *(80) FILEN           ! Image on which the galaxy was found   
      CHARACTER *(80) FILEN2          ! Temporary storage of FILEN  
      CHARACTER *(3) FTYPE            ! The type of record being read
      CHARACTER *(256) RADISP         ! Option choice defining how the
                                      ! radius data is to be displayed
      CHARACTER *(256) WHATD          ! Which parameter from the results
                                      ! file is to be examined
      LOGICAL ANGCON                  ! Position angle convention
      LOGICAL EXCLAIM                 ! Was the cursor an exclaimation?
      LOGICAL RRANGE                  ! Automatic range selection?
      LOGICAL CURSOR                  ! Keyboard or cursor radii selection
      LOGICAL AGAIN                   ! Look at another part of the image?
      LOGICAL GRAPH                   ! Is a graph to be plotted
      LOGICAL OKAY                    ! Was the value of WHATD sensible?
      LOGICAL OPENF                   ! Was the output text file opened okay?
      INTEGER AGIID                   ! AGI identifier
      INTEGER FIOD2                   ! Output file identifer
      INTEGER NUMBP(2)                ! The number of data points used in the
                                      ! scale length regression
      INTEGER FIOID                   ! FIO input file descriptor
      INTEGER FLAG                    ! Can the central pixel value be found?
      INTEGER FSTAT                   ! Has the end of the input file been
                                      ! found
      INTEGER I                       ! Temporary storage
      INTEGER POINTS                  ! The number of valid data points found
      REAL ANGOFF                     ! Position angle offset
      REAL BACK                       ! Background count value
      REAL CONS(2)                    ! Constant terms of the curves used 
                                      ! to find the scale length
      REAL GRAD(2)                    ! Gradients of the curves used
                                      ! to find out the scale length
      REAL HIR                        ! Highest radius value used in the fit
                                      ! calculated
      REAL LOR                        ! Lowest radius value employed in
                                      ! the fit calculated
      REAL LOWLIM                     ! Low radius limit
      REAL PSIZE                      ! Size of the image pixels in arc sec
      REAL REG(2)                     ! Regression coefficient squared 
      REAL SIGMA                      ! Standard deviation of the background value
      REAL SLEN(2)                    ! Scale length of the galaxy
      REAL RESULT(GRA__RESUL,17)      ! Sum of the pixel counts for all pixels
                                      ! at a given distance from the origin
      REAL XCO                        ! X index of the sector origin
      REAL YCO                        ! Y index of the sector origin
      REAL ZEROP                      ! Zero point of the surface 
                                      ! brightness graphs
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   Choose between cursor or keyboard selection of 
*   radii.
      CALL PAR_GET0L('CURSOR',CURSOR,STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999

*   Determine the input ELLPRO, SECTOR or ELLFOU file name.
      CALL FIO_ASSOC('INFILE','READ','LIST',80,FIOID,STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999

*   Look at the command line value for LOWLIM.
*   Otherwise, use the default.
      CALL PAR_STATE('LOWLIM',I,STATUS )
      IF (STATUS.NE.SAI__OK) GOTO 9999
      IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
         CALL PAR_GET0R('LOWLIM',LOWLIM,STATUS)
         CALL MSG_OUT(' ','Command line LOWLIM value used.',STATUS)
      ELSE
         LOWLIM=0.5
      END IF

*   Look at the command line value for ANGCON.
*   Otherwise, use the default.
      CALL PAR_STATE('ANGCON',I,STATUS )
      IF (STATUS.NE.SAI__OK) GOTO 9999
      IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
         CALL PAR_GET0L('ANGCON',ANGCON,STATUS)
         CALL MSG_OUT(' ','Command line ANGCON value used.',STATUS)
      ELSE
         ANGCON=.TRUE.
      END IF
 
*   Look at the command line value for ANGOFF.
*   Otherwise, use the default.
      CALL PAR_STATE('ANGOFF',I,STATUS )
      IF (STATUS.NE.SAI__OK) GOTO 9999
      IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
         CALL PAR_GET0R('ANGOFF',ANGOFF,STATUS)
         CALL MSG_OUT(' ','Command line ANGOFF value used.',STATUS)
      ELSE
         ANGOFF=0.0
      END IF

*   Create a text file containing the latest profile/fit results.
      CALL GRA1_TEXTO(0,FILEN,REG,XCO,YCO,CURCO,SLEN,CONS,ZEROP,
     :                OPENF,FIOD2,EXCLAIM,STATUS)
      FILEN2=' '

*   Look at all the entries in the text file.
      FSTAT=-1
      DO WHILE (FSTAT.LT.1)

*      Obtain the results from the file.
         CALL GRA1_FILER(FSTAT,FIOID,FLAG,POINTS,RESULT,
     :                   BACK,SIGMA,PSIZE,XCO,YCO,CURCO,FILEN,
     :                   FTYPE,ZEROP,STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9999

*      Only allow fitting when more than two data points are present.
         IF ((POINTS.GT.2).AND.(FSTAT.EQ.0)) THEN
          
*         Loop round to redisplay the results as required.
            AGAIN=.TRUE.
            DO WHILE ((AGAIN).AND.(STATUS.EQ.SAI__OK))  

*            Enquire what is to be displayed versus the radius.
               OKAY=.FALSE.
               DO WHILE ((.NOT.OKAY).AND.(STATUS.EQ.SAI__OK))

*               Clear the values for scale length, regression coeff,
*               gradient and slope.
                  DO 27 I=1,2
                     SLEN(I)=0.0
                     CONS(I)=0.0
                     GRAD(I)=0.0
                     REG(I)=0.0
 27               CONTINUE

*               Get the parameters code name.
                  CALL PAR_GET0C('WHATD',WHATD,STATUS)
                  IF (STATUS.NE.SAI__OK) GOTO 9999
                  CALL CHR_UCASE(WHATD)

*               Determine if the input is acceptable.

*               Brightness parameters.
                  IF ((WHATD.EQ.'S').OR.(WHATD.EQ.'B').OR.
     :                (WHATD.EQ.'C')) OKAY=.TRUE.

                  IF ((FTYPE.EQ.'ELF').OR.(FTYPE.EQ.'ELP')) THEN

*                  Other normal parameters.
                     IF ((WHATD.EQ.'E').OR.(WHATD.EQ.'P').OR.
     :                   (WHATD.EQ.'X').OR.(WHATD.EQ.'Y')) OKAY=.TRUE.

*                  Fourier descriptors.
                     IF ((WHATD.EQ.'FS1').OR.(WHATD.EQ.'FC1').OR.
     :                   (WHATD.EQ.'FS2').OR.(WHATD.EQ.'FC2').OR.
     :                   (WHATD.EQ.'FS3').OR.(WHATD.EQ.'FC3').OR.
     :                   (WHATD.EQ.'FS4').OR.(WHATD.EQ.'FC4'))
     :                    OKAY=.TRUE.

                  END IF

*               Cancel the parameter.
                  IF (.NOT.OKAY) THEN
                     CALL PAR_CANCL('WHATD',STATUS)
                     CALL MSG_OUT(' ' ,'That option is not valid.',
     :                                  STATUS)
                  END IF

               END DO

*            Get the radius display type mode and convert to upper case.
               CALL PAR_GET0C('RADISP',RADISP,STATUS)
               IF (STATUS.NE.SAI__OK) GOTO 9999
               CALL CHR_UCASE(RADISP)

*            Ask user for device name.
               AGIID=0
               GRAPH=.TRUE.
               CALL ERR_MARK
               CALL GRA1_AGICO(0,0,0,AGIID,STATUS)
               IF (STATUS.NE.SAI__OK) THEN
                  GRAPH=.FALSE.
                  CALL ERR_ANNUL(STATUS)
               END IF
               CALL ERR_RLSE

*            Display the un-analysed data as a graphical plot of 
*            radius (in some form) versus intensity (in some form).
               IF (GRAPH) THEN              
            
                  CALL GRA1_GRAPH(1,ANGCON,ANGOFF,FTYPE,ZEROP,RADISP,
     :                            WHATD,POINTS,PSIZE,SIGMA,RESULT,
     :                            CONS,GRAD,STATUS)  
                  IF (STATUS.NE.SAI__OK) GOTO 9999

*               Turn off the AGI/PGPLOT interface.
                  CALL GRA1_AGICO(1,0,0,AGIID,STATUS)

               ELSE
                  CALL MSG_OUT(' ','The attempt to use a '/
     :                         /'display failed.',STATUS)
                  GOTO 9999
               END IF

*            Only allow fitting when more than two data points are present.
               IF (POINTS.GT.2) THEN

*                Is the radius range selection to be automatic.
                  CALL PAR_GET0L('RRANGE',RRANGE,STATUS)
                  IF (STATUS.NE.SAI__OK) GOTO 9999
 
                  IF (.NOT.RRANGE) THEN

*                  Find the radius range from which data points are
*                  taken when calculating the scale lengths.
                     CALL GRA1_GRLIMS(POINTS,RESULT,CURSOR,PSIZE,RADISP,
     :                                 LOR,HIR,STATUS)    
                     IF (STATUS.NE.SAI__OK) GOTO 9999
                     
                  END IF
                 
*               Calculate the scale length assuming spiral or elliptical.

*               Obtain the 'fit' parameters for linear fits to the 
*               brightness versus radius data (suitably transformed). 
                  CALL GRA1_LINRE(POINTS,LOWLIM,FTYPE,RRANGE,LOR,
     :                            HIR,RESULT,PSIZE,GRAD,CONS,SLEN,
     :                            NUMBP,REG,STATUS)
                  IF (STATUS.NE.SAI__OK) GOTO 9999

*               Display the fit plots if a graphics device was selected
*               and if brightness is being displayed versus radius.
                  IF ((GRAPH).AND.((WHATD.EQ.'S').OR.
     :                 (WHATD.EQ.'B').OR.(WHATD.EQ.'C'))) THEN

*                  Open up the AGI/PGPLOT interface again.
                     CALL GRA1_AGICO(0,0,1,AGIID,STATUS)

                     CALL GRA1_GRAPH(2,ANGCON,ANGOFF,FTYPE,ZEROP,
     :                               RADISP,WHATD,POINTS,PSIZE,
     :                               SIGMA,RESULT,CONS,
     :                               GRAD,STATUS) 

*                     Turn off the AGI/PGPLOT interface.
                        CALL GRA1_AGICO(1,0,1,AGIID,STATUS)
                        IF (STATUS.NE.SAI__OK) GOTO 9999

                  END IF

*               Display the results on the default display.
                  CALL GRA1_TEXTD(FLAG,POINTS,XCO,YCO,CURCO,BACK,SIGMA,
     :                            CONS,GRAD,PSIZE,NUMBP,ZEROP,SLEN,
     :                            LOR,HIR,REG,STATUS)    

               END IF           
               
*            Interactive display the profile again?
               CALL MSG_BLANK(STATUS)
               CALL PAR_GET0L('AGAIN',AGAIN,STATUS)
               IF (STATUS.NE.SAI__OK) GOTO 9999

*            Create a text file header (if the filename has changed).
               IF (FILEN.NE.FILEN2) THEN 
                  CALL GRA1_TEXTO(1,FILEN,REG,XCO,YCO,CURCO,SLEN,
     :                            CONS,ZEROP,OPENF,FIOD2,
     :                            EXCLAIM,STATUS)
                  FILEN2=FILEN
               END IF

*            Store the latest profile/fit results 
               IF (.NOT.EXCLAIM) THEN
                  CALL GRA1_TEXTO(2,FILEN,REG,XCO,YCO,CURCO,SLEN,
     :                            CONS,ZEROP,OPENF,
     :                            FIOD2,EXCLAIM,STATUS)
               END IF

*            Cancel the parameters so that they must be reinput when
*            looping round.
               CALL GRA1_CANCL(0,STATUS)

            END DO

         ELSE

*            Too few isophotes in the input text file.
               IF (FSTAT.EQ.0) THEN
                   CALL MSG_BLANK(STATUS)
                   CALL MSG_OUT(' ','Too few isophotes to'//
     :                        ' calculate scale length.',STATUS)
                   CALL MSG_BLANK(STATUS)
               END IF
               
         END IF

      END DO

*   Close the results file.
      IF (.NOT.EXCLAIM) THEN
         CALL GRA1_TEXTO(3,FILEN,REG,XCO,YCO,CURCO,SLEN,CONS,ZEROP,
     :                   OPENF,FIOD2,EXCLAIM,STATUS)
      END IF
                   
 9999 CONTINUE

      END 


      SUBROUTINE GRA1_FMODE(STATUS)
*+
*  Name:
*     GRA1_FMODE

*  Purpose:
*     Performs scale length calculations on profile data
*     contained in an input text file.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL GRA1_FMODE(STATUS)

*  Arguments:   
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Description: 
*     Reads through an input text file and identifies valid ESP
*     format files created by ELLFOU, ELLPRO or SECTOR.
*
*     Processes the information it finds in such a way as to
*     determine the scale lnegth of the profiles it finds. 
*     the result generated is output to another text file
*     with a suitable header.


*  Implementation Status:
*     Under development

*  Authors:
*     GJP: Grant Privett (STARLINK)
*     {enter_new_authors_here}

*  History:
*     06-OCT-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE

*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'PRM_PAR'               ! PRIMDAT primitive data constants
      INCLUDE 'gra_par'               ! GRAPHS constants
      INCLUDE 'SUBPAR_PAR'            ! SUBPAR constants
          
*  Status:     
      INTEGER STATUS                  ! Global status

*  Local Variables:   
      CHARACTER *(80) CURCO           ! Current coordinates of galaxy centre
      CHARACTER *(80) FILEN           ! Image on which the galaxy was found
      CHARACTER *(80) FILEN2          ! Temporary storage for FILEN
      CHARACTER *(3) FTYPE            ! The record type being read
                                      ! radius data is to be displayed
      LOGICAL ANGCON                  ! Position angle convention
      LOGICAL EXCLAIM                 ! Is the file name a !?
      LOGICAL RRANGE                  ! Is the limit selection automatic?
      LOGICAL INOKAY                  ! Was the most recent input value okay
      LOGICAL OPENF                   ! Was the text output file opened okay?
      INTEGER FIOD2                   ! File identifier
      INTEGER NUMB                    ! The number of data points within
                                      ! the given radius range
      INTEGER NUMBP(2)                ! The number of data points used in the
                                      ! scale length regression
      INTEGER FIOID                   ! FIO file descriptor
      INTEGER FLAG                    ! Can the central pixel value be found?
      INTEGER FSTAT                   ! Has the file end been reached?
      INTEGER I                       ! Temporary storage
      INTEGER IND                     ! The number of origin indices to
                                      ! be input at one go i.e. 2
      INTEGER IND2                    ! Number of indices returned
      INTEGER POINTS                  ! The number of valid data points found
      REAL ANGOFF                     ! Position angle offsets
      REAL BACK                       ! Background count value
      REAL CONS(2)                    ! Constant terms of the curves used 
                                      ! to find the scale length
      REAL GRAD(2)                    ! Gradients of the curves used
                                      ! to find out the scale length
      REAL HIR                        ! Highest radius value used in the fit
                                      ! calculated
      REAL HIRPERM                    ! Permanent version of HIR 
      REAL INP(2)                     ! Value input by the user
      REAL LOR                        ! Lowest radius value employed in
                                      ! the fit calculated
      REAL LORPERM                    ! Permanent version of LOR
      REAL LOWLIM                     ! Lower fit radius limit
      REAL PSIZE                      ! Size of the image pixels in arc sec
      REAL REG(2)                     ! Regression coefficient squared 
      REAL SIGMA                      ! Standard deviation of the background value
      REAL SLEN(2)                    ! Scale length of the galaxy
      REAL RESULT(GRA__RESUL,17)      ! Sum of the pixel counts for all pixels
                                      ! at a given distance from the origin
      REAL XCO                        ! X index of the sector origin
      REAL YCO                        ! Y index of the sector origin
      REAL ZEROP                      ! Zero point of the surface 
                                      ! brightness graphs
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   
                                       
*   Determine the input ELLPRO, SECTOR or ELLFOU file name.
      CALL FIO_ASSOC('INFILE','READ','LIST',80,FIOID,STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999

*   Look at the command line value for LOWLIM.
*   Otherwise, use the default.
      CALL PAR_STATE('LOWLIM',I,STATUS )
      IF (STATUS.NE.SAI__OK) GOTO 9999
      IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
         CALL PAR_GET0R('LOWLIM',LOWLIM,STATUS)
         CALL MSG_OUT(' ','Command line LOWLIM value used.',STATUS)
      ELSE
         LOWLIM=0.5
      END IF
 
*   Look at the command line value for ANGCON.
*   Otherwise, use the default.
      CALL PAR_STATE('ANGCON',I,STATUS )
      IF (STATUS.NE.SAI__OK) GOTO 9999
      IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
         CALL PAR_GET0L('ANGCON',ANGCON,STATUS)
         CALL MSG_OUT(' ','Command line ANGCON value used.',STATUS)
      ELSE
         ANGCON=.TRUE.
      END IF

*   Look at the command line value for ANGOFF.
*   Otherwise, use the default.
      CALL PAR_STATE('ANGOFF',I,STATUS )
      IF (STATUS.NE.SAI__OK) GOTO 9999
      IF ((I.EQ.SUBPAR__ACTIVE).OR.(I.EQ.SUBPAR__FPROMPT)) THEN    
         CALL PAR_GET0R('ANGOFF',ANGOFF,STATUS)
         CALL MSG_OUT(' ','Command line ANGOFF value used.',STATUS)
      ELSE
         ANGOFF=0.0
      END IF

*   Is the radius range selection to be automatic.
      CALL PAR_GET0L('RRANGE',RRANGE,STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999
 
*   Get the radius range limits from the user.
      IF (.NOT.RRANGE) THEN
                  
*      Get the two values from the keyboard.
         IND=2
         CALL PAR_GET1R('FITLIM',IND,INP,IND2,STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9999

*      Check that the values were not inadvertantly reversed 
*      and swop them round so that the result can be sensible.
         IF (INP(1).LT.INP(2)) THEN
             LORPERM=INP(1)
             HIRPERM=INP(2)
         ELSE
             LORPERM=INP(2)
             HIRPERM=INP(1)
         END IF

      ELSE
       
*      Set arbitrary low and high limits for the scale length calculation.
         LORPERM=0
         HIRPERM=1E5

      END IF
      IF (STATUS.NE.SAI__OK) GOTO 9999 

*   Create a text file containing the latest profile/fit results.
      CALL GRA1_TEXTO(0,FILEN,REG,XCO,YCO,CURCO,SLEN,CONS,ZEROP,
     :                OPENF,FIOD2,EXCLAIM,STATUS)
      FILEN2=' '
    
*   Look at all the entries in the text file.
      FSTAT=-1
      DO WHILE (FLAG.LT.1)

*      Obtain the results from the file.
         CALL GRA1_FILER(FSTAT,FIOID,FLAG,POINTS,RESULT,
     :                   BACK,SIGMA,PSIZE,XCO,YCO,CURCO,
     :                   FILEN,FTYPE,ZEROP,STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9999

*      Only continue if you are sure everything is okay.
         IF(FSTAT.EQ.0) THEN

*      Set up the radius limits for this loop.
            LOR=LORPERM
            HIR=HIRPERM

*         Check to see if it is possible for there to be two 
*         data points in the radius range required.
            CALL GRA1_RANGE(POINTS,PSIZE,RESULT,LOR,HIR,NUMB,STATUS)
            IF (NUMB.GT.2) INOKAY=.TRUE.
         
*         Clear the values for scale length, regression coeff,
*         gradient and slope.
            DO 27 I=1,2
               SLEN(I)=0.0
               CONS(I)=0.0
               GRAD(I)=0.0
               REG(I)=0.0
 27         CONTINUE

*         Only allow fitting when more than two data points are present.
            IF (INOKAY) THEN
          
*            Calculate the scale length assuming spiral or elliptical.

*            Obtain the 'fit' parameters for linear fits to the brightness 
*            versus radius data (suitably transformed). 
                CALL GRA1_LINRE(POINTS,LOWLIM,FTYPE,RRANGE,LOR,
     :                          HIR,RESULT,PSIZE,GRAD,CONS,SLEN,
     :                          NUMBP,REG,STATUS)
                IF (STATUS.NE.SAI__OK) GOTO 9999

*            Display the results on the default display.
               CALL GRA1_TEXTD(FLAG,POINTS,XCO,YCO,CURCO,BACK,SIGMA,
     :                         CONS,GRAD,PSIZE,NUMBP,ZEROP,SLEN,
     :                         LOR,HIR,REG,STATUS)    

*            Create a text file header (if the filename has changed).
               IF (FILEN.NE.FILEN2) THEN 
                  CALL GRA1_TEXTO(1,FILEN,REG,XCO,YCO,CURCO,SLEN,
     :                            CONS,ZEROP,OPENF,
     :                            FIOD2,EXCLAIM,STATUS)
                  FILEN2=FILEN
               END IF

*            Store the latest profile/fit results 
               IF (.NOT.EXCLAIM)  THEN
                  CALL GRA1_TEXTO(2,FILEN,REG,XCO,YCO,CURCO,SLEN,
     :                            CONS,ZEROP,OPENF,FIOD2,
     :                            EXCLAIM,STATUS)
               END IF  

            ELSE
               CALL MSG_BLANK(STATUS)
               CALL MSG_OUT(' ','Too few isophotes to calculate'//
     :                      ' scale length.',STATUS)
               CALL MSG_BLANK(STATUS)
            END IF

         END IF

      END DO

*   Close the results file.
      IF (.NOT.EXCLAIM) THEN
         CALL GRA1_TEXTO(3,FILEN,REG,XCO,YCO,CURCO,SLEN,
     :                   CONS,ZEROP,OPENF,
     :                   FIOD2,EXCLAIM,STATUS)
      END IF

 9999 CONTINUE

      END 


      SUBROUTINE GRA1_AGICO(ONOFF,MODE,NEW,AGIID,STATUS)
*+
*  Name:
*     GRA1_AGICO

*  Purpose:
*     Turns on/off the AGI/PGPLOT interface used for plotting the graphs.
      
*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL GRA1_AGICO(ONOFF,MODE,NEW,AGIID,STATUS)    

*  Description:
*     Depending on the value of ONOFF the subroutine either:-
*     sets up the AGI/PGPLOT interface and enters new information into
*     the AGI database (ONOFF=0) or closes down the database and
*     interface (ONOFF=1). The routine may be called to generate a display
*     on the device currently used or on a new device to be specified.

*  Arguments:                                     
*     ONOFF = INTEGER (Given)
*        Defines whether the routines controlling AGI/PGPLOT should
*        be turned on or off. 0=on 1=off 
*     MODE = INTEGER (Given)
*        Defines whether or not the ADAM parameter is the current
*        graphics device or a new one to be specified. 0=current 1=new.
*     NEW = INTEGER (Given)
*        Defines whether or not a new viewport should be created
*        and to determine if UPDATE or WRITE mode is required in
*        AGI_ASSOC. This influences the tranformation required.
*     AGIID = INTEGER (Given and Returned)
*        An AGI picture identifier used by AGI.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     8-July-1992 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants

*  Arguments Given:                              
      INTEGER MODE                    ! Defines whether the display will
                                      ! be on a new device or the current
                                      ! one 0=current 1=new
      INTEGER NEW                     ! Defines the WRITE/UPDATE status
                                      ! and whether or not a new
                                      ! viewport transformation is required
      INTEGER ONOFF                   ! Defines whether AGI/PGPLOT
                                      ! must be turned on or off
                                      ! 0=on 1=off

*  Arguments Given and Returned:           
      INTEGER AGIID                   ! An AGI picture identifier
                                           
*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variables:
      REAL CR                         ! RGB red index of current 
                                      ! background colour
      REAL CG                         ! RGB green index of current
                                      ! background colour
      REAL CB                         ! RGB blue index of current
                                      ! background colour
      real x1,x2,y1,y2
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN

*   Start an AGI context.
      CALL AGI_BEGIN

*   Setup the AGI/PGPLOT interface.
      IF (ONOFF.EQ.0) THEN

*      Open AGI on a device obtained from the parameter system.
         IF (MODE.EQ.0) THEN 

*         Use a device to be specified by the user.
            IF (NEW.EQ.0) THEN

*            Get the name of the new device.
               CALL AGI_ASSOC('DEVICE','WRITE',AGIID,STATUS) 

*            Ensure that the whole screen is used.
               CALL AGI_IBASE(AGIID,STATUS)
               CALL AGI_SELP(AGIID,STATUS)

            ELSE

*            Update the graph display.
               CALL AGI_ASSOC('DEVICE','UPDATE',AGIID,STATUS)

            END IF

         ELSE
*         Associate the window in the correct mode.
            IF (NEW.EQ.0) THEN
               CALL AGI_ASSOC('DEVICE','WRITE',AGIID,STATUS)
            ELSE
               CALL AGI_ASSOC('DEVICE','UPDATE',AGIID,STATUS)
            END IF
         END IF
         IF (STATUS.NE.SAI__OK) GOTO 9999

*      Activate the PGPLOT interface to AGI.
         CALL AGP_ACTIV(STATUS)
         IF (STATUS.NE.SAI__OK) GOTO 9999

*      Create a new viewport if required.
         IF (NEW.EQ.0) THEN
*         Create the new viewport.
            CALL AGP_NVIEW(.TRUE.,STATUS)
*         Inquire what the viewport size is.
            CALL PGQVP(1,X1,X2,Y1,Y2)
         ELSE
*         Use the old viewport information. No new border and transformations.
            CALL AGP_NVIEW(.FALSE.,STATUS)
         END IF
         IF (STATUS.NE.SAI__OK) GOTO 9999

*      Enquire details of the current background colour.
         CALL PGQCR(0,CR,CG,CB)

*      Set the pen colours (otherwise the output does not show on the IKON).
*      User colour index of 1 since it is accepted by all monochrome
*      devices.
         CALL PGSCR(1,1.0-CR,1.0-CG,1.0-CB)
         CALL PGSCI(1)

      END IF

 9999 CONTINUE

*   Closedown the AGI/PGPLOT interface.
      IF ((ONOFF.EQ.1).OR.(STATUS.NE.SAI__OK)) THEN

*      Save the current viewport in the AGI database. 
         CALL AGP_SVIEW('GRAPHS','Galaxy Profile',AGIID,STATUS)

*      Close down PGPLOT. 
         CALL AGP_DEACT(STATUS)

*      Cancel the picture identifier or annul the parameter association 
*      depending on the value of STATUS.
         IF (STATUS.NE.SAI__OK) THEN

*         Cancel the AGI parameter association.       
            IF (MODE.EQ.0) THEN
               CALL AGI_CANCL('DEVICE',STATUS)
            ELSE
               CALL AGI_CANCL('IMGDEV',STATUS)
            END IF

         ELSE     

*         Annul the AGI parameter association.       
            CALL AGI_ANNUL(AGIID,STATUS)

         END IF

      END IF
                          
      END


      SUBROUTINE GRA1_AGIC2(ONOFF,DEVCAN,PICID,STATUS)
*+
*  Name:
*     GRA1_AGIC2

*  Purpose:
*     Turns on/off the AGI/SGS/PGPLOT interface allowing line drawing
*     and a cursor using SGS and  displaying graphs using PGPLOT.
      
*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL GRA1_AGIC2(ONOFF,DEVCAN,PICID,STATUS)    

*  Description:
*     Depending on the value of ONOFF the subroutine either:-
*
*     Sets up the AGI interface, obtaining the most recent 'GRAPHS' 
*     picture. Activates SGS so that PGPLOT and normal SGS 
*     routines can be used. PGPLOT is turned on/off to set up its colour
*     tables.
*
*     Closes down the above in an orderly fashion. (ONOFF=1).

*  Arguments:                                     
*     ONOFF = INTEGER (Given)
*        Defines whether the routines controlling AGI/PGPLOT should
*        be turned on or off. 0=on 1=off 
*     DEVCAN = LOGICAL (Given and Returned)
*        The device parameter is to be annuled when ONOFF=1.
*     PICID = INTEGER (Given and Returned)
*        An AGI picture identifier used by AGI.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     18-Jan-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'PAR_ERR'               ! Parameter-system errors

*  Arguments Given:                              
      INTEGER ONOFF                   ! Defines whether AGI/PGPLOT
                                      ! must be turned on or off
                                      ! 0=on 1=off

*  Arguments Returned.                                           

*  Arguments Given and Returned:           
      LOGICAL DEVCAN                  ! Defines whether the current
                                      ! picture is to be retained at
                                      ! database closedown
      INTEGER PICID                   ! An AGI picture identifier

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local Variables:
      INTEGER ZONID                   ! SGS zone identifier of the initial
                                      ! picture
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN

*   Set default value.
      DEVCAN=.FALSE.   

*   Setup the AGI/SGS/PGPLOT interface.
      IF (ONOFF.EQ.0) THEN

*      Start a new AGI context.
         CALL AGI_BEGIN

*      Get the graphics device, and open SGS.
         CALL AGI_ASSOC('DEVICE','UPDATE',PICID,STATUS)
         IF (STATUS.NE.SAI__OK) THEN 
            CALL ERR_FLUSH(STATUS)
            GOTO 9999
         END IF

*      Activate SGS.
         CALL AGS_ACTIV(STATUS)

*      If the graphics device was not available, report the error and
*      leave the programme.
         IF (STATUS.NE.SAI__OK) THEN 
            IF (STATUS.NE.PAR__ABORT) DEVCAN=.TRUE.
            CALL ERR_FLUSH(STATUS)
            GOTO 9999
         END IF

*      Select the base picture as current so that the search for GRAPHS 
*      later will look through all the pictures.
         CALL AGI_IBASE(PICID,STATUS)
         CALL AGI_SELP(PICID,STATUS)
         IF (STATUS.NE.SAI__OK) THEN 
            CALL ERR_FLUSH(STATUS)
            GOTO 9999
         END IF

*      Create a new SGS_ZONE from current picture of correct name.

*      Find most recent GRAPHS results display.
         CALL AGI_RCL('GRAPHS',PICID,STATUS)

*      Abort if it was impossible to find a suitable entry in the AGI database.
         IF (STATUS.NE.SAI__OK) THEN 
            DEVCAN=.TRUE.
            CALL ERR_FLUSH(STATUS)
            GOTO 9999
         END IF

*      Select the AGI database entry selected as the current picture and
*      create the new zone.
         CALL AGI_SELP(PICID,STATUS)
         CALL AGS_NZONE(ZONID,STATUS)

      END IF

 9999 CONTINUE
 

*   Closedown the AGI/SGS interface.
      IF ((ONOFF.EQ.1).OR.(STATUS.NE.SAI__OK)) THEN

*      Deactivate SGS and close the workstation.
         CALL AGS_DEACT(STATUS)

*      Close the AGI context.
         CALL AGI_END(PICID,STATUS)

*      Close the AGI database. Record the name of the workstation only
*      if it was used successfully.
         IF (DEVCAN) THEN
            CALL AGI_CANCL('DEVICE',STATUS)
         ELSE
            CALL AGI_ANNUL(PICID,STATUS)
         END IF

      END IF

      END


      SUBROUTINE GRA1_CONV(RADISP,WHATD,SIGMA,ZEROP,FLAG,RADIUS,
     :                     BRIGHT,STATUS)
*+
*  Name:
*     GRA1_CONV

*  Purpose:
*     Transforms the radius and pixel count value into the currently 
*     required format. Returns an error flag if one of the values is 
*     unusable. Is employed when displaying data points or data
*     fits.
      
*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL GRA1_CONV(RADISP,WHATD,SIGMA,ZEROP,FLAG,RADIUS,BRIGHT,STATUS)    

*  Description:
*     Depending on the value of RADISP the subroutine converts the values
*     for radius and pixel count into the appropriate form. These may be
*     R, R**2, R**.5 or Log10(R) (in the case of R) and Log10(I)
*     I/SIGMA in the case of pixel count value.

*  Arguments:                                     
*     RADISP = CHAR (Given)
*        Character variable denoting the format to be used for the radius
*        value. R=Linear Q=Quarter power, L=Logarithmic and S=Squared.
*     WHATD *(256) = CHARACTER  (Given)
*        Describes what parameter is to be displayed against 
*        radius on the graphs. 
*     BACK = REAL (Given)
*        The background count value for the image. Units counts.
*     SIGMA = REAL (Given)
*        The standard deviation the image background count. Units counts.
*     ZEROP = REAL (Given)
*        Zero point of the brightness scale. Units magnitudes.
*     FLAG = INTEGER (Returned)
*        Set to non-zero if the radius or brightness value could not
*        be transformed. eg log of a negative number.
*     RADIUS = REAL (Given and Returned)
*        The radius value to be transformed. Units arc seconds.
*     BRIGHT = REAL (Given and Returned)
*        The pixel count value to be transformed. Units counts.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     30-Nov-1992 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants

*  Arguments Given:                              
      CHARACTER RADISP *(256)         ! Defines the type of transformation
                                      ! to be applied to the radius value
      CHARACTER *(256) WHATD          ! What is to be displayed against
                                      ! the radius
      REAL SIGMA                      ! Standard deviation of the background count value
      REAL ZEROP                      ! The zero point of the magnitude scale

*  Arguments Returned:
      INTEGER FLAG                    ! Indicates whether or not the 
                                      ! transformations were successful
*  Arguments Given and Returned:           
      REAL BRIGHT                     ! The pixel count value to be
                                      ! transformed
      REAL RADIUS                     ! The radius value to be transformed    

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variables:
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN

*   Set the transformation successful? flag.
      FLAG=0

*   Perform pixel count transformations.

*   Modify the incoming Y axis values if required. 
*   Not required when WHATD = E, P, C, X, Y or the Fourier descriptors..

*   In terms of sigma compared to sky.
      IF (WHATD.EQ.'B') BRIGHT=BRIGHT/SIGMA

*   In terms of surface brightness.
      IF (WHATD.EQ.'S') THEN                       
         IF (BRIGHT.GT.0.0) THEN
            BRIGHT=ZEROP-2.5*LOG10(BRIGHT)
         ELSE
*         Avoid calculating Log of zero or a negative number.
            FLAG=1
         END IF
      END IF

*   Perform radius transformations.

*   Linear radius transformation.
      IF (RADISP.EQ.'R') RADIUS=RADIUS

*   Quarter power radius transformation.
      IF (RADISP.EQ.'Q') RADIUS=RADIUS**(0.25)

*   Logarithmic radius transform.
      IF (RADISP.EQ.'L') THEN
         IF (RADIUS.GT.0.0) THEN
            RADIUS=LOG10(RADIUS)
         ELSE
*         Avoid calculation Log of zero or a negative number.
            FLAG=-1
         END IF
      END IF

*   Squared radius transformation.
      IF (RADISP.EQ.'S') RADIUS=RADIUS*RADIUS

 9999 CONTINUE

      END


      SUBROUTINE GRA1_CURSO(POINT,X,Y,STATUS)
*+
*  Name:
*     GRA1_CURSO

*  Purpose:
*     Multi-purpose routine that allows use of the SGS cursor for returning 
*     the co-ordinate for a given type of image and also controls all SGS 
*     graphics displays (such as that displaying the shape/position of the 
*     user defined sector). The routine is used for more than one purpose to 
*     avoid unecessary duplication of code.

*  Language:
*     Starlink Fortran 77

*  Type of Module:
*     ADAM A-task

*  Invocation:
*     CALL GRA1_CURSO(POINT,X,Y,STATUS)

*  Arguments:
*     POINT = INTEGER (Given)
*        Specifies what action is to be taken by the subroutine.
*     X = REAL (Given and Returned)
*        Co-ordinate information obtained via the cursor.
*     Y = REAL (Given and Returned)
*        Co-ordinate information obtained via the cursor.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Description:
*     The routine allows the user to use the SGS cursor to specify the 
*     radius range to be used.
*
*     It inspects the AGI database to ensure that the co-ordinate
*     system values are being returned for the file most recently stored 
*     within the database name GRAPHS.
*
*     It closes down the AGI resources and SGS at the end of each call so
*     that confusion may be avoided at the calling routines.

*  Notes:
*     This program is a massively disembowelled version of KAPPA program
*     CURSOR with a few bits of ZAPLIN used here and there. 
*
*     The application only acts on the most recent picture in the 
*     graphics database called 'GRAPHS' which contains a graphical display 
*     of the profile results.
 
*  Authors:
*     GJP: Grant Privett (STARLINK)
*     {enter_new_authors_here}

*  History:
*     See KAPPA CURSOR and ZAPLIN for their history.
*     Original Version: 05/01/93
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}

*-

*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants
      INCLUDE 'PAR_ERR'          ! Parameter-system errors
      INCLUDE 'AGI_ERR'          ! AGI error constants

*  Arguments given:
      INTEGER POINT              ! Which of the describing points is being
                                 ! selected

*  Arguments Given and Returned:
      REAL X                     ! Position information from the cursor 
                                 ! or to be displayed on the workstation
      REAL Y                     ! Position information from the cursor 
                                 ! or to be displayed on the workstatio

*  Status:
      INTEGER STATUS             ! Global status

*  Local Variables:
      CHARACTER *80 IMGMES(3)    ! Informational messages if device is
                                 ! an image display
      CHARACTER *80 TERMES(3)    ! Informational messages if device is
                                 ! a terminal

      INTEGER HITVAL             ! The selected choice of the cursor
      INTEGER NIMGMS             ! Number of lines of image-display
                                 ! messages
      INTEGER NTERMS             ! Number of lines of terminal messages
      INTEGER PICID              ! Current (input) picture identifier
      INTEGER USED               ! Was a point defined? USED<>0 True.
      REAL CURSIZ                ! Size of the graphics cursor
      REAL X1,Y1                 ! Lower-left corner of the initial
                                 ! picture
      REAL X2,Y2                 ! Upper-right corner of the initial
                                 ! picture
      REAL XIN                   ! X co-ord as measured by cursor
      REAL XM,YM                 ! Size of the initial picture
      REAL YIN                   ! Y co-ord as measured by cursor
      LOGICAL CURCHO             ! Cursor is available with suitable
                                 ! number of choices
      LOGICAL DEVCAN             ! The device parameter is to be
                                 ! cancelled
      LOGICAL IMGDIS             ! Device is nominally an image display

*.

*   Check inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN
    
*   Create informative messages for use with the cursor.

*   Select a point defining the lower limit for the radius of data
*   points used in the analysis of the scale length.
      IF (POINT.EQ.1) THEN
         TERMES(1)='Select a point defining the lower limit for '//
     :             'radius using the space bar.'
         TERMES(2)='Type . or use button to exit.'
         IMGMES(1)='Select a point defining the lower limit for'/
     :    /' the radius required.'
         IMGMES(2)='To exit press the right button.'
      END IF

*   Select a point defining the upper limit for the radius of data
*   points used in the analysis of the scale length.
      IF (POINT.EQ.2) THEN
         TERMES(1)='Select a point defining the upper limit for '//
     :             'radius using the space bar.'
         TERMES(2)='Type . or use button to exit.'
         IMGMES(1)='Select a point defining the upper limit for'/
     :    /' the radius required.'
         IMGMES(2)='To exit press the right button.'
      END IF

      NTERMS=2
      NIMGMS=2

*   Start the graphics system.
      CALL GRA1_AGIC2(0,DEVCAN,PICID,STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999

*   Set initial cursor position of the current picture. When defining the
*   sector to be used, the last location selected is supplied as the initial
*   position. Also re-establishes the screen limits.
      CALL SGS_IZONE(X1,X2,Y1,Y2,XM,YM)
      IF (POINT.EQ.8) THEN
         XIN=0.5*(X1+X2)
         YIN=0.5*(Y1+Y2)
      END IF  

*   Actually sets the position (code above calculated it).
      CALL SGS_SETCU(XIN,YIN)
      CURSIZ=0.004*MIN(X2-X1,Y2-Y1)   

*   Put out a blank line to ensure the commentary appears on the alpha
*   plane of the terminal.
      CALL MSG_BLANK(STATUS)

*   Prepare the cursor for use.
      CALL GRA1_PRPCUR(1,3,TERMES,NTERMS,IMGMES,NIMGMS,'12 .',
     :            CURCHO,IMGDIS,STATUS)
      IF ((.NOT.CURCHO).OR.(STATUS.NE.SAI__OK)) GOTO 980

*   Initialise HITVAL before the main loop is entered.
      HITVAL=1

*   Initialise flag to show that the cursor was used.
      USED=0

*   Loop until the escape choice is selected
      DO WHILE (HITVAL.GT.0.AND.HITVAL.LT.4.AND.STATUS.EQ.SAI__OK)

*      Start a new error context.
         CALL ERR_MARK

*      If a message has already been displayed, and then the cursor
*      is used, the next message is no longer in synchronisation
*      with the cursor. So synchronise the message system.
         CALL MSG_SYNC(STATUS)

*      Read the cursor position and button value.
         CALL SGS_REQCU(XIN,YIN,HITVAL)
         IF(HITVAL.EQ.-1) HITVAL=4

*      Get the result from the cursor.
         IF ((HITVAL.GT.0).AND.(HITVAL.LT.4)) THEN
                         
*         Note that an input was obtained.
            USED=USED+1

            X=XIN
            Y=YIN

         ELSE
            IF (USED.EQ.0) THEN
               CALL MSG_OUT(' ','No points selected!!!',STATUS) 
               IF (STATUS.EQ.SAI__OK) HITVAL=1
            END IF
         END IF

*      Release the new error context.
         CALL ERR_RLSE

      END DO
  
 980  CONTINUE

*   Closedown the AGI/SGS/PGPLOT interface.
      CALL GRA1_AGIC2(1,DEVCAN,PICID,STATUS)
      IF (STATUS.NE.SAI__OK) GOTO 9999

 9999 CONTINUE

      END


      SUBROUTINE GRA1_GRAPH(GMODE,ANGCON,ANGOFF,FTYPE,ZEROP,RADISP,
     :                     WHATD,POINTS,PSIZE,SIGMA,RESULT,CONS,
     :                     GRAD,STATUS)
*+                          
*  Name:
*     GRA1_GRAPH

*  Purpose:
*     Displays the graphs on the requested graphics device. 
      
*  Language:
*     Starlink Fortran 77

*  Invocation:
*      CALL GRA1_GRAPH(GMODE,ANGCON,ANGOFF,FTYPE,ZEROP,RADISP,
*                      WHATD,POINTS,PSIZE,SIGMA,RESULT,CONS,GRAD,STATUS)    
                      
*  Description:
*      Displays the graphical output from the program. This consists of
*      a graph showing the radius (or some transformation thereof) versus
*      the mean pixel brightness/intensity in terms of Log10(I)
*      or relative to sky I/Sigma. 
*
*      It is also possible, depending on the input file type, to show
*      ellipticity, position angle, Fourier descriptors etc versus
*      transformed radius.

*  Arguments:         
*     GMODE = INTEGER (Given)
*        Defines whether or not raw data or profile fits are to be 
*        displayed at the moment. 1=Raw 2=Fit
*     ANGCON = LOGICAL (Given)
*        Position angle rotation convention. TRUE=clockwise positive.
*     ANGOFF = REAL (Given) 
*        Position angle offset. Units degrees.
*     FTYPE *(3) = CHARACTER (Given)
*        The record type found in the results file. ELF=ELLFOU,
*        SEC=SECTOR and ELP=ELLPRO.
*     ZEROP = REAL (Given)
*        Zero point of the brightness scale.
*     RADISP = CHARACTER (Given)
*        Defines the format in whcih the radius will be displayed on 
*        the graph. R=linear Q=Quarter power L=Logarithmic S=Square.
*     WHATD *(256) = CHARACTER (Given)
*        Which parameter is to be displayed versus radius.
*     POINTS = INTEGER (Given) 
*        Number of raw data points available for the graph.
*     PSIZE = REAL (Given) 
*        Pixel size. Units arc seconds.
*     SIGMA = REAL (Given) 
*        The standard deviation of the background count value. Units counts.
*     RESULT(GRA__RESUL) = REAL (Given)
*        The summation count for all the data points found at a given 
*        distance from the required origin.
*     CONS(2) = REAL (Given) 
*        The constant term of the linear equation fit to the radius/brightness
*        results obtained in the most recent profile analysis.
*     GRAD(2) = REAL (Given)           
*        The gradient term of the linear equation fit to the radius/brightness
*        results obtained in the most recent profile analysis.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     02-Dec-1992 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'gra_par'               ! GRAPHS constants
      INCLUDE 'PRM_PAR'               ! PRIMDAT primitive data constants

*  Arguments Given:                           
      LOGICAL ANGCON                  ! Position angle convention 
      CHARACTER *(3) FTYPE            ! File header type
      CHARACTER *(256) RADISP         ! Denotes the form in which radius
                                      ! values are displayed
      CHARACTER *(256) WHATD          ! What parameter is to be displayed
                                      ! against radius
      INTEGER GMODE                   ! Determines which parts of the 
                                      ! graph should be displayed
      INTEGER POINTS                  ! The number of data points
      REAL ANGOFF                     ! Position angle offset
      REAL PSIZE                      ! The size of each pixel in
                                      ! arc seconds
      REAL SIGMA                      ! Standard deviation of the background count
      REAL RESULT(GRA__RESUL,17)      ! Summation of the count value of 
                                      ! all the pixels found at a given 
                                      ! radius
      REAL CONS(2)                    ! Constant term of the linear regression
                                      ! fit for the data
      REAL GRAD(2)                    ! Gradient term of the linear regression
                                      ! fit for the data
      REAL ZEROP                      ! The zero point of the magnitude 
                                      ! scale

*  Arguments Given and Returned:           
                                           
*  Arguments Returned:

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variables:
      CHARACTER *(256) LABELX         ! Graph X axis heading
      CHARACTER *(256) LABELY         ! Graph Y axis heading
      INTEGER FLAG                    ! Indicates whether the transformation 
                                      ! radius and brightness to be displayed
                                      ! was possible for the current data
                                      ! point
      INTEGER I                       ! Loop variable
      INTEGER J                       ! Loop variable
      REAL BIGR                       ! Biggest semi-major axis
      REAL BRIGHT                     ! Brightness/count etc at a given
                                      ! distance from the origin
      REAL LOWP                       ! The lowest count/brightness value 
      REAL LOWP2                      ! Temporary stoarge of LOWP
      REAL LOWR                       ! The lowest radius value
      REAL HIGHP                      ! The highest count/brightness value
      REAL HIGHP2                     ! Temporary storage of HIGHP
      REAL HIGHR                      ! The highest radius value
      REAL MEAN(1)                    ! Y axis value to display
      REAL RAD(1)                     ! X axis value to display
      REAL RADIUS                     ! Distance from the origin in arc sec
      REAL TEMP                       ! Temporary variable
      REAL X                          ! The transformed radius value
      REAL X1                         ! Viewport limit   
      REAL X2                         ! Viewport limit   
      REAL Y1                         ! Viewport limit   
      REAL Y2                         ! Viewport limit   
      REAL Y(2)                       ! Transformed brightness value
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN

*   Raw data display.
      IF (GMODE.EQ.1) THEN

*      Set the minimum and maximum initial values.
         LOWR=VAL__MAXR
         HIGHR=VAL__MINR
         LOWP=VAL__MAXR
         HIGHP=VAL__MINR
         
*      Loop through all the data points.
         DO 30 I=1,POINTS

*            Convert the radius data to the right form.
               IF ((FTYPE.EQ.'ELF').OR.(FTYPE.EQ.'ELP')) THEN
                  RADIUS=PSIZE*SQRT(RESULT(I,4)*RESULT(I,4)*RESULT(I,7))
               ELSE
                  RADIUS=RESULT(I,4)*PSIZE
               END IF

*            Set the parameter value required for the current
*            value of WHATD.
               IF (WHATD.EQ.'S') BRIGHT=RESULT(I,5)
               IF (WHATD.EQ.'B') BRIGHT=RESULT(I,5)
               IF (WHATD.EQ.'C') BRIGHT=RESULT(I,5)
               IF (WHATD.EQ.'E') BRIGHT=RESULT(I,7)
               IF (WHATD.EQ.'P') THEN
                  IF (ANGCON) THEN
                     BRIGHT=RESULT(I,6)+ANGOFF
                  ELSE
                     BRIGHT=-RESULT(I,6)+ANGOFF
                  END IF
               END IF
               IF (WHATD.EQ.'X') BRIGHT=RESULT(I,1)
               IF (WHATD.EQ.'Y') BRIGHT=RESULT(I,2)

*            Do the same in the case of Fourier descriptors.
               IF (WHATD.EQ.'FS1') BRIGHT=RESULT(I,10)
               IF (WHATD.EQ.'FC1') BRIGHT=RESULT(I,11)
               IF (WHATD.EQ.'FS2') BRIGHT=RESULT(I,12)
               IF (WHATD.EQ.'FC2') BRIGHT=RESULT(I,13)
               IF (WHATD.EQ.'FS3') BRIGHT=RESULT(I,14)
               IF (WHATD.EQ.'FC3') BRIGHT=RESULT(I,15)
               IF (WHATD.EQ.'FS4') BRIGHT=RESULT(I,16)
               IF (WHATD.EQ.'FC4') BRIGHT=RESULT(I,17)
             
*            Transfer the required values to the conversion subroutine.
               CALL GRA1_CONV(RADISP,WHATD,SIGMA,ZEROP,FLAG,
     :                        RADIUS,BRIGHT,STATUS)    

*            Use the results if they were legal.
               IF (FLAG.EQ.0) THEN
                  IF (RADIUS.LT.LOWR) LOWR=RADIUS
                  IF (RADIUS.GT.HIGHR) HIGHR=RADIUS
                  IF (BRIGHT.LT.LOWP) LOWP=BRIGHT
                  IF (BRIGHT.GT.HIGHP) HIGHP=BRIGHT
               END IF
                       
 30      CONTINUE

*      Set up the display using the limits calculated. Limits are
*      defined by the values of WHATD and RADISP. 
         LOWP2=LOWP
         HIGHP2=HIGHP
         IF (WHATD.EQ.'S') THEN
            HIGHP=HIGHP+.25
            LOWP=LOWP-.25
            TEMP=HIGHP
            HIGHP=LOWP
            LOWP=TEMP
         ELSE
            IF (HIGHP.GT.0.0) THEN
               HIGHP=HIGHP*1.10
            ELSE
               HIGHP=HIGHP*0.9
            END IF
            IF (LOWP.GT.0.0) THEN 
               LOWP=LOWP*0.9
            ELSE
               LOWP=LOWP*1.1
            END IF
         END IF
         HIGHR=HIGHR*1.05
         CALL PGWINDOW(LOWR,HIGHR,LOWP,HIGHP)
   
*      Inquire what the viewport size is.
         CALL PGQVP(1,X1,X2,Y1,Y2)

*      Reset the lettering size if necessary.
         IF (((Y2-Y1).LT.1.0).OR.((X2-X1).LT.1.0)) THEN
            IF ((Y2-Y1).LT.(X2-X1)) THEN 
               TEMP=(Y2-Y1)/2.
            ELSE
               TEMP=(X2-X1)/2.
            END IF
            CALL PGSCH(TEMP)
         END IF

*      Set up the labelling marks on the axes.
         CALL PGBOX('ABCGNST',0.0,0,'ABCGNST',0.0,0)
    
*      Set up values for and display the labels for the graph.

*      Set up the Y axis labels.

*      Normal parameters.
         IF (WHATD.EQ.'B') LABELY='(I-BACK)/Sigma'
         IF (WHATD.EQ.'C') LABELY='Counts'
         IF (WHATD.EQ.'E') LABELY='Ellipticity'
         IF (WHATD.EQ.'P') LABELY='Position angle'
         IF (WHATD.EQ.'X') LABELY='X co-ordinate'
         IF (WHATD.EQ.'Y') LABELY='Y co-ordinate'
         IF (WHATD.EQ.'S') LABELY='Surface Brightness Zp-2.5Log(I)'

*      Fourier descriptors. 
         IF (WHATD.EQ.'FS1') LABELY='Sine(theta)'
         IF (WHATD.EQ.'FC1') LABELY='Cos(theta)'
         IF (WHATD.EQ.'FS2') LABELY='Sine(2xtheta)'
         IF (WHATD.EQ.'FC2') LABELY='Cos(2xtheta)'
         IF (WHATD.EQ.'FS3') LABELY='Sine(3xtheta)'
         IF (WHATD.EQ.'FC3') LABELY='Cos(3xtheta)'
         IF (WHATD.EQ.'FS4') LABELY='Sine(4xtheta)'
         IF (WHATD.EQ.'FC4') LABELY='Cos(4xtheta)'

*      Setup the X axis labels.
         IF ((FTYPE.EQ.'ELF').OR.(FTYPE.EQ.'ELP')) THEN
            IF (RADISP.EQ.'R') LABELX='Radius(*) (arc seconds)'
            IF (RADISP.EQ.'Q') LABELX='Power Radius(*) (**0.25)'
            IF (RADISP.EQ.'L') LABELX='Logarithmic Radius(*)'         
            IF (RADISP.EQ.'S') LABELX='Radius(*) Squared'
         ELSE
            IF (RADISP.EQ.'R') LABELX='Radius (arc seconds)'
            IF (RADISP.EQ.'Q') LABELX='Power Radius (**0.25)'
            IF (RADISP.EQ.'L') LABELX='Logarithmic Radius'         
            IF (RADISP.EQ.'S') LABELX='Radius Squared'
         END IF

*      Display the labels of the graph.
         CALL PGLABEL(LABELX,LABELY,'GALAXY PROFILE')

*      Display the data points in the RADISP mode required.
         DO 40 I=1,POINTS
        
*            Set up a flag. If greater than 0 then an error was found.
*            Display is then stopped for the current radius value.
               FLAG=0
               
*            Convert the radius data to the right form.
               IF ((FTYPE.EQ.'ELF').OR.(FTYPE.EQ.'ELP')) THEN
                  RADIUS=PSIZE*SQRT(RESULT(I,4)*RESULT(I,4)*RESULT(I,7))
               ELSE
                  RADIUS=RESULT(I,4)*PSIZE
               END IF

*            Set the parameter value required for the current
*            value of WHATD.
               IF (WHATD.EQ.'S') BRIGHT=RESULT(I,5)
               IF (WHATD.EQ.'B') BRIGHT=RESULT(I,5)
               IF (WHATD.EQ.'C') BRIGHT=RESULT(I,5)
               IF (WHATD.EQ.'E') BRIGHT=RESULT(I,7)
               IF (WHATD.EQ.'P') THEN
                  IF (ANGCON) THEN
                     BRIGHT=RESULT(I,6)+ANGOFF
                  ELSE
                     BRIGHT=-RESULT(I,6)+ANGOFF
                  END IF
               END IF
               IF (WHATD.EQ.'X') BRIGHT=RESULT(I,1)
               IF (WHATD.EQ.'Y') BRIGHT=RESULT(I,2)

*            Do the same in the case of Fourier descriptors.
               IF (WHATD.EQ.'FS1') BRIGHT=RESULT(I,10)
               IF (WHATD.EQ.'FC1') BRIGHT=RESULT(I,11)
               IF (WHATD.EQ.'FS2') BRIGHT=RESULT(I,12)
               IF (WHATD.EQ.'FC2') BRIGHT=RESULT(I,13)
               IF (WHATD.EQ.'FS3') BRIGHT=RESULT(I,14)
               IF (WHATD.EQ.'FC3') BRIGHT=RESULT(I,15)
               IF (WHATD.EQ.'FS4') BRIGHT=RESULT(I,16)
               IF (WHATD.EQ.'FC4') BRIGHT=RESULT(I,17)

*            Transfer the required values to the conversion subroutine.
               CALL GRA1_CONV(RADISP,WHATD,SIGMA,ZEROP,FLAG,
     :                        RADIUS,BRIGHT,STATUS)    

*            Display the result if it is possible. An arrow is displayed
*            indicating the radius at which a value has occured for which
*            the Y co-ordinate cannot be calculated.
*            If FLAG=0 then both x and y values may be displayed.
*            If FLAG=1 then the Y axis value cannot be calculated.
*            IF FLAG=-1 the X axis value could not be calculated so
*            no display is possible.
               IF (FLAG.NE.-1) THEN 

                  IF ((RADIUS.GE.LOWR).AND.(RADIUS.LE.HIGHR)) THEN 
                     IF (FLAG.EQ.0) THEN
*                     Display radius and brightness value.
                        IF ((BRIGHT.GE.LOWP2).AND.
     :                       (BRIGHT.LE.HIGHP2)) THEN
                           RAD(1)=RADIUS
                           MEAN(1)=BRIGHT
                           CALL PGPOINT(1,RAD,MEAN,4)
                        END IF
                     ELSE
*                     Display the radius value only.
                        IF ((BRIGHT.GE.LOWP2).AND.
     :                       (BRIGHT.LE.HIGHP2)) THEN
                           RAD(1)=RADIUS
                           MEAN(1)=LOWP2+(HIGHP2-LOWP2)*.05
                           CALL PGPOINT(1,RAD,MEAN,31)
                        END IF
                     END IF

                  END IF
               
               END IF
         
 40      CONTINUE

      END IF

*  show both spiral and elliptical fits.
      IF (GMODE.EQ.2) THEN

*      Find biggest radius to be considered (use semi major axis).
         BIGR=0.0
         DO 100 J=1,POINTS
            IF (RESULT(J,4).GT.BIGR) BIGR=RESULT(J,4)
 100     CONTINUE
         BIGR=BIGR*1.10

*      Display the fits at reasonable resolution.
         DO 50 I=1,500
            
*         Calculate the fit values and display.

*         Find the fit value at each radius value.  
            X=BIGR/500.*REAL(I)
                        
            DO 60 J=1,2

*            Calculate brightness value at this radius.
               IF (J.EQ.1) THEN               
                  Y(J)=GRAD(J)*X+CONS(J)
               ELSE
                  Y(J)=GRAD(J)*(X**(0.25))+CONS(J)
               END IF

 60         CONTINUE

*         Calculate radius value on current display.
            IF (RADISP.EQ.'R') X=X
            IF (RADISP.EQ.'Q') X=X**(0.25)
            IF (RADISP.EQ.'L') X=LOG10(X)
            IF (RADISP.EQ.'S') X=X*X

*         Convert the intensity value to sigma or surface brightness.
            DO 65 J=1,2    

*            Convert to brightness the current display.
               IF (WHATD.EQ.'B') Y(J)=(10.**Y(J))/SIGMA
               IF (WHATD.EQ.'S') Y(J)=ZEROP-2.5*Y(J)
               IF (WHATD.EQ.'C') Y(J)=10.**Y(J)
  
*            Display.
               RAD(1)=X
               MEAN(1)=Y(J)
               CALL PGPOINT(1,RAD,MEAN,1+(J-1)*19)

 65         CONTINUE        

 50      CONTINUE
     
      END IF


 9999 CONTINUE

      END 


      SUBROUTINE GRA1_LINRE(POINTS,LOWLIM,FTYPE,RRANGE,LOR,HIR,
     :                      RESULT,PSIZE,GRAD,CONS,SLEN,
     :                      NUMBP,REG,STATUS)
*+
*  Name:
*     GRA1_LINRE

*  Purpose:
*     Determines a least squares linear fit for data in arrays X and Y. 
*     This fit is used to calculate value for the scale length of the
*     object if it was a spiral galaxy or elliptical galaxy.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL GRA1_LINRE(POINTS,LOWLIM,FTYPE,RRANGE,LOR,HIR,RESULT,
*                     PSIZE,BACK,CONS,SLEN,NUMBP,REG,STATUS)
                     
*  Description:
*     Uses a normal least squares method to determine the coefficients
*     of a linear fit to the contents of arrays X and Y.

*  Arguments:
*     POINTS = INTEGER (Given)
*        Number of profiles available for the current galaxy.
*     LOWLIM = REAL (Given)
*        Number of arc seconds below which points are not included in 
*        the profile calculation of the scale lengths.
*     FTYPE *(3) = CHARACTER (Returned)
*        The record type found in the results file. ELF=ELLFOU,
*        SEC=SECTOR and ELP=ELLPRO.
*     RRANGE = LOGICAL (Given)
*        Are the data points used in the analysis to be selected automatically?
*     LOR = REAL (Given)
*        The radius below which a data point should not be included
*        in the linear regression. Units arc seconds.
*     HIR = REAL (Given)
*        The radius above which a data point should not be included
*        in the linear regression. Units arc seconds.
*     RESULT(GRA__RESUL) = REAL (Given)
*        The summation of pixels counts at a given radius. Units counts.
*     PSIZE = REAL (Given)
*        Image pixel size in arc secs.
*     GRAD(2) = REAL (Returned)
*        The gradient values for the linear fit.
*     CONS(2) = REAL (Returned)
*        The constant values for the linear fit.
*     SLEN(2) = REAL (Returned)
*        The scale lengths of the two fits i.e. spiral and elliptical.
*        Units arc seconds.
*     NUMBP(2) = INTEGER (Returned)
*        The number of data points used during the linear regression.
*     REG(2) = REAL (Returned)
*        The square of the linear correlation coefficient.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     12-DEC-1995 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE

*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'PRM_PAR'               ! PRIMDAT primitive data constants
      INCLUDE 'gra_par'               ! GRAPHS constants
                     
*  Arguments Given:
      CHARACTER *(3) FTYPE            ! File header type
      LOGICAL RRANGE                  ! Select data points interactively?
      INTEGER POINTS                  ! Number of profiles available
      REAL HIR                        ! The upper limit of radius requested  
      REAL LOR                        ! The lower limit of radius requested
      REAL LOWLIM                     ! The lower radius limit
      REAL PSIZE                      ! Size of the pixels in arc secs
      REAL RESULT(GRA__RESUL,17)      ! Summed counts for all pixels at a
                                      ! given radius

*  Arguments Returned:
      INTEGER NUMBP(2)                ! Number of data points used
      REAL CONS(2)                    ! Constant of linear equation
      REAL GRAD(2)                    ! Gradient of linear equation     
      REAL REG(2)                     ! Regression coefficient squared 
      REAL SLEN(2)                    ! Scale length of the galaxy

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local Variables: 
      INTEGER FLAG                    ! Problems with the regresssion flag
      INTEGER I                       ! Loop variable
      INTEGER LLI                     ! Lowest useable pixel index
      INTEGER TYPE                    ! Defines the data transform type
      REAL LIMIT                      ! Number of pixels = lowlim
      REAL MEANELL                    ! Mean ellipticity value
      REAL MNVX                       ! Mean value of X1 array
      REAL MNVY                       ! Mean value of Y1 array
      REAL NUMB                       ! Number of data points
      REAL SUMX                       ! Sum of X1 array
      REAL SUMY                       ! Sum of Y1 array
      REAL TOT(7)                     ! Various total and summations used 
                                      ! later.
      REAL TOTELL                     ! Total of ellipticity values
      REAL X                          ! Transformed raw data radius value
      REAL Y                          ! Transformed raw data pixel count



*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN
                     
*    Set up the automatic values for LOR and HIR radius limits.
      IF (RRANGE) THEN

*      Assign default values.
         LOR=RESULT(1,4)
         HIR=RESULT(POINTS,4)

*      Find the number of pixels corresponding to LOWLIM arc secs
         LIMIT=LOWLIM/REAL(PSIZE)
         LLI=POINTS
         DO 100 I=POINTS,1,-1
            IF (RESULT(I,4).GE.LIMIT) LLI=I
 100     CONTINUE 

*      Deal with a very small number of points.    
         IF (POINTS.LT.4) THEN
            LOR=RESULT(1,4)
            HIR=RESULT(POINTS,4)
         END IF

*      Sufficient data points to allow the central limit to be imposed but not 
*      the outer limit value.
         IF (POINTS-LLI+1.EQ.3) THEN
            LOR=RESULT(LLI,4)
            HIR=RESULT(POINTS,4)
         END IF

*      Sufficient data points to allow the central limit to be imposed and
*      also the outermost point to be ignored.
         IF (POINTS-LLI+1.GT.3) THEN 
            LOR=RESULT(LLI,4)
            HIR=RESULT(POINTS-1,4)
         END IF

*      Find mean ellipticity value.
         TOTELL=0.0
         DO 20 I=1,POINTS
            TOTELL=TOTELL+RESULT(I,7)*RESULT(I,7)
 20      CONTINUE
         MEANELL=SQRT(TOTELL/REAL(POINTS))

*      Employ mean vlues of ellipticity to give radii limit modifications.
         LOR=PSIZE*SQRT(LOR*LOR*MEANELL)
         HIR=PSIZE*HIR

      END IF
    
*   Find the mean value of x and the sums of the x and y arrays.

*   Set an error flag.
      FLAG=0

*   Set the line fit values to zero.
      DO 10 I=1,2 
         GRAD(I)=0.0
         CONS(I)=0.0
 10   CONTINUE

*   Calculate the linear regression for each of the galaxy types.
      DO 200 TYPE=1,2

*      Setup the initial values for the sums and counter.
         SUMX=0.0
         SUMY=0.0
         MNVX=0.0
         MNVY=0.0

         NUMBP(TYPE)=0

*      Loop through all the data points used.
         DO 500 I=1,POINTS

*         Calculate the radius.
            IF ((FTYPE.EQ.'ELF').OR.(FTYPE.EQ.'ELP')) THEN
               X=PSIZE*SQRT(RESULT(I,4)*RESULT(I,4)*RESULT(I,7))
            ELSE
               X=RESULT(I,4)*PSIZE
            END IF
            Y=LOG10(RESULT(I,5))
       
*         Only use the value if it is within the requested limits.
            IF ((X.GE.LOR).AND.(X.LE.HIR)) THEN

*            Increment the points used counter.
               NUMBP(TYPE)=NUMBP(TYPE)+1

*            Convert radius to form required for spiral galaxy or
*            for an elliptical galaxy.
               IF (TYPE.EQ.2) X=X**(0.25)

*            Sum the X and Y values found (radius and brightness).
               SUMX=SUMX+X
               SUMY=SUMY+Y

            END IF

 500     CONTINUE

*      Raise an error flag since the number of data points was too low.
         IF (NUMBP(TYPE).LT.2) THEN

            FLAG=1
            GOTO 200

         ELSE

*         Produce the mean value of X and a real representation of the number
*         of data points that contributed to the current mean.
            NUMB=REAL(NUMBP(TYPE))
            MNVX=SUMX/NUMB
            MNVY=SUMY/NUMB

         END IF

*      Calculate the squared sum of (x-xmean) 
*      and thereby the gradient and constant terms in the equation.
     
*      Set up the initial values for the sums.
         DO 99 I=1,7
            TOT(I)=0.0
 99      CONTINUE

*      Loop through all the data points used.
         DO 510 I=1,POINTS

*         Calculate the radius and log of the count.
            IF ((FTYPE.EQ.'ELF').OR.(FTYPE.EQ.'ELP')) THEN
               X=PSIZE*SQRT(RESULT(I,4)*RESULT(I,4)*RESULT(I,7))
            ELSE
               X=RESULT(I,4)*PSIZE
            END IF
            Y=LOG10(RESULT(I,5))
      
*         Check that the radius is within the range requested.
            IF ((X.GE.LOR).AND.(X.LE.HIR)) THEN
              
*            Generate the radius and brightness values.              
               IF (TYPE.EQ.2) X=X**(0.25)
                    
*            Calculate X deviations from the mean.
               TOT(1)=X-MNVX
               TOT(2)=TOT(2)+TOT(1)*TOT(1)

*            Calculate Y deviations from the mean.
               TOT(4)=Y-MNVY

*            Needed to calculate gradient later.
               TOT(3)=TOT(3)+TOT(1)*Y
              
*            Needed to calculate correlation.
               TOT(5)=TOT(5)+TOT(1)*TOT(1)
               TOT(6)=TOT(6)+TOT(4)*TOT(4)
               TOT(7)=TOT(7)+TOT(1)*TOT(4)

            END IF

 510     CONTINUE

*      Check that more than one value of pixel count was found.
         IF (ABS(TOT(1)).GT.GRA__VSMAL) THEN

*         Calculate the linear regression co-efficients.

            GRAD(TYPE)=TOT(3)/TOT(2)
            CONS(TYPE)=(SUMY-SUMX*GRAD(TYPE))/NUMB

*         Check that the gradient is physically reasonable.
            IF (GRAD(TYPE).LT.0.0) THEN

*            Calculate the scale length.
               IF ((TYPE.EQ.1).AND.(GRAD(TYPE).NE.0.0)) THEN
                  SLEN(TYPE)=-LOG10(EXP(1.0))/GRAD(TYPE)
               ELSE
                  SLEN(TYPE)=LOG10(EXP(1.0))/((-GRAD(TYPE))**(4.0))  
               END IF

*            Calculate regression.
               REG(TYPE)=TOT(7)/SQRT(TOT(5))/SQRT(TOT(6))
               REG(TYPE)=REG(TYPE)*REG(TYPE)

            ELSE

*            Set the error flag since the gradient was zero or greater.
               FLAG=3

            END IF
     
         ELSE

*      Raise an error flag if all the pixels had the same value.
            FLAG=2

         END IF
        
 200  CONTINUE

*   Display the reason that the linear regression failed.
      IF (FLAG.GT.0) THEN

         CALL MSG_BLANK(STATUS)
         CALL MSG_OUT(' ','WARNING!!!',STATUS)

*      Too few data points found for a result to be calculated.
         IF (FLAG.EQ.1) THEN
            CALL MSG_OUT(' ','Not enough data points '//
     :                       'were selected.',STATUS) 
         END IF

*      Not possible to calculate a meaningful slope.
         IF (FLAG.EQ.2) THEN
            CALL MSG_OUT(' ','The points selected had a '//
     :                       'single value.',STATUS) 
         END IF

*      Negative or zero scale length.
         IF (FLAG.EQ.3) THEN
            CALL MSG_OUT(' ','The scale length calculated '//
     :                       'was not physically sensible.',STATUS) 
         END IF

         CALL MSG_BLANK(STATUS)

      END IF

 9999 CONTINUE
     
      END       
       

      SUBROUTINE GRA1_TEXTD(FLAG,POINTS,XCO,YCO,CURCO,BACK,SIGMA,CONS,
     :                      GRAD,PSIZE,NUMBP,ZEROP,SLEN,
     :                      LOR,HIR,REG,STATUS)
*+
*  Name:
*     GRA1_TEXTD

*  Purpose:
*     Displays the galaxy profiling results in text format.
      
*  Language:
*     Starlink Fortran 77

*  Invocation:
*      CALL GRA1_TEXTD(FLAG,POINTS,XCO,YCO,CURCO,BACK,SIGMA,CONS,
*                      GRAD,PSIZE,NUMBP,ZEROP,SLEN,
*                      LOR,HIR,REG,STATUS)    

*  Description:
*      Displays the text output from the program. This consists of
*      values for the scale lengths, brightness at the origin, extrapolated
*      central brightnesses, the number of data points used, the range
*      over which data points were used in the 'fit' and also the origin
*      image indices used.

*  Arguments:               
*     FLAG = INTEGER (Given)
*        Was a value found for the central pixel flag.                    
*     POINTS = INTEGER (Given)
*        Number of data points available.
*     XCO = REAL (Given)
*        The X index of the origin used. Units pixels.
*     YCO = REAL (Given)
*        The Y index of the origin used. Units pixels.
*     CURCO *(80) = CHARACTER (Given)
*        The coordinates in the Current frame of the origin used.
*     BACK = REAL (Given)
*        Background value found. Units counts.
*     SIGMA = REAL (Given)
*        Standard deviation of the background value. Units counts.
*     CONS = REAL (Given)
*        Constant terms of the linear fits made on the data selected.
*     GRAD = REAL (Given)
*        Gradinet of the fits made on the data selected.
*     PSIZE = REAL (Given)
*        The image pixels size. Units arc secs.
*     NUMBP(2) = INTEGER (Given)
*        The number of data points used when calculating the scale
*        length values.
*     ZEROP = REAL (Given)
*        Zero point of the maginitude scale. Units magnitudes.
*     SLEN(2) = REAL (Given)
*        Scale lengths of the galaxy/object in the case of a spiral
*        or an elliptical. Units arc secs.
*     LOR = REAL (Given)
*        Low limit of the radius range from which data was taken.
*        Units arc seconds.
*     HIR = REAL (Given)
*        High limit of the radius range from which data was taken.
*        Units arc seconds.
*     REG(2) = REAL (Given)
*        Linear correlation coefficient squared.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     02-FEB-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants

*  Arguments Given:                              
      CHARACTER *(80) CURCO           ! Current coordinates of origin
      INTEGER NUMBP(2)                ! Number of data points used for the
                                      ! radius/brightness fits
      INTEGER FLAG                    ! Was the central pixel value found?
      INTEGER POINTS
      REAL BACK                       ! Background count value
      REAL CONS(2)                    ! The constant term of the fits
                                      ! to radius versus brightness
      REAL GRAD(2)                    ! The gradient term of the fits
                                      ! to radius versus brightness
      REAL HIR                        ! Upper limit of radius values used
      REAL LOR                        ! Lower limit of radius values used 
      REAL PSIZE                      ! The size of each pixel in
                                      ! arc seconds
      REAL REG(2)                     ! Regression coefficient squared 
      REAL SIGMA                      ! Standard deviation of the background
      REAL SLEN(2)                    ! Scale length values from the two  
                                      ! fits i.e. spiral and elliptical
      REAL XCO                        ! X index of the origin
      REAL YCO                        ! Y index of the origin
      REAL ZEROP                      ! Zero point of the magnitude scale
      
*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variables:
      REAL VALUE                      ! Temporary variable
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN
     
*  Display the extent of the data set available, the size
*  in arc seconds this represents.     
      CALL MSG_BLANK(STATUS)
      CALL MSG_FMTI('VALUE','I5',POINTS)
      CALL MSG_OUT(' ','Number of data points:   ^VALUE ',STATUS)

*  Display the range in arc seconds of the data points used.
      CALL MSG_FMTR('VALUE','F7.2',LOR)
      CALL MSG_FMTR('VALUE1','F7.2',HIR)
      CALL MSG_OUT(' ','Range used (arc sec):  ^VALUE,^VALUE1',
     :             STATUS)

*  Display X and Y Base frame co-ordinates.
      CALL MSG_FMTR('VALUE','F7.2',XCO)
      CALL MSG_FMTR('VALUE1','F7.2',YCO)
      CALL MSG_OUT(' ','X and Y co-ordinates (Base): ^VALUE ^VALUE1 ',
     :                STATUS)

*  Display X and Y Current frame co-ordinates.
      CALL MSG_SETC('VALUE',CURCO)
      CALL MSG_OUT(' ','X and Y co-ordinates (Current): ^VALUE ',STATUS)
   

*  Display 'fit' information.

*  Spiral galaxy model.
      CALL MSG_FMTI('VALUE','I5',NUMBP(1))
      CALL MSG_OUT(' ','Points used for spiral calculation:     '//
     :             '^VALUE',STATUS)

      CALL MSG_FMTR('VALUE','F8.4',SLEN(1))
      CALL MSG_OUT(' ','Scale length spiral:                 '//
     :             '^VALUE',STATUS)

*  Elliptical galaxy model.
      CALL MSG_FMTI('VALUE','I5',NUMBP(2))
      CALL MSG_OUT(' ','Points used for elliptical calculation.:'//
     :               '^VALUE',STATUS)

      CALL MSG_FMTR('VALUE','F8.5',SLEN(2))
      CALL MSG_OUT(' ','Scale length elliptical:             '//
     :             '^VALUE',STATUS)


*  Display correlation coefficient information.

*  Spiral galaxy model.
      CALL MSG_FMTR('VALUE','F5.3',REG(1))
      CALL MSG_OUT(' ','Spiral LCC squared:             '//
     :             '^VALUE',STATUS)

*  Elliptical galaxy model.
      CALL MSG_FMTR('VALUE','F5.3',REG(2))
      CALL MSG_OUT(' ','Ellip. LCC squared:             '//
     :             '^VALUE',STATUS)


*  Extrapolated central brightnesses (based on the fits).

*  Spiral galaxy.
      VALUE=ZEROP-2.5*CONS(1)
      CALL MSG_FMTR('VALUE','F7.1',VALUE)
      CALL MSG_OUT(' ','Extrapolated CSB spiral:           '//
     :             '^VALUE',STATUS)

*   Elliptical galaxy.
      VALUE=ZEROP-2.5*CONS(2)
      CALL MSG_FMTR('VALUE','F7.1',VALUE)
      CALL MSG_OUT(' ','Extrapolated CSB elliptical:       '//
     :             '^VALUE',STATUS)

 9999 CONTINUE

      END 


      SUBROUTINE GRA1_TEXTO(MODE,FILEN,REG,XCO,YCO,CURCO,SLEN,
     :                      CONS,ZEROP,OPENF,FIOD2,EXCLAIM,STATUS)
*+
*  Name:
*     GRA1_TEXTO

*  Purpose:
*     Puts the most recent galaxy 'fit' results into a text format file.
      
*  Language:
*     Starlink Fortran 77

*  Invocation:
*      CALL GRA1_TEXTO(MODE,FILEN,REG,XCO,YCO,CURCO,SLEN,
*                      CONS,ZEROP,OPENF,FIOD2,EXCLAIM,STATUS)    

*  Description:
*     Creates a text file (if required) and places in it data from the
*     most recent galaxy profile/fit generated. The output values for
*     radius are measured in pixels.

*  Arguments:               
*     MODE = INTEGER (Given)
*        MODE=0 Open the text output file.
*        MODE=1 Write the file header.
*        MODE=2 Write the scale length values.
*        MODE=3 Clode the output text file. 
*     FILEN *(80) = CHARACTER (Given)
*        Name of the text file being read. 
*     REG(2) = REAL (Given)
*        Linear correlation coefficient squared.
*     XCO = REAL (Given)
*        The X coordinate of the origin used (Base frame).
*     YCO = REAL (Given)
*        The Y coordinate of the origin used (Base frame).
*     CURCO *(80) = CHARACTER (Given)
*        Coordinates of the origin used (Current frame).
*     SLEN(2) = REAL (Given)
*        Scale lengths of the galaxy/object in the case of a spiral
*        or an elliptical. Units arc secs.
*     CONS(2) = REAL (Given)
*        The constant term of the equation 'fitted' to
*        the galaxy profile. See GRA1_LINRE subroutine.
*     ZEROP = REAL (Given)
*        Zero point of the magnitude scale.
*     OPENF = LOGICAL (Given and Returned)
*        Was the text output file opened properly?
*     FIOD2 = INTEGER (Given and Returned)
*        File identifier.
*     EXCLAIM = LOGICAL (Given and Returned)
*        Was the text output file named '!'
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     12-MAR-1993 (GJP)
*     (Original version)
*     10-JAN-1997 (GJP)
*     Modified output format to cope with big images.

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants
      INCLUDE 'gra_par'               ! GRAPHS constants
      INCLUDE 'MSG_PAR'               ! MSG constants

*  Arguments Given:         
      CHARACTER *(80) CURCO           ! Current coordinates of galaxy
      CHARACTER *(80) FILEN           ! Image on which the galaxy was found
      INTEGER MODE                    ! Write a header or data?
      REAL CONS(2)                    ! The constant term of the fits
                                      ! to radius versus brightness
      REAL REG(2)                     ! LCC squared
      REAL SLEN(2)                    ! Scale length values from the two  
                                      ! fits i.e. spiral and elliptical
      REAL XCO                        ! X index of the origin
      REAL YCO                        ! Y index of the origin
      REAL ZEROP                      ! Magnitude scale zero point

*  Arguments Given and Returned:
      LOGICAL EXCLAIM                 ! Was file name a '!'?
      LOGICAL OPENF                   ! Was the output file created okay?      
      INTEGER FIOD2                   ! File identifier

*  Status:     
      INTEGER STATUS                  ! Global status

*  Local variables:
      CHARACTER *(80) BUFFER          ! Temporary storage
      CHARACTER *(120) LINE           ! FIO line output length
      CHARACTER *(MSG__SZMSG) TEMPO1  ! Temporary storage
      CHARACTER *(MSG__SZMSG) TEMPO2  ! Temporary storage
      CHARACTER *(80) WORDS(3)        ! Words in string
      INTEGER NCHAR                   ! Length of output string
      INTEGER NWRDS                   ! Number of words in string
      INTEGER START(3)                ! Start positions of words
      INTEGER STOP(3)                 ! End positions of words
      REAL VALUE                      ! Temporary storage
*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN

*   Determine the output text file name. If the file name chosen fails, 
*   the user is reprompted
      IF (MODE.EQ.0) THEN 
         CALL MSG_BLANK(STATUS)
         OPENF=.FALSE.             
         EXCLAIM=.FALSE.   
         CALL ERR_MARK
         DO WHILE((.NOT.OPENF).AND.(.NOT.EXCLAIM)
     :             .AND.(STATUS.EQ.SAI__OK))
            CALL GRA1_AIF_ASFIO('OUT','WRITE','LIST',120,FIOD2,OPENF,
     :                      EXCLAIM,STATUS)
            IF ((.NOT.OPENF).AND.(.NOT.EXCLAIM)) THEN
               CALL ERR_REP(' ','Bad file name.',STATUS)
               CALL ERR_REP(' ','For no file, type !',STATUS)
               CALL ERR_ANNUL(STATUS)
            END IF
         END DO
         CALL ERR_RLSE
         IF (STATUS.NE.SAI__OK) GOTO 9999

*      Inform the user if a difficulty was encountered and that an
*      an output file will not be used. 
         IF (EXCLAIM) THEN  
            CALL MSG_BLANK(STATUS)
            CALL MSG_OUT(' ','WARNING!!!',STATUS)
            CALL MSG_OUT(' ','No output text file created.',STATUS)
            CALL MSG_BLANK(STATUS)
            GOTO 9999
         END IF

      END IF

*   Inform the user if a difficulty was encountered and that an
*   an output file will not be used. Otherwise add values to the 
*   output file.
      IF ((OPENF).AND.(STATUS.EQ.SAI__OK).AND.(MODE.EQ.1)) THEN  

*      Output a heading.
         NCHAR=0
         CALL CHR_PUTC('## ESP GRAPHS V1.1 OUTPUT FILE ',LINE,NCHAR)
         CALL FIO_WRITE(FIOD2,LINE(:NCHAR),STATUS)
         NCHAR=0
         CALL CHR_PUTC('##',LINE,NCHAR)
         CALL FIO_WRITE(FIOD2,LINE(:NCHAR),STATUS)

*      Output the file name.
         NCHAR=0
         CALL CHR_PUTC('## Filename: ',LINE,NCHAR)
         CALL FIO_WRITE(FIOD2,LINE(:NCHAR),STATUS)
         NCHAR=0
         CALL CHR_PUTC(FILEN,LINE,NCHAR)
         CALL FIO_WRITE(FIOD2,LINE(:NCHAR),STATUS)

*      Output a data description.
         NCHAR=0
         CALL CHR_PUTC('##  X         Y         Xc        Yc'//
     :   '       SLenS      SLenE    SCSB  ECSB   LCCS  LCCE',
     :   LINE,NCHAR)
         CALL FIO_WRITE(FIOD2,LINE(1:NCHAR),STATUS)

      END IF

*   Output scale length results and co-ordinates.
      IF ((OPENF).AND.(STATUS.EQ.SAI__OK).AND.(MODE.EQ.2)) THEN   
     
*      Format X and Y Base frame co-ordinates.
         CALL MSG_FMTR('VALUE1','F9.2',XCO)
         CALL MSG_FMTR('VALUE2','F9.2',YCO)
      
*      Format X and Y Current frame co-ordinates.
         CALL CHR_DCWRD(CURCO,3,NWRDS,START,STOP,WORDS,STATUS)
         IF (NWRDS.EQ.2.AND.STOP(1)-START(1).LT.9.AND.
     :       STOP(2)-START(2).LT.9) THEN
            BUFFER=' '
            BUFFER(9-STOP(1)+START(1):)=WORDS(1)
            BUFFER(19-STOP(2)+START(2):)=WORDS(2)
            CALL MSG_SETC('VALUE3',BUFFER)
         ELSE
            CALL MSG_SETC('VALUE3',CURCO)
         END IF

*      Format the scale length values.
         IF(SLEN(1).GT.99.999) SLEN(1)=99.999
         IF(SLEN(2).GT.99.999) SLEN(2)=99.999
         CALL MSG_FMTR('VALUE5','F10.4',SLEN(1))
         CALL MSG_FMTR('VALUE6','F10.4',SLEN(2))

*      Format spiral galaxy csb.
         VALUE=ZEROP-2.5*CONS(1)
         CALL MSG_FMTR('VALUE7','F5.1',VALUE)

*      Format elliptical galaxy csb.
         VALUE=ZEROP-2.5*CONS(2)
         CALL MSG_FMTR('VALUE8','F5.1',VALUE)

*      Regression coefficients.
         CALL MSG_FMTR('VALUE9', 'F5.3',REG(1))
         CALL MSG_FMTR('VALUE10','F5.3',REG(2))


*      Output the co-ordinates, scale lengths and extrapolated CSB.
         TEMPO1='^VALUE1 ^VALUE2 ^VALUE3 ^VALUE5 ^VALUE6'//
     :          ' ^VALUE7 ^VALUE8 ^VALUE9 ^VALUE10'
         CALL MSG_LOAD(' ',TEMPO1,TEMPO2,NCHAR,STATUS)
         CALL FIO_WRITE(FIOD2,TEMPO2(1:NCHAR),STATUS)

      END IF

*   Close file.
      IF ((OPENF).AND.(STATUS.EQ.SAI__OK).AND.(MODE.EQ.3)) THEN   
         CALL FIO_CLOSE(FIOD2,STATUS)
      END IF

 9999 CONTINUE

      END 



      SUBROUTINE GRA1_UNCON(RADISP,LOWR,HIGHR,STATUS)         
*+
*  Name:
*     GRA1_UNCON

*  Purpose:
*     Takes the value returned by the cursor for the radius required and
*     converts it to linear radius.
      
*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL GRA1_UNCON(RADISP,LOWR,HIGHR,STATUS)         

*  Description:
*     Take the values chosen by the user (using a cursor) from the graph
*     plot of raw data and converts it from the transform value i.e. log,
*     squared or quarter power to linear values.
*     
*     The value is modified to ignore values for radius beyond the left hand
*     edge of the plot.

*  Arguments:                                
*     RADISP = CHAR (Given)
*        Character variable denoting the format used for transforming 
*        the radius value on the plotted graph.
*        R=Linear Q=Quarter power, L=Logarithmic and S=Squared.
*     LOWR = REAL (Given and Returned)
*        The low value for transformed radius derived from the graph using
*        a cursor.
*     HIGHR = REAL (Given and Returned)
*        The high value for transformed radius derived from the graph using
*        a cursor.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     GJP: Grant Privett (STARLINK)

*  History:
*     23-FEB-1993 (GJP)
*     (Original version)

*  Bugs:
*     None known.

*-

*  Type Definitions:                  ! No implicit typing
      IMPLICIT NONE
                                                                        
*  Global Constants:
      INCLUDE 'SAE_PAR'               ! Standard SAE constants

*  Arguments Given:                              
      CHARACTER RADISP *(256)         ! Defines the type of transformation
                                      ! to be applied to the radius value

*  Arguments Given and Returned:
      REAL LOWR                       ! Low transfromed radius value to
                                      ! be untransformed
      REAL HIGHR                      ! High transformed radius value to
                                      ! be untransformed

*  Status:     
      INTEGER STATUS                  ! Global status

*.

*   Check the inherited global status.
      IF (STATUS.NE.SAI__OK) RETURN   

*   Transformation not required.
      IF (RADISP.EQ.'R') THEN
         IF (LOWR.LT.0.0) LOWR=0.0
         IF (HIGHR.LT.0.0) HIGHR=0.0
      END IF

*   Untransform data from a squared plot.
      IF (RADISP.EQ.'S') THEN
         IF (LOWR.LT.0.0) LOWR=0.0
         IF (HIGHR.LT.0.0) HIGHR=0.0
         LOWR=LOWR**(0.5)
         HIGHR=HIGHR**(0.5)
      END IF

*   Untransform data from a log base 10 plot.
      IF (RADISP.EQ.'L') THEN
         LOWR=10.**(LOWR)
         HIGHR=10.**(HIGHR)
      END IF

*   Untransform data from a quarter power plot.
      IF (RADISP.EQ.'Q') THEN
         IF (LOWR.LT.0.0) LOWR=0.0
         IF (HIGHR.LT.0.0) HIGHR=0.0
         LOWR=LOWR**(4.0)
         HIGHR=HIGHR**(4.0)
      END IF

 9999 CONTINUE

      END


*********************************************
*** MODIFIED KAPPA/KAPGEN CODE ADDED HERE ***
*********************************************


      SUBROUTINE GRA1_AIF_ASFIO (PNFILE,ACMODE,FORM,RECSZ,FD,OPEN,
     :                      EXCLAIM,STATUS)
*+
*    Description :
*
*     This routine opens a sequential file via FIO_ASSOC.  Up to four
*     attempts may be made to open the file.  If a null response is
*     supplied the file is not opened, and the flag returned indicates
*     this fact.
*
*    Invocation :
*
*      CALL GRA1_AIF_ASFIO (PNFILE,ACMODE,FORM,RECSZ,FD,OPEN, 
*                      EXCLAIM,STATUS)

*
*    Arguments :
*
*     PNFILE=CHARACTER*(*)
*         Parameter name by which file is to be opened
*     ACMODE=CHARACTER*(*)
*         Expression giving the required access mode.
*           Valid modes are: 'READ', 'WRITE', 'UPDATE' and 'APPEND'.
*           For details, see FIO_OPEN.
*     FORM=CHARACTER*(*)( READ )
*         Expression giving the required formatting of the file.
*           Valid formats are: 'FORTRAN', 'LIST', 'NONE' and
*           'UNFORMATTED'. For details, see FIO_OPEN.
*     RECSZ=INTEGER( READ )
*         Expression giving the maximum record size in bytes.
*           Set it to zero if the Fortran default is required.
*     FD=INTEGER( WRITE )
*         Variable to contain the file descriptor.
*     OPEN=LOGICAL( WRITE )
*         If true the file has been opened.
*     EXCLAIM=LOGICAL( WRITE )
*         If true then the user input was '!'.
*     STATUS=INTEGER( READ, WRITE )
*         Global status value
*
*    Method :
*
*     Check for error on entry - return if not o.k.
*     Initialise looping flag
*     Do while no error obtaining the name and opening the output file
*       and maximum number of attempts not exceeded
*        Get file name and open file
*        If null returned then
*           Set flag so that a log file will not be created
*           Annul the error
*           Exit from the loop
*        Else if error occurred then
*           If abort requested, do so
*           Increment loop counter
*           If maximum number of attempts not exceeded then
*              Report error
*           Else
*              Set looping flag to exit
*           Endif
*             Cancel parameter used to get filename
*        Else
*           Set flag to indicate that the file has been opened
*           Set looping flag to false
*        Endif
*     Enddo
*     If error then
*        Report and abort
*     Endif
*     Return
*
*    Bugs :
*
*     None known.
*-
*    Authors :
*
*     Malcolm Currie RAL (UK.AC.RL.STAR::CUR)
*
*    History :
*
*     1989 Jul 25: Original (RL.STAR::CUR).
*     1990 Feb 20: Renamed from AIF_OPFIO (RAL::CUR).
*     1994 Mar 1: Modified to return EXCLAIM (CARDIFF::GJP).
*     1997 Feb 24: MOdified for Linux (GJP).
*
*    Type definitions :

      IMPLICIT  NONE           ! no implicit typing allowed

*    Global constants :
      INCLUDE  'SAE_PAR'       ! SSE global definitions
      INCLUDE  'PAR_ERR'       ! parameter-system errors

*    Import :
      CHARACTER*(*) PNFILE     ! File Parameter Name
      CHARACTER*(*) ACMODE     ! File access mode
      CHARACTER*(*) FORM       ! Required form of carriagecontrol
      INTEGER RECSZ            ! File record size

*    Export :
      LOGICAL OPEN             ! File opened successfully
      LOGICAL EXCLAIM          ! File name was exclaimation
      INTEGER FD               ! File descriptor

*    Status :
      INTEGER STATUS

*    Local Constants :
      INTEGER MXLOOP           ! Maximum number of attempts at
                               ! opening a data file
      PARAMETER ( MXLOOP=4 )

      INTEGER LOOP             ! Number of attempts to open the file

      LOGICAL LOOPAG           ! Loop again to open output file

*.

*    check status on entry - return if not o.k.

      IF ( STATUS .NE. SAI__OK ) RETURN

      LOOP=0
      LOOPAG=.TRUE.
      OPEN=.FALSE.
      EXCLAIM=.FALSE.
      DO WHILE ( LOOPAG )

*       attempt to obtain and open a file to output listing

         CALL FIO_ASSOC( PNFILE, ACMODE, FORM, RECSZ, FD, STATUS )

         IF ( STATUS .EQ. PAR__NULL ) THEN
            OPEN=.FALSE.
            LOOPAG=.FALSE.
            EXCLAIM=.TRUE.
            CALL ERR_ANNUL( STATUS )
         ELSE IF ( STATUS .NE. SAI__OK ) THEN

            IF ( STATUS .EQ. PAR__ABORT ) GOTO 999

*         Here if filename is not allowed or file is not opened
*         - try again
*         Need to flush error here, as not quitting routine

            LOOP=LOOP + 1
            IF ( LOOP .LE. MXLOOP ) THEN
               CALL MSG_SETC( 'FILNAM', PNFILE )
               CALL ERR_REP( 'ERR_AIF_ASFIO_NOFI',
     :           'AIF_ASFIO: Could not open file $^FILNAM - try again',
     :           STATUS )
               CALL ERR_FLUSH( STATUS )
            ELSE

*             end looping as user is having serious problems

               LOOPAG=.FALSE.
            END IF

            CALL PAR_CANCL( PNFILE, STATUS )

         ELSE

*          no problem, so exit loop

            LOOPAG=.FALSE.
            OPEN=.TRUE.

*       end of file-opened-successfully check

         END IF
      END DO

*    abort for repeated error

      IF ( STATUS .NE. SAI__OK ) THEN
         CALL ERR_REP( 'ERR_AIF_ASFIO_NOOPEN',
     :     'AIF_ASFIO: Repeatedly unable to open a file.', STATUS )
      END IF

 999  CONTINUE

      END


      SUBROUTINE GRA1_PRPCUR ( MNCHOI, SWCHOI, TERMES, NTERMS, IMGMES,
     :                    NIMGMS, BUTTNS, CURSOR, IMGDIS, STATUS )
*+
*    Description :
*
*     This determines whether a cursor with a suitable number of choices
*     is available on the current graphics device.  Messages are given
*     describing which buttons to press if the device is a terminal or
*     an image display.  The messages has parameters CHOICETERMn or
*     CHOICEIDn, where n is number of the message starting from 1.
*
*    Invocation :
*
*     CALL GRA1_PRPCUR( MNCHOI, SWCHOI, TERMES, NTERMS, IMGMES,
*    :             NIMGMS, BUTTNS, CURSOR, IMGDIS, STATUS )
*
*    Parameters :
*
*     MNCHOI = INTEGER (Given)
*        The minimum number of choices required by the calling
*          application.  It must be positive.
*     SWCHOI = INTEGER (Given)
*        The maximum number of choices for the graphics-device to be an
*          image display. It must be at least %MNCHOI.
*     TERMES( NTERMS ) = CHARACTER (Given)
*        Description of which terminal buttons to press to obtain the
*          various choices, to be reported to the user if the device
*          is nominally a terminal, i.e. its number of choices exceeds
*          %SWCHOI.
*     NTERMS = INTEGER (Given)
*        Number of lines describing the action of the terminal choices.
*     IMGMES( NIMGMS ) = CHARACTER (Given)
*        Description of the action of the mouse or trackerball buttons
*          to be reported to the user if the device is nominally an
*          image display, i.e. its number of choices is less than or
*          equal to %SWCHOI.
*     NIMGMS = INTEGER (Given)
*        Number of lines describing the action of the image-display
*          choices.
*     BUTTNS = CHARACTER (Given)
*        The terminal buttons to be pressed to obtain the different
*          choices, e.g. '1A.' would mean '1' would give the first
*          choice, 'A' would the second and '.' to exit. A fullstop
*          is the recommended Starlink method for terminating such an
*          interaction.  The last character is assumed to be the exit
*          choice in cases where this string is longer than the number
*          of choices plus one (the exit). 
*          characters.  There must be at least %MNCHOI+1 characters.
*          This string is ignored if the device is an image display.
*     CURSOR = LOGICAL (Returned)
*        If true there is a suitable cursor and number of choices.
*     IMGDIS = LOGICAL (Returned)
*        If true the choice device is an image-display mouse or
*          trackerball
*     DEVICE = DEVICE (Given)
*        The graphics workstation.
*
*    Arguments :
*
*     STATUS = INTEGER (Given and Returned)
*        The global status.
*
*    Method :
*
*     If status is bad then exit
*     Validate input data
*     Determine the number of options on the workstation's choice device
*     If the number of choices is less than specified minimum then
*       report error context and abort
*     Activate the cursor and specify the options depending on the
*       number of choices and set cursor-ready flag
*     End
*
*    Bugs :
*
*     None known. 
*
*    Authors :
*
*     Malcolm J. Currie  STARLINK  (RAL::CUR)
*
*    History :
*
*     1989 Nov 10: Original version (RAL::CUR).
*
*    Type definitions :
      IMPLICIT NONE              ! No implicit typing

*    Global Constants :
      INCLUDE 'SAE_PAR'          ! Standard SAE constants

*    Import :
      INTEGER MNCHOI             ! Minimum number of choices
      INTEGER SWCHOI             ! Maximum number fo choices if the
                                 ! device is to be classed as an image
                                 ! display
      INTEGER NTERMS             ! Number of lines of terminal messages
      INTEGER NIMGMS             ! Number of lines of image-display
                                 ! messages

      CHARACTER *(*) TERMES( NTERMS )
                                 ! Informational messages if device is
                                 ! a terminal
      CHARACTER *(*) IMGMES( NTERMS )
                                 ! Informational messages if device is
                                 ! an image display
      CHARACTER *(*) BUTTNS      ! Choices buttons for a terminal.

*    Export :
      LOGICAL CURSOR             ! Device has a sutiable cursor and
                                 ! choices
      LOGICAL IMGDIS             ! Device is an image-display for the
                                 ! purpose of using the cursor

*    Status :
      INTEGER STATUS             ! Global status

*    External references :
      INTEGER
     :  CHR_LEN

*    Local variables :
      CHARACTER*80 BUTLST        ! List of buttons which may be a
                                 ! trimmed version of the input list
      CHARACTER DATREC(10)*80    ! Data record return by GKS inquiry

      INTEGER CONID              ! Connection identifier
      INTEGER GSTAT              ! Graphics status
      INTEGER I                  ! Loop index
      CHARACTER*4 IC             ! Message counter
      CHARACTER*14 LABEL         ! Informational-message parameter
      INTEGER LDR                ! Length of data record returned by
                                 ! GKS inquiry
      INTEGER MALT               ! Number of alternatives for choice
                                 ! input on graphics device
      INTEGER NC                 ! Number of characters in a string
      INTEGER OL                 ! Number of available prompt/echo types
                                 ! for graphics device
      INTEGER PET                ! Element of prompt/echo types of
                                 ! device returned by GKS inquiry
      INTEGER WKID               ! GKS workstation identifier
      INTEGER WTYPE              ! Workstation type

      REAL EAREA( 4 )            ! Graphics device echo area

                                 ! True if:
      LOGICAL CURAVA             ! A cursor is available

*-

*    Check inherited global status.

      IF ( STATUS .NE. SAI__OK ) RETURN

      CURSOR = .FALSE.
      IMGDIS = .FALSE.
      
*    Validate input data.

      IF ( MNCHOI .LT. 1 .OR. SWCHOI .LT. MNCHOI ) THEN
         STATUS = SAI__ERROR
         CALL ERR_REP( 'PRPCUR__PROG',
     :     'PRPCUR: Programmer error.  Check calling arguments',
     :      STATUS )
         GOTO 999
      END IF
 
*    Put out a blank line to ensure the commentary appears on the alpha
*    plane of the terminal.

      CALL MSG_OUT( 'BLANK', ' ', STATUS )

*    Is there a cursor?

      CURAVA = .FALSE.
      CALL SGS_ICUAV( CURAVA )

      IF ( .NOT. CURAVA ) THEN
         STATUS = SAI__ERROR
         CALL ERR_REP( 'PRPCUR__NOCUR',
     :     'PRPCUR: Chosen workstation does not have a cursor.',
     :     STATUS )

         GOTO 999
      END IF

      CALL SGS_ICURW( WKID )

*    Find workstation type

      CALL GQWKC( WKID, GSTAT, CONID, WTYPE )

*    Find number of options on choice device

      CALL GQDCH( WTYPE, 1, 1, 10, GSTAT, MALT, OL, PET, EAREA, LDR,
     :            DATREC )

*    At least one choice required

      IF ( MALT .LT. MNCHOI ) THEN
         STATUS = SAI__ERROR
         CALL ERR_REP( 'PRPCUR__WDV',
     :     'PRPCUR: Graphics device chosen has unsuitable choice '/
     :     /'device (e.g. mouse or trackerball) for this application.',
     :     STATUS )

         GOTO 999

*       Tell the user what to do...

      ELSE IF ( MALT .LE. SWCHOI ) THEN

*       first for an image display with a few buttons, and...

         DO  I = 1, NIMGMS
            CALL MSG_SETC( 'IMGMSG', IMGMES( I ) )
            CALL CHR_ITOC( I, IC, NC )
            LABEL = 'CHOICEID'//IC( :NC )

            CALL MSG_OUT( LABEL, '^IMGMSG', STATUS )
         END DO

*       Set the flag to say the cursor is ready for use.

         CURSOR = .TRUE.

*       Nominally an image display.

         IMGDIS = .FALSE.
      ELSE

*       a terminal with many choices.

*       First validate list of buttons.

         NC = CHR_LEN( BUTTNS )
         IF ( NC .LT. MNCHOI ) THEN
            STATUS = SAI__ERROR
            CALL ERR_REP( 'PRPCUR__PROG',
     :        'PRPCUR: Programmer error.  Check calling arguments',
     :         STATUS )
            GOTO 999
         END IF
 
*       Trim the button list if necessary.

         IF ( NC .GT. MALT + 1 ) THEN
            BUTLST = BUTTNS( :MNCHOI ) //BUTTNS( NC:NC )
         ELSE
            BUTLST = BUTTNS
         END IF

*       Ensure that the messages below appear before activating the
*       cursor, otherwise they may appear on the graphics plane instead
*       of the alpha plane. This is a two-part operation. First we
*       need to give time to switch to the alpha plane.
      
         CALL MSG_SYNC( STATUS )

         DO  I = 1, NTERMS
            CALL MSG_SETC( 'TERMSG', TERMES( I ) )
            CALL CHR_ITOC( I, IC, NC )
            LABEL = 'CHOICETERM'//IC( :NC )

            CALL MSG_OUT( LABEL, '^TERMSG', STATUS )
         END DO

*       The part is to wait for the messages to appear before returning
*       to graphics plane.
      
         CALL MSG_SYNC( STATUS )

*       Activate the cursor

         CALL SGS_CUVIS( .TRUE. )
         CALL SGS_SELCH( 0 )
         CALL SGS_DEFCH( BUTLST )

*       Set the flag to say the cursor is ready for use.

         CURSOR = .TRUE.
      END IF

 999  CONTINUE

      END

