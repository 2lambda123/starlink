      SUBROUTINE PROCVT( STATUS )
*+
*  Name:
*     PROCVT

*  Purpose:
*     Converts "old-style" ADAM/SSE prologues into STARLSE format.

*  Language:
*     Starlink Fortran 77

*  Type of Module:
*     ADAM A-task

*  Invocation:
*     CALL PROCVT( STATUS )

*  Description:
*     This application converts "old-style" ADAM/SSE routine prologues
*     into the format generated by the extended VAX Language Sensitive
*     Editor STARLSE (SUN/105). The converted prologue information may
*     then be used as input to other SST applications which generate
*     documentation, help libraries, etc.

*  Usage:
*     PROCVT IN [OUT]

*  ADAM Parameters:
*     ATASK = _LOGICAL (Read)
*        If ATASK is set to TRUE, then the style of output prologue
*        will be suitable for application programs (i.e.  ADAM
*        A-tasks).  If it is set to FALSE, then prologues suitable for
*        ordinary subroutines or functions, such as a subroutine
*        library, are produced. [TRUE]
*     IN() = LITERAL (Read)
*        A list of (optionally wild-carded) file specifications which
*        identify the Fortran 77 source code files with "old-style"
*        ADAM prologues which are to be used for input. Up to 10 values
*        may be given, but only a single specification such as '*.FOR'
*        is normally required.  There is no limit on the number of
*        program units which may be held in each input file.
*     LANG = LITERAL (Read)
*        This value specifies the programming language (i.e. the
*        particular dialect of Fortran 77) in which the source code is
*        written. It does not affect the processing performed, but will
*        be inserted into the output prologues under the "Language"
*        section heading. If a null (!) or blank value is given, then
*        an appropriate STARLSE placeholder will be used instead. The
*        required entry can then be made later by hand. ['VAX Fortran']
*     OUT = FILE (Write)
*        The output file to which the source code will be copied with
*        its prologue format converted. If multiple input files are
*        specified, then the converted output will be concatenated into
*        a single file. [PROCVT.FOR]

*  Examples:
*     PROCVT MYPROG_OLD.FOR MYPROG_NEW.FOR
*        Reads the application program source code held in the file
*        MYPROG_OLD.FOR and converts its prologue information into
*        STARLSE format. The converted source code is written to the
*        file MYPROG_NEW.FOR.
*     PROCVT *.FOR OUT=SUBS.FOR ATASK=FALSE LANG="Starlink Fortran 77"
*        Reads the source code for a subroutine library, held in the
*        files *.FOR, and converts its prologue information to STARLSE
*        format. The converted source code is written to a single
*        output file SUBS.FOR. The language specified in the converted
*        prologues will be "Starlink Fortran 77".
*     PROCVT IN=["*.FOR","*.GEN"] NOATASK
*        In this example, a sequence of input file specifications is
*        given. Each will be processed in turn, converting its prologue
*        information into STARLSE format. Output is written to the
*        single default output file PROCVT.FOR.

*  Notes:
*     Due to the variety of layouts found in existing "old-style"
*     ADAM/SSE prologues, this application is not guaranteed always to
*     produce a perfect result. Particular problem areas are the
*     inconsistent use of indentation, and the occasional use of
*     section headings and placeholders (of the form '<...>') which do
*     not quite match those given in the original ADAM/SSE prologue
*     templates.  Nevertheless, in most cases, PROCVT will produce a
*     result which can be edited fairly easily using STARLSE to conform
*     with the requirements of other SST applications. Appropriate
*     STARLSE placeholders will be inserted into output prologues to
*     facilitate the entry of any essential information which cannot be
*     found in the corresponding input prologue.

*  Timing:
*     The execution time is approximately proportional to the total
*     number of source code lines supplied for conversion. The time
*     will be increased somewhat if the code resides in a large number
*     of separate files, due to the need to open and close each file.

*  Arguments:
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     RFWS: R.F. Warren-Smith (STARLINK)
*     PDRAPER: Peter Draper (STARLINK - Durham University)
*     {enter_new_authors_here}

*  History:
*     16-AUG-1990 (RFWS):
*        Original, derived from the PROLAT routine.
*     4-SEP-1990 (RFWS):
*        Improved the prologue information.
*     5-SEP-1990 (RFWS):
*        Improved the parameter descriptions in the prologue.
*     7-SEP-1990 (RFWS):
*        Changed to pass the program unit type to the conversion
*        algorithm.
*     7-SEP-1990 (RFWS):
*        Added display of each program unit name and type as it is
*        processed.
*     10-SEP-1990 (RFWS):
*        Re-structured the status checking in the main DO WHILE loop
*        for processing input prologues.
*     10-SEP-1990 (RFWS):
*        Added the LANG parameter.
*     12-SEP-1990 (RFWS):
*        Improved the prologue documentation.
*     17-SEP-1990 (RFWS):
*        Close scratch file with explicit delete status.
*     5-DEC-1994 (PDRAPER):
*        Changed file OPENs to FIO_OPEN, should be more portable.
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}

*-

*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants
      INCLUDE 'FIO_PAR'          ! FIO_ public constants
      INCLUDE 'SST_PAR'          ! SST_ constants
      INCLUDE 'PAR_ERR'          ! PAR_ error codes

*  Global Variables:
      INCLUDE 'SST_SCB'          ! SST Source Code Buffer

*  Status:
      INTEGER STATUS             ! Global status

*  Local Constants:
      INTEGER MXSPEC             ! Max. no of file specifications
      PARAMETER ( MXSPEC = 10 )

      INTEGER SZNAME             ! Max. length of a routine name
      PARAMETER ( SZNAME = 32 )

*  Local Variables:
      CHARACTER * ( 1 ) TYPE     ! Program unit type
      CHARACTER * ( FIO__SZFNM ) FNAME ! Input file name
      CHARACTER * ( FIO__SZFNM ) OUTFIL ! Output file name
      CHARACTER * ( FIO__SZFNM ) SPEC( MXSPEC ) ! File specifications
      CHARACTER * ( SST__SZLIN ) LANG ! Programming language
      CHARACTER * ( SST__SZLIN ) PURPOS ! Routine purpose
      CHARACTER * ( SZNAME ) NAME ! Routine name
      INTEGER FDIN               ! Input file descriptor
      INTEGER FDOUT              ! Output fiile descriptor
      INTEGER IFILE              ! Loop counter for input files
      INTEGER NFILE              ! Number of input files
      INTEGER NPRO               ! Number of prologues read
      INTEGER NSPEC              ! Number of file specifications
      INTEGER SCRAT              ! I/O unit for scratch file
      INTEGER TOTPRO             ! Total prologues processed
      LOGICAL ATASK              ! Whether processing ADAM A-tasks

*.

*  Check inherited global status.
      IF ( STATUS .NE. SAI__OK ) RETURN

*  Obtain I/O units for scratch files.
      CALL FIO_GUNIT( SCRAT, STATUS )

*  Get the input file specifications.
      CALL PAR_GET1C( 'IN', MXSPEC, SPEC, NSPEC, STATUS )
      IF ( STATUS .NE. SAI__OK ) GO TO 99

*  Write the list of input files to be processed into a scratch file.
      CALL SST_FWILD( NSPEC, SPEC, SCRAT, NFILE, STATUS )
      IF ( STATUS .NE. SAI__OK ) GO TO 99

*  If no files were found, then report an error.
      IF ( NFILE .LE. 0 ) THEN
         STATUS = SAI__ERROR
         CALL MSG_SETC( 'SPEC', SPEC( 1 ) )
         CALL ERR_REP( 'PROCVT_NOFILES',
     :   'No input files found matching the specification ''^SPEC''...',
     :   STATUS )
         GO TO 99
      END IF

*  Report how many files are to be processed.
      CALL MSG_OUT( 'BLANK', ' ', STATUS )
      IF ( NFILE .EQ. 1 ) THEN
         CALL MSG_OUT( 'NFILE1', '   1 file to be processed...',
     :                 STATUS )
      ELSE
         CALL MSG_SETI( 'NFILE', NFILE )
         CALL MSG_OUT( 'NFILE', '   ^NFILE files to be processed...',
     :                 STATUS )
      END IF
      CALL MSG_OUT( 'BLANK', ' ', STATUS )

*  Rewind the scratch file ready for re-reading.
      REWIND( SCRAT )

*  Obtain the name of the output file.
      CALL PAR_GET0C( 'OUT', OUTFIL, STATUS )
      IF ( STATUS .NE. SAI__OK ) GO TO 99

*  Open the output file.
      CALL FIO_OPEN( OUTFIL, 'WRITE', 'LIST', 0, FDOUT, STATUS )
      CALL FIO_UNIT( FDOUT, SCB_OUT, STATUS )

*  Check for errors, setting a suitable STATUS value and reporting the
*  error.
      IF ( STATUS .NE. SAI__OK  ) THEN
         CALL MSG_SETC( 'FILE', OUTFIL )
         CALL MSG_SETI( 'UNIT', SCB_OUT )
         CALL ERR_REP( 'PROCVT_OPENOUT',
     :   'Error opening output file ^FILE on Fortran unit ^UNIT. ',
     :   STATUS )
         GO TO 99
      END IF

*  Determine if the input files to be processed are for ADAM A-tasks.
      CALL PAR_GET0L( 'ATASK', ATASK, STATUS )
      IF ( STATUS .NE. SAI__OK ) GO TO 99

*  Obtain the language specification for insertion into the output
*  prologues. If a null value was given, then set the language to be
*  blank.
      CALL PAR_GET0C( 'LANG', LANG, STATUS )
      IF ( STATUS .EQ. PAR__NULL ) THEN
         CALL ERR_ANNUL( STATUS )
         LANG = ' '
      END IF
      IF ( STATUS .NE. SAI__OK ) GO TO 99

*  Output a heading for the list of files being processed.
      IF ( NFILE .EQ. 1 ) THEN
         CALL MSG_OUT( 'PROCESSING1', '   Processing file...',
     :                 STATUS )
      ELSE
         CALL MSG_OUT( 'PROCESSING', '   Processing files...',
     :                 STATUS )
      ENDIF
      CALL MSG_OUT( 'BLANK', ' ', STATUS )

*  Initialise the total count of prologues processed.
      TOTPRO = 0

*  Read the name of each input file from the scratch file.
      DO 2 IFILE = 1, NFILE
         CALL SST_GET( SCRAT, FNAME, STATUS )
         IF ( STATUS .NE. SAI__OK ) GO TO 99

*  Show which file is being processed.
         CALL MSG_SETI( 'IFILE', IFILE )
         CALL MSG_SETC( 'FILE', FNAME )
         CALL MSG_OUT( 'CURRENT_FILE', '      ^IFILE: ^FILE', STATUS )

*  Open the input file. Note that successive input files are not closed
*  as this is done automatically by opening a new file on the same I/O
*  unit.
         IF ( STATUS .NE. SAI__OK ) GO TO 99
         CALL FIO_OPEN( FNAME, 'READ', 'LIST', 0, FDIN, STATUS )
         CALL FIO_UNIT( FDIN, SCB_IN, STATUS )

*  Check for errors, setting a suitable STATUS value and reporting the
*  error.
         IF ( STATUS .NE. SAI__OK ) THEN
            CALL MSG_SETC( 'FNAME', FNAME )
            CALL MSG_SETI( 'UNIT', SCB_IN )
            CALL ERR_REP( 'PROCVT_OPENIN',
     :      'Error opening input file ^FILE on Fortran unit ^UNIT.',
     :           STATUS )
            GO TO 99
         END IF

*  Loop to read input prologues into the source code buffer, stopping
*  when an error occurs or no prologue line are read. Count the number
*  of prologues read.
         NPRO = 0
 1       CONTINUE                ! Start of 'DO WHILE' loop
         CALL SST_RDAD1( NAME, TYPE, PURPOS, STATUS )
         IF ( ( STATUS .EQ. SAI__OK ) .AND. ( SCB_NLINE .GT. 0 ) ) THEN
            NPRO = NPRO + 1

*  If the program unit type is unknown, then indicate this.
            IF ( TYPE .EQ. '?' ) THEN
               CALL MSG_OUT( 'PROG_UNKNOWN',
     :                       '         <unknown program unit>',
     :                       STATUS )

*  Otherwise, display each program unit type and name as it is
*  processed.
            ELSE
               IF ( TYPE .EQ. 'B' ) THEN
                  CALL MSG_SETC( 'TYPE', 'block data' )
               ELSE IF ( TYPE .EQ. 'F' ) THEN
                  CALL MSG_SETC( 'TYPE', 'function' )
               ELSE IF ( TYPE .EQ. 'P' ) THEN
                  CALL MSG_SETC( 'TYPE', 'program' )
               ELSE IF ( TYPE .EQ. 'S' ) THEN
                  CALL MSG_SETC( 'TYPE', 'subroutine' )
               END IF
               CALL MSG_SETC( 'NAME', NAME )
               CALL MSG_OUT( 'PROG_UNIT',
     :                       '         ^TYPE ^NAME', STATUS )
            END IF

*  Write out a new routine name section, supplying a placeholder if the
*  actual routine name could not be found.
            CALL SST_FOR( 1, '+', STATUS )
            CALL SST_FOR( 3, 'Name:', STATUS )
            IF ( NAME .NE. ' ' ) THEN
               CALL SST_FOR( 6, NAME, STATUS )
            ELSE
               CALL SST_FOR( 6, '{routine_name}', STATUS )
            END IF
            CALL SST_FOR( 0, ' ', STATUS )
            IF ( STATUS .NE. SAI__OK ) GO TO 99

*  Write out a new routine purpose section, supplying a placeholder if
*  the actual purpose description could not be found.
            CALL SST_FOR( 3, 'Purpose:', STATUS )
            IF ( PURPOS .NE. ' ' ) THEN
               CALL SST_FOR( 6, PURPOS, STATUS )
            ELSE
               CALL SST_FOR( 6, '{routine_purpose}', STATUS )
            END IF
            CALL SST_FOR( 0, ' ', STATUS )
            IF ( STATUS .NE. SAI__OK ) GO TO 99

*  Translate the remaining prologue information into the new format in
*  the output file.
            CALL SST_TRCVT( ATASK, LANG, NAME, TYPE, STATUS )

*  Transfer the remaining part of the input program unit to the output
*  file.
            CALL SST_RDAD2( STATUS )

*  Return to process the next prologue.
            GO TO 1
         END IF
         IF ( STATUS .NE. SAI__OK ) GO TO 99

*  Check that at least one prologue is read from each file. Report an
*  error if none was found.
         IF ( NPRO .LE. 0 ) THEN
            STATUS = SAI__ERROR
            CALL MSG_SETC( 'FILE', FNAME )
            CALL ERR_REP( 'PROCVT_NOPRO',
     :      'No prologue found in input file ^FILE', STATUS )
            GO TO 99
         END IF

*  If more than one prologue was expected, then show how many prologues
*  were found.
         IF ( NPRO .EQ. 1 ) THEN
            CALL MSG_OUT( 'NPROLOGUES1',
     :                    '         1 prologue found', STATUS )
         ELSE
            CALL MSG_SETI( 'NPRO', NPRO )
            CALL MSG_OUT( 'NPROLOGUES',
     :                    '         ^NPRO prologues found', STATUS )
         END IF

*  Count the total number of prologues processed.
         TOTPRO = TOTPRO + NPRO
2     CONTINUE

*  Arrive here when all the input files have been processed, or earlier
*  if an error occurred.
99    CONTINUE

*  Close the last input file, the output file and the scratch file.
      CALL FIO_CLOSE( FDIN, STATUS )
      CALL FIO_CLOSE( FDOUT, STATUS )
      CLOSE( SCRAT, STATUS = 'DELETE' )

*  Release the I/O channels.
      CALL FIO_PUNIT( SCRAT, STATUS )

*  If there were no errors, then report successful completion.
      IF ( STATUS .EQ. SAI__OK ) THEN
         CALL MSG_OUT( 'BLANK', ' ', STATUS )
         CALL MSG_SETI( 'NFILE', NFILE )
         IF ( NFILE .EQ. 1 ) THEN
            CALL MSG_SETC( 'FILES', 'file' )
         ELSE
            CALL MSG_SETC( 'FILES', 'files' )
         END IF
         CALL MSG_SETI( 'TOTPRO', TOTPRO )
         IF ( TOTPRO .EQ. 1 ) THEN
            CALL MSG_SETC( 'PROLOGUES', 'prologue' )
         ELSE
            CALL MSG_SETC( 'PROLOGUES', 'prologues' )
         END IF
         CALL MSG_OUT( 'ALL_DONE',
     :                 '   ^NFILE ^FILES (^TOTPRO ^PROLOGUES) ' //
     :                 'processed successfully', STATUS )

*  Say where the output is.
         CALL MSG_SETC( 'OUTFILE', OUTFIL )
         CALL MSG_OUT( 'OUT_FILE',
     :                 '   Converted source written to file ^OUTFILE',
     :                 STATUS )
         CALL MSG_OUT( 'BLANK', ' ', STATUS )
      END IF

*  If an error occurred, then report contextual information.
      IF ( STATUS .NE. SAI__OK ) THEN
         CALL ERR_REP( 'PROCVT_ERR',
     :   'PROCVT: Error converting "old-style" ADAM/SSE prologues ' //
     :   'to STARLSE format.', STATUS )
      END IF

      END
* @(#)procvt.f   1.1   94/12/05 11:31:19   96/07/05 10:27:40
