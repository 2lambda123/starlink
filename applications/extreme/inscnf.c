/*
*+
*  Name:
*     inscnf
*
*  Purpose:
*     Wrap %VAL arguments with CNF_PVAL in Fortran 77.
*
*  Usage:
*     inscnf [ in [ out ] ]
*
*  Description:
*     This is a filter which takes FORTRAN 77 source code
*     and modifies it so that text which is the argument of a %VAL
*     directive is wrapped in a call to CNF_PVAL; i.e. input text
*
*        %VAL( IPTR )
*
*     is changed to
*
*        %VAL( CNF_PVAL( IPTR ) )
*
*     If the call to CNF_PVAL is already present no change is made,
*     and a warning is emitted.  Lines with no references to the %VAL
*     directive are left alone.
*
*     Additionally, for each program unit in which a call to CNF_PVAL
*     has been made, an attempt is made to insert a line like
*
*        INCLUDE 'CNF_PAR'        ! For CNF_PVAL function
*
*     This is inserted after the last INCLUDE line which already exists
*     in the program unit.  If there are no INCLUDE lines there, this
*     line is not inserted, and a warning message is printed to standard
*     error.
*
*     Attention is paid to Fortran 77 source format, so that lines
*     more than 72 characters long are avoided (unless they were there
*     in the first place).
*
*     Characters '\r' (carriage return) and '\t' (tab) might possibly
*     cause erroneous line breaking - if any are encountered a warning
*     is given (these should not be in the source really).
*     Code using columns 73-80 of the source cards for comments is
*     likely to be mangled (nobody does this any more do they?).
*
*     Under certain improbable circumstances it is possible for the
*     program to get stuck trying to break a line; in this case it will
*     exit with error status and an error message.
*
*     Some attention is paid to the aesthetic qualities of the output:
*     line breaks are made, where possible, following the usage in, e.g.,
*     KAPPA.  An attempt is made to copy the style of case usage and bracket
*     spacing from the input.
*
*     This program wraps ALL occurrences of %VAL in a call to CNF_PVAL,
*     unless they are already so wrapped.  If it suspects that %VAL
*     may not be a legitimate candidate for this treatment, it will
*     output a warning message to standard error.  It will do this in
*     the following cases:
*       - %VAL is on the last argument in the argument list (this
*         suggests that it might be a trailing string length)
*       - The argument of %VAL looks like an integer constant
*       - The argument of %VAL looks like a Starlink-style symbolic
*         constant (has two adjacent underscore characters).
*
*  Notes:
*     Although this program behaves as a filter, it is written on
*     the assumption that it will be run on a file of a finite length:
*     it may buffer large amounts of input before writing output, and
*     it may not free up memory.
*
*  Authors:
*     MBT: Mark Taylor (STARLINK)
*
*  History:
*     06-JAN-2000 (MBT):
*        Initial version.
*-
*/


#include <stdio.h>
#include <string.h>
#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>
#include <ctype.h>

#include "ygen.h"
#include "ftokens.h"

#define MAXCONT 100                     /* Maximum continuation lines        */
#define MAXNEST 100                     /* Deepest level of bracket nesting  */
#define LBUFSIZ 4000                    /* Longest source line               */


/* Structure to hold the input text with associated information. */
   struct outchr {
      char *interp;                     /* Text to interpolate before chr    */
      short flag;                       /* Special information               */
      unsigned char indent;             /* Indent column if line broken      */
      char chr;                         /* Input character                   */
   };


/* Local function prototypes. */
   void inscnf();
   void outbuf( struct outchr *buf, int leng );
   int tokmatch( int *toks, ... );


   int main( int argc, char **argv ) {
/*
*+
*  Name:
*     main
*
*  Purpose:
*     Main routine of C program.
*
*  Description:
*     Invokes the appropriate filter function.
*-
*/

/* Declare variables. */
      extern char *name;

/* Set up standard input and output correctly for a filter. */
      name = filter( argc, argv );

/* Filter input to output. */
      inscnf();

/* Finish. */
      return 0;
   }



   void inscnf() {
/*
*+
*  Name:
*     inscnf
*
*  Purpose:
*     Perform data processing for inscnf program.
*
*  Invocation:
*     inscnf()
*
*  Description:
*     This routine reads characters from standard input and writes them
*     to standard output.  The output is substantially similar to the
*     input except that arguments of %VAL are wrapped in the CNF_PVAL
*     function, and "INCLUDE 'CNF_PAR'" lines are inserted where
*     appropriate.
*
*     Tokenising the input stream is done using code generated by lex.
*-
*/
#define MAXTOK 1000                          /* Maximum tokens in a line     */
#define LINELENG 160                         /* Maximum characters in a line */

      int bufsiz = 0;
      int calltok[ MAXNEST ];
      int col = 0;
      int incpos = 0;
      int i;
      int ilev;
      int j;
      int k;
      int leng = 0;
      int level = 0;
      int ntok = 0;
      int nval = 0;
      int stcol[ MAXNEST ];
      int tok;
      int tokid[ MAXTOK ];
      int tokpos[ MAXTOK ];
      int yleng;
      int scase;
      int sspace;
      struct outchr *buf = NULL;
      char c;
      char *tokstr[ MAXTOK ];
      char *cpo[ 4 ];
      char *cpc[ 4 ];
      char *pc;
      char callname[ LINELENG ];
      char *namestart;

/* Set up strings for output. */
#define CASE_UPPER 0
#define CASE_LOWER 2
#define SPACE_YES  0
#define SPACE_NO   1
      cpo[ CASE_UPPER | SPACE_YES ] = " CNF_PVAL(";
      cpo[ CASE_UPPER | SPACE_NO  ] = "CNF_PVAL(";
      cpo[ CASE_LOWER | SPACE_YES ] = " cnf_pval(";
      cpo[ CASE_LOWER | SPACE_NO  ] = "cnf_pval(";
      cpc[ CASE_UPPER | SPACE_YES ] = " )";
      cpc[ CASE_UPPER | SPACE_NO  ] = ")";
      cpc[ CASE_LOWER | SPACE_YES ] = " )";
      cpc[ CASE_LOWER | SPACE_NO  ] = ")";
      scase = CASE_UPPER;
      sspace = SPACE_YES;

/* Get characters from the lex tokeniser.  As well as the token id which
   is the return value of yylex, the global yylval points to the
   characters which constituted this token. */
      while ( ( tok = yylex() ) || ( yylval != NULL ) ) {

/* Assemble a line in terms of tokens. */
         tokid[ ntok ] = tok;
         tokpos[ ntok ] = leng;
         tokstr[ ntok ] = yylval;
         tokid[ ++ntok ] = 0;
         if ( ntok >= MAXTOK ) {
            fprintf( stderr, "%s: Too many tokens in line\n", name );
            exit( 1 );
         }

/* Add text to output buffer. */
         yleng = strlen( yylval );
         if ( leng + yleng >= bufsiz ) {
            bufsiz += BUFINC;
            buf = memok( realloc( buf, bufsiz * sizeof( struct outchr ) ) );
            for ( i = 0; i < BUFINC; i++ ) {
               buf[ bufsiz - i - 1 ].interp = NULL;
               buf[ bufsiz - i - 1 ].chr = '\0';
               buf[ bufsiz - i - 1 ].flag = 0;
               buf[ bufsiz - i - 1 ].indent = 0;
            }
         }
         for ( i = 0; i < yleng; i++ ) {
            buf[ leng + i ].chr = yylval[ i ];
         }

/* If we have reached the end of the file apart from trailing untokenised
   characters, output them and exit the loop. */
         if ( tok == 0 ) break;

/* Record interesting facts about the current token. */
         switch( tok ) {
            case LINE_START:
               buf[ leng ].flag = tok;
               break;
            case LINE_END:
            case '(':
            case ')':
               buf[ leng + yleng - 1 ].flag = tok;
               break;
            case CNF_PVAL:
               fprintf( stderr, "%s: CNF_PVAL already present in input file\n",
                                name );
               break;
         }
         leng += yleng;

/* If we have reached the end of a line, process the line. */
         if ( tok == LINE_END || tok == COMMENT_LINE || tok == BLANK_LINE ) {

/* INCLUDE line - mark as spot for interpolating "INCLUDE 'CNF_PVAL'". */
            if ( tokmatch( tokid, LINE_START, INCLUDE, STRING_CONSTANT,
                                  LINE_END, 0 ) ) {
               if ( incpos ) buf[ incpos ].interp = NULL;
               incpos = tokpos[ 3 ] + yleng;

/* Allocate and generate text for the INCLUDE line.  We go to some trouble
   to match the style (spacing, case, and comment positioning) of existing
   INCLUDE lines. */
               buf[ incpos ].interp = pc = memok( calloc( LINELENG, 1 ) );
               strcpy( pc, "      " );
               pc += 6;
               for ( i = tokpos[ 1 ]; ( *(pc++) = buf[ i ].chr ) != '\''; i++ );
               strcpy( pc, "CNF_PAR'" );
               for ( j = 0; ( c = buf[ i + j ].chr ) != '\n' && c != '!' ; j++);
               if ( c == '!' ) {
                  while ( --j > 8 ) strcat( pc, " " );
                  strcat( pc, "! For CNF_PVAL function" );
               }
               strcat( pc, "\n" );
            }

/* END line.  If there have been no interpolations, then forget about
   inserting the INCLUDE line.  If there have been interpolations but
   we couldn't find any INCLUDE lines, warn the user. */
            else if ( tokmatch( tokid, LINE_START, END, LINE_END, 0 ) ) {
               buf[ tokpos[ 1 ] ].flag = END;
               if ( nval == 0 ) {
                  if ( incpos )
                     buf[ incpos ].interp = NULL;
               }
               else {
                  if ( ! incpos )
                     fprintf( stderr,
                              "%s: Failed to place INCLUDE 'CNF_PAR'\n", name );
               }
               nval = 0;
               incpos = 0;
            }

/* Otherwise, it is potentially an executable line. */
            else {

/* Work through tokens in the line looking for interesting things. */
               for ( i = 0; i < ntok; i++ ) {

/* Keep track of bracket nesting. */
                  if ( tokid[ i ] == '(' ) {
                     if ( level < MAXNEST + 1 ) level++;
                     if ( i && tokid[ i - 1 ] == IDENTIFIER )
                        calltok[ level ] = i - 1;
                     else
                        calltok[ level ] = 0;
                  }
                  if ( tokid[ i ] == ')' ) {
                     if ( level ) level--;
                  }

/* Do we have a %VAL invocation? */
                  if ( tokmatch( tokid + i, (int) '%', VAL, (int) '(', 0 )
                     && tokid[ i + 3 ] != CNF_PVAL ) {

/* Get name of subroutine being called. */
                     j = tokpos[ calltok[ level ] + 1 ];
                     k = LINELENG - 1;
                     callname[ k-- ] = '\0';
                     for ( j = tokpos[ calltok[ level ] + 1 ] - 1;
                             j > tokpos[ calltok[ level ] ] && k > 0
                                && ! ( isspace( c = buf[ j ].chr ) );
                             j-- )
                        callname[ k-- ] = c;
                     namestart = callname + k + 1;

/* Warn if the content of the %VAL looks like an integer. */
                     if ( tokid[ i + 3 ] == INTEGER_CONSTANT ) {
                        fprintf( stderr, "%s: Constant %%VAL argument in %s?\n",
                                 name, namestart );
                     }

/* Warn if the content of the %VAL looks like it contains a symbolic
   constant (i.e. something with two consecutive underscores in its name. */
                     if ( tokid[ i + 3 ] == IDENTIFIER ) {
                        for ( j = tokpos[ i + 3 ]; j < tokpos[ i + 4 ] - 1;
                              j++ ) {
                           if ( buf[ j ].chr == '_' &&
                                buf[ j + 1 ].chr == '_' ) {
                              fprintf( stderr,
                                       "%s: Constant %%VAL argument in %s?\n",
                                       name, namestart );
                              break;
                           }
                        }
                     }

/* Infer stylistic conventions used by the source code. */
                     scase = islower( buf[ tokpos[ i + 1 ] ].chr )
                                ? CASE_LOWER : CASE_UPPER;
                     sspace = buf[ tokpos[ i + 2 ] + 1 ].chr == ' '
                                ? SPACE_YES : SPACE_NO;

/* Look for the matching bracket. */
                     ilev = level++;
                     for ( j = i + 3; j < ntok; j++ ) {
                        if ( tokid[ j ] == '(' ) {
                           level++;
                        }
                        else if ( tokid[ j ] == ')' ) {
                           level--;

/* Found the matching bracket.  We can now note the interpolations. */
                           if ( level == ilev ) {
                              buf[ tokpos[ i + 3 ] ].interp =
                                 cpo[ scase | sspace ];
                              buf[ tokpos[ j ] ].interp = cpc[ scase | sspace ];
                              if ( tokid[ j + 1 ] == (int) ')' ) {
                                 fprintf( stderr,
                                          "%s: Last arg %%VAL in %s\n",
                                          name, namestart );
                              }
                              nval++;
                              break;
                           }
                        }
                     }
                     if ( level != ilev ) {
                        fprintf( stderr, "%s: Lost track of brackets!\n",
                                 name );
                     }
                  }
               }

/* Set natural indent levels. */
               level = 0;
               col = 0;
               for ( i = tokpos[ 0 ]; i <= tokpos[ ntok - 1 ]; i++ ) {
                  if ( ! isspace( buf[ i ].chr ) && col > 6 ) {
                     if ( stcol[ level ] > col ) stcol[ level ] = col;
                  }
                  if ( buf[ i ].flag == '(' ) {
                     if ( level < MAXNEST - 1 ) level++;
                     stcol[ level ] = 99999;
                  }
                  else if ( buf[ i ].flag == ')' ) {
                     if ( level ) level--;
                  }
                  col++;
                  if ( buf[ i ].chr == '\n' ) {
                     col = 0;
                  }
                  buf[ i ].indent = stcol[ level ] < 72 ? stcol[ level ] : 0;
               }

            }
            ntok = 0;
         }
      }

/* End of text; ensure that the INCLUDE lines are in the right place. */
      if ( nval == 0 ) {
         if ( incpos )
            buf[ incpos ].interp = NULL;
      }
      else {
         if ( ! incpos )
            fprintf( stderr, "%s: Failed to place INCLUDE 'CNF_PAR'\n", name );
      }

/* Pass control to the output routine. */
      outbuf( buf, leng );
   }



   void outbuf( struct outchr *buf, int leng ) {
/*
*+
*  Name:
*     outbuf
*
*  Purpose:
*     Output prepared text.
*
*  Description:
*     Takes the array of outchr structs and prints them to standard output.
*
*  Arguments:
*     buf = struct outchr *
*        Array of things to output.
*     leng = int
*        Number of elements in buf.
*-
*/
      char c;
      char chr;
      char ebuf[ LBUFSIZ ];
      char *interp;
      int col;
      int done;
      int eindent[ LBUFSIZ ];
      int epos = -1;
      int flag;
      int hadint = 0;
      int i;
      int ind;
      int indent;
      int j;
      int k;
      int level;
      int ninterp = 0;
      int nonblank;
      int oc;
      int started;
      int we;

/* Loop through buffer. */
      for ( oc = 0; oc < leng; oc++ ) {

/* Get info for this buffer element. */
         chr = buf[ oc ].chr;
         interp = buf[ oc ].interp;
         flag = buf[ oc ].flag;
         indent = buf[ oc ].indent;

/* Initialise some counters if it is the start of a line. */
         if ( flag == LINE_START ) {
            epos = 0;
            level = 0;
            hadint = 0;
         }

/* Outside a line, interpolations are output without special care. */
         if ( epos < 0 ) {
            if ( interp != NULL ) {
               while ( c = *( interp++ ) )
                  putchar( c );
               hadint = 1;
            }
            putchar( chr );
         }

/* Within a line it is ensured that interpolations do not cause characters
   to overflow beyond column 72.  Firstly, characters in each line are
   copied into an intermediate buffer, which includes the interpolations
   as well as the original characters.  When a newline character is
   encountered, the intermediate buffer is output, with new line breaks
   if they are required. */
         else {

/* If there are interpolations, copy them into the intermediate buffer. */
            if ( interp != NULL ) {
               while ( c = *( interp++ ) ) {
                  ebuf[ epos ] = c;
                  eindent[ epos ] = indent;
                  epos++;
               }
               hadint = 1;
            }

/* As long as the character is not a line end, just copy it to the
   intermediate buffer. */
            if ( chr != '\n' ) {
               ebuf[ epos ] = chr;
               eindent[ epos ] = indent;
               epos++;
            }

/* It's a line end.  Process the whole line now. */
            else {

/* Strip trailing whitespace if there have been interpolations, as it
   simplifies matters later on. */
               if ( hadint )
                  while ( epos >= 0 && ebuf[ epos - 1 ] == ' ' ) epos--;

/* There are no interpolations, or any interpolations do not cause the
   line to overflow 72 columns.  Output it without further ado. */
               if ( ! hadint || epos < 72 ) {
                  for ( i = 0; i < epos; i++ ) putchar( ebuf[ i ] );
               }

/* Interpolations cause the line to overflow.  We will have to break the
   line. */
               else {

/* The procedure is to identify 'word boundaries'; if all text up to the
   next boundary can be output on the current line do so, otherwise
   introduce a line break and continue with the rest of the input.
   A word starts at a '%' and ends at the first character at the same
   level of bracketing which is none of ')', ',' or ' '.  These are
   sensible choices based on our knowledge of what interpolations we
   are expecting. */
                  i = 0;
                  col = 1;
                  while ( i < epos ) {

/* Find the next place a line break could occur. */
                     done = 0;
                     level = 0;
                     started = 0;
                     for ( j = i; !done && j < epos; j++ ) {
                        if ( ebuf[ i ] == '%' ) {
                           switch ( ebuf[ j + 1 ] ) {
                              case '(':
                                 if ( level < MAXNEST -1 ) level++;
                                 started = 1;
                                 break;
                              case ')':
                                 if ( level ) level--;
                                 break;
                              case ' ':
                              case ',':
                                 break;
                              case '\n':
                                 done = 1;
                                 break;
                              default:
                                 done = ( started && level <= 0 );
                           }
                        }
                        else {
                           done = ( ebuf[ j + 1 ] == '%' ) || col + j == 6;
                        }
                     }
                     j--;

/* Backtrack through whitespace to find the last non-blank character before
   the potential line break. */
                     for ( we = j; isspace( ebuf[ we ] ) && we > i; we-- );

/* If this word won't fit on the current line, output a line break now. */
                     if ( we - i + col > 72 ) {

/* Set best indent value. */
                        ind = eindent[ i ];
                        if ( ind < 6 ) ind = 6;
                        if ( we - i + ind + 1 > 72 ) ind = 9;
                        if ( we - i + ind + 1 > 72 ) ind = 6;

/* Output the line break, unless we've just done one. */
                        if ( col != 7 ) {
                           putchar( '\n' );
                           for ( k = 1; k <= ind; k++ )
                              putchar( k == 6 ? ':' : ' ' );
                           col = ind + 1;
                        }
                     }

/* Now output the word. */
                     while ( i <= j ) {
                        if ( col > 72 && ! isspace( ebuf[ i ] ) ) {
                           putchar( '\n' );
                           for ( k = 1; k <= ind; k++ )
                              putchar( k == 6 ? ':' : ' ' );
                           col = ind;
                           fprintf( stderr, "%s: Ugly line break\n", name );
                        }
                        putchar( ebuf[ i ] );
                        col++;
                        i++;
                     }
                  }

               }

/* Output the newline and reset counters. */
               putchar( '\n' );
               epos = 0;
               hadint = 0;
            }
         }

/* If we have reached a line end, output the intermediate buffer. */
         if ( flag == LINE_END ) {
               for ( i = 0; i < epos; i++ ) putchar( ebuf[ i ] );
               epos = -1;
         }

      }
   }


   int tokmatch( int *toks, ... ) {   /* Last arg should be zero. */
/*
*+
*  Name:
*     tokmatch
*
*  Purpose:
*     Match lists of integers.
*
*  Description:
*     This matches a list of integers given as arguments against ones
*     in an array.  The given arguments are of variable number; the
*     last one should be a zero (this causes matching to stop).
*     If by the time the final (zero) argument is encountered no
*     mismatches have occurred, a true result is returned, but if
*     any mismatches occur matching attempts stop and a false (zero)
*     result is returned.
*
*  Arguments:
*     toks = int *
*        Start of an array of integers.
*     ... = int
*        A variable number of int arguments which are to be matched
*        against the list starting at toks.
*
*  Return value:
*     Unity if the lists match, zero if they don't.
*-
*/
       va_list ap;
       int mtok;

       va_start( ap, toks );
       while ( mtok = va_arg( ap, int ) ) {
          if ( mtok != *(toks++) ) {
             va_end( ap );
             return 0;
          }
       }
       va_end( ap );
       return 1;
   }



/* $Id$ */
