\documentclass[twoside,11pt]{article}

% ? Specify used packages
% \usepackage{graphicx}        %  Use this one for final production.
% \usepackage[draft]{graphicx} %  Use this one for drafting.
% ? End of specify used packages

\pagestyle{myheadings}

% -----------------------------------------------------------------------------
% ? Document identification
% Fixed part
\newcommand{\stardoccategory}  {Starlink System Note}
\newcommand{\stardocinitials}  {SSN}
\newcommand{\stardocsource}    {ssn\stardocnumber}

% Variable part - replace [xxx] as appropriate.
\newcommand{\stardocnumber}    {73.1}
\newcommand{\stardocauthors}   {Mark Taylor}
\newcommand{\stardocdate}      {17 January 2000}
\newcommand{\stardoctitle}     {EXTREME --- Handling extreme data sets}
\newcommand{\stardocabstract}  {
This package provides some utilities, background documentation,
and associated files
for adapting the Starlink Software Collection, and software which uses it, 
to handle very large data sets.
The principal focus of this is to move to use of 64 bits of address
space on 64-bit operating systems.
}
% ? End of document identification
% -----------------------------------------------------------------------------

% +
%  Name:
%     ssn.tex
%
%  Purpose:
%     Template for Starlink System Note (SSN) documents.
%     Refer to SUN/199
%
%  Authors:
%     AJC: A.J.Chipperfield (Starlink, RAL)
%     BLY: M.J.Bly (Starlink, RAL)
%     PWD: Peter W. Draper (Starlink, Durham University)
%     MBT: Mark B. Taylor (Starlink)
%
%  History:
%     17-JAN-1996 (AJC):
%        Original with hypertext macros, based on MDL plain originals.
%     16-JUN-1997 (BLY):
%        Adapted for LaTeX2e.
%     13-AUG-1998 (PWD):
%        Converted for use with LaTeX2HTML version 98.2 and
%        Star2HTML version 1.3.
%     17-JAN-1999 (MBT):
%        Instantiated as SSN/73.
%     {Add further history here}
%
% -

\newcommand{\stardocname}{\stardocinitials /\stardocnumber}
\markboth{\stardocname}{\stardocname}
\setlength{\textwidth}{160mm}
\setlength{\textheight}{230mm}
\setlength{\topmargin}{-2mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\setlength{\unitlength}{1mm}

% -----------------------------------------------------------------------------
%  Hypertext definitions.
%  ======================
%  These are used by the LaTeX2HTML translator in conjunction with star2html.

%  Comment.sty: version 2.0, 19 June 1992
%  Selectively in/exclude pieces of text.
%
%  Author
%    Victor Eijkhout                                      <eijkhout@cs.utk.edu>
%    Department of Computer Science
%    University Tennessee at Knoxville
%    104 Ayres Hall
%    Knoxville, TN 37996
%    USA

%  Do not remove the %begin{latexonly} and %end{latexonly} lines (used by 
%  LaTeX2HTML to signify text it shouldn't process).
%begin{latexonly}
\makeatletter
\def\makeinnocent#1{\catcode`#1=12 }
\def\csarg#1#2{\expandafter#1\csname#2\endcsname}

\def\ThrowAwayComment#1{\begingroup
    \def\CurrentComment{#1}%
    \let\do\makeinnocent \dospecials
    \makeinnocent\^^L% and whatever other special cases
    \endlinechar`\^^M \catcode`\^^M=12 \xComment}
{\catcode`\^^M=12 \endlinechar=-1 %
 \gdef\xComment#1^^M{\def\test{#1}
      \csarg\ifx{PlainEnd\CurrentComment Test}\test
          \let\html@next\endgroup
      \else \csarg\ifx{LaLaEnd\CurrentComment Test}\test
            \edef\html@next{\endgroup\noexpand\end{\CurrentComment}}
      \else \let\html@next\xComment
      \fi \fi \html@next}
}
\makeatother

\def\includecomment
 #1{\expandafter\def\csname#1\endcsname{}%
    \expandafter\def\csname end#1\endcsname{}}
\def\excludecomment
 #1{\expandafter\def\csname#1\endcsname{\ThrowAwayComment{#1}}%
    {\escapechar=-1\relax
     \csarg\xdef{PlainEnd#1Test}{\string\\end#1}%
     \csarg\xdef{LaLaEnd#1Test}{\string\\end\string\{#1\string\}}%
    }}

%  Define environments that ignore their contents.
\excludecomment{comment}
\excludecomment{rawhtml}
\excludecomment{htmlonly}

%  Hypertext commands etc. This is a condensed version of the html.sty
%  file supplied with LaTeX2HTML by: Nikos Drakos <nikos@cbl.leeds.ac.uk> &
%  Jelle van Zeijl <jvzeijl@isou17.estec.esa.nl>. The LaTeX2HTML documentation
%  should be consulted about all commands (and the environments defined above)
%  except \xref and \xlabel which are Starlink specific.

\newcommand{\htmladdnormallinkfoot}[2]{#1\footnote{#2}}
\newcommand{\htmladdnormallink}[2]{#1}
\newcommand{\htmladdimg}[1]{}
\newcommand{\hyperref}[4]{#2\ref{#4}#3}
\newcommand{\htmlref}[2]{#1}
\newcommand{\htmlimage}[1]{}
\newcommand{\htmladdtonavigation}[1]{}

\newenvironment{latexonly}{}{}
\newcommand{\latex}[1]{#1}
\newcommand{\html}[1]{}
\newcommand{\latexhtml}[2]{#1}
\newcommand{\HTMLcode}[2][]{}

%  Starlink cross-references and labels.
\newcommand{\xref}[3]{#1}
\newcommand{\xlabel}[1]{}

%  LaTeX2HTML symbol.
\newcommand{\latextohtml}{\LaTeX2\texttt{HTML}}

%  Define command to re-centre underscore for Latex and leave as normal
%  for HTML (severe problems with \_ in tabbing environments and \_\_
%  generally otherwise).
\renewcommand{\_}{\texttt{\symbol{95}}}

% -----------------------------------------------------------------------------
%  Debugging.
%  =========
%  Remove % on the following to debug links in the HTML version using Latex.

% \newcommand{\hotlink}[2]{\fbox{\begin{tabular}[t]{@{}c@{}}#1\\\hline{\footnotesize #2}\end{tabular}}}
% \renewcommand{\htmladdnormallinkfoot}[2]{\hotlink{#1}{#2}}
% \renewcommand{\htmladdnormallink}[2]{\hotlink{#1}{#2}}
% \renewcommand{\hyperref}[4]{\hotlink{#1}{\S\ref{#4}}}
% \renewcommand{\htmlref}[2]{\hotlink{#1}{\S\ref{#2}}}
% \renewcommand{\xref}[3]{\hotlink{#1}{#2 -- #3}}
%end{latexonly}
% -----------------------------------------------------------------------------
% ? Document specific \newcommand or \newenvironment commands.


%+
%  Name:
%     SST.TEX

%  Purpose:
%     Define LaTeX commands for laying out Starlink routine descriptions.

%  Language:
%     LaTeX

%  Type of Module:
%     LaTeX data file.

%  Description:
%     This file defines LaTeX commands which allow routine documentation
%     produced by the SST application PROLAT to be processed by LaTeX and
%     by LaTeX2html. The contents of this file should be included in the
%     source prior to any statements that make of the sst commnds.

%  Notes:
%     The style file html.sty provided with LaTeX2html needs to be used.
%     This must be before this file.

%  Authors:
%     RFWS: R.F. Warren-Smith (STARLINK)
%     PDRAPER: P.W. Draper (Starlink - Durham University)

%  History:
%     10-SEP-1990 (RFWS):
%        Original version.
%     10-SEP-1990 (RFWS):
%        Added the implementation status section.
%     12-SEP-1990 (RFWS):
%        Added support for the usage section and adjusted various spacings.
%     8-DEC-1994 (PDRAPER):
%        Added support for simplified formatting using LaTeX2html.
%     {enter_further_changes_here}

%  Bugs:
%     {note_any_bugs_here}

%-

%  Define length variables.
\newlength{\sstbannerlength}
\newlength{\sstcaptionlength}
\newlength{\sstexampleslength}
\newlength{\sstexampleswidth}

%  Define a \tt font of the required size.
\latex{\newfont{\ssttt}{cmtt10 scaled 1095}}
\html{\newcommand{\ssttt}{\tt}}

%  Define a command to produce a routine header, including its name,
%  a purpose description and the rest of the routine's documentation.
\newcommand{\sstroutine}[3]{
   \newpage
   \label{#1}
   \goodbreak
   \rule{\textwidth}{0.5mm}
   \vspace{-7ex}
   \newline
   \settowidth{\sstbannerlength}{{\Large {\bf #1}}}
   \setlength{\sstcaptionlength}{\textwidth}
   \setlength{\sstexampleslength}{\textwidth}
   \addtolength{\sstbannerlength}{0.5em}
   \addtolength{\sstcaptionlength}{-2.0\sstbannerlength}
   \addtolength{\sstcaptionlength}{-5.0pt}
   \settowidth{\sstexampleswidth}{{\bf Examples:}}
   \addtolength{\sstexampleslength}{-\sstexampleswidth}
   \parbox[t]{\sstbannerlength}{\flushleft{\Large {\bf #1}}}
   \parbox[t]{\sstcaptionlength}{\center{\Large #2}}
   \parbox[t]{\sstbannerlength}{\flushright{\Large {\bf #1}}}
   \begin{description}
      #3
   \end{description}
}

%  Format the description section.
\newcommand{\sstdescription}[1]{\item[Description:] #1}

%  Format the usage section.
\newcommand{\sstusage}[1]{\item[Usage:] \mbox{}
   \begin{description}
      {\ssttt \item #1}
   \end{description}
}
% \newcommand{\sstusage}[1]{\item[Usage:] \mbox{}
% \\[1.3ex]{\raggedright \ssttt #1}}

%  Format the invocation section.
\newcommand{\sstinvocation}[1]{\sloppy \item[Invocation:]\hspace{0.4em}{\tt #1}}
%\newcommand{\sstinvocation}[1]{\item[Invocation:]\hspace{0.4em}{\tt #1}}

%  Format the arguments section.
\newcommand{\sstarguments}[1]{
   \item[Arguments:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the returned value section (for a function).
\newcommand{\sstreturnedvalue}[1]{
   \item[Returned Value:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the parameters section (for an application).
\newcommand{\sstparameters}[1]{
   \item[Parameters:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the examples section.
\newcommand{\sstexamples}[1]{
   \item[Examples:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Define the format of a subsection in a normal section.
\newcommand{\sstsubsection}[1]{ \item[{#1}] \mbox{} \\}

%  Define the format of a subsection in the examples section.
\newcommand{\sstexamplesubsection}[2]{\sloppy \item{\ssttt #1} \mbox{} \\ #2 }
%\newcommand{\sstexamplesubsection}[2]{\sloppy
%\item[\parbox{\sstexampleslength}{\ssttt #1}] \mbox{} \vspace{1.0ex}
%\\ #2 }

%  Format the notes section.
\newcommand{\sstnotes}[1]{\item[Notes:] \mbox{} \\[1.3ex] #1}

%  Provide a general-purpose format for additional (DIY) sections.
\newcommand{\sstdiytopic}[2]{\item[#1:] \mbox{} \\[1.3ex] #2}
%\newcommand{\sstdiytopic}[2]{\item[{\hspace{-0.35em}#1\hspace{-0.35em}:}]
%\mbox{} \\[1.3ex] #2}

%  Format the implementation status section.
\newcommand{\sstimplementationstatus}[1]{
   \item[{Implementation Status:}] \mbox{} \\[1.3ex] #1}

%  Format the bugs section.
\newcommand{\sstbugs}[1]{\item[Bugs:] #1}

%  Format a list of items while in paragraph mode.
\newcommand{\sstitemlist}[1]{
  \mbox{} \\
  \vspace{-3.5ex}
  \begin{itemize}
     #1
  \end{itemize}
}

%  Define the format of an item.
\newcommand{\sstitem}{\item}

%% Now define html equivalents of those already set. These are used by
%  latex2html and are defined in the html.sty files.
\begin{htmlonly}

%  sstroutine.
   \newcommand{\sstroutine}[3]{
      \subsection{#1\xlabel{#1}-\label{#1}#2}
      \begin{description}
         #3
      \end{description}
   }

%  sstdescription
   \newcommand{\sstdescription}[1]{\item[Description:]
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstusage
   \newcommand{\sstusage}[1]{\item[Usage:]
      \begin{description}
         {\ssttt #1}
      \end{description}
      \\
   }

%  sstinvocation
   \newcommand{\sstinvocation}[1]{\item[Invocation:]
      \begin{description}
         {\ssttt #1}
      \end{description}
      \\
   }

%  sstarguments
   \newcommand{\sstarguments}[1]{
      \item[Arguments:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstreturnedvalue
   \newcommand{\sstreturnedvalue}[1]{
      \item[Returned Value:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstparameters
   \newcommand{\sstparameters}[1]{
      \item[Parameters:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstexamples
   \newcommand{\sstexamples}[1]{
      \item[Examples:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstsubsection
   \newcommand{\sstsubsection}[1]{\item[{#1}]}

%  sstexamplesubsection
   \newcommand{\sstexamplesubsection}[2]{\item[{\ssttt #1}] #2}

%  sstnotes
   \newcommand{\sstnotes}[1]{\item[Notes:] #1 }

%  sstdiytopic
   \newcommand{\sstdiytopic}[2]{\item[{#1}] #2 }

%  sstimplementationstatus
   \newcommand{\sstimplementationstatus}[1]{
      \item[Implementation Status:] #1
   }

%  sstitemlist
   \newcommand{\sstitemlist}[1]{
      \begin{itemize}
         #1
      \end{itemize}
      \\
   }
%  sstitem
   \newcommand{\sstitem}{\item}

\end{htmlonly}

%  End of "sst.tex" layout definitions.


% ? End of document specific commands
% -----------------------------------------------------------------------------
%  Title Page.
%  ===========
\renewcommand{\thepage}{\roman{page}}
\begin{document}
\thispagestyle{empty}

%  Latex document header.
%  ======================
\begin{latexonly}
   CCLRC / \textsc{Rutherford Appleton Laboratory} \hfill \textbf{\stardocname}\\
   {\large Particle Physics \& Astronomy Research Council}\\
   {\large Starlink Project\\}
   {\large \stardoccategory\ \stardocnumber}
   \begin{flushright}
   \stardocauthors\\
   \stardocdate
   \end{flushright}
   \vspace{-4mm}
   \rule{\textwidth}{0.5mm}
   \vspace{5mm}
   \begin{center}
   {\Large\textbf{\stardoctitle}}
   \end{center}
   \vspace{5mm}

% ? Heading for abstract if used.
   \vspace{10mm}
   \begin{center}
      {\Large\textbf{Abstract}}
   \end{center}
% ? End of heading for abstract.
\end{latexonly}

%  HTML documentation header.
%  ==========================
\begin{htmlonly}
   \xlabel{}
   \begin{rawhtml} <H1> \end{rawhtml}
      \stardoctitle
   \begin{rawhtml} </H1> <HR> \end{rawhtml}

   \begin{rawhtml} <P> <I> \end{rawhtml}
   \stardoccategory\ \stardocnumber \\
   \stardocauthors \\
   \stardocdate
   \begin{rawhtml} </I> </P> <H3> \end{rawhtml}
      \htmladdnormallink{CCLRC / Rutherford Appleton Laboratory}
                        {http://www.cclrc.ac.uk} \\
      \htmladdnormallink{Particle Physics \& Astronomy Research Council}
                        {http://www.pparc.ac.uk} \\
   \begin{rawhtml} </H3> <H2> \end{rawhtml}
      \htmladdnormallink{Starlink Project}{http://www.starlink.rl.ac.uk/}
   \begin{rawhtml} </H2> \end{rawhtml}
   \htmladdnormallink{\htmladdimg{source.gif} Retrieve hardcopy}
      {http://www.starlink.rl.ac.uk/cgi-bin/hcserver?\stardocsource}\\

%  HTML document table of contents. 
%  ================================
%  Add table of contents header and a navigation button to return to this 
%  point in the document (this should always go before the abstract \section). 
  \label{stardoccontents}
  \begin{rawhtml} 
    <HR>
    <H2>Contents</H2>
  \end{rawhtml}
  \htmladdtonavigation{\htmlref{\htmladdimg{contents_motif.gif}}
        {stardoccontents}}

% ? New section for abstract if used.
  \section{\xlabel{abstract}Abstract}
% ? End of new section for abstract

\end{htmlonly}

% -----------------------------------------------------------------------------
% ? Document Abstract. (if used)
%  ==================
\stardocabstract
% ? End of document abstract
% -----------------------------------------------------------------------------
% ? Latex document Table of Contents (if used).
%  ===========================================
  \newpage
  \begin{latexonly}
    \setlength{\parskip}{0mm}
    \tableofcontents
    \setlength{\parskip}{\medskipamount}
    \markboth{\stardocname}{\stardocname}
  \end{latexonly}
% ? End of Latex document table of contents
% -----------------------------------------------------------------------------
\cleardoublepage
\renewcommand{\thepage}{\arabic{page}}
\setcounter{page}{1}



% ? Main text

% Private macro definitions.

\newcommand{\xroutine}[1]{\htmlref{{\tt #1}}{#1}}
\newcommand{\file}[1]{{\tt #1}}
\newcommand{\routine}[1]{{\tt #1}}
\newcommand{\cc}[1]{{\tt #1}}
\newenvironment{squote}{\begin{quote}\begin{small}}{\end{small}\end{quote}}

\section{Introduction}

The Extreme Dataset project is intended to allow processing of ``unusually''
large data sets by Starlink software, 
although the sizes for which special measures
are required will become less and less unusual as time goes on.
The principal underlying problem is that as images get larger
32 bits are no longer enough to index into an image.
The largest integer that can be stored in 32 bits 
is approximately $4 \times 10^9$ (unsigned) or $2 \times 10^9$ (signed).
If the operating system itself uses unsigned 32 bit pointers to 
address bytes
in memory, this means that it is impossible to map into memory 
an image of more
than 4Gbyte or, say, two images of half that size. 
This could correspond to, for instance, an input and an output image
simultaneously mapped each with an HDS type of \_DOUBLE and 
size of 16k pixels square.

For this sort of work therefore an operating system with 64-bit 
pointers is required.

For the systems supported by
Starlink this currently means that Compaq Tru64 Unix can be used,
as can Solaris running in 64-bit mode.  
On appropriate hardware the Solaris kernel 
may be compiled for 32 bit or 64 bit mode;
but almost\footnote{
   There can be trouble with applications which use 
   \file{libkvm} or access \file{/proc}.}
all binaries which run on the 32-bit version
will run equally well on the 64-bit version, 
so that reconfiguring a system from 32-bit to 64-bit should be
fairly painless from a software point of view.
You can tell if your Solaris kernel is 64-bit 
by using the \file{isainfo -v} command; on a 64-bit system the
following response will be given
\begin{squote}
\begin{verbatim}
% isainfo -v
64-bit sparcv9 applications
32-bit sparc applications
\end{verbatim}
\end{squote}

User code will also run up against these problems.
It is often necessary to count the pixels, or the bytes,
in an image, and this is typically done using a Fortran INTEGER
or a C \cc{int}.  These are normally signed 32-bit values, with
a maximum value of about $2 \times 10^9$; the pixel count of a 
47k $\times$ 47k image, or the byte count of a 16k $\times$ 16k 
\_DOUBLE image, will overflow this limit.

Another common requirement is holding a pointer 
to allocated memory, which has ultimately been 
acquired from a C routine such as \cc{malloc}, 
in a variable.
In C this will be taken care of automatically because the compiler
will ensure that a pointer type is long enough to hold memory addresses.
In Fortran however there is no pointer type so that INTEGERs, which are
normally 32 bits, have to be used.
The solution to this, explained in \xref{SUN/209}{sun209}{pointers},
is to use the \xref{CNF\_PVAL}{sun209}{CNF\_PVAL} function.

This package provides some tools and instructions for 
software maintainers to use 
in modifying their source code to take advantage of a 64-bit environment.

The issues addressed in this document apply to user programs which link
against Starlink libraries as well as to the code which forms the USSC;
if the USSC has been built for a 64-bit system, then user code 
which uses its libraries will need to be modified at the 
source level in order to work.
Depending on the complexity of the code, it may be easier to do this
with a few manual adjustments than by using the automatic 
tools supplied with the EXTREME package.  
The discussion here should be of use in any case.


\section{Changeover to 64-bit systems}

In general, it is not possible to modify packages to deal with large
images independently of each other;
before changing a package to use 64 bits, it is necessary 
that all the packages on which it depends are 64-bit compatible.
Certain packages, which are used only at a command-line level, 
may not need changes to the code, but any package which provides a library 
against which other code is to link must be modified,
since the public interfaces of the routines,
specifically the types of integer arguments, will change. 
Additionally, in the case of Solaris,
32-bit and 64-bit object types cannot be mixed by the link loader.

At some point in the future, it may be that support for 32-bit systems
is dropped, but at the moment this is undesirable, since 
Solaris systems running 32-bit kernels would be incapable of running
code compiled for 64 bits.  
Older Suns (before SPARC v9) cannot be made to run the 64-bit kernels.

For these reasons, the transfer to 64 bits will be approached
effectively as ports to new systems.  All Starlink packages should
therefore come to 
include support for two new values of the \file{makefile}/\file{mk}
SYSTEM variable: ``alpha\_OSF1\_64'' and ``sun4\_Solaris\_64''.



\section{Modifications to code\label{sec:modificienda}}

Making Starlink packages able to run in a 64-bit environment and 
handle appropriately large data sets requires changes to the source
code of each package.
For packages like \xref{HDS}{sun92}{}, 
which get their hands dirty with data structures on disk,
extensive changes are required.
Most packages however can hopefully be fixed by making some more-or-less
automatic changes to the source code.
These changes boil down to making sure that Fortran pointers 
can address any allocated memory,
and making sure that non-pointer integers in Fortran and C 
have enough bits to hold sufficiently large numbers.

Because of the difficulty of distinguishing, in any automatic fashion,
variables which may 
need to hold big numbers from those which will not,
the recommended approach is to change the type of {\em all\/} 
integer variables to a 64-bit type in 64-bit environments.
There are undesirable consequences of this,
the main one being that 
the HDS type \_INTEGER becomes, as far as the HDS user is concerned,
a 64-bit type 
{\it (though it will still be stored on disk in 32 bits??)\/}.
Where images are mapped with \_INTEGER type in the new system therefore, 
they will take up twice as much space as they need to in memory,
and the process of mapping and unmapping them can be expected to be slower.
There is nothing much to be done about this;
fortunately, \_INTEGER should not be a very common type for
storing large data arrays in an NDF.

Once the increase in integer size has been made 
globally to the source code in a package,
it is possible to identify variables which do not need the extra size
and change their declarations (and other parts of the code which depend
on these) back to the normal integer types.
In most cases such retrochanges will not be worthwhile, 
but they could be appropriate in either of the following situations:
\begin{itemize}
\item
The change has broken something which is easier to fix by returning to 
a normal integer size than by other means
\item
The change results in significant overuse of resources, 
and returning to a normal
integer size will not cause too many problems.
\end{itemize}


\subsection{Pointer references in Fortran}

As explained in \xref{SUN/209}{sun209}{pointers},
whenever the \%VAL Fortran compiler directive 
is used to pass the value of registered allocated
memory to a subroutine, its argument should be wrapped in a call
to \xref{CNF\_PVAL}{sun209}{CNF\_PVAL}.  This effectively allows
a 32-bit integer to address memory in a 64-bit address space.
This call could in principle be avoided 
where code is written using long integers as
described in section \ref{sec:fint}, but it is necessary as an intermediate
measure where Fortran is written using normal integers in a
64-bit environment.
This includes the case of SYSTEM=alpha\_OSF1 (as opposed to alpha\_OSF1\_64),
which is to be supported for the forseeable future, so even where the
move to large integers is to be made, these calls should be incorporated.
Since this change is less problematic than the move to large integers,
it is possible, and advisable, to make this
change to all code and test it before converting the normal integer types
as described in section \ref{sec:fint}.  

As well as the calls to CNF\_PVAL themselves, 
the header file \file{CNF\_PAR} needs to be included
in affected source files to provide the declaration of the CNF\_PVAL function.

The main pitfall of making these modifications is
wrapping the argument of a \%VAL in a CNF\_PVAL call when it ought
not to be so wrapped.
CNF\_PVAL should {\em only\/} be applied to registered pointers.
If your Fortran code uses pointers which are got from C without 
being registered with CNF, you'll need to address this in the C code 
as described in \xref{SUN/209}{sun209}{pointers}.
More commonly, you may have \%VAL invocations which are not
applied to pointers at all --- for instance when passing 
the lengths of character variables as trailing arguments 
as sometimes needs to be done when the compiler doesn't know that
it's passing a character variable.  In this case the \%VAL 
invocation should be left alone and no call to CNF\_PVAL inserted.
In general, it is impossible to spot all such non-pointer uses
of \%VAL automatically.  However, if \%VAL is applied to a constant,
or a small integer, then it should be left alone.

The program \xroutine{inscnf}, and the corresponding driver script 
\routine{do\_inscnf}, is supplied for inserting CNF\_PVALs
in the right places.  It wraps {\em all\/} arguments of \%VAL 
in calls to CNF\_PVAL, but emits warnings for those which look like
they may not be pointers.  It is described further in section 
\ref{sec:tools}.


\subsection{Enlarging integer type in Fortran\label{sec:fint}}


In Fortran there is no (even slightly) portable way of declaring
an integer to be of a configurable length. 
Therefore all variables currently declared as `INTEGER' 
should be changed instead to type `INTEGER*8'. 
This is not standard Fortran 77, but it is widely understood by compilers.
This should not be interpreted (by a human) as an indication that exactly
eight bytes are required, but as an indication that 
the variable in question needs to be
long enough to hold a large number.
At compile time, typically on 64-bit systems the code will be compiled
as it stands, while on 32-bit systems a simple \file{sed(1)} command or similar
can preprocess the source code before it is fed to the compiler,
under makefile control (see section \ref{sec:makefile}).

Having done this, the following issues may need to be addressed.
\begin{description}
%
\item[External libraries]\mbox{}
\\
In Fortran, the actual arguments used in a subroutine/function
call must be of the same type as the formal arguments declared
in the routine itself, since arguments are passed by address.
Thus if you change the type of integers passed to a subroutine,
you have to change the type of the integers declared in the subroutine too.
It is therefore necessary either to convert any called subroutines
to using the new integer type (at least as far as their arguments go), 
or to ensure that any calls to these routines use variables of 
the old integer type.
Thus a package can only be successfully converted to large integers
and built once all the libraries against which it links have been 
similarly converted.  The Starlink libraries will therefore have to
be done before applications packages.
If a program uses an external library which is not part of the USSC,
then either the library will have to be converted in the same way,
or the affected calls will have to be written using 
variables specially declared as the normal INTEGER type.
%
\item[Literal integer constants as arguments]\mbox{}
\\
If there are any calls to functions or subroutines in the converted 
code which have literal integer constants as actual arguments,
these will need to be replaced with expressions of the right type.
There is no way of specifying the length of a literal integer constant
in Fortran, so you should either use a variable for the purpose 
(perhaps assigned using the Fortran PARAMETER statement) 
or ensure that the expression
has the correct type.  This can be done using a call to the statement
function EXT\_ITOX, which returns an integer equal in value to its
argument, but of the correct type for a large integer
(it behaves just like the NUM\_xTOy functions in the 
\xref{PRIMDAT}{sun39}{} package).
Thus
\begin{squote}
\begin{verbatim}
      CALL SUB( 5, STATUS )
\end{verbatim}
\end{squote}
must be changed to something like
\begin{squote}
\begin{verbatim}
      INTEGER * 8 IFIVE
      PARAMETER( IFIVE = 5 )
        ...
      CALL SUB( IFIVE, STATUS )
\end{verbatim}
\end{squote}
or
\begin{squote}
\begin{verbatim}
      INCLUDE 'EXT_DEC'          ! EXTREME conversion declarations
      INCLUDE 'EXT_DEF'          ! EXTREME conversion definitions
        ...
      CALL SUB( EXT_ITOX( 5 ), STATUS )
\end{verbatim}
\end{squote}
Note that, as for the PRIMDAT file PRM\_DEF, the EXT\_DEF 
file must be included after all variable declarations but before
the first executable statement of the routine.

For convenience another mechanism is provided by the EXTREME package;
the file \file{EXT\_PAR} includes definitions of the integers
$-10$\ldots 10, with names EXT\_\_M10\ldots EXT\_\_10.
So a third alternative for the above situation would be
\begin{squote}
\begin{verbatim}
      INCLUDE 'EXT_PAR'          ! Integer constant definitions
        ...
      CALL SUB( EXT__5, STATUS )
\end{verbatim}
\end{squote}
{\it (Perhaps this functionality should be handed to PRIMDAT?)}
%
\item[Intrinsic functions]\mbox{}
\\
Calls to standard Fortran intrinsic functions should take care of themselves,
as long as the generic name is used rather than the specific one
(e.g. you should use ABS instead of IABS),
since they adapt themselves automatically to the type of their argument.  
Use of generic names is generally good practice anyway;
the only time it is necessary to supply the specific name is 
when passing an intrinsic function itself as an actual argument
to a procedure, which is pretty rare.
The only intrinsic functions in standard Fortran 77 which have 
INTEGER-specific names are IABS, ISIGN, IDIM, MAX0, AMAX0, MIN0 and AMIN0.

There are some non-standard intrinsic functions which require INTEGER
arguments, and will cause trouble if they have INTEGER*8 arguments.
These are mostly system-specific ones, such as GETARG,
and are likely only to be used in fairly low level code.

A related problem is using a call to an intrinsic function with 
an integer return type as an actual argument to a function.
Since for most functions the return type is the same as the argument,
this will, again, take care of itself.  However, for the few
intrinsic functions which return integer regardless of the type of
the argument (LEN, INDEX), the return value will have to be converted to
the correct type as if it were an integer literal, as described above.
%
\item[Storage association]\mbox{}
\\
The Fortran 77 standard does not state how much storage is used by
an INTEGER, but does state that it should be the same amount as that
used by REALs and LOGICALs.
Converting all INTEGERs to INTEGER*8s will
normally have the effect that this is no longer the case.
Thus code which relies on this, for instance by using COMMON blocks or
EQUIVALENCE statements to address the same memory as both INTEGER and REAL,
will break.  
Such practices are, as you might expect, deprecated by the 
\xref{Starlink Application Programming Standard}{sgp16}{},
but there may be instances of them lurking about.

Similarly, code which makes the assumption that four elements of
a CHARACTER array correspond to each INTEGER will need changing.
%
\item[Storage alignment]\mbox{}
\\
64-bit data types on Sun and Alpha systems should be aligned on 
64-bit boundaries for performance reasons.
Normally this is taken care of automatically by the compiler, 
but in COMMON blocks (or EQUIVALENCE?) the address of a 
variable is determined by the source code, so that the compiler
is not free to move it around (the start of a COMMON block is
always aligned to the largest boundary, 64 bits).
Thus the following code:
\begin{squote}
\begin{verbatim}
      REAL        XX, YY
      INTEGER * 8 IX, IY
      COMMON /BLOCK/ XX, IX, YY, IY
\end{verbatim}
\end{squote}
which would align everything (happily) on 32-bit boundaries if IX, IY
were INTEGER*4s, will be forced to align the 64-bit IX on a 32-bit
boundary.
The compilers will warn about this behaviour.
I believe that on the supported platforms this only 
results in slower, rather than incorrect, executables, 
but I have not found assurances of this in the documentation.
%
\item[IMPLICIT variable declarations]\mbox{}
\\
It is highly desirable in Fortran, and usual in Starlink code, to use
the ``IMPLICIT NONE'' declaration, so that all variables have to be
explicitly declared before use.
It would be possible to fix this by redeclaring IMPLICIT INTEGER
statements as IMPLICIT INTEGER*8, but to make the job easier for
the makefile in editing the source code, it is better to place
an ``IMPLICIT NONE'' statement in every source code module, and
make explicit INTEGER*8 declarations for all integers.
%
\item[I/O return values]\mbox{}
\\
A few Fortran I/O statements have specifiers which require the name
of an INTEGER variable.  In standard Fortran 77 these are 
IOSTAT in all I/O statements, and 
NUMBER, RECL and NEXTREC in the INQUIRE statement.
Particular compilers often provide a whole bunch more, but these
should hopefully not be much used in Starlink code.
So there may be a problem with a statement like
\begin{squote}
\begin{verbatim}
      CLOSE( UNIT = 99, IOSTAT = STVAL )
\end{verbatim}
\end{squote}
if the variable STVAL is now declared INTEGER*8 rather than INTEGER.
Of the supported systems, Tru64 and Solaris seem to handle 
INTEGER*8 variables used for this purpose without complaint.
Linux with g77 0.5.24 may fail to compile although (a) it seems to
be OK if you compile with {\tt -O}, and (b) this is reportedly
fixed at g77 0.5.25.  So it's probably all right to leave these cases.
%
\end{description}

The program \xroutine{frepint} is provided for changing 
INTEGER declarations to INTEGER*8.
Details of which of the above constructs it fixes, and which it
warns about, are given in section \ref{sec:tools}.


\subsection{Enlarging integer type in C\label{sec:cint}}

All references to the type \cc{int} in C code should be changed to 
\cc{INT\_BIG}.  This is a reference to a macro which can be defined
in a header file or on the compiler command line 
(and hence typically in the \file{mk} environment variable CFLAGS).  
For a 32-bit build it would normally be defined at build time as 
\cc{int} and for a 64-bit build as \cc{long}.
As well as declarations of variables and functions, this applies
to almost any other syntactically significant occurrence of the
identifier \cc{int}, for instance casts and arguments of \cc{sizeof}.
References to the types \cc{short~int} and \cc{long~int},
which are just synonyms for \cc{short} and \cc{long} respectively,
should not be changed.  Type \cc{unsigned~INT\_BIG} 
(or, redundantly, \cc{signed~INT\_BIG}) may be used.
There are some places where an \cc{int} declaration is implicit,
and here an \cc{INT\_BIG} must be inserted.

As regards calling functions from external libraries,
the approach described in section \ref{sec:fint} of 
recoding all the functions in the library will of course work in C
as well as in Fortran.
However, this is not always necessary.
If the function's ANSI C-style declaration (prototype) is in scope when 
the function is called,
the compiler will normally arrange for conversion
of each actual argument to the declared type of
the corresponding formal argument in the declaration 
before passing it by value.
Hence the following code
\begin{squote}
\begin{verbatim}
int add( int a, int b );
INT_BIG i, j;
add( i, j );
\end{verbatim}
\end{squote}
is correct whatever type \cc{INT\_BIG} is defined as, 
since \cc{i} and \cc{j} are converted to type \cc{int}
before \cc{add()} sees them.
If the prototype of \cc{add()} were not in scope however,
the conversion would not take place and the code would be
in error.\footnote{
   In fact, the standard says simply that the effect of the call is
   undefined in this case.  Furthermore, it seems that the three
   currently supported systems handle these cases without
   any undesirable behaviour; presumably the compilers are written
   such that all arguments are passed in 64 bits or in registers.
   But such code is still not correct.
}
The lesson is to make sure that header files are
included.
Of course this relies on having ANSI C-style function prototypes;
if old-style function declarations are used then no argument type
conversions are made.  For code which uses old-style function 
declarations it is probably best to convert it, 
or at least a corresponding header file, 
to ANSI C style.

However this does not solve all problems.
Where a function has a variable argument list
(as declared in the prototype using ellipsis `\cc{...}'
and handled in the function using the \file{stdarg.h} macros), 
the function prototype
is not able to specify the types of all arguments,
and so the type of the actual argument must match the type of
the formal argument for correctness.  If it is impractical
to recode the function (as in the case of \cc{printf}),
the best solution is to cast the variable arguments to the type
which is expected where the function is called.

A more difficult problem is when the address of an argument is
passed so that the contents of that address can be changed by
the function.  In this case if the called function has a
different idea of the length of the object being pointed to
it will write to the wrong amount of memory, possibly overwriting
other data.  Consider this function:
\begin{squote}
\begin{verbatim}
   void zero( int *a ) { 
      *a = 0; 
   }
\end{verbatim}
\end{squote}
and this code:
\begin{squote}
\begin{verbatim}
   INT_BIG x;
   zero( &x );
\end{verbatim}
\end{squote}
If \cc{INT\_BIG} is a 64 bit type and \cc{int} is 32 bits
then only half the bits in the variable \cc{x} will be zeroed by this call.
If the function declaration is in scope when the call is made,
the compiler will issue a pointer mismatch warning about this sort of thing; 
again, make sure that the appropriate header files are included.
Again, in the case of variable argument lists, the compiler can't spot it.

To summarise, external functions should be declared before use by
including the appropriate header files.  If this is done, then the only
problems associated with calling functions which have not been
converted to use \cc{INT\_BIG} instead of \cc{int} should be:
\begin{description}
%
\item[INT\_BIG in variable part of argument list:]
A modified caller of an unmodified function should explicitly cast
an \cc{INT\_BIG} argument in the variable (\cc{...}) part of the argument
list.  
Normally the cast should be to \cc{int}, but it may be possible,
as with \cc{printf}, to cast to \cc{long} and indicate to the called
function that this has been done.
A modified function which may get called by unmodified code
should expect arguments of type \cc{int}
(i.e.\ should call the \cc{va\_arg} macro with a second argument
of \cc{int} instead of \cc{INT\_BIG}).
See the \cc{printf} example below.
%
\item[Pointer to INT\_BIG variable passed:]
A modified caller of an unmodified function will have to declare
a local variable of type \cc{int} and exchange values between it
and the \cc{INT\_BIG} before, and possibly after, the call.
A modified function which may get called by unmodified code 
will have to declare pointer arguments as pointers to a given fixed
type (presumably \cc{int}), not to \cc{INT\_BIG}.
\item[Overflow:]
If an \cc{INT\_BIG} value which is too large to be an \cc{int}
is passed to a variable which is an \cc{int}, arithmetic overflow will
occur when C tries to do the type conversion according to the function
declaration.
No warning is issued by the Solaris or Tru64 C runtime systems about
such overflows.
See the \cc{scanf} example below.
\end{description}


External libraries which code may have to link against
can be split into a few categories:
\begin{description}
%
\item[Starlink libraries]\mbox{}
\\
As with Fortran, the plan is for Starlink libraries to get converted
to use \cc{INT\_BIG}
before code which uses them (although for C code calling C libraries
this is not so necessary as with Fortran when functions are pre-declared
using header files).
%
\item[Blocks of source code not to be converted:]\mbox{}
\\
It may not be a good idea to do \cc{INT\_BIG} conversion to
large bodies of non-Starlink code used by the USSC; Perl and Tcl
spring to mind.  
If there is function-level access to these packages,
some recoding may be required as above.
%
\item[The C standard library:]\mbox{}
\\
The functions of the C standard library are no different from any
other unconverted external library, but since their use is
common, it is discussed in detail here.
Most of the functions in the standard library will be handled
adequately as described above by including the appropriate header files,
since they do not have \cc{int~*} arguments or variable argument lists.
The exceptions are those which use format strings:
\cc{printf}, \cc{fprintf}, \cc{sprintf} and 
\cc{scanf}, \cc{fscanf}, \cc{sscanf}; these fall foul of both obstacles.
For \cc{printf} and friends 
any of the format specifiers \cc{cdiouxX*}\footnote{
   Inclusion of the \cc{c} format specifier here is not a mistake.
   Although the corresponding argument will typically be of type \cc{char},
   it is promoted to \cc{int} by the usual mechanism before being 
   passed to \cc{printf}.  If the type of the actual argument is
   of type \cc{char} and not type \cc{INT\_BIG} of course, no change 
   will be required here.
}
indicate that the corresponding argument should be an \cc{int},
and the \cc{n} specifier indicates a pointer to \cc{int}.
For \cc{scanf} and friends, any of the specifiers \cc{diouxXn} indicate
pointer to \cc{int}.
If any of the actual arguments in the call is of type \cc{INT\_BIG} 
(or \cc{INT\_BIG~*}) when it should be of type \cc{int} (or \cc{int~*}),
then the calling code needs to be changed.

In the case of \cc{int} arguments, if the actual argument
might be too large to be
represented in an \cc{int}, then an \cc{l} should be inserted 
after the `{\tt\%}' sign to 
indicate that a \cc{long} argument is being supplied and the 
corresponding argument should be cast to \cc{long}.  If it will definitely
be possible to store the value in an \cc{int} then the format specifier
may be left alone and the argument cast to \cc{int}.
Arguments passed using the \cc{c} or \cc{*} specifiers should be cast 
to \cc{int}, and not modified with an \cc{l} character.
In the case of \cc{int~*} arguments, intermediate variables have to be used.
Here is an example.  If after simple substitution of \cc{INT\_BIG} for
\cc{int} a piece of code reads:
\begin{squote}
\begin{verbatim}
   extern INT_BIG quintuple( INT_BIG x );
   INT_BIG i, j;
   char c;
   scanf( "%i %c", &i, &c );
   j = quintuple( i );
   printf( "Integer quintupled is %i; Character is '%c'\n", j, c );
\end{verbatim}
\end{squote}
then the \cc{scanf} call must be replaced by something like this: 
\begin{squote}
\begin{verbatim}
   {  
      long tmp; 
      scanf( "%li %c", &tmp, &c ); 
      i = tmp; 
   }
\end{verbatim}
\end{squote}
and the \cc{printf} call by something like this:
\begin{squote}
\begin{verbatim}
   printf( "Integer quintupled is %li; Character is '%c'\n", (long) j, c );
\end{verbatim}
\end{squote}
%
\item[Other external libraries:]\mbox{}
\\
If your code links to any other external libraries
which cannot, or will not, be converted to use \cc{INT\_BIG}s,
some recoding of the calls may be required as above.
The most common case of this is use of the various system libraries
whose functions are declared in header files in or under \file{/usr/include}.
\cc{waitpid()}, \cc{signal()} and \cc{pipe()} are a few of the culprits.
\end{description}


There are a few other issues which arise from replacing \cc{int} type
with \cc{INT\_BIG}:
\begin{description}
%
\item[Integer constants from limits.h:]\mbox{}
\\
Where an \cc{int} is compared against one of the values 
\cc{INT\_MAX}, \cc{INT\_MIN} and \cc{UINT\_MAX} 
defined in the system header file \file{limits.h},
an \cc{INT\_BIG} should be compared against one of the corresponding
macros \cc{INT\_BIG\_MAX} etc.
These macros are defined in the header file \file{extreme.h}. 
%
\item[Implicit int declarations:]\mbox{}
\\
There are several places in C (macros and typedefs apart) 
in which an identifier can be declared
as an \cc{int} without the \cc{int} reserved word appearing.
For example, in the code:
\begin{squote}
\begin{verbatim}
sub( x ) {
   static y;
   signed z;
}
\end{verbatim}
\end{squote}
the symbols \cc{sub}, \cc{x}, \cc{y} and \cc{z} all have type \cc{int}.
%
\item[int used for Fortran LOGICAL:]\mbox{}
\\
Where a C \cc{int} is used to represent a LOGICAL variable in Fortran,
it should not be replaced by \cc{INT\_BIG}.
This is only likely to arise in certain low-level code 
(e.g.\ \xref{HDS}{sun92}{} and \xref{CNF}{sun209}{}) 
which does direct interfacing with Fortran.
Under normal circumstances code should use the macros
F77\_LOGICAL\_TYPE and F77\_INTEGER\_TYPE defined in the 
CNF header file \file{cnf.h}.
%
\end{description}

The program \xroutine{crepint} is provided for making some of these
changes.  It replaces all references to \cc{int} type, with a few exceptions,
by \cc{INT\_BIG} type, modifies explicit declarations which are of type 
\cc{int}, and warns about constructs which might need further attention.
It is described in section \ref{sec:tools}.

A construction which \routine{crepint} misses altogether is finding
implicit declarations in function prototypes, which are implicitly
of type \cc{int}.
The {\tt -proto} flag of Tru64 Unix's C compiler is useful for identifying
these.
Given a file \file{sub.c} which reads:
\begin{squote}
\begin{verbatim}
sub( x ) {
   return x;
}
\end{verbatim}
\end{squote}
then running
\begin{squote}
\begin{verbatim}
% cc -protois -noobject sub.c
\end{verbatim}
\end{squote}
will produce a file called \file{sub.H} which reads:
\begin{squote}
\begin{verbatim}
extern int sub(int x);
\end{verbatim}
\end{squote}
Occurrences of \cc{int} in the output file \file{sub.H} should be 
changed to read \cc{INT\_BIG} wherever the function is declared or
defined in the source code (typically in a source file and maybe a 
header file), so that \file{sub.c} should
end up reading:
\begin{squote}
\begin{verbatim}
INT_BIG sub( INT_BIG x ) {
   return x;
}
\end{verbatim}
\end{squote}
By running
\begin{squote}
\begin{verbatim}
% cc -protois -noobject -DINT_BIG=long *.c
\end{verbatim}
\end{squote}
and attending to any \cc{int} declarations in the resulting \file{.H} files,
it should be possible to find any offending implicit declarations.
Note however that this only writes function prototypes 
from function definitions, it does not normalise existing prototypes,
so it cannot usefully be applied to header files.


\subsection{Changes to makefile/mk\label{sec:makefile}}

Since not all build environments require the enlarged integers,
the build process must be modified so that 64-bit integers are
used for some build environments and 32-bit integers for others.
Identifying build environments is done by using different values
of the SYSTEM macro.  As well as the existing supported values
\begin{itemize}
\item ix86\_Linux
\item sun4\_Solaris
\item alpha\_OSF1
\end{itemize}
which indicate that 32-bit integers should be used as before, 
the following new ones should be used
\begin{itemize}
\item sun4\_Solaris\_64
\item alpha\_OSF1\_64
\end{itemize}
which indicate that 64-bit integers should be used.
Thus two new stanzas are required in the \file{mk} file for each package
setting the values of the other \file{makefile} macros for the newly
supported systems.  

Additionally, if the package contains Fortran source,
a new macro INTEGER8 should be 
defined by the \file{mk} file.  This should contain text which is to
replace `INTEGER~*~8' declarations in fortran source code.  
If blank (defined as spaces or the empty string) it means 
that INTEGER~*~8 declarations should be left unchanged.
Therefore for 64-bit systems this should be defined as the empty
string, and for 32-bit systems it should be defined as `INTEGER~~~~'
(defining it with four trailing spaces
is not required, but improves the aesthetics of
the modified source files).
The makefile should then apply the 
INTEGER*8 \latexhtml{$\rightarrow$}{->} \$(INTEGER8)
substitution to the fortran source files as it extracts them from the
tar archive where they are stored.
The recommended code for this is:
\begin{squote}
\begin{verbatim}
sed "s/^[ \t]*[Ii][Nn][Tt][Ee][Gg][Ee][Rr] *\* *8/      $(INTEGER8)/"
\end{verbatim}
\end{squote}
which should be applied only when {\tt test \$(INTEGER8)} is true.
Note that this changes nothing except variable declarations; 
in particular it will not modify references to INTEGER*8 type in IMPLICIT
statements.
It also makes no allowance for the more bizarre spacing possibilities
permissible in Fortran 77.
It would be possible to use a more comprehensive editing script,
but in the interests of clarity, and of simplicity at build time,
it is recommended that the above is used, 
and source code required to match the given pattern where edits
are needed.

The intention is that Fortran source code is stored in the source 
archive with INTEGER*8 declarations,
and is edited if necessary 
as it is extracted from the tar file, prior to being
written in the build directory.
In this way, the set of Fortran files in the build directory 
will be consistent and compilable, 
but may not have the same content as the set of files in the source archive.

For C files, the source code itself does not need to be modified at
build time, but the \cc{INT\_BIG} preprocessor macro must be defined.
This is most easily done by adding a \cc{-DINT\_BIG=int} or 
\cc{-DINT\_BIG=long} flag as appropriate to the
CFLAGS macro in each \file{mk} stanza.
Alternatively, a SOURCE\_VARIANT-controlled header file could be
written and included into all C source files;
the EXTREME package provides the header file \file{extreme.h}
for this purpose.

The following gives the relevant parts of a basic \file{mk}
file by way of example:
\begin{squote}
\begin{verbatim}
   ...
#  Supported Systems:
#     The following systems are currently supported and may be
#     identified by defining the SYSTEM environment variable
#     appropriately before invoking this script:
#
#        alpha_OSF1
#           DEC Alpha machines running OSF1
#
#        alpha_OSF1_64
#           DEC Alpha machines running OSF1, long integers
#
#        ix86_Linux
#           Intel PC running Linux
#
#        sun4_Solaris
#           SUN Sparcstations running SunOS 5.x (Solaris)
#
#        sun4_Solaris_64
#           SUN Sparcstations running 64-bit SunOS 5.x (Solaris), long integers
   ...
#        CFLAGS (-O -DINT_BIG=int)
#           The C compiler options to use.
#
#        INTEGER8 (INTEGER    )
#           Replacement text for 'INTEGER * 8' declarations in the original
#           original Fortran source code.  If set to the empty string,
#           INTEGER * 8 declarations will not be modified.  For 64-bit
#           systems which must be able to deal with very large images
#           this should be set to the empty string (or 'INTEGER*8').
#           Otherwise, more efficient code may be generated by setting
#           it to 'INTEGER' or 'INTEGER*4'.  The trailing whitespace is
#           optional but may make source code more readable.
   ...

      export INTEGER8
   ...

      case "$SYSTEM" in

#  DEC Alpha machines running OSF1.
#  -------------------------------
         alpha_OSF1)
            CFLAGS='-DINT_BIG=int'
            INTEGER8='INTEGER    '
               ...

#  DEC Alpha machines running OSF1, long integers.
#  ----------------------------------------------
         alpha_OSF1_64)
            CFLAGS='-DINT_BIG=long'
            INTEGER8=''
               ...

#  SUN Sparcstations running SunOS 5.x (Solaris).
#  ---------------------------------------------
         sun4_Solaris)
            CFLAGS='-DINT_BIG=int'
            INTEGER8='INTEGER    '
               ...

#  SUN Sparcstations running 64-bit SunOS 5.x (Solaris), long integers.
#  -------------------------------------------------------------------
         sun4_Solaris_64)
            CFLAGS='-DINT_BIG=long -xarch=v9'
            FFLAGS='-xarch=v9'
            INTEGER8=''
               ...

#  Intel PC running Linux.
#  ----------------------
         ix86_Linux)
            CFLAGS='-DINT_BIG=int'
            INTEGER8='INTEGER    '
               ...
\end{verbatim}
\end{squote}
Note the `{\tt -xarch=v9}' addition to the sun4\_Solaris\_64 CFLAGS
and FFLAGS variables,
which instructs the compiler to compile for a 64-bit system.
Tru64 Unix C compiles for 64 bit executables by default, so needs no
extra flags.

It may also be desirable to add the lines:
\begin{squote}
\begin{verbatim}
            SOURCE_VARIANT='alpha_OSF1'
\end{verbatim}
\end{squote}
and 
\begin{squote}
\begin{verbatim}
            SOURCE_VARIANT='sun4_Solaris'
\end{verbatim}
\end{squote}
to the alpha\_OSF1\_64 and sun4\_Solaris\_64 stanzas respectively,
if the same
machine-specific source files can be used for 32-bit and 64-bit 
builds on the same platforms; if this is not the case then SOURCE\_VARIANT
should be left to default to \$(SYSTEM) as usual,
and additional copies of the system-dependent files must be supplied.

The relevant parts of a suitable matching \file{makefile} would look 
something like this:
\begin{squote}
\begin{verbatim}
#  Default values for macros for compiling C and Fortran source code.

CFLAGS = -O -DINT_BIG=int
   ...

#  Default replacement text for Fortran INTEGER * 8 type.

INTEGER8 = INTEGER
   ...

#  Macro for filter to replace INTEGER * 8 declarations with INTEGER8.

REPLACE_INTEGER8 = sed \
   "s/^[ \t]*[Ii][Nn][Tt][Ee][Gg][Ee][Rr] *\* *8/      $(INTEGER8)/"

#  Rules for extracting non-Fortran source files from the source archive.

$(C_ROUTINES) $(PUBLIC_C_INCLUDES) $(PRIVATE_C_INCLUDES):
        $(TAR_OUT) $(PKG_NAME)_source.tar $@
        @ if test -f $@; then :;\
           else echo $@ is not in the tar file; exit 1; fi

#  Rules for extracting Fortran source files from the source archive.

$(F_ROUTINES) $(PUBLIC_F_INCLUDES) $(PRIVATE_F_INCLUDES):
        $(TAR_OUT) $(PKG_NAME)_source.tar $@
        @ if test -f $@; then :;\
           else echo $@ is not in the tar file; exit 1; fi
        if test $(INTEGER8); then \
           $(REPLACE_INTEGER8) < $@ > $@_tmp; \
           mv $@_tmp $@; \
        else :; fi

#  Rules for extracting platform specific Fortran files from the archive.

$(PLATFORM_F) dummy_target2:
        $(TAR_OUT) $(PKG_NAME)_source.tar $@_$(SOURCE_VARIANT)
        @ if test -f $@_$(SOURCE_VARIANT); then :;\
           else echo $@_$(SOURCE_VARIANT) is not in the tar file; exit 1; fi
        if test $(INTEGER8); then \
           $(REPLACE_INTEGER8) < $@_$(SOURCE_VARIANT) > $@; \
           rm -f $@_$(SOURCE_VARIANT); \
           else mv $@_$(SOURCE_VARIANT) $@; fi
   ...

#  Enter information about the current machine and build environment
#  into the date stamp file.
   ...
        @ echo '   INTEGER8: $(INTEGER8)'     >>$(DATE_STAMP)
\end{verbatim}
\end{squote}

It may also be necessary to add dependencies for INCLUDE files inserted
by the conversion tools; \xroutine{inscnf} may include \file{CNF\_PAR}
and \xroutine{frepint} may include \file{EXT\_PAR} in some Fortran source
files.  Rules will need to be made for building links to the referenced
include files, and dependencies added for the object files corresponding
to the source files so modified.

Files may be extracted from the source archive(s) in more places than
one in the makefile - in particular, for some reason lost in the
mists of time the {\tt do\_test} target 
usually extracts required files from the source archives explicitly
rather than relying on a dependency.
It will be necessary to identify all such places 
(try grepping for TAR\_OUT), and ensure that
the INTEGER8 macro is substituted in to the source code before it
gets compiled.

Note that because of the way this approach edits Fortran source files on
their way out of the source archive
(typically \file{\$(PKG\_NAME)\_source.tar}),
the copies of the files in the build directory may not be the same
as the files in the source archive, and so files cannot in general
be transferred between the build directory and source archive
simply using {\tt tar}.
This means that in general the source archive cannot be rebuilt 
from the files in the build directory.
This may well break private, non-standard targets inserted into the
makefile by the package developer (commonly called {\tt archive}),
and effectively means that it is not possible to tweak package source
code in the build directory prior to re-exporting it.

The script \xroutine{extmk} is provided to make the necessary 
modifications to \file{mk} files, and is described fully in 
section \ref{sec:tools}.
No automatic tool is provided for modifying \file{makefile}s, 
since they tend to be more varied and may require more ingenious
changes.


\section{Tools\label{sec:tools}}

This section documents utilities distributed with this package
to modify source code for use in 64-bit environments.

One tool is provided for each of the source code conversion
tasks described in the previous section:
\begin{description}
\item[inscnf:] Inserts CNF\_PVAL calls where required in Fortran source code
\item[frepint:] Converts INTEGER to INTEGER*8 in Fortran source code
\item[crepint:] Converts \cc{int} to \cc{INT\_BIG} in C source code
\item[extmk:] Makes the necessary edits to a package \file{mk} file
\end{description}
No tool is provided for making edits to the \file{makefile};
this normally requires a bit of human intelligence for identifying
which files are Fortran and processing them separately.


Each of these is a normal Unix filter command with usage like \file{cat}, 
so may be given zero, one or two arguments to specify its input and output.
Where no change needs to be made, the input is written with no changes 
to the output.  This means that the \file{diff} command can be used 
to see what changes the filters make, by doing something like:
\begin{squote}
\begin{verbatim}
% frepint file.f | diff file.f -
\end{verbatim}
\end{squote}
which might give a result like:
\begin{squote}
\begin{verbatim}
94c94
<       INTEGER STATUS             ! Global status
---
>       INTEGER * 8 STATUS         ! Global status
97,98c97,98
<       INTEGER I                  ! Loop variable
<       INTEGER INDF               ! NDF identifier
---
>       INTEGER * 8 I              ! Loop variable
>       INTEGER * 8 INDF           ! NDF identifier
\end{verbatim}
\end{squote}

Each of the filters, as well as making changes, 
draws attention to constructs which might need 
further attention by writing a message to standard error. 
In some cases, it will also insert a comment in the modified file where
the questionable construct occurs.
Such comment lines contain the name of the filter followed by a colon
and explanatory text, so given the file \file{watcher.c}:
\begin{squote}
\begin{verbatim}
   int watcher( int mins ) {
      printf( "Only %i minutes till coffee break\n", mins );
   }
\end{verbatim}
\end{squote}
\xroutine{crepint} will do the following:
\begin{squote}
\begin{verbatim}
% crepint watcher.c >fixed/watcher.c
crepint: Format string has %[cdiouxX*] (comment inserted)
\end{verbatim}
\end{squote}
and the resulting file \file{fixed/watcher.c} will look like this:
\begin{squote}
\begin{verbatim}
INT_BIG watcher( INT_BIG mins ) {
/* crepint: Format string has %[cdiouxX*]                                */
   printf( "Only %i minutes till coffee break\n", mins );
}
\end{verbatim}
\end{squote}
which can then be fixed by hand as described in
section \ref{sec:cint}.

If the filter thinks it has lost track of the source code in a dangerous
way, i.e.\ that it might be making changes which are likely to invalidate
the code, it may exit with an error status, and print a message to standard
error to that effect.

Each of the filters has a go at retaining the aesthetic 
qualities of the code; an attempt is made to respect 
case usage and spacing conventions in Fortran, 
padding whitespace is shuffled to keep things at the same column as
before if possible, and so on.
If replacement text is longer than the original
then Fortran lines are broken in hopefully reasonable places,
but no line breaks in existing lines are introduced in C.

In addition, for each of the source code modifying filters
\xroutine{inscnf}, \xroutine{frepint} and \xroutine{crepint}, 
a driver script is provided. 
For converting large numbers of files, this is likely to be the 
most convenient way to proceed.  Each driver script 
runs the filter on a given set of files, summarises the output, and
writes any files have been changed in a new directory.
Any files which did not need alteration are not rewritten.
It also performs some crude safety checks that the modified source
files seem to have been changed in the right way (for instance, that
no changes have been made except for the ones which should have been
made, and that changes to Fortran code do not result in lines longer
than 72 characters).  
These checks do not do such careful parsing
of the source code as the conversion filters themselves, 
so they can throw up false positives or false negatives, but they give 
an extra level of confidence.

The driver script for \xroutine{inscnf} is called \file{do\_inscnf}
and is invoked with the files to be converted as command line arguments.
For each of its command line arguments it runs \xroutine{inscnf} and
\begin{itemize}
\item Writes a line to a log file \file{./inscnf.log} 
      saying how many lines were changed
\item If and only if some changes were made, it writes the modified copy
      of the file, under the same name, 
      into a directory called \file{./inscnf.changed}
\item If the filter or the driver script thinks there might be something 
      which needs human attention, it writes a suitable message to standard
      output.  These warning messages can be understood in conjunction 
      with the documentation of the filter, or of the corresponding 
      text in section \ref{sec:modificienda}.
\end{itemize}
Finally it writes a short summary of the run.
An excerpt of its output might look like this:
\begin{squote}
\begin{verbatim}
% do_inscnf *.f *.gen
***  astimp.f:            inscnf: Last arg %VAL in FTS1_GKEYD       ***
***  import.f:            inscnf: Integer %VAL arg in CCD1_IMFIT?   ***
***  import.f:            inscnf: Last arg %VAL in CCD1_IMFIT       ***
  ...
71/483 modified files written in ./inscnf.changed
Logfile is ./inscnf.log
\end{verbatim}
\end{squote}

The other driver scripts, \file{do\_crepint} and \file{do\_frepint},
differ in the form of their output somewhat but otherwise work the
same way as \file{do\_inscnf}.

The driver script may occasionally throw out a comment like this:
\begin{squote}
\begin{verbatim}
ndf1_pshdt.f:              Possible error in modifications?          
\end{verbatim}
\end{squote}
which indicates that there seems to be a difference between
the output of the filter and the input plus the expected changes.
The checking is done by a quick-and-dirty Perl script called
\file{cmp\_inscnf} (and similarly for the other filters),
and if you see this warning you can run this script yourself
to get an idea what the problem may have been. 
The above warning was emitted by \routine{do\_frepint}; investigate 
as follows:
\begin{squote}
\begin{verbatim}
% cmp_frepint ndf1_pshdt.f
 *** Edit error near line 69?:
 CALL NDF1_SPLDT( STR, 1, LEN( STR ), ' ', -10, F, L, NFIELD, STATUS )
 CALL NDF1_SPLDT( STR, 1, LEN( STR ), ' ', - 10, F, L, NFIELD, STATUS )
\end{verbatim}
\end{squote}
from which it is clear that the culprit is some harmlessly inserted
whitespace.
Note that in order to make these comparisons, the \file{cmp\_*} scripts
deal in a cavalier fashion with formatting, so the source
lines may not look very much like the original copies and the line number
reporting may not be accurate, but the message
should be sufficient to locate the problem.
Such ``{\tt Possible error in modifications?}'' 
warnings ought to be infrequent, and may often not be indicative
of a real problem, but it is as well to investigate them.

Detailed descriptions of the behaviour of the filter programs is
given in section \ref{sec:filters}


\section{Cribsheet: Converting to extreme datasets in 99 easy steps}

This section gives a list of what you should to to
a Starlink package to enable it to cope with large images.
The steps here give an indication of how to proceed, 
but for more discussion of what's going on, refer to other sections
in this document, as referenced.
Some examples of the commands you could use are given, 
but obviously you can change these to personal taste.

\begin{enumerate}
%
\item
Identify all C source files and all Fortran source files.
\begin{squote}
\begin{verbatim}
% tar xf package_source.tar
% echo >ffiles *.f *.gen pkg1_par pkg1_err
% echo >cfiles *.c *.h package.h
\end{verbatim}
\end{squote}
%
\item
Run \routine{do\_inscnf} on Fortran files 
to wrap %VAL arguments in CNF\_PVAL calls,
if this has not already been done.
\begin{squote}
\begin{verbatim}
% do_inscnf `cat ffiles`
pkg1_sub.f:                Constant %VAL arg in PKG1_ADD?
pgk1_mult.f:               INTEGER*2 declaration not changed                 
5/25 modified files written in ./inscnf.changed
Logfile is ./inscnf.log
\end{verbatim}
\end{squote}
%
\item
Check CNF\_PVAL insertions which generated warnings, and remove them
if necessary.
\begin{squote}
\begin{verbatim}
% vi inscnf.changed/pkg1_sub.f
\end{verbatim}
\end{squote}
%
\item
Rebuild source archive, rebuild package, and test.
\begin{squote}
\begin{verbatim}
% mkdir retar
% cd retar
% tar xf ../package_source.tar
% cp ../inscnf.changed/* .
% tar cf ../package_source.tar *
% cd ..
% rm -r retar
% mk build
% mk install
% mk test
   ...
\end{verbatim}
\end{squote}
%
\item
Ensure that you have 64-bit copies of all the Starlink libraries on which the
package depends.
\begin{squote}
\end{squote}
\item
Run \routine{do\_frepint} on Fortran files to replace INTEGER declarations
by INTEGER~*~8.
\begin{squote}
\begin{verbatim}
% tar xf package_source.tar `cat ffiles`
% do_frepint `cat ffiles`
pgk1_mult.f:               INTEGER*2 declaration not changed                 
pkg1_divid.f:              No IMPLICIT NONE in module PKG1_DIVID
22/25 modified files written in ./frepint.changed.
Logfile is ./frepint.log
\end{verbatim}
\end{squote}
%
\item
Check constructs which led to warnings, and make any necessary edits.
\begin{squote}
\begin{verbatim}
% vi frepint.changed/pkg1_mult.f frepint.changed/pkg1_divid.f
\end{verbatim}
\end{squote}
%
\item
If the package calls any unconverted libraries 
(e.g. non-standard intrinsic functions), change the types of
actual arguments back to INTEGER.
\begin{squote}
\end{squote}
%
\item
If there is any tricky use of storage association involving integers,
such as use of COMMON or EQUIVALENCE, you may need to recode this.
\begin{squote}
\end{squote}
%
\item
Run \routine{do\_crepint} on C files to replace references to \cc{int} type
by \cc{INT\_BIG}.
\begin{squote}
\begin{verbatim}
% tar xf package_source.tar `cat cfiles`
% do_crepint `cat cfiles`
input.c:               2 x Format string implies int * (comment inserted)
output.c:              5 x Format string has %[cdiouxX*] (comment inserted)  
output.c:                  Format string non-literal (comment inserted)
process.c:                 Variable argument list for pkgParse()
toplevel.c:                Type of main not changed from int
toplevel.c:                Type of argc not changed from int
\end{verbatim}
\end{squote}
%
\item
Attend to any of the warnings generated by \routine{crepint}
and make edits accordingly.  
Most of the `format string' warnings will require changes, 
but others may not.
\begin{squote}
\end{squote}
%
\item
Check that you've attended to all the Format string warnings and removed
the flagging comments.
\begin{squote}
\begin{verbatim}
% grep crepint: `cat cfiles`
\end{verbatim}
\end{squote}
%
\item
Try to ensure that all functions are defined using ANSI C-style argument 
type declarations.
\begin{squote}
\end{squote}
%
\item
Try to make sure that all functions are declared before being used,
by including header files or declaring prototypes in-line near the 
top of the file.
\begin{squote}
\end{squote}
%
\item
Make sure that communication with Fortran routines is done properly
using CNF as described in \xref{SUN/209}{sun209}{}.
In particular it is essential to use the \xref{TRAIL}{sun209}{TRAIL} 
macro for passing character string lengths.
\begin{squote}
\end{squote}
%
\item
Identify any external non-Starlink functions called by the package, 
typically system ones as declared in \file{/usr/include} header files.
This can hopefully be done by looking at which header files have been 
included.
If any of the declarations contain variable argument lists (`\cc{...}')
or pointers to integer (`int *'), calls to them will need to be
modified - for examples see the discussion of \cc{printf} and \cc{scanf}
in \ref{sec:cint}.
\begin{squote}
\begin{verbatim}
% cat `cat cfiles` | grep '^#include <' | awk '{print $2}' | sort | uniq
   ...
\end{verbatim}
\end{squote}
%
\item
Have a look for implicit function or argument declarations
and replace them by explicit \cc{INT\_BIG} declarations
(the following example requires the Tru64 Unix C compiler).
\begin{squote}
\begin{verbatim}
% cc -protois -noobject -DINT_BIG=long crepint.changed/*.c
% grep '[^a-z]int[^a-z]' *.H
\end{verbatim}
\end{squote}
%
\item
Rebuild the source archive.
\begin{squote}
\begin{verbatim}
% mkdir retar
% cd retar
% tar xf ../package_source.tar
% cp ../frepint.changed/* .
% cp ../crepint.changed/* .
% tar cf ../package_source.tar
% cd ..
% rm -r retar
\end{verbatim}
\end{squote}
%
\item
Use \xroutine{extmk} to make the necessary modifications to the \file{mk} file.
\begin{squote}
\begin{verbatim}
% mv mk mk.orig
% extmk < mk.orig > mk
\end{verbatim}
\end{squote}
%
\item
If \routine{extmk} generated any warnings, edit the \file{mk} file by
hand accordingly.
\begin{squote}
\end{squote}
%
\item
If there are platform-dependent files in the package you must either add
\begin{squote}
\begin{verbatim}
      SOURCE_VARIANT='alpha_OSF1'
\end{verbatim}
\end{squote}
and
\begin{squote}
\begin{verbatim}
      SOURCE_VARIANT='sun4_Solaris'
\end{verbatim}
\end{squote}
to the alpha\_OSF1\_64 and sun4\_Solaris\_64 stanzas of the \file{mk} file
respectively, or generate new platform-dependent files for the 
two new platforms.
\begin{squote}
\end{squote}
%
\item
Edit the \file{makefile} as discussed in section \ref{sec:makefile}.
You must make the following changes:
\begin{itemize}
\item
Add \cc{-DINT\_BIG=int} to the default value of the CFLAGS macro.
\item
Add a default value for the INTEGER8 macro.
\item
Insert the definition of the REPLACE\_INTEGER8 macro.
\item
Ensure that any extraction of Fortran source files from source archives
are processed using the REPLACE\_INTEGER8 macro.
\item
Record the value of the INTEGER8 macro in the DATE\_STAMP file.
\item
Add rules for building any new include files the edits require 
(\file{CNF\_PAR}, \file{EXT\_PAR} or \file{extreme.h}).
\item
Add any new dependencies of object files on these include files.
\item
Fix, or remove, any private archive-type targets which have been broken
by the fact that source files in the build directory are no longer
original copies.
\end{itemize}
\begin{squote}
\end{squote}
%
\item
Build the package.  Look out for the following warnings:
\begin{itemize}
\item Fortran variable misaligned in COMMON block.
\item C pointer type mismatch.
\item Incompatible arguments.
\end{itemize}
If there are compilation errors or new warnings fix them.
In general, sun4\_Solaris\_64 is more sensitive to problems than
alpha\_OSF1\_64, since the size of \cc{long} and pointers is 
actually different between the 32-bit and 64-bit compilations.
\begin{squote}
\end{squote}
%
\end{enumerate}


\section{Filter utility descriptions\label{sec:filters}}

%%%% Begin filter descriptions
\newpage
\sstroutine{
   inscnf
}{
   Wrap \%VAL arguments with CNF\_PVAL in Fortran
}{
   \sstdescription{
      This is a filter which takes FORTRAN 77 source code
      and modifies it so that text which is the argument of a \%VAL
      directive is wrapped in a call to CNF\_PVAL; i.e. input text

         \%VAL( IPTR )

      is changed to

         \%VAL( CNF\_PVAL( IPTR ) )

      If the call to CNF\_PVAL is already present no change is made,
      and a warning is emitted.  Lines with no references to the \%VAL
      directive are left alone.

      Additionally, for each program unit in which a call to CNF\_PVAL
      has been made, an attempt is made to insert a line like

         INCLUDE {\tt '}CNF\_PAR{\tt '}        ! For CNF\_PVAL function

      This is inserted after the last INCLUDE line which already exists
      in the program unit.  If there are no INCLUDE lines there, this
      line is not inserted, and a warning message is printed to standard
      error.

      Attention is paid to Fortran 77 source format, so that lines
      more than 72 characters long are avoided (unless they were there
      in the first place).

      Characters {\tt '}$\backslash$r{\tt '} (carriage return) and {\tt '}$\backslash$t{\tt '} (tab) might possibly
      cause erroneous line breaking - if any are encountered a warning
      is given (these should not be in the source really).
      Code using columns 73-80 of the source cards for comments is
      likely to be mangled (nobody does this any more do they?).

      Under certain improbable circumstances it is possible for the
      program to get stuck trying to break a line; in this case it will
      exit with error status and an error message.

      Some attention is paid to the aesthetic qualities of the output:
      line breaks are made, where possible, following the usage in, e.g.,
      KAPPA.  An attempt is made to copy the style of case usage and bracket
      spacing from the input.

      This program wraps ALL occurrences of \%VAL in a call to CNF\_PVAL,
      unless they are already so wrapped.  If it suspects that \%VAL
      may not be a legitimate candidate for this treatment, it will
      output a warning message to standard error.  It will do this in
      the following cases:
      \sstitemlist{

         \sstitem
           \%VAL is on the last argument in the argument list (this
             suggests that it might be a trailing string length)

         \sstitem
           The argument of \%VAL looks like an integer constant

         \sstitem
           The argument of \%VAL looks like a Starlink-style symbolic
             constant (has two adjacent underscore characters).
      }
   }
   \sstusage{
      inscnf [ in [ out ] ]
   }
   \sstnotes{
      Although this program behaves as a filter, it is written on
      the assumption that it will be run on a file of a finite length:
      it may buffer large amounts of input before writing output, and
      it may not free up memory.
   }
}
\newpage
\sstroutine{
   frepint
}{
   Replace INTEGER by INTEGER$*$8 in Fortran
}{
   \sstdescription{
      This program is a filter which takes FORTRAN 77 source code
      and modifies it so that INTEGER declarations are rewritten as
      {\tt '}INTEGER $*$ 8{\tt '}.  It also attempts to warn if there are usages which
      might cause trouble given this change.

      Additionally, if there appear to be actual arguments to subroutines
      or functions which are literal integers, the program will attempt
      to replace them with symbolic constants, as defined in the
      EXT\_PAR include file.  It will also attempt to add a line INCLUDEing
      this file.  This aspect of the processing is not foolproof.
      It can misidentify an array reference as a function call - if
      the {\tt '}function{\tt '} name contains an underscore it assumes that it is
      a function name and not an array name.  Only single literal integers
      as actual arguments are thus replaced, so that, e.g. the code

         L = XXX1\_FUNC( X, Y, Z, 0, 3 $*$ 5, STATUS )

      will be replaced by

         L = XXX1\_FUNC( X, Y, Z, EXT\_\_0, 3 $*$ 5, STATUS )

      Attention is paid to fortran 77 source format, so that lines
      more than 72 characters long are avoided (unless they were there
      in the first place).

      Some attention is paid to the aesthetic qualities of the output:
      line breaks are made, where possible, following the usage in, e.g.,
      KAPPA.  An attempt is made to copy the style of case usage from the
      input.

      No changes are made to comment lines so that, for instance, the
      Arguments stanza of subroutine prologues will not have argument
      types modified from {\tt '}INTEGER{\tt '} to {\tt '}INTEGER $*$ 8{\tt '}.

      The program will write a warning on standard error for certain
      constructions in the code which are likely to cause trouble after
      the mass redeclaration of INTEGER as INTEGER$*$8 has occurred.
      These constructions are:
      \sstitemlist{

         \sstitem
            INTEGER $*$ n declarations which already exist in the code
              (these are not modified)

         \sstitem
            EQUIVALENCE statements

         \sstitem
            Use of INTEGER Specific names for standard intrinsic functions
              (IABS, ISIGN, IDIM, MAX0, AMAX0, MIN0, IMIN0)

         \sstitem
            Any module (SUBROUTINE, FUNCTION or BLOCK DATA) which does not
              include an IMPLICIT NONE statement.
      }
   }
   \sstusage{
      frepint [ in [ out ] ]
   }
   \sstnotes{
      Although this program behaves as a filter, it is written on
      the assumption that it will be run on a file of a finite length:
      it may buffer large amounts of input before writing output, and
      it may not free up memory.
   }
   \sstbugs{
      In some cases, the line breaks are not made in very beautiful places.
      They should, however, always be correct.
   }
}
\newpage
\sstroutine{
   crepint
}{
   Replace int by INT\_BIG in C
}{
   \sstdescription{
      This program is a filter which takes C source code and replaces
      occurrences of the type specifier `int{\tt '} by the identifier
      `INT\_BIG{\tt '}.  This identifier can then be assigned a preprocessor
      value of a suitable integral type (int or long) either using an
      include file or with a -DINT\_BIG=xxx flag on the C compiler.

      It{\tt '}s not quite as simple as replacing every semantically significant
      occurrence of the `int{\tt '} identifier; `short int{\tt '} and `long int{\tt '} type
      specifiers will be left alone.

      If a use of int appears to be declaring a symbol called `main{\tt '} or
      `argc{\tt '}, then this will be left alone too, and a warning written
      to standard error to the effect that it is not being changed.

      Additionally, references to the limit.h macros INT\_MAX, INT\_MIN
      and UINT\_MAX are replaced by INT\_BIG\_MAX, INT\_BIG\_MIN and
      UINT\_BIG\_MAX respectively.  If any of these substitutions are
      made, then a line {\tt '}\#include {\tt "}extreme.h{\tt "}{\tt '} is added after the
      {\tt '}\#include $<$limits.h$>${\tt '} line which is presumably in the file.
      If $<$limits.h$>$ is not included in the input file, a warning is
      written to standard error.

      Explicit declarations which are implicitly of type int will have
      an INT\_BIG token inserted - for instance `static x, y;{\tt '} will be
      changed to `static INT\_BIG x, y;{\tt '}.

      The program will write a warning on standard error for certain
      constructions in the code which are likely to cause trouble after
      the mass redeclaration of int as INT\_BIG has occurred.
      These constructions are:
      \sstitemlist{

         \sstitem
            Declarations of functions with variable argument lists

         \sstitem
            Use of format strings in formatted I/O which may need changes

      }
      In the case of potentially dangerous format strings, for
      convenience a comment is inserted in the output code on the line
      before the function call is made.  The comment will contain the
      character string `crepint: {\tt '}.  The warning to standard error
      notes that the comment line has been inserted.

      The program does not make all changes which are required to effect
      this conversion.  The following constructions are likely to cause
      trouble, but will not be warned about by the program:
      \sstitemlist{

         \sstitem
            Use of functions without prototypes.  If header files are
              omitted or old style function declarations are used then the
              ANSI C machinery for doing type conversion at function call
              time will not work.

         \sstitem
            Use of external C libraries apart from the C standard library
              which have not been recoded replacing INT\_BIG for int.

         \sstitem
            Implicit declarations, which are implicitly of type int.
              If a name is declared simply by mentioning it without any type
              or type qualifiers, it is implicitly of type int, and so
              should become delcared as INT\_BIG.  This program does not
              find these.  Such implicit declarations (only?) occur in
              function declarations.  The Tru64 Unix C compiler{\tt '}s {\tt "}-protois{\tt "}
              flag is useful for identifying these.

      }
      The program tries to adjust padding whitespace outside comments
      so that the spacing of the output looks OK.

      No changes are made to comment lines so that, for instance, the
      Synopsis stanza of function prologues will not have formal argument
      types changed from {\tt '}int{\tt '} to {\tt '}INT\_BIG{\tt '}.
   }
   \sstusage{
      crepint [ in [ out ] ]
   }
   \sstnotes{
      Although this program behaves as a filter, it is written on
      the assumption that it will be run on a file of a finite length:
      it may buffer large amounts of input before writing output, and
      it may not free up memory.
   }
}
\newpage
\sstroutine{
   extmk
}{
   Modify mk file for use with EXTREME data sets
}{
   \sstdescription{
      This is a simple filter which takes a Starlink mk file as input and
      writes as output a file which should provide the additional
      functionality required by the EXTREME package, i.e. it adds new
      SYSTEM types of alpha\_OSF1\_64 and sun4\_Solaris\_64, provides
      for use of the INTEGER8 macro to preprocess Fortran source code
      before compilation, and modifies the C compilation flags for
      use with the INT\_BIG macro.

      The changes it attempts to make are as follows:
      \sstitemlist{

         \sstitem
            Add comment blocks describing the two new values of SYSTEM

         \sstitem
            Modify the comment describing the default value of CFLAGS

         \sstitem
            Add a comment describing the INTEGER8 environment variable

         \sstitem
            Export the INTEGER8 environment variable

         \sstitem
            Modify SYSTEM-specific settings for existing SYSTEMs

         \sstitem
            Add support for the two new SYSTEMs

      }
      If it is unable to make any of the modifications it would like to,
      it will print an explanatory message saying what it could not do.

      The only change which might be required which this script does not
      make is to set values for the SOURCE\_VARIANT variable.  Depending
      on how the system-specific compilation is going to be done, it
      may be desirable to add SOURCE\_VARIANT={\tt '}alpha\_OSF1{\tt '} in the new
      alpha\_OSF1\_64 stanza, and SOURCE\_VARIANT={\tt '}sun4\_Solaris{\tt '} in the
      new sun4\_Solaris\_64 stanza.  If required, this must be done by hand.

      This script is not extremely intelligent - unless the mk file
      follows the usual pattern quite closely, the output may be in
      error, or complete rubbish.  It is intended as a convenience,
      and if it does not work, then it will be necessary to make the
      modifications by hand; this is not too arduous.
   }
   \sstusage{
      extmk $<$ mk $>$ mk.new
   }
}
%%%% End filter descriptions

% ? End of main text
\end{document}

% $Id$
