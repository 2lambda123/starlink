\documentclass[twoside,11pt]{article}

% ? Specify used packages
% \usepackage{graphicx}        %  Use this one for final production.
% \usepackage[draft]{graphicx} %  Use this one for drafting.
% ? End of specify used packages

\pagestyle{myheadings}

% -----------------------------------------------------------------------------
% ? Document identification
% Fixed part
\newcommand{\stardoccategory}  {Starlink System Note}
\newcommand{\stardocinitials}  {SSN}
\newcommand{\stardocsource}    {ssn\stardocnumber}

% Variable part - replace [xxx] as appropriate.
\newcommand{\stardocnumber}    {73.1}
\newcommand{\stardocauthors}   {Mark Taylor}
\newcommand{\stardocdate}      {17 January 2000}
\newcommand{\stardoctitle}     {EXTREME --- Handling extreme data sets}
\newcommand{\stardocabstract}  {
This package provides some utilities and background documentation,
and associated files
for adapting the USSC, and software which uses it, 
to handle very large data sets.
The principal focus of this is to move to use of 64 bits of address
space on 64-bit operating systems.
}
% ? End of document identification
% -----------------------------------------------------------------------------

% +
%  Name:
%     ssn.tex
%
%  Purpose:
%     Template for Starlink System Note (SSN) documents.
%     Refer to SUN/199
%
%  Authors:
%     AJC: A.J.Chipperfield (Starlink, RAL)
%     BLY: M.J.Bly (Starlink, RAL)
%     PWD: Peter W. Draper (Starlink, Durham University)
%     MBT: Mark B. Taylor (Starlink)
%
%  History:
%     17-JAN-1996 (AJC):
%        Original with hypertext macros, based on MDL plain originals.
%     16-JUN-1997 (BLY):
%        Adapted for LaTeX2e.
%     13-AUG-1998 (PWD):
%        Converted for use with LaTeX2HTML version 98.2 and
%        Star2HTML version 1.3.
%     17-JAN-1999 (MBT):
%        Instantiated as SSN/73.
%     {Add further history here}
%
% -

\newcommand{\stardocname}{\stardocinitials /\stardocnumber}
\markboth{\stardocname}{\stardocname}
\setlength{\textwidth}{160mm}
\setlength{\textheight}{230mm}
\setlength{\topmargin}{-2mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\setlength{\unitlength}{1mm}

% -----------------------------------------------------------------------------
%  Hypertext definitions.
%  ======================
%  These are used by the LaTeX2HTML translator in conjunction with star2html.

%  Comment.sty: version 2.0, 19 June 1992
%  Selectively in/exclude pieces of text.
%
%  Author
%    Victor Eijkhout                                      <eijkhout@cs.utk.edu>
%    Department of Computer Science
%    University Tennessee at Knoxville
%    104 Ayres Hall
%    Knoxville, TN 37996
%    USA

%  Do not remove the %begin{latexonly} and %end{latexonly} lines (used by 
%  LaTeX2HTML to signify text it shouldn't process).
%begin{latexonly}
\makeatletter
\def\makeinnocent#1{\catcode`#1=12 }
\def\csarg#1#2{\expandafter#1\csname#2\endcsname}

\def\ThrowAwayComment#1{\begingroup
    \def\CurrentComment{#1}%
    \let\do\makeinnocent \dospecials
    \makeinnocent\^^L% and whatever other special cases
    \endlinechar`\^^M \catcode`\^^M=12 \xComment}
{\catcode`\^^M=12 \endlinechar=-1 %
 \gdef\xComment#1^^M{\def\test{#1}
      \csarg\ifx{PlainEnd\CurrentComment Test}\test
          \let\html@next\endgroup
      \else \csarg\ifx{LaLaEnd\CurrentComment Test}\test
            \edef\html@next{\endgroup\noexpand\end{\CurrentComment}}
      \else \let\html@next\xComment
      \fi \fi \html@next}
}
\makeatother

\def\includecomment
 #1{\expandafter\def\csname#1\endcsname{}%
    \expandafter\def\csname end#1\endcsname{}}
\def\excludecomment
 #1{\expandafter\def\csname#1\endcsname{\ThrowAwayComment{#1}}%
    {\escapechar=-1\relax
     \csarg\xdef{PlainEnd#1Test}{\string\\end#1}%
     \csarg\xdef{LaLaEnd#1Test}{\string\\end\string\{#1\string\}}%
    }}

%  Define environments that ignore their contents.
\excludecomment{comment}
\excludecomment{rawhtml}
\excludecomment{htmlonly}

%  Hypertext commands etc. This is a condensed version of the html.sty
%  file supplied with LaTeX2HTML by: Nikos Drakos <nikos@cbl.leeds.ac.uk> &
%  Jelle van Zeijl <jvzeijl@isou17.estec.esa.nl>. The LaTeX2HTML documentation
%  should be consulted about all commands (and the environments defined above)
%  except \xref and \xlabel which are Starlink specific.

\newcommand{\htmladdnormallinkfoot}[2]{#1\footnote{#2}}
\newcommand{\htmladdnormallink}[2]{#1}
\newcommand{\htmladdimg}[1]{}
\newcommand{\hyperref}[4]{#2\ref{#4}#3}
\newcommand{\htmlref}[2]{#1}
\newcommand{\htmlimage}[1]{}
\newcommand{\htmladdtonavigation}[1]{}

\newenvironment{latexonly}{}{}
\newcommand{\latex}[1]{#1}
\newcommand{\html}[1]{}
\newcommand{\latexhtml}[2]{#1}
\newcommand{\HTMLcode}[2][]{}

%  Starlink cross-references and labels.
\newcommand{\xref}[3]{#1}
\newcommand{\xlabel}[1]{}

%  LaTeX2HTML symbol.
\newcommand{\latextohtml}{\LaTeX2\texttt{HTML}}

%  Define command to re-centre underscore for Latex and leave as normal
%  for HTML (severe problems with \_ in tabbing environments and \_\_
%  generally otherwise).
\renewcommand{\_}{\texttt{\symbol{95}}}

% -----------------------------------------------------------------------------
%  Debugging.
%  =========
%  Remove % on the following to debug links in the HTML version using Latex.

% \newcommand{\hotlink}[2]{\fbox{\begin{tabular}[t]{@{}c@{}}#1\\\hline{\footnotesize #2}\end{tabular}}}
% \renewcommand{\htmladdnormallinkfoot}[2]{\hotlink{#1}{#2}}
% \renewcommand{\htmladdnormallink}[2]{\hotlink{#1}{#2}}
% \renewcommand{\hyperref}[4]{\hotlink{#1}{\S\ref{#4}}}
% \renewcommand{\htmlref}[2]{\hotlink{#1}{\S\ref{#2}}}
% \renewcommand{\xref}[3]{\hotlink{#1}{#2 -- #3}}
%end{latexonly}
% -----------------------------------------------------------------------------
% ? Document specific \newcommand or \newenvironment commands.


%+
%  Name:
%     SST.TEX

%  Purpose:
%     Define LaTeX commands for laying out Starlink routine descriptions.

%  Language:
%     LaTeX

%  Type of Module:
%     LaTeX data file.

%  Description:
%     This file defines LaTeX commands which allow routine documentation
%     produced by the SST application PROLAT to be processed by LaTeX and
%     by LaTeX2html. The contents of this file should be included in the
%     source prior to any statements that make of the sst commnds.

%  Notes:
%     The style file html.sty provided with LaTeX2html needs to be used.
%     This must be before this file.

%  Authors:
%     RFWS: R.F. Warren-Smith (STARLINK)
%     PDRAPER: P.W. Draper (Starlink - Durham University)

%  History:
%     10-SEP-1990 (RFWS):
%        Original version.
%     10-SEP-1990 (RFWS):
%        Added the implementation status section.
%     12-SEP-1990 (RFWS):
%        Added support for the usage section and adjusted various spacings.
%     8-DEC-1994 (PDRAPER):
%        Added support for simplified formatting using LaTeX2html.
%     {enter_further_changes_here}

%  Bugs:
%     {note_any_bugs_here}

%-

%  Define length variables.
\newlength{\sstbannerlength}
\newlength{\sstcaptionlength}
\newlength{\sstexampleslength}
\newlength{\sstexampleswidth}

%  Define a \tt font of the required size.
\latex{\newfont{\ssttt}{cmtt10 scaled 1095}}
\html{\newcommand{\ssttt}{\tt}}

%  Define a command to produce a routine header, including its name,
%  a purpose description and the rest of the routine's documentation.
\newcommand{\sstroutine}[3]{
   \newpage
   \label{#1}
   \goodbreak
   \rule{\textwidth}{0.5mm}
   \vspace{-7ex}
   \newline
   \settowidth{\sstbannerlength}{{\Large {\bf #1}}}
   \setlength{\sstcaptionlength}{\textwidth}
   \setlength{\sstexampleslength}{\textwidth}
   \addtolength{\sstbannerlength}{0.5em}
   \addtolength{\sstcaptionlength}{-2.0\sstbannerlength}
   \addtolength{\sstcaptionlength}{-5.0pt}
   \settowidth{\sstexampleswidth}{{\bf Examples:}}
   \addtolength{\sstexampleslength}{-\sstexampleswidth}
   \parbox[t]{\sstbannerlength}{\flushleft{\Large {\bf #1}}}
   \parbox[t]{\sstcaptionlength}{\center{\Large #2}}
   \parbox[t]{\sstbannerlength}{\flushright{\Large {\bf #1}}}
   \begin{description}
      #3
   \end{description}
}

%  Format the description section.
\newcommand{\sstdescription}[1]{\item[Description:] #1}

%  Format the usage section.
\newcommand{\sstusage}[1]{\item[Usage:] \mbox{}
   \begin{description}
      {\ssttt \item #1}
   \end{description}
}
% \newcommand{\sstusage}[1]{\item[Usage:] \mbox{}
% \\[1.3ex]{\raggedright \ssttt #1}}

%  Format the invocation section.
\newcommand{\sstinvocation}[1]{\sloppy \item[Invocation:]\hspace{0.4em}{\tt #1}}
%\newcommand{\sstinvocation}[1]{\item[Invocation:]\hspace{0.4em}{\tt #1}}

%  Format the arguments section.
\newcommand{\sstarguments}[1]{
   \item[Arguments:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the returned value section (for a function).
\newcommand{\sstreturnedvalue}[1]{
   \item[Returned Value:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the parameters section (for an application).
\newcommand{\sstparameters}[1]{
   \item[Parameters:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the examples section.
\newcommand{\sstexamples}[1]{
   \item[Examples:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Define the format of a subsection in a normal section.
\newcommand{\sstsubsection}[1]{ \item[{#1}] \mbox{} \\}

%  Define the format of a subsection in the examples section.
\newcommand{\sstexamplesubsection}[2]{\sloppy \item{\ssttt #1} \mbox{} \\ #2 }
%\newcommand{\sstexamplesubsection}[2]{\sloppy
%\item[\parbox{\sstexampleslength}{\ssttt #1}] \mbox{} \vspace{1.0ex}
%\\ #2 }

%  Format the notes section.
\newcommand{\sstnotes}[1]{\item[Notes:] \mbox{} \\[1.3ex] #1}

%  Provide a general-purpose format for additional (DIY) sections.
\newcommand{\sstdiytopic}[2]{\item[#1:] \mbox{} \\[1.3ex] #2}
%\newcommand{\sstdiytopic}[2]{\item[{\hspace{-0.35em}#1\hspace{-0.35em}:}]
%\mbox{} \\[1.3ex] #2}

%  Format the implementation status section.
\newcommand{\sstimplementationstatus}[1]{
   \item[{Implementation Status:}] \mbox{} \\[1.3ex] #1}

%  Format the bugs section.
\newcommand{\sstbugs}[1]{\item[Bugs:] #1}

%  Format a list of items while in paragraph mode.
\newcommand{\sstitemlist}[1]{
  \mbox{} \\
  \vspace{-3.5ex}
  \begin{itemize}
     #1
  \end{itemize}
}

%  Define the format of an item.
\newcommand{\sstitem}{\item}

%% Now define html equivalents of those already set. These are used by
%  latex2html and are defined in the html.sty files.
\begin{htmlonly}

%  sstroutine.
   \newcommand{\sstroutine}[3]{
      \subsection{#1\xlabel{#1}-\label{#1}#2}
      \begin{description}
         #3
      \end{description}
   }

%  sstdescription
   \newcommand{\sstdescription}[1]{\item[Description:]
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstusage
   \newcommand{\sstusage}[1]{\item[Usage:]
      \begin{description}
         {\ssttt #1}
      \end{description}
      \\
   }

%  sstinvocation
   \newcommand{\sstinvocation}[1]{\item[Invocation:]
      \begin{description}
         {\ssttt #1}
      \end{description}
      \\
   }

%  sstarguments
   \newcommand{\sstarguments}[1]{
      \item[Arguments:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstreturnedvalue
   \newcommand{\sstreturnedvalue}[1]{
      \item[Returned Value:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstparameters
   \newcommand{\sstparameters}[1]{
      \item[Parameters:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstexamples
   \newcommand{\sstexamples}[1]{
      \item[Examples:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstsubsection
   \newcommand{\sstsubsection}[1]{\item[{#1}]}

%  sstexamplesubsection
   \newcommand{\sstexamplesubsection}[2]{\item[{\ssttt #1}] #2}

%  sstnotes
   \newcommand{\sstnotes}[1]{\item[Notes:] #1 }

%  sstdiytopic
   \newcommand{\sstdiytopic}[2]{\item[{#1}] #2 }

%  sstimplementationstatus
   \newcommand{\sstimplementationstatus}[1]{
      \item[Implementation Status:] #1
   }

%  sstitemlist
   \newcommand{\sstitemlist}[1]{
      \begin{itemize}
         #1
      \end{itemize}
      \\
   }
%  sstitem
   \newcommand{\sstitem}{\item}

\end{htmlonly}

%  End of "sst.tex" layout definitions.


% ? End of document specific commands
% -----------------------------------------------------------------------------
%  Title Page.
%  ===========
\renewcommand{\thepage}{\roman{page}}
\begin{document}
\thispagestyle{empty}

%  Latex document header.
%  ======================
\begin{latexonly}
   CCLRC / \textsc{Rutherford Appleton Laboratory} \hfill \textbf{\stardocname}\\
   {\large Particle Physics \& Astronomy Research Council}\\
   {\large Starlink Project\\}
   {\large \stardoccategory\ \stardocnumber}
   \begin{flushright}
   \stardocauthors\\
   \stardocdate
   \end{flushright}
   \vspace{-4mm}
   \rule{\textwidth}{0.5mm}
   \vspace{5mm}
   \begin{center}
   {\Large\textbf{\stardoctitle}}
   \end{center}
   \vspace{5mm}

% ? Heading for abstract if used.
   \vspace{10mm}
   \begin{center}
      {\Large\textbf{Abstract}}
   \end{center}
% ? End of heading for abstract.
\end{latexonly}

%  HTML documentation header.
%  ==========================
\begin{htmlonly}
   \xlabel{}
   \begin{rawhtml} <H1> \end{rawhtml}
      \stardoctitle
   \begin{rawhtml} </H1> <HR> \end{rawhtml}

   \begin{rawhtml} <P> <I> \end{rawhtml}
   \stardoccategory\ \stardocnumber \\
   \stardocauthors \\
   \stardocdate
   \begin{rawhtml} </I> </P> <H3> \end{rawhtml}
      \htmladdnormallink{CCLRC / Rutherford Appleton Laboratory}
                        {http://www.cclrc.ac.uk} \\
      \htmladdnormallink{Particle Physics \& Astronomy Research Council}
                        {http://www.pparc.ac.uk} \\
   \begin{rawhtml} </H3> <H2> \end{rawhtml}
      \htmladdnormallink{Starlink Project}{http://www.starlink.rl.ac.uk/}
   \begin{rawhtml} </H2> \end{rawhtml}
   \htmladdnormallink{\htmladdimg{source.gif} Retrieve hardcopy}
      {http://www.starlink.rl.ac.uk/cgi-bin/hcserver?\stardocsource}\\

%  HTML document table of contents. 
%  ================================
%  Add table of contents header and a navigation button to return to this 
%  point in the document (this should always go before the abstract \section). 
  \label{stardoccontents}
  \begin{rawhtml} 
    <HR>
    <H2>Contents</H2>
  \end{rawhtml}
  \htmladdtonavigation{\htmlref{\htmladdimg{contents_motif.gif}}
        {stardoccontents}}

% ? New section for abstract if used.
  \section{\xlabel{abstract}Abstract}
% ? End of new section for abstract

\end{htmlonly}

% -----------------------------------------------------------------------------
% ? Document Abstract. (if used)
%  ==================
\stardocabstract
% ? End of document abstract
% -----------------------------------------------------------------------------
% ? Latex document Table of Contents (if used).
%  ===========================================
  \newpage
  \begin{latexonly}
    \setlength{\parskip}{0mm}
    \tableofcontents
    \setlength{\parskip}{\medskipamount}
    \markboth{\stardocname}{\stardocname}
  \end{latexonly}
% ? End of Latex document table of contents
% -----------------------------------------------------------------------------
\cleardoublepage
\renewcommand{\thepage}{\arabic{page}}
\setcounter{page}{1}



% ? Main text

% Private macro definitions.

\newcommand{\xroutine}[1]{\htmlref{{\tt #1}}{#1}}
\newcommand{\file}[1]{{\tt #1}}
\newcommand{\routine}[1]{{\tt #1}}
\newcommand{\cc}[1]{{\tt #1}}
\newenvironment{squote}{\begin{quote}\begin{small}}{\end{small}\end{quote}}

\section{Introduction}

The Extreme Dataset project is intended to allow processing of ``unusually''
large data sets by Starlink software, 
although the sizes for which special measures
are required will become less and less unusual as time goes on.
The principal underlying problem is that as images get larger
32 bits are no longer enough to index into an image.
The largest integer that can be stored in 32 bits 
is approximately $4 \times 10^9$ (unsigned) or $2 \times 10^9$ (signed).
If the operating system itself uses unsigned 32 bit pointers to 
address bytes
in memory, this means that it is impossible to map an image of more
than 4Gbyte or, say, two images of half that size. 
This could correspond to, for instance, an input and an output image
simultaneously mapped each with an HDS type of \_DOUBLE and 
size of 16k pixels square.

For this sort of work therefore an operating system with 64-bit 
pointers is required.

For the systems supported by
Starlink this currently means that Compaq Tru64 Unix can be used,
as can Solaris running in 64-bit mode.  
On appropriate hardware the Solaris kernel 
may be compiled for 32 bit or 64 bit mode;
but almost\footnote{
   There can be trouble with applications which use 
   \file{libkvm} or access \file{/proc}.}
all binaries which run on the 32-bit version
will run equally well on the 64-bit version, 
so that reconfiguring a system from 32-bit to 64-bit should be
fairly painless from a software point of view.
You can tell if your Solaris kernel is 64-bit 
by using the \file{isainfo -v} command; on a 64-bit system the
following response will be given
\begin{squote}
\begin{verbatim}
% isainfo -v
64-bit sparcv9 applications
32-bit sparc applications
\end{verbatim}
\end{squote}

User code will also run up against these problems.
It is often necessary to count the pixels, or the bytes,
in an image, and this is typically done using a Fortran INTEGER
or a C \cc{int}.  These are normally signed 32-bit values, with
a maximum value of about $2 \times 10^9$; the pixel count of a 
47k $\times$ 47k image, or the byte count of a 16k $\times$ 16k 
\_DOUBLE image, will overflow this limit.

Another common requirement is holding a pointer 
to allocated memory, which has ultimately been 
acquired from a C routine such as \cc{malloc}, 
in a variable.
In C this will be taken care of automatically because the compiler
will ensure that a pointer type is long enough to hold memory addresses.
In Fortran however there is no pointer type so that INTEGERs, which are
normally 32 bits, have to be used.
The solution to this, explained in \xref{SUN/209}{sun209}{pointers},
is to use the \xref{CNF\_PVAL}{sun209}{CNF\_PVAL} function.

This package provides some tools and instructions for 
software maintainers to use 
in modifying their source code to work in a 64-bit environment.

The issues addressed in this document apply to user programs which link
against Starlink libraries as well as to the code which forms the USSC;
if the USSC has been built for a 64-bit system, then user code 
which uses its libraries will need to be modified at the 
source level in order to work.
Depending on the complexity of the code, it may be easier to do this
with a few manual adjustments than by using the automatic 
tools supplied with the EXTREME package.  
The discussion here should be of use in any case.


\section{Changeover to 64-bit systems}

In general, it is not possible to modify packages to deal with large
images independently of each other;
before changing a package to use 64 bits, it is necessary 
that all the packages on which it depends are 64-bit compatible.
Certain packages, which are used only at a command-line level, 
may not need changes to the code, but any package which provides a library 
against which other code is to link, must be modified,
since the routine interfaces (argument types) will change, 
and, in the case of Solaris
the 32-bit and 64-bit object types cannot be mixed by the link loader.

At some point in the future, it may be that support for 32-bit systems
is dropped, but at the moment this is undesirable, since 
Solaris systems running 32-bit kernels would be incapable of running
code compiled for 64 bits.  
Older Suns (before SPARC v9) cannot be made to run the 64-bit kernels.

For these reasons, the transfer to 64 bits will be approached
effectively as a port to a new system.  All Starlink packages should
therefore come to 
include support for two new values of the \file{makefile}/\file{mk}
SYSTEM variable: ``{\tt alpha\_OSF1\_64}'' and ``{sun4\_Solaris\_64}''.



\section{Modifications to code\label{sec:modificienda}}

Making Starlink packages able to run in 64-bit environment and 
handle appropriately large data sets requires changes to the source
code of each package.
For packages like \xref{HDS}{sun92}{}, 
which get their hands dirty with data structures on disk,
extensive changes are required.
Most packages however can hopefully be fixed by making some more-or-less
automatic changes to the source code.
These changes boil down to making sure that Fortran pointers 
can address any allocated memory,
and making sure that non-pointer integers in Fortran and C 
have enough bits to hold sufficiently large numbers.

Because of the difficulty of distinguishing, in any automatic fashion,
variables which may 
need to hold big numbers from those which will not,
the approach taken is to change the type of {\em all\/} 
integer variables to a 64-bit type in 64-bit environments.
This is a somewhat extravagant solution,
but the alternatives seem to be worse.
Once the increase in integer size has been made 
globally to the source code in a package,
it is possible to identify variables which do not need the extra size
and change their declarations (and other parts of the code which depend
on these) back to the normal integer types.
Such retrochanges could be appropriate in either of the following situations:
\begin{itemize}
\item
The change has broken something which is easier to fix by returning to 
a normal integer size than by other means
\item
The change results in significant overuse of resources, 
and returning to a normal
integer size will not cause too many problems.
\end{itemize}


\subsection{Pointer references in Fortran}

As explained in \xref{SUN/209}{sun209}{pointers} 
whenever the \%VAL Fortran compiler directive 
is used to pass the value of allocated
memory to a subroutine, its argument should be wrapped in a call
to \xref{CNF\_PVAL}{sun209}{CNF\_PVAL}.  This effectively allows
a 32-bit integer to address memory in a 64-bit address space.
Additionally, the header file \file{CNF\_PAR} needs to be included
in affected source files to provide the declaration of the CNF\_PVAL 
function.
This modification is fairly unproblematic, 
since it should not under normal
circumstances affect the behaviour of the code in either 32-bit or
64-bit environments, so it's possible, and advisable, to make this
change to all code and test it before converting the normal integer types
as described in section \ref{sec:fint}.  

The main pitfall of making these modifications is
wrapping the argument of a \%VAL in a CNF\_PVAL call when it ought
not to be so wrapped.
CNF\_PVAL should {\em only\/} be applied to registered pointers.
If your Fortran code uses pointers which are got from C without 
being registered with CNF, you'll need to address this in the C code 
as described in \xref{SUN/209}{sun209}{pointers}.
More commonly, you may have \%VAL invocations which are not
applied to pointers at all --- for instance when passing 
the lengths of character variables as trailing arguments 
as sometimes needs to be done when the compiler doesn't know that
it's passing a character variable.  In this case the \%VAL 
invocation should be left alone and no call to CNF\_PVAL inserted.
In general, it is impossible to spot all such non-pointer uses
of \%VAL automatically.  However, if \%VAL is applied to a constant,
or a small integer, then it should be left alone.

The program \xroutine{inscnf} is supplied for inserting CNF\_PVALs
in the right places.  It wraps {\em all\/} arguments of \%VAL 
in calls to CNF\_PVAL, but emits warnings for those which look like
they may not be pointers.  It is described further in section 
\ref{sec:tools}.


\subsection{Enlarging integer type in Fortran\label{sec:fint}}


In Fortran there is no (even slightly) portable way of declaring
an integer to be of a configurable length. 
Therefore all variables currently declared as `INTEGER' 
should be changed instead to type `INTEGER*8'. 
This is not standard Fortran 77, but it is widely understood by compilers.
This should not be interpreted (by a human) as an indication that exactly
eight bytes are required, but as an indication that this needs to be
long enough to hold a large number.
At compile time, typically on 64-bit systems the code will be compiled
as it stands, while on 32-bit systems a simple \file{sed(1)} script or similar
can preprocess the source code before it's fed to the compiler,
under makefile control (see section \ref{sec:makefile}).

Having done this, the following issues may need to be addressed.
\begin{description}
%
\item[External libraries]\mbox{}
\\
In Fortran, the actual arguments used in a subroutine/function
call must be of the same type as the formal arguments declared
in the routine itself, since arguments are passed by address.
Thus if you change the type of integers passed to a subroutine,
you have to change the type of the integers declared in the subroutine too.
It is therefore necessary either to convert any called subroutines
to using the new integer type (at least as far as their arguments go), 
or to ensure that any calls to these routines use variables of 
the old integer type.
Thus a package can only be successfully converted to large integers
and built once all the libraries against which it links have been 
similarly converted.  The Starlink libraries will therefore have to
be done before applications packages.
If a program uses an external library which is not part of the USSC,
then either the library will have to be converted in the same way,
or the affected calls will have to be written using 
variables specially declared as the normal INTEGER type.
%
\item[Literal integer constants as arguments]\mbox{}
\\
If there are any calls to functions or subroutines in the converted 
code which have literal integer constants as actual arguments,
these will need to be replaced with expressions of the right type.
There is no way of specifying the length of a literal integer constant
in Fortran, so you should either assign a variable (perhaps assigned
using the Fortran PARAMETER statement) or ensure that the expression
has the correct type.  This can be done using a call to the statement
function EXT\_ITOX, which returns an integer equal in value to its
argument, but of the correct type for a large integer
(it behaves just like the NUM\_xTOy functions in the 
\xref{PRIMDAT}{sun39}{} package).
Thus
\begin{squote}
\begin{verbatim}
      CALL SUB( 5, STATUS )
\end{verbatim}
\end{squote}
must be changed to something like
\begin{squote}
\begin{verbatim}
      INTEGER * 8 IFIVE
      PARAMETER( IFIVE = 5 )
        ...
      CALL SUB( IFIVE, STATUS )
\end{verbatim}
\end{squote}
or
\begin{squote}
\begin{verbatim}
      INCLUDE 'EXT_DEC'          ! EXTREME conversion declarations
      INCLUDE 'EXT_DEF'          ! EXTREME conversion definitions
        ...
      CALL SUB( EXT_ITOX( 5 ), STATUS )
\end{verbatim}
\end{squote}
Note that, as for the PRIMDAT file PRM\_DEF, the EXT\_DEF 
file must be included after all variable declarations but before
the first executable statement of the routine.

For convenience another mechanism is provided by the EXTREME package;
the file \file{EXT\_PAR} includes definitions of the integers
-10\ldots 10, with names EXT\_\_M10\ldots EXT\_\_10.
So a third alternative for the above situation would be
\begin{squote}
\begin{verbatim}
      INCLUDE 'EXT_PAR'          ! Integer constant definitions
        ...
      CALL SUB( EXT__5, STATUS )
\end{verbatim}
\end{squote}
{\it (Perhaps this functionality should be handed to PRIMDAT?)}
%
\item[Intrinsic functions]\mbox{}
\\
Calls to Fortran intrinsic functions should take care of themselves,
as long as the generic name is used rather than the specific one
(e.g. you should use ABS instead of IABS).  This is always good
practice in any case.  The only time it is not possible to do 
this is if you are passing an intrinsic function as an actual
argument to a procedure, which is pretty rare.
The only intrinsic functions in standard Fortran 77 which have 
INTEGER-specific names are IABS, ISIGN, IDIM, MAX0, AMAX0, MIN0 and AMIN0.
Others may be available in particular Fortran implementations.
%
\item[Storage association]\mbox{}
\\
The Fortran 77 standard does not state how much storage is used by
an INTEGER, but does state that it should be the same amount as that
used by REALs and LOGICALs.
Converting all INTEGERs to INTEGER*8s will
probably have the effect that this is no longer the case.
Thus code which relies on this, for instance by using COMMON blocks or
EQUIVALENCE statements to address the same memory as both INTEGER and REAL,
will break.  
Such practices are, as you might expect, deprecated by the 
\xref{Starlink Application Programming Standard}{sgp16}{},
but there may be instances of them lurking about.
%
\item[IMPLICIT variable declarations]\mbox{}
\\
It is highly desirable in Fortran, and usual in Starlink code, to use
the ``IMPLICIT NONE'' declaration, so that all variables must be
explicitly declared before use.
It would be possible to fix this by redeclaring IMPLICIT INTEGER
statements as IMPLICIT INTEGER*8, but to make the job easier for
the makefile in editing the source code, it is better to place
an ``IMPLICIT NONE'' statement in every source code module, and
make explicit INTEGER*8 declarations for all integers.
%
\item[I/O return values]\mbox{}
\\
A few Fortran I/O statements have specifiers which require the name
of an INTEGER variable.  In standard Fortran 77 these are 
IOSTAT in all I/O statements, and 
NUMBER, RECL and NEXTREC in the INQUIRE statement.
Particular compilers often provide a whole bunch more, but these
should hopefully not be much used in Starlink code.
So there may be a problem with a statement like
\begin{squote}
\begin{verbatim}
      CLOSE( UNIT = 99, IOSTAT = STVAL )
\end{verbatim}
\end{squote}
if the variable STVAL is now declared INTEGER*8 rather than INTEGER.
Of the supported systems, Tru64 and Solaris seem to handle 
INTEGER*8 variables used for this purpose without complaint.
Linux with g77 0.5.24 may fail to compile although (a) it seems to
be OK if you compile with {\tt -O}, and (b) this is reportedly
fixed at g77 0.5.25.  So it's probably all right to leave these cases.
%
\end{description}

The program \xroutine{frepint} is provided for changing 
INTEGER declarations to INTEGER*8.
Details of which of the above constructs it fixes, and which it
warns about, are given in section \ref{sec:tools}.


\subsection{Enlarging integer type in C\label{sec:cint}}

All references to the type \cc{int} in C code should be changed to 
\cc{INT\_BIG}.  This is a reference to a macro which can be defined
in a header file or on the compiler command line 
(and hence typically in the CFLAG \file{mk} environment variable).  
For a 32-bit build it would normally be defined at build time as 
\cc{int} and for a 64-bit build as \cc{long}.
As well as declarations of variables and functions, this applies
to casts and arguments of \cc{sizeof} too (in fact almost any 
syntactically significant occurrence of the identifier `\cc{int}').
References to the types \cc{short~int} and \cc{long~int},
which are just synonyms for \cc{short} and \cc{long} respectively,
should not be changed.  Type \cc{unsigned INT\_BIG} 
(or, redundantly, \cc{signed INT\_BIG}) may be used.

As regards calling functions from external libraries,
the approach described in section \ref{sec:fint} of 
recoding all the functions in the library will of course work in C too.
However, this is not always necessary.
If a function's declaration (prototype) is in scope when it is called,
the compiler will normally 
convert each actual argument to the declared type of
the corresponding formal argument in the prototype 
before passing it by value.
Hence the following code
\begin{squote}
\begin{verbatim}
int add( int a, int b );
INT_BIG i, j;
add( i, j );
\end{verbatim}
\end{squote}
is correct whatever type \cc{INT\_BIG} is defined as, 
since \cc{i} and \cc{j} are converted to type \cc{int}
before \cc{add()} sees them.
If the prototype of \cc{add()} were not in scope however,
the conversion would not take place and the code would be
in error.\footnote{
   In fact, the standard says simply that the effect of the call is
   undefined in this case.  Furthermore, it seems that the three
   currently supported systems handle these cases without
   any undesirable behaviour; presumably the compilers are written
   such that all arguments are passed in 64 bits or in registers.
   But such code is still not correct.
}
The lesson is to make sure that header files are
included.
Of course this relies on having ANSI-style function prototypes;
if old-style function declarations are used then no argument type
conversions are made.  For code which uses old-style function 
declarations it is probably best to convert it to ANSI style.

However this does not solve all problems.
Where a function has a variable argument list
(as declared in the prototype using ellipsis `\cc{...}'
and handled in the function using the \file{stdarg.h} macros), 
the function prototype
is not able to specify the types of all arguments,
and so the type of the actual argument must match the type of
the formal argument for correctness.  If it is impractical
to recode the function (as in the case of \cc{printf}),
the best solution is to cast the variable arguments to the type
which is expected where the function is called.

A more difficult problem is when the address of an argument is
passed so that the contents of that address can be changed by
the function.  In this case if the called function has a
different idea of the length of the object being pointed to
it will write to the wrong amount of memory, possibly overwriting
other data.  Consider this function:
\begin{squote}
\begin{verbatim}
   void zero( int *a ) { *a = 0; }
\end{verbatim}
\end{squote}
and this code:
\begin{squote}
\begin{verbatim}
   INT_BIG x;
   zero( &x );
\end{verbatim}
\end{squote}
If \cc{INT\_BIG} is a 64 bit type and \cc{int} is 32 bits
then only half the bits in the variable \cc{x} will be zeroed by this call.
If the function declaration is in the same file as the call,
the compiler will (hopefully) issue a warning about this sort of thing; 
again, make sure that the appropriate header files are included.
Again, in the case of variable argument lists, the compiler can't spot it.

To summarise, external functions should be declared before use by
including the appropriate header files.  If this is done, then the only
problems associated with calling functions which have not been
converted to use \cc{INT\_BIG} instead of \cc{int} should be:
\begin{description}
\item[INT\_BIG in variable part of argument list:]
A modified caller of an unmodified function should explicitly cast
an \cc{INT\_BIG} argument in the variable (\cc{...}) part of the argument
list.  
Normally the cast should be to \cc{int}, but it may possible,
as with \cc{printf}, to cast to \cc{long} and indicate to the called
function that this has been done).
A modified function which will may get called by unmodified code
should expect arguments of type \cc{int}
(i.e.\ should call the \cc{va\_arg} macro with a second argument
of \cc{int} instead of \cc{INT\_BIG}).
%
\item[Pointer to INT\_BIG variable passed:]
A modified caller of an unmodified function will have to declare
a local variable of type \cc{int} and exchange values between it
and the \cc{INT\_BIG} before, and possibly after, the call.
A modified function which may get called by unmodified code 
will have to declare pointer arguments as pointers to a given fixed
type (presumably \cc{int}), not to \cc{INT\_BIG}.
\item[Overflow:]
If an \cc{INT\_BIG} value which is too large to be an \cc{int}
is passed to a variable which is an \cc{int}, arithmetic overflow will
occur when C tries to do the type conversion according to the function
declaration.
No warning is issued by the Solaris or Tru64 C runtime systems about
such overflows.
\end{description}
Examples of these modifications in action are given in the discussion of 
\cc{printf} and \cc{scanf} below.


External libraries which code may have to link against
can be split into a few categories:
\begin{description}
%
\item[Starlink libraries]\mbox{}
\\
As with Fortran, the plan is for Starlink libraries to get converted
to use \cc{INT\_BIG}
before code which uses them (although for C code calling C libraries
this is not so necessary as with Fortran when functions are pre-declared
using header files).
%
\item[Blocks of source code not to be converted:]\mbox{}
\\
It is probably not a good idea to do \cc{INT\_BIG} conversion to
large bodies of non-Starlink code used by the USSC; Perl and Tcl
spring to mind.  
If there is function-level access to these packages,
some recoding may be required as above.
%
\item[The C standard library:]\mbox{}
\\
The functions of the C standard library are no different from any
other unconverted external library, but since their use is
common, we discuss it in detail here.
Most of the functions in the standard library will be handled
adequately as described above by including the appropriate header files,
since they do not have \cc{int~*} arguments or variable argument lists.
The exception is those which use format strings:
\cc{printf}, \cc{fprintf}, \cc{sprintf} and 
\cc{scanf}, \cc{fscanf}, \cc{sscanf}; these fall foul of both obstacles.
For \cc{printf} and friends 
any of the format specifiers \cc{cdiouxX*}\footnote{
   Inclusion of the \cc{c} format specifier here is not a mistake.
   Although the corresponding argument will typically be of type \cc{char},
   it is promoted to \cc{int} by the usual mechanism before being 
   passed to \cc{printf}.  If the type of the actual argument is
   of type \cc{char} and not type \cc{INT\_BIG} of course, no change 
   will be required here.
}
indicate that the corresponding argument should be an \cc{int},
and the \cc{n} specifier indicates a pointer to \cc{int}.
For \cc{scanf} and friends, any of the specifiers \cc{diouxXn} indicate
pointer to \cc{int}.
If any of the actual arguments in the call is of type \cc{INT\_BIG} 
(or \cc{INT\_BIG~*}) when it should be of type \cc{int} (or \cc{int~*}),
then the calling code needs to be changed.

In the case of \cc{int} arguments, if the actual argument
might be too large to be
represented in an \cc{int}, then an \cc{l} should be inserted to 
indicate that a \cc{long} argument is being supplied and the 
corresponding argument cast to \cc{long}.  If it will definitely
be possible to store the value in an \cc{int} then the format specifier
may be left alone and the argument cast to \cc{int}.
Arguments passed using the \cc{c} or \cc{*} specifiers should be cast 
to \cc{int}, and not modified with an \cc{l} character.
In the case of \cc{int~*} arguments, intermediate variables have to be used.
Here is an example.  If after simple substitution of \cc{INT\_BIG} for
\cc{int} a piece of code reads:
\begin{squote}
\begin{verbatim}
   extern INT_BIG quintuple( INT_BIG x );
   INT_BIG i, j;
   char c;
   scanf( "%i %c", &i, &c );
   j = quintuple( i );
   printf( "Integer quintupled is %i; Character is '%c'\n", j, c );
\end{verbatim}
\end{squote}
then the \cc{scanf} call must be replaced by something like this: 
\begin{squote}
\begin{verbatim}
   {  
      long tmp; 
      scanf( "%li %c", &tmp, &c ); 
      i = tmp; 
   }
\end{verbatim}
\end{squote}
and the \cc{printf} call by something like this:
\begin{squote}
\begin{verbatim}
   printf( "Integer quintupled is %li; Character is '%c'\n", (long) j, c );
\end{verbatim}
\end{squote}
%
\item[Other external libraries:]\mbox{}
\\
If your code links to any other external libraries
which cannot, or will not, be converted to use \cc{INT\_BIG}s,
some recoding of the calls may be required as above.
\end{description}


There are a few other issues which arise from replacing \cc{int} type
with \cc{INT\_BIG}:
\begin{description}
%
\item[Integer constants from limits.h:]\mbox{}
\\
Where an \cc{int} is compared against one of the values 
\cc{INT\_MAX}, \cc{INT\_MIN} and \cc{UINT\_MAX} 
defined in the system header file \file{limits.h},
an \cc{INT\_BIG} should be compared against one of the corresponding
macros \cc{INT\_BIG\_MAX} etc.
These macros are defined in the header file \file{extreme.h}, 
which should be included {\em after\/} \file{limits.h} in the source file.
%
\item[Implicit int declarations:]\mbox{}
\\
There are several places in C (macros and typedefs apart) 
in which an identifier can be declared
as an \cc{int} without the \cc{int} reserved word appearing.
For example, in the code:
\begin{squote}
\begin{verbatim}
sub( x ) {
   static y;
   signed z;
}
\end{verbatim}
\end{squote}
the symbols \cc{sub}, \cc{x}, \cc{y} and \cc{z} all have type \cc{int}.
%
\item[int used for Fortran LOGICAL:]\mbox{}
\\
Where a C \cc{int} is used to represent a LOGICAL variable in Fortran,
it should not be replaced by \cc{INT\_BIG}.
This is only likely to arise in certain low-level code 
(e.g.\ \xref{HDS}{sun92}{} and \xref{CNF}{sun209}{}) 
which does direct interfacing with Fortran.
%
\end{description}

The program \xroutine{crepint} is provided for making some of these
changes.  It replaces all references to \cc{int} type, with a few exceptions,
by \cc{INT\_BIG} type, modifies explicit declarations which are of type 
\cc{int}, and warns about constructs which might need further attention.
It is described in section \ref{sec:tools}.

A construction which \routine{crepint} misses altogether is finding
implicit declarations in function prototypes, which are implicitly
of type \cc{int}.
The {\tt -proto} flag of Tru64 Unix's C compiler is useful for identifying
these.
Given a file \file{sub.c} which reads:
\begin{squote}
\begin{verbatim}
sub( x ) {
   return x;
}
\end{verbatim}
\end{squote}
then running
\begin{squote}
\begin{verbatim}
% cc -protoi -noobject sub.c
\end{verbatim}
\end{squote}
will produce a file called \file{sub.H} which reads:
\begin{squote}
\begin{verbatim}
extern int sub(int x);
\end{verbatim}
\end{squote}
Occurrences of \cc{int} in the output \file{sub.H} should be 
changed to read \cc{INT\_BIG} wherever the function is declared or
defined in the source code (typically in a source file and maybe a 
header file), so that \file{sub.c} should
end up reading:
\begin{squote}
\begin{verbatim}
INT_BIG sub( INT_BIG x ) {
   return x;
}
\end{verbatim}
\end{squote}
By running
\begin{squote}
\begin{verbatim}
% cc -protoi -noobject -DINT_BIG=long
\end{verbatim}
\end{squote}
and attending to any \cc{int} declarations in the resulting \file{.H} files,
it should be possible to find any offending implicit declarations.


\subsection{Changes to makefile/mk\label{sec:makefile}}

Since not all build environments require the enlarged integers,
the build process must be modified so that 64-bit integers are
used for some build environments and 32-bit integers for others.
Identifying build environments is done by using different values
of the SYSTEM macro.  As well as the existing supported values
\begin{itemize}
\item ix86\_Linux
\item sun4\_Solaris
\item alpha\_OSF1
\end{itemize}
which indicate that 32-bit integers should be used as before, 
the following new ones should be used
\begin{itemize}
\item sun4\_Solaris\_64
\item alpha\_OSF1\_64
\end{itemize}
which indicate that 64-bit integers should be used.
Thus two new stanzas are required in the \file{mk} file for each package
setting the values of the other \file{makefile} macros for the newly
supported systems.  

Additionally, a new macro INTEGER8 should be 
defined by the \file{mk} file.  This should contain text which is to
replace `INTEGER~*~8' declarations in fortran source code.  
If blank (defined as spaces or the empty string) it means 
that INTEGER~*~8 declarations should be left unchanged.
Therefore for 64-bit systems this should be defined as the empty
string, and for 32-bit systems it should be defined as `INTEGER~~~~'
(defining it with four trailing spaces improves the aesthetics of
the modified source files).
The makefile should then apply the INTEGER*8 $\rightarrow$ \$(INTEGER8)
substitution to the fortran source files as it extracts them from the
tar archive where they are stored.

For C source code, the \cc{INT\_BIG} preprocessor macro needs to be defined.
This is most easily done by adding a \cc{-DINT\_BIG=int} or 
\cc{-DINT\_BIG=long} flag as appropriate to the
CFLAGS macro in each \file{mk} stanza.
Alternatively, a SYSTEM\_VARIANT-controlled header file could be
written and included into all C source files.

The following gives the relevant parts of a minimal \file{mk}
file by way of example:
\begin{squote}
\begin{verbatim}
   ...
#  Supported Systems:
#     The following systems are currently supported and may be
#     identified by defining the SYSTEM environment variable
#     appropriately before invoking this script:
#
#        alpha_OSF1
#           DEC Alpha machines running OSF1
#
#        alpha_OSF1_64
#           DEC Alpha machines running OSF1, long integers
#
#        ix86_Linux
#           Intel PC running Linux
#
#        sun4_Solaris
#           SUN Sparcstations running SunOS 5.x (Solaris)
#
#        sun4_Solaris_64
#           SUN Sparcstations running SunOS 5.x (64-bit Solaris), long integers
   ...
#        CFLAGS (-O -DINT_BIG=int)
#           The C compiler options to use.
#
#        INTEGER8 (INTEGER    )
#           Replacement text for 'INTEGER * 8' declarations in the original
#           original Fortran source code.  If set to the empty string,
#           INTEGER * 8 declarations will not be modified.  For 64-bit
#           systems which must be able to deal with very large images
#           this should be set to the empty string (or 'INTEGER*8').
#           Otherwise, more efficient code may be generated by setting
#           it to 'INTEGER' or 'INTEGER*4'.  The trailing whitespace is
#           optional but may make source code more readable.
   ...

      export INTEGER8
   ...

      case "$SYSTEM" in

#  DEC Alpha machines running OSF1.
#  -------------------------------
         alpha_OSF1)
            CFLAGS='-DINT_BIG=int'
            INTEGER8='INTEGER    '
               ...

#  DEC Alpha machines running OSF1, long integers.
#  ----------------------------------------------
         alpha_OSF1_64)
            CFLAGS='-DINT_BIG=long'
            INTEGER8=''
            SOURCE_VARIANT='alpha_OSF1'
               ...

#  SUN Sparcstations running SunOS 5.x (Solaris).
#  ---------------------------------------------
         sun4_Solaris)
            CFLAGS='-DINT_BIG=int'
            INTEGER8='INTEGER    '
               ...

#  SUN Sparcstations running SunOS 5.x (Solaris), long integers.
#  ------------------------------------------------------------
         sun4_Solaris_64)
            CFLAGS='-DINT_BIG=long -xarch=v9'
            INTEGER8=''
            SOURCE_VARIANT='sun4_Solaris'
               ...

#  Intel PC running Linux.
#  ----------------------
         ix86_Linux)
            CFLAGS='-DINT_BIG=int'
            INTEGER8='INTEGER    '
               ...
\end{verbatim}
\end{squote}
Note the `{\tt -xarch=v9}' addition to the sun4\_Solaris\_64 CFLAGS,
which instructs the compiler to compile for a 64-bit system
(the difference is effectively that pointers and \cc{long}s are stored in
64 bits instead of 32 bits when this flag is given).
Tru64 Unix C compiles for 64 bit executables by default, so needs no
extra flags.
The SOURCE\_VARIANT assignments here make the assumption that the same
machine-specific source files can be used for 32-bit and 64-bit 
builds on the same platform.

The relevant parts of a suitable matching \file{makefile} would look 
something like this:
\begin{squote}
\begin{verbatim}
#  Default values for macros for compiling C and Fortran source code.

CFLAGS = -O -DINT_BIG=int

#  Default replacement text for Fortran INTEGER * 8 type.

INTEGER8 = INTEGER
   ...

#  Macro for filter to replace INTEGER * 8 declarations with INTEGER8.

REPLACE_INTEGER8 = sed \
   "s/^[ \t]*[Ii][Nn][Tt][Ee][Gg][Ee][Rr] *\* *8/      $(INTEGER8)/"

#  Rules for extracting non-Fortran files from the source archive.

$(C_FILES):
        $(TAR_OUT) $(PKG_NAME)_source.tar $@
        @ if test -f $@; then :;\
           else echo $@ is not in the tar file; exit 1; fi

#  Rules for extracting Fortran files from the source archive.

$(F_FILES):
        $(TAR_OUT) $(PKG_NAME)_source.tar $@
        @ if test -f $@; then :;\
           else echo $@ is not in the tar file; exit 1; fi
        if test $(INTEGER8); then \
           $(REPLACE_INTEGER8) < $@ > $@_tmp; \
           mv $@_tmp $@; \
        else :; fi

#  Rules for extracting platform specific Fortran files from the archive.

$(PLATFORM_F) dummy_target2:
        $(TAR_OUT) $(PKG_NAME)_source.tar $@_$(SOURCE_VARIANT)
        @ if test -f $@_$(SOURCE_VARIANT); then :;\
           else echo $@_$(SOURCE_VARIANT) is not in the tar file; exit 1; fi
        if test $(INTEGER8); then \
           $(REPLACE_INTEGER8) < $@_$(SOURCE_VARIANT) > $@; \
           rm -f $@_$(SOURCE_VARIANT); \
           else mv $@_$(SOURCE_VARIANT) $@; fi
   ...

#  Enter information about the current machine and build environment
#  into the date stamp file.
   ...
        @ echo '   INTEGER8: $(INTEGER8)'     >>$(DATE_STAMP)
\end{verbatim}
\end{squote}

It may also be necessary to add dependencies for INCLUDE files inserted
by the conversion tools; \xroutine{inscnf} may include \file{CNF\_PAR}
and \xroutine{frepint} may include \file{EXT\_PAR} in some Fortran source
files.  Rules will need to be made for building links to the referenced
include files, and dependencies added for the object files corresponding
to the source files so modified.

Note that because of the way this method edits Fortran source files on
their way out of the source archive
(typically \file{\$(PKG\_NAME)\_source.tar}),
the copies of the files in the build directory may not be the same
as the files in the source archive.
This means that in general the source archive cannot be rebuilt 
from the files in the build directory.
This may well break private, non-standard targets inserted into the
makefile by the package developer (commonly called {\tt archive}),
and effectively means that it is not possible to tweak package source
code in the build directory prior to re-exporting it.


\section{Tools\label{sec:tools}}

This section documents utilities distributed with this package
to modify source code for use in 64-bit environments.

Basically, one tool is provided for each of the source code conversion
tasks described in the previous section:
\begin{description}
\item[inscnf:] Inserts CNF\_PVAL calls where required in Fortran source code
\item[frepint:] Converts INTEGER to INTEGER*8 in Fortran source code
\item[crepint:] Converts \cc{int} to \cc{INT\_BIG} in C source code
\end{description}
Each of these is a normal Unix filter command such as \file{cat}, 
so may be given zero, one or two arguments to specify its input and output.
Where no change needs to be made, the input is written with no changes 
to the output.  This means that the \file{diff} command can be used 
to see what changes the filters make, by doing something like:
\begin{squote}
\begin{verbatim}
% frepint file.f | diff file.f -
\end{verbatim}
\end{squote}
which might give a result like:
\begin{squote}
\begin{verbatim}
94c94
<       INTEGER STATUS             ! Global status
---
>       INTEGER * 8 STATUS         ! Global status
97,98c97,98
<       INTEGER I                  ! Loop variable
<       INTEGER INDF               ! NDF identifier
---
>       INTEGER * 8 I              ! Loop variable
>       INTEGER * 8 INDF           ! NDF identifier
\end{verbatim}
\end{squote}

Each of the filters draws attention to constructs which might need 
further attention.  It will do this either by writing a message to
standard error or by inserting a comment line in the output.
Such comment lines contain the name of the filter followed by a colon
and explanatory text, so for instance:
\begin{squote}
\begin{verbatim}
% crepint file.c | grep crepint:
/* crepint: Format string contains %[cdiouxX*]                           */
\end{verbatim}
\end{squote}
If the filter thinks it has lost track of the source code in a dangerous
way, i.e.\ that it might be making changes which are likely to invalidate
the code, it may exit with an error status, and print a message to standard
error to that effect.

Each of the filters has a go at retaining the aesthetic 
qualities of the code; an attempt is made to respect 
case usage and spacing conventions in Fortran, 
padding whitespace is shuffled to keep things at the same column as
before if possible, and so on.
If replacement text is longer than the original
then Fortran lines are broken in hopefully reasonable places,
but no line breaks in existing lines are introduced in C.

In addition, for each of the filters, a driver script is provided. 
For converting large numbers of files, this is likely to be the 
most convenient way to proceed.  Basically the driver scripts 
run the filters on a given set of files, summarise the output, and
write the files which need changes in a given place.
They also perform some crude safety checks that the modified source
files seem to have been changed in the right way (for instance, that
no changes have been made except for the ones which should have been
made, and that changes to Fortran code do not result in lines longer
than 72 characters).  
These checks do not nearly such careful parsing
of the source code that the conversion filters themselves do, so
they can throw up false positives or false negatives, but they give 
an extra level of confidence.

The driver script for \xroutine{inscnf} is called \file{do\_inscnf}
and is invoked with the files to be converted as command line arguments.
For each of its command line arguments it runs \xroutine{inscnf} and
\begin{itemize}
\item Writes a line to a log file \file{./inscnf.log} 
      saying how many lines were changed
\item If and only if some changes were made, it writes the modified copy
      of the file, under the same name, 
      into a directory called \file{./inscnf.changed}
\item If the filter or the driver script thinks there might be something 
      which needs human attention, it writes a suitable message to standard
      output.  These warning messages can be understood in conjunction 
      with the documentation of the filter, or of the corresponding 
      text in section \ref{sec:modificienda}.
\end{itemize}
Finally it writes a short summary of the run.
An excerpt of its output might look like this:
\begin{squote}
\begin{verbatim}
% do_inscnf *.f *.gen
***  astimp.f:            inscnf: Last arg %VAL in FTS1_GKEYD       ***
***  import.f:            inscnf: Integer %VAL arg in CCD1_IMFIT?   ***
***  import.f:            inscnf: Last arg %VAL in CCD1_IMFIT       ***
  ...
71/483 modified files written in ./inscnf.changed
Logfile is ./inscnf.log
\end{verbatim}
\end{squote}

The other driver scripts, \file{do\_crepint} and \file{do\_frepint},
differ in the form of their output somewhat but otherwise work the
same way as \file{do\_inscnf}.

Detailed descriptions of the behaviour of the filter programs is
given in section \ref{sec:filters}

\section{Filter utility descriptions\label{sec:filters}}

%%%% Begin filter descriptions
\newpage
\sstroutine{
   inscnf
}{
   Wrap \%VAL arguments with CNF\_PVAL in Fortran
}{
   \sstdescription{
      This is a filter which takes FORTRAN 77 source code
      and modifies it so that text which is the argument of a \%VAL
      directive is wrapped in a call to CNF\_PVAL; i.e. input text

         \%VAL( IPTR )

      is changed to

         \%VAL( CNF\_PVAL( IPTR ) )

      If the call to CNF\_PVAL is already present no change is made.
      Lines with no references to the \%VAL directive are left alone.

      Additionally, for each program unit in which a call to CNF\_PVAL
      has been made, an attempt is made to insert a line like

         INCLUDE {\tt '}CNF\_PAR{\tt '}        ! For CNF\_PVAL function

      This is inserted after the last INCLUDE line which already exists
      in the program unit.  If there are no INCLUDE lines there, this
      line is not inserted, and a warning message is printed to standard
      error.

      Attention is paid to Fortran 77 source format, so that lines
      more than 72 characters long are avoided (unless they were there
      in the first place).

      Characters {\tt '}$\backslash$r{\tt '} (carriage return) and {\tt '}$\backslash$t{\tt '} (tab) might possibly
      cause erroneous line breaking - if any are encountered a warning
      is given (these shouldn{\tt '}t be in the source really).
      Code using columns 73-80 of the source cards for comments is
      likely to be mangled (nobody does this any more do they?).

      Under certain improbable circumstances it is possible for the
      program to get stuck trying to break a line; in this case it will
      exit with error status and an error message.

      Some attention is paid to the aesthetic qualities of the output:
      line breaks are done, where possible, following the usage in, e.g.,
      KAPPA.  An attempt is made copy the style of case usage and bracket
      spacing from the input.

      This program wraps ALL occurrences of \%VAL in a call to CNF\_PVAL,
      unless they are already so wrapped.  If it suspects that \%VAL
      may not be a legitimate candidate for this treatment, it will
      output a warning message to standard error.  It will do this in
      the following cases:
      \sstitemlist{

         \sstitem
           \%VAL is on the last argument in the argument list (this
             suggests that it might be a trailing string length)

         \sstitem
           The argument of \%VAL looks like an integer constant

         \sstitem
           The argument of \%VAL looks like a Starlink-style symbolic
             constant (has two adjacent underscore characters).
      }
   }
   \sstusage{
      inscnf [ in [ out ] ]
   }
   \sstnotes{
      Although this program behaves as a filter, it is written on
      the assumption that it will be run on a file of a finite length:
      it may buffer large amounts of input before writing output, and
      it may not free up memory.
   }
}
\newpage
\sstroutine{
   frepint
}{
   Replace INTEGER by INTEGER$*$8 in Fortran
}{
   \sstdescription{
      This program is a filter which takes FORTRAN 77 source code
      and modifies it so that INTEGER declarations are rewritten as
      {\tt '}INTEGER $*$ 8{\tt '}.  It also attempts to warn if there are usages which
      might cause trouble given this change.

      Additionally, if there appear to be actual arguments to subroutines
      or functions which are literal integers, the program will attempt
      to replace them with symbolic constants, as defined in the
      EXT\_PAR include file.  It will also attempt to add a line INCLUDEing
      this file.  This aspect of the processing is not foolproof.
      It can misidentify an array reference as a function call - if
      the {\tt '}function{\tt '} name contains an underscore it assumes that it is
      a function name and not an array name.  Only single literal integers
      as actual arguments are thus replaced, so that, e.g. the code

         L = XXX1\_FUNC( X, Y, Z, 0, 3 $*$ 5, STATUS )

      will be replaced by

         L = XXX1\_FUNC( X, Y, Z, EXT\_\_0, 3 $*$ 5, STATUS )

      Attention is paid to fortran 77 source format, so that lines
      more than 72 characters long are avoided (unless they were there
      in the first place).

      Some attention is paid to the aesthetic qualities of the output:
      line breaks are done, where possible, following the usage in, e.g.,
      KAPPA.  An attempt is made copy the style of case usage from the
      input.

      No changes are made to comment lines so that, for instance, the
      Arguments stanza of subroutine prologues will not have argument
      types modified from {\tt '}INTEGER{\tt '} to {\tt '}INTEGER $*$ 8{\tt '}.

      The program will write a warning on standard error for certain
      constructions in the code which are likely to cause trouble after
      the mass redeclaration of INTEGER as INTEGER$*$8 has occurred.
      These constructions are:
      \sstitemlist{

         \sstitem
            INTEGER $*$ n declarations which already exist in the code
              (these are not modified)

         \sstitem
            EQUIVALENCE statements

         \sstitem
            Use of INTEGER Specific names for standard intrinsic functions
              (IABS, ISIGN, IDIM, MAX0, AMAX0, MIN0, IMIN0)

         \sstitem
            Any module (SUBROUTINE, FUNCTION or BLOCK DATA) which does not
              include an IMPLICIT NONE statement.
      }
   }
   \sstusage{
      frepint [ in [ out ] ]
   }
   \sstnotes{
      Although this program behaves as a filter, it is written on
      the assumption that it will be run on a file of a finite length:
      it may buffer large amounts of input before writing output, and
      it may not free up memory.
   }
   \sstbugs{
      In some cases, the line breaks are not made in very beautiful places.
      They should, however, always be correct.
   }
}
\newpage
\sstroutine{
   crepint
}{
   Replace int by INT\_BIG in C
}{
   \sstdescription{
      This program is a filter which takes C source code and replaces
      any occurrences of the type specifier `int{\tt '} by the identifier
      `INT\_BIG{\tt '}.  This identifier should then be assigned a preprocessor
      value of a suitable integral type (int or long) either using an
      include file or with a -DINT\_BIG=xxx flag on the C compiler.

      It{\tt '}s not quite as simple as replacing every semantically significant
      occurrence of the `int{\tt '} identifier; `short int{\tt '} and `long int{\tt '} type
      specifiers will be left alone.

      If a use of int appears to be declaring a symbol called `main{\tt '} or
      `argc{\tt '}, then this will be left alone too, and a message written
      to standard error to the effect that it is not being changed.

      Additionally, references to the limit.h macros INT\_MAX, INT\_MIN
      and UINT\_MAX are replaced by INT\_BIG\_MAX, INT\_BIG\_MIN and
      UINT\_BIG\_MAX respectively.  These may be defined on the compiler
      command line, or using a suitable header file (extreme.h), which
      would sensibly be included immediately after limit.h.

      Explicit declarations which are implicitly of type int will have
      an INT\_BIG token inserted - for instance `static x, y;{\tt '} will be
      changed to `static INT\_BIG x, y;{\tt '}.

      The program will write a warning on standard error for certain
      constructions in the code which are likely to cause trouble after
      the mass redeclaration of int as INT\_BIG has occurred.
      These constructions are:
      \sstitemlist{

         \sstitem
            Declarations of functions with variable argument lists

         \sstitem
            Use of format strings in formatted I/O which may need changes

      }
      In the case of potentially dangerous format strings, for
      convenience a comment is inserted in the output code on the line
      before the format string is used.  The comment will contain the
      character string `crepint: {\tt '}.

      The program does not make all changes which are required to effect
      this conversion.  The following constructions are likely to cause
      trouble, but will not be warned about by the program:
      \sstitemlist{

         \sstitem
            Use of functions without prototypes.  If header files are
              omitted or old style function declarations are used then the
              ANSI C machinery for doing type conversion at function call
              time will not work.

         \sstitem
            Use of external C libraries apart from the C standard library
              which have not been recoded replacing INT\_BIG for int.

         \sstitem
            Implicit declarations, which are implicitly of type int.
              If a name is declared simply by mentioning it without any type
              or type qualifiers, it is implicitly of type int, and so
              should become delcared as INT\_BIG.  This program does not
              find these.  Such implicit declarations (only?) occur in
              function declarations.  The Tru64 Unix C compiler{\tt '}s {\tt "}-protois{\tt "}
              flag is useful for identifying these.

      }
      The program tries to adjust padding whitespace outside comments
      so that the spacing of the output looks OK.

      No changes are made to comment lines so that, for instance, the
      Synopsis stanza of function prologues will not have formal argument
      types changed from {\tt '}int{\tt '} to {\tt '}INT\_BIG{\tt '}.
   }
   \sstusage{
      crepint [ in [ out ] ]
   }
   \sstnotes{
      Although this program behaves as a filter, it is written on
      the assumption that it will be run on a file of a finite length:
      it may buffer large amounts of input before writing output, and
      it may not free up memory.
   }
}
%%%% End filter descriptions

% ? End of main text
\end{document}

% $Id$
