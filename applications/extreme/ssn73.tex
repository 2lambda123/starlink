\documentclass[twoside,11pt]{article}

% ? Specify used packages
% \usepackage{graphicx}        %  Use this one for final production.
% \usepackage[draft]{graphicx} %  Use this one for drafting.
% ? End of specify used packages

\pagestyle{myheadings}

% -----------------------------------------------------------------------------
% ? Document identification
% Fixed part
\newcommand{\stardoccategory}  {Starlink System Note}
\newcommand{\stardocinitials}  {SSN}
\newcommand{\stardocsource}    {ssn\stardocnumber}

% Variable part - replace [xxx] as appropriate.
\newcommand{\stardocnumber}    {73.1}
\newcommand{\stardocauthors}   {Mark Taylor}
\newcommand{\stardocdate}      {17 January 2000}
\newcommand{\stardoctitle}     {EXTREME --- Handling extreme data sets}
\newcommand{\stardocabstract}  {
This package provides some utilities and background documentation 
for adapting the USSC, and software which uses it, 
to handle very large data sets.
The principal focus of this is to move to use of 64 bits of address
space on 64-bit operating systems.
}
% ? End of document identification
% -----------------------------------------------------------------------------

% +
%  Name:
%     ssn.tex
%
%  Purpose:
%     Template for Starlink System Note (SSN) documents.
%     Refer to SUN/199
%
%  Authors:
%     AJC: A.J.Chipperfield (Starlink, RAL)
%     BLY: M.J.Bly (Starlink, RAL)
%     PWD: Peter W. Draper (Starlink, Durham University)
%     MBT: Mark B. Taylor (Starlink)
%
%  History:
%     17-JAN-1996 (AJC):
%        Original with hypertext macros, based on MDL plain originals.
%     16-JUN-1997 (BLY):
%        Adapted for LaTeX2e.
%     13-AUG-1998 (PWD):
%        Converted for use with LaTeX2HTML version 98.2 and
%        Star2HTML version 1.3.
%     17-JAN-1999 (MBT):
%        Instantiated as SSN/73.
%     {Add further history here}
%
% -

\newcommand{\stardocname}{\stardocinitials /\stardocnumber}
\markboth{\stardocname}{\stardocname}
\setlength{\textwidth}{160mm}
\setlength{\textheight}{230mm}
\setlength{\topmargin}{-2mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\setlength{\unitlength}{1mm}

% -----------------------------------------------------------------------------
%  Hypertext definitions.
%  ======================
%  These are used by the LaTeX2HTML translator in conjunction with star2html.

%  Comment.sty: version 2.0, 19 June 1992
%  Selectively in/exclude pieces of text.
%
%  Author
%    Victor Eijkhout                                      <eijkhout@cs.utk.edu>
%    Department of Computer Science
%    University Tennessee at Knoxville
%    104 Ayres Hall
%    Knoxville, TN 37996
%    USA

%  Do not remove the %begin{latexonly} and %end{latexonly} lines (used by 
%  LaTeX2HTML to signify text it shouldn't process).
%begin{latexonly}
\makeatletter
\def\makeinnocent#1{\catcode`#1=12 }
\def\csarg#1#2{\expandafter#1\csname#2\endcsname}

\def\ThrowAwayComment#1{\begingroup
    \def\CurrentComment{#1}%
    \let\do\makeinnocent \dospecials
    \makeinnocent\^^L% and whatever other special cases
    \endlinechar`\^^M \catcode`\^^M=12 \xComment}
{\catcode`\^^M=12 \endlinechar=-1 %
 \gdef\xComment#1^^M{\def\test{#1}
      \csarg\ifx{PlainEnd\CurrentComment Test}\test
          \let\html@next\endgroup
      \else \csarg\ifx{LaLaEnd\CurrentComment Test}\test
            \edef\html@next{\endgroup\noexpand\end{\CurrentComment}}
      \else \let\html@next\xComment
      \fi \fi \html@next}
}
\makeatother

\def\includecomment
 #1{\expandafter\def\csname#1\endcsname{}%
    \expandafter\def\csname end#1\endcsname{}}
\def\excludecomment
 #1{\expandafter\def\csname#1\endcsname{\ThrowAwayComment{#1}}%
    {\escapechar=-1\relax
     \csarg\xdef{PlainEnd#1Test}{\string\\end#1}%
     \csarg\xdef{LaLaEnd#1Test}{\string\\end\string\{#1\string\}}%
    }}

%  Define environments that ignore their contents.
\excludecomment{comment}
\excludecomment{rawhtml}
\excludecomment{htmlonly}

%  Hypertext commands etc. This is a condensed version of the html.sty
%  file supplied with LaTeX2HTML by: Nikos Drakos <nikos@cbl.leeds.ac.uk> &
%  Jelle van Zeijl <jvzeijl@isou17.estec.esa.nl>. The LaTeX2HTML documentation
%  should be consulted about all commands (and the environments defined above)
%  except \xref and \xlabel which are Starlink specific.

\newcommand{\htmladdnormallinkfoot}[2]{#1\footnote{#2}}
\newcommand{\htmladdnormallink}[2]{#1}
\newcommand{\htmladdimg}[1]{}
\newcommand{\hyperref}[4]{#2\ref{#4}#3}
\newcommand{\htmlref}[2]{#1}
\newcommand{\htmlimage}[1]{}
\newcommand{\htmladdtonavigation}[1]{}

\newenvironment{latexonly}{}{}
\newcommand{\latex}[1]{#1}
\newcommand{\html}[1]{}
\newcommand{\latexhtml}[2]{#1}
\newcommand{\HTMLcode}[2][]{}

%  Starlink cross-references and labels.
\newcommand{\xref}[3]{#1}
\newcommand{\xlabel}[1]{}

%  LaTeX2HTML symbol.
\newcommand{\latextohtml}{\LaTeX2\texttt{HTML}}

%  Define command to re-centre underscore for Latex and leave as normal
%  for HTML (severe problems with \_ in tabbing environments and \_\_
%  generally otherwise).
\renewcommand{\_}{\texttt{\symbol{95}}}

% -----------------------------------------------------------------------------
%  Debugging.
%  =========
%  Remove % on the following to debug links in the HTML version using Latex.

% \newcommand{\hotlink}[2]{\fbox{\begin{tabular}[t]{@{}c@{}}#1\\\hline{\footnotesize #2}\end{tabular}}}
% \renewcommand{\htmladdnormallinkfoot}[2]{\hotlink{#1}{#2}}
% \renewcommand{\htmladdnormallink}[2]{\hotlink{#1}{#2}}
% \renewcommand{\hyperref}[4]{\hotlink{#1}{\S\ref{#4}}}
% \renewcommand{\htmlref}[2]{\hotlink{#1}{\S\ref{#2}}}
% \renewcommand{\xref}[3]{\hotlink{#1}{#2 -- #3}}
%end{latexonly}
% -----------------------------------------------------------------------------
% ? Document specific \newcommand or \newenvironment commands.
% ? End of document specific commands
% -----------------------------------------------------------------------------
%  Title Page.
%  ===========
\renewcommand{\thepage}{\roman{page}}
\begin{document}
\thispagestyle{empty}

%  Latex document header.
%  ======================
\begin{latexonly}
   CCLRC / \textsc{Rutherford Appleton Laboratory} \hfill \textbf{\stardocname}\\
   {\large Particle Physics \& Astronomy Research Council}\\
   {\large Starlink Project\\}
   {\large \stardoccategory\ \stardocnumber}
   \begin{flushright}
   \stardocauthors\\
   \stardocdate
   \end{flushright}
   \vspace{-4mm}
   \rule{\textwidth}{0.5mm}
   \vspace{5mm}
   \begin{center}
   {\Large\textbf{\stardoctitle}}
   \end{center}
   \vspace{5mm}

% ? Heading for abstract if used.
   \vspace{10mm}
   \begin{center}
      {\Large\textbf{Abstract}}
   \end{center}
% ? End of heading for abstract.
\end{latexonly}

%  HTML documentation header.
%  ==========================
\begin{htmlonly}
   \xlabel{}
   \begin{rawhtml} <H1> \end{rawhtml}
      \stardoctitle
   \begin{rawhtml} </H1> <HR> \end{rawhtml}

   \begin{rawhtml} <P> <I> \end{rawhtml}
   \stardoccategory\ \stardocnumber \\
   \stardocauthors \\
   \stardocdate
   \begin{rawhtml} </I> </P> <H3> \end{rawhtml}
      \htmladdnormallink{CCLRC / Rutherford Appleton Laboratory}
                        {http://www.cclrc.ac.uk} \\
      \htmladdnormallink{Particle Physics \& Astronomy Research Council}
                        {http://www.pparc.ac.uk} \\
   \begin{rawhtml} </H3> <H2> \end{rawhtml}
      \htmladdnormallink{Starlink Project}{http://www.starlink.rl.ac.uk/}
   \begin{rawhtml} </H2> \end{rawhtml}
   \htmladdnormallink{\htmladdimg{source.gif} Retrieve hardcopy}
      {http://www.starlink.rl.ac.uk/cgi-bin/hcserver?\stardocsource}\\

%  HTML document table of contents. 
%  ================================
%  Add table of contents header and a navigation button to return to this 
%  point in the document (this should always go before the abstract \section). 
  \label{stardoccontents}
  \begin{rawhtml} 
    <HR>
    <H2>Contents</H2>
  \end{rawhtml}
  \htmladdtonavigation{\htmlref{\htmladdimg{contents_motif.gif}}
        {stardoccontents}}

% ? New section for abstract if used.
  \section{\xlabel{abstract}Abstract}
% ? End of new section for abstract

\end{htmlonly}

% -----------------------------------------------------------------------------
% ? Document Abstract. (if used)
%  ==================
\stardocabstract
% ? End of document abstract
% -----------------------------------------------------------------------------
% ? Latex document Table of Contents (if used).
%  ===========================================
  \newpage
  \begin{latexonly}
    \setlength{\parskip}{0mm}
    \tableofcontents
    \setlength{\parskip}{\medskipamount}
    \markboth{\stardocname}{\stardocname}
  \end{latexonly}
% ? End of Latex document table of contents
% -----------------------------------------------------------------------------
\cleardoublepage
\renewcommand{\thepage}{\arabic{page}}
\setcounter{page}{1}

% ? Main text

% Private macro definitions.

\newcommand{\xroutine}[1]{{\tt #1}}
\newcommand{\cc}[1]{{\tt #1}}
\newenvironment{squote}{\begin{quote}\begin{small}}{\end{small}\end{quote}}

\section{Introduction}

The Extreme Dataset project is intended to allow processing of ``unusually''
large data sets by Starlink software, 
although the sizes for which special measures
are required will become less and less unusual as time goes on.
The principal underlying problem is that as images get larger
32 bits are no longer enough to index into an image.
The largest integer that can be stored in 32 bits 
is approximately $4 \times 10^9$ (unsigned) or $2 \times 10^9$ (signed).
If the operating system itself uses unsigned 32 bit pointers to 
address bytes
in memory, this means that it is impossible to map an image of more
than 4Gbyte or, say, two images of half that size. 
This could correspond to, for instance, an input and an output image
simultaneously mapped each with an HDS type of \_DOUBLE and 
size of 16k pixels square.

For this sort of work therefore an operating system with 64-bit 
pointers is required.

For the systems supported by
Starlink this currently means that Compaq Tru64 Unix can be used,
as can Solaris running in 64-bit mode.  
On appropriate hardware the Solaris kernel 
may be compiled for 32 bit or 64 bit mode;
but almost\footnote{
   There can be trouble with applications which use 
   {\tt libkvm} or access {\tt /proc}.}
all binaries which run on the 32-bit version
will also run on the 64-bit version, 
so that reconfiguring a system from 32-bit to 64-bit should be
fairly painless from a software point of view.
You can tell if your Solaris kernel is 64-bit 
by using the {\tt isainfo -v} command; on a 64-bit system the
following response will be given
\begin{squote}
\begin{verbatim}
% isainfo -v
64-bit sparcv9 applications
32-bit sparc applications
\end{verbatim}
\end{squote}

User code will also run up against these problems.
It is often necessary to count the pixels, or the bytes,
in an image, and this is typically done using a Fortran INTEGER
or a C \cc{int}.  These are normally signed 32-bit values, with
a maximum value of about $2 \times 10^9$; the pixel count of a 
47k $\times$ 47k image, or the byte count of a 16k $\times$ 16k 
\_DOUBLE image, will overflow this limit.

Another common requirement is holding a pointer 
to allocated memory, which has ultimately been 
acquired from a C routine such as \cc{malloc}, 
in a variable.
In C this will be taken care of automatically because the compiler
will ensure that a pointer type is long enough to hold memory addresses.
In Fortran however there is no pointer type so that INTEGERs, which are
normally 32 bits, have to be used.
The solution to this, explained in \xref{SUN/209}{sun209}{pointers},
is to use the \xref{CNF\_PVAL}{sun209}{CNF\_PVAL} function.

This package provides some tools and instructions for 
software maintainers to use 
in modifying their source code to work in a 64-bit environment.

The issues addressed in this document apply to user programs which link
against Starlink libraries as well as to the code which forms the USSC;
if the USSC has been built for a 64-bit system, then user code 
which uses its libraries will need to be modified at the 
source level in order to work.
Depending on the complexity of the code, it may be easier to do this
with a few manual adjustments than by using the automatic 
tools supplied with the EXTREME package.  
The discussion here should be of use in any case.


\section{Changeover to 64-bit systems}

All of the changes discussed in this document
are intended to be backwardly compatible, 
so that packages thus modified should, eventually, 
continue to work unchanged in 32-bit environments.
However, because of the difficulties of handling the changeover of all 
Starlink packages simultaneously, conversion of a package
to work properly in 64 bits should be considered effectively as
a port to a new platform.  
When the entire USSC is properly in 64 bits it will be possible
to discontinue support of the 32-bit platforms as a separate SYSTEM
type in the {\tt mk} file, but packages built for the the new 
64-bit platforms should run properly on 32-bit systems.
Two new values of the {\tt mk}/{\tt makefile} environment variable 
SYSTEM will therefore be introduced: 
``sun4\_Solaris\_64'' and ``alpha\_OSF1\_64''.



\section{Modifications to code\label{sec:modificienda}}

Making Starlink packages able to run in 64-bit environment and 
handle appropriately large data sets requires changes to the source
code of each package.
For packages like \xref{HDS}{sun92}{}, 
which get their hands dirty with data structures on disk,
extensive changes are required.
Most packages however can hopefully be fixed by making some more-or-less
automatic changes to the source code.
These changes boil down to making sure that Fortran pointers 
can address any allocated memory,
and making sure that non-pointer integers in Fortran and C 
are large enough to hold big numbers.

Because of the difficulty of distinguishing, in any automatic fashion,
variables which may 
need to hold big numbers from those which will not,
the approach taken is to change the type of {\em all\/} 
integer variables to a 64-bit type in 64-bit environments.
This is a somewhat extravagant solution,
but the alternatives seem to be worse.
Once the increase in integer size has been made 
globally to the source code in a package,
it is possible to identify variables which do not need the extra size
and change their declarations (and other parts of the code which depend
on these) back to the normal integer types.
Such retrochanges could be appropriate in either of the following situations:
\begin{itemize}
\item
The change has broken something which is easier to fix by returning to 
a normal integer size than by other means
\item
The change results in overuse of resources, and returning to a normal
integer size will not cause too many problems.
\end{itemize}


\subsection{Pointer references in Fortran}

As explained in \xref{SUN/209}{sun209}{pointers} 
whenever the \%VAL Fortran compiler directive 
is used to pass the value of allocated
memory to a subroutine, its argument should be wrapped in a call
to \xref{CNF\_PVAL}{sun209}{CNF\_PVAL}.  This effectively allows
a 32-bit integer to address memory in a 64-bit address space.
Additionally, the header file {\tt CNF\_PAR} needs to be included
in affected source files to provide the declaration of the CNF\_PVAL 
function.
This modification is fairly unproblematic, 
since it should not under normal
circumstances affect the behaviour of the code in either 32-bit or
64-bit environments, so it's possible, and advisable, to make this
change to all code and test it before converting the normal integer types
as described in section \ref{sec:fint}.  

The main pitfall of making these modifications is
wrapping the argument of a \%VAL in a CNF\_PVAL call when it ought
not to be so wrapped.
CNF\_PVAL should {\em only\/} be applied to registered pointers.
If your fortran code uses pointers which are got from C without 
being registered with CNF, you'll need to address this in the C code 
as described in \xref{SUN/209}{sun209}{pointers}.
More commonly, you may have \%VAL invocations which are not
applied to pointers at all --- for instance when passing 
the lengths of character variables as trailing arguments 
as sometimes needs to be done when the compiler doesn't know that
it's passing a character variable.  In this case the \%VAL 
invocation should be left alone and no call to CNF\_PVAL inserted.
In general, it is impossible to spot all such non-pointer uses
of \%VAL automatically.  However, if \%VAL is applied to a constant,
or a small integer, then it should be left alone.

The program \xroutine{inscnf} is supplied for inserting CNF\_PVALs
in the right places.  It wraps {\em all\/} arguments of \%VAL 
in calls to CNF\_PVAL, but emits warnings for those which look like
they may not be pointers.  It is described further in section 
\ref{sec:tools}.


\subsection{Enlarging integer type in Fortran\label{sec:fint}}


In fortran there is no (even slightly) portable way of declaring
an integer to be of a configurable length. 
Therefore all variables currently declared as `INTEGER' 
should be changed instead to type `INTEGER*8'. 
This is not standard Fortran 77, but it is widely understood by compilers.
This should not be interpreted (by a human) as an indication that exactly
eight bytes are required, but as an indication that this needs to be
long enough to hold a large number.
At compile time, typically on 64-bit systems the code will be compiled
as it stands, while on 32-bit systems a simple {\tt sed(1)} script or similar
can preprocess the source code before it's fed to the compiler.

Having done this, the following issues need to be addressed.
\begin{description}
%
\item[External libraries]\mbox{}
\\
In Fortran, the actual arguments used in a subroutine/function
call must be of the same type as the formal arguments declared
in the routine itself, since arguments are passed by address.
Thus if you change the type of integers passed to a subroutine,
you have to change the type of the integers declared in the subroutine too.
It is therefore necessary either to convert any called subroutines
to using the new integer type (at least as far as their arguments go), 
or to ensure that any calls to these routines use variables of 
the old integer type.
Thus a package can only be successfully converted to large integers
and built once all the libraries against which it links have been 
similarly converted.  The Starlink libraries will therefore have to
be done before applications packages.
If a program uses an external library which is not part of the USSC,
then either the library will have to be converted in the same way,
or the affected calls will have to be written using 
variables specially declared as the normal INTEGER type.
%
\item[Literal integer constants as arguments]\mbox{}
\\
If there are any calls to functions or subroutines in the converted 
code which have literal integer constants as actual arguments,
these will need to be replaced with expressions of the right type.
There is no way of specifying the length of a literal integer constant
in fortran, so you should either assign a variable (perhaps assigned
using the fortran PARAMETER statement) or ensure that the expression
has the correct type by adding the special value EXT\_\_ZERO, defined
in the EXT\_PAR include file.  EXT\_\_ZERO has a numerical value of 
zero, but a large integer type, so combining it with
a literal constant promotes the value to the correct type.
Thus
\begin{squote}
\begin{verbatim}
      CALL SUB( 5, STATUS )
\end{verbatim}
\end{squote}
must be changed to something like
\begin{squote}
\begin{verbatim}
      INTEGER * 8 CONST_5
      PARAMETER( CONST_5 = 5 )
      CALL SUB( CONST_5, STATUS )
\end{verbatim}
\end{squote}
or
\begin{squote}
\begin{verbatim}
      INCLUDE 'EXT_PAR'
      CALL SUB( 5 + EXT__ZERO, STATUS )
\end{verbatim}
\end{squote}
{\it (or perhaps this is a job for PRIMDAT?)}
%
\item[Intrinsic functions]\mbox{}
\\
Calls to Fortran intrinsic functions should take care of themselves,
as long as the generic name is used rather than the specific one
(e.g. you should use ABS instead of IABS).  This is always good
practice in any case.  The only time it is not possible to do 
this is if you are passing an intrinsic function as an actual
argument to a procedure, which is pretty rare.
%
\item[I/O return values]\mbox{}
\\
A few Fortran I/O statements have specifiers which require the name
of an INTEGER variable.  In standard Fortran 77 these are 
IOSTAT in all I/O statements, and 
NUMBER, RECL and NEXTREC in the INQUIRE statement.
Particular compilers often provide a whole bunch more, but these
should hopefully not be much used in Starlink code.
So there may be a problem with a statement like
\begin{squote}
\begin{verbatim}
      CLOSE( UNIT = 99, IOSTAT = STVAL )
\end{verbatim}
\end{squote}
if the variable STVAL is now declared INTEGER*8 rather than INTEGER.
Of the supported systems, Tru64 and Solaris seem to handle 
INTEGER*8 variables used for this purpose without complaint,
while Linux/g77 fails to compile.
%
\item[Storage association]\mbox{}
\\
The Fortran 77 standard states that an INTEGER takes the same number of
storage units as a REAL.  Converting all INTEGERs to INTEGER*8s will
probably have the effect that this is no longer the case.
Thus code which relies on this, for instance by using COMMON blocks or
EQUIVALENCE statements to address the same memory as both INTEGER and REAL,
will break.  
Such practices are, as you might expect, deprecated by the 
\xref{Starlink Application Programming Standard}{sgp16}{},
but there may be instances of them lurking about.
%
\end{description}

The program \xroutine{frepint} is provided for changing 
INTEGER declarations to INTEGER*8.
It is described in section \ref{sec:tools}.


\subsection{Enlarging integer type in C}

All references to the type \cc{int} in C code should be changed to 
\cc{INT\_BIG}.  This is a reference to a macro which can be defined
in a header file or on the compiler command line 
(and hence typically in the CFLAG {\tt mk} environment variable).  
For a 32-bit build it would normally be defined at build time as 
\cc{int} and for a 64-bit build as \cc{long}.
As well as declarations of variables and functions, this applies
to casts and arguments of \cc{sizeof} too (in fact any 
syntactically significant occurrence of the identifier `\cc{int}').
References to the types \cc{short~int} and \cc{long~int},
which are just synonyms for \cc{short} and \cc{long} respectively,
should not be changed.  Type \cc{unsigned INT\_BIG} 
(or, redundantly, \cc{signed INT\_BIG}) may be used.

As regards calling functions from external libraries,
the approach described in the previous section of 
recoding all the functions in the library will of course work in C too.
However, this is not always necessary.
If a function's declaration (prototype) is in scope when it is called,
the compiler will convert each actual argument to the declared type of
the corresponding formal argument in the prototype 
before passing it by value.
Thus the following code
\begin{squote}
\begin{verbatim}
int add( int a, int b );
INT_BIG i, j;
add( i, j );
\end{verbatim}
\end{squote}
is correct whatever type \cc{INT\_BIG} is defined as, 
since \cc{i} and \cc{j} are converted to type \cc{int}
before \cc{add()} sees them.
If the prototype of \cc{add()} were not in scope however,
the conversion would not take place and the code would be
in error.\footnote{
   In fact, the standard says simply that the effect of the call is
   undefined in this case.  Furthermore, it seems that the three
   currently supported systems handle these cases without
   any undesirable behaviour; presumably the compilers are written
   such that all arguments are passed in 64 bits or in registers.
   But such code is still not correct.
}
The lesson is to make sure that header files are
included.

However this does not solve all problems.
Where a function has a variable argument list
(as declared in the prototype using ellipsis `\cc{...}'
and handled in the function using the {\tt stdarg.h} macros), 
the function prototype
is not able to specify the types of all arguments,
and so the type of the actual argument must match the type of
the formal argument for correctness.  If it is impractical
to recode the function (as in the case of \cc{printf}),
the best solution is to cast the variable arguments to the type
which is expected where the function is called.

A more difficult problem is when the address of an argument is
passed so that the contents of that address can be changed by
the function.  In this case if the called function has a
different idea of the length of the object being pointed to
it will write to the wrong amount of memory, possibly overwriting
other data.  Consider this function:
\begin{squote}
\begin{verbatim}
   void zero( int *a ) { *a = 0; }
\end{verbatim}
\end{squote}
and this code:
\begin{squote}
\begin{verbatim}
   INT_BIG x;
   zero( &x );
\end{verbatim}
\end{squote}
If \cc{INT\_BIG} is a 64 bit type and \cc{int} is 32 bits
then only half the bits in the variable \cc{x} will be zeroed by this call.
If the function declaration is in the same file as the call,
the compiler will (hopefully) issue a warning about this sort of thing; 
again, make sure that the appropriate header files are included.
Again, in the case of variable argument lists, the compiler can't spot it.

To summarise, external functions should be declared before use by
including the appropriate header files.  If this is done, then the only
problems associated with calling functions which have not been
converted to use \cc{INT\_BIG} instead of \cc{int} should be:
\begin{description}
\item[INT\_BIG in variable part of argument list:]
A modified caller of an unmodified function should explicitly cast
an \cc{INT\_BIG} argument in the variable (\cc{...}) part of the argument
list.  
Normally the cast should be to \cc{int}, but it may possible,
as with \cc{printf}, to cast to \cc{long} and indicate to the called
function that this has been done).
A modified function which will may get called by unmodified code
should expect arguments of type \cc{int}
(i.e.\ should call the \cc{va\_arg} macro with a second argument
of \cc{int} instead of \cc{INT\_BIG}).
%
\item[Pointer to INT\_BIG variable passed:]
A modified caller of an unmodified function will have to declare
a local variable of type \cc{int} and exchange values between it
and the \cc{INT\_BIG} before, and possibly after, the call.
A modified function which may get called by unmodified code 
will have to declare pointer arguments as pointers to a given fixed
type (presumably \cc{int}), not to \cc{INT\_BIG}.
\item[Overflow:]
If an \cc{INT\_BIG} value which is too large to be an \cc{int}
is passed to a variable which is an \cc{int}, arithmetic overflow will
occur when C tries to do the type conversion according to the function
declaration.
No warning is issued by the Solaris or Tru64 C runtime systems about
such overflows.
\end{description}
Examples of these modifications in action are given in the discussion of 
\cc{printf} and \cc{scanf} below.


External libraries which code may have to link against
can be split into a few categories:
\begin{description}
%
\item[Starlink libraries]\mbox{}
\\
As with Fortran, the plan is for Starlink libraries to get converted
to use \cc{INT\_BIG}
before code which uses them (although for C code calling C libraries
this is not so necessary as with Fortran when functions are pre-declared
using header files).
%
\item[Blocks of source code not to be converted:]\mbox{}
\\
It is probably not a good idea to do \cc{INT\_BIG} conversion to
large bodies of non-Starlink code used by the USSC; Perl and Tcl
spring to mind.  
If there is function-level access to these packages,
some recoding may be required as above.
%
\item[The C standard library:]\mbox{}
\\
The functions of the C standard library are no different from any
other unconverted external library, but since their use is
common, we discuss it in detail here.
Most of the functions in the standard library will be handled
adequately as described above by including the appropriate header files,
since they do not have \cc{int~*} arguments or variable argument lists.
The exception is those which use format strings:
\cc{printf}, \cc{fprintf}, \cc{sprintf} and 
\cc{scanf}, \cc{fscanf}, \cc{sscanf}; these fall foul of both obstacles.
For \cc{printf} and friends 
any of the format specifiers \cc{cdiouxX*}\footnote{
   Inclusion of the \cc{c} format specifier here is not a mistake.
   Although the corresponding argument will typically be of type \cc{char},
   it is promoted to \cc{int} by the usual mechanism before being 
   passed to \cc{printf}.  If the type of the actual argument is
   of type \cc{char} and not type \cc{INT\_BIG} of course, no change 
   will be required here.
}
indicate that the corresponding argument should be an \cc{int},
and the \cc{n} specifier indicates a pointer to \cc{int}.
For \cc{scanf} and friends, any of the specifiers \cc{diouxXn} indicate
pointer to \cc{int}.
If any of the actual arguments in the call is of type \cc{INT\_BIG} 
(or \cc{INT\_BIG~*}) when it should be of type \cc{int} (or \cc{int~*}),
then the calling code needs to be changed.

In the case of \cc{int} arguments, if the actual argument
might be too large to be
represented in an \cc{int}, then an \cc{l} should be inserted to 
indicate that a \cc{long} argument is being supplied and the 
corresponding argument cast to \cc{long}.  If it will definitely
be possible to store the value in an \cc{int} then the format specifier
may be left alone and the argument cast to \cc{int}.
In the case of \cc{int~*} arguments, intermediate variables have to be used.
Here is an example.  If after simple substitution of \cc{INT\_BIG} for
\cc{int} a piece of code reads:
\begin{squote}
\begin{verbatim}
   extern INT_BIG quintuple( INT_BIG x );
   INT_BIG i, j;
   char c;
   scanf( "%i %c", &i, &c );
   j = quintuple( i );
   printf( "Integer quintupled is %i; Character is '%c'\n", j, c );
\end{verbatim}
\end{squote}
then the \cc{scanf} call must be replaced by something like this: 
\begin{squote}
\begin{verbatim}
   {  long tmp; 
      scanf( "%li %c", &tmp, &c ); 
      i = tmp; 
   }
\end{verbatim}
\end{squote}
and the \cc{printf} call by something like this:
\begin{squote}
\begin{verbatim}
   printf( "Integer quintupled is %li; Character is '%c'\n", (long) j, c );
\end{verbatim}
\end{squote}
%
\item[Other external libraries:]\mbox{}
\\
If your code links to any other external libraries
which cannot, or will not, be converted to use \cc{INT\_BIG}s,
some recoding of the calls may be required as above.
\end{description}


There is one other issue which arises from replacing \cc{int} type
with \cc{INT\_BIG}:
\begin{description}
%
\item[Integer limit constants]\mbox{}
\\
Where an \cc{int} is compared against one of the values 
\cc{INT\_MAX}, \cc{INT\_MIN} and \cc{UINT\_MAX} 
defined in the system header file {\tt limits.h},
an \cc{INT\_BIG} should be compared against one of the corresponding
macros \cc{INT\_BIG\_MAX} etc.
These macros are defined in the header file {\tt extreme.h}, 
which should be included {\em after\/} {\tt limits.h} in the source file.
%
\end{description}

The program \xroutine{crepint} is provided for making some of these
changes.  It replaces all references to \cc{int} type, with a few exceptions,
by \cc{INT\_BIG} type, and warns about constructs which might need further
attention.
It is described in section \ref{sec:tools}.


\subsection{Changes to makefile/mk}





\section{Tools\label{sec:tools}}

This section documents utilities distributed with this package
to modify source code for use in 64-bit environments.

Basically, one tool is provided for each of the source code conversion
tasks described in the previous section:
\begin{description}
\item[inscnf:] Inserts CNF\_PVAL calls where required in Fortran source code
\item[frepint:] Converts INTEGER to INTEGER*8 in Fortran source code
\item[crepint:] Converts \cc{int} to \cc{INT\_BIG} in C source code
\end{description}
Each of these is a normal Unix filter command such as {\tt cat}, 
so may be given zero, one or two arguments to specify its input and output.
Where no change needs to be made, the input is written with no changes 
to the output.  This means that the {\tt diff} command can be used 
to see what changes the filters make, by doing something like:
\begin{squote}
\begin{verbatim}
% inscnf file.f | diff file.f -
\end{verbatim}
\end{squote}
which might give a result like:
\begin{squote}
\begin{verbatim}
94c94
<       INTEGER STATUS             ! Global status
---
>       INTEGER * 8 STATUS         ! Global status
97,98c97,98
<       INTEGER I                  ! Loop variable
<       INTEGER INDF               ! NDF identifier
---
>       INTEGER * 8 I              ! Loop variable
>       INTEGER * 8 INDF           ! NDF identifier
\end{verbatim}
\end{squote}

Each of the filters draws attention to constructs which might need 
further attention.  It will do this either by writing a message to
standard error or by inserting a comment line in the output.
Such comment lines contain the name of the filter followed by a colon
and explanatory text, so for instance:
\begin{squote}
\begin{verbatim}
% crepint file.c | grep crepint:
/* crepint: Format string contains %[cdiouxX*]                           */
\end{verbatim}
\end{squote}
If the filter thinks it has lost track of the source code in a dangerous
way, i.e.\ that it might be making changes which are likely to invalidate
the code, it may exit with an error status, and print a message to standard
error to that effect.

Each of the filters has a go at retaining the aesthetic 
qualities of the code; an attempt is made to respect 
case usage and spacing conventions in Fortran, 
padding whitespace is shuffled to keep things at the same column as
before if possible, and so on.
If replacement text is of a different length to the original
then Fortran lines are broken in hopefully reasonable places,
but no line breaks in existing lines are introduced in C.

In addition, for each of the filters, a driver script is provided. 
For converting large numbers of files, this is likely to be the 
most convenient way to proceed.  Basically the driver scripts simply
run the filters on a given set of files, summarise the output, and
write the files which need changes in a given place.
They also perform some crude safety checks that the modified source
files seem to have been changed in the right way (for instance, that
no changes have been made except for the ones which should have been
made, and that changes to Fortran code do not result in lines longer
than 72 characters).  
These checks do not nearly such careful parsing
of the source code that the conversion filters themselves do, so
they can throw up false positives or false negatives, but they give 
an extra level of confidence.

The driver script for \xroutine{inscnf} is called {\tt do\_inscnf}
and is invoked with the files to be converted as command line arguments.
For each of its command line arguments it runs \xroutine{inscnf} and
\begin{itemize}
\item Writes a line to a log file {\tt ./inscnf.log} 
      saying how many lines were changed
\item If and only if some changes were made, it writes the modified copy
      of the file into a directory called {\tt ./inscnf.changed}
\item If the filter or the driver script thinks there might be something 
      which needs human attention, it writes a suitable message to standard
      output.  These warning messages can be understood in conjunction 
      with the documentation of the filter, or of the corresponding 
      text in section \ref{sec:modificienda}.
\end{itemize}
Finally it writes a short summary of the run.
An excerpt of its output might look like this:
\begin{squote}
\begin{verbatim}
% do_inscnf *.f *.gen
***  astimp.f:            inscnf: Last arg %VAL in FTS1_GKEYD       ***
***  import.f:            inscnf: Integer %VAL arg in CCD1_IMFIT?   ***
***  import.f:            inscnf: Last arg %VAL in CCD1_IMFIT       ***
  ...
71/483 modified files written in ./inscnf.changed
Logfile is ./inscnf.log
\end{verbatim}
\end{squote}

The other driver scripts, {\tt do\_crepint} and {\tt do\_frepint},
differ in the form of their output somewhat but otherwise work the
same way as {\tt do\_inscnf}.

Detailed descriptions of the behaviour of the filter programs is
given in section \ref{sec:filters}

\section{Filter utility descriptions\label{sec:filters}}

\subsection{inscnf}
\subsection{frepint}
\subsection{crepint}






% ? End of main text
\end{document}

% $Id$
