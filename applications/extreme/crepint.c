/*
*+
*  Name:
*     crepint
*
*  Purpose:
*     Replace int declarations by INT_BIG declarations in C source code.
*
*  Usage:
*     crepint [ in [ out ] ]
*
*  Description:
*     This program is a filter which takes C source code and replaces 
*     any occurrences of the type specifier `int' by the value
*     `INT_BIG'.  This should then be assigned a preprocessor value 
*     at compile time using a -DINT_BIG=int or -DINT_BIG=long flag on
*     the C compiler.
*
*     It's not quite as simple as replacing every occurrence; `short int'
*     and `long int' type specifiers will be left alone.
*
*  Authors:
*     MBT: Mark Taylor (STARLINK)
*
*  History:
*     25-JAN-2000 (MBT):
*        Initial version.
*-
*/


#include "ygen.h"
#include "ctokens.h"

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>

/* Local function prototypes. */
   void crepint();

   int main( int argc, char **argv ) {
/*
*+
*  Name:
*     main
*
*  Purpose:
*     Main routine of C program.
*
*  Description:
*     Invoke the appropriate filter function.
*-
*/

/* Declare variables. */
      extern char *name;

/* Set up standard input and output correctly for a filter. */
      name = filter( argc, argv );

/* Filter input to output. */
      crepint();

/* Finish. */
      return 0;
   }



   struct tokitem {
      char *string;
      char *strmat;
      char *interp;
      int tokval;
   };


   int tokmatch( struct tokitem *tok, ... ) {
      va_list ap;
      int mtok;

      va_start( ap, tok );
      while ( mtok = va_arg( ap, int ) ) {
         if ( mtok != (tok++)->tokval ) {
            va_end( ap );
            return 0;
         }
      }
      va_end( ap );
      return 1;
   }

   struct tokitem *nextarg( struct tokitem *ptok ) {
      int blev = 0;
      int plev = 0;
      int slev = 0;
      int t;
      int trouble;
      while( t = (++ptok)->tokval ) {
         trouble = 0;
         switch ( t ) {
            case '(': 
               ++plev; 
               break;
            case ')': 
               trouble = ( --plev < 0 );
               break;
            case '{': 
               ++blev; 
               break;
            case '}': 
               trouble = ( --blev < 0 ); 
               break;
            case '[': 
               ++slev; 
               break;
            case ']': 
               trouble = ( --slev < 0 ); 
               break;
            case ',':
               if ( plev == 0 && blev == 0 && slev == 0 ) return ++ptok;
               break;
         }
         if ( trouble ) {
            while ( (++ptok)->tokval );
            return( ptok );
         }
      }
      return ptok;
   }


   void subst( struct tokitem *ptok, char *replace ) {
      char *put;
      put = ptok->strmat;
      while ( *put && *replace ) *(put++) = *(replace++);
      if ( *put ) {
         while ( *put ) *(put++) = ' ';
      }
      else if ( *replace ) {
         ptok->interp = memok( malloc( strlen( replace ) + 1 ) );
         strcpy( ptok->interp, replace );
      }
   }


   void crepint() { 
/*
*+
*  Name:
*     crepint
*
*  Purpose:
*     Perform data processing for crepint program.
*
*  Invocation:
*     crepint();
*
*  Description:
*     This routine reads characters from standard input and writes them to
*     standard output.  The output is as similar as possible to the input
*     except that (most) occurrences of the type specifier token `int' 
*     are replaced by a new string.
*
*     Tokenising the input stream is done using code generated by lex.
*-
*/

/* Declare local variables. */
      int arg;
      int i;
      int incomm;
      int leng = 0;
      int skipspc;
      int t;
      int t1;
      int tbufsiz = 0;
      int tok;
      char c;
      char c1;
      char *string;
      char *strmat;
      char *interp;

      struct tokitem *tbuf = NULL;

/* Fill buffer of tokens with all the information we get from the lexer. */
      while ( ( tok = yylex() ) || ( yylval != NULL ) ) {
         if ( leng + 1 >= tbufsiz ) {
            tbufsiz += BUFINC;
            tbuf = memok( realloc( tbuf, tbufsiz * sizeof( struct tokitem ) ) );
         }
         tbuf[ leng ].tokval = tok;
         tbuf[ leng ].string = yylval;
         tbuf[ leng ].strmat = ymatst;
         tbuf[ leng ].interp = NULL;
         leng++;
      }

/* Go through the token buffer looking for sequences which we need to do
   something about. */
      for ( i = 0; i < leng; i++ ) {
         t = tbuf[ i ].tokval;
         t1 = tbuf[ i + 1 ].tokval;
         if ( t1 == INT && t != SHORT && t != LONG )
            subst( tbuf + i + 1, "INT_BIG" );
         if ( t == INT_MAX )
            subst( tbuf + i, "INT_BIG_MAX" );
         if ( t == INT_MIN )
            subst( tbuf + i, "INT_BIG_MIN" );
         if ( ( t == PRINTF || t == FPRINTF || t == SPRINTF ) && t1 == '(' ) {
            arg = i + 1;
            if ( t != PRINTF ) arg = nextarg( tbuf + arg ) - tbuf;
            if ( tokmatch( tbuf + arg, STRING_LITERAL, ',', 0 ) ||
                 tokmatch( tbuf + arg, STRING_LITERAL, ')', 0 ) ) { 
            }
            else {
            }
         }
         if ( ( t == SCANF || t == FSCANF || t == SSCANF ) && t1 == '(' ) {
            arg = i + 1;
            if ( t != SCANF ) arg = nextarg( tbuf + arg ) - tbuf;
            if ( tokmatch( tbuf + arg, STRING_LITERAL, ',', 0 ) ||
                 tokmatch( tbuf + arg, STRING_LITERAL, ')', 0 ) ) {
            }
            else {
            }
         }
      }

/* Go through token buffer outputting the characters associated with each 
   token. */
      for ( i = 0; i < leng; i++ ) {
         string = tbuf[ i ].string;
         strmat = tbuf[ i ].strmat;
         interp = tbuf[ i ].interp;
         c1 = 0;
         incomm = 0;
         while ( c = *(string++) ) {
            if ( c == ' ' && c1 == ' ' && skipspc && ! incomm ) {
               skipspc--;
            }
            else {
               putchar( c );
               if ( c == '\n' || c == '\t' ) skipspc = 0;
               if ( string < strmat ) {
                  if ( c1 == '/' && c == '*' ) incomm = 1;
                  if ( c1 == '*' && c == '/' ) incomm = 0;
               }
            }
            c1 = c;
         }
         if ( interp ) {
            while ( c = *(interp++) ) {
               putchar( c );
               skipspc = ( c == '\n' ) ? 0 : skipspc + 1;
            }
         }
      }
   }





/* $Id$ */
