/*
*+
*  Name:
*     frepint
*
*  Purpose:
*     Replace INTEGER declarations with INTEGER*8 in Fortran source.
*
*  Usage:
*     frepint [ in [ out ] ] 
*
*  Description:
*     This program is a filter which takes FORTRAN 77 source code
*     and modifies it so that INTEGER declarations are rewritten as
*     'INTEGER * 8'.  It also attempts to warn if there are usages which
*     might cause trouble given this change.  Other lines are left
*     unmodified.
*
*     Attention is paid to fortran 77 source format, so that lines are
*     more than 72 characters long are avoided (unless they were there
*     in the first place.
*
*     Some effort is made to make the output aesthetically pleasing:
*     line breaks are done, where possible, following the usage in, e.g.,
*     KAPPA.  An attempt is made copy the style of case usage and bracket 
*     spacing from the input.
*
*     The program will warn if any INTEGER*X declarations already exist
*     in the code, and will not modify these.
*
*     Note: although this program behaves as a filter, it is written on
*     the assumption that it will be run on a file of a finite length:
*     it may buffer large amounts of input before writing output, and
*     it may not free up memory.
*
*  Authors:
*     MBT: Mark Taylor (STARLINK)
*
*  History:
*     01-FEB-2000 (MBT):
*        Initial version.
*-
*/


#include <stdio.h>
#include <string.h>
#include <stddef.h>
#include <stdlib.h>
#include <ctype.h>

#include "ygen.h"
#include "ftokens.h"


/* Local function prototypes. */
   void frepint();


   int main( int argc, char **argv ) {
/*
*+
*  Name:
*     main
*
*  Purpose:
*     Main routine of C program.
*
*  Description:
*     This routine provides a monolith for the filter programs in the
*     EXTREME package.
*-
*/

/* Declare variables. */
      extern char *name;

/* Set up standard input and output correctly for a filter. */
      name = filter( argc, argv );

/* Filter input to output. */
      frepint();

/* Finish. */
      return 0;
   }


/* Structure to hold all the useful information about the tokens got from
   the lexer. */
   struct tokitem {
      char *string;
      char *strmat;
      int tokval;
   };



   void frepint() {
/*
*+
*  Name:
*     frepint
* 
*  Purpose:
*     Perform data processing for frepint program.
*
*  Invocation:
*     frepint()
*
*  Description:
*     This routine reads characters from standard input and writes them
*     to standard output.  The output is substantially similar to the
*     input except that INTEGER declarations are changed to INTEGER*8.
*
*     Tokenising the input stream is done using code generated by lex.
*-
*/

/* Local variable declarations. */
      int col;
      int done;
      int i;
      int j;
      int k;
      int leng;
      int linend;
      int nc;
      int nspc;
      int skipspc;
      int tbufsiz = 0;
      int tok;
      char c;
      char *pc;
      char *qc;
      struct tokitem *tbuf = NULL;

/* Get characters from the lex tokeniser.  As well as the token id which
   is the return value of yylex, the global yylval points to the 
   characters which constituted this token. */
      leng = 0;
      while ( ( tok = yylex() ) || ( yylval != NULL ) ) {
         if ( leng + 1 >= tbufsiz ) {
            tbufsiz += BUFINC;
            tbuf = memok( realloc( tbuf, tbufsiz * sizeof( struct tokitem ) ) );
         }
         tbuf[ leng ].tokval = tok;
         tbuf[ leng ].string = yylval;
         tbuf[ leng ].strmat = ymatst;
         leng++;
      }

/* Go through the tokens and output them.  INTEGER can only appear at the
   start of a fortran line.  */
      col = 1;
      for ( i = 0; i < leng; i++ ) {

/* Output the string in any case, keeping track of source line column. */
         for ( pc = tbuf[ i ].string; c = *pc; pc++ ) {
            putchar( c );
            switch ( c ) {
               case '\n':
                  col = 1;
                  break;
               case '\t':
                  col += 8;  /* better safe than sorry */
                  break;
               default:
                  col++;
            }
         }

/* INTEGER declaration to be changed.  Handle this token and any others 
   up till the next newline character. */
         if ( tbuf[ i ].tokval == INTEGER && tbuf[ i + 1 ].tokval != '*' ) {
            printf( " * 8" );
            skipspc = 4;
            if ( ! isspace( *(tbuf[ i + 1 ].string) ) ) {
               putchar( ' ' );
               skipspc++;
            }
            col += skipspc;
            done = 0;
            nspc = 0;
            nc = 0;
            for ( j = i + 1; ! done && j < leng; j++ ) {
               for ( pc = tbuf[ j ].string; c = *pc; pc++ ) {

/* We have found a line end (or start of inline comment).  Now see whether
   the expanded line can fit into 72 characters. */
                  if ( ( ! done ) && ( c == '\n' || c == '!' ) ) {
                     done = 1;

/* Expanded line will fit into 72 characters.  Output the intervening
   tokens, squashing up spaces to retain as much of the formatting as 
   possible if we have the chance. */
                     if ( col + nc + ( pc - tbuf[ j ].string ) 
                              - MIN( nspc, skipspc ) <= 73 ) {
                        linend = 0;
                        for ( k = i + 1; k <= j; k++ ) {
                           for ( qc = tbuf[ k ].string; c = *qc; qc++ ) {
                              if ( c == ' ' && skipspc && 
                                   qc > tbuf[ k ].string && qc[ -1 ] == ' ' ) {
                                 skipspc--;
                              }
                              else {
                                 putchar( c );
                                 switch( c ) {
                                    case '\n':
                                       col = 1;
                                       linend = 1;
                                       break;
                                    case '\t':
                                       col += 8;
                                       break;
                                    case '!':
                                       linend = 1;
                                       col++;
                                       break;
                                    default:
                                       col++;
                                }
                              }
                           }
                        }
                     }

/* Expanded line will not fit in 72 characters.  Output a linebreak right
   after the INTEGER declaration and the rest of the line unchanged after 
   it. */
                     else {
                        putchar( '\n' );
                        for ( k = 1; k < col - skipspc ; k++ )
                           putchar( k == 6 ? ':' : ' ' );
                        for ( k = i + 1; k <= j; k++ ) {
                           for ( qc = tbuf[ k ].string; c = *qc; qc++ ) {
                              putchar( c );
                              switch( c ) {
                                 case '\n':
                                    col = 1;
                                    break;
                                 case '\t':
                                    col += 8;
                                    break;
                                 default:
                                    col++;
                              }
                           }
                        }

                     }
                  }
                  nc++;
                  if ( c == ' ' && pc > tbuf[ j ].string && pc[ -1 ] == ' ' ) {
                     nspc++;
                  }
               }
            }
            if ( ! done ) {
               fprintf( stderr, "%s: Fortran parse error\n", name );
               exit( 1 );
            }
            i = j - 1;
         }

/* Any other token. */
         else {
            if ( tbuf[ i ].tokval == INTEGER && tbuf[ i + 1 ].tokval == '*' ) {
               fprintf( stderr, "%s: INTEGER*%s declaration found\n", 
                                name, tbuf[ i + 2 ].strmat );
            }
         }
      }

   }




/* $Id$ */
