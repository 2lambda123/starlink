#!/bin/csh
#+
#  Name:
#     POLSKY

#  Purpose:
#     Subtract constant sky backgrounds from 4 images

#  Language:
#     C shell

#  Description:
#     The NDF supplied for parameter IN1 is displayed on the specified 
#     graphics device (bad pixels are shown blue). The user then uses a 
#     cursor to indicate an area which is to be used to define the sky 
#     background in each image. The mean value is found (after rejection 
#     of aberrant values) within the same sub-region in each image and this 
#     value is subtracted from the corresponding image. The name of the 
#     output NDFs are derived from the input NDF names by appending the 
#     string supplied for parameter SUFFIX to them.

#  Usage:
#     POLSKY IN1 IN2 IN3 IN4 SUFFIX DEVICE

#  Parameters:
#     IN1 = NDF (Read)
#        NDF obtained with the waveplate at 0 degrees.
#     IN2 = NDF (Read)
#        NDF obtained with the waveplate at 45 degrees.
#     IN3 = NDF (Read)
#        NDF obtained with the waveplate at 22.5 degrees.
#     IN4 = NDF (Read)
#        NDF obtained with the waveplate at 67.5 degrees.
#     SUFFIX = LITERAL (Read)
#        A string to append to the end of the supplied NDF names to 
#        get the output NDF names.
#     DEVICE = DEVICE (Read)
#        Name of the graphics device to use [Current graphics device]

#  Notes:
#     - It is assumed that the four input images are aligned.
#     - This is a script and so command line parameters can be 
#     specified by position only, not by keyword.
#     - The suggested defaults for the four input NDFs are the
#     output NDFS from the previous application or script. 

#  Authors:
#     DSB: David Berry (STARLINK)
#     {enter_new_authors_here}

#  History:
#     19-NOV-1993 (DSB):
#        Original version.
#     {enter_changes_here}
#-

#  Store the name of the current command.
      set IRCCOM = "polsky"

#  Ensure IRCAMPACK and KAPPA commands are available
      alias echo 'echo >/dev/null'
      kappa
      ircampack
      unalias echo

#  Store the path of the directory containing the kappa parameter files.
      if( ${?ADAM_USER} ) then
         set PARDIR = $ADAM_USER
      else
         set PARDIR = $HOME/adam
      endif

#  Obtain the current set of values for the IRCAM global parameters.
      set GLOBPAR = `ircamset`

#  Get the 0 degree input NDF. First establish any command line value
#  as the primary value
      if( $#argv > 0 ) then
         set DEF1 = $argv[1]
      endif

#  Now establish any defined global value as the suggested default.
      set DEF2 = $GLOBPAR[1]
      if( $DEF2 == 'undefined' ) unset DEF2

#  Now set the prompt.
      set PROM = "IN1 - NDF obtained with waveplate at 0 degrees"

#  Now get the NDF. Abort if the NDF name is not defined.
      ircamndf
      if( $?NDFNAM == 0 ) exit

#  Save the NDF name. If a parameter abort was requested the NDFNAM variable
#  will be undefined and the script will consequently abort.
      set IN1 = $NDFNAM

#  Now do the same for the 45 degree input NDF. 
      if( $#argv > 1 ) then
         set DEF1 = $argv[2]
      endif
      set DEF2 = $GLOBPAR[2]
      if( $DEF2 == 'undefined' ) unset DEF2
      set PROM = "IN2 - NDF obtained with waveplate at 45 degrees"
      ircamndf
      if( $?NDFNAM == 0 ) exit
      set IN2 = $NDFNAM

#  Now do the same for the 22.5 degree input NDF. 
      if( $#argv > 2 ) then
         set DEF1 = $argv[3]
      endif
      set DEF2 = $GLOBPAR[3]
      if( $DEF2 == 'undefined' ) unset DEF2
      set PROM = "IN3 - NDF obtained with waveplate at 22.5 degrees"
      ircamndf
      if( $?NDFNAM == 0 ) exit
      set IN3 = $NDFNAM

#  Now do the same for the 67.5 degree input NDF. 
      if( $#argv > 3 ) then
         set DEF1 = $argv[4]
      endif
      set DEF2 = $GLOBPAR[4]
      if( $DEF2 == 'undefined' ) unset DEF2
      set PROM = "IN4 - NDF obtained with waveplate at 67.5 degrees"
      ircamndf
      if( $?NDFNAM == 0 ) exit
      set IN4 = $NDFNAM

#  Obtain the suffix for the output NDFs.
      if( $#argv > 4 ) then
         set DEF1 = $argv[5]
      endif
      set PROM = "SUFFIX - Suffix for output NDF names"
      ircamstr
      if( $?STRING == 0 ) exit
      set SUFFIX = $STRING

#  If a graphics device name was supplied on the command line, establish 
#  it as the current graphics device. 
      if( $#argv > 5 ) then
         gdset DEVICE=$argv[6]

#  Otherwise, get the current graphics device (if any). The grep command 
#  selects the line displayed by KAPPA:GLOBALS which describes the graphics 
#  device. The awk command selects the word following the last colon in the 
#  line. This may need to be changed if the format of the output generated by 
#  KAPPA:GLOBALS is changed.
      else
         set DEVICE = `globals | grep "graphics device" | awk '{for(f=NF;f;f--)if($f==":")print $(f+1);exit}'`

#  See if the device is undefined. If so, get a new value from the user.
         if( `echo $DEVICE | grep "undefined"` != "" || $DEVICE == "" ) then
            gdset
         endif
      endif

#  Now get the new current graphics device. 
      set DEVICE = `globals | grep "graphics device" | awk '{for(f=NF;f;f--)if($f==":")print $(f+1);exit}'`

#  Abort if no graphics device is defined.
      if( `echo $DEVICE | grep "undefined"` != "" || $DEVICE == "" ) exit

#  Clear the current graphics device
      echo "  Setting up the graphics device..."
      gdclear device=$DEVICE

#  Set up the default pallette (except that entry 2 is set to BLUE2 - used for
#  bad pixels) and grey-scale LUT.
      paldef device=$DEVICE
      palentry 2 blue2 device=$DEVICE
      lutgrey device=$DEVICE

#  Create a picture to contain the image display. 
      picdef mode=cc fraction=0.85 nooutline device=$DEVICE

#  Now display the 0 degrees image. The awk command suppressed the message
#  produced by display which describes the scaling of the image.
      echo "  Displaying $IN1 on the graphics device..."
      display $IN1 mode=percentiles percentiles=\[5,75\] badcol=2 \
              cosys=data axes pltitl="'$IN1'" device=$DEVICE | awk '{if($1!="Data")print $0}'

#  Ensure that there are no files left over from last time.
      rm IRCAMPACK_sky.sdf IRCAMPACK_log.tmp >&/dev/null

#  Now extract the region form the 0 degrees image which is to be used 
#  to determine the sky background. A text file is created holding the
#  co-ordinates of the polygon vertices selected using the cursor. The 
#  screen output generated by SEGMENT is filtered by an awk script to 
#  suppress non-essential messages (instructions relating to the use of 
#  the cursor are retained). This would be better done using conditional 
#  message filtering within the MSG_ subroutine package, but this isn't
#  yet available.
      echo " "
      echo "  In a moment, a cursor will appear on the graphics device."
      echo "  Please use it to define a polygonal region by positioning"
      echo "  it at each vertex in turn, and pressing the appropriate"
      echo "  key. The sky background will be estimated from this region."
      echo " "
      segment in1=$IN1 out=IRCAMPACK_sky mode=cursor maxpoly=1 \
              logfile=IRCAMPACK_log.tmp cosys=world accept device=$DEVICE | \
              awk -f `alias awkseg`

#  Get the mean value in the selected polygon, clipping aberrant points
#  at 3 sigma on three succesive iterations. The two lines normally 
#  displayed by stats which show the mean value before and after 
#  clipping are assigned to succesive words within the variable MEANS.
      set MEANS = `stats IRCAMPACK_sky clip="[3,3,3]" | grep mean`

#  Display the background value. This may obviously need adjusting if
#  the format of the results displayed by stats is changed. It would be 
#  better to read the value from the stats parameter file, but there is 
#  currently no way of doing this within KAPPA.
      echo " "
      echo "  Background value in ${IN1} is $MEANS[8]"

#  Now subtract the mean value from the input image. The mean value is
#  extracted from the stats parameter file.
      csub ${IN1} "@${PARDIR}/stats.mean" ${IN1}${SUFFIX}

#  Loop round each of the other input images.
      foreach IN ($IN2 $IN3 $IN4)

#  Extract the same region from the current input image. 
         segment in1=${IN} out=IRCAMPACK_sky mode=file poly1=IRCAMPACK_log.tmp \
                 cosys=world accept | awk -f `alias awkseg`

#  Get the mean value in the region, clipping aberrant points
#  at 3 sigma on three succesive iterations. The two lines normally 
#  displayed by stats which show the mean value before and after 
#  clipping are assigned to succesive words within the variable MEANS.
         set MEANS = `stats IRCAMPACK_sky clip="[3,3,3]" | grep mean`

#  Display the background value. This may obviously need adjusting if
#  the format of the results displayed by stats is changed. It would be 
#  better to read the value from the stats parameter file, but there is 
#  currently no way of doing this within KAPPA.
         echo "  Background value in ${IN} is $MEANS[8]"

#  Now subtract the mean value from the input image. The mean value is
#  extracted from the stats parameter file.
         csub ${IN} "@${PARDIR}/stats.mean" ${IN}${SUFFIX}

#  Do the next input NDF.
      end

#  Remove the temporary files.
      rm IRCAMPACK_sky.sdf IRCAMPACK_log.tmp

#  Store the new IRCAM global parameters.
      ircamset ${IN1}${SUFFIX} ${IN2}${SUFFIX} ${IN3}${SUFFIX} ${IN4}${SUFFIX} >/dev/null

#  Finish
      echo " "
      echo " "
      exit
