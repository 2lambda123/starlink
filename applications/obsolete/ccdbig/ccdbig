#!/bin/csh -f
#+
#  Name:
#     CCDBIG

#  Purpose:
#     Tests CCDPACK functionality for a variety of image sizes.

#  Language:
#     C shell

#  Description:
#     The script creates a series of test frames using CCDGENERATE. It
#     then executes various of the CCDPACK Atasks simulating a
#     reduction sequence. Intermediary results are displayed (if requested)
#     The process is repeated for increasingly large images:
#     both the size of the image in pixels and the number of objects
#     per image is changed.

#  Authors:
#     PDRAPER: Peter Draper (STARLINK)
#     MBT: Mark Taylor (STARLINK)
#     {enter_new_authors_here}

#  History:
#     4-APR-1992 (PDRAPER):
#        Original version.
#     29-JUN-1993 (PDRAPER):
#     	 Changed to include automated alignment.
#     18-JUL-1995 (PDRAPER):
#        Now references $CCDPACK_DIR instead of editting INSTALL at
#        install time.
#     22-APR-1998 (MBT):
#        Modified to deal with increasingly large image sizes.
#        Added options for cutting corners in some of the reduction.
#        Name changed to ccdbig from (ccdexercise).
#     {enter_further_changes_here}
#-
#
###################################################################
# Set up the parameters of the reduction sequences.
# These can be changed to test behaviour of the programs under
# different circumstances.

      # Do we want variances calculated and propagated (TRUE or FALSE)?
            set variance = TRUE

      # Do we want to treat ARD mask within CCDPACK (TRUE or FALSE)?  
      # (else explicitly impose mask on data using ARDMASK).
            set keepard = TRUE

      # Set list of image sizes of frames (pixels along a side)
            set image_sizes = ( 1000 2000 3000 4000 5000 6000 )

      # Set list of object densities (objects per million pixels)
            set object_densities = ( 50 )

      # Set logging interval (seconds)
            set interval = 15

      # Set filename for logging resource usage
            set timelogfile = ccdbig_time.log

# End of parameter setup.
###################################################################

      onintr EXIT
      set null = "\!"
      set abort = "\!\!"

#  Validation
      if ("$variance" != "TRUE" && "$variance" != "FALSE") then
         echo "Variable variance must be set TRUE or FALSE."
         goto EXIT
      endif
      if ("$keepard"  != "TRUE" && "$keepard"  != "FALSE") then
         echo "Variable keepard must be set TRUE or FALSE."
         goto EXIT
      endif

#  Initialize starlink environment
      source /star/etc/cshrc
      source /star/etc/login

#  Ensure CCDPACK commands are available
      ccdpack

#  Establish the current directory as ADAM_USER and clear 
#  any global values already existing 
      setenv ADAM_USER $cwd
      if ( -e ${ADAM_USER}/GLOBAL.sdf ) then
	 ccdclear accept 
      endif

#  Check CCDBIG_DIR is defined
      if ( ! $?CCDBIG_DIR ) then
         echo "Please define CCDBIG_DIR as the directory containing the"
         echo "ccdbig files."
         goto EXIT
      endif

#  Copy required files from source directory.
      if ( -e $CCDBIG_DIR/ccdbig_obj.dat )  cp $CCDBIG_DIR/ccdbig_obj.dat .
      if ( -e $CCDBIG_DIR/ccdtest_ard.dat ) cp $CCDBIG_DIR/ccdtest_ard.dat .
      if ( -e $CCDBIG_DIR/reslog )          cp $CCDBIG_DIR/reslog .
      if ( ! -x ./reslog )                  chmod +x reslog
      if ( ! -e ccdbig_obj.dat ) then
        echo "Can't find file of objects ccdbig_obj.dat - aborting"
        goto EXIT
      endif

#  Does the user want to see image display activity?
      echo -n "DISPLAY - Display device (! for none) > "
      set device = $<
      if ( "$device" == "$abort" || "$device" == "" ) then
         goto EXIT
      else
         if ( "$device" == "$null" ) then
            set device = "NONE"
         endif
      endif

#  If we're going to use a device we need KAPPA.
      if ( "$device" != "NONE" ) then
         kappa
         idset $device \\
         gdset $device \\
         gdclear \\
         paldef \\
         palentry colour=white palnum=0 \\
      endif

#  Write some startup info to the log file
      set labelfile = reslog.label
      echo                                                >>$timelogfile
      uname -a                                            >>$timelogfile
      uptime                                              >>$timelogfile
      date                                                >>$timelogfile 
      du -sk $PWD                                         >>$timelogfile
      echo                                                >>$timelogfile
      echo "Variance:  $variance"                         >>$timelogfile
      echo "Keepard:   $keepard "                         >>$timelogfile
      echo "Logging interval:   $interval"                >>$timelogfile
      echo                                                >>$timelogfile
      printf "\n%7s%7s%12s\n"   'Pixels ' Objects Command >>$timelogfile 
      echo                                                >>$timelogfile

#  Set up aliases for logging run times to a file.
      alias log_start \
         'printf "%7d%7d%12s:  " $frame_pixels $objects \!\!:1 >$labelfile'
      ./reslog -f $timelogfile -i $interval -l $labelfile  &

#  Loop over sizes of images
      foreach frame_pixels ( $image_sizes )
         @ field_pixels = ($frame_pixels * 15) / 10

#  Loop over number of objects in frame
         foreach density ( $object_densities )
            @ objects = ($field_pixels * $field_pixels * $density) / 1000000
            if ($objects < 50) set objects = 50 

#  Generate file containing objects for use by ccdgenerate:
#  First strip comments and blank lines,
#  then select fields and scale by image size.
            rm -f ccdtest_obj.dat
            sed -e'/^ *#/d' -e'/^ *$/d' ccdbig_obj.dat  \
          | awk 'NR <= '$objects' { print $1, $2*'$field_pixels', $3*'$field_pixels', $4*0.1, $5 }' \
          > ccdtest_obj.dat

#  Set up geometry of CCD.
#  This matches (and must match) the prescription used in ccdgenerate.
            set minlobias = 3
            @   maxhibias = $frame_pixels - 5 + 1
            @   lobias = ($frame_pixels * 5) / 100
            @   hibias = $frame_pixels - ( ($frame_pixels * 6) / 100 )
            if ($lobias < $minlobias) set lobias = $minlobias
            if ($hibias > $maxhibias) set hibias = $maxhibias
            @   loframe = $lobias + 1
            @   hiframe = $hibias - 1

#  Try to locate the ARD file which goes with the test. If this is 
#  not found, or if we're treating the mask external to CCDPACK,
#  then proceed without it.
            echo " "
            echo "  Setting the characteristics of the CCD device using the "
            echo "  CCDSETUP routine."
            echo " "
            if ( -e ccdtest_ard.dat && "$keepard" == "TRUE" ) then

#  Found the ARD file setup CCDPACK appropriately.
#  We use the same ARD file regardless of size.  This is probably OK.
               log_start ccdsetup
               ccdsetup \
                  genvar=$variance \
                  bounds="[1,$lobias,$hibias,$frame_pixels]" \
                  extent="[$loframe,$hiframe,1,$frame_pixels]" \
                  adc=1 \
                  rnoise=9.95 \
                  logto=both \
                  logfile=ccdtest.log \
                  preserve=true \
                  direction=x \
                  mask=ccdtest_ard.dat \
                  reset accept
#              end ccdsetup

            else

#  Do the "device" setup without an ARD file.
               ccdsetup \
                  genvar=$variance \
                  bounds="[1,$lobias,$hibias,$frame_pixels]" \
                  extent="[$loframe,$hiframe,1,$frame_pixels]" \
                  adc=1 \
                  rnoise=10.0 \
                  logto=both \
                  logfile=ccdtest.log \
                  preserve=true \
                  direction=x \
                  reset accept
#              end ccdsetup
            endif

#  Try to locate the file containing the long list of objects.
#  If this does not exist then exit.
            if ( ! -e ccdbig_obj.dat ) then
               echo "Can't find file ccdbig_obj.dat of objects"
               goto EXIT
            endif

#  Create the test frames.
#  They are displaced from each other to give an overlap of about one quarter.
            echo " "
            echo "  Creating the test data. "
            echo " "
            echo "  The test data consists of :-"
            echo "     2 bias frames    "
            echo "     2 flatfields     "
            echo "     2 object fields. "
            echo " "
            echo "  The target data is a simulated starfield in which the"
            echo "  telescope position has been moved between exposures."
            echo " "
            @ x1lo = 1
            @ x2lo = 1 + ($frame_pixels * 50) / 100
            @ y1lo = 1
            @ y2lo = 1 + ($frame_pixels * 50) / 100
            @ x1hi = $x1lo + $frame_pixels - 1
            @ x2hi = $x2lo + $frame_pixels - 1
            @ y1hi = $y1lo + $frame_pixels - 1
            @ y2hi = $y2lo + $frame_pixels - 1
            log_start ccdgenerate
            ccdgenerate \
               nseq=2 \
               ubnds="[$x1hi,$y1hi,$x2hi,$y2hi]" \
               lbnds="[$x1lo,$y1lo,$x2lo,$y2lo]" \
     	       file=ccdtest_obj.dat \
     	       accept
#           end ccdgenerate

#  If display capability is enabled then display one DATA frame.
            if ( "$device" != "NONE" ) then
               echo " "
               echo "  Displaying one raw target frame."
               echo " "
               lutheat \
                  accept
#              end lutheat
               log_start display
               display \
                  in=data1 \
                  mode=percentiles \
                  percentiles='[2,98]' \
                  accept
#              end display
            endif
 
#  Add note to logfile.
            echo " "
            echo "  Adding a note to the logfile. "
            echo " "
            set name = `who am i`
            ccdnote \
               '"'$name : exercising CCDPACK \
                  with $objects objects \
                  in $frame_pixels \* $frame_pixels frames'"' \
               accept
#           end ccdnote
 
#  Make a BIAS frame.
            echo " "
            echo "  Producing a master bias calibration frame. This is produced"
            echo "  by median stacking the ordinary bias frames. This process"
            echo "  reduces the noise introduced in debiassing."
            echo " "
            log_start makebias
            makebias \
               in='bias*' \
               out=master_bias \
               preserve=true \
               genvar=$variance \
               accept
#           end makebias

#  Apply masking directly to the frames if we're not using the ARD file
#  implicitly
            if ( "$keepard" == "FALSE" ) then
               echo
               echo "  Use ARDMASK to apply ARD file directly to bias frame."
               echo
               log_start ardmask
               ardmask  \
                  in=master_bias \
                  out=masked_bias \
                  ardfile=ccdtest_ard.dat 
#              end ardmask
               mv masked_bias.sdf master_bias.sdf
            endif

#  DEBIAS all frames (including flatfields)
            log_start debias
            debias \
               in='"data?,ff?"' \
               out='debias_*' \
               getmask=$keepard \
               genvar=$variance \
               accept
#           end debias

#  Display all the debiassed frames.
           if ( "$device" != "NONE" ) then
              echo " "
              echo "  Displaying debiassed target frame. Note the absence of"
              echo "  the bias strips (which were along the Y edges) and the"
              echo "  removal of defective regions. The flatfields have also"
              echo "  been debiassed but are not displayed."
              echo " "
              gdclear \\
              log_start display
              display \
                 in=debias_data1 \
                 mode=percentiles \
                 percentiles='[2,98]' \
                 accept
#             end display
           endif

#  Create a flat field master
           echo " "
           echo "   Producing a master flatfield. This frame will be used to"
           echo "   correct for the sensitivity variations in the detector"
           echo "   response and any variations in the optical throughput" 
           echo "   (vignetting).  As in the creation of the master bias"
           echo "   frame median stacking is used to combine a series of"
           echo "   flatfields."
           echo " "
           log_start makeflat
           makeflat \
              in='debias_ff?' \
              out=master_flat \
              accept
#          end makeflat

#  Display the master flatfield.
           if ( "$device" != "NONE" ) then 
              echo " "
              echo "  Displaying master flatfield (the flatfield used in this"
              echo "  case is a ramp, normal flatfields are not like this). "
              echo " "
              gdclear \\
              log_start display
              display \
                 in=master_flat \
                 mode=percentiles \
                 percentiles='[2,98]' \
                 accept
#             end display
           endif

#  Flatfield all the DATA frames
           echo " "
           echo "  Flatfielding all the target frames."
           echo " "
           log_start flatcor
           flatcor \
              in='debias_data?' \
              out='*|debias|reduced|' \
              accept
#          end flatcor
           if ( "$device" != "NONE" ) then
              echo " "
              echo "  Displaying one flatfielded target frame."
              echo " "
              gdclear \\
              lutheat \
                 accept
#             end lutheat
              log_start display
              display \
                 in=reduced_data1 \
                 mode=percentiles \
                 percentiles='[2,98]' \
                 accept
#             end display
           endif

#  Now proceed to test out some alignment functionality.
           echo " "
           echo "  CCDPACK will now attempt to realign the target frames to"
           echo "  produce a complete mosaic of whole of the target region."
           echo " "

#  Locate all the objects on the frames
           echo " " 
           echo "  The first stage of the automated registration process is"
           echo "  to detect the positions of objects (stars and galaxies)."
           echo "  "
           log_start findobj
           findobj \
              in='reduced_data?' \
              outlist='*.find' \
              percentile=95 \
              binfrac=0 \
              accept
#          end findobj
           if ( "$device" != "NONE" ) then

#  Display the objects located.
              echo " "
              echo "  Displaying the positions of the object which have been"
              echo "  detected."
              echo " "
              log_start plotlist
              plotlist \
                 inlist='reduced_data1' \
                 palnum=4 \
                 mtype=23 \
                 accept
#             end plotlist
           endif
     	
#  Determine matches between the positions.
           echo " "
           echo "  After locating the objects it is now necessary to determine"
           echo "  which objects correspond."
           echo " "
           log_start findoff
           findoff \
              inlist='reduced_data?' \
              ndfnames=true \
              outlist='*.off' \
              accept
#          end findoff
           if ( "$device" != "NONE" ) then

#  Display the objects located.
              echo " "
              echo "  Displaying the labels of objects which have been matched."
              echo " "
              log_start plotlist
              plotlist \
                 inlist='reduced_data1' \
                 palnum=3 \
                 mtype=-1 \
                 thick=2 \
                 msize=1.5 \
                 accept
#             end plotlist
           endif

#  Set the registration structures.
           echo " "
           echo "  Now that the object-object correspondence is known it is"
           echo "  possible to work out the inter-NDF transformations."
           echo "  The next routine does this for a range of different"
           echo "  transformation types. It also writes the information into"
           echo "  the NDFs so that other routines may use it."
           echo " "
           log_start register
           register \
              inlist='reduced_data?' \
              fittype=1 \
              accept
#          end register

#  Resample the data.
           echo " "
           echo "  The reduced NDFs will now be resampled to the same coordinate"
           echo "  system. After this is performed they can then be combined"
           echo "  (after determining normalising scale and zero points which "
           echo "  take into account any variations in sky transparency and "
           echo "  exposure time) into a single frame which shows the complete"
           echo "  data coverage for the target area."
           echo " "
           log_start tranndf
           tranndf \
              in='reduced_data?' \
              out='*|reduced|resamp|' \
              accept
#          end tranndf

#  Normalise it.
           echo " "
           echo "  Normalising the aligned datasets."
           echo " "
           log_start makemosnorm
           makemos \
              in='resamp_data?' \
              scale=true \
              zero=true \
              modify=true \
              out=\! \
              accept

#  Combine to produce a mosaic.
           echo " "
           echo "  Combining the aligned datasets."
           echo " "
           log_start makmoscomb
           makemos \
              in='resamp_data?' \
              scale=false \
              zero=false \
              out=mosaic \
              accept
#          end makemos

#  Display the final mosaic.
           if ( "$device" != "NONE" ) then 
              echo " "
              echo "  Displaying the final mosaic."
              echo " "
              gdclear \\
              log_start display
              display \
                 in=mosaic \
                 mode=percentiles \
                 percentiles='[2,98]' \
                 accept
#             end display
           endif

#  Exercise is completed.
           ccdnote \
              '"Exercise completed"' \
              accept
#          end ccdnote

        end        # density loop

     end           # frame_pixels loop

     log_start "done"

#  Exit label
     EXIT:
     exit
# @(#)ccdexercise	2.6     12/5/96     2
