#!/bin/csh -f

#+
#  Name:
#     RESLOG

#  Purpose:
#     Enables logging of resource (time + memory usage) of large processes
#     run from it's parent shell (e.g. a shell script)

#  Language:
#     C shell

#  Description:
#     The script spends most of its time sleeping, but at intervals wakes
#     up and takes a look at what processes are running.  It takes note
#     of the largest (biggest memory usage) and records the current 
#     CPU and elapsed time values, and the maximum so far total virtual
#     memory use and resident set size (i.e. real memory use).
#     Every time the contents of a given external label file are changed
#     (presumably by the parent process) it writes the contents of the 
#     label file, plus a summary of the resource usage since last time 
#     the label file was changed to a log file.
#     The only communication between the parent and this process, 
#     after it is started, is via the label file.
#
#     Accuracy of the summary will necessarily depend on the lenght of
#     the intervals during which the script sleeps.  In particular 
#     it cannot be expected to report accurately on processes whose
#     elapsed time is comparable with the interval time, and may 
#     miss reporting on these altogether.
#
#     If this process receives an interrupt, or if it detects that its
#     parent no longer exists, this process will terminate.

#  Implementation status:
#     Determining resource usage is inherently a highly system-dependent
#     task, and the script cannot be expected to be portable to 
#     arbitrary platforms.  In particular the 'ps' command, which has
#     to be used heavily, exists in two very differnt forms, one 
#     descending from BSD and one from Sytem V Unix.
#     The script as it stands appears to run on the following systems:
#        Red Hat Linux 5.0
#        Solaris (SunOS 5.6)
#     however it's likely to be sensitive to details of the systems it's
#     running on.  There may also be problems, for instance, if (e.g. 
#     for a process with very large memory usage) the columns from ps 
#     run into each other.

#  Parameters:
#     If invoked with a command-line argument, it will take it as the
#     name of the log file to write to.  Otherwise it will use a default
#     file name (reslog.log).

#  Authors:
#     MBT: Mark Taylor (STARLINK)
#     {enter_new_authors_here}

#  History:
#     15-MAY-1998 (MBT):
#        Original version.
#     {enter_further_changes_here}
#-
#


# Set up variables
set logfile = test.log
if ("$1" != "") set logfile = "$1"
set labelfile = ./current_label
set tmpfile = ./tmpfile
set interval = 10

# Print out header
set  format = "%29s %10d %10d %10d %10d  %s\n"
set hformat = "%29s %10s %10s %10s %10s\n"
printf "$hformat" " " "Elapsed(s)" "CPU(s)" "RSS(k)" "Size(k)" >>$logfile

# Classify operating system 
# (currently works for Red Hat Linux, Solaris, Digital Unix) 
if ("`uname`" == "Linux") then
   set pstype = 'BSD'
else
   set pstype = 'SYSV'
endif


# Set up alias for pulling fields out of 'ps' output
alias getfield awk "'\\
   NR==1 {for (i=1;i<=NF;i++) {if("\$"i==field) f_i=i; if("\$"i==sortby) s_i=i;}} \\
   NR==2 {out = "\$"f_i; s_max="\$"s_i} \\
   NR>2 && s_i>0 {if ("\$"s_i > s_max) out="\$"f_i;} \\
   END {print out}'"

# Set up alias for converting from hh:mm:ss to seconds
alias tosec awk -F: "'\\
   {mult=1; for (i=NF;i>0;i--) {sec += "\$"i * mult; mult *= 60} print sec }'"

# Some initialisation
set size_max = 0
set rss_max = 0
set label = ""
rm -f $labelfile
onintr SIGNAL

# Work out parent's PID
if ("$pstype" == "BSD") then
   set pscmd = "ps l $$"
else 
   set pscmd = "ps -lp $$"
endif
set ppid = `$pscmd | getfield field=PPID`
if ("$ppid" == "") then
   set name = $0
   echo "${name:t}:  No parent process - aborting"
   goto EXIT
endif
if ("$pstype" == "BSD") then
   set parent_pscmd = "ps $ppid"
else
   set parent_pscmd = "ps -p $ppid"
endif

while (`$parent_pscmd | getfield field=PID`) 
   # See what is the currently active application
   set label_last = "$label"
   if (-e $labelfile) set label = "`cat $labelfile`"

   if ("$label_last" != "" && "$label" != "$label_last" && $?elapsed_major) then
   # Application has changed since we last looked.  
   # Write summary to log and reset values.
      printf >> $logfile "$format" \
        "$label_last" \
        "$elapsed_major" "$cpu_major" "$rss_max" "$size_max" 
      set rss_max = 0
      set size_max = 0
   endif

   # Find the process we're interested in.
   # We do this (somewhat haphazardly) by checking the processes which have
   # the same parent as this one, and then selecting the one with the 
   # largest (total virtual) memory size.
   if ("$pstype" == "BSD") then
      set pscmd = "ps lx"
   else
      set pscmd = "ps -u $USER -opid -oppid -ovsz=SIZE"
   endif 

   # The awk here is to select only processes with the right PPID
   set awkprog = 'NR==1{for (i=1;i<=NF;i++) {if ($i=="PPID") f_i=i} print;} \\
                  NR>1 && $f_i=="'$ppid'" {print;}'
   set pid = `$pscmd | awk $awkprog:q  | getfield field=PID sortby=SIZE`

   
   # Find out the stats we want (cpu, elapsed, size, rss)
   if ("$pstype" == "BSD") then
      (ps u $pid > $tmpfile) >& /dev/null
      @ ps_worked = (`cat $tmpfile | wc -l` == 2)
      if ($ps_worked) then
         set command = `cat $tmpfile | getfield field=COMMAND`
         set cpu     = `cat $tmpfile | getfield field=TIME | tosec`
         set size    = `cat $tmpfile | getfield field=SIZE`
         set rss     = `cat $tmpfile | getfield field=RSS`
         set percent = `cat $tmpfile | getfield field=%CPU`
         set elapsed = `echo $cpu $percent | awk '{print ($2>0) ? int(100.*$1/$2):0}'`
      endif
   else
      ( ps -p $pid -otime=TIME -oetime=ETIME -ovsz='     VSZ' -orss='     RSS' -ocomm > $tmpfile ) >& /dev/null
      @ ps_worked = (`cat $tmpfile | wc -l` == 2)
      if ($ps_worked) then
         tail -1 $tmpfile >> $logfile
         set command = `cat $tmpfile | getfield field=COMMAND`
         set cpu     = `cat $tmpfile | getfield field=TIME | tosec`
         set size    = `cat $tmpfile | getfield field=VSZ`
         set rss     = `cat $tmpfile | getfield field=RSS`
         set elapsed = `cat $tmpfile | getfield field=ETIME | tosec`
      endif
   endif
   
   # Update maxima and make sure the current stats are those for the 
   # so far biggest process
   if ($ps_worked) then
      # The major process is the one which has had the largest SIZE or RSS
      # since the last reset.
      # Check if the major process is the same as last time
      if ($size > $size_max || $rss > $rss_max) set pid_major = $pid
      if ($size > $size_max) set size_max = $size
      if ($rss  > $rss_max)  set rss_max  = $rss
      # Update the times as long as we're still looking at the major process
      if ($pid_major == $pid) then
         set command_major = "$command"
         set elapsed_major = "$elapsed"
         set cpu_major     = "$cpu"
      endif
   endif
   
   # Go back to sleep for a while
   sleep $interval
   
end

echo
set name = $0
echo >> $logfile
echo "${name:t}: Parent died.  Logging terminated" >> $logfile

goto EXIT

SIGNAL:
   set name = $0
   echo >> $logfile
   echo "${name:t}: Caught a signal.  Logging terminated" >> $logfile

EXIT:
   rm -f $tmpfile
   exit
   

