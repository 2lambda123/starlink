#!/bin/csh

# Set up variables
set logfile = test.log
set interval = 10

# Print out header
set format = "%10s %10s %10s %10s\n"
printf "$format" "Elapsed(s)" "CPU(s)" "RSS(k)" "Size(k)" >>$logfile

# Classify operating system 
# (currently works for Red Hat Linux, Solaris, Digital Unix) 
if ("`uname`" == "Linux") then
   set pstype = 'BSD'
else
   set pstype = 'SYSV'
endif


# Set up alias for pulling fields out of 'ps' output
alias getfield awk "'\\
   NR==1 {for (i=1;i<=NF;i++) {if("\$"i==field) f_i=i; if("\$"i==sortby) s_i=i;}} \\
   NR==2 {out = "\$"f_i;} \\
   NR>3 && s_i {if ("\$"s_i > out) out="\$"f_i;} \\
   END {print out}'"

# Set up alias for converting from hh:mm:ss to seconds
alias tosec awk -F: "'\\
   {mult=1; for (i=NF;i>0;i--) {sec += "\$"i * mult; mult *= 60} print sec }'"

# Some initialisation
set dirent = "`ls -l $logfile`"
set size_max = 0
set rss_max = 0
onintr SIGNAL

# Work out parent's PID
if ("$pstype" == "BSD") then
   set pscmd = "ps l $$"
else 
   set pscmd = "ps -lp $$"
endif
set ppid = `$pscmd | getfield field=PPID`
if ("$ppid" == "") then
   echo "${0:r}:  No parent process - aborting"
   exit 1
endif
if ("$pstype" == "BSD") then
   set parent_pscmd = "ps $ppid"
else
   set parent_pscmd = "ps -p $ppid"
endif

while (`$parent_pscmd | getfield field=PID`) 
   # Find the process we're interested in.
   # We do this (somewhat haphazardly) by checking the processes which have
   # the same parent as this one, and then selecting the one with the 
   # largest (total virtual) memory size.
   if ("$pstype" == "BSD") then
      set pscmd = "ps ux"
   else
      set pscmd = "ps -oppid,vsz='         VSZ'"
   endif 
   # The mucky grep here is to stop it finding the grep process
   set pid = `$pscmd | grep '[ ]'$ppid' ' | getfield field=PID sortby=VSZ`

   
   # Find out the stats we want (cpu, elapsed, size, rss)
   if ("$pstype" == "BSD") then
      set pscmd = "ps u $pid"
      set cpu     = `$pscmd | getfield field=TIME | tosec`
      set size    = `$pscmd | getfield field=SIZE`
      set rss     = `$pscmd | getfield field=RSS`
      set percent = `$pscmd | getfield field=%CPU`
      set elapsed = `echo $cpu $percent | awk '{print ($2>0) ? 100.*$1/$2 : 0}'`
   else
      set pscmd = "ps -p $pid -otime=TIME,etime=ETIME,vsz='       VSZ',rss='        RSS'"
      set cpu     = `$pscmd | getfield field=TIME | tosec`
      set size    = `$pscmd | getfield field=VSZ`
      set rss     = `$pscmd | getfield field=RSS`
      set elapsed = `$pscmd | getfield field=ETIME | tosec`
   endif
   
   # Update maxima (times are monotonic so they take care of themselves)
   if ($size > $size_max) set size_max = $size
   if ($rss  > $rss_max)  set rss_max  = $rss
   
   
   # See if log file has been altered since last time we did it
   set dirent_last = "$dirent"
   set dirent = "`ls -l $logfile`"
   set lines = `printf "%s\n%s\n" "$dirent_last" "$dirent" | uniq | wc -l`
   
   if ("$lines" == "2") then
   # File has been written to.  Write our summary and reset values.
      set buf = `printf "$format" "$elapsed" "$cpu" "$rss_max" "$size_max"`
      echo $buf >> $logfile
      ps u $$ >> $logfile
      set rss_max = 0
      set size_max = 0
      set dirent = "`ls -l $logfile`"
   endif

   # Go back to sleep for a while
   sleep $interval
   
end

echo "${0:r}: Logging terminated"

exit

SIGNAL:
   echo "${0:r}: Caught a signal.  Logging terminated"
   exit
   

