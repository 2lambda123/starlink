      SUBROUTINE FILEOPEN( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7,
     : ARG8, STATUS )
*+
*  Name:
*     FILEOPEN

*  Purpose:
*     Opens a file, and is used instead of an OPEN statement in the
*     calling routine. This is because when we ported Chart to Sun
*     machines, we found that Sun Fortran did'nt implement the
*     CARRIAGECONTROL and READONLY specifiers, which were needed on the
*     DEC machines, and so rather than have two different versions of
*     the many routines which use these in their OPEN statements, for
*     the different machines, we can have those routines call this one
*     to do OPENs and just have two versions of this. This is the Sun
*     machine version.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL FILEOPEN( ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7, ARG8,
*                   STATUS )
*  Description:
*     Basically it just does an OPEN statement, with the parameters
*     supplied for the specifiers. Not all OPENs need all the
*     specifiers, so it puts the machine defaults into those left
*     blank. No attempt has been made to cater for every possible
*     specifier / combination of specifiers you can have in the OPEN
*     statement - it is just sufficient to replace the OPENs in the
*     routines with non-standard OPEN specifiers.

*  Arguments:
*     ARG1 = INTEGER (Given)
*        Fortran logical unit #
*     ARG2 = CHARACTER * ( * ) (Given)
*        Filename.
*     ARG3 = CHARACTER * ( * ) (Given)
*        Status specifier.
*     ARG4 = CHARACTER * ( * ) (Given)
*        ACCESS specifier.
*     ARG5 = CHARACTER * ( * ) (Given)
*        FORM specifier.
*     ARG6 = LOGICAL (Given)
*        Flag : .TRUE. if CARRIAGECONTROL = 'LIST' specifier required,
*        except that CARRIAGECONTROL is not used in this version (which
*        is why there are two versions), but it has to be left in the
*        calling sequence.
*     ARG7 = INTEGER (Given)
*        RECL specifier. Given in longwords, this version converts to
*        bytes, as required by Sun machines.
*     ARG8 = LOGICAL (Given)
*        .TRUE. if READONLY specifier required - not implemented on Sun
*        machines, but this arg must still be in the calling sequence so
*        that the calling routines can remain unchanged.
*     STATUS = INTEGER (Given and returned)
*        The global status.

*  [optional_subroutine_items]...
*  Authors:
*     AJJB: Andrew J. J. Broderick (Starlink - RAL)
*     {enter_new_authors_here}

*  History:
*     17-MAR-1993 (AJJB):
*        Original version.
*     {enter_changes_here}

*  Bugs:
*     {note_any_bugs_here}

*-
      
*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

      INCLUDE 'SAE_PAR'          ! Standard SAE constants

      INCLUDE 'CHT_ERR'          ! Chart error constants

*  Arguments Given:
      INTEGER ARG1
      CHARACTER * ( * ) ARG2
      CHARACTER * ( * ) ARG3
      CHARACTER * ( * ) ARG4
      CHARACTER * ( * ) ARG5
      LOGICAL ARG6
      INTEGER ARG7
      LOGICAL ARG8

*  Arguments Given and Returned:
      INTEGER STATUS             ! The global status

*  Local Constants:
      CHARACTER * ( 7 ) STADEF   ! Default value for STATUS specifier
      PARAMETER ( STADEF = 'UNKNOWN' )
      CHARACTER * ( 10 ) ACCDEF  ! Default value for ACCESS specifier
      PARAMETER ( ACCDEF = 'SEQUENTIAL' )
      CHARACTER * ( 9 ) SEQDEF   ! Default for FORM when ACCESS =
                                 ! SEQUENTIAL.
      PARAMETER ( SEQDEF = 'FORMATTED' )
      CHARACTER * ( 11 ) DIRDEF  ! Default for FORM when ACCESS =
                                 ! DIRECT.
      PARAMETER ( DIRDEF = 'UNFORMATTED' )
      CHARACTER BLANK            ! A space character
      PARAMETER ( BLANK = ' ' )

*  Local Variables:
      INTEGER UNIT               ! Fortran logical unit #
      CHARACTER * ( 60 ) FILE    ! Filename.
      CHARACTER * ( 7 ) STAT     ! Status specifier.
      CHARACTER * ( 10 ) ACCESS  ! ACCESS specifier.
      CHARACTER * ( 11 ) FORM    ! FORM specifier.
      LOGICAL CARIGE             ! Flag : .TRUE. if CARRIAGECONTROL =
                                 ! 'LIST' specifier required.
      INTEGER RECL               ! RECL specifier
      LOGICAL RDONLY             ! .TRUE. if READONLY specifier
                                 ! required.

*.

* Status check:
      IF ( STATUS .NE. SAI__OK ) RETURN

* Assign args to local variables with slightly more meaningful names :

      UNIT = ARG1
      FILE = ARG2
      STAT = ARG3
      ACCESS = ARG4
      FORM = ARG5
      CARIGE = ARG6
      RECL = ARG7
      RDONLY = ARG8

* Set any which are left blank to machine default values :

      IF ( STAT(1:2) .EQ. BLANK )  STAT = STADEF
      IF ( ACCESS(1:2) .EQ. BLANK ) ACCESS = ACCDEF
      IF ( FORM(1:2) .EQ. BLANK .AND. ACCESS(1:10) .EQ. 'SEQUENTIAL' )
     :     FORM = SEQDEF 
      IF ( FORM(1:2) .EQ. BLANK .AND. ACCESS(1:6) .EQ. 'DIRECT' )
     :     FORM = DIRDEF 

* Convert RECL specifier from longwords (as required on DEC machines) to
* bytes (as required on Sun machines) if need be.

      IF (FORM(:11) .EQ. 'UNFORMATTED' ) RECL = RECL * 4
      
* Pick OPEN statement with or without RECL specifier according to what
* calling routine requires :

      IF ( ACCESS(1:3) .EQ. 'SEQ' ) THEN
      
            OPEN( UNIT = UNIT, FILE = FILE, STATUS = STAT,
     :      ACCESS = ACCESS, FORM = FORM, ERR = 500 )
 
        ELSE

            OPEN( UNIT = UNIT, FILE = FILE, STATUS = STAT,
     :      ACCESS = ACCESS, RECL = RECL, FORM = FORM, ERR = 500 )

        ENDIF

      RETURN

* If error on opening . . .

 500  CONTINUE

      STATUS = CHT__NOFIL
      CALL ERR_REP( ' ', 'FILEOPEN: Can''t open ' // FILE, STATUS )
                  
      END
