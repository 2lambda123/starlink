*+  SPLOT - Generates plot of spectra with overlaid fits
	SUBROUTINE SPLOT( STATUS )
*    Description :
*     Obtains observed data (with instrument response if present) and fit
*     model from the environment, and produces a GRAFIX dataset of data with
*     model overlaid. This can be done rigorously in the data space, or (in
*     the case where model and data spaces are distict; i.e. instrument folding
*     has taken place) with some approximation in the model space, or both,
*     according to the plot mode selected:
*         Mode D/C...........................  data/channel space plot
*         Mode P ............................  photon space plot
*         Mode DP ...........................  both data and model plots
*         Mode DPR......... .................  data and model with residuals
*         Mode R.............................  data space residuals (only)
*     If multiple datasets are entered then all are displayed.
*     For the spectral fitting case, a redshift may be included. The model is
*     then interpreted as applying in the source frame, but the model space
*     spectrum displayed is that observed in the earth frame (i.e. flux from
*     blue shifted source energy bins is mapped onto the corresponding
*     unshifted rest frame bins.
*     Note - no special treatment is required for data which has been
*     likelihood fitted - it is assumed that the dataset given is
*     b/g-subtracted, so plotting is unaffected.
*    Environment parameters :
*     INP=UNIV(R)
*            input data (either a single dataset or a file of references).
*     REDSHIFT=REAL(R)
*            redshift of source spectrum
*     FIT_MOD=UNIV(R)
*            data object containing model specification
*     MODE=LITERAL(R)
*            plot mode
*     OUT=UNIV(W)
*            output plot file
*    Method :
*     Model space dataset values are generated by an approximate method
*     (unavoidably), explained in SPLOT_TRANSFM. Note that the
*     transformation is only valid if the model is a good fit.
*     Formatting of plotted output is expressed in terms of 'plot zones'
*      'plots' and 'graphs'. A 'plot' is a set of axes with one or more
*     'graphs' plotted on it (i.e. overlaying allows several graphs per plot).
*     A 'plot zone' is just the collection of plots for a single input
*     dataset. The total graphical output from the program consists of one
*     p.z. for each dataset.
*     Note that the base axes in each plot are set by the observed data. This
*     may mean that some of an overlaid fit will disappear off the graph.
*     Graph legends and axis labels etc are propagated from the input datasets
*     into the plots produced.
*    Deficiencies :
*     Assumes that either ALL or NO datasets are folded.
*     Residual plotting not yet implemented.
*    Bugs :
*    Authors :
*     Trevor Ponman (BHVAD::TJP)
*    History :
*     26 Aug 88: Converted to FIT_MODEL, model space plotting working (TJP)
*      1 Dec 88: Residual plotting implemented + various minor bug fixes (TJP)
*     24 Jan 89: QUALITY copied into residual plot (TJP)
*     17 May 89: Safeguarded against undefined returns from MATH_LINTERP (TJP)
*     13 Jun 89: Converted to ASTERIX88 (RJV)
*     21 Jun 89: Final mods and redshifting (TJP)
*     12 Jul 89: Final final mods to deal with spectral sets (RJV/TJP)
*     17 Nov 89: Warning if no response found in spectral case (TJP)
*      5 Dec 89: Photon space residuals expressed as significances (TJP)
*     18 May 90: Trap missing quality in model space resid case (TJP)
*      6 Dec 90: Doesn't copy input quality if not present (DJA)
*      5 Aug 90: QUALITY copied to residuals plot! (TJP)
*     22 Jun 92: Handle case when photon space model (& its variance) = 0 (TJP)
*      3 Jul 92: Change to FIT_DATINGET & _PREDDAT interfaces (l-fitting) (TJP)
*      8 Jul 92: Legend change in plots (TJP)
*      9 Aug 92: Bug in handling Quality for spectral sets fixed (TJP)
*     25 Jun 87: V0.6-1 Original (BHVAD::TJP)
*     23 Aug 88: V0.6-2 Major reorganisation, FIT_PLOT introduced (TJP)
*     28 Nov 88: V0.6-3 Residual plotting option implemented (TJP)
*     21 Jun 89: V1.0-1 ASTERIX88 release, incorporates redshifting (TJP/RJV)
*      7 Dec 90: V1.4-1 Bug with multiple spectra and model compts fixed (TJP)
*      5 Aug 91: V1.5-1 Quality arrays copied to resids plots, INIT added (TJP)
*     24 Jun 92: V1.6-1 FIT_PLOT adapted to call l-fit routines + bug fix (TJP)
*        Feb 93: V1.7-0 FIT_PLOT got rid of - interactive plotting (RJV)
*      4 Mar 93: V1.7-1 Use new SFIT_ subroutines (DJA)
*      6 May 93: V1.7-2 Divide by bin width (RJV)
*      8 Sep 93: V1.7-3 Added SPEC_INIT call and removed reference to
*                       SPEC_CMN_RZ (DJA)
*        Nov 93: V1.7-4 Complete rebuild and new features (RJV)
*     19 Mar 94: V1.7-5 Model component plot (RJV)
*    Type definitions :
	IMPLICIT NONE
*    Global constants :
	INCLUDE 'SAE_PAR'
	INCLUDE 'FIT_PAR'
	INCLUDE 'DAT_PAR'
        INCLUDE 'QUAL_PAR'
*    Structure declarations :
	INCLUDE 'FIT_STRUC'
*    Status :
	INTEGER STATUS
*    Function declarations :
*    Global variables :
        INCLUDE 'SPLOT_CMN'
*    Local constants :
*    Local variables :
	RECORD /DATASET/ OBDAT(NDSMAX)	! Observed datasets
	RECORD /INSTR_RESP/ INSTR(NDSMAX)   ! Instrument responses
	RECORD /PREDICTION/ PREDDAT(NDSMAX) ! Data predicted by model
	RECORD /MODEL_SPEC/ MODEL	! Model specification
	RECORD /MODEL_SPEC/ TMODEL	! Model specification

	CHARACTER*(DAT__SZLOC) ILOC	! Locator to input data (or ref object)
	CHARACTER*(DAT__SZLOC) OLOC	! Locator to output multiple dataset
	CHARACTER*(DAT__SZLOC) MLOC	! Locator to model_spec object
	CHARACTER*(DAT__SZLOC) QLOC	! Locator to quality array
	CHARACTER*(DAT__SZLOC) SLOC	! Locator to slice
	CHARACTER*80 MODSPEC		! Model spec (for title)
	CHARACTER*80 TITLE(2)		! Text specifying dataset and model
        CHARACTER*20 DEV
        CHARACTER*20 COMPSPEC(MAXCOMP)	! spec for individual components

        LOGICAL FROZEN(NPAMAX)
        LOGICAL IPRIM,MPRIM
        LOGICAL ACTIVE			! graphics device active
        LOGICAL SAVE			! save data to graphics dataset
        LOGICAL CHANGE			! plot mode has changed
        LOGICAL COMPLEX                 ! complex plot (>1 per page)
        LOGICAL NEW			! new plotting session

        INTEGER NGOOD
        INTEGER SSCALE
	INTEGER N			! Dataset index
	INTEGER NPAR			! No of parameters
	INTEGER NACT			! No of values mapped
	INTEGER NPZ			! No of plots per plot zone
	INTEGER NGZ			! No of graphs per plot zone
	INTEGER NNDF			! Total no of NDFs (curves)
	INTEGER NZX,NZY			! x,y layout of plot zones
	INTEGER IG			! Current graph number
	INTEGER IP			! Current plot number
	INTEGER IUX			! Current x posn (in plot zone)
	INTEGER IUY			! Current y posn (in plot zone)
        INTEGER NDIM
        INTEGER LDIM(2),UDIM(2)         ! slice specification
        INTEGER NSET
        INTEGER NDMAX,NFMAX
        INTEGER NMAX
        INTEGER APTR
        INTEGER NCHAN			! energy channels for model plot
        INTEGER NTERM			! number of additive terms in model
        INTEGER ITERM
        INTEGER TERMS(MAXCOMP,MAXCOMP)	! individual terms
        INTEGER SIGNS(MAXCOMP)		! sign of each term

	REAL Z				! Redshift [ Eobs/Esource=1/(1+z) ]
	REAL PARAM(NPAMAX)		! Model parameters
	REAL LB(NPAMAX)			! Parameter lower bounds
	REAL UB(NPAMAX)			! Parameter upper bounds
	REAL LE(NPAMAX)			! Lower parameter errors
	REAL UE(NPAMAX)			! Upper parameter errors
        REAL D1,D2,DMIN,DMAX
        REAL A1,A2,AMIN,AMAX
	REAL XMIN,XMAX			! Min/max x for current p.z. (NDC)
	REAL YMIN,YMAX			! Min/max y for current p.z. (NDC)
        REAL ELOW,EUPP			! energy bounds for model plot
        REAL EWID			! channel width for model plot
*    Version :
	CHARACTER*30 VERSION
	PARAMETER		(VERSION='SPLOT Version 1.7-4')
*-

* Announce version
	CALL MSG_PRNT( VERSION )

* ASTERIX initialisation
	CALL AST_INIT()
        CALL SPEC_INIT( STATUS )

* Set up genus in MODEL structure
	MODEL.GENUS='SPEC'

* Set plot mode flags in common
        CALL SPLOT_PLOTMODE('MODE',CHANGE,COMPLEX,STATUS)

        IF (MPLOT) THEN

          CALL USI_GET0R('ELOW',ELOW,STATUS)
          CALL USI_GET0R('EUPP',EUPP,STATUS)
          CALL USI_GET0I('NCHAN',NCHAN,STATUS)

        ELSE

* Get observed data and response
          CALL USI_ASSOCI('INP','READ',ILOC,IPRIM,STATUS)
          CALL FIT_DATINGET(ILOC,'SPEC',1,.FALSE.,.FALSE.,NDS,OBDAT,
     :                             NGOOD,SSCALE,PREDDAT,INSTR,STATUS)
          NDMAX=OBDAT(1).NDAT
          NFMAX=PREDDAT(1).NMDAT

        ENDIF

* Get model specification
	CALL USI_ASSOCI('FIT_MOD','READ',MLOC,MPRIM,STATUS)
	CALL FIT_MODGET(MLOC,MODEL,NPAR,PARAM,LB,UB,LE,UE,FROZEN,STATUS)
	CALL CMP_GET0C(MLOC,'SPEC',MODSPEC,STATUS)

*   Look for redshift
        CALL SFIT_GETZ( Z, STATUS )


        IF (MPLOT) THEN

*  Apply redshift
          CALL SFIT_APPRED(Z,1,ELOW,EUPP,STATUS)
          EWID=(EUPP-ELOW)/REAL(NCHAN)


        ELSE

*   Loop through input datasets
          DO N=1,NDS

*        Apply redshift to model space energy bounds
            CALL SFIT_APPRED( Z, PREDDAT(N).NMBOUND,
     :                      %val(PREDDAT(N).MLBNDPTR),
     :                      %val(PREDDAT(N).MUBNDPTR),  STATUS )


*        Report on success in finding instrument response
            IF(PREDDAT(N).CONVOLVE)THEN
              IF(NDS.EQ.1)THEN
                CALL MSG_PRNT('Instrument response found')
              ELSE
                CALL MSG_SETI('NDS',N)
                CALL MSG_PRNT('Instrument response found for'//
     :          ' dataset ^NDS')
              ENDIF
            ELSE
              IF(NDS.EQ.1)THEN
                CALL MSG_PRNT('!! Warning - no instrument response '
     :              //'found, results may not be meaningful !!')
              ELSE
                CALL MSG_SETI('NDS',N)
                CALL MSG_PRNT('!! Warning - no instrument response'
     :                    //' for dataset ^NDS !!')
              ENDIF
            ENDIF

            NDMAX=MAX(NDMAX,OBDAT(N).NDAT)
            NFMAX=MAX(NFMAX,PREDDAT(N).NMDAT)


          ENDDO

* get dynmaic storage
          CALL SPLOT_GET_DYN(NDMAX,NFMAX,STATUS)

        ENDIF


* Set up workspace for model stack
        IF (MPLOT) THEN
          CALL DYN_MAPR(1,NCHAN*MAXSTACK,MODEL.STACKPTR,STATUS)
        ELSE
          NMAX=MAX(NDMAX,NFMAX)
          CALL DYN_MAPR(1,NMAX*MAXSTACK,MODEL.STACKPTR,STATUS)
        ENDIF

        IF (STATUS.NE.SAI__OK) GO TO 9000

        IF (MPLOT) THEN

          CALL FIT_MSPECFLAT(MODEL,MAXCOMP,NTERM,TERMS,SIGNS,STATUS)
*  dynamic storage
          CALL SPLOT_MPLOT_GET_DYN(NCHAN,NTERM,STATUS)
          CALL ARR_INIT1R(0.0,NCHAN,%val(MTDPTR),STATUS)

*  get channel boundaries and centres
          CALL SPLOT_MPLOT_EAXIS(NCHAN,ELOW,EUPP,
     :                   %val(ELPTR),%val(EUPTR),%val(MCXPTR),STATUS)

*  get data values for each term
          DO ITERM=1,NTERM
            CALL FIT_MCALCTERM(MODEL,NTERM,TERMS,SIGNS,ITERM,
     :                             PARAM,1,1,NCHAN,NCHAN,NCHAN+1,
     :                                %val(ELPTR),%val(EUPTR),
     :                                %val(MODEL.STACKPTR),TMODEL,
     :                                %val(MCDPTR(ITERM)),STATUS)
            COMPSPEC(ITERM)=TMODEL.SPEC
            CALL SPLOT_DIVWID2(NCHAN,EWID,%val(MCDPTR(ITERM)),STATUS)
*  add to total model
            CALL SPLOT_MPLOT_ADDCOMP(NCHAN,%val(MCDPTR(ITERM)),
     :                                     %val(MTDPTR),STATUS)
          ENDDO

        ELSE


*   Loop through input datasets
          DO N=1,NDS


*  get predicted data values
            CALL FIT_PREDDAT(1,NDS,OBDAT,INSTR,PREDDAT,MODEL,PARAM,N,
     :                                  %val(PREDDAT(N).DPTR),STATUS)

          ENDDO

*  if no convolution is involved, plot mode 'P' is unavailable
          IF (PPLOT.AND..NOT.(PREDDAT(1).CONVOLVE)) THEN
            CALL MSG_PRNT('No convolution available - '//
     :                         'cannot plot in photon space')
            PPLOT=.FALSE.
            PRPLOT=.FALSE.
          ENDIF

        ENDIF

	IF(STATUS.NE.SAI__OK) GO TO 9000

* Set up layout parameters
        CALL SPLOT_LAYOUT(NPZ,NGZ,NZX,NZY,STATUS)

* get number of NDFs to store data
        IF (MPLOT) THEN
          NNDF=NTERM+1
        ELSE
          NNDF=NGZ*NDS
        ENDIF


* Interactive or save mode
        CALL USI_GET0L('SAVE',SAVE,STATUS)

        IF (SAVE) THEN
* Create file
          CALL USI_ASSOCO('OUT','GRAFIX',OLOC,STATUS)
          CALL MSG_PRNT('Creating multiple dataset...')
        ELSE
* temporary internal file
          CALL DAT_TEMP('TEMPORARY',0,0,OLOC,STATUS)
* open device if not already open
          CALL GDV_STATUS(ACTIVE,STATUS)
          IF (.NOT.ACTIVE) THEN
            CALL USI_GET0C('DEV',DEV,STATUS)
            CALL GDV_OPEN(DEV,1,1,STATUS)
          ENDIF
        ENDIF
* create structure for holding NDFs
        CALL GMD_CREMULT(OLOC,NNDF,STATUS)
* connect to local graphics control
        CALL GCB_LCONNECT(STATUS)


        IF (STATUS.NE.SAI__OK) GOTO 9000

* finally do plotting

*  model only plot
        IF (MPLOT) THEN


          CALL SPLOT_MPLOT_SETUP(NCHAN,NTERM,MODSPEC,COMPSPEC,STATUS)
          CALL SPLOT_MPLOT_COPY(OLOC,NCHAN,NTERM,COMPSPEC,SAVE,STATUS)


        ELSE

* Loop through datasets
	  DO N=1,NDS
	    IG=1+(N-1)*NGZ	! Current graph no.
            IF (OVERLAY) THEN
              IP=1
            ELSE
              IP=1+(N-1)*NPZ	! Current plot no.
            ENDIF

* Window for current plot zone (in Normalised Device Coords)
            IF (OVERLAY) THEN
              IUX=1
              IUY=1
            ELSE
              IUX=1+MOD(N-1,NZX)  	! Current x position (in plot zones)
	      IUY=1+INT((N-1)/NZX)	! Current y position (in plot zones)
            ENDIF
	    XMIN=REAL(IUX-1)/NZX
	    XMAX=REAL(IUX)/NZX
	    YMIN=REAL(IUY-1)/NZY
	    YMAX=REAL(IUY)/NZY



            NFIT=PREDDAT(N).NMDAT
            IFPTR=PREDDAT(N).DPTR
            NVAL=OBDAT(N).NDAT
            DSLOC=OBDAT(N).DLOC
            IDPTR=OBDAT(N).DPTR
            NSET=OBDAT(N).SETINDEX
            QOK=((OBDAT(N).QPTR).NE.0)
            VOK=((OBDAT(N).VPTR).NE.0)


            IF (NSET.GT.0) THEN		! spectral set
              NDIM=2
              LDIM(1)=1
              LDIM(2)=NSET
              UDIM(1)=NVAL
              UDIM(2)=NSET
            ELSE				! single dataset
              NDIM=1
              LDIM(1)=1
              UDIM(1)=NVAL
            ENDIF

            CALL ARR_COP1R(NVAL,%val(IDPTR),%val(DDPTR),STATUS)
            CALL ARR_COP1R(NVAL,%val(IFPTR),%val(DFDPTR),STATUS)


            IF (VOK) THEN
              IVPTR=OBDAT(N).VPTR
              CALL ARR_COP1R(NVAL,%val(IVPTR),%val(DVPTR),STATUS)
            ELSE
              CALL BDA_MAPVAR(DSLOC,'R',IVPTR,STATUS)
              CALL ARR_COP1R(NVAL,%val(IVPTR),%val(DVPTR),STATUS)
            ENDIF
            IF (QOK) THEN
              CALL BDA_LOCQUAL(DSLOC,QLOC,STATUS)
              CALL DAT_SLICE(QLOC,NDIM,LDIM,UDIM,SLOC,STATUS)
              CALL DAT_MAPV(SLOC,'_UBYTE','READ',DQPTR,NACT,STATUS)
              CALL BDA_GETMASK(DSLOC,MASK,STATUS)
            ENDIF
            CALL BDA_MAPAXVAL(DSLOC,'R',1,DXPTR,STATUS)
            CALL BDA_MAPAXWID(DSLOC,'R',1,DWPTR,STATUS)


*  set up data for plots
            CALL SPLOT_GEN_SETUP(INSTR(N),PREDDAT(N),Z,STATUS)

*  construct plot title
            CALL SPLOT_TITLE(OBDAT(N).DATNAME,MODSPEC,TITLE)

            IF (SAVE) THEN
              CALL MSG_SETI('DS',N)
              CALL MSG_PRNT('Dataset ^DS')
            ENDIF

*  Data space plot
	    IF (DPLOT) THEN
              CALL SPLOT_DPLOT_SETUP(N,NPZ,XMIN,XMAX,YMIN,YMAX,TITLE,
     :                                                         STATUS)
              CALL SPLOT_DPLOT_COPY(OLOC,IP,IG,N,SAVE,STATUS)

* update plot and graph nos.
	      IP=IP+1
	      IG=IG+2

            ENDIF

* data space residuals
            IF (DRPLOT) THEN

              CALL SPLOT_DRPLOT_SETUP(N,NPZ,XMIN,XMAX,YMIN,YMAX,
     :                                                     STATUS)
              CALL SPLOT_DRPLOT_COPY(OLOC,IP,IG,N,SAVE,STATUS)


* update plot and graph nos.
              IP=IP+1
              IG=IG+1

            ENDIF




* Photon space plot
            IF (PPLOT) THEN

              CALL SPLOT_PPLOT_SETUP(N,NPZ,XMIN,XMAX,YMIN,YMAX,TITLE,
     :                                                         STATUS)
              CALL SPLOT_PPLOT_COPY(OLOC,IP,IG,N,SAVE,STATUS)


* update plot and graph nos.
	      IP=IP+1
	      IG=IG+2

            ENDIF

* photon space residuals
	    IF (PRPLOT) THEN

              CALL SPLOT_PRPLOT_SETUP(N,NPZ,XMIN,XMAX,YMIN,YMAX,STATUS)
              CALL SPLOT_PRPLOT_COPY(OLOC,IP,IG,N,SAVE,STATUS)


* update plot and graph nos.
              IP=IP+1
              IG=IG+1


	    ENDIF


            CALL BDA_RELEASE(DSLOC,STATUS)

* End of dataset loop
	  ENDDO

          CALL SPLOT_RELEASE_DYN(STATUS)


        ENDIF

*  if in interactive mode - plot
        IF (.NOT.SAVE) THEN
          CALL GDRAW_SUB(OLOC,STATUS)
        ENDIF

        CALL DYN_UNMAP(MODEL.STACKPTR,STATUS)

        CALL DAT_ANNUL(OLOC,STATUS)

* Exit
 9000	CONTINUE

        IF (.NOT.ACTIVE) THEN
          CALL GDV_CLOSE(STATUS)
        ENDIF

        CALL GCB_DETACH(STATUS)

	CALL AST_CLOSE()

	END


*+
      SUBROUTINE SPLOT_GET_DYN(ND,NF,STATUS)
*    Description :
*    Type definitions :
      IMPLICIT NONE
*    Import :
      INTEGER ND,NF
*    Import-Export :
*    Export :
*    Status :
        INTEGER STATUS
*    Global constants :
	INCLUDE 'QUAL_PAR'
        INCLUDE 'SAE_PAR'
        INCLUDE 'DAT_PAR'
        INCLUDE 'FIT_PAR'
*    Global variables :
        INCLUDE 'SPLOT_CMN'
*    Local variables :
*-
        IF (STATUS.EQ.SAI__OK) THEN
          CALL DYN_MAPR(1,ND,DDPTR,STATUS)
          CALL DYN_MAPR(1,ND,DVPTR,STATUS)
          CALL DYN_MAPR(1,ND,DRDPTR,STATUS)
          CALL DYN_MAPR(1,ND,DFDPTR,STATUS)
          CALL DYN_MAPR(1,ND,PDPTR,STATUS)
          CALL DYN_MAPR(1,ND,PVPTR,STATUS)
          CALL DYN_MAPR(1,ND,PXPTR,STATUS)
          CALL DYN_MAPR(1,ND,PWPTR,STATUS)
          CALL DYN_MAPR(1,NF,PFDPTR,STATUS)
          CALL DYN_MAPR(1,NF,PFXPTR,STATUS)
          CALL DYN_MAPR(1,ND,PRDPTR,STATUS)
          CALL DYN_MAPR(1,ND,PRVPTR,STATUS)
          CALL DYN_MAPB(1,ND,PRQPTR,STATUS)
          CALL DYN_MAPR(1,ND,PIDPTR,STATUS)

          IF (STATUS.NE.SAI__OK) THEN
            CALL ERR_REP(' ','from SPLOT_GET_DYN',STATUS)
          ENDIF

        ENDIF
	END


*+
      SUBROUTINE SPLOT_RELEASE_DYN(STATUS)
*    Description :
*    Type definitions :
      IMPLICIT NONE
*    Import :
*    Import-Export :
*    Export :
*    Status :
        INTEGER STATUS
*    Global constants :
	INCLUDE 'QUAL_PAR'
        INCLUDE 'SAE_PAR'
        INCLUDE 'DAT_PAR'
        INCLUDE 'FIT_PAR'
*    Global variables :
        INCLUDE 'SPLOT_CMN'
*    Local variables :
*-

        CALL DYN_UNMAP(DDPTR,STATUS)
        CALL DYN_UNMAP(DVPTR,STATUS)
        CALL DYN_UNMAP(DRDPTR,STATUS)
        CALL DYN_UNMAP(DFDPTR,STATUS)
        CALL DYN_UNMAP(PDPTR,STATUS)
        CALL DYN_UNMAP(PVPTR,STATUS)
        CALL DYN_UNMAP(PXPTR,STATUS)
        CALL DYN_UNMAP(PWPTR,STATUS)
        CALL DYN_UNMAP(PFDPTR,STATUS)
        CALL DYN_UNMAP(PFXPTR,STATUS)
        CALL DYN_UNMAP(PRDPTR,STATUS)
        CALL DYN_UNMAP(PRVPTR,STATUS)
        CALL DYN_UNMAP(PRQPTR,STATUS)
        CALL DYN_UNMAP(PIDPTR,STATUS)


	END


*+
      SUBROUTINE SPLOT_MPLOT_GET_DYN(NCHAN,NTERM,STATUS)
*    Description :
*    Type definitions :
      IMPLICIT NONE
*    Import :
      INTEGER NCHAN,NTERM
*    Import-Export :
*    Export :
*    Status :
        INTEGER STATUS
*    Global constants :
        INCLUDE 'SAE_PAR'
        INCLUDE 'DAT_PAR'
        INCLUDE 'FIT_PAR'
*    Global variables :
        INCLUDE 'SPLOT_CMN'
*    Local variables :
        INTEGER I
*-
        IF (STATUS.EQ.SAI__OK) THEN

          CALL DYN_MAPR(1,NCHAN+1,ELPTR,STATUS)
          CALL DYN_MAPR(1,NCHAN+1,EUPTR,STATUS)
          CALL DYN_MAPR(1,NCHAN,MCXPTR,STATUS)
          DO I=1,NTERM
            CALL DYN_MAPR(1,NCHAN,MCDPTR(I),STATUS)
          ENDDO
          CALL DYN_MAPR(1,NCHAN,MTDPTR,STATUS)

          IF (STATUS.NE.SAI__OK) THEN
            CALL ERR_REP(' ','from SPLOT_MPLOT_GET_DYN',STATUS)
          ENDIF

        ENDIF
	END


*+
      SUBROUTINE SPLOT_MPLOT_RELEASE_DYN(NTERM,STATUS)
*    Description :
*    Type definitions :
      IMPLICIT NONE
*    Import :
      INTEGER NTERM
*    Import-Export :
*    Export :
*    Status :
        INTEGER STATUS
*    Global constants :
        INCLUDE 'SAE_PAR'
        INCLUDE 'DAT_PAR'
        INCLUDE 'FIT_PAR'
*    Global variables :
        INCLUDE 'SPLOT_CMN'
*    Local variables :
        INTEGER I
*-

        CALL DYN_UNMAP(ELPTR,STATUS)
        CALL DYN_UNMAP(EUPTR,STATUS)
        CALL DYN_UNMAP(MCXPTR,STATUS)
        DO I=1,NTERM
          CALL DYN_UNMAP(MCDPTR(I),STATUS)
        ENDDO
        CALL DYN_UNMAP(MTDPTR,STATUS)

	END



*+  SPLOT_MODRES - calc. model space residuals
      SUBROUTINE SPLOT_MODRES(N,D,FIT,V,DR,VR,QR,STATUS)
*    Description :
*    Type definitions :
      IMPLICIT NONE
*    Import :
	INTEGER N			! No of data values
	REAL D(*)			! Data array
        REAL FIT(*)
        REAL V(*)
*    Import-Export :
*    Export :
        REAL DR(*)
        REAL VR(*)
        BYTE QR(*)
*    Status :
        INTEGER STATUS
*    Functions :
        BYTE BIT_ORUB
*    Local constants :
	INCLUDE 'QUAL_PAR'
        INCLUDE 'SAE_PAR'
        INCLUDE 'DAT_PAR'
*    Local variables :
	INTEGER I
        LOGICAL WARN
*-
        IF (STATUS.EQ.SAI__OK) THEN

          WARN=.FALSE.
          DO I=1,N

            IF (V(I).GT.0.0) THEN
              DR(I)=(D(I)-FIT(I))/SQRT(V(I))
            ELSE
              DR(I)=0.0
              QR(I)=BIT_ORUB(QR(I),QUAL__ARITH)
              WARN=.TRUE.
            ENDIF
            VR(I)=1.0

          ENDDO

          IF (WARN) THEN
	    CALL MSG_PRNT(' ')
	    CALL MSG_PRNT('Warning - photon space model is zero for '//
     :          'some channel energies')
	    CALL MSG_PRNT(' ')
          ENDIF

        ENDIF
	END

*+  SPLOT_RESID - calc. data space residuals
      SUBROUTINE SPLOT_RESID(N,D,FIT,DR,STATUS)
*    Description :
*    Type definitions :
      IMPLICIT NONE
*    Import :
	INTEGER N			! No of data values
	REAL D(*)			! Data array
        REAL FIT(*)
*    Import-Export :
*    Export :
        REAL DR(*)
*    Status :
        INTEGER STATUS
*    Local constants :
        INCLUDE 'SAE_PAR'
        INCLUDE 'DAT_PAR'
*    Local variables :
	INTEGER I
*-
        IF (STATUS.EQ.SAI__OK) THEN

          DO I=1,N

            DR(I)=D(I)-FIT(I)

          ENDDO


        ENDIF
	END


*+  SPLOT_CHEN - Derives channel centres & widths from bounds
      SUBROUTINE SPLOT_CHEN(NDAT,CBOUND,CHEN,CHWID,STATUS)
*    Description :
*    History :
*     24 Aug 88: Original (TJP)
*     21 Jun 89: ASTERIX88; half-widths -> widths (RJV)
*    Type definitions :
      IMPLICIT NONE
*    Import :
	INTEGER NDAT			! No of energy space channels
	REAL CBOUND(0:NDAT)		! Channel bound energies
*    Import-Export :
*    Export :
	REAL CHEN(NDAT)			! Channel centre energies
	REAL CHWID(NDAT)		! Channel widths
*    Status :
       INTEGER STATUS
*    Global constants :
      INCLUDE 'SAE_PAR'
*    Local variables :
	INTEGER I
*-------------------------------------------------------------------------------
      IF (STATUS.EQ.SAI__OK) THEN
	DO I=1,NDAT
	  CHEN(I)=(CBOUND(I-1)+CBOUND(I))/2
	  CHWID(I)=CBOUND(I)-CBOUND(I-1)
	ENDDO
      ENDIF
      END

*+  SPLOT_NORM - Normalises flux array w.r.t. energy
      SUBROUTINE SPLOT_NORM(NDAT,FLUX,LB,UB,Z,SPECFLUX,STATUS)
*    Description :
*     Normalises flux to spectral flux observed at earth. Since the
*     energy bin bounds are those applying at the source the interval
*     between them is decreased by a factor 1/(1+z) at earth, and the
*     spectral flux (photon/(cm**2*s*keV)) consequently increases by a
*     factor 1+z.
*    History :
*     18 Aug 88: Original (TJP)
*     21 Jun 89: Redshifting added (TJP)
*    Type definitions :
      IMPLICIT NONE
*    Import :
	INTEGER NDAT			! No of energy space channels
	REAL FLUX(NDAT)			! Flux in each channel
	REAL LB(NDAT)			! Lower channel bounds
	REAL UB(NDAT)			! Upper channel bounds
	REAL Z				! Redshift [ Eobs/Esource=1/(1+z) ]
*    Import-Export :
*    Export :
	REAL SPECFLUX(NDAT)		! Flux per unit energy in each channel
*    Status :
      INTEGER STATUS
*    Global constants :
      INCLUDE 'SAE_PAR'
*    Local variables :
	INTEGER I
*-------------------------------------------------------------------------------
      IF (STATUS.EQ.SAI__OK) THEN
	DO I=1,NDAT
	  SPECFLUX(I)=(1+Z)*FLUX(I)/(UB(I)-LB(I))
	ENDDO
      ENDIF
      END

*+  SPLOT_TRANSFM - Transforms observed data into approx model space values
	SUBROUTINE SPLOT_TRANSFM(NDAT,OBDAT,PREDDAT,ERR,OBVAR,
     :  PREDMOD,TRANDAT,TRANVAR,STATUS)
*    Description :
*     The observed data values OBDAT are transformed approximately back into
*     the model space (e.g. channel spectrum transformed to photon spectrum)
*     using the prescription:
*                TRANDAT = OBDAT*PREDMOD/PREDDAT
*     i.e. the returned values are the model space values from the FIT model
*     (interpolated to give values at the data channel energies) scaled by
*     the ratio of the observed to predicted intensities in each data channel.
*     The PREDMOD values should already be normalised to unit model bin width.
*     This results, in the spectral case, in output values in
*     photon/(cm**2*sec*keV), rather than  photon/(cm**2*sec).
*     Where errors are present they are scaled similarly, so that
*               TRANVAR=OBVAR*(TRANDAT/OBDAT)**2
*     (Note that errors are represented as variances in ASTERIX88)
*     It is assumed that predicted data values will be positive, and to
*     avoid floating zero divides, all are set to be >=PREDLIM.
*    History :
*     25 Jun 87: Original (TJP)
*     25 Nov 88: Proofed against PREDDAT=0 (TJP)
*     21 Jun 89: ASTERIX88 version, errors->variances
*    Type definitions :
      IMPLICIT NONE
*    Import :
	INTEGER NDAT		! No of spectral channels
	REAL OBDAT(*)		! Observed spectrum
	REAL PREDDAT(*)		! Predicted spectrum
	LOGICAL ERR		! Errors available?
	REAL OBVAR(*)		! Data variances
	REAL PREDMOD(*)		! Model space prediction
*    Import-Export :
*    Export :
	REAL TRANDAT(*)		! Transformed data values (i.e. in model space)
	REAL TRANVAR(*)		! Transformed variances
*    Status :
        INTEGER STATUS
*    Global Constants :
        INCLUDE 'SAE_PAR'
        INCLUDE 'DAT_PAR'
*    Local Constants :
	REAL PREDLIM		! Minimum value allowed for predicted data
	PARAMETER (PREDLIM=1.0E-10)
*    Local variables :
	INTEGER I
	REAL PDAT		! PREDDAT value limited to be >=PREDLIM
*-------------------------------------------------------------------------------
      IF (STATUS.EQ.SAI__OK) THEN
	DO I=1,NDAT
	  IF(PREDDAT(I).GE.PREDLIM)THEN
	    PDAT=PREDDAT(I)
	  ELSE
	    PDAT=PREDLIM
	  ENDIF
	  TRANDAT(I)=OBDAT(I)*PREDMOD(I)/PDAT
	  IF(ERR)THEN
	    TRANVAR(I)=OBVAR(I)*(PREDMOD(I)/PDAT)**2
	  ENDIF
	ENDDO

      ENDIF
      END



*+  SPLOT_ZERO - Zeroes any undefined values in model space array
      SUBROUTINE SPLOT_ZERO(N,ARRAY,STATUS)
*    Description :
*     MATH_LINTERP returns values VAL__BADR if asked for a value outside
*     its interpolation range. This can occur if some channel energies lie
*     outside the energy range in the response matrix (which they shouldn't
*     really...). This routine simply zeroes these on the basis that they
*     ought not to contribute to the source counts. This will result in
*     the corresponding transformed data and errors being zeroed too.
*    History :
*     17 May 89: Original (TJP)
*    Type definitions :
      IMPLICIT NONE
*    Import :
	INTEGER N			! No of array elements
*    Import-Export :
	REAL ARRAY(N)			! Array
*    Export :
*    Status :
      INTEGER STATUS
*    Global constants :
      INCLUDE 'SAE_PAR'
      INCLUDE 'DAT_PAR'
      INCLUDE 'PRM_PAR'
*    Local variables :
	INTEGER I
*-

      IF (STATUS.EQ.SAI__OK) THEN
	DO I=1,N
	  IF(ARRAY(I).LE.VAL__BADR)THEN
	    ARRAY(I)=0.0
	  ENDIF
	ENDDO
      ENDIF
      END


      SUBROUTINE SPLOT_DIVWID(N,W,D,STATUS)

      IMPLICIT NONE

      INCLUDE 'SAE_PAR'
      INCLUDE 'DAT_PAR'

      INTEGER STATUS

      INTEGER N
      REAL W(*)
      REAL D(*)

      INTEGER I

      IF (STATUS.EQ.SAI__OK) THEN
        DO I=1,N
          IF (W(I).GT.0.0) THEN
            D(I)=D(I)/W(I)
          ENDIF
        ENDDO
      ENDIF

      END


      SUBROUTINE SPLOT_DIVWID2(N,W,D,STATUS)

      IMPLICIT NONE

      INCLUDE 'SAE_PAR'
      INCLUDE 'DAT_PAR'

      INTEGER STATUS

      INTEGER N
      REAL W
      REAL D(*)

      INTEGER I

      IF (STATUS.EQ.SAI__OK.AND.W.GT.0.0) THEN
        DO I=1,N
          D(I)=D(I)/W
        ENDDO
      ENDIF

      END


*+
      SUBROUTINE SPLOT_PLOTMODE(PAR,CHANGE,COMPLEX,STATUS)
*    Description :
*        D = plot observed data (ie counts)
*        C = same as D
*        P = plot photons (ie convolved data - if convolution available)
*        R = plot residuals
*        E = all x-axes to be energy (ie not channel number)
*        L = all axes log scale - by default photon plot axes are log
*        M = plot model by itself, showing each component
*        O = overlay multiple datasets, instead of separate plots
*    Type definitions :
      IMPLICIT NONE
*    Global constants :
      INCLUDE 'SAE_PAR'
      INCLUDE 'DAT_PAR'
      INCLUDE 'FIT_PAR'
*    Global variables :
      INCLUDE 'SPLOT_CMN'
*    Structure definitions :
*    Import :
      CHARACTER*(*) PAR
*    Import-Export :
*    Export :
      LOGICAL CHANGE
      LOGICAL COMPLEX
*    Status :
      INTEGER STATUS
*    Function declarations :
*    Local constants :
*    Local variables :
      CHARACTER*10 MODE,LAST
      SAVE LAST
      INTEGER NP
      LOGICAL D,P,R,E,M,L,O
*-

      IF (STATUS.EQ.SAI__OK) THEN

*  get plotting mode
        MODE=' '
        DO WHILE (MODE.EQ.' '.AND.STATUS.EQ.SAI__OK)
          CALL USI_DEF0C(PAR,LAST,STATUS)
          CALL USI_GET0C(PAR,MODE,STATUS)
          CALL CHR_UCASE(MODE)
          IF (MODE(:1).EQ.'H'.OR.MODE.EQ.' '.AND.
     :                           STATUS.EQ.SAI__OK) THEN
            CALL SPLOT_PLOTMODE_HELP()
            MODE=' '
            CALL USI_CANCL(PAR,STATUS)
          ENDIF
        ENDDO

        IF (STATUS.EQ.SAI__OK) THEN

*  see if mode has changed
          IF (MODE.NE.LAST) THEN
            CHANGE=.TRUE.
            LAST=MODE
          ENDIF

	  DPLOT=.FALSE.
          PPLOT=.FALSE.
          DRPLOT=.FALSE.
          PRPLOT=.FALSE.
          MPLOT=.FALSE.
          EAXIS=.FALSE.
          LOGAX=.FALSE.
          OVERLAY=.FALSE.

          E=(INDEX(MODE,'E').NE.0)
          R=(INDEX(MODE,'R').NE.0)
          M=(INDEX(MODE,'M').NE.0)
          D=(INDEX(MODE,'D').NE.0.OR.INDEX(MODE,'C').NE.0)
          P=(INDEX(MODE,'P').NE.0)
          O=(INDEX(MODE,'O').NE.0)
          L=(INDEX(MODE,'L').NE.0)

          EAXIS=E

          NP=0

          IF (MODE.EQ.' ') THEN
            CALL MSG_PRNT('No plot mode specified - '//
     :                       'defaulting to data plot')
            DPLOT=.TRUE.
            NP=NP+1

          ELSEIF (M) THEN

            MPLOT=.TRUE.
            IF (D.OR.P.OR.R) THEN
              CALL MSG_PRNT('Cannot mix model plot with others')
              CALL MSG_PRNT('    - other modes will be ignored')
            ENDIF
            NP=NP+1

          ELSE

            IF (R) THEN
              IF (D) THEN
                DRPLOT=.TRUE.
                NP=NP+1
              ENDIF
              IF (P) THEN
                PRPLOT=.TRUE.
                NP=NP+1
              ENDIF
              IF (.NOT.(D.OR.P)) THEN
                DRPLOT=.TRUE.
                NP=NP+1
              ENDIF
            ENDIF

            IF (D) THEN
              DPLOT=.TRUE.
              NP=NP+1
            ENDIF

            IF (P) THEN
              PPLOT=.TRUE.
              NP=NP+1
            ENDIF

            IF (O) THEN
              OVERLAY=.TRUE.
              EAXIS=.TRUE.
            ENDIF


          ENDIF

          IF (L) THEN
            LOGAX=.TRUE.
          ENDIF

          COMPLEX=(NP.NE.1.AND..NOT.OVERLAY)

        ENDIF

      ENDIF

      END

*+
      SUBROUTINE SPLOT_PLOTMODE_HELP()

      INTEGER NLINE
      PARAMETER (NLINE=7)

      INTEGER I
      CHARACTER*79 TEXT(NLINE)
      DATA TEXT/
     :  '   D (or C) - plot observed data (counts)',
     :  '   P        - plot convolved data (photons)',
     :  '   R        - plot residuals',
     :  '   E        - all x-axes plotted as energy',
     :  '   L        - all axes plotted with log scale',
     :  '   O        - (multiple data overlayed on same axes)-soon',
     :  '   M        - plot model only, showing components'/
*-
      CALL MSG_BLNK()
      DO I=1,NLINE
        CALL MSG_PRNT(TEXT(I))
      ENDDO
      CALL MSG_BLNK()

      END


*+
      SUBROUTINE SPLOT_TITLE(DATNAME,MODSPEC,TITLE)

*    Description :
*    Type definitions :
      IMPLICIT NONE
*    Global constants :
*    Global variables :
*    Structure definitions :
*    Import :
      CHARACTER*(*) DATNAME,MODSPEC
*    Import-Export :
*    Export :
      CHARACTER*(*) TITLE(2)
*    Status :
*    Function declarations :
      INTEGER CHR_LEN
*    Local constants :
*    Local variables :
      INTEGER I,L
*-
      L=CHR_LEN(DATNAME)

      I=L
*  strip off directory spec.
      DO WHILE (.NOT.(DATNAME(I:I).EQ.']'.OR.DATNAME(I:I).EQ.'/')
     :                                               .AND.I.GT.1)
        I=I-1
      ENDDO
      IF (I.GT.1) THEN
        I=I+1
      ENDIF

      TITLE(1)='Dataset: '//DATNAME(I:)
      TITLE(2)='Model: '//MODSPEC


      END

*+
      SUBROUTINE SPLOT_LAYOUT(NPZ,NGZ,NZX,NZY,STATUS)
*    Description :
*    Type definitions :
      IMPLICIT NONE
*    Global constants :
      INCLUDE 'SAE_PAR'
      INCLUDE 'DAT_PAR'
      INCLUDE 'FIT_PAR'
*    Global variables :
      INCLUDE 'SPLOT_CMN'
*    Structure definitions :
*    Import :
*    Import-Export :
*    Export :
      INTEGER NPZ,NGZ,NZX,NZY
*    Status :
      INTEGER STATUS
*    Function declarations :
*    Local constants :
*    Local variables :
      INTEGER NXZ,NYZ
*-

      IF (STATUS.EQ.SAI__OK) THEN

*  just plotting model
        IF (MPLOT) THEN
          NPZ=1
          NGZ=1
          NXZ=1
          NYZ=1
          NZX=1
          NZY=1

        ELSE

*    Number of plots per plot zone
          NPZ=0
          NGZ=0
	  IF (DPLOT) THEN
            NPZ=NPZ+1			! one plot
            NGZ=NGZ+2			! two curves
          ENDIF
	  IF (PPLOT) THEN
            NPZ=NPZ+1			! same as DPLOT
            NGZ=NGZ+2
          ENDIF
	  IF (DRPLOT) THEN
            NPZ=NPZ+1			! one curve per plot
            NGZ=NGZ+1
          ENDIF
	  IF (PRPLOT) THEN
            NPZ=NPZ+1
            NGZ=NGZ+1
          ENDIF

*    Layout within each plot zone (dependent on plot mode)
          IF(NPZ.EQ.1)THEN
	    NXZ=1
	    NYZ=1
	  ELSEIF(NPZ.EQ.2)THEN
	    NXZ=1
	    NYZ=2
	  ELSEIF(NPZ.EQ.4)THEN
	    NXZ=2
	    NYZ=2
	  ENDIF


*  Layout of plot zones  - one per dataset unless overlayed
	  NZX=1
	  NZY=1
          IF (.NOT.OVERLAY) THEN
            DO WHILE(NZX*NZY.LT.NDS)
*  nx no more than ny+2
	      IF(NZX.GE.NZY+2)THEN
	        NZY=NZY+1
	      ELSE
	        NZX=NZX+1
	      ENDIF
	    ENDDO
          ENDIF

        ENDIF


      ENDIF

      END


*+
      SUBROUTINE SPLOT_GEN_SETUP(INSTR,PREDDAT,Z,STATUS)
*    Description :
*    Type definitions :
      IMPLICIT NONE
*    Global constants :
      INCLUDE 'SAE_PAR'
      INCLUDE 'DAT_PAR'
      INCLUDE 'FIT_PAR'
*    Global variables :
      INCLUDE 'SPLOT_CMN'
*    Structure definitions :
       INCLUDE 'FIT_STRUC'
*    Import :
      RECORD /INSTR_RESP/ INSTR
      RECORD /PREDICTION/ PREDDAT
      REAL Z
*    Import-Export :
*    Export :
*    Status :
      INTEGER STATUS
*    Function declarations :
*    Local constants :
      REAL YDEC				! No of decades allowed in range of
      PARAMETER (YDEC=3.1)		! data
*    Local variables :
      CHARACTER*(DAT__SZLOC) ESLOC
      INTEGER CBPTR,ESPTR
      INTEGER NACT
      LOGICAL CBOUNDS
*-

      IF (STATUS.NE.SAI__OK) RETURN


*  divide data and fit by bin width to normalise
      CALL SPLOT_DIVWID(NVAL,%val(DWPTR),%val(DDPTR),STATUS)
      CALL SPLOT_DIVWID(NVAL,%val(DWPTR),%val(DVPTR),STATUS)
      CALL SPLOT_DIVWID(NVAL,%val(DWPTR),%val(DVPTR),STATUS)
      CALL SPLOT_DIVWID(NVAL,%val(DWPTR),%val(DFDPTR),STATUS)

*  get fit data
      CALL INSR_FIND(INSTR.ELOC,'ENERGY_SPEC',ESLOC,STATUS)
      CALL DAT_MAPV(ESLOC,'_REAL','READ',ESPTR,NACT,STATUS)
      CALL ARR_COP1R(NFIT,%val(ESPTR),%val(PFXPTR),STATUS)
      CALL SPLOT_NORM(NFIT,%val(PREDDAT.MPTR),
     :      %val(PREDDAT.MLBNDPTR),%val(PREDDAT.MUBNDPTR),Z,
     :                                     %val(PFDPTR),STATUS)
      CALL DAT_ANNUL(ESLOC,STATUS)

*     determine channel energies & widths


*     look for channel bound information
      CALL INSR_MAP(INSTR.ELOC,'CHANNEL_BOUNDS','_REAL',
     :                              'READ',CBPTR,NACT,STATUS)
      IF(STATUS.NE.SAI__OK)THEN
        CALL ERR_ANNUL(STATUS)
        CBOUNDS=.FALSE.
      ELSE IF(NACT.NE.NVAL+1)THEN
        CALL MSG_PRNT('Channel bounds array is incorrect length'
     :        //' and will be ignored')
        CBOUNDS=.FALSE.
      ELSE
        CBOUNDS=.TRUE.

*     derive centres and widths from bounds
        CALL SPLOT_CHEN(NVAL,%val(CBPTR),%val(PXPTR),
     :                                     %val(PWPTR),STATUS)
      ENDIF


*     no bounds available, so derive them by interpoln from response matrix
      IF(.NOT.CBOUNDS)THEN
        CALL MSG_PRNT('Deriving channel energies & widths '
     :        //'from response matrix')
        CALL SPEC_CHEN(NVAL,INSTR.NRESP,
     :            %val(INSTR.MIPTR),%val(INSTR.DIPTR),
     :                %val(INSTR.RESPTR),%val(PFXPTR),%val(PXPTR),
     :                                          %val(PWPTR),STATUS)
      ENDIF

*     interpolate to give predicted model space fluxes at channel energies
      CALL MATH_LINTERP(NFIT,%val(PFXPTR),%val(PFDPTR),
     :                NVAL,%val(PXPTR),%val(PIDPTR),STATUS)



*     safeguard against bad (undefined) model space values (from MATH_LINTERP)
      CALL SPLOT_ZERO(NVAL,%val(PIDPTR),STATUS)


*   Model space data (i.e. transformed back using fitted model)
      CALL SPLOT_TRANSFM(NVAL,%val(IDPTR),%val(IFPTR),
     :                          .TRUE.,%val(IVPTR),%val(PIDPTR),
     :                            %val(PDPTR),%val(PVPTR),STATUS)




      END




*+
      SUBROUTINE SPLOT_DPLOT_SETUP(IDS,NPZ,XMIN,XMAX,YMIN,YMAX,TITLE,
     :                                                        STATUS)
*    Description :
*    Type definitions :
      IMPLICIT NONE
*    Global constants :
      INCLUDE 'SAE_PAR'
      INCLUDE 'DAT_PAR'
      INCLUDE 'FIT_PAR'
*    Global variables :
*    Structure definitions :
*    Import :
      INTEGER IDS,NPZ
      REAL XMIN,XMAX,YMIN,YMAX
      CHARACTER*(*) TITLE(*)
*    Import-Export :
*    Export :
*    Status :
      INTEGER STATUS
*    Function declarations :
*    Global variables :
        INCLUDE 'SPLOT_CMN'
*    Local constants :
      INTEGER SYMBOL(8)/17,13,16,18,4,7,6,12/
*    Local variables :
      CHARACTER*40 LABEL
      REAL TXTSCALE
      REAL X1,X2,Y1,Y2
      REAL XW1,XW2,YW1,YW2
      REAL BXW1,BXW2,BYW1,BYW2
      SAVE BXW1,BXW2,BYW1,BYW2
      INTEGER ISYM
*-

      IF (STATUS.NE.SAI__OK) RETURN


*   set plot position and text size
      X1=XMIN
      X2=XMAX
      Y1=YMIN
      Y2=YMAX
      IF(NPZ.EQ.2)THEN
        IF(PPLOT)THEN			! Mode DM
          Y2=0.5*(YMIN+YMAX)
        ELSE				! Mode DR
          Y1=YMIN+0.33*(YMAX-YMIN)
        ENDIF
      ELSEIF (NPZ.GT.2) THEN		! Mode DMR
        X2=0.5*(XMIN+XMAX)
        Y1=YMIN+0.33*(YMAX-YMIN)
      ENDIF
      TXTSCALE=MIN(0.8,2*(X2-X1))

*     now allow margin for labels & title
      X1=X1+3.0*TXTSCALE*0.025		! 3.0 char. heights
      Y1=Y1+3.0*TXTSCALE*0.025		! 3.0 char. heights
      Y2=Y2-2.5*TXTSCALE*0.025		! 2.5 char. heights

*  viewport position
      CALL GCB_SETR('POS_X1',X1,STATUS)
      CALL GCB_SETR('POS_X2',X2,STATUS)
      CALL GCB_SETR('POS_Y1',Y1,STATUS)
      CALL GCB_SETR('POS_Y2',Y2,STATUS)

*  numeric label character size
      CALL GCB_SETR('AXES_SIZE',TXTSCALE,STATUS)

*  axis labels
      CALL GCB_SETR('XLABEL_SIZE',TXTSCALE,STATUS)
      IF (EAXIS) THEN
        LABEL='Energy (keV)'
      ELSE
        LABEL='Channel no.'
      ENDIF
      CALL GCB_SETC('XLABEL_TEXT',LABEL,STATUS)

      CALL GCB_SETR('YLABEL_SIZE',TXTSCALE,STATUS)
      CALL GCB_SETC('YLABEL_TEXT','count s\u-1\d channel\u-1\d',
     :                                                  STATUS)

      IF (LOGAX) THEN
        CALL GCB_SETL('XAXIS_LOG',.TRUE.,STATUS)
        CALL GCB_SETL('YAXIS_LOG',.TRUE.,STATUS)
      ENDIF

*  title lines
      CALL GCB_SETI('TITLE_N',2,STATUS)
      CALL GCB_SET1C('TITLE_TEXT',1,2,TITLE,STATUS)
      CALL GCB_SET1R('TITLE_SIZE',1,1,TXTSCALE,STATUS)
      CALL GCB_SET1R('TITLE_SIZE',2,1,TXTSCALE,STATUS)
      CALL GCB_SET1C('TITLE_JUST',1,1,'L',STATUS)
      CALL GCB_SET1C('TITLE_JUST',2,1,'L',STATUS)


*  if several datasets to be overlayed on same axes need overall max/min
      IF (OVERLAY) THEN
        CALL GFX_DEF1DWNDV(NVAL,%val(PXPTR),%val(DDPTR),%val(DVPTR),
     :                                         XW1,XW2,YW1,YW2,STATUS)
        IF (IDS.EQ.1) THEN
          BXW1=XW1
          BXW2=XW2
          BYW1=YW1
          BYW2=YW2
        ELSE
          BXW1=MIN(XW1,BXW1)
          BXW2=MAX(XW2,BXW2)
          BYW1=MIN(YW1,BYW1)
          BYW2=MAX(YW2,BYW2)
        ENDIF
        IF (IDS.EQ.NDS) THEN
          CALL GCB_SETR('XAXIS_LO',BXW1,STATUS)
          CALL GCB_SETR('XAXIS_HI',BXW2,STATUS)
          CALL GCB_SETR('YAXIS_LO',BYW1,STATUS)
          CALL GCB_SETR('YAXIS_HI',BYW2,STATUS)
        ENDIF

*  set plotting symbol for each dataset
        ISYM=MOD(IDS,8)
        IF (ISYM.EQ.0) THEN
          ISYM=8
        ENDIF
        CALL GCB_SETL('POINT_FLAG',.TRUE.,STATUS)
        CALL GCB_SETI('POINT_SYMBOL',SYMBOL(ISYM),STATUS)
        CALL GCB_SETL('ERR_FLAG',.TRUE.,STATUS)

      ENDIF

      END




*+
      SUBROUTINE SPLOT_DPLOT_COPY(OLOC,IP,IG,IDS,SAVE,STATUS)
*    Description :
*    Type definitions :
      IMPLICIT NONE
*    Global constants :
      INCLUDE 'SAE_PAR'
      INCLUDE 'DAT_PAR'
      INCLUDE 'FIT_PAR'
*    Global variables :
        INCLUDE 'SPLOT_CMN'
*    Structure definitions :
*    Import :
      CHARACTER*(*) OLOC
      INTEGER IP,IG,IDS
      LOGICAL SAVE
*    Import-Export :
*    Export :
*    Status :
      INTEGER STATUS
*    Function declarations :
      INTEGER CHR_LEN
*    Local constants :
*    Local variables :
      CHARACTER*(DAT__SZLOC) NDFLOC
      CHARACTER*80 OVLY
      CHARACTER*80 UNITS
      INTEGER NDFS(NDSMAX)
      INTEGER PTR,XPTR,WPTR
      INTEGER I,L
*-

      IF (STATUS.NE.SAI__OK) RETURN

*  axis in channels or energy
      IF (EAXIS) THEN
        XPTR=PXPTR
        WPTR=PWPTR
      ELSE
        XPTR=DXPTR
        WPTR=DWPTR
      ENDIF


*  locate correct NDF and write index entry
      IF (SAVE) THEN
        CALL MSG_SETI('NDF',IG)
        CALL MSG_PRNT('  Writing channel space data to NDF ^NDF ...')
      ENDIF
      CALL GMD_LOCNDF(OLOC,IG,NDFLOC,STATUS)
      CALL GMD_PUTINDEX(OLOC,IG,
     :           'Channel/Data space - data',STATUS)


*  copy axis
      CALL BDA_CREAXES(NDFLOC,1,STATUS)
      CALL BDA_CREAXVAL(NDFLOC,1,.FALSE.,NVAL,STATUS)
      CALL BDA_MAPAXVAL(NDFLOC,'W',1,PTR,STATUS)
      CALL ARR_COP1R(NVAL,%val(XPTR),%val(PTR),STATUS)
      CALL BDA_CREAXWID(NDFLOC,1,.FALSE.,NVAL,STATUS)
      CALL BDA_MAPAXWID(NDFLOC,'W',1,PTR,STATUS)
      CALL ARR_COP1R(NVAL,%val(WPTR),%val(PTR),STATUS)

*  copy data
      CALL BDA_CREDATA(NDFLOC,1,NVAL,STATUS)
      CALL BDA_MAPDATA(NDFLOC,'W',PTR,STATUS)
      CALL ARR_COP1R(NVAL,%val(DDPTR),%val(PTR),STATUS)

*  copy labels
      CALL BDA_COPTEXT(DSLOC,NDFLOC,STATUS)
*  modify units to take account of normalisation
      CALL BDA_GETUNITS(NDFLOC,UNITS,STATUS)
      L=CHR_LEN(UNITS)+1
      UNITS(L:)='/channel'
      CALL BDA_PUTUNITS(NDFLOC,UNITS,STATUS)

*     variance (assume always there)
      CALL BDA_CREVAR(NDFLOC,1,NVAL,STATUS)
      CALL BDA_MAPVAR(NDFLOC,'W',PTR,STATUS)
      CALL ARR_COP1R(NVAL,%val(DVPTR),%val(PTR),STATUS)

*     quality if there
      IF (QOK) THEN
        CALL BDA_CREQUAL(NDFLOC,1,NVAL,STATUS)
        CALL BDA_MAPQUAL(NDFLOC,'W',PTR,STATUS)
        CALL ARR_COP1B(NVAL,%val(DQPTR),%val(PTR),STATUS)
        CALL BDA_PUTMASK(NDFLOC,MASK,STATUS)
      ENDIF

      IF (SAVE) THEN
        CALL BDA_COPMORE(DSLOC,NDFLOC,STATUS)
      ENDIF

      CALL GCB_SAVE(NDFLOC,STATUS)
      IF (SAVE) THEN
        CALL BDA_RELEASE(NDFLOC,STATUS)
      ENDIF
      CALL DAT_ANNUL(NDFLOC,STATUS)

*  cancel attributes that not relevant to other data
      CALL GCB_CANI('TITLE_N',STATUS)
      CALL GCB_CAN1R('TITLE_SIZE',1,2,STATUS)
      CALL GCB_CAN1C('TITLE_TEXT',1,2,STATUS)
      CALL GCB_CAN1C('TITLE_JUST',1,2,STATUS)
      CALL GCB_CANC('YLABEL_TEXT',STATUS)
      IF (OVERLAY) THEN
        CALL GCB_CANL('POINT_FLAG',STATUS)
        CALL GCB_CANI('POINT_SYMBOL',STATUS)
        CALL GCB_CANL('ERR_FLAG',STATUS)
        CALL GCB_CANR('XAXIS_LO',STATUS)
        CALL GCB_CANR('XAXIS_HI',STATUS)
        CALL GCB_CANR('YAXIS_LO',STATUS)
        CALL GCB_CANR('YAXIS_HI',STATUS)
      ENDIF

*   enter fit
      IF (SAVE) THEN
        CALL MSG_SETI('NDF',IG+1)
        CALL MSG_PRNT('  Writing channel space fit to NDF ^NDF ...')
      ENDIF
      CALL GMD_LOCNDF(OLOC,IG+1,NDFLOC,STATUS)
      CALL GMD_PUTINDEX(OLOC,IG+1,
     :            'Channel/Data space - fit',STATUS)
*   take axis values from main data
      CALL BDA_CREAXES(NDFLOC,1,STATUS)
      CALL BDA_CREAXVAL(NDFLOC,1,.FALSE.,NVAL,STATUS)
      CALL BDA_MAPAXVAL(NDFLOC,'W',1,PTR,STATUS)
      CALL ARR_COP1R(NVAL,%val(XPTR),%val(PTR),STATUS)
      CALL BDA_CREAXWID(NDFLOC,1,.FALSE.,NVAL,STATUS)
      CALL BDA_MAPAXWID(NDFLOC,'W',1,PTR,STATUS)
      CALL ARR_COP1R(NVAL,%val(WPTR),%val(PTR),STATUS)

*   take data values from fit
      CALL BDA_CREDATA(NDFLOC,1,NVAL,STATUS)
      CALL BDA_MAPDATA(NDFLOC,'W',PTR,STATUS)
      CALL ARR_COP1R(NVAL,%val(DFDPTR),%val(PTR),STATUS)

*   if single point then set marker to '*' for model point
      IF(NVAL.EQ.1)THEN
        CALL GCB_SETL('POINT_FLAG',.TRUE.,STATUS)
        CALL GCB_SETI('POINT_SYMBOL',3,STATUS)
      ENDIF

*  datasets overlayed - record NDF number
      IF (OVERLAY) THEN
        NDFS(IDS)=IG
*  last dataset - construct overlays
        IF (IDS.EQ.NDS) THEN
          OVLY=' '
          L=0
          DO I=1,NDS-1
            L=L+6
            WRITE(OVLY(L-5:L),'(2(I2,A1))') NDFS(I),',',NDFS(I)+1,','
          ENDDO
          L=L+1
          WRITE(OVLY(L:L+1),'(I2)') IG+1
          CALL GMD_SETPLOT(OLOC,IP,IG,OVLY,STATUS)
        ENDIF
      ELSE
*  set overlay
        WRITE(OVLY,'(I2)') IG+1
        CALL GMD_SETPLOT(OLOC,IP,IG,OVLY,STATUS)

      ENDIF


      CALL GCB_SAVE(NDFLOC,STATUS)
      IF (SAVE) THEN
        CALL BDA_RELEASE(NDFLOC,STATUS)
      ENDIF
      CALL DAT_ANNUL(NDFLOC,STATUS)

      CALL GCB_CANL('POINT_FLAG',STATUS)
      CALL GCB_CANI('POINT_SYMBOL',STATUS)
      CALL GCB_CANL('XAXIS_LOG',STATUS)
      CALL GCB_CANL('YAXIS_LOG',STATUS)
      CALL GCB_CANR('YAXIS_LO',STATUS)
      CALL GCB_CANR('YAXIS_HI',STATUS)


      END


*+
      SUBROUTINE SPLOT_DRPLOT_SETUP(IDS,NPZ,XMIN,XMAX,YMIN,YMAX,STATUS)
*    Description :
*    Type definitions :
      IMPLICIT NONE
*    Global constants :
      INCLUDE 'SAE_PAR'
      INCLUDE 'DAT_PAR'
      INCLUDE 'FIT_PAR'
*    Global variables :
        INCLUDE 'SPLOT_CMN'
*    Structure definitions :
*    Import :
      INTEGER IDS,NPZ
      REAL XMIN,XMAX,YMIN,YMAX
*    Import-Export :
*    Export :
*    Status :
      INTEGER STATUS
*    Function declarations :
*    Local constants :
      INTEGER SYMBOL(8)/17,13,16,18,4,7,6,12/
*    Local variables :
      CHARACTER*20 LABEL
      REAL X1,X2,Y1,Y2
      REAL TXTSCALE
      REAL XW1,XW2,YW1,YW2
      REAL BXW1,BXW2,BYW1,BYW2
      SAVE BXW1,BXW2,BYW1,BYW2
      INTEGER ISYM
*-

      IF (STATUS.NE.SAI__OK) RETURN



* calculate residuals
      CALL SPLOT_RESID(NVAL,%val(DDPTR),%val(DFDPTR),%val(DRDPTR),
     :                                                     STATUS)


*   set plot position
      X1=XMIN
      X2=XMAX
      Y1=YMIN
      Y2=YMAX
      IF(NPZ.EQ.2)THEN     		! Mode DR
        Y2=YMIN+0.33*(YMAX-YMIN)
      ELSEIF (NPZ.GT.2) THEN		! Mode DMR
        X2=0.5*(XMIN+XMAX)
        Y2=YMIN+0.33*(YMAX-YMIN)
      ENDIF
      TXTSCALE=MIN(0.8,2*(X2-X1))

*     now allow margin for labels & title
      X1=X1+3.0*TXTSCALE*0.025		! 3.0 char. heights
      Y1=Y1+3.0*TXTSCALE*0.025		! 3.0 char. heights
      Y2=Y2-2.5*TXTSCALE*0.025		! 2.5 char. heights

      CALL GCB_SETR('POS_X1',X1,STATUS)
      CALL GCB_SETR('POS_X2',X2,STATUS)
      CALL GCB_SETR('POS_Y1',Y1,STATUS)
      CALL GCB_SETR('POS_Y2',Y2,STATUS)

      CALL GCB_SETR('AXES_SIZE',TXTSCALE,STATUS)
*  axis labels
      CALL GCB_SETR('XLABEL_SIZE',TXTSCALE,STATUS)
      IF (EAXIS) THEN
        LABEL='Energy (keV)'
      ELSE
        LABEL='Channel no.'
      ENDIF
      CALL GCB_SETC('XLABEL_TEXT',LABEL,STATUS)
      CALL GCB_SETR('YLABEL_SIZE',TXTSCALE,STATUS)

      IF (LOGAX) THEN
        CALL GCB_SETL('XAXIS_LOG',.TRUE.,STATUS)
      ENDIF

      CALL GCB_SETI('TITLE_N',1,STATUS)
      CALL GCB_SET1C('TITLE_TEXT',1,1,'Residuals (data-model)',STATUS)
      CALL GCB_SET1R('TITLE_SIZE',1,1,TXTSCALE,STATUS)


*  if several datasets to be overlayed on same axes need overall max/min
      IF (OVERLAY) THEN
        CALL GFX_DEF1DWNDV(NVAL,%val(PXPTR),%val(DRDPTR),%val(DVPTR),
     :                                         XW1,XW2,YW1,YW2,STATUS)
        IF (IDS.EQ.1) THEN
          BXW1=XW1
          BXW2=XW2
          BYW1=YW1
          BYW2=YW2
        ELSE
          BXW1=MIN(XW1,BXW1)
          BXW2=MAX(XW2,BXW2)
          BYW1=MIN(YW1,BYW1)
          BYW2=MAX(YW2,BYW2)
        ENDIF
        IF (IDS.EQ.NDS) THEN
          CALL GCB_SETR('XAXIS_LO',BXW1,STATUS)
          CALL GCB_SETR('XAXIS_HI',BXW2,STATUS)
          CALL GCB_SETR('YAXIS_LO',BYW1,STATUS)
          CALL GCB_SETR('YAXIS_HI',BYW2,STATUS)
        ENDIF

*  set plotting symbol for each dataset
        ISYM=MOD(IDS,8)
        IF (ISYM.EQ.0) THEN
          ISYM=8
        ENDIF
        CALL GCB_SETL('POINT_FLAG',.TRUE.,STATUS)
        CALL GCB_SETI('POINT_SYMBOL',SYMBOL(ISYM),STATUS)
        CALL GCB_SETL('ERR_FLAG',.TRUE.,STATUS)

      ENDIF

      END





*+
      SUBROUTINE SPLOT_DRPLOT_COPY(OLOC,IP,IG,IDS,SAVE,STATUS)
*    Description :
*    Type definitions :
      IMPLICIT NONE
*    Global constants :
      INCLUDE 'SAE_PAR'
      INCLUDE 'DAT_PAR'
      INCLUDE 'FIT_PAR'
*    Global variables :
        INCLUDE 'SPLOT_CMN'
*    Structure definitions :
*    Import :
      CHARACTER*(*) OLOC
      INTEGER IP,IG,IDS
      LOGICAL SAVE
*    Import-Export :
*    Export :
*    Status :
      INTEGER STATUS
*    Function declarations :
*    Local constants :
*    Local variables :
      CHARACTER*(DAT__SZLOC) NDFLOC
      CHARACTER*80 OVLY
      INTEGER NDFS(NDSMAX)
      INTEGER XPTR,WPTR,PTR
      INTEGER I,L
*-

      IF (STATUS.NE.SAI__OK) RETURN

*  axis in channels or energy
      IF (EAXIS) THEN
        XPTR=PXPTR
        WPTR=PWPTR
      ELSE
        XPTR=DXPTR
        WPTR=DWPTR
      ENDIF

      IF (SAVE) THEN
        CALL MSG_SETI('NDF',IG)
        CALL MSG_PRNT(
     :           '  Writing channel space residuals to NDF ^NDF ...')
      ENDIF
      CALL GMD_LOCNDF(OLOC,IG,NDFLOC,STATUS)
      CALL GMD_PUTINDEX(OLOC,IG,'Channel/Data space - residuals',STATUS)

      CALL BDA_CREAXES(NDFLOC,1,STATUS)
      CALL BDA_CREAXVAL(NDFLOC,1,.FALSE.,NVAL,STATUS)
      CALL BDA_MAPAXVAL(NDFLOC,'W',1,PTR,STATUS)
      CALL ARR_COP1R(NVAL,%val(XPTR),%val(PTR),STATUS)
      CALL BDA_CREAXWID(NDFLOC,1,.FALSE.,NVAL,STATUS)
      CALL BDA_MAPAXWID(NDFLOC,'W',1,PTR,STATUS)
      CALL ARR_COP1R(NVAL,%val(WPTR),%val(PTR),STATUS)

      CALL BDA_CREDATA(NDFLOC,1,NVAL,STATUS)
      CALL BDA_MAPDATA(NDFLOC,'W',PTR,STATUS)
      CALL ARR_COP1R(NVAL,%val(DRDPTR),%val(PTR),STATUS)

*       variance (assume always there)
      CALL BDA_CREVAR(NDFLOC,1,NVAL,STATUS)
      CALL BDA_MAPVAR(NDFLOC,'W',PTR,STATUS)
      CALL ARR_COP1R(NVAL,%val(DVPTR),%val(PTR),STATUS)

*       quality if there
      IF (QOK) THEN
        CALL BDA_CREQUAL(NDFLOC,1,NVAL,STATUS)
        CALL BDA_MAPQUAL(NDFLOC,'W',PTR,STATUS)
        CALL ARR_COP1B(NVAL,%val(DQPTR),%val(PTR),STATUS)
        CALL BDA_PUTMASK(NDFLOC,MASK,STATUS)
      ENDIF

*   add title
      CALL BDA_PUTTITLE(NDFLOC,'Residuals (data-model)',STATUS)

*  datasets overlayed - record NDF number
      IF (OVERLAY) THEN
        NDFS(IDS)=IG
*  last dataset - construct overlays
        IF (IDS.EQ.NDS) THEN
          OVLY=' '
          L=0
          DO I=1,NDS-1
            L=L+3
            WRITE(OVLY(L-2:L),'(I2,A1)') NDFS(I),','
          ENDDO
          OVLY(L:L)=' '
          CALL GMD_SETPLOT(OLOC,IP,IG,OVLY,STATUS)
        ENDIF
      ELSE
        CALL GMD_SETPLOT(OLOC,IP,IG,' ',STATUS)
      ENDIF

      CALL GCB_SAVE(NDFLOC,STATUS)
      IF (SAVE) THEN
        CALL BDA_RELEASE(NDFLOC,STATUS)
      ENDIF
      CALL DAT_ANNUL(NDFLOC,STATUS)

      CALL GCB_CANL('XAXIS_LOG',STATUS)
      CALL GCB_CANL('YAXIS_LOG',STATUS)
      IF (OVERLAY) THEN
        CALL GCB_CANL('POINT_FLAG',STATUS)
        CALL GCB_CANI('POINT_SYMBOL',STATUS)
        CALL GCB_CANL('ERR_FLAG',STATUS)
        CALL GCB_CANR('XAXIS_LO',STATUS)
        CALL GCB_CANR('XAXIS_HI',STATUS)
        CALL GCB_CANR('YAXIS_LO',STATUS)
        CALL GCB_CANR('YAXIS_HI',STATUS)
      ENDIF


      END


*+
      SUBROUTINE SPLOT_PPLOT_SETUP(IDS,NPZ,XMIN,XMAX,YMIN,YMAX,
     :                                            TITLE,STATUS)
*    Description :
*    Type definitions :
      IMPLICIT NONE
*    Global constants :
      INCLUDE 'SAE_PAR'
      INCLUDE 'DAT_PAR'
      INCLUDE 'FIT_PAR'
*    Global variables :
      INCLUDE 'SPLOT_CMN'
*    Structure definitions :
*    Import :
      INTEGER IDS,NPZ
      REAL XMIN,XMAX,YMIN,YMAX
      CHARACTER*(*) TITLE(*)
*    Import-Export :
*    Export :
*    Status :
      INTEGER STATUS
*    Function declarations :
*    Local constants :
      INTEGER SYMBOL(8)/17,13,16,18,4,7,6,12/
*    Local variables :
      REAL X1,X2,Y1,Y2
      REAL TXTSCALE
      REAL XW1,XW2,YW1,YW2
      REAL BXW1,BXW2,BYW1,BYW2
      SAVE BXW1,BXW2,BYW1,BYW2
      INTEGER ISYM
      LOGICAL ERR
*-

      IF (STATUS.NE.SAI__OK) RETURN

      ERR=.TRUE.


*     set up log:log flag
      CALL GCB_SETL('XAXIS_LOG',.TRUE.,STATUS)
      CALL GCB_SETL('YAXIS_LOG',.TRUE.,STATUS)


*     set plot position
      X1=XMIN				! Mode P
      X2=XMAX
      Y1=YMIN
      Y2=YMAX
      IF(NPZ.EQ.2)THEN
        IF(DPLOT)THEN			! Mode CP
          Y1=0.5*(YMIN+YMAX)
        ELSE				! Mode PR
          Y1=YMIN+0.33*(YMAX-YMIN)
        ENDIF
      ELSEIF (NPZ.GT.2) THEN		! Mode CPR
        X1=0.5*(XMIN+XMAX)
        Y1=YMIN+0.33*(YMAX-YMIN)
      ENDIF
      TXTSCALE=MIN(0.8,2*(X2-X1))

*     now allow margin for labels & title
      X1=X1+3.0*TXTSCALE*0.025		! 3.0 char. heights
      Y1=Y1+3.0*TXTSCALE*0.025		! 3.0 char. heights
      Y2=Y2-2.5*TXTSCALE*0.025		! 2.5 char. heights

      CALL GCB_SETR('POS_X1',X1,STATUS)
      CALL GCB_SETR('POS_X2',X2,STATUS)
      CALL GCB_SETR('POS_Y1',Y1,STATUS)
      CALL GCB_SETR('POS_Y2',Y2,STATUS)
      CALL GCB_SETR('AXES_SIZE',TXTSCALE,STATUS)


      CALL GCB_SETC('XLABEL_TEXT','Energy (keV)',STATUS)
      CALL GCB_SETR('XLABEL_SIZE',TXTSCALE,STATUS)
      CALL GCB_SETC('YLABEL_TEXT',
     :            'photon cm\u-2\d s\u-1\d keV\u-1\d',STATUS)
      CALL GCB_SETR('YLABEL_SIZE',TXTSCALE,STATUS)

      CALL GCB_SET1C('TITLE_TEXT',1,2,TITLE,STATUS)
      CALL GCB_SETI('TITLE_N',2,STATUS)
      CALL GCB_SET1R('TITLE_SIZE',1,1,TXTSCALE,STATUS)
      CALL GCB_SET1R('TITLE_SIZE',2,1,TXTSCALE,STATUS)
      CALL GCB_SET1C('TITLE_JUST',1,1,'L',STATUS)
      CALL GCB_SET1C('TITLE_JUST',2,1,'L',STATUS)

*  if several datasets to be overlayed on same axes need overall max/min
      IF (OVERLAY) THEN
        CALL GFX_DEF1DWNDV(NVAL,%val(PXPTR),%val(PDPTR),%val(PVPTR),
     :                                         XW1,XW2,YW1,YW2,STATUS)
        IF (IDS.EQ.1) THEN
          BXW1=XW1
          BXW2=XW2
          BYW1=YW1
          BYW2=YW2
        ELSE
          BXW1=MIN(XW1,BXW1)
          BXW2=MAX(XW2,BXW2)
          BYW1=MIN(YW1,BYW1)
          BYW2=MAX(YW2,BYW2)
        ENDIF
        IF (IDS.EQ.NDS) THEN
          CALL GCB_SETR('XAXIS_LO',BXW1,STATUS)
          CALL GCB_SETR('XAXIS_HI',BXW2,STATUS)
          CALL GCB_SETR('YAXIS_LO',BYW1,STATUS)
          CALL GCB_SETR('YAXIS_HI',BYW2,STATUS)
        ENDIF

*  set plotting symbol for each dataset
        ISYM=MOD(IDS,8)
        IF (ISYM.EQ.0) THEN
          ISYM=8
        ENDIF
        CALL GCB_SETL('POINT_FLAG',.TRUE.,STATUS)
        CALL GCB_SETI('POINT_SYMBOL',SYMBOL(ISYM),STATUS)
        CALL GCB_SETL('ERR_FLAG',.TRUE.,STATUS)

      ENDIF


      END




*+
      SUBROUTINE SPLOT_PPLOT_COPY(OLOC,IP,IG,IDS,SAVE,STATUS)
*    Description :
*    Type definitions :
      IMPLICIT NONE
*    Global constants :
      INCLUDE 'SAE_PAR'
      INCLUDE 'DAT_PAR'
      INCLUDE 'FIT_PAR'
*    Global variables :
        INCLUDE 'SPLOT_CMN'
*    Structure definitions :
*    Import :
      CHARACTER*(*) OLOC
      INTEGER IP,IG,IDS
      LOGICAL SAVE
*    Import-Export :
*    Export :
*    Status :
      INTEGER STATUS
*    Function declarations :
*    Local constants :
*    Local variables :
      CHARACTER*(DAT__SZLOC) NDFLOC
      CHARACTER*80 LABEL
      CHARACTER*80 OVLY
      INTEGER NDFS(NDSMAX)
      INTEGER PTR
      INTEGER I,L
*-

      IF (STATUS.NE.SAI__OK) RETURN

*  Model space data (i.e. transformed back using fitted model)
      IF (SAVE) THEN
        CALL MSG_SETI('NDF',IG)
        CALL MSG_PRNT('  Writing photon space data to NDF ^NDF ...')
      ENDIF
      CALL GMD_LOCNDF(OLOC,IG,NDFLOC,STATUS)
      CALL GMD_PUTINDEX(OLOC,IG,
     :             'Photon space - data',STATUS)

*  create data & variance
      CALL BDA_CREDATA(NDFLOC,1,NVAL,STATUS)
      CALL BDA_MAPDATA(NDFLOC,'W',PTR,STATUS)
      CALL ARR_COP1R(NVAL,%val(PDPTR),%val(PTR),STATUS)
      CALL BDA_CREVAR(NDFLOC,1,NVAL,STATUS)
      CALL BDA_MAPVAR(NDFLOC,'W',PTR,STATUS)
      CALL ARR_COP1R(NVAL,%val(PVPTR),%val(PTR),STATUS)

*  quality if there
      IF (QOK) THEN
        CALL BDA_CREQUAL(NDFLOC,1,NVAL,STATUS)
        CALL BDA_MAPQUAL(NDFLOC,'W',PTR,STATUS)
        CALL ARR_COP1B(NVAL,%val(DQPTR),%val(PTR),STATUS)
        CALL BDA_PUTMASK(NDFLOC,MASK,STATUS)
      ENDIF

*       create non-regular axis array of correct size
      CALL BDA_CREAXES(NDFLOC,1,STATUS)
      CALL BDA_CREAXVAL(NDFLOC,1,.FALSE.,NVAL,STATUS)
      CALL BDA_MAPAXVAL(NDFLOC,'W',1,PTR,STATUS)
      CALL ARR_COP1R(NVAL,%val(PXPTR),%val(PTR),STATUS)
      CALL BDA_CREAXWID(NDFLOC,1,.FALSE.,NVAL,STATUS)
      CALL BDA_MAPAXWID(NDFLOC,'W',1,PTR,STATUS)
      CALL ARR_COP1R(NVAL,%val(PWPTR),%val(PTR),STATUS)

      CALL BDA_GETLABEL(DSLOC,LABEL,STATUS)
      IF(LABEL.NE.' ')THEN
        CALL BDA_PUTLABEL(NDFLOC,LABEL,STATUS)
      ENDIF
      CALL BDA_PUTUNITS(NDFLOC,'photon/(cm**2*sec*keV)',STATUS)

      CALL BDA_PUTAXLABEL(NDFLOC,1,'Energy',STATUS)
      CALL BDA_PUTAXUNITS(NDFLOC,1,'keV',STATUS)


      CALL GCB_SAVE(NDFLOC,STATUS)
      IF (SAVE) THEN
        CALL BDA_RELEASE(NDFLOC,STATUS)
      ENDIF
      CALL DAT_ANNUL(NDFLOC,STATUS)

      CALL GCB_CANI('TITLE_N',STATUS)
      CALL GCB_CAN1R('TITLE_SIZE',1,2,STATUS)
      CALL GCB_CAN1C('TITLE_TEXT',1,2,STATUS)
      CALL GCB_CAN1C('TITLE_JUST',1,2,STATUS)
      CALL GCB_CANC('YLABEL_TEXT',STATUS)
      CALL GCB_CANR('YAXIS_LO',STATUS)
      CALL GCB_CANR('YAXIS_HI',STATUS)
      IF (OVERLAY) THEN
        CALL GCB_CANL('POINT_FLAG',STATUS)
        CALL GCB_CANI('POINT_SYMBOL',STATUS)
        CALL GCB_CANL('ERR_FLAG',STATUS)
        CALL GCB_CANR('XAXIS_LO',STATUS)
        CALL GCB_CANR('XAXIS_HI',STATUS)
        CALL GCB_CANR('YAXIS_LO',STATUS)
        CALL GCB_CANR('YAXIS_HI',STATUS)
      ENDIF



*   Model space fit (for overlay)
      IF (SAVE) THEN
        CALL MSG_SETI('NDF',IG+1)
        CALL MSG_PRNT('  Writing photon space fit to NDF ^NDF ...')
      ENDIF
      CALL GMD_LOCNDF(OLOC,IG+1,NDFLOC,STATUS)
      CALL GMD_PUTINDEX(OLOC,IG+1,
     :            'Photon space - fit',STATUS)
      CALL BDA_CREDATA(NDFLOC,1,NFIT,STATUS)
      CALL BDA_MAPDATA(NDFLOC,'W',PTR,STATUS)
      CALL ARR_COP1R(NFIT,%val(PFDPTR),%val(PTR),STATUS)

*       energy axis
      CALL BDA_CREAXVAL(NDFLOC,1,.FALSE.,NFIT,STATUS)
      CALL BDA_MAPAXVAL(NDFLOC,'W',1,PTR,STATUS)
      CALL ARR_COP1R(NFIT,%val(PFXPTR),%val(PTR),STATUS)
      CALL BDA_PUTAXLABEL(NDFLOC,1,'Energy',STATUS)
      CALL BDA_PUTAXUNITS(NDFLOC,1,'keV',STATUS)

      CALL GCB_SAVE(NDFLOC,STATUS)
      IF (SAVE) THEN
        CALL BDA_RELEASE(NDFLOC,STATUS)
      ENDIF
      CALL DAT_ANNUL(NDFLOC,STATUS)


*  datasets overlayed - record NDF number
      IF (OVERLAY) THEN
        NDFS(IDS)=IG
*  last dataset - construct overlays
        IF (IDS.EQ.NDS) THEN
          OVLY=' '
          L=0
          DO I=1,NDS-1
            L=L+6
            WRITE(OVLY(L-5:L),'(2(I2,A1))') NDFS(I),',',NDFS(I)+1,','
          ENDDO
          L=L+1
          WRITE(OVLY(L:L+1),'(I2)') IG+1
          CALL GMD_SETPLOT(OLOC,IP,IG,OVLY,STATUS)
        ENDIF
      ELSE
*     set overlay
        WRITE(OVLY,'(I2)') IG+1
        CALL GMD_SETPLOT(OLOC,IP,IG,OVLY,STATUS)
      ENDIF

      CALL GCB_CANL('XAXIS_LOG',STATUS)
      CALL GCB_CANL('YAXIS_LOG',STATUS)


      END


*+
      SUBROUTINE SPLOT_PRPLOT_SETUP(IDS,NPZ,XMIN,XMAX,YMIN,YMAX,STATUS)
*    Description :
*    Type definitions :
      IMPLICIT NONE
*    Global constants :
      INCLUDE 'SAE_PAR'
      INCLUDE 'DAT_PAR'
      INCLUDE 'QUAL_PAR'
      INCLUDE 'FIT_PAR'
*    Global variables :
        INCLUDE 'SPLOT_CMN'
*    Structure definitions :
*    Import :
      INTEGER IDS,NPZ
      REAL XMIN,XMAX,YMIN,YMAX
*    Import-Export :
*    Export :
*    Status :
      INTEGER STATUS
*    Function declarations :
*    Local constants :
      INTEGER SYMBOL(8)/17,13,16,18,4,7,6,12/
*    Local variables :
      REAL X1,X2,Y1,Y2
      REAL TXTSCALE
      REAL XW1,XW2,YW1,YW2
      REAL BXW1,BXW2,BYW1,BYW2
      SAVE BXW1,BXW2,BYW1,BYW2
      INTEGER ISYM
*-

      IF (STATUS.NE.SAI__OK) RETURN

      IF (QOK) THEN
        CALL ARR_COP1B(NVAL,%val(DQPTR),%val(PRQPTR),STATUS)
      ELSE
        CALL ARR_INIT1B(QUAL__GOOD,NVAL,%val(PRQPTR),STATUS)
      ENDIF


* subtract fit from data values & divide by sqrt(variance)
      CALL SPLOT_MODRES(NVAL,%val(PDPTR),%val(PIDPTR),
     :                           %val(PVPTR),%val(PRDPTR),
     :                               %val(PRVPTR),%val(PRQPTR),
     :                                                  STATUS)



*     set plot position
      IF(NPZ.EQ.2)THEN			! Mode MR
        X1=XMIN
        X2=XMAX
        Y1=YMIN
        Y2=YMIN+0.33*(YMAX-YMIN)
      ELSE				! Mode DMR
        X1=0.5*(XMIN+XMAX)
        X2=XMAX
        Y1=YMIN
        Y2=YMIN+0.33*(YMAX-YMIN)
      ENDIF
      TXTSCALE=MIN(0.8,2*(X2-X1))

*     now allow margin for labels & title
      X1=X1+3.0*TXTSCALE*0.025		! 3.0 char. heights
      Y1=Y1+3.0*TXTSCALE*0.025		! 3.0 char. heights
      Y2=Y2-2.5*TXTSCALE*0.025		! 2.5 char. heights

      CALL GCB_SETR('POS_X1',X1,STATUS)
      CALL GCB_SETR('POS_X2',X2,STATUS)
      CALL GCB_SETR('POS_Y1',Y1,STATUS)
      CALL GCB_SETR('POS_Y2',Y2,STATUS)
      CALL GCB_SETR('AXES_SIZE',TXTSCALE,STATUS)
      CALL GCB_SETR('XLABEL_SIZE',TXTSCALE,STATUS)
      CALL GCB_SETC('XLABEL_TEXT','Energy (keV)',STATUS)
      CALL GCB_SETR('YLABEL_SIZE',TXTSCALE,STATUS)
      CALL GCB_SETC('YLABEL_TEXT','Significance',STATUS)
      CALL GCB_SET1C('TITLE_TEXT',1,1,
     :           'Normalised residuals (data-model)/sigma',STATUS)
      CALL GCB_SET1R('TITLE_SIZE',1,1,TXTSCALE,STATUS)
      CALL GCB_SETI('TITLE_N',1,STATUS)

      CALL GCB_SETL('XAXIS_LOG',.TRUE.,STATUS)
      CALL GCB_SETL('YAXIS_LOG',.FALSE.,STATUS)

*  if several datasets to be overlayed on same axes need overall max/min
      IF (OVERLAY) THEN
        CALL GFX_DEF1DWNDV(NVAL,%val(PXPTR),%val(PRDPTR),%val(PRVPTR),
     :                                         XW1,XW2,YW1,YW2,STATUS)
        IF (IDS.EQ.1) THEN
          BXW1=XW1
          BXW2=XW2
          BYW1=YW1
          BYW2=YW2
        ELSE
          BXW1=MIN(XW1,BXW1)
          BXW2=MAX(XW2,BXW2)
          BYW1=MIN(YW1,BYW1)
          BYW2=MAX(YW2,BYW2)
        ENDIF
        IF (IDS.EQ.NDS) THEN
          CALL GCB_SETR('XAXIS_LO',BXW1,STATUS)
          CALL GCB_SETR('XAXIS_HI',BXW2,STATUS)
          CALL GCB_SETR('YAXIS_LO',BYW1,STATUS)
          CALL GCB_SETR('YAXIS_HI',BYW2,STATUS)
        ENDIF

*  set plotting symbol for each dataset
        ISYM=MOD(IDS,8)
        IF (ISYM.EQ.0) THEN
          ISYM=8
        ENDIF
        CALL GCB_SETL('POINT_FLAG',.TRUE.,STATUS)
        CALL GCB_SETI('POINT_SYMBOL',SYMBOL(ISYM),STATUS)
        CALL GCB_SETL('ERR_FLAG',.TRUE.,STATUS)

      ENDIF


      END


*+
      SUBROUTINE SPLOT_PRPLOT_COPY(OLOC,IP,IG,IDS,SAVE,STATUS)
*    Description :
*    Type definitions :
      IMPLICIT NONE
*    Global constants :
      INCLUDE 'SAE_PAR'
      INCLUDE 'DAT_PAR'
      INCLUDE 'FIT_PAR'
*    Global variables :
        INCLUDE 'SPLOT_CMN'
*    Structure definitions :
*    Import :
      CHARACTER*(*) OLOC
      INTEGER IP,IG,IDS
      LOGICAL SAVE
*    Import-Export :
*    Export :
*    Status :
      INTEGER STATUS
*    Function declarations :
*    Local constants :
*    Local variables :
      CHARACTER*(DAT__SZLOC) NDFLOC
      CHARACTER*80 OVLY
      INTEGER NDFS(NDSMAX)
      INTEGER PTR
      INTEGER I,L
*-

      IF (STATUS.NE.SAI__OK) RETURN

      IF (SAVE) THEN
        CALL MSG_SETI('NDF',IG)
        CALL MSG_PRNT(
     :       '  Writing photon space residuals to NDF ^NDF ...')
      ENDIF
      CALL GMD_LOCNDF(OLOC,IG,NDFLOC,STATUS)
      CALL GMD_PUTINDEX(OLOC,IG,
     :             'Photon space - residuals',STATUS)

      CALL BDA_CREDATA(NDFLOC,1,NVAL,STATUS)
      CALL BDA_MAPDATA(NDFLOC,'W',PTR,STATUS)
      CALL ARR_COP1R(NVAL,%val(PRDPTR),%val(PTR),STATUS)

      CALL BDA_PUTTITLE(NDFLOC,
     :        'Normalised residuals (data-model)/sigma',STATUS)
      CALL BDA_PUTLABEL(NDFLOC,'Significance',STATUS)

      CALL BDA_CREVAR(NDFLOC,1,NVAL,STATUS)
      CALL BDA_MAPVAR(NDFLOC,'W',PTR,STATUS)
      CALL ARR_COP1R(NVAL,%val(PRVPTR),%val(PTR),STATUS)

      CALL BDA_CREQUAL(NDFLOC,1,NVAL,STATUS)
      CALL BDA_MAPQUAL(NDFLOC,'W',PTR,STATUS)
      CALL ARR_COP1B(NVAL,%val(PRQPTR),%val(PTR),STATUS)
      CALL BDA_PUTMASK(NDFLOC,MASK,STATUS)

      CALL BDA_CREAXES(NDFLOC,1,STATUS)
      CALL BDA_CREAXVAL(NDFLOC,1,.FALSE.,NVAL,STATUS)
      CALL BDA_MAPAXVAL(NDFLOC,'W',1,PTR,STATUS)
      CALL ARR_COP1R(NVAL,%val(PXPTR),%val(PTR),STATUS)

      CALL BDA_CREAXWID(NDFLOC,1,.FALSE.,NVAL,STATUS)
      CALL BDA_MAPAXWID(NDFLOC,'W',1,PTR,STATUS)
      CALL ARR_COP1R(NVAL,%val(PWPTR),%val(PTR),STATUS)

      CALL BDA_PUTAXLABEL(NDFLOC,1,'Energy',STATUS)
      CALL BDA_PUTAXUNITS(NDFLOC,1,'keV',STATUS)


*  datasets overlayed - record NDF number
      IF (OVERLAY) THEN
        NDFS(IDS)=IG
*  last dataset - construct overlays
        IF (IDS.EQ.NDS) THEN
          OVLY=' '
          L=0
          DO I=1,NDS-1
            L=L+3
            WRITE(OVLY(L-2:L),'(I2,A1)') NDFS(I),','
          ENDDO
          OVLY(L:L)=' '
          CALL GMD_SETPLOT(OLOC,IP,IG,OVLY,STATUS)
        ENDIF
      ELSE
        CALL GMD_SETPLOT(OLOC,IP,IG,' ',STATUS)
      ENDIF

      CALL GCB_SAVE(NDFLOC,STATUS)
      IF (SAVE) THEN
        CALL BDA_RELEASE(NDFLOC,STATUS)
      ENDIF
      CALL DAT_ANNUL(NDFLOC,STATUS)

      CALL GCB_CANI('TITLE_N',STATUS)
      CALL GCB_CAN1R('TITLE_SIZE',1,2,STATUS)
      CALL GCB_CAN1C('TITLE_TEXT',1,2,STATUS)
      CALL GCB_CANL('XAXIS_LOG',STATUS)
      CALL GCB_CANL('YAXIS_LOG',STATUS)
      IF (OVERLAY) THEN
        CALL GCB_CANL('POINT_FLAG',STATUS)
        CALL GCB_CANI('POINT_SYMBOL',STATUS)
        CALL GCB_CANL('ERR_FLAG',STATUS)
        CALL GCB_CANR('XAXIS_LO',STATUS)
        CALL GCB_CANR('XAXIS_HI',STATUS)
        CALL GCB_CANR('YAXIS_LO',STATUS)
        CALL GCB_CANR('YAXIS_HI',STATUS)
      ENDIF


      END



*+
      SUBROUTINE SPLOT_MPLOT_SETUP(NCHAN,NTERM,MODSPEC,COMPSPEC,STATUS)
*    Description :
*    Type definitions :
      IMPLICIT NONE
*    Global constants :
      INCLUDE 'SAE_PAR'
      INCLUDE 'DAT_PAR'
      INCLUDE 'FIT_PAR'
*    Global variables :
*    Structure definitions :
*    Import :
      INTEGER NCHAN,NTERM
      CHARACTER*(*) MODSPEC,COMPSPEC(*)
*    Import-Export :
*    Export :
*    Status :
      INTEGER STATUS
*    Function declarations :
*    Global variables :
      INCLUDE 'SPLOT_CMN'
*    Local constants :
*    Local variables :
      CHARACTER*80 TEXT
      REAL TXTSCALE
      REAL X1,X2,Y1,Y2
      REAL XW1,XW2,YW1,YW2
      REAL XRAN,YRAN
      REAL XL,YL,XT,YT,XTL,YTL
      REAL XDISP,YSTEP
      INTEGER I
      INTEGER STYLE
*-

      IF (STATUS.NE.SAI__OK) RETURN


*   set plot position and text size
      X1=0.0
      X2=0.99
      Y1=0.0
      Y2=0.99

      TXTSCALE=MIN(0.8,2*(X2-X1))

*     now allow margin for labels & title
      X1=X1+3.0*TXTSCALE*0.025		! 3.0 char. heights
      Y1=Y1+3.0*TXTSCALE*0.025		! 3.0 char. heights
      Y2=Y2-2.5*TXTSCALE*0.025		! 2.5 char. heights

*  viewport position
      CALL GCB_SETR('POS_X1',X1,STATUS)
      CALL GCB_SETR('POS_X2',X2,STATUS)
      CALL GCB_SETR('POS_Y1',Y1,STATUS)
      CALL GCB_SETR('POS_Y2',Y2,STATUS)

      IF (LOGAX) THEN
        CALL GCB_SETL('XAXIS_LOG',.TRUE.,STATUS)
        CALL GCB_SETL('YAXIS_LOG',.TRUE.,STATUS)
      ENDIF

*  get axis limits for key
      CALL GFX_DEF1DWND(NCHAN,%val(MCXPTR),%val(MTDPTR),
     :                             XW1,XW2,YW1,YW2,STATUS)

*  get positions for key
      XRAN=XW2-XW1
      YRAN=YW2-YW1
      XDISP=0.1*XRAN
      XL=XW1+0.8*XRAN
      YL=YW1+0.9*YRAN
      XT=XW1+0.91*XRAN
      YT=YL-0.5*TXTSCALE*0.025*YRAN
      YSTEP=0.05*YRAN

      CALL GCB_SETI('SHAPE_N',NTERM+1,STATUS)
      CALL GCB_SET1C('SHAPE_TYPE',1,1,'VECTOR',STATUS)
      CALL GCB_SET1R('SHAPE_DATA1',1,1,XDISP,STATUS)
      CALL GCB_SET1R('SHAPE_DATA2',1,1,0.0,STATUS)
      CALL GCB_SET1R('SHAPE_X',1,1,XL,STATUS)
      CALL GCB_SET1R('SHAPE_Y',1,1,YL,STATUS)
      CALL GCB_SETI('NOTE_N',NTERM+1,STATUS)
      IF (LOGAX) THEN
        XTL=10.0**XT
        YTL=10.0**YT
        CALL GCB_SET1R('NOTE_X',1,1,XTL,STATUS)
        CALL GCB_SET1R('NOTE_Y',1,1,YTL,STATUS)
      ELSE
        CALL GCB_SET1R('NOTE_X',1,1,XT,STATUS)
        CALL GCB_SET1R('NOTE_Y',1,1,YT,STATUS)
      ENDIF
      CALL GCB_SET1C('NOTE_TEXT',1,1,'Total',STATUS)
      CALL GCB_SET1R('NOTE_SIZE',1,1,TXTSCALE,STATUS)
      STYLE=0
      DO I=1,NTERM
        STYLE=STYLE+1
        STYLE=STYLE/5 + MOD(STYLE,5) + 1
        CALL GCB_SET1C('SHAPE_TYPE',I+1,1,'VECTOR',STATUS)
        CALL GCB_SET1R('SHAPE_DATA1',I+1,1,XDISP,STATUS)
        CALL GCB_SET1R('SHAPE_DATA2',I+1,1,0.0,STATUS)
        CALL GCB_SET1I('SHAPE_STYLE',I+1,1,STYLE,STATUS)
        CALL GCB_SET1R('SHAPE_X',I+1,1,XL,STATUS)
        YL=YL-YSTEP
        CALL GCB_SET1R('SHAPE_Y',I+1,1,YL,STATUS)
        CALL GCB_SET1C('NOTE_TEXT',I+1,1,COMPSPEC(I),STATUS)
        CALL GCB_SET1R('NOTE_SIZE',I+1,1,TXTSCALE,STATUS)
        YT=YT-YSTEP
        IF (LOGAX) THEN
          YTL=10.0**YT
          CALL GCB_SET1R('NOTE_X',I+1,1,XTL,STATUS)
          CALL GCB_SET1R('NOTE_Y',I+1,1,YTL,STATUS)
        ELSE
          CALL GCB_SET1R('NOTE_X',I+1,1,XT,STATUS)
          CALL GCB_SET1R('NOTE_Y',I+1,1,YT,STATUS)
        ENDIF
      ENDDO


*  numeric label character size
      CALL GCB_SETR('AXES_SIZE',TXTSCALE,STATUS)

*  axis labels
      CALL GCB_SETR('XLABEL_SIZE',TXTSCALE,STATUS)
      TEXT='Energy (keV)'
      CALL GCB_SETC('XLABEL_TEXT',TEXT,STATUS)

      CALL GCB_SETR('YLABEL_SIZE',TXTSCALE,STATUS)
      TEXT='photon s\u-1\d cm\u-2\d keV\u-1\d'
      CALL GCB_SETC('YLABEL_TEXT',TEXT,STATUS)


*  title lines
      CALL GCB_SETI('TITLE_N',1,STATUS)
      TEXT='Additive components for model: '//MODSPEC
      CALL GCB_SET1C('TITLE_TEXT',1,1,TEXT,STATUS)
      CALL GCB_SET1R('TITLE_SIZE',1,1,TXTSCALE,STATUS)
      CALL GCB_SET1C('TITLE_JUST',1,1,'L',STATUS)


      END





*+
      SUBROUTINE SPLOT_MPLOT_COPY(OLOC,NCHAN,NTERM,COMPSPEC,SAVE,STATUS)
*    Description :
*    Type definitions :
      IMPLICIT NONE
*    Global constants :
      INCLUDE 'SAE_PAR'
      INCLUDE 'DAT_PAR'
      INCLUDE 'FIT_PAR'
*    Global variables :
        INCLUDE 'SPLOT_CMN'
*    Structure definitions :
*    Import :
      CHARACTER*(*) OLOC
      INTEGER NCHAN,NTERM
      CHARACTER*(*) COMPSPEC(*)
      LOGICAL SAVE
*    Import-Export :
*    Export :
*    Status :
      INTEGER STATUS
*    Function declarations :
*    Local constants :
*    Local variables :
      CHARACTER*(DAT__SZLOC) NDFLOC
      CHARACTER*80 OVLY
      INTEGER PTR
      INTEGER IG
      INTEGER I
      INTEGER STYLE
      INTEGER L
*-

      IF (STATUS.NE.SAI__OK) RETURN

      IG=1
*  locate correct NDF and write index entry
      IF (SAVE) THEN
        CALL MSG_SETI('NDF',IG)
        CALL MSG_PRNT('  Writing total model to NDF ^NDF ...')
      ENDIF
      CALL GMD_LOCNDF(OLOC,IG,NDFLOC,STATUS)
      CALL GMD_PUTINDEX(OLOC,IG,'Total model',STATUS)

*  copy axis
      CALL BDA_CREAXES(NDFLOC,1,STATUS)
      CALL BDA_CREAXVAL(NDFLOC,1,.FALSE.,NCHAN,STATUS)
      CALL BDA_MAPAXVAL(NDFLOC,'W',1,PTR,STATUS)
      CALL ARR_COP1R(NCHAN,%val(MCXPTR),%val(PTR),STATUS)

*  copy data
      CALL BDA_CREDATA(NDFLOC,1,NCHAN,STATUS)
      CALL BDA_MAPDATA(NDFLOC,'W',PTR,STATUS)
      CALL ARR_COP1R(NCHAN,%val(MTDPTR),%val(PTR),STATUS)


      CALL GCB_SAVE(NDFLOC,STATUS)
      IF (SAVE) THEN
        CALL BDA_RELEASE(NDFLOC,STATUS)
      ENDIF
      CALL DAT_ANNUL(NDFLOC,STATUS)

      L=1
      DO I=1,NTERM
        IG=IG+1
        IF (SAVE) THEN
          CALL MSG_SETI('NDF',IG)
          CALL MSG_SETC('CMP',COMPSPEC(I))
          CALL MSG_PRNT('  Writing component ^CMP to NDF ^NDF ...')
        ENDIF
        CALL GMD_LOCNDF(OLOC,IG,NDFLOC,STATUS)
        CALL GMD_PUTINDEX(OLOC,IG,COMPSPEC(I),STATUS)
        STYLE=STYLE+1
        STYLE=STYLE/5 + MOD(STYLE,5) + 1
        CALL GCB_SETI('POLY_STYLE',STYLE,STATUS)

*  copy axis
        CALL BDA_CREAXES(NDFLOC,1,STATUS)
        CALL BDA_CREAXVAL(NDFLOC,1,.FALSE.,NCHAN,STATUS)
        CALL BDA_MAPAXVAL(NDFLOC,'W',1,PTR,STATUS)
        CALL ARR_COP1R(NCHAN,%val(MCXPTR),%val(PTR),STATUS)

*  copy data
        CALL BDA_CREDATA(NDFLOC,1,NCHAN,STATUS)
        CALL BDA_MAPDATA(NDFLOC,'W',PTR,STATUS)
        CALL ARR_COP1R(NCHAN,%val(MCDPTR(I)),%val(PTR),STATUS)


        CALL GCB_SAVE(NDFLOC,STATUS)
        IF (SAVE) THEN
          CALL BDA_RELEASE(NDFLOC,STATUS)
        ENDIF
        CALL DAT_ANNUL(NDFLOC,STATUS)

        WRITE(OVLY(L:),'(I2)') IG
        IF (I.LT.NTERM) THEN
          L=L+2
          OVLY(L:L)=','
          L=L+1
        ENDIF


      ENDDO


*  cancel attributes that not relevant to other data
      CALL GCB_CANI('SHAPE_N',STATUS)
      CALL GCB_CANI('NOTE_N',STATUS)
      CALL GCB_CAN1C('SHAPE_TYPE',1,NTERM+1,STATUS)
      CALL GCB_CAN1R('SHAPE_X',1,NTERM+1,STATUS)
      CALL GCB_CAN1R('SHAPE_Y',1,NTERM+1,STATUS)
      CALL GCB_CAN1R('SHAPE_DATA1',1,NTERM+1,STATUS)
      CALL GCB_CAN1R('SHAPE_DATA2',1,NTERM+1,STATUS)
      CALL GCB_CAN1I('SHAPE_STYLE',1,NTERM+1,STATUS)
      CALL GCB_CAN1C('NOTE_TEXT',1,NTERM+1,STATUS)
      CALL GCB_CAN1R('NOTE_X',1,NTERM+1,STATUS)
      CALL GCB_CAN1R('NOTE_Y',1,NTERM+1,STATUS)
      CALL GCB_CANI('POLY_STYLE',STATUS)
      CALL GCB_CANI('TITLE_N',STATUS)
      CALL GCB_CAN1R('TITLE_SIZE',1,1,STATUS)
      CALL GCB_CAN1C('TITLE_TEXT',1,1,STATUS)
      CALL GCB_CAN1C('TITLE_JUST',1,1,STATUS)
      CALL GCB_CANC('YLABEL_TEXT',STATUS)
      CALL GCB_CANL('XAXIS_LOG',STATUS)
      CALL GCB_CANL('YAXIS_LOG',STATUS)
      CALL GCB_CANR('YAXIS_LO',STATUS)
      CALL GCB_CANR('YAXIS_HI',STATUS)

*   set overlay
      CALL GMD_SETPLOT(OLOC,1,1,OVLY,STATUS)


      END



*+
      SUBROUTINE SPLOT_MPLOT_ADDCOMP(NCHAN,COMP,TOT,STATUS)
*    Description :
*    Type definitions :
      IMPLICIT NONE
*    Global constants :
      INCLUDE 'SAE_PAR'
      INCLUDE 'DAT_PAR'
*    Global variables :
*    Structure definitions :
*    Import :
      INTEGER NCHAN
      REAL COMP(*)
*    Import-Export :
*    Export :
      REAL TOT(*)
*    Status :
      INTEGER STATUS
*    Function declarations :
*    Local constants :
*    Local variables :
      INTEGER I
*-

      IF (STATUS.EQ.SAI__OK) THEN

        DO I=1,NCHAN
          TOT(I)=TOT(I)+COMP(I)
        ENDDO

      ENDIF


      END



*+
      SUBROUTINE SPLOT_MPLOT_EAXIS(NCHAN,EL,EU,ELB,EUB,X,STATUS)
*    Description :
*    Type definitions :
      IMPLICIT NONE
*    Global constants :
      INCLUDE 'SAE_PAR'
      INCLUDE 'DAT_PAR'
*    Import :
      INTEGER NCHAN
      REAL EL,EU
*    Import-Export :
*    Export :
      REAL ELB(*),EUB(*)
      REAL X(*)
*    Status :
      INTEGER STATUS
*    Function declarations :
*    Local constants :
*    Local variables :
      REAL WID,HWID
      INTEGER ICHAN
*-

      IF (STATUS.EQ.SAI__OK) THEN

        WID=(EU-EL)/REAL(NCHAN)
        HWID=WID/2.0

        ELB(1)=EL
        EUB(1)=EL+WID
        X(1)=EL+HWID
        DO ICHAN=2,NCHAN
          ELB(ICHAN)=ELB(ICHAN-1)+WID
          EUB(ICHAN)=ELB(ICHAN)+WID
          X(ICHAN)=ELB(ICHAN)+HWID
        ENDDO

      ENDIF


      END
