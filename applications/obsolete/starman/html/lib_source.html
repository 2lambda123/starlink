<HTML><HEAD>
<TITLE> Source Code for
LIB
</TITLE>
</HEAD> <BODY>

<h1> Source Code for
LIB
</h1>

All rights reserved. &copy 1995 RAL. <i>Starlink</i> disclaimers and
conditions apply. <br>
<hr>

Go to the Starman <a href="source_top.html#lib_source_back"> Source Code </a> Page at the pointer to this page.
<hr>
Starman general purpose subroutines called by this program
can be found via the subroutine libraries and general
include files, pointed to at the top of the
<a href="source_top.html"> Source Code page. </a>
<hr>
Any include files are the end of the page. <p>
Subroutines for this program:- <p>

<a href="#bell">
bell  </a>  Sound the terminal bell       <br>
<a href="#charln">
charln  </a>  Position of last non-blank character in a character string       <br>
<a href="#endstrip">
endstrip  </a>  Return start and end of non-blank string in a string       <br>
<a href="#findhead">
findhead  </a>  Find column header with a character string       <br>
<a href="#gettheh">
gettheh  </a>  Get header order in the input list       <br>
<a href="#gthead">
gthead  </a>  Get a character string from a file column header       <br>
<a href="#ident">
ident  </a>  Fill identifier columns of a table with #1 - #n       <br>
<a href="#lbgone">
lbgone  </a>  Remove leading blanks from a character string       <br>
<a href="#lens">
lens  </a>  (FN) Find position of last non-blank character in a string       <br>
<a href="#lowcase">
lowcase  </a>  Convert a character string to lower case       <br>
<a href="#namechr">
namechr  </a>  See if two 20 character 'names' are the same       <br>
<a href="#namegt">
namegt  </a>  Get the 20 character 'name' identifier from a line in a table       <br>
<a href="#nametr">
nametr  </a>  Translate a 20 character 'name' into 5 Reals       <br>
<a href="#numel">
numel  </a>  Get no and location of elements in a text string       <br>
<a href="#pargbeg">
pargbeg  </a>  Start text values text loading       <br>
<a href="#pargc">
pargc  </a>  Load character string for text loading with constant value       <br>
<a href="#pargi">
pargi  </a>  Load integer for text loading with constant value       <br>
<a href="#pargl">
pargl  </a>  Load boolean for text loading with constant value       <br>
<a href="#pargr">
pargr  </a>  Load real for text loading with constant value       <br>
<a href="#printd">
printd  </a>  Output text string to CL with embedded constants       <br>
<a href="#pthead">
pthead  </a>  Put a character string as a file column header       <br>
<a href="#rcheck">
rcheck  </a>  Read a real number and returns true if bit n is set, false if not       <br>
<a href="#rchzero">
rchzero  </a>  Check a 2-d sub-image in a 3-d real array, and returns       <br>
<a href="#rvtext">
rvtext  </a>  Put a real number into a character string       <br>
<a href="#trunc">
trunc  </a>  (Function) Truncate no of digits before decimal point       <br>
<a href="#trunc_e">
trunc_e  </a>  (Function) Truncate no of digits after decimal point       <br>
<a href="#tyhelp">
tyhelp  </a>  Type out help       <br>
<a href="#uppcase">
uppcase  </a>  Convert a character string to upper case       <br>
<a href="#valform">
valform  </a>  Formats a real number into a 12 character text string       <br>
<a href="#wcheck">
wcheck  </a>  Write 1/0 into bit n of a real number if flag true/false       <br>
<a href="#ischar">
ischar  </a>  (Fn) Is this a character?       <br>
<a href="#isnumb">
isnumb  </a>  (Fn) Is this a number?       <br>
<a href="#issign">
issign  </a>  (Fn) Is this a sign?       <br>
<a href="#cubint">
cubint  </a>  Cubic interpolates value/slope at a point in a set of 4 values       <br>
<a href="#acubint">
acubint  </a>  Cubic interpolates value/slope at a point in a set of 4 values       <br>
<a href="#cubintx">
cubintx  </a>  Cubic interpolates value at a point in a set of 4 values       <br>
<a href="#c ajran">
c ajran  </a>  (FN) Random number generator - uniform between 0 and 1       <br>
<a href="#c ajseed">
c ajseed  </a>  Set seed for Random number generator       <br>
<a href="#ajdate">
ajdate  </a>  Return character string with date and time       <br>
<a href="#canpar">
canpar  </a>  Cancel parameter name connection - actually cancel associtation       <br>
<a href="#chartoi">
chartoi  </a>  Convert character string to integer       <br>
<a href="#chartol">
chartol  </a>  Convert character string to logical       <br>
<a href="#chartor">
chartor  </a>  Convert character string to real       <br>
<a href="#icopdes">
icopdes  </a>  Copy all headers from one file to next for image       <br>
<a href="#tcopdes">
tcopdes  </a>  Copy all headers from one file to next for table       <br>
<a href="#dldes">
dldes  </a>  Delete a descriptor from a file       <br>
<a href="#filebeg">
filebeg  </a>  Start up file access system (ndf space common block)       <br>
<a href="#file_is">
file_is  </a>  Does this HDS file exist?       <br>
<a href="#file_par">
file_par  </a>  Writes the name of an HDS file to a parameter       <br>
<a href="#find_space">
find_space  </a>  Find gap in work space common block       <br>
<a href="#get1c">
get1c  </a>  Get a character string from the CL       <br>
<a href="#getnc">
getnc  </a>  Get a number of character strings from the CL       <br>
<a href="#getgi">
getgi  </a>  Get a number of integers from the CL       <br>
<a href="#getgb">
getgb  </a>  Get a number of booleans from the CL       <br>
<a href="#getgr">
getgr  </a>  Get a number of reals from the CL       <br>
<a href="#gtdesc_gen">
gtdesc_gen  </a>  Get a character string from a file descriptor       <br>
<a href="#gtdesc">
gtdesc  </a>  Get a character string from a file STARMAN descriptor       <br>
<a href="#gtdesi">
gtdesi  </a>  Get an integer value from the descriptor       <br>
<a href="#gtdesn">
gtdesn  </a>  Get the name of the 'nth' descriptor of a file       <br>
<a href="#gtdesn_gen">
gtdesn_gen  </a>  Get the name of the 'nth' descriptor of a file extension       <br>
<a href="#gtdesr">
gtdesr  </a>  Get a real value from the descriptor       <br>
<a href="#gtimid">
gtimid  </a>  Get descriptors BSCALE, BZERO, INVAL, TITLE form an int*4 image       <br>
<a href="#gtimrd">
gtimrd  </a>  Get descriptors BSCALE, BZERO, RINVAL, TITLE form a real image       <br>
<a href="#gtimsd">
gtimsd  </a>  Get descriptors BSCALE, BZERO, INVAL, TITLE form an int*2 image       <br>
<a href="#gtwrkg">
gtwrkg  </a>  Open integer*2/integer*4/real*4 computer work space       <br>
<a href="#isbswop">
isbswop  </a>  Is the computer swopping bytes on read (only if osf1)?       <br>
<a href="#isvms">
isvms  </a>  Is the computer running VMS?       <br>
<a href="#opimgr">
opimgr  </a>  Open an input 2d read-only generic image       <br>
<a href="#opimgw">
opimgw  </a>  Open an output 2d write-only generic image       <br>
<a href="#opim4gw">
opim4gw  </a>  Open an output 4d write-only generic image       <br>
<a href="#opim4gr">
opim4gr  </a>  Open an input read-only generic image up to 4 dimensions       <br>
<a href="#optabr">
optabr  </a>  Open an input read-only table       <br>
<a href="#optabw">
optabw  </a>  Open an output write-only table       <br>
<a href="#printo">
printo  </a>  Write a line out to the CL       <br>
<a href="#ptdescn">
ptdescn  </a>  Write character strings into the header area of an opened file       <br>
<a href="#ptdesc">
ptdesc  </a>  Write a character string into the header area of an opened file       <br>
<a href="#ptdesi">
ptdesi  </a>  Write an integer into the header area of an opened file       <br>
<a href="#ptdesr">
ptdesr  </a>  Write a real into the header area of an opened file       <br>
<a href="#putgi">
putgi  </a>  Put integer number(s) to the CL       <br>
<a href="#putgr">
putgr  </a>  Put real number(s) to the CL       <br>
<a href="#space_ndf">
space_ndf  </a>  Find gap in ndf space common block       <br>
<a href="#starman_end">
starman_end  </a>  Close down Starman controls       <br>
<a href="#starman_start">
starman_start  </a>  Set up Starman defaults       <br>
<a href="#wrkbeg">
wrkbeg  </a>  Set up computer work space information       <br>
<a href="#wrkcan">
wrkcan  </a>  Cancel work space name connection       <br>
<a href="#setup_option_s">
setup_option_s  </a>  Set up option in simple (key/panel) option choice       <br>
<a href="#setup_option">
setup_option  </a>  Set up option in (key/panel) option choice       <br>
<a href="#get_choice">
get_choice  </a>  Get (key/panel) option choice       <br>
<a href="#choice_panel_sw">
choice_panel_sw  </a>  Change between keyboard/panel input       <br>
<a href="#get_option">
get_option  </a>  Get name in option name list from user chosen option name       <br>
<a href="#get_job">
get_job  </a>  Get number in option name list from user chosen option name       <br>
<a href="#type_hchoice">
type_hchoice  </a>  Type out help at a program start on using the OPTION input       <br>
<a href="#ch_setup">
ch_setup  </a>  Set up defaults before using choices       <br>
<a href="#gcmdlst">
gcmdlst  </a>  Squeeze command list and determine its character       <br>
<a href="#gcmdlsta">
gcmdlsta  </a>  Squeeze command list(s) and determine its/their character       <br>
<a href="#getdeft">
getdeft  </a>  Get default option from list of defaults (character)       <br>
<a href="#hx_hload">
hx_hload  </a>  Put out help panel help on chosen option  (ignores case)       <br>
<a href="#ajran">
ajran  </a>  Random number generator       <br>
<a href="#ajseed">
ajseed  </a>  Seed for random number generator       <br>
<a href="#get1b">
get1b  </a>  Get a boolean value from the CL       <br>
<a href="#get1i">
get1i  </a>  Get 1 integer from CL       <br>
<a href="#get2i">
get2i  </a>  Get 2 integers from the CL       <br>
<a href="#get3i">
get3i  </a>  Get 3 integers from the CL       <br>
<a href="#get4i">
get4i  </a>  Get 4 integers from the CL       <br>
<a href="#get5i">
get5i  </a>  Get 5 integers from the CL       <br>
<a href="#get1r">
get1r  </a>  Get 1 real from CL       <br>
<a href="#get2r">
get2r  </a>  Get 2 reals from the CL       <br>
<a href="#get3r">
get3r  </a>  Get 3 reals from the CL       <br>
<a href="#get4r">
get4r  </a>  Get 4 reals from the CL       <br>
<a href="#get5r">
get5r  </a>  Get 5 reals from the CL       <br>
<a href="#gtimzd">
gtimzd  </a>  Get descriptors BSACLE, BZERO, INVAL, TITLE form a real or int*2 image       <br>
<a href="#gtwrki">
gtwrki  </a>  Open integer*4 computer work space       <br>
<a href="#gtwrkr">
gtwrkr  </a>  Open real computer work space       <br>
<a href="#gtwrks">
gtwrks  </a>  Open short computer work space       <br>
<a href="#opimir">
opimir  </a>  Open an input 2d read-only integer*4 image       <br>
<a href="#opimrr">
opimrr  </a>  Open an input 2d read-only real image       <br>
<a href="#opimsr">
opimsr  </a>  Open an input 2d read-only integer*2 image       <br>
<a href="#opimur">
opimur  </a>  Open an input 2d read-only unsigned integer*2 image       <br>
<a href="#opimzr">
opimzr  </a>  Open an input 2d read-only real or integer*2 image       <br>
<a href="#opim4zr">
opim4zr  </a>  Open an input 4d read-only real/int/integer*2 image       <br>
<a href="#opimzw">
opimzw  </a>  Open an output 2d read-only real or integer*2 image       <br>
<a href="#opim4zw">
opim4zw  </a>  Open an outnput 4d read-only real or integer*2 image       <br>
<a href="#opimiw">
opimiw  </a>  Open an output 2d write-only integer*4 image       <br>
<a href="#opimrw">
opimrw  </a>  Open an output 2d write-only real image       <br>
<a href="#opimsw">
opimsw  </a>  Open an output 2d write-only integer*2 image       <br>
<a href="#opim4iw">
opim4iw  </a>  Open an output 4d write-only integer*4 image       <br>
<a href="#opim4rw">
opim4rw  </a>  Open an output 4d write-only real image       <br>
<a href="#opim4sw">
opim4sw  </a>  Open an output 4d write-only integer*2 image       <br>
<a href="#put1i">
put1i  </a>  Put an integer number to the CL       <br>
<a href="#put2i">
put2i  </a>  Put two integer numbers to the CL       <br>
<a href="#put3i">
put3i  </a>  Put three integer numbers to the CL       <br>
<a href="#put1r">
put1r  </a>  Put a real number to the CL       <br>
<a href="#put2r">
put2r  </a>  Put two real numbers to the CL       <br>
<a href="#put3r">
put3r  </a>  Put three real numbers to the CL       <br>
<a href="#abors">
abors  </a>  Bitwise Boolean OR of two short vectors       <br>
<a href="#achtbri">
achtbri  </a>  Load a real array into an integer array with magic values       <br>
<a href="#achtbrs">
achtbrs  </a>  Load a real array into a short integer array with magic values       <br>
<a href="#achtbdr">
achtbdr  </a>  Load a double precision array into a real array with magic values       <br>
<a href="#achtbdi">
achtbdi  </a>  Load a double precision array into a integer array with magic values       <br>
<a href="#achtbds">
achtbds  </a>  Load a double precision array into a integer*2 array with magic values       <br>
<a href="#achtri">
achtri  </a>  Load a real array into an integer array       <br>
<a href="#achtrs">
achtrs  </a>  Load a real array into a short integer array       <br>
<a href="#achtdr">
achtdr  </a>  Load a double precision array into a real array       <br>
<a href="#achtdi">
achtdi  </a>  Load a double precision array into a integer array       <br>
<a href="#achtds">
achtds  </a>  Load a double precision array into a integer*2 array       <br>
<a href="#amovz">
amovz  </a>  Load a byte array into another  B = A       <br>
<a href="#amovkz">
amovkz  </a>  Load a byte constant into a byte array  A = K       <br>
<a href="#azeroz">
azeroz  </a>  Load zero into a byte array  A = 0       <br>
<a href="#copzz">
copzz  </a>  Copy part of a byte array into an area of a byte array       <br>
<a href="#morehelp">
morehelp  </a>  See if more HELP is desired       <br>
<a href="#xxtime">
xxtime  </a>  Type out a message and the time       <br>
<a href="#gd_setup">
gd_setup  </a>  Set up defaults before using graphics device       <br>
<a href="#gd_open">
gd_open  </a>  Open graphics device       <br>
<a href="#gd_close">
gd_close  </a>  Close graphics device       <br>
<a href="#gd_dobox">
gd_dobox  </a>  Clear a graphics plot and make a graph box       <br>
<a href="#gd_opts">
gd_opts  </a>  Plot points with optional ommitting and numbering       <br>
<a href="#gd_text">
gd_text  </a>  Put a text string at a posn on graphic device       <br>
<a href="#gd_setdev">
gd_setdev  </a>  Set graph device not open       <br>
<a href="#gd_bbuf">
gd_bbuf  </a>  Start command buffer       <br>
<a href="#gd_ebuf">
gd_ebuf  </a>  End command buffer       <br>
<a href="#gd_updt">
gd_updt  </a>  Flush commands       <br>
<a href="#addcoli">
addcoli  </a>  Adds constant to a column of an integer array       <br>
<a href="#addcolr">
addcolr  </a>  Adds constant to a column of a real array       <br>
<a href="#addcols">
addcols  </a>  Adds constant to a column of a short array       <br>
<a href="#adiffr">
adiffr  </a>  See if two real arrays are different       <br>
<a href="#arrsc">
arrsc  </a>  Scale a real array  (Out = in*BS + BZ)       <br>
<a href="#copii">
copii  </a>  Copy part of an integer array into an area of an integer array       <br>
<a href="#copir">
copir  </a>  Copy part of an integer array into an area of a real array       <br>
<a href="#coprr">
coprr  </a>  Copy part of a real array into an area of a real array       <br>
<a href="#coprs">
coprs  </a>  Copy part of a real array into an area of a short array       <br>
<a href="#copsr">
copsr  </a>  Copy part of a short array into an area of a real array       <br>
<a href="#copss">
copss  </a>  Copy part of a short array into an area of a short array       <br>
<a href="#copfri">
copfri  </a>  Copy vertical column of a real 2-D array to an integer vector       <br>
<a href="#copfrr">
copfrr  </a>  Copy vertical column of a real 2-D array to a real vector       <br>
<a href="#copssi">
copssi  </a>  Copy a integer*2 array (with invalid flags) to an integer one.       <br>
<a href="#copssr">
copssr  </a>  Copy a integer*2 array (scaled with invalid flags) to a real one.       <br>
<a href="#coprrr">
coprrr  </a>  Copy a real array (scaled with invalid flags) to a real one.       <br>
<a href="#copsss">
copsss  </a>  Copy a int*2 array to another one, NO scaling, INVAL deal       <br>
<a href="#coptir">
coptir  </a>  Copy part of a real vector into a vertical part of a real array       <br>
<a href="#coptrr">
coptrr  </a>  Copy part of a real vector into a vertical part of a real array       <br>
<a href="#copr1">
copr1  </a>  Copy a single real value from a real array into a value       <br>
<a href="#cops1">
cops1  </a>  Copy a single short value from a short array into a value       <br>
<a href="#cop1r">
cop1r  </a>  Copy a single real value into a real array       <br>
<a href="#cop1s">
cop1s  </a>  Copy a single short value into a short array       <br>
<a href="#copvsi">
copvsi  </a>  Extract part of an integer*2 array to an integer array.       <br>
<a href="#copvrr">
copvrr  </a>  Extract part of a real array to a real array.       <br>
<a href="#copvsr">
copvsr  </a>  Extract part of an integer*2 array to a real array.       <br>
<a href="#copvss">
copvss  </a>  Extract part of an integer*2 array to an integer*2 array.       <br>
<a href="#cswopi">
cswopi  </a>  Swop two integers if second smaller than first       <br>
<a href="#cswopr">
cswopr  </a>  Swop two reals if second smaller than first       <br>
<a href="#determ">
determ  </a>  (function) Calc the determinant of a square matrix       <br>
<a href="#fourc">
fourc  </a>  Calc Fourier Transform       <br>
<a href="#fourn">
fourn  </a>  Calc Fourier Transform in N dimensions       <br>
<a href="#gasdev">
gasdev  </a>  Make normally (Gauss) distributed random number       <br>
<a href="#gauss1r">
gauss1r  </a>  Solve for a 1-D (modified) Gaussian for real data       <br>
<a href="#gauss2ra">
gauss2ra  </a>  Fit a 2-D gaussian to a real array and bad pixels       <br>
<a href="#gauss2sa">
gauss2sa  </a>  Fit a 2-D gaussian to an int*2 array and bad pixels       <br>
<a href="#gauss2r">
gauss2r  </a>  Fit a 2-D Gaussian (fast) to real array with centered star       <br>
<a href="#gauss_cn">
gauss_cn  </a>  Update Gauss estimates and see if converged       <br>
<a href="#gauss_pr">
gauss_pr  </a>  Sets up terms for use in GAUSS2(R)       <br>
<a href="#gprob">
gprob  </a>  Calc prob of a one-tailed Normal (Gauss) distribution       <br>
<a href="#hgramr">
hgramr  </a>  Load histogram from values in a real array       <br>
<a href="#hgrams">
hgrams  </a>  Load histogram from values in an integer*2 array       <br>
<a href="#linfit">
linfit  </a>  Take N  X,Y points and fits a straight line to them.       <br>
<a href="#linfita">
linfita  </a>  Find mean and slope of a vector (simple and fast)       <br>
<a href="#ludecmat">
ludecmat  </a>  Decompose matrix by LU decomposition       <br>
<a href="#lusolmat">
lusolmat  </a>  Solve a matrix by LU decompsoition       <br>
<a href="#mannwhiti">
mannwhiti  </a>  Perform a 1-tailed mann-whitney (Wilcoxon) test on integers       <br>
<a href="#mannwhitr">
mannwhitr  </a>  Perform a 1-tailed mann-whitney (Wilcoxon) test on reals       <br>
<a href="#matinv">
matinv  </a>  Invert a matrix       <br>
<a href="#meanstdi">
meanstdi  </a>  Calc mean and std deviation of an integer vector.       <br>
<a href="#meanstdr">
meanstdr  </a>  Calc mean and std deviation of a real vector.       <br>
<a href="#poidev">
poidev  </a>  Make a poisson randomised integer output of a real input number       <br>
<a href="#polfit">
polfit  </a>  Least squares fit to data with a polynomial curve,       <br>
<a href="#prodcc">
prodcc  </a>  Sum the products of columns in two arrays       <br>
<a href="#prodcr">
prodcr  </a>  Sum the products of a column of one array with the row of another       <br>
<a href="#prodrc">
prodrc  </a>  Sum the products of a row of one array with the column of another       <br>
<a href="#prodrr">
prodrr  </a>  Sum the products of rows in two arrays       <br>
<a href="#rangei">
rangei  </a>  Find mean, std dev of an integer bad pixel flagged image section       <br>
<a href="#ranger">
ranger  </a>  Find mean, std dev of a real bad pixel flagged image section       <br>
<a href="#medianr">
medianr  </a>  Find median of real bad pixel flagged image section       <br>
<a href="#medians">
medians  </a>  Find median int*2 bad pixel flagged image section       <br>
<a href="#ranges">
ranges  </a>  Find mean, std dev of int*2 bad pixel flagged image section       <br>
<a href="#rano">
rano  </a>  Make random number between 0 and 1.       <br>
<a href="#rinter">
rinter  </a>  (function) Interpolate in a two-dimensional look-up table.       <br>
<a href="#rsscale">
rsscale  </a>  Scale a real array into an integer*2 array in range       <br>
<a href="#simulx">
simulx  </a>  Solve the simultaneous equations   Y = A.X  for X       <br>
<a href="#smoothr">
smoothr  </a>  Smooth a real array with a rectangular 'local mean' filter       <br>
<a href="#smoothbr">
smoothbr  </a>  Smooth a real flagged array with rectangular 'local mean' filter       <br>
<a href="#smoothbs">
smoothbs  </a>  Smooth a int*2 flagged array with rectangular 'local mean' filter       <br>
<a href="#sort1i">
sort1i  </a>  Sort of an integer vector       <br>
<a href="#sort1r">
sort1r  </a>  Sort of a real vector       <br>
<a href="#sort2i">
sort2i  </a>  Sort of one integer array, with alignment of another       <br>
<a href="#sort2r">
sort2r  </a>  Sort of one real array, with alignment of another       <br>
<a href="#srt1hi">
srt1hi  </a>  Heapsort to sort integers into ascending order       <br>
<a href="#srt1hr">
srt1hr  </a>  Heapsort to sort reals into ascending order       <br>
<a href="#srt1pi">
srt1pi  </a>  Straight insertion sort to sort integers into ascending order       <br>
<a href="#srt1pr">
srt1pr  </a>  Straight insertion sort to sort reals into ascending order       <br>
<a href="#srt1si">
srt1si  </a>  Shell's method insertion to sort integers into ascending order       <br>
<a href="#srt1sr">
srt1sr  </a>  Shell's method insertion to sort reals into ascending order       <br>
<a href="#srt2hi">
srt2hi  </a>  Heapsort to sort integers with alignment of another array       <br>
<a href="#srt2hr">
srt2hr  </a>  Heapsort to sort real array with alignment of another array       <br>
<a href="#srt2pi">
srt2pi  </a>  Straight insertion sort of int array with alignment of another       <br>
<a href="#srt2pr">
srt2pr  </a>  Straight insertion sort of real array  with alignment of another       <br>
<a href="#srt2si">
srt2si  </a>  Shell's method insertion sort to sort integer array       <br>
<a href="#srt2sr">
srt2sr  </a>  Shell's method insertion to sort real array       <br>
<a href="#st_minmax">
st_minmax  </a>  Get max and min of flagged area of array       <br>
<a href="#st_minmaxr">
st_minmaxr  </a>  Get max and min of flagged area of real array       <br>
<a href="#st_minmaxs">
st_minmaxs  </a>  Get max and min of flagged area of array       <br>
<a href="#tran_doit">
tran_doit  </a>  Transfromation between two sets of x,y posns - set up       <br>
<a href="#tran_lintran">
tran_lintran  </a>  Transformation between points - calculate       <br>
<a href="#boxeli">
boxeli  </a>  Calc size of box needed round a rotated star       <br>
<a href="#cvolume">
cvolume  </a>  Calc volume under a star profile.       <br>
<a href="#getd">
getd  </a>  Get x,y, and height out of a table, using the header code       <br>
<a href="#get_mprof">
get_mprof  </a>  Get the star profile from the profile file on disk       <br>
<a href="#htval">
htval  </a>  Calc height of lorentz profile given coded input       <br>
<a href="#popafi">
popafi  </a>  Add a star to an integer image with pixel flags       <br>
<a href="#popami">
popami  </a>  Add a star to an integer image with pixel magic values       <br>
<a href="#popamr">
popamr  </a>  Add a star to a real image with pixel magic values       <br>
<a href="#popams">
popams  </a>  Add a star to an integer*2 image with pixel magic values       <br>
<a href="#popsfi">
popsfi  </a>  Subtract a star from an integer image with pixel flags       <br>
<a href="#popsfr">
popsfr  </a>  Subtract a star from a real image with pixel flags       <br>
<a href="#popsfs">
popsfs  </a>  Subtract a star from a short image with pixel flags       <br>
<a href="#popsmr">
popsmr  </a>  Subtract a star from a real image with pixel magic values       <br>
<a href="#popsms">
popsms  </a>  Subtract a star from a short image with magic values       <br>
<a href="#proset">
proset  </a>  Set up values for s/r POP(AS)(FM)(SR)       <br>
<a href="#profval">
profval  </a>  Calc profile value at a pixel.       <br>
<a href="#sky_0">
sky_0  </a>  Find background and noise in a real or integer*2 image       <br>
<a href="#sky_1r">
sky_1r  </a>  Find background and noise in boxes in a real image       <br>
<a href="#sky_1s">
sky_1s  </a>  Find background and noise in boxes in a real image       <br>
<a href="#sky_2s">
sky_2s  </a>  Find the sky, given a sky map table, and a position       <br>
<a href="#sky_2r">
sky_2r  </a>  Find the sky, given a sky map table, and a position       <br>
<a href="#subdiv">
subdiv  </a>  Calc pixel sub-division needed for given profile       <br>
<a href="#aaddd">
aaddd  </a>  Adds two double precision vectors to make a third. C = A + B       <br>
<a href="#aaddi">
aaddi  </a>  Adds two integer vectors to make a third. C = A + B       <br>
<a href="#aaddr">
aaddr  </a>  Adds two real vectors to make a third. C = A + B       <br>
<a href="#aadds">
aadds  </a>  Adds two short integer vectors to make a third. C = A + B       <br>
<a href="#aaddkd">
aaddkd  </a>  Adds dble prec constant to vector to make second B=A+K       <br>
<a href="#aaddki">
aaddki  </a>  Adds integer constant to integer vector to make second B=A+K       <br>
<a href="#aaddkr">
aaddkr  </a>  Adds real constant to real vector to make second B+A+K       <br>
<a href="#aaddks">
aaddks  </a>  Adds short integer constant to vector to make second B+A+K       <br>
<a href="#aavgd">
aavgd  </a>  Calcs the mean and standard deviation of a double precision array       <br>
<a href="#aavgi">
aavgi  </a>  Calcs the mean and standard deviation of an integer array       <br>
<a href="#aavgr">
aavgr  </a>  Calcs the mean and standard deviation of a real array       <br>
<a href="#aavgs">
aavgs  </a>  Calcs the mean and standard deviation of a short integer array       <br>
<a href="#achtid">
achtid  </a>  Load an integer array into a double precision array       <br>
<a href="#achtir">
achtir  </a>  Load an integer array into a real array       <br>
<a href="#achtis">
achtis  </a>  Load an integer array into a short integer array       <br>
<a href="#achtrd">
achtrd  </a>  Load a real array into an double precision array       <br>
<a href="#achtsi">
achtsi  </a>  Load a short integer array into an integer array       <br>
<a href="#achtsr">
achtsr  </a>  Load a short integer array into a real aarray       <br>
<a href="#achtsd">
achtsd  </a>  Load a short integer array into a doubel precision aarray       <br>
<a href="#achvali">
achvali  </a>  Change a particular value in elements in an integer vector       <br>
<a href="#achvalr">
achvalr  </a>  Change a particular value in elements in a real vector       <br>
<a href="#achvals">
achvals  </a>  Change a particular value in elements in an int*2 vector       <br>
<a href="#adivd">
adivd  </a>  Divide array by another - double precision C=A/B       <br>
<a href="#adivi">
adivi  </a>  Divide array by another - integer C=A/B       <br>
<a href="#adivr">
adivr  </a>  Divide array by another - real C=A/B       <br>
<a href="#adivs">
adivs  </a>  Divide array by another - short integer C=A/B       <br>
<a href="#adivkd">
adivkd  </a>  Divides array by constant - double precision B=A/K       <br>
<a href="#adivki">
adivki  </a>  Divides array by constant - integer B=A/K       <br>
<a href="#adivkr">
adivkr  </a>  Divides array by constant - real B=A/K       <br>
<a href="#adivks">
adivks  </a>  Divides array by constant - short integer B=A/K       <br>
<a href="#alimd">
alimd  </a>  Finds the min and max of a double precision vector       <br>
<a href="#alimi">
alimi  </a>  Finds the min and max of an integer vector       <br>
<a href="#alimr">
alimr  </a>  Finds the min and max of a real vector       <br>
<a href="#alims">
alims  </a>  Finds the min and max of a short integer vector       <br>
<a href="#amediani">
amediani  </a>  Median of integer vector       <br>
<a href="#amedianr">
amedianr  </a>  Median of real vector       <br>
<a href="#amedians">
amedians  </a>  Median of short vector       <br>
<a href="#amovb">
amovb  </a>  Load a boolean array into another  B = A       <br>
<a href="#amovd">
amovd  </a>  Load a double precision array into another  B = A       <br>
<a href="#amovi">
amovi  </a>  Moves an integer array to another B = A       <br>
<a href="#amovr">
amovr  </a>  Load a real array into a real array  B = A       <br>
<a href="#amovs">
amovs  </a>  Load a short integer array into another  B = A       <br>
<a href="#amovkb">
amovkb  </a>  Load a constant into a logical array  A = K       <br>
<a href="#amovkd">
amovkd  </a>  Load a constant into a double precision array A = K       <br>
<a href="#amovki">
amovki  </a>  Load a constant into a integer array  A = K       <br>
<a href="#amovkr">
amovkr  </a>  Load a constant into a real array  A = K       <br>
<a href="#amovks">
amovks  </a>  Load an integer constant into a short integer array   A = K       <br>
<a href="#amuld">
amuld  </a>  Multiplies two double precision arrays C = A.B       <br>
<a href="#amuli">
amuli  </a>  Multiplies two integer arrays C = A.B       <br>
<a href="#amulr">
amulr  </a>  Multiplies two real arrays C = A.B       <br>
<a href="#amuls">
amuls  </a>  Multiplies two short integer arrays C = A.B       <br>
<a href="#amulkd">
amulkd  </a>  Multiplies a double precision array by a constant B = A.K       <br>
<a href="#amulki">
amulki  </a>  Multiplies an integer array by a constant B = A.K       <br>
<a href="#amulkr">
amulkr  </a>  Multiplies a real array by a constant B = A.K       <br>
<a href="#amulks">
amulks  </a>  Multiplies a short integer array by a constant B = A.K       <br>
<a href="#anuminci">
anuminci  </a>  Load increasing integer numbers (1,2,3,..) into array       <br>
<a href="#anumincr">
anumincr  </a>  Load increasing real numbers (1,2,3,..) into array       <br>
<a href="#anumincs">
anumincs  </a>  Load increasing short numbers (1,2,3,..) into array       <br>
<a href="#asubd">
asubd  </a>  Subtracts a double precision vector from another vector C = A - B       <br>
<a href="#asubi">
asubi  </a>  Subtracts an integer vector from another vector C = A - B       <br>
<a href="#asubr">
asubr  </a>  Subtracts a real vector from another vector C = A - B       <br>
<a href="#asubs">
asubs  </a>  Subtracts a short integer vector from another vector C = A - B       <br>
<a href="#asubkd">
asubkd  </a>  Subtracts a constant from a double precision vector B = A - K       <br>
<a href="#asubki">
asubki  </a>  Subtracts a constant from an integer vector B = A - K       <br>
<a href="#asubkr">
asubkr  </a>  Subtracts a constant from a real vector B = A - K       <br>
<a href="#asubks">
asubks  </a>  Subtracts a constant from a short integer vector B = A - K       <br>
<a href="#asumd">
asumd  </a>  Sums a double precision vector       <br>
<a href="#asumi">
asumi  </a>  Sums an integer vector       <br>
<a href="#asumr">
asumr  </a>  Sums a real vector       <br>
<a href="#asums">
asums  </a>  Sums a short integer vector       <br>
<a href="#amzerob">
amzerob  </a>  Load .FALSE. into a logical array  A = .FALSE.       <br>
<a href="#azerod">
azerod  </a>  Load zeroes into a double precision array A = 0.0d0       <br>
<a href="#azeroi">
azeroi  </a>  Load zeroes into a integer array  A = 0       <br>
<a href="#azeror">
azeror  </a>  Load zeroes into a real array  A = 0.0       <br>
<a href="#azeros">
azeros  </a>  Load zeros into a short integer array   A = 0       <br>
<a href="#azaddkd">
azaddkd  </a>  Adds dble prec constant to magic vector to make second B=A+K       <br>
<a href="#azaddki">
azaddki  </a>  Adds integer constant to integer magic vector to make second B=A+K       <br>
<a href="#azaddkr">
azaddkr  </a>  Adds real constant to real magic vector to make second B+A+K       <br>
<a href="#azaddks">
azaddks  </a>  Adds short integer constant to magic vector to make second B+A+K       <br>
<a href="#azsubkd">
azsubkd  </a>  Subtracts dble prec constant to magic vector to make second B=A-K       <br>
<a href="#azsubki">
azsubki  </a>  Subtracts integer constant to magic vector to make second B=A-K       <br>
<a href="#azsubkr">
azsubkr  </a>  Subtracts real constant to magic vector to make second B=A-K       <br>
<a href="#azsubks">
azsubks  </a>  Subtracts short integer constant to magic vector to make second B=A-K       <br>
<a href="#azmulkd">
azmulkd  </a>  Multiplies a double precision magic vector by a constant B = A.K       <br>
<a href="#azmulki">
azmulki  </a>  Multiplies an integer magic vector by a constant B = A.K       <br>
<a href="#azmulkr">
azmulkr  </a>  Multiplies a real magic vector by a constant B = A.K       <br>
<a href="#azmulks">
azmulks  </a>  Multiplies a short integer array by a constant B = A.K       <br>
<a href="#azdivkd">
azdivkd  </a>  Divides a double precision magic vector by a constant B = A/K       <br>
<a href="#azdivki">
azdivki  </a>  Divides an integer magic vector by a constant B = A/K       <br>
<a href="#azdivkr">
azdivkr  </a>  Divides a real magic vector by a constant B = A/K       <br>
<a href="#azdivks">
azdivks  </a>  Divides a short integer array by a constant B = A/K       <br>
<a href="#azsubd">
azsubd  </a>  Subtract dble prec vector from another with magic values C = A - B       <br>
<a href="#azsubi">
azsubi  </a>  Subtract integer vector from another with magic values C = A - B       <br>
<a href="#azsubr">
azsubr  </a>  Subtract real vector from another with magic values C = A - B       <br>
<a href="#azsubs">
azsubs  </a>  Subtract short vector from another with magic values C = A - B       <br>
<a href="#azaddd">
azaddd  </a>  Add dble prec vector from another with magic values C = A + B       <br>
<a href="#azaddi">
azaddi  </a>  Add integer vector from another with magic values C = A + B       <br>
<a href="#azaddr">
azaddr  </a>  Add real vector from another with magic values C = A + B       <br>
<a href="#azadds">
azadds  </a>  Add short vector from another with magic values C = A + B       <br>
<a href="#azmuld">
azmuld  </a>  Multiply dble prec vector from another with magic values C = A * B       <br>
<a href="#azmuli">
azmuli  </a>  Multiply integer vector from another with magic values C = A * B       <br>
<a href="#azmulr">
azmulr  </a>  Multiply real vector from another with magic values C = A * B       <br>
<a href="#azmuls">
azmuls  </a>  Multiply short vector from another with magic values C = A * B       <br>
<a href="#azdivd">
azdivd  </a>  Divide dble prec vector from another with magic values C = A / B       <br>
<a href="#azdivi">
azdivi  </a>  Divide integer vector from another with magic values C = A / B       <br>
<a href="#azdivr">
azdivr  </a>  Subtract real vector from another with magic values C = A / B       <br>
<a href="#azdivs">
azdivs  </a>  Divide short vector from another with magic values C = A / B       <br>
<a href="#azchtir">
azchtir  </a>  Load an integer array into a real array with magic values       <br>
<a href="#azchtid">
azchtid  </a>  Load an integer array into a double precisionn array with magic values       <br>
<a href="#azchtis">
azchtis  </a>  Load an integer array into a short integer array with magic values       <br>
<a href="#azchtrd">
azchtrd  </a>  Load a real array into an double precision array with magic values       <br>
<a href="#azchtri">
azchtri  </a>  Load a real array into an integer array with magic values       <br>
<a href="#azchtrs">
azchtrs  </a>  Load a real array into an integer*2 array with magic values       <br>
<a href="#azchtsi">
azchtsi  </a>  Load a short integer array into an integer array with magic values       <br>
<a href="#azchtsr">
azchtsr  </a>  Load a short integer array into a real array with magic values       <br>
<a href="#azchtsd">
azchtsd  </a>  Load a short integer array into a doubel precision array with magic values       <br>
<a href="#azlimd">
azlimd  </a>  Finds the min and max of an dble prec vector with magic values       <br>
<a href="#azlimi">
azlimi  </a>  Finds the min and max of an integer vector with magic values       <br>
<a href="#azlimr">
azlimr  </a>  Finds the min and max of a real vector with magic values       <br>
<a href="#azlims">
azlims  </a>  Finds the min and max of a short integer vector with magic values       <br>
<a href="#azzallbadr">
azzallbadr  </a>  Check for some ok in a real image box with magic values       <br>
<a href="#azzallbads">
azzallbads  </a>  Check for some ok in an int*2 image box with magic values       <br>

<HR>
<pre>

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C    This is STARFLIB.FOR
C
C    It contains the general s/rs:-
C
C BELL         Sound the terminal bell
C CHARLN       Position of last non-blank character in a character string
C ENDSTRIP     Return start and end of non-blank string in a string
C FINDHEAD     Find column header with a character string
C GETTHEH      Get header order in the input list
C GTHEAD       Get a character string from a file column header
C IDENT        Fill identifiers columns of a table with #1 - #n
C LBGONE       Remove leading blanks from string
C LENS         (FN) Find position of last non-blank character in a string
C LOWCASE      Convert a character string to lower case
C NAMECHR      See if two 20 character 'names' are the same
C NAMEGT       Get the 20 character 'name' identifier from a line in a table
C NAMETR       Translate a 20 character 'name' into 5 Reals
C NUMEL        Get no and location of elements in a text string
C PARGBEG      Start text values text loading
C PARG(CILR)   Load (string:int:logical:real) value for text loading
C PRINTD       Output text string to CL with embedded constants
C PTHEAD       Put a character string as a file column header
C RCHECK       Read a real number; return true if bit n is set, false if not
C RCHZERO      Check a 2-d sub-image in a 3-d real array, and returns
C RVTEXT       Put a real number into a character string
C TRUNC        (Function) Truncate no of digits before decimal point
C TRUNC_E      (Function) Truncate no of digits after decimal point
C TYHELP       Type out help
C UPPCASE      Convert a character string to upper case
C VALFORM      Formats a real number into a 12 character text string
C WCHECK       Write 1/0 into bit n of a real number if flag true/false

C ISCHAR       (Fn) Is this a character?
C ISNUMB       (Fn) Is this a number?
C ISSIGN       (Fn) Is this a sign?


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="bell"> BELL  </a>-- Sound the terminal bell
C
C    a j penny                ral               1991 June

      subroutine bell ( )

      implicit none
      include 'STARMAN_INC'
C--
Cbegin

      if ( ST_FAILED ) return

      write ( 6, '(''+'',a1)' ) char(7)


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="charln"> CHARLN  </a>-- Position of last non-blank character in a character string
C
C  alan penny                 ral                      1990-02-19

      subroutine charln ( text, klen )

      implicit none
      include 'STARMAN_INC'

      character*(*)  text	!i: Input character string
      integer        klen	!o: Position of last non-blank character
				!   (if all blank, returned as 0)
C--
      integer k
Cbegin

      if ( ST_FAILED ) return

      klen = len(text)
      k = 1
      do while ( k.eq.1 .and. klen.gt.0 )
         if ( text(klen:klen).eq.' ' ) then
            klen = klen - 1
         else
            k = 0
         endif
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="endstrip"> ENDSTRIP  </a>-- Return start and end of non-blank string in a string
C     (non-blank string may have imbedded blanks)
C
C   alan penny         ral                   1988 Nov

      subroutine endstrip ( string, i1, i2 )

      implicit none
      include 'STARMAN_INC'

      character string*(*)	!i: Input string
      integer   i1              !o: Posn in input string of start
      integer   i2              !o: Posn in input string of end
C--
      logical found
      integer length, i, j
Cbegin


      if ( ST_FAILED ) return

      length = len(string)

      i = 1
      found = .false.
      do while ( .not.found .and. i.le.length )
        if ( string(i:i) .ne. ' ' ) then
           found = .true.
           j = i
        else
           i = i + 1
        endif
      enddo
      i1 = 0
      if ( found ) i1 = j

      i2 = 0
      i = length
      found = .false.
      do while ( .not.found .and. i.ge.1 )
        if ( string(i:i) .ne. ' ' ) then
           found = .true.
           j = i
        else
           i = i - 1
        endif
      enddo
      i2 = 0
      if ( found ) i2 = j


      end

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="findhead"> FINDHEAD  </a>-- Find column header with a character string
C             (ignores leading blanks)
C  a j penny                          ral               1995 Aug

      subroutine findhead ( file, nx, head, case, ncol )

      implicit none
      include 'STARMAN_INC'

      character*(*) file	!i: Name of input file
      integer nx		!i: No of columns (not including 5 of names)
      character*(*) head	!i: Header to search for
      logical case		!i: Case import? (.true. = yes)
      integer ncol		!o: Column header is in (0=not found)
C--
      integer j, kla, klf, istat
      character*132 heada, headf, headfa
      logical found
Cbegin


      ncol = 0

      if ( case ) then
         heada = head
      else
         call lowcase ( head, heada )
      endif
      call lbgone ( heada )
      call charln ( heada, kla )

      j = 0
      found = .false.
      do while ( .not.found .and. j.lt.nx )
         j = j + 1
         call gthead ( file, j, headf, istat )
         if ( ST_FAILED ) return
         if ( case ) then
            headfa = headf
         else
            call lowcase ( headf, headfa )
         endif
         call lbgone ( headfa )
         call charln ( headfa, klf )
         if ( heada(1:kla).eq.headfa(1:klf) ) then
            found = .true.
            ncol = j
         endif
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gettheh"> GETTHEH  </a>-- Get header order in the input list
C
C  a j penny                          dao              1988-04-19

      subroutine gettheh ( file, nxfile, khead )

      implicit none
      include 'STARMAN_INC'

      character*(*) file	!i: Name of input file
      integer nxfile		!i: No of columns (+5)
      integer khead(16)		!o: Column positions of descripotors
C--
      integer j, k, ierr
      character*20 header(16), ahead
      data header / 'X', 'Y', 'HEIGHT', 'RX', 'RY', 'P', 'PRX', 'PRY',
     +              'THETA', 'QH', 'QR', 'QP', 'MAPNUM', 'MAPX',
     +              'MAPY', 'MAGNIF' /
Cbegin


      if ( ST_FAILED ) return

      call azeroi ( khead, 16 )

      do k = 1, nxfile - 5
         call gthead ( file, k, ahead, ierr )
         if ( ierr.eq.0 ) then
            do j = 1, 16
               if ( ahead.eq.header(j) ) khead(j) = k
            enddo
         endif
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gthead"> GTHEAD  </a>-- Get a character string from a file column header
C   It assumes the file is an XYlist and finds how many parameters
C   it has and then reads the decsriptor 'HEAD00n' , where 'n'
C   is the number of the wanted Header.
C
C   If the descriptor is missing it is set to ' ' and an error flagged.
C
C   alan penny                       ral                    1990 Jan

      subroutine gthead ( file, num, text, ierr )

      implicit none
      include 'STARMAN_INC'

      character*(*) file	!i: File to read from
      integer       num		!i: Number of the descriptor to be read
      character*(*) text	!o: Descriptor
      integer       ierr	!o: Error flag. ok=0
C--
      character*7 texth
      integer istat, iv
Cbegin


      if ( ST_FAILED ) return

      ierr = 0						!Set error flag

      write ( texth, '(''HEAD'',i3.3)' ) num		!Get header
      call gtdesc ( file, texth, text, ' ', iv, istat )
      if ( text.eq.' ' .or. istat.ne.0 ) ierr = 1


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="ident"> IDENT  </a>-- Fill identifier columns of a table with #1 - #n
C   Load the identifier characters one by one into ID, and then
C   transfer them byte by byte into the correct place in the table.
C
C   The identifiers take up the first 20 bytes (1st 5 real words)
C   of each row.
C
C
C
C   alan penny                       ral                   1990-02-16

      subroutine ident ( data, nx, ny )

      implicit none
      include 'STARMAN_INC'

      integer    nx		!i: No of columns (inc identifier columns)
      integer    ny		!i: No of rows
      byte       data(nx*4,ny)	!o: Table
C--
      character id*20
      integer j, k
Cbegin


      if ( ST_FAILED ) return

      do k = 1, ny
         write ( id, '(i20)' ) k
         id(1:1) = '#'
         call lbgone(id(2:))
         do j = 1, 20
            data(j,k) = ichar(id(j:j))
         enddo
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="lbgone"> LBGONE  </a>-- Remove leading blanks from a character string
C
C   alan penny               ral         1990 Jan

      subroutine lbgone ( str )

      implicit none
      include 'STARMAN_INC'

      character*(*)  str	!i/o: Input string, modified on output
C--
      integer start, stop, lencpy, curorg, curshf
Cbegin


      if ( ST_FAILED ) return

      stop = len(str)

      do start = 1, stop
         if ( str(start:start).ne.' ' ) go to 1
      enddo
      start = stop + 1
    1 continue

      if ( start.gt.1 .and. start.le.stop ) then
         lencpy = stop - start + 1
         do curshf = 1, lencpy
            curorg = curshf + start - 1
            str(curshf:curshf) = str(curorg:curorg)
         enddo
         str(lencpy+1:) = ' '
      endif


      end

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="lens"> LENS  </a>-- (FN) Find position of last non-blank character in a string
C  If all blank, then 0 is returned
C
C  alan penny                     ral             1990 Jan

      integer function lens ( ch )

      implicit none
      include 'STARMAN_INC'

      character*(*)   ch  	!i: Input string
C--
      integer ip
Cbegin


      lens = 0

      if ( ST_FAILED ) return

      ip = len ( ch )
      if ( ip.eq.0 ) return

      do while ( ip.ne.0 .and. ch(ip:ip).eq.' ' )
         ip = ip - 1
      enddo
      lens = ip


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="lowcase"> LOWCASE  </a>-- Convert a character string to lower case
C
C a j penny             ral                          1991 March

      subroutine lowcase ( a, b )

      implicit none
      include 'STARMAN_INC'

      character*(*)  a		!i: Input string
      character*(*)  b		!o: Output string
C--
      integer j, k, kl, lens
      external lens
Cbegin


      if ( ST_FAILED ) return

      b = a
      kl = lens(b)
      do k = 1, kl
         j = ichar(b(k:k))
         if ( j.ge.65 .and.  j.le.90 ) b(k:k) = char(j+32)
      enddo

      end



CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="namechr"> NAMECHR  </a>-- See if two 20 character 'names' are the same
C
C a j penny             ral                          1990-06-06

      subroutine namechr ( na, nb, ka )

      implicit none
      include 'STARMAN_INC'

      byte	na(20)			!i: First name
      byte	nb(20)			!i: Second name
      integer	ka			!o: Match flag (0=same;1=different)
C--
      integer k
Cbegin


      if ( ST_FAILED ) return

      ka = 0
      k = 1
      do while ( k.le.20 .and. ka.eq.0 )
         if ( na(k).ne.nb(k) ) ka = 1
         k = k + 1
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="namegt"> NAMEGT  </a>-- Get the 20 character 'name' identifier from a line in a table
C
C a j penny             stsci                  1987-03-22

      subroutine namegt ( tb, tbvx, tby, kl, name )

      implicit none
      include 'STARMAN_INC'

      integer	tbvx			!i: No of columns in table
      integer	tby			!i: No of rows in table
      integer	tb(tbvx,tby)		!i: The table
      integer	kl			!i: Line to access
      character name*20			!o: Name found there
C--
      integer buf(20)
      byte asc(20)
      equivalence (buf(1),asc(1))
      integer i, nchar
Cbegin


      if ( ST_FAILED ) return

      call amovz ( tb(1,kl), buf(1), 20 )		!Load name

      do i = 1, 20					!Convert identifier bytes
         nchar = asc(i)					! to characters
         name(i:i) = char(nchar)
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="nametr"> NAMETR  </a>-- Translate a 20 character 'name' into 5 Reals
C
C a j penny             ral                     1990-06-06

      subroutine nametr ( na, rna )

      implicit none
      include 'STARMAN_INC'

      character na*20			!i: Input name
      real	rna(5)			!o: Output name
C--
      real rid(5)
      byte bid(20)
      equivalence (bid(1),rid(1))
      integer k
Cbegin


      if ( ST_FAILED ) return

      do k = 1, 20
         bid(k) = ichar(na(k:k))
      enddo

      call amovr ( rid, rna, 5 )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="numel"> NUMEL  </a>-- Get no and location of elements in a text string
C If an element is null (i.e. blanks or two commas or comma
C at start or end of text), then this is marked by the end
C position being before the start position.
C
C  alan penny                 ral                1990-06-15

      subroutine numel ( text, num, ks, ke )

      implicit none
      include 'STARMAN_INC'

      character*(*)   text	!i: Text string
      integer         num	!o: Number of elements
      integer         ks(1000)	!o: Start locations of elements
      integer         ke(1000)	!o: End locations of elements
C--
      integer k, klen, lens
      external lens
      logical gap, iscomma
      character*1 cv
Cbegin


      if ( ST_FAILED ) return

      klen = lens(text)

      if ( klen.lt.1 ) then
         num = 0
         ks(1) = 1
         ke(1) = 0
         return
      endif

      if ( klen.eq.1 ) then
         if ( text(1:1).eq.',' ) then
            num = 2
            ks(1) = 1
            ke(1) = 0
            ks(1) = 2
            ke(1) = 1
         else
            num = 1
            ks(1) = 1
            ke(1) = 1
         endif
         return
      endif

      cv = text(1:1)
      if ( cv.eq.',' ) then
         gap = .true.
         iscomma = .true.
         num = 1
         ks(1) = 1
         ke(1) = 0
      elseif ( cv.eq.' ' ) then
         gap = .true.
         iscomma = .false.
         num = 0
      else
         gap = .false.
         iscomma = .false.
         num = 1
         ks(1) = 1
      endif

      do k = 2, klen
         cv = text(k:k)
         if ( gap ) then
            if ( cv.ne.' ' .and. cv.ne.',' ) then
               iscomma = .false.
               gap = .false.
               num = num + 1
               ks(num) = k
            elseif ( cv.eq.',' ) then
               if ( iscomma ) then
                  num = num + 1
                  ks(num) = k - 1
                  ke(num) = k - 2
               endif
               iscomma = .true.
            endif
         else
            if ( cv.eq.' ' .or. cv.eq.',' ) then
               gap = .true.
               ke(num) = k - 1
               if ( cv.eq.',' ) iscomma = .true.
            endif
         endif
      enddo

      cv = text(klen:klen)
      if ( cv.eq.',' ) then
         num = num + 1
         ks(num) = klen
         ke(num) = klen - 1
      else
         ke(num) = klen
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="pargbeg"> PARGBEG  </a>-- Start text values text loading
C
C alan penny                  ral          1990-06-24

      subroutine pargbeg ( )

      implicit none
      include 'STARMAN_INC'

C--
      integer nint, nreal, aint(1000), nlog, nch, nach(100)
      real areal(1000)
      logical alog(1000)
      common / pargaa / aint, nint, areal, nreal, alog, nlog, nch, nach
Cbegin


      if ( ST_FAILED ) return

      NINT = 0
      NREAL = 0
      NLOG = 0
      NCH = 0


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="pargc"> PARGC  </a>-- Load character string for text loading with constant value
C
C alan penny                  ral          1990-06-24

      subroutine pargc ( ch )

      implicit none
      include 'STARMAN_INC'

      character*(*)	ch		!i: Input character string
C--
      integer nint, nreal, aint(1000), nlog, nch, nach(100)
      real areal(1000)
      logical alog(1000)
      common / pargaa / aint, nint, areal, nreal, alog, nlog, nch, nach
      character*200 ach(100)
      common / pargcc / ach

      character*200 bch
      integer kl, lens
      external lens
Cbegin


      if ( ST_FAILED ) return

      NCH = min(100,NCH+1)

      if ( NCH.lt.1 ) then
         call printo ( 'ERROR: In s/r PARGC - no text' )
         NCH = 1
      endif

      kl = min(lens(ch),200)
      if ( kl.eq.0 ) then
         NACH(NCH) = 0
      else
         bch = ch(1:kl)
         call lbgone ( bch )
         kl = lens(bch)
         ACH(NCH) = bch(1:kl)
         NACH(NCH) = kl
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="pargi"> PARGI  </a>-- Load integer for text loading with constant value
C
C alan penny                  ral          1990-06-24

      subroutine pargi ( n )

      implicit none
      include 'STARMAN_INC'

      integer	n		!i: Input integer
C--
      integer nint, nreal, aint(1000), nlog, nch, nach(100)
      real areal(1000)
      logical alog(1000)
      common / pargaa / aint, nint, areal, nreal, alog, nlog, nch, nach
Cbegin


      if ( ST_FAILED ) return

      NINT = min(1000,NINT+1)
      if ( NINT.lt.1 ) then
         call printo ( 'ERROR: In s/r PARGI' )
         NINT = 1
      endif

      AINT(NINT) = n


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="pargl"> PARGL  </a>-- Load boolean for text loading with constant value
C
C alan penny                  ral          1990-06-24

      subroutine pargl ( l )

      implicit none
      include 'STARMAN_INC'

      logical	l		!i: Input integer
C--
      integer nint, nreal, aint(1000), nlog, nch, nach(100)
      real areal(1000)
      logical alog(1000)
      common / pargaa / aint, nint, areal, nreal, alog, nlog, nch, nach
Cbegin


      if ( ST_FAILED ) return

      NLOG = min(1000,NLOG+1)
      if ( NLOG.lt.1 ) then
         call printo ( 'ERROR: In s/r PARGL' )
         NLOG = 1
      endif

      ALOG(NLOG) = l


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="pargr"> PARGR  </a>-- Load real for text loading with constant value
C
C alan penny                  ral          1990-06-24

      subroutine pargr ( r )

      implicit none
      include 'STARMAN_INC'

      real	r		!i: Input real
C--
      integer nint, nreal, aint(1000), nlog, nch, nach(100)
      real areal(1000)
      logical alog(1000)
      common / pargaa / aint, nint, areal, nreal, alog, nlog, nch, nach
Cbegin


      if ( ST_FAILED ) return

      NREAL = max(1,min(1000,NREAL+1))
      if ( NREAL.lt.1 ) then
         call printo ( 'ERROR: In s/r PARGR' )
         NREAL = 1
      endif

      AREAL(NREAL) = r


      end



CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="printd"> PRINTD  </a>-- Output text string to CL with embedded constants
C  %c = text; %d = integer; %f = real; %l = logical
C
C alan penny                  ral          1990-06-24

      subroutine printd ( ch )

      implicit none
      include 'STARMAN_INC'

      character*(*)	ch		!i: Input text string
C--
      integer nint, nreal, aint(1000), nlog, nch, nach(100)
      real areal(1000)
      logical alog(1000)
      character*200 ach(100)
      common / pargaa / aint, nint, areal, nreal, alog, nlog, nch, nach
      common / pargcc / ach

      integer lens, io, j, kl, kout, kin, km, kd, ka, nlen, ktext
      real ro
      logical more, lo
      character texta*100, textt*2000, texto*100, co*200
      external lens
Cbegin


      if ( ST_FAILED ) return

      kout = 1
      kin = 1
      textt = ' '

      km = lens(ch)
      more = .true.
      do while ( more .and. kin.lt.km )
         ka = index(ch(kin:),'%')
         if ( ka.eq.0 ) then
            more = .false.
         else

            if ( ka.ne.1 ) then
               textt(kout:kout+ka-2) = ch(kin:kin+ka-2)
               kout = kout + ka - 1
            endif
            kin = kin + ka

            ktext = 0
            if ( ch(kin:kin).eq.'d' ) then
               io = AINT(1)
               if ( NINT.ge.2 ) then
                  do j = 1, NINT-1
                     AINT(j) = AINT(j+1)
                  enddo
               endif
               NINT = NINT - 1
               write ( texta, '(i30)' ) io
               kin = kin + 1
            elseif ( ch(kin:kin).eq.'f' ) then
               ro = AREAL(1)
               if ( NREAL.ge.2 ) then
                  do j = 1, NREAL-1
                     AREAL(j) = AREAL(j+1)
                  enddo
               endif
               NREAL = NREAL - 1
               if ( abs(ro).gt.1.0e10 .or. abs(ro).lt.1.0e-3 ) then
                  write ( texta, '(g17.5)' ) ro
               else
                  write ( texta, '(f20.7)' ) ro
                  j = 15 + max(0.0,alog10(1000000.0/abs(ro)))
                  if ( j.lt.20 ) texta(j:) = ' '
               endif
               kin = kin + 1
            elseif ( ch(kin:kin).eq.'l' ) then
               lo = ALOG(1)
               if ( NLOG.ge.2 ) then
                  do j = 1, NLOG-1
                     ALOG(j) = ALOG(j+1)
                  enddo
               endif
               NLOG = NLOG - 1
               write ( texta, '(l1)' ) lo
               kin = kin + 1
            elseif ( ch(kin:kin).eq.'c' ) then
               co = ACH(1)
               nlen = NACH(1)
               if ( NCH.ge.2 ) then
                  do j = 1, NCH-1
                     ACH(j) = ACH(j+1)
                     NACH(j) = NACH(j+1)
                  enddo
               endif
               NCH = NCH - 1
               if ( nlen.eq.0 ) then
                  texta = ' '
               else
                  texta = co(1:nlen)
               endif
               ktext = 1
               kin = kin + 1
            endif

            if ( ktext.eq.1 .and. nlen.ne.0 ) then
               kl = nlen
            else
               call lbgone ( texta )
               kl = lens(texta)
            endif

            textt(kout:kout+kl-1) = texta(1:kl)
            kout = kout + kl

         endif
      enddo

      km = lens(ch)
      if ( km.gt.kin ) then
         kd = km - kin
         textt(kout+1:kout+kd) = ch(kin+1:km)
      endif

      kl = min(lens(textt),99)
      texto = textt(1:kl)
      call printo ( texto(1:kl) )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="pthead"> PTHEAD  </a>-- Put a character string as a file column header
C     It is put as the contents of a descriptor onto a file where the
C     descriptor is of the form 'HEADn' where 'n' is the desired
C     number 001 or 002 thru 099 to 999.
C     They should be at least 20 characters long and must be 72 or less.
C
C   alan penny            ral           1990 jan

      subroutine pthead ( file, num, text, ierr )

      implicit none
      include 'STARMAN_INC'

      character*(*) file	!i: File to write to
      integer       num		!i: Number of header to write to
      character*(*) text	!i: Header to write
      integer       ierr	!o: Error flag (always ok )
C--
      character*72 texta
      character texth*7
Cbegin


      if ( ST_FAILED ) return

      ierr = 0						!Set error flag

      write ( texth, '(''HEAD'',i3.3)' ) num		!Put header
      texta = text
      call ptdesc ( file, texth, texta )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="rcheck"> RCHECK  </a>-- Read a real number and returns true if bit n is set, false if not
C           (i.e.2**(n-1) is set.)
C
C     a j penny                stsci                   1987-02-24


      logical function rcheck ( val, num )
      implicit none

      real val		!i: Number to get result from
      integer num	!i: Bit in number to access
C--
      integer j, kval
Cbegin


      if ( num.lt.1 .or. num .gt.18 ) then
         rcheck = .false.
         call printo ( 'ERROR: Function RCHECK out of bounds' )
         return
      endif

      kval = nint(mod(val,100000000.0))
      if ( num.gt.1 ) then
         do j = 1, num - 1
            kval = kval/2
         enddo
      endif
      rcheck = .false.
      kval = mod(kval,2)
      if ( kval.eq.1 ) rcheck = .true.


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="rchzero"> RCHZERO  </a>-- Check a 2-d sub-image in a 3-d real array, and returns
C            .FALSE. if it is ALL zero, .TRUE.  if NOT ALL zero
C
C  a j penny                stsci                    1987-02-23

      subroutine rchzero ( data, nx, ny, nz, num, nxa, nya, check )

      implicit none
      include 'STARMAN_INC'

      integer nx		!i: X size of input array
      integer ny		!i: Y size of input array
      integer nz		!i: Z size of input array
      real    data(nx,ny,nz)	!i: Input array
      integer num		!i: Z plane in input array to use
      integer nxa		!i: X extent of valid area in Z-plane used
      integer nya		!i: Y extent of valid area in Z-plane used
      logical check		!o: Result. (True if sub-image zero
				!            False if non-zero)
C--
      integer j, k
Cbegin


      if ( ST_FAILED ) return

      check = .false.
      do k = 1, nya
         do j = 1, nxa
            if ( data(j,k,num).ne.0.0 ) check = .true.
         enddo
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="rvtext"> RVTEXT  </a>-- Put a real number into a character string
C
C alan penny                  ral          1993 Feb

      subroutine rvtext ( rv, text )

      implicit none
      include 'STARMAN_INC'

      real              rv              !i: Input number
      character*(*)	text		!o: Output text string
					!    Must be >= 11 characters long
C--
      integer j, kl
      character*50 texta
Cbegin


      if ( ST_FAILED ) return

      if ( abs(rv).gt.1.0e10 .or. abs(rv).lt.1.0e-3 ) then
         write ( texta, '(g17.5)' ) rv
      else
         write ( texta, '(f20.7)' ) rv
         j = 15 + max(0.0,alog10(1000000.0/abs(rv)))
         if ( j.lt.20 ) texta(j:) = ' '
      endif

      call lbgone ( texta )
      call charln ( texta, kl )
      kl = min(kl,11)
      text = texta(1:kl)


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="trunc"> TRUNC  </a>-- (Function) Truncate no of digits before decimal point
C  Thus if you want a number to be limited between
C                +99*99.0 and -9*99.0
C  where * can be any number of nines, but the -ve one has one less.
C  Useful in listing numbers to ensure they do not overflow bounds.
C
C    alan penny             ral               1989-08-13

      real function trunc ( a, n )

      implicit none

      real     a      !i: input
      integer  n      !i: Max no of characters before decimal point
C--
      real rmin, rmax
Cbegin


      rmax = 10.0**max(1.0,real(n))
      rmin = -1.0*(rmax/10.0)
      trunc = max((rmin+1.0),min((rmax-1.0),a))


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="trunc_e"> TRUNC_E  </a>-- (Function) Truncate no of digits after decimal point
C  Thus if you want a number to be rounded
C      123.4567 can go to  123.45
C     -123.4567 can go to -123.4567
C
C    alan penny             ral               1989-08-13

      real function trunc_e ( a, n )

      implicit none

      real     a      !i: input
      integer  n      !i: Max no of characters after decimal point
C--
      real ab, aat, sv
      integer k
Cbegin


      sv = sign(1.0,a)
      ab = abs(a)
      k = int(ab)
      aat = real(10**n)
      trunc_e = sv*(real(k)+(real(int(aat*(ab-real(k))))/aat))


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="tyhelp"> TYHELP  </a>-- Type out help
C
C     a j penny                stsci                   1987-02-24

      subroutine tyhelp ( thelp, nh, cmdlst, ksw, klw, jcon, num )

      implicit none
      include 'STARMAN_INC'

      integer		nh		!i: No of help lines
      character*68	thelp(*)	!i: Help text
      character*(*)	cmdlst		!i: Command list
      integer		ksw(200)	!i: Start posn of commands in list
      integer		klw(200)	!i: Length of commands in list
      integer		jcon(200)	!i: Order of commands in list
      integer		num		!i: No of commands in list
C--
      integer k, kl, j, ja, ks, ke
      logical more
Cbegin


      if ( ST_FAILED ) return

      call printo ( 'For more help (when responding to :=) ' )
      call printo ( '     - on parameters, type "?" ' )
      call printo ( '     - on the program, type "??" ')
      call printo ( '     - to exit, type "!!" ' )
      call printo ( ' ' )
      kl = 4

      k = 0
      if ( nh.ge.1 ) then
         more = .true.
         do while ( k.lt.nh .and. more )
            k = k + 1
            kl = kl + 1
            call printo ( thelp(k) )
            if ( k.ne.nh .and. mod(kl,20).eq.0 ) then
               call morehelp ( more )
            endif
         enddo
      else
         call printo (
     +           'No help available. Try "?" or "$help PROGRAM_NAME"' )
         call printo ( 'Options are:-' )
         call printo ( '--------------------------------' )
         kl = kl + 3
         more = .true.
         do while ( k.lt.num .and. more )
            k = k + 1
            kl = kl + 1
            j = 1
            do ja = 1, num
               if ( jcon(ja).eq.k ) j = ja
            enddo
            ks = ksw(j)
            ke = ks + klw(j) - 1
            if ( (ke-ks).gt.49 ) ke = ks + 49
            call printo ( cmdlst(ks:ke) )
            if ( k.ne.num .and. mod(kl,20).eq.0 ) then
                call morehelp ( more )
            endif
          enddo
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="uppcase"> UPPCASE  </a>-- Convert a character string to upper case
C
C a j penny             ral                          1991 June

      subroutine uppcase ( a, b )

      implicit none
      include 'STARMAN_INC'

      character*(*)  a		!i: Input string
      character*(*)  b		!o: Output string
C--
      integer j, k, kl, lens
      external lens
Cbegin


      if ( ST_FAILED ) return

      b = a
      kl = lens(b)
      do k = 1, kl
         j = ichar(b(k:k))
         if ( j.ge.97 .and.  j.le.122 ) b(k:k) = char(j-32)
      enddo

      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="valform"> VALFORM  </a>-- Formats a real number into a 12 character text string
C
C   alan penny                   RAL            1991 May

      subroutine valform ( val, text )

      implicit none
      include 'STARMAN_INC'

      real            val	!i: Input number
      character*12   text	!o: Output text string
C--
      character*40 texta
      integer j, k, lens
      external lens
Cbegin


      if ( ST_FAILED ) return

      if ( val.eq.0.0 ) then
         texta = '0.0'
      elseif ( abs(val).gt.1.0e10 .or. abs(val).lt.1.0e-3 ) then
         write ( texta, '(g17.5)' ) val
      else
         write ( texta, '(f20.7)' ) val
         j = 15 + max(0.0,alog10(1000000.0/abs(val)))
         if ( val.lt.10.0 ) j = j - 1
         if ( j.lt.20 ) texta(j:) = ' '
      endif

      call lbgone ( texta )
      k = min(12,lens(texta))
      text = texta(1:k)


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="wcheck"> WCHECK  </a>-- Write 1/0 into bit n of a real number if flag true/false
C           (i.e.2**(n-1)) if true or false flag.
C
C     a j penny                stsci                   1987-02-24


      subroutine wcheck ( val, num, test )

      implicit none
      include 'STARMAN_INC'

      real val			!i/o: Storage number
      integer num		!i:   Bit in number to write to
      logical test		!i:   if true, write 1, else 0
C--
      integer j, kval, jval, ival, mval
Cbegin


      if ( ST_FAILED ) return

C  Check not too far to left

      if ( num.lt.1 .or. num .gt.18 ) then
         call printo ( 'ERROR: Subroutine WCHECK out of bounds' )
         return
      endif

C  Get vals to left (jval) and from the bit to left (ival)

      kval = nint(mod(val,1000000.0))
      ival = kval
      if ( num.gt.1 ) then
         do j = 1, num - 1
            ival = ival/2
         enddo
      endif
      jval = ival/2

C  Shift left part back one step, and set bit

      mval = jval*2
      if ( test ) mval = mval + 1

C  Shift new left part back to original position

      if ( num.gt.1 ) then
         do j = 1, num-1
            mval = mval*2
         enddo
      endif

C  Restore right part

      if ( num.gt.1 ) then
         do j = 1, num-1
            ival = ival*2
         enddo
      endif
      ival = kval - ival

C  Get new number

      mval = mval + ival

C Return value

      val = mval


      end

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="ischar"> ISCHAR  </a>-- (Fn) Is this a character?
C
C  alan Penny               ral             1991 Dec

      logical function ischar ( arg )
      implicit none
      character*1      arg	!i: Input character
C--
Cbegin
      ischar = (arg.ge.'A') .and. (arg.le.'Z')	
      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="isnumb"> ISNUMB  </a>-- (Fn) Is this a number?
C
C  alan Penny               ral             1991 Dec

      logical function isnumb ( arg )
      implicit none
      character*1      arg	!i: Input character
C--
Cbegin
      isnumb = ((arg.ge.'0') .and. (arg.le.'9')).or.(arg.eq.'.' )
      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="issign"> ISSIGN  </a>-- (Fn) Is this a sign?
C
C  alan Penny               ral             1991 Dec

      logical function issign ( arg )
      implicit none
      character*1      arg	!i: Input character
C--
Cbegin
      issign = (arg.eq.'+') .or. (arg.eq.'-')
      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C  This is  STARFLIB1.FOR
C
C It contains:-
C
C ACUBINT    Cubic interpolates value/slope at a point in a set of 4 values
C CUBINT     Cubic interpolates value/slope at a point in a set of 4 values
C CUBINTX    Cubic interpolates value at a point in a set of 4 values



CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="cubint"> CUBINT  </a>-- Cubic interpolates value/slope at a point in a set of 4 values
C  Given values for a function F(x) at positions x=-1,0,1,2, this
C  function estimates a value for the function at a position X,
C  using a cubic interpolating polynomial.  The specific polynomial used
C  has the properties CUBINT(0)=F(0), CUBINT(1)=F(1), and the first
C  derivative of CUBINT with respect to x is continuous at x=0 and x=1.
C
C  P B STETSON                  DAO                1986
C  A j penny                        ral             1991

      real function  cubint ( f, x, dfdx )

      implicit none
      real f(0:0)	!i: Data values (-1),(0),(1),(2)
      real x		!i: Position to interpolate at (0<=x<1)
      real dfdx		!o: Fitted slope df/dx at x
C--
      real c1, c2, c3
Cbegin


      c1 = 0.5*(f(1)-f(-1))
      c2 = 2.0*f(1)+f(-1)-0.5*(5.0*f(0)+f(2))
      c3 = 0.5*(3.0*(f(0)-f(1))+f(2)-f(-1))
      cubint = x*(x*(x*c3+c2)+c1) + f(0)
      dfdx = x*(x*c3*3.0+2.0*c2) + c1


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="acubint"> ACUBINT  </a>-- Cubic interpolates value/slope at a point in a set of 4 values
C  Given values for a function F(x) at positions x=-1,0,1,2, this
C  function estimates a value for the function at a position X,
C  using acubic interpolating polynomial.  The specific polynomial used
C  has the properties ACUBINT(0)=F(0), ACUBINT(1)=F(1), and the first
C  derivative of ACUBINT with respect to x is continuous at x=0 and x=1.
C
C  P B STETSON                  DAO                1986
C  A j penny                        ral             1991

      real function  acubint ( f, x, dfdx )

      implicit none
      real f(0:0)	!i: Data values (-1),(0),(1),(2)
      real x		!i: Position to interpolate at (0<=x<1)
      real dfdx		!o: Fitted slope df/dx at x
C--
      real c1, c2, c3
Cbegin


      c1 = 0.5*(f(1)-f(-1))
      c2 = 2.0*f(1)+f(-1)-0.5*(5.0*f(0)+f(2))
      c3 = 0.5*(3.0*(f(0)-f(1))+f(2)-f(-1))
      acubint = x*(x*(x*c3+c2)+c1) + f(0)
      dfdx = x*(x*c3*3.0+2.0*c2) + c1


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="cubintx"> CUBINTX  </a>-- Cubic interpolates value at a point in a set of 4 values
C  Given values for a function F(x) at positions x=-1,0,1,2, this
C  function estimates a value for the function at a position X,
C  using a cubic interpolating polynomial.  The specific polynomial used
C  has the properties CUBINTX(0)=F(0), CUBINTX(1)=F(1), and the first
C  derivative of CUBINTX with respect to x is continuous at x=0 and x=1.
C
C  P B STETSON                      DAO 1989
C  A j penny                        ral             1991

      real function  cubintx ( f, x )

      implicit none
      real f(0:0)	!i: Data values (-1),(0),(1),(2)
      real x		!i: Position to interpolate at (0<=x<1)
C--
      real c1, c2, c3
Cbegin


      c1 = 0.5*(f(1)-f(-1))
      c2 = 2.0*f(1)+f(-1)-0.5*(5.0*f(0)+f(2))
      c3 = 0.5*(3.0*(f(0)-f(1))+f(2)-f(-1))
      cubintx = x*(x*(x*c3+c2)+c1) + f(0)


      end

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C   This is STARFLIB_ADAM.F
C
C  This contains the subroutines which the programmer uses to
C  access ADAM specific cpabilities:-
C
C*********************************
C Subroutines sorted by function:-
C
C   Command line/parameter system:
C
C FILE_IS     Does this HDS file exist?
C FILE_PAR    Writes the name of an HDS file to a parameter
C GET1C       Get a character string from the CL
C GETNC       Get a number of character strings from the CL
C GETG(BIR)   Get a number of booleans:integers:reals from the CL
C PRINTO      Write a line out to the CL
C PUTG(IR)    Put (1:2:3) (integer/real) number(s) to the CL
C
C   Image/table input/output:
C
C CANPAR      Cancel parameter name connection - actually cancel associtation
C             to a NDF and parameter
C OPIMGR      Open an input 2d read-only generic image
C OPIMGW      Open an output 2d write-only generic image
C OPIM4G(RW)  Open an in/output 4d read-only/write-only generic image
C OPTAB(RW)   Open an input read-only/output write-only  table
C
C   Work space:
C
C GTWRKG      Open computer work space
C WRKCAN      Cancel work space name connection
C
C   Internal image/table handling:
C
C (IT)COPDES  Copy all headers from one file to next for image/table
C DLDES       Delete a descriptor from a file
C GTDESC_GEN  Get a character string from a file defined extension descriptor
C GTDES(CIR)  Get a (character string:integer:real) from a file descriptor
C GTDESN      Get the name of the 'nth' descriptor of a file
C GTDESN_GEN  Get the name of the 'nth' descriptor of a file extension
C GTIM(IRS)D  Get descriptors (BSCALE,BZERO,(R)INVAL,TITLE) from image
C PTDESCN     Write character strings into the header area of an opened file
C PTDES(CIR)  Write a character string/integer/real into the header area of an opened file
C
C   Misc:
C
C AJRAN         Random number generator
C AJSEED        Set seed for Random number generator
C AJDATE        Return a string with date and time
C CHARTO(ILR)   Convert character string to (integer:logical:real)
C FILEBEG       Start up file access system (ndf space common block)
C FIND_SPACE    Find gap in work space common block
C ISBSWOP       Is the computer swopping bytes on data read?
C ISVMS         Is the computer running VMS?
C STARMAN_END   Close down Starman controls
C STARMAN_START Set up Starman defaults
C SPACE_NDF     Find gap in ndf space common block
C WRKBEG        Set up computer work space information
C
C**********************************
C Subroutines in alpbetical order:-
C
C AJRAN       Random number generator
C AJSEED      Set seed for Random number generator
C AJDATE      Return a string with date and time
C CANPAR      Cancel parameter name connection - actually cancel associtation
C             to a NDF and parameter
C CHARTO(ILR) Convert character string to (integer:logical:real)
C (IT)COPDES  Copy all headers from one file to next for image/table
C DLDES       Delete a descriptor from a file
C FILEBEG     Start up file access system (ndf space common block)
C FILE_IS     Does this HDS file exist?
C FILE_PAR    Writes the name of an HDS file to a parameter
C FIND_SPACE  Find gap in work space common block
C GET1C       Get a character string from the CL
C GETNC       Get a number of character strings from the CL
C GETG(BIR)   Get a number of booleans:integers:reals from the CL
C GTDESC_GEN  Get a character string from a file defined extension descriptor
C GTDES(CIR)  Get a (character string:integer:real) from a file descriptor
C GTDESN      Get the name of the 'nth' descriptor of a file
C GTDESN_GEN  Get the name of the 'nth' descriptor of a file extension
C GTIM(IRS)D  Get descriptors (BSCALE,BZERO,(R)INVAL,TITLE) from image
C GTWRKG      Open computer work space
C ISBSWOP     Is the computer swopping bytes on data read?
C ISVMS       Is the computer running VMS?
C OPIMGR      Open an input 2d read-only generic image
C OPIMGW      Open an output 2d write-only generic image
C OPIM4G(RW)  Open an in/output 4d read-only/write-only generic image
C OPTAB(RW)   Open an input read-only/output write-only  table
C PRINTO      Write a line out to the CL
C PTDESCN     Write character strings into the header area of an opened file
C PTDES(CIR)  Write a character string/integer/real into the header area of an opened file
C PUTG(IR)    Put (1:2:3) (integer/real) number(s) to the CL
C SPACE_NDF   Find gap in ndf space common block
C STARMAN_END  Close down Starman controls
C STARMAN_START Set up Starman defaults
C WRKBEG      Set up computer work space information
C WRKCAN      Cancel work space name connection


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CX<a name="c ajran"> C AJRAN  </a>-- (FN) Random number generator - uniform between 0 and 1
CXC
CXC   a j penny                    ral                 1991 Nov
CX
CX      real function ajran ( rvd )
CX
CX      implicit none
CX      include 'NDF_PAR'
CX      include 'SAE_PAR'
CX
CX      real    rvd	!i: dummy number, not used
CXC--
CX      real rv
CX      integer status, nran, maxn
CXCbegin
CX
CX
CX      status = SAI__OK
CX      call psx_rand ( nran, maxn, rv, status )
CX      ajran = rv
CX
CX
CX      end
CX
CXCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CX<a name="c ajseed"> C AJSEED  </a>-- Set seed for Random number generator
CXC
CXC   a j penny                    ral                 1991 Nov
CX
CX      subroutine ajseed ( nran )
CX
CX      implicit none
CX      include 'NDF_PAR'
CX      include 'SAE_PAR'
CX      include 'ST_LIMITS_INC'
CX
CX      integer	nran	!i: Seed
CXC--
CX      integer status
CXCbegin
CX
CX
CX      status = SAI__OK
CX      call psx_srand ( nran, status )
CX
CX
CX      end
CX
CX

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="ajdate"> AJDATE  </a>-- Return character string with date and time
C
C   a j penny                    ral                 1991 Nov

      subroutine ajdate ( date_time )

      implicit none
      include 'SAE_PAR'
      include 'STARMAN_INC'

      character*(*)    date_time	!o: Date and time in format
					!   Wed Apr 17 09:01:04 1991
					!   (needs up to 24 characters)
C--
      integer status, nticks
Cbegin


      if ( ST_FAILED ) return

      status = SAI__OK

      call psx_time ( nticks, status )
      call psx_ctime ( nticks, date_time, status )


      end

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="canpar"> CANPAR  </a>-- Cancel parameter name connection - actually cancel associtation
C           to a NDF and parameter
C
C  alan penny              ral               1990 Jan

      subroutine canpar ( text )

      implicit none
      include 'NDF_PAR'
      include 'SAE_PAR'
      include 'ST_ADAM_INC'
      include 'STARMAN_INC'

      character*(*) text	!i: Name of parameter to cancel
C--
      integer istat, n, kl, lens
      logical found, chr_equal
      external chr_equal, lens
Cbegin


      if ( ST_FAILED ) return

      if ( text.eq.' ' ) then

         do n = 1, NDF_LIMIT                				!Cancel all current files
            istat = SAI__OK
            if ( NDF_NAME(n).ne.'-' ) then
               if ( SNDF(n).ne.NDF__NOID ) then
                  call ndf_annul ( SNDF(n), istat )
                  call par_cancl ( NDF_NAME(n), istat )
               else
                  call printo ( 'INVALID NDF identifier ')
               endif
               NDF_NAME(n) = '-'
               NDF_COUNTER = NDF_COUNTER - 1
            endif
         enddo

      else

         istat = SAI__OK
         kl = min(50,lens(text))
         n = 1
         found = .false.
         do while ( .not.found )
            found = chr_equal ( text(1:kl), NDF_NAME(n) )
            if ( found ) then
               if ( SNDF(n).ne.NDF__NOID ) then
                  call ndf_annul ( SNDF(n), istat )
               else
                  call printo ( 'INVALID NDF identifier ')
               endif
               NDF_NAME(n) = '-'
               NDF_COUNTER = NDF_COUNTER - 1
            else
               n = n + 1
               if ( n.gt.NDF_LIMIT ) then
                  found = .true.
                  kl = min(45,kl)
                  call printo ( 'Cant find NDF parameter to'//
     +                          ' annul: '//text(1:kl) )
               endif
            endif
         enddo

         call par_cancl ( text, istat )

      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="chartoi"> CHARTOI  </a>-- Convert character string to integer
C
C    a j penny                 ral                  1991 Dec

      subroutine chartoi ( ch, iv, istat )

      implicit none
      include 'SAE_PAR'
      include 'STARMAN_INC'

      character*(*)      ch      !i: Character string
      integer            iv      !o: Integer
      integer            istat   !o: Error flag (0=ok, 1=bad)
C--
      integer ierr
Cbegin


      if ( ST_FAILED ) return

      ierr = SAI__OK
      call chr_ctoi ( ch, iv, ierr )

      istat = 0
      if ( ierr.ne.SAI__OK ) istat = 1


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="chartol"> CHARTOL  </a>-- Convert character string to logical
C
C    a j penny                 ral                  1991 Dec

      subroutine chartol ( ch, bv, istat )

      implicit none
      include 'SAE_PAR'
      include 'STARMAN_INC'

      character*(*)      ch      !i: Character string
      logical            bv      !o: Integer
      integer            istat   !o: Error flag (0=ok, 1=bad)
C--
      integer ierr
Cbegin


      if ( ST_FAILED ) return

      ierr = SAI__OK
      call chr_ctol ( ch, bv, ierr )

      istat = 0
      if ( ierr.ne.SAI__OK ) istat = 1


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="chartor"> CHARTOR  </a>-- Convert character string to real
C
C    a j penny                 ral                  1991 Dec

      subroutine chartor ( ch, rv, istat )

      implicit none
      include 'SAE_PAR'
      include 'STARMAN_INC'

      character*(*)      ch      !i: Character string
      real               rv      !o: Real
      integer            istat   !o: Error flag (0=ok, 1=bad)
C--
      integer ierr
Cbegin


      if ( ST_FAILED ) return

      ierr = SAI__OK
      call chr_ctor ( ch, rv, ierr )


      istat = 0
      if ( ierr.ne.SAI__OK ) istat = 1


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="icopdes"> ICOPDES  </a>-- Copy all headers from one file to next for image
C
C    a j penny                 ral                  1990-07-09

      subroutine icopdes ( ifile, ofile, istat )

      implicit none
      include 'DAT_PAR'
      include 'NDF_PAR'
      include 'SAE_PAR'
      include 'STARMAN_INC'

      character*(*)     ifile           !i: Parameter name for input file
      character*(*)     ofile           !i: Parameter name for output file
      integer           istat           !o: Error flag (0=ok;1=bad)
C--
      integer istata, indf, ondf, i, ncomp
      character*80 title,label,dscr
      character*(DAT__SZLOC) iloc,oloc,cloc, oloc2
      logical there, outth
Cbegin


      if ( ST_FAILED ) return

      istat = 0
      istata = SAI__OK

      call ndf_exist ( ifile, 'READ', indf, istata )
      if ( indf.eq.NDF__NOID ) then
         istat = 1
         return
      endif
      call ndf_exist ( ofile, 'UPDATE', ondf, istata )
      if ( ondf.eq.NDF__NOID ) then
         call ndf_annul ( indf, istata )
         istat = 1
         return
      endif

      call ndf_xstat ( indf, 'FITS', there, istata )    		!Check there is input FITS
      if ( there ) then
         call ndf_loc ( ondf, 'UPDATE', oloc, istata )
         call dat_find (oloc,'MORE',oloc2,istata)

         call ndf_xstat ( ondf, 'FITS', outth, istata )  		!See if FITS there already
         if ( outth ) call dat_erase ( oloc2, 'FITS', istata ) 		!If it is delete it

         call ndf_xloc ( indf, 'FITS', 'READ', iloc, istata ) 		!Get locator to input fits
         call dat_copy ( iloc, oloc2, 'FITS', istata )  		! Copy over
         call dat_annul ( oloc2, istata )
         call dat_annul ( oloc, istata )
         call dat_annul ( iloc, istata )
      endif

      call ndf_xstat ( indf, 'STARMAN', there, istata )			!Check input image
      if ( .not.there ) then						! has STARMAN extension - if not exit
         call printo ( 'No STARMAN extension in INPUT image' )
         call ndf_annul ( indf, istata )
         call ndf_annul ( ondf, istata )
         istat = 1
         return
      endif

      call ndf_xstat ( ondf, 'STARMAN', there, istata )			!See if output extension has
      if ( .not.there ) then						! STARMAN EXT, if not create
         call ndf_xnew ( ondf, 'STARMAN', 'EXT', 0, 0, oloc, istata )
      else
         call ndf_xloc ( ondf, 'STARMAN', 'WRITE', oloc, istata )	!Write access means previous info deleted
      endif

      call ndf_cget ( indf, 'TITLE', title, istata )                    !Copy in new label and title
      call ndf_cget ( indf, 'LABEL', label, istata )
      call ndf_cput ( title, ondf, 'TITLE', istata )
      call ndf_cput ( label, ondf, 'LABEL', istata )

      call ndf_xloc ( indf, 'STARMAN', 'READ', iloc, istata )           !Find locators to extensions

      call dat_ncomp ( iloc, ncomp, istata )
      if ( ncomp.ge.2 ) then
         do i = 2, ncomp                                                !Copy extension
            call dat_index ( iloc, i, cloc, istata )
            call dat_name ( cloc, dscr, istata )
            call dat_copy ( cloc, oloc, dscr, istata )
            call dat_annul ( cloc, istata )
         enddo
      endif
      call dat_annul ( iloc, istata )
      call dat_annul ( oloc, istata )
      call ndf_annul ( indf, istata )
      call ndf_annul ( ondf, istata )

      if ( istata.ne.SAI__OK ) then
         call printo ( ' ERROR: Error in copying descriptors from'//
     +                        ' one image to another.' )
         call printo ( ' ERROR:   - Happened in subroutine ICOPDES' )
         istat = 1
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="tcopdes"> TCOPDES  </a>-- Copy all headers from one file to next for table
C
C    a j penny                 ral                  1990-07-09

      subroutine tcopdes ( ifile, ofile, istat )

      implicit none
      include 'SAE_PAR'
      include 'STARMAN_INC'

      character*(*)	ifile		!i: Parameter name for input file
      character*(*)	ofile		!i: Parameter name for output file
      integer		istat		!o: Error flag (0=ok;1=bad)
C--
Cbegin


      if ( ST_FAILED ) return

      istat = SAI__OK
      call icopdes ( ifile, ofile, istat )

      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="dldes"> DLDES  </a>-- Delete a descriptor from a file
C
C  a j penny                     ral            1990-06-15

      subroutine dldes ( name, dscr, istat )

      implicit none
      include 'DAT_PAR'
      include 'SAE_PAR'
      include 'NDF_PAR'
      include 'STARMAN_INC'

      character*(*)	name		!i: File name
      character*(*)	dscr		!i: Descriptor
      integer		istat		!o: 0 => ok;1 = failure
C--
      integer istata, ndf
      character*(DAT__SZLOC) loc
      logical there
Cbegin


      if ( ST_FAILED ) return

      istata = SAI__OK

      istat = 1
      call ndf_exist ( name, 'UPDATE', ndf, istata )
      if (ndf.eq.NDF__NOID) return
      call ndf_xstat ( ndf, 'STARMAN', there, istata )
      if ( there ) then
        call ndf_xloc ( ndf, 'STARMAN', 'UPDATE', loc, istata )
        call dat_erase ( loc, dscr, istata )
        call dat_annul ( loc , istata )
        call ndf_annul ( ndf, istata )
      else
        call ndf_annul ( ndf, istata )
        istata =  1
      endif

      istat = 0
      if ( istata.ne.SAI__OK ) istat = 1


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="filebeg"> FILEBEG  </a>-- Start up file access system (ndf space common block)
C
C  Patrick Morris          leeds          1991 Dec

      subroutine filebeg ( )

      implicit none
      include 'ST_ADAM_INC'
      include 'STARMAN_INC'
C--
      integer k
Cbegin


      if ( ST_FAILED ) return

      NDF_COUNTER = 0
      do k = 1, NDF_LIMIT
         NDF_NAME(k) = '-'
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="file_is"> FILE_IS  </a>-- Does this HDS file exist?
C
C   alan penny               ral         1990 Jan

      subroutine file_is ( name, flag )

      implicit none
      include 'SAE_PAR'
      include 'DAT_PAR'
      include 'DAT_ERR'
      include 'STARMAN_INC'

      character*(*) name	!i: Text string file name
      logical       flag	!o: .true. if is an HDS file, .false. if not
C--
      character*(DAT__SZLOC) nloc
      integer status
Cbegin


      if ( ST_FAILED ) return


      flag = .true.

      status = SAI__OK
      call err_mark
      call hds_open ( name, 'READ', nloc, status )
      if ( status.eq.DAT__FILNF ) then
         call err_annul ( status )
         flag = .false.
      else
         call hds_close ( nloc, status )
      endif
      call err_rlse


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="file_par"> FILE_PAR  </a>-- Writes the name of an HDS file to a parameter
C
C     Normally, the handles to HDS data files are locators and files
C     are obtained via the parameter system.  However, some
C     applications can generate sensible names, especially when dealing
C     a long series of files that are to be created without manual
C     intervention.  There is no direct mechanism in the user-level
C     parameter-system library to put a name into the associated
C     parameter.  This routine provides that functionality.
C     This cannot be used to obtain the names of objects within
C     an HDS file.
C
C  Malcolm J. Currie (STARLINK)
C  alan penny                  ral  1994 March

      subroutine file_par ( filename, parname, istat )

      implicit none
      include 'SAE_PAR'
      include 'STARMAN_INC'

      character*(*) filename		!i: The name of the file
      character*(*) parname		!i: Parameter name associated with
					!   the data object whose name is to be written
      integer       istat		!o: Error flag (0=ok; 1=bad)
C--
      integer imcode, status
Cbegin


      if ( ST_FAILED ) return

      status = SAI__OK
      call subpar_findpar ( parname, imcode, status )		!Get the ADAM internal code that refers to the piece of
								! parameter space associated with the input parameter PARNAM.

      call subpar_putname ( imcode, filename, status )		!Associate the file name with the ADAM internal pointer.

      istat = 0
      if ( status.ne.SAI__OK ) istat = 1


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="find_space"> FIND_SPACE  </a>-- Find gap in work space common block
C
C  Patrick Morris          leeds          1991 Dec

      subroutine find_space ( n )

      implicit none
      include 'ST_ADAM_INC'
      include 'STARMAN_INC'

      integer	n		!o : Available space, -1 no space
C--
      logical found
Cbegin


      if ( ST_FAILED ) return

      if ( WS_COUNTER.ge.WORK_LIMIT ) then
          n = -1
          return
      endif

      found = .false.
      n = 0
      do while ( .not.found )
          n = n + 1
          if ( n.gt.WORK_LIMIT ) then
             n = -1
             found = .true.
          else
             found = ( WS_NAME(n).eq.'-' )
          endif
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="get1c"> GET1C  </a>-- Get a character string from the CL
C
C   a j penny                 dao           1988-04-25

      subroutine get1c ( param, out, in, def )

      implicit none
      include 'SAE_PAR'
      include 'PAR_ERR'
      include 'STARMAN_INC'

      character*(*) param		!i: Command line paramter
      character*(*) out			!o: Character string obtained
      character*(*) in			!i: Default character string to use
      logical       def			!i: If .true., null entry ok, and
					!   default taken; if not ask again
C--
      character text*200, atext*200
      integer istat, nvals, nloop, nmax
      logical loop
Cbegin


      if ( ST_FAILED ) return

      istat = SAI__OK
      call par_def1c ( param, 1, in, istat )

      nloop = 1
      loop = .true.
      nmax = 1
      do while ( loop .and. nloop.le.nmax )
         loop = .false.

         text = in
         istat = SAI__OK

         call err_mark
         call par_get1c ( param, 1, text, nvals, istat )
         call par_cancl ( param, istat )
         if ( istat.eq.PAR__ABORT ) then
            ST_FAILED = .true.
            call err_annul ( istat )
            call err_rlse
            return
         elseif ( istat.eq.PAR__INVST ) then
            atext = ' ERROR: Parameter name - '//param//' - invalid'
            call printo ( atext )
            loop = .true.
         elseif ( .not.def .and. istat.eq.PAR__NULL ) then
            text = ' ERROR: Null entry unacceptable'
            if ( nloop.le.nmax-1 ) atext = ' ERROR: Null entry '//
     +                           'unacceptable - try again'
            call printo ( atext )
            loop = .true.
         else
            if ( istat.eq.PAR__INVST ) then
               out = in
            else
               out = text
            endif
         endif
         call err_rlse

         nloop = nloop + 1
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="getnc"> GETNC  </a>-- Get a number of character strings from the CL
C
C   a j penny                 dao           1988-04-25

      subroutine getnc ( param, out, nin, nout, def )

      implicit none
      include 'SAE_PAR'
      include 'PAR_ERR'
      include 'STARMAN_INC'

      character*(*) param		!i: Parameter to get info from
      integer       nin			!i: Max no of strings to get
      character*(*) out(nin)		!o: Strings got
      integer       nout		!o: No of strings got
      logical       def			!i: Is null response ok?
C--
      character text*50, atext*70
      character*500 intext
      integer istat, nvals, nloop, nmax, k
      integer ks(1000),ke(1000)
      logical loop
Cbegin


      if ( ST_FAILED ) return

      istat = SAI__OK
      call par_def0c ( param, ' ', istat )

      nloop = 1
      loop = .true.
      nmax = 1
      do while ( loop .and. nloop.le.nmax )
         loop = .false.

         istat = SAI__OK

         intext = ' '
         call err_mark
         call par_get0c ( param, intext, istat )
         call par_cancl ( param, istat )
         if ( istat.eq.PAR__ABORT ) then
            ST_FAILED = .true.
            call err_annul ( istat )
            call err_rlse
            return
         elseif ( istat.eq.PAR__INVST ) then
            atext = ' ERROR: Parameter name - '//param//' - invalid'
            call printo ( atext )
            loop = .true.
         elseif ( .not.def .and. istat.eq.PAR__NULL ) then
            atext = ' ERROR: Null entry unacceptable'
            if ( nloop.le.nmax-1 ) atext = ' ERROR: Null entry '//
     +                        'unacceptable - try again'
            call printo ( atext )
            loop = .true.
         elseif ( istat.ne.SAI__OK ) then
            call err_rep ( ' ', ' ERROR: ^status', istat )
            loop = .true.
         else
            do k = 1, nin
               call chr_fill ( ' ', out(k) )
            enddo
            call numel ( intext, nvals, ks, ke )
            nout = min( nin, nvals )
            do k = 1, nout
               if ( ke(k).ge.ks(k) ) out(k) = intext(ks(k):ke(k))
            enddo
         endif
         call err_rlse
         nloop = nloop + 1

      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="getgi"> GETGI  </a>-- Get a number of integers from the CL
C
C    a j penny                 ral                   1988-Nov


      subroutine getgi ( param, ivn, num, def, imin, imax )

      implicit none
      include 'SAE_PAR'
      include 'PAR_ERR'
      include 'STARMAN_INC'

      character*(*) param	!i: Parameter to access in CL
      integer       num		!i: Number of integers
      integer	    ivn(num)	!i/o: Integers (defaults/gotten values)
      logical       def		!i: Is a null rsponse valid?
      integer       imin	!i: Min allowed value
      integer       imax	!i: Max allowed value
C--
      logical loop, isok
      integer nvals, istat, nloop, nmax, k, iv(5), iva
      character text*50, atext*70
Cbegin


      if ( ST_FAILED ) return

      nloop = 1
      loop = .true.
      nmax = 1
      do while ( loop .and. nloop.le.nmax )
         loop = .false.
         do k = 1, num
            iv(k) = ivn(k)
         enddo
         istat = SAI__OK
         isok = .true.

         call err_mark
         call par_def1i ( param, num, iv, istat )
         call par_get1i ( param, num, iv, nvals, istat )
         call par_cancl ( param, istat )
         if ( istat.eq.PAR__ABORT ) then
            ST_FAILED = .true.
            call err_annul ( istat )
            call err_rlse
            return
         elseif ( istat.eq.PAR__INVST ) then
            atext = ' ERROR: Parameter name - '//param//' - invalid'
            call printo ( atext )
            loop = .true.
            isok = .false.
         elseif ( istat.ne.SAI__OK ) then
            atext = ' ERROR: Parameter error - '//param
            call printo ( atext )
            call err_rep ( ' ', ' ERROR: ^status', istat )
            loop = .true.
            isok = .false.
         elseif ( .not.def .and.nvals.ne.num ) then
            call pargi ( num )
            call printd ( ' ERROR: must input %d values' )
            loop = .true.
            isok = .false.
         else
            iva = iv(1)
            do k = 1, num
               iva = max(iva,iv(k))
            enddo
            if ( imax.lt.iva ) then
               write ( atext,'('' ERROR: over maximum value of '',
     +                       i11)' ) imax
               call printo ( atext )
               loop = .true.
               isok = .false.
            endif
            iva = iv(1)
            do k = 1, num
               iva = min(iva,iv(k))
            enddo
            if ( imin.gt.iva ) then
               write (atext,'('' ERROR: under minimum value of '',
     +                      i11)' ) imin
               call printo ( atext )
               loop = .true.
               isok = .false.
            endif
         endif

         call err_rlse
         nloop = nloop + 1

      enddo

      if ( nloop.eq.(nmax+1) .and. .not.isok ) then
         call printo ( ' WARNING: Default values taken' )
      else
         do k = 1, num
            ivn(k) = iv(k)
         enddo
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="getgb"> GETGB  </a>-- Get a number of booleans from the CL
C
C    a j penny                 ral                   1988-Nov


      subroutine getgb ( param, ivn, num, def )

      implicit none
      include 'SAE_PAR'
      include 'PAR_ERR'
      include 'STARMAN_INC'

      character*(*) param	!i: Parameter to access in CL
      integer       num		!i: Number of integers
      logical       ivn(num)	!i/o: Integers (defaults/gotten values)
      logical       def		!i: Is a null rsponse valid?
C--
      logical loop, isok
      integer nvals, istat, nloop, nmax, k
      character text*50, atext*70
      logical iv(5)
Cbegin


      if ( ST_FAILED ) return

      nloop = 1
      loop = .true.
      nmax = 1
      do while ( loop .and. nloop.le.nmax )
         loop = .false.

         do k = 1, num
            iv(k) = ivn(k)
         enddo
         istat = SAI__OK
         isok = .true.

         call err_mark
         call par_def1l ( param, num, iv, istat )
         call par_get1l ( param, num, iv, nvals, istat )
         call par_cancl ( param, istat )
         if ( istat.eq.PAR__ABORT ) then
            ST_FAILED = .true.
            call err_annul ( istat )
            call err_rlse
            return
         elseif ( istat.eq.PAR__INVST ) then
            atext = ' ERROR: Parameter name - '//param//' - invalid'
            call printo ( atext )
            loop = .true.
            isok = .false.
         elseif ( istat.ne.SAI__OK ) then
            atext = ' ERROR: Parameter error - '//param
            call printo ( atext )
            call err_rep ( ' ', ' ERROR: ^status', istat )
            loop = .true.
            isok = .false.
         elseif ( .not.def .and.nvals.ne.num ) then
            call pargi ( num )
            call printd ( ' ERROR: must input %d values' )
            loop = .true.
            isok = .false.
         endif
         call err_rlse
         nloop = nloop + 1

      enddo

      if ( nloop.eq.(nmax+1) .and. .not.isok ) then
         call printo ( ' WARNING: Default values taken' )
      else
         do k = 1, num
            ivn(k) = iv(k)
         enddo
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="getgr"> GETGR  </a>-- Get a number of reals from the CL
C
C    a j penny                 ral                   1988-Nov


      subroutine getgr ( param, rvn, num, def, rmin, rmax )

      implicit none
      include 'SAE_PAR'
      include 'PAR_ERR'
      include 'STARMAN_INC'

      character*(*) param	!i: Parameter to access in CL
      integer       num		!i: Number of reals
      real          rvn(num)	!i/o: Reals (defaults/gotten values)
      logical       def		!i: Is a null rsponse valid?
      real          rmin	!i: Min allowed value
      real          rmax	!i: Max allowed value
C--
      logical loop, isok
      integer nvals, istat, nloop, nmax, k
      real rv(5), rva
      character  text*50, atext*70
Cbegin


      if ( ST_FAILED ) return

      nloop = 1
      loop = .true.
      nmax = 1
      do while ( loop .and. nloop.le.nmax )
         loop = .false.

         do k = 1, num
            rv(k) = rvn(k)
         enddo
         istat = SAI__OK
         isok = .true.

         call err_mark
         call par_def1r ( param, num, rv, istat )
         call par_get1r ( param, num, rv, nvals, istat )
         call par_cancl ( param, istat )
         if ( istat.eq.PAR__ABORT ) then
            ST_FAILED = .true.
            call err_annul ( istat )
            call err_rlse
            return
         elseif ( istat.eq.PAR__INVST ) then
            atext = ' ERROR: Parameter name - '//param//' - invalid'
            call printo ( atext )
            loop = .true.
            isok = .false.
         elseif ( .not.def .and.nvals.ne.num ) then
            call pargi ( num )
            call printd ( ' ERROR: must input %d values' )
            loop = .true.
            isok = .false.
         else
            rva = rv(1)
            do k = 1, num
               rva = max(rva,rv(k))
            enddo
            if ( rmax.lt.rva ) then
               if ( abs(rmax).ge.1.0e7 ) then
                  write ( atext,'('' ERROR: over maximum value of '',
     +                                            g15.7)' ) rmax
               else
                  write ( atext,'('' ERROR: over maximum value of '',
     +                                            f15.7)' ) rmax
               endif
               call printo ( atext )
               loop = .true.
               isok = .false.
            endif
            rva = rv(1)
            do k = 1, num
               rva = min(rva,rv(k))
            enddo
            if ( rmin.gt.rva ) then
               if ( abs(rmin).ge.1.0e7 ) then
                  write ( atext,'('' ERROR: under minimum value of '',
     +                                             g15.7)' ) rmin
               else
                  write ( atext,'('' ERROR: under minimum value of '',
     +                                             f15.7)' ) rmin
               endif
               call printo ( atext )
               loop = .true.
               isok = .false.
            endif
         endif
         call err_rlse
         nloop = nloop + 1

      enddo

      if ( nloop.eq.(nmax+1) .and. .not.isok ) then
         call printo ( ' WARNING: Default values taken' )
      else
         do k = 1, num
            rvn(k) = rv(k)
         enddo
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gtdesc_gen"> GTDESC_GEN  </a>-- Get a character string from a file descriptor
C
C  a j penny                     dao          1988-04-19

      subroutine gtdesc_gen ( name, ext, dscr, cv, cdef, num, istat )

      implicit none
      include 'SAE_PAR'
      include 'NDF_PAR'
      include 'STARMAN_INC'

      character*(*)	name		!i: Parameter name for file
      character*(*)	ext		!i: Extension
      character*(*)	dscr		!i: Descriptor
      character*(*)	cv		!o: String got
      character*(*)	cdef		!i: Default string on failure
      integer		num		!o: No of lines got (min=1)
      integer		istat		!o: 0 => ok;1 = failure
C--
      integer istata, istatb, ndf
      logical there
Cbegin


      if ( ST_FAILED ) return

      if ( dscr.eq.' ' ) then
         istat = 1
         cv = ' '
         return
      endif

      istata = SAI__OK
      istat = 1
      istatb = 0
      cv = cdef
      num = 1
      call ndf_exist ( name, 'READ', ndf, istata )
      if ( ndf.eq.NDF__NOID ) return
      call ndf_xstat ( ndf, ext, there, istata )
      if ( there ) then
         if ( ( dscr.eq.'TITLE' ) .or. ( dscr.eq.'LABEL') .or.
     + 			( dscr.eq.'UNITS' ) ) then
	    call ndf_cget ( ndf, dscr, cv, istata )
         else
            call ndf_xgt0c ( ndf, ext, dscr, cv, istata )
         endif
      else
         if ( ext.eq.'STARMAN' ) then
            istatb = 1
            call printo(' WARNING: Cant access descriptors in '//
     +                    'file: If needed, use IMPORT' )
            call printo('         to load STARMAN extension from'//
     +                            ' FITS or other extension.')
            call printo('         Another way is via KAPPA FITSIMP.')
         endif
      endif
      call ndf_annul ( ndf, istata )

      istat = 0
      if ( istata.ne.SAI__OK .or. istatb.ne.0 ) then
         cv = cdef
         istat = 1
      endif


      end



CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gtdesc"> GTDESC  </a>-- Get a character string from a file STARMAN descriptor
C
C  a j penny                     dao          1988-04-19

      subroutine gtdesc ( name, dscr, cv, cdef, num, istat )

      implicit none
      include 'SAE_PAR'
      include 'NDF_PAR'
      include 'STARMAN_INC'

      character*(*)	name		!i: Parameter name for file
      character*(*)	dscr		!i: Descriptor
      character*(*)	cv		!o: String got
      character*(*)	cdef		!i: Default string on failure
      integer		num		!o: No of lines got (min=1)
      integer		istat		!o: 0 => ok;1 = failure
C--
Cbegin


      if ( ST_FAILED ) return

      istat = SAI__OK
      call gtdesc_gen ( name, 'STARMAN', dscr, cv, cdef, num, istat )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gtdesi"> GTDESI  </a>-- Get an integer value from the descriptor
C
C  a j penny                     dao          1988-04-19

      subroutine gtdesi ( file, dscr, iv, idef, istat )

      implicit none
      include 'SAE_PAR'
      include 'NDF_PAR'
      include 'STARMAN_INC'

      character*(*) file		!i: Parameter name for file
      character*(*) dscr		!i: Descriptor name
      integer iv			!o: descriptor value
      integer idef			!i: value loaded on failure
      integer istat			!o: 0=success;1=failure
C--
      integer istata, istatb, ndf
      logical there
Cbegin


      if ( ST_FAILED ) return

      if ( dscr.eq.' ' ) then
         istat = 1
         iv = 0
         return
      endif

      istata = SAI__OK
      istat = 1
      istatb = 0
      iv = idef
      call ndf_exist ( file, 'READ', ndf, istata )
      if ( ndf.eq.NDF__NOID ) return

      call ndf_xstat ( ndf, 'STARMAN', there, istata )
      if ( there ) then
         call ndf_xgt0i ( ndf, 'STARMAN', dscr, iv, istata )
      else
         istatb = 1
         call printo(' WARNING: Cant access descriptors in '//
     +                    'file: If needed, use IMPORT' )
         call printo('         to load STARMAN extension from'//
     +                            ' FITS or other extension.')
         call printo('         Another way is via KAPPA FITSIMP.')
      endif
      call ndf_annul ( ndf, istata )

      istat = 0
      if ( istata.ne.SAI__OK .or. istatb.ne.0 ) then
         iv = idef
         istat = 1
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gtdesn"> GTDESN  </a>-- Get the name of the 'nth' descriptor of a file
C
C  a j penny                     dao          1988-04-19

      subroutine gtdesn ( file, numd, name, istat )

      implicit none
      include 'SAE_PAR'
      include 'NDF_PAR'
      include 'STARMAN_INC'

      character*(*)	file		!i: Parameter name for file
      integer		numd		!i: Number of descriptor
      character*(*)	name		!o: Name of descriptor
      integer		istat		!o: 0 => ok;1 = failure
C--
Cbegin


      if ( ST_FAILED ) return

      istat = SAI__OK
      call gtdesn_gen ( file, numd, 'STARMAN', name, istat )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gtdesn_gen"> GTDESN_GEN  </a>-- Get the name of the 'nth' descriptor of a file extension
C
C  a j penny                     dao          1988-04-19

      subroutine gtdesn_gen ( file, numd, ext, name, istat )

      implicit none
      include 'DAT_PAR'
      include 'SAE_PAR'
      include 'NDF_PAR'
      include 'STARMAN_INC'

      character*(*)	file		!i: Parameter name for file
      integer		numd		!i: Number of descriptor
      character*(*)	ext		!i: Name of extension
      character*(*)	name		!o: Name of descriptor
      integer		istat		!o: 0 => ok;1 = failure
C--
      integer istata, istatb, ndf, ncomp
      character*(DAT__SZLOC) loc, dloc
      logical there
Cbegin


      if ( ST_FAILED ) return

      istata = SAI__OK

      istat =  1
      istatb = 0
      call ndf_exist ( file, 'READ', ndf, istata )
      if ( ndf.eq.NDF__NOID ) return

      call ndf_xstat ( ndf, ext, there, istata )
      if ( there ) then
         call ndf_xloc ( ndf, ext, 'READ', loc, istata )
         call dat_ncomp ( loc, ncomp, istata )
         istat = 0
         if ( numd.le.ncomp ) then
            call dat_index ( loc, numd, dloc, istata )
            call dat_name ( dloc, name, istata )
            call dat_annul ( dloc, istata )
         else
            name = ' '
            istat = 1
         endif

         call dat_annul ( loc, istata )
      else
         if ( ext.eq.'STARMAN' ) then
            istatb = 1
            call printo(' WARNING: Cant access descriptors in '//
     +                    'file: If needed, use IMPORT' )
            call printo('         to load STARMAN extension from'//
     +                            ' FITS or other extension.')
            call printo('         Another way is via KAPPA FITSIMP.')
         endif
      endif

      call ndf_annul ( ndf, istata )

      if ( istata.ne.SAI__OK .or. istatb.ne.0 ) then
         name = ' '
         istat = 1
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gtdesr"> GTDESR  </a>-- Get a real value from the descriptor
C
C  a j penny                     dao          1988-04-19

      subroutine gtdesr ( file, dscr, rv, rdef, istat )

      implicit none
      include 'SAE_PAR'
      include 'NDF_PAR'
      include 'STARMAN_INC'

      character*(*) file		!i: Parameter name for file
      character*(*) dscr		!i: Descriptor name
      real	rv 			!o: descriptor value
      real	rdef			!i: value loaded on failure
      integer istat			!o: 0=success;1=failure
C--
      integer istata, istatb, ndf
      logical there
Cbegin


      if ( ST_FAILED ) return

      if ( dscr.eq.' ' ) then
         istat = 1
         rv = 0.0
         return
      endif

      istata = SAI__OK
      istat = 1
      istatb = 0
      rv = rdef
      call ndf_exist ( file, 'READ', ndf, istata )
      if ( ndf.eq.NDF__NOID ) return

      call ndf_xstat ( ndf, 'STARMAN', there, istata )
      if ( there ) then
         call ndf_xgt0r ( ndf, 'STARMAN', dscr, rv, istata )
      else
         istatb = 1
         call printo(' WARNING: Cant access descriptors in '//
     +                    'file: If needed, use IMPORT' )
         call printo('         to load STARMAN extension from'//
     +                            ' FITS or other extension.')
         call printo('         Another way is via KAPPA FITSIMP.')
      endif
      call ndf_annul ( ndf, istata )

      istat = 0
      if ( istata.ne.SAI__OK .or. istatb.ne.0 ) then
         rv = rdef
         istat = 1
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gtimid"> GTIMID  </a>-- Get descriptors BSCALE, BZERO, INVAL, TITLE form an int*4 image
C
C  alan penny              ral          1990 Jan

      subroutine gtimid ( name, bs, bz, inval, title, ierr )

      implicit none
      include 'STARMAN_INC'
      include 'ST_LIMITS_INC'

      character*(*) name        !i: parameter name of image
      real          bs          !o: Image scale
      real          bz          !o: Image zero
      integer       inval       !o: Image bad pixel flag
      character*(*) title       !o: Image title
      integer       ierr        !o: Error flag (0=ok)
C--
      integer ierra, ierrb, ierrc, ierrd, num, iv
Cbegin


      if ( ST_FAILED ) return

      iv = INT_INVALI
      call gtdesi ( name, 'INVAL', inval,     iv, ierra )
      call gtdesr ( name, 'BZERO',    bz,    0.0, ierrb )
      call gtdesr ( name, 'BSCALE',   bs,    1.0, ierrc )
      call gtdesc ( name, 'TITLE', title,    ' ', num, ierrd )
      ierr = max(ierra,ierrb,ierrc,ierrd)


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gtimrd"> GTIMRD  </a>-- Get descriptors BSCALE, BZERO, RINVAL, TITLE form a real image
C
C  alan penny              ral          1990 Jan

      subroutine gtimrd ( name, bs, bz, rinval, title, ierr )

      implicit none
      include 'ST_LIMITS_INC'
      include 'STARMAN_INC'

      character*(*) name        !i: parameter name of image
      real          bs          !o: Image scale
      real          bz          !o: Image zero
      real          rinval      !o: Image bad pixel flag
      character*(*) title       !o: Image title
      integer       ierr        !o: Error flag (0=ok)
C--
      integer ierra, ierrb, ierrc, ierrd, num
      real rv
Cbegin


      if ( ST_FAILED ) return

      rv = INT_INVALR
      call gtdesr ( name, 'INVAL',  rinval,   rv,  ierra )
      call gtdesr ( name, 'BZERO',      bz,  0.0,  ierrb )
      call gtdesr ( name, 'BSCALE',     bs,  1.0,  ierrc )
      call gtdesc ( name, 'TITLE',   title,  ' ',  num, ierrd )
      ierr = max(ierra,ierrb,ierrc,ierrd)


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gtimsd"> GTIMSD  </a>-- Get descriptors BSCALE, BZERO, INVAL, TITLE form an int*2 image
C
C  alan penny              ral          1990 Jan

      subroutine gtimsd ( name, bs, bz, inval, title, ierr )

      implicit none
      include 'STARMAN_INC'
      include 'ST_LIMITS_INC'

      character*(*) name        !i: parameter name of image
      real          bs          !o: Image scale
      real          bz          !o: Image zero
      integer       inval       !o: Image bad pixel flag
      character*(*) title       !o: Image title
      integer       ierr        !o: Error flag (0=ok)
C--
      integer ierra, ierrb, ierrc, ierrd, num, iv
Cbegin


      if ( ST_FAILED ) return

      iv = INT_INVALSI
      call gtdesi ( name, 'INVAL', inval,     iv, ierra )
      call gtdesr ( name, 'BZERO',    bz,    0.0, ierrb )
      call gtdesr ( name, 'BSCALE',   bs,    1.0, ierrc )
      call gtdesc ( name, 'TITLE', title,    ' ', num, ierrd )
      ierr = max(ierra,ierrb,ierrc,ierrd)


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gtwrkg"> GTWRKG  </a>-- Open integer*2/integer*4/real*4 computer work space
C
C  alan penny              ral          1990 Jan

      subroutine gtwrkg ( text, n, format, ip, ierr )

      implicit none
      include 'SAE_PAR'
      include 'PSX_ERR'
      include 'ST_ADAM_INC'
      include 'STARMAN_INC'

      character*(*) text	!i: Name to give to work space
      integer       n		!i: Size to allocate (in words)
      character*(*) format      !i: Type of space ('SHORT:INT:REAL')
      integer       ip		!o: Pointer to allocated space
      integer       ierr	!o: Error flag: 0=ok, 1=bad
C--
      integer istat, ilen, lens, next, i
      character texta*80, texte*20, iform*20
      external lens
Cbegin


      if ( ST_FAILED ) return

      ierr = 0
      ilen = min(50,lens(text))

      if ( format.eq.'SHORT' ) then
          iform = 'WORD'
          texte = ' 16-bit integers'
      elseif ( format.eq.'INT' ) then
          iform = '_INTEGER'
          texte = ' 32-bit integers'
      elseif ( format.eq.'REAL' ) then
          iform = '_REAL'
          texte = ' 32-bit reals'
      else
          call printo ( ' ERROR: Programmer error in type in'//
     +                  ' work space: '//text(1:ilen) )
          call printo ( '        Code needs rewriting: Contact'//
     +                 ' person who wrote the program' )
           ierr = 1
          return
      endif

      istat = SAI__OK

      if ( ilen.gt.WS_NSIZE ) then
          call printo ( ' ERROR: Programmer error in name size'//
     +                  ' in work space: '//text(1:ilen) )
          call printo ( '        Code needs rewriting: Contact'//
     +                 ' person who wrote the program' )
           ierr = 1
          return
      endif

      do i = 1, WORK_LIMIT
         if ( WS_NAME(i).eq.text ) then
            call printo ( ' ERROR: Work space of that name'//
     +             ' still open: '//text(1:ilen) )
            ierr = 1
            return
         endif
      enddo

      call find_space ( next )
      if ( next.le.0 ) then
          call printo ( ' ERROR: No spaces left in ws common'//
     +                  ' block: '//text(1:ilen) )
          ierr = 1
          return
      else
         if ( iform.ne.'WORD' ) then
             call psx_calloc ( n, iform, ip, istat )
         else
             call psx_malloc ( n*2, ip, istat )
         endif
      endif

      if ( istat.ne.SAI__OK ) then
          call printo ( ' ERROR: Cant open work space because '//
     +                  text(1:ilen) )
          write ( texta, '(1x,''   Desired work size = ''
     +           ,i7, a20)') n, texte
          call printo ( texta )
          call printo ( '    May be too large or invalid' )
          ierr = 1
      else
          WS_NAME(next) = text(1:ilen)
          CPNTR(next) = ip
          WS_COUNTER = WS_COUNTER + 1
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="isbswop"> ISBSWOP  </a>-- Is the computer swopping bytes on read (only if osf1)?
C
C   alan penny               ral         1994 Dec

      subroutine isbswop ( flag )

      implicit none
      include 'SAE_PAR'
      include 'STARMAN_INC'

      logical   flag		!o: .true. if is Byte swopping; .false. if not
C--
      character*132 sysname, nodename, release, version, machine, cv
      integer status
Cbegin


      if ( ST_FAILED ) return

      status = SAI__OK
      call psx_uname ( sysname, nodename, release, version, machine,
     +                 status )
      call lowcase ( sysname, cv )
      flag = .false.
      if ( index(cv,'osf1').ne.0 ) flag = .true.


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="isvms"> ISVMS  </a>-- Is the computer running VMS?
C
C   alan penny               ral         1990 Jan

      subroutine isvms ( flag )

      implicit none
      include 'SAE_PAR'
      include 'STARMAN_INC'

      logical   flag		!o: .true. if is VMS; .false. if not
C--
      character*132 sysname, nodename, release, version, machine
      integer status
Cbegin


      if ( ST_FAILED ) return

      status = SAI__OK
      call psx_uname ( sysname, nodename, release, version, machine,
     +                 status )
      flag = .false.
      if ( index(sysname,'VMS').ne.0 ) flag = .true.
      if ( index(sysname,'vms').ne.0 ) flag = .true.


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="opimgr"> OPIMGR  </a>-- Open an input 2d read-only generic image
C  The parameter name is left attached
C
C      alan penny             ral                1990 jan

      subroutine opimgr ( name, ipin, nx, ny, gtype, def, ierr )

      implicit none
      include 'SAE_PAR'
      include 'NDF_PAR'
      include 'NDF_ERR'
      include 'PAR_ERR'
      include 'STARMAN_INC'
      include 'ST_ADAM_INC'

      character*(*) name		!i: Name of parameter to get image name
      integer       ipin		!o: Image pointer
      integer       nx			!o: Image X size
      integer       ny			!o: Image Y size
      character*(*) gtype	        !o: Image type ('REAL'/'INT'/'SHORT'/'USHORT')
      logical       def			!i: if true, null reply accepted
      integer       ierr		!o: Error 0=ok, 1=bad, 2=null and acceptable
C--
      integer nsize(2), ndim, istat, istata, nloop, nmax, i, ndf, n
      character*(NDF__SZTYP)  ggtype
      logical loop
      character text*45, textc*45, atext*70
Cbegin


      if ( ST_FAILED ) return

      nloop = 1
      loop = .true.
      nmax = 4
      do while ( loop .and. nloop.le.nmax )
         loop = .false.

         istat = SAI__OK
         call err_mark
	 call ndf_assoc ( name, 'UPDATE', ndf, istat )
         if ( istat.eq.PAR__ABORT ) then
            ST_FAILED = .true.
            call err_annul ( istat )
            call err_rlse
            return
         endif
         call err_rlse
         call ndf_type ( ndf, 'DATA', ggtype, istat )
 	 call ndf_dim ( ndf, 2, nsize, ndim, istat )
	 call ndf_map ( ndf, 'DATA', ggtype, 'READ', ipin, i, istat )

         gtype = 'SHORT'
         if ( ggtype.eq.'_REAL' )    gtype = 'REAL'
         if ( ggtype.eq.'_INTEGER' ) gtype = 'INT'
         if ( ggtype.eq.'_WORD' )    gtype = 'SHORT'
         if ( ggtype.eq.'_UWORD' )   gtype = 'USHORT'

         if ( istat.eq.SAI__OK .and. ndim.eq.2 ) then
            ierr = 0
         elseif ( istat.eq.PAR__NULL ) then
            if ( .not.def ) then
               atext = ' ERROR: Null entry unacceptable'
               if ( nloop.le.(nmax-1) ) atext = ' ERROR: Null '//
     +                           'entry unacceptable - try again'
               call printo ( atext )
               loop = .true.
               ierr = 1
            else
               ierr = 2
            endif
            call err_load ( text, n, textc, i, istat )
         else
            ierr = 1
            call printo ( ' ERROR: Cant open file because - ' )
            if ( istat.eq.NDF__ACDEN ) then
               call printo ( '   Image could not be accessed' )
            elseif ( istat.eq.PAR__INVST ) then
               call printo ( '   Programmer error -  '//
     +                       'Parameter name invalid' )
               call printo ( '        Code needs rewriting:'//
     +                 ' Contact person who wrote the program' )
            elseif ( istat.eq.NDF__TYPIN ) then
               call printo ( '   Programmer error -  '//
     +                       'Type code invalid' )
               call printo ( '        Code needs rewriting:'//
     +                 ' Contact person who wrote the program' )
            elseif ( istat.eq.NDF__DIMIN ) then
               call printo ( '   Image dimensions invalid' )
               call pargi ( ndim )
               call printd (
     +         '   Image has %d dimensions - should only have 2' )
               call printo ( ' ' )
            elseif ( istat.eq.NDF__XSDIM ) then
               call printo (
     +         '   Image dimensions too large - should only have 2' )
               call printo ( ' ' )
            else
               call err_rep ( ' ',  ' ERROR: ^status', istat )
               call printo ( ' ERROR: Error on opening image' )
               call pargi ( istat )
               call printd ( '       - ADAM error number %d ' )

               call printo ( '       Check in /star/include files' )
               call printo ( '       Perhaps program.sdf file '//
     +                       'corrupted in adam dir' )
               call printo  ( ' ' )
               call err_flush ( istat )
               call printo ( ' ' )
            endif
         endif

         if ( loop ) then
            istata = istat
            istat = SAI__OK
            if ( istata.ne.NDF__NOID .and. istata.ne.PAR__NULL )
     +         call ndf_annul ( ndf, istat )
            call par_cancl ( name, istat )
         endif

         nloop = nloop + 1
      enddo

      if ( ierr.eq.0 ) then
         nx = nsize(1)
         ny = nsize(2)
         call space_ndf ( i )
         if ( i.gt.0 ) then
            NDF_NAME(i) = name
            SNDF(i) = ndf
         else
            call printo ( 'No space left in NDF_NAME' )
         endif
      else
         if (nloop.eq.(nmax+1)) call printo
     +                          (' ERROR: Too many failures')
         istata = istat
         istat = SAI__OK
         if ( istata.ne.NDF__NOID .and. istata.ne.PAR__NULL )
     +      call ndf_annul ( ndf, istat )
         call par_cancl ( name, istat )
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="opimgw"> OPIMGW  </a>-- Open an output 2d write-only generic image
C  The parameter name is left attached
C
C    a j penny                 ral                  1988-07-10

      subroutine opimgw ( name, gtype, ip, nx, ny, def, ierr )

      implicit none
      include 'DAT_PAR'
      include 'SAE_PAR'
      include 'PAR_ERR'
      include 'NDF_PAR'
      include 'NDF_ERR'
      include 'ST_ADAM_INC'
      include 'STARMAN_INC'

      character*(*) name		!i: Parameter name for image
      character*(*) gtype        	!i: Image type
      integer       ip			!o: Pointer to image
      integer	    nx			!i: Image X size
      integer	    ny			!i: Image Y size
      logical	    def			!i: If true, null reply is accepted
      integer	    ierr		!o: Error 0=ok, 1=bad, 2=blank and ok
C--
      logical loop
      integer nloop, nmax, i, istat, istata, udims(2), ldims(2),
     +        ndf, n
      character*(DAT__SZLOC) loc
      character*(NDF__SZTYP) ggtype
      character text*40, textc*40, texta*72, atext*70
Cbegin


      if ( ST_FAILED ) return

      ierr = 0

      ggtype = '_WORD'
      if ( gtype.eq.'REAL' )   ggtype = '_REAL'
      if ( gtype.eq.'INT' )    ggtype = '_INTEGER'
      if ( gtype.eq.'SHORT' )  ggtype = '_WORD'
      if ( gtype.eq.'USHORT' ) ggtype = '_UWORD'

      ldims(1) = 1
      ldims(2) = 1
      udims(1) = nx
      udims(2) = ny

      nloop = 1
      loop = .true.
      nmax = 4
      do while ( loop .and. nloop.le.nmax )

         istat = SAI__OK
         call err_mark
	 call ndf_creat ( name, ggtype, 2, ldims, udims, ndf, istat )
         if ( istat.eq.PAR__ABORT ) then
            ST_FAILED = .true.
            call err_annul ( istat )
            call err_rlse
            ierr = 1
            return
         elseif ( istat.eq.SAI__OK ) then				!OK
            ierr = 0
            loop = .false.
         elseif ( istat.eq.PAR__NULL ) then				!Null response
            if ( def ) then
               loop = .false.
               ierr = 2
            else
               atext = ' ERROR: Null entry unacceptable'
               if ( nloop.le.(nmax-1) ) atext = ' ERROR: Null entry '//
     +                           'unacceptable - try again'
               call printo ( atext )
               ierr = 1
            endif
            call err_load ( text, n, textc, i, istat )
         elseif ( istat.ne.SAI__OK ) then				!Error
            ierr = 1
            call printo ( ' ERROR: Cant open file because - ' )
            if ( istat.eq.NDF__ACDEN ) then
               call printo ( '   Image could not be accessed' )
            elseif ( istat.eq.PAR__INVST ) then
               call printo ( '   Programmer error -  '//
     +                       'Parameter name invalid' )
               call printo ( '        Code needs rewriting:'//
     +                 ' Contact person who wrote the program' )
            elseif ( istat.eq.NDF__FTPIN ) then
               call printo ( '   Image type impossible' )
            elseif ( istat.eq.NDF__DIMIN ) then
                write ( texta,'(''   Invalid size:'',
     +                        i7,'' x '',i7)' ) nx, ny
               call printo ( texta )
            else
               call err_rep ( ' ',  ' ERROR: ^status', istat )
               call printo ( ' ERROR: Error on opening image' )
               call pargi ( istat )
               call printd ( '       - ADAM error number %d ' )
               call printo ( '       Check in /star/include files' )
               call printo ( '       Perhaps program.sdf file '//
     +                       'corrupted in adam dir' )
               call printo  ( ' ' )
               call err_flush ( istat )
               call printo ( ' ' )
            endif
         endif
         call err_rlse

         if ( loop ) then
            istata = istat
            istat = SAI__OK
            if ( istata.ne.NDF__NOID .and. istata.ne.PAR__NULL )
     +         call ndf_annul ( ndf, istat )
            call par_cancl ( name, istat )
         endif

         nloop = nloop + 1
      enddo

      if ( ierr.eq.0 ) then						!Made image, so put size
         call ndf_xnew ( ndf, 'STARMAN', 'EXT', 0, 0, loc, istat )
         call dat_annul ( loc,istat )
         call ndf_map ( ndf, 'DATA', ggtype, 'WRITE', ip, i, istat )
         call ptdesi ( name, 'NAXIS', 2 )
         call ptdesi ( name, 'NAXIS1', nx )
         call ptdesi ( name, 'NAXIS2', ny )
         call space_ndf ( i )
         if ( i.gt.0 ) then
            NDF_NAME(i) = name
            SNDF(i) = ndf
         else
            call printo ( 'No space left in NDF_NAME' )
         endif
      else
         if (nloop.eq.(nmax+1)) call printo
     +                          (' ERROR: Too many failures')
         istata = istat
         istat = SAI__OK
         if ( istata.ne.NDF__NOID .and. istata.ne.PAR__NULL )
     +      call ndf_annul ( ndf, istat )
         call par_cancl ( name, istat )
      endif


      end

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="opim4gw"> OPIM4GW  </a>-- Open an output 4d write-only generic image
C  The parameter name is left attached
C
C    a j penny                 ral                  1988-07-10

      subroutine opim4gw ( name, gtype, ip, nx, ny, nz,nt,def,ierr)

      implicit none
      include 'DAT_PAR'
      include 'SAE_PAR'
      include 'PAR_ERR'
      include 'NDF_PAR'
      include 'NDF_ERR'
      include 'ST_ADAM_INC'
      include 'STARMAN_INC'

      character*(*) name		!i: Parameter name for image
      character*(*) gtype        	!i: Image type
      integer       ip			!o: Pointer to image
      integer	    nx			!i: Image X size
      integer	    ny			!i: Image Y size
      integer	    nz			!i: Image Z size
      integer	    nt			!i: Image T size
      logical	    def			!i: If true, null reply is accepted
      integer	    ierr		!o: Error 0=ok, 1=bad, 2=blank and ok
C--
      logical loop
      integer nloop, nmax, i, istat, istata, udims(4), ldims(4),
     +        ndf, n
      character*(DAT__SZLOC) loc
      character*(NDF__SZTYP) ggtype
      character text*40, textc*40, texta*72, atext*70
Cbegin


      if ( ST_FAILED ) return

      ierr = 0

      ggtype = '_WORD'
      if ( gtype.eq.'REAL' )   ggtype = '_REAL'
      if ( gtype.eq.'INT' )    ggtype = '_INTEGER'
      if ( gtype.eq.'SHORT' )  ggtype = '_WORD'
      if ( gtype.eq.'USHORT' ) ggtype = '_UWORD'

      ldims(1) = 1
      ldims(2) = 1
      ldims(3) = 1
      ldims(4) = 1
      udims(1) = nx
      udims(2) = ny
      udims(3) = nz
      udims(4) = nt

      nloop = 1
      loop = .true.
      nmax = 4
      do while ( loop .and. nloop.le.nmax )

         istat = SAI__OK
         call err_mark
	 call ndf_creat ( name, ggtype, 4, ldims, udims, ndf, istat )
         if ( istat.eq.PAR__ABORT ) then
            ST_FAILED = .true.
            call err_annul ( istat )
            call err_rlse
            ierr = 1
            return
         elseif ( istat.eq.SAI__OK ) then				!OK
            ierr = 0
            loop = .false.
         elseif ( istat.eq.PAR__NULL ) then				!Null response
            if ( def ) then
               loop = .false.
               ierr = 2
            else
               atext = ' ERROR: Null entry unacceptable'
               if ( nloop.le.(nmax-1) ) atext = ' ERROR: Null entry '//
     +                           'unacceptable - try again'
               call printo ( atext )
               ierr = 1
            endif
            call err_load ( text, n, textc, i, istat )
         elseif ( istat.ne.SAI__OK ) then				!Error
            ierr = 1
            call printo ( ' ERROR: Cant open file because - ' )
            if ( istat.eq.NDF__ACDEN ) then
               call printo ( '   Image could not be accessed' )
            elseif ( istat.eq.PAR__INVST ) then
               call printo ( '   Programmer error -  '//
     +                       'Parameter name invalid' )
               call printo ( '        Code needs rewriting:'//
     +                 ' Contact person who wrote the program' )
            elseif ( istat.eq.NDF__FTPIN ) then
               call printo ( '   Image type impossible' )
            elseif ( istat.eq.NDF__DIMIN ) then
                write ( texta,'(''   Invalid size:'',
     +                   i7,'' x '',i7,'' x '',i7,'' x '',i7)' )
     +                          nx, ny, nz, nt
               call printo ( texta )
            else
               call err_rep ( ' ',  ' ERROR: ^status', istat )
               call printo ( ' ERROR: Error on opening image' )
               call pargi ( istat )
               call printd ( '       - ADAM error number %d ' )
               call printo ( '       Check in /star/include files' )
               call printo ( '       Perhaps program.sdf file '//
     +                       'corrupted in adam dir' )
               call printo  ( ' ' )
               call err_flush ( istat )
               call printo ( ' ' )
            endif
         endif
         call err_rlse

         if ( loop ) then
            istata = istat
            istat = SAI__OK
            if ( istata.ne.NDF__NOID .and. istata.ne.PAR__NULL )
     +         call ndf_annul ( ndf, istat )
            call par_cancl ( name, istat )
         endif

         nloop = nloop + 1
      enddo

      if ( ierr.eq.0 ) then						!Made image, so put size
         call ndf_xnew ( ndf, 'STARMAN', 'EXT', 0, 0, loc, istat )
         call dat_annul ( loc,istat )
         call ndf_map ( ndf, 'DATA', ggtype, 'WRITE', ip, i, istat )
         call ptdesi ( name, 'NAXIS', 4 )
         call ptdesi ( name, 'NAXIS1', nx )
         call ptdesi ( name, 'NAXIS2', ny )
         call ptdesi ( name, 'NAXIS3', nz )
         call ptdesi ( name, 'NAXIS4', nt )
         call space_ndf ( i )
         if ( i.gt.0 ) then
            NDF_NAME(i) = name
            SNDF(i) = ndf
         else
            call printo ( 'No space left in NDF_NAME' )
         endif
      else
         if (nloop.eq.(nmax+1)) call printo
     +                          (' ERROR: Too many failures')
         istata = istat
         istat = SAI__OK
         if ( istata.ne.NDF__NOID .and. istata.ne.PAR__NULL )
     +      call ndf_annul ( ndf, istat )
         call par_cancl ( name, istat )
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="opim4gr"> OPIM4GR  </a>-- Open an input read-only generic image up to 4 dimensions
C  The parameter name is left attached
C
C      alan penny             ral                1990 jan

      subroutine opim4gr ( name, ipin, nx, ny, nz, nt, ndim, gtype,
     +                     def, ierr )

      implicit none
      include 'SAE_PAR'
      include 'NDF_PAR'
      include 'NDF_ERR'
      include 'PAR_ERR'
      include 'ST_ADAM_INC'
      include 'STARMAN_INC'

      character*(*) name		!i: Name of parameter to get image name
      integer       ipin		!o: Image pointer
      integer       nx			!o: Image X size
      integer       ny			!o: Image Y size
      integer       nz			!o: Image Z size
      integer       nt			!o: Image T size
      integer       ndim		!o: No of dimensions
      character*(*) gtype	        !i: Image type ('REAL'/'INT'/'SHORT'/'USHORT')
      logical       def			!i: if true, null reply accepted
      integer       ierr		!o: Error 0=ok, 1=bad, 2=null and acceptable
C--
      integer nsize(10), istat, istata, nloop, nmax, i, ndf, n
      character*(NDF__SZTYP)  ggtype
      logical loop
      character text*45, textc*45, atext*70
Cbegin


      if ( ST_FAILED ) return

      nloop = 1
      loop = .true.
      nmax = 4
      do while ( loop .and. nloop.le.nmax )
         loop = .false.

         istat = SAI__OK
         call err_mark
	 call ndf_assoc ( name, 'READ', ndf, istat )
         if ( istat.eq.PAR__ABORT ) then
            ST_FAILED = .true.
            call err_annul ( istat )
            call err_rlse
            return
         endif
         call err_rlse
	 call ndf_dim ( ndf, 4, nsize, ndim, istat )
	 call ndf_type ( ndf, 'DATA', ggtype, istat )
	 call ndf_map ( ndf, 'DATA', ggtype, 'READ', ipin, i, istat )

         gtype = 'SHORT'
         if ( ggtype.eq.'_REAL' )    gtype = 'REAL'
         if ( ggtype.eq.'_INTEGER' ) gtype = 'INT'
         if ( ggtype.eq.'_WORD' )    gtype = 'SHORT'

         if ( istat.eq.SAI__OK .and. ndim.le.4 .and. ndim.ge.2 ) then
            ierr = 0
         elseif ( istat.eq.PAR__NULL ) then
            if ( .not.def ) then
               atext = ' ERROR: Null entry unacceptable'
               if ( nloop.le.(nmax-1) ) atext = ' ERROR: Null entry '//
     +                           'unacceptable - try again'
               call printo ( atext )
               loop = .true.
               ierr = 1
            else
               ierr = 2
            endif
            call err_load ( text, n, textc, i, istat )
         else
            ierr = 1
            call printo ( ' ERROR: Cant open file because - ' )
            if ( istat.eq.NDF__ACDEN ) then
               call printo ( '   Image could not be accessed' )
            elseif ( istat.eq.PAR__INVST ) then
               call printo ( '   Programmer error -  '//
     +                       'Parameter name invalid' )
               call printo ( '        Code needs rewriting:'//
     +                 ' Contact person who wrote the program' )
            elseif ( istat.eq.NDF__TYPIN ) then
               call printo ( '   Programmer error -  '//
     +                       'Type code invalid' )
               call printo ( '        Code needs rewriting:'//
     +                 ' Contact person who wrote the program' )
            elseif ( istat.eq.NDF__DIMIN ) then
               call printo ( '   Image dimensions invalid' )
               call pargi ( ndim )
               call printd (
     +         '    They are %d and should be between 2 and 4 ' )
               call printo ( ' ' )
            elseif ( istat.eq.NDF__XSDIM ) then
               call printo (
     +     '   Image dimensions too large - should be between 2 and 4' )
               call printo ( ' ' )
            else
               call err_rep ( ' ',  ' ERROR: ^status', istat )
               call printo ( ' ERROR: Error on opening image' )
               call pargi ( istat )
               call printd ( '       - ADAM error number %d ' )
               call printo ( '       Check in /star/include files' )
               call printo ( '       Perhaps program.sdf file '//
     +                       'corrupted in adam dir' )
               call printo  ( ' ' )
               call err_flush ( istat )
               call printo ( ' ' )
            endif
         endif

         if ( loop ) then
            istat = SAI__OK
            if ( istata.ne.NDF__NOID .and. istata.ne.PAR__NULL )
     +         call ndf_annul ( ndf, istat )
            call par_cancl ( name, istat )
         endif

         nloop = nloop + 1
      enddo

      if ( ierr.eq.0 ) then
         nx = nsize(1)
         ny = nsize(2)
         if ( ndim.ge.3 ) nz = nsize(3)
         if ( ndim.ge.4 ) nt = nsize(4)
         call space_ndf ( i )
         if ( i.gt.0 ) then
            NDF_NAME(i) = name
            SNDF(i) = ndf
         else
            call printo ( 'No space left in NDF_NAME' )
         endif
      else
         if (nloop.eq.(nmax+1)) call printo
     +                          (' ERROR: Too many failures')
         istata = istat
         istat = SAI__OK
         if ( istata.ne.NDF__NOID .and. istata.ne.PAR__NULL )
     +      call ndf_annul ( ndf, istat )
         call par_cancl ( name, istat )
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="optabr"> OPTABR  </a>-- Open an input read-only table
C  The parameter name is left attached
C
C   alan penny                   ral         1990 Jan

      subroutine optabr ( name, ip, nx, ny, def, ierr )

      implicit none
      include 'DAT_PAR'
      include 'SAE_PAR'
      include 'NDF_ERR'
      include 'NDF_PAR'
      include 'ARY_ERR'
      include 'PAR_ERR'
      include 'ST_ADAM_INC'
      include 'STARMAN_INC'

      character name*(*)		!i: parameter name for table
      integer   ip			!o: Pointer to table
      integer   nx			!o: No of columns (inc 5 for name column)
      integer   ny			!o: No of rows
      logical	def			!i: if true, null reply acceptable
      integer   ierr			!o: Error flag 0=ok; 1=bad; 2=blank
					!   and ok; 3 = already opened
C--
      character*6 frtype
      character*(DAT__SZLOC) loc, dloc, nloc
      character*(NDF__SZFRM) form
      character*20 texta, textb, ver, nmach, nsys, sys, mach
      character*72 text
      logical  loop, type, chr_simlr, doit
      integer  nloop, nmax, k, n, istat, istata, dim(2), ndf,
     +         icptr, ierra
      external chr_simlr
Cbegin


      if ( ST_FAILED ) return

      nx = 1
      ny = 1

      call err_mark

      nloop = 1
      loop = .true.
      type = .true.
      nmax = 4
      do while ( loop .and. nloop.le.nmax )

         istat = SAI__OK

         call ndf_assoc ( name, 'UPDATE', ndf, istat )			!Open file
         if ( istat.eq.PAR__ABORT ) then
            ST_FAILED = .true.
            call err_annul ( istat )
            call err_rlse
            return
         endif

         call ndf_dim ( ndf, 2, dim, k, istat )
         call ndf_map ( ndf, 'DATA', '_REAL', 'UPDATE', ip, k, istat )

         ierr = 1
         doit = .true.
         if ( istat.eq.PAR__NULL ) then					!Null reply
            doit = .false.
            if ( def ) then
               loop = .false.
               ierr = 2
            else
               text = ' ERROR: Null entry unacceptable'
               if ( nloop.le.(nmax-1) ) text = ' ERROR: Null entry '//
     +                           'unacceptable - try again'
               call printo ( text )
            endif
            call err_load ( texta, n, textb, k, istat )
         endif

         if ( istat.eq.ARY__CFLAC ) then				!Already accessed file
            doit = .false.
            loop = .false.
            ierr = 3
            do while ( istat.ne.SAI__OK )
               call err_load ( texta, n, textb, k, istat )
            enddo
            call err_flush ( istat )
            call err_annul ( istat )
            istata = SAI__OK
            call ndf_annul ( ndf, istata )
            call par_cancl ( name, istata )
         endif

         if ( istat.eq.NDF__ACDEN ) then				!Not accessible
            doit = .false.
            call printo ( ' ERROR: Cant access file '//
     +             ' - Table could not be accessed' )
            call err_rep ( ' ',  ' ERROR: ^status', istat )
            call err_flush ( istat )
            call err_annul ( istat )
         elseif ( istat.eq.PAR__INVST ) then				!Invalid parameter name
            doit = .false.
            call printo ( ' ERROR: Invalid parameter name '//
     +             ' - Table could not be accessed' )
            call err_rep ( ' ',  ' ERROR: ^status', istat )
            call err_flush ( istat )
            call err_annul ( istat )
         elseif ( istat.eq.NDF__DIMIN ) then				!Invalid size
            doit = .false.
            call printo ( ' ERROR: Invalid size '//
     +             ' - Table could not be accessed' )
            call err_rep ( ' ',  ' ERROR: ^status', istat )
            call err_flush ( istat )
            call err_annul ( istat )
          elseif ( istat.eq.NDF__XSDIM ) then				!Invalid size
            doit = .false.
            call printo ( ' ERROR: Invalid size '//
     +             ' - Table could not be accessed' )
            call err_rep ( ' ',  ' ERROR: ^status', istat )
            call err_flush ( istat )
            call err_annul ( istat )
          elseif ( istat.ne.SAI__OK .and. istat.ne.PAR__NULL ) then	!Unknown error
            doit = .false.
            call printo ( ' ERROR: Error on opening table ' )
            call pargi ( istat )
            call printd ( '       - ADAM error number %d ' )
            call printo ( '       Check in /star/include files' )
            call printo ( '       Perhaps program.sdf file '//
     +                    'corrupted in adam dir' )
            call printo  ( ' ' )
            call err_rep ( ' ',  ' ERROR: ^status', istat )
            call err_flush ( istat )
            call err_annul ( istat )
            call printo ( ' ' )
         endif

         if ( doit ) then						!Ok - Check dimensions and type
	    nx = dim (1)
	    ny = dim (2)
            call ndf_cget ( ndf, 'LABEL', frtype, istat )
            type = chr_simlr ( frtype, 'XYLIST' )
            if ( istat.ne.SAI__OK ) then
               call printo ( ' ERROR: Error in opening table' )
               call err_rep ( ' ',  ' ERROR: ^status', istat )
               call err_flush ( istat )
               call err_annul ( istat )
            elseif ( .not.type .or. nx.lt.6 .or. ny.lt.1 ) then	
               call printo (' ERROR: Not a proper table - or size '//
     +                    'wrong - Table could not be accessed' )
            else
               loop = .false.
               ierr = 0
            endif
         endif

         if ( loop ) then
            istata = istat
            istat = SAI__OK
            if ( istata.ne.NDF__NOID .and. istata.ne.PAR__NULL )
     +         call ndf_annul ( ndf, istat )
            call par_cancl ( name, istat )
         endif

         nloop = nloop + 1
      enddo

      if ( ierr.eq.0 ) then

         call psx_uname ( nsys, texta, textb, ver, nmach, istat )
         call gtdesc ( name, 'SYSNAME', sys, 'NO', k, ierra )
         call gtdesc ( name, 'MACHINE', mach, 'NO', k, ierra )  	!Get current machine + OS and file

         if ( sys.ne.nsys .or. mach.ne.nmach ) then             	!NB Default is that the file was
                                                   			! not written on this machine or
            call ndf_loc ( ndf, 'READ', loc, istat )			! operating system
            call ndf_form ( ndf, 'DATA', form, istat )

            if ( form.eq.'SIMPLE' ) then                        	!Find data array
               call dat_find ( loc, 'DATA_ARRAY', nloc, istat )
               call dat_find ( nloc, 'DATA', dloc, istat )
            else
               call dat_find ( loc, 'DATA_ARRAY', dloc, istat )
            endif

            call dat_basic ( dloc, 'READ', icptr, k, istat )   		!Map as basic

            if ( istat.eq.SAI__OK ) then				!If okay  copy over names and write
               call copzz ( %val(icptr), nx*4, ny, 1, 20, 1,
     +                      ny, %val(ip), nx*4, ny, 1, 1 )
            endif

            call dat_annul ( dloc, istat )
            call dat_annul ( loc, istat )
            if ( form.eq.'SIMPLE' ) call dat_annul ( nloc, istat )

         endif

         call space_ndf ( k )
         if ( k.gt.0 ) then
            NDF_NAME(k) = name
            SNDF(k) = ndf
         else
            call printo ( ' ERROR: No space left in NDF_NAME' )
         endif

      elseif ( ierr.eq.1 .or. ierr.eq.2 ) then
         if ( nloop.eq.(nmax+1) ) call printo
     +                          (' ERROR: Too many failures')
         istata = istat
         istat = SAI__OK
         if ( istata.ne.NDF__NOID .and. istata.ne.PAR__NULL ) then
            call ndf_annul ( ndf, istat )
            call printo ( ' ERROR: Error in opening table' )
            call err_rep ( ' ',  ' ERROR: ^status', istata )
            call err_flush ( istat )
            call err_annul ( istat )
         endif
         call par_cancl ( name, istat )

      endif

      call err_rlse


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="optabw"> OPTABW  </a>-- Open an output write-only table
C  The parameter name is left attached
C
C    a j penny                 ral                  1988-07-10

      subroutine optabw ( name, ip, nx, ny, def, ierr )

      implicit none
      include 'DAT_PAR'
      include 'SAE_PAR'
      include 'PAR_ERR'
      include 'NDF_ERR'
      include 'NDF_PAR'
      include 'ST_ADAM_INC'
      include 'STARMAN_INC'

      character*(*)	name		!i: Parameter name for table
      integer		ip		!o: Pointer to table
      integer		nx		!i: No of columns (+5 for name column)
      integer		ny		!i: No of rows
      logical		def		!i: If true, null reply is accepted
      integer		ierr		!o: Error flag 0=ok;1=bad;2=blank and ok
C--
      logical loop
      integer nloop, nmax, istat, istata, iv, lbnd(2),ubnd(2), ndf,
     +        k, n
      character*(DAT__SZLOC) loc
      character*(NDF__SZTYP) gtype
      character text*55, textc*55, atext*70
      character*20 sys, node, release, ver, mach
Cbegin


      if ( ST_FAILED ) return

      if ( nx*ny.lt.6 ) then
         ierr = 1
         iv = nx - 5
         write ( text, '('' ERROR: Invalid table size - '',i7,
     +                   '' x '',i7)' ) iv, ny
         call printo ( text//' - Wont try to open file for table' )
         return
      endif

      nloop = 1
      loop = .true.
      lbnd (1) = 1
      lbnd (2) = 1
      ubnd (1) = nx
      ubnd (2) = ny
      gtype = '_REAL'

      nmax = 4
      do while ( loop .and. nloop.le.nmax )

         istat = SAI__OK
         call err_mark
 	 call ndf_creat ( name, gtype, 2, lbnd, ubnd, ndf, istat )	!Open table
         if ( istat.eq.PAR__ABORT ) then
            ST_FAILED = .true.
            call err_annul ( istat )
            call err_rlse
            return
         elseif ( istat.eq.PAR__NULL ) then				!Null response
            if ( def ) then
               loop = .false.
               ierr = 2
            else
               atext = ' ERROR: Null entry unacceptable'
               if ( nloop.le.(nmax-1) ) atext = ' ERROR: Null entry '//
     +                           'unacceptable - try again'
               call printo ( atext )
               ierr = 1
            endif
            call err_load ( text, n, textc, k, istat )
         elseif ( istat.ne.SAI__OK ) then				!Bad response
            if ( istat.eq.NDF__ACDEN ) then
               call printo ( ' ERROR: Cant access file' )
            elseif ( istat.eq.PAR__INVST ) then
               call printo ( ' ERROR: Invalid parameter name'//
     +                         ' - Cant open that file' )
            elseif ( istat.eq.NDF__DIMIN ) then
               iv = nx - 5
               write ( text, '('' ERROR: Invalid table size - '',i7,
     +                         '' x '',i7)' ) iv, ny
               call printo ( text//' - Cant open file ' )
            else
               call err_rep ( ' ',  ' ERROR: ^status', istat )
               call printo ( ' ERROR: Error on opening table ' )
               call pargi ( istat )
               call printd ( '       - ADAM error number %d ' )
               call printo ( '       Check in /star/include files' )
               call printo ( '       Perhaps program.sdf file '//
     +                       'corrupted in adam dir' )
               call printo  ( ' ' )
               call err_flush ( istat )
               call printo ( ' ' )
            endif
            ierr = 1
         else								!OK
            ierr = 0
            loop = .false.
         endif
         call err_rlse

         if ( loop ) then
            istata = istat
            istat = SAI__OK
            if ( istata.ne.NDF__NOID .and. istata.ne.PAR__NULL )
     +         call ndf_annul ( ndf, istat )
            call par_cancl ( name, istat )
         endif

         nloop = nloop + 1
      enddo

      if ( ierr.eq.0 ) then						!If opened, load size
         call ndf_xnew ( ndf, 'STARMAN', 'EXT', 0, 0, loc, istat )
         call dat_annul ( loc, istat )
         call ndf_map ( ndf, 'DATA', gtype, 'WRITE', ip, k, istat )
         call ndf_cput ( 'XYLIST', ndf, 'LABEL', istat)
         call psx_uname ( sys, node, release, ver, mach, istat )
         call ptdesc ( name, 'SYSNAME', sys )
         call ptdesc ( name, 'MACHINE', mach )
         call ptdesi ( name, 'NITEM', nx )
         call ptdesi ( name, 'LSTLEN', ny )
         call space_ndf ( k )
         if ( k.gt.0 ) then
            NDF_NAME(k) = name
            SNDF(k) = ndf
         else
            call printo ( ' ERROR: No space left in NDF_NAME' )
         endif
      else
         if (nloop.eq.(nmax+1)) call printo
     +                          (' ERROR: Too many failures')
         istata = istat
         istat = SAI__OK
         if ( istata.ne.NDF__NOID .and. istata.ne.PAR__NULL )
     +      call ndf_annul ( ndf, istat )
         call par_cancl ( name, istat )
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="printo"> PRINTO  </a>-- Write a line out to the CL
C
C   alan penny                ral        1990 Jan

      subroutine printo ( text )

      implicit none
      include 'STARMAN_INC'
      include 'SAE_PAR'

      character*(*) text	!i: Text to output
C--
      integer istat
Cbegin


      if ( ST_FAILED ) return

      istat = SAI__OK
      if ( text(1:1).eq.'0' .or. text(1:1).eq.'1' .or.
     +     text(1:1).eq.'+' ) then
         call msg_out ( ' ', ' '//text, istat )
      elseif ( text.eq.' ' ) then
         call msg_out ( ' ', '  ', istat )
      else
         call msg_out ( ' ', text, istat )
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="ptdescn"> PTDESCN  </a>-- Write character strings into the header area of an opened file
C
C    a j penny                 ral                  1990-01

      subroutine ptdescn ( file, name, cval, n )

      implicit none
      include 'DAT_PAR'
      include 'SAE_PAR'
      include 'NDF_PAR'
      include 'STARMAN_INC'

      character*(*)	file		!i: Parameter name for file to write to
      character*(*)	name		!i: Name to give to value
      integer           n		!i: Number of values to write
      character*(*)	cval(n)		!i: value to write
C--
      integer istat, ndf, i(1), nchar, chr_size
      character*(DAT__SZLOC) loc
      external chr_size
      logical there
Cbegin


      if ( ST_FAILED ) return

      if ( name.eq.' ' ) return

      istat = SAI__OK
      i(1) = n
      nchar = chr_size ( cval(1) )

      call ndf_exist ( file, 'UPDATE', ndf, istat )
      if ( ndf.eq.NDF__NOID ) return

      call ndf_xstat ( ndf, 'STARMAN', there, istat )
      if ( .not.there ) then
         call ndf_xnew ( ndf, 'STARMAN', 'EXT', 0, 0, loc, istat )
      else
         call ndf_xloc ( ndf, 'STARMAN', 'UPDATE', loc, istat )
      endif

      call cmp_modc ( loc, name, nchar, 1, i, istat )
      call cmp_put1c ( loc, name, n, cval, istat )
      call dat_annul ( loc, istat )
      call ndf_annul ( ndf, istat )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="ptdesc"> PTDESC  </a>-- Write a character string into the header area of an opened file
C
C    a j penny                 ral                  1990-01

      subroutine ptdesc ( file, name, cval )

      implicit none
      include 'DAT_PAR'
      include 'SAE_PAR'
      include 'NDF_PAR'
      include 'STARMAN_INC'

      character*(*)	file		!i: Parameter name for file to write to
      character*(*)	name		!i: Name to give to value
      character*(*)	cval 		!i: value to write
C--
      integer istat, ndf
      logical there
      character*(DAT__SZLOC) loc
Cbegin


      if ( ST_FAILED ) return

      if ( name.eq.' ' ) return

      istat = SAI__OK
      call ndf_exist ( file, 'UPDATE', ndf, istat )
      if ( ndf.eq.NDF__NOID ) return

      call ndf_xstat ( ndf, 'STARMAN', there, istat )
      if ( .not.there ) then
        call ndf_xnew ( ndf, 'STARMAN', 'EXT', 0, 0, loc, istat )
        call dat_annul ( loc, istat )
      endif

      if ( (name.eq.'TITLE') .or. (name.eq.'LABEL') .or.
     +					(name.eq.'UNITS') ) then
	 call ndf_cput ( cval, ndf, name, istat )
      else
         call ndf_xpt0c ( cval, ndf, 'STARMAN', name, istat )
      endif

      call ndf_annul ( ndf, istat )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="ptdesi"> PTDESI  </a>-- Write an integer into the header area of an opened file
C
C    a j penny                 ral                  1990-01

      subroutine ptdesi ( file, name, ival )

      implicit none
      include 'DAT_PAR'
      include 'SAE_PAR'
      include 'NDF_PAR'
      include 'STARMAN_INC'

      character*(*)	file		!i: Parameter name for file to write to
      character*(*)	name		!i: Name to give to value
      integer		ival 		!i: value to write
C--
      integer istat, ndf
      character*(DAT__SZLOC) loc
      logical there
Cbegin


      if ( ST_FAILED ) return

      if ( name.eq.' ' ) return

      istat = SAI__OK
      call ndf_exist ( file, 'UPDATE', ndf, istat )
      if ( ndf.eq.NDF__NOID ) return

      call ndf_xstat ( ndf, 'STARMAN', there, istat )
      if ( .not.there ) then
        call ndf_xnew ( ndf, 'STARMAN', 'EXT', 0, 0, loc, istat )
        call dat_annul ( loc, istat )
      endif

      call ndf_xpt0i ( ival, ndf, 'STARMAN', name, istat )
      call ndf_annul ( ndf, istat )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="ptdesr"> PTDESR  </a>-- Write a real into the header area of an opened file
C
C    a j penny                 ral                  1990-01

      subroutine ptdesr ( file, name, rval )

      implicit none
      include 'DAT_PAR'
      include 'SAE_PAR'
      include 'NDF_PAR'
      include 'STARMAN_INC'

      character*(*)	file		!i: Paramter name of file to write to
      character*(*)	name		!i: Name to give to value
      real		rval 		!i: value to write
C--
      integer istat, ndf
      character*(DAT__SZLOC) loc
      logical there
Cbegin


      if ( ST_FAILED ) return

      if ( name.eq.' ' ) return

      istat = SAI__OK
      call ndf_exist ( file, 'UPDATE', ndf, istat )
      if ( ndf.eq.NDF__NOID ) return

      call ndf_xstat ( ndf, 'STARMAN', there, istat )
      if ( .not.there ) then
        call ndf_xnew ( ndf, 'STARMAN', 'EXT', 0, 0, loc, istat )
        call dat_annul ( loc, istat )
      endif

      call ndf_xpt0r ( rval, ndf, 'STARMAN', name, istat )
      call ndf_annul ( ndf, istat )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="putgi"> PUTGI  </a>-- Put integer number(s) to the CL
C
C    a j penny                ral         1988-09-07

      subroutine putgi ( name, num, ival )

      implicit none
      include 'SAE_PAR'
      include 'STARMAN_INC'

      character*(*)	name		!i: Name of parameter
      integer           num             !i: Number of values
      integer		ival(3)		!i: Value(s) to load parameter
C--
      integer istat
Cbegin


      if ( ST_FAILED ) return

      istat = SAI__OK
      call par_put1i ( name, num, ival, istat )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="putgr"> PUTGR  </a>-- Put real number(s) to the CL
C
C    a j penny                ral         1988-09-07

      subroutine putgr ( name, num, rval )

      implicit none
      include 'SAE_PAR'
      include 'STARMAN_INC'

      character*(*)	name		!i: Name of parameter
      integer           num             !i: Number of values
      real		rval(3)		!i: Value to load parameter
C--
      integer istat
Cbegin


      if ( ST_FAILED ) return

      istat = SAI__OK
      call par_put1r ( name, num, rval, istat )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="space_ndf"> SPACE_NDF  </a>-- Find gap in ndf space common block
C
C  Patrick Morris          leeds          1991 Dec

      subroutine space_ndf ( n )

      implicit none
      include 'ST_ADAM_INC'
      include 'STARMAN_INC'

      integer	n		!o : Available space, -1 no space
C--
      logical found
Cbegin


      if ( ST_FAILED ) return

      if ( NDF_COUNTER.ge.NDF_LIMIT ) then
         n = -1
         return
      endif

      found = .false.
      n = 0
      do while ( .not.found )
         n = n + 1
         if ( n.gt.NDF_LIMIT ) then
            n = -1
            found = .true.
         else
            found = ( NDF_NAME(n).eq.'-' )
         endif
      enddo

      if ( n.gt.0 ) NDF_COUNTER = NDF_COUNTER + 1


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="starman_end"> STARMAN_END  </a>-- Close down Starman controls
C
C  alan penny               ral            1993 Jan

      subroutine starman_end ( ierradam )

      implicit none
      include 'STARMAN_INC'
      include 'SAE_PAR'

      integer    ierradam	!o: Flag for ADAM on 'failed'
C--
Cbegin


      call wrkcan ( ' ' )
      call canpar ( ' ' )

      call gd_close

      ierradam = SAI__OK
      call ndf_end ( ierradam )

      if ( ST_FAILED ) ierradam = SAI__ERROR


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="starman_start"> STARMAN_START  </a>-- Set up Starman defaults
C
C  alan penny               ral            1993 Jan

      subroutine starman_start ( )

      implicit none
      include 'STARMAN_INC'
C--
Cbegin


      ST_FAILED = .false.

      call ndf_begin
      call pargbeg
      call wrkbeg
      call filebeg
      call ds_setup
      call gd_setup
      call ch_setup


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="wrkbeg"> WRKBEG  </a>-- Set up computer work space information
C
C  alan penny              ral          1990 Jan

      subroutine wrkbeg ( )

      implicit none
      include 'ST_ADAM_INC'

C--
      integer k
Cbegin


      WS_COUNTER = 1
      do k = 1, WORK_LIMIT
          WS_NAME(k) = '-'
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="wrkcan"> WRKCAN  </a>-- Cancel work space name connection
C
C  alan penny              ral               1990 Jan
C
      subroutine wrkcan ( text )

      implicit none
      include 'ST_ADAM_INC'
      include 'SAE_PAR'

      character*(*)	text	!i: Name of work space to cancel
C--
      integer istat, n, lens, kl
      logical found, chr_equal
      external chr_equal, lens
Cbegin


      istat = SAI__OK

      if ( text.eq.' ' ) then

         do n = 1, WORK_LIMIT                				!Cancel all current w/s
            if ( WS_NAME(n).ne.'-' ) then
               call psx_free ( CPNTR(n), istat )
               WS_NAME(n) = '-'
               WS_COUNTER = WS_COUNTER - 1
            endif
         enddo

      else                                     				!Cancel one named w/s

         kl = min(50,lens(text))
         n = 0
         found = .false.
         do while ( .not.found )
            n = n + 1
            found = chr_equal ( text(1:kl), WS_NAME(n) )
            if ( found ) then
               call psx_free ( CPNTR(n), istat )
               WS_NAME(n) = '-'
               WS_COUNTER = WS_COUNTER - 1
            else
               if ( n.eq.WORK_LIMIT ) then
                  found = .true.
                  call printo ( 'Cant find workspace to close - '//
     +                           text(1:kl) )
               endif
            endif
         enddo

      endif


      end



CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C    This is STARFLIB_CHO.F
C
C    It contains s/rs for getting choices from the user:-
C
C SETUP_OPTION_S   Set up option in simple (key/panel) option choice
C SETUP_OPTION     Set up option in (key/panel) option choice
C GET_CHOICE       Get (key/panel) option choice
C CHOICE_PANEL_SW  Change between keyboard/panel input

C GET_OPTION       Get name in option name list from user chosen option name
C GET_JOB          Get number in option name list from user chosen option name

C TYPE_HCHOICE     Type out help at a program start on using the OPTION input

C CH_SETUP         Set up defaults before using choices
C GCMDLST          Squeeze command list and determine its character
C GCMDLSTA         Squeeze command list(s) and determine its/their character
C GETDEFT          Get default option from list of defaults (character)
C HX_HLOAD         Put out help panel help on chosen option  (ignores case)



CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="setup_option_s"> SETUP_OPTION_S  </a>-- Set up option in simple (key/panel) option choice
C
C   alan penny                      ral                    1993 Jul

      subroutine setup_option_s ( ktopt, set_num, koutside,
     +                            options, key_option, ncode )

      implicit none

      character*12  ktopt             		!o: Chosen option
      integer       set_num			!i: Arbitrary number for this set of options
						!    (must be different for different sets)
      logical       koutside			!i: Is this called from outside loop?
      character*(*) options			!i: Options list (a:b:c) (in order of appearence)
      character*(*) key_option			!i: Keyboard option name
      integer       ncode			!i: Panel number
C--
Cbegin


      call setup_option ( ktopt, set_num, koutside,
     +                    1, options, 'OPTIONS',
     +                    'List of options', key_option, ncode,
     +                    0, 1, ' ',
     +                    0, ' ',
     +                    0, ' ',
     +                    0, ' ',
     +                    0, 1, 1, ' ' )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="setup_option"> SETUP_OPTION  </a>-- Set up option in (key/panel) option choice
C
C   alan penny                      ral                    1993 Jul

      subroutine setup_option ( ktopt, set_num, koutside,
     +                          sect_num, sect_text, sect_head,
     +                          title, option, ncode,
     +                          do_opt_text, opt_num, opt_text,
     +                          do_opt_head, opt_head,
     +                          do_opt_help, opt_help,
     +                          do_help_ext, help_num, help_text,
     +                          do_def_text, def_x, def_y, def_text )

      implicit none

      include 'STARMAN_INC'
      include 'ST_CHOICE_INC'
      include 'ST_DS_PANEL_INC'

      character*12  ktopt             		!o: Chosen option
      integer       set_num			!i: Arbitrary number for this set of options
						!    (must be different for different sets)
      logical       koutside			!i: Is this called from outside loop?

      integer       sect_num			!i: Number of sections in panel
      character*(*) sect_head(sect_num)		!i: Headers for sections
      character*(*) sect_text(sect_num)		!i: Options in each section (in order of appearence)

      character*(*) title			!i: Title of panel
      character*(*) option			!i: Panel option name
      integer       ncode			!i: Panel number

      integer       do_opt_text			!i: Use option list? (0=no;1=yes)
      integer       opt_num			!i: Number of options (=1 if not use)
      character*(*) opt_text(opt_num)		!i: Options (= ' ' if not use)

      integer       do_opt_head			!i: Use Headers? (0=no;1=yes)
      character*(*) opt_head(opt_num)		!i: Header describing option (= ' ' if not use)

      integer       do_opt_help			!i: Use Help Box? (0=no;1=yes)
      character*(*) opt_help(6,opt_num)		!i: 6 line explanation of option
						!    (= ' ' if not use)

      integer       do_help_ext			!i: Use extra Help lines? (0=no;1=yes)
      integer       help_num			!i: Lines of extra help text (=1 if not use)
      character*(*) help_text(help_num)		!i: Extra help text (= ' ' if not use)

      integer       do_def_text			!i: Use defaults list? (0=no;1=yes)
      integer       def_x			!i: Number of default options
      integer       def_y			!i: Number of different sets of default options
      character*(*) def_text(def_x,def_y)	!i: Default options
C--
      integer j, k, ka, lens, kcon(200), jcon(200), kla(200), nmax
      integer kx, ky, knum, kb, kta(200), ktb(200)
      character*2000 texta
      external lens
Cbegin


      if ( ST_FAILED ) return

      if ( koutside ) then						!Set up defaults

         ktopt = ' '

         KLEF_X = 0
         KLEF_Y = 1
         LOOPT_HELP = .true.
         KTDEF_HELP = ' '
         TBHELP     = ' '

         CH_TITLE = ' '
         CH_OPTION = ' '
         CH_NCODE = 0

         CH_HELP_NUM = 1
         CH_HELP_TEXT(1) = ' '

         DOHPANEL = .true.
         CH_OPT_NUM = 1
         CH_OPT_TEXT(1) = ' '
         CH_OPT_HEAD(1) = ' '
         do k = 1, 6
            CH_OPT_HELP(k,1) = ' '
         enddo

         CH_SECT_NUM = 1
         CH_SECT_HEAD(1) = ' '
         CH_SECT_TEXT(1) = ' '

         CH_DEF_X = 1
         CH_DEF_Y = 1
         CH_DEF_TEXT(1,1) = ' '

      endif

      if ( set_num.eq.CH_NCODE ) return					!Check to see if needed

      if ( opt_num.gt.CH_MAX_OPT_NUM ) then
         call printo ( 'ERROR: Programmer error in s/r XX_CH_SETUP' )
         call printo ( '       OPT_NUM too large' )
         call printo ( '       Code needs rewriting: Contact'//
     +                 ' person who wrote the program' )
           ST_FAILED = .true.
         return
      endif

      if ( opt_num.lt.1 ) then
         call printo ( 'ERROR: Programmer error in s/r XX_CH_SETUP' )
         call printo ( '       OPT_NUM less than 1' )
         call printo ( '        Code needs rewriting: Contact'//
     +                 ' person who wrote the program' )
         ST_FAILED = .true.
         return
      endif

      if ( sect_num.gt.CH_MAX_SECT_NUM ) then
         call printo ( 'ERROR: Programmer error in s/r XX_CH_SETUP' )
         call printo ( '       SECT_NUM too large' )
         call printo ( '        Code needs rewriting: Contact'//
     +                 ' person who wrote the program' )
         ST_FAILED = .true.
         return
      endif

      if ( def_x.gt.CH_MAX_DEF_X ) then
         call printo ( 'ERROR: Programmer error in s/r XX_CH_SETUP' )
         call printo ( '       DEF_X too large' )
         call printo ( '        Code needs rewriting: Contact'//
     +                 ' person who wrote the program' )
         ST_FAILED = .true.
         return
      endif

      if ( def_x.lt.1 ) then
         call printo ( 'ERROR: Programmer error in s/r XX_CH_SETUP' )
         call printo ( '       DEF_X less than 1 ' )
         call printo ( '       Code needs rewriting: Contact'//
     +                 ' person who wrote the program' )
         ST_FAILED = .true.
         return
      endif

      if ( def_y.gt.CH_MAX_DEF_Y ) then
         call printo ( 'ERROR: Programmer error in s/r XX_CH_SETUP' )
         call printo ( '       DEF_Y too large' )
         call printo ( '       Code needs rewriting: Contact'//
     +                 ' person who wrote the program' )
         ST_FAILED = .true.
         return
      endif

      if ( def_y.lt.1 ) then
         call printo ( 'ERROR: Programmer error in s/r XX_CH_SETUP' )
         call printo ( '       DEF_Y less than 1 ' )
         call printo ( '       Code needs rewriting: Contact'//
     +                 ' person who wrote the program' )
         ST_FAILED = .true.
         return
      endif

      if ( (help_num+2+opt_num).gt.CH_MAX_HELP_NUM ) then
         call printo ( 'ERROR: Programmer error in s/r XX_CH_SETUP' )
         call printo ( '       HELP_NUM too large' )
         call printo ( '       Code needs rewriting: Contact'//
     +                 ' person who wrote the program' )
         ST_FAILED = .true.
         return
      endif

      kx = PNSNX/91							!Check enough space on Panel for buttons
      if ( (kx*91).ne.PNSNX ) then
         call printo ( 'ERROR: Programmer error in s/r XX_CH_SETUP' )
         call printo ( '       PNSNX not multiple of 91' )
         call printo ( '       Code needs rewriting: Contact'//
     +                 ' person who wrote the program' )
         ST_FAILED = .true.
         return
      endif
      ky = PNSNY/26
      if ( (ky*26).ne.PNSNY ) then
         call printo ( 'ERROR: Programmer error in s/r XX_CH_SETUP' )
         call printo ( '       PNSNY not multiple of 26' )
         call printo ( '       Code needs rewriting: Contact'//
     +                 ' person who wrote the program' )
         ST_FAILED = .true.
         return
      endif
      ka = 0								!Work out where the buttons end
      do k = 1, sect_num
         call gcmdlsta ( sect_text(k), texta, kb, knum, kta, ktb )
         ka = ka + 1 + knum
         if ( (ka-((ka/ky)*ky)).eq.(ky-1) ) ka = ka + 1
      enddo
      if ( ka.gt.((kx*ky)-5) ) then
         call printo ( 'ERROR: Programmer error in s/r XX_CH_SETUP' )
         call printo ( '       Not enough room in Panel for buttons')
         call printo ( '       Three gaps needed after Help button' )
         call printo ( '       Code needs rewriting: Contact'//
     +                 ' person who wrote the program' )
         ST_FAILED = .true.
         return
      endif


      CH_TITLE = title
      CH_OPTION = option
      CH_NCODE = ncode
      if ( do_opt_text.eq.0 ) DOHPANEL = .false.
      if ( do_opt_help.eq.0 .and. do_opt_head.eq.0)DOHPANEL=.false.

      CH_HELP_NUM = 2
      CH_HELP_TEXT(1) = 'Option        Function'
      CH_HELP_TEXT(2) = '------        --------'
      if ( do_opt_text.eq.0 ) then
         CH_HELP_NUM = 3
         CH_HELP_TEXT(3) = '   No -option- help available'
      else
         CH_HELP_NUM = CH_HELP_NUM + opt_num
      endif
      if ( do_help_ext.eq.1 ) CH_HELP_NUM = CH_HELP_NUM + help_num

      if ( do_opt_text.eq.1 ) then
         do k = 1, opt_num
            jcon(k) = k
         enddo
         nmax = 1
         do k = 1, opt_num
            kla(k) = lens(opt_text(k))
            nmax = max(nmax,kla(k))
         enddo
         do j = nmax, 1, -1
            do k = 1, opt_num
               ka = jcon(k)
               if ( j.gt.kla(ka) ) then
                  kcon(k) = -1
               else
                  kcon(k) = ichar(opt_text(ka)(j:j))
               endif
            enddo
            call sort2i ( kcon, jcon, opt_num )
         enddo
         ka = 2
         if ( do_opt_text.eq.0 ) ka = 3
         do k = 1, opt_num
            CH_HELP_TEXT(k+ka)(1:12) = opt_text(jcon(k))
            CH_HELP_TEXT(k+ka)(13:14) = '  '
            if ( do_opt_head.eq.1 ) then
               CH_HELP_TEXT(k+ka)(15:68) = opt_head(jcon(k))
            else
               CH_HELP_TEXT(k+ka)(15:68)='No description available'
            endif
         enddo

         CH_OPT_NUM = opt_num
         do k = 1, opt_num
            CH_OPT_TEXT(k) = opt_text(k)
            if ( do_opt_head.eq.1 ) then
               CH_OPT_HEAD(k) = opt_head(k)
            else
               CH_OPT_HEAD(k) = 'No description available'
            endif
            if ( do_opt_help.eq.1 ) then
                do j = 1, 6
                   CH_OPT_HELP(j,k) = opt_help(j,k)
                enddo
            else
                do j = 1, 6
                   CH_OPT_HELP(j,k) = ' '
                enddo
                CH_OPT_HELP(3,k) = 'No help available'
            endif
         enddo

      endif

      if ( do_help_ext.eq.1 .and. help_num.gt.0 ) then
         ka = 3
         if ( do_opt_text.eq.1 ) ka = 2 + opt_num
         do k = 1, help_num
            CH_HELP_TEXT(k+ka) = help_text(k)
         enddo
      endif

      CH_SECT_NUM = sect_num
      do k = 1, sect_num
         CH_SECT_TEXT(k) = sect_text(k)
         CH_SECT_HEAD(k) = sect_head(k)
      enddo

      if ( DOPANEL ) then						!Load panel
         call ds_p_sload ( CH_SECT_TEXT, CH_SECT_HEAD, CH_SECT_NUM,
     +                     CH_NCODE )
         call ds_p_pttit ( CH_TITLE )
         if ( DOHPANEL ) call ds_p_hx_load ( CH_TITLE )
      endif

      if ( koutside ) then
         if ( do_def_text.eq.1 ) then
            CH_DEF_X = def_x
            CH_DEF_Y = def_y
            do k = 1, def_y
               do j = 1, def_x
                 CH_DEF_TEXT(j,k) = def_text(j,k)
               enddo
            enddo
            ktopt = def_text(1,1)
         else
            CH_DEF_TEXT(1,1) = ' '
            ktopt = ' '
         endif
      endif


      end




CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="get_choice"> GET_CHOICE  </a>-- Get (key/panel) option choice
C
C   alan penny                      ral                    1993 Jul

      subroutine get_choice ( ktopt, kdohpanel )

      implicit none

      include 'ST_DS_GEN_INC'
      include 'ST_DS_PANEL_INC'
      include 'STARMAN_INC'
      include 'ST_CHOICE_INC'

      character*12    ktopt		!i/o: Option string
      integer         kdohpanel		!i: Use Help Panel? (0=no;1=yes)
C--
      integer ierr
      character*70 kd
Cbegin


      if ( ST_FAILED ) return

      call getdeft ( CH_DEF_TEXT, CH_MAX_DEF_X, CH_MAX_DEF_Y, 		!Default option
     +               CH_DEF_X, CH_DEF_Y, KLEF_X, KLEF_Y, LOOPT_HELP,
     +               ktopt )
      if ( ST_FAILED ) return
      if ( .not.LOOPT_HELP ) CH_AUTOSTART = .false.

      if ( ktopt.ne.' ' ) KTDEF_HELP = ktopt				!Choice

      kd = KTDEF_HELP
      if ( .not.CH_AUTOSTART ) then
         if ( DOPANEL ) then
            call ds_p_gsbox ( CH_SECT_TEXT, CH_SECT_HEAD, CH_SECT_NUM,
     +                        ktopt, kd, CH_HELP_TEXT, CH_HELP_NUM,
     +                        CH_OPT_NUM, CH_OPT_TEXT, CH_OPT_HEAD,
     +                        CH_OPT_HELP, CH_TITLE, DOHPANEL, ierr )
         else
            call get_option ( 'OPTION', CH_SECT_TEXT, CH_SECT_NUM,
     +                        ktopt, kd, CH_HELP_TEXT, CH_HELP_NUM )
            if ( ST_FAILED ) return
         endif
      endif
      KTDEF_HELP = kd

      if ( kdohpanel.eq.1 .and. DOHPANEL ) call hx_hload ( ktopt,
     +            CH_OPT_TEXT, CH_OPT_HEAD, CH_OPT_HELP, CH_OPT_NUM )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="choice_panel_sw"> CHOICE_PANEL_SW  </a>-- Change between keyboard/panel input
C
C  a j penny                          dao              1988-04-19

      subroutine choice_panel_sw ()

      implicit none
      include 'STARMAN_INC'
      include 'ST_CHOICE_INC'
      include 'ST_DS_PANEL_INC'
C--
Cbegin


      if ( ST_FAILED ) return

      call ds_p_switchs ( CH_TITLE, CH_SECT_TEXT, CH_SECT_HEAD,         !Change panel/keyboard inpu
     +                    CH_SECT_NUM, CH_NCODE )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="get_option"> GET_OPTION  </a>-- Get name in option name list from user chosen option name
C  User chooses from a list of option names, this s/r returns the number of
C  that option. If 'help' entered, help given. S/r cycles until a 'correct'
C  reply is given.
C
C   alan penny               ral                       1990 Jan

      subroutine get_option ( option, cmdlsts, nopt, ktopt, ktdefs,
     +                        thelp, nh )

      implicit none
      include 'STARMAN_INC'

      character*(*) option		!i: Name of programme parameter to access
      integer       nopt		!i: Number of lists
      character*(*) cmdlsts(nopt)	!i: List of option names
      character*(*) ktopt		!o: Name of chosen option
      character*(*) ktdefs		!i: Default option name
      integer       nh			!i: No of help text lines
      character*68  thelp(1)		!i: Help text
C--
      integer k, ks, ke, kd, kp, ktlen, kl, kexact, kopt, kdef, num,
     +        ksw(200), klw(200), jcon(200)
      character text*40, texta*40, ktdef*10
      character*2000 cmdlst, textc
      logical loop

      integer lens
      external lens
Cbegin


      if ( ST_FAILED ) return

      textc = cmdlsts(1)
      if ( nopt.gt.1 ) then
         do k = 2, nopt
            kl = lens(textc)
            textc = textc(1:kl)//':'//cmdlsts(k)
         enddo
      endif

      if ( textc.eq.' ' ) return					!Check for null reference entry

      call gcmdlsta  ( textc, cmdlst, kl, num, ksw, klw )		!Squeeze command list

      kdef = 1								!Find location in list of default
      do k = 1, num
         ks = ksw(k)
         ke = ks + klw(k) - 1
         if ( ktdef.eq.cmdlst(ks:ke) ) kdef = k
      enddo

      do k = 1, 200							!Order of listing for 'not found'
         jcon(k) = k							! is as input
      enddo

      loop = .true.							!Get entry, put into lower case
      do while ( loop )							! Loop back if help asked for

         call get1c ( option, texta, ktdefs, .true. )			!Get entry
         if ( ST_FAILED ) return
         call lbgone ( texta )						!Make input Lower case and remove leading blanks
         ktlen = lens(texta)
         call lowcase ( texta, text )

         if ( text.eq.'help' ) then					!Issue help if that is entry
            call tyhelp ( thelp, nh, cmdlst, jcon, ksw, klw, num )
         else

            kd = -1							!Find if any match in entry
            kexact = 0							! and if so what
            if ( text.ne.' ' ) then
               kd = 0
               do k = 1, num
                  ks = ksw(k)
                  ke = ks + klw(k) - 1
                  if ( index(cmdlst(ks:ke),text(1:ktlen)).eq.1 ) then
                     if ( ktlen.eq.(ke-ks+1) ) kexact = k
                     kp = k
                     kd = kd + 1
                  endif
               enddo
            endif

            loop = .false.							!Check entry
            if ( kd.eq.-1 ) then
               kopt = kdef
            elseif ( kd.eq.0 ) then
               call printo ( 'ERROR: Not found - ignored - try again' )
               loop = .true.
            elseif ( kexact.ne.0 ) then
               kopt = kexact
            elseif ( kd.eq.1 ) then
               kopt = kp
            else
               call printo ( 'ERROR: Ambiguous - ignored - try again' )
               loop = .true.
            endif

         endif

      enddo

      ks = ksw(kopt)
      ke = ks + klw(kopt) - 1
      ktopt = cmdlst(ks:ke)


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="get_job"> GET_JOB  </a>-- Get number in option name list from user chosen option name
C  User chooses from a list of option names, this s/r returns the number of
C  that option. If 'help' entered, help given. S/r cycles until a 'correct'
C  reply is given.
C
C   alan penny               ral                       1990 Jan

      subroutine get_job ( option, cmdlsts, kopt, kdefs, thelp, nh )

      implicit none
      include 'STARMAN_INC'

      character*(*) option	!i: Name of programme parameter to access
      character*(*) cmdlsts	!i: List of option names
      integer       kopt	!o: Posn in list of chosen option
      integer       kdefs	!i: Posn in list of default option name
      integer       nh		!i: No of help text lines
      character*68  thelp(1)	!i: Help text
C--
      integer k, ks, ke, kd, kp, ktlen, kdef, j, kl, kexact,
     +        jcon(200), num, kds, kde, ksw(200), klw(200), lens
      character*40 text
      character*2000 cmdlst
      logical loop
      external lens
Cbegin


      if ( ST_FAILED ) return

      if ( cmdlsts.eq.' ' ) return					!Check for null reference entry

      call gcmdlst  ( cmdlsts, cmdlst, kdefs, kdef, kds, kde, kl, num,	!Squeeze command list
     +                jcon, ksw, klw )

      loop = .true.							!Get entry, put into lower case
      do while ( loop )							! Loop back if help asked for

         call get1c ( option, text, cmdlst(kds:kde), .true. )		!Get entry
         if ( ST_FAILED ) return
         call lbgone ( text )						!Make input Lower case and remove leading blanks
         ktlen = lens(text)
         do k = 1, ktlen
            j = ichar(text(k:k))
            if ( j.ge.65 .and.  j.le.90 ) text(k:k) = char(j+32)
         enddo

         if ( text.eq.'help' ) then					!Issue help if that is entry
            call tyhelp ( thelp, nh, cmdlst, ksw, klw, jcon, num )
         else

            kd = -1							!Find if any match in entry
            kexact = 0							! and if so what
            if ( text.ne.' ' ) then
               kd = 0
               do k = 1, num
                  ks = ksw(k)
                  ke = ks + klw(k) - 1
                  if ( index(cmdlst(ks:ke),text(1:ktlen)).eq.1 ) then
                     if ( ktlen.eq.(ke-ks+1) ) kexact = k
                     kp = k
                     kd = kd + 1
                  endif
               enddo
            endif

            loop = .false.							!Check entry
            if ( kd.eq.-1 ) then
               kopt = kdef
            elseif ( kd.eq.0 ) then
               call printo ( 'ERROR: Not found - ignored - try again' )
               loop = .true.
            elseif ( kexact.ne.0 ) then
               kopt = kexact
            elseif ( kd.eq.1 ) then
               kopt = kp
            else
               call printo ( 'ERROR: Ambiguous - ignored - try again' )
               loop = .true.
            endif

         endif

      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="type_hchoice"> TYPE_HCHOICE  </a>-- Type out help at a program start on using the OPTION input
C
C  a j penny                          dao              1988-04-19

      subroutine type_hchoice ()


      implicit none
      include 'STARMAN_INC'

C--
      integer nline, j
      parameter ( nline=22 )
      character*68 tline (nline)
      data ( tline(j),j=1,10 ) /
     + ' ',
     + '       GENERAL INTRODUCTION to LOOPING INSTRUCTIONS',
     + 'You can choose from a list of OPTIONS, either by:-',
     + ' a) If a "TV" type screen is being used, by using a window',
     + '    "panel" full of "buttons" for inputting choices.',
     + ' b) Using the keyboard and the normal window.',
     + '  ',
     + 'In this later case, then:-',
     + '1) You have a list of OPTIONs to choose from; you choose one;',
     + '   the computer performs that OPTION (which may require '/
      data ( tline(j),j=11,20 ) /
     + '   further user interaction); the list is offered again.',
     + '   For example, you might be offered the line:-',
     + '   "  OPTION - Which action to perform? /"image"/ >  "',
     + '   To (say) get an image in a file, reply "image" (without',
     + '   the quote marks). You are then asked for the name of the ',
     + '   file, the computer accesses it, and offers OPTION again.',
     + '2) A "default" choice is given ("image" in the above example).',
     + '   The default is selected by doing the "carriage return".',
     + '3) Get Help by typing "?" or "??" (for full help), for input.',
     + '4) At the start, the default changes at each choice, with a '/
      data ( tline(j),j=21,nline ) /
     + '   succession of defaults being "recommended".',
     + ' '/
Cbegin


      if ( ST_FAILED ) return

      do j = 1, nline
         call printo ( tline(j) )
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="ch_setup"> CH_SETUP  </a>-- Set up defaults before using choices
C
C   a j penny                 ral                1994 April

      subroutine ch_setup ()

      implicit none
      include 'ST_CHOICE_INC'
      include 'STARMAN_INC'
C--
Cbegin


      if ( ST_FAILED ) return

      CH_AUTOSTART = .false.


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gcmdlst"> GCMDLST  </a>-- Squeeze command list and determine its character
C
C  a j penny                          dao              1988-04-19

      subroutine gcmdlst ( cmdlsts, cmdlst, kdefs, kdef, kds, kde,
     +                     kl, num, jcon, ksw, klw )


      implicit none
      include 'STARMAN_INC'

      character*(*)	cmdlsts		!i: Input list
      character*(*)	cmdlst		!o: List removed of blanks,
					!   multiple ':'s, etc
      integer		kdefs		!i: Input default option number
      integer		kdef		!o: Output default option number
      integer		kds		!o: Start of default option
      integer		kde		!o: End of default option
      integer		kl		!o: Character length of ouput command
					!   list
      integer		num		!o: Number of options in list
      integer		jcon(200)	!o: Alphabetical order of options
      integer		ksw(200)	!o: Start characters of options
      integer		klw(200)	!o: Character length of options
C--
      integer j, k, ja, ka, lens, kcon(200), nmax
      logical more
      external lens
Cbegin


      if ( ST_FAILED ) return

      kl = lens(cmdlsts)
      call lowcase ( cmdlsts, cmdlst )					!Transfer input, and lower case it

      cmdlst(kl+1:) = ' '						!Remove blanks in reference entry
      k = 1
      do while ( k.lt.kl )
         if ( cmdlst(k:k).eq.' ' ) then
            do j = k, kl-1
               cmdlst(j:j) = cmdlst(j+1:j+1)
            enddo
            kl = kl - 1
            k = k - 1
         endif
         k = k + 1
      enddo

      k = 1								!Remove multiple ':'s
      do while ( k.lt.kl )
         if ( cmdlst(k:k).eq.':' ) then
            more = .true.
            ka = k
            do while ( more )
               ka = ka + 1
               if ( cmdlst(ka:ka).ne.':' ) more = .false.
            enddo
            ja = ka - k - 1
            if ( ja.ne.0 ) then
               do j = k+1, kl - ja
                  cmdlst(j:j) = cmdlst(j+ja:j+ja)
               enddo
               kl = kl - ja
               cmdlst(kl+1:) = ' '
            endif
         endif
         k = k + 1
      enddo

      if ( cmdlst(1:1).eq.':' ) then					!Remove lead or end ':'	
          do k = 1, kl-1
             cmdlst(k:k) = cmdlst(k+1:k+1)
          enddo
          kl = kl - 1
      endif
      if ( cmdlst(kl:kl).eq.':' ) then
         cmdlst(kl:kl) = ' '
         kl = kl - 1
      endif

      num = 0								!Find number of words
      do k = 1, kl
         if ( cmdlst(k:k).eq.':' ) num = num + 1
      enddo
      num = num + 1
      num = min(200,num)

      kdef = min(num,max(1,kdefs))					!Get default entry
      kds = 1
      kde = 1
      k = 1
      do j = 1, kl
         if ( cmdlst(j:j).eq.':' ) then
            k = k + 1
            if ( k.eq.kdef ) kds = j + 1
            if ( k.eq.kdef+1 ) kde = j - 1
         endif
      enddo
      if ( kdef.eq.num ) kde = kl

      nmax = 0								!Max length of any option
      ka = 0								! and start and length ofeach option
      do k = 1, kl
         if ( k.eq.1 .or. cmdlst(k:k).eq.':' ) then
            ka = ka + 1
            ksw(ka) = k
            j = k
            if ( k.ne.1 ) then
               ksw(ka) = ksw(ka) + 1
               j = j + 1
            endif
            do while ( j.lt.kl .and. cmdlst(j:j).ne.':' )
               j = j + 1
            enddo
            klw(ka) = j - ksw(ka)
            if ( j.eq.kl ) klw(ka) = klw(ka) + 1
            nmax = max(nmax,klw(ka))
         endif
      enddo

      do k = 1, num
         jcon(k) = k
      enddo
      do j = nmax, 1, -1
         do k = 1, num
            ka = jcon(k)
            if ( j.gt.klw(ka) ) then
               kcon(k) = -1
            else
               ja = ksw(ka) + j - 1
               kcon(k) = ichar(cmdlst(ja:ja))
            endif
         enddo
         call sort2i ( kcon, jcon, num )
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gcmdlsta"> GCMDLSTA  </a>-- Squeeze command list(s) and determine its/their character
C
C  a j penny                          dao              1988-04-19

      subroutine gcmdlsta ( cmdlsts, cmdlst, kl, num, ksw, klw )


      implicit none
      include 'STARMAN_INC'

      character*(*)	cmdlsts		!i: Input list
      character*(*)	cmdlst		!o: List removed of blanks, multiple ':'s, etc
      integer		kl		!o: Character length of ouput command list
      integer		num		!o: Number of options in list
      integer		ksw(200)	!o: Start characters of options
      integer		klw(200)	!o: Character length of options
C--
      integer j, k, ja, ka, lens, nmax
      logical more
      external lens
Cbegin


      if ( ST_FAILED ) return

      kl = lens(cmdlsts)
      call lowcase ( cmdlsts, cmdlst )					!Transfer input, and lower case it

      cmdlst(kl+1:) = ' '						!Remove blanks in reference entry
      k = 1
      do while ( k.lt.kl )
         if ( cmdlst(k:k).eq.' ' ) then
            do j = k, kl-1
               cmdlst(j:j) = cmdlst(j+1:j+1)
            enddo
            kl = kl - 1
            k = k - 1
         endif
         k = k + 1
      enddo

      k = 1								!Remove multiple ':'s
      do while ( k.lt.kl )
         if ( cmdlst(k:k).eq.':' ) then
            more = .true.
            ka = k
            do while ( more )
               ka = ka + 1
               if ( cmdlst(ka:ka).ne.':' ) more = .false.
            enddo
            ja = ka - k - 1
            if ( ja.ne.0 ) then
               do j = k+1, kl - ja
                  cmdlst(j:j) = cmdlst(j+ja:j+ja)
               enddo
               kl = kl - ja
               cmdlst(kl+1:) = ' '
            endif
         endif
         k = k + 1
      enddo

      if ( cmdlst(1:1).eq.':' ) then					!Remove lead or end ':'	
          do k = 1, kl-1
             cmdlst(k:k) = cmdlst(k+1:k+1)
          enddo
          kl = kl - 1
      endif
      if ( cmdlst(kl:kl).eq.':' ) then
         cmdlst(kl:kl) = ' '
         kl = kl - 1
      endif

      num = 0								!Find number of words
      do k = 1, kl
         if ( cmdlst(k:k).eq.':' ) num = num + 1
      enddo
      num = num + 1
      num = min(200,num)

      nmax = 0								!Max length of any option
      ka = 0								! and start and length ofeach option
      do k = 1, kl
         if ( k.eq.1 .or. cmdlst(k:k).eq.':' ) then
            ka = ka + 1
            ksw(ka) = k
            j = k
            if ( k.ne.1 ) then
               ksw(ka) = ksw(ka) + 1
               j = j + 1
            endif
            do while ( j.lt.kl .and. cmdlst(j:j).ne.':' )
               j = j + 1
            enddo
            klw(ka) = j - ksw(ka)
            if ( j.eq.kl ) klw(ka) = klw(ka) + 1
            nmax = max(nmax,klw(ka))
         endif
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="getdeft"> GETDEFT  </a>-- Get default option from list of defaults (character)
C
C    alan penny                    ral       1990 jan

      subroutine getdeft ( kopta, knx, kny, nx, ny, kl_x, kl_y,
     +                     loopt, kopt )

      implicit none
      include 'STARMAN_INC'

      integer       knx			!i: Max no of times defaults can be asked for
      integer       kny			!i: Max No of different sets of possible defaults
      character*12  kopta(knx,kny)	!i: Default series
      integer       nx			!i: No of times defaults can be asked for
      integer       ny			!i: No of different sets of possible defaults
      integer       kl_x		!i/o: Number of times have asked for default
      integer       kl_y		!i/o: Last Y posn in defaults array
      logical       loopt		!i/o: Following correct series of defaults?
      character*(*) kopt		!i/o: Last default/Chosen new default
C--
      logical ok
      integer j
Cbegin


      if ( ST_FAILED ) return

      kl_x = kl_x + 1			
      if ( kl_x.lt.nx .and. loopt ) then
         ok = .false.
         do j = kl_y, ny
            if ( .not.ok .and. kopt.eq.kopta(kl_x,j) ) then
               ok = .true.
               kl_y = j
            endif
         enddo
         if ( ok ) then
            kopt = kopta((kl_x+1),kl_y)
         else
            loopt = .false.
         endif
      else
         loopt = .false.
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="hx_hload"> HX_HLOAD  </a>-- Put out help panel help on chosen option  (ignores case)
C
C   alan penny                        ral              1990-01-31

      subroutine hx_hload ( ktopt, topt, thead, thelp, nopt )

      implicit none
      include 'ST_CHOICE_INC'

      character*(*)   ktopt		!i: Chosen option
      integer         nopt		!i: No of possible options
      character*12    topt(nopt)	!i: Possible options  (ignores case)
      character*68    thead(nopt)	!i: Single line helps
      character*68    thelp(6,nopt)	!i: Fuller helps
C--
      logical there, found
      integer j, k, ka, kb, kl, kch, ktlen, ktlena
      character topta*12, toptb*12, texta*12, textb*50, textc*50
      character ohead*68, ohelp*545, ohelp1*68, bopt*12
      integer lens
      external lens

      character*68  otbhead, otbhelp(8)
      data otbhead, (otbhelp(j),j=1,8) /
     + 'Help for the buttons',
     + ' ', ' ',
     + '    *************************************************',
     + '    YOU WILL GET HELP HERE ON A BUTTON WHEN YOU PRESS',
     + '                    THE BUTTON YOU WANT THE HELP ON  ',
     + '    *************************************************',
     + ' ',' ' /

      character*68  ntbhead, ntbhelp(6)
      data ntbhead, (ntbhelp(j),j=1,6) /
     + 'Help for this button',
     + ' ', ' ',
     + '    ***  ***   ***  ***   ***   ***   ***   ***   ***   ***',
     + '    PANEL HELP IS NOT YET AVAILABLE FOR THIS BUTTON      ',
     + '    ***  ***   ***  ***   ***   ***   ***   ***   ***   ***',
     + ' ' /

      character*68  t1head, t1help(6)
      data t1head, (t1help(j),j=1,6) /
     + 'HELP',
     + 'Pressing this button gets a type-out of the list of options ',
     + 'and also some general help on the options.',
     + 'This button also has a display of the -state- of the program.',
     + 'WAITING = waiting for you to do something like press a button',
     + 'Other messages are: WORKING HELPING PANNING ZOOMING ',
     + 'NOT YET    READY   ONE GOT. The meaning will be clear in use.' /

Cbegin


      found = .false.
      ktlen = lens ( ktopt )
      if ( ktlen.ge.1 ) then
         ktlen = min(50,ktlen)
         textb = ktopt(1:ktlen)
         call lowcase ( textb, textc )
         call lbgone ( textc )
         ktlen = lens ( textc )
         ktlen = min(12,ktlen)
         texta = textc(1:ktlen)

         kch = 0
         do while ( .not.found .and. kch.lt.nopt )
            kch = kch + 1
            toptb = topt(kch)
            call lowcase ( toptb, topta )
            ktlena = lens(topta)
            if ( ktlena.eq.ktlen ) then
               there = .true.
               do j = 1, ktlen
                  if ( topta(j:j).ne.texta(j:j) ) there = .false.
               enddo
               if ( there ) found = .true.
            endif
         enddo
         kl = 0
         if ( .not.found ) then
            if ( ktopt.eq.'XX_HELP' ) then
               kl = 1
            else
               kl = 2
            endif
            found = .true.
         endif
      endif

      if ( found ) then
          bopt = ' '
          k = 1
          if ( kl.eq.0 ) bopt = topt(kch)
          if ( kl.eq.1 ) bopt = t1head
          if ( kl.eq.2 ) bopt = texta
          k = lens(bopt)
          ohead = 'Help for the  - '//bopt(1:k)//' -  panel button'
      endif

      do j = 1, 8*68
         ohelp(j:j) = ' '
      enddo
      ohelp(545:545) = 'T'


      do j = 1, 8

         if ( found ) then
            if ( j.eq.1 ) then
               if ( kl.eq.0 ) then
                  ohelp1 = thead(kch)
               elseif ( kl.eq.1 ) then
                  ohelp1 = t1head
               else
                  ohelp1 = ntbhead
               endif
            elseif ( j.eq.2 ) then
               ohelp1 = ' '
            else
               if ( kl.eq.0 ) then
                  ohelp1 = thelp(j-2,kch)
               elseif ( kl.eq.1 ) then
                  ohelp1 = t1help(j-2)
               else
                  ohelp1 = ntbhelp(j-2)
               endif
            endif
         endif

         ka = 1 + (j-1)*68
         k = min(68,lens(ohelp1))
         if ( k.gt.0 ) then
            kb = ka + k - 1
            ohelp(ka:kb) = ohelp1(1:k)
         endif

      enddo

      call ds_p_hx_hload ( ohead, ohelp )


      end

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C  This is  starflib_mach.f_OSF1
C
C  Contains Machine specific routines:-
C
C AJRAN       Random number generator
C AJSEED      Set seed for Random number generator


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="ajran"> AJRAN  </a>-- Random number generator
C
C   a j penny                    ral                 1991 Nov

      real function ajran ( nran )

      implicit none

      integer   nran    !i/o: Seed
C--
      real rand
      external rand
Cbegin

      ajran = rand ()

      end

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="ajseed"> AJSEED  </a>-- Seed for random number generator
C
C   a j penny                    ral                 1991 Nov

      subroutine ajseed ( nran )

      implicit none

      integer   nran    !i/o: Seed
C--
      real j

Cbegin


      call srand (nran)


      end

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C STARFLIB_PRE.FOR
C
C  It contains:-
C
C GET1(BCIR)     Get a (boolean:character string:integer:real) from the CL
C GET(2345)(IR)  Get (2:3:4:5) (integers:reals) from the CL
C GTIMZD         Get descriptors BSACLE, BZERO, INVAL, TITLE form a real or int*2 image
C GTWRK(IRS)     Open (int:real:short) computer work space
C OPIM(IRSU)R    Open an input 2d read-only (real:int*2:unsigned int*2:int) image
C OPIM4ZR        Open an input 4d read-only real/int/int*2 image
C OPIMZ(RW)      Open an input 2d read-only/write-only real or int*2 image
C OPIM(IRS)W     Open an output 2d write-only (real:integer*2:integer) image
C OPIM4(IRS)W    Open an output 4d write-only (real:integer*2:integer) image
C PUT(123)(IR)   Put (integer:real) (1:2:3) numbers to the CL



CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="get1b"> GET1B  </a>-- Get a boolean value from the CL
C
C       a j penny              stsci                1987 oct 16

      subroutine get1b ( param, bool, inbool )

      implicit none

      character*(*) param	!i: Parameter name
      logical bool		!o: Boolean value got
      logical inbool		!i: Default boolean value
C--
      logical bv(5)
      integer num
Cbegin


      num = 1
      bv(1) = inbool
      call getgb ( param, bv, num, .true. )
      bool = bv(1)


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="get1i"> GET1I  </a>-- Get 1 integer from CL
C
C   aj penny                        dao             1988-04-19


      subroutine get1i ( param, i1, in, imin, imax )

      implicit none

      character*(*) param	!i: Parameter to access in CL
      integer	    i1		!o: Integer - gotten value
      integer	    in		!i: Integer - default value
      integer       imin	!i: Min allowed value
      integer       imax	!i: Max allowed value
C--
      integer iv(5)
Cbegin


      iv(1) = in
      call getgi ( param, iv, 1, .true., imin, imax )
      i1 = iv(1)

      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="get2i"> GET2I  </a>-- Get 2 integers from the CL
C
C   aj penny                        dao             1988-04-19


      subroutine get2i ( param, i1, i2, def, imin, imax )

      implicit none

      character*(*) param	!i: Parameter to access in CL
      integer	    i1		!i/o: Integers (defaults/gotten values)
      integer       i2		!i/o
      logical       def		!i: Is a null rsponse valid?
      integer       imin	!i: Min allowed value
      integer       imax	!i: Max allowed value
C--
      integer iv(5)
Cbegin


      iv(1) = i1
      iv(2) = i2
      call getgi ( param, iv, 2, def, imin, imax )
      i1 = iv(1)
      i2 = iv(2)


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="get3i"> GET3I  </a>-- Get 3 integers from the CL
C
C    a j penny                 dao                   1988-04-19


      subroutine get3i ( param, i1, i2, i3, def, imin, imax )

      implicit none

      character*(*) param	!i: Parameter to access in CL
      integer	    i1		!i/o: Integers (defaults/gotten values)
      integer       i2		!i/o
      integer       i3		!i/o:
      logical       def		!i: Is a null rsponse valid?
      integer       imin	!i: Min allowed value
      integer       imax	!i: Max allowed value
C--
      integer iv(5)
Cbegin


      iv(1) = i1
      iv(2) = i2
      iv(3) = i3
      call getgi ( param, iv, 3, def, imin, imax )
      i1 = iv(1)
      i2 = iv(2)
      i3 = iv(3)


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="get4i"> GET4I  </a>-- Get 4 integers from the CL
C
C    a j penny                 ral                   1988-Nov


      subroutine get4i ( param, i1, i2, i3, i4, def, imin, imax )

      implicit none

      character*(*) param	!i: Parameter to access in CL
      integer	    i1		!i/o: Integers (defaults/gotten values)
      integer       i2		!i/o
      integer       i3		!i/o:
      integer       i4		!i/o:
      logical       def		!i: Is a null rsponse valid?
      integer       imin	!i: Min allowed value
      integer       imax	!i: Max allowed value
C--
      integer iv(5)
Cbegin


      iv(1) = i1
      iv(2) = i2
      iv(3) = i3
      iv(4) = i4
      call getgi ( param, iv, 4, def, imin, imax )
      i1 = iv(1)
      i2 = iv(2)
      i3 = iv(3)
      i4 = iv(4)


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="get5i"> GET5I  </a>-- Get 5 integers from the CL
C
C    a j penny                 ral                   1988-Nov


      subroutine get5i ( param, i1, i2, i3, i4, i5, def, imin, imax )

      implicit none

      character*(*) param	!i: Parameter to access in CL
      integer	    i1		!i/o: Integers (defaults/gotten values)
      integer       i2		!i/o
      integer       i3		!i/o:
      integer       i4		!i/o:
      integer       i5		!i/o:
      logical       def		!i: Is a null rsponse valid?
      integer       imin	!i: Min allowed value
      integer       imax	!i: Max allowed value
C--
      integer iv(5)
Cbegin


      iv(1) = i1
      iv(2) = i2
      iv(3) = i3
      iv(4) = i4
      iv(5) = i5
      call getgi ( param, iv, 5, def, imin, imax )
      i1 = iv(1)
      i2 = iv(2)
      i3 = iv(3)
      i4 = iv(4)
      i5 = iv(5)


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="get1r"> GET1R  </a>-- Get 1 real from CL
C
C   aj penny                        dao             1988-04-19


      subroutine get1r ( param, r1, rin, rmin, rmax )

      implicit none

      character*(*) param	!i: Parameter to access in CL
      real          r1		!o: Real - gotten value
      real          rin		!i: Real - default value
      real          rmin	!i: Min allowed value
      real          rmax	!i: Max allowed value
C--
      real  rv(5)
Cbegin


      rv(1) = rin
      call getgr ( param, rv, 1, .true., rmin, rmax )
      r1 = rv(1)


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="get2r"> GET2R  </a>-- Get 2 reals from the CL
C
C   aj penny                        dao             1988-04-19


      subroutine get2r ( param, r1, r2, def, rmin, rmax )

      implicit none

      character*(*) param	!i: Parameter to access in CL
      real          r1		!i/o: Reals (defaults/gotten values)
      real          r2		!i/o:
      logical       def		!i: Is a null rsponse valid?
      real          rmin	!i: Min allowed value
      real          rmax	!i: Max allowed value
C--
      real rv(5)
Cbegin


      rv(1) = r1
      rv(2) = r2
      call getgr ( param, rv, 2, def, rmin, rmax )
      r1 = rv(1)
      r2 = rv(2)


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="get3r"> GET3R  </a>-- Get 3 reals from the CL
C
C   aj penny                        dao             1988-04-19


      subroutine get3r ( param, r1, r2, r3, def, rmin, rmax )

      implicit none

      character*(*) param	!i: Parameter to access in CL
      real          r1		!i/o: Reals (defaults/gotten values)
      real          r2		!i/o:
      real          r3		!i/o:
      logical       def		!i: Is a null rsponse valid?
      real          rmin	!i: Min allowed value
      real          rmax	!i: Max allowed value
C--
      real rv(5)
Cbegin


      rv(1) = r1
      rv(2) = r2
      rv(3) = r3
      call getgr ( param, rv, 3, def, rmin, rmax )
      r1 = rv(1)
      r2 = rv(2)
      r3 = rv(3)


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="get4r"> GET4R  </a>-- Get 4 reals from the CL
C
C   aj penny                        dao             1988-04-19


      subroutine get4r ( param, r1, r2, r3, r4, def, rmin, rmax )

      implicit none

      character*(*) param	!i: Parameter to access in CL
      real          r1		!i/o: Reals (defaults/gotten values)
      real          r2		!i/o:
      real          r3		!i/o:
      real          r4		!i/o:
      logical       def		!i: Is a null rsponse valid?
      real          rmin	!i: Min allowed value
      real          rmax	!i: Max allowed value
C--
      real rv(5)
Cbegin


      rv(1) = r1
      rv(2) = r2
      rv(3) = r3
      rv(4) = r4
      call getgr ( param, rv, 4, def, rmin, rmax )
      r1 = rv(1)
      r2 = rv(2)
      r3 = rv(3)
      r4 = rv(4)


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="get5r"> GET5R  </a>-- Get 5 reals from the CL
C
C   aj penny                        dao             1988-04-19


      subroutine get5r ( param, r1, r2, r3, r4, r5, def, rmin, rmax )

      implicit none

      character*(*) param	!i: Parameter to access in CL
      real          r1		!i/o: Reals (defaults/gotten values)
      real          r2		!i/o:
      real          r3		!i/o:
      real          r4		!i/o:
      real          r5		!i/o:
      logical       def		!i: Is a null rsponse valid?
      real          rmin	!i: Min allowed value
      real          rmax	!i: Max allowed value
C--
      real rv(5)
Cbegin


      rv(1) = r1
      rv(2) = r2
      rv(3) = r3
      rv(4) = r4
      rv(5) = r5
      call getgr ( param, rv, 5, def, rmin, rmax )
      r1 = rv(1)
      r2 = rv(2)
      r3 = rv(3)
      r4 = rv(4)
      r5 = rv(5)


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gtimzd"> GTIMZD  </a>-- Get descriptors BSACLE, BZERO, INVAL, TITLE form a real or int*2 image
C
C  alan penny              ral          1990 Jan

      subroutine gtimzd ( name, gtype, bs, bz, inval, rinval, title,
     +                    ierr )

      implicit none
      include 'ST_LIMITS_INC'

      character*(*) name        !i: parameter name of image
      character*(*) gtype       !i: Image type ('REAL', 'SHORT')
      real          bs          !o: Image scale
      real          bz          !o: Image zero
      integer       inval      	!o: Int*2 Image bad pixel flag (undef if 'REAL')
      real          rinval      !o: Real Image bad pixel flag  (undef if 'SHORT')
      character*(*) title       !o: Image title
      integer       ierr        !o: Error flag (0=ok)
C--
Cbegin


      if ( gtype.eq.'SHORT') then
         call gtimsd ( name, bs, bz, inval, title, ierr )
      elseif ( gtype.eq.'REAL') then
         call gtimrd ( name, bs, bz, rinval, title, ierr )
      else
         ierr = 1
         call printo ( ' ERROR: programmer error in s/r GTIMZD' )
         call printo ( '        Code needs rewriting: Contact'//
     +                 ' person who wrote the program' )
        endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gtwrki"> GTWRKI  </a>-- Open integer*4 computer work space
C
C  alan penny              ral          1990 Jan

      subroutine gtwrki ( text, n, ip, ierr )

      implicit none

      character*(*) text	!i: Name to give to work space
      integer       n		!i: Size to allocate (in words)
      integer       ip		!o: Pointer to allocated space
      integer       ierr	!o: Error flag: 0=ok, 1=bad
C--
Cbegin


      call gtwrkg ( text, n, 'INT', ip, ierr )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gtwrkr"> GTWRKR  </a>-- Open real computer work space
C
C  alan penny              ral          1990 Jan

      subroutine gtwrkr ( text, n, ip, ierr )

      implicit none

      character*(*) text	!i: Name to give to work space
      integer       n		!i: Size to allocate (in words)
      integer       ip		!o: Pointer to allocated space
      integer       ierr	!o: Error flag: 0=ok, 1=bad
C--
Cbegin


      call gtwrkg ( text, n, 'REAL', ip, ierr )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gtwrks"> GTWRKS  </a>-- Open short computer work space
C
C  alan penny              ral          1990 Jan

      subroutine gtwrks ( text, n, ip, ierr )

      implicit none

      character*(*) text	!i: Name to give to work space
      integer       n		!i: Size to allocate (in words)
      integer       ip		!o: Pointer to allocated space
      integer       ierr	!o: Error flag: 0=ok, 1=bad
C--
Cbegin


      call gtwrkg ( text, n, 'SHORT', ip, ierr )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="opimir"> OPIMIR  </a>-- Open an input 2d read-only integer*4 image
C  The parameter name is left attached
C
C      alan penny             ral                1990 jan

      subroutine opimir ( name, ipin, nx, ny, def, ierr )

      implicit none
      include 'STARMAN_INC'

      character*(*) name	!i: Name of parameter to hold image name
      integer       ipin	!o: Image pointer
      integer       nx		!o: Image X size
      integer       ny		!o: Image Y size
      logical       def		!i: if true, null reply accepted
      integer       ierr	!o: Error 0=ok, 1=bad, 2=null and acceptable
				!         3=wrong type
C--
      character*6 gtype
Cbegin


      call opimgr ( name, ipin, nx, ny, gtype, def, ierr )
      if ( ST_FAILED ) return
      if ( ierr.eq.0 .and. gtype.ne.'INT' ) then
         call printo ( 'WARNING: Image not integer type' )
         ierr = 3
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="opimrr"> OPIMRR  </a>-- Open an input 2d read-only real image
C  The parameter name is left attached
C
C      alan penny             ral                1990 jan

      subroutine opimrr ( name, ipin, nx, ny, def, ierr )

      implicit none
      include 'STARMAN_INC'

      character*(*) name	!i: Name of parameter to hold image name
      integer       ipin	!o: Image pointer
      integer       nx		!o: Image X size
      integer       ny		!o: Image Y size
      logical       def		!i: if true, null reply accepted
      integer       ierr	!o: Error 0=ok, 1=bad, 2=null and acceptable
				!         3=wrong type
C--
      character*6 gtype
Cbegin


      call opimgr ( name, ipin, nx, ny, gtype, def, ierr )
      if ( ST_FAILED ) return
      if ( ierr.eq.0 .and. gtype.ne.'REAL' ) then
         call printo ( 'WARNING: Image not real type' )
         ierr = 3
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="opimsr"> OPIMSR  </a>-- Open an input 2d read-only integer*2 image
C  The parameter name is left attached
C
C      alan penny             ral                1990 jan

      subroutine opimsr ( name, ipin, nx, ny, def, ierr )

      implicit none
      include 'STARMAN_INC'

      character*(*) name	!i: Name of parameter to hold image name
      integer       ipin	!o: Image pointer
      integer       nx		!o: Image X size
      integer       ny		!o: Image Y size
      logical       def		!i: if true, null reply accepted
      integer       ierr	!o: Error 0=ok, 1=bad, 2=null and acceptable
				!         3=wrong type
C--
      character*6 gtype
Cbegin


      call opimgr ( name, ipin, nx, ny, gtype, def, ierr )
      if ( ST_FAILED ) return
      if ( ierr.eq.0 .and. gtype.ne.'SHORT' ) then
         call printo ( 'WARNING: Image not integer*2 type' )
         ierr = 3
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="opimur"> OPIMUR  </a>-- Open an input 2d read-only unsigned integer*2 image
C  The parameter name is left attached
C
C      alan penny             ral                1990 jan

      subroutine opimur ( name, ipin, nx, ny, def, ierr )

      implicit none
      include 'STARMAN_INC'

      character*(*) name	!i: Name of parameter to hold image name
      integer       ipin	!o: Image pointer
      integer       nx		!o: Image X size
      integer       ny		!o: Image Y size
      logical       def		!i: if true, null reply accepted
      integer       ierr	!o: Error 0=ok, 1=bad, 2=null and acceptable
				!         3= wrong type
C--
      character*6 gtype
Cbegin


      call opimgr ( name, ipin, nx, ny, gtype, def, ierr )
      if ( ST_FAILED ) return
      if ( ierr.eq.0 .and. gtype.ne.'USHORT' ) then
         call printo ( 'WARNING: Image not unsigned integer*2 type' )
         ierr = 3
      endif


      end



CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="opimzr"> OPIMZR  </a>-- Open an input 2d read-only real or integer*2 image
C  The parameter name is left attached
C
C      alan penny             ral                1990 jan

      subroutine opimzr ( name, ipin, nx, ny, gtype, def, ierr )

      implicit none
      include 'STARMAN_INC'

      character*(*) name	!i: Name of parameter to hold image name
      integer       ipin	!o: Image pointer
      integer       nx		!o: Image X size
      integer       ny		!o: Image Y size
      character*(*) gtype	!o: Image type
      logical       def		!i: if true, null reply accepted
      integer       ierr	!o: Error 0=ok, 1=bad, 2=null and acceptable
				!         3=not real or short type
C--
      character*40 text
Cbegin


      call opimgr ( name, ipin, nx, ny, gtype, def, ierr )
      if ( ST_FAILED ) return
      if ( ierr.eq.0 .and.
     +     gtype.ne.'REAL' .and. gtype.ne.'SHORT' ) then
         write ( text, '('' ERROR: Image type is: '',a)') gtype
         call printo ( text )
         call printo ( 'ERROR: Can only use REAL or SHORT images' )
         ierr = 3
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="opim4zr"> OPIM4ZR  </a>-- Open an input 4d read-only real/int/integer*2 image
C  The parameter name is left attached
C
C      alan penny             ral                1990 jan


      subroutine opim4zr ( name, ipin, nx, ny, nz, nt, ndim, gtype,
     +                     def, ierr )

      implicit none
      include 'STARMAN_INC'

      character*(*) name		!i: Name of parameter to get image name
      integer       ipin		!o: Image pointer
      integer       nx			!o: Image X size
      integer       ny			!o: Image Y size
      integer       nz			!o: Image Z size
      integer       nt			!o: Image T size
      integer       ndim		!o: No of dimensions
      character*(*) gtype	        !o: Image type ('REAL'/'INT'/'SHORT')
      logical       def			!i: if true, null reply accepted
      integer       ierr		!o: Error 0=ok, 1=bad, 2=null and acceptable
					!         3=wrong type
C--
      character*40 text
Cbegin


      call opim4gr ( name, ipin, nx, ny, nz, nt, ndim, gtype,
     +                     def, ierr )
      if ( ST_FAILED ) return
      if ( ierr.eq.0 .and. gtype.ne.'REAL' .and.
     +     gtype.ne.'INT' .and. gtype.ne.'SHORT' ) then
         write ( text, '(''ERROR: Image type is: '',a)') gtype
         call printo ( text )
         call printo ( 'ERROR: Can only use REAL, INT or SHORT images' )
         ierr = 3
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="opimzw"> OPIMZW  </a>-- Open an output 2d read-only real or integer*2 image
C  The parameter name is left attached
C
C      alan penny             ral                1990 jan

      subroutine opimzw ( name, gtype, ip, nx, ny, def, ierr )

      implicit none

      character*(*) name		!i: Parameter name for image
      character*(*) gtype 		!i: Image type ('SHORT', 'REAL')
      integer       ip			!o: Pointer to image
      integer	    nx			!i: Image X size
      integer	    ny			!i: Image Y size
      logical	    def			!i: If true, null reply is accepted
      integer	    ierr		!o: Error 0=ok, 1=bad, 2=blank and ok
					!         3=not REAL/SHORT
C--
Cbegin


      if ( gtype.ne.'REAL' .and. gtype.ne.'SHORT' ) then
         ierr = 3
         call printo ( ' ERROR: Programmer error in s/r OPIMZW' )
         call printo ( '        Code needs rewriting: Contact'//
     +                 ' person who wrote the program' )
      else
         call opimgw ( name, gtype, ip, nx, ny, def, ierr )
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="opim4zw"> OPIM4ZW  </a>-- Open an outnput 4d read-only real or integer*2 image
C  The parameter name is left attached
C
C      alan penny             ral                1990 jan

      subroutine opim4zw ( name, gtype, ip, nx, ny, nz,nt,def,ierr)

      implicit none

      character*(*) name		!i: Parameter name for image
      character*(*) gtype 		!i: Image type ('SHORT', 'REAL')
      integer       ip			!o: Pointer to image
      integer	    nx			!i: Image X size
      integer	    ny			!i: Image Y size
      integer	    nz			!i: Image Z size
      integer	    nt			!i: Image T size
      logical	    def			!i: If true, null reply is accepted
      integer	    ierr		!o: Error 0=ok, 1=bad, 2=blank and ok
					!         3=not REAL/SHORT
C--
Cbegin


      if ( gtype.ne.'REAL' .and. gtype.ne.'SHORT' ) then
         ierr = 3
         call printo ( ' ERROR: Programmer error in s/r OPIM4ZW' )
         call printo ( '        Code needs rewriting: Contact'//
     +                 ' person who wrote the program' )
      else
         call opim4gw ( name, gtype, ip, nx, ny, nz, nt,def,ierr)
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="opimiw"> OPIMIW  </a>-- Open an output 2d write-only integer*4 image
C  The parameter name is left attached
C
C    a j penny                 ral                  1988-07-10

      subroutine opimiw ( name, ip, nx, ny, def, ierr )

      implicit none

      character*(*) name		!i: Parameter name for image
      integer       ip			!o: Pointer to image
      integer	    nx			!i: Image X size
      integer	    ny			!i: Image Y size
      logical	    def			!i: If true, null reply is accepted
      integer	    ierr		!o: Error 0=ok, 1=bad, 2=blank and ok
C--
Cbegin


      call opimgw ( name, 'INT', ip, nx, ny, def, ierr )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="opimrw"> OPIMRW  </a>-- Open an output 2d write-only real image
C  The parameter name is left attached
C
C    a j penny                 ral                  1988-07-10

      subroutine opimrw ( name, ip, nx, ny, def, ierr )

      implicit none

      character*(*) name		!i: Parameter name for image
      integer       ip			!o: Pointer to image
      integer	    nx			!i: Image X size
      integer	    ny			!i: Image Y size
      logical	    def			!i: If true, null reply is accepted
      integer	    ierr		!o: Error 0=ok, 1=bad, 2=blank and ok
C--
Cbegin


      call opimgw ( name, 'REAL', ip, nx, ny, def, ierr )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="opimsw"> OPIMSW  </a>-- Open an output 2d write-only integer*2 image
C  The parameter name is left attached
C
C    a j penny                 ral                  1988-07-10

      subroutine opimsw ( name, ip, nx, ny, def, ierr )

      implicit none

      character*(*) name		!i: Parameter name for image
      integer       ip			!o: Pointer to image
      integer	    nx			!i: Image X size
      integer	    ny			!i: Image Y size
      logical	    def			!i: If true, null reply is accepted
      integer	    ierr		!o: Error 0=ok, 1=bad, 2=blank and ok
C--
Cbegin


      call opimgw ( name, 'SHORT', ip, nx, ny, def, ierr )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="opim4iw"> OPIM4IW  </a>-- Open an output 4d write-only integer*4 image
C  The parameter name is left attached
C
C    a j penny                 ral                  1988-07-10

      subroutine opim4iw ( name, ip, nx, ny, nz, nt, def, ierr )

      implicit none

      character*(*) name		!i: Parameter name for image
      integer       ip			!o: Pointer to image
      integer	    nx			!i: Image X size
      integer	    ny			!i: Image Y size
      integer	    nz			!i: Image Z size
      integer	    nt			!i: Image T size
      logical	    def			!i: If true, null reply is accepted
      integer	    ierr		!o: Error 0=ok, 1=bad, 2=blank and ok
C--
Cbegin


      call opim4gw ( name, 'INT', ip, nx, ny, nz, nt, def, ierr )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="opim4rw"> OPIM4RW  </a>-- Open an output 4d write-only real image
C  The parameter name is left attached
C
C    a j penny                 ral                  1988-07-10

      subroutine opim4rw ( name, ip, nx, ny, nz, nt, def, ierr )

      implicit none

      character*(*) name		!i: Parameter name for image
      integer       ip			!o: Pointer to image
      integer	    nx			!i: Image X size
      integer	    ny			!i: Image Y size
      integer	    nz			!i: Image Z size
      integer	    nt			!i: Image T size
      logical	    def			!i: If true, null reply is accepted
      integer	    ierr		!o: Error 0=ok, 1=bad, 2=blank and ok
C--
Cbegin


      call opim4gw ( name, 'REAL', ip, nx, ny, nz, nt, def, ierr )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="opim4sw"> OPIM4SW  </a>-- Open an output 4d write-only integer*2 image
C  The parameter name is left attached
C
C    a j penny                 ral                  1988-07-10

      subroutine opim4sw ( name, ip, nx, ny, nz, nt, def, ierr )

      implicit none

      character*(*) name		!i: Parameter name for image
      integer       ip			!o: Pointer to image
      integer	    nx			!i: Image X size
      integer	    ny			!i: Image Y size
      integer	    nz			!i: Image Z size
      integer	    nt			!i: Image T size
      logical	    def			!i: If true, null reply is accepted
      integer	    ierr		!o: Error 0=ok, 1=bad, 2=blank and ok
C--
Cbegin


      call opim4gw ( name, 'SHORT', ip, nx, ny, nz, nt, def, ierr )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="put1i"> PUT1I  </a>-- Put an integer number to the CL
C
C    a j penny                ral         1988-09-07

      subroutine put1i ( name, ival )

      implicit none

      character*(*)	name		!i: Name of parameter
      integer           ival		!i: Value to load parameter
C--
      integer iv(3)
Cbegin


      iv(1) = ival
      call putgi ( name, 1, iv )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="put2i"> PUT2I  </a>-- Put two integer numbers to the CL
C
C    a j penny                ral         1988-09-07

      subroutine put2i ( name, ival1, ival2 )

      implicit none

      character*(*)	name		!i: Name of parameter
      integer		ival1		!i: 1st value to load parameter
      integer		ival2		!i: 2nd value to load parameter
C--
      integer iv(3)
Cbegin


      iv(1) = ival1
      iv(2) = ival2
      call putgi ( name, 2, iv )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="put3i"> PUT3I  </a>-- Put three integer numbers to the CL
C
C    a j penny                ral         1988-09-07

      subroutine put3i ( name, ival1, ival2, ival3 )

      implicit none

      character*(*)	name		!i: Name of parameter
      integer 		ival1		!i: 1st value to load parameter
      integer		ival2		!i: 2nd value to load parameter
      integer		ival3		!i: 3rd value to load parameter
C--
      integer  iv(3)
Cbegin


      iv(1) = ival1
      iv(2) = ival2
      iv(3) = ival3
      call putgi ( name, 3, iv )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="put1r"> PUT1R  </a>-- Put a real number to the CL
C
C    a j penny                ral         1988-09-07

      subroutine put1r ( name, val )

      implicit none

      character*(*)	name		!i: Name of parameter
      real		val		!i: Value to load parameter
C--
      real  rv(3)
Cbegin


      rv(1) = val
      call putgr ( name, 1, rv )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="put2r"> PUT2R  </a>-- Put two real numbers to the CL
C
C    a j penny                ral         1988-09-07

      subroutine put2r ( name, val1, val2 )

      implicit none

      character*(*)	name		!i: Name of parameter
      real		val1		!i: 1st value to load parameter
      real		val2		!i: 2nd value to load parameter
C--
      real rv(3)
Cbegin


      rv(1) = val1
      rv(2) = val2
      call putgr ( name, 2, rv )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="put3r"> PUT3R  </a>-- Put three real numbers to the CL
C
C    a j penny                ral         1988-09-07

      subroutine put3r ( name, val1, val2, val3 )

      implicit none

      character*(*)	name		!i: Name of parameter
      real		val1		!i: 1st value to load parameter
      real		val2		!i: 2nd value to load parameter
      real		val3		!i: 3rd value to load parameter
C--
      real rv(3)
Cbegin


      rv(1) = val1
      rv(2) = val2
      rv(3) = val3
      call putgr ( name, 3, rv )


      end

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C  This is  STARFLIB_UNIX.F
C
C  Contains UNIX specific routines:-
C
C ABORS         Bitwise Boolean OR of two short vectors
C ACHT(DR:IRS)  Load a (dble:real) array into a (real:int:short) array
C ACHTB(DR:IRS) Load a (dble:real) array into a (RIS) array with magic values
C AMOVZ         Load byte vector with another
C AMOVKZ        Load byte vector with constant
C AZEROZ        Load byte vector with zero
C COPZZ         Copy part of a byte array into an area of a byte array
C MOREHELP      See if more HELP is desired
C XXTIME        Type out a message and the time


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="abors"> ABORS  </a>-- Bitwise Boolean OR of two short vectors
C alan penny            ral                1988-12-29
      subroutine abors ( a, b, c, n )
      implicit none
      include 'STARMAN_INC'
      integer    n	!i: No of values
      integer*2  a(n)	!i: 1st input vector
      integer*2  b(n)	!i: 2nd input vector
      integer*2  c(n)	!o: Output vector
C--
      integer j
Cbegin


      if ( ST_FAILED ) return

      do j = 1, n
         c(j) = ior(a(j),b(j))
      enddo


      end



CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="achtbri"> ACHTBRI  </a>-- Load a real array into an integer array with magic values
C
C   a j penny                    dao	         1988-05-16

      subroutine achtbri ( a, ka, b, kb, n )
      implicit none
      include 'STARMAN_INC'
      include 'ST_LIMITS_INC'
      integer	n	!i: No of points
      real	a(n)	!i: input array
      real      ka	!i: input magic value
      integer	b(n)	!o: output array
      integer   kb	!i: Output magic value
C--
      integer j
Cbegin
      if ( ST_FAILED ) return

      do j = 1, n
         if ( a(j).eq.ka .or. a(j).lt.INT_MINIR .or.
     +        a(j).gt.INT_MAXIR ) then
            b(j) = kb
         else
            b(j) = a(j)
         endif
      enddo

      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="achtbrs"> ACHTBRS  </a>-- Load a real array into a short integer array with magic values
C
C   a j penny                    dao	         1988-05-16

      subroutine achtbrs ( a, ka, b, kb, n )
      implicit none
      include 'STARMAN_INC'
      include 'ST_LIMITS_INC'
      integer	n	!i: No of points
      real	a(n)	!i: input array
      real      ka	!i: Input magic value
      integer*2	b(n)	!o: output array
      integer   kb	!i: Output magica value
C--
      integer j
Cbegin
      if ( ST_FAILED ) return

      do j = 1, n
         if ( a(j).eq.ka .or. a(j).lt.INT_MINSR .or.
     +        a(j).gt.INT_MAXSR ) then
            b(j) = kb
         else
            b(j) = a(j)
         endif
      enddo

      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="achtbdr"> ACHTBDR  </a>-- Load a double precision array into a real array with magic values
C
C   a j penny                    dao	         1988-05-16

      subroutine achtbdr ( a, ka, b, kb, n )
      implicit none
      include 'STARMAN_INC'
      include 'ST_LIMITS_INC'
      integer		n	!i: No of points
      double precision	a(n)	!i: Input array
      double precision  ka	!i: input magic value
      real		b(n)	!o: input array
      real              kb	!i: Output magic value
C--
      integer j
      double precision dkl, dku
Cbegin
      if ( ST_FAILED ) return

      dku = INT_MAXRR
      dkl = INT_MINRR
      do j = 1, n
         if ( a(j).eq.ka .or. a(j).lt.dkl .or. a(j).gt.dku ) then
            b(j) = kb
         else
            b(j) = a(j)
         endif
      enddo

      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="achtbdi"> ACHTBDI  </a>-- Load a double precision array into a integer array with magic values
C
C   a j penny                    dao	         1988-05-16

      subroutine achtbdi ( a, ka, b, kb, n )
      implicit none
      include 'STARMAN_INC'
      include 'ST_LIMITS_INC'
      integer		n	!i: No of points
      double precision	a(n)	!i: Input array
      double precision  ka	!i: input magic value
      integer		b(n)	!o: input array
      integer           kb	!i: Output magic value
C--
      integer j
      double precision dkl, dku
Cbegin
      if ( ST_FAILED ) return

      dkl = INT_MINIR
      dku = INT_MAXIR
      do j = 1, n
         if ( a(j).eq.ka .or. a(j).lt.dkl .or. a(j).gt.dku ) then
            b(j) = kb
         else
            b(j) = a(j)
         endif
      enddo

      end

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="achtbds"> ACHTBDS  </a>-- Load a double precision array into a integer*2 array with magic values
C
C   a j penny                    dao	         1988-05-16

      subroutine achtbds ( a, ka, b, kb, n )
      implicit none
      include 'STARMAN_INC'
      include 'ST_LIMITS_INC'
      integer		n	!i: No of points
      double precision	a(n)	!i: Input array
      double precision  ka	!i: input magic value
      integer*2		b(n)	!o: input array
      integer*2          kb	!i: Output magic value
C--
      integer j
      double precision dkl, dku
Cbegin
      if ( ST_FAILED ) return

      dkl = INT_MINSR
      dku = INT_MAXSR
      do j = 1, n
         if ( a(j).eq.ka .or. a(j).lt.dkl .or. a(j).gt.dku ) then
            b(j) = kb
         else
            b(j) = a(j)
         endif
      enddo

      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="achtri"> ACHTRI  </a>-- Load a real array into an integer array
C
C   a j penny                    dao	         1988-05-16

      subroutine achtri ( a, b, n )
      implicit none
      include 'STARMAN_INC'
      include 'ST_LIMITS_INC'
      integer	n	!i: No of points
      real	a(n)	!i: input array
      integer	b(n)	!o: output array
C--
      integer j
Cbegin
      if ( ST_FAILED ) return

      do j = 1, n
         if ( a(j).gt.INT_MAXIR ) then
            b(j) = INT_MAXII
         elseif ( a(j).lt.INT_MINIR ) then
            b(j) = INT_MINII
         else
            b(j) = a(j)
         endif
      enddo

      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="achtrs"> ACHTRS  </a>-- Load a real array into a short integer array
C
C   a j penny                    dao	         1988-05-16

      subroutine achtrs ( a, b, n )
      implicit none
      include 'STARMAN_INC'
      include 'ST_LIMITS_INC'
      integer	n	!i: No of points
      real	a(n)	!i: input array
      integer*2	b(n)	!o: output array
C--
      integer j
Cbegin
      if ( ST_FAILED ) return

      do j = 1, n
         if ( a(j).gt.INT_MAXSR ) then
            b(j) = INT_MAXSS
         elseif ( a(j).lt.INT_MINSR ) then
            b(j) = INT_MINSS
         else
            b(j) = a(j)
         endif
      enddo

      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="achtdr"> ACHTDR  </a>-- Load a double precision array into a real array
C
C   a j penny                    dao	         1988-05-16

      subroutine achtdr ( a, b, n )
      implicit none
      include 'STARMAN_INC'
      include 'ST_LIMITS_INC'
      integer		n	!i: No of points
      double precision	a(n)	!i: Input array
      real		b(n)	!o: input array
C--
      integer j
      double precision dkl, dku
Cbegin
      if ( ST_FAILED ) return

      dku = INT_MAXRR
      dkl = INT_MINRR
      do j = 1, n
         if ( a(j).gt.dku ) then
            b(j) = INT_MAXRR
         elseif ( a(j).lt.dkl ) then
            b(j) = INT_MINRR
         else
            b(j) = a(j)
         endif
      enddo

      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="achtdi"> ACHTDI  </a>-- Load a double precision array into a integer array
C
C   a j penny                    dao	         1988-05-16

      subroutine achtdi ( a, b, n )
      implicit none
      include 'STARMAN_INC'
      include 'ST_LIMITS_INC'
      integer		n	!i: No of points
      double precision	a(n)	!i: Input array
      integer 		b(n)	!o: input array
C--
      integer j
      double precision dkl, dku
Cbegin
      if ( ST_FAILED ) return

      dkl = INT_MINIR
      dku = INT_MAXIR
      do j = 1, n
         if ( a(j).gt.dku ) then
            b(j) = INT_MAXII
         elseif ( a(j).lt.dkl ) then
            b(j) = INT_MINII
         else
            b(j) = a(j)
         endif
      enddo

      end

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="achtds"> ACHTDS  </a>-- Load a double precision array into a integer*2 array
C
C   a j penny                    dao	         1988-05-16

      subroutine achtds ( a, b, n )
      implicit none
      include 'STARMAN_INC'
      include 'ST_LIMITS_INC'
      integer		n	!i: No of points
      double precision  a(n)	!i: Input array
      integer*2 	b(n)	!o: input array
C--
      integer j
      double precision dkl, dku
Cbegin
      if ( ST_FAILED ) return

      dku = INT_MAXSR
      dkl = INT_MINSR
      do j = 1, n
         if ( a(j).gt.dku ) then
            b(j) = INT_MAXSS
         elseif ( a(j).lt.dkl ) then
            b(j) = INT_MINSS
         else
            b(j) = a(j)
         endif
      enddo

      end



CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="amovz"> AMOVZ  </a>-- Load a byte array into another  B = A
C   a j penny                    dao	         1988-05-16
      subroutine amovz ( a, b, n )
      implicit none
      include 'STARMAN_INC'
      integer	n	!i: No of points
      byte 	a(n)	!i: input array
      byte 	b(n)	!o: output array
C--
      integer j
Cbegin
      if ( ST_FAILED ) return

      do j = 1, n
         b(j) = a(j)
      enddo
      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="amovkz"> AMOVKZ  </a>-- Load a byte constant into a byte array  A = K
C   a j penny                    dao	         1988-05-16
      subroutine amovkz ( k, a, n )
      implicit none
      include 'STARMAN_INC'
      byte 	k 	!i: constant to load
      integer	n	!i: No of points
      byte 	a(n)	!o: Array
C--
      integer j
Cbegin
      if ( ST_FAILED ) return

      do j = 1, n
         a(j) = k
      enddo
      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="azeroz"> AZEROZ  </a>-- Load zero into a byte array  A = 0
C   a j penny                    dao	         1988-05-16
      subroutine azeroz ( a, n )
      implicit none
      include 'STARMAN_INC'
      integer	n	!i: No of points
      byte 	a(n)	!o: Array
C--
      integer j
      byte bzero
      data bzero / 0 /
Cbegin
      if ( ST_FAILED ) return

      do j = 1, n
         a(j) = bzero
      enddo
      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="copzz"> COPZZ  </a>-- Copy part of a byte array into an area of a byte array
C
C    a j penny                ral                 88-08-12

      subroutine copzz ( in, n, m, ixs, ixe, iys, iye, out, n1, m1,
     +                   oxs, oys )

      implicit none
      include 'STARMAN_INC'

      integer	n		!i: X size of input image
      integer	m		!i: Y size of input image
      byte 	in(n,m)		!i: Input image
      integer	ixs     	!i: X start of input area to be copied
      integer	ixe		!i: X end of input area to be copied
      integer	iys     	!i: Y start of input area to be copied
      integer	iye		!i: Y end of input area to be copied
      integer	n1		!i: X size of output image
      integer	m1		!i: Y size of output image
      byte 	out(n1,m1)	!i/o: Output image
      integer	oxs     	!i: X start of output area to be copied into
      integer	oys		!i: Y start of output area to be copied into
C--
      integer i, j, ox, oy
Cbegin


      if ( ST_FAILED ) return

      do j = iys, iye
         do i = ixs, ixe
            if ( i.ge.1 .and. i.le.n .and. j.ge.1 .and. j.le.m ) then
               ox = oxs + i - ixs
               oy = oys + j - iys
               if ( ox.ge.1 .and. ox.le.n1 .and. oy.ge.1 .and.
     +              oy.le.m1 ) out(ox,oy) = in(i,j)
            endif
         enddo
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="morehelp"> MOREHELP  </a>-- See if more HELP is desired
C
C alan penny           RAL            1991 March

      subroutine morehelp ( more )

      implicit none
      include 'STARMAN_INC'

      logical     more		!o: True if more help wanted, false if not
C--
      character*256 text
Cbegin


      if ( ST_FAILED ) return

      write ( 6, '('' '')' )
      write ( 6, '('' Press RETURN to continue ... ''$)' )
      read ( 5, '(a)' ) text
      more = .false.
      if ( text.eq.' ' ) then
         more = .true.
         write ( 6, '('' '')' )
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="xxtime"> XXTIME  </a>-- Type out a message and the time
C
C  alan penny                      ral         1990-07-04

      subroutine xxtime ( text )

      implicit none
      include 'STARMAN_INC'

      character*(*)	text	!i: Message
C--
      integer k, lens
      character xt*8, atext*72
      external lens
Cbegin


      if ( ST_FAILED ) return

      call time ( xt )
      k = min(60,lens(text))
      write ( atext, '(1x,a,'' at '',a8)' ) text(1:k), xt
      call printo ( atext )


      end
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C    This is STARFLIBG.FOR
C
C     Contains:-
C GD_SETUP    Set up defaults before using graphics device
C GD_OPEN     Open graphics device
C GD_CLOSE    Close graphics device
C GD_DOBOX    Clear a graphics plot and make a graph box
C GD_OPTS     Plot points with optional ommitting and numbering
C GD_TEXT     Put a text string at a posn on graphic device
C GD_SETDEV   Set graph device not open
C GD_BBUF     Start plot buffer
C GD_EBUF     End plot buffer
C GD_UPDT     Flush pending commands

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gd_setup"> GD_SETUP  </a>-- Set up defaults before using graphics device
C
C   a j penny                 dao           1988-04-25

      subroutine gd_setup ()

      implicit none
      include 'ST_GRAPH_INC'
      include 'STARMAN_INC'
C--
Cbegin


      if ( ST_FAILED ) return

      GD_DISPOP = .false.


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gd_open"> GD_OPEN  </a>-- Open graphics device
C
C   a j penny                 dao           1988-04-25

      subroutine gd_open ( istat )

      implicit none
      include 'ST_GRAPH_INC'
      include 'STARMAN_INC'

      integer    istat		!o: Error flag (1=ok;0=bad)
C--
      character*50 text
      integer n, k
Cbegin


      if ( ST_FAILED ) return

      istat = 0
      if ( .not.GD_DISPOP ) then
         call printo ( 'Input GKS name of device for graphs'//
     +                 ' (-ask- if dont know)' )
         call get1c ( 'GTYPE', text, 'xwindows', .true. )
         if ( ST_FAILED ) return
         if ( text.eq.'ask' ) text = '?'
         call pgbegin ( 0, text, 1, 1 )
         call pgqinf ( 'STATE', text, n )
         if ( n.eq.6 .and. text(1:6).eq.'CLOSED' ) then
            call printo ( 'ERROR: Cant open graphical display' )
            istat = 1
         else
            call pgask ( .false. )
            call get_job ( 'LINECOL', 'black:white', k, 1, 0, ' ' )
            GD_LINECOL = k
            if ( k.eq.1 ) call pgscr ( 1, 0.0, 0.0, 0.0 )
            if ( k.eq.2 ) call pgscr ( 1, 1.0, 1.0, 1.0 )
            GD_DISPOP = .true.
         endif
      else
         call pgpage
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gd_close"> GD_CLOSE  </a>-- Close graphics device
C
C   a j penny                 dao           1988-04-25

      subroutine gd_close ()

      implicit none
      include 'ST_GRAPH_INC'
      include 'STARMAN_INC'
C--
Cbegin


      if ( ST_FAILED ) return

      if ( GD_DISPOP ) call pgend
      GD_DISPOP = .false.


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gd_dobox"> GD_DOBOX  </a>-- Clear a graphics plot and make a graph box
C
C   a j penny                 dao           1988-04-25

      subroutine gd_dobox ( xs, xe, xt, ys, ye, yt, capt, kj )

      implicit none
      include 'ST_GRAPH_INC'
      include 'STARMAN_INC'

      real		xs	!i: User X start
      real		xe	!i: User X end
      character*(*)	xt	!i: Text for X axis
      real		ys	!i: User Y start
      real		ye	!i: User Y end
      character*(*)	yt	!i: Text for Y axis
      character*(*)     capt    !i: Caption
      integer           kj      !i: 1=X/Y scaled equal;0=scaled indep
C--
Cbegin


      if ( ST_FAILED ) return

      GD_XS = xs
      GD_XE = ye
      GD_YS = ys
      GD_YE = ye

      call pgbbuf
      call pgenv ( xs, xe, ys, ye, kj, 0 )        !Draw axes

      call pgsch ( 1.0 )			 !Draw labels
      call pglabel ( xt, yt, capt )
      call pgebuf


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gd_opts"> GD_OPTS  </a>-- Plot points with optional ommitting and numbering
C
C   a j penny                 dao           1988-04-25

      subroutine gd_opts ( x, y, z, n, doz, dotnum, isymb )

      implicit none
      include 'STARMAN_INC'

      integer	n	!i: no of points
      real	x(n)	!i: X values
      real	y(n)	!i: Y values
      logical	z(n)	!i: Flags as to plot a point
      logical	doz	!i: Use the flags?
      logical	dotnum	!i: Number the points?
      integer	isymb	!i: PGPLOT code for plot symbol (1=small dot)
C--
      integer k
      character*7 text
Cbegin


      if ( ST_FAILED ) return

      call pgbbuf

      if ( .not.doz .and. .not.dotnum ) then
         call pgpoint ( n, x, y, isymb )
      elseif ( doz .and. .not.dotnum ) then
         do k = 1, n
            if ( z(k) ) call pgpoint ( 1, x(k), y(k), isymb )
         enddo
      elseif ( .not.doz .and. dotnum ) then
         call pgpoint ( n, x, y, isymb )
         do k = 1, n
            if ( k.ge.100000) then
               write ( text, '(1x,i6)' ) k
            elseif ( k.ge.10000) then
               write ( text, '(1x,i5)' ) k
            elseif ( k.ge.1000) then
               write ( text, '(1x,i4)' ) k
            elseif ( k.ge.100) then
               write ( text, '(1x,i3)' ) k
            elseif ( k.ge.10) then
               write ( text, '(1x,i2)' ) k
            else
               write ( text, '(1x,i1)' ) k
            endif
            call pgtext ( x(k), y(k), text )
         enddo
      else
         do k = 1, n
            if ( z(k) ) then
               call pgpoint ( 1, x(k), y(k), isymb )
               if ( k.ge.100000) then
                  write ( text, '(1x,i6)' ) k
               elseif ( k.ge.10000) then
                  write ( text, '(1x,i5)' ) k
               elseif ( k.ge.1000) then
                  write ( text, '(1x,i4)' ) k
               elseif ( k.ge.100) then
                  write ( text, '(1x,i3)' ) k
               elseif ( k.ge.10) then
                  write ( text, '(1x,i2)' ) k
               else
                  write ( text, '(1x,i1)' ) k
               endif
               call pgtext ( x(k), y(k), text )
            endif
         enddo
      endif

      call pgebuf


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gd_text"> GD_TEXT  </a>-- Put a text string at a posn on graphic device

C   a j penny                 dao           1988-04-25

      subroutine gd_text ( x, y, text )

      implicit none
      include 'STARMAN_INC'

      real	x		!i: X position
      real	y		!i: Y position
      character*(*) text	!i: Text string
C--
Cbegin


      if ( ST_FAILED ) return

      call pgtext ( x, y, text )
      call pgebuf


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gd_setdev"> GD_SETDEV  </a>-- Set graph device not open
C
C   a j penny                 dao           1988-04-25

      subroutine gd_setdev ()

      implicit none
      include 'ST_GRAPH_INC'
      include 'STARMAN_INC'
C--
Cbegin


      if ( ST_FAILED ) return

      GD_DISPOP = .false.
      GD_BAD = 1


      end

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gd_bbuf"> GD_BBUF  </a>-- Start command buffer
C
C   a j penny                 dao           1988-04-25

      subroutine gd_bbuf ()

      implicit none
      include 'STARMAN_INC'
C--
Cbegin


      if ( ST_FAILED ) return

      call pgbbuf


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gd_ebuf"> GD_EBUF  </a>-- End command buffer
C
C   a j penny                 dao           1988-04-25

      subroutine gd_ebuf ()

      implicit none
      include 'STARMAN_INC'
C--
Cbegin


      if ( ST_FAILED ) return

      call pgebuf


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gd_updt"> GD_UPDT  </a>-- Flush commands
C
C   a j penny                 dao           1988-04-25

      subroutine gd_updt ()

      implicit none
      include 'STARMAN_INC'
C--
Cbegin


      if ( ST_FAILED ) return

      call pgupdt


      end
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C    This is STARFLIBM.FOR
C
C    It contains general array and maths subroutines:-
C
C ADDCOL(IRS)  Add a constant to a column in a (int:real:short) array
C ADIFFR       See if two real arrays are different
C ARRSC        Scale a real array (Out = in*BS + BZ)
C COP(ab)      Copy array part into another array part (to:fm int:int*2:real)
C COPFR(IR)    Copy vertical column of a real 2-D array to (int:real) vector
C COPRR(R)     Copy real array ([scaled]; invalid flags) to real array
C COPSS(IRS)   Copy int*2 array ([scaled]; invalid flags) to int*2:int:real array
C COPT(IR)R    Copy an (int:real) row part into a column of a real 2-D array
C COPV(RS)(IRS)Extract part of a (real:int*2) array to (int*2:integer:real) array
C COP(1R:R1)   Copy a single real value (to:from) a real array location
C COP(1S:S1)   Copy a single short value (to:from) a short array location
C CSWOP(IR)    Swop two integers/reals if second smaller than first
C DETERM       (function) Calc the determinant of a square matrix
C FOURC        Calc Fourier Transform
C FOURN        Calc Fourier Transform in N dimensions
C GASDEV       Make normally (Gauss) distributed random number
C GAUSS1R      Solve for a 1-D (modified) Gaussian for real data
C GAUSS2RA     Fit a 2-D gaussian to a real array and bad pixels
C GAUSS2SA     Fit a 2-D gaussian to an int*2 array and bad pixels
C GAUSS2R      Fit a 2-D Gaussian (fast) to real array with centered star
C GAUSS_CN     Update s/r GAUSS2R estimates and see if converged
C GAUSS_PR     Sets up terms for use in GAUSS2R
C GPROB        Calc prob of a one-tailed Normal (Gauss) distribution
C HGRAM(RS)    Load histogram from values in a real/integer*2 array
C LINFIT       Take set of X,Y points and fits a straight line to them.
C LINFITA      Find mean and slope of a vector (simple and fast)
C LUDECMAT     Decompose matrix by LU decomposition
C LUSOLMAT     Solve a matrix by LU decompsoition
C MANNWHIT     Perform a 1-tailed mann-whitney (Wilcoxon) test to see
C MATINV       Invert a matrix
C MEANSTD(IR)  Calc mean and std deviation of an (integer:real) vector.
C POIDEV       Make a poisson randomised integer output of a real input number
C POLFIT       Least squares fit to data with a polynomial curve,
C PROD(CR/CR)  Sum products of an array row/column with row/column of another
C MEDIAN(RS)   Find median of real:int*2 bad pixel flagged image section
C RANGE(IRS)   Find mean, std dev of int:real:int*2 bad pixeled image section
C RANO         Make random number between 0 and 1.
C RINTER       (function) Interpolate in a two-dimensional look-up table.
C RSSCALE      Scale a real array into an integer*2 array in range
C SIMULX       Solve the simultaneous equations   Y = A.X  for X.
C SMOOTHR      Smooth a real array with a rectangular 'local mean' filter
C SMOOTHB(RS)  Smooth real:int*2 flagged array with rectangular 'local mean' filter
C SORT1(IR)    Sort of an (integer:real) vector
C SORT2(IR)    Sort of an (integer:real) vector, with alignment of another
C SRT1H(IR)    Heapsort to sort (integers:reals) into ascending order
C SRT1P(IR)    Straight insertion sort (ints:reals) to ascending order
C SRT1S(IR)    Shell's method insertion sort (ints:reals) to ascending order
C SRT2H(IR)    Heapsort to sort (integers:reals) with alignment of another
C SRT2P(IR)    Straight insertion sort (ints:reals) with alignment of another
C SRT2S(IR)    Shell's method sort (ints:reals) with alignment of another
C ST_MINMAX    Get max and min of flagged area of array
C ST_MINMAX(RS) Get max and min of flagged area of (real:int*2) array
C TRAN_DOIT    Transfromation between two sets of x,y posns - set up
C TRAN_LINTRAN Transformation between points - calculate



CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="addcoli"> ADDCOLI  </a>-- Adds constant to a column of an integer array
C   a j penny                 ral           1994-09-01
      subroutine addcoli ( a, nx, ny, kcol, k )
      implicit none
      integer   nx		!i: no of columns
      integer   ny		!i: no of rows
      integer   a(nx,ny)	!i/o: 1st input vector
      integer   kcol	 	!i: column to add to
      integer   k 		!i: constant to add
C--
      integer j
Cbegin
      do j = 1, ny
         a(kcol,j) = a(kcol,j) + k
      enddo
      end
C <a name="addcolr"> ADDCOLR  </a>-- Adds constant to a column of a real array
C   a j penny                 ral           1994-09-01
      subroutine addcolr ( a, nx, ny, kcol, k )
      implicit none
      integer   nx		!i: no of columns
      integer   ny		!i: no of rows
      real      a(nx,ny)	!i/o: 1st input vector
      integer   kcol	 	!i: column to add to
      real      k 		!i: constant to add
C--
      integer j
Cbegin
      do j = 1, ny
         a(kcol,j) = a(kcol,j) + k
      enddo
      end
C <a name="addcols"> ADDCOLS  </a>-- Adds constant to a column of a short array
C   a j penny                 ral           1994-09-01
      subroutine addcols ( a, nx, ny, kcol, k )
      implicit none
      integer    nx		!i: no of columns
      integer    ny		!i: no of rows
      integer*2  a(nx,ny)	!i/o: 1st input vector
      integer    kcol	 	!i: column to add to
      integer*2  k 		!i: constant to add
C--
      integer j
Cbegin
      do j = 1, ny
         a(kcol,j) = a(kcol,j) + k
      enddo
      end

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="adiffr"> ADIFFR  </a>-- See if two real arrays are different
C
C   a j penny                    dao	         1988-05-16

      subroutine adiffr ( r1, r2, n, flag )

      implicit none
      include 'STARMAN_INC'

      integer	n	!i: No of points
      real	r1(n)	!i: frst input array
      real	r2(n)	!i: frst input array
      logical	flag	!o: true if diff, false if same
C--
      integer j
Cbegin


      if ( ST_FAILED ) return

      flag = .false.
      j = 0
      do while ( j.lt.n .and. .not.flag )
         j = j + 1
         if ( r1(j).ne.r2(j) ) flag = .true.
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="arrsc"> ARRSC  </a>-- Scale a real array  (Out = in*BS + BZ)
C
C  a j penny                      stsci                   1987-01-25


      subroutine arrsc ( data, nx, ny, bs, bz )

      implicit none
      include 'STARMAN_INC'

      integer nx		!i: X size of array
      integer ny		!i: Y Size of array
      real    data(nx,ny)	!i/o: Array to scale
      real    bs		!i: Scaling factor
      real    bz		!i: Zero factor
C--
      integer j, k
Cbegin


      if ( ST_FAILED ) return

      do k = 1, ny
         do j = 1, nx
            data(j,k) = bs*data(j,k) + bz
         enddo
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="copii"> COPII  </a>-- Copy part of an integer array into an area of an integer array
C
C    a j penny                ral                 88-08-12

      subroutine copii ( in, n, m, ixs, ixe, iys, iye, out, n1, m1,
     +                   oxs, oys )

      implicit none
      include 'STARMAN_INC'

      integer	n		!i: X size of input image
      integer	m		!i: Y size of input image
      integer	in(n,m)		!i: Input image
      integer	ixs     	!i: X start of input area to be copied
      integer	ixe		!i: X end of input area to be copied
      integer	iys     	!i: Y start of input area to be copied
      integer	iye		!i: Y end of input area to be copied
      integer	n1		!i: X size of output image
      integer	m1		!i: Y size of output image
      integer   out(n1,m1)	!i/o: Output image
      integer	oxs     	!i: X start of output area to be copied into
      integer	oys		!i: Y start of output area to be copied into
C--
      integer i, j, ox, oy
Cbegin


      if ( ST_FAILED ) return

      do j = iys, iye
         do i = ixs, ixe
            if ( i.ge.1 .and. i.le.n .and. j.ge.1 .and. j.le.m ) then
               ox = oxs + i - ixs
               oy = oys + j - iys
               if ( ox.ge.1 .and. ox.le.n1 .and. oy.ge.1 .and.
     +              oy.le.m1 ) out(ox,oy) = real(in(i,j))
            endif
         enddo
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="copir"> COPIR  </a>-- Copy part of an integer array into an area of a real array
C
C    a j penny                ral                 88-08-12

      subroutine copir ( in, n, m, ixs, ixe, iys, iye, out, n1, m1,
     +                   oxs, oys )

      implicit none
      include 'STARMAN_INC'

      integer	n		!i: X size of input image
      integer	m		!i: Y size of input image
      integer	in(n,m)		!i: Input image
      integer	ixs     	!i: X start of input area to be copied
      integer	ixe		!i: X end of input area to be copied
      integer	iys     	!i: Y start of input area to be copied
      integer	iye		!i: Y end of input area to be copied
      integer	n1		!i: X size of output image
      integer	m1		!i: Y size of output image
      real	out(n1,m1)	!i/o: Output image
      integer	oxs     	!i: X start of output area to be copied into
      integer	oys		!i: Y start of output area to be copied into
C--
      integer i, j, ox, oy
Cbegin


      if ( ST_FAILED ) return

      do j = iys, iye
         do i = ixs, ixe
            if ( i.ge.1 .and. i.le.n .and. j.ge.1 .and. j.le.m ) then
               ox = oxs + i - ixs
               oy = oys + j - iys
               if ( ox.ge.1 .and. ox.le.n1 .and. oy.ge.1 .and.
     +              oy.le.m1 ) out(ox,oy) = real(in(i,j))
            endif
         enddo
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="coprr"> COPRR  </a>-- Copy part of a real array into an area of a real array
C
C    a j penny                ral                 88-08-12

      subroutine coprr ( in, n, m, ixs, ixe, iys, iye, out, n1, m1,
     +                   oxs, oys )

      implicit none
      include 'STARMAN_INC'

      integer	n		!i: X size of input image
      integer	m		!i: Y size of input image
      real	in(n,m)		!i: Input image
      integer	ixs     	!i: X start of input area to be copied
      integer	ixe		!i: X end of input area to be copied
      integer	iys     	!i: Y start of input area to be copied
      integer	iye		!i: Y end of input area to be copied
      integer	n1		!i: X size of output image
      integer	m1		!i: Y size of output image
      real	out(n1,m1)	!i/o: Output image
      integer	oxs     	!i: X start of output area to be copied into
      integer	oys		!i: Y start of output area to be copied into
C--
      integer i, j, ox, oy
Cbegin


      if ( ST_FAILED ) return

      do j = iys, iye
         do i = ixs, ixe
            if ( i.ge.1 .and. i.le.n .and. j.ge.1 .and. j.le.m ) then
               ox = oxs + i - ixs
               oy = oys + j - iys
               if ( ox.ge.1 .and. ox.le.n1 .and. oy.ge.1 .and.
     +              oy.le.m1 ) out(ox,oy) = in(i,j)
            endif
         enddo
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="coprs"> COPRS  </a>-- Copy part of a real array into an area of a short array
C
C    a j penny                ral                 88-08-12

      subroutine coprs ( in, n, m, ixs, ixe, iys, iye, out, n1, m1,
     +                   oxs, oys )

      implicit none
      include 'STARMAN_INC'

      integer	n		!i: X size of input image
      integer	m		!i: Y size of input image
      real	in(n,m)		!i: Input image
      integer	ixs     	!i: X start of input area to be copied
      integer	ixe		!i: X end of input area to be copied
      integer	iys     	!i: Y start of input area to be copied
      integer	iye		!i: Y end of input area to be copied
      integer	n1		!i: X size of output image
      integer	m1		!i: Y size of output image
      integer*2	out(n1,m1)	!i/o: Output image
      integer	oxs     	!i: X start of output area to be copied into
      integer	oys		!i: Y start of output area to be copied into
C--
      integer i, j, ox, oy
Cbegin


      if ( ST_FAILED ) return

      do j = iys, iye
         do i = ixs, ixe
            if ( i.ge.1 .and. i.le.n .and. j.ge.1 .and. j.le.m ) then
               ox = oxs + i - ixs
               oy = oys + j - iys
               if ( ox.ge.1 .and. ox.le.n1 .and. oy.ge.1 .and.
     +              oy.le.m1 ) out(ox,oy) =
     +                           int(max(-32768.0,min(32767.0,in(i,j))))
            endif
         enddo
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="copsr"> COPSR  </a>-- Copy part of a short array into an area of a real array
C
C    a j penny                ral                 88-08-12

      subroutine copsr ( in, n, m, ixs, ixe, iys, iye, out, n1, m1,
     +                   oxs, oys )

      implicit none
      include 'STARMAN_INC'

      integer	n		!i: X size of input image
      integer	m		!i: Y size of input image
      integer*2	in(n,m)		!i: Input image
      integer	ixs     	!i: X start of input area to be copied
      integer	ixe		!i: X end of input area to be copied
      integer	iys     	!i: Y start of input area to be copied
      integer	iye		!i: Y end of input area to be copied
      integer	n1		!i: X size of output image
      integer	m1		!i: Y size of output image
      real	out(n1,m1)	!i/o: Output image
      integer	oxs     	!i: X start of output area to be copied into
      integer	oys		!i: Y start of output area to be copied into
C--
      integer i, j, ox, oy
Cbegin


      if ( ST_FAILED ) return

      do j = iys, iye
         do i = ixs, ixe
            if ( i.ge.1 .and. i.le.n .and. j.ge.1 .and. j.le.m ) then
               ox = oxs + i - ixs
               oy = oys + j - iys
               if ( ox.ge.1 .and. ox.le.n1 .and. oy.ge.1 .and.
     +              oy.le.m1 ) out(ox,oy) = real(in(i,j))
            endif
         enddo
      enddo


      end



CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="copss"> COPSS  </a>-- Copy part of a short array into an area of a short array
C
C    a j penny                ral                 88-08-12

      subroutine copss ( in, n, m, ixs, ixe, iys, iye, out, n1, m1,
     +                   oxs, oys )

      implicit none
      include 'STARMAN_INC'

      integer	n		!i: X size of input image
      integer	m		!i: Y size of input image
      integer*2	in(n,m)		!i: Input image
      integer	ixs     	!i: X start of input area to be copied
      integer	ixe		!i: X end of input area to be copied
      integer	iys     	!i: Y start of input area to be copied
      integer	iye		!i: Y end of input area to be copied
      integer	n1		!i: X size of output image
      integer	m1		!i: Y size of output image
      integer*2	out(n1,m1)	!i/o: Output image
      integer	oxs     	!i: X start of output area to be copied into
      integer	oys		!i: Y start of output area to be copied into
C--
      integer i, j, ox, oy
Cbegin


      if ( ST_FAILED ) return

      do j = iys, iye
         do i = ixs, ixe
            if ( i.ge.1 .and. i.le.n .and. j.ge.1 .and. j.le.m ) then
               ox = oxs + i - ixs
               oy = oys + j - iys
               if ( ox.ge.1 .and. ox.le.n1 .and. oy.ge.1 .and.
     +              oy.le.m1 ) out(ox,oy) = in(i,j)
            endif
         enddo
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="copfri"> COPFRI  </a>-- Copy vertical column of a real 2-D array to an integer vector
C
C    a j penny                ral                 1990 Jan

      subroutine copfri ( in, nxi, nyi, ix, iy, out, n )

      implicit none
      include 'STARMAN_INC'

      integer	nxi		!i: X size of input array
      integer	nyi		!i: Y size of input array
      real	in(nxi,nyi)	!i: Input array
      integer	ix		!i: X start in input array
      integer	iy		!i: Y start in input array
      integer	out(*)		!o: Output array
      integer	n	     	!i: Length to copy
C--
      integer k
Cbegin


      if ( ST_FAILED ) return

      do k = 1, n
         out(k) = in(ix,k+iy-1)
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="copfrr"> COPFRR  </a>-- Copy vertical column of a real 2-D array to a real vector
C
C    a j penny                ral                 1990 Jan

      subroutine copfrr ( in, nxi, nyi, ix, iy, out, n )

      implicit none
      include 'STARMAN_INC'

      integer	nxi		!i: X size of input array
      integer	nyi		!i: Y size of input array
      real	in(nxi,nyi)	!i: Input array
      integer	ix		!i: X start in input array
      integer	iy		!i: Y start in input array
      real	out(*)		!o: Output array
      integer	n	     	!i: Length to copy
C--
      integer k
Cbegin


      if ( ST_FAILED ) return

      do k = 1, n
         out(k) = in(ix,k+iy-1)
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="copssi"> COPSSI  </a>-- Copy a integer*2 array (with invalid flags) to an integer one.
C  Integer = integer*2. Invalid points replaced with last (in fortran
C  sense ) pixel value, or 0 if it is the first pixel
C
C  Deals with case in an X row where contiguous pixels are invalid coming
C  in either from the left or right edges. In this case, pixels given
C  edge value of previous X row.
C
C     a j penny                  ral          1991 apr

      subroutine copssi ( in, nx, ny, inval, out )

      implicit none
      include 'STARMAN_INC'

      integer	nx		!i: X size of array
      integer	ny		!i: X size of array
      integer*2 in(nx,ny)	!i: Input array
      integer	inval		!i: Input array invalid flag value
      integer	out(nx,ny)	!o: Output array
C--
      integer jx, jy, iv, ilast, iclast, iclaste, kk
Cbegin


      if ( ST_FAILED ) return

      ilast = 0
      iclast = 0
      iclaste = 0
      do jy = 1, ny

         do jx = 1, nx
            iv = in(jx,jy)
            if ( iv.eq.inval ) then
               if ( jx.eq.1 ) then
                  out(jx,jy) = iclast
                  ilast = iclast
               else
                  out(jx,jy) = ilast
               endif
            else
               out(jx,jy) = iv
               ilast = iv
               if ( jx.eq.1 ) iclast = iv
            endif
         enddo

         if ( in(nx,jy).eq.inval ) then
            out(nx,jy) = iclaste
            kk = nx - 1
            do while ( kk.ge.1 )
               if ( in(kk,jy).eq.inval ) then
                  out(kk,jy) = iclaste
                  kk = kk - 1
               else
                  kk = 0
               endif
            enddo
         else
            iclaste = iv
         endif

      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="copssr"> COPSSR  </a>-- Copy a integer*2 array (scaled with invalid flags) to a real one.
C  Real = scale.integer*2 + zero. Invalid points replaced with last (in
C  fortran sense ) pixel value, or 0.0 if it is the first pixel
C
C  Deals with case in an X row where contiguous pixels are invalid coming
C  in either from the left or right edges. In this case, pixels given
C  edge value of previous X row.
C
C     a j penny                  ral          1991 apr

      subroutine copssr ( in, nx, ny, bs, bz, inval, out )

      implicit none
      include 'STARMAN_INC'

      integer	nx		!i: X size of array
      integer	ny		!i: X size of array
      integer*2 in(nx,ny)	!i: Input array
      real	bs		!i: Scale of input array
      real	bz		!i: Zero of invalid array
      integer	inval		!i: Input array invalid flag value
      real	out(nx,ny)	!o: Output array
C--
      real alast, aclast, aclaste, rv
      integer jx, jy, iv, kk
Cbegin


      if ( ST_FAILED ) return

      alast = 0.0
      aclast = 0.0
      aclaste = 0.0
      do jy = 1, ny

         do jx = 1, nx
            iv = in(jx,jy)
            if ( iv.eq.inval ) then
               if ( jx.eq.1 ) then
                  out(jx,jy) = aclast
                  alast = aclast
               else
                  out(jx,jy) = alast
               endif
            else
               rv = real(iv)*bs + bz
               out(jx,jy) = rv
               alast = rv
               if ( jx.eq.1 ) aclast = alast
            endif
         enddo

         if ( in(nx,jy).eq.inval ) then
            out(nx,jy) = aclaste
            kk = nx - 1
            do while ( kk.ge.1 )
               if ( in(kk,jy).eq.inval ) then
                  out(kk,jy) = aclaste
                  kk = kk - 1
               else
                  kk = 0
               endif
            enddo
         else
            aclaste = rv
         endif

      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="coprrr"> COPRRR  </a>-- Copy a real array (scaled with invalid flags) to a real one.
C  Real = scale.real + zero. Invalid points replaced with last (in
C  fortran sense ) pixel value, or 0.0 if it is the first pixel
C
C  Deals with case in an X row where contiguous pixels are invalid coming
C  in either from the left or right edges. In this case, pixels given
C  edge value of previous X row.
C
C     a j penny                  ral          1991 apr

      subroutine coprrr ( in, nx, ny, bs, bz, rinval, out )

      implicit none
      include 'STARMAN_INC'

      integer	nx		!i: X size of array
      integer	ny		!i: X size of array
      real      in(nx,ny)	!i: Input array
      real	bs		!i: Scale of input array
      real	bz		!i: Zero of invalid array
      real      rinval		!i: Input array invalid flag value
      real	out(nx,ny)	!o: Output array
C--
      real alast, aclast, aclaste, rv
      integer jx, jy, kk
Cbegin


      if ( ST_FAILED ) return

      alast = 0.0
      aclast = 0.0
      aclaste = 0.0
      do jy = 1, ny

         do jx = 1, nx
            rv = in(jx,jy)
            if ( rv.eq.rinval ) then
               if ( jx.eq.1 ) then
                  out(jx,jy) = aclast
                  alast = aclast
               else
                  out(jx,jy) = alast
               endif
            else
               rv = rv*bs + bz
               out(jx,jy) = rv
               alast = rv
               if ( jx.eq.1 ) aclast = alast
            endif
         enddo

         if ( in(nx,jy).eq.rinval ) then
            out(nx,jy) = aclaste
            kk = nx - 1
            do while ( kk.ge.1 )
               if ( in(kk,jy).eq.rinval ) then
                  out(kk,jy) = aclaste
                  kk = kk - 1
               else
                  kk = 0
               endif
            enddo
         else
            aclaste = rv
         endif

      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="copsss"> COPSSS  </a>-- Copy a int*2 array to another one, NO scaling, INVAL deal
C   Invalid replaced by 0 (or last actual pixel )
C
C  Deals with case in an X row where contiguous pixels are invalid coming
C  in either from the left or right edges. In this case, pixels given
C  edge value of previous X row.
C
C     a j penny                   ral               1991 apr

      subroutine copsss ( in, nx, ny, inval, out )

      implicit none
      include 'STARMAN_INC'

      integer	nx			!i: X size of arrays
      integer	ny			!i: Y size of arrays
      integer*2	in(nx,ny)		!i: Input array
      integer	inval			!i: Invalid value
      integer*2	out(nx,ny)		!i: Output array
C--
      integer jx, jy, iv, ilast, iclast, iclaste, kk
Cbegin


      if ( ST_FAILED ) return

      ilast = 0
      iclast = 0
      iclaste = 0
      do jy = 1, ny

         do jx = 1, nx
            iv = in(jx,jy)
            if ( iv.eq.inval ) then
               if ( jx.eq.1 ) then
                  out(jx,jy) = iclast
                  ilast = iclast
               else
                  out(jx,jy) = ilast
               endif
            else
               out(jx,jy) = iv
               ilast = iv
               if ( jx.eq.1 ) iclast = iv
            endif
         enddo

         if ( in(nx,jy).eq.inval ) then
            out(nx,jy) = iclaste
            kk = nx - 1
            do while ( kk.ge.1 )
               if ( in(kk,jy).eq.inval ) then
                  out(kk,jy) = iclaste
                  kk = kk - 1
               else
                  kk = 0
               endif
            enddo
         else
            iclaste = iv
         endif

      enddo


      end



CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="coptir"> COPTIR  </a>-- Copy part of a real vector into a vertical part of a real array
C
C    a j penny                ral                 88-08-12

      subroutine coptir ( in, nxi, out, nxo, nyo, oxs, oys )

      implicit none
      include 'STARMAN_INC'

      integer	nxi		!i: X size of input vector
      integer	in(nxi)		!i: Input vector
      integer	nxo		!i: X size of output array
      integer	nyo		!i: Y size of output array
      real	out(nxo,nyo)	!i/o: Output array
      integer	oxs     	!i: X start of output array to be copied into
      integer	oys		!i: Y start of output array to be copied into
C--
      integer i, oy
Cbegin


      if ( ST_FAILED ) return

      if ( oxs.ge.1 .and. oxs.le.nxo ) then
         do i = 1, nxi
            oy = oys + i - 1
            if ( oy.ge.1 .and. oy.le.nyo ) out(oxs,oy) = in(i)
         enddo
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="coptrr"> COPTRR  </a>-- Copy part of a real vector into a vertical part of a real array
C
C    a j penny                ral                 88-08-12

      subroutine coptrr ( in, nxi, out, nxo, nyo, oxs, oys )

      implicit none
      include 'STARMAN_INC'

      integer	nxi		!i: X size of input vector
      real	in(nxi)		!i: Input vector
      integer	nxo		!i: X size of output array
      integer	nyo		!i: Y size of output array
      real	out(nxo,nyo)	!i/o: Output array
      integer	oxs     	!i: X start of output array to be copied into
      integer	oys		!i: Y start of output array to be copied into
C--
      integer i, oy
Cbegin


      if ( ST_FAILED ) return

      if ( oxs.ge.1 .and. oxs.le.nxo ) then
         do i = 1, nxi
            oy = oys + i - 1
            if ( oy.ge.1 .and. oy.le.nyo ) out(oxs,oy) = in(i)
         enddo
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="copr1"> COPR1  </a>-- Copy a single real value from a real array into a value
C
C    a j penny                 oxvad                88-08-14

      subroutine copr1 ( arr, nx, ny, ix, iy, rv )

      implicit none
      include 'STARMAN_INC'

      integer	nx		!i: X size of intput array
      integer	ny		!i: Y size of intput array
      real	arr(nx,ny)	!i: array
      integer	ix		!i: X position in array to get value from
      integer	iy		!i: Y position in array to get value from
      real	rv		!i: Value to put into
C--
Cbegin


      if ( ST_FAILED ) return

      rv = arr(ix,iy)


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="cops1"> COPS1  </a>-- Copy a single short value from a short array into a value
C
C    a j penny                 oxvad                88-08-14

      subroutine cops1 ( iarr, nx, ny, ix, iy, iv )

      implicit none
      include 'STARMAN_INC'

      integer	nx		!i: X size of intput array
      integer	ny		!i: Y size of intput array
      integer*2	iarr(nx,ny)	!i: array
      integer	ix		!i: X position in array to get value from
      integer	iy		!i: Y position in array to get value from
      integer*2	iv		!i: Value to put into
C--
Cbegin


      if ( ST_FAILED ) return

      iv = iarr(ix,iy)


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="cop1r"> COP1R  </a>-- Copy a single real value into a real array
C
C    a j penny                 oxvad                88-08-14

      subroutine cop1r ( rv, arr, nx, ny, ix, iy )

      implicit none
      include 'STARMAN_INC'

      real	rv		!i: Value to put in
      integer	nx		!i: X size of output array
      integer	ny		!i: Y size of output array
      real	arr(nx,ny)	!i/o: output array
      integer	ix		!i: X position in array to put value in
      integer	iy		!i: Y position in array to put value in
C--
Cbegin


      if ( ST_FAILED ) return

      arr(ix,iy) = rv


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="cop1s"> COP1S  </a>-- Copy a single short value into a short array
C
C    a j penny                 oxvad                88-08-14

      subroutine cop1s ( iv, iarr, nx, ny, ix, iy )

      implicit none
      include 'STARMAN_INC'

      integer*2 iv		!i: Value to put in
      integer	nx		!i: X size of output array
      integer	ny		!i: Y size of output array
      integer*2	iarr(nx,ny)	!i/o: output array
      integer	ix		!i: X position in array to put value in
      integer	iy		!i: Y position in array to put value in
C--
Cbegin


      if ( ST_FAILED ) return

      iarr(ix,iy) = iv


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="copvsi"> COPVSI  </a>-- Extract part of an integer*2 array to an integer array.
C  INVALID pixels are copied over. The copying can either add to the input
C  values or replace them. It deals with areas outside of input and output
C  areas.
C
C    a j penny                      stsci                     87-12-30

      subroutine copvsi ( kwhole, n, m, part, no, mo, kxs, kxe, kys,
     +                    kye, inval, ninval, kadd )

      implicit none
      include 'STARMAN_INC'

      integer n			!i: X size of input image
      integer m			!i: Y size of input image
      integer*2 kwhole(n,m)	!i: Input image
      integer no		!i: X size of output image
      integer mo		!i: Y size of output image
      integer part(no,mo)	!i/o: Output image
      integer kxs     		!i: The first column to be stored
      integer kxe     		!i: The last column to be stored
      integer kys     		!i: The first row to be stored
      integer kye     		!i: The last row to be stored.
      integer inval   		!i: The flag value for an INVALID pixel
      integer ninval		!o: The number of INVALID pixels found
      integer kadd	    	!i: The flag for adding (1) into PART
				!   or overwriting (0)
C--
      integer j, ja, k, ka, kv
Cbegin


      if ( ST_FAILED ) return

      ninval = 0
      ka = 1
      do k = kys, kye
         ja = 1
         do j = kxs, kxe
            if ( j.lt.1.or.j.gt.n .or. k.lt.1.or.k.gt.m ) then
               kv = inval
            else
               kv = kwhole(j,k)
            endif
            if ( kv.eq.inval ) then
               ninval = ninval + 1
            endif
            if ( ja.le.no .and. ka.le.mo ) then
               if ( kv.eq.inval ) then
                  part(ka,ka) = inval
               else
                  if ( kadd.eq.0 ) then
                     part(ja,ka) = kv
                  else
                     part(ja,ka) = part(ja,ka) + kv
                  endif
               endif
            endif
            ja = ja + 1
         enddo
         ka = ka + 1
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="copvrr"> COPVRR  </a>-- Extract part of a real array to a real array.
C  INVALID pixels are copied over. The copying can either add to the input
C  values or replace them. It deals with areas outside of input and output
C  areas.
C
C
C    a j penny                      stsci                     87-12-30

      subroutine copvrr ( whole, n, m, part, no, mo, kxs, kxe, kys,
     +                    kye, bs, bz, rinval, ninval, kadd )

      implicit none
      include 'STARMAN_INC'

      integer	n		!i: X size of input image
      integer	m		!i: Y size of input image
      real      whole(n,m)	!i: Input image
      integer	no		!i: X size of output image
      integer	mo		!i: Y size of output image
      real	part(no,mo)	!i/o: Output image
      integer	kxs     	!i: The first column to be stored
      integer   kxe    		!i: The last column to be stored
      integer   kys    		!i: The first row to be stored
      integer	kye     	!i: The last row to be stored.
      real	bs		!i: Image pixel value scale
      real	bz		!i: Image pixel value zero
      real	rinval   	!i: The flag value for an INVALID real pixel
      integer	ninval		!o: The number of INVALID pixels found
      integer	kadd    	!i: The flag for adding (1) into PART
				!   or overwriting (0)
C--
      integer j, ja, k, ka
      real rv
Cbegin


      if ( ST_FAILED ) return

      ninval = 0
      ka = 1
      do k = kys, kye
         ja = 1
         do j = kxs, kxe
            if ( j.lt.1.or.j.gt.n .or. k.lt.1.or.k.gt.m ) then
               rv = rinval
            else
               rv = whole(j,k)
            endif
            if ( rv.eq.rinval ) then
               ninval = ninval + 1
            endif
            if ( ja.le.no .and. ka.le.mo ) then
               if ( rv.eq.rinval ) then
                  part(ja,ka) = rinval
               else
                  if ( kadd.eq.0 ) then
                     part(ja,ka) = bs*rv + bz
                  else
                     part(ja,ka) = part(ja,ka) + bs*rv + bz
                  endif
               endif
            endif
            ja = ja + 1
         enddo
         ka = ka + 1
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="copvsr"> COPVSR  </a>-- Extract part of an integer*2 array to a real array.
C  INVALID pixels are copied over. The copying can either add to the input
C  values or replace them. It deals with areas outside of input and output
C  areas.
C
C
C    a j penny                      stsci                     87-12-30

      subroutine copvsr ( kwhole, n, m, part, no, mo, kxs, kxe, kys,
     +                    kye, bs, bz, inval, rinval, ninval, kadd )

      implicit none
      include 'STARMAN_INC'

      integer	n		!i: X size of input image
      integer	m		!i: Y size of input image
      integer*2	kwhole(n,m)	!i: Input image
      integer	no		!i: X size of output image
      integer	mo		!i: Y size of output image
      real	part(no,mo)	!i/o: Output image
      integer	kxs     	!i: The first column to be stored
      integer   kxe    		!i: The last column to be stored
      integer   kys    		!i: The first row to be stored
      integer	kye     	!i: The last row to be stored.
      real	bs		!i: Image pixel value scale
      real	bz		!i: Image pixel value zero
      integer	inval   	!i: The flag value for a INVALID int*2 pixel
      real	rinval   	!i: The flag value for an INVALID real pixel
      integer	ninval		!o: The number of INVALID pixels found
      integer	kadd    	!i: The flag for adding (1) into PART
				!   or overwriting (0)
C--
      integer j, ja, k, ka, kv
Cbegin


      if ( ST_FAILED ) return

      ninval = 0
      ka = 1
      do k = kys, kye
         ja = 1
         do j = kxs, kxe
            if ( j.lt.1.or.j.gt.n .or. k.lt.1.or.k.gt.m ) then
               kv = inval
            else
               kv = kwhole(j,k)
            endif
            if ( kv.eq.inval ) then
               ninval = ninval + 1
            endif
            if ( ja.le.no.and.ka.le.mo ) then
               if ( kv.eq.inval ) then
                  part(ja,ka) = rinval
               else
                  if ( kadd.eq.0 ) then
                     part(ja,ka) = bs*real(kv) + bz
                  else
                     part(ja,ka) = part(ja,ka) + bs*real(kv) + bz
                  endif
               endif
            endif
            ja = ja + 1
         enddo
         ka = ka + 1
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="copvss"> COPVSS  </a>-- Extract part of an integer*2 array to an integer*2 array.
C  INVALID pixels are copied over. The copying can either add to the input
C  values or replace them. It deals with areas outside of input and output
C  areas.
C
C    a j penny                      stsci                     87-12-30

      subroutine copvss ( kwhole, n, m, part, no, mo, kxs, kxe,
     +                    kys, kye, inval, ninval, kadd )

      implicit none
      include 'STARMAN_INC'

      integer n			!i: X size of input image
      integer m			!i: Y size of input image
      integer*2 kwhole(n,m)	!i: Input image
      integer no		!i: X size of output image
      integer mo		!i: Y size of output image
      integer*2 part(no,mo)	!i/o: Output image
      integer	kxs     	!i: The first column to be stored
      integer   kxe    		!i: The last column to be stored
      integer   kys    		!i: The first row to be stored
      integer	kye     	!i: The last row to be stored.
      integer	inval   	!i: The flag value for an INVALID pixel
      integer	ninval		!o: The number of INVALID pixels found
      integer	kadd    	!i: The flag for adding (1) into PART
				!   or overwriting (0)
C--
      integer j, ja, k, ka, kv
Cbegin


      if ( ST_FAILED ) return

      ninval = 0
      ka = 1
      do k = kys, kye
         ja = 1
         do j = kxs, kxe
            if ( j.lt.1.or.j.gt.n .or. k.lt.1.or.k.gt.m ) then
               kv = inval
            else
               kv = kwhole(j,k)
            endif
            if ( kv.eq.inval ) then
               ninval = ninval + 1
            endif
            if ( ja.le.no .and. ka.le.mo ) then
               if ( kv.eq.inval ) then
                  part(ja,ka) = inval
               else
                  if ( kadd.eq.0 ) then
                     part(ja,ka) = kv
                  else
                     part(ja,ka) = part(ja,ka) + kv
                  endif
               endif
            endif
            ja = ja + 1
         enddo
         ka = ka + 1
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="cswopi"> CSWOPI  </a>-- Swop two integers if second smaller than first
C
C   alan penny                 ral                   1988-12-2

      subroutine cswopi ( ia, ib )

      implicit none
      include 'STARMAN_INC'

      integer    ia      !i/o: 1st number
      integer    ib      !i/o: 2nd number
C--
      integer iv
Cbegin


      if ( ST_FAILED ) return

      if ( ib.lt.ia ) then
         iv = ia
         ia = ib
         ib = iv
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="cswopr"> CSWOPR  </a>-- Swop two reals if second smaller than first
C
C   alan penny                 ral                   1988-12-2

      subroutine cswopr ( a, b )

      implicit none
      include 'STARMAN_INC'

      real      a      !i/o: 1st number
      real      b      !i/o: 2nd number
C--
      real rv
Cbegin


      if ( ST_FAILED ) return

      if ( b.lt.a ) then
         rv = a
         a  = b
         b  = rv
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="determ"> DETERM  </a>-- (function) Calc the determinant of a square matrix
C
C     Destroys the input matrix array
C     Dimension valid for norder up to 10
C
C
C      a j penny             rgo                      83-2-16

      double precision function determ ( array, norder )

      implicit none

      double precision	array(10,10)	!i/o: Matrix
      integer		norder		!i: Order of det (degree of matrix)
C--
      double precision save
      integer i, j, k, k1
Cbegin


      determ = 1.0d0
      do k = 1, norder

C  Interchange columns if diagonal element is zero

         if ( array(k,k).eq.0.0d0 ) then
            j = k
            do while ( array(k,j).eq.0.0d0 .and. j.lt.norder )
               j = j + 1
            enddo
            if ( j.eq.norder ) then
               determ = 0.0d0
               return
            endif
            do i = k, norder
               save = array(i,j)
               array(i,j) = array(i,k)
               array(i,k) = save
            enddo
            determ = -1.0d0*determ
         endif

C   Subtract row k from lower rows to get diagonal matrix

         determ = determ*array(k,k)
         if ( k.lt.norder ) then
            k1 = k + 1
            do i = k1, norder
               do j = k1, norder
                 array(i,j) = array(i,j) -
     +                        array(i,k)*array(k,j)/array(k,k)
               enddo
            enddo
         endif

      enddo



      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="fourc"> FOURC  </a>-- Calc Fourier Transform
C  Takes complex data and calculates its fourier transform
C  The input data is stored as 'DATA(1),DATA(2),DATA(3),DATA(4)..'
C  as 'real part of 1st point, complex part of 1st point, real part
C  of 2nd point, complex part of 2nd point..'. The number of
C  data points must be a power of 2.
C
C     a j penny                 ral                   1990-1-2

      subroutine fourc ( data, nn, isign )

      implicit none

      integer	nn		!i: no of data points (must be power of 2)
      real	data(2*nn)	!i/o: data/fft (both in complex form)
      integer	isign		!i: 1=transform wanted;-1=inverse wanted
C--
      real*8 wr, wi, wpr, wpi, wtemp, theta, dtemp
      integer i, j, m, n, mmax, istep
      real tempr, tempi
Cbegin


      n = 2*nn
      j = 1
      do i = 1, n, 2
         if ( j.gt.i ) then
            tempr     = data(j)
            tempi     = data(j+1)
            data(j)   = data(i)
            data(j+1) = data(i+1)
            data(i)   = tempr
            data(i+1) = tempi
         endif
         m = n/2
         do while ( m.ge.2 .and. j.gt.m )
            j = j - m
            m = m/2
         enddo
         j = j + m
      enddo

      mmax = 2
      do while ( n.gt.mmax )
         istep = 2*mmax
         theta = 6.28318530717959d0/(isign*mmax)
         dtemp =  dsin(0.5d0*theta)
         wpr = -2.0d0*dtemp*dtemp
         wpi = dsin(theta)
         wr = 1.0d0
         wi = 0.0d0
         do m = 1, mmax, 2
            do i = m, n, istep
               j = i + mmax
               tempr = sngl(wr)*data(j)   - sngl(wi)*data(j+1)
               tempi = sngl(wr)*data(j+1) + sngl(wi)*data(j)
               data(j)   = data(i)   - tempr
               data(j+1) = data(i+1) - tempi
               data(i)   = data(i)   + tempr
               data(i+1) = data(i+1) + tempi
            enddo
            wtemp = wr
            wr = wr*wpr - wi*wpi + wr
            wi = wi*wpr + wtemp*wpi + wi
         enddo
         mmax = istep
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="fourn"> FOURN  </a>-- Calc Fourier Transform in N dimensions
C  Does a N-dimensional FFT. Calculates either the FFT, or its inverse
C  times the product of the lengths of all dimensions.
C
C   a j penny                 dao           1988-04-25

      subroutine fourn ( data, nn, ndim, isign )

      implicit none
      include 'STARMAN_INC'

      integer	ndim		!i: no of dimensions
      integer	nn(ndim)	!i: size of each dimension (power of 2)
      real	data(*)		!i/o: data/fft (both in complex form)
      integer	isign		!i: 1=transform wanted;-1=inverse wanted
C--
      real*8 wr, wi, wpr, wpi, wtemp, theta
      integer ntot, idim, n, nrem, nprev, ip1, ip2, ip3, i2rev,
     +        i3rev, i1, i2, i3, ibit, ifp1, ifp2, k1, k2
      real tempr, tempi
Cbegin


      if ( ST_FAILED ) return

      ntot = 1
      do idim = 1, ndim
         ntot = ntot*nn(idim)
      enddo

      nprev = 1
      do idim = 1, ndim

         n = nn(idim)
         nrem = ntot/(n*nprev)
         ip1 = 2*nprev
         ip2 = ip1*n
         ip3 = ip2*nrem
         i2rev = 1
         do i2 = 1, ip2, ip1

            if ( i2.lt.i2rev ) then
               do i1 = i2, i2+ip1-2, 2
                  do i3 = i1, ip3, ip2
                     i3rev = i2rev + i3 - i2
                     tempr = data(i3)
                     tempi = data(i3+1)
                     data(i3) = data(i3rev)
                     data(i3+1) = data(i3rev+1)
                     data(i3rev) = tempr
                     data(i3rev+1) = tempi
                  enddo
               enddo
            endif

            ibit = ip2/2
            do while ( (ibit.ge.ip1) .and. (i2rev.gt.ibit) )
               i2rev = i2rev - ibit
               ibit = ibit/2
            enddo
            i2rev = i2rev + ibit

         enddo

         ifp1 = ip1
         do while ( ifp1.lt.ip2 )
            ifp2 = 2*ifp1
            theta = isign*6.28318530717959d0/(ifp2/ip1)
            wpr = -2.0d0*dsin(0.5d0*theta)**2
            wpi = dsin(theta)
            wr = 1.0d0
            wi = 0.0d0
            do i3 = 1, ifp1, ip1
               do i1 = i3, i3+ip1-2, 2
                  do i2 = i1, ip3, ifp2
                     k1 = i2
                     k2 = k1 + ifp1
                     tempr = sngl(wr)*data(k2) - sngl(wi)*data(k2+1)
                     tempi = sngl(wr)*data(k2+1) + sngl(wi)*data(k2)
                     data(k2) = data(k1) - tempr
                     data(k2+1) = data(k1+1) - tempi
                     data(k1) = data(k1) + tempr
                     data(k1+1) = data(k1+1) + tempi
                  enddo
               enddo
               wtemp = wr
               wr = wr*wpr - wi*wpi + wr
               wi = wi*wpr + wtemp*wpi + wi
            enddo
            ifp1 = ifp2
         enddo

         nprev = n*nprev

      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gasdev"> GASDEV  </a>-- Make normally (Gauss) distributed random number
C   zero mean, unit standard deviation. Uses call to uniform
C   distribution RANO(IDUM).
C
C   a j penny                ral         88-07-04

      subroutine gasdev ( gas, idum )

      implicit none
      include 'STARMAN_INC'

      real      gas             !o:   random number
      integer	idum		!i/o: random number seed
C--
      real rv, r, gset, v1, v2, fac
      integer iset
      data iset / 0 /
Cbegin


      if ( ST_FAILED ) return

      if ( iset.eq.0 ) then
         r = 2.0
         do while ( r.ge.1.0 )
            call rano ( rv, idum )
            v1 = 2.0*rv - 1.0
            call rano ( rv, idum )
            v2 = 2.0*rv - 1.0
            r = v1*v1 + v2*v2
         enddo
         if ( r.gt.1.0e-20 ) then
            fac = sqrt(-2.0*log(r)/r)
            gset = v1*fac
            gas = v2*fac
         else
            gset = 0.0
            gas = 0.0
         endif
         iset = 1
      else
         gas = gset
         iset = 0
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gauss1r"> GAUSS1R  </a>-- Solve for a 1-D (modified) Gaussian for real data
C
C   The data are input as (y,x) pairs of (height,x distance), or
C   just as data, when the x positions are taken as 1,2,3,...
C   Any of the parameters can be fixed.
C
C       EQUATION:
C                                                   P
C                               -1.0*(abs((x-x0)/R))
C                I  =   B + HT*e
C
C  On entry the height must be non-negative, the radius greater than 0.25
C  and the power between 0.1 and 6.0.
C
C  If during the fit, the height, radius or power go beyond those limits,
C  the subroutine stops and the input values are returned, with the base
C  and height set to 0.0.
C
C     a j penny                stsci             1987-01-31

      subroutine gauss1r ( data, dist, nx, isdist, nxa, nxb, b, ht, r,
     +                    p, xo, jf, htlim, ftlim, itlim, damp, iter,
     +                    kprint )

      implicit none
      include 'STARMAN_INC'

      integer	nx		!i: No of points
      real	data(nx)	!i: Data values
      real	dist(nx)	!i: X posns of data
      logical	isdist		!i: if true, DIST => x vals; if not, not
      integer	nxa		!i: Start analyzing data from this pixel
      integer	nxb		!i: End analyzing data at this pixel
      real	b		!i/o: Input/output estimate of base
      real	ht		!i/o: Input/output estimate of height
      real	r		!i/o: Input/output estimate of radius
      real	p		!i/o: Input/output estimate of power
      real	xo		!i/o: Input/output estimate of posn
      integer	jf(5)		!i: jf(n)=0 =>param n fixed; =+1 => var
				!   in order b, ht, r, p, xo
      real	htlim		!i: min fract diff in height to stop (0.001)
      real	ftlim		!i: min fract diff in other pars to stop (0.001)
      integer	itlim		!i: Max no of iterations allowed  (20 normal)
      real	damp		!i: Damping factor in iterations (0.5 normal)
      integer	iter		!o: No of iterations done
      integer   kprint		!i: Progress printinmg flag (0=no;1=yes)
C--
      real cmat(25), cvec(5), rvec(5), cc(5), ccs(5), cclast(5), erf(5),
     +     x, dr, dd, f, z, res, factor, diff, fdiff
      integer j, k, kk, jk, kj, n, npf, npfa, nc
      logical loop, again
      character*80 text
Cbegin


      if ( ST_FAILED ) return

      cc(1) = b								!Set up on entry
      cc(2) = ht								! Translate to CC from outside
      cc(3) = r
      cc(4) = p
      cc(5) = xo

      if ( cc(2).lt.0.0 .or. cc(3).lt.0.25 .or. 			!Do not do if input too strange
     +     cc(4).lt.0.1 .or. cc(4).gt.6.0 ) return

      call asumi ( jf, 5, f )						!No free parameters
      if ( nint(f).eq.0 ) return

      npfa = 5								!Max poss no of free parameters

      call amovr ( cc, ccs, npfa )					!Store input, initial paramters
      call amovr ( cc, cclast, npfa )

      iter = 0								!Start of iteration loop
      loop = .true.
      do while ( loop )

         call azeror ( cmat, npfa*npfa )				!Zero norm eqns
         call azeror ( cvec, npfa  )

         do n = nxa, nxb						!Loop through the data, setting
									! up the simultaenous equations
            x = n - cc(5)
            if ( isdist ) x = dist(n) - cc(5)
            if ( abs(x).lt.1.0e-6) x = sign(1.0e-6,x)
            dr = abs(min((x/cc(3)),1.0e8))
            dd = min(max(dr**cc(4),1.0e-6),1.0e6)
            f = exp(-1.0*dd)

            npf = 0
            if ( jf(1).eq.1 ) then
               npf = npf + 1
               erf(npf) = 1.0						!di/db
            endif
            if ( jf(2).eq.1 ) then
               npf = npf + 1
               erf(npf) = f						!di/dht
            endif
            if ( jf(3).eq.1 ) then
               npf = npf + 1
               erf(npf) = cc(4)*cc(2)*f*dd/cc(3)			!di/dr
            endif
            if ( jf(4).eq.1 ) then
               npf = npf + 1
               erf(npf) = -1.0*cc(2)*f*dd*alog(dr)			!di/dp
            endif
            if ( jf(5).eq.1 ) then
               npf = npf + 1
               erf(npf) = cc(4)*cc(2)*f*dd/x				!di/dxo
            endif

            z = cc(1) + cc(2)*f						!height of fit here

            res = data(n) - z						!residual from data
            if ( abs(res).lt.1e-30 ) res = 0.0

            if ( npf.ge.1 ) then					!Accumulate vector and matrix
               do k = 1, npf						! contributions at this pixel
                  if ( abs(erf(k)).lt.1.0e-5 ) erf(k) = 0.0
               enddo
               do k = 1, npf
                  cvec(k) = cvec(k) + erf(k)*res
                  do j = k, npf
                     jk =  (k-1)*npf + j
                     cmat(jk) = cmat(jk) + erf(j)*erf(k)
                  enddo
               enddo
            endif

         enddo

         if ( npf.gt.1 ) then
            do k = 2, npf						!Complete matrix
               do j = 1, k-1
                  jk = (k-1)*npf + j
                  kj = (j-1)*npf + k
                  cmat(jk) = cmat(kj)
               enddo
            enddo
         endif

         factor = 1.0 + damp*damp					!Apply damping factor
         do k = 1, npf
            kk = (k-1)*npf + k
            cmat(kk) = cmat(kk)*factor
         enddo

         call simulx ( cvec, cmat, rvec, npf )				!Solve the normal equations

         nc = 0								!Update the solution. check
         do k = 1, npfa							! for radius, power, posn
            if ( jf(k).eq.1 ) then					! changing too rapidly
               nc = nc + 1
               if ( k.eq.3 .or. k.eq.4 .or. k.eq.5 ) then
                  diff = rvec(nc)/cc(k)
                  if ( abs(diff).gt.0.1 ) rvec(nc) =
     +                                    sign((0.1*cc(k)),rvec(nc))
               endif
               cc(k) = cc(k) + rvec(nc)
            endif
         enddo
         cc(3) = abs(cc(3))

         again = .false.						!Compare new parameters with the old ones.
         do k = 1, npfa
            if ( abs(cclast(k)-cc(k)).gt.1.0e-6 ) then
               if ( abs(cclast(k)).lt.1.0e-10 ) cclast(k) =
     +                                       sign(1.0e-10,cclast(k))
               diff = min(abs(cc(k)-cclast(k)),1.0e10)
               fdiff = diff/cclast(k)
               if ( k.eq.2 .and. fdiff.gt.htlim   ) again = .true.
               if ( k.ne.2 .and. fdiff.gt.ftlim   ) again = .true.
               cclast(k) = cc(k)
            endif
         enddo

         if ( cc(2).lt.0.0 .or. cc(3).lt.0.25 .or. 			!Fit too strange?
     +        cc(4).lt.0.1 .or. cc(4).gt.30.0 ) again = .false.

         iter = iter + 1

         if ( kprint.eq.1 ) then					!Print out progress?
            write ( text, '(''  Iter '',i5, ''  Base '', g12.2,
     +                      '' Ht '',g12.2, '' Rad '',g12.3)' )
     +                      iter, cc(1), cc(2), cc(3)
            call printo ( text )
            write ( text, '(12x, ''  Pow '',g12.3, '' Posn '',g12.3)' )
     +                     cc(4), cc(5)
            call printo ( text )
         endif

         if ( .not.again .or. iter.ge.itlim ) loop = .false.		!Loop again unless settled, or
									! bad profile, or too many loops
      enddo

      if ( cc(2).lt.0.0 .or. cc(3).lt.0.25 .or. 			!Reset result if fit too strange
     +        cc(4).lt.0.1 .or. cc(4).gt.30.0 ) then
         cc(1) = 0.0
         cc(2) = 0.0
         cc(3) = r
         cc(4) = p
         cc(5) = xo
      endif

      b  = cc(1)							!Translate back from CC to outside
      ht = cc(2)
      r  = cc(3)
      p  = cc(4)
      xo = cc(5)


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gauss2ra"> GAUSS2RA  </a>-- Fit a 2-D gaussian to a real array and bad pixels
C  This takes a sub-area from an array, and fits a single
C  gaussian to the data, assuming a single star at the centre of
C  the sub-area.
C  It deals with bad pixels by assuming that they have the value
C  of the neighbouring one. Maximum size of sub-area is 100x100.
C
C          The profile fitted is :-
C
C                                    2
C                                -1.d
C                   I  = HEIGHT.e      + BASE
C
C          where d = sqrt(((x-XO)/RX)**2+((y-YO)/RY)**2)
C
C It assumes a single star near the centre and either using fixed
C orthogonal radii, or floating ones with a first estimate of
C boxsize/6, the s/r fits the data by means of an iterative
C linearised fully 2-d approximation method using least squares.
C
C      The Output mag is = 30 - 2.5*log  (HEIGHT.RX.RY)
C                                      10
C
C      But in the event of failure it is set to:-
C                 50   Fitted height less than 0.00001
C                 60   Star too near edge (all of box must be in image)
C                 61   Box size greater than 70
C                 70   No valid pixels in box
C
C
C   alan penny                        ral          1990-05-22

      subroutine gauss2ra ( pt, kx, ky, ax, ay, nx, ny, kw, orix,
     +                      oriy, rinval, itlim, amag, height, base,
     +                      dxo, dyo, anx, any, rx, ry, rms, iter,
     +                      ninval )

      implicit none
      include 'STARMAN_INC'

      integer   kx		!i: X length of the image
      integer   ky		!i: Y length of image
      real      pt(kx,ky)	!i: The input image
      real      ax		!i: X position of star in image
      real      ay		!i: Y position of star in image
      integer   nx		!i: X size of box round star
      integer   ny		!i: Y size of box round star
      integer   kw		!i: Flag- radii fixed/to be found (1/0)
      real      orix		!i: Value of X radius (if fixed to be used)
      real      oriy		!i: Value of Y radius (if fixed to be used)
      real      rinval		!i: Flag value of a pixel if Invalid
      integer   itlim		!i: Limit of no of iterations to try
      real      amag		!o: Output magnitude (may be false if failed)
      real	height		!o: Fitted Gaussian height
      real	base		!o: Fitted Gaussian base
      real	dxo		!o: X diff of fitted posn from input posn
      real	dyo		!o: Y diff of fitted posn from input posn
      real	anx		!o: X fitted position
      real	any		!o: Y fitted position
      real	rx		!o: X fitted radius (=input if fixed)
      real	ry		!o: Y fitted radius (=input if fixed)
      real	rms		!o: RMS error between fit and data in box
      integer   iter		!o: No of iterations done
      integer   ninval		!o: No of Invalid pixels in box
C--
      real data(100*100), xo, yo, rlast, rd
      integer jx, jy, js, je, ks, ke, j, ja, jj, k, ka
      logical found
Cbegin


      if ( ST_FAILED ) return

      jx = int(ax)							!Get x,y coord at star
      jy = int(ay)

      amag = 0.0							!Set up default output values
      height = 0.001
      base = 0.001
      dxo = 0.0
      dyo = 0.0
      anx = ax
      any = ay
      rms = 0.0
      iter = 20
      ninval = 0

      js = jx - nx/2							!Check if box lies totally in image
      je = js + nx - 1
      ks = jy - ny/2
      ke = ks + ny - 1
      if ( js.lt.1 .or. je.gt.kx .or. ks.lt.1 .or. ke.gt.ky ) then
         amag = 60.0							!Return if not
         return
      endif

      if ( nx.lt.2 .or. nx.gt.100 .or. ny.lt.2 .or. ny.gt.100 ) then	!Check if box size ok
         amag = 61.0							!Return if not
         return
      endif

									!Extract data.
									!If any Invalid pixels, set to pixel before

      js = js - 1							!Find first valid value
      ks = ks - 1
      found = .false.
      do k = 1, ny
         ka = ks + k
         do j = 1, nx
            ja = js + j
            rd = pt(ja,ka)
            if ( .not.found .and. rd.ne.rinval ) then
               rlast = rd
               found = .true.
            endif
         enddo
      enddo
      if ( .not.found ) then
         amag = 70.0
         return
      endif

      ninval = 0							!Move data over to real
      do k = 1, ny							!Replacing bad points
         ka = ks + k
         jj = (k-1)*nx
         do j = 1, nx
            ja = js + j
            rd = pt(ja,ka)
            if ( rd.eq.rinval ) then
               rd = rlast
               ninval = ninval + 1
            endif
            rlast = rd
            data(jj+j) = rd
         enddo
      enddo

      call gauss2r ( data, nx, ny, kw, orix, oriy, itlim, amag,		!Solve for Gaussian
     +               height, base, xo, yo, rx, ry, rms, iter )

      anx = xo + js 							!Calc position in main image
      any = yo + ks
      dxo = anx - ax
      dyo = any - ay


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gauss2sa"> GAUSS2SA  </a>-- Fit a 2-D gaussian to an int*2 array and bad pixels
C  This takes a sub-area from an array, and fits a single
C  gaussian to the data, assuming a single star at the centre of
C  the sub-area.
C  It deals with bad pixels by assuming that they have the value
C  of the neighbouring one. Maximum size of sub-area is 100x100.
C
C          The profile fitted is :-
C
C                                    2
C                                -1.d
C                   I  = HEIGHT.e      + BASE
C
C          where d = sqrt(((x-XO)/RX)**2+((y-YO)/RY)**2)
C
C It assumes a single star near the centre and either using fixed
C orthogonal radii, or floating ones with a first estimate of
C boxsize/6, the s/r fits the data by means of an iterative
C linearised fully 2-d approximation method using least squares.
C
C      The Output mag is = 30 - 2.5*log  (HEIGHT.RX.RY)
C                                      10
C
C      But in the event of failure it is set to:-
C                 50   Fitted height less than 0.00001
C                 60   Star too near edge (all of box must be in image)
C                 61   Box size greater than 70
C                 70   No valid pixels in box
C
C
C   alan penny                        ral          1990-05-22

      subroutine gauss2sa ( kpt, kx, ky, ax, ay, nx, ny, kw, orix,
     +                      oriy, inval, itlim, amag, height, base,
     +                      dxo, dyo, anx, any, rx, ry, rms, iter,
     +                      ninval )

      implicit none
      include 'STARMAN_INC'

      integer   kx		!i: X length of the image
      integer   ky		!i: Y length of image
      integer*2 kpt(kx,ky)	!i: The input image
      real      ax		!i: X position of star in image
      real      ay		!i: Y position of star in image
      integer   nx		!i: X size of box round star
      integer   ny		!i: Y size of box round star
      integer   kw		!i: Flag- radii fixed/to be found (1/0)
      real      orix		!i: Value of X radius (if fixed to be used)
      real      oriy		!i: Value of Y radius (if fixed to be used)
      integer   inval		!i: Flag value of a pixel if Invalid
      integer   itlim		!i: Limit of no of iterations to try
      real      amag		!o: Output magnitude (may be false if failed)
      real	height		!o: Fitted Gaussian height
      real	base		!o: Fitted Gaussian base
      real	dxo		!o: X diff of fitted posn from input posn
      real	dyo		!o: Y diff of fitted posn from input posn
      real	anx		!o: X fitted position
      real	any		!o: Y fitted position
      real	rx		!o: X fitted radius (=input if fixed)
      real	ry		!o: Y fitted radius (=input if fixed)
      real	rms		!o: RMS error between fit and data in box
      integer   iter		!o: No of iterations done
      integer   ninval		!o: No of Invalid pixels in box
C--
      real data(100*100), xo, yo
      integer jx, jy, js, je, ks, ke, j, ja, jj, k, ka, kd, last
      logical found
Cbegin


      if ( ST_FAILED ) return

      jx = int(ax)							!Get x,y coord at star
      jy = int(ay)

      amag = 0.0							!Set up default output values
      height = 0.001
      base = 0.001
      dxo = 0.0
      dyo = 0.0
      anx = ax
      any = ay
      rms = 0.0
      iter = 20
      ninval = 0

      js = jx - nx/2							!Check if box lies totally in image
      je = js + nx - 1
      ks = jy - ny/2
      ke = ks + ny - 1
      if ( js.lt.1 .or. je.gt.kx .or. ks.lt.1 .or. ke.gt.ky ) then
         amag = 60.0							!Return if not
         return
      endif

      if ( nx.lt.2 .or. nx.gt.100 .or. ny.lt.2 .or. ny.gt.100 ) then	!Check if box size ok
         amag = 61.0							!Return if not
         return
      endif

									!Extract data.
									!If any Invalid pixels, set to pixel before

      js = js - 1							!Find first valid value
      ks = ks - 1
      found = .false.
      do k = 1, ny
         ka = ks + k
         do j = 1, nx
            ja = js + j
            kd = kpt(ja,ka)
            if ( .not.found .and. kd.ne.inval ) then
               last = kd
               found = .true.
            endif
         enddo
      enddo
      if ( .not.found ) then
         amag = 70.0
         return
      endif

      ninval = 0							!Move data over to real
      do k = 1, ny							!Replacing bad points
         ka = ks + k
         jj = (k-1)*nx
         do j = 1, nx
            ja = js + j
            kd = kpt(ja,ka)
            if ( kd.eq.inval ) then
               kd = last
               ninval = ninval + 1
            endif
            last = kd
            data(jj+j) = kd
         enddo
      enddo

      call gauss2r ( data, nx, ny, kw, orix, oriy, itlim, amag,		!Solve for Gaussian
     +               height, base, xo, yo, rx, ry, rms, iter )

      anx = xo + js 							!Calc position in main image
      any = yo + ks
      dxo = anx - ax
      dyo = any - ay


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gauss2r"> GAUSS2R  </a>-- Fit a 2-D Gaussian (fast) to real array with centered star
C It assumes a single star near the centre of the data and either using
C fixed orthogonal radii, or floating ones with a first estimate of
C boxsize/6.0, the s/r fits the data by means of an iterative linearised
C fully 2-d approximation method using least squares.
C
C          The profile fitted is :-
C
C                                2
C                            -1.d
C                I = HEIGHT.e     + BASE
C
C          where d = sqrt(((x-XO)/RX)**2+((y-YO)/RY)**2)
C
C
C          Maximum size of array = 100
C
C
C      The Output mag is = 30 - 2.5*log  (HEIGHT.RX.RY)
C                                      10
C
C      But in the event of failure it is set to:-
C                MAG        Reason
C                 50   Fitted height less than 0.00001
C
C  alan penny                ral             1990-05-22

      subroutine gauss2r ( apt, nx, ny, kw, orix, oriy, itlim, amag,
     +                     height, base, xo, yo, rx, ry, rms, iter )

      implicit none
      include 'STARMAN_INC'

      integer	nx		!i: X size of the array
      integer	ny		!i: Y size of the array
      real	apt(nx,ny)	!i: Data array
      integer	kw		!i: Flag for radii (1=fixed;0=variable)
      real	orix		!i: Value of X radius (if fixed to be used)
      real	oriy		!i: Value of Y radius (if fixed to be used)
      integer	itlim		!i: Max no of iterations to do
      real	amag		!o: Output magnitude (may be false if failed)
      real	height		!o: Fitted Gaussian height
      real	base		!o: Fitted Gaussian base
      real	xo		!o: X fitted position
      real	yo		!o: Y fitted position
      real	rx		!o: X fitted radius (=input if fixed)
      real	ry		!o: Y fitted radius (=input if fixed)
      real	rms		!o: RMS error between fit and data in box
      integer	iter		!o: No of iterations done
C--
      real ise(6), isf(6), isg(6)
      data ise/6,1,2,4,3,5/,isf/4,1,2,1,3,1/,isg/4,1,1,2,1,3/
      equivalence ( d(1,1), dd(1) )

      real s(7), d(6,6), dd(36), e(6), xe(6), f(100,4), g(100,4), ra(3),
     +     rb(3), sf(4,4), sg(4,4), pr, sp, a, b
      integer ne, nf, ng, itera, j, k, jk, ks, kst, ksu, ksv, ksx
Cbegin


      if ( ST_FAILED ) return

      if ( nx.gt.100 .or. ny.gt.100 ) then				!Check size
         call printo ( 'ERROR: Array too large for s/r GAUSS2R' )
         return
      endif

      xo = real(nx)/2.0 + 0.5						!Assume star is at centre of data
      yo = real(ny)/2.0 + 0.5

      if ( kw.eq.0 ) then						!Set to fixed or floating radii
         ne = 6
         nf = 3
         ng = 3
         rx = real(nx)/6.0
         ry = real(ny)/6.0
      else
         ne = 4
         nf = 2
         ng = 2
         rx = orix
         ry = oriy
      endif

      amag = 0.0							!Set up default output values
      height = 0.001
      base = 0.001
      rms = 0.0

      call asumr ( apt, nx*ny, sp )					!Get sum of data

      itera = 0								!Iterate until solved or too many iterations
      iter = 0
      do while ( iter.lt.itlim .and. itera.eq.0 )

         call gauss_pr ( nx, rx, xo, f, sf, ra, nf )			!Set up the simultaneous equations
         call gauss_pr ( ny, ry, yo, g, sg, rb, ng )
         s(6) = sp
         do j = 1, nx
            call prodcr ( apt, nx, ny, j, g, 100, 4, 1, 1, ny, pr )
            f(j,4) = pr
         enddo
         do j = 1, ny
            call prodrr ( apt, nx, ny, j, f, 100, 4, 1, 1, nx, pr )
            g(j,4) = pr
         enddo
         do j = 1, nf
            call prodrr ( f, 100, 4, 4, f, 100, 4, j, 1, nx, pr )
            s(j) = ra(j)*pr
         enddo
         do j = 2, ng
            call prodrr ( g, 100, 4, 4, g, 100, 4, j, 1, ny, pr )
            s(j+2) = rb(j)*pr
         enddo
         do k = 1, ne
            do j = k, ne
               ks =  isf(k)
               kst = isf(j)
               ksu = isg(k)
               ksv = isg(j)
               d(j,k) = sf(ks,kst)*sg(ksu,ksv)
               d(k,j) = d(j,k)
            enddo
            ksx = ise(k)
            e(k) = s(ksx)
         enddo
         if ( kw.eq.1 ) then
            do k = 2, ne
               jk = (k-1)*ne
               do j = 1, ne
                  dd(jk+j) = d(j,k)
               enddo
            enddo
         endif

         call simulx ( e, d, xe, ne )					!Solve the simultaneous equations

         call gauss_cn ( xe, a, b, xo, yo, rx, ry, itera, nx, ny, kw )	!Update the estimates as a result of this iteration and
									! decide if converged
         iter = iter + 1
      enddo

      rms = 0.0								!Calc the RMS
      do k = 1, ny
         do j = 1, nx
            rms = rms + abs(apt(j,k)-(a*f(j,1)*g(k,1)+b))**2.0
         enddo
      enddo
      rms = sqrt(rms/real(nx*ny-1))

      amag = 50.0							!Calc the magnitude
      if ( a.gt.1.0e-5 ) amag = 30.0 - 2.5*alog10(a*rx*ry)
      height = a
      base = b

      if ( a.le.1.0e-5 .or. rx.gt.500.0 .or. ry.gt.500.0 ) then		!Check for bad fit
         if ( kw.eq.0 ) then
            rx = 0.0
            ry = 0.0
         endif
         base = 0.0
         height = 0.0
         rms = 0.0
         amag = 50.0
         xo = real(nx)/2.0 + 0.5
         yo = real(ny)/2.0 + 0.5
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gauss_cn"> GAUSS_CN  </a>-- Update Gauss estimates and see if converged
C  It makes new estimates of the height and base and corrects the
C  position and radii. Does not allow centre to go too near edge.
C
C  alan penny                ral                      1990-05-22

      subroutine gauss_cn ( e, a, b, xo, yo, rx, ry, itera, nx, ny, kw )

      implicit none
      include 'STARMAN_INC'

      real	e(6)		!i: Update factors
      real	a		!o: Gaussian height
      real	b		!o: Gaussian base
      real	xo		!i/o: X posn of Gauss centre
      real	yo		!i/o: Y posn of Gauss centre
      real	rx		!i/o: X Gauss radius
      real	ry		!i/o: Y Gauss radius
      integer	itera		!o: Convergence flag (no=0;yes=1)
      integer   nx		!i: Array X size
      integer   ny		!i: Array Y size
      integer   kw		!i: Flag for keeping radii fixed/var (1/0)
C--
      real rxo, ryo, hrx, hry, dx, dy, drx, dry
Cbegin


      if ( ST_FAILED ) return

      rxo = abs(rx)
      ryo = abs(ry)
      hrx = rxo/2.0
      hry = ryo/2.0
      a = e(2)
      if ( abs(a).lt.1.0e-6 ) a = sign(1.0e-6,a)
      dx = e(3)/a
      dy = e(4)/a
      drx = 0.0
      dry = 0.0
      if ( a.gt.0.0 ) then
         if ( kw.eq.0 ) drx = e(5)/a
         if ( kw.eq.0 ) dry = e(6)/a
      else
         dx = -1.0*dx
         dy = -1.0*dy
      endif
      b = e(1)

      if ( abs(dx).gt.hrx ) dx = sign(hrx,dx)
      if ( abs(dy).gt.hry ) dy = sign(hry,dy)
      xo = xo + dx
      xo = max(3.0,xo)
      xo = min(real(nx-2),xo)
      yo = yo + dy
      yo = max(3.0,yo)
      yo = min(real(ny-2),yo)
      rx = rxo + drx
      ry = ryo + dry
      rx = max(0.3,rx)
      ry = max(0.3,ry)

      itera = 1
      if ( abs(dx).gt.0.1 .or. abs(dy).gt.0.1 .or. abs(drx).gt.0.005
     +   .or. abs(dry).gt.0.005 ) itera = 0


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gauss_pr"> GAUSS_PR  </a>-- Sets up terms for use in GAUSS2(R)
C
C  alan penny                   ral                  1990-05-022

      subroutine gauss_pr ( n, r, xo, f, sf, ra, nf )

      implicit none
      include 'STARMAN_INC'

      integer   n		!i: No of points wanted
      real	r		!i: Gaussian radius
      real	xo		!i: Posn of Gaussian centre
      real      f(100,4)	!o:
      real      sf(4,4)		!o:
      real      ra(3)		!o:
      integer	nf		!i: Flag (fixed radii=2;variable=3)
C--
      real rr, z, zr, w, xj, s
      integer j, k
Cbegin


      if ( ST_FAILED ) return

      if ( n.gt.100 ) then
          call printo ( 'ERROR: Array too large in GAUSS_PR' )
          return
      endif

      rr = 1.0/r
      ra(1) = 1.0
      ra(2) = 2.0*rr*rr
      ra(3) = ra(2)*rr

      do j = 1, n
         xj = j
         z = xj - xo
         zr = z*rr
         w = 0.0
         if ( abs(zr).lt.6.0 ) w = exp(-1.0*zr*zr)
         f(j,1) = w
         w = z*w
         f(j,2) = w
         f(j,3) = z*w
      enddo

      do k = 1, nf
         do j = k, nf
            call prodrr ( f, 100, 4, k, f, 100, 4, j, 1, n, s )
            sf(k,j) = s*ra(k)*ra(j)
            sf(j,k) = sf(k,j)
         enddo
         call asumr ( f(1,k), n, s )
         sf(4,k) = s*ra(k)
         sf(k,4) = s*ra(k)
      enddo

      sf(4,4) = n

      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="gprob"> GPROB  </a>-- Calc prob of a one-tailed Normal (Gauss) distribution
C             If input value >4.3; prob = 0.0
C             If input value <1.28 prob = 0.1003
C             In between, a good approximation
C
C   a j penny                 dao           1988-04-25

      subroutine gprob ( rv, prob )

      implicit none
      include 'STARMAN_INC'

      real	rv		!i: Value
      real	prob		!o: Probability
C--
      real av
      integer j, kv
      real cubintx
      external cubintx

      real	f(17), g(176)
      data	f / .0025600, .0018658, .0013499, .0009676, .0006871,
     +              .0004834, .0003369, .0002326, .0001591, .0001078,
     +              .0000723, .0000481, .0000317, .0000207, .0000133,
     +              .000082,  .000055 /
      data (g(j),j=1,60)/ .1038, .1020, .1003, .0985, .0968, .0951,
     +              .0934, .0918, .0901, .0885, .0869, .0853,
     +              .0838, .0823, .0808, .0793, .0778, .0764,
     +              .0749, .0735, .0721, .0708, .0694, .0681,
     +              .0668, .0655, .0643, .0630, .0618, .0606,
     +              .0594, .0582, .0571, .0559, .0548, .0537,
     +              .0526, .0516, .0505, .0495, .0485, .0475,
     +              .0465, .0455, .0446, .0436, .0427, .0418,
     +              .0409, .0401, .0392, .0384, .0375, .0367,
     +              .0359, .0351, .0344, .0336, .0329, .0322 /
      data (g(j),j=61,74)/ .0314, .0307, .0301, .0294, .0287, .0281,
     +              .0274, .0268, .0262, .0256, .0250, .0244,
     +              .0239, .0233 /
      data (g(j),j=75,124)/ .02275, .02222, .02169, .02118, .02068,
     +              .02018, .01970, .01923, .01876, .01831,
     +              .01786, .01743, .01700, .01659, .01618,
     +              .01578, .01539, .01500, .01463, .01426,
     +              .01390, .01355, .01321, .01287, .01255,
     +              .01222, .01191, .01160, .01130, .01101,
     +              .01072, .01044, .01017, .00990, .00964,
     +              .00939, .00914, .00889, .00866, .00842,
     +              .00820, .00798, .00776, .00755, .00734,
     +              .00714, .00695, .00676, .00657, .00639 /
      data (g(j),j=125,174)/ .00621, .00604, .00587, .00570, .00554,
     +              .00539, .00523, .00508, .00494, .00480,
     +              .00466, .00453, .00440, .00427, .00415,
     +              .00402, .00391, .00379, .00368, .00357,
     +              .00347, .00336, .00326, .00317, .00307,
     +              .00298, .00289, .00280, .00272, .00264,
     +              .00256, .00248, .00240, .00233, .00226,
     +              .00219, .00212, .00205, .00199, .00193,
     +              .00187, .00181, .00175, .00169, .00164,
     +              .00159, .00154, .00149, .00144, .00139 /
      data (g(j),j=175,176)/ .00134, .00129 /
Cbegin


      if ( ST_FAILED ) return

      if ( rv.gt.4.3 ) then
         prob = 0.0
      elseif ( rv.ge.3.0 ) then
         av = (rv-2.7)*10.0
         kv = av
         av = av - kv
         prob = cubintx ( f(kv), av )
      elseif ( rv.ge.1.28 ) then
         av = (rv-1.25)*100.0
         kv = av
         av = av - kv
         prob = cubintx ( g(kv), av )
      else
         prob = 0.1003
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="hgramr"> HGRAMR  </a>-- Load histogram from values in a real array
C
C a j penny                         dao           1988-04-19

      subroutine hgramr ( rdata, kx, ky, lxa, lxb, lya, lyb, rmin,
     +                    kgram, numbin, rbin, rinval )

      implicit none
      include 'STARMAN_INC'

      integer kx		!i: X size of array
      integer ky		!i: Y size of array
      real    rdata(kx,ky)	!i: Array
      integer lxa		!i: X start of array area to use
      integer lya		!i: Y start of array area to use
      integer lxb		!i: X end of array area to use
      integer lyb		!i: Y end start of array area to use
      real    rmin		!i: Pixel value of histogram 1st bin
      integer numbin		!i: Number of bins in histogram
      integer kgram(numbin)	!o: Histogram
      real    rbin		!i: Pixel value step per bin
      real    rinval		!i: INVAL bad pixel flag value
C--
      integer j, k, l
Cbegin


      if ( ST_FAILED ) return

      call azeroi ( kgram, numbin )

      do k = lya, lyb
         do j = lxa, lxb
            if ( rdata(j,k).ne.rinval ) then
               l = int((rdata(j,k)-rmin)/rbin) + 1
               if ( l.ge.1 .and. l.le.numbin ) kgram(l) = kgram(l) + 1
            endif
         enddo
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="hgrams"> HGRAMS  </a>-- Load histogram from values in an integer*2 array
C
C a j penny                         dao           1988-04-19

      subroutine hgrams ( kdata, kx, ky, lxa, lxb, lya, lyb, kmin,
     +                    kgram, numbin, kbin, inval )

      implicit none
      include 'STARMAN_INC'

      integer kx		!i: X size of array
      integer ky		!i: Y size of array
      integer*2 kdata(kx,ky)	!i: Array
      integer lxa		!i: X start of array area to use
      integer lya		!i: Y start of array area to use
      integer lxb		!i: X end of array area to use
      integer lyb		!i: Y end start of array area to use
      integer kmin		!i: Pixel value of histogram 1st bin
      integer numbin		!i: Number of bins in histogram
      integer kgram(numbin)	!o: Histogram
      integer kbin		!i: Pixel value step per bin
      integer inval		!i: INVAL bad pixel flag value
C--
      integer j, k, l
Cbegin


      if ( ST_FAILED ) return

      call azeroi ( kgram, numbin )

      do k = lya, lyb
         do j = lxa, lxb
            if ( kdata(j,k).ne.inval ) then
               l = (kdata(j,k)-kmin)/kbin + 1
               if ( l.ge.1 .and. l.le.numbin ) kgram(l) = kgram(l) + 1
            endif
         enddo
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="linfit"> LINFIT  </a>-- Take N  X,Y points and fits a straight line to them.
C       Y = ZERO + SL.X
C
C   a.j.penny                   rgo                    83-8-14


      subroutine linfit ( x, y, n, sl, zero, dx, dy, dsd, chi, rms )

      implicit none
      include 'STARMAN_INC'

      integer	n		!i: no of points
      real	x(n)		!i: X value of points
      real	y(n)		!i: Y value of points
      real	sl		!o: Slope of line fit
      real	zero		!o: zero of line fit
      double precision dx(n)	!o: Work space 1
      double precision dy(n)	!o: Work space 2
      double precision dsd(n)	!o: Work space 3
      real	chi		!o: Chi-sq of fit
      real	rms		!o: RMS of Y data from fit
C--
      double precision da(3), dchi, drms
      real xmax, ymax, xmin, ymin, xr, yr
      integer k
Cbegin


      if ( ST_FAILED ) return

C Scale data

      xmax = x(1)
      ymax = y(1)
      xmin = x(1)
      ymin = y(1)
      do k = 2, n
         xmax = max(xmax,x(k))
         ymax = max(ymax,y(k))
         xmin = min(xmin,x(k))
         ymin = min(ymin,y(k))
      enddo
      xr = xmax - xmin
      yr = ymax - ymin
      do k = 1, n
         dx(k) = dble((x(k)-xmin)/xr)
         dy(k) = dble((y(k)-ymin)/yr)
         dsd(k) = 1.0d0
      enddo

C  Do the fit

      call polfit ( dx, dy, dsd, n, 3, 0, da, dchi, drms )

C Rescale answer back

      sl   = da(2)*yr/xr
      zero = da(1)*yr + ymin - da(2)*yr*xmin/xr
      rms  = drms*yr
      chi  = dchi


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="linfita"> LINFITA  </a>-- Find mean and slope of a vector (simple and fast)
C  This takes the vector as values of Y, and assumes X values of
C  1,2,3,... It then calculates the mean of the Y values and
C  the slope of a line Y = a.X + b
C
C alan penny            ral               nov 89

      subroutine linfita ( gx, n, am, sl )

      implicit none
      include 'STARMAN_INC'

      integer n			!i: Number of input points
      real    gx(n)		!i: Input data
      real    am		!o: Mean
      real    sl		!o: Slope
C--
      real e, ak, g, rh
      integer j
Cbegin


      if ( ST_FAILED ) return

      call asumr ( gx, n, e )				!Mean
      am = e/real(n)

      ak = 1 + real(n-1)/2.0				!Slope
      g = 0.0		
      do j = 1, n
         g = g + (real(j)-ak)*(gx(j)-am)
      enddo
      rh = real(n)/2.0
      sl = g/(2.0*rh*(rh+1.0)*(2.0*rh+1.0)/6.0)


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="ludecmat"> LUDECMAT  </a>-- Decompose matrix by LU decomposition
C
C    alan penny             ral          1990 apr 14

      subroutine ludecmat ( a, n, np, indx, d, ierr )

      implicit none
      include 'STARMAN_INC'

      integer   np		!i:   Size of matrix
      real      a(np,np)	!i/o: Matrix and solution
      integer   n		!i:   Size of matrix contents
      integer   indx(n)		!o:   Row permutation
      real      d		!o:   =+1 if even no of interchanges,
				!     =-1 if odd number
      integer   ierr		!o:   Error flag 0=ok;1=bad
C--
      real  vv(100), aamax, sum, dum, tiny
      integer i, j, k, imax
      parameter ( tiny=1.0e-18 )
Cbegin


      if ( ST_FAILED ) then
         ierr = 1
         return
      endif

      ierr = 0

      d = 1.0
      do i = 1, n
         aamax = 0.0
         do j = 1, n
            if ( abs(a(i,j)).gt.aamax ) aamax = abs(a(i,j))
         enddo
         if ( abs(aamax).lt.tiny ) then
            ierr = 1
            return
         endif
         vv(i) = 1.0/aamax
      enddo

      do j = 1, n

         if ( j.gt.1 ) then
            do i = 1, j-1
               sum = a(i,j)
               if ( i.gt.1 ) then
                  do k = 1, i-1
                     sum = sum - a(i,k)*a(k,j)
                  enddo
                  a(i,j) = sum
               endif
            enddo
        endif

        aamax = 0.0
        do i = j, n
           sum = a(i,j)
           if ( j.gt.1 ) then
              do k = 1, j-1
                 sum = sum - a(i,k)*a(k,j)
              enddo
              a(i,j) = sum
           endif
           dum = vv(i)*abs(sum)
           if ( dum.ge.aamax ) then
              imax = i
              aamax = dum
           endif
        enddo

        if ( j.ne.imax ) then
           do k = 1, n
              dum = a(imax,k)
              a(imax,k) = a(j,k)
              a(j,k) = dum
           enddo
           d = -d
           vv(imax) = vv(j)
        endif

        indx(j) = imax
        if ( j.ne.n ) then
           if ( a(j,j).eq.0.0 ) then
              a(j,j) = tiny
           else
              if ( abs(a(j,j)).lt.tiny ) a(j,j) = sign(tiny,a(j,j))
           endif
           dum = 1.0/a(j,j)
           do i = j+1, n
              a(i,j) = a(i,j)*dum
           enddo
        endif

      enddo

      if ( a(n,n).eq.0.0 ) then
         a(n,n) = tiny
      else
         if ( abs(a(n,n)).lt.tiny ) a(n,n) = sign(tiny,a(n,n))
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="lusolmat"> LUSOLMAT  </a>-- Solve a matrix by LU decompsoition
C
C  alan penny                 ral              1990 Jan

      subroutine lusolmat ( a, n, np, indx, b )

      implicit none
      include 'STARMAN_INC'

      integer  np
      real     a(np,np)
      integer  n
      integer  indx(n)
      real     b(n)
C--
      integer i, j, ii, ll
      real sum
Cbegin


      if ( ST_FAILED ) return

      ii = 0
      do i = 1, n
         ll = indx(i)
         sum = b(ll)
         b(ll) = b(i)
         if ( ii.ne.0 ) then
            do j = ii, i-1
               sum = sum - a(i,j)*b(j)
            enddo
         elseif ( sum.ne.0.0 ) then
            ii=i
         endif
         b(i)=sum
      enddo

      do i = n, 1, -1
         sum = b(i)
         if ( i.lt.n ) then
            do j = i+1, n
               sum = sum - a(i,j)*b(j)
            enddo
         endif
         b(i)=sum/a(i,i)
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="mannwhiti"> MANNWHITI  </a>-- Perform a 1-tailed mann-whitney (Wilcoxon) test on integers
C   To see if two groups of numbers come from the same population.
C   Approximation is valid provided n1 and n2 both > 8.
C   If probability is >0.1003, set at 0.1003. The total number of
C   points in the two groups can be up to 2000.
C
C   a j penny             stsci     86-11-26

      subroutine mannwhiti ( ix1, n1, ix2, n2, sig, larger, ierr )

      implicit none
      include 'STARMAN_INC'

      integer	n1		!i: No of points in 1st group
      integer	ix1(n1)		!i: 1st group data
      integer	n2		!i: No of points in 2nd group
      integer	ix2(n2)		!i: 2nd group data
      real	sig		!o: prob groups are same
      logical	larger		!o: True if group2 median>group1
      integer   ierr		!o: Failure flag: 0=ok;1= bad (total no of
				!    values > 2000)
C--
      integer   ix(2000), iw(2000)
      integer	j, k, kk, n, ivi
      real	sum, r1, r2, r3, r4, rv, diff, var, sumt, t
      logical	loop, allsame
Cbegin


      if ( ST_FAILED ) then
         ierr = 1
         return
      endif

      ierr = 0								!Failure flag

      larger = .false.							!Default
      sig = 1.0
									!Load data
      n = n1 + n2							!Total number of points	

      if ( n.gt.2000 ) then						!Size check
         type *,'Mann-Whitney U test failed. Over 2000 points'
         ierr = 1
         return
      endif

      allsame = .true.
      ivi = ix1(1)
      do k = 1, n1							!Load and set up where come from
         if ( ix1(k).ne.ivi ) allsame = .false.
         ix(k) = ix1(k)
         iw(k) = 0
      enddo
      do k = 1, n2
         if ( ix2(k).ne.ivi ) allsame = .false.
         j = k + n1
         ix(j) = ix2(k)
         iw(j) = 1
      enddo

      if ( allsame ) return						!Check if all same, and if so, return

      call sort2i ( ix, iw, n )						!Order ix and iw

      sum = 0.0								!Calc rank sum of first set
      sumt = 0.0
      k = 1
      do while ( k.le.n )
         loop = .true.
         j = k
         do while ( loop )
            j = j + 1
            if ( j.gt.n .or. ix(k).ne.ix(j) ) loop = .false.
         enddo
         j = j - 1
         if ( j.ne.k ) then
            t = j - k + 1
            sumt = sumt + t*t*t - t
            rv = real(k+j)/2.0
            do kk = k, j
               if ( iw(kk).eq.1 ) sum = sum + rv
            enddo
            k = j
         else
           if ( iw(k).eq.1 ) sum = sum + real(k)
         endif
         k = k + 1
      enddo

      r1 = n1								!Median diff and significance
      r2 = n2
      r4 = n1 + n2
      r3 = r4 + 1
      diff = sum - (r2*r3)/2.0
      larger = .false.
      if ( diff.gt.0.0 ) larger = .true.
      sig = 1.0
      var = (r1*r2/(r4*(r4-1.0)))*((r4*r4*r4-r4-sumt)/12.0)
      rv = abs(diff)/sqrt(var)
      call gprob ( rv, sig )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="mannwhitr"> MANNWHITR  </a>-- Perform a 1-tailed mann-whitney (Wilcoxon) test on reals
C   To see if two groups of numbers come from the same population.
C   Approximation is valid provided n1 and n2 both > 8.
C   If probability is >0.1003, set at 0.1003. The total number of
C   points in the two groups can be up to 2000.
C
C   a j penny             stsci     86-11-26

      subroutine mannwhitr ( ix1, n1, ix2, n2, sig, larger, ierr )

      implicit none
      include 'STARMAN_INC'

      integer	n1		!i: No of points in 1st group
      real      ix1(n1)		!i: 1st group data
      integer	n2		!i: No of points in 2nd group
      real      ix2(n2)		!i: 2nd group data
      real	sig		!o: prob groups are same
      logical	larger		!o: True if group2 median>group1
      integer   ierr		!o: Failure flag: 0=ok;1= bad (total no of
				!    values > 2000)
C--
      real      ix(2000), iw(2000)
      integer	j, k, kk, n
      real	rvi, sum, r1, r2, r3, r4, rv, diff, var, sumt, t
      logical	loop, allsame
Cbegin


      if ( ST_FAILED ) then
         ierr = 1
         return
      endif

      ierr = 0								!Failure flag

      larger = .false.							!Default
      sig = 1.0
									!Load data
      n = n1 + n2							!Total number of points	

      if ( n.gt.2000 ) then						!Size check
         type *,'Mann-Whitney U test failed. Over 2000 points'
         ierr = 1
         return
      endif

      allsame = .true.
      rvi = ix1(1)
      do k = 1, n1							!Load and set up where come from
         if ( ix1(k).ne.rvi ) allsame = .false.
         ix(k) = ix1(k)
         iw(k) = 0.0
      enddo
      do k = 1, n2
         if ( ix2(k).ne.rvi ) allsame = .false.
         j = k + n1
         ix(j) = ix2(k)
         iw(j) = 1.0
      enddo

      if ( allsame ) return						!Check if all same, and if so, return

      call sort2r ( ix, iw, n )						!Order ix and iw

      sum = 0.0								!Calc rank sum of first set
      sumt = 0.0
      k = 1
      do while ( k.le.n )
         loop = .true.
         j = k
         do while ( loop )
            j = j + 1
            if ( j.gt.n .or. ix(k).ne.ix(j) ) loop = .false.
         enddo
         j = j - 1
         if ( j.ne.k ) then
            t = j - k + 1
            sumt = sumt + t*t*t - t
            rv = real(k+j)/2.0
            do kk = k, j
               if ( iw(kk).eq.1.0 ) sum = sum + rv
            enddo
            k = j
         else
           if ( iw(k).eq.1.0 ) sum = sum + real(k)
         endif
         k = k + 1
      enddo

      r1 = n1								!Median diff and significance
      r2 = n2
      r4 = n1 + n2
      r3 = r4 + 1
      diff = sum - (r2*r3)/2.0
      larger = .false.
      if ( diff.gt.0.0 ) larger = .true.
      sig = 1.0
      var = (r1*r2/(r4*(r4-1.0)))*((r4*r4*r4-r4-sumt)/12.0)
      rv = abs(diff)/sqrt(var)
      call gprob ( rv, sig )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="matinv"> MATINV  </a>-- Invert a matrix
C
C   alan penny                 ral          1990 apr 14

      subroutine matinv ( ain, w, n, na, ierr )

      implicit none
      include 'STARMAN_INC'

      integer n			!i:   Matrix occupies n by n
      real    ain(n,n)		!i/o: Input matrix. Replaced by inverse
      real    w(n,n)		!o:   Work space
      integer na		!i:   Matrix contents in na by na
      integer ierr		!o:   Error flag 0=ok;1=bad
C--
      integer  j, k, ka(100)
      real rv
Cbegin


      if ( ST_FAILED ) then
         ierr = 1
         return
      endif

      do j = 1, na							!Load identity matrix
         do k = 1, na
            w(j,k) = 0.0
         enddo
         w(j,1) = 1.0
      enddo

      call ludecmat ( ain, na, n, ka, rv, ierr )			!Decompose matrix

      if ( ierr.eq.0 ) then
         do j = 1, n							!Get inverse by columns
            call lusolmat ( ain, na, n, ka, w(1,j) )
         enddo
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="meanstdi"> MEANSTDI  </a>-- Calc mean and std deviation of an integer vector.
C    This uses weights and elements of the vector can be ignored.
C    After calculating the mean and std dev, then those input
C    values which were more than some number of std devs from the
C    mean are rejected. Also rejected are those more than some
C    value from the mean. The mean and standard deviation are then
C    recalculated and the process repeated until no more values
C    are rejected. (The process stops if less than 5 values are left.)
C
C  a j penny             stsci             1988-03-27

      subroutine meanstdi ( v, w, use, n, dosdlim, rsd, doalim, rab,
     +                      av, sd )

      implicit none
      include 'STARMAN_INC'

      integer	n		!i: No of elements
      integer	v(n)		!i: Vector
      real	w(n)		!i: Weights
      logical	use(n)		!i:/o Flag to use element (can be set to
				!     to false if rejected by RSD or RAB)
      logical   dosdlim		!i: Use sd dev lim to reject?
      real	rsd		!i: Reject elements more than RSD sd devs from mean
      logical   doalim		!i: Use absolute lim to reject?
      real	rab		!i: Reject elements more than RAB from  mean
      real	av		!o: Mean
      real	sd		!o: Standard deviation
C--
      integer k, ng, knote
      real rmax, abdiff
      logical loop
      double precision dav, dsw, dsvw, dsvvw, dv, dw
Cbegin


      if ( ST_FAILED ) return

      av = 0.0								!Default and Checks
      sd = 0.0

      if ( n.lt.1 ) return
      ng = 0
      do k = 1, n
         if ( use(k) ) ng = ng + 1
      enddo
      if ( ng.eq.0 ) return

      dsw = 0.0d0							!Calculate mean and std dev
      dsvw = 0.0d0
      dsvvw = 0.0d0
      do k = 1, n
         if ( use(k) ) then
            dw = w(k)
            dsw = dsw + dw
            dsvw = dsvw + v(k)*dw
            dsvvw = dsvvw + v(k)*v(k)*dw
         endif
      enddo

      if ( dsw.eq.0.0d0 ) return
      dav = dsvw/dsw
      av = dav
      if ( ng.lt.2 ) return
      dv = max (1.0d-20,(dsvvw-dsw*dav*dav))
      sd = sqrt(dv/(dsw-1.0d0))

C  If wanted, recalculate mean, by throwing out largest diff and
C  recalculating until none thrown out as too far off mean

      if ( .not.dosdlim .and. .not.doalim ) return

      loop = .true.
      do while ( loop )							!Loop till no more rejected
         rmax = 0.0							!Find max out of limits
         do k = 1, n
            if ( use(k) ) then
               abdiff = abs(v(k)-av)
               if ( abdiff.gt.rmax ) then
                  rmax = abdiff
                  knote = k
               endif
            endif
         enddo
         if ( ( doalim .and. rmax.gt.rab )     .or.			!if,note or exit
     +        ( dosdlim .and. rmax.gt.rsd*sd ) ) then
            use(knote) = .false.
            ng = ng - 1
         else
            loop = .false.
         endif

         if ( loop ) then						!If redo, recalc mean, sd
            dsw = 0.0d0
            dsvw = 0.0d0
            dsvvw = 0.0d0
            do k = 1, n
               if ( use(k) ) then
                  dw = w(k)
                  dsw = dsw + dw
                  dsvw = dsvw + v(k)*dw
                  dsvvw = dsvvw + v(k)*v(k)*dw
               endif
            enddo

            if ( dsw.eq.0.0d0 ) return
            dav = dsvw/dsw
            av = dav
            if ( ng.lt.2 ) return
            dv = max (1.0d-20,(dsvvw-dsw*dav*dav))
            sd = sqrt(dv/(dsw-1.0d0))
         endif

         if ( loop .and. ng.lt.5 ) loop = .false.			!Must be >4 elements

      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="meanstdr"> MEANSTDR  </a>-- Calc mean and std deviation of a real vector.
C    This uses weights and elements of the vector can be ignored.
C    After calculating the mean and std dev, then those input
C    values which were more than some number of std devs from the
C    mean are rejected. Also rejected are those more than some
C    value from the mean. The mean and standard deviation are then
C    recalculated and the process repeated until no more values
C    are rejected. (The process stops if less than 5 values are left.)
C
C  a j penny             stsci             1988-03-27


      subroutine meanstdr ( v, w, use, n, dosdlim, rsd, doalim, rab,
     +                      av, sd )

      implicit none
      include 'STARMAN_INC'

      integer	n		!i: No of elements
      real	v(n)		!i: Vector
      real	w(n)		!i: Weights
      logical	use(n)		!i:/o Flag to use element (can be set to
				!     to false if rejected by RSD or RAB)
      logical   dosdlim		!i: Use sd dev lim to reject?
      real	rsd		!i: Reject elements more than RSD sd devs from mean
      logical   doalim		!i: Use absolute lim to reject?
      real	rab		!i: Reject elements more than RAB from  mean
      real	av		!o: Mean
      real	sd		!o: Standard deviation
C--
      integer k, ng, knote
      real rmax, abdiff
      logical loop
      double precision dav, dsw, dsvw, dsvvw, dv, dw
Cbegin


      if ( ST_FAILED ) return

      av = 0.0								!Default and Checks
      sd = 0.0

      if ( n.lt.1 ) return
      ng = 0
      do k = 1, n
         if ( use(k) ) ng = ng + 1
      enddo
      if ( ng.eq.0 ) return

      dsw = 0.0d0							!Calculate mean and std dev
      dsvw = 0.0d0
      dsvvw = 0.0d0
      do k = 1, n
         if ( use(k) ) then
            dw = w(k)
            dsw = dsw + dw
            dsvw = dsvw + v(k)*dw
            dsvvw = dsvvw + v(k)*v(k)*dw
         endif
      enddo

      if ( dsw.eq.0.0d0 ) return
      dav = dsvw/dsw
      av = dav
      if ( ng.lt.2 ) return
      dv = max (1.0d-20,(dsvvw-dsw*dav*dav))
      sd = sqrt(dv/(dsw-1.0d0))

C  If wanted, recalculate mean, by throwing out largest diff and
C  recalculating until none thrown out as too far off mean

      if ( .not.doalim .and. .not.dosdlim ) return

      loop = .true.
      do while ( loop )							!Loop till no more rejected
         rmax = 0.0							!Find max out of limits
         do k = 1, n
            if ( use(k) ) then
               abdiff = abs(v(k)-av)
               if ( abdiff.gt.rmax ) then
                  rmax = abdiff
                  knote = k
               endif
            endif
         enddo
         if ( ( doalim .and. rmax.gt.rab )     .or.			!if,note or exit
     +        ( dosdlim .and. rmax.gt.rsd*sd ) ) then
            use(knote) = .false.
            ng = ng - 1
         else
            loop = .false.
         endif

         if ( loop ) then						!if redo, recalc mean, sd
            dsw = 0.0d0
            dsvw = 0.0d0
            dsvvw = 0.0d0
            do k = 1, n
               if ( use(k) ) then
                  dw = w(k)
                  dsw = dsw + dw
                  dsvw = dsvw + v(k)*dw
                  dsvvw = dsvvw + v(k)*v(k)*dw
               endif
            enddo

            if ( dsw.eq.0.0d0 ) return
            dav = dsvw/dsw
            av = dav
            if ( ng.lt.2 ) return
            dv = max (1.0d-20,(dsvvw-dsw*dav*dav))
            sd = sqrt(dv/(dsw-1.0d0))
         endif

         if ( loop .and. ng.lt.5 ) loop = .false.			!Must be >4 elements

      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="poidev"> POIDEV  </a>-- Make a poisson randomised integer output of a real input number
C 1)Numbers < 20
C        choose a random number between 0 and 1. then calc the probability
C        p0 of 0 as exp(-s). if nr is less than p0 exit with answer 0. else
C        calc prob p1 of 1 as s*exp(-s)/1. if nr less than p0+p1, exit with
C        ans 1. else calc prob p2 of 2 as s*s*exp(-s)/2.1  if nr less than
C        p0+p1+p2, exit with ans 2. and so on
C 2)Numbers >=20
C        a gaussian scatter times the square root of the number, which is
C        very nearly a poissonian scatter.
C
C 3)Numbers < 1.0e-10
C        These get a return of 0.0
C
C   The seed number is changed after each call, but can be set to any number
C   to start the random number pattern
C
C     a.j. penny               stsci                        1989-04-21

      subroutine poidev ( s, ss, nran )

      implicit none
      include 'STARMAN_INC'

      real    s		!i:   input number
      real    ss	!o:   output number (integral value)
      integer nran	!i/o: Seed number for the random number
			!     generator
C--
      real b, r, a, c
      integer k
Cbegin


      if ( ST_FAILED ) return

      if ( s.lt.1.0e-10 ) then				!If -ve or very near zero
         ss = 0.0					! output 0. (random gen
         call rano ( b, nran )				! called anyway)
         return
      endif

      if ( s.lt.20.0 ) then				!Do full calc
         call rano (b, nran )
         k = 0
         r = 0.0
         a = exp(-1.0*s)
         c = a
         do while ( b.ge.c )
            k = k + 1
            r = r + 1.0
            a = a*s/r
            c = c + a
         enddo
         ss = real(k)
      else						!Approx gauss
         call gasdev ( a, nran )
         ss = a*sqrt(s)
         ss = aint(s+ss+0.5)
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="polfit"> POLFIT  </a>-- Least squares fit to data with a polynomial curve,
C               Y = A(1) + A(2)*X + A(3)*X**2 + ...
C
C     Valid up to nterms = 10
C     Needs input x,y values not much above 1
C
C     Got from m j currie by a j penny     rgo      7-sep-82

      subroutine polfit ( dx, dy, dsd, np, nfp, mode, da, dchisq, drms )

      implicit none
      include 'STARMAN_INC'

      integer	np		!i: No of points
      double precision dx(np)	!i: data of independent variable
      double precision dy(np)	!i: data of dependent variable
      double precision dsd(np)	!i: Std dev for y data points
      integer	nfp		!i: No of coefficents (polynomial degree +1)
      integer	mode		!i: 'mode' => weighting of least squares fit
				! +1=(instrumental) weight(i)=1.0/sdy(i)**2
				!  0=(no weighting) weight(i)=1.0
				! -1=(statistical)  weight(i)=1.0/y(i)
      double precision da(nfp)	!o: coeffs of polynomial
      double precision dchisq	!o: Reduced chi square for fit
      double precision drms	!o: Std deviation of fit
C--
      double precision dsumx(19), dsumy(10), darray(10,10), dxi, dyi,
     +                 dweight, dxterm, dyterm, ddelta, dcalc
      logical same
      integer i, j, k, l, n, nmax, nfree

      double precision determ
      external determ
Cbegin


      if ( ST_FAILED ) return

C  Set up default

      da(1) = dy(1)
      do k = 2, nfp
         da(k) = 0.0d0
      enddo
      dchisq = 0.0
      drms = 0.0

C  Check for all values same. If so, set answer, return.

      same = .true.
      do k = 1, np
         if ( dy(k).ne.dy(1) ) same = .false.
      enddo
      if ( same ) return

C   Accumulate weighted sums

      nmax = 2*nfp - 1
      do n = 1, nmax
         dsumx(n) = 0.0d0
      enddo
      do j = 1, nfp
         dsumy(j) = 0.0d0
      enddo

      do i = 1, np

         dxi = dx(i)
         dyi = dy(i)

         if ( mode.eq.1 ) then
            dweight = 1.0d0/(dsd(i)*dsd(i))
         elseif ( mode.eq.0 ) then
            dweight = 1.0d0
         else
            if ( dyi.gt.0.0d0 ) then
               dweight = 1.0d0/dyi
            elseif ( dyi.eq.0.0d0 ) then
               dweight = 1.0d0
            else
               dweight = -1.0d0/dyi
            endif
         endif
         dxterm = dweight

         do n = 1, nmax
            dsumx(n) = dsumx(n) + dxterm
            dxterm = dxterm*dxi
         enddo
         dyterm = dweight*dyi
         do n = 1, nfp
            dsumy(n) = dsumy(n) + dyterm
            dyterm = dyterm*dxi
         enddo
         dchisq = dchisq + dweight*dyi*dyi
      enddo

C   Construct matrices and calculate coefficients

      do j = 1, nfp
         do k = 1, nfp
            n = j + k - 1
            darray(j,k) = dsumx(n)
         enddo
      enddo
      ddelta = determ ( darray, nfp )

C  If determ is zero, exit

      if ( ddelta.eq.0.0d0 ) then
         dchisq = 0.0
         do j = 1, nfp
            da(j) = 0.0d0
         enddo
         return
      endif

      do l = 1, nfp
         do j = 1, nfp
            do k = 1, nfp
               n = j + k - 1
               darray(j,k) = dsumx(n)
            enddo
            darray(j,l) = dsumy(j)
         enddo
         da(l) = determ(darray,nfp)/ddelta
      enddo

C   Calculate chi square

      nfree = np - nfp
      if ( nfree.le.0 ) return
      do  j = 1, nfp
         dchisq = dchisq - 2.0d0*da(j)*dsumy(j)
         do k = 1, nfp
            n = j + k - 1
            dchisq = dchisq + da(j)*da(k)*dsumx(n)
         enddo
      enddo
      dchisq = dchisq/dble(nfree)

C   Calculate standard deviation

      drms = 0.0
      do k = 1, np
         dcalc = da(1)
         if ( nfp.ne.1 ) then
            do j = 2, nfp
               dcalc = dcalc + da(j)*(dx(k)**(j-1))
            enddo
            drms = drms + (dy(k)-dcalc)*(dy(k)-dcalc)
         endif
      enddo
      drms = sqrt(drms/dble(nfree))


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="prodcc"> PRODCC  </a>-- Sum the products of columns in two arrays
C    It takes any column in each of the arrays and multiplies and sums
C    It takes any column in each of the arrays and multiplies and sums
C    the elements of the same section in those columns.
C
C   alan penny                ral              1990-05-22

      subroutine prodcc ( a, nxa, nya, ja, b, nxb, nyb, jb, ns, ne, s )

      implicit none
      include 'STARMAN_INC'

      integer	nxa		!i: X size of array A
      integer	nya		!i: Y size of array A
      real	a(nxa,nya)	!i: Array A
      integer	ja		!i: Column of array A to multiply
      integer	nxb		!i: X size of array B
      integer	nyb		!i: Y size of array B
      real	b(nxb,nyb)	!i: Array B
      integer	jb		!i: Column of array B to multiply
      integer	ns		!i: Start of section in columns
      integer	ne		!i: End of section in columns
      real	s		!o: Output sum
C--
      integer k
Cbegin


      if ( ST_FAILED ) return

      s = 0.0
      do k = ns, ne
         s = s + a(ja,k)*b(jb,k)
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="prodcr"> PRODCR  </a>-- Sum the products of a column of one array with the row of another
C    It takes any column in each of the arrays and multiplies and sums
C    the elements of the same section in those columns.
C
C   alan penny                ral              1990-05-22

      subroutine prodcr ( a, nxa, nya, ja, b, nxb, nyb, jb, ns, ne, s )

      implicit none
      include 'STARMAN_INC'

      integer	nxa		!i: X size of array A
      integer	nya		!i: Y size of array A
      real	a(nxa,nya)	!i: Array A
      integer	ja		!i: Column of array A to multiply
      integer	nxb		!i: X size of array B
      integer	nyb		!i: Y size of array B
      real	b(nxb,nyb)	!i: Array B
      integer	jb		!i: Row of array B to multiply
      integer	ns		!i: Start of section in row/column
      integer	ne		!i: End of section in row/column
      real	s		!o: Output sum
C--
      integer k
Cbegin


      if ( ST_FAILED ) return

      s = 0.0
      do k = ns, ne
         s = s + a(ja,k)*b(k,jb)
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="prodrc"> PRODRC  </a>-- Sum the products of a row of one array with the column of another
C    It takes any column in each of the arrays and multiplies and sums
C    the elements of the same section in those columns.
C
C   alan penny                ral              1990-05-22

      subroutine prodrc ( a, nxa, nya, ja, b, nxb, nyb, jb, ns, ne, s )

      implicit none
      include 'STARMAN_INC'

      integer	nxa		!i: X size of array A
      integer	nya		!i: Y size of array A
      real	a(nxa,nya)	!i: Array A
      integer	ja		!i: Row of array A to multiply
      integer	nxb		!i: X size of array B
      integer	nyb		!i: Y size of array B
      real	b(nxb,nyb)	!i: Array B
      integer	jb		!i: Column of array B to multiply
      integer	ns		!i: Start of section in row/column
      integer	ne		!i: End of section in row/column
      real	s		!o: Output sum
C--
      integer k
Cbegin


      if ( ST_FAILED ) return

      s = 0.0
      do k = ns, ne
         s = s + a(k,ja)*b(jb,k)
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="prodrr"> PRODRR  </a>-- Sum the products of rows in two arrays
C    It takes any row in each of the arrays and multiplies and sums
C    the elements of the same section in those rows.
C
C
C   alan penny                ral              1990-05-22

      subroutine prodrr ( a, nxa, nya, ja, b, nxb, nyb, jb, ns, ne, s )

      implicit none
      include 'STARMAN_INC'

      integer	nxa		!i: X size of array A
      integer	nya		!i: Y size of array A
      real	a(nxa,nya)	!i: Array A
      integer	ja		!i: Row of array A to multiply
      integer	nxb		!i: X size of array B
      integer	nyb		!i: Y size of array B
      real	b(nxb,nyb)	!i: Array B
      integer	jb		!i: Row of array B to multiply
      integer	ns		!i: Start of section in rows
      integer	ne		!i: End of section in rows
      real	s		!o: Output sum
C--
      integer k
Cbegin


      if ( ST_FAILED ) return

      s = 0.0
      do k = ns, ne
         s = s + a(k,ja)*b(k,jb)
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="rangei"> RANGEI  </a>-- Find mean, std dev of an integer bad pixel flagged image section
C  It calcs the mean and std dev. Then recalcs (2 more times) using only
C  those points within 3 std dev of the calculated mean.
C  If the section is more than 80 on either side, a grid of points
C  is taken so that between 40 and 80 on a side is sampled.
C
C   alan penny             ral         1990 jan

      subroutine rangei ( data, nx, ny, kx, ky, inval, am, std, ierr )

      implicit none
      include 'STARMAN_INC'

      integer   nx		!i: X image size
      integer   ny		!i: Y image size
      integer	data(nx,ny)	!i: Image
      integer   kx(2)		!i: X range of image to use
      integer   ky(2)		!i: Y range of image to use
      integer	inval		!i: Image bad pixel value flag
      real      am		!o: Mean of image
      real      std		!o: Std Dev of image
      integer   ierr		!o: Error flag. 0=ok;1=all same;2=only
				!   one good point; 3=no good points
				!   (in sampling grid)
C--
      double precision s, ss, sn, an
      integer nxa, nya, j, k, iter, kn, iv
      real amax, amin, rmin, rmax
Cbegin


      if ( ST_FAILED ) then
         ierr = 1
         return
      endif

      nxa = 1 + (kx(2)-kx(1))/80			!Get sampling step
      nya = 1 + (ky(2)-ky(1))/80

      rmin = 1.0e10					!Get max and min
      rmax = -1.0e10					! (these are later used
      kn = 0						! as limits)
      do k = ky(1), ky(2), nya
         do j = kx(1), kx(2), nxa
            iv = data(j,k)
            if ( iv.ne.inval ) then
               kn = kn + 1
               rmin = min(real(iv),rmin)
               rmax = max(real(iv),rmax)
            endif
         enddo
      enddo

      ierr = 0	
      am = 0.0
      std = 0.0
      if ( kn.eq.0 ) then				!Check none good
         am = rmin
         ierr = 3
      elseif ( kn.eq.1 ) then				!Check more than 1
         am = rmin
         ierr = 2
      elseif ( rmin.ge.rmax ) then			!Check that not all same
         am = rmin
         ierr = 1
      endif
      if ( ierr.ne.0 ) return

      do iter = 1,3					!Do the calcs 3 times

         s = 0.0					!get mean and std dev
         sn = 0.0					! of good data within
         ss = 0.0					! the limits
         do k = ky(1), ky(2), nya
            do j = kx(1), kx(2), nxa
               iv = data(j,k)
               if ( iv.ne.inval .and. real(iv).ge.rmin
     +              .and. real(iv).le.rmax ) then
                  an = dble(real(iv))
                  s = s + an
                  ss = ss + an*an
                  sn = sn + 1.0d0
               endif
            enddo
         enddo
         if ( sn.gt.0.1 ) am = s/sn
         if ( sn.gt.1.1 ) then
            ss = (ss-s*s/sn)/(sn-1.0)
            if ( ss.gt.1.0e-20 ) std = sqrt(ss)
         endif

         amin = am - 3.0*std				!Get new limits
         amax = am + 3.0*std
         rmin = int(max(amin,real(rmin)))
         rmax = int(min(amax,real(rmax)))

      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="ranger"> RANGER  </a>-- Find mean, std dev of a real bad pixel flagged image section
C  It calcs the mean and std dev. Then recalcs (2 more times) using only
C  those points within 3 std dev of the calculated mean.
C  If the section is more than 80 on either side, a grid of points
C  is taken so that between 40 and 80 on a side is sampled.
C
C   alan penny             ral         1990 jan

      subroutine ranger ( data, nx, ny, kx, ky, rinval, am, std, ierr )

      implicit none
      include 'STARMAN_INC'

      integer   nx		!i: X image size
      integer   ny		!i: Y image size
      real      data(nx,ny)	!i: Image
      integer   kx(2)		!i: X range of image to use
      integer   ky(2)		!i: Y range of image to use
      real      rinval		!i: Image bad pixel value flag
      real      am		!o: Mean of image
      real      std		!o: Std Dev of image
      integer   ierr		!o: Error flag. 0=ok;1=all same;2=only
				!   one good point; 3=no good points
				!   (in sampling grid)
C--
      double precision s, ss, sn, an
      integer nxa, nya, j, k, iter, kn,
     +        kxs, kxe, kys, kye
      real amax, amin, rv, rmin, rmax
Cbegin


      if ( ST_FAILED ) then
         ierr = 1
         return
      endif

      am = 0.0						!Defaults
      std = 0.0
      ierr = 0

      kxs = min(kx(1),kx(2))
      kxe = max(kx(1),kx(2))
      kys = min(ky(1),ky(2))
      kye = max(ky(1),ky(2))

      if ( kxs.gt.nx .or. kxe.lt.1 .or. kys.gt.ny
     +     .or. kye.lt.1 ) then
          ierr = 3
          return
      endif

      kxs = max(1,kxs)
      kxe = min(nx,kxe)
      kys = max(1,kys)
      kye = min(ny,kye)

      nxa = 1 + (kxe-kxs)/80				!Get sampling step
      nya = 1 + (kye-kys)/80

      rmin = 1.0e10					!Get default max and min
      rmax = -1.0e10					! (these are later used as limits)
      kn = 0
      do k = kys, kye, nya
         do j = kxs, kxe, nxa
            rv = data(j,k)
            if ( rv.ne.rinval ) then
               kn = kn + 1
               rmin = min(rv,rmin)
               rmax = max(rv,rmax)
            endif
         enddo
      enddo

      if ( kn.eq.0 ) then				!Check none good
         am = rmin
         ierr = 3
      elseif ( kn.eq.1 ) then				!Check more than 1
         am = rmin
         ierr = 2
      elseif ( rmin.ge.rmax ) then			!Check that not all same
         am = rmin
         ierr = 1
      endif
      if ( ierr.ne.0 ) return

      do iter = 1,3					!Do the calcs 3 times

         s = 0.0					!get mean and std dev
         sn = 0.0					! of good data within
         ss = 0.0					! the limits
         do k = kys, kye, nya
            do j = kxs, kxe, nxa
               rv = data(j,k)
               if ( rv.ne.rinval .and.
     +              rv.ge.rmin .and. rv.le.rmax ) then
                  an = dble(rv)
                  s = s + an
                  ss = ss + an*an
                  sn = sn + 1.0d0
               endif
            enddo
         enddo
         if ( sn.gt.0.1 ) am = s/sn
         if ( sn.gt.1.1 ) then
            ss = (ss-s*s/sn)/(sn-1.0)
            if ( ss.gt.1.0e-20 ) std = sqrt(ss)
         endif

         amin = am - 3.0*std				!Get new limits
         amax = am + 3.0*std
         rmin = max(amin,rmin)
         rmax = min(amax,rmax)

      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="medianr"> MEDIANR  </a>-- Find median of real bad pixel flagged image section
C
C   alan penny             ral         1990 jan

      subroutine medianr ( data, nx, ny, rw, kx, ky, rinval, rm, ierr )

      implicit none
      include 'STARMAN_INC'

      integer   nx		!i: X image size
      integer   ny		!i: Y image size
      real      data(nx,ny)	!i: Image
      real      rw(*)		!o: Work space (box size)
      integer   kx(2)		!i: X range of image to use
      integer   ky(2)		!i: Y range of image to use
      real      rinval		!i: Image bad pixel value flag
      real      rm		!o: Mean of image
      integer   ierr		!o: Error flag. 0=ok;1=all same;2=only
				!   one good point; 3=no good points
				!   (in sampling grid)
C--
      integer j, k, kn, ka, kxs, kxe, kys, kye
      real rv
Cbegin


      if ( ST_FAILED ) then
         ierr = 1
         return
      endif

      rm = 0.0						!Defaults
      ierr = 0

      kxs = min(kx(1),kx(2))
      kxe = max(kx(1),kx(2))
      kys = min(ky(1),ky(2))
      kye = max(ky(1),ky(2))

      if ( kxs.gt.nx .or. kxe.lt.1 .or. kys.gt.ny
     +     .or. kye.lt.1 ) then
          ierr = 3
          return
      endif

      kxs = max(1,kxs)
      kxe = min(nx,kxe)
      kys = max(1,kys)
      kye = min(ny,kye)

      kn = (kxe-kxs+1)*(kye-kys+1)

      if ( kn.eq.1 ) then
         rv = data(kxs,kys)
         if ( rv.eq.rinval ) then
            ierr = 3
            rm = 0.0
         else
            ierr = 2
            rm = rv
         endif
         return
      endif

      rm = 0.0

      ka = 0
      do k = kys, kye
         do j = kxs, kxe
            if ( data(j,k).ne.rinval ) then
               ka = ka + 1
               rw(ka) = data(j,k)
            endif
         enddo
      enddo

      if ( ka.eq.0 ) then
         ierr = 3
      elseif ( ka.eq.1 ) then
         ierr = 2
         rm = rw(1)
      else
         call sort1r ( rw, ka )
         if ( (2*(ka/2)).eq.ka ) then
            k = (ka/2)
            rm = (rw(k)+rw(k+1))/2.0
         else
            k = (ka/2) + 1
            rm = rw(k)
         endif
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="medians"> MEDIANS  </a>-- Find median int*2 bad pixel flagged image section
C
C   alan penny             ral         1990 jan

      subroutine medians ( kdata, nx, ny, iw, kx, ky, inval, rm, ierr )

      implicit none
      include 'STARMAN_INC'

      integer   nx		!i: X image size
      integer   ny		!i: Y image size
      integer*2 kdata(nx,ny)	!i: Image
      integer   iw(*)       	!o: Work space (box size)
      integer   kx(2)		!i: X range of image to use
      integer   ky(2)		!i: Y range of image to use
      integer   inval		!i: Image bad pixel value flag
      real      rm		!o: Mean of image
      integer   ierr		!o: Error flag. 0=ok;1=all same;2=only
				!   one good point; 3=no good points
				!   (in sampling grid)
C--
      integer j, k, ka, kn, kv, kxs, kxe, kys, kye
Cbegin


      if ( ST_FAILED ) then
         ierr = 1
         return
      endif

      rm = 0.0						!Defaults
      ierr = 0

      kxs = min(kx(1),kx(2))
      kxe = max(kx(1),kx(2))
      kys = min(ky(1),ky(2))
      kye = max(ky(1),ky(2))

      if ( kxs.gt.nx .or. kxe.lt.1 .or. kys.gt.ny
     +     .or. kye.lt.1 ) then
          ierr = 3
          return
      endif

      kxs = max(1,kxs)
      kxe = min(nx,kxe)
      kys = max(1,kys)
      kye = min(ny,kye)

      kn = (kxe-kxs+1)*(kye-kys+1)

      if ( kn.eq.1 ) then
         kv = kdata(kxs,kys)
         if ( kv.eq.inval ) then
            ierr = 3
            rm = 0.0
         else
            ierr = 2
            rm = kv
         endif
         return
      endif

      rm = 0.0

      ka = 0
      do k = kys, kye
         do j = kxs, kxe
            if ( kdata(j,k).ne.inval ) then
               ka = ka + 1
               iw(ka) = kdata(j,k)
            endif
         enddo
      enddo

      if ( ka.eq.0 ) then
         ierr = 3
      elseif ( ka.eq.1 ) then
         ierr = 2
         rm = iw(1)
      else
         call sort1i ( iw, ka )
         if ( (2*(ka/2)).eq.ka ) then
            k = (ka/2)
            rm = (real(iw(k)+iw(k+1)))/2.0
         else
            k = (ka/2) + 1
            rm = iw(k)
         endif
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="ranges"> RANGES  </a>-- Find mean, std dev of int*2 bad pixel flagged image section
C  It calcs the mean and std dev. Then recalcs (2 more times) using only
C  those points within 3 std dev of the calculated mean.
C  If the section is more than 80 on either side, a grid of points
C  is taken so that between 40 and 80 on a side is sampled.
C
C   alan penny             ral         1990 jan

      subroutine ranges ( kdata, nx, ny, kx, ky, inval, am, std, ierr )

      implicit none
      include 'STARMAN_INC'

      integer   nx		!i: X image size
      integer   ny		!i: Y image size
      integer*2 kdata(nx,ny)	!i: Image
      integer   kx(2)		!i: X range of image to use
      integer   ky(2)		!i: Y range of image to use
      integer   inval		!i: Image bad pixel value flag
      real      am		!o: Mean of image
      real      std		!o: Std Dev of image
      integer   ierr		!o: Error flag. 0=ok;1=all same;2=only
				!   one good point; 3=no good points
				!   (in sampling grid)
C--
      double precision s, ss, sn, an
      integer nxa, nya, kmin, kmax, kv, j, k, iter, kn,
     +        kxs, kxe, kys, kye
      real amax, amin
Cbegin


      if ( ST_FAILED ) then
         ierr = 1
         return
      endif

      am = 0.0						!Defaults
      std = 0.0
      ierr = 0

      kxs = min(kx(1),kx(2))
      kxe = max(kx(1),kx(2))
      kys = min(ky(1),ky(2))
      kye = max(ky(1),ky(2))

      if ( kxs.gt.nx .or. kxe.lt.1 .or. kys.gt.ny
     +     .or. kye.lt.1 ) then
          ierr = 3
          return
      endif

      kxs = max(1,kxs)
      kxe = min(nx,kxe)
      kys = max(1,kys)
      kye = min(ny,kye)

      nxa = 1 + (kxe-kxs)/80				!Get sampling step
      nya = 1 + (kye-kys)/80

      kmin = 32767					!Get max and min
      kmax = -32768					! (these are later used as limits)
      kn = 0
      do k = kys, kye, nya
         do j = kxs, kxe, nxa
            kv = kdata(j,k)
            if ( kv.ne.inval ) then
               kn = kn + 1
               kmin = min(kv,kmin)
               kmax = max(kv,kmax)
            endif
         enddo
      enddo

      ierr = 0	
      am = 0.0
      std = 0.0
      if ( kn.eq.0 ) then				!Check none good
         am = kmin
         ierr = 3
      elseif ( kn.eq.1 ) then				!Check more than 1
         am = kmin
         ierr = 2
      elseif ( kmin.ge.kmax ) then			!Check that not all same
         am = kmin
         ierr = 1
      endif
      if ( ierr.ne.0 ) return

      do iter = 1,3					!Do the calcs 3 times

         s = 0.0					!get mean and std dev
         sn = 0.0					! of good data within
         ss = 0.0					! the limits
         do k = kys, kye, nya
            do j = kxs, kxe, nxa
               kv = kdata(j,k)
               if ( kv.ne.inval .and. kv.ge.kmin .and.
     +              kv.le.kmax ) then
                  an = dble(kv)
                  s = s + an
                  ss = ss + an*an
                  sn = sn + 1.0d0
               endif
            enddo
         enddo
         if ( sn.gt.0.1 ) am = s/sn
         if ( sn.gt.1.1 ) then
            ss = (ss-s*s/sn)/(sn-1.0)
            if ( ss.gt.1.0e-20 ) std = sqrt(ss)
         endif

         amin = am - 3.0*std				!Get new limits
         amax = am + 3.0*std
         kmin = int(max(amin,real(kmin)))
         kmax = int(min(amax,real(kmax)))

      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="rano"> RANO  </a>-- Make random number between 0 and 1.
C   Takes machine supplied generator (RAN) and randomises it a bit more.
C
C   AJSEED should be called before this. If not treated as
C   call with seed set to 1.
C
C   On 1st use, the routine sets itself up, using many calls to the
C   machine random generator. After that, it calls machine generator
C   only once per call.
C
C     a j penny               ral                      88-07-04

      subroutine rano ( rv, iseed )

      implicit none
      include 'STARMAN_INC'

      real      rv		!o:   Random number
      integer	iseed		!i/o: Random number seed
C--
      real v(85), y, dum
      integer iff, j
      data iff / 0 /
      real ajran
      external ajran
Cbegin


      if ( ST_FAILED ) return

      rv = 1.0
      if ( iff.eq.0 ) then
         do j = 1, 85
            dum = ajran ( iseed )
            iff = 1
         enddo
         do j = 1, 85
            v(j) = ajran ( iseed )
         enddo
         y = ajran ( iseed )
      endif
      j = 1 + int(85.0*y)
      if ( j.gt.85 .or. j.lt.1 ) pause
      y = v(j)
      rv = y
      v(j) = ajran ( iseed )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="rinter"> RINTER  </a>-- (function) Interpolate in a two-dimensional look-up table.
C
C Input arguments
C
C        F  is an NX by NY array, where X=1.0, Y=1.0 refers to the center
C           of the first pixel and X=FLOAT(NX), Y=FLOAT(NY) refers to the
C           center of the last pixel.
C
C      X,Y  are the real coordinates of the point, relative to the corner
C           of the array, to which the table is to be interpolated.
C
C
C Output arguments
C
C   RINTER  is the numerical obtained by the interpolation.
C
C   DFDX,   are the estimated first spatial derivatives of F with
C   DFDY    respect to x and y, evaluated at (X, Y).
C
C The method used is cubic interpolation: first, at four integral
C values of y, the values of F at integral values of x are interpolated
C to the point x=X, yielding four values for the function and its first
C derivative with respect to x.  Then these four are interpolated to
C the point x,y=X,Y to give one functional value and one first
C derivative with respect to y.  Finally, the four first derivatives
C of F with respect to x are interpolated to x,y=X,Y.  It so happens
C that the final value obtained for the function and its derivatives
C would have come out the same if we had interpolated in y first,
C rather than in x.
C
C This has been modified to work on a 2-D (XY) plane in a 3-D (XYZ)
C cube. In the Z plane chosen, only a (sub)area is used.
C
C  P B STETSON                         DAO    1986
C  Modified by  A J PENNY          STScI              1987 jan 20
C


      real function rinter ( f, nxa, nya, nza, num, nx, ny, x, y, dfdx,
     +                       dfdy )


      implicit none

      integer nxa		!i: X size of input array
      integer nya		!i: Y size of input array
      integer nza		!i: Z size of input array
      real    f(nxa,nya,nza)	!i: Input array
      integer num		!i: Z plane of array to use
      integer nx		!i: X size useful data in that Z plane
      integer ny		!i: Y size useful data in that Z plane
      real    x			!i: X position
      real    y			!i: Y position
      real    dfdx		!o: Spatial derivative wrt X
      real    dfdy		!o: Spatial derivative wrt Y
C--
      integer ix, iy, i, j, k, ixn
      real dx, dy, val(-1:2), g(-1:2), dgdx(-1:2), dummy

      real cubint
      external cubint
      real acubint
      external acubint
Cbegin


C  Location

      ix = x
      iy = y
      dx = x - ix
      dy = y - iy

C  If outside box by 1 or more

      if ( iy.le.0 .or. iy.ge.ny+1 .or. ix.le.0. .or. ix.ge.nx+1 ) then
         rinter = 0.0
         dfdx = 0.0
         dfdy = 0.0
         return
      endif

C  If in body or not

      if ( ix.ge.2 .and. ix.le.nx-2 .and. iy.ge.2 .and. iy.le.ny-2 )then
         do i = -1, 2
            j = iy + i
            g(i) = cubint ( f(ix,j,num), dx, dgdx(i) )
         enddo
      else
         do i = -1, 2
            j = iy + i
            do k = -1, 2
               if ( j.lt.1 .or. j.gt.ny ) then
                  val(k) = 0.0
               else
                  ixn = ix + k
                  if ( ixn.lt.1 .or. ixn.gt.nx ) then
                     val(k) = 0.0
                  else
                     val(k) = f(ixn,j,num)
                  endif
               endif
            enddo
            g(i) = cubint ( val(0), dx, dgdx(i) )
         enddo
      endif

C  Calculate values

      rinter = cubint ( g(0), dy, dfdy )
      dfdx = cubint ( dgdx(0), dy, dummy )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="rsscale"> RSSCALE  </a>-- Scale a real array into an integer*2 array in range
C             0 - 255, from amin to amax
C
C   a j penny                 dao           1988-04-25

      subroutine rsscale ( rv, iv, n, rinval, amin, amax )

      implicit none
      include 'STARMAN_INC'

      integer	n		!i: No of points to do
      real	rv(n)		!i: Input array
      integer*2	iv(n)		!o: Output scaled array
      real	rinval		!i: Invalid pixel flag
      real	amin		!i: Bottom level to go to 0
      real	amax		!i: Top level to go to 255
C--
      real am, val, d
      integer k
Cbegin


      if ( ST_FAILED ) return

      am = amax
      if ( abs(amax-amin).lt.1.0e-3 ) am = amin + 1.0e-3
      d = am - amin
      do k = 1, n
         val = 127.0
         if ( rv(k).ne.rinval ) val = 255.0*(am-rv(k))/d
         iv(k) = min(max(val,1.0),255.0)
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="simulx"> SIMULX  </a>-- Solve the simultaneous equations   Y = A.X  for X
C This is taken from the AAO routine SIMULT, except that the
C arrays have been extended to allow for 100 unknowns and there
C is no separate work space for the coefficent matrix. There is
C also more out-of-range checking. The method is Gaussian
C back-substitution.
C
C      K F HARTLEY, A J PENNY  RGO    STAFF AAO            83-2-23

      subroutine simulx ( y, a, x, n )

      implicit none
      include 'STARMAN_INC'

      integer n        		!i:Size of vector arrays; matrix is N*N
      real    y(n)     		!i:Array of function values
      real    a(n,n) 		!i:Array of coefficents (destroyed in calcs)
      real    x(n)     		!o:Vectorix
C--
      integer row(100), col(100)
      integer ip, iq, i, j, ia, ja, ik, jk, np2, n50, k
      real amx, aminv, amaxv, afactor, factor
Cbegin


      if ( ST_FAILED ) return

      if ( n.gt.100 ) then
         call printo ( 'ERROR: Too many eqns for s/r SIMULX' )
         return
      endif

      do i = 1, n							!Preparation
         row(i) = i
         col(i) = i
         x(i) = y(i)
      enddo

      np2 = n + 2							!Successive reduction from n equations in n unknowns
      if ( n.ge.2 ) then							! to n-1 equations in n-1 unknowns

         do n50 = 2, n							!Already one equation in one unknown
            k = np2 - n50

            aminv = 1.0e-15						!Reduce equation set from k equations in k unknowns
            amaxv = 1.0e10						!to k-1 equations in k-1 unknowns

            ik = row(k)							!First find largest element for pivot
            jk = col(k)
            amx = a(ik,jk)
            ip = k
            iq = k
            do i = 1, k
               ik = row(i)
               if ( abs(x(ik)).gt.amaxv ) then
                  amaxv = abs(x(ik))
                  aminv = max(1.0e-15,1.0e-25*amaxv)
               endif
               do j = 1, k
                  jk = col(j)
                  if ( amx.lt.a(ik,jk) ) then
                     ip = i
                     iq = j
                     amx = a(ik,jk)
                  endif
               enddo
            enddo
            if ( abs(amx).lt.aminv ) amx = sign(aminv,amx)

            ik = row(ip)						!Now have largest element a(ip,iq)
            row(ip) = row(k)						! "Interchange" rows and columns
            row(k) = ik
            jk = col(iq)
            col(iq) = col(k)
            col(k) = jk

            do i = 1, k							!"Normalise" current equations in variable to be eliminated
               ia = row(i)
               x(ia) = x(ia)/amx
               do j = 1, k
                  ja = col(j)
                  a(ia,ja) = a(ia,ja)/amx
               enddo
            enddo

            do i = 1, k - 1						!Eliminate kth unknown
               ia = row(i)
               factor = a(ia,jk)
	       afactor = abs(factor)
               if ( afactor.lt.1.0e-8 ) factor = sign ( 1.0e-8, factor )
               if ( afactor.gt.1.0e8 )  factor = sign ( 1.0e8, factor )
               x(ia) = x(ia) - factor*x(ik)
               do j = 1, k - 1
                  ja = col(j)
                  a(ia,ja) = a(ia,ja) - factor*a(ik,ja)
               enddo
            enddo

         enddo

      endif

      ia = row(1)							!Find first solution
      ja = col(1)
      if ( abs(a(ia,ja)).lt.1.0e-20 ) a(ia,ja) = sign(1.0e-20,a(ia,ja))
      if ( abs(x(ia)).gt.1.0e10 ) x(ia) = sign(1.0e10,x(ia))
      x(ia) = x(ia)/a(ia,ja)

      if ( n.ge.2 ) then						!Substitute to find other solutions
         do i = 2, n
            ia = row(i)
            do j = 1, i-1
               ja = col(j)
               ik = row(j)
               if ( abs(x(ik)).gt.1.0e12 ) x(ik) = sign(1.0e12,x(ik))
               if ( abs(a(ia,ja)).gt.1.0e12 ) a(ia,ja) =
     +                                        sign(1.0e12,a(ia,ja))
               x(ia) = x(ia) - a(ia,ja)*x(ik)
            enddo
         enddo
      endif

      do i = 1, n							!Put results in correct order
         a(i,1) = x(i)
      enddo
      do i = 1, n
         ia = row(i)
         ja = col(i)
         x(ja) = a(ia,1)
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="smoothr"> SMOOTHR  </a>-- Smooth a real array with a rectangular 'local mean' filter
C  Smooth each line by running a local mean filter through it. Store the
C  result in workspace, then repeat the process down the image columns.
C
C  Taken from EDRS of R Warren-Smith
C  alan penny                  ral                  1990-05-022

      subroutine smoothr ( ia, nx, ny, ix, iy, nmin,
     +                     istor, nstor, iline, nline )

      implicit none
      include 'STARMAN_INC'

      integer   nx			!i: X size of array
      integer   ny			!i: Y size of array
      real	ia(nx,ny)		!i/o: Array
      integer   ix			!i: X size of smoothing rectangle
      integer   iy			!i: Y size of smoothing rectangle
      integer   nmin			!i: Min no of valid pixels required in
					!   smoothing area
      real	istor(nx,ny)		!w: Workspace
      integer	nstor(nx,ny)		!w: Workspace
      real	iline(nx)		!w: Workspace
      integer   nline(nx)		!w: Workspace
C--
      integer oldx, newx, oldy, newy, thresh, nx2, ny2, idx, idy,
     +        iside, jside, i, ii, j, jj, nsum
      real sum
Cbegin


      if ( ST_FAILED ) return

      nx2 = 2*nx
      ny2 = 2*ny

      idx = max(0,ix/2)							!Make box sizes next largest odd number and positive
      iside = 2*idx+1
      idy = max(0,iy/2)
      jside = 2*idy+1

      thresh = min(max(1,nmin),iside*jside)				!Set threshold for no. of good pixels
									! in box between 1 and max possible number

      do j = 1, ny							!First smooth along each line
									!----------------------------

	 sum = 0.0							!initiallise running sum of data (isum) and no. of
	 nsum = 0 							! good pixels (nsum)

	 do ii = -idx, idx						!Start with box size iside*1 centred on pixel (0,j)
	    i = ii

            if ( i.lt.1 ) i = 2 - i					!Box will project off ends of lines,
	    if ( i.gt.nx )  i = nx2 - i					! so reflect to keep it inside


            i = min(max(1,i),nx)					!Protect against extreme cases where box is so big it
									! goes off opposite end after reflection

            sum = sum + ia(i,j)					! it to sum of pixels within box
            nsum = nsum + 1

         enddo

         do i = 1, nx							!Now step the box along the line

	    oldx = i - idx - 1						!Find position of old pixel to be removed from left
	    newx = i + idx						! and new pixel to be added at right

	    if ( oldx.lt.1 ) oldx = 2 - oldx				!Reflect at ends of line
            if ( oldx.gt.nx ) oldx = nx2 - oldx
            oldx = min(max(1,oldx),nx)
            if ( newx.lt.1 ) newx = 2-newx
            if ( newx.gt.nx ) newx = nx2-newx
            newx = min(max(1,newx),nx)

            sum = sum - ia(oldx,j)
            nsum = nsum - 1

            sum = sum + ia(newx,j)
            nsum = nsum + 1

            istor(i,j) = sum						!store sums along line in workspace
            nstor(i,j) = nsum

         enddo

      enddo
									!Now smooth down columns
									!-----------------------

      do i = 1, nx							!Initiallise sums.. this time
         iline(i) = 0.0							! processing a whole line at once
         nline(i) = 0
      enddo

      do jj = -idy, idy							!Sum over a box of size 1*jside centred on pixel (i,0),
         j = jj								! where i scans along whole line

         if ( j.lt.1 ) j = 2 - j					!Reflect at top and bottom of image
         if ( j.gt.ny ) j = ny2 - j
         j = min(max(1,j),ny)

         do i = 1, nx							!Form a sum for each pixel in the line from the
            iline(i) = iline(i) + istor(i,j)				! data now stored in the workspace
            nline(i) = nline(i) + nstor(i,j)
         enddo

      enddo

      do j = 1, ny							!Now step down the image

         oldy = j- idy - 1						!Find location of old line to subtract at top
         newy = j + idy							! and new line to add at bottom

         if ( oldy.lt.1 ) oldy = 2 - oldy				!Reflect at top and bottom of image
         if ( oldy.gt.ny ) oldy = ny2 - oldy
         oldy = min(max(1,oldy),ny)
         if ( newy.lt.1 ) newy = 2 - newy
         if ( newy.gt.ny ) newy = ny2 - newy
         newy = min(max(1,newy),ny)

         do i = 1, nx							!Take off old line
            iline(i) = iline(i) - istor(i,oldy)
            nline(i) = nline(i) - nstor(i,oldy)

            iline(i) = iline(i) + istor(i,newy)				!Add new line
            nline(i) = nline(i) + nstor(i,newy)

            if ( nline(i).ge.thresh ) then				!If sufficient pixels present, form
               ia(i,j) = iline(i)/real(nline(i))			! output, otherwise output is not valid
            else
               ia(i,j) = 0.0
            endif
         enddo

      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="smoothbr"> SMOOTHBR  </a>-- Smooth a real flagged array with rectangular 'local mean' filter
C  Smooth each line by running a local mean filter through it. Store the
C  result in workspace, then repeat the process down the image columns. Take
C  account of invalid pixels.
C
C  Taken from EDRS of R Warren-Smith
C  alan penny                  ral                  1990-05-022

      subroutine smoothbr ( ra, nx, ny, rinval, ix, iy, nmin,
     +			    ristor, rnstor, riline, rnline )

      implicit none
      include 'STARMAN_INC'

      integer   nx			!i: X size of array
      integer   ny			!i: Y size of array
      real      ra(nx,ny)		!i/o: Array
      real      rinval			!i: Invalid pixel magic value flag
      integer   ix			!i: X size of smoothing rectangle
      integer   iy			!i: Y size of smoothing rectangle
      integer   nmin			!i: Min no of valid pixels required
					!   in smoothing area
      real      ristor(nx,ny)		!w: Workspace
      real      rnstor(nx,ny)		!w: Workspace
      real      riline(nx)		!w: Workspace
      real      rnline(nx)		!w: Workspace
C--
      integer oldx, newx, oldy, newy, thresh, nx2, ny2, idx, idy,
     +        iside, jside, i, ii, j, jj
      real sum, rnsum
Cbegin


      if ( ST_FAILED ) return

      nx2 = 2*nx
      ny2 = 2*ny

      idx = max(0,ix/2)							!Make box sizes next largest odd number and positive
      iside = 2*idx+1
      idy = max(0,iy/2)
      jside = 2*idy+1

      thresh = min(max(1,nmin),iside*jside)				!Set threshold for no. of good pixels
									! in box between 1 and max possible number

      do j = 1, ny							!First smooth along each line
									!----------------------------

	 sum = 0.0							!initiallise running sum of data (isum) and no. of
	 rnsum = 0.0 							! good pixels (nsum)

	 do ii = -idx, idx						!Start with box size iside*1 centred on pixel (0,j)
	    i = ii

            if ( i.lt.1 ) i = 2 - i					!Box will project off ends of lines,
	    if ( i.gt.nx )  i = nx2 - i					! so reflect to keep it inside


            i = min(max(1,i),nx)					!Protect against extreme cases where box is so big it
									! goes off opposite end after reflection

            if ( ra(i,j).ne.rinval ) then				!If pixel found is valid, add
               sum = sum + ra(i,j)					! it to sum of pixels within box
               rnsum = rnsum + 1.0
            endif

         enddo

         do i = 1, nx							!Now step the box along the line

	    oldx = i - idx - 1						!Find position of old pixel to be removed from left
	    newx = i + idx						! and new pixel to be added at right

	    if ( oldx.lt.1 ) oldx = 2 - oldx				!Reflect at ends of line
            if ( oldx.gt.nx ) oldx = nx2 - oldx
            oldx = min(max(1,oldx),nx)
            if ( newx.lt.1 ) newx = 2-newx
            if ( newx.gt.nx ) newx = nx2-newx
            newx = min(max(1,newx),nx)

            if ( ra(oldx,j).ne.rinval ) then				!If old pixel is valid, subtract from sums
               sum = sum - ra(oldx,j)
               rnsum = rnsum - 1.0
            endif

	    if ( ra(newx,j).ne.rinval ) then				!If new pixel is valid, add to sums
	       sum = sum + ra(newx,j)
	       rnsum = rnsum + 1.0
	    endif

            ristor(i,j) = sum						!store sums along line in workspace
            rnstor(i,j) = rnsum

         enddo

      enddo
									!Now smooth down columns
									!-----------------------

      do i = 1, nx							!Initiallise sums.. this time
         riline(i) = 0.0						! processing a whole line at once
         rnline(i) = 0.0
      enddo

      do jj = -idy, idy							!Sum over a box of size 1*jside centred on pixel (i,0),
         j = jj								! where i scans along whole line

         if ( j.lt.1 ) j = 2 - j					!Reflect at top and bottom of image
         if ( j.gt.ny ) j = ny2 - j
         j = min(max(1,j),ny)

         do i = 1, nx							!Form a sum for each pixel in the line from the
            riline(i) = riline(i) + ristor(i,j)				! data now stored in the workspace
            rnline(i) = rnline(i) + rnstor(i,j)
         enddo

      enddo

      do j = 1, ny							!Now step down the image

         oldy = j - idy - 1						!Find location of old line to subtract at top
         newy = j + idy							! and new line to add at bottom

         if ( oldy.lt.1 ) oldy = 2 - oldy				!Reflect at top and bottom of image
         if ( oldy.gt.ny ) oldy = ny2 - oldy
         oldy = min(max(1,oldy),ny)
         if ( newy.lt.1 ) newy = 2 - newy
         if ( newy.gt.ny ) newy = ny2 - newy
         newy = min(max(1,newy),ny)

         do i = 1, nx							!Take off old line
            riline(i) = riline(i) - ristor(i,oldy)
            rnline(i) = rnline(i) - rnstor(i,oldy)

            riline(i) = riline(i) + ristor(i,newy)			!Add new line
            rnline(i) = rnline(i) + rnstor(i,newy)

            if ( rnline(i).ge.thresh ) then				!If sufficient pixels present, form
               ra(i,j) = riline(i)/rnline(i)				! output, otherwise output is not valid
            else
               ra(i,j) = rinval
            endif
         enddo

      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="smoothbs"> SMOOTHBS  </a>-- Smooth a int*2 flagged array with rectangular 'local mean' filter
C  Smooth each line by running a local mean filter through it. Store the
C  result in workspace, then repeat the process down the image columns. Take
C  account of invalid pixels.
C
C  Taken from EDRS of R Warren-Smith
C  alan penny                  ral                  1990-05-022

      subroutine smoothbs ( ia, nx, ny, inval, ix, iy, nmin,
     +			    ristor, rnstor, riline, rnline )

      implicit none
      include 'STARMAN_INC'

      integer   nx			!i: X size of array
      integer   ny			!i: Y size of array
      integer*2 ia(nx,ny)		!i/o: Array
      integer   inval			!i: Invalid pixel magic value flag
      integer   ix			!i: X size of smoothing rectangle
      integer   iy			!i: Y size of smoothing rectangle
      integer   nmin			!i: Min no of valid pixels required
					!   in smoothing area
      real      ristor(nx,ny)		!w: Workspace
      real      rnstor(nx,ny)		!w: Workspace
      real      riline(nx)		!w: Workspace
      real      rnline(nx)		!w: Workspace
C--
      integer oldx, newx, oldy, newy, thresh, nx2, ny2, idx, idy,
     +        iside, jside, i, ii, j, jj
      real sum, rnsum
Cbegin


      if ( ST_FAILED ) return

      nx2 = 2*nx
      ny2 = 2*ny

      idx = max(0,ix/2)							!Make box sizes next largest odd number and positive
      iside = 2*idx+1
      idy = max(0,iy/2)
      jside = 2*idy+1

      thresh = min(max(1,nmin),iside*jside)				!Set threshold for no. of good pixels
									! in box between 1 and max possible number

      do j = 1, ny							!First smooth along each line
									!----------------------------

	 sum = 0.0							!initiallise running sum of data (isum) and no. of
	 rnsum = 0.0 							! good pixels (nsum)

	 do ii = -idx, idx						!Start with box size iside*1 centred on pixel (0,j)
	    i = ii

            if ( i.lt.1 ) i = 2 - i					!Box will project off ends of lines,
	    if ( i.gt.nx )  i = nx2 - i					! so reflect to keep it inside


            i = min(max(1,i),nx)					!Protect against extreme cases where box is so big it
									! goes off opposite end after reflection

            if ( ia(i,j).ne.inval ) then				!If pixel found is valid, add
               sum = sum + ia(i,j)					! it to sum of pixels within box
               rnsum = rnsum + 1.0
            endif

         enddo

         do i = 1, nx							!Now step the box along the line

	    oldx = i - idx - 1						!Find position of old pixel to be removed from left
	    newx = i + idx						! and new pixel to be added at right

	    if ( oldx.lt.1 ) oldx = 2 - oldx				!Reflect at ends of line
            if ( oldx.gt.nx ) oldx = nx2 - oldx
            oldx = min(max(1,oldx),nx)
            if ( newx.lt.1 ) newx = 2-newx
            if ( newx.gt.nx ) newx = nx2-newx
            newx = min(max(1,newx),nx)

            if ( ia(oldx,j).ne.inval ) then				!If old pixel is valid, subtract from sums
               sum = sum - ia(oldx,j)
               rnsum = rnsum - 1.0
            endif

	    if ( ia(newx,j).ne.inval ) then				!If new pixel is valid, add to sums
	       sum = sum + ia(newx,j)
	       rnsum = rnsum + 1.0
	    endif

            ristor(i,j) = sum						!store sums along line in workspace
            rnstor(i,j) = rnsum

         enddo

      enddo
									!Now smooth down columns
									!-----------------------

      do i = 1, nx							!Initiallise sums.. this time
         riline(i) = 0.0						! processing a whole line at once
         rnline(i) = 0.0
      enddo

      do jj = -idy, idy							!Sum over a box of size 1*jside centred on pixel (i,0),
         j = jj								! where i scans along whole line

         if ( j.lt.1 ) j = 2 - j					!Reflect at top and bottom of image
         if ( j.gt.ny ) j = ny2 - j
         j = min(max(1,j),ny)

         do i = 1, nx							!Form a sum for each pixel in the line from the
            riline(i) = riline(i) + ristor(i,j)				! data now stored in the workspace
            rnline(i) = rnline(i) + rnstor(i,j)
         enddo

      enddo

      do j = 1, ny							!Now step down the image

         oldy = j - idy - 1						!Find location of old line to subtract at top
         newy = j + idy							! and new line to add at bottom

         if ( oldy.lt.1 ) oldy = 2 - oldy				!Reflect at top and bottom of image
         if ( oldy.gt.ny ) oldy = ny2 - oldy
         oldy = min(max(1,oldy),ny)
         if ( newy.lt.1 ) newy = 2 - newy
         if ( newy.gt.ny ) newy = ny2 - newy
         newy = min(max(1,newy),ny)

         do i = 1, nx							!Take off old line
            riline(i) = riline(i) - ristor(i,oldy)
            rnline(i) = rnline(i) - rnstor(i,oldy)

            riline(i) = riline(i) + ristor(i,newy)			!Add new line
            rnline(i) = rnline(i) + rnstor(i,newy)

            if ( rnline(i).ge.thresh ) then				!If sufficient pixels present, form
               ia(i,j) = riline(i)/rnline(i)				! output, otherwise output is not valid
            else
               ia(i,j) = inval
            endif
         enddo

      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="sort1i"> SORT1I  </a>-- Sort of an integer vector
C  Depending on the number of values, calls the fastest
C  routine. Works on integers, into ascending order.
C
C    a j penny      ral                     1988-07-01

      subroutine sort1i ( ia, n )

      implicit none
      include 'STARMAN_INC'

      integer	n		!i:   No of numbers to do
      integer	ia(n)		!i/o: Numbers to be sorted
C--
Cbegin


      if ( ST_FAILED ) return

      if ( n.lt.50 ) then
         call srt1pi ( ia, n )		! Straight insertion
      else if ( n.lt.1000 ) then
         call srt1si ( ia, n )		! Shell's method
      else
         call srt1hi ( ia, n )		! Heap sort
      endif

      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="sort1r"> SORT1R  </a>-- Sort of a real vector
C  Depending on the number of values, calls the fastest
C  routine. Works on reals, into ascending order.
C
C    a j penny      ral                     1988-07-01

      subroutine sort1r ( a, n )

      implicit none
      include 'STARMAN_INC'

      integer	n		!i:   No of numbers to do
      real 	a(n)		!i/o: Numbers to be sorted
C--
Cbegin


      if ( ST_FAILED ) return

      if ( n.lt.50 ) then
         call srt1pr ( a, n )		! Straight insertion
      else if ( n.lt.1000 ) then
         call srt1sr ( a, n )		! Shell's method
      else
         call srt1hr ( a, n )		! Heap sort
      endif

      end



CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="sort2i"> SORT2I  </a>-- Sort of one integer array, with alignment of another
C          Depending on the number of values, calls the fastest
C          routine. Works on integers, into ascending order.
C
C    a j penny      ral                     1988-07-01

      subroutine sort2i ( ia, ib, n )

      implicit none
      include 'STARMAN_INC'

      integer	n		!i:   No of numbers to do
      integer	ia(n)		!i/o: Numbers to be sorted
      integer	ib(n)		!i/o: Numbers to follow ia
C--
Cbegin


      if ( ST_FAILED ) return

      if ( n.lt.50 ) then
         call srt2pi ( ia, ib, n )		! Straight insertion
      else if ( n.lt.1000 ) then
         call srt2si ( ia, ib, n )		! Shell's method
      else
         call srt2hi ( ia, ib, n )		! Heap sort
      endif

      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="sort2r"> SORT2R  </a>-- Sort of one real array, with alignment of another
C           Depending on the number of values, calls the fastest
C           routine. Works on reals, into ascending order.
C
C    a j penny      ral                     1988-07-01

      subroutine sort2r ( a, b, n )

      implicit none
      include 'STARMAN_INC'

      integer	n		!i:   No of numbers to do
      real 	a(n)		!i/o: Numbers to be sorted
      real	b(n)		!i/o: Numbers to follow ia
C--
Cbegin


      if ( ST_FAILED ) return

      if ( n.lt.50 ) then
         call srt2pr ( a, b, n )		! Straight insertion
      else if ( n.lt.1000 ) then
         call srt2sr ( a, b, n )		! Shell's method
      else
         call srt2hr ( a, b, n )		! Heap sort
      endif

      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="srt1hi"> SRT1HI  </a>-- Heapsort to sort integers into ascending order
C
C   a j penny                 dao           1988-04-25

      subroutine srt1hi ( ia, n )

      implicit none
      include 'STARMAN_INC'

      integer	n		!i:   No of numbers to do
      integer	ia(n)		!i/o: Numbers to be sorted
C--
      integer l, ir, iia, i, j
      logical loop
Cbegin


      if ( ST_FAILED ) return

      l = n/2 + 1
      ir = n
      do while ( .true. )
         if ( l.gt.1 ) then
            l = l - 1
            iia = ia(l)
         else
            iia = ia(ir)
            ia(ir) = ia(1)
            ir =ir - 1
            if ( ir.eq.1 ) then
               ia(1) = iia
               return
            endif
         endif
         i = l
         j = l + l
         loop = .true.
         do while ( loop )
            if ( j.le.ir ) then
               if ( j.lt.ir ) then
                  if ( ia(j).lt.ia(j+1) ) j = j + 1
               endif
               if ( iia.lt.ia(j) ) then
                  ia(i) = ia(j)
                  i = j
                  j = j + j
               else
                  j = ir + 1
               endif
            else
               loop = .false.
               ia(i) = iia
            endif
         enddo
      enddo


      end



CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="srt1hr"> SRT1HR  </a>-- Heapsort to sort reals into ascending order
C
C   a j penny                 dao           1988-04-25

      subroutine srt1hr ( a, n )

      implicit none
      include 'STARMAN_INC'

      integer	n		!i:   No of numbers to do
      real	a(n)		!i/o: Numbers to be sorted
C--
      integer l, ir, i, j
      real ra
      logical loop
Cbegin


      if ( ST_FAILED ) return

      l = n/2 + 1
      ir = n
      do while ( .true. )
         if ( l.gt.1 ) then
            l = l - 1
            ra = a(l)
         else
            ra = a(ir)
            a(ir) = a(1)
            ir =ir - 1
            if ( ir.eq.1 ) then
               a(1) = ra
               return
            endif
         endif
         i = l
         j = l + l
         loop = .true.
         do while ( loop )
            if ( j.le.ir ) then
               if ( j.lt.ir ) then
                  if ( a(j).lt.a(j+1) ) j = j + 1
               endif
               if ( ra.lt.a(j) ) then
                  a(i) = a(j)
                  i = j
                  j = j + j
               else
                  j = ir + 1
               endif
            else
               loop = .false.
               a(i) = ra
            endif
         enddo
      enddo


      end




CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="srt1pi"> SRT1PI  </a>-- Straight insertion sort to sort integers into ascending order
C
C   a j penny                 dao           1988-04-25

      subroutine srt1pi ( ia, n )

      implicit none
      include 'STARMAN_INC'

      integer	n		!i:   No of numbers to do
      integer	ia(n)		!i/o: Numbers to be sorted
C--
      integer i, j
      integer ja
Cbegin


      if ( ST_FAILED ) return

      do j = 2, n
         ja = ia(j)
         i = j - 1
         do while ( i.ge.1 .and. ia(i).gt.ja )
            ia(i+1) = ia(i)
            i = i - 1
         enddo
         ia(i+1) = ja
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="srt1pr"> SRT1PR  </a>-- Straight insertion sort to sort reals into ascending order
C
C   a j penny                 dao           1988-04-25

      subroutine srt1pr ( a, n )

      implicit none
      include 'STARMAN_INC'

      integer	n		!i:   No of numbers to do
      real	a(n)		!i/o: Numbers to be sorted
C--
      integer i, j
      real ra
Cbegin


      if ( ST_FAILED ) return

      do j = 2, n
         ra = a(j)
         i = j - 1
         do while ( i.ge.1 .and. a(i).gt.ra )
            a(i+1) = a(i)
            i = i - 1
         enddo
         a(i+1) = ra
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="srt1si"> SRT1SI  </a>-- Shell's method insertion to sort integers into ascending order
C
C   a j penny                 dao           1988-04-25

      subroutine srt1si ( ia, n )

      implicit none
      include 'STARMAN_INC'

      integer	n		!i:   No of numbers to do
      integer	ia(n)		!i/o: Numbers to be sorted
C--
      integer i, j, k, lognb2, m, l, nn
      real it, aln2i, tiny
      parameter ( aln2i=1.0/0.69314718 )
      parameter ( tiny=1.0e-5 )
Cbegin


      if ( ST_FAILED ) return

      lognb2 = int(alog(real(n)*aln2i+tiny))
      m = n
      do nn = 1, lognb2
         m = m/2
         k = n - m
         do j = 1, k
            i = j
            l = i + m
            do while ( i.ge.1 .and. ia(l).lt.ia(i) )
               it = ia(i)
               ia(i) = ia(l)
               ia(l) = it
               i = i - m
               l = i + m
            enddo
         enddo
      enddo


      end



CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="srt1sr"> SRT1SR  </a>-- Shell's method insertion to sort reals into ascending order
C
C   a j penny                 dao           1988-04-25

      subroutine srt1sr ( a, n )

      implicit none
      include 'STARMAN_INC'

      integer	n		!i:   No of numbers to do
      real	a(n)		!i/o: Numbers to be sorted
C--
      integer i, j, k, lognb2, m, l, nn
      real t, aln2i, tiny
      parameter ( aln2i=1.0/0.69314718 )
      parameter ( tiny=1.0e-5 )
Cbegin


      if ( ST_FAILED ) return

      lognb2 = int(alog(real(n)*aln2i+tiny))
      m = n
      do nn = 1, lognb2
         m = m/2
         k = n - m
         do j = 1, k
            i = j
            l = i + m
            do while ( i.ge.1 .and. a(l).lt.a(i) )
               t = a(i)
               a(i) = a(l)
               a(l) = t
               i = i - m
               l = i + m
            enddo
         enddo
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="srt2hi"> SRT2HI  </a>-- Heapsort to sort integers with alignment of another array
C (ascending order)
C
C   a j penny                 dao           1988-04-25

      subroutine srt2hi ( ia, ib, n )

      implicit none
      include 'STARMAN_INC'

      integer	n		!i:   No of numbers to do
      integer	ia(n)		!i/o: Numbers to be sorted
      integer	ib(n)		!i/o: Numbers to follow ia
C--
      integer l, ir, iia, iib, i, j
      logical loop
Cbegin


      if ( ST_FAILED ) return

      l = n/2 + 1
      ir = n
      do while ( .true. )
         if ( l.gt.1 ) then
            l = l - 1
            iia = ia(l)
            iib = ib(l)
         else
            iia = ia(ir)
            iib = ib(ir)
            ia(ir) = ia(1)
            ib(ir) = ib(1)
            ir =ir - 1
            if ( ir.eq.1 ) then
               ia(1) = iia
               ib(1) = iib
               return
            endif
         endif
         i = l
         j = l + l
         loop = .true.
         do while ( loop )
            if ( j.le.ir ) then
               if ( j.lt.ir ) then
                  if ( ia(j).lt.ia(j+1) ) j = j + 1
               endif
               if ( iia.lt.ia(j) ) then
                  ia(i) = ia(j)
                  ib(i) = ib(j)
                  i = j
                  j = j + j
               else
                  j = ir + 1
               endif
            else
               loop = .false.
               ia(i) = iia
               ib(i) = iib
            endif
         enddo
      enddo


      end



CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="srt2hr"> SRT2HR  </a>-- Heapsort to sort real array with alignment of another array
C   (ascending order)
C
C   a j penny                 dao           1988-04-25

      subroutine srt2hr ( a, b, n )

      implicit none
      include 'STARMAN_INC'

      integer	n		!i:   No of numbers to do
      real	a(n)		!i/o: Numbers to be sorted
      real	b(n)		!i/o: Numbers to follow a
C--
      integer l, ir, i, j
      real ra, rb
      logical loop
Cbegin


      if ( ST_FAILED ) return

      l = n/2 + 1
      ir = n
      do while ( .true. )
         if ( l.gt.1 ) then
            l = l - 1
            ra = a(l)
            rb = b(l)
         else
            ra = a(ir)
            rb = b(ir)
            a(ir) = a(1)
            b(ir) = b(1)
            ir =ir - 1
            if ( ir.eq.1 ) then
               a(1) = ra
               b(1) = rb
               return
            endif
         endif
         i = l
         j = l + l
         loop = .true.
         do while ( loop )
            if ( j.le.ir ) then
               if ( j.lt.ir ) then
                  if ( a(j).lt.a(j+1) ) j = j + 1
               endif
               if ( ra.lt.a(j) ) then
                  a(i) = a(j)
                  b(i) = b(j)
                  i = j
                  j = j + j
               else
                  j = ir + 1
               endif
            else
               loop = .false.
               a(i) = ra
               b(i) = rb
            endif
         enddo
      enddo


      end




CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="srt2pi"> SRT2PI  </a>-- Straight insertion sort of int array with alignment of another
C    (ascending order)
C
C   a j penny                 dao           1988-04-25

      subroutine srt2pi ( ia, ib, n )

      implicit none
      include 'STARMAN_INC'

      integer	n		!i:   No of numbers to do
      integer	ia(n)		!i/o: Numbers to be sorted
      integer	ib(n)		!i/o: Numbers to follow a
C--
      integer i, j
      integer ja, jb
Cbegin


      if ( ST_FAILED ) return

      do j = 2, n
         ja = ia(j)
         jb = ib(j)
         i = j - 1
         do while ( i.ge.1 .and. ia(i).gt.ja )
            ia(i+1) = ia(i)
            ib(i+1) = ib(i)
            i = i - 1
         enddo
         ia(i+1) = ja
         ib(i+1) = jb
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="srt2pr"> SRT2PR  </a>-- Straight insertion sort of real array  with alignment of another
C    (ascending order)
C
C   a j penny                 dao           1988-04-25

      subroutine srt2pr ( a, b, n )

      implicit none
      include 'STARMAN_INC'

      integer	n		!i:   No of numbers to do
      real	a(n)		!i/o: Numbers to be sorted
      real	b(n)		!i/o: Numbers to follow a
C--
      integer i, j
      real ra, rb
Cbegin


      if ( ST_FAILED ) return

      do j = 2, n
         ra = a(j)
         rb = b(j)
         i = j - 1
         do while ( i.ge.1 .and. a(i).gt.ra )
            a(i+1) = a(i)
            b(i+1) = b(i)
            i = i - 1
         enddo
         a(i+1) = ra
         b(i+1) = rb
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="srt2si"> SRT2SI  </a>-- Shell's method insertion sort to sort integer array
C     (ascending order) with alignment of another array
C
C   a j penny                 dao           1988-04-25

      subroutine srt2si ( ia, ib, n )

      implicit none
      include 'STARMAN_INC'

      integer	n		!i:   No of numbers to do
      integer	ia(n)		!i/o: Numbers to be sorted
      integer	ib(n)		!i/o: Numbers to follow a
C--
      integer i, j, k, lognb2, m, l, nn
      real it, aln2i, tiny
      parameter ( aln2i=1.0/0.69314718 )
      parameter ( tiny=1.0e-5 )
Cbegin


      if ( ST_FAILED ) return

      lognb2 = int(alog(real(n))*aln2i+tiny)
      m = n
      do nn = 1, lognb2
         m = m/2
         k = n - m
         do j = 1, k
            i = j
            l = i + m
            do while ( i.ge.1 .and. ia(l).lt.ia(i) )
               it = ia(i)
               ia(i) = ia(l)
               ia(l) = it
               it = ib(i)
               ib(i) = ib(l)
               ib(l) = it
               i = i - m
               l = i + m
            enddo
         enddo
      enddo


      end



CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="srt2sr"> SRT2SR  </a>-- Shell's method insertion to sort real array
C    (ascending order) with alignment of another array
C
C   a j penny                 dao           1988-04-25

      subroutine srt2sr ( a, b, n )

      implicit none
      include 'STARMAN_INC'

      integer	n		!i:   No of numbers to do
      real	a(n)		!i/o: Numbers to be sorted
      real	b(n)		!i/o: Numbers to follow a
C--
      integer i, j, k, lognb2, m, l, nn
      real t, aln2i, tiny
      parameter ( aln2i=1.0/0.69314718 )
      parameter ( tiny=1.0e-5 )
Cbegin


      if ( ST_FAILED ) return

      lognb2 = int(alog(real(n))*aln2i+tiny)
      m = n
      do nn = 1, lognb2
         m = m/2
         k = n - m
         do j = 1, k
            i = j
            l = i + m
            do while ( i.ge.1 .and. a(l).lt.a(i) )
               t = a(i)
               a(i) = a(l)
               a(l) = t
               t = b(i)
               b(i) = b(l)
               b(l) = t
               i = i - m
               l = i + m
            enddo
         enddo
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="st_minmax"> ST_MINMAX  </a>-- Get max and min of flagged area of array
C
C  alan penny                ral                      1990-06-15

      subroutine st_minmax ( im, nx, ny, bs, bz, gtype, inval, rinval,
     +               nxs, nxe, nys, nye, amin, amax, kp, ngood, nbad )

      implicit none

      integer	nx		!i: Image X size
      integer	ny		!i: Image Y size
      integer*2 im(*)		!i: Image
      real	bs		!i: Image pixel value scale
      real	bz		!i: Image pixel value zero
      character*(*) gtype	!i: Image type ('REAL', 'SHORT' )
      integer	inval		!i: Integer*2 Image pixel value invalid flag
      real      rinval		!i: Real Image pixel value invalid flag
      integer	nxs		!i: Area X start
      integer	nxe		!i: Area Y end
      integer	nys		!i: Area X start
      integer	nye		!i: Area Y end
      real	amin		!o: Minimum value (scaled,zeroed)
      real	amax		!o: Maximum value (scaled,zeroed)
      integer   kp(4)		!o: Locations of min, max (x,y;x,y)
      integer	ngood		!o: Number of valid pixels
      integer	nbad		!o: Number of invalid pixels
C--
Cbegin


      if ( gtype.eq.'SHORT' ) then
         call st_minmaxs ( im, nx, ny, bs, bz, inval, nxs, nxe,
     +                     nys, nye, amin, amax, kp, ngood, nbad )
      else
         call st_minmaxr ( im, nx, ny, bs, bz, rinval, nxs, nxe,
     +                     nys, nye, amin, amax, kp, ngood, nbad )
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="st_minmaxr"> ST_MINMAXR  </a>-- Get max and min of flagged area of real array
C
C  alan penny                ral                      1990-06-15

      subroutine st_minmaxr ( im, nx, ny, bs, bz, rinval,
     +               nxs, nxe, nys, nye, amin, amax, kp, ngood, nbad )

      implicit none

      integer	nx		!i: Image X size
      integer	ny		!i: Image Y size
      real      im(nx,ny)	!i: Image
      real	bs		!i: Image pixel value scale
      real	bz		!i: Image pixel value zero
      real      rinval		!i: Image pixel value invalid flag
      integer	nxs		!i: Area X start
      integer	nxe		!i: Area Y end
      integer	nys		!i: Area X start
      integer	nye		!i: Area Y end
      real	amin		!o: Minimum value (scaled,zeroed)
      real	amax		!o: Maximum value (scaled,zeroed)
      integer   kp(4)		!o: Locations of min, max (x,y;x,y)
      integer	ngood		!o: Number of valid pixels
      integer	nbad		!o: Number of invalid pixels
C--
      integer j, k, knxs, knxe, knys, knye, iv
      real    rv
Cbegin


      amax = -1.0e20
      amin = 1.0e20
      call azeroi ( kp, 4 )
      ngood = 0
      nbad = 0

      knxs = max(1,min(nx,nxs))
      knxe = max(1,min(nx,nxe))
      knys = max(1,min(ny,nys))
      knye = max(1,min(ny,nye))
      call cswopi ( knxs, knxe )
      call cswopi ( knys, knye )

      do k = knys, knye
         do j = knxs, knxe
            rv = im(j,k)
            if ( rv.ne.rinval ) then
               ngood = ngood + 1
               if ( rv.gt.amax ) then
                  amax = rv
                  kp(3) = j
                  kp(4) = k
               endif
               if ( rv.lt.amin ) then
                  amin = rv
                  kp(1) = j
                  kp(2) = k
               endif
            else
               nbad = nbad + 1
            endif
         enddo
      enddo

      amax = amax*bs + bz
      amin = amin*bs + bz
      if ( amin.gt.amax ) then
         rv = amin
         amin = amax
         amax = rv
         iv = kp(3)
         kp(3) = kp(1)
         kp(1) = iv
         iv = kp(4)
         kp(4) = kp(2)
         kp(2) = iv
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="st_minmaxs"> ST_MINMAXS  </a>-- Get max and min of flagged area of array
C
C  alan penny                ral                      1990-06-15

      subroutine st_minmaxs ( im, nx, ny, bs, bz, inval,
     +               nxs, nxe, nys, nye, amin, amax, kp, ngood, nbad )

      implicit none

      integer	nx		!i: Image X size
      integer	ny		!i: Image Y size
      integer*2 im(nx,ny)	!i: Image
      real	bs		!i: Image pixel value scale
      real	bz		!i: Image pixel value zero
      integer	inval		!i: Image pixel value invalid flag
      integer	nxs		!i: Area X start
      integer	nxe		!i: Area Y end
      integer	nys		!i: Area X start
      integer	nye		!i: Area Y end
      real	amin		!o: Minimum value (scaled,zeroed)
      real	amax		!o: Maximum value (scaled,zeroed)
      integer   kp(4)		!o: Locations of min, max (x,y;x,y)
      integer	ngood		!o: Number of valid pixels
      integer	nbad		!o: Number of invalid pixels
C--
      integer j, k, iv, knxs, knxe, knys, knye
      real    rv
Cbegin


      amax = -1.0e20
      amin = 1.0e20
      call azeroi ( kp, 4 )
      ngood = 0
      nbad = 0

      knxs = max(1,min(nx,nxs))
      knxe = max(1,min(nx,nxe))
      knys = max(1,min(ny,nys))
      knye = max(1,min(ny,nye))
      call cswopi ( knxs, knxe )
      call cswopi ( knys, knye )

      do k = knys, knye
         do j = knxs, knxe
            iv = im(j,k)
            if ( iv.ne.inval ) then
               ngood = ngood + 1
               if ( real(iv).gt.amax ) then
                  amax = real(iv)
                  kp(3) = j
                  kp(4) = k
               endif
               if ( real(iv).lt.amin ) then
                  amin = real(iv)
                  kp(1) = j
                  kp(2) = k
               endif
            else
               nbad = nbad + 1
            endif
         enddo
      enddo

      amax = amax*bs + bz
      amin = amin*bs + bz
      if ( amin.gt.amax ) then
         rv = amin
         amin = amax
         amax = rv
         iv = kp(3)
         kp(3) = kp(1)
         kp(1) = iv
         iv = kp(4)
         kp(4) = kp(2)
         kp(2) = iv
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="tran_doit"> TRAN_DOIT  </a>-- Transfromation between two sets of x,y posns - set up
C
C    a j penny               rgo                      82-11-4

      subroutine tran_doit ( xy1, xy2, num, numa, ktype, siglim, ok,
     +                       trc, ngood, sd )

      implicit none
      include 'STARMAN_INC'

      integer   num             !i: Size of table files
      real	xy1(num,2)	!i: 1st input table positions
      real	xy2(num,2)	!i: 2nd input table positions
      integer   numa            !i: Number of points to look at, starting from top
      integer	ktype		!i: Tranformation type (1=shift;2=shift+rotation;
                                !   3=shift+rotn+mag;4=full )
      real      siglim		!i: Limit to misfit allowed
      logical   ok(num)		!o: Work space for use
      real	trc(6)		!o: Calculated transformation
      integer   ngood		!o: Number of good points
      real      sd		!o: Std dev of points from fit
C--
      integer k, ierr, maxk
      logical more
      double precision xd, yd, dx, dy, errmax, errsq, varlim,
     +                 s, ss, sn, dss
Cbegin


      if ( ST_FAILED ) return

      do k = 1, numa
         ok(k) = .true.
      enddo

      more = .true.
      do while ( more )

         call tran_lintran ( xy1(1,1), xy1(1,2), xy2(1,1),
     +                       xy2(1,2), ok, num, numa, ktype, trc,
     +                       ierr )

         if ( ierr.ne.0 ) then
            more = .false.
         else
            errmax = 0.0d0
            maxk = 0
            s = 0.0d0
            ss = 0.0d0
            sn = 0.0d0
            do k = 1, numa
               if ( ok(k) ) then
                  xd = trc(1) + trc(2)*xy1(k,1) + trc(3)*xy1(k,2)
                  yd = trc(4) + trc(5)*xy1(k,1) + trc(6)*xy1(k,2)
                  dx = dble(xy2(k,1)) - xd
                  dy = dble(xy2(k,2)) - yd
                  errsq = dx*dx + dy*dy
                  s = s + dsqrt(errsq)
                  ss = ss + errsq
                  sn = sn + 1.0d0
                  if ( errsq.gt.errmax ) then
                     errmax = errsq
                     maxk = k
                  endif
               endif
            enddo

            sd = 0.0
            if ( sn.gt.1.0d0 ) then
               dss = ( ss-(s*s/sn))/(sn-1.0d0)
               if ( dss.gt.1.0d-20 ) sd = dsqrt(dss)
            endif

            ngood = nint(sn)
            if ( ngood.gt.0 ) then
               varlim = siglim*siglim
               if ( ss.gt.0.0d0 .and. errmax.gt.((ss/sn)*varlim)) then
                  ok(maxk) = .false.
                  if ( ngood.le.2 ) more = .false.
               else
                  more = .false.
               endif
            endif

         endif

      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="tran_lintran"> TRAN_LINTRAN  </a>-- Transformation between points - calculate
C
C    a j penny               ral                      1991 may

      subroutine tran_lintran ( xa, ya, xb, yb, ok, na, n, jfit, c,
     +                          ierr )

      implicit none
      include 'STARMAN_INC'

      integer    na		!i: Size of vectors
      real       xa(na)		!i: 1st table X positions
      real       ya(na)		!i: 1st table Y positions
      real       xb(na)		!i: 2nd table X positions
      real       yb(na)		!i: 2nd table Y positions
      logical    ok(na)		!i: Use this pair?
      integer    n		!i: Number of positions
      integer    jfit		!i: Type of fit (1=shift;2=shift+rotation;
				!   3=shift+rotn+mag;4=full 6 coords)
      real       c(6)		!o: Transformation coordinates
      integer    ierr		!o: Error flag (0=ok;1=no points;2=no good points)
C--
      double precision a(4,4), b(4), sw, swx, swy, swxy, swx2, swy2,
     +                 swxd, swyd, swxxd, swyyd, swxyd, swyxd, wx,
     +                 wy, x0, y0, xd0, yd0, swxxd0, swyyd0, swxyd0,
     +                 swyxd0, bot, top, theta
      real  rra(16), rrb(4)
      logical solved
      integer j, k, ka, ifit, npts
Cbegin


      if ( ST_FAILED ) return

      ierr = 0

      ifit = jfit
      call azeror ( c, 6 )

      if ( n.lt.1 ) then						!No points
         ierr = 1
         return
      endif

      sw = 0.0d0							!Number of good points
      do k = 1, n
         if ( ok(k) ) sw = sw + 1.0d0
      enddo
      npts = nint(sw)

      if ( npts.le.0 ) then						!No good points
         ierr = 2
         return
      endif

      if ( npts.le.2 ) ifit = min(ifit,3)				!check degrees of freedom
      if ( npts.le.1 ) ifit = 1

      swx   = 0.0d0							!Initialise for normal eqns
      swy   = 0.0d0
      swxy  = 0.0d0
      swx2  = 0.0d0
      swy2  = 0.0d0
      swxd  = 0.0d0
      swyd  = 0.0d0
      swxxd = 0.0d0
      swyyd = 0.0d0
      swxyd = 0.0d0
      swyxd = 0.0d0

      do k = 1, n							!Form sums
         if ( ok(k) ) then

            swx  = swx + xa(k)
            swy  = swy + ya(k)
            swxd = swxd + xb(k)
            swyd = swyd + yb(k)

            if ( ifit.ne.1 ) then
               wx = xa(k)
               wy = ya(k)
               swxy  = swxy  + wx*ya(k)
               swx2  = swx2  + wx*xa(k)
               swy2  = swy2  + wy*ya(k)
               swxxd = swxxd + wx*xb(k)
               swxyd = swxyd + wx*yb(k)
               swyxd = swyxd + wy*xb(k)
               swyyd = swyyd + wy*yb(k)
            endif

         endif
      enddo

      solved = .false.							!Solve: If cant try a simpler fit
      do while ( ifit.ge.1 .and. .not.solved )

         if ( ifit.eq.1 ) then						!Shift only

            c(1) = (swxd-swx)/sw
            c(2) = 1.0
            c(3) = 0.0
            c(4) = (swyd-swy)/sw
            c(5) = 0.0
            c(6) = 1.0
            solved = .true.

         elseif ( ifit.eq.2 ) then					!Shift and rotation

            xd0 = swxd/sw						!Centroids
            yd0 = swyd/sw
            x0  = swx/sw
            y0  = swy/sw

            swyxd0 = 0.0d0						!Deviations from centroids
            swxyd0 = 0.0d0
            swxxd0 = 0.0d0
            swyyd0 = 0.0d0
            do k = 1, n
               if ( ok(k) ) then
                  swyxd0 = swyxd0 + (ya(k)-y0)*(xb(k)-xd0)
                  swxyd0 = swxyd0 + (xa(k)-x0)*(yb(k)-yd0)
                  swxxd0 = swxxd0 + (xa(k)-x0)*(xb(k)-xd0)
                  swyyd0 = swyyd0 + (ya(k)-y0)*(yb(k)-yd0)
               endif
            enddo

            top = swyxd0 - swxyd0					!Rotation angle not defined
            bot = swyyd0 + swxxd0
            if ( top.ne.0.0d0 .or. bot.ne.0.0d0 ) then
               theta = atan2(top,bot)					!Calc rotation angle
               c(1) = xd0 - (x0*cos(theta)+y0*sin(theta))
               c(2) = cos(theta)
               c(3) = sin(theta)
               c(4) = yd0 - (-x0*sin(theta)+y0*cos(theta))
               c(5) = -sin(theta)
               c(6) = cos(theta)
               solved = .true.
            endif

         elseif ( ifit.eq.3 ) then					!Shift, rotation and magnification

            a(1,1) = sw
            a(1,2) = swx
            a(1,3) = swy
            a(1,4) = 0.0d0
            a(2,1) = swx
            a(2,2) = swx2 + swy2
            a(2,3) = 0.0d0
            a(2,4) = swy
            a(3,1) = swy
            a(3,2) = 0.0d0
            a(3,3) = swx2 + swy2
            a(3,4) = -swx
            a(4,1) = 0.0d0
            a(4,2) = swy
            a(4,3) = -swx
            a(4,4) = sw

            b(1) = swxd
            b(2) = swxxd + swyyd
            b(3) = swyxd - swxyd
            b(4) = swyd

            call achtdr ( a, rra, 16 )
            call achtdr ( b, rrb, 4 )
            call simulx ( rrb, rra, c, 4 )
            c(5) = -1.0*c(3)
            c(6) = c(2)

            solved = .true.

         elseif ( ifit.eq.4 ) then					!Full fit

            a(1,1) = sw
            a(1,2) = swx
            a(1,3) = swy
            a(2,1) = swx
            a(2,2) = swx2
            a(2,3) = swxy
            a(3,1) = swy
            a(3,2) = swxy
            a(3,3) = swy2

            b(1) = swxd
            b(2) = swxxd
            b(3) = swyxd

            ka = 0
            do k = 1, 3
               do j = 1, 3
                  ka = ka + 1
                  rra(ka) = a(j,k)
               enddo
            enddo
            call achtdr ( b, rrb, 3 )
            call simulx ( rrb, rra, c, 3 )

            b(1) = swyd
            b(2) = swxyd
            b(3) = swyyd

            ka = 0
            do k = 1, 3
               do j = 1, 3
                  ka = ka + 1
                  rra(ka) = a(j,k)
               enddo
            enddo
            call achtdr ( b, rrb, 3 )
            call simulx ( rrb, rra, c(4), 3 )

            solved = .true.

         endif

         ifit = ifit - 1

      enddo


      end
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C    This is STARFLIBS.FOR
C
C    It contains star and sky s/rs:-
C
C BOXELI           Calculates size of box needed round a rotated star
C CVOLUME          Performs an integration under a 2-D curve defined by
C GETD             Get x,y, and height out of a table, using the header code
C GET_MPROF        Get the star profile from the profile file on disk
C HTVAL            Calc height of lorentz profile given coded input
C POP(AS)(FM)(ISR) Add/Sub star with pixel (flags/magic) to/fm (i:s:r) array
C PROSET           Set up values for s/r POP(AS)(FM)(SR)
C PROFVAL          Calc profile value at a pixel.
C SKY_0            Find background and noise in an real or integer*2 image
C SKY_1(RS)        Find background and noise in boxes in a (real/int*2) image
C SKY_2(RS)        Find the sky, given a (real/int*2) sky map table, and a position
C SUBDIV           Calc pixel sub-division needed for given profile


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="boxeli"> BOXELI  </a>-- Calc size of box needed round a rotated star
C  The star is elliptical, rotated
C
C a j penny                    dao                  1988-04-19

      subroutine boxeli ( rx, ry, theta, dx, dy )

      implicit none
      include 'STARMAN_INC'

      real rx		!i: Star major axis radius
      real ry 		!i: Star minor axis radius
      real theta	!i: Angle of major axis to X
      real dx		!o: X size of box
      real dy		!o: Y size of box
C--
      real gx2, gy2, t, s, c, f
Cbegin


      if ( ST_FAILED ) return

      if ( abs(rx).gt.0.0001 .and. abs(ry).gt.0.00001 ) then
         gx2 = 1.0/(rx*rx)
         gy2 = 1.0/(ry*ry)
         t = (tan(theta))**2.0
         s = (sin(theta))**2.0
         c = (cos(theta))**2.0
         f = (gy2-gx2)/(gx2+t*gy2)
         dy = sqrt(s*gx2*((1.0+f)**2.0)+c*gy2*((1.0-t*f)**2.0))
         dy = 1.0/dy
         f = (gy2-gx2)/(gy2+t*gx2)
         dx = sqrt(c*gx2*((1+t*f)**2.0)+s*gy2*((-1.0+f)**2.0))
         dx = 1.0/dx
      else
         dx = 1.0
         dy = 1.0
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="cvolume"> CVOLUME  </a>-- Calc volume under a star profile.
C  Performs an integration under a 2-D curve defined by some of
C  the parameters in the array PROF and a residuals map.
C
C      a j penny                     stsci                1987-02-21


      subroutine cvolume ( prof, domap, map, mx, my, mz,
     +                     mapnum, mapx, mapy, magnif, radius, vol )

      implicit none
      include 'STARMAN_INC'

      real prof(9)	 !i: parameters of the function to be fitted.
      logical domap	 !i: Flag whether to use map
      integer mx	 !i: Maximum Map x size in Map array
      integer my	 !i: Maximum Map y size in Map array
      integer mz	 !i: Total no of maps in Map array
      real map(mx,my,mz) !i: Array containing all maps
      integer mapnum	 !i: Number of map to actually use
      integer mapx	 !i: Actual Map x size
      integer mapy	 !i: Actual Map x size
      integer magnif	 !i: Map pixel subdivision
      real radius	 !i: Radius out to which to calculate volume
      real vol		 !o: Volume under profile, out to specified radius
C--
      real avol, fxa, fya, fxb, fyb, pa, rslim, xxa, xxb,
     +     yya, yyb, gg, pab, pac, dd, rr, dx, dy, x, y, val
      integer kradlim, j, ja, k
Cbegin


      if ( ST_FAILED ) return

C  Start with centre pixel

      vol = 1.0

C  Set up parameters

      fxa = 1.0/30.0
      fxa = fxa*fxa
      fya = 1.0/30.0
      fya = fya*fya
      fxb = prof(1)/(30.0*prof(4))
      fxb = fxb*fxb
      fyb = prof(2)/(30.0*prof(5))
      fyb = fyb*fyb
      pa = 0.5*prof(3)

C  Translate radius edge

      kradlim = radius*30.0
      rslim = radius*radius*30.0*30.0

C  Do one quadrant, steps of 1/30 out to 3.33 star radii. Then *4

      avol = 0.0
      do k = 1, min(kradlim,100)
         y = k
         do j = 1, min(kradlim,100)
            x = j
            call htval ( x, y, fxa, fxb, fya, fyb, pa, rslim, val )
            avol = avol + val
         enddo
      enddo
      vol = vol + 4.0*avol

      if ( kradlim.ge.101 ) then

C Now do the quadrant in steps of 1/15, top half of 3.3 to 10 star radii

         avol = 0.0
         do k = 101, min(kradlim,299), 2
            y = real(k) + 0.5
            do j = 1, min(kradlim,299), 2
               x = real(j) + 0.5
               call htval ( x, y, fxa, fxb, fya, fyb, pa, rslim, val )
               avol = avol + val
            enddo
         enddo
         vol = vol + 4.0*avol*4.0

C Now do the quadrant in steps of 1/15, remainder of 3.3 - 10 star radii

         avol = 0.0
         do k = 1, 99, 2
            y = real(k) + 0.5
               do j = 101, min(kradlim,299), 2
                  x = real(j) + 0.5
                  call htval ( x, y, fxa, fxb, fya, fyb, pa, rslim, val)
                  avol = avol + val
            enddo
         enddo
         vol = vol + 4.0*avol*4.0

      endif

      if ( kradlim.ge.305 ) then

C  Now do from 10 to 20 star radii, in steps of 10, right half

         avol = 0.0
         do k = 305, min(kradlim,595), 10
            y = real(k) + 0.5
            do j = 5, min(kradlim,595), 10
               x = real(j) + 0.5
               call htval ( x, y, fxa, fxb, fya, fyb, pa, rslim, val )
               avol = avol + val
            enddo
         enddo
         vol = vol + 4.0*avol*100.0

C  Now do from 10 to 20 star radii, in steps of 10, top left part

         avol = 0.0
         do k = 5, 295, 10
            y = real(k) + 0.5
            do j = 305, min(kradlim,595), 10
               x = real(j) + 0.5
               call htval ( x, y, fxa, fxb, fya, fyb, pa, rslim, val )
               avol = avol + val
            enddo
         enddo
         vol = vol + 4.0*avol*100.0

      endif

C  Do one X arm

      avol = 0.0
      do j = 1, min(kradlim,600)
         xxa = real(j*j)/900.0
         xxb = xxa*prof(1)*prof(1)/(prof(4)*prof(4))
         gg = xxa
         pab = pa*(1.0+sqrt(xxb))
         pac = pab*alog10(gg)
         if (pac.lt.25.0) then
            avol = avol + 1.0/(1.0+10.0**pac)
         endif
      enddo
      vol = vol + 2.0*avol

C  Do one Y arm

      avol = 0.0
      do k = 1, min(kradlim,600)
         yya = real(k*k)/900.0
         yyb = yya*prof(2)*prof(2)/(prof(5)*prof(5))
         gg = yya
         pab = pa*(1.0+sqrt(yyb))
         pac = pab*alog10(gg)
         if (pac.lt.25.0) then
            avol = avol + 1.0/(1.0+10.0**pac)
         endif
      enddo
      vol = vol + 2.0*avol

C  Correct for area of pixels

      vol = prof(1)*prof(2)*vol/900.0

C  Add the Gaussian component

      avol = 0.0
      ja = min(3.0*radius,60.0)
      do k = -1*ja, ja
         y = prof(2)*real(k)/3.0
         do j = -1*ja, ja
            dd = j*j + k*k
            if ( dd.lt.(3.0*3.0*radius*radius) ) then
               x = prof(1)*real(j)/3.0
               dd = sqrt(x*x+y*y)/prof(8)
               avol = avol + exp( -1.0*(min(40.0,(dd**prof(9)))) )
            endif
         enddo
      enddo
      vol = vol + prof(7)*avol*prof(1)*prof(2)/9.0

C  Now add the residuals map

      if (domap) then
         avol = 0.0
         rr = radius*radius*real(magnif*magnif)
         do k = 1, mapy
            do j = 1, mapx
               dx = j - mapx/2
               dy = k - mapy/2
               dd = dx*dx + dy*dy
               if ( dd.le.rr ) then
                  avol = avol + map(j,k,mapnum)
               endif
            enddo
         enddo
         vol = vol + (avol/(real(magnif)*real(magnif)))
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="getd"> GETD  </a>-- Get x,y, and height out of a table, using the header code
C
C    It is assumed that if there is no 'X' or 'Y' headers, then
C    the x,y is stored in columns 6,7 (the 1st data columns).
C    If there is no 'H' header then the height is assumed to be in
C    col number 'nhtcol' (and is set to 0.0 if there is no such col)
C
C    If there is no header for a particular value, the
C    default values in the input prof,magnifk,mapxk,mapyk,mapnumk are
C    taken. IF HOWEVER 'PBOSS' is set, this makes prof override for
C    profile.
C
C
C     a j penny                stsci                   1987-02-24

      subroutine getd ( tab, tbvx, tby, khead, num, x, y, h, nhtcol,
     +                  profk, prof, mapnum, mapx, mapy, magnif,
     +                  magnifk, mapxk, mapyk, mapnumk, pboss )

      implicit none
      include 'STARMAN_INC'

      integer  tbvx		!i: X size of table
      integer  tby		!i: Y size of table
      real     tab(tbvx,tby)	!i: Table input
      integer  khead(16)	!i: Column locations of various data
      integer  num		!i: Row of table to get data from
      integer  mapnum		!i: Map number
      integer  mapx		!o: Map X size
      integer  mapy		!o: Map Y size
      integer  magnif		!o: Map magnification
      integer  magnifk		!i: Default map magnification
      integer  mapxk		!i: Default map X size
      integer  mapyk		!i: Default map Y size
      integer  mapnumk		!i: Default map number
      integer  nhtcol		!i: Column number (-5) holding height
      real     profk(9)		!i: Default profile
      logical  pboss		!i: Flag (true=use array;
				!   false=take std profile)
      real     prof(9)		!o: Output profile
      real     x		!o: X position
      real     y		!o: Y position
      real     h		!o: Height
C--
      integer k
Cbegin


      if ( ST_FAILED ) return

      x = tab(6,num)
      if ( khead(1).ne.0 ) x = tab(khead(1)+5,num)			!Position
      y = tab(7,num)
      if ( khead(2).ne.0 ) y = tab(khead(2)+5,num)

      h = 0.0								!Height
      if ( khead(3).eq.0 ) then
         if ( nhtcol.ne.0 .and. nhtcol.ge.1 .and. nhtcol+5.le.tbvx )
     +      h = tab(nhtcol+5,num)
      else
         h = tab(khead(3)+5,num)
      endif

      call amovr ( profk, prof, 9 )					!Main profile
      mapnum = mapnumk
      mapx = mapxk
      mapy = mapyk
      magnif = magnifk

      if ( .not.pboss ) then						!File profile overwrites?
         do k = 1, 9
            if ( khead(k+3).ne.0 ) then
               if ( k.eq.6 ) then
                  prof(k) = tab(khead(k+3)+5,num)*(3.1415927/180.0)
               else
                  prof(k) = tab(khead(k+3)+5,num)
               endif
            endif
         enddo
         if ( khead(13).ne.0 ) mapnum = nint(tab(khead(13)+5,num))
         if ( khead(14).ne.0 ) mapx = nint(tab(khead(14)+5,num))
         if ( khead(15).ne.0 ) mapy = nint(tab(khead(15)+5,num))
         if ( khead(16).ne.0 ) magnif = nint(tab(khead(16)+5,num))
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="get_mprof"> GET_MPROF  </a>-- Get the star profile from the profile file on disk

C  a j penny                 stsci              1987-02-2

      subroutine get_mprof ( file, ipinr, prof, mx, my, mz, magnif,
     +                       mapx, mapy, pbs, pbz, qbase, vol,
     +                       volrad, ierr )

      implicit none
      include 'STARMAN_INC'

      character*(*) 	file		!i: File name
      integer 		ipinr		!o: Pointer to data
      real 		prof(9)		!o: Profile
      integer 		mx		!o: Map X size
      integer 		my		!o: Map Y size
      integer 		mz		!o: Map Z size
      integer 		magnif		!o: Map magnification
      integer 		mapx		!o: Map X size?
      integer 		mapy		!o: Map Y size?
      real 		pbs		!o: Map value scale
      real 		pbz		!o: Map X size
      real              qbase		!o: Wing profile base
      real 		vol		!o: Profile volume
      real 		volrad		!o: Profile volume calced in this
					!   radius
      integer 		ierr		!o: Error flag (0=ok:1=bad file:
					!               2=descriptor wrong)
C--
      real angle
      integer istat, lyma
Cbegin


      if ( ST_FAILED ) return

      ierr = 0

      ipinr = 1
      call amovkr ( 1.0, prof, 9 )				!Default profile
      mx = 1
      my = 1
      mz = 1
      magnif = 1
      mapx = 1
      mapy = 1
      pbs = 1.0
      pbz = 0.0
      vol = 1.0
      volrad = 1.0

      call opimsr ( file, ipinr, mx, lyma, .true., istat )	!Get image. If can't, return
      if ( ST_FAILED .or. istat.ne.0 ) then
         ierr = 1
         return
      endif

      call gtdesr ( file, 'BSCALE',   pbs,      1.0, istat )	!Get descriptors
      ierr = max(ierr,istat)
      call gtdesr ( file, 'BZERO',    pbz,      0.0, istat )
      ierr = max(ierr,istat)
      call gtdesr ( file, 'RX',       prof(1),  4.0, istat )
      ierr = max(ierr,istat)
      call gtdesr ( file, 'RY',       prof(2),  4.0, istat )
      ierr = max(ierr,istat)
      call gtdesr ( file, 'P',        prof(3),  2.0, istat )
      ierr = max(ierr,istat)
      call gtdesr ( file, 'PRX',      prof(4), 20.0, istat )
      ierr = max(ierr,istat)
      call gtdesr ( file, 'PRY',      prof(5), 20.0, istat )
      ierr = max(ierr,istat)
      call gtdesr ( file, 'THETA',    angle,    0.0, istat )
      ierr = max(ierr,istat)
      prof(6) = angle*3.1415926536/180.0
      call gtdesr ( file, 'QH',       prof(7),  0.0, istat )
      ierr = max(ierr,istat)
      call gtdesr ( file, 'QR',       prof(8), 20.0, istat )
      ierr = max(ierr,istat)
      call gtdesr ( file, 'QP',       prof(9),  2.0, istat )
      ierr = max(ierr,istat)
      call gtdesr ( file, 'QBASE',      qbase,  0.0, istat )
      ierr = max(ierr,istat)
      call gtdesr ( file, 'VOL',      vol,      0.0, istat )
      ierr = max(ierr,istat)
      call gtdesr ( file, 'VOLRAD',   volrad,   0.0, istat )
      ierr = max(ierr,istat)
      call gtdesi ( file, 'MAPMAX',   mz,         1, istat )
      ierr = max(ierr,istat)
      my = lyma/mz
      call gtdesi ( file, 'MAGNIF', magnif,     1, istat )
      ierr = max(ierr,istat)

      call gtdesi ( file, 'MAPX',     mapx,      mx, istat )
      call gtdesi ( file, 'MAPY',     mapy,      my, istat )

      if ( ierr.ne.0 ) ierr = 2


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="htval"> HTVAL  </a>-- Calc height of lorentz profile given coded input
C          parameters ( only used by s/r CVOLUME)
C
C      a j penny                     stsci                1987-05-29

      subroutine htval ( x, y, fxa, fxb, fya, fyb, pa, rslim, val )

      implicit none
      include 'STARMAN_INC'

      real  x		!i: X position in profile
      real  y		!i: Y position in profile
      real  fxa		!i: Profile X radius
      real  fxb		!i: Profile X power radius
      real  fya		!i: Profile Y radius
      real  fyb		!i: Profile Y power radius
      real  pa		!i: Profile power
      real  rslim	!i: Max distance out squared 'val' calculated for
      real  val		!o: Profile height at that posn
C--
      real xx, yy, xxa, xxb, yya, yyb, gg, hh, pab, pac
Cbegin


      if ( ST_FAILED ) return

      val = 0.0

      xx = x*x
      yy = y*y
      if ( (xx+yy).lt.rslim ) then
         xxa = xx*fxa
         xxb = xx*fxb
         yya = yy*fya
         yyb = yy*fyb
         gg = xxa + yya
         hh = sqrt(xxb+yyb)
         pab = pa*(1.0+hh)
         pac = pab*alog10(gg)
         if (pac.lt.25.0) then
            val = 1.0/(1.0+10.0**pac)
        endif
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="popafi"> POPAFI  </a>-- Add a star to an integer image with pixel flags
C
C   a.j.penny                   ral                    1988-08-06

      subroutine popafi ( kdata, nx, ny, bs, kdo, xp, yp, hp, prof,
     +                    map, mx, my, mz, mapnum,
     +                    mapx, mapy, magnif, domap, ierr, kw )

      implicit none
      include 'STARMAN_INC'

      integer	nx		!i: X size of image
      integer	ny		!i: Y size of image
      integer  	kdata(nx,ny)  	!i/o: image
      real      bs              !i: Scale of image
      logical	kdo(nx,ny)	!i: image pixel flags
      real	xp		!i: star x posn
      real	yp		!i: star y posn
      real	hp      	!i: star height
      real	prof(9)		!i: profile (rx,ry,p,prx,pry,angle(radians),
				!            wh,wp,wr)
      logical   domap	 	!i: Flag whether to use map
      integer   mx	 	!i: Maximum Map x size in Map array
      integer   my	 	!i: Maximum Map y size in Map array
      integer   mz	 	!i: Total no of maps in Map array
      real      map(mx,my,mz) 	!i: Array containing all maps
      integer   mapnum	 	!i: Number of map to actually use
      integer   mapx	 	!i: Actual Map x size
      integer   mapy	 	!i: Actual Map x size
      integer   magnif	 	!i: Map pixel subdivision
      integer	ierr		!o: Error flag (0=ok:1=no placement)
      integer   kw(4)		!o: Bounds of area affected (lxs,lxe,lys,lye)
C--
      real co, si, sim, qh, qr, qp, val, ap, hx2, hy2, gx2, gy2
      integer lxs, lxe, lys, lye, j, k, lx, ly
      logical ok
Cbegin


      if ( ST_FAILED ) return

C  Set up parameters and check if ok

      call proset ( xp, yp, hp, prof, lx, ly, lxs, lxe, lys, lye, co,
     +              si, sim, gx2, gy2, ap, hx2, hy2, qh, qr, qp, nx,
     +              ny, ok )
      ierr = 0
      if ( .not.ok ) then
         ierr = 1
         return
      endif

C  Do the addition, for valid pixels in the right area, with scaling

      do k = lys, lye
         do j = lxs, lxe
           if ( kdo(j,k) ) then
             call profval ( val, j, k, xp, yp, hp, lx, ly, co, si,
     +                      sim, gx2, gy2, ap, hx2, hy2, qh, qr, qp,
     +                      domap, map, mx, my, mx, mapnum, mapx,
     +                      mapy, magnif )

             val = real(kdata(j,k)) + val/bs
             kdata(j,k) = nint(min(2147480000.0,max(-2147480000.0,val)))
           endif
         enddo
      enddo

      kw(1) = lxs
      kw(2) = lxe
      kw(3) = lys
      kw(4) = lye


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="popami"> POPAMI  </a>-- Add a star to an integer image with pixel magic values
C
C   a.j.penny                   ral                    1988-08-06

      subroutine popami ( kdata, nx, ny, bs, inval, xp, yp, hp, prof,
     +                    map, mx, my, mz, mapnum,
     +                    mapx, mapy, magnif, domap, ierr, kw )

      implicit none
      include 'STARMAN_INC'

      integer	nx		!i: X size of image
      integer	ny		!i: Y size of image
      integer   kdata(nx,ny)  	!i/o: image
      real      bs              !i: image value scale
      integer   inval           !i: image bad pixel magic value
      real	xp		!i: star x posn
      real	yp		!i: star y posn
      real	hp      	!i: star height
      real	prof(9)		!i: profile (rx,ry,p,prx,pry,angle(radians),
				!            wh,wp,wr)
      logical   domap		!i: Flag whether to use map
      integer   mx		!i: Maximum Map x size in Map array
      integer   my		!i: Maximum Map y size in Map array
      integer   mz		!i: Total no of maps in Map array
      real      map(mx,my,mz) 	!i: Array containing all maps
      integer   mapnum		!i: Number of map to actually use
      integer   mapx		!i: Actual Map x size
      integer   mapy		!i: Actual Map x size
      integer   magnif		!i: Map pixel subdivision
      integer	ierr		!o: Error flag (0=ok:1=no placement)
      integer   kw(4)		!o: Bounds of area affected (lxs,lxe,lys,lye)
C--
      real co, si, sim, qh, qr, qp, val, ap, hx2, hy2, gx2, gy2
      integer lxs, lxe, lys, lye, j, k, lx, ly
      logical ok
Cbegin


      if ( ST_FAILED ) return

C  Set up parameters and check if ok

      call proset ( xp, yp, hp, prof, lx, ly, lxs, lxe, lys, lye, co,
     +              si, sim, gx2, gy2, ap, hx2, hy2, qh, qr, qp, nx,
     +              ny, ok )
      ierr = 0
      if ( .not.ok ) then
         ierr = 1
         return
      endif

C  Do the addition, for valid pixels in the desired area, with scaling

      do k = lys, lye
         do j = lxs, lxe
            if ( kdata(j,k).ne.inval ) then
               call profval ( val, j, k, xp, yp, hp, lx, ly, co, si,
     +                        sim, gx2, gy2, ap, hx2, hy2, qh, qr, qp,
     +                        domap, map, mx, my, mx, mapnum, mapx,
     +                        mapy, magnif )
               val = real(kdata(j,k)) + val/bs
               kdata(j,k)=nint(min(2147480000.0,max(-2147480000.0,val)))
            endif
         enddo
      enddo

      kw(1) = lxs
      kw(2) = lxe
      kw(3) = lys
      kw(4) = lye


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="popamr"> POPAMR  </a>-- Add a star to a real image with pixel magic values
C
C   a.j.penny                   ral                    1988-08-06

      subroutine popamr ( rdata, nx, ny, bs, rinval, xp, yp, hp, prof,
     +                    map, mx, my, mz, mapnum,
     +                    mapx, mapy, magnif, domap, ierr, kw )

      implicit none
      include 'STARMAN_INC'

      integer	nx		!i: X size of image
      integer	ny		!i: Y size of image
      real 	rdata(nx,ny)  	!i/o: image
      real      bs              !i: image value scale
      real      rinval          !i: image bad pixel magic value
      real	xp		!i: star x posn
      real	yp		!i: star y posn
      real	hp      	!i: star height
      real	prof(9)		!i: profile (rx,ry,p,prx,pry,angle(radians),
				!            wh,wp,wr)
      logical   domap		!i: Flag whether to use map
      integer   mx		!i: Maximum Map x size in Map array
      integer   my		!i: Maximum Map y size in Map array
      integer   mz		!i: Total no of maps in Map array
      real      map(mx,my,mz) 	!i: Array containing all maps
      integer   mapnum		!i: Number of map to actually use
      integer   mapx		!i: Actual Map x size
      integer   mapy		!i: Actual Map x size
      integer   magnif		!i: Map pixel subdivision
      integer	ierr		!o: Error flag (0=ok:1=no placement)
      integer   kw(4)		!o: Bounds of area affected (lxs,lxe,lys,lye)
C--
      real co, si, sim, qh, qr, qp, val, ap, hx2, hy2, gx2, gy2
      integer lxs, lxe, lys, lye, j, k, lx, ly
      logical ok
Cbegin


      if ( ST_FAILED ) return

C  Set up parameters and check if ok

      call proset ( xp, yp, hp, prof, lx, ly, lxs, lxe, lys, lye, co,
     +              si, sim, gx2, gy2, ap, hx2, hy2, qh, qr, qp, nx,
     +              ny, ok )
      ierr = 0
      if ( .not.ok ) then
         ierr = 1
         return
      endif

C  Do the addition, for valid pixels in the desired area, with scaling

      do k = lys, lye
         do j = lxs, lxe
            if ( rdata(j,k).ne.rinval ) then
               call profval ( val, j, k, xp, yp, hp, lx, ly, co, si,
     +                        sim, gx2, gy2, ap, hx2, hy2, qh, qr, qp,
     +                        domap, map, mx, my, mx, mapnum, mapx,
     +                        mapy, magnif )
               rdata(j,k) = rdata(j,k) + val/bs
            endif
         enddo
      enddo

      kw(1) = lxs
      kw(2) = lxe
      kw(3) = lys
      kw(4) = lye


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="popams"> POPAMS  </a>-- Add a star to an integer*2 image with pixel magic values
C
C   a.j.penny                   ral                    1988-08-06

      subroutine popams ( kdata, nx, ny, bs, inval, xp, yp, hp, prof,
     +                    map, mx, my, mz, mapnum,
     +                    mapx, mapy, magnif, domap, ierr, kw )

      implicit none
      include 'STARMAN_INC'

      integer	nx		!i: X size of image
      integer	ny		!i: Y size of image
      integer*2 kdata(nx,ny)  	!i/o: image
      real      bs              !i: image value scale
      integer   inval           !i: image bad pixel magic value
      real	xp		!i: star x posn
      real	yp		!i: star y posn
      real	hp      	!i: star height
      real	prof(9)		!i: profile (rx,ry,p,prx,pry,angle(radians),
				!            wh,wp,wr)
      logical   domap		!i: Flag whether to use map
      integer   mx		!i: Maximum Map x size in Map array
      integer   my		!i: Maximum Map y size in Map array
      integer   mz		!i: Total no of maps in Map array
      real      map(mx,my,mz) 	!i: Array containing all maps
      integer   mapnum		!i: Number of map to actually use
      integer   mapx		!i: Actual Map x size
      integer   mapy		!i: Actual Map x size
      integer   magnif		!i: Map pixel subdivision
      integer	ierr		!o: Error flag (0=ok:1=no placement)
      integer   kw(4)		!o: Bounds of area affected (lxs,lxe,lys,lye)
C--
      real co, si, sim, qh, qr, qp, val, ap, hx2, hy2, gx2, gy2
      integer lxs, lxe, lys, lye, j, k, lx, ly
      logical ok
Cbegin


      if ( ST_FAILED ) return

C  Set up parameters and check if ok

      call proset ( xp, yp, hp, prof, lx, ly, lxs, lxe, lys, lye, co,
     +              si, sim, gx2, gy2, ap, hx2, hy2, qh, qr, qp, nx,
     +              ny, ok )
      ierr = 0
      if ( .not.ok ) then
         ierr = 1
         return
      endif

C  Do the addition, for valid pixels in the desired area, with scaling

      do k = lys, lye
         do j = lxs, lxe
            if ( kdata(j,k).ne.inval ) then
               call profval ( val, j, k, xp, yp, hp, lx, ly, co, si,
     +                        sim, gx2, gy2, ap, hx2, hy2, qh, qr, qp,
     +                        domap, map, mx, my, mx, mapnum, mapx,
     +                        mapy, magnif )
               val = real(kdata(j,k)) + val/bs
               kdata(j,k)=nint(min(32767.0,max(-32768.0,val)))
            endif
         enddo
      enddo

      kw(1) = lxs
      kw(2) = lxe
      kw(3) = lys
      kw(4) = lye


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="popsfi"> POPSFI  </a>-- Subtract a star from an integer image with pixel flags
C
C   a.j.penny                   ral                    1988-08-06

      subroutine popsfi ( kdata, nx, ny, bs, kdo, xp, yp, hp, prof,
     +                    map, mx, my, mz, mapnum,
     +                    mapx, mapy, magnif, domap, ierr, kw )

      implicit none
      include 'STARMAN_INC'

      integer	nx		!i: X size of image
      integer	ny		!i: Y size of image
      integer  	kdata(nx,ny)  	!i/o: image
      real      bs              !i: Scale of image
      logical	kdo(nx,ny)	!i: image pixel flags
      real	xp		!i: star x posn
      real	yp		!i: star y posn
      real	hp      	!i: star height
      real	prof(9)		!i: profile (rx,ry,p,prx,pry,angle(radians),
				!            wh,wp,wr)
      logical   domap	 	!i: Flag whether to use map
      integer   mx	 	!i: Maximum Map x size in Map array
      integer   my	 	!i: Maximum Map y size in Map array
      integer   mz	 	!i: Total no of maps in Map array
      real      map(mx,my,mz) 	!i: Array containing all maps
      integer   mapnum	 	!i: Number of map to actually use
      integer   mapx	 	!i: Actual Map x size
      integer   mapy	 	!i: Actual Map x size
      integer   magnif	 	!i: Map pixel subdivision
      integer	ierr		!o: Error flag (0=ok:1=no placement)
      integer   kw(4)		!o: Bounds of area affected (lxs,lxe,lys,lye)
C--
      real co, si, sim, qh, qr, qp, val, ap, hx2, hy2, gx2, gy2
      integer lxs, lxe, lys, lye, j, k, lx, ly
      logical ok
Cbegin


      if ( ST_FAILED ) return

C  Set up parameters and check if ok

      call proset ( xp, yp, hp, prof, lx, ly, lxs, lxe, lys, lye, co,
     +              si, sim, gx2, gy2, ap, hx2, hy2, qh, qr, qp, nx,
     +              ny, ok )
      ierr = 0
      if ( .not.ok ) then
         ierr = 1
         return
      endif

C  Do the subtraction, for valid pixels in the right area, with scaling

      do k = lys, lye
         do j = lxs, lxe
           if ( kdo(j,k) ) then
             call profval ( val, j, k, xp, yp, hp, lx, ly, co, si,
     +                      sim, gx2, gy2, ap, hx2, hy2, qh, qr, qp,
     +                      domap, map, mx, my, mx, mapnum, mapx,
     +                      mapy, magnif )

             val = real(kdata(j,k)) - val/bs
             kdata(j,k) = nint(min(2147480000.0,max(-2147480000.0,val)))
           endif
         enddo
      enddo

      kw(1) = lxs
      kw(2) = lxe
      kw(3) = lys
      kw(4) = lye


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="popsfr"> POPSFR  </a>-- Subtract a star from a real image with pixel flags
C
C   a.j.penny                   ral                    1988-08-06

      subroutine popsfr ( data, nx, ny, bs, kdo, xp, yp, hp, prof,
     +                    map, mx, my, mz, mapnum,
     +                    mapx, mapy, magnif, domap, ierr, kw )

      implicit none
      include 'STARMAN_INC'

      integer	nx		!i: X size of image
      integer	ny		!i: Y size of image
      real	data(nx,ny)  	!i/o: image
      real      bs              !i: Scale of image
      logical	kdo(nx,ny)	!i: image pixel flags
      real	xp		!i: star x posn
      real	yp		!i: star y posn
      real	hp      	!i: star height
      real	prof(9)		!i: profile (rx,ry,p,prx,pry,angle(radians),
				!            wh,wp,wr)
      logical   domap	 	!i: Flag whether to use map
      integer   mx	 	!i: Maximum Map x size in Map array
      integer   my	 	!i: Maximum Map y size in Map array
      integer   mz	 	!i: Total no of maps in Map array
      real      map(mx,my,mz) 	!i: Array containing all maps
      integer   mapnum	 	!i: Number of map to actually use
      integer   mapx	 	!i: Actual Map x size
      integer   mapy	 	!i: Actual Map x size
      integer   magnif	 	!i: Map pixel subdivision
      integer	ierr		!o: Error flag (0=ok:1=no placement)
      integer   kw(4)		!o: Bounds of area affected (lxs,lxe,lys,lye)
C--
      real co, si, sim, qh, qr, qp, val, ap, hx2, hy2, gx2, gy2
      integer lxs, lxe, lys, lye, j, k, lx, ly
      logical ok
Cbegin


      if ( ST_FAILED ) return

C  Set up parameters and check if ok

      call proset ( xp, yp, hp, prof, lx, ly, lxs, lxe, lys, lye, co,
     +              si, sim, gx2, gy2, ap, hx2, hy2, qh, qr, qp, nx,
     +              ny, ok )
      ierr = 0
      if ( .not.ok ) then
         ierr = 1
         return
      endif

C  Do the subtraction, for valid pixels in the right area, with scaling

      do k = lys, lye
         do j = lxs, lxe
           if ( kdo(j,k) ) then
              call profval ( val, j, k, xp, yp, hp, lx, ly, co, si,
     +                       sim, gx2, gy2, ap, hx2, hy2, qh, qr, qp,
     +                       domap, map, mx, my, mx, mapnum, mapx,
     +                       mapy, magnif )
              data(j,k) = data(j,k) - val/bs
           endif
         enddo
      enddo

      kw(1) = lxs
      kw(2) = lxe
      kw(3) = lys
      kw(4) = lye


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="popsfs"> POPSFS  </a>-- Subtract a star from a short image with pixel flags
C
C   a.j.penny                   ral                    1988-08-06

      subroutine popsfs ( sdata, nx, ny, bs, kdo, xp, yp, hp, prof,
     +                    map, mx, my, mz, mapnum,
     +                    mapx, mapy, magnif, domap, ierr, kw )

      implicit none
      include 'STARMAN_INC'

      integer	nx		!i: X size of image
      integer	ny		!i: Y size of image
      integer*2	sdata(nx,ny)  	!i/o: image
      real      bs              !i: Scale of image
      logical	kdo(nx,ny)	!i: image pixel flags
      real	xp		!i: star x posn
      real	yp		!i: star y posn
      real	hp      	!i: star height
      real	prof(9)		!i: profile (rx,ry,p,prx,pry,angle(radians),
				!            wh,wp,wr)
      logical   domap	 	!i: Flag whether to use map
      integer   mx		!i: Maximum Map x size in Map array
      integer   my		!i: Maximum Map y size in Map array
      integer   mz		!i: Total no of maps in Map array
      real      map(mx,my,mz) 	!i: Array containing all maps
      integer   mapnum		!i: Number of map to actually use
      integer   mapx		!i: Actual Map x size
      integer   mapy		!i: Actual Map x size
      integer   magnif	 	!i: Map pixel subdivision
      integer	ierr		!o: Error flag (0=ok:1=no placement)
      integer   kw(4)		!o: Bounds of area affected (lxs,lxe,lys,lye)
C--
      real co, si, sim, qh, qr, qp, val, ap, hx2, hy2, gx2, gy2
      integer lxs, lxe, lys, lye, j, k, lx, ly
      logical ok
Cbegin


      if ( ST_FAILED ) return

C  Set up parameters and check if ok

      call proset ( xp, yp, hp, prof, lx, ly, lxs, lxe, lys, lye, co,
     +              si, sim, gx2, gy2, ap, hx2, hy2, qh, qr, qp, nx,
     +              ny, ok )
      ierr = 0
      if ( .not.ok ) then
         ierr = 1
         return
      endif

C  Do the subtraction, for valid pixels in the right area, with scaling

      do k = lys, lye
         do j = lxs, lxe
            if ( kdo(j,k) ) then
               call profval ( val, j, k, xp, yp, hp, lx, ly, co, si,
     +                        sim, gx2, gy2, ap, hx2, hy2, qh, qr, qp,
     +                        domap, map, mx, my, mx, mapnum, mapx,
     +                        mapy, magnif )
               val = real(sdata(j,k)) - val/bs
               sdata(j,k) = nint(min(32767.0,max(-32768.0,val)))
            endif
         enddo
      enddo

      kw(1) = lxs
      kw(2) = lxe
      kw(3) = lys
      kw(4) = lye


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="popsmr"> POPSMR  </a>-- Subtract a star from a real image with pixel magic values
C
C   a.j.penny                   ral                    1988-08-06

      subroutine popsmr ( rdata, nx, ny, bs, rinval, xp, yp, hp, prof,
     +                    map, mx, my, mz, mapnum,
     +                    mapx, mapy, magnif, domap, ierr, kw )

      implicit none
      include 'STARMAN_INC'

      integer	nx		!i: X size of image
      integer	ny		!i: Y size of image
      real 	rdata(nx,ny)  	!i/o: image
      real      bs              !i: image value scale
      real      rinval          !i: image bad pixel magic value
      real	xp		!i: star x posn
      real	yp		!i: star y posn
      real	hp      	!i: star height
      real	prof(9)		!i: profile (rx,ry,p,prx,pry,angle(radians),
				!            wh,wp,wr)
      logical   domap		!i: Flag whether to use map
      integer   mx		!i: Maximum Map x size in Map array
      integer   my		!i: Maximum Map y size in Map array
      integer   mz		!i: Total no of maps in Map array
      real      map(mx,my,mz) 	!i: Array containing all maps
      integer   mapnum		!i: Number of map to actually use
      integer   mapx		!i: Actual Map x size
      integer   mapy		!i: Actual Map x size
      integer   magnif		!i: Map pixel subdivision
      integer	ierr		!o: Error flag (0=ok:1=no placement)
      integer   kw(4)		!o: Bounds of area affected (lxs,lxe,lys,lye)
C--
      real co, si, sim, qh, qr, qp, val, ap, hx2, hy2, gx2, gy2
      integer lxs, lxe, lys, lye, j, k, lx, ly
      logical ok
Cbegin


      if ( ST_FAILED ) return

C  Set up parameters and check if ok

      call proset ( xp, yp, hp, prof, lx, ly, lxs, lxe, lys, lye, co,
     +              si, sim, gx2, gy2, ap, hx2, hy2, qh, qr, qp, nx,
     +              ny, ok )
      ierr = 0
      if ( .not.ok ) then
         ierr = 1
         return
      endif

C  Do the subtraction, for valid pixels in the right area, with scaling

      do k = lys, lye
         do j = lxs, lxe
            if ( rdata(j,k).ne.rinval ) then
               call profval ( val, j, k, xp, yp, hp, lx, ly, co, si,
     +                        sim, gx2, gy2, ap, hx2, hy2, qh, qr, qp,
     +                        domap, map, mx, my, mx, mapnum, mapx,
     +                        mapy, magnif )
               rdata(j,k) = rdata(j,k) - val/bs
            endif
         enddo
      enddo

      kw(1) = lxs
      kw(2) = lxe
      kw(3) = lys
      kw(4) = lye


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="popsms"> POPSMS  </a>-- Subtract a star from a short image with magic values
C
C   a.j.penny                   ral                    1988-08-06


      subroutine popsms ( sdata, nx, ny, bs, inval, xp, yp, hp, prof,
     +                    map, mx, my, mz, mapnum,
     +                    mapx, mapy, magnif, domap, ierr, kw )

      implicit none
      include 'STARMAN_INC'

      integer	nx		!i: X size of image
      integer	ny		!i: Y size of image
      integer*2	sdata(nx,ny)  	!i/o: image
      real      bs              !i: Scale of image
      integer   inval		!i: image pixel magic value
      real	xp		!i: star x posn
      real	yp		!i: star y posn
      real	hp      	!i: star height
      real	prof(9)		!i: profile (rx,ry,p,prx,pry,angle(radians),
				!            wh,wp,wr)
      logical   domap	 	!i: Flag whether to use map
      integer   mx		!i: Maximum Map x size in Map array
      integer   my		!i: Maximum Map y size in Map array
      integer   mz		!i: Total no of maps in Map array
      real      map(mx,my,mz) 	!i: Array containing all maps
      integer   mapnum		!i: Number of map to actually use
      integer   mapx		!i: Actual Map x size
      integer   mapy		!i: Actual Map x size
      integer   magnif		!i: Map pixel subdivision
      integer	ierr		!o: Error flag (0=ok:1=no placement)
      integer   kw(4)		!o: Bounds of area affected (lxs,lxe,lys,lye)
C--
      real co, si, sim, qh, qr, qp, val, ap, hx2, hy2, gx2, gy2
      integer lxs, lxe, lys, lye, j, k, lx, ly
      logical ok
Cbegin


      if ( ST_FAILED ) return

C  Set up parameters and check if ok

      call proset ( xp, yp, hp, prof, lx, ly, lxs, lxe, lys, lye, co,
     +              si, sim, gx2, gy2, ap, hx2, hy2, qh, qr, qp, nx,
     +              ny, ok )
      ierr = 0
      if ( .not.ok ) then
         ierr = 1
         return
      endif

C  Do the subtraction, for valid pixels in the right area, with scaling

      do k = lys, lye
         do j = lxs, lxe
            if ( sdata(j,k).ne.inval ) then
               call profval ( val, j, k, xp, yp, hp, lx, ly, co, si,
     +                        sim, gx2, gy2, ap, hx2, hy2, qh, qr, qp,
     +                        domap, map, mx, my, mx, mapnum, mapx,
     +                        mapy, magnif )
               val = real(sdata(j,k)) - val/bs
               sdata(j,k) = nint(min(32767.0,max(-32768.0,val)))
            endif
         enddo
      enddo

      kw(1) = lxs
      kw(2) = lxe
      kw(3) = lys
      kw(4) = lye


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="proset"> PROSET  </a>-- Set up values for s/r POP(AS)(FM)(SR)
C
C  a j penny              ral                1989-08-04

      subroutine proset ( xp, yp, hp, prof, lx, ly, lxs, lxe, lys, lye,
     +                    co, si, sim, gx2, gy2, ap, hx2, hy2, qh, qr,
     +                    qp, nx, ny, ok )

      implicit none
      include 'STARMAN_INC'

      real xp		!i: X position wrt profile centre
      real yp		!i: Y position wrt profile centre
      real hp		!i: Star height
      real prof(9)	!i: Profile
      real co		!o: Cosine (profile angle)
      real si		!o: Sine (profile angle)
      real sim		!o: -1*sine (profile angle)
      real qh		!o: Gaussian profile height
      real qr		!o: Gaussian profile radius
      real qp		!o: Gaussian profile power
      real ap		!o: Power/2.0
      real hx2		!o: 1/(X radius squared)
      real hy2		!o: 1/(Y radius squared)
      real gx2		!o: 1/(X power radius squared)
      real gy2		!o: 1/(Y power radius squared)
      integer lxs	!o: X start of box to work in
      integer lxe	!o: X end of box to work in
      integer lys	!o: Y start of box to work in
      integer lye	!o: Y end of box to work in
      integer lx	!o: Recommended X pixel sub-division
      integer ly	!o: Recommended Y pixel sub-division
      integer nx	!i: X image size
      integer ny	!i: Y image size
      logical ok	!o: Error flag (true=ok;false=bad)
C--
      real gx, gy, hx, hy, p, theta, gav, hav, dl, ha, hal, hag, yap
Cbegin


      if ( ST_FAILED ) return

      ok = .true.

C  Check to see if profile radii all +ve

      if ( prof(1).le.0.0 .or. prof(2).le.0.0 .or. prof(4).le.0.0 .or.
     +     prof(5).le.0.0 ) then
         ok = .false.
         return
      endif
      if ( prof(7).ne.0.0 .and. prof(8).le.0.0 ) then
         ok = .false.
         return
      endif

C  Check to see if height is non-zero

      if ( hp.eq.0.0 ) then
         ok = .false.
         return
      endif

C  Load image parameters

      gx = 1.0/prof(1)
      gy = 1.0/prof(2)
      hx = 1.0/prof(4)
      hy = 1.0/prof(5)
      gav = (gx+gy)/2.0
      hav = (hx+hy)/2.0
      p = prof(3)
      theta = prof(6)
      co = cos(theta)
      si = sin(theta)
      sim = -1.0*si

      qh = prof(7)
      if ( qh.ne.0.0 ) qr = 1.0/prof(8)
      qp = prof(9)

C  Calculate distance (dl) out to work to, as set by image value = 0.2

      dl = 0.0
      ha = hp
      hal = hp
      hag = hp*qh
      do while (ha.gt.0.2)

         dl = dl + 1.0

C  Lorentz part
C  Calculate hal = hp/(1.0+(dl*gav)**(p*(1.0+dl*hav))), avoiding overfow

         if (hal.gt.0.01) then
            yap = p*(1.0+dl*hav)*alog(dl*gav)
            if (yap.lt.20.0) then
               hal = hp/(1.0+exp(yap))
            else
               hal = 0.0
            endif
         endif

C  Gaussian part

         if ( hag.gt.0.01 ) then
            hag = hp*qh*exp(-1.0*((dl*qr)**qp))
         endif

         ha = hal + hag

      enddo

C  Box in image to work in

      lxs = xp - dl
      lxe = lxs + 2*dl + 1.0
      lys = yp - dl
      lye = lys + 2*dl + 1.0

C  Return if none in area

      if ( lxs.gt.nx .or. lxe.lt.1 .or. lys.gt.ny .or. lye.lt.1 ) then
         ok = .false.
         return
      endif

C  Check only work in area

      lxs = max(1,min(lxs,nx))
      lxe = max(1,min(lxe,nx))
      lys = max(1,min(lys,ny))
      lye = max(1,min(lye,ny))

C Preload more image parameters

      lx = 1 + int(2.9/min(prof(1),prof(2)))
      ly = lx
      ap = prof(3)/2.0
      gx2 = 1.0/(prof(1)*prof(1))
      gy2 = 1.0/(prof(2)*prof(2))
      hx2 = 1.0/(prof(4)*prof(4))
      hy2 = 1.0/(prof(5)*prof(5))


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="profval"> PROFVAL  </a>-- Calc profile value at a pixel.
C
C   a.j.penny                   stsCi                 1987-02-20

      subroutine profval ( val, j, k, xp, yp, hp, lx, ly, co, si, sim,
     +                     gx2, gy2, ap, hx2, hy2, qh, qr, qp,
     +                     domap, map, mx, my, mz, mapnum, mapx, mapy,
     +                     magnif )

      implicit none
      include 'STARMAN_INC'

      real    val	    !o: Profile value
      integer j	 	    !i: X position
      integer k	 	    !i: Y position
      real    xp	    !i: X position wrt profile centre
      real    yp	    !i: Y position wrt profile centre
      real    hp	    !i: Star height
      integer lx	    !i: X pixel sub-division
      integer ly	    !i: Y pixel sub-division
      real    co	    !i: Cosine (profile angle)
      real    si	    !i: Sine (profile angle)
      real    sim	    !i: -1*sine (profile angle)
      real    gx2	    !i: 1/(X power radius squared)
      real    gy2	    !i: 1/(Y power radius squared)
      real    ap	    !i: Power/2.0
      real    hx2	    !i: 1/(X radius squared)
      real    hy2	    !i: 1/(Y radius squared)
      real    qh	    !i: Gaussian profile height
      real    qr	    !i: Gaussian profile radius
      real    qp	    !i: Gaussian profile power
      logical domap	    !i: Flag whether to use map
      integer mx	    !i: Maximum Map x size in Map array
      integer my	    !i: Maximum Map y size in Map array
      integer mz	    !i: Total no of maps in Map array
      real    map(mx,my,mz) !i: Array containing all maps
      integer mapnum	    !i: Number of map to actually use
      integer mapx	    !i: Actual Map x size
      integer mapy	    !i: Actual Map x size
      integer magnif	    !i: Map pixel subdivision
C--
      real dx, dy, ay, ax, dxa, dya, da, db, dxb, dyb, zt, dla, z, vala,
     +     dfdx, dfdy, dxm, dym
      integer llx, lly, mapx2, mapy2
      real rinter
      external rinter
Cbegin


      if ( ST_FAILED ) return

      dx = real(j) - xp
      dy = real(k) - yp
      z = 0.0
      do lly = 1, ly
         do llx = 1, lx
            ay = -0.5 + ((0.5+real(lly)-1.0)/real(ly))
            ax = -0.5 + ((0.5+real(llx)-1.0)/real(lx))
            dxa = dx + ax
            dya = dy + ay
            dla = sqrt(dxa*dxa+dya*dya)
            if (dla.lt.0.00001) dla = 0.00001
            dxb = dxa*co + dya*si
            dyb = dxa*sim + dya*co
            da = dxb*dxb*gx2 + dyb*dyb*gy2
            if (da.lt.0.00001) da = 0.00001
            db = sqrt(dxb*dxb*hx2+dyb*dyb*hy2)
            zt = ap*(1.0+db)*alog(da)
            if (zt.gt.10.0) zt = 10.0
            z = z + 1.0/(1.0+exp(zt))

            if (qh.ne.0.0) then
               zt = (dla*qr)**qp
               if (zt.gt.10.0) zt = 10.0
               z = z + qh*exp(-1.0*zt)
            endif

         enddo
      enddo

      val = hp*(z/real(lx*ly))

C     And the profile map at the pixel

      if ( domap ) then
         dxm = dx*real(magnif)
         dym = dy*real(magnif)
         mapx2 = mapx/2
         mapy2 = mapy/2
         ax = mapx2 + dxm
         ay = mapy2 + dym
         vala = rinter ( map, mx, my, mz, mapnum, mapx, mapy,
     +                   ax, ay, dfdx, dfdy )
         val = val + hp*vala
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="sky_0"> SKY_0  </a>-- Find background and noise in a real or integer*2 image
C
C  Divide image into 50x50 squares. Get square with lowest mean
C  value. Assume this is the background.
C
C  Take this area. Make a histogram. Fit a Gaussian to the
C  peak. Take mean and std dev of that Gaussian as the mean
C  and std dev of the image background.
C
C   a j penny                   stsci             86-12-02

      subroutine sky_0 ( im, gtype, nx, ny, inval, rinval, skylev,
     +                   skystd )

      implicit none
      include 'STARMAN_INC'

      integer   nx		!i: Image X size
      integer   ny		!i: Image Y size
      integer*2 im(*)		!i: Input image
      character*(*)  gtype	!i: Image type (REAL/SHORT)
      integer   inval		!i: Image (int*2) invalid number flag
      real      rinval		!i: Image (real) invalid number flag
      real      skylev		!o: Background level
      real      skystd		!o: Background noise
C--

      integer kgram(1000), kxc(2), kyc(2), nxbox, nybox, j, k, kl
      integer jl, istat, kmin, kbin, num, lmax, lmin, kv, iter
      real rkgram(1000), aam1, astd1, aam, astd, xo, a, b, r, pow,
     +     rva(1), rbin, rmin, rmax
      integer jfita(5,4)
      data jfita / 0, 1, 1, 0, 1,
     +             0, 0, 0, 0, 1,
     +             0, 1, 1, 0, 0,
     +             0, 1, 1, 0, 1 /
Cbegin


      if ( ST_FAILED ) return

      kxc(1) = 1 							!Get 1st background for
      kxc(2) = min(50,nx)						! b.l.h. 50x50 box
      kyc(1) = 1
      kyc(2) = min(50,ny)
      if ( gtype.eq.'SHORT' ) then
         call ranges ( im, nx, ny, kxc, kyc, inval, aam1, astd1, istat )
      else
         call ranger ( im, nx, ny, kxc, kyc, rinval, aam1, astd1, istat)
      endif

      nxbox = 1 + (nx-1)/50						!Find position of 50x50
      nybox = 1 + (ny-1)/50						! box with lowest mean
      j = 1
      k = 1
      jl = j
      kl = k
      do k = 1, nybox
         do j = 1, nxbox
            kxc(1) = 1 + (j-1)*50
            kxc(2) = min((50+(j-1)*50),nx)
            kyc(1) = 1 + (k-1)*50
            kyc(2) = min((50+(k-1)*50),ny)
            if ( gtype.eq.'SHORT' ) then
               call ranges ( im, nx, ny, kxc, kyc, inval,aam,astd,istat)
            else
               call ranger ( im, nx, ny, kxc, kyc,rinval,aam,astd,istat)
            endif
            if ( aam.lt.aam1 ) then
               aam1 = aam
               astd1 = astd
               jl = j
               kl = k
            endif
         enddo
      enddo

      rmin = aam1 - 6.0*astd1						!Take mean +/- 6 std dev
      rmax = aam1 + 6.0*astd1
      rbin = 1.0 + (rmax-rmin)/1000.0
      kbin = rbin
      kmin = rmin
      num = (rmax-rmin-1)/kbin
      kxc(1) = 1 + (jl-1)*50						!Define area
      kxc(2) = min((50+(jl-1)*50),nx)
      kyc(1) = 1 + (kl-1)*50
      kyc(2) = min((50+(kl-1)*50),ny)
      if ( gtype.eq.'SHORT' ) then				 	!Make histogram
         call hgrams ( im, nx, ny, kxc(1), kxc(2), kyc(1), kyc(2),
     +                 kmin, kgram, 1000, kbin, inval )
      else
         call hgramr ( im, nx, ny, kxc(1), kxc(2), kyc(1), kyc(2),
     +                 rmin, kgram, 1000, rbin, rinval )
      endif

      lmin = kgram(1)							!Fit 1-D Gaussian to histogram
      lmax = kgram(1)
      xo = 1
      do k = 1, 1000
         kv = kgram(k)
         rkgram(k) = kgram(k)
         lmin = min(lmin,kv)
         if ( kv.gt.lmax ) then
            lmax = kv
            xo = k
         endif
      enddo
      a = lmin
      b = lmax - lmin
      r = astd/(1.5*rbin)
      pow = 2.0
      do j = 2, 4
         call gauss1r ( rkgram, rva, 1000, .false., 1, num, a, b, r,
     +           pow, xo, jfita(1,j), 0.004, 0.004, 20, 0.5, iter, 0 )
      enddo
      r = min(real(num),max(0.1,r))
      xo = min(real(num),max(1.0,xo))

      lmin = min(real(num),max(1.0,(xo-2.0*r)))				!Refine fit by fitting to
      lmax = max(1.0,min(real(num),(xo+2.0*r)))				! histogram peak
      if ( (lmin+1).ge.lmax ) then
         skylev = rmin - 1 + rbin*real(lmin+lmax)/2.0
         skystd = rbin*real(lmax-lmin)/4.0
      else
         do j = 2, 4
            call gauss1r ( rkgram, rva, 1000, .false., lmin, lmax, a,
     +      b, r, pow, xo, jfita(1,j), 0.004, 0.004, 20, 0.5, iter, 0 )
         enddo
         r = min(real(num),max(0.1,r))
         xo = min(real(lmax),max(real(lmin),xo))
         skylev = rmin - 1 + xo*rbin					!Turn histogram mean, std dev
         skystd = r*rbin						! to image mean, std dev
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="sky_1r"> SKY_1R  </a>-- Find background and noise in boxes in a real image
C
C   a j penny                   stsci             86-12-02

      subroutine sky_1r ( im, nx, ny, rinval, msky, asky, nxsky, nysky,
     +                    csky, bsky, nxsd, nysd, failed )

      implicit none
      include 'STARMAN_INC'

      integer        nx, ny			!i: Image size
      real           im(nx,ny)			!i: Input image
      real           rinval			!i: Image (real) invalid number flag
      real           msky(nx,ny)		!o: Sky level
      real           asky(nx,ny)		!o: Sky level + 1 std dev
      integer        nxsky, nysky		!i: No of sky boxes
      real           bsky(nxsky,nysky)		!o: Mean + 1 std dev in sky boxes
      real           csky(nxsky,nysky)		!o: Mean levels in sky boxes
      integer        nxsd			!i: X Size of sky boxes
      integer        nysd			!i: Y Size of sky boxes
      logical        failed			!i/o: Failure flag. True = exit
C--

      integer kgram(1024), kxc(2), kyc(2), j, k, istat,
     +        num, numbin, lmin, lmax, kv, kkmin, kkmax,
     +        iter, kxa, kxb, kya, kyb, ja, kk
      real rkgram(1024), aam, astd, a, b, r, xo, val, skylev, avtot,
     +     pow, rva(1), rmin, rmax, rbin, rsky
      logical allinv
      integer jfita(5,4)
      data jfita / 0, 1, 1, 0, 1,
     +             0, 0, 0, 0, 1,
     +             0, 1, 1, 0, 0,
     +             0, 1, 1, 0, 1 /
Cbegin


      if ( ST_FAILED ) return

      if ( failed ) return						!Check failure

      numbin = min( 1024, int(500.0*real(nxsd)*real(nysd)/4096.0) )	!Get mean levels and scatters

      skylev = 0.0
      val = 1.0
      do k = 1, nysky
         do j = 1, nxsky

            kxc(1) = 1 + (j-1)*nxsd
            kxc(2) = min((nxsd+(j-1)*nxsd),nx)
            kyc(1) = 1 + (k-1)*nysd
            kyc(2) = min((nysd+(k-1)*nysd),ny)

            call azzallbadr ( im, nx, ny, rinval, kxc, kyc, allinv )	!Check some valid

            if ( .not.allinv ) then					!Default level
               call ranger ( im, nx, ny, kxc,kyc,rinval,aam,astd,istat)
               skylev = aam
               val = aam + astd
            endif

            if ( .not.allinv .and. 					!Better level
     +          (((kxc(2)-kxc(1)).ge.9).and.((kyc(2)-kyc(1)).ge.9)))then
               skylev = aam
               val = aam + 1.0
               rmin = aam - 6.0*astd
               rmax = aam + 6.0*astd
               rbin = (rmax-rmin)/real(numbin)
               num =  1 + int((rmax-rmin)/rbin)

               if ( num.gt.4 ) then
                  kxa = 1 + (j-1)*nxsd
                  kxb = min((nxsd+(j-1)*nxsd),nx)
                  kya = 1 + (k-1)*nysd
                  kyb = min((nysd+(k-1)*nysd),ny)
                  call hgramr ( im, nx, ny, kxa, kxb, kya, kyb, rmin,
     +                          kgram, numbin, rbin, rinval )
                  lmin = kgram(1)
                  lmax = kgram(1)
                  xo = 1
                  avtot = 0.0
                  do kk = 1, numbin
                     kv = kgram(kk)
                     rkgram(kk) = kgram(kk)
                     avtot = avtot + kv
                     lmin = min(lmin,kv)
                     if ( kv.gt.lmax ) then
                        lmax = kv
                        xo = kk
                     endif
                  enddo
                  if ( avtot.ne.0.0 ) then
                     if ( (real(lmax)/avtot).le.0.4 ) then
                        a = lmin
                        b = lmax - lmin
                        r = astd/(1.5*rbin)
                        pow = 2.0
                        do ja = 2, 4
                           call gauss1r ( rkgram, rva, numbin, .false.,
     +                          1, num, a, b, r, pow, xo, jfita(1,ja),
     +                          0.004, 0.004, 20, 0.5, iter,  0 )
                        enddo
                        r = min(real(numbin),max(0.1,r))
                        xo = min(real(numbin),max(1.0,xo))
                        kkmin = min(real(numbin),max(1.0,(xo-2.0*r)))
                        kkmax = max(1.0,min(real(numbin),(xo+2.0*r)))
                        if ( (kkmin+1).ge.kkmax ) then
                          skylev =rmin+(rbin*real(kkmin+kkmax)/2.0)-rbin
                          val = skylev + 1.5*rbin*real(kkmax-kkmin)/4.0
                        else
                           do ja = 2, 4
                              call gauss1r ( rkgram, rva, numbin,
     +                        .false., kkmin, kkmax, a, b, r, pow, xo,
     +                        jfita(1,ja) ,0.004, 0.004, 20, 0.5,iter,0)
                           enddo
                           r = min(real(numbin),max(0.1,r))
                           xo = min(real(numbin),max(1.0,xo))
                           skylev = rmin + xo*rbin - rbin
                           val =  skylev + 1.5*r*rbin
                        endif
                     endif
                  endif
               endif
            endif

            bsky(j,k) = val						!Load level
            csky(j,k) = skylev

         enddo
      enddo

      do k = 1, ny							!Turn means into a sky map
         do j = 1, nx
            call sky_2r ( bsky, nxsky, nysky, j, k, rsky, nxsd, nysd )
            asky(j,k) = rsky
         enddo
      enddo
      do k = 1, ny
         do j = 1, nx
            call sky_2r ( csky, nxsky, nysky, j, k, rsky, nxsd, nysd )
            msky(j,k) = rsky
         enddo
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="sky_1s"> SKY_1S  </a>-- Find background and noise in boxes in a real image
C
C   a j penny                   stsci             86-12-02

      subroutine sky_1s ( im, nx, ny, inval, msky, asky, nxsky, nysky,
     +                    csky, bsky, nxsd, nysd, failed )

      implicit none
      include 'STARMAN_INC'

      integer        nx, ny			!i: Image size
      integer*2      im(nx,ny)			!i: Input image
      integer        inval			!i: Image (real) invalid number flag
      real           msky(nx,ny)		!o: Sky level
      real           asky(nx,ny)		!o: Sky level + 1 std dev
      integer        nxsky, nysky		!i: No of sky boxes
      real           bsky(nxsky,nysky)		!o: Mean + 1 std dev in sky boxes
      real           csky(nxsky,nysky)		!o: Mean levels in sky boxes
      integer        nxsd			!i: X Size of sky boxes
      integer        nysd			!i: Y Size of sky boxes
      logical        failed			!i/o: Failure flag. True = exit
C--

      integer kgram(1024), kxc(2), kyc(2), j, k, istat, kmin, kmax,
     +        kbin, num, numbin, lmin, lmax, kv, kkmin, kkmax,
     +        iter, kxa, kxb, kya, kyb, ja, kk
      real rkgram(1024), aam, astd, a, b, r, xo, val, skylev, avtot,
     +     pow, rva(1), rsky
      logical allinv
      integer jfita(5,4)
      data jfita / 0, 1, 1, 0, 1,
     +             0, 0, 0, 0, 1,
     +             0, 1, 1, 0, 0,
     +             0, 1, 1, 0, 1 /
Cbegin


      if ( ST_FAILED ) return

      if ( failed ) return						!Check failure

      numbin = min( 1024, int(500.0*real(nxsd)*real(nysd)/4096.0) )	!Get mean levels and scatters

      skylev = 0.0
      val = 1.0
      do k = 1, nysky
         do j = 1, nxsky

            kxc(1) = 1 + (j-1)*nxsd
            kxc(2) = min((nxsd+(j-1)*nxsd),nx)
            kyc(1) = 1 + (k-1)*nysd
            kyc(2) = min((nysd+(k-1)*nysd),ny)

            call azzallbads ( im, nx, ny, inval, kxc, kyc, allinv )	!Check some valid

            if ( .not.allinv ) then					!Default level
               call ranges ( im, nx, ny, kxc,kyc,inval,aam,astd,istat)
               skylev = aam
               val = aam + astd
            endif

            if ( .not.allinv .and. 					!Better level
     +          (((kxc(2)-kxc(1)).ge.9).and.((kyc(2)-kyc(1)).ge.9)))then
               skylev = aam
               val = aam + 1.0
               kmin = aam - 6.0*astd
               kmax = aam + 6.0*astd
               kbin = 1 + (kmax-kmin)/numbin
               num =  (kmax-kmin+1)/kbin

               if ( num.gt.4 ) then
                  kxa = 1 + (j-1)*nxsd
                  kxb = min((nxsd+(j-1)*nxsd),nx)
                  kya = 1 + (k-1)*nysd
                  kyb = min((nysd+(k-1)*nysd),ny)
                  call hgrams ( im, nx, ny, kxa, kxb, kya, kyb, kmin,
     +                          kgram, numbin, kbin, inval )
                  lmin = kgram(1)
                  lmax = kgram(1)
                  xo = 1
                  avtot = 0.0
                  do kk = 1, numbin
                     kv = kgram(kk)
                     rkgram(kk) = kgram(kk)
                     avtot = avtot + kv
                     lmin = min(lmin,kv)
                     if ( kv.gt.lmax ) then
                        lmax = kv
                        xo = kk
                     endif
                  enddo
                  if ( avtot.ne.0.0 ) then
                     if ( (real(lmax)/avtot).le.0.4 ) then
                        a = lmin
                        b = lmax - lmin
                        r = astd/(1.5*kbin)
                        pow = 2.0
                        do ja = 2, 4
                           call gauss1r ( rkgram, rva, numbin, .false.,
     +                          1, num, a, b, r, pow, xo, jfita(1,ja),
     +                          0.004, 0.004, 20, 0.5, iter,  0 )
                        enddo
                        r = min(real(numbin),max(0.1,r))
                        xo = min(real(numbin),max(1.0,xo))
                        kkmin = min(real(numbin),max(1.0,(xo-2.0*r)))
                        kkmax = max(1.0,min(real(numbin),(xo+2.0*r)))
                        if ( (kkmin+1).ge.kkmax ) then
                          skylev = kmin - 1 + kbin*real(kkmin+kkmax)/2.0
                          val = skylev + 1.5*kbin*real(kkmax-kkmin)/4.0
                        else
                           do ja = 2, 4
                              call gauss1r ( rkgram, rva, numbin,
     +                        .false., kkmin, kkmax, a, b, r, pow, xo,
     +                        jfita(1,ja) ,0.004, 0.004, 20, 0.5,iter,0)
                           enddo
                           r = min(real(numbin),max(0.1,r))
                           xo = min(real(numbin),max(1.0,xo))
                           skylev = kmin - 1 + xo*kbin
                           val =  skylev + 1.5*r*kbin
                        endif
                     endif
                  endif
               endif
            endif

            bsky(j,k) = val						!Load level
            csky(j,k) = skylev

         enddo
      enddo

      do k = 1, ny							!Turn means into a sky map
         do j = 1, nx
            call sky_2r ( bsky, nxsky, nysky, j, k, rsky, nxsd, nysd )
            asky(j,k) = rsky
         enddo
      enddo
      do k = 1, ny
         do j = 1, nx
            call sky_2r ( csky, nxsky, nysky, j, k, rsky, nxsd, nysd )
            msky(j,k) = rsky
         enddo
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="sky_2s"> SKY_2S  </a>-- Find the sky, given a sky map table, and a position
C
C  a j penny                      stsci               1987 dec

      subroutine sky_2s ( asky, nxsky, nysky, kx, ky, ksky, nxsd, nysd )

      implicit none
      include 'STARMAN_INC'

      integer   nxsky			!i: X size of sky map table
      integer   nysky			!i: Y size of sky map table
      integer*2 asky(nxsky,nysky)	!i: Sky map table
      integer	kx			!i: X position
      integer   ky			!i: Y position
      integer	ksky			!o: Sky value
      integer	nxsd			!i: X box size in sky map table
      integer	nysd			!i: Y box size in sky map table
C--
      integer kxa, kya, kxb, kyb
      real usky, tsky, dx, dy, xa, ya
Cbegin


      if ( ST_FAILED ) return

      xa = 1.0 + (real(kx)-(real(nxsd)/2.0))/real(nxsd)			!Set up position relative to the grid of box mean points
      ya = 1.0 + (real(ky)-(real(nysd)/2.0))/real(nysd)
      kxa = xa
      kxb = kxa + 1
      kya = ya
      kyb = kya + 1
      dx = xa - kxa
      dy = ya - kya

      if ( kxa.lt.1 .and. kya.lt.1 ) then				!Do the interpolation for the
         ksky = asky(1,1)						! cases at the corners, at the edges,
      elseif ( kxa.lt.1 .and. kya.ge.nysky ) then			! in the body
         ksky = asky(1,nysky)
      elseif ( kxa.ge.nxsky .and. kya.lt.1 ) then
         ksky = asky(nxsky,1)
      elseif ( kxa.ge.nxsky .and. kya.ge.nysky ) then
         ksky = asky(nxsky,nysky)
      elseif ( kxa.lt.1 ) then
         ksky = asky(1,kya)+dy*(asky(1,kyb)-asky(1,kya))
      elseif ( kxa.ge.nxsky ) then
         ksky = asky(nxsky,kya)+dy*(asky(nxsky,kyb)-asky(nxsky,kya))
      elseif ( kya.lt.1 ) then
         ksky = asky(kxa,1)+dx*(asky(kxb,1)-asky(kxa,1))
      elseif ( kya.ge.nysky ) then
         ksky = asky(kxa,nysky)+dx*(asky(kxb,nysky)-asky(kxa,nysky))
      else
         tsky = asky(kxa,kya)+dx*(asky(kxb,kya)-asky(kxa,kya))
         usky = asky(kxa,kyb)+dx*(asky(kxb,kyb)-asky(kxa,kyb))
         ksky = tsky+dy*(usky-tsky)
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="sky_2r"> SKY_2R  </a>-- Find the sky, given a sky map table, and a position
C
C  a j penny                      stsci               1987 dec

      subroutine sky_2r ( asky, nxsky, nysky, kx, ky, rsky, nxsd, nysd )

      implicit none
      include 'STARMAN_INC'

      integer   nxsky			!i: X size of sky map table
      integer   nysky			!i: Y size of sky map table
      real      asky(nxsky,nysky)	!i: Sky ymap table
      integer	kx			!i: X position
      integer   ky			!i: Y position
      real      rsky			!o: Sky value
      integer	nxsd			!i: X box size in sky map table
      integer	nysd			!i: Y box size in sky map table
C--
      integer kxa, kya, kxb, kyb
      real usky, tsky, dx, dy, xa, ya
Cbegin


      if ( ST_FAILED ) return

      xa = 1.0 + (real(kx)-(real(nxsd)/2.0))/real(nxsd)			!Set up position relative to the grid of box mean points
      ya = 1.0 + (real(ky)-(real(nysd)/2.0))/real(nysd)
      kxa = xa
      kxb = kxa + 1
      kya = ya
      kyb = kya + 1
      dx = xa - kxa
      dy = ya - kya

      if ( kxa.lt.1 .and. kya.lt.1 ) then				!Do the interpolation for the
         rsky = asky(1,1)						! cases at the corners, at the edges,
      elseif ( kxa.lt.1 .and. kya.ge.nysky ) then			! in the body
         rsky = asky(1,nysky)
      elseif ( kxa.ge.nxsky .and. kya.lt.1 ) then
         rsky = asky(nxsky,1)
      elseif ( kxa.ge.nxsky .and. kya.ge.nysky ) then
         rsky = asky(nxsky,nysky)
      elseif ( kxa.lt.1 ) then
         rsky = asky(1,kya)+dy*(asky(1,kyb)-asky(1,kya))
      elseif ( kxa.ge.nxsky ) then
         rsky = asky(nxsky,kya)+dy*(asky(nxsky,kyb)-asky(nxsky,kya))
      elseif ( kya.lt.1 ) then
         rsky = asky(kxa,1)+dx*(asky(kxb,1)-asky(kxa,1))
      elseif ( kya.ge.nysky ) then
         rsky = asky(kxa,nysky)+dx*(asky(kxb,nysky)-asky(kxa,nysky))
      else
         tsky = asky(kxa,kya)+dx*(asky(kxb,kya)-asky(kxa,kya))
         usky = asky(kxa,kyb)+dx*(asky(kxb,kyb)-asky(kxa,kyb))
         rsky = tsky+dy*(usky-tsky)
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="subdiv"> SUBDIV  </a>-- Calc pixel sub-division needed for given profile
C
C   a j penny                 dao           1988-04-25

      subroutine subdiv ( r1, r2, ksubdiv )

      implicit none
      include 'STARMAN_INC'

      real	r1		!i: 1st radius
      real	r2		!i: 2nd radius
      integer	ksubdiv		!o: Pixel sub-division
C--
      real	ar
Cbegin


      if ( ST_FAILED ) return

      ar = min(r1,r2)
      if ( ar.lt.0.001 ) then
         ksubdiv = 1
      else
         ksubdiv = 1 + int(2.9/ar)
      endif


      end

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C  STARFLIBV.F
C
C  It contains vector operations in the same format as the IRAF ones:-
C
C
C AADD(DIRS)     Add two vectors to make a third. C = A + B
C AADDK(DIRS)    Add constant to vector to make second B = A + K
C AAVG(DIRS)     Mean and standard deviation of an array
C ACHT(IRS:DIRS) Load a (real:int:short) array into a (dble:real:int:short) array
C ACHVAL(IRS)    Change a particular value in elements in a (short:int:real) vector
C ADIV(DIRS)     Divide array by another. C = A/B
C ADIVK(DIRS)    Divide array by constant.  B = A/K
C ALIM(DIRS)     Min and max of a vector
C AMEDIAN(IRS)   Median of (int:real:short) vector
C AMOV(BDIRS)    Load an array into another  B = A
C AMOVK(BDIRS)   Load a constant into an array  A = K
C AMUL(DIRS)     Multiply two arrays C = A.B
C AMULK(DIRS)    Multiply an array by a constant B = A.K
C ANUMINC(IR)    Load numbers (1,2,3,..) into array
C ASUB(DIRS)     Subtract a vector from another vector C = A - B
C ASUBK(DIRS)    Subtract a constant from a vector B = A - K
C ASUM(DIRS)     Sum a vector
C AZERO(BDIRS)   Zero a vector

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="aaddd"> AADDD  </a>-- Adds two double precision vectors to make a third. C = A + B
C   a j penny                 dao           1988-04-25
      subroutine aaddd ( a, b, c, n )
      implicit none
      integer	n		!i: no of elements to add
      double precision 	a(n)	!i: 1st input vector
      double precision	b(n)	!i: 2nd input vector
      double precision	c(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         c(j) = a(j) + b(j)
      enddo
      end
C <a name="aaddi"> AADDI  </a>-- Adds two integer vectors to make a third. C = A + B
C   a j penny                 dao           1988-04-25
      subroutine aaddi ( a, b, c, n )
      implicit none
      integer	n	!i: no of elements to add
      integer	a(n)	!i: 1st input vector
      integer	b(n)	!i: 2nd input vector
      integer	c(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         c(j) = a(j) + b(j)
      enddo
      end
C <a name="aaddr"> AADDR  </a>-- Adds two real vectors to make a third. C = A + B
C   a j penny                 dao           1988-04-25
      subroutine aaddr ( a, b, c, n )
      implicit none
      integer	n	!i: no of elements to add
      real	a(n)	!i: 1st input vector
      real	b(n)	!i: 2nd input vector
      real	c(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         c(j) = a(j) + b(j)
      enddo
      end
C <a name="aadds"> AADDS  </a>-- Adds two short integer vectors to make a third. C = A + B
C   a j penny                 dao           1988-04-25
      subroutine aadds ( a, b, c, n )
      implicit none
      integer	n	!i: no of elements to add
      integer*2	a(n)	!i: 1st input vector
      integer*2	b(n)	!i: 2nd input vector
      integer*2	c(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         c(j) = a(j) + b(j)
      enddo
      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="aaddkd"> AADDKD  </a>-- Adds dble prec constant to vector to make second B=A+K
C   a j penny                 dao           1988-04-25
      subroutine aaddkd ( a, k, b, n )
      implicit none
      integer		n	!i: no of elements to add
      double precision	a(n)	!i: input vector
      double precision	k	!i: Constant to add
      double precision	b(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         b(j) = a(j) + k
      enddo
      end
C <a name="aaddki"> AADDKI  </a>-- Adds integer constant to integer vector to make second B=A+K
C   a j penny                 dao           1988-04-25
      subroutine aaddki ( a, k, b, n )
      implicit none
      integer	n	!i: no of elements to add
      integer	a(n)	!i: input vector
      integer	k	!i: Constant to add
      integer	b(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         b(j) = a(j) + k
      enddo
      end
C <a name="aaddkr"> AADDKR  </a>-- Adds real constant to real vector to make second B+A+K
C   a j penny                 dao           1988-04-25
      subroutine aaddkr ( a, k, b, n )
      implicit none
      integer	n	!i: no of elements to add
      real	a(n)	!i: input vector
      real	k	!i: Constant to add
      real	b(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         b(j) = a(j) + k
      enddo
      end
C <a name="aaddks"> AADDKS  </a>-- Adds short integer constant to vector to make second B+A+K
C   a j penny                 dao           1988-04-25
      subroutine aaddks ( a, k, b, n )
      implicit none
      integer	n	!i: no of elements to add
      integer*2	a(n)	!i: input vector
      integer*2	k	!i: Constant to add
      integer*2	b(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         b(j) = a(j) + k
      enddo
      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="aavgd"> AAVGD  </a>-- Calcs the mean and standard deviation of a double precision array
C
C   a j penny                 dao           1988-04-25

      subroutine aavgd ( a, n, av, sd )
      implicit none
      integer		n	!i: no of elements in vector
      double precision 	a(n)	!i: input vector
      double precision 	av	!o: Mean
      double precision 	sd	!o: Standard deviation
C--
      integer j
Cbegin
      double precision ds, dss, dn

      av = 0.0d0
      sd = 0.0d0
      if ( n.lt.1 ) return

      ds = 0.0d0
      dss = 0.0d0
      do j = 1, n
         ds = ds + a(j)
         dss = dss + a(j)*a(j)
      enddo

      dn = dble(n)
      av = ds/dn
      if ( n.gt.1 ) then
         dss = ( dss-ds*ds/dn)/(dn-1.0d0)
         if ( dss.gt.1.0d-20 ) sd = dsqrt(dss)
      endif
      end
C <a name="aavgi"> AAVGI  </a>-- Calcs the mean and standard deviation of an integer array
      subroutine aavgi ( a, n, av, sd )
      implicit none
      integer	n	!i: no of elements in vector
      integer	a(n)	!i: input vector
      real	av	!o: Mean
      real	sd	!o: Standard deviation
C--
      integer j
      double precision ds, dss, dn
      real rv
Cbegin
      av = 0.0
      sd = 0.0
      if ( n.lt.1 ) return

      ds = 0.0
      dss = 0.0
      do j = 1, n
         rv = real(a(j))
         ds = ds + rv
         dss = dss + rv*rv
      enddo

      dn = dble(n)
      av = ds/dn
      if ( n.gt.1 ) then
         dss = ( dss-ds*ds/dn)/(dn-1.0d0)
         if ( dss.gt.1.0d-20 ) sd = sqrt(dss)
      endif
      end
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="aavgr"> AAVGR  </a>-- Calcs the mean and standard deviation of a real array
      subroutine aavgr ( a, n, av, sd )
      implicit none
      integer	n	!i: no of elements in vector
      real	a(n)	!i: input vector
      real	av	!o: Mean
      real	sd	!o: Standard deviation
C--
      integer j
      double precision ds, dss, dn
Cbegin
      av = 0.0
      sd = 0.0
      if ( n.lt.1 ) return

      ds = 0.0
      dss = 0.0
      do j = 1, n
         ds = ds + a(j)
         dss = dss + a(j)*a(j)
      enddo

      dn = dble(n)
      av = ds/dn
      if ( n.gt.1 ) then
         dss = ( dss-ds*ds/dn)/(dn-1.0d0)
         if ( dss.gt.1.0d-20 ) sd = sqrt(dss)
      endif
      end
C <a name="aavgs"> AAVGS  </a>-- Calcs the mean and standard deviation of a short integer array
      subroutine aavgs ( a, n, av, sd )
      implicit none
      integer	n	!i: no of elements in vector
      integer*2 a(n)	!i: input vector
      real	av	!o: Mean
      real	sd	!o: Standard deviation
C--
      integer j
      double precision ds, dss, dn
      real rv
Cbegin
      av = 0.0
      sd = 0.0
      if ( n.lt.1 ) return

      ds = 0.0
      dss = 0.0
      do j = 1, n
         rv = real(a(j))
         ds = ds + rv
         dss = dss + rv*rv
      enddo

      dn = dble(n)
      av = ds/dn
      if ( n.gt.1 ) then
         dss = ( dss-ds*ds/dn)/(dn-1.0d0)
         if ( dss.gt.1.0d-20 ) sd = sqrt(dss)
      endif
      end

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="achtid"> ACHTID  </a>-- Load an integer array into a double precision array
C
C   a j penny                    dao	         1988-05-16

      subroutine achtid ( a, b, n )
      implicit none
      integer            n	!i: No of points
      integer            a(n)	!i: input array
      double precision   b(n)	!o: output array
C--
      integer j
Cbegin
      do j = 1, n
         b(j) = a(j)
      enddo

      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="achtir"> ACHTIR  </a>-- Load an integer array into a real array
C
C   a j penny                    dao	         1988-05-16

      subroutine achtir ( a, b, n )
      implicit none
      integer	n	!i: No of points
      integer   a(n)	!i: input array
      real	b(n)	!o: output array
C--
      integer j
Cbegin
      do j = 1, n
         b(j) = a(j)
      enddo

      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="achtis"> ACHTIS  </a>-- Load an integer array into a short integer array
C
C   a j penny                    dao	         1988-05-16

      subroutine achtis ( a, b, n )
      implicit none
      integer	n	!i: No of points
      integer   a(n)	!i: input array
      integer*2	b(n)	!o: output array
C--
      integer j
Cbegin
      do j = 1, n
         b(j) = min(max(a(j),-32768),32767)
      enddo

      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="achtrd"> ACHTRD  </a>-- Load a real array into an double precision array
C
C   a j penny                    dao	         1988-05-16

      subroutine achtrd ( a, b, n )
      implicit none
      integer       	n	!i: No of points
      real		a(n)	!i: input array
      double precision  b(n)	!o: output array
C--
      integer j
Cbegin
      do j = 1, n
         b(j) = a(j)
      enddo

      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="achtsi"> ACHTSI  </a>-- Load a short integer array into an integer array
C
C   a j penny                    dao	         1988-05-16

      subroutine achtsi ( a, b, n )
      implicit none
      integer	n	!i: No of points
      integer*2	a(n)	!i: input array
      integer	b(n)	!o: output array
C--
      integer j
Cbegin
      do j = 1, n
         b(j) = a(j)
      enddo

      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="achtsr"> ACHTSR  </a>-- Load a short integer array into a real aarray
C
C   a j penny                    dao	         1988-05-16

      subroutine achtsr ( a, b, n )
      implicit none
      integer	n	!i: No of points
      integer*2	a(n)	!i: input array
      real 	b(n)	!o: output array
C--
      integer j
Cbegin
      do j = 1, n
         b(j) = a(j)
      enddo

      end
C <a name="achtsd"> ACHTSD  </a>-- Load a short integer array into a doubel precision aarray
C
C   a j penny                    dao	         1988-05-16

      subroutine achtsd ( a, b, n )
      implicit none
      integer           n	!i: No of points
      integer*2         a(n)	!i: input array
      double precision  b(n)	!o: output array
C--
      integer j
Cbegin
      do j = 1, n
         b(j) = a(j)
      enddo

      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="achvali"> ACHVALI  </a>-- Change a particular value in elements in an integer vector
C
C alan penny                    ral            1991 March

      subroutine achvali ( a, b, c, n )

      implicit none
      integer	n		!i: No of elements
      integer   a(n)		!i/o: Vector
      integer   b		!i: Value to change
      integer   c		!i: Value to change to
C--
      integer k
Cbegin

      do k = 1, n
         if ( a(k).eq.b ) a(k) = c
      enddo

      end

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="achvalr"> ACHVALR  </a>-- Change a particular value in elements in a real vector
C
C alan penny                    ral            1991 March

      subroutine achvalr ( a, b, c, n )

      implicit none
      integer	n		!i: No of elements
      real      a(n)		!i/o: Vector
      real	b		!i: Value to change
      real	c		!i: Value to change to
C--
      integer k
Cbegin

      do k = 1, n
         if ( a(k).eq.b ) a(k) = c
      enddo

      end

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="achvals"> ACHVALS  </a>-- Change a particular value in elements in an int*2 vector
C
C alan penny                    ral            1991 March

      subroutine achvals ( a, b, c, n )

      implicit none
      integer	 n		!i: No of elements
      integer*2  a(n)		!i/o: Vector
      integer*2  b		!i: Value to change
      integer*2  c		!i: Value to change to
C--
      integer k
Cbegin

      do k = 1, n
         if ( a(k).eq.b ) a(k) = c
      enddo

      end

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="adivd"> ADIVD  </a>-- Divide array by another - double precision C=A/B
C   a j penny                    dao	         1988-05-16
      subroutine adivd ( a, b, c, n )
      implicit none
      integer		n	!i: No of points
      double precision	a(n)	!i: input array
      double precision	b(n)	!i: dividing array
      double precision	c(n)	!o: output array
C--
      integer j
Cbegin
      do j = 1, n
         c(j) = a(j)/b(j)
      enddo
      end
C <a name="adivi"> ADIVI  </a>-- Divide array by another - integer C=A/B
C   a j penny                    dao	         1988-05-16
      subroutine adivi ( a, b, c, n )
      implicit none
      integer	n	!i: No of points
      integer	a(n)	!i: input array
      integer	b(n)	!i: dividing array
      integer	c(n)	!o: output array
C--
      integer j
Cbegin
      do j = 1, n
         c(j) = a(j)/b(j)
      enddo
      end
C <a name="adivr"> ADIVR  </a>-- Divide array by another - real C=A/B
C   a j penny                    dao	         1988-05-16
      subroutine adivr ( a, b, c, n )
      implicit none
      integer	n	!i: No of points
      real	a(n)	!i: input array
      real	b(n)	!i: dividing array
      real 	c(n)	!o: output array
C--
      integer j
Cbegin
      do j = 1, n
         c(j) = a(j)/b(j)
      enddo
      end
C <a name="adivs"> ADIVS  </a>-- Divide array by another - short integer C=A/B
C   a j penny                    dao	         1988-05-16
      subroutine adivs ( a, b, c, n )
      implicit none
      integer	n	!i: No of points
      integer*2	a(n)	!i: input array
      integer*2	b(n)	!i: dividing array
      integer*2	c(n)	!o: output array
C--
      integer j
Cbegin
      do j = 1, n
         c(j) = a(j)/b(j)
      enddo
      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="adivkd"> ADIVKD  </a>-- Divides array by constant - double precision B=A/K
C   a j penny                    dao	         1988-05-16
      subroutine adivkd ( a, k, b, n )
      implicit none
      integer		n	!i: No of points
      double precision	a(n)	!i: input array
      double precision	k	!i: dividing constant
      double precision	b(n)	!o: output array
C--
      integer j
Cbegin
      do j = 1, n
         b(j) = a(j)/k
      enddo
      end
C <a name="adivki"> ADIVKI  </a>-- Divides array by constant - integer B=A/K
C   a j penny                    dao	         1988-05-16
      subroutine adivki ( a, k, b, n )
      implicit none
      integer	n	!i: No of points
      integer	a(n)	!i: input array
      integer	k	!i: dividing constant
      integer	b(n)	!o: output array
C--
      integer j
Cbegin
      do j = 1, n
         b(j) = a(j)/k
      enddo
      end
C <a name="adivkr"> ADIVKR  </a>-- Divides array by constant - real B=A/K
C   a j penny                    dao	         1988-05-16
      subroutine adivkr ( a, k, b, n )
      implicit none
      integer	n	!i: No of points
      real	a(n)	!i: input array
      real	k	!i: dividing constant
      real 	b(n)	!o: output array
C--
      integer j
Cbegin
      do j = 1, n
         b(j) = a(j)/k
      enddo
      end
C <a name="adivks"> ADIVKS  </a>-- Divides array by constant - short integer B=A/K
C   a j penny                    dao	         1988-05-16
      subroutine adivks ( a, k, b, n )
      implicit none
      integer	n	!i: No of points
      integer*2	a(n)	!i: input array
      integer*2	k	!i: dividing constant
      integer*2	b(n)	!o: output array
C--
      integer j
Cbegin
      do j = 1, n
         b(j) = a(j)/k
      enddo
      end

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="alimd"> ALIMD  </a>-- Finds the min and max of a double precision vector
C
C   a j penny                 dao           1988-04-25

      subroutine alimd ( a, n, rmin, rmax )
      implicit none
      integer		n	!i: no of elements to useadd
      double precision	a(n)	!i: input vector
      double precision	rmin	!o: minimum
      double precision	rmax	!o: maximum
C--
      integer j
Cbegin
      rmin = a(1)
      rmax = a(1)
      do j = 1, n
         rmin = min(rmin,a(j))
         rmax = max(rmax,a(j))
      enddo
      end
C <a name="alimi"> ALIMI  </a>-- Finds the min and max of an integer vector
      subroutine alimi ( a, n, rmin, rmax )
      implicit none
      integer	n	!i: no of elements to useadd
      integer	a(n)	!i: input vector
      integer	rmin	!o: minimum
      integer	rmax	!o: maximum
C--
      integer j
Cbegin
      rmin = a(1)
      rmax = a(1)
      do j = 1, n
         rmin = min(rmin,a(j))
         rmax = max(rmax,a(j))
      enddo
      end
C <a name="alimr"> ALIMR  </a>-- Finds the min and max of a real vector
      subroutine alimr ( a, n, rmin, rmax )
      implicit none
      integer	n	!i: no of elements to useadd
      real	a(n)	!i: input vector
      real	rmin	!o: minimum
      real	rmax	!o: maximum
C--
      integer j
Cbegin
      rmin = a(1)
      rmax = a(1)
      do j = 1, n
         rmin = min(rmin,a(j))
         rmax = max(rmax,a(j))
      enddo
      end
C <a name="alims"> ALIMS  </a>-- Finds the min and max of a short integer vector
      subroutine alims ( a, n, rmin, rmax )
      implicit none
      integer	n	!i: no of elements to useadd
      integer*2	a(n)	!i: input vector
      integer*2	rmin	!o: minimum
      integer*2	rmax	!o: maximum
C--
      integer j
Cbegin
      rmin = a(1)
      rmax = a(1)
      do j = 1, n
         rmin = min(rmin,a(j))
         rmax = max(rmax,a(j))
      enddo


      end

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="amediani"> AMEDIANI  </a>-- Median of integer vector
C
C   alan penny             ral         1994 Nov

      subroutine amediani ( a, n, rm )

      implicit none
      include 'STARMAN_INC'

      integer   n		!i: Data size
      integer   a(n)		!i/o: Data (sorted on exit)
      real      rm		!o: Median
C--
      integer k
Cbegin


      if ( ST_FAILED ) return

      rm = 0.0						!Defaults

      if ( n.lt.1 ) return

      if ( n.eq.1 ) then
         rm = a(1)
         return
      endif

      call sort1i ( a, n )
      if ( (2*(n/2)).eq.n ) then
         k = (n/2)
         rm = (real(a(k))+real(a(k+1)))/2.0
      else
         k = (n/2) + 1
         rm = a(k)
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="amedianr"> AMEDIANR  </a>-- Median of real vector
C
C   alan penny             ral         1994 Nov

      subroutine amedianr ( a, n, rm )

      implicit none
      include 'STARMAN_INC'

      integer   n		!i: Data size
      real      a(n)		!i/o: Data (sorted on exit)
      real      rm		!o: Median
C--
      integer k
Cbegin


      if ( ST_FAILED ) return

      rm = 0.0						!Defaults

      if ( n.lt.1 ) return

      if ( n.eq.1 ) then
         rm = a(1)
         return
      endif

      call sort1r ( a, n )
      if ( (2*(n/2)).eq.n ) then
         k = (n/2)
         rm = (a(k)+a(k+1))/2.0
      else
         k = (n/2) + 1
         rm = a(k)
      endif


      end

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="amedians"> AMEDIANS  </a>-- Median of short vector
C
C   alan penny             ral         1994 Nov

      subroutine amedians ( a, n, rm )

      implicit none
      include 'STARMAN_INC'

      integer   n		!i: Data size
      integer*2 a(n)		!i/o: Data (sorted on exit)
      real      rm		!o: Median
C--
      integer k
Cbegin


      if ( ST_FAILED ) return

      rm = 0.0						!Defaults

      if ( n.lt.1 ) return

      if ( n.eq.1 ) then
         rm = a(1)
         return
      endif

      call sort1i ( a, n )
      if ( (2*(n/2)).eq.n ) then
         k = (n/2)
         rm = (real(a(k))+real(a(k+1)))/2.0
      else
         k = (n/2) + 1
         rm = a(k)
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="amovb"> AMOVB  </a>-- Load a boolean array into another  B = A
C   a j penny                    dao	         1988-05-16
      subroutine amovb ( a, b, n )
      implicit none
      integer	n	!i: No of points
      logical	a(n)	!i: input array
      logical	b(n)	!o: output array
C--
      integer j
Cbegin
      do j = 1, n
         b(j) = a(j)
      enddo
      end
C <a name="amovd"> AMOVD  </a>-- Load a double precision array into another  B = A
C   a j penny                    dao	         1988-05-16
      subroutine amovd ( a, b, n )
      implicit none
      integer		n	!i: No of points
      double precision	a(n)	!i: input array
      double precision	b(n)	!o: output array
C--
      integer j
Cbegin
      do j = 1, n
         b(j) = a(j)
      enddo
      end
C <a name="amovi"> AMOVI  </a>-- Moves an integer array to another B = A
C   a j penny                    dao	         1988-05-16
      subroutine amovi ( a, b, n )
      implicit none
      integer	n	!i: No of points
      integer	a(n)	!i: Input array
      integer 	b(n)	!o: Output array
C--
      integer j
Cbegin
      do j = 1, n
         b(j) = a(j)
      enddo
      end
C <a name="amovr"> AMOVR  </a>-- Load a real array into a real array  B = A
C   a j penny                    dao	         1988-05-16
      subroutine amovr ( a, b, n )
      implicit none
      integer	n	!i: No of points
      real	a(n)	!i: input array
      real	b(n)	!o: output array
C--
      integer j
Cbegin
      do j = 1, n
         b(j) = a(j)
      enddo
      end
C <a name="amovs"> AMOVS  </a>-- Load a short integer array into another  B = A
C   a j penny                    dao	         1988-05-16
      subroutine amovs ( a, b, n )
      implicit none
      integer	n	!i: No of points
      integer*2	a(n)	!i: input array
      integer*2	b(n)	!o: output array
C--
      integer j
Cbegin
      do j = 1, n
         b(j) = a(j)
      enddo
      end



CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="amovkb"> AMOVKB  </a>-- Load a constant into a logical array  A = K
C   a j penny                    dao	         1988-05-16
      subroutine amovkb ( k, a, n )
      implicit none
      logical 	k 	!i: constant to load
      integer	n	!i: No of points
      logical 	a(n)	!o: Array
C--
      integer j
Cbegin
      do j = 1, n
         a(j) = k
      enddo
      end
C <a name="amovkd"> AMOVKD  </a>-- Load a constant into a double precision array A = K
C   a j penny                    dao	         1988-05-16
      subroutine amovkd ( dk, a, n )
      implicit none
      double precision	dk 	!i: constant to load
      integer		n	!i: No of points
      double precision	a(n)	!o: Array
C--
      integer j
Cbegin
      do j = 1, n
         a(j) = dk
      enddo
      end
C <a name="amovki"> AMOVKI  </a>-- Load a constant into a integer array  A = K
C   a j penny                    dao	         1988-05-16
      subroutine amovki ( k, a, n )
      implicit none
      integer	k 	!i: constant to load
      integer	n	!i: No of points
      integer	a(n)	!o: Array
C--
      integer j
Cbegin
      do j = 1, n
         a(j) = k
      enddo
      end
C <a name="amovkr"> AMOVKR  </a>-- Load a constant into a real array  A = K
C   a j penny                    dao	         1988-05-16
      subroutine amovkr ( rk, a, n )
      implicit none
      real	rk	!i: constant to load
      integer	n	!i: No of points
      real	a(n)	!o: Array
C--
      integer j
Cbegin
      do j = 1, n
         a(j) = rk
      enddo
      end
C <a name="amovks"> AMOVKS  </a>-- Load an integer constant into a short integer array   A = K
C   a j penny                    dao	         1988-05-16
      subroutine amovks ( k, a, n )
      implicit none
      integer*2	k 	!i: constant to load
      integer	n	!i: No of points
      integer*2	a(n)	!o: Array
C--
      integer j
Cbegin
      do j = 1, n
         a(j) = k
      enddo
      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="amuld"> AMULD  </a>-- Multiplies two double precision arrays C = A.B
C   a j penny                    dao	         1988-05-16
      subroutine amuld ( a, b, c, n )
      implicit none
      integer		n	!i: No of points
      double precision	a(n)	!i: Input 1 Array
      double precision	b(n)	!i: Input 2 Array
      double precision	c(n)	!o: Output Array
C--
      integer j
Cbegin
      do j = 1, n
         c(j) = a(j)*b(j)
      enddo
      end
C <a name="amuli"> AMULI  </a>-- Multiplies two integer arrays C = A.B
C   a j penny                    dao	         1988-05-16
      subroutine amuli ( a, b, c, n )
      implicit none
      integer	n	!i: No of points
      integer 	a(n)	!i: Input 1 Array
      integer	b(n)	!i: Input 2 Array
      integer	c(n)	!o: Output Array
C--
      integer j
Cbegin
      do j = 1, n
         c(j) = a(j)*b(j)
      enddo
      end
C <a name="amulr"> AMULR  </a>-- Multiplies two real arrays C = A.B
C   a j penny                    dao	         1988-05-16
      subroutine amulr ( a, b, c, n )
      implicit none
      integer	n	!i: No of points
      real	a(n)	!i: Input 1 Array
      real	b(n)	!i: Input 2 Array
      real	c(n)	!o: Output Array
C--
      integer j
Cbegin
      do j = 1, n
         c(j) = a(j)*b(j)
      enddo
      end
C <a name="amuls"> AMULS  </a>-- Multiplies two short integer arrays C = A.B
C   a j penny                    dao	         1988-05-16
      subroutine amuls ( a, b, c, n )
      implicit none
      integer		n	!i: No of points
      integer*2		a(n)	!i: Input 1 Array
      integer*2		b(n)	!i: Input 2 Array
      integer*2		c(n)	!o: Output Array
C--
      integer j
Cbegin
      do j = 1, n
         c(j) = a(j)*b(j)
      enddo
      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="amulkd"> AMULKD  </a>-- Multiplies a double precision array by a constant B = A.K
C   a j penny                    dao	         1988-05-16
      subroutine amulkd ( a, dk, b, n )
      implicit none
      double precision	dk 	!i: constant to load
      integer		n	!i: No of points
      double precision	a(n)	!i: Input Array
      double precision	b(n)	!o: Output Array
C--
      integer j
Cbegin
      do j = 1, n
         b(j) = dk*a(j)
      enddo
      end
C <a name="amulki"> AMULKI  </a>-- Multiplies an integer array by a constant B = A.K
C   a j penny                    dao	         1988-05-16
      subroutine amulki ( a, k, b, n )
      implicit none
      integer	k 	!i: constant to load
      integer	n	!i: No of points
      integer	a(n)	!i: Input Array
      integer	b(n)	!o: Output Array
C--
      integer j
Cbegin
      do j = 1, n
         b(j) = k*a(j)
      enddo
      end
C <a name="amulkr"> AMULKR  </a>-- Multiplies a real array by a constant B = A.K
C   a j penny                    dao	         1988-05-16
      subroutine amulkr ( a, rk, b, n )
      implicit none
      real	rk 	!i: constant to load
      integer	n	!i: No of points
      real	a(n)	!i: Input Array
      real	b(n)	!o: Output Array
C--
      integer j
Cbegin
      do j = 1, n
         b(j) = rk*a(j)
      enddo
      end
C <a name="amulks"> AMULKS  </a>-- Multiplies a short integer array by a constant B = A.K
C   a j penny                    dao	         1988-05-16
      subroutine amulks ( a, k, b, n )
      implicit none
      integer*2		k 	!i: constant to load
      integer		n	!i: No of points
      integer*2		a(n)	!i: Input Array
      integer*2		b(n)	!o: Output Array
C--
      integer j
Cbegin
      do j = 1, n
         b(j) = k*a(j)
      enddo
      end

C <a name="anuminci"> ANUMINCI  </a>-- Load increasing integer numbers (1,2,3,..) into array
C   a j penny                    ral           1994 Nov
      subroutine anuminci ( a, n )
      implicit none
      integer		n	!i: No of points
      integer		a(n)	!o: Output Array
C--
      integer j
Cbegin
      do j = 1, n
         a(j) = j
      enddo
      end

C <a name="anumincr"> ANUMINCR  </a>-- Load increasing real numbers (1,2,3,..) into array
C   a j penny                    ral           1994 Nov
      subroutine anumincr ( a, n )
      implicit none
      integer		n	!i: No of points
      real		a(n)	!o: Output Array
C--
      integer j
Cbegin
      do j = 1, n
         a(j) = j
      enddo
      end

C <a name="anumincs"> ANUMINCS  </a>-- Load increasing short numbers (1,2,3,..) into array
C   a j penny                    ral           1994 Nov
      subroutine anumincs ( a, n )
      implicit none
      integer		n	!i: No of points
      integer*2		a(n)	!o: Output Array
C--
      integer j
      integer*2 k
Cbegin
      do j = 1, n
         k = min(j,32767)
         a(j) = k
      enddo
      end

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="asubd"> ASUBD  </a>-- Subtracts a double precision vector from another vector C = A - B
C
C   a j penny                 dao           1988-04-25

      subroutine asubd ( a, b, c, n )
      implicit none
      integer		n	!i: no of elements to add
      double precision 	a(n)	!i: 1st input vector
      double precision 	b(n)	!i: 2nd input vector to subtract
      double precision 	c(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         c(j) = a(j) - b(j)
      enddo
      end
C <a name="asubi"> ASUBI  </a>-- Subtracts an integer vector from another vector C = A - B
      subroutine asubi ( a, b, c, n )
      implicit none
      integer	n	!i: no of elements to add
      integer	a(n)	!i: 1st input vector
      integer	b(n)	!i: 2nd input vector to subtract
      integer	c(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         c(j) = a(j) - b(j)
      enddo
      end
C <a name="asubr"> ASUBR  </a>-- Subtracts a real vector from another vector C = A - B
      subroutine asubr ( a, b, c, n )
      implicit none
      integer	n	!i: no of elements to add
      real	a(n)	!i: 1st input vector
      real	b(n)	!i: 2nd input vector to subtract
      real	c(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         c(j) = a(j) - b(j)
      enddo
      end
C <a name="asubs"> ASUBS  </a>-- Subtracts a short integer vector from another vector C = A - B
      subroutine asubs ( a, b, c, n )
      implicit none
      integer		n	!i: no of elements to add
      integer*2		a(n)	!i: 1st input vector
      integer*2		b(n)	!i: 2nd input vector to subtract
      integer*2		c(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         c(j) = a(j) - b(j)
      enddo
      end

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="asubkd"> ASUBKD  </a>-- Subtracts a constant from a double precision vector B = A - K
C
C   a j penny                 dao           1988-04-25

      subroutine asubkd ( a, k, b, n )
      implicit none
      integer		n	!i: no of elements to add
      double precision 	a(n)	!i: input vector
      double precision 	k	!i: constant to subtract
      double precision 	b(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         b(j) = a(j) - k
      enddo
      end
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="asubki"> ASUBKI  </a>-- Subtracts a constant from an integer vector B = A - K
      subroutine asubki ( a, k, b, n )
      implicit none
      integer	n	!i: no of elements to add
      integer	a(n)	!i: input vector
      integer	k	!i: constant to subtract
      integer	b(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         b(j) = a(j) - k
      enddo
      end
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="asubkr"> ASUBKR  </a>-- Subtracts a constant from a real vector B = A - K
      subroutine asubkr ( a, k, b, n )
      implicit none
      integer	n	!i: no of elements to add
      real	a(n)	!i: input vector
      real	k	!i: constant to subtract
      real	b(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         b(j) = a(j) - k
      enddo
      end
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="asubks"> ASUBKS  </a>-- Subtracts a constant from a short integer vector B = A - K
      subroutine asubks ( a, k, b, n )
      implicit none
      integer	n	!i: no of elements to add
      integer*2	a(n)	!i: input vector
      integer*2	k	!i: constant to subtract
      integer*2	b(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         b(j) = a(j) - k
      enddo
      end



CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="asumd"> ASUMD  </a>-- Sums a double precision vector
C
C   a j penny                 dao           1988-04-25

      subroutine asumd ( a, n, sum )
      implicit none
      integer		n	!i: no of elements to add
      double precision	a(n)	!i: input vector
      double precision	sum 	!o: sum
C--
      integer j
Cbegin
      sum = 0.0d0
      do j = 1, n
         sum = sum + a(j)
      enddo
      end
C <a name="asumi"> ASUMI  </a>-- Sums an integer vector
      subroutine asumi ( a, n, sum )
      implicit none
      integer	n	!i: no of elements to add
      integer	a(n)	!i: input vector
      real	sum 	!o: sum
C--
      double precision dsum
      integer j
Cbegin
      dsum = 0.0d0
      do j = 1, n
         dsum = dsum + dble(a(j))
      enddo
      sum = dsum
      end
C <a name="asumr"> ASUMR  </a>-- Sums a real vector
      subroutine asumr ( a, n, sum )
      implicit none
      integer	n	!i: no of elements to add
      real	a(n)	!i: input vector
      real 	sum 	!o: sum
C--
      double precision dsum
      integer j
Cbegin
      dsum = 0.0d0
      do j = 1, n
         dsum = dsum + dble(a(j))
      enddo
      sum = dsum
      end
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="asums"> ASUMS  </a>-- Sums a short integer vector
      subroutine asums ( a, n, sum )
      implicit none
      integer	n	!i: no of elements to add
      integer*2	a(n)	!i: input vector
      real	sum 	!o: sum
C--
      double precision dsum
      integer j
Cbegin
      dsum = 0.0d0
      do j = 1, n
         dsum = dsum + dble(a(j))
      enddo
      sum = dsum
      end



CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="amzerob"> AMZEROB  </a>-- Load .FALSE. into a logical array  A = .FALSE.
C   a j penny                    dao	         1988-05-16
      subroutine azerob ( a, n )
      implicit none
      integer	n	!i: No of points
      logical 	a(n)	!o: Array
C--
      integer j
      logical zero
      parameter ( zero=.false. )
Cbegin
      do j = 1, n
         a(j) = zero
      enddo
      end
C <a name="azerod"> AZEROD  </a>-- Load zeroes into a double precision array A = 0.0d0
C   a j penny                    dao	         1988-05-16
      subroutine azerod ( a, n )
      implicit none
      integer		n	!i: No of points
      double precision	a(n)	!o: Array
C--
      integer j
      double precision zero
      parameter ( zero=0.0d0 )
Cbegin
      do j = 1, n
         a(j) = zero
      enddo
      end
C <a name="azeroi"> AZEROI  </a>-- Load zeroes into a integer array  A = 0
C   a j penny                    dao	         1988-05-16
      subroutine azeroi ( a, n )
      implicit none
      integer	n	!i: No of points
      integer	a(n)	!o: Array
C--
      integer j
      integer zero
      parameter ( zero=0 )
Cbegin
      do j = 1, n
         a(j) = zero
      enddo
      end
C <a name="azeror"> AZEROR  </a>-- Load zeroes into a real array  A = 0.0
C   a j penny                    dao	         1988-05-16
      subroutine azeror ( a, n )
      implicit none
      integer	n	!i: No of points
      real	a(n)	!o: Array
C--
      integer j
      real zero
      parameter ( zero=0.0 )
Cbegin
      do j = 1, n
         a(j) = zero
      enddo
      end
C <a name="azeros"> AZEROS  </a>-- Load zeros into a short integer array   A = 0
C   a j penny                    dao	         1988-05-16
      subroutine azeros ( a, n )
      implicit none
      integer	n	!i: No of points
      integer*2	a(n)	!o: Array
C--
      integer j
      integer*2 zero
      parameter ( zero=0 )
Cbegin
      do j = 1, n
         a(j) = zero
      enddo
      end

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C      This is STARFLIBVZ.F
C
C  It contains vector operations with magic values.
C
C AZADDK(DIRS)       Add a constant from a magic vector B = A + K
C AZSUBK(DIRS)       Subtract a constant from a magic vector B = A - K
C AZMULK(DIRS)       Multiply a magic array by a constant B = A.K
C AZDIVK(DIRS)       Divide a magic array by a constant B = A/K
C AZADD(DIRS)        Add one vector from another with magic values C = A + B
C AZSUB(DIRS)        Subtract one vector from another with magic values C = A - B
C AZMUL(DIRS)        Multiply one vector from another with magic values C = A*B
C AZDIV(DIRS)        Divide one vector from another with magic values C = A/B
C AZCHT(IRS:DIRS)    Load a (real:int:short) array into a (DRIS) array with magic values
C AZLIM(DIRS)        Find the min and max of a vector with magic values
C AZZALLBAD(RS)      Check for some ok in an image box with magic values
C


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="azaddkd"> AZADDKD  </a>-- Adds dble prec constant to magic vector to make second B=A+K
C   a j penny                 dao           1988-04-25
      subroutine azaddkd ( a, ak, k, b, n )
      implicit none
      integer		n	!i: no of elements to add
      double precision	a(n)	!i: input vector
      double precision  ak      !i: Magic value
      double precision	k	!i: Constant to add
      double precision	b(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).ne.ak ) b(j) = a(j) + k
      enddo
      end
C <a name="azaddki"> AZADDKI  </a>-- Adds integer constant to integer magic vector to make second B=A+K
C   a j penny                 dao           1988-04-25
      subroutine azaddki ( a, ak, k, b, n )
      implicit none
      integer	n	!i: no of elements to add
      integer	a(n)	!i: input vector
      integer   ak      !i: Magic value
      integer	k	!i: Constant to add
      integer	b(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).ne.ak ) b(j) = a(j) + k
      enddo
      end
C <a name="azaddkr"> AZADDKR  </a>-- Adds real constant to real magic vector to make second B+A+K
C   a j penny                 dao           1988-04-25
      subroutine azaddkr ( a, ak, k, b, n )
      implicit none
      integer	n	!i: no of elements to add
      real	a(n)	!i: input vector
      real      ak      !i: Magic value
      real	k	!i: Constant to add
      real	b(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).ne.ak ) b(j) = a(j) + k
      enddo
      end
C <a name="azaddks"> AZADDKS  </a>-- Adds short integer constant to magic vector to make second B+A+K
C   a j penny                 dao           1988-04-25
      subroutine azaddks ( a, ak, k, b, n )
      implicit none
      integer	n	!i: no of elements to add
      integer*2	a(n)	!i: input vector
      integer*2 ak      !i: Magic value
      integer*2	k	!i: Constant to add
      integer*2	b(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).ne.ak ) b(j) = a(j) + k
      enddo
      end

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="azsubkd"> AZSUBKD  </a>-- Subtracts dble prec constant to magic vector to make second B=A-K
C   a j penny                 dao           1988-04-25
      subroutine azsubkd ( a, ak, k, b, n )
      implicit none
      integer		n	!i: no of elements to add
      double precision	a(n)	!i: input vector
      double precision  ak      !i: Magic value
      double precision	k	!i: Constant to add
      double precision	b(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).ne.ak ) b(j) = a(j) - k
      enddo
      end
C <a name="azsubki"> AZSUBKI  </a>-- Subtracts integer constant to magic vector to make second B=A-K
C   a j penny                 dao           1988-04-25
      subroutine azsubki ( a, ak, k, b, n )
      implicit none
      integer	n	!i: no of elements to operate one
      integer	a(n)	!i: input vector
      integer   ak      !i: Magic value
      integer	k	!i: Constant to subtract
      integer	b(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).ne.ak ) b(j) = a(j) - k
      enddo
      end
C <a name="azsubkr"> AZSUBKR  </a>-- Subtracts real constant to magic vector to make second B=A-K
C   a j penny                 dao           1988-04-25
      subroutine azsubkr ( a, ak, k, b, n )
      implicit none
      integer	n	!i: no of elements to oeprate on
      real	a(n)	!i: input vector
      real      ak      !i: Magic value
      real	k	!i: Constant to subtract
      real	b(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).ne.ak ) b(j) = a(j) - k
      enddo
      end
C <a name="azsubks"> AZSUBKS  </a>-- Subtracts short integer constant to magic vector to make second B=A-K
C   a j penny                 dao           1988-04-25
      subroutine azsubks ( a, ak, k, b, n )
      implicit none
      integer	n	!i: no of elements to operate on
      integer*2	a(n)	!i: input vector
      integer*2 ak      !i: Magic value
      integer*2	k	!i: Constant to subtract
      integer*2	b(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).ne.ak ) b(j) = a(j) - k
      enddo
      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="azmulkd"> AZMULKD  </a>-- Multiplies a double precision magic vector by a constant B = A.K
C   a j penny                    dao	         1988-05-16
      subroutine azmulkd ( a, ak, dk, b, n )
      implicit none
      integer		n	!i: No of points
      double precision	a(n)	!i: Input Array
      double precision	ak 	!i: Magic value
      double precision	dk 	!i: constant to multiply by
      double precision	b(n)	!o: Output Array
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).ne.ak ) b(j) = dk*a(j)
      enddo
      end
C <a name="azmulki"> AZMULKI  </a>-- Multiplies an integer magic vector by a constant B = A.K
C   a j penny                    dao	         1988-05-16
      subroutine azmulki ( a, ak, k, b, n )
      implicit none
      integer	n	!i: No of points
      integer	a(n)	!i: Input Array
      integer   ak 	!i: Magic value
      integer	k 	!i: constant to multiply by
      integer	b(n)	!o: Output Array
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).ne.ak ) b(j) = k*a(j)
      enddo
      end
C <a name="azmulkr"> AZMULKR  </a>-- Multiplies a real magic vector by a constant B = A.K
C   a j penny                    dao	         1988-05-16
      subroutine azmulkr ( a, ak, rk, b, n )
      implicit none
      integer	n	!i: No of points
      real	a(n)	!i: Input Array
      real      ak 	!i: Magic value
      real	rk 	!i: constant to multiply by
      real	b(n)	!o: Output Array
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).ne.ak ) b(j) = rk*a(j)
      enddo
      end
C <a name="azmulks"> AZMULKS  </a>-- Multiplies a short integer array by a constant B = A.K
C   a j penny                    dao	         1988-05-16
      subroutine azmulks ( a, ak, k, b, n )
      implicit none
      integer		n	!i: No of points
      integer*2		a(n)	!i: Input Array
      integer*2		ak 	!i: Magic value
      integer*2		k 	!i: constant to multiply by
      integer*2		b(n)	!o: Output Array
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).ne.ak ) b(j) = k*a(j)
      enddo
      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="azdivkd"> AZDIVKD  </a>-- Divides a double precision magic vector by a constant B = A/K
C   a j penny                    dao	         1988-05-16
      subroutine azdivkd ( a, ak, dk, b, n )
      implicit none
      integer		n	!i: No of points
      double precision	a(n)	!i: Input Array
      double precision	ak 	!i: Magic value
      double precision	dk 	!i: constant to divide by
      double precision	b(n)	!o: Output Array
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).ne.ak ) b(j) = a(j)/dk
      enddo
      end
C <a name="azdivki"> AZDIVKI  </a>-- Divides an integer magic vector by a constant B = A/K
C   a j penny                    dao	         1988-05-16
      subroutine azdivki ( a, ak, k, b, n )
      implicit none
      integer	n	!i: No of points
      integer	a(n)	!i: Input Array
      integer   ak 	!i: Magic value
      integer	k 	!i: constant to didvide by
      integer	b(n)	!o: Output Array
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).ne.ak ) b(j) = a(j)/k
      enddo
      end
C <a name="azdivkr"> AZDIVKR  </a>-- Divides a real magic vector by a constant B = A/K
C   a j penny                    dao	         1988-05-16
      subroutine azdivkr ( a, ak, rk, b, n )
      implicit none
      integer	n	!i: No of points
      real	a(n)	!i: Input Array
      real      ak 	!i: Magic value
      real	rk 	!i: constant to divide by
      real	b(n)	!o: Output Array
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).ne.ak ) b(j) = a(j)/rk
      enddo
      end
C <a name="azdivks"> AZDIVKS  </a>-- Divides a short integer array by a constant B = A/K
C   a j penny                    dao	         1988-05-16
      subroutine azdivks ( a, ak, k, b, n )
      implicit none
      integer		n	!i: No of points
      integer*2		a(n)	!i: Input Array
      integer*2		ak 	!i: Magic value
      integer*2		k 	!i: constant to divide by
      integer*2		b(n)	!o: Output Array
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).ne.ak ) b(j) = a(j)/k
      enddo
      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="azsubd"> AZSUBD  </a>-- Subtract dble prec vector from another with magic values C = A - B
C   a j penny                 dao           1988-04-25
      subroutine azsubd ( a, ak, b, bk, c, n )
      implicit none
      integer		n	!i: no of elements to add
      double precision	a(n)	!i: input vector
      double precision  ak      !i: Magic value
      double precision	b(n)	!i: input vector
      double precision  bk      !i: Magic value
      double precision	c(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).ne.ak .and. b(j).ne.bk ) then
            c(j) = a(j) - b(j)
         else
            c(j) = ak
         endif
      enddo
      end
C <a name="azsubi"> AZSUBI  </a>-- Subtract integer vector from another with magic values C = A - B
C   a j penny                 dao           1988-04-25
      subroutine azsubi ( a, ak, b, bk, c, n )
      implicit none
      integer		n	!i: no of elements to add
      integer           a(n)	!i: input vector
      integer           ak      !i: Magic value
      integer           b(n)	!i: input vector
      integer           bk      !i: Magic value
      integer           c(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).ne.ak .and. b(j).ne.bk ) then
            c(j) = a(j) - b(j)
         else
            c(j) = ak
         endif
      enddo
      end
C <a name="azsubr"> AZSUBR  </a>-- Subtract real vector from another with magic values C = A - B
C   a j penny                 dao           1988-04-25
      subroutine azsubr ( a, ak, b, bk, c, n )
      integer		n	!i: no of elements to add
      real              a(n)	!i: input vector
      integer           ak      !i: Magic value
      real              b(n)	!i: input vector
      integer           bk      !i: Magic value
      real              c(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).ne.ak .and. b(j).ne.bk ) then
            c(j) = a(j) - b(j)
         else
            c(j) = ak
         endif
      enddo
      end
C <a name="azsubs"> AZSUBS  </a>-- Subtract short vector from another with magic values C = A - B
C   a j penny                 dao           1988-04-25
      subroutine azsubs ( a, ak, b, bk, c, n )
      implicit none
      integer		n	!i: no of elements to add
      integer*2         a(n)	!i: input vector
      integer           ak      !i: Magic value
      integer*2         b(n)	!i: input vector
      integer           bk      !i: Magic value
      integer*2         c(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).ne.ak .and. b(j).ne.bk ) then
            c(j) = a(j) - b(j)
         else
            c(j) = ak
         endif
      enddo
      end

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="azaddd"> AZADDD  </a>-- Add dble prec vector from another with magic values C = A + B
C   a j penny                 dao           1988-04-25
      subroutine azaddd ( a, ak, b, bk, c, n )
      implicit none
      integer		n	!i: no of elements to add
      double precision	a(n)	!i: input vector
      double precision  ak      !i: Magic value
      double precision	b(n)	!i: input vector
      double precision  bk      !i: Magic value
      double precision	c(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).ne.ak .and. b(j).ne.bk ) then
            c(j) = a(j) + b(j)
         else
            c(j) = ak
         endif
      enddo
      end
C <a name="azaddi"> AZADDI  </a>-- Add integer vector from another with magic values C = A + B
C   a j penny                 dao           1988-04-25
      subroutine azaddi ( a, ak, b, bk, c, n )
      implicit none
      integer		n	!i: no of elements to add
      integer           a(n)	!i: input vector
      integer           ak      !i: Magic value
      integer           b(n)	!i: input vector
      integer           bk      !i: Magic value
      integer           c(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).ne.ak .and. b(j).ne.bk ) then
            c(j) = a(j) + b(j)
         else
            c(j) = ak
         endif
      enddo
      end
C <a name="azaddr"> AZADDR  </a>-- Add real vector from another with magic values C = A + B
C   a j penny                 dao           1988-04-25
      subroutine azaddr ( a, ak, b, bk, c, n )
      integer		n	!i: no of elements to add
      real              a(n)	!i: input vector
      integer           ak      !i: Magic value
      real              b(n)	!i: input vector
      integer           bk      !i: Magic value
      real              c(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).ne.ak .and. b(j).ne.bk ) then
            c(j) = a(j) + b(j)
         else
            c(j) = ak
         endif
      enddo
      end
C <a name="azadds"> AZADDS  </a>-- Add short vector from another with magic values C = A + B
C   a j penny                 dao           1988-04-25
      subroutine azadds ( a, ak, b, bk, c, n )
      implicit none
      integer		n	!i: no of elements to add
      integer*2         a(n)	!i: input vector
      integer           ak      !i: Magic value
      integer*2         b(n)	!i: input vector
      integer           bk      !i: Magic value
      integer*2         c(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).ne.ak .and. b(j).ne.bk ) then
            c(j) = a(j) + b(j)
         else
            c(j) = ak
         endif
      enddo
      end

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="azmuld"> AZMULD  </a>-- Multiply dble prec vector from another with magic values C = A * B
C   a j penny                 dao           1988-04-25
      subroutine azmuld ( a, ak, b, bk, c, n )
      implicit none
      integer		n	!i: no of elements to add
      double precision	a(n)	!i: input vector
      double precision  ak      !i: Magic value
      double precision	b(n)	!i: input vector
      double precision  bk      !i: Magic value
      double precision	c(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).ne.ak .and. b(j).ne.bk ) then
            c(j) = a(j)*b(j)
         else
            c(j) = ak
         endif
      enddo
      end
C <a name="azmuli"> AZMULI  </a>-- Multiply integer vector from another with magic values C = A * B
C   a j penny                 dao           1988-04-25
      subroutine azmuli ( a, ak, b, bk, c, n )
      implicit none
      integer		n	!i: no of elements to add
      integer           a(n)	!i: input vector
      integer           ak      !i: Magic value
      integer           b(n)	!i: input vector
      integer           bk      !i: Magic value
      integer           c(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).ne.ak .and. b(j).ne.bk ) then
            c(j) = a(j)*b(j)
         else
            c(j) = ak
         endif
      enddo
      end
C <a name="azmulr"> AZMULR  </a>-- Multiply real vector from another with magic values C = A * B
C   a j penny                 dao           1988-04-25
      subroutine azmulr ( a, ak, b, bk, c, n )
      integer		n	!i: no of elements to add
      real              a(n)	!i: input vector
      integer           ak      !i: Magic value
      real              b(n)	!i: input vector
      integer           bk      !i: Magic value
      real              c(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).ne.ak .and. b(j).ne.bk ) then
            c(j) = a(j)*b(j)
         else
            c(j) = ak
         endif
      enddo
      end
C <a name="azmuls"> AZMULS  </a>-- Multiply short vector from another with magic values C = A * B
C   a j penny                 dao           1988-04-25
      subroutine azmuls ( a, ak, b, bk, c, n )
      implicit none
      integer		n	!i: no of elements to add
      integer*2         a(n)	!i: input vector
      integer           ak      !i: Magic value
      integer*2         b(n)	!i: input vector
      integer           bk      !i: Magic value
      integer*2         c(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).ne.ak .and. b(j).ne.bk ) then
            c(j) = a(j)*b(j)
         else
            c(j) = ak
         endif
      enddo
      end

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="azdivd"> AZDIVD  </a>-- Divide dble prec vector from another with magic values C = A / B
C   a j penny                 dao           1988-04-25
      subroutine azdivd ( a, ak, b, bk, c, n )
      implicit none
      integer		n	!i: no of elements to add
      double precision	a(n)	!i: input vector
      double precision  ak      !i: Magic value
      double precision	b(n)	!i: input vector
      double precision  bk      !i: Magic value
      double precision	c(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).ne.ak .and. b(j).ne.bk ) then
            if ( b(j).ne.0d0 ) then
               c(j) = a(j)/b(j)
            else
               c(j) = ak
            endif
         else
            c(j) = ak
         endif
      enddo
      end
C <a name="azdivi"> AZDIVI  </a>-- Divide integer vector from another with magic values C = A / B
C   a j penny                 dao           1988-04-25
      subroutine azdivi ( a, ak, b, bk, c, n )
      implicit none
      integer		n	!i: no of elements to add
      integer           a(n)	!i: input vector
      integer           ak      !i: Magic value
      integer           b(n)	!i: input vector
      integer           bk      !i: Magic value
      integer           c(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).ne.ak .and. b(j).ne.bk ) then
            if ( b(j).ne.0 ) then
               c(j) = a(j)/b(j)
            else
               c(j) = ak
            endif
         else
            c(j) = ak
         endif
      enddo
      end
C <a name="azdivr"> AZDIVR  </a>-- Subtract real vector from another with magic values C = A / B
C   a j penny                 dao           1988-04-25
      subroutine azdivr ( a, ak, b, bk, c, n )
      integer		n	!i: no of elements to add
      real              a(n)	!i: input vector
      integer           ak      !i: Magic value
      real              b(n)	!i: input vector
      integer           bk      !i: Magic value
      real              c(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).ne.ak .and. b(j).ne.bk ) then
            if ( b(j).ne.0.0 ) then
               c(j) = a(j)/b(j)
            else
               c(j) = ak
            endif
         else
            c(j) = ak
         endif
      enddo
      end
C <a name="azdivs"> AZDIVS  </a>-- Divide short vector from another with magic values C = A / B
C   a j penny                 dao           1988-04-25
      subroutine azdivs ( a, ak, b, bk, c, n )
      implicit none
      integer		n	!i: no of elements to add
      integer*2         a(n)	!i: input vector
      integer           ak      !i: Magic value
      integer*2         b(n)	!i: input vector
      integer           bk      !i: Magic value
      integer*2         c(n)	!o: output vector
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).ne.ak .and. b(j).ne.bk ) then
            if ( b(j).ne.0 ) then
               c(j) = a(j)/b(j)
            else
               c(j) = ak
            endif
         else
            c(j) = ak
         endif
      enddo
      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="azchtir"> AZCHTIR  </a>-- Load an integer array into a real array with magic values
C
C   a j penny                    dao	         1988-05-16

      subroutine azchtir ( a, ka, b, kb, n )
      implicit none
      integer	n	!i: No of points
      integer   a(n)	!i: input array
      integer   ka	!i: input magic value
      real	b(n)	!o: output array
      real      kb	!i: Output magic value
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).eq.ka ) then
            b(j) = kb
         else
            b(j) = a(j)
         endif
      enddo

      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="azchtid"> AZCHTID  </a>-- Load an integer array into a double precisionn array with magic values
C
C   a j penny                    dao	         1988-05-16

      subroutine azchtid ( a, ka, b, kb, n )
      implicit none
      integer           n	!i: No of points
      integer           a(n)	!i: input array
      integer		ka	!i: input magic value
      double precision 	b(n)	!o: output array
      double precision  kb	!i: Output magic value
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).eq.ka ) then
            b(j) = kb
         else
            b(j) = a(j)
         endif
      enddo

      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="azchtis"> AZCHTIS  </a>-- Load an integer array into a short integer array with magic values
C
C   a j penny                    dao	         1988-05-16

      subroutine azchtis ( a, ka, b, kb, n )
      implicit none
      integer	n	!i: No of points
      integer   a(n)	!i: input array
      integer   ka	!i: input magic value
      integer*2	b(n)	!o: output array
      integer*2 kb	!i: Output magic value
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).eq.ka .or. a(j).lt.-32768 .or. a(j).gt.32767 ) then
            b(j) = kb
         else
            b(j) = a(j)
         endif
      enddo

      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="azchtrd"> AZCHTRD  </a>-- Load a real array into an double precision array with magic values
C
C   a j penny                    dao	         1988-05-16

      subroutine azchtrd ( a, ka, b, kb, n )
      implicit none
      integer       	n	!i: No of points
      real		a(n)	!i: input array
      real              ka	!i: Input magic value
      double precision  b(n)	!o: output array
      double precision  kb	!i: Output magic value
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).eq.ka ) then
            b(j) = kb
         else
            b(j) = a(j)
         endif
      enddo

      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="azchtri"> AZCHTRI  </a>-- Load a real array into an integer array with magic values
C
C   a j penny                    dao	         1988-05-16

      subroutine azchtri ( a, ka, min, max, b, kb, n )
      implicit none
      integer       	n	!i: No of points
      real		a(n)	!i: input array
      real              ka	!i: Input magic value
      real              min	!i: Input max valid value
      real              max	!i: Input max valid value
      integer           b(n)	!o: output array
      integer           kb	!i: Output magic value
C--
      integer j
Cbegin
      do j = 1, n
         if ( (a(j).eq.ka) .or. (a(j).lt.min) .or. (a(j).gt.max) ) then
            b(j) = kb
         else
            b(j) = a(j)
         endif
      enddo

      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="azchtrs"> AZCHTRS  </a>-- Load a real array into an integer*2 array with magic values
C
C   a j penny                    dao	         1988-05-16

      subroutine azchtrs ( a, ka, min, max, b, kb, n )
      implicit none
      integer       	n	!i: No of points
      real		a(n)	!i: input array
      real              ka	!i: Input magic value
      real              min	!i: Input max valid value
      real              max	!i: Input max valid value
      integer*2         b(n)	!o: output array
      integer*2         kb	!i: Output magic value
C--
      integer j
Cbegin
      do j = 1, n
         if ( (a(j).eq.ka) .or. (a(j).lt.min) .or. (a(j).gt.max) ) then
            b(j) = kb
         else
            b(j) = a(j)
         endif
      enddo

      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="azchtsi"> AZCHTSI  </a>-- Load a short integer array into an integer array with magic values
C
C   a j penny                    dao	         1988-05-16

      subroutine azchtsi ( a, ka, b, kb, n )
      implicit none
      integer	n	!i: No of points
      integer*2	a(n)	!i: input array
      integer*2 ka	!i: Input magic value
      integer	b(n)	!o: output array
      integer   kb	!i: Output magic value
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).eq.ka ) then
            b(j) = kb
         else
            b(j) = a(j)
         endif
      enddo

      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="azchtsr"> AZCHTSR  </a>-- Load a short integer array into a real array with magic values
C
C   a j penny                    dao	         1988-05-16

      subroutine azchtsr ( a, ka, b, kb, n )
      implicit none
      integer	n	!i: No of points
      integer*2	a(n)	!i: input array
      integer*2 ka	!i: Magic input flag
      real 	b(n)	!o: output array
      real      kb	!o: Magic output flag
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).eq.ka ) then
            b(j) = kb
         else
            b(j) = a(j)
         endif
      enddo

      end

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="azchtsd"> AZCHTSD  </a>-- Load a short integer array into a doubel precision array with magic values
C
C   a j penny                    dao	         1988-05-16

      subroutine azchtsd ( a, ka, b, kb, n )
      implicit none
      integer            n	!i: No of points
      integer*2	         a(n)	!i: input array
      integer*2          ka	!i: Magic input flag
      double precision   b(n)	!o: output array
      double precision   kb	!o: Magic output flag
C--
      integer j
Cbegin
      do j = 1, n
         if ( a(j).eq.ka ) then
            b(j) = kb
         else
            b(j) = a(j)
         endif
      enddo

      end

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="azlimd"> AZLIMD  </a>-- Finds the min and max of an dble prec vector with magic values
      subroutine azlimd ( a, n, rinval, rmin, rmax, ierr )
      implicit none
      integer            n       !i: no of elements to useadd
      double precision   a(n)    !i: input vector
      double precision   rinval  !i: Magic value
      double precision   rmin    !o: minimum
      double precision   rmax    !o: maximum
      integer            ierr    !o: Error flag 0=ok; 1=no good points
C--
      integer j
      logical found
Cbegin
      found = .false.
      do j = 1, n
         if ( a(j).ne.rinval ) then
            if ( .not.found ) then
               rmin = a(j)
               rmax = a(j)
               found = .true.
            else
               rmin = min(rmin,a(j))
               rmax = max(rmax,a(j))
            endif
         endif
      enddo
      ierr = 0
      if ( .not.found ) then
         ierr = 1
         rmin = 0.0d0
         rmax = 0.0d0
      endif
      end
C <a name="azlimi"> AZLIMI  </a>-- Finds the min and max of an integer vector with magic values
      subroutine azlimi ( a, n, rinval, rmin, rmax, ierr )
      implicit none
      integer   n       !i: no of elements to useadd
      integer   a(n)    !i: input vector
      integer   rinval  !i: Magic value
      integer   rmin    !o: minimum
      integer   rmax    !o: maximum
      integer   ierr    !o: Error flag 0=ok; 1=no good points
C--
      integer j
      logical found
Cbegin
      found = .false.
      do j = 1, n
         if ( a(j).ne.rinval ) then
            if ( .not.found ) then
               rmin = a(j)
               rmax = a(j)
               found = .true.
            else
               rmin = min(rmin,a(j))
               rmax = max(rmax,a(j))
            endif
         endif
      enddo
      ierr = 0
      if ( .not.found ) then
         ierr = 1
         rmin = 0
         rmax = 0
      endif
      end
C <a name="azlimr"> AZLIMR  </a>-- Finds the min and max of a real vector with magic values
      subroutine azlimr ( a, n, rinval, rmin, rmax, ierr )
      implicit none
      integer   n       !i: no of elements to useadd
      real      a(n)    !i: input vector
      real      rinval  !i: Magic value
      real      rmin    !o: minimum
      real      rmax    !o: maximum
      integer   ierr    !o: Error flag 0=ok; 1=no good points
C--
      integer j
      logical found
Cbegin
      found = .false.
      do j = 1, n
         if ( a(j).ne.rinval ) then
            if ( .not.found ) then
               rmin = a(j)
               rmax = a(j)
               found = .true.
            else
               rmin = min(rmin,a(j))
               rmax = max(rmax,a(j))
            endif
         endif
      enddo
      ierr = 0
      if ( .not.found ) then
         ierr = 1
         rmin = 0.0
         rmax = 0.0
      endif
      end
C <a name="azlims"> AZLIMS  </a>-- Finds the min and max of a short integer vector with magic values
      subroutine azlims ( a, n, rinval, rmin, rmax, ierr )
      implicit none
      integer   n       !i: no of elements to useadd
      integer*2 a(n)    !i: input vector
      integer*2 rinval  !i: Magic value
      integer*2 rmin    !o: minimum
      integer*2 rmax    !o: maximum
      integer   ierr    !o: Error flag 0=ok; 1=no good points
C--
      integer j
      logical found
Cbegin
      found = .false.
      do j = 1, n
         if ( a(j).ne.rinval ) then
            if ( .not.found ) then
               rmin = a(j)
               rmax = a(j)
               found = .true.
            else
               rmin = min(rmin,a(j))
               rmax = max(rmax,a(j))
            endif
         endif
      enddo
      ierr = 0
      if ( .not.found ) then
         ierr = 1
         rmin = 0
         rmax = 0
      endif
      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="azzallbadr"> AZZALLBADR  </a>-- Check for some ok in a real image box with magic values
C
C   a j penny                   stsci             86-12-02

      subroutine azzallbadr ( im, nx, ny, rinval, kxc, kyc, allbad )

      implicit none

      integer   nx, ny			!i: Image size
      real      im(nx,ny)		!i: Input image
      real      rinval			!i: Image (int*2) invalid number flag
      integer   kxc(2)			!i: X range to check
      integer   kyc(2)			!i: Y range to check
      logical   allbad			!i: No 'good' values?
C--
      integer j, k
Cbegin


      allbad = .true.
      do k = kyc(1), kyc(2)
         do j = kxc(1), kxc(2)
            if ( im(j,k).ne.rinval ) allbad = .false.
         enddo
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="azzallbads"> AZZALLBADS  </a>-- Check for some ok in an int*2 image box with magic values
C
C   a j penny                   stsci             86-12-02

      subroutine azzallbads ( im, nx, ny, inval, kxc, kyc, allbad )

      implicit none

      integer   nx, ny			!i: Image size
      integer*2 im(nx,ny)		!i: Input image
      integer   inval			!i: Image (int*2) invalid number flag
      integer   kxc(2)			!i: X range to check
      integer   kyc(2)			!i: X range to check
      logical   allbad			!i: No 'good' values?
C--
      integer j, k
Cbegin


      allbad = .true.
      do k = kyc(1), kyc(2)
         do j = kxc(1), kxc(2)
            if ( im(j,k).ne.inval ) allbad = .false.
         enddo
      enddo


      end


</pre>

<HR>

<address>
<a href="http://ast.star.rl.ac.uk/dev/ajp_page.html">
Alan J Penny </a>
 - <a href="http://www.rl.ac.uk/rutherford.html">
 Rutherford Appleton Laboratory </a> (RAL) </address>
<i> a.j.penny@rl.ac.uk </i> -
<i> This page last modified: 1994 Oct 23  </i>

