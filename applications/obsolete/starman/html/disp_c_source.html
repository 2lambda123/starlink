<HTML><HEAD>
<TITLE> Source Code for DISP - C routines
</TITLE>
</HEAD> <BODY>

<h1> Source Code for DISP - C routines
</h1>

All rights reserved. &copy 1995 RAL. <i>Starlink</i> disclaimers and
conditions apply. <br>
<hr>

Go to the Starman <a href="source_top.html#disp_source_back"> Source Code </a> Page at the pointer to this page.
<hr>
Starman general purpose subroutines called by this program
can be found via the subroutine libraries and general
include files, pointed to at the top of the
<a href="source_top.html"> Source Code page. </a>
<hr>
Any include files are the end of the page. <p>
Subroutines for this program:- <p>

<a href="#dsx_pttit">
dsx_pttit  </a>  Put image title on display - FORTRAN interface (Xwindows)       <br>
<a href="#sx_vtim">
sx_vtim  </a>  Display part of virtual image - Fortran interface (Xwindows)       <br>
<a href="#dsx_pscur">
   dsx_pscur  </a>  Put the cursor at screen position - Fortran Interface (Xwindows)       <br>
<a href="#dsx_getcurpb">
 dsx_getcurpb  </a>  Get cursor posn and button state - Fortran interface (XWindows)       <br>
<a href="#dsx_paintova">
 dsx_paintova  </a>  Paint moving oval at X/Y normal - erase last - Fortran interface (XWindows)       <br>
<a href="#dsx_paintovb">
 dsx_paintovb  </a>  Paint moving oval - erase last - Fortran interface (XWindows)       <br>
<a href="#dsx_init">
dsx_init  </a>  Initialise window - Fortran interface (XWindows)       <br>
<a href="#dsx_id_init">
dsx_id_init  </a>  Initialise window IDs - Fortran interface (XWindows)       <br>
<a href="#dsx_scol">
    dsx_scol  </a>  Set line colour - Fortran interface (XWindows)       <br>
<a href="#dsx_close">
      dsx_close  </a>  Close window - Fortran interface (XWindows)       <br>
<a href="#dsx_erase">
      dsx_erase  </a>  Erase display - Fortran interface (XWindows)       <br>
<a href="#dsx_scur">
      dsx_scur  </a>  Start the cursor - Fortran interface (XWindows)       <br>
<a href="#dsx_pcur">
      dsx_pcur  </a>  Put the cursor at position - Fortran interface (XWindows)       <br>
<a href="#dsx_oval">
   dsx_oval  </a>  Paint an oval - Fortran interface (XWindows)       <br>
<a href="#dsx_osize">
   dsx_osize  </a>  X, Y Size of tilted oval - Fortran interface (XWindows)       <br>
<a href="#dsx_cross">
  dsx_cross  </a>  Put a cross at a position - Fortran interface (XWindows)       <br>
<a href="#sx_line">
sx_line  </a>  Put a line at a position - Fortran interface (XWindows)       <br>
<a href="#dsx_updown">
  dsx_updown  </a>  Raise' or 'lower' a window - Fortran interface (Xwindows)       <br>
<a href="#dsx_acimr">
dsx_acimr  </a>  Display part of an actual real image (loads virtual image)       <br>
<a href="#dsx_acims">
  dsx_acims  </a>  Display part of an actual int*2 image (loads virtual image)       <br>
<a href="#dsx_mswait">
  dsx_mswait  </a>  Wait N milliseconds an image - Fortran interface (Xwindows)       <br>
<a href="#dsxc_init">
dsxc_init  </a>  Initialise window (XWindows)       <br>
<a href="#dsxc_id_init">
dsxc_id_init  </a>  Initialise window IDs (XWindows)       <br>
<a href="#sxc_opcolmap">
sxc_opcolmap  </a>  Open colour map (Xwindows)       <br>
<a href="#sxc_bytecol">
sxc_bytecol  </a>  Calc byte equivalents of PC_ID (Xwindows)       <br>
<a href="#sxc_cicon">
sxc_cicon  </a>  Set up corner icon (Xwindows)       <br>
<a href="#dsxc_scol">
    dsxc_scol  </a>  Set line colour (XWindows)       <br>
<a href="#dsxc_setcol">
dsxc_setcol  </a>  Set up color display for image display (Xwindows)       <br>
<a href="#sxc_vtim">
sxc_vtim  </a>  Display part of virtual image (Xwindows)       <br>
<a href="#dsxc_vtima">
dsxc_vtima  </a>  Display part of virtual image (Xwindows)       <br>
<a href="#sxc_vtload">
sxc_vtload  </a>  Load part of virtual image into a zoomed array (Xwindows)       <br>
<a href="#dsxc_close">
      dsxc_close  </a>  Close window (XWindows)       <br>
<a href="#dsxc_pttit">
 dsxc_pttit  </a>  Put image title on display (XWindows)       <br>
<a href="#dsxc_erase">
      dsxc_erase  </a>  Erase display (XWindows)       <br>
<a href="#dsxc_clear">
 dsxc_clear  </a>  Clear screen (XWindows)       <br>
<a href="#dsxc_clearpix">
dsxc_clearpix  </a>  Clear pixmap (XWindows)       <br>
<a href="#dsxc_scur">
      dsxc_scur  </a>  Start the cursor (XWindows)       <br>
<a href="#dsxc_pcur">
      dsxc_pcur  </a>  Put the cursor at position (XWindows)       <br>
<a href="#dsxc_pscur">
dsxc_pscur  </a>  Put the cursor at screen position (XWindows)       <br>
<a href="#dsxc_getcurpb">
dsxc_getcurpb  </a>  Get cursor posn and button state (XWindows)       <br>
<a href="#dsxc_waitbut">
dsxc_waitbut  </a>  Wait for button to be pressed or to be up (Xwindows)       <br>
<a href="#dsxc_putim">
  dsxc_putim  </a>  Put an image (XWindows)       <br>
<a href="#dsxc_paintova">
   dsxc_paintova  </a>  Paint moving oval  at X/Y normals - erase last (Xwindows)       <br>
<a href="#dsxc_paintovb">
   dsxc_paintovb  </a>  Paint moving oval (XY) - erase last (Xwindows)       <br>
<a href="#dsxc_oval">
   dsxc_oval  </a>  Paint an oval (XWindows)       <br>
<a href="#dsxc_ovala">
   dsxc_ovala  </a>  Paint an oval at X/Y normals (XWindows)       <br>
<a href="#dsxc_ovalb">
   dsxc_ovalb  </a>  Paint an oval at an angle (XWindows)       <br>
<a href="#dsxc_osize">
   dsxc_osize  </a>  X, Y size of tilted oval       <br>
<a href="#dsxc_cross">
  dsxc_cross  </a>  Put a cross at a position (XWindows)       <br>
<a href="#dsxc_scolnum">
dsxc_scolnum  </a>  Calc colour pixel number from colour number (XWindows)       <br>
<a href="#sxc_line">
sxc_line  </a>  Put a line at a position (XWindows)       <br>
<a href="#dsxc_setthecol">
  dsxc_setthecol  </a>  Set writing colour (Xwindows)       <br>
<a href="#dsxc_updown">
  dsxc_updown  </a>  Raise' or 'lower' a window (Xwindows)       <br>
<a href="#dsxc_acimr">
 dsxc_acimr  </a>  Display part of an actual real image (loads virtual image) (X window)       <br>
<a href="#dsxc_acims">
 dsxc_acims  </a>  Display part of an actual short image (loads virtual image) (X window)       <br>
<a href="#sxc_mswait">
sxc_mswait  </a>  Wait X millisecs  (Xwindows)       <br>
<a href="#sxc_unix_mswait">
sxc_unix_mswait  </a>  Wait X millisecs  (Xwindows)       <br>
<a href="#dsx_lutcol">
dsx_lutcol  </a>  Set up color Look-up table for image display - FORTRAN interface (Xwindows)       <br>
<a href="#dsx_lutrot">
dsx_lutrot  </a>  Rotate color Look-up table for image display - FORTRAN interface (Xwindows)       <br>
<a href="#dsx_lutpai">
dsx_lutpai  </a>  Paint a color in the LUT for image display (FORTRAN interface) (XWindows)       <br>
<a href="#dsx_lutsca">
dsx_lutsca  </a>  Scale, shift color Look-up table for image display - FORTRAN interface (Xwindows)       <br>
<a href="#dsx_lutbar">
dsx_lutbar  </a>  Load/clear display of Look-up Table bar - FORTRAN interface (Xwindows)       <br>
<a href="#dsx_lutput">
dsx_lutput  </a>  Put a LUT into operation for image display - FORTRAN interface (Xwindows)       <br>
<a href="#sxc_lutcol">
sxc_lutcol  </a>  Set up color Look-up table for image display (XWindows)       <br>
<a href="#sxc_lutacol">
sxc_lutacol  </a>  Set up color Look-up table for image display (XWindows)       <br>
<a href="#sxc_lutrot">
sxc_lutrot  </a>  Rotate color Look-up table for image display (XWindows)       <br>
<a href="#sxc_lutsca">
sxc_lutsca  </a>  Scale, shift color Look-up table for image display (XWindows)       <br>
<a href="#dsxc_lutpai">
dsxc_lutpai  </a>  Paint a color in the LUT for image display (XWindows)       <br>
<a href="#sxc_lutput">
sxc_lutput  </a>  Put a LUT into operation for image display (XWindows)       <br>
<a href="#dsxc_lutbar">
dsxc_lutbar  </a>  Load/clear display of Look-up Table bar (XWindows)       <br>
<a href="#dsxc_lutbarl">
dsxc_lutbarl  </a>  Load 'background' of LUT bar       <br>
<a href="#sxc_luttran">
sxc_luttran  </a>  Translate bar posn to LUT posn       <br>
<a href="#sxc_lutload">
sxc_lutload  </a>  Load LUT into working LUT       <br>
<a href="#sxc_lutvget">
sxc_lutvget  </a>  Copy 'LUT.INC' Fortran variables over in this C       <br>
<a href="#sxc_lutvput">
sxc_lutvput  </a>  Copy 'LUT.H' C variables over into Fortran version       <br>
<a href="#sx_p_init">
sx_p_init  </a>  Initialise panel window (Fortran interface) (XWindows)       <br>
<a href="#dsx_p_close">
dsx_p_close  </a>  Close panel window (Fortran interface) (XWindows)       <br>
<a href="#dsx_p_pttit">
dsx_p_pttit  </a>  Put title on panel (Fortran interface) (XWindows)       <br>
<a href="#dsx_p_scol">
dsx_p_scol  </a>  Set panel line colour (Fortran interface) (XWindows)       <br>
<a href="#dsx_p_sscur">
dsx_p_sscur  </a>  Start the panel cursor (sections) (Fortran interface) (XWindows)       <br>
<a href="#sx_p_erase">
sx_p_erase  </a>  Erase panel display (Fortran interface) (XWindows)       <br>
<a href="#sx_p_sbox">
sx_p_sbox  </a>  Paint a panel box (sections) (Fortran interface) (XWindows)       <br>
<a href="#sx_p_line">
sx_p_line  </a>  Put a line at a position (Fortran interface) (XWindows)       <br>
<a href="#sx_p_puttxt">
sx_p_puttxt  </a>  Write text to panel (Fortran interface) (XWindows)       <br>
<a href="#sx_p_putim">
sx_p_putim  </a>  Put an image into panel (Fortran interface) (XWindows)       <br>
<a href="#sx_p_carea">
sx_p_carea  </a>  Put a standard colour rectangle into panel (Fortran interface) (XWindows)       <br>
<a href="#sx_p_hstat">
sx_p_hstat  </a>  Write panel status in the help panel box (Fortran interface) (XWindows)       <br>
<a href="#sx_p_hx_load">
sx_p_hx_load  </a>  Put help panel start information (Fortran interface) (XWindows)       <br>
<a href="#sx_p_hx_hload">
sx_p_hx_hload  </a>  Put help panel information (Fortran interface) (XWindows)       <br>
<a href="#sx_p_hbox">
sx_p_hbox  </a>  Paint a help panel box (Fortran interface) (XWindows)       <br>
<a href="#sxc_p_init">
sxc_p_init  </a>  Initialise panel window (XWindows)       <br>
<a href="#dsxc_p_scolours">
 dsxc_p_scolours  </a>  Set up panel colours       <br>
<a href="#sxc_p_cicon">
sxc_p_cicon  </a>  Set up panel corner icon       <br>
<a href="#sxc_p_isview">
sxc_p_isview  </a>  Is panel viewable?       <br>
<a href="#sxc_p_hx_cicon">
sxc_p_hx_cicon  </a>  Set up help panel corner icon       <br>
<a href="#dsxc_p_close">
dsxc_p_close  </a>  Close panel window (XWindows)       <br>
<a href="#dsxc_p_pttit">
dsxc_p_pttit  </a>  Put title on panel (XWindows)       <br>
<a href="#dsxc_p_sscur">
dsxc_p_sscur  </a>  Start the panel cursor (sections) (XWindows)       <br>
<a href="#sxc_p_sbox">
sxc_p_sbox  </a>  Paint a panel box (sections) (XWindows)       <br>
<a href="#sxc_p_putim">
sxc_p_putim  </a>  Put an image into panel (XWindows)       <br>
<a href="#sxc_p_carea">
sxc_p_carea  </a>  Put a standard colour rectangle into panel (XWindows)       <br>
<a href="#dsxc_p_hbox">
dsxc_p_hbox  </a>  Paint a help panel box (XWindows)       <br>
<a href="#sxc_p_puttxt">
sxc_p_puttxt  </a>  Write text to panel (XWindows)       <br>
<a href="#sxc_p_hx_puttxt">
sxc_p_hx_puttxt  </a>  Write text to help panel (XWindows)       <br>
<a href="#sxc_p_line">
sxc_p_line  </a>  Put a line at a position (XWindows)       <br>
<a href="#sxc_p_setthecol">
sxc_p_setthecol  </a>  Set writing colour for panel (XWindows)       <br>
<a href="#sxc_p_scolnum">
sxc_p_scolnum  </a>  Calc panel colour pixel number from colour number (XWindows)       <br>
<a href="#sxc_p_hstat">
sxc_p_hstat  </a>  Write status in the help panel box (XWindows)       <br>
<a href="#sxc_p_clear">
sxc_p_clear  </a>  Clear panel (XWindows)       <br>
<a href="#sxc_p_putcol">
sxc_p_putcol  </a>  Put a colour into an array (XWindows)       <br>
<a href="#sxc_p_hx_putim">
sxc_p_hx_putim  </a>  Put an image into help panel (XWindows)       <br>
<a href="#sxc_p_hx_load">
sxc_p_hx_load  </a>  Put help panel start information (XWindows)       <br>
<a href="#sxc_p_hx_hload">
sxc_p_hx_hload  </a>  Put help panel information (XWindows)       <br>
<a href="#j_scpy">
j_scpy  </a>  Copy text       <br>
<a href="#c_printo">
c_printo  </a>  Buffers call to Fortran rountine printo  (Xwindows)       <br>
<a href="#_tyhelp">
_tyhelp  </a>  Put out help       <br>
<a href="#_gcmdlst">
_gcmdlst  </a>  Squeeze command list and get defaults       <br>
<a href="#_get1i">
_get1i  </a>  Get 1 integer from command line       <br>
<a href="#_get2i">
_get2i  </a>  Get 2 integers from command line       <br>
<a href="#_get1b">
_get1b  </a>  Get 1 Boolean from command line       <br>
<a href="#s_refresh">
s_refresh  </a>  Refreshes  Starman X window when it is revealed       <br>
<a href="#vtc_tis">
vtc_tis  </a>  Translate image cords to screen coords       <br>
<a href="#c_tsi">
c_tsi  </a>  Translate screen coords to image coords       <br>
<a href="#vtc_tsv">
 vtc_tsv  </a>  Translate screen to virtual screen coords       <br>
<a href="#vtc_tvs">
 vtc_tvs  </a>  Translate virtual to screen coords       <br>
<a href="#vtc_tvi">
 vtc_tvi  </a>  Covert virtual coordinates to image ones       <br>
<a href="#vtc_tiv">
 vtc_tiv  </a>  Covert image coordinates to virtual ones       <br>

<HR>
<pre>

/******************************************************************************
* DSX_GENC.C
-
 Contains:-
-
 DSX_VTIM       Display part of virtual image - Fortran interface (Xwindows)
 DSX_PTTIT      Put image title on display - fortran interface (Xwindows)
 DSX_PSCUR      Put the cursor at screen position - fortran interface (Xwindows)
 DSX_GETCURPB   Get cursor posn and button state  - fortran interface (XWindows)
 DSX_PAINTOV(AB) Paint moving oval - erase last - Fortran interface (X windows)
 DSX_INIT       Initialise window - Fortran interface (Xwindows)
 DSX_ID_INIT    Initialise window IDs - Fortran interface (XWindows)
 DSX_SCOL       Set line colour - Fortran interface (XWindows)
 DSX_CLOSE      Close window - Fortran interface (XWindows)
 DSX_ERASE      Erase display - Fortran interface (XWindows)
 DSX_SCUR       Start the cursor - Fortran interface (XWindows)
 DSX_PCUR       Put the cursor at position - Fortran interface (XWindows)
 DSX_OVAL       Paint an oval - Fortran interface (Xwindows)
 DSX_OSIZE      X, Y size of tilted oval
 DSX_CROSS      Put a cross at a position - Fortran interface (Xwindows)
 DSX_LINE       Put a line at a position - Fortran interface (Xwindows)
 DSX_UPDOWN     Raise' or 'lower' a window - Fortran interface (Xwindows)
 DSX_ACIM(RS)   Display part of an actual (real:short) image - Fortran interface (X window)
 DSX_MSWAIT     Wait X millisecs  - Fortran interface (Xwindows)
-
 DSXC_INIT      Initialise window (Xwindows)
 DSXC_ID_INIT   Initialise window IDs (XWindows)
 DSXC_OPCOLMAP  Open colour map (Xwindows)
 DSXC_BYTECOL   Calc byte equivalents of PC_ID (Xwindows)
 DSXC_CICON     Set up corner icon (Xwindows)
 DSXC_SCOL      Set line colour (XWindows)
 DSXC_SETCOL    Set up colour display for image display (Xwindows)
 DSXC_VTIM      Display part of virtual image (Xwindows)
 DSXC_VTIMA     Display part of virtual image (Xwindows)
 DSXC_VTLOAD    Load part of virtual image into a zoomed array (Xwindows)
 DSXC_CLOSE     Close window (XWindows)
 DSXC_PTTIT     Put image title on display (XWindows)
 DSXC_ERASE     Erase display (XWindows)
 DSXC_CLEAR     Clear screen (XWindows)
 DSXC_CLEARPIX  Clear pixmap (XWindows)
 DSXC_SCUR      Start the cursor (XWindows)
 DSXC_PCUR      Put the cursor at position (XWindows)
 DSXC_PSCUR     Put the cursor at screen position (XWindows)
 DSXC_GETCURPB  Get cursor posn and button state (XWindows)
 DSXC_WAITBUT   Wait for button to be pressed or to be up (Xwindows)
-
 DSXC_PUTIM     Put an image (Xwindows)
-
 DSXC_PAINTOV(AB)  Paint moving oval - erase last (X windows)
 DSXC_OVAL      Paint an oval (Xwindows)
 DSXC_OVALA     Paint an oval at X/Y normals (Xwindows)
 DSXC_OVALB     Paint an oval at angle (Xwindows)
 DSXC_OSIZE     X, Y size of tilted oval
 DSXC_CROSS     Put a cross at a position (Xwindows)
 DSXC_SCOLNUM   Calc colour pixel number from colour number (Xwindows)
 DSXC_LINE      Put a line at a position (Xwindows)
 DSXC_SETTHECOL Set writing colour  (Xwindows)
-
 DSXC_UPDOWN    'Raise' or 'lower' a window (Xwindows)
 DSXC_ACIM(RS)   Display part of an actual (real:short) image (X window)
 DSXC_MSWAIT    Wait X millisecs  (Xwindows)

*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <errno.h>

#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/X.h>
#include <sys/time.h>
#include <malloc.h>


#include "f77.h"
#include "cnf.h"

#include "image.h"
#include "ds_gen.h"
#include "ds_lut.h"
#include "ds_panel.h"
#include "dsx_gen.h"

/* Prototypes */

int imax ( int, int );
int imin ( int, int );
float fmax ( float, float );
float fmin ( float, float );

/* External C functions */

extern void dsxc_lutcol ();
extern void dsxc_lutacol ();
extern void dsxc_p_putim ( char*, int, int, int, int );
extern void dsxc_p_puttxt ( char*, int, int, int, int );
extern void dsxc_p_hstat ( int );

extern void c_printo ( char* );
extern void c_get1i ( char*, int*, int, int, int );
extern void c_get2i ( char*, int*, int*, Bool, int, int );

extern void vtc_tis ( int, int, int*, int* );
extern void vtc_tsv ( int, int, int*, int* );
extern void vtc_tvs ( int, int, int*, int* );



/* Panel Globals */

int PNKXS;
int PNKYS;
int PNKXO;
int PNKYO;

int	KXO;		/*  X Last cursor X posn */
int	KYO;		/*  Y Last cursor Y posn */

char   TEXTAA[200];
/*
  (void) sprintf ( TEXTAA, " F1XXX %d %d %d %d %d ",
                          PDSOPEN, DSNXS, DSNXE, DSNYS, DSNYE );
   (void) c_printo ( TEXTAA );
*/

/***********************************************************************
  <a name="dsx_pttit"> DSX_PTTIT  </a>-- Put image title on display - FORTRAN interface (Xwindows)

    alan penny                ral              1990-01-31
    pat morris             leeds        1992 jan
*/

F77_SUBROUTINE(dsx_pttit) ( CHARACTER(title) TRAIL(title) )

{
       GENPTR_CHARACTER(title)		/*   i: Title to put up */
/* C-- */
       char *name;
/* Cbegin */


       name = cnf_creim ( title, title_length );

       (void) dsxc_pttit ( name );

       cnf_free (name);


}


/******************************************************************
 D<a name="sx_vtim"> SX_VTIM  </a>-- Display part of virtual image - Fortran interface (Xwindows)

    alan penny           ral                       1990-02-01
*/

F77_SUBROUTINE(dsx_vtim) ( INTEGER(jvxs), INTEGER(jvxe), INTEGER(jvys),
                           INTEGER(jvye), INTEGER(kcl) )

{
      GENPTR_INTEGER(jvxs)           /* i: X start of virtual area to display */
      GENPTR_INTEGER(jvxe)           /* i: X   end of virtual area to display */
      GENPTR_INTEGER(jvys)           /* i: Y start of virtual area to display */
      GENPTR_INTEGER(jvye)           /* i: Y   end of virtual area to display */
      GENPTR_INTEGER(kcl)            /* i: Flag to clear screen before (0=no) */
/* C-- */
/* Cbegin */

      (void) dsxc_vtim ( *jvxs, *jvxe, *jvys, *jvye, *kcl );
}


/**********************************************************************
  <a name="dsx_pscur">    DSX_PSCUR  </a>-- Put the cursor at screen position - Fortran Interface (Xwindows)

   alan penny                  ral                        1990-02-03
  pat morris             leeds        1992 jan
*/

F77_SUBROUTINE(dsx_pscur) ( REAL(x), REAL(y) )

{
     GENPTR_REAL(x)		/* i: X position to put cursor at */
     GENPTR_REAL(y)		/* i: Y position to put cursor at */
/* C-- */
/* Cbegin */

      (void) dsxc_pscur ( *x, *y );

}


/*******************************************************************
  <a name="dsx_getcurpb">  DSX_GETCURPB  </a>-- Get cursor posn and button state - Fortran interface (XWindows)

   alan penny                  ral                        1990-02-03
  pat morris             leeds        1992 jan
*/

F77_SUBROUTINE(dsx_getcurpb) ( LOGICAL(isimage), INTEGER(kx), INTEGER(ky),
                               INTEGER_ARRAY(kb), INTEGER(ierr) )

{
    GENPTR_LOGICAL(isimage)		/* i: Image (T) or panel (F) ? */
    GENPTR_INTEGER(kx)			/* o: Cursor X position */
    GENPTR_INTEGER(ky)			/* o: Cursor Y position */
    GENPTR_INTEGER_ARRAY(kb)		/* o: Cursor Button states (0=up;1=down) */
    GENPTR_INTEGER(ierr)	    	/* o: Error flag ( 0=ok; 1=bad) */
/* C-- */
    Bool la;
    int ikx, iky, iierr;
/* Cbegin */

       la = *isimage;
      (void) dsxc_getcurpb ( la, &ikx, &iky, kb, &iierr );
       *kx = ikx; *ky = iky; *ierr = iierr;

}



/*******************************************************************
  <a name="dsx_paintova">  DSX_PAINTOVA  </a>-- Paint moving oval at X/Y normal - erase last - Fortran interface (XWindows)

   alan penny                  ral                        1990-02-03
  pat morris             leeds        1992 jan
*/

F77_SUBROUTINE(dsx_paintova) ( REAL(pxo), REAL(pyo), REAL(rxo), REAL(ryo),
                              REAL(px),  REAL(py),
                              REAL(rax1), REAL(ray1), INTEGER(kc1),
                              REAL_ARRAY(rax2), REAL_ARRAY(ray2),
                              INTEGER(kc2) )

{
    GENPTR_REAL(pxo)		/* i: Old screen X posn */
    GENPTR_REAL(pyo)		/* i: Old screen Y posn */
    GENPTR_REAL(rxo)		/* i: Old max X radius (image scale) */
    GENPTR_REAL(ryo)		/* i: Old max Y radius (image scale) */
    GENPTR_REAL(px)		/* i: New screen X posn */
    GENPTR_REAL(py)		/* i: New screen Y posn */
    GENPTR_REAL(rax1)		/* i: Inner X oval radius (image scale) */
    GENPTR_REAL(ray1)		/* i: Inner Y oval radius (image scale) */
    GENPTR_INTEGER(kc1)		/* i: Inner oval colour (1-8) */
    GENPTR_REAL_ARRAY(rax2)	/* i: Inner/outer annular X oval radii */
    GENPTR_REAL_ARRAY(ray2)	/* i: Inner/outer annular Y oval radii */
    GENPTR_INTEGER(kc2)		/* i: Outer oval colour (1-8) */
/* C-- */
/* Cbegin */


      (void) dsxc_paintova ( *pxo, *pyo, *rxo, *ryo, *px, *py, *rax1, *ray1,
                             *kc1, rax2, ray2, *kc2 );


}


/*******************************************************************
  <a name="dsx_paintovb">  DSX_PAINTOVB  </a>-- Paint moving oval - erase last - Fortran interface (XWindows)

   alan penny                  ral                        1990-02-03
  pat morris             leeds        1992 jan
*/

F77_SUBROUTINE(dsx_paintovb) ( INTEGER_ARRAY(kcx), INTEGER_ARRAY(kcy),
                               INTEGER(kc1), INTEGER(kc2),
                               REAL(pxo), REAL(pyo), REAL(rxo), REAL(ryo) )
{
    GENPTR_INTEGER_ARRAY(kcx)		/* i: Centre/Inner/outer annular X oval */
    GENPTR_INTEGER_ARRAY(kcy)		/* i: Centre/Inner/outer annular Y oval */
    GENPTR_INTEGER(kc1)			/* i: Centre oval colour (1-8) */
    GENPTR_INTEGER(kc2)			/* i: Inner/Outer oval colour (1-8) */
    GENPTR_REAL(pxo)        	    	/* i: Old screen X posn */
    GENPTR_REAL(pyo)            	/* i: Old screen Y posn */
    GENPTR_REAL(rxo)			/* i: Old max X radius (image scale) */
    GENPTR_REAL(ryo)			/* i: Old max Y radius (image scale) */
/* C-- */
/* Cbegin */


      (void) dsxc_paintovb ( kcx, kcy, *kc1, *kc2, *pxo, *pyo, *rxo, *ryo );


}


/***********************************************************************
  <a name="dsx_init"> DSX_INIT  </a>-- Initialise window - Fortran interface (XWindows)

  alan penny             ral          1990 Aug
  patrick Morris         leeds                  1992 Jan
*/

F77_SUBROUTINE(dsx_init) ( CHARACTER(title), INTEGER(kscreen),
                           INTEGER(ierr) TRAIL(title) )

{
    GENPTR_CHARACTER(title)  	/* i: Title of image */
    GENPTR_INTEGER(kscreen)     /* i: Ask for screen size flag (0=yes;1=no) */
    GENPTR_INTEGER(ierr)     	/* o: Error flag (0=ok;1=bad) */
/* C-- */
     char *name;
     int iierr;
/* Cbegin */

      name = cnf_creim ( title, title_length );

      (void) dsxc_init ( name, *kscreen, &iierr );

      *ierr = iierr;
      cnf_free ( name );

}


/***********************************************************************
  <a name="dsx_id_init"> DSX_ID_INIT  </a>-- Initialise window IDs - Fortran interface (XWindows)

  alan penny             ral          1990 Aug
  patrick Morris         leeds                  1992 Jan
*/

F77_SUBROUTINE(dsx_id_init) ( void )

{
/* C-- */
/* Cbegin */


      (void) dsxc_id_init ( );


}


/******************************************************************
  <a name="dsx_scol">     DSX_SCOL  </a>-- Set line colour - Fortran interface (XWindows)

    alan penny           ral                       1990-02-01
  pat morris             leeds        1992 jan
*/

F77_SUBROUTINE(dsx_scol) ( REAL(w), INTEGER(kc) )

{
    GENPTR_REAL(w)		/* i: Line width */
    GENPTR_INTEGER(kc)		/* i: Colour (1=red;2=green;3=blue;4=yellow
				   5=cyan;6=mauve;7=tan;8=pink) */
/* C-- */
/* Cbegin */

    (void)  dsxc_scol ( *w, *kc );


}


/***********************************************************************
  <a name="dsx_close">       DSX_CLOSE  </a>-- Close window - Fortran interface (XWindows)

  alan penny             ral          1990 jan
  pat morris             leeds        1992 jan
*/

F77_SUBROUTINE(dsx_close) ( INTEGER(ierr) )

{
    GENPTR_INTEGER(ierr)		/* o: Error flag (0=ok;1=bad) */
/* C-- */
    int iierr;
/* Cbegin */


      (void) dsxc_close ( &iierr );
       *ierr = iierr;


}



/**************************************************************************
  <a name="dsx_erase">       DSX_ERASE  </a>-- Erase display - Fortran interface (XWindows)

    a j penny                    ral         1990 jan
*/

F77_SUBROUTINE(dsx_erase) (void)

/* C-- */
{
/* Cbegin */


     (void) dsxc_erase ();


}



/*********************************************************************
  <a name="dsx_scur">       DSX_SCUR  </a>-- Start the cursor - Fortran interface (XWindows)

   alan penny                  ral                        1990-02-03
  pat morris             leeds        1992 jan
*/

F77_SUBROUTINE(dsx_scur) (void)

/* C-- */
{
/* Cbegin */


     (void) dsxc_scur ();

}



/**********************************************************************
  <a name="dsx_pcur">       DSX_PCUR  </a>-- Put the cursor at position - Fortran interface (XWindows)

   alan penny                  ral                        1990-02-03
  pat morris             leeds        1992 jan
*/

F77_SUBROUTINE(dsx_pcur) ( INTEGER(kx), INTEGER(ky) )

{
    GENPTR_INTEGER(kx)		/*i: X position to put cursor at */
    GENPTR_INTEGER(ky)		/*i: Y position to put cursor at */
/* C-- */
/* Cbegin */

     (void) dsxc_pcur ( *kx, *ky );


}


/********************************************************************
  <a name="dsx_oval">    DSX_OVAL  </a>-- Paint an oval - Fortran interface (XWindows)

    alan penny           ral                       1990-02-01
  pat morris             leeds        1992 jan
*/

F77_SUBROUTINE(dsx_oval) ( REAL(xp), REAL(yp), REAL(radx), REAL(angle),
                           REAL(elli), INTEGER(kc) )

{
    GENPTR_REAL(xp)		/* i: Image X position */
    GENPTR_REAL(yp)		/* i: Image Y position */
    GENPTR_REAL(radx)		/* i: Image pixel X radius */
    GENPTR_REAL(angle)		/* i: Oval angle to X-axis */
    GENPTR_REAL(elli)		/* i: Oval ellipticity */
    GENPTR_INTEGER(kc)		/* i: Colour (1=red;2=green;3=blue;4=yellow;
				           5=cyan;6=mauve;7=tan;8=pink)
				           9=black;10=white) */
/* C-- */
/* Cbegin */

     (void) dsxc_oval ( *xp, *yp, *radx, *angle, *elli, *kc );


}

/********************************************************************
  <a name="dsx_osize">    DSX_OSIZE  </a>-- X, Y Size of tilted oval - Fortran interface (XWindows)

    alan penny           ral                       1994
*/

F77_SUBROUTINE(dsx_osize) ( REAL(rad), REAL(ang), REAL(elli), REAL(xs),
                            REAL(ys) )

{
    GENPTR_REAL(rad)		/* i: Oval maj radius */
    GENPTR_REAL(ang)		/* i: Angle to X-axis in degrees */
    GENPTR_REAL(elli)		/* i: Ellipticity */
    GENPTR_REAL(xs)		/* o: X coverage */
    GENPTR_REAL(ys)		/* o: Y coverage */
/* C-- */
    float xxs, yys;
/* Cbegin */


     (void) dsxc_osize ( *rad, *ang, *elli, &xxs, &yys );
     *xs = xxs;
     *ys = yys;

}


/****************************************************************
  <a name="dsx_cross">   DSX_CROSS  </a>-- Put a cross at a position - Fortran interface (XWindows)

  alan penny             ral             1990 Jan
  pat morris             leeds        1992 jan
*/

F77_SUBROUTINE(dsx_cross) ( REAL(x), REAL(y), REAL(crs), INTEGER(kc) )

{
    GENPTR_REAL(x)		/* i: X position(image pixels) */
    GENPTR_REAL(y)		/* i: Y position (image pixels) */
    GENPTR_REAL(crs)		/* i: Cross size (end-to-end) (image pixels) */
    GENPTR_INTEGER(kc)		/* i: Colour (1=red;2=green;3=blue;4=yellow;
					      5=cyan;6=mauve;7=tan;8=pink)
					      9=black;10=white) */
/* C-- */
/* Cbegin */


     (void) dsxc_cross ( *x, *y, *crs, *kc );


}



/**********************************************************************
 D<a name="sx_line"> SX_LINE  </a>-- Put a line at a position - Fortran interface (XWindows)

  alan penny             ral             1990 May
  pat morris             leeds        1992 jan
*/

F77_SUBROUTINE(dsx_line) ( REAL(xs), REAL(ys), REAL(xe), REAL(ye),
                            INTEGER(kc) )

{
    GENPTR_REAL(xs)		/* i: Line start X position(image pixels) */
    GENPTR_REAL(ys)		/* i: Line start Y position (image pixels) */
    GENPTR_REAL(xe)		/* i: Line end X position(image pixels) */
    GENPTR_REAL(ye)		/* i: Line end Y position (image pixels) */
    GENPTR_INTEGER(kc)		/* i: Colour (1=red;2=green;3=blue;4=yellow;
				           5=cyan;6=mauve;7=tan;8=pink)
				           9=black;10=white) */
/* C-- */
/* Cbegin */


     (void) dsxc_line ( *xs, *ys, *xe, *ye, *kc );


}



/****************************************************************************
  <a name="dsx_updown">   DSX_UPDOWN  </a>-- Raise' or 'lower' a window - Fortran interface (Xwindows)

  alan penny           ral                         1990-06-09
  pat morris             leeds        1992 jan
*/

F77_SUBROUTINE(dsx_updown) ( INTEGER(kf) )

{
    GENPTR_INTEGER(kf)		/* i: raise=1; lower=2 */
/* C-- */
/* Cbegin */


    (void) dsxc_updown ( *kf );


}


/**************************************************************************
  <a name="dsx_acimr"> DSX_ACIMR  </a>-- Display part of an actual real image (loads virtual image)

  alan penny                  ral         1990 jan
  pat morris             leeds        1992 jan
*/

F77_SUBROUTINE(dsx_acimr) ( REAL_ARRAY(im), INTEGER(mx), INTEGER(my),
                            INTEGER(ixs), INTEGER(ixe), INTEGER(iys), INTEGER(iye),
                            INTEGER(ix), INTEGER(iy), LOGICAL(wrap) )

GENPTR_INTEGER(mx) 		/* i: Actual image X size */
GENPTR_INTEGER(my)		/* i: Actual image Y size */
GENPTR_REAL_ARRAY(im)		/* i: Actual image */
GENPTR_INTEGER(ixs)		/* i: Actual image area X start */
GENPTR_INTEGER(ixe)		/* i: Actual image area X end */
GENPTR_INTEGER(iys)		/* i: Actual image area Y start */
GENPTR_INTEGER(iye)		/* i: Actual image area Y end */
GENPTR_INTEGER(ix)		/* i: Position in virtual image of X start */
GENPTR_INTEGER(iy)		/* i: Position in virtual image of Y start */
GENPTR_LOGICAL(wrap)		/* i: Flag to wrap values round display limits */

{

    (void) dsxc_acimr ( im, *mx, *my, *ixs, *ixe, *iys, *iye, *ix, *iy, *wrap );

}


/****************************************************************
  <a name="dsx_acims">   DSX_ACIMS  </a>-- Display part of an actual int*2 image (loads virtual image)

  alan penny             ral          1990 jan
  pat morris             leeds        1992 jan
*/

F77_SUBROUTINE(dsx_acims) ( WORD_ARRAY(im), INTEGER(mx), INTEGER(my),
                            INTEGER(ixs), INTEGER(ixe), INTEGER(iys), INTEGER(iye),
                            INTEGER(ix), INTEGER(iy), LOGICAL(wrap) )

GENPTR_INTEGER(mx) 			/* i: Actual image X size */
GENPTR_INTEGER(my)			/* i: Actual image Y size */
GENPTR_WORD_ARRAY(im)			/* i: Actual image */
GENPTR_INTEGER(ixs)			/* i: Actual image area X start */
GENPTR_INTEGER(ixe)			/* i: Actual image area X end */
GENPTR_INTEGER(iys)			/* i: Actual image area Y start */
GENPTR_INTEGER(iye)			/* i: Actual image area Y end */
GENPTR_INTEGER(ix)			/* i: Position in virtual image of X start */
GENPTR_INTEGER(iy)			/* i: Position in virtual image of Y start */
GENPTR_LOGICAL(wrap)			/* i: Flag to wrap values round display limits*/

{

    (void) dsxc_acims ( im, *mx, *my, *ixs, *ixe, *iys, *iye, *ix, *iy, *wrap );

}


/****************************************************************************
  <a name="dsx_mswait">   DSX_MSWAIT  </a>-- Wait N milliseconds an image - Fortran interface (Xwindows)

  alan penny           ral                         1990-06-09
  pat morris             leeds        1992 jan
*/

F77_SUBROUTINE(dsx_mswait) ( INTEGER(msecs) )

{
    GENPTR_INTEGER(msecs)		/* i: Milliseconds to wait */
/* C-- */

/* Cbegin */

    (void) dsxc_mswait ( *msecs );

}


/***********************************************************************
  <a name="dsxc_init"> DSXC_INIT  </a>-- Initialise window (XWindows)

  alan penny             ral          1990 Aug
  patrick Morris         leeds                  1992 Jan
*/

dsxc_init ( title, kscreenopt, ierr )

    char  *title;		/* i: Title of image */
    int   *kscreenopt;		/* i: Ask for screen size? (0=yes;1=no)*/
    int   *ierr;		/* o: Error flag (0=ok;1=bad) */

/* C-- */
{
      char                texta[100];

      Bool                func = True ;		/* Synchronous behaour */

      unsigned long       attr_mask;		/* attributes mask */
      long                event_mask;
      int     iv, ivx, ivy, jx, jy, lxy, nxa, nya, k, kka, kkb;
      int     kxa, kya, nnxa, nnya;
      float   rvx, rvy;
      XFontStruct         *font;		/* font structure */

      XSetWindowAttributes   xswda; 		/* window attributes */
      XGCValues           xgcvl;    		/* gc values */
      XSizeHints          xszhn;	    	/* size hints */
/*
      char   *font_name = "-adobe-new century schoolbook-medium-r-normal--*-120-*-*-p*";
      char   *font_name = "-adobe-new century schoolbook-medium-r-normal--*-80-*-*-p*";
*/
      char   *font_name = "-adobe-new century schoolbook-medium-r-normal--*-100-*-*-p*";
      char   *display_name = NULL;
      char buf1[32], buf2[32];
      char *argv[8];

      XEvent              event;
      Status              status;
      XVisualInfo         vinfo;
/* Cbegin */


      *ierr = 0;

      PDSOPEN = F77_NAMED_COMMON(ds_panelb).pdsopen;
      DSNXS = F77_NAMED_COMMON(ds_gen).dsnxs;
      DSNXE = F77_NAMED_COMMON(ds_gen).dsnxe;
      DSNYS = F77_NAMED_COMMON(ds_gen).dsnys;
      DSNYE = F77_NAMED_COMMON(ds_gen).dsnye;

      if ( PDSOPEN ) {
         if ( VD_ID == NULL ) {
            (void) c_printo ( "ERROR: Cant open Xwindows display" );
            *ierr = 1;
            return ;
         }
      }
      else {
         if ( (VD_ID = XOpenDisplay(display_name)) == NULL ) {
            (void) c_printo ( "ERROR: Cant open Xwindows display" );
            *ierr = 1;
            return;
         }
         (void) c_get1i ( "NUMBUTT", &iv, 3, 2, 3 );
         NUMXBUTTONS = iv;
         F77_NAMED_COMMON(ds_gen).numxbuttons = iv;
      }
      DSOPEN = True;
      F77_NAMED_COMMON(ds_genb).dsopen = F77_TRUE;

      (void) XSynchronize ( VD_ID, func );
      SC_ID = DefaultScreen ( VD_ID );
      RW_ID = RootWindow ( VD_ID, SC_ID );

      nxa = DisplayWidth ( VD_ID, SC_ID ) ;
      nya = DisplayHeight( VD_ID, SC_ID ) ;
      nnxa = nxa - 6 ;
      nnya = nya - 25 ;

      if ( nnxa*nnya > MAXVIRT ) {
         (void) sprintf ( texta,
         "  WARNING: Total screen size is %5d x %5d :", nxa, nya );
         (void) c_printo ( texta );
         (void) sprintf ( texta,
         "           Opening a window with more than 8%d pixels ", MAXVIRT );
         (void) c_printo ( texta );
         (void) c_printo ( "           will crash this program" );
      }

      jx  = DSNXE - DSNXS + 1 ;		/* Get screen pixel size */
      jy  = DSNYE - DSNYS + 1 ;
      if ( jx<16 || jy<16 ) {
         (void) sprintf ( texta,
         "  WARNING: Window size asked for was %5d x %5d :", jx, jy);
         (void) c_printo ( texta );
         (void) c_printo (
         "           For technical reasons, display sides must be > 15" );
         if ( jx<16 ) jx = 16;
         if ( jy<16 ) jy = 16;
         (void) sprintf ( texta,
         "           Window will be opened as size %5d x %5d :", jx, jy);
         (void) c_printo ( texta );
       }
      DSSNX = jx ;
      DSSNY = jy ;
      if ( (jx > nnxa) || (jy > nnya) ) {
         kka = jx - 1;
         if ( kka<0 ) kka = -1*kka;
         kkb = jy - 1;
         if ( kkb<0 ) kkb = -1*kkb;
         lxy = 1 + imax((kka/nnxa),(kkb/nnya));
         DSSNX = 1 + ((jx-1)/lxy);
         DSSNY = 1 + ((jy-1)/lxy);
         (void) sprintf ( texta,
                          " Image size %5d x %5d is too large for screen size - %5d x %5d",
                          jx, jy, nnxa, nnya );
         (void) c_printo ( texta );
         (void) sprintf ( texta, " Displayed image will be compressed by %5d x %5d",
                          lxy, lxy);
         (void) c_printo ( texta );
      }

      if ( kscreenopt==0 ) {
         k = imax(nnxa,nnya);
         ivx = DSSNX;
         ivy = DSSNY;
         (void) c_get2i ( "SCREEN", &ivx, &ivy, True, 1, k );
         DSSNX = ivx;
         DSSNY = ivy;
      }

      if ( DSSNX > nnxa ) {
         (void) sprintf ( texta, " X size too large - set to max X size of %d",
                                 nnxa);
         (void) c_printo ( texta );
         DSSNX = nnxa;
      }
      if ( DSSNY > nnya ) {
         (void) sprintf ( texta, " Y size too large - set to max Y size of %d",
                                nnya);
         (void) c_printo ( texta );
         DSSNY = nnya;
      }

      F77_NAMED_COMMON(ds_gen).dssnx = DSSNX;
      F77_NAMED_COMMON(ds_gen).dssny = DSSNY;

      if ( ( DEPTH = DefaultDepth (VD_ID, SC_ID) ) < 8 ) {
         (void) c_printo ( "ERROR: Screen pixel depth must be at least 8" );
         *ierr = 1;
         return ;
      }

      D_VISUAL = DefaultVisual (VD_ID, SC_ID);
      status = XMatchVisualInfo ( VD_ID, SC_ID, DEPTH, PseudoColor, &vinfo );
      if ( status == 0 ) {
         (void) c_printo (
         "ERROR: Cant allocate colours - display type has to be pseudo color" );
         *ierr = 1;
         return ;
      }

      if ( vinfo.visual != D_VISUAL )
	  (void) c_printo ( "Not default visual" );
      if (!PDSOPEN) (void) dsxc_opcolmap ();				/* Open colour map */

      attr_mask = CWEventMask | CWBackPixel | CWBorderPixel | CWColormap;
      xswda.event_mask = ExposureMask;
      xswda.background_pixel = BlackPixel(VD_ID,SC_ID);
      xswda.border_pixel = WhitePixel(VD_ID,SC_ID);
      xswda.colormap = CM_ID;

      kxa = nnxa - DSSNX - DSWINDX;					/* Position */
      kya = DSWINDY ;

      WD_ID = XCreateWindow ( VD_ID, RW_ID, kxa, kya, DSSNX, DSSNY, 0, DEPTH,
                             InputOutput, D_VISUAL, attr_mask, &xswda );

      (void) dsxc_cicon ();						/* Set up corner icon */

      DSWINDX = DSWINDX + DSSNX + 20;
      DSWINDXM = DSWINDX;

      F77_NAMED_COMMON(ds_gen).dswindx = DSWINDX;
      F77_NAMED_COMMON(ds_gen).dswindxm = DSWINDXM;

      xgcvl.foreground = WhitePixel(VD_ID,SC_ID);			/* Create graphics context */
      xgcvl.background = WhitePixel(VD_ID,SC_ID);
      GC_ID = XCreateGC ( VD_ID, WD_ID, (GCForeground | GCBackground), &xgcvl );

      if ( (font = XLoadQueryFont ( VD_ID, font_name ) ) == NULL ) {	/* Load the font for text writing */
         (void) c_printo (
         "WARNING: Couldn\'t open fonts - any text may be wrong size");
      }else{
         XSetFont ( VD_ID, GC_ID, font->fid );
      }

      XSetForeground ( VD_ID, GC_ID, WhitePixel(VD_ID,SC_ID) );

      xszhn.x = kxa;							/* Define the size and name of the WD_ID window */
      xszhn.y = kya;
      xszhn.width = DSSNX;
      xszhn.height = DSSNY;
      xszhn.flags = PPosition | PSize ;

      XSetNormalHints ( VD_ID, WD_ID, &xszhn );
      XFlush ( VD_ID );

      PIXMAP = XCreatePixmap ( VD_ID, RW_ID, DSSNX, DSSNY, DEPTH );
      (void) dsxc_clearpix () ;

      XSelectInput ( VD_ID, WD_ID, (  StructureNotifyMask    | ButtonReleaseMask
                                    | ButtonPressMask        | PointerMotionMask
                                    | SubstructureNotifyMask | ExposureMask) );


      PID = vfork();
      if ( PID != 0 ) {  						/* We are child so do exposure monitor */
         if ( PID == -1 ) (void) c_printo ( "ERROR: Refresh not started" );
      } else {
         display_name = DisplayString ( VD_ID );
         argv[0] = "s_refresh";
         sprintf ( buf1, "%lu", WD_ID );
         argv[1] = buf1;
         sprintf ( buf2, "%lu", PIXMAP );
         argv[2] = buf2;
         argv[3] = display_name;
         argv[4] = '\0';
         execvp ( "s_refresh", argv );
        _exit ( errno );
       }

      XMapWindow ( VD_ID, WD_ID );					/* Map the windows */
      XFlush ( VD_ID );

      (void) dsxc_pttit ( title );

      (void) dsxc_erase () ;

      event_mask = StructureNotifyMask | SubstructureNotifyMask;
      XWindowEvent ( VD_ID, WD_ID, event_mask, &event ); 		/* Wait for window to appear */

      XFlush ( VD_ID );

      rvx = DSSNX/2;							/* Cursor position */
      rvy = DSSNY/2;
      DSCURPOSX = rvx;
      DSCURPOSY = rvy;
      DSCURSET  = False;

      DSZM = 1;								/* Set Zoom factors */
      DSZPX = 1;
      DSZPY = 1;

      DSIXS  = 1;							/* Default image blh corner X */
      DSIYS  = 1;							/* and Y virtual image posn */

      F77_NAMED_COMMON(ds_gen).dscurposx = rvx;
      F77_NAMED_COMMON(ds_gen).dscurposy = rvy;
      F77_NAMED_COMMON(ds_genb).dscurset = F77_FALSE;
      F77_NAMED_COMMON(ds_gen).dszm = DSZM;
      F77_NAMED_COMMON(ds_gen).dszpx = DSZPX;
      F77_NAMED_COMMON(ds_gen).dszpy = DSZPY;
      F77_NAMED_COMMON(ds_gen).dsiys = DSIYS;
      F77_NAMED_COMMON(ds_gen).dsixs = DSIXS;

      DSCOMFX = F77_NAMED_COMMON(ds_gen).dscomfx;
      DSCOMFY = F77_NAMED_COMMON(ds_gen).dscomfy;
}


/**************************************************************************
  <a name="dsxc_id_init"> DSXC_ID_INIT  </a>-- Initialise window IDs (XWindows)

  alan penny             ral          1990 jan
  pat morris             leeds        1992 jan
*/

dsxc_id_init (void)
{

      VD_ID = NULL;

}


/**************************************************************************
 D<a name="sxc_opcolmap"> SXC_OPCOLMAP  </a>-- Open colour map (Xwindows)

  alan penny             ral                    1990 Aug
  patrick Morris         leeds                  1992 Jan
*/

dsxc_opcolmap (void)

/* C-- */
{
      Status istat;
      int iv;
      unsigned long plane_mask;
/* Cbegin */


      CM_ID = DefaultColormap ( VD_ID, SC_ID );		/* Get colormap */

      OWNCOL = True;
      NUMDDCOL = NUMDCOL;
      istat = XAllocColorCells ( VD_ID, CM_ID, False, &plane_mask,
                                 0, PC_ID, (15+NUMDDCOL) );
      if ( istat == 0 ) {
         NUMDDCOL = NUMDCOL/2;
         istat = XAllocColorCells ( VD_ID, CM_ID, False, &plane_mask,
                                    0, PC_ID, 15+NUMDDCOL );
         if ( istat == 0 ) {
            NUMDDCOL = NUMDCOL/3;
            istat = XAllocColorCells ( VD_ID, CM_ID, False, &plane_mask,
                                       0, PC_ID, 15+NUMDDCOL );
            if ( istat == 0 ) {
               NUMDDCOL = NUMDCOL;
               (void) c_printo ( "WARNING: Cant allocate own colours - will take available ones" );
               (void) c_printo ( "        LUT Rotation and Scaling will not work" );
               (void) c_printo ( "        Any change to the LUT will also need to have the image redisplayed" );
               OWNCOL = False;
            }
            else
               (void) c_printo ( "WARNING: Only 50 steps in image display" );
         }
         else
            (void) c_printo ( "WARNING: Only 75 steps in image display" );
      }

      F77_NAMED_COMMON(lutacom).numddcol = NUMDDCOL;

      (void) dsxc_setcol ();
      (void) dsxc_bytecol ();


}


/*********************************************************************
 D<a name="sxc_bytecol"> SXC_BYTECOL  </a>-- Calc byte equivalents of PC_ID (Xwindows)

  alan penny             ral                    1990 Aug
  pat morris             leeds        1992 jan
*/

dsxc_bytecol (void)

/* C-- */
{
      int k, iv, ka, kdiv;
/* Cbegin */


      NUMDDCOL = F77_NAMED_COMMON(lutacom).numddcol;

      kdiv = NUMDCOL/NUMDDCOL ;
      for ( k = 1; k <= (15+NUMDCOL) ; k++ ) {
         ka = k;
         if ( k > 15 ) ka = 16 + ((ka-16)/kdiv);
         iv = PC_ID[ka-1];
         if ( iv>255 )
            BY_PC_ID[k-1] = -1;
         else if ( iv>127 )
            BY_PC_ID[k-1] = -256 + iv;
         else if ( iv<0 )
            BY_PC_ID[k-1] = 0;
	 else
            BY_PC_ID[k-1] = iv;

      }


}


/*************************************************************************
 D<a name="sxc_cicon"> SXC_CICON  </a>-- Set up corner icon (Xwindows)

  alan penny             ral                    1990 Aug
  pat morris             leeds        1992 jan
*/

dsxc_cicon (void)

/* C-- */
{

      XWMHints        xwmhn;	    	/* Window manager hints */

      XWMHints        xwmhints;

      Pixmap          icon_pixmap;
      Atom            wmatom;
      static unsigned char icon_bits[512] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x3c, 0x1f, 0x63, 0x23, 0x62, 0x88, 0x00, 0x00,
        0x02, 0x04, 0x43, 0x64, 0x63, 0x88, 0x00, 0x00,
        0x02, 0x84, 0x44, 0x64, 0x93, 0x98, 0x00, 0x00,
        0x02, 0x84, 0x64, 0xa3, 0x92, 0xa8, 0x00, 0x00,
        0x1c, 0x84, 0x44, 0x21, 0x92, 0xa8, 0x00, 0x00,
        0x20, 0x84, 0x47, 0x22, 0xf2, 0xc8, 0x00, 0x00,

        0x20, 0x44, 0x48, 0x22, 0x0a, 0x89, 0x00, 0x00,
        0x1e, 0x44, 0x48, 0x24, 0x0a, 0x89, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

        0x80, 0x84, 0x20, 0x30, 0x1e, 0x00, 0x00, 0x00,
        0x80, 0xcc, 0x20, 0x48, 0x02, 0x00, 0x00, 0x00,
        0x80, 0xcc, 0x48, 0x08, 0x02, 0x00, 0x00, 0x00,
        0x80, 0xb4, 0x48, 0x04, 0x02, 0x00, 0x00, 0x00,
        0x80, 0x84, 0x48, 0x64, 0x0e, 0x00, 0x00, 0x00,
        0x80, 0x84, 0x68, 0x48, 0x02, 0x00, 0x00, 0x00,
        0x80, 0x84, 0x84, 0x48, 0x02, 0x00, 0x00, 0x00,
        0x80, 0x84, 0x84, 0x30, 0x1e, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xf0, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } ;
/* Cbegin */


      icon_pixmap = XCreateBitmapFromData ( VD_ID, WD_ID, icon_bits, 64, 64 );

      xwmhn.flags  = IconPixmapHint | IconMaskHint ;
      xwmhn.icon_pixmap = icon_pixmap ;
      xwmhn.icon_mask   = icon_pixmap ;
      XSetWMHints ( VD_ID, WD_ID, &xwmhn );

      wmatom = XInternAtom ( VD_ID, "XA_WM_HINTS", 0 ) ;

      if ( wmatom != None ) {
         xwmhints.flags =  IconPixmapHint ;
         xwmhints.icon_pixmap = icon_pixmap ;
         XChangeProperty ( VD_ID, WD_ID, wmatom, wmatom, 32,
                           PropModeReplace, (char *) &xwmhints, 9 ) ;
      }

      XFlush ( VD_ID );


}


/******************************************************************
  <a name="dsxc_scol">     DSXC_SCOL  </a>-- Set line colour (XWindows)

    alan penny           ral                       1990-02-01
  pat morris             leeds        1992 jan
*/

dsxc_scol ( w, kc )

    float     w;		/* i: Line width */
    int       kc;		/* i: Colour (1=red;2=green;3=blue;4=yellow
				   5=cyan;6=mauve;7=tan;8=pink) */
/* C-- */
{
/* Cbegin */



}


/*********************************************************************
  <a name="dsxc_setcol"> DSXC_SETCOL  </a>-- Set up color display for image display (Xwindows)

   alan penny                  ral                        1990-02-03
  pat morris             leeds        1992 jan
*/

dsxc_setcol (void)

/* C-- */
{
      int          k, ka;
      Status       istat;
      char         flags;
      unsigned short int    j;

      static float rr[10]={0.8, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.5};
      static float gg[10]={0.8, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.5, 1.0};
      static float bb[10]={0.8, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0};
      static float sgr[5]={0.0,  0.5,  0.75,  0.89,  1.0};                        /* Starman greys */
      static float sgg[5]={0.0,  0.5,  0.75,  0.89,  1.0};
      static float sgb[5]={0.0,  0.5,  0.75,  0.89,  1.0};
/* Cbegin */


      flags = DoRed | DoGreen | DoBlue ;

      if ( OWNCOL ) {

         for ( k = 0; k<10; k++ ) {						/* Pgplot colours */
            COLOUR[k].pixel = PC_ID[k];
            COLOUR[k].flags = flags;
            j = (short) (rr[k]*65535.0) ;
            COLOUR[k].red = j;
            j = (short) (gg[k]*65535.0) ;
            COLOUR[k].green = j;
            j =  (short) (bb[k]*65535.0) ;
            COLOUR[k].blue = j;
         }

         for ( k = 10; k<15; k++ ) {						/* Starman greys */
            COLOUR[k].pixel = PC_ID[k];
            COLOUR[k].flags = flags;
            ka = k - 10;
            j = (short) (sgr[ka]*65535.0) ;
            COLOUR[k].red = j;
            j = (short) (sgg[ka]*65535.0) ;
            COLOUR[k].green = j;
            j = (short) (sgb[ka]*65535.0) ;
            COLOUR[k].blue = j;
         }

         for ( k = 15; k<15+NUMDDCOL ; k++ ) {					/* Starman grey scale */
            COLOUR[k].pixel = PC_ID[k];
            COLOUR[k].flags = flags;
            j =  65535.0 * (k-15)/(NUMDDCOL-1);
            COLOUR[k].red = j;
            COLOUR[k].green = j;
            COLOUR[k].blue = j;
         }


         XStoreColors ( VD_ID, CM_ID, COLOUR, (15+NUMDDCOL) );
         XInstallColormap ( VD_ID, CM_ID );
         XFlush ( VD_ID );

         (void) dsxc_lutacol () ;						/* Set up LUT */
         (void) dsxc_lutcol () ;

      }
      else {

         for ( k = 0; k<10 ; k++ ) {						/* Pgplot colours */
            COLOUR[k].flags = flags;
            j = (short) (rr[k]*65535.0);
            COLOUR[k].red = j;
            j = (short) (gg[k]*65535.0);
            COLOUR[k].green = j;
            j = (short) (bb[k]*65535.0);
            COLOUR[k].blue = j;
            istat = XAllocColor ( VD_ID, CM_ID, &COLOUR[k] );
            if ( istat == 0 ) {
               (void) c_printo ( "ERROR: Colour pixel not allocated" ) ;
               PC_ID[k] = 0 ;
            }
            else
               PC_ID[k] = COLOUR[k].pixel ;
         }

         for ( k = 10; k<15 ; k++ ) {						/* Starman greys */
            COLOUR[k].flags = flags;
            ka = k - 10;
            j = (short) (sgr[ka]*65535.0) ;
            COLOUR[k].red = j;
            j = (short) (sgg[ka]*65535.0) ;
            COLOUR[k].green = j;
            j = (short) (sgb[ka]*65535.0) ;
            COLOUR[k].blue = j;
            istat = XAllocColor ( VD_ID, CM_ID, &COLOUR[k] );
            if ( istat == 0 ) {
               (void) c_printo ( "ERROR: Colour pixel not allocated" );
               PC_ID[k] = 0;
            }
            else
               PC_ID[k] = COLOUR[k].pixel ;
         }

         for ( k = 15; k<15+NUMDCOL ; k++ ) {					/* Starman grey scale */
            COLOUR[k].flags = flags ;
            j = (short) (( (float) (k-15)/ (float) (NUMDCOL-1))*65535.0) ;
            COLOUR[k].red = j;
            COLOUR[k].green = j;
            COLOUR[k].blue = j;
            istat = XAllocColor ( VD_ID, CM_ID, &COLOUR[k] ) ;
            if ( istat == 0 ) {
               (void) c_printo ( "ERROR: Colour pixel not allocated" );
               PC_ID[k] = 0;
            }
            else
               PC_ID[k] = COLOUR[k].pixel;
         }

         XFlush ( VD_ID );

         (void) dsxc_lutacol () ; 						/* Set up LUT */
         (void) dsxc_lutcol () ;

      }


}



/******************************************************************
 D<a name="sxc_vtim"> SXC_VTIM  </a>-- Display part of virtual image (Xwindows)

    alan penny           ral                       1990-02-01
*/

dsxc_vtim ( jvxs, jvxe, jvys, jvye, kcl )

    int    jvxs;           /* i: X start of virtual area to display */
    int    jvxe;           /* i: X   end of virtual area to display */
    int    jvys;           /* i: Y start of virtual area to display */
    int    jvye;           /* i: Y   end of virtual area to display */
    int    kcl;            /* i: Flag to clear screen before (0=no) */

/* C-- */
{

      int j, isxs, isxe, isys, isye, ksxs, ksxe, ksys, ksye,
             ivxs, ivxe, ivys, ivye, kvxs, kvxe, kvys, kvye;
      long nn;
      char *ptr;
      char texta[100];
/* Cbegin */


      DSSNX = F77_NAMED_COMMON(ds_gen).dssnx;
      DSSNY = F77_NAMED_COMMON(ds_gen).dssny;
      DSZM = F77_NAMED_COMMON(ds_gen).dszm;

      ivxe = imax( jvxs, jvxe ); 					/* Get +ve version of area*/
      ivxs = imin( jvxs, jvxe );
      ivye = imax( jvys, jvye );
      ivys = imin( jvys, jvye );

      if ( ivxe<1 || ivxs>DSSNX || ivye<1 || ivys>DSSNY ) {		/* Check in virtual image */
         if ( kcl != 0 ) (void) dsxc_clear();				/* If told to, clear */
         return;
      }

      (void) vtc_tvs ( ivxs, ivys, &isxs, &isys );  			/*Get screen positions */
      isye = isye + (DSZM-1);
      (void) vtc_tvs ( ivxe, ivye, &isxe, &isye );
      isxe = isxe + (DSZM-1);

      if ( (isxe+DSZM-1)<1 || isxs>DSSNX || 				/* Check in screen image */
           (isye+DSZM-1)<1 || isys>DSSNY ) {
         if ( kcl != 0 ) (void) dsxc_clear();				/* If told to, clear */
         return;
      }

      kvxs = imax(1,ivxs);                    				/* Get area to display on screen*/
      kvys = imax(1,ivys);
      kvxe = imin(DSSNX,ivxe);
      kvye = imin(DSSNY,ivye);
      (void) vtc_tvs ( kvxs, kvys, &ksxs, &ksys );
      (void) vtc_tvs ( kvxe, kvye, &ksxe, &ksye );
      ksxe = ksxe + (DSZM-1);
      ksye = ksye + (DSZM-1);

      if ( ksys<1 ) {
         ksys = 1;
         (void) vtc_tsv ( 0, ksys, &j, &kvys );
      }

      if ( ksye>DSSNY ) {
         ksye = DSSNY;
         (void) vtc_tsv ( 0, ksye, &j, &kvye );
      }

      if ( ksxs<1 ) {
         ksxs = 1;
         (void) vtc_tsv ( ksxs, 0, &kvxs, &j );
      }

      if ( ksxe>DSSNX ) {
         ksxe = DSSNX;
         (void) vtc_tsv ( ksxe, 0, &kvxe, &j );
      }

      if ( DSZM==1 && kvxs==1 && kvxe==DSSNX && kvys==1 		/* Display whole vitual image */
           && kvye==DSSNY ) {
         nn = 1;
         (void) dsxc_vtima  ( ptr, nn, kcl, ksxs, ksxe,
                              ksys, ksye, kvxs, kvxe, kvys, kvye );
      } else {
         nn = DSZM*DSZM*(kvxe-kvxs+1)*(kvye-kvys+1);

         if ( nn<=0 ) {
         (void) sprintf ( texta,
            "ERROR:  %d size workspace asked in - s/r dsxc_vtim", nn);
            (void ) c_printo ( texta );
            return;
         }
         ptr = calloc ( nn, sizeof(char) );
         if ( ptr==NULL ) {
            (void ) c_printo (
                    "ERROR: cant get workspace - in s/r dsxc_vtim" );
            return;
         }
         (void) dsxc_vtima ( ptr, nn, kcl, ksxs, ksxe, ksys, ksye,
                                kvxs, kvxe, kvys, kvye );
         free ( ptr);
      }


}




/******************************************************************
  <a name="dsxc_vtima"> DSXC_VTIMA  </a>-- Display part of virtual image (Xwindows)

    alan penny           ral                       1990-02-01
  pat morris             leeds        1992 jan
*/

dsxc_vtima ( vt, nn, kcl, ksxs, ksxe, ksys, ksye, kvxs, kvxe, kvys, kvye )

    char vt[];		/* o: Work area */
    long nn; 		/* i: size of work area */
    int kcl;		/* i: Flag to clear screen before display  (0=no) */
    int ksxs;		/* i: X start of screen area */
    int ksxe;		/* i: X   end of screen area */
    int ksys;		/* i: Y start of screen area */
    int ksye;		/* i: Y   end of screen area */
    int kvxs;		/* i: X start of virtual area to display */
    int kvxe;		/* i: X   end of virtual area to display */
    int kvys;		/* i: Y start of virtual area to display */
    int kvye;		/* i: Y   end of virtual area to display */

/* C-- */
{
      XImage    *image;
      int       k, kx, ky, jkx, jky;
      unsigned int  ukx, uky;
      char *ipd;
/* Cbegin */


      DSSNX = F77_NAMED_COMMON(ds_gen).dssnx;
      DSSNY = F77_NAMED_COMMON(ds_gen).dssny;
      DSZM = F77_NAMED_COMMON(ds_gen).dszm;

      if ( kcl != 0 && ( ksxs > 1 || ksxe < DSSNX || 			/* If not fill screen and told to, clear first */
           ksys > 1 || ksye < DSSNY ) ) (void) dsxc_clear();

      kx = ksxe - ksxs + 1;
      ky = ksye - ksys + 1;
      ukx = kx;
      uky = ky;

      jkx = ksxs - 1;
      jky = DSSNY - ksye;

      if ( (DSZM==1) && (kvxs==1) && (kvxe==DSSNX) &&			/* Display whole vitual image */
           (kvys==1) && (kvye==DSSNY) ) {
         ipd = malloc ( kx*ky );
         for ( k=0;k<kx*ky;k++ )
            ipd[k] = VT_IM[k];
      } else {
         (void) dsxc_vtload ( vt, nn, kvxs, kvxe, kvys, kvye, ksxs );	/* Load array */

         ipd = malloc ( kx*ky );
         for ( k=0; k<kx*ky; k++ )
            ipd[k] = vt[k];
      }

      image = XCreateImage ( VD_ID, D_VISUAL, DEPTH, ZPixmap, 0,	/* Point to image */
                             ipd, ukx, uky, 8, kx);
      if ( image == NULL ) {
         (void) c_printo (
                   "ERROR: Could not get image - in s/r dsxc_vtima" );
         return;
      }

      XPutImage ( VD_ID, PIXMAP,GC_ID, image, 0, 0, jkx, jky, ukx, 	/* Put image in pixmap */
                  uky );
      XCopyArea ( VD_ID, PIXMAP, WD_ID, GC_ID, jkx, jky, ukx, uky, 	/* Put pixmap area on screen */
                  jkx, jky );

      XDestroyImage ( image );
      XFlush ( VD_ID );
      free (ipd);


}

/***********************************************************************
 D<a name="sxc_vtload"> SXC_VTLOAD  </a>-- Load part of virtual image into a zoomed array (Xwindows)

 Output array sides are size of input part array times the zoom factor.
 Output array starts at [0,0].

 The area is defined in the standard 'virtual' array - the 'VT_IM'
 input and 'vt' output are Y-reversed from this.

 If the 'right' of the new (perhaps enlarged) array lies
 outside the screen, then the array is filled up only to the edge.

 The output array is usually sized so that it is big enough
 to hold the whole zoomed aray.

 alan penny           ral                       1991 Aug
*/

dsxc_vtload ( vt, nn, kvxs, kvxe, kvys, kvye, ksxs )

    int   nn;			/* i: Size of work array */
    char  vt[];			/* o: Array to put image into */
    int   kvxs;			/* i: X start of virtual area */
    int   kvxe;			/* i: X   end of virtual area */
    int   kvys;			/* i: Y start of virtual area */
    int   kvye;			/* i: Y   end of virtual area */
    int   ksxs;			/* i: X screen start of output array */

/* C-- */
{
      int  j, k, jj, kk, ja, ka, kxd, kxf, kyd, kyf,
           kxs, kxe, kys, kye;
/* Cbegin */


      DSSNX = F77_NAMED_COMMON(ds_gen).dssnx;
      DSSNY = F77_NAMED_COMMON(ds_gen).dssny;
      DSZM = F77_NAMED_COMMON(ds_gen).dszm;

      kxs = kvxs - 1;						/* VT_IM and vt coordinates */
      kxe = kvxe - 1;
      kys = DSSNY - kvye;
      kye = DSSNY - kvys;

      if ( DSZM == 1 ) {

         ka = 0;						/* Unzoomed is easy */
         for ( j = kys; j <= kye; j++ ) {
             ja = j*DSSNX;
             for ( k = kxs; k <= kxe; k++ ) {
                 vt[ka] = VT_IM[ja+k];
                 ka = ka + 1;
             }
         }

      } else {

         kxf = DSZM;						/* Fraction of zoomed pixel */
         kxd = ksxs + (kvxe-kvxs+1)*DSZM - 1;			/* at right edge */
         if ( kxd>DSSNX ) kxf = DSZM - (kxd-DSSNX);

         ka = 0;
         for ( j = kys; j <= kye; j++ ) {			/* Y rows */
            ja = j*DSSNX;

            for ( jj=1; jj <= DSZM; jj++ ) {
               if ( kxs != kxe ) {				/* 1st N-1 X pixels */
                  for ( k = kxs; k <= kxe-1; k++ ) {
                     for ( kk = 1; kk<= DSZM; kk++ ) {
                        vt[ka] = VT_IM[ja+k];
                        ka = ka + 1;
                     }
                  }
               }
               if ( kxf >= 1 ) {
                  for ( kk = 1; kk <= kxf; kk++ ) {		/* Last X pixel (or fraction) */
                     vt[ka] = VT_IM[ja+kxe];
                     ka = ka + 1;
                  }
               }
            }

         }

      }


}




/***********************************************************************
  <a name="dsxc_close">       DSXC_CLOSE  </a>-- Close window (XWindows)

  alan penny             ral          1990 jan
  pat morris             leeds        1992 jan
*/

dsxc_close ( ierr )

    int    *ierr;		/* o: Error flag (0=ok;1=bad) */

/* C-- */
{
/* Cbegin */


      DSSNX = F77_NAMED_COMMON(ds_gen).dssnx;
      DSWINDX = F77_NAMED_COMMON(ds_gen).dswindx;
      DSOPEN = F77_NAMED_COMMON(ds_genb).dsopen;
      PDSOPEN = F77_NAMED_COMMON(ds_panelb).pdsopen;

      *ierr = 0;						/* Cant fail! */

      if (!DSOPEN) return;

      DSWINDX = DSWINDX - DSSNX - 20;

      XUnmapWindow ( VD_ID, WD_ID );
      XDestroyWindow ( VD_ID, WD_ID );
      XFreePixmap ( VD_ID, PIXMAP );
      if ( !PDSOPEN ) XCloseDisplay ( VD_ID );
      XFlush ( VD_ID );

      DSOPEN = False;
      DSSCUR = False;

      F77_NAMED_COMMON(ds_genb).dsopen = F77_FALSE;	/* Display not open */
      F77_NAMED_COMMON(ds_genb).dsscur = F77_FALSE;
      F77_NAMED_COMMON(ds_gen).dswindx = DSWINDX;


}


/***********************************************************************
  <a name="dsxc_pttit">  DSXC_PTTIT  </a>-- Put image title on display (XWindows)

    alan penny                ral              1990-01-31
  pat morris             leeds        1992 jan
*/

dsxc_pttit ( title )

    char       *title;	/*   i: Title to put up */

/* C-- */
{
/* Cbegin */


    XStoreName ( VD_ID, WD_ID, title );


}



/**************************************************************************
  <a name="dsxc_erase">       DSXC_ERASE  </a>-- Erase display (XWindows)

    a j penny                    ral         1990 jan
*/

dsxc_erase ()

/* C-- */
{
      int k;
      unsigned int udssnx, udssny;
      XImage *image;
      char kbya;
      char *ipd;
/* Cbegin */


      DSOPEN = F77_NAMED_COMMON(ds_genb).dsopen;
      DSSNX = F77_NAMED_COMMON(ds_gen).dssnx;
      DSSNY = F77_NAMED_COMMON(ds_gen).dssny;

      if (!DSOPEN) return;

      udssnx = DSSNX;
      udssny = DSSNY;
      kbya = BY_PC_ID[9+4];

      ipd = malloc (DSSNX*DSSNY);				/* Clear virtual screen */
      for ( k=0 ; k<(DSSNX*DSSNY) ; k++ ) {
         ipd[k] = kbya;		
         VT_IM[k] = kbya;
      }

      image = XCreateImage ( VD_ID, D_VISUAL, DEPTH, ZPixmap, 0,	/* Point to image */
                             ipd, udssnx, udssny, 8, DSSNX );
      XPutImage ( VD_ID, PIXMAP, GC_ID, image, 0, 0, 0, 0, udssnx,	/* Put image in pixmap */
                  udssny );
      XCopyArea ( VD_ID, PIXMAP, WD_ID, GC_ID, 0, 0, udssnx, udssny, 	/* Put pixmap area on screen */
                  0, 0 );
      XDestroyImage ( image );
      XFlush ( VD_ID );
      free (ipd);


}


/************************************************************
  <a name="dsxc_clear">  DSXC_CLEAR  </a>-- Clear screen (XWindows)

    a j penny                    ral         1990 jan
    patrick morris               leeds       1992 jan
*/

dsxc_clear (void)

/* C-- */
{
      int k;
      unsigned int udssnx, udssny;
      XImage  *image;
      char kbya;
      char *ipd;
/* Cbegin */


      DSSNX = F77_NAMED_COMMON(ds_gen).dssnx;
      DSSNY = F77_NAMED_COMMON(ds_gen).dssny;

      udssnx = DSSNX;
      udssny = DSSNY;
      kbya = BY_PC_ID[13];

      k = (DSSNX*DSSNY)+1;
      ipd = calloc( k, sizeof(char) );			/* Get workspace */
      if ( ipd == NULL ) {
         (void) c_printo ( "Error:Cant allocate memory in dsxc_clear" );
         return;
      }
      for ( k=0 ; k<DSSNX*DSSNY ; k++ )		/* Clear temp virtual screen */
          ipd[k] = kbya;

      image = XCreateImage ( VD_ID, D_VISUAL, DEPTH, ZPixmap, 0, 	/* Point to image */
                                     ipd, udssnx, udssny, 8, DSSNX );
      XPutImage ( VD_ID, PIXMAP, GC_ID, image, 0, 0, 0, 0, udssnx,	/* Put image in pixmap */
                  udssny );
      XCopyArea ( VD_ID, PIXMAP, WD_ID, GC_ID, 0, 0, udssnx, udssny, 	/* Put pixmap area on screen */
                  0, 0 );
      XDestroyImage ( image );
      XFlush ( VD_ID );
      free (ipd);



}

/***************************************************************
  <a name="dsxc_clearpix"> DSXC_CLEARPIX  </a>-- Clear pixmap (XWindows)

    a j penny                    ral         1990 jan
    patrick morris               leeds       1992 feb
*/

dsxc_clearpix (void)

/* C-- */
{
      int k;
      unsigned int udssnx, udssny;
      XImage *image;
      char kbya;
      char *ipd;
/* Cbegin */


      DSSNX = F77_NAMED_COMMON(ds_gen).dssnx;
      DSSNY = F77_NAMED_COMMON(ds_gen).dssny;

      udssnx = DSSNX;
      udssny = DSSNY;
      kbya = BY_PC_ID[13];

      k = (DSSNX*DSSNY)+1 ;
      ipd = calloc( k, sizeof(char) );		/* Get workspace */
      if ( ipd == NULL ) {
         (void) c_printo ( "Error:Cant allocate memory in dsxc_clearpix" );
         return;
      }
      for ( k=0 ; k<DSSNX*DSSNY ; k++ )		/* Clear temp virtual screen */
          ipd[k] = kbya;

      image = XCreateImage ( VD_ID, D_VISUAL, DEPTH, ZPixmap, 0,	/* Point to image */
                                     ipd, udssnx, udssny, 8, DSSNX );
      XPutImage ( VD_ID, PIXMAP, GC_ID, image, 0, 0, 0, 0, udssnx, 	/* Put image in pixmap */
                  udssny );
      XDestroyImage ( image );
      XFlush ( VD_ID );
      free (ipd);


}


/*********************************************************************
  <a name="dsxc_scur">       DSXC_SCUR  </a>-- Start the cursor (XWindows)

   alan penny                  ral                        1990-02-03
  pat morris             leeds        1992 jan
*/

dsxc_scur (void)

/* C-- */
{
      int  kxi, kyi, kxo, kyo, jxo, jyo;
      float xo, yo;
      Cursor cursor;
      Pixmap   cursor_pixmap;
      static unsigned char cursor_bits[32] = {
                              0x80, 0x00, 0x80, 0x00,
                              0x80, 0x00, 0x80, 0x00,
                              0x80, 0x00, 0x80, 0x00,
                              0x80, 0x00, 0x80, 0x00,
                              0xff, 0xff, 0x80, 0x00,
                              0x80, 0x00, 0x80, 0x00,
                              0x80, 0x00, 0x80, 0x00,
                              0x80, 0x00, 0x80, 0x00 } ;
      XColor cursor_dummy;
      XColor cursor_foreground;
      XColor cursor_background;
/* Cbegin */


      DSSNY = F77_NAMED_COMMON(ds_gen).dssny;
      DSNXS = F77_NAMED_COMMON(ds_gen).dsnxs;
      DSNXE = F77_NAMED_COMMON(ds_gen).dsnxe;
      DSNYS = F77_NAMED_COMMON(ds_gen).dsnys;
      DSNYE = F77_NAMED_COMMON(ds_gen).dsnye;

      cursor_pixmap = XCreatePixmapFromBitmapData ( VD_ID, RW_ID,
                                        cursor_bits, 16, 16, 1, 0, 1 );
      XLookupColor ( VD_ID, DefaultColormap(VD_ID, SC_ID),
                           "red", &cursor_dummy, &cursor_foreground );
      XLookupColor ( VD_ID, DefaultColormap(VD_ID, SC_ID),
                           "black", &cursor_dummy, &cursor_background );
      cursor = XCreatePixmapCursor ( VD_ID, cursor_pixmap, cursor_pixmap,
                               &cursor_foreground, &cursor_background, 7, 7 );
				/* Use same bitmap for shape and mask
   				 so cursor background is transparent */

      XDefineCursor ( VD_ID, WD_ID, cursor );
      XFreePixmap ( VD_ID, cursor_pixmap );

      kxi = (DSNXS+DSNXE)/2;				/*Set pointer position*/
      kyi = (DSNYS+DSNYE)/2;

      (void) vtc_tis ( kxi, kyi, &kxo, &kyo );

      jxo = kxo - 1;
      jyo = DSSNY - kyo;
      XWarpPointer ( VD_ID, None, WD_ID,  0, 0, 0, 0, jxo, jyo );
      XFlush ( VD_ID );

      xo = kxo;
      yo = kyo;

      DSCURPOSX = xo;
      DSCURPOSY = yo;
      DSSCUR = True;

      F77_NAMED_COMMON(ds_gen).dscurposx = xo;
      F77_NAMED_COMMON(ds_gen).dscurposy = yo;
      F77_NAMED_COMMON(ds_genb).dsscur = F77_TRUE;

}


/**********************************************************************
  <a name="dsxc_pcur">       DSXC_PCUR  </a>-- Put the cursor at position (XWindows)

   alan penny                  ral                        1990-02-03
  pat morris             leeds        1992 jan
*/

dsxc_pcur ( kx, ky )

    int   kx;		/*i: X position to put cursor at */
    int   ky;		/*i: Y position to put cursor at */

/* C-- */
{
      int  kxo, kyo, jxo, jyo;
      float     xo, yo;
/* Cbegin */


      DSOPEN = F77_NAMED_COMMON(ds_genb).dsopen;
      DSSCUR = F77_NAMED_COMMON(ds_genb).dsscur;
      DSSNY = F77_NAMED_COMMON(ds_gen).dssny;

      if (!DSOPEN) return;
      if (!DSSCUR) (void) dsxc_scur ();

      (void) vtc_tis ( kx, ky, &kxo, &kyo );
      xo = kxo;
      yo = kyo;

      jxo = kxo - 1;
      jyo = DSSNY - kyo;
      XWarpPointer ( VD_ID, None, WD_ID,  0, 0, 0, 0, jxo, jyo );

      XFlush ( VD_ID );

      DSCURPOSX = xo;
      DSCURPOSY = yo;
      DSCURSET = True;

      F77_NAMED_COMMON(ds_gen).dscurposx = xo;
      F77_NAMED_COMMON(ds_gen).dscurposy = yo;
      F77_NAMED_COMMON(ds_genb).dscurset = F77_TRUE;

}


/**********************************************************************
  <a name="dsxc_pscur"> DSXC_PSCUR  </a>-- Put the cursor at screen position (XWindows)

   alan penny                  ral                        1990-02-03
  pat morris             leeds        1992 jan
*/

dsxc_pscur ( x, y )

    float      x;		/* i: X position to put cursor at */
    float      y;		/* i: Y position to put cursor at */

/* C-- */
{
      int kx, ky;
/* Cbegin */


      DSOPEN = F77_NAMED_COMMON(ds_genb).dsopen;
      DSSCUR = F77_NAMED_COMMON(ds_genb).dsscur;
      DSSNY = F77_NAMED_COMMON(ds_gen).dssny;

      if (!DSOPEN) return;
      if (!DSSCUR) (void) dsxc_scur ();

      kx = x - 1;
      ky = DSSNY - y;
      XWarpPointer ( VD_ID, None, WD_ID,  0, 0, 0, 0, kx, ky );

      XFlush ( VD_ID );

      DSCURPOSX = x;
      DSCURPOSY = y;
      DSCURSET = True;

      F77_NAMED_COMMON(ds_gen).dscurposx = x;
      F77_NAMED_COMMON(ds_gen).dscurposy = y;
      F77_NAMED_COMMON(ds_genb).dscurset = F77_TRUE;


}



/*******************************************************************
  <a name="dsxc_getcurpb"> DSXC_GETCURPB  </a>-- Get cursor posn and button state (XWindows)

   alan penny                  ral                        1990-02-03
   pat morris             leeds        1992 jan
*/

dsxc_getcurpb ( isimage, kx, ky, kb, ierr )

Bool   isimage;          /* i: Image (T) or panel (F) ? */
int    *kx;              /* o: Cursor X position (start at 1,1) */
int    *ky;              /* o: Cursor Y position (start at 1,1) */
int    kb[];             /* o: Cursor Button states (0=up;1=down) */
int    *ierr;            /* o: Error flag ( 0=ok; 1=bad) */
/* C-- */
{
      int n, kwx, kwy, jkx, jky;
      Window win, root, child;
      XEvent event;
      XWindowAttributes  xwattr;                /* Window Attributes */
      unsigned int kbstat;
      Bool istat, loop;
/* Cbegin */


      DSSNY = F77_NAMED_COMMON(ds_gen).dssny;
      PNSNY = F77_NAMED_COMMON(ds_panel).pnsny;
      NUMXBUTTONS = F77_NAMED_COMMON(ds_gen).numxbuttons;

      *ierr = 0;

      if ( isimage )
         win = WD_ID;
      else
         win = WD_P_ID;

      XGetWindowAttributes ( VD_ID, win, & xwattr );
      if ( xwattr.map_state != IsViewable ) {
         *kx = 0 ;
         *ky = 0 ;
         kb[0] = 0 ;
         kb[1] = 0 ;
         kb[2] = 0 ;
         return;
      }

      istat = XQueryPointer ( VD_ID, win, &root, &child, &kwx, &kwy,
                              &jkx, &jky, &kbstat );
      XFlush ( VD_ID );

      jkx = jkx + 1;
      if ( isimage )
         jky = DSSNY - jky;
      else
         jky = PNSNY - jky;

      *kx = jkx;
      *ky = jky;
      if ( istat!=1 ) *ierr = 1;

      kb[0] = (kbstat-512*(kbstat/512))/256;
      kb[1] = (kbstat-1024*(kbstat/1024))/512;
      kb[2] = (kbstat-2048*(kbstat/2048))/1024;

      if ( *ierr == 0 && NUMXBUTTONS==2 && kb[1]==1 ) {
         (void) dsxc_mswait ( 400 );
         istat = XQueryPointer ( VD_ID, win, &root, &child, &kwx, &kwy,
                                 &jkx, &jky, &kbstat );
         XFlush ( VD_ID );

         jkx = jkx + 1;
         if ( isimage )
             jky = DSSNY - jky;
         else
             jky = PNSNY - jky;

         *kx = jkx;
         *ky = jky;
         if ( istat!=1 ) *ierr = 1;

         kb[0] = (kbstat-512*(kbstat/512))/256;
         kb[1] = (kbstat-1204*(kbstat/1024))/512;

         if ( kb[0]==1 && kb[1]==1 ) {
            kb[0] = 0;
            kb[1] = 0;
            kb[2] = 1;
         }
      }


}


/***********************************************************
  <a name="dsxc_waitbut"> DSXC_WAITBUT  </a>-- Wait for button to be pressed or to be up (Xwindows)

   alan penny                  ral                        1990-02-03
  pat morris             leeds        1992 jan
*/


dsxc_waitbut ( isimage, down, kbut, kpx, kpy )

Bool  isimage;          /* i: Looking in the image (T) or panel (F)? */
Bool  down;		/* i: Flag to wait till button pressed
			    (True) or all up (False) */
int   *kbut;		/* o: Which button pressed */
int   *kpx;		/* o: X screen position */
int   *kpy;		/* o: Y screen position */
/* C-- */
{
      int kb[3], istat, kpxa, kpya;
      Bool loop;
/* Cbegin */


      loop = True;
      while ( loop ) {
         (void) dsxc_mswait ( 20 );
         (void) dsxc_getcurpb ( isimage, &kpxa, &kpya, kb, &istat );

         if ( istat == 0 ) {
           if ( down ) {
              if ( (kb[0]==1) || (kb[1]==1) || (kb[2]==1) ) loop = False;
              if ( kb[0]==1 ) *kbut = 1;
              if ( kb[1]==1 ) *kbut = 2;
              if ( kb[2]==1 ) *kbut = 3;
           }
           else {
              *kbut = 0 ;
              if ( (kb[0]==0) && (kb[1]==0) && (kb[2]==0) ) loop= False;
           }
         }
      }

      *kpx = kpxa;
      *kpy = kpya;

}

/**************************************************************
  <a name="dsxc_putim">   DSXC_PUTIM  </a>-- Put an image (XWindows)

    alan penny           ral                       1990-02-01
  pat morris             leeds        1992 jan
*/

void dsxc_putim ( data, kx, ky, ksxs, ksys )

    char  *data;		/* i: Input data */
    int   kx;			/* i: X size of data */
    int   ky;			/* i: Y size of data */
    int   ksxs;			/* i: X screen start of data position */
    int   ksys;			/* i: Y screen start of data position */

/* C-- */
{
      int k, jkx, jky;
      unsigned int ukx, uky;
      XImage *image;
      char *ipd;
/* Cbegin */


      DSSNY = F77_NAMED_COMMON(ds_gen).dssny;
      ukx = kx;
      uky = ky;

      ipd = malloc (kx*ky);
      for ( k=0;k<kx*ky;k++ )
          ipd[k] = data[k];

      image = XCreateImage ( VD_ID, D_VISUAL, DEPTH, ZPixmap, 0, ipd,	/* Point to image */
                             ukx, uky, 8, kx );
      XFlush ( VD_ID );

      jkx = ksxs - 1;
      jky = DSSNY - (ky-1) - ksys;
      XPutImage ( VD_ID, PIXMAP, GC_ID, image, 0, 0, jkx, jky, ukx, uky ); 	/* Put image in pixmap */
      XCopyArea ( VD_ID, PIXMAP, WD_ID, GC_ID, jkx, jky, ukx, uky, jkx, jky );	/* Put pixmap area on screen */
      XDestroyImage ( image );
      XFlush ( VD_ID );
      free ( ipd);


}


/************************************************************************
  <a name="dsxc_paintova">    DSXC_PAINTOVA  </a>-- Paint moving oval  at X/Y normals - erase last (Xwindows)

  alan penny             ral             1990 Jan
  pat morris             leeds        1992 jan
*/

dsxc_paintova ( pxo, pyo, rxo, ryo, px, py, rx1, ry1, kc1, rx2, ry2, kc2 )

    float   pxo;	/* i: Old screen X posn */
    float   pyo;	/* i: Old screen Y posn */
    float   rxo;	/* i: Old max X oval radius (image scale) */
    float   ryo;	/* i: Old max Y oval radius (image scale) */
    float   px;		/* i: New screen X posn */
    float   py;		/* i: New screen Y posn */
    float   rx1;	/* i: Inner X oval radius (image scale) */
    float   ry1;	/* i: Inner Y oval radius (image scale) */
    int     kc1;	/* i: Inner oval colour (1-8) */
    float   rx2[];	/* i: Inner/outer annular X oval radii */
    float   ry2[];	/* i: Inner/outer annular Y oval radii */
    int     kc2;	/* i: Outer oval colour (1-8) */

/* C-- */
{
      int      kvxs, kvxe, kvys, kvye, kvx, kvy, kpxo, kpyo,
               jx, jy, jxs, jys, jxe, jye;
      unsigned int  krx, kry;
      float    rx, ry, pxi, pyi;
/* Cbegin */



      DSSNY = F77_NAMED_COMMON(ds_gen).dssny;
      DSZM = F77_NAMED_COMMON(ds_gen).dszm;
      DSCOMFX = F77_NAMED_COMMON(ds_gen).dscomfx;
      DSCOMFY = F77_NAMED_COMMON(ds_gen).dscomfy;

      kpxo = pxo;
      kpyo = pyo;
      (void) vtc_tsv ( kpxo, kpyo, &kvx, &kvy ); 			/* Get old image pos */

      kvxs = kvx - (int) ((rxo/DSCOMFX)+6.0);				/* Restore old area */
      kvxe = kvxs + (int) ((2.0*rxo/DSCOMFX)+12.0);
      kvys = kvy - (int) ((ryo/DSCOMFY)+6.0);
      kvye = kvys + (int) ((2.0*ryo/DSCOMFY)+12.0);
      (void) dsxc_vtim ( kvxs, kvxe, kvys, kvye, 0 );

      if ( kc1!=-1 ) {							/* Paint new oval */
         pxi = px + (DSZM/2);
         pyi = py + (DSZM/2);
         (void) dsxc_setthecol ( kc1 );

         rx = (float) (DSZM) * rx1/ (float) (DSCOMFX);
         ry = (float) (DSZM) * ry1/ (float) (DSCOMFY);
         krx = 2.0*rx;
         kry = 2.0*ry;
         jx = pxi - rx - 1;
         jy = DSSNY - pyi - ry;
         XDrawArc ( VD_ID, WD_ID, GC_ID, jx, jy, krx, kry, 0, 64*360 );
      }

      if ( kc2!=-1 ) {							/* Paint new oval */
         pxi = px + (DSZM/2);
         pyi = py + (DSZM/2);
         (void) dsxc_setthecol ( kc2 );

         rx = (float) (DSZM) * rx2[0]/ (float) (DSCOMFX);
         ry = (float) (DSZM) * ry2[0]/ (float) (DSCOMFY);
         krx = 2.0*rx;
         kry = 2.0*ry;
         jx = pxi - rx - 1;
         jy = DSSNY - pyi - ry;
         XDrawArc ( VD_ID, WD_ID, GC_ID, jx, jy, krx, kry, 0, 64*360 );

         rx = (float) (DSZM)* rx2[1]/(float) (DSCOMFX);
         ry = (float) (DSZM)* ry2[1]/(float) (DSCOMFY);
         krx = 2.0*rx;
         kry = 2.0*ry;
         jx = pxi - rx - 1;
         jy = DSSNY - pyi - ry;
         XDrawArc ( VD_ID, WD_ID, GC_ID, jx, jy, krx, kry, 0, 64*360 );

         XFlush ( VD_ID );
      }

}


/************************************************************************
  <a name="dsxc_paintovb">    DSXC_PAINTOVB  </a>-- Paint moving oval (XY) - erase last (Xwindows)

  alan penny             ral             1990 Jan
  pat morris             leeds        1992 jan
*/

dsxc_paintovb ( kcx, kcy, kc1, kc2, pxo, pyo, rxo, ryo )


    int     kcx[];	/* i: Centre/Inner/Outer oval X posns (image scale) */
    int     kcy[];	/* i: Centre/Inner/Outer oval Y posns (image scale) */
    int     kc1;	/* i: Inner oval colour (1-8) */
    int     kc2;	/* i: Outer oval colour (1-8) */
    float   pxo;        /* i: Old screen X posn */
    float   pyo;        /* i: Old screen Y posn */
    float   rxo;	/* i: Old max X oval radius (image scale) */
    float   ryo;	/* i: Old max Y oval radius (image scale) */

/* C-- */
{
      int      kvxs, kvxe, kvys, kvye, kvx, kvy, kpxo, kpyo,
               kpxi, kpyi, k;
      XPoint   theline[185];
/* Cbegin */


      kpxo = pxo;
      kpyo = pyo;
      (void) vtc_tsv ( kpxo, kpyo, &kvx, &kvy ); 			/* Get old image pos */

      kvxs = kvx - (int) ((rxo/DSCOMFX)+6.0);				/* Restore old area */
      kvxe = kvxs + (int) ((2.0*rxo/DSCOMFX)+12.0);
      kvys = kvy - (int) ((ryo/DSCOMFY)+6.0);
      kvye = kvys + (int) ((2.0*ryo/DSCOMFY)+12.0);
      (void) dsxc_vtim ( kvxs, kvxe, kvys, kvye, 0 );
      XFlush ( VD_ID );
	
      if ( kc1!=-1 ) {							/* Paint new oval */
         (void) dsxc_setthecol ( kc1 );
         for ( k=0; k<=180; k++ ) {
            theline[k].x = kcx[k];
            theline[k].y = DSSNY - kcy[k];
         }
         XDrawLines ( VD_ID, WD_ID, GC_ID, theline, 181, CoordModeOrigin );
         XFlush ( VD_ID );
      }

      if ( kc2!=-1 ) {							/* Paint new oval */
         (void) dsxc_setthecol ( kc2 );

         for ( k=0; k<=180; k++ ) {
            theline[k].x = kcx[181+k];
            theline[k].y = DSSNY - kcy[181+k];
         }
         XDrawLines ( VD_ID, WD_ID, GC_ID, theline, 181, CoordModeOrigin );
         for ( k=0; k<=180; k++ ) {
            theline[k].x = kcx[362+k];
            theline[k].y = DSSNY - kcy[362+k];
         }
         XDrawLines ( VD_ID, WD_ID, GC_ID, theline, 181, CoordModeOrigin );

         XFlush ( VD_ID );
      }


}


/********************************************************************
  <a name="dsxc_oval">    DSXC_OVAL  </a>-- Paint an oval (XWindows)

    alan penny           ral                       1990-02-01
  pat morris             leeds        1992 jan
*/

dsxc_oval ( xp, yp, radx, rangle, elli, kc )

    float     xp;		/* i: Image X position */
    float     yp;		/* i: Image Y position */
    float     radx;		/* i: Image pixel X radius */
    float     rangle;		/* i: Oval angle to X-axis */
    float     elli;		/* i: Oval ellipticity */
    int       kc;		/* i: Colour (1=red;2=green;3=blue;4=yellow;
				           5=cyan;6=mauve;7=tan;8=pink)
				           9=black;10=white) */
/* C-- */
{
      float angle;
      int k;
/* Cbegin */


      DSZM = F77_NAMED_COMMON(ds_gen).dszm;

      if ( radx<=0.0 || elli<0.0 || elli>1.0 ) return ;

      angle = rangle;
      if ( rangle<0.0 ) angle = -1.0*rangle;
      k = angle/180.0;
      angle = angle - 180.0*(float)k;
      if ( angle>90.0 ) angle = angle - 180.0;
      if ( rangle<0.0 ) angle = -1.0*angle;

      (void) dsxc_setthecol ( kc );

      if ( angle==0.0 || angle==90.0 || angle==-90.0 || elli==0.0 ) {
         (void) dsxc_ovala ( xp, yp, radx, angle, elli, kc );
      } else {
         (void) dsxc_ovalb ( xp, yp, radx, angle, elli, kc );
      }


}


/********************************************************************
  <a name="dsxc_ovala">    DSXC_OVALA  </a>-- Paint an oval at X/Y normals (XWindows)

    alan penny           ral                       1990-02-01
  pat morris             leeds        1992 jan
*/

dsxc_ovala ( xp, yp, radx, angle, elli, kc )

    float     xp;		/* i: Image X position */
    float     yp;		/* i: Image Y position */
    float     radx;		/* i: Image pixel X radius */
    float     angle;		/* i: Oval angle to X-axis */
    float     elli;		/* i: Oval ellipticity */
    int       kc;		/* i: Colour (1=red;2=green;3=blue;4=yellow;
				           5=cyan;6=mauve;7=tan;8=pink)
				           9=black;10=white) */
/* C-- */
{
      float rx, ry, da, rxx, ryy, dx1, dy1, rx1, ry1, tt, sdx[5], sdy[5];
      int j, k, nxv, nyv, kkcol, kp, jx, jy, krv, krva, ivx, ivy,
          kvx, kvy, kxp, kyp, kpx, kpy, kpxi, kpyi, krx, kry, ns;
/* Cbegin */


      DSSNX = F77_NAMED_COMMON(ds_gen).dssnx;
      DSSNY = F77_NAMED_COMMON(ds_gen).dssny;
      DSZM = F77_NAMED_COMMON(ds_gen).dszm;
      DSCOMFX = F77_NAMED_COMMON(ds_gen).dscomfx;
      DSCOMFY = F77_NAMED_COMMON(ds_gen).dscomfy;

      kxp = xp;
      kyp = yp;
      (void) vtc_tis ( kxp, kyp, &kpx, &kpy );				/* Get screen pos, rad */
      kpx = kpx + (DSZM/2);
      kpy = kpy + (DSZM/2);

      if ( angle==0.0 ) {
         rx = radx;
         ry = radx*(1.0-elli);
      } else if ( elli==0.0) {
         rx = radx;
         ry = radx;
      } else {
         rx = radx*(1.0-elli);
         ry = radx;
      }
      rx = (float) (DSZM)*(rx)/(float) (DSCOMFX);
      ry = (float) (DSZM)*(ry)/(float) (DSCOMFY);

      krx = rx;								/* Paint oval */
      kry = ry;
      jx = kpx - rx - 1;
      jy = DSSNY - kpy - ry;
      XDrawArc ( VD_ID, WD_ID, GC_ID, jx, jy, 2*krx, 2*kry, 0, 64*360 );

      (void) vtc_tsv ( kpx, kpy, &kvx, &kvy );				/*Put oval in virtual memory */
      ivx = kpx + (int) rx;
      ivy = kpy + (int) ry;
      (void) vtc_tsv ( ivx, ivy, &krv, &krva );
      rx1 = krv - kvx;
      ry1 = krva - kvy;

      (void) dsxc_scolnum ( kc, &kkcol );

      if ( radx<=0.0 ) {
         nxv = kvx;
         nyv = kvy;
         kp = nxv + (DSSNY-nyv)*DSSNX;
         if ( (nxv>=1) && (nxv<=DSSNX) && (nyv>=1) && (nyv<=DSSNY) ) {
            VT_IM[kp-1] = (char) kkcol;
         }
      } else {
         nxv = kvx + rx1;
         nyv = kvy;
         kp = nxv + (DSSNY-nyv)*DSSNX;
         if ( (nxv>=1) && (nxv<=DSSNX) && (nyv>=1) && (nyv<=DSSNY) ) {
            VT_IM[kp-1] = (char) kkcol;
         }

         sdx[1] = 1.0;
         sdx[2] = 1.0;
         sdx[3] = -1.0;
         sdx[4] = -1.0;
         sdy[1] = 1.0;
         sdy[2] = -1.0;
         sdy[3] = -1.0;
         sdy[4] = 1.0;

         da = 0.3/rx1;
         ns = 3.14159/(2.0*da);
         ns = imin(90,ns);
         da = (3.14159/2.0)/(float) (ns);
         rxx = 1.0/(rx1*rx1);
         ryy = 1.0/(ry1*ry1);
         for ( j=1; j<=4; j++ ) {
            for ( k = 1; k<=ns+1 ; k++ ) {
               tt = tan(da*(float)(k));
               tt = tt*tt;
               dx1 = sqrt(1.0/(rxx+(tt*ryy)));
               dy1 = sqrt(1.0/(ryy+(rxx/tt)));
               nxv = kvx + sdx[j]*dx1;
               nyv = kvy + sdy[j]*dy1;
               kp = nxv + (DSSNY-nyv)*DSSNX;
               if ( (nxv>=1) && (nxv<=DSSNX) && (nyv>=1) && (nyv<=DSSNY) ){
                  VT_IM[kp-1] = (char) kkcol;
               }
            }
         }
      }

      XFlush ( VD_ID );

}


/********************************************************************
  <a name="dsxc_ovalb">    DSXC_OVALB  </a>-- Paint an oval at an angle (XWindows)

    alan penny           ral                       1990-02-01
  pat morris             leeds        1992 jan
*/

dsxc_ovalb ( xp, yp, radx, angle, elli, kc )

    float     xp;		/* i: Image X position */
    float     yp;		/* i: Image Y position */
    float     radx;		/* i: Image pixel X radius */
    float     angle;		/* i: Oval angle to X-axis */
    float     elli;		/* i: Oval ellipticity */
    int       kc;		/* i: Colour (1=red;2=green;3=blue;4=yellow;
				           5=cyan;6=mauve;7=tan;8=pink)
				           9=black;10=white) */
/* C-- */
{
      float ry, sav, cav, ryy, trv, ttrv, dx, dy, rv, afx, afy, ax1, ax2,
            ay1, ay2, dfx, dfy, dax[48], day[48], sdx[5], sdy[5],
            f1, f2, f3, f4;
      int   k, kk, kkcol, kp, ka, kcx[185], kcy[185], kcxa[185], kcya[185],
            kpx, kpy, kxp, kyp, nxv, nyv, nxva, nyva;
      XPoint  theline[185];
/* Cbegin */


      DSSNX = F77_NAMED_COMMON(ds_gen).dssnx;
      DSSNY = F77_NAMED_COMMON(ds_gen).dssny;
      DSZM = F77_NAMED_COMMON(ds_gen).dszm;
      DSZPX = F77_NAMED_COMMON(ds_gen).dszpx;
      DSZPY = F77_NAMED_COMMON(ds_gen).dszpy;
      DSCOMFX = F77_NAMED_COMMON(ds_gen).dscomfx;
      DSCOMFY = F77_NAMED_COMMON(ds_gen).dscomfy;

      kxp = xp;
      kyp = yp;
      (void) vtc_tis ( kxp, kyp, &kpx, &kpy );				/* Get screen pos, rad */
      kpx = kpx + (DSZM/2);
      kpy = kpy + (DSZM/2);

      sav = -1.0*sin(angle*3.14159/180.0);
      cav = cos(angle*3.14159/180.0);

      sdx[1] = 1.0;
      sdx[2] = 1.0;
      sdx[3] = -1.0;
      sdx[4] = -1.0;
      sdy[1] = 1.0;
      sdy[2] = -1.0;
      sdy[3] = -1.0;
      sdy[4] = 1.0;

      ry = 1.0 - elli;
      ry = fmin(1.0,fmax(1.0e-6,ry));
      ryy = 1.0/(ry*ry);
      for ( k=1; k<=45; k++ ) {
         rv = ((float)(k-1))*2.0*3.14159/180.0;
         trv = tan(rv);
         ttrv = trv*trv;

         if ( trv>-1.0e-5 && trv<1.0e-5) {
            dax[k] = 0.0;
            day[k] = ry;
         } else if ( trv>1.0e5 || trv<-1.0e5 ) {
            dax[k] = 1.0;
            day[k] = 0.0;
         } else {
            dax[k] = sqrt(1.0/(1.0+(ryy/ttrv)));
            day[k] = sqrt(1.0/(ryy+(1.0*ttrv)));
         }
      }

      afx = (float)DSZM/(float)DSCOMFX;
      afy = (float)DSZM/(float)DSCOMFY;
      dfx = kpx;
      dfy = kpy;

      ax1 = (float) DSZPX;
      ax2 = (float) DSZM;
      ay1 = (float) DSZPY;
      ay2 = (float) DSZM;

      for ( kk=1; kk<=4; kk++ ) {
         ka = (kk-1)*45 - 1;
         f1 = cav*radx*sdx[kk];
         f2 = sav*radx*sdy[kk];
         f3 = -1.0*sav*radx*sdx[kk];
         f4 = cav*radx*sdy[kk];
         for ( k=1; k<=45; k++ ) {
            if ( kk==2 || kk==4 ) {
               dx = f1*dax[46-k] + f2*day[46-k];
               dy = f3*dax[46-k] + f4*day[46-k];
            } else {
               dx = f1*dax[k] + f2*day[k];
               dy = f3*dax[k] + f4*day[k];
            }
            kcx[k+ka] = dx*afx + dfx;
            kcy[k+ka] = dy*afy + dfy;
            kcxa[k+ka] = ax1 + (float) (kcx[k+ka]-1)/ax2;
            kcya[k+ka] = ay1 + (float) (kcy[k+ka]-1)/ay2;
         }
      }
      kcxa[180] = kcxa[0];
      kcya[180] = kcya[0];
      kcx[180] = kcx[0];
      kcy[180] = kcy[0];

      for ( k=0; k<=180; k++ ) {
         theline[k].x = kcx[k];
         theline[k].y = DSSNY - kcy[k];
      }
      XDrawLines ( VD_ID, WD_ID, GC_ID, theline, 181, CoordModeOrigin );

      (void) dsxc_scolnum ( kc, &kkcol );				/* Put in virtual image */

      for ( k = 0; k<=180 ; k++ ) {
         nxv = kcxa[k];
         nyv = kcya[k];
         if ( (nxv>=1) && (nxv<=DSSNX) && (nyv>=1) && (nyv<=DSSNY) ) {
            kp = nxv + (DSSNY-nyv)*DSSNX;
            VT_IM[kp-1] = (char) kkcol;
         }
      }

      XFlush ( VD_ID );

}


/********************************************************************
  <a name="dsxc_osize">    DSXC_OSIZE  </a>-- X, Y size of tilted oval

    alan penny           ral                       1994
*/

dsxc_osize ( rad, ang, ell, xs, ys )

    float     rad;		/* i: Major axis size */
    float     ang;		/* i: Angle to x-axis in degrees */
    float     ell;		/* i: Ellipticity */
    float     *xs;		/* o: X size (total) */
    float     *ys;		/* o: Y size (total) */

/* C-- */
{
/* Cbegin */


      *xs = 2.0*rad;
      *ys = 2.0*rad;


}


/****************************************************************
  <a name="dsxc_cross">   DSXC_CROSS  </a>-- Put a cross at a position (XWindows)

  alan penny             ral             1990 Jan
  pat morris             leeds        1992 jan
*/

dsxc_cross ( x, y, crs, kc )

    float      x;		/* i: X position(image pixels) */
    float      y;		/* i: Y position (image pixels) */
    float      crs;		/* i: Cross size (end-to-end) (image pixels) */
    int        kc;		/* i: Colour (1=red;2=green;3=blue;4=yellow;
					      5=cyan;6=mauve;7=tan;8=pink)
					      9=black;10=white) */
/* C-- */
{
      int iv, jx, jxs, jxe, jy, jys, jye, k, kxa, kxb, kya, kyb,
          kkcol, kjs, kje, kx, ky, kpx, kpy, kdx, kdy;
/* Cbegin */


      DSSNX = F77_NAMED_COMMON(ds_gen).dssnx;
      DSSNY = F77_NAMED_COMMON(ds_gen).dssny;
      DSZM = F77_NAMED_COMMON(ds_gen).dszm;

      (void) dsxc_setthecol ( kc );

      kx = x;
      ky = y;
      (void) vtc_tis ( kx, ky, &kpx, &kpy );				/* Get screen position*/
      kpx = kpx + (DSZM/2);
      kpy = kpy + (DSZM/2);
      kdx = (float) (DSZM)*(crs/2.0);
      kdy = (float) (DSZM)*(crs/2.0);

      jxs = kpx - kdx - 1;						/* Paint cross  */
      jxe = kpx + kdx - 1;
      jy = DSSNY - kpy;
      XDrawLine ( VD_ID, WD_ID, GC_ID, jxs, jy, jxe, jy );
      XDrawLine ( VD_ID, PIXMAP, GC_ID,	jxs, jy, jxe, jy );
      jx = kpx - 1;
      jys = DSSNY - (kpy-kdy);
      jye = DSSNY - (kpy+kdy);
      XDrawLine ( VD_ID, WD_ID, GC_ID, jx, jye, jx, jys );
      XDrawLine ( VD_ID, PIXMAP, GC_ID, jx, jye, jx, jys );
      XFlush ( VD_ID );

      iv = kpx - kdx;
      (void) vtc_tsv ( iv, kpy, &kxa, &kya );				/*Put in virtual image*/
      iv = kpx + kdx;
      (void) vtc_tsv ( iv, kpy, &kxb, &kya );

      (void) dsxc_scolnum ( kc, &kkcol );

      if( (kxa<=DSSNX) && (kxb>=1) && (kya>=1) && (kya<=DSSNY) ) {
         kxa = imin(DSSNX,imax(1,kxa));
         kxb = imin(DSSNX,imax(1,kxb));
         kya = imin(DSSNY,imax(1,kya));
         kjs = kxa + (DSSNY-kya)*DSSNX;
         kje = kjs + kxb - kxa ;
         for ( k = kjs; k<=kje ; k++ )
            VT_IM[k-1] = (char) kkcol;
      }

      iv = kpy - kdy;
      (void) vtc_tsv ( kpx, iv, &kxa, &kya );
      iv = kpy + kdy;
      (void) vtc_tsv ( kpx, iv, &kxa, &kyb );
      if( (kxa<=DSSNX) && (kxb>=1) && (kya>=1) && (kya<=DSSNY) ) {
         kxa = imin(DSSNX,imax(1,kxa));
         kya = imin(DSSNY,imax(1,kya));
         kyb = imin(DSSNY,imax(1,kyb));
         kje = (DSSNY-kya)*DSSNX + kxa;
         kjs = (DSSNY-kyb)*DSSNX + kxa;
         for ( k = kjs; k<=kje; k += DSSNX )
            VT_IM[k-1] = (char) kkcol;
      }


}


/**********************************************************************
  <a name="dsxc_scolnum"> DSXC_SCOLNUM  </a>-- Calc colour pixel number from colour number (XWindows)

  alan penny             ral             1990 May
  pat morris             leeds        1992 jan
*/

dsxc_scolnum ( kc, kkcol )

    int   kc;		/* i: Colour number */
    int   *kkcol;	/* o: Display colour pixel number */

/* C-- */
{
/* Cbegin */


      switch (kc) {
         case 9 :  *kkcol = BY_PC_ID[10];
                   break;
         case 10 : *kkcol = BY_PC_ID[14];
                   break;
         default : *kkcol = BY_PC_ID[1+imin(8,imax(0,kc))];
      }


}


/**********************************************************************
 D<a name="sxc_line"> SXC_LINE  </a>-- Put a line at a position (XWindows)

  alan penny             ral             1990 May
  pat morris             leeds        1992 jan
*/

dsxc_line ( xs, ys, xe, ye, kc )

    float   xs;		/* i: Line start X position(image pixels) */
    float   ys;		/* i: Line start Y position (image pixels) */
    float   xe;		/* i: Line end X position(image pixels) */
    float   ye;		/* i: Line end Y position (image pixels) */
    int     kc;		/* i: Colour (1=red;2=green;3=blue;4=yellow;
			              5=cyan;6=mauve;7=tan;8=pink)
			              9=black;10=white) */

/* C-- */
{
      float ds, axc, ayc, dx, dy, ax, ay;
      int k, kxa, kxb, kya, kyb, kkcol, kx, ky, kn, kp,
          kjs, kje, kt, kxs, kys, kpxs, kpys, kxe, kye, kpxe, kpye,
          jxs, jxe, jys, jye;
/* Cbegin */


      DSSNX = F77_NAMED_COMMON(ds_gen).dssnx;
      DSSNY = F77_NAMED_COMMON(ds_gen).dssny;
      DSZM = F77_NAMED_COMMON(ds_gen).dszm;

      (void) dsxc_setthecol ( kc );

      kxs = xs;
      kys = ys;
      (void) vtc_tis ( kxs, kys, &kpxs, &kpys );				/*Get screen position*/
      kxe = xe;
      kye = ye;
      (void) vtc_tis ( kxe, kye, &kpxe, &kpye );				/*Get screen position*/

      kpxs = kpxs + (DSZM/2);
      kpys = kpys + (DSZM/2);

      kpxe = kpxe + (DSZM/2);
      kpye = kpye + (DSZM/2);

      jxs = kpxs - 1;
      jxe = kpxe - 1;
      jys = DSSNY - kpys;
      jye = DSSNY - kpye;
      XDrawLine ( VD_ID,  WD_ID, GC_ID, jxs, jys, jxe, jye );			/* Paint line */
      XDrawLine ( VD_ID, PIXMAP, GC_ID, jxs, jys, jxe, jye );
      XFlush ( VD_ID );

      (void) vtc_tsv ( kpxs, kpys, &kxa, &kya );				/* Put in virtual image */
      (void) vtc_tsv ( kpxe, kpye, &kxb, &kyb );

      (void) dsxc_scolnum ( kc, &kkcol );

      if ( kxa==kxb ) {
         if ( (kxa>=1) && (kxa<=DSSNX) ) {
            kxa = imin(DSSNX,imax(1,kxa));
            kjs  = kxa + (DSSNY-kya)*DSSNX;
            kje  = kxa + (DSSNY-kyb)*DSSNX;
            if ( kjs>kje ) {
               kt = kjs;
               kjs = kje;
               kje = kt;
            }
            if ( (kjs<=MAXVIRT) && (kje>=1) ) {
               kjs = imax(1,imin(MAXVIRT,kjs));
               kje = imax(1,imin(MAXVIRT,kje));
               for ( k = kjs; k<=kje; k+=DSSNX )
                  VT_IM[k-1] = (char) kkcol;
            }
         }
      }
      else if ( kya==kyb ) {
         if ( (kya>=1) && (kya<=DSSNY) ) {
            kya = imin(DSSNY,imax(1,kya));
            if ( kxa>kxb ) {
               kt = kxa;
               kxa = kxb;
               kxb = kxa;
            }
            if ( (kxa<=DSSNX) && (kya>=1) ) {
               kxa = imin(DSSNX,imax(1,kxa));
               kxb = imin(DSSNX,imax(1,kxb));
               kjs  = kxa + (DSSNY-kya)*DSSNX;
               kje  = kxb + (DSSNY-kya)*DSSNX;
               for ( k = kjs; k<=kje; k++ )
                  VT_IM[k-1] = (char) kkcol;
            }
         }
      }
      else {
         dx = kxb - kxa;
         dy = kyb - kya;
         ds = sqrt(dx*dx+dy*dy);
         axc = dx/ds;
         ayc = dy/ds;
         ax = (float) (kxa) - 0.25;
         ay = (float) (kya) - 0.25;
         kn = ds*4.0;
         for ( k = 1; k<=kn; k++ ) {
            ax = ax + 0.25*axc;
            ay = ay + 0.25*ayc;
            kx = ax;
            ky = ay;
            if ( (kx>=1) && (kx<=DSSNX) && (ky>=1) && (ky<=DSSNY) ) {
               kp = kx + (DSSNY-ky)*DSSNX;
               VT_IM[kp-1] = (char) kkcol;
            }
         }
      }


}



/************************************************************************
  <a name="dsxc_setthecol">   DSXC_SETTHECOL  </a>-- Set writing colour (Xwindows)

  alan penny           ral                         1990-06-09
  pat morris             leeds        1992 jan
*/

dsxc_setthecol ( kc )

    int  kc;		/* i: Colour (1=red;2=green;3=blue;4=yellow;
				           5=cyan;6=mauve;7=tan;8=pink;
				           9=black;10=white) */

/* C-- */
{
      int kkcol;
/* Cbegin */


      (void) dsxc_scolnum ( kc, &kkcol );

      XSetForeground ( VD_ID, GC_ID, kkcol );
      XFlush ( VD_ID );


}


/****************************************************************************
  <a name="dsxc_updown">   DSXC_UPDOWN  </a>-- Raise' or 'lower' a window (Xwindows)

  alan penny           ral                         1990-06-09
  pat morris             leeds        1992 jan
*/

dsxc_updown ( kf )

    int     kf;			/* i: raise=1; lower=2 */

/* C-- */
{
/* Cbegin */


      DSOPEN = F77_NAMED_COMMON(ds_genb).dsopen;

      if (!DSOPEN) return;

      if ( kf==1 ) {
         XRaiseWindow ( VD_ID, WD_ID );
         XFlush ( VD_ID );
      }
      else {
         XLowerWindow ( VD_ID, WD_ID );
         XFlush ( VD_ID );
      }


}



/********************************************************************************
  <a name="dsxc_acimr">  DSXC_ACIMR  </a>-- Display part of an actual real image (loads virtual image) (X window)

  alan penny                  ral         1990 jan
*/
      dsxc_acimr ( im, mx, my, ixs, ixe, iys, iye, ix, iy, wrap )

      int       mx;		/* i: Actual image X size */
      int       my;		/* i: Actual image Y size */
      float     im[];		/* i: Actual image  */
      int       ixs;		/* i: Actual image area X start */
      int       ixe;		/* i: Actual image area X end */
      int       iys;		/* i: Actual image area Y start */
      int       iye;		/* i: Actual image area Y end */
      int       ix;		/* i: Position in virtual image of X start */
      int       iy;		/* i: Position in virtual image of Y start */
      Bool      wrap;		/* i: Flag to wrap values round display limits */
/* C--*/
{
      int     iv, j, jj, ja, jx, jy, k, ka, kxoff, kyoff, kvxs,
              kvxe, kvys, kvye, knv, kas, kbs, kcs, nxs, nxe, nys, nye;
      float   zero, delta, rv, rva;
      char    byteim[2048];
/* Cbegin */


      DSSNX = F77_NAMED_COMMON(ds_gen).dssnx;
      DSSNY = F77_NAMED_COMMON(ds_gen).dssny;
      DSZM = F77_NAMED_COMMON(ds_gen).dszm;
      DSCOMFX = F77_NAMED_COMMON(ds_gen).dscomfx;
      DSCOMFY = F77_NAMED_COMMON(ds_gen).dscomfy;
      DSVMIN = F77_NAMED_COMMON(ds_gen).dsvmin;
      DSVMAX = F77_NAMED_COMMON(ds_gen).dsvmax;
      RINVAL = F77_NAMED_COMMON(imagecoma).rinval;

      if ( ixs>mx || ixe<1 || iys>my || iye<1 ) return;			/* Check in image */

      nxs = imax(1,ixs);						/* Check all in image */
      nxe = imin(mx,ixe);
      nys = imax(1,iys);
      nye = imin(my,iye);

      jx = 1 + (((nxe-nxs+1)-1)/DSCOMFX);
      jy = 1 + (((nye-nys+1)-1)/DSCOMFY);

      kvxs = ix;
      kvxe = ix + jx - 1;
      kvys = iy;
      kvye = iy + jy - 1;

      if ( kvxs>DSSNX || kvys>DSSNY || kvxe<1 || kvye<1 ) return;	/* Check any in virtual screen */

      kxoff = 0;
      kyoff = 0;
      if ( kvxs<1 ) kxoff = 1 - kvxs;
      if ( kvys<1 ) kyoff = 1 - kvys;

      kvxs = imax(1,kvxs);
      kvxe = imin(DSSNX,kvxe);
      kvys = imax(1,kvys);
      kvye = imin(DSSNY,kvye);

      rv = DSVMAX - DSVMIN;
      if ( rv==0.0 ) rv = 1.0;
      delta = (float) (NUMDCOL-1)/rv;					/* Set up display factors */
      zero = -1.0*DSVMIN*delta;

      knv = kvxe - kvxs + 1;

      ka = nys + kyoff;							/* Load in virtual image */
      for ( k=kvys; k<=kvye; k++ ) {

         ja = nxs + kxoff;
         for ( j=kvxs; j<=kvxe; j++ ) {

            rv = im[ja-1+(ka-1)*mx];
            ja = ja + DSCOMFX;
            if ( rv==RINVAL ) {
               byteim[j-1] = BY_PC_ID[15+NUMDCOL];
            }else{
               rva = rv*delta + zero;
               rva = fmin(1.0e6,fmax(-1.0e6,rva));
               jj = (int)rva;
               if ( wrap ) {
                  jj = jj % (NUMDCOL-1);
                  if ( jj<0 ) jj = jj + NUMDCOL;
                  iv = 16 + jj;
               }else{
                  iv = 16 + imax(0,imin(jj,(NUMDCOL-1)));
               }
               byteim[j-1] = BY_PC_ID[iv];
            }
         }
         ka = ka + DSCOMFY;

         for ( kas=0; kas<knv; kas++ ) {
            kbs = kvxs + (DSSNY-k)*DSSNX - 1;
            kcs = kvxs - 1;
            VT_IM[kbs+kas] = byteim[kcs+kas];
         }

      }

      dsxc_vtim ( kvxs, kvxe, kvys, kvye, 0 );		/* Display section of virtual image */


}



/********************************************************************************
  <a name="dsxc_acims">  DSXC_ACIMS  </a>-- Display part of an actual short image (loads virtual image) (X window)

  alan penny                  ral         1990 jan
*/
      dsxc_acims ( im, mx, my, ixs, ixe, iys, iye, ix, iy, wrap )

      int       mx;		/* i: Actual image X size */
      int       my;		/* i: Actual image Y size */
      short int im[];		/* i: Actual image  */
      int       ixs;		/* i: Actual image area X start */
      int       ixe;		/* i: Actual image area X end */
      int       iys;		/* i: Actual image area Y start */
      int       iye;		/* i: Actual image area Y end */
      int       ix;		/* i: Position in virtual image of X start */
      int       iy;		/* i: Position in virtual image of Y start */
      Bool      wrap;		/* i: Flag to wrap values round display limits */
/* C--*/
{
      int   iv, j, ja, jj, jx, jy, kk, k, ka, kv, kxoff, kyoff, kvxs,
            kvxe, kvys, kvye, knv, kas, kbs, kcs, nxs, nxe, nys, nye;
      float zero, delta, rv, rva;
      char  byteim[2048];
/* Cbegin */


      DSSNX = F77_NAMED_COMMON(ds_gen).dssnx;
      DSSNY = F77_NAMED_COMMON(ds_gen).dssny;
      DSZM = F77_NAMED_COMMON(ds_gen).dszm;
      DSCOMFX = F77_NAMED_COMMON(ds_gen).dscomfx;
      DSCOMFY = F77_NAMED_COMMON(ds_gen).dscomfy;
      DSVMIN = F77_NAMED_COMMON(ds_gen).dsvmin;
      DSVMAX = F77_NAMED_COMMON(ds_gen).dsvmax;
      INVAL = F77_NAMED_COMMON(imagecoma).inval;

      if ( ixs>mx || ixe<1 || iys>my || iye<1 ) return;			/* Check in image */

      nxs = imax(1,ixs);						/* Check all in image */
      nxe = imin(mx,ixe);
      nys = imax(1,iys);
      nye = imin(my,iye);

      jx = 1 + (((nxe-nxs+1)-1)/DSCOMFX);
      jy = 1 + (((nye-nys+1)-1)/DSCOMFY);

      kvxs = ix;
      kvxe = ix + jx - 1;
      kvys = iy;
      kvye = iy + jy - 1;

      if ( kvxs>DSSNX || kvys>DSSNY || kvxe<1 || kvye<1 ) return;	/* Check any in virtual screen */

      kxoff = 0;
      kyoff = 0;
      if ( kvxs<1 ) kxoff = 1 - kvxs;
      if ( kvys<1 ) kyoff = 1 - kvys;

      kvxs = imax(1,kvxs);
      kvxe = imin(DSSNX,kvxe);
      kvys = imax(1,kvys);
      kvye = imin(DSSNY,kvye);

      rv = DSVMAX - DSVMIN;
      if ( rv==0.0 ) rv = 1.0;
      delta = (float) (NUMDCOL-1)/rv;					/* Set up display factors */
      zero = -1.0*DSVMIN*delta;

      knv = kvxe - kvxs + 1;

      ka = nys + kyoff;							/* Load in virtual image */
      for ( k=kvys; k<=kvye; k++ ) {

         ja = nxs + kxoff;
         for ( j=kvxs; j<=kvxe; j++ ) {
            kv = (int) im[ja-1+(ka-1)*mx];
            ja = ja + DSCOMFX;
            if ( kv==INVAL ) {
               byteim[j-1] = BY_PC_ID[15+NUMDCOL];
            }else{
               rva = (float) kv*delta + zero;
               rva = fmin(1.0e6,fmax(-1.0e6,rva));
               jj = (int) rva;
               if ( wrap ) {
                  jj = jj % (NUMDCOL-1);
                  if ( jj<0 ) jj = jj + NUMDCOL;
                  iv = 16 + jj;
               }else{
                  iv = 16 + imax(0,imin(jj,(NUMDCOL-1)));
               }
               byteim[j-1] = BY_PC_ID[iv];
            }
         }
         ka = ka + DSCOMFY;

         for ( kas=0; kas<knv; kas++ ) {
            kbs = kvxs + (DSSNY-k)*DSSNX - 1;
            kcs = kvxs - 1;
            VT_IM[kbs+kas] = byteim[kcs+kas];
         }
      }

      dsxc_vtim ( kvxs, kvxe, kvys, kvye, 0 );		/* Display section of virtual image */


}



/********************************************************************************
IMIN

*/
int imin ( int f1, int f2 )
{
     int smaller;
     if ( f1 < f2 )
        smaller = f1;
     else
        smaller = f2;
     return smaller ;
}
/********************************************************************************
IMAX

*/
int imax ( int f1, int f2 )
{
     int bigger;
     if ( f1 > f2 )
        bigger = f1;
     else
        bigger = f2;
     return bigger ;
}
/********************************************************************************
FMIN

*/
float fmin ( float f1, float f2 )
{
     float smaller;
     if ( f1 < f2 )
        smaller = f1;
     else
        smaller = f2;
     return smaller ;
}
/********************************************************************************
FMAX

*/
float fmax ( float f1, float f2 )
{
     float bigger;
     if ( f1 > f2 )
        bigger = f1;
     else
        bigger = f2;
     return bigger ;
}


/****************************************************************************
 D<a name="sxc_mswait"> SXC_MSWAIT  </a>-- Wait X millisecs  (Xwindows)

  Authors: Alan Penny  (RAL)              2 Mar 1993  Convert to Starman
*/

   dsxc_mswait ( msecs )

    int     msecs;			/* i: no of milliseconds to wait */
/* C-- */
{
/* Cbegin */


    (void) dsxc_unix_mswait ( msecs );

}

/****************************************************************************
 D<a name="sxc_unix_mswait"> SXC_UNIX_MSWAIT  </a>-- Wait X millisecs  (Xwindows)
     This function causes the program to go to sleep for a given number of
     milliseconds. This function in needed to provides sub-second sleep
     intervals as the standard C function, sleep, has a resolution of 1 second.

  Notes:
     -  If a negative time interval is given, the routine returns immediately.
     -  The resolution of the timer on the Sun is 10ms.
     -  The resolution of the timer on the DECstation is 3.906ms.
     -  All actual sleep times will be in units of the timer resolution and
        will be rounded up. E.g. a request to sleep for 15ms on a Sun will
        result in an actual sleep time of 20ms.

  Copyright: Copyright (C) 1992 Science & Engineering Research Council

  Authors: PMA: Peter Allan (Starlink, RAL)   18 Jun 1992  Original
                 Alan Penny  (RAL)              2 Mar 1993  Convert to Starman
*/

   dsxc_unix_mswait ( msecs )

    int     msecs;			/* i: no of milliseconds to wait */
/* C-- */
{
    struct timeval time_struct;    /* The time structure to give to select.  */
    int ret;                       /* The return code from select.           */
    fd_set ia, ib, ic;
/* Cbegin */


    if ( msecs <= 0 ) return;					/* Check for a positive time interval.  */

    if ( msecs < 1000 ) {  					/* Set up the time structure, allowing */
       time_struct.tv_sec = 0; 					/* for times longer than 1 second.     */
       time_struct.tv_usec = msecs * 1000;
    } else {
       time_struct.tv_sec = msecs / 1000;
       time_struct.tv_usec = ( msecs % 1000 ) * 1000;
    }

    FD_ZERO (&ia); FD_ZERO (&ib); FD_ZERO (&ic);
    ret = select ( 0, &ia, &ib, &ic, &time_struct );	  	/* Call select with null file descriptor sets */
								/* to give the effect of going   */
								/* to sleep for a given time.  */


}

/**********************************************************************
   DSX_LUTC.C
-
 Contains:-
-
 DSX_LUTCOL    Set up color Look-up table for image display - FORTRAN interface (Xwindows)
 DSX_LUTROT    Rotate color Look-up table for image display - FORTRAN interface (Xwindows)
 DSX_LUTPAI    Paint a color in the LUT for image display - FORTRAN interface (XWindows)
 DSX_LUTSCA    Scale, shift color Look-up table for image display - FORTRAN interface (Xwindows)
 DSX_LUTBAR    Load/clear display of Look-up Table bar - FORTRAN interface (Xwindows)
 DSX_LUTPUT    Put a LUT into operation for image display - FORTRAN interface (Xwindows)

 DSXC_LUTCOL     Set up color Look-up table for image display (XWindows)
 DSXC_LUTACOL    Set up color Look-up table for image display (XWindows)
 DSXC_LUTROT     Rotate color Look-up table for image display (XWindows)
 DSXC_LUTSCA     Scale, shift color Look-up table for image display (XWindows)
 DSXC_LUTPAI     Paint a color in the LUT for image display (XWindows)
 DSXC_LUTPUT     Put a LUT into operation for image display (XWindows)
 DSXC_LUTBAR     Load/clear display of Look-up Table bar
 DSXC_LUTBARL    Load 'background' of LUT bar
 DSXC_LUTTRAN    Translate bar posn to LUT posn
 DSXC_LUTLOAD    Load LUT into working LUT
 DSXC_LUTVGET    Copy 'LUT.INC' Fortran variables over in this C
 DSXC_LUTVPUT    Copy 'LUT.H' C variables over into Fortran vserionC
*/


#include <stdlib.h>
#include <math.h>

#include <X11/Xlib.h>
#include <X11/Xos.h>

#include "f77.h"
#include "cnf.h"

#include "malloc.h"

#include "ds_gen.h"
#include "ds_panel.h"
#include "ds_lut.h"
#include "dsx_lut.h"
#include "lut.h"

/* Exterbal F77 routines */

extern void F77_EXTERNAL_NAME(ds_lutacol) ( );

/* External C routines */

extern void vtc_tsv ( int, int, int*, int* );
extern void c_printo ( char* );
extern void dsxc_pscur ( float, float );
extern void dsxc_waitbut ( Bool, Bool, int*, int*, int* );
extern void dsxc_getcurpb ( Bool, int*, int*, int[], int* );
extern void dsxc_putim ( char*, int, int, int, int );
extern int imax ( int, int );
extern int imin ( int, int );
extern float fmax ( float, float );
extern float fmin ( float, float );

char   TEXTAA[200];
/*
  (void) sprintf ( TEXTAA, " F1XXX %d %d %d %d %d ",
                          PDSOPEN, DSNXS, DSNXE, DSNYS, DSNYE );
   (void) c_printo ( TEXTAA );
*/

/***********************************************************************
  <a name="dsx_lutcol"> DSX_LUTCOL  </a>-- Set up color Look-up table for image display - FORTRAN interface (Xwindows)

    alan penny                ral              1993 Aug
*/

F77_SUBROUTINE(dsx_lutcol) (void)

/* C-- */
{
/* Cbegin */

       (void) dsxc_lutcol ( );

}


/***********************************************************************
  <a name="dsx_lutrot"> DSX_LUTROT  </a>-- Rotate color Look-up table for image display - FORTRAN interface (Xwindows)

    alan penny                ral              1993 Aug
*/

F77_SUBROUTINE(dsx_lutrot) (void)

/* C-- */
{
/* Cbegin */

       (void) dsxc_lutrot ( );

}


/***********************************************************************
  <a name="dsx_lutpai"> DSX_LUTPAI  </a>-- Paint a color in the LUT for image display (FORTRAN interface) (XWindows)

    alan penny                ral              1993 Aug
*/

F77_SUBROUTINE(dsx_lutpai) (void)

/* C-- */
{
/* Cbegin */

       (void) dsxc_lutpai ( );

}


/***********************************************************************
  <a name="dsx_lutsca"> DSX_LUTSCA  </a>-- Scale, shift color Look-up table for image display - FORTRAN interface (Xwindows)

    alan penny                ral              1993 Aug
*/

F77_SUBROUTINE(dsx_lutsca) (void)

/* C-- */
{
/* Cbegin */

       (void) dsxc_lutsca ( );

}


/***********************************************************************
  <a name="dsx_lutbar"> DSX_LUTBAR  </a>-- Load/clear display of Look-up Table bar - FORTRAN interface (Xwindows)

    alan penny                ral              1993 Aug
*/

F77_SUBROUTINE(dsx_lutbar) ( INTEGER(kopt) )

    GENPTR_INTEGER(kopt)         /* i: Option Flag 1=load; 0= clear */
/* C-- */
{
      int ka;
/* Cbegin */

      ka = *kopt;
      (void) dsxc_lutbar ( ka );

}


/***********************************************************************
  <a name="dsx_lutput"> DSX_LUTPUT  </a>-- Put a LUT into operation for image display - FORTRAN interface (Xwindows)

    alan penny                ral              1993 Aug
*/

F77_SUBROUTINE(dsx_lutput) (void)

/* C-- */
{
/* Cbegin */

       (void) dsxc_lutput ( );

}



/***************************************************************************
 D<a name="sxc_lutcol"> SXC_LUTCOL  </a>-- Set up color Look-up table for image display (XWindows)

   alan penny                  ral                        1990-02-03
   pat morris                  leeds                      1992 feb
*/

dsxc_lutcol (void)

/* C-- */
{
      int   k, ka, kdiv;
      Status istat;
      unsigned short int c;
      char flags;
/* Cbegin */


      DSOPEN = F77_NAMED_COMMON(ds_genb).dsopen;
      PDSOPEN = F77_NAMED_COMMON(ds_panelb).pdsopen;
      NUMDDCOL = F77_NAMED_COMMON(lutacom).numddcol;

      flags = DoRed | DoGreen | DoBlue;

      if ( DSOPEN || PDSOPEN ) {

         (void) dsxc_lutvget();

         if ( OWNCOL ) {

            kdiv = LVX/NUMDDCOL;
            for ( k = 15; k<15+LVX; k++ ) {
               ka = 15 + ((k-15)/kdiv);
               COLOUR[ka].pixel = PC_ID[ka];
               COLOUR[ka].flags = flags;
               c = LUTC_VAL[(k-15)][0]*65535.0;
               COLOUR[ka].red = c;
               c = LUTC_VAL[(k-15)][1]*65535.0;
               COLOUR[ka].green = c;
               c = LUTC_VAL[(k-15)][2]*65535.0;
               COLOUR[ka].blue = c;
            }

            XStoreColors ( VD_ID, CM_ID, COLOUR, 15+NUMDDCOL );
            XInstallColormap ( VD_ID, CM_ID );
            XFlush ( VD_ID );

         }
         else {

            for (k = 15; k<15+LVX; k++ ) {
               COLOUR[k].flags = flags;
               c = LUTC_VAL[(k-15)][0]*65535.0;
               COLOUR[k].red = c;
               c = LUTC_VAL[(k-15)][1]*65535.0;
               COLOUR[k].green = c;
               c = LUTC_VAL[(k-15)][2]*65535.0;
               COLOUR[k].blue = c;
               istat = XAllocColor ( VD_ID, CM_ID, &COLOUR[k] );
               if ( istat==0 ) {
                  (void) c_printo ( "ERROR,x_lut: Colour pixel not allocated" );
                  PC_ID[k] = 0;
               }
               else
                  PC_ID[k] = COLOUR[k].pixel;
            }
            XFlush ( VD_ID );

         }

      }

}



/***************************************************************************
 D<a name="sxc_lutacol"> SXC_LUTACOL  </a>-- Set up color Look-up table for image display (XWindows)

   alan penny                  ral                        1990-02-03
   pat morris                  leeds                      1992 feb
*/

dsxc_lutacol (void)

/* C-- */
{
/* Cbegin */

      (void) F77_CALL(ds_lutacol) ( );

}

/*****************************************************************
 D<a name="sxc_lutrot"> SXC_LUTROT  </a>-- Rotate color Look-up table for image display (XWindows)

   alan penny                  ral                        1990-02-03
   pat morris                  leeds                      1992 feb
*/

dsxc_lutrot (void)

/* C-- */
{
      float rot, ta[LVX], rv;
      int j, k, kd, istat, kb[3], kbut, ja, kpx, kpy, kpxa, kpya, kdpx;
      Bool loop;
/* Cbegin */


      DSSNX = F77_NAMED_COMMON(ds_gen).dssnx;

      rv = (float) (DSSNX)/2.0;
      (void) dsxc_pscur ( rv, 10.0 );					/*Set cursor at bar*/

      (void) dsxc_lutvget();

      (void) dsxc_waitbut ( True, False, &kbut, &kpxa, &kpya );		/*Buttons up?*/

      loop = True;
      while ( loop ) {
         (void) dsxc_waitbut ( True, True, &kbut, &kpxa, &kpya );		/*Button pressed?*/
         if ( kpxa>=0 && kpxa<DSSNX && kpya>=0 && kpya<DSSNY ) loop = False;
      }

      loop = True;
      while ( loop ) {

         (void) dsxc_mswait ( 50 );
         (void) dsxc_getcurpb ( True, &kpx, &kpy, kb, &istat );

         kbut = 0;
         if ( istat==0 ) {
            if ( (kb[0]==1) || (kb[1]==1) || (kb[2]==1) ) {
               if ( kb[0]==1 ) kbut = 1;
               if ( kb[1]==1 ) kbut = 2;
               if ( kb[2]==1 ) kbut = 3;
            }
         }

         kdpx = kpx - kpxa ;
         if ( kbut==3 )
            loop = False;
         else if ( kbut==0 )
            kpxa = kpx;
         else if ( kpx>=0 && kpx<DSSNX && kdpx!=0 ) {
            kpxa = kpx;
            rot = (float) (kdpx)/( LUTC_SC * (float) DSSNX );
            kd = rot * (float) LVX;
            for ( k = 0; k<=2 ;k++ ) {
               for ( j=0 ; j<LVX; j++ ) {
                  ja = j - kd;
                  if ( ja<0 ) ja += LVX;
                  if ( ja>=LVX ) ja = ja % (LVX-1);
                  ta[j] = LUTC_VAL[ja][k];
               }
               for ( j=0 ; j<LVX ; j++ )
                  LUTC_VAL[j][k] = ta[j] ;
            }
            (void) dsxc_lutvput();
            (void) dsxc_lutput ();
         }

      }


      DSCURPOSX = kpx;						/*Store cursor screen posn*/
      DSCURPOSY = kpy;
      DSCURSET = True;

      F77_NAMED_COMMON(ds_gen).dscurposx = kpx;
      F77_NAMED_COMMON(ds_gen).dscurposy = kpy;
      F77_NAMED_COMMON(ds_genb).dscurset = F77_TRUE;


}

/***************************************************************************
 D<a name="sxc_lutsca"> SXC_LUTSCA  </a>-- Scale, shift color Look-up table for image display (XWindows)

   alan penny                  ral                        1990-02-03
   pat morris                  leeds                      1992 feb
*/

dsxc_lutsca (void)

/* C-- */
{
      float rv;
      int istat, kb[3], kbut, kpx, kpy, kpxa, kpya, kdpx, kdpy;
      Bool loop;
/* Cbegin */


      DSSNX = F77_NAMED_COMMON(ds_gen).dssnx;
      DSSNY = F77_NAMED_COMMON(ds_gen).dssny;
      (void) dsxc_lutvget();

      rv = DSSNX/2;
      (void) dsxc_pscur ( rv, 10.0 );						/*Set cursor on bar*/

      (void) dsxc_waitbut ( True, False, &kbut, &kpxa, &kpya );			/*Buttons up?*/

      loop = True;
      while ( loop ) {
         (void) dsxc_waitbut ( True, True, &kbut, &kpxa, &kpya );		/*Button pressed?*/
         if ( kpxa>=0 && kpxa<DSSNX && kpya>=0 && kpya<DSSNY ) loop = False;
      }
      loop = True;
      while ( loop ) {

         (void) dsxc_mswait ( 50 );
         (void) dsxc_getcurpb ( True, &kpx, &kpy, kb, &istat );

         kbut = 0;
         if ( istat==0 ) {
            if ( (kb[0]==1) || (kb[1]==1) || (kb[2]==1) ) {
               if ( kb[0]==1 ) kbut = 1;
               if ( kb[1]==1 ) kbut = 2;
               if ( kb[2]==1 ) kbut = 3;
            }
         }

         kdpx = kpx - kpxa;
         kdpy = kpy - kpya;

         if ( kbut==3 )
            loop = False;
         else if ( kbut==0 ) {
            kpxa = kpx;
            kpya = kpy;
         } else {
            if ( kpx>=0 && kpx<DSSNX && kpy>=0 && kpy<DSSNY ) {
               if ( kdpx!=0 ) {
                  kpxa = kpx;
                  LUTC_ZE = LUTC_ZE + (float) (kdpx)/ (float) (DSSNX);
               }
               if ( abs(kdpy)>=1 ) {
                  kpya = kpy;
                  rv = LUTC_SC * (1.0+( (float) (kdpy)/ (float) (DSSNY)));
                  LUTC_ZE = LUTC_ZE + (LUTC_SC - rv) * ((float) (kpx)/(float) (DSSNX));
                  LUTC_SC = rv;
               }
               if ( abs(kdpx)>=1 || abs(kdpy)>=1 ) {
                  F77_NAMED_COMMON(lutacom).lut_sc = LUTC_SC;
                  F77_NAMED_COMMON(lutacom).lut_ze = LUTC_ZE;
                  (void) dsxc_lutput ();
              }
            }
         }

      }

      DSCURSET = True;					/*Store cursor screen posn*/
      DSCURPOSX = kpx;
      DSCURPOSY = kpy;

      F77_NAMED_COMMON(ds_gen).dscurposx = kpx;
      F77_NAMED_COMMON(ds_gen).dscurposy = kpy;
      F77_NAMED_COMMON(ds_genb).dscurset = F77_TRUE;


}

/************************************************************************
  <a name="dsxc_lutpai"> DSXC_LUTPAI  </a>-- Paint a color in the LUT for image display (XWindows)

   alan penny                  ral                        1990-02-03
   pat morris                  leeds                      1992 feb
*/

dsxc_lutpai (void)

/* C-- */
{
      float  col[3], acol[3], rv;
      int    j, istat, kb[3], kpx, kpy, kbut, js, je,
             kxss, kxse, kpxa;
      Bool   loop, loopmain;
/* Cbegin */


      DSSNX = F77_NAMED_COMMON(ds_gen).dssnx;

      kxss = 0;
      kxse = DSSNX;
      if ( DSSNX>260 ) {
         kxss = (DSSNX-260)/2;
         kxse = kxss + 260 - 1;
      }

      rv = DSSNX / 2.0;
      (void) dsxc_pscur ( rv, 10.0 );					/* Set cursor at bar centre */

      (void) dsxc_waitbut ( True, False, &kbut, &kpx, &kpy );		/* Buttons up in area? */

      loopmain = True;						/* Loop repeating sequence */
      while ( loopmain ) {

         (void) dsxc_waitbut ( True, True, &kbut, &kpx, &kpy );

         if ( kbut==3 )					/* Exit if button 3 */
            loopmain = False;
         else if ( (kpx<kxss) || (kpx>kxse) )
            (void) c_printo ( "Must be within LUT bar" );
         else {
            rv = (float) (kpx-kxss)/(float) (kxse-kxss+1);
            (void) dsxc_luttran ( rv, col, &je );

            (void) dsxc_waitbut ( True, False, &kbut, &kpx, &kpy );	/* Buttons up in area? */

            (void) dsxc_waitbut ( True, True, &kbut, &kpx, &kpy );	/* Buttons pressed in area? */
            kpx = imin(kxse,imax(kxss,kpx));
            rv = (float) (kpx-kxss)/(float) (kxse-kxss+1);
            kpxa = kpx;
            (void) dsxc_luttran ( rv, acol, &js );

            loop = True;
            while ( loop ) {
               (void) dsxc_getcurpb ( True, &kpx, &kpy, kb, &istat );
               kpx = imin(kxse,imax(kxss,kpx));
               if ( istat==0 ) {
                  if ( (kb[0]==0) && (kb[1]==0) && (kb[2]==0) )
                     loop = False;
               }
               if ( loop && (istat==0) && (kpx>kpxa) ) {
                  rv = (float) (kpx-kxss)/(float) (kxse-kxss+1);
                  (void) dsxc_luttran ( rv, acol, &je );
                  if ( je<js ) {
                     for (j = js-1; j<LVX; j++ ) {
                        LUTC_VAL[j][0] = col[0];
                        LUTC_VAL[j][1] = col[1];
                        LUTC_VAL[j][2] = col[2];
                     }
                     for (j = 0; j<je; j++ ) {
                        LUTC_VAL[j][0] = col[0];
                        LUTC_VAL[j][1] = col[1];
                        LUTC_VAL[j][2] = col[2];
                     }
                  }
                  else {
                     for (j = js-1; j<je; j++ ) {
                        LUTC_VAL[j][0] = col[0];
                        LUTC_VAL[j][1] = col[1];
                        LUTC_VAL[j][2] = col[2];
                     }
                  }
                  (void) dsxc_lutvput();
                  (void) dsxc_lutput ();
               }
            }

         }

      }

      (void) dsxc_lutvput();

      DSCURPOSX = kpx;						/*Store cursor screen posn*/
      DSCURPOSY = kpy;
      DSCURSET = True;

      F77_NAMED_COMMON(ds_gen).dscurposx = kpx;
      F77_NAMED_COMMON(ds_gen).dscurposy = kpy;
      F77_NAMED_COMMON(ds_genb).dscurset = F77_TRUE;


}


/******************************************************************************
 D<a name="sxc_lutput"> SXC_LUTPUT  </a>-- Put a LUT into operation for image display (XWindows)

   alan penny                  ral                        1990-02-03
   pat morris                  leeds                      1992 feb
*/

dsxc_lutput (void)

/* C-- */
{
      float tcol[LVX*3];
      int   k, istat, ka, kdiv;

      char  flags;
      unsigned short int j;
/* Cbegin */


      DSOPEN = F77_NAMED_COMMON(ds_genb).dsopen;
      PDSOPEN = F77_NAMED_COMMON(ds_panelb).pdsopen;
      NUMDDCOL = F77_NAMED_COMMON(lutacom).numddcol;

      (void) dsxc_lutload ( tcol );	 			/* Load LUT into working LUT */

      flags = DoRed | DoGreen | DoBlue;

      if ( DSOPEN || PDSOPEN ) {

         if ( OWNCOL ) {

            kdiv = LVX/NUMDDCOL;
            for ( k = 15; k<15+LVX; k++ ) {
               ka = 15 + ((k-15)/kdiv);
               COLOUR[ka].pixel = PC_ID[ka];
               COLOUR[ka].flags = flags;
               j = tcol[3*(k-15)+0]*65535.0;
               COLOUR[ka].red = j;
               j = tcol[3*(k-15)+1]*65535.0;
               COLOUR[ka].green = j;
               j = tcol[3*(k-15)+2]*65535.0;
               COLOUR[ka].blue = j;
            }

            XStoreColors ( VD_ID, CM_ID, COLOUR, 15+NUMDDCOL );
            XInstallColormap ( VD_ID, CM_ID );
            XFlush ( VD_ID );
         }
         else {

            for ( k = 15; k < 15+LVX; k++ ) {
               COLOUR[k].flags = flags;
               j = tcol[3*(k-15)+0]*65535.0;
               COLOUR[k].red = j;
               j = tcol[3*(k-15)+1]*65535.0;
               COLOUR[k].green = j;
               j = tcol[3*(k-15)+2]*65535.0;
               COLOUR[k].blue = j;
               istat = XAllocColor ( VD_ID, CM_ID, &COLOUR[k] );
               if ( istat==0 ) {
                  (void) c_printo ( "ERROR: Colour pixel not allocated" );
                  PC_ID[k] = 0 ;
               }
               else
                  PC_ID[k] = COLOUR[k].pixel;
            }
            XFlush ( VD_ID );

         }

      }


}

/*********************************************************************
  <a name="dsxc_lutbar"> DSXC_LUTBAR  </a>-- Load/clear display of Look-up Table bar (XWindows)

   alan penny                        ral              1990-01-31
   pat morris                        leeds            1992 feb
*/

dsxc_lutbar ( kopt )

   int kopt;		/* i: Option Flag 1=load; 0= clear */

/* C-- */
{
      int     kxss, kxse, kyss, kyse, kxvs, kxve, kyvs, kyve,
               i, j, kxcs, kxce, kycs, kyce, ncx, ncy,
               kx, ky, kxos, kyos, kyoe, iv;
      float   rva;
      char    byteim[2048], xdu, xdd, *ip, *tip;
/* Cbegin */


      DSSNX = F77_NAMED_COMMON(ds_gen).dssnx;
      DSSNY = F77_NAMED_COMMON(ds_gen).dssny;

      xdu = BY_PC_ID[14];
      xdd = BY_PC_ID[10];

      kxss = 0;
      kxse = DSSNX-1;
      if ( DSSNX>260 ) {
         kxss = (DSSNX-260)/2;
         kxse = kxss + 260 - 1;
      }
      kyss = 0;
      kyse = 17;
      kx = kxse - kxss + 1;
      ky = kyse - kyss + 1;
      kxcs = kxss + 2;
      kxce = kxse - 2;
      kycs = kyss + 2;
      kyce = kyse - 2;
      ncx = kxce - kxcs + 1;
      ncy = kyce - kycs + 1;

      if ( kopt==1 ) {
         ip = calloc ( kx*ky+1, sizeof(char) );
         (void) dsxc_lutbarl ( ip, kx, ky, xdu, xdd );
         if ( (ncx>1) && (ncy>0) ) {
            for ( j = 0; j<ncx; j++ ) {
               rva = (float) j*(float) (LVX-1)/((float) (ncx-1));
               rva = fmax(-1.0e6,rva);
               rva = fmin(1.0e6,rva);
               iv = 15 + (int) rva;
               byteim[j] = BY_PC_ID[iv];
            }
            kxos = kxcs - kxss + 1;
            kyos = kycs - kyss + 1;
            kyoe = kyos + ncy - 1;
            for ( j = kyos; j<=kyoe; j++ ) {
               for ( i = 0; i<ncx; i++ ) {
                  ip[kxos+i+j*kx] = byteim[i];
               }
            }
         }
         (void) dsxc_putim ( ip, kx, ky, kxss, kyss );
         free ( ip );
      }

      if ( kopt==0 ) {
         kyse = kyse + 3;
         vtc_tsv ( kxss, kyss, &kxvs, &kyvs );
         vtc_tsv ( kxse, kyse, &kxve, &kyve );
         kxvs = imax(0,imin(DSSNX,(kxvs-1)));
         kxve = imax(0,imin(DSSNX,(kxve+1)));
         kyvs = imax(0,imin(DSSNY,(kyvs-1)));
         kyve = imax(0,imin(DSSNY,(kyve+1)));
         (void) dsxc_vtim ( kxvs, kxve, kyvs, kyve, 0 );
      }


}


/****************************************************************
  <a name="dsxc_lutbarl"> DSXC_LUTBARL  </a>-- Load 'background' of LUT bar

    alan penny           ral                       1990-02-01
*/

dsxc_lutbarl ( im, kx, ky, xdu, xdd )

      char       im[];		/* o: Colour bar */
      int        kx;		/* i: X size of bar */
      int        ky;		/* i: Y size of bar */
      char       xdu;		/* i: Up colour code */
      char       xdd;		/* i: Down colour code */

/* C-- */
{
      int  j, ja, jb, k, ka, kb, lx, ly;
/* Cbegin */


      lx = imax(2,(kx/10));
      ly = imax(2,(ky/3));

      for ( k=0; k<=kx*ky-1; k++ ){
         im[k] = xdd;
      }

      for ( k=1; k<=ky; k=k+2*ly ){
         for ( ka=1; ka<=ly; ka++ ){
            kb = k + ka - 1;
            if ( kb<=ky ) {
               for ( j=1; j<=kx; j=j+2*lx ){
                  for ( ja=1; ja<=lx; ja++ ){
                     jb = j + ja - 1;
                     if ( jb<=kx ) im[(jb-1)+(kb-1)*kx] = xdu;
                  }
               }
               if ( jb<kx ) {
                  for ( j=jb; j<=kx; j++ ){
                     im[(j-1)+(kb-1)*kx] = xdu;
                  }
               }
            }
         }
      }

      if ( kb<ky ) {
         for ( k=kb; k<=ky; k++ ) {
            for ( j=1; j<=kx; j=j+2*lx ) {
               for ( ja=1; j<=lx; ja++ ) {
                  jb = j + ja - 1;
                  if ( jb<=kx ) im[(jb-1)+(k-1)*kx] = xdu ;
               }
            }
         }
      }


}


/******************************************************************
 D<a name="sxc_luttran"> SXC_LUTTRAN  </a>-- Translate bar posn to LUT posn

   alan penny                  ral                        1990-02-03
*/

dsxc_luttran ( rv, col, jm )

      float    rv;		/* i: Posn in bar (0.0-0.999) */
      float    col[];		/* o: Colour in LUT */
      int      *jm;		/* o: Posn in LUT */
/* C-- */
{
      int k;
      float st[3], en[3];
/* Cbegin */


      (void) dsxc_lutvget();

      if ( LUTC_ENDS==1 ) {
         if ( LUTC_FLIPPED ) {
            st[0] = 1.0; st[1] = 1.0; st[2] = 1.0;
            en[0] = 0.0; en[1] = 0.0; en[2] = 0.0;
         }else{
            st[0] = 0.0; st[1] = 0.0; st[2] = 0.0;
            en[0] = 1.0; en[1] = 1.0; en[2] = 1.0;
         }
      }else if ( LUTC_ENDS==2 ) {
         if ( LUTC_FLIPPED ) {
            st[0] = 0.0; st[1] = 0.0; st[2] = 0.0;
            en[0] = 1.0; en[1] = 1.0; en[2] = 1.0;
         }else{
            st[0] = 1.0; st[1] = 1.0; st[2] = 1.0;
            en[0] = 0.0; en[1] = 0.0; en[2] = 0.0;
         }
      }else if ( LUTC_ENDS==3 ) {
         st[0] = LUTC_VAL[0][0];
         st[1] = LUTC_VAL[0][1];
         st[2] = LUTC_VAL[0][2];
         en[0] = LUTC_VAL[LVX-1][0];
         en[1] = LUTC_VAL[LVX-1][1];
         en[2] = LUTC_VAL[LVX-1][2];
      }

      rv = (rv-LUTC_ZE)/LUTC_SC;
      *jm = 1 + (int) ((float) (LVX-1)*rv);

      if ( *jm<1 ) {
         if ( LUTC_ENDS==4 ) {
            while ( *jm<1 ) {
               *jm = *jm + LVX;
            }
            for ( k=0; k<=2; k++ ) {
               col[k] = LUTC_VAL[*jm-1][k];
            }
         }else{
            *jm = 1;
            col[0] = st[0]; col[1] = st[1]; col[2] = st[2];
         }
      }else if ( *jm>LVX ) {
         if ( LUTC_ENDS==4 ) {
            while ( *jm>LVX ) {
               *jm = *jm - LVX ;
            }
            for ( k=0; k<=2; k++ ) {
               col[k] = LUTC_VAL[*jm-1][k];
            }
         }else{
            *jm = LVX;
            col[0] = en[0]; col[1] = en[1]; col[2] = en[2];
         }
      }else{
          col[0] = LUTC_VAL[*jm-1][0];
          col[1] = LUTC_VAL[*jm-1][1];
          col[2] = LUTC_VAL[*jm-1][2];
      }


}


/******************************************************************
 D<a name="sxc_lutload"> SXC_LUTLOAD  </a>-- Load LUT into working LUT

   alan penny                  ral                        1990-02-03
*/

dsxc_lutload ( tcol )

      float    tcol[];		/* o: Working LUT */
/* C-- */
{
      float st[3], en[3], rv;
      int jb, k, ja;

/* Cbegin */


      (void) dsxc_lutvget();

      if ( LUTC_ENDS==1 ) {
         if ( LUTC_FLIPPED ) {
            st[0]=1.0; st[1]=1.0; st[2]=1.0;
            en[0]=0.0; en[1]=0.0; en[2]=0.0;
         }else{
            st[0]=0.0; st[1]=0.0; st[2]=0.0;
            en[0]=1.0; en[1]=1.0; en[2]=1.0;
         }
      }else if ( LUTC_ENDS==2 ) {
         if ( LUTC_FLIPPED ) {
            st[0]=0.0; st[1]=0.0; st[2]=0.0;
            en[0]=1.0; en[1]=1.0; en[2]=1.0;
         }else{
            st[0]=1.0; st[1]=1.0; st[2]=1.0;
            en[0]=0.0; en[1]=0.0; en[2]=0.0;
         }
      }else if ( LUTC_ENDS==3 ) {
         st[0] = LUTC_VAL[0][0];
         st[1] = LUTC_VAL[0][1];
         st[2] = LUTC_VAL[0][2];
         en[0] = LUTC_VAL[LVX-1][0];
         en[1] = LUTC_VAL[LVX-1][1];
         en[2] = LUTC_VAL[LVX-1][2];
      }

      if ( LUTC_ENDS==4 ) {
         for ( jb=1; jb<=LVX; jb++ ) {
            rv = (float) (jb-1)/(float) (LVX-1);
            ja = 1.0 + ((float)(LVX-1))*(rv-LUTC_ZE)/LUTC_SC;
            while ( ja<1 ) {
               ja = ja + LVX;
            }
            while ( ja>LVX ) {
               ja = ja - LVX;
            }
            for ( k=0; k<=2; k++ ) {
               tcol[3*(jb-1)+k] = LUTC_VAL[ja-1][k];
            }
         }
      }else{
         for ( jb=1; jb<=LVX; jb++ ) {
            rv = (float) (jb-1)/(float) (LVX-1);
            ja = 1.0 + ((float)(LVX-1))*(rv-LUTC_ZE)/LUTC_SC;
            if ( ja<1 ) {
               for ( k=0; k<=2; k++ ) {
                  tcol[3*(jb-1)+k] = st[k];
               }
            }else if ( ja>LVX ) {
               for ( k=0; k<=2; k++ ) {
                  tcol[3*(jb-1)+k] = en[k];
               }
            }else{
               for ( k=0; k<=2; k++ ) {
                  tcol[3*(jb-1)+k] = LUTC_VAL[ja-1][k];
               }
            }
         }
      }


}
/***************************************************************************
 D<a name="sxc_lutvget"> SXC_LUTVGET  </a>-- Copy 'LUT.INC' Fortran variables over in this C

   alan penny                  ral                        1993 Aug
*/

dsxc_lutvget (void)

/* C-- */
{
      int   j, k;
/* Cbegin */


      LUTC_STORED  = F77_NAMED_COMMON(lutacom).lut_stored;
      LUTC_ENDS    = F77_NAMED_COMMON(lutacom).lut_ends;
      LUTC_NUM     = F77_NAMED_COMMON(lutacom).lut_num;
      LUTC_SC      = F77_NAMED_COMMON(lutacom).lut_sc;
      LUTC_ZE      = F77_NAMED_COMMON(lutacom).lut_ze;
      LUTC_FLIPPED = F77_NAMED_COMMON(lutbcom).lut_flipped;


      for ( k=0; k<=2; k++ ) {
         for ( j=0; j<=LVX-1; j++ ) {
            LUTC_VAL[j][k] = F77_NAMED_COMMON(lutacom).lut_val[k][j];
         }
      }

}


/***************************************************************************
 D<a name="sxc_lutvput"> SXC_LUTVPUT  </a>-- Copy 'LUT.H' C variables over into Fortran version

   alan penny                  ral                        1993 Aug
*/

dsxc_lutvput (void)

/* C-- */
{
      int   j, k;
/* Cbegin */


      F77_NAMED_COMMON(lutacom).lut_stored  = LUTC_STORED;
      F77_NAMED_COMMON(lutacom).lut_ends    = LUTC_ENDS;
      F77_NAMED_COMMON(lutacom).lut_num     = LUTC_NUM;
      F77_NAMED_COMMON(lutacom).lut_sc      = LUTC_SC;
      F77_NAMED_COMMON(lutacom).lut_ze      = LUTC_ZE;
      F77_NAMED_COMMON(lutbcom).lut_flipped = LUTC_FLIPPED;


      for ( k=0; k<=2; k++ ) {
         for ( j=0; j<=LVX-1; j++ ) {
            F77_NAMED_COMMON(lutacom).lut_val[k][j] = LUTC_VAL[j][k];
         }
      }

}

/*******************************************************
 DSX_PANELC.C
-
 Contains:-
-
 DSX_P_INIT      Initialise panel window (Fortran interface) (XWindows)
 DSX_P_CLOSE     Close panel window (Fortran interface) (XWindows)
 DSX_P_PTTIT     Put title on panel (Fortran interface) (Xwindows)
 DSX_P_SCOL      Set panel line colour (Fortran interface) (XWindows)
 DSX_P_SCUR      Start the panel cursor (Fortran interface) (XWindows)
 DSX_P_SSCUR     Start the panel cursor (sections) (Fortran interface) (XWindows)
 DSX_P_ERASE     Erase panel display (Fortran interface) (XWindows)
 DSX_P_SBOX      Paint a panel box (sections) (Fortran interface) (XWindows)
 DSX_P_LINE      Put a line at a position (Fortran interface) (Xwindows)
 DSX_P_PUTTXT    Write text to panel (Fortran interface) (XWindows)
 DSX_P_PUTIM     Put an image into panel (Fortran interface) (XWindows)
 DSX_P_CAREA     Put a standard colour rectangle into panel (Fortran interface) (XWindows)
 DSX_P_HBOX      Paint a help panel box (Fortran interface) (XWindows)
 DSX_P_HSTAT     Write panel status in the help panel box (Fortran interface) (XWindows)

 DSX_P_HX_LOAD   Load help panel with start help (Fortran interface) (XWindows)
 DSX_P_HX_HLOAD  Put help panel information (Fortran interface) (XWindows)
-
 DSXC_P_INIT      Initialise panel window (XWindows)
 DSXC_P_BYTECOL   Calc panel byte equivalents of PC_P_ID (XWindows)
 DSXC_P_SCOLOURS  Set up panel colours (XWindows)
 DSXC_P_CICON     Set up panel corner icon (XWindows)
 DSXC_P_ISVIEW    Is panel viewable?
 DSXC_P_EVENT     Handle panel exposure event (XWindows)
 DSXC_P_SETCOL    Set up color display for panel image display (XWindows)
 DSXC_P_CLOSE     Close panel window (XWindows)
 DSXC_P_PTTIT     Put title on panel (Xwindows)
 DSXC_P_ERASE     Erase panel display (XWindows)
 DSXC_P_SSCUR     Start the panel cursor (sections) (XWindows)
 DSXC_P_SBOX      Paint a panel box (sections) (XWindows)
 DSXC_P_PUTIM     Put an image to panel (XWindows)
 DSXC_P_CAREA     Put a standard colour rectangle into panel (XWindows)
 DSXC_P_LINE      Put a line at a position (Xwindows)
 DSXC_P_HBOX      Paint a help panel box (XWindows)
 DSXC_P_PUTTXT    Write text to panel (XWindows)
 DSXC_P_SETTHECOL Set writing colour for panel (XWindows)
 DSXC_P_SCOLNUM   Calc panel colour pixel number from colour number (XWindows)
 DSXC_P_HSTAT     Write panel status in the help panel box (XWindows)
 DSXC_P_CLEAR     Clear panel (Xwindows )
 DSXC_P_PUTCOL    Put a colour into an array (XWindows)

 DSXC_P_HX_LOAD   Load help panel with start help (XWindows)
 DSXC_P_HX_HLOAD  Put help panel information (Fortran interface) (XWindows)
 DSXC_P_HX_CICON  Set up help panel corner icon
 DSXC_P_HX_PUTTXT Write text to help panel (XWindows)
 DSXC_P_HX_PUTIM  Put an image into help panel (XWindows)

 AJ_SCPY          Copy text

*/

/* Include files */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <errno.h>

#if defined(vms)
#include "starman_x11_xlib"
#include "starman_x11_xutil"
#include "starman_x11_x"
#else
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/X.h>
#include <malloc.h>
#endif

#include "f77.h"
#include "cnf.h"

#include "dsx_panel.h"
#include "ds_gen.h"
#include "ds_panel.h"
#include "image.h"

/* Definitions */

extern void c_printo ( char* );
extern void c_gcmdlst ( char*, char*, int, int*, int*, int*, int*, int*,
                        int*, int*, int* );
extern void c_tyhelp ( char*, int, char*, int, int, int, int );
extern void c_get1i ( char*, int*, int, int, int );
extern void c_get1b ( char*, Bool*, Bool );
extern void dsxc_waitbut ( Bool, Bool, int*, int*, int* );
extern int imax ( int, int );
extern int imin ( int, int );

/*
DECLARE_CHARACTER(in,2000);
DECLARE_CHARACTER(out,2000);
*/

/* Panel Globals */

extern int PNKXS;
extern int PNKYS;
extern int PNKXO;
extern int PNKYO;

char TEXTAA[200];
/*
  (void) sprintf ( TEXTAA, " F1XXX %d %d %d %d %d ",
                          PDSOPEN, DSNXS, DSNXE, DSNYS, DSNYE );
   (void) c_printo ( TEXTAA );
*/

/*******************************************************************************
 D<a name="sx_p_init"> SX_P_INIT  </a>-- Initialise panel window (Fortran interface) (XWindows)

  alan penny             ral          1990 Aug
  pat morris             leeds        1992 Jan
*/

F77_SUBROUTINE(dsx_p_init) ( INTEGER(kx), INTEGER(ky), CHARACTER(title),
                             INTEGER(kdoh), INTEGER(ierr)  TRAIL(title) )

{
      GENPTR_INTEGER(kx)		/* i: Panel X size */
      GENPTR_INTEGER(ky)		/* i: Panel Y size */
      GENPTR_CHARACTER(title)		/* i: Title of image */
      GENPTR_INTEGER(kdoh)		/* i: Use Help Panel? (0=no;1=yes) */
      GENPTR_INTEGER(ierr)		/* o: Error flag (0=ok;1=bad) */
/* C-- */
      char  *name;
      int iierr;
/* Cbegin */

      name = cnf_creim ( title, title_length );

      (void) dsxc_p_init ( *kx, *ky, name, *kdoh, &iierr );

      *ierr = iierr;
      cnf_free ( name );

}



/*************************************************************************
  <a name="dsx_p_close"> DSX_P_CLOSE  </a>-- Close panel window (Fortran interface) (XWindows)

   alan penny             ral          1990 jan
  pat morris             leeds        1992 Jan
*/

F77_SUBROUTINE(dsx_p_close) ( INTEGER(kdoh), INTEGER(ierr) )

{
   GENPTR_INTEGER(kdoh)		/* i: Use Help Box? (0=no;1=yes) */
   GENPTR_INTEGER(ierr)		/* o: Error flag (0=ok;1=bad) */
/* C-- */
    int iierr;
/* Cbegin */

    (void) dsxc_p_close ( *kdoh, &iierr );

    *ierr = iierr;

}



/**************************************************************************
  <a name="dsx_p_pttit"> DSX_P_PTTIT  </a>-- Put title on panel (Fortran interface) (XWindows)

    alan penny                ral              1990-01-31
  pat morris             leeds        1992 Jan
*/

F77_SUBROUTINE(dsx_p_pttit) ( CHARACTER(title) TRAIL(title) )

{
GENPTR_CHARACTER(title)		/* i: Title to put up */
/* C-- */
      char *name;
/* Cbegin */


      name = cnf_creim ( title, title_length );
      (void) dsxc_p_pttit ( name );
      cnf_free (name);

}


/***********************************************************************
  <a name="dsx_p_scol"> DSX_P_SCOL  </a>-- Set panel line colour (Fortran interface) (XWindows)

    alan penny           ral                       1990-02-01
  pat morris             leeds        1992 Jan
*/

F77_SUBROUTINE(dsx_p_scol) ( REAL(w), INTEGER(kc) )

{
GENPTR_REAL(w)		/* i: Line width */
GENPTR_INTEGER(kc)      /* i: Colour (1=red;2=green;3=blue;4=yellow;
				5=cyan;6=mauve;7=tan;8=pink;
				9=black;10=white) */
/* C-- */
/* Cbegin */


}


/****************************************************************************
  <a name="dsx_p_sscur"> DSX_P_SSCUR  </a>-- Start the panel cursor (sections) (Fortran interface) (XWindows)

   alan penny                  ral                        1990-02-03
  pat morris             leeds        1992 Jan
*/

F77_SUBROUTINE(dsx_p_sscur) ( INTEGER(kn) )

{
GENPTR_INTEGER(kn)		/* i: Button to place cursor on */
/* C-- */
/* Cbegin */



     (void) dsxc_p_sscur ( *kn );

}


/**************************************************************************
 D<a name="sx_p_erase"> SX_P_ERASE  </a>-- Erase panel display (Fortran interface) (XWindows)

    a j penny                    ral         1990 jan
*/

F77_SUBROUTINE(dsx_p_erase) (void)

/* C-- */
{
/* Cbegin */

      (void) dsxc_p_clear ( 1 );

}



/**********************************************************************
 D<a name="sx_p_sbox"> SX_P_SBOX  </a>-- Paint a panel box (sections) (Fortran interface) (XWindows)

    alan penny           ral                       1990-02-01
  pat morris             leeds        1992 Jan
*/

F77_SUBROUTINE(dsx_p_sbox) ( INTEGER(kn), CHARACTER(text),
                            INTEGER(kflagu), INTEGER(kflage) TRAIL(text) )
{
   GENPTR_INTEGER(kn)		/* i: Box number (if -1=COMMAND; -2=HELP BUTT) */
   GENPTR_CHARACTER(text)	/* i: Text in box */
   GENPTR_INTEGER(kflagu)	/* i: Down or up box (0/1) */
   GENPTR_INTEGER(kflage)	/* i: Whole or edge of box (0/1) */
/* C-- */
      char *name;
/* Cbegin */

      name = cnf_creim( text, text_length );

      (void) dsxc_p_sbox ( *kn, name, *kflagu, *kflage );

      cnf_free (name);

}



/**********************************************************************
 D<a name="sx_p_line"> SX_P_LINE  </a>-- Put a line at a position (Fortran interface) (XWindows)

  alan penny             ral             1990 May
  pat morris             leeds        1992 jan
*/

F77_SUBROUTINE(dsx_p_line) ( REAL(xs), REAL(ys), REAL(xe), REAL(ye),
                            INTEGER(kc) )

{
    GENPTR_REAL(xs)		/* i: Line start X position(image pixels) */
    GENPTR_REAL(ys)		/* i: Line start Y position (image pixels) */
    GENPTR_REAL(xe)		/* i: Line end X position(image pixels) */
    GENPTR_REAL(ye)		/* i: Line end Y position (image pixels) */
    GENPTR_INTEGER(kc)		/* i: Colour (1=red;2=green;3=blue;4=yellow;
				           5=cyan;6=mauve;7=tan;8=pink)
				           9=black;10=white) */
/* C-- */
/* Cbegin */


     (void) dsxc_p_line ( *xs, *ys, *xe, *ye, *kc );


}


/***************************************************************************
 D<a name="sx_p_puttxt"> SX_P_PUTTXT  </a>-- Write text to panel (Fortran interface) (XWindows)

    alan penny           ral                       1990-02-01
  pat morris             leeds        1992 Jan
*/

F77_SUBROUTINE(dsx_p_puttxt) ( CHARACTER(text), INTEGER(kl), INTEGER(kx),
                               INTEGER(ky), INTEGER(kc) TRAIL(text) )

{
     GENPTR_CHARACTER(text)		/* i: Text to write */
     GENPTR_INTEGER(kl)			/* i: No of characters to write */
     GENPTR_INTEGER(kx)			/* i: X position */
     GENPTR_INTEGER(ky)       		/* i: Y position */
     GENPTR_INTEGER(kc)			/* i: Colour code (1=red;2=green;3=blue;
						4=yellow;5=cyan;6=mauve;7=tan;
				   		8=pink;9=black;10=white) */
/* C-- */
      char *name;
/* Cbegin */

      name = cnf_creim( text, text_length );

      (void) dsxc_p_puttxt ( name, *kl, *kx, *ky, *kc );

      cnf_free (name);

}


/**********************************************************************
 D<a name="sx_p_putim"> SX_P_PUTIM  </a>-- Put an image into panel (Fortran interface) (XWindows)

    alan penny           ral                       1990-02-01
  pat morris             leeds        1992 Jan
*/


F77_SUBROUTINE(dsx_p_putim) ( BYTE_ARRAY(data), INTEGER(kxl), INTEGER(kyl),
                              INTEGER(kx), INTEGER(ky) )

{
     GENPTR_BYTE_ARRAY(data)		/* i: Input data */
     GENPTR_INTEGER(kxl)		/* i: X size of data */
     GENPTR_INTEGER(kyl)		/* i: Y size of data */
     GENPTR_INTEGER(kx)       		/* i: X start of data position */
     GENPTR_INTEGER(ky)       		/* i: Y start of data position */
/* C-- */
/* Cbegin */


      (void) dsxc_p_putim ( data, *kxl, *kyl, *kx, *ky );

}

/**********************************************************************
 D<a name="sx_p_carea"> SX_P_CAREA  </a>-- Put a standard colour rectangle into panel (Fortran interface) (XWindows)

    alan penny           ral                       1990-02-01
  pat morris             leeds        1992 Jan
*/


F77_SUBROUTINE(dsx_p_carea) ( INTEGER(kx), INTEGER(ky), INTEGER(kxl),
                              INTEGER(kyl), INTEGER(kc) )

{
     GENPTR_INTEGER(kx)       		/* i: X start of area */
     GENPTR_INTEGER(ky)       		/* i: Y start of area */
     GENPTR_INTEGER(kxl)		/* i: X length of area */
     GENPTR_INTEGER(kyl)		/* i: Y length of area */
     GENPTR_INTEGER(kc)       		/* i: Colour code (0:1:2=medium:light:dark grey) */
/* C-- */
/* Cbegin */


      (void) dsxc_p_carea ( *kx, *ky, *kxl, *kyl, *kc );

}


/**********************************************************************
 D<a name="sx_p_hstat"> SX_P_HSTAT  </a>-- Write panel status in the help panel box (Fortran interface) (XWindows)

    alan penny           ral                       1990-02-01
  pat morris             leeds        1992 Jan
*/


F77_SUBROUTINE(dsx_p_hstat) ( INTEGER(kin) )

{
     GENPTR_INTEGER(kin)			/* i: Work/Wait/Help/Command/Pan/Zoom/Not Yet/Ready/One Got/ */
						/*    (0/1/2/3/4/5/6/7/8) */
/* C-- */
/* Cbegin */


      (void) dsxc_p_hstat ( *kin );

}

/**********************************************************************
 D<a name="sx_p_hx_load"> SX_P_HX_LOAD  </a>-- Put help panel start information (Fortran interface) (XWindows)

    alan penny           ral                       1990-02-01
  pat morris             leeds        1992 Jan
*/


F77_SUBROUTINE(dsx_p_hx_load) ( CHARACTER(title) TRAIL(title) )

{
     GENPTR_CHARACTER(title)		/* i: Title of help */
/* C-- */
      char  *name;
/* Cbegin */


      name = cnf_creim ( title, title_length );

      (void) dsxc_p_hx_load ( name );

      cnf_free ( name );


}

/**********************************************************************
 D<a name="sx_p_hx_hload"> SX_P_HX_HLOAD  </a>-- Put help panel information (Fortran interface) (XWindows)

    alan penny           ral                       1990-02-01
  pat morris             leeds        1992 Jan
*/


F77_SUBROUTINE(dsx_p_hx_hload) ( CHARACTER(topt), CHARACTER(thelp)
                                 TRAIL(topt) TRAIL(thelp)  )
{
     GENPTR_CHARACTER(topt)		/* i: Help Panel title - 68 character description of Option */
     GENPTR_CHARACTER(thelp)		/* i: Help Panel text - six lines of 68 characters*/

/* C-- */
      char  *namea, *nameb;
/* Cbegin */


      namea = cnf_creim ( topt, topt_length );
      nameb = cnf_creim ( thelp, thelp_length );

      (void) dsxc_p_hx_hload ( namea, nameb );

      cnf_free ( namea );
      cnf_free ( nameb );

}


/**********************************************************************
 D<a name="sx_p_hbox"> SX_P_HBOX  </a>-- Paint a help panel box (Fortran interface) (XWindows)

    alan penny           ral                       1990-02-01
  pat morris             leeds        1992 Jan
*/


F77_SUBROUTINE(dsx_p_hbox) (void)

{
/* C-- */
/* Cbegin */


      (void) dsxc_p_hbox ();

}


/*******************************************************************************
 D<a name="sxc_p_init"> SXC_P_INIT  </a>-- Initialise panel window (XWindows)

  alan penny             ral          1990 Aug
  pat morris             leeds        1992 Jan
*/

      dsxc_p_init ( kx, ky, title, kdoh, ierr )

      int    kx;		/* i: Panel X size */
      int    ky;		/* i: Panel Y size */
      char   *title;		/* i: Title of image */
      int    kdoh;		/* i: Use Help Panel? (0=no;1=yes) */
      int    *ierr;		/* o: Error flag (0=ok;1=bad) */
{
/* C-- */
      Bool func = True ;			/* Synchronous behaour */
      unsigned long attr_mask, event_mask;	/* attributes mask */
      XSetWindowAttributes xswda; 		/* window attributes */
      XGCValues       xgcvl;	    		/* gc values */
      XSizeHints      xszhn;	    		/* size hints */
/*
      char *font_name = "-adobe-new century schoolbook-medium-r-normal--*-120-*-*-p*";
      char *font_name = "-adobe-new century schoolbook-medium-r-normal--*-80-*-*-p*";
*/
      char *font_name = "-adobe-new century schoolbook-medium-r-normal--*-100-*-*-p*";
      char *display_name = NULL;
      char buf1[32], buf2[32], buf3[32], buf4[32], buf5[32], texta[50];
      char *argv[8];
      XEvent   event;
      int     k, nxa, nya, kxa, kya, khxa, khya, status, iout, fd[2];
      Bool loop;
/* Cbegin */

      *ierr = 0;

      if ( DSOPEN ) {
         if ( VD_ID == NULL ) {
            (void) c_printo ( "ERROR: Cant open Xwindows window" );
            *ierr = 1;
            return;
         }
      }
      else {
         if ( (VD_ID = XOpenDisplay(display_name)) == NULL ) {
            (void) c_printo ( "ERROR: Cant open Xwindows Display" );
            *ierr = 1;
            return;
         }
         (void) c_get1i ( "NUMBUTT", &iout, 3, 2, 3 );
         NUMXBUTTONS = iout;
         F77_NAMED_COMMON(ds_gen).numxbuttons = NUMXBUTTONS;
      }

      PDSOPEN = True;
      F77_NAMED_COMMON(ds_panelb).pdsopen = F77_TRUE;

      (void) XSynchronize ( VD_ID, func );
      SC_P_ID = DefaultScreen( VD_ID );
      RW_P_ID = RootWindow( VD_ID, SC_P_ID );

      nxa = DisplayWidth ( VD_ID, SC_P_ID) ;
      nya = DisplayHeight( VD_ID, SC_P_ID);

      PNSNX = kx;
      PNSNY = ky;

      F77_NAMED_COMMON(ds_panel).pnsnx = PNSNX;
      F77_NAMED_COMMON(ds_panel).pnsny = PNSNY;

      if ( (PNSNX>(nxa-6)) || (PNSNY>(nya-25)) ) {
         (void) c_printo ( "ERROR: Panel too large for display" );
         *ierr = 1;
         return;
      }

      PNNCOL = PNSNX/91;
      PNNROW = PNSNY/26;
      F77_NAMED_COMMON(ds_panel).pnncol = PNNCOL;
      F77_NAMED_COMMON(ds_panel).pnnrow = PNNROW;

      P_DEPTH = DefaultDepth(VD_ID, SC_P_ID);
      if ( P_DEPTH<8 ) {
         (void) c_printo ( "ERROR: Panel pixel depth must be at least 8" );
         *ierr = 1;
         return;
      }

      P_VISUAL = DefaultVisual( VD_ID, SC_P_ID );
      if ( P_VISUAL->class != PseudoColor ) {
         (void) c_printo ( "ERROR: Cant allocate colours - display type has to be pseudo color" );
         *ierr = 1;
         return;
      }

      if (!DSOPEN) (void) dsxc_opcolmap ();				/* Open colour map */

      attr_mask = CWEventMask | CWBackPixel | CWBorderPixel | CWColormap;
      xswda.event_mask = ExposureMask ;
      xswda.background_pixel = BlackPixel(VD_ID, SC_P_ID);
      xswda.border_pixel = WhitePixel(VD_ID, SC_P_ID);
      xswda.colormap = CM_ID;

      DSWINDX = F77_NAMED_COMMON(ds_gen).dswindx;
      DSWINDY = F77_NAMED_COMMON(ds_gen).dswindy;
      kxa = nxa - PNSNX - DSWINDX;					/* Position */
      kya = DSWINDY;

      WD_P_ID = XCreateWindow ( VD_ID, RW_P_ID, kxa, kya, PNSNX,
                                PNSNY, 0, P_DEPTH, InputOutput,
                                P_VISUAL, attr_mask, &xswda );		/* Open window */

      (void) dsxc_p_cicon (); 						/* Set up panel corner icon */

      (void) dsxc_p_scolours ();					/* Set up panel parts */

      DSWINDX = DSWINDX + PNSNX + 20;
      DSWINDXM = DSWINDX;
      F77_NAMED_COMMON(ds_gen).dswindx = DSWINDX;
      F77_NAMED_COMMON(ds_gen).dswindxm = DSWINDXM;

      xgcvl.foreground = BlackPixel(VD_ID, SC_P_ID);			/* Create graphics context*/
      xgcvl.background = WhitePixel(VD_ID, SC_P_ID);
      GC_P_ID = XCreateGC ( VD_ID, WD_P_ID, (GCForeground | GCBackground),
                            &xgcvl );

      if ( (FT_P_ID = XLoadQueryFont ( VD_ID, font_name ) ) == NULL ) {	/* Load the font for text */
         (void) c_printo (
         "WARNING: Couldn\'t open fonts - Text may be wrong size" );	/* writing */
      }else{
         XSetFont ( VD_ID, GC_P_ID, FT_P_ID->fid );
      }

      XSetForeground ( VD_ID, GC_P_ID, WhitePixel(VD_ID, SC_P_ID) );

      xszhn.x = kxa;							/* Define the size and */
      xszhn.y = kya;							/* name of the WD_P_ID */
      xszhn.width = PNSNX;						/* window */
      xszhn.height = PNSNY;
      xszhn.flags = PPosition | PSize;

      XSetNormalHints ( VD_ID, WD_P_ID, &xszhn );

      XFlush ( VD_ID );

      P_PIXMAP = XCreatePixmap ( VD_ID, RW_P_ID, PNSNX, PNSNY, P_DEPTH );
      (void) dsxc_p_clear ( 1 );

      XSelectInput ( VD_ID, WD_P_ID, StructureNotifyMask | ButtonPressMask
                     | ButtonReleaseMask | PointerMotionMask
                     | SubstructureNotifyMask | ExposureMask );

      XMapWindow ( VD_ID, WD_P_ID );					/* Map the windows */

      XFlush ( VD_ID );

      (void) dsxc_p_pttit ( title );

      event_mask = SubstructureNotifyMask | StructureNotifyMask ;
      XWindowEvent ( VD_ID, WD_P_ID, event_mask, &event );
									/* Wait for window to appear */


      PID = vfork();
      if ( PID != 0 ) {  				/* We are child so do exposure monitor */
         if ( PID == -1 ) (void) c_printo ( "ERROR: Panel Refresh not started" );
      } else {

         display_name = DisplayString ( VD_ID );
         argv[0] = "s_refresh";
         sprintf ( buf1, "%lu", WD_P_ID );
         argv[1] = buf1;
         sprintf ( buf2, "%lu", P_PIXMAP );
         argv[2] = buf2;
         argv[3] = display_name;
         argv[4] = '\0';
         execvp ( "s_refresh", argv );
         _exit ( errno );
      }

      XFlush ( VD_ID );

      if ( kdoh==1 ) {
         PHNX = 470;							/* Open Help window */
         PHNY = 120;
         khxa = kxa - (PHNX-PNSNX);
         khya = kya + PNSNY + 100;		
         xswda.background_pixel = WhitePixel(VD_ID, SC_P_ID);
         xswda.border_pixel = BlackPixel(VD_ID, SC_P_ID);
         WD_PH_ID = XCreateWindow ( VD_ID, RW_P_ID, khxa, khya, PHNX,
                                    PHNY, 0, P_DEPTH, InputOutput,
                                    P_VISUAL, attr_mask, &xswda );

         (void) dsxc_p_hx_cicon (); 					/* Set up Help panel corner icon */

         GC_PH_ID = XCreateGC ( VD_ID, WD_PH_ID,
                                (GCForeground | GCBackground), &xgcvl );

									/* Load the font for text */
         if ( (FT_P_ID = XLoadQueryFont ( VD_ID, font_name ) )
              != NULL ) {	
            XSetFont ( VD_ID, GC_PH_ID, FT_P_ID->fid );
         }

         XSetForeground (VD_ID,GC_PH_ID, WhitePixel(VD_ID, SC_P_ID) );

         xszhn.x = khxa;						/* Define the size and */
         xszhn.y = khya;						/* name of the WD_PH_ID */
         xszhn.width = PHNX;						/* window */
         xszhn.height = PHNY;
         XSetNormalHints ( VD_ID, WD_PH_ID, &xszhn );

         XFlush ( VD_ID );

         PH_PIXMAP = XCreatePixmap (VD_ID,RW_P_ID,PHNX,PHNY,P_DEPTH);
         (void) dsxc_p_clear ( 2 );

         XSelectInput ( VD_ID, WD_PH_ID,
                        StructureNotifyMask | ButtonPressMask
                        | ButtonReleaseMask | PointerMotionMask
                        | SubstructureNotifyMask | ExposureMask );

         XMapWindow ( VD_ID, WD_PH_ID );				/* Map the windows */

         XFlush ( VD_ID );

         event_mask = SubstructureNotifyMask | StructureNotifyMask ;
         XWindowEvent ( VD_ID, WD_PH_ID, event_mask, &event );
 									/* Wait for window to appear */
         PID = vfork();
         if ( PID != 0 ) {  						/* We are child so do exposure monitor */
            if ( PID == -1 ) (void) c_printo (
                             "ERROR: Help Panel Refresh not started" );
         } else {

            display_name = DisplayString ( VD_ID );
            argv[0] = "s_refresh";
            sprintf ( buf1, "%lu", WD_PH_ID );
            argv[1] = buf1;
            sprintf ( buf2, "%lu", PH_PIXMAP );
            argv[2] = buf2;
            argv[3] = display_name;
            argv[4] = '\0';
            execvp ( "s_refresh", argv );
            _exit ( errno );
         }

         (void) dsxc_p_hx_load ( title );
         XFlush ( VD_ID );

      }

}


/************************************************************************
  <a name="dsxc_p_scolours">  DSXC_P_SCOLOURS  </a>-- Set up panel colours

  alan penny             ral                    1990 Aug
  pat morris             leeds        1992 Jan
*/

dsxc_p_scolours ( )

{
/* C-- */
      int i, j, k, ka;
      char gcol[5];

      static int knu[59] = { 1, 1, 1, 3, 1, 1, 3, 1, 1, 3, 1, 2, 3,
     			     1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,
                             1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,
        1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3,
        1, 3, 3, 1, 3, 3, 1, 3, 3, 3 };

      static int knd[59] = { 3,
        3, 3, 1, 3, 3, 1,
        3, 3, 1, 3, 2, 1,
        3, 2, 1, 3, 2, 1,
        3, 2, 1, 3, 2, 1,
        3, 2, 1, 3, 2, 1,
        3, 2, 1, 3, 2, 1,
        3, 2, 1, 3, 2, 1,
        3, 2, 1, 3, 2, 1,
        3, 1, 1, 3, 1, 1,
        3, 1, 1,
        1 };

      static int knum[59] = { 86,
        1, 84, 1,   2, 82, 2,
        3, 80, 3,   4, 78, 4,
        5, 76, 5,   5, 76, 5,
        5, 76, 5,   5, 76, 5,
        5, 76, 5,   5, 76, 5,
        5, 76, 5,   5, 76, 5,
        5, 76, 5,   5, 76, 5,
        5, 76, 5,   4, 78, 4,
        3, 80, 3,   2, 82, 2,
        1, 84, 1,
        86 };

       static int knh[134] = { 1,
         1, 1, 3, 1, 1, 3,
         1, 1, 3, 1, 1, 3,
         1, 2, 3, 1, 2, 3,
         1, 2, 3, 1, 2, 3,
         1, 2, 3, 1, 2, 3,
         1, 2, 3, 1, 2, 3,
         1, 2, 3, 1, 2, 3,
         1, 2, 3, 1, 2, 3,
         1, 2, 3, 1, 2, 3,
         1, 2, 3, 1, 2, 3,
         1, 2, 3, 1, 2, 3,
         1, 2, 3, 1, 2, 3,
         1, 2, 3, 1, 2, 3,
         1, 2, 3, 1, 2, 3,
         1, 2, 3, 1, 2, 3,
         1, 2, 3, 1, 2, 3,
         1, 2, 3, 1, 2, 3,
         1, 2, 3, 1, 2, 3,
         1, 2, 3, 1, 2, 3,
         1, 2, 3, 1, 2, 3,
         1, 2, 3, 1, 3, 3,
         1, 3, 3, 1, 3, 3,
         3 };

      static int knumh[134] = { 86,
        1, 84, 1, 2, 82, 2,
        3, 80, 3, 4, 78, 4,
        5, 76, 5, 5, 76, 5,
        5, 76, 5, 5, 76, 5,
        5, 76, 5, 5, 76, 5,
        5, 76, 5, 5, 76, 5,
        5, 76, 5, 5, 76, 5,
        5, 76, 5, 5, 76, 5,
        5, 76, 5, 5, 76, 5,
        5, 76, 5, 5, 76, 5,
        5, 76, 5, 5, 76, 5,
        5, 76, 5, 5, 76, 5,
        5, 76, 5, 5, 76, 5,
        5, 76, 5, 5, 76, 5,
        5, 76, 5, 5, 76, 5,
        5, 76, 5, 5, 76, 5,
        5, 76, 5, 5, 76, 5,
        5, 76, 5, 5, 76, 5,
        5, 76, 5, 5, 76, 5,
        5, 76, 5, 5, 76, 5,
        4, 78, 4, 3, 80, 3,
        2, 82, 2, 1, 84, 1,
        86 };

       static int knr[40] = { 4, 4, 4, 2, 4, 4, 2, 4,
        4, 2, 4, 4, 2, 4, 4, 2, 4,
        4, 2, 4, 4, 2, 4,
        4, 2, 4, 4, 2, 4, 4, 2, 4,
        4, 2, 4, 4, 2, 4, 4, 4 };

       static int kng[40] = { 5, 5, 5, 2, 5, 5, 2, 5,
        5, 2, 5, 5, 2, 5, 5, 2, 5,
        5, 2, 5, 5, 2, 5,
        5, 2, 5, 5, 2, 5, 5, 2, 5,
        5, 2, 5, 5, 2, 5, 5, 5 };

      static int knumr[40] = { 67, 67, 3, 61, 3, 3, 61, 3,
         3, 61, 3, 3, 61, 3, 3, 61, 3,
         3, 61, 3, 3, 61, 3,
         3, 61, 3, 3, 61, 3, 3, 61, 3,
         3, 61, 3, 3, 61, 3, 67, 67 };
/* Cbegin */


      gcol[0] = BY_PC_ID[13];
      gcol[1] = BY_PC_ID[12];
      gcol[2] = BY_PC_ID[11];
      gcol[3] = BY_PC_ID[2];
      gcol[4] = BY_PC_ID[3];

      GL = gcol[0];
      GM = gcol[1];
      GD = gcol[2];

      for ( j=0; j<500*500; j++ ) {
         XPM[j] = GM;
      }

      for ( j=0; j<2000 ; j++ ) {
         XPD[j] = GD;
         XPL[j] = GL;
      }

      k = 0;
      for ( j = 0; j<59; j++ ) {
         ka = knu[j]-1;
         for ( i=0; i<knum[j]; i++ )
             XDU[k+i] = gcol[ka];
         k = k + knum[j];
      }

      k = 0;
      for ( j=0; j<59; j++ ) {
         ka = knd[j]-1;
         for ( i=0; i<knum[j]; i++ )
             XDD[k+i] = gcol[ka];
         k = k + knum[j];
      }

      k = 0;
      for ( j=0; j<134; j++ ) {
         ka = knh[j]-1;
         for ( i=0; i<knumh[j]; i++ )
             XDH[k+i] = gcol[ka];
         k = k + knumh[j];
      }

      k = 0;
      for ( j=0; j<40; j++ ) {
         ka = knr[j]-1;
         for ( i=0; i<knumr[j]; i++ )
             IR[k+i] = gcol[ka];
         k = k + knumr[j];
      }

      k = 0;
      for ( j=0; j<40; j++ ) {
         ka = kng[j]-1;
         for ( i=0; i<knumr[j]; i++ )
             IG[k+i] = gcol[ka];
         k = k + knumr[j];
      }


}

/*********************************************************************
 D<a name="sxc_p_cicon"> SXC_P_CICON  </a>-- Set up panel corner icon

  alan penny             ral                    1990 Aug
  pat morris             leeds        1992 Jan
*/

dsxc_p_cicon ( )

{
/* C-- */
      XWMHints        xwmhn;	    	/* Window manager hints */
      XWMHints        xwmhints;

      Pixmap icon_pixmap;
      Atom   wmatom;
      static unsigned char icon_bits[512] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x3c, 0x1f, 0x63, 0x23, 0x62, 0x88, 0x00, 0x00,
        0x02, 0x04, 0x43, 0x64, 0x63, 0x88, 0x00, 0x00,
        0x02, 0x84, 0x44, 0x64, 0x93, 0x98, 0x00, 0x00,
        0x02, 0x84, 0x64, 0xa3, 0x92, 0xa8, 0x00, 0x00,
        0x1c, 0x84, 0x44, 0x21, 0x92, 0xa8, 0x00, 0x00,
        0x20, 0x84, 0x47, 0x22, 0xf2, 0xc8, 0x00, 0x00,

        0x20, 0x44, 0x48, 0x22, 0x0a, 0x89, 0x00, 0x00,
        0x1e, 0x44, 0x48, 0x24, 0x0a, 0x89, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

        0x00, 0x1f, 0x8c, 0x90, 0x27, 0x00, 0x00, 0x00,
        0x00, 0x21, 0x8c, 0x91, 0x20, 0x00, 0x00, 0x00,
        0x00, 0x21, 0x92, 0x92, 0x20, 0x00, 0x00, 0x00,
        0x00, 0x21, 0x92, 0x92, 0x20, 0x00, 0x00, 0x00,
        0x00, 0x1f, 0x92, 0x94, 0x23, 0x00, 0x00, 0x00,
        0x00, 0x01, 0x9e, 0x94, 0x20, 0x00, 0x00, 0x00,
        0x00, 0x01, 0xa1, 0x98, 0x20, 0x00, 0x00, 0x00,
        0x00, 0x01, 0xa1, 0x90, 0xe7, 0x01, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xf0, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } ;
/* Cbegin */


      icon_pixmap = XCreateBitmapFromData ( VD_ID, WD_P_ID, icon_bits, 64, 64 );

      xwmhn.flags  = IconPixmapHint | IconMaskHint;
      xwmhn.icon_pixmap = icon_pixmap;
      xwmhn.icon_mask   = icon_pixmap;
      XSetWMHints ( VD_ID, WD_P_ID, &xwmhn );

      wmatom = XInternAtom ( VD_ID, "XA_WM_HINTS", 0 );

      if ( wmatom != None ) {
         xwmhints.flags = IconPixmapHint;
         xwmhints.icon_pixmap = icon_pixmap;

         XChangeProperty ( VD_ID, WD_P_ID, wmatom, wmatom, 32,
                                 PropModeReplace, (char *) &xwmhints, 9 );
      }

      XFlush ( VD_ID );


}

/*********************************************************************
 D<a name="sxc_p_isview"> SXC_P_ISVIEW  </a>-- Is panel viewable?

  alan penny             ral                    1990 Aug
  pat morris             leeds        1992 Jan
*/

dsxc_p_isview ( kis )

       int   *kis;	/* o: Is Viewable (0=yes;1=no) */

{
/* C-- */
      XWindowAttributes  xwattr;	    	/* Window Attributes */

/* Cbegin */


      *kis = 1;

      XGetWindowAttributes ( VD_ID, WD_P_ID, & xwattr );
      if ( xwattr.map_state == IsViewable ) *kis = 0 ;

      XFlush ( VD_ID );


}

/*********************************************************************
 D<a name="sxc_p_hx_cicon"> SXC_P_HX_CICON  </a>-- Set up help panel corner icon

  alan penny             ral                    1990 Aug
  pat morris             leeds        1992 Jan
*/

dsxc_p_hx_cicon ( )

{
/* C-- */
      XWMHints        xwmhn;	    	/* Window manager hints */
      XWMHints        xwmhints;

      Pixmap icon_pixmap;
      Atom   wmatom;
      static unsigned char icon_bits[512] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x3c, 0x1f, 0x63, 0x23, 0x62, 0x88, 0x00, 0x00,
        0x02, 0x04, 0x43, 0x64, 0x63, 0x88, 0x00, 0x00,
        0x02, 0x84, 0x44, 0x64, 0x93, 0x98, 0x00, 0x00,
        0x02, 0x84, 0x64, 0xa3, 0x92, 0xa8, 0x00, 0x00,
        0x1c, 0x84, 0x44, 0x21, 0x92, 0xa8, 0x00, 0x00,
        0x20, 0x84, 0x47, 0x22, 0xf2, 0xc8, 0x00, 0x00,

        0x20, 0x44, 0x48, 0x22, 0x0a, 0x89, 0x00, 0x00,
        0x1e, 0x44, 0x48, 0x24, 0x0a, 0x89, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

        0x00, 0x40, 0xe4, 0x09, 0x3e, 0x00, 0x00, 0x00,
        0x00, 0x40, 0x24, 0x08, 0x42, 0x00, 0x00, 0x00,
        0x00, 0x40, 0x24, 0x08, 0x42, 0x00, 0x00, 0x00,
        0x00, 0x40, 0x24, 0x08, 0x42, 0x00, 0x00, 0x00,
        0x00, 0xc0, 0xe7, 0x08, 0x3e, 0x00, 0x00, 0x00,
        0x00, 0x40, 0x24, 0x08, 0x02, 0x00, 0x00, 0x00,
        0x00, 0x40, 0x24, 0x08, 0x02, 0x00, 0x00, 0x00,
        0x00, 0x40, 0xe4, 0x78, 0x02, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xf0, 0xff, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x00,
        0x00, 0xff, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00,
        0x00, 0x00, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } ;
/* Cbegin */


      icon_pixmap = XCreateBitmapFromData ( VD_ID, WD_PH_ID, icon_bits, 64, 64 );

      xwmhn.flags  = IconPixmapHint | IconMaskHint;
      xwmhn.icon_pixmap = icon_pixmap;
      xwmhn.icon_mask   = icon_pixmap;
      XSetWMHints ( VD_ID, WD_PH_ID, &xwmhn );

      wmatom = XInternAtom ( VD_ID, "XA_WM_HINTS", 0 );

      if ( wmatom != None ) {
         xwmhints.flags = IconPixmapHint;
         xwmhints.icon_pixmap = icon_pixmap;

         XChangeProperty ( VD_ID, WD_PH_ID, wmatom, wmatom, 32,
                                 PropModeReplace, (char *) &xwmhints, 9 );
      }

      XFlush ( VD_ID );


}


/*************************************************************************
  <a name="dsxc_p_close"> DSXC_P_CLOSE  </a>-- Close panel window (XWindows)

   alan penny             ral          1990 jan
  pat morris             leeds        1992 Jan
*/

dsxc_p_close ( kdoh, ierr )

       int    kdoh;	/* i: Use Help Panel? (0=no;1=yes) */
       int   *ierr;	/* o: Error flag (0=ok;1=bad) */
{
/* C-- */
/* Cbegin */


      *ierr = 0;					/* Cant fail! */

      DSOPEN = F77_NAMED_COMMON(ds_genb).dsopen;
      PDSOPEN = F77_NAMED_COMMON(ds_panelb).pdsopen;
      DSWINDX = F77_NAMED_COMMON(ds_gen).dswindx;
      DSWINDXM = F77_NAMED_COMMON(ds_gen).dswindxm;
      PNSNX = F77_NAMED_COMMON(ds_panel).pnsnx;

      if ( !PDSOPEN ) return;

      DSWINDX = DSWINDX - PNSNX - 20;

      XUnmapWindow ( VD_ID, WD_P_ID );
      XDestroyWindow ( VD_ID, WD_P_ID );
      XFreePixmap ( VD_ID, P_PIXMAP );

      if ( kdoh==1 ) {
         XUnmapWindow ( VD_ID, WD_PH_ID );
         XDestroyWindow ( VD_ID, WD_PH_ID );
         XFreePixmap ( VD_ID, PH_PIXMAP );
      }

      if ( !DSOPEN ) XCloseDisplay ( VD_ID );
      XFlush ( VD_ID );

      PDSOPEN = False;

      F77_NAMED_COMMON(ds_gen).dswindx = DSWINDX;
      F77_NAMED_COMMON(ds_panelb).pdsopen = F77_FALSE;


}


/**************************************************************************
  <a name="dsxc_p_pttit"> DSXC_P_PTTIT  </a>-- Put title on panel (XWindows)

    alan penny                ral              1990-01-31
  pat morris             leeds        1992 Jan
*/
dsxc_p_pttit ( title )

char *title;	/* i: Title to put up */
{
/* C-- */
/* Cbegin */


      XStoreName ( VD_ID, WD_P_ID, title );


}


/****************************************************************************
  <a name="dsxc_p_sscur"> DSXC_P_SSCUR  </a>-- Start the panel cursor (sections) (XWindows)

   alan penny                  ral                        1990-02-03
  pat morris             leeds        1992 Jan
*/

dsxc_p_sscur ( kn )

     int kn;		/* i: Box number to place cursor */
{
/* C-- */
      Cursor  cursor;
      Pixmap cursor_pixmap;
      static unsigned char cursor_bits[32] =  { 0x00, 0x00, 0x00, 0x00,
                        0x00, 0x00, 0xff, 0xff,
                        0xff, 0xff, 0xff, 0xff,
                        0xff, 0xff, 0xff, 0xff,
                        0xff, 0xff, 0xff, 0xff,
                        0xff, 0xff, 0xff, 0xff,
                        0xff, 0xff, 0x00, 0x00,
                        0x00, 0x00, 0x00, 0x00 } ;
      int     kx, ky, jx, jy;
      XColor  cursor_dummy;
      XColor  cursor_foreground;
      XColor  cursor_background;
/* Cbegin */


      cursor_pixmap = XCreatePixmapFromBitmapData ( VD_ID, RW_P_ID,	
                             cursor_bits, 16, 16, 1, 0, 1 );

      XLookupColor ( VD_ID, DefaultColormap(VD_ID,SC_P_ID),
                           "red", &cursor_dummy, &cursor_foreground );
      XLookupColor ( VD_ID, DefaultColormap(VD_ID,SC_P_ID),
                           "black", &cursor_dummy, &cursor_background );

      cursor = XCreatePixmapCursor ( VD_ID, cursor_pixmap, cursor_pixmap,
                              &cursor_foreground, &cursor_background, 7, 7 );
                                	         			/* Use same bitmap for shape and mask
				                                         so cursor background is transparent */
      XDefineCursor ( VD_ID, WD_P_ID, cursor );
      XFreePixmap ( VD_ID, cursor_pixmap );

      jx = F77_NAMED_COMMON(ds_panel).pnx[kn-1];
      jy = F77_NAMED_COMMON(ds_panel).pny[kn-1];
      jx = jx + 68.0;
      jy = jy + 10.0;

      kx = jx - 1;
      ky = PNSNY - jy;

/*
      XWarpPointer ( VD_ID, None, WD_P_ID,  0, 0, 0, 0, kx, ky );
*/

      XFlush ( VD_ID );

}


/**********************************************************************
 D<a name="sxc_p_sbox"> SXC_P_SBOX  </a>-- Paint a panel box (sections) (XWindows)

    alan penny           ral                       1990-02-01
  pat morris             leeds        1992 Jan
*/

dsxc_p_sbox ( kn, text, kflagu, kflage )

   int  kn;		/* i: Box number (unless -1=COMMAND;-2=Help Buttons) */
   char *text;		/* i: Text in box */
   int  kflagu;		/* i: Down or up box (0/1) */
   int  kflage;		/* i: Whole or edge of box (0/1) */
{
/* C-- */
      int jx, jy, kl;
/* Cbegin */


      if ( kn==-1 ) {
         jx = F77_NAMED_COMMON(ds_panel).pncposx;
         jy = F77_NAMED_COMMON(ds_panel).pncposy;
      } else if ( kn==-2 ) {
         jx = F77_NAMED_COMMON(ds_panel).pnbhposx;
         jy = F77_NAMED_COMMON(ds_panel).pnbhposy;
      } else {
         jx = F77_NAMED_COMMON(ds_panel).pnx[kn-1];
         jy = F77_NAMED_COMMON(ds_panel).pny[kn-1];
      }

      if ( kflage == 0 ) {						/* Paint box */
         if ( kflagu == 1 )
            (void) dsxc_p_putim ( XDU, 86, 21, jx, jy );
         else
            (void) dsxc_p_putim ( XDD, 86, 21, jx, jy );
         kl = strlen(text);
         kl = imin (11, kl );
         if ( kl > 1 ) (void) dsxc_p_puttxt ( text, kl, jx+9, jy+5, 9 );
      }else {
         if ( kflagu == 1 ) {
            (void) dsxc_p_putim ( &XDU[86*17], 86, 4, jx, jy );
            (void) dsxc_p_putim ( XDU, 86, 4, jx, jy+17 );
            (void) dsxc_p_putim ( XPL, 5, 13, jx, jy+4 );
            (void) dsxc_p_putim ( XPD, 5, 13, jx+81, jy+4 );
         }else {
            (void) dsxc_p_putim ( &XDD[86*17], 86, 4, jx, jy );
            (void) dsxc_p_putim ( XDD, 86, 4, jx, jy+17 );
            (void) dsxc_p_putim ( XPD, 5, 13, jx, jy+4 );
            (void) dsxc_p_putim ( XPL, 5, 13, jx+81, jy+4 );
         }
      }


}


/**********************************************************************
 D<a name="sxc_p_putim"> SXC_P_PUTIM  </a>-- Put an image into panel (XWindows)

    alan penny           ral                       1990-02-01
  pat morris             leeds        1992 Jan
*/

dsxc_p_putim ( data, kxl, kyl, kx, ky )

char  *data;		/* i: Input data */
int   kxl;		/* i: X size of data */
int   kyl;		/* i: Y size of data */
int   kx;		/* i: X start of data position */
int   ky;		/* i: Y start of data position */
{
/* C-- */

      int xkx, xky;
      XImage  *image;
      char *ipd;
      int i;
/* Cbegin */


      PNSNY = F77_NAMED_COMMON(ds_panel).pnsny;

      ipd = malloc ( kxl*kyl );
      for ( i=0;i<kxl*kyl;i++ )
          ipd[i] = data[i];

      image = XCreateImage ( VD_ID, P_VISUAL, P_DEPTH, ZPixmap, 0, ipd,
                              kxl, kyl, 8, kxl );
									/* Point to image */
      XFlush ( VD_ID );
      xkx = kx - 1;
      xky = PNSNY - ky - kyl + 2;
      XPutImage ( VD_ID, P_PIXMAP, GC_P_ID, image, 0, 0,
                  xkx, xky, kxl, kyl );					/* Put image in pixmap */
      XCopyArea ( VD_ID, P_PIXMAP, WD_P_ID, GC_P_ID,
		  xkx, xky, kxl, kyl, xkx, xky );			/* Put pixmap area on screen */

      XDestroyImage ( image );
      free (ipd);
      XFlush ( VD_ID );


}

/**********************************************************************
 D<a name="sxc_p_carea"> SXC_P_CAREA  </a>-- Put a standard colour rectangle into panel (XWindows)

    alan penny           ral                       1990-02-01
  pat morris             leeds        1992 Jan
*/

dsxc_p_carea ( kx, ky, kxl, kyl, kc )

     int   kx;       		/* i: X start of area */
     int   ky;       		/* i: Y start of area */
     int   kxl;			/* i: X length of area */
     int   kyl;			/* i: Y length of area */
     int   kc;       		/* i: Colour code (0:1:2=medium:light:dark grey) */
{
/* C-- */
/* Cbegin */


      PNSNY = F77_NAMED_COMMON(ds_panel).pnsny;

      switch (kc) {
         case 0  : if ( kxl*kyl<=500*500 ) {
                      (void) dsxc_p_putim ( XPM, kxl, kyl, kx, ky );
                   }
                   break;
         case 1  : if ( kxl*kyl<=2000 ) {
                      (void) dsxc_p_putim ( XPL, kxl, kyl, kx, ky );
                   }
                   break;
         case 2  : if ( kxl*kyl<=2000 ) {
                      (void) dsxc_p_putim ( XPD, kxl, kyl, kx, ky );
                   }
                   break;
         default : return;
      }
}

/***************************************************************************
  <a name="dsxc_p_hbox"> DSXC_P_HBOX  </a>-- Paint a help panel box (XWindows)

    alan penny           ral                       1990-02-01
  pat morris             leeds        1992 Jan
*/

dsxc_p_hbox (void)

{
/* C-- */

      int j, jx, jy;
/* Cbegin */


      jx = F77_NAMED_COMMON(ds_panel).pnhposx;
      jy = F77_NAMED_COMMON(ds_panel).pnhposy;

      (void) dsxc_p_putim ( XDH, 86, 46, jx, jy );

      (void) dsxc_p_puttxt ( "HELP", 4, jx+23, jy+9, 9 );


}


/***************************************************************************
 D<a name="sxc_p_puttxt"> SXC_P_PUTTXT  </a>-- Write text to panel (XWindows)

    alan penny           ral                       1990-02-01
  pat morris             leeds        1992 Jan
*/

dsxc_p_puttxt ( text, kl, kx, ky, kc )

char    *text;			/* i: Text to write */
int     kl;			/* i: No of characters to write */
int     kx;			/* i: X position */
int     ky;       		/* i: Y position */
int     kc;			/* i: Colour code (1=red;2=green;3=blue;
				   4=yellow;5=cyan;6=mauve;7=tan;
				   8=pink;9=black;10=white) */
{
/* C-- */
      int jy;
/* Cbegin */


      PNSNY = F77_NAMED_COMMON(ds_panel).pnsny;

      (void) dsxc_p_setthecol ( kc );

      jy = PNSNY - ky;

      XDrawString ( VD_ID, WD_P_ID, GC_P_ID, kx, jy, text, kl );
      XDrawString ( VD_ID, P_PIXMAP, GC_P_ID, kx, jy, text, kl );
      XFlush ( VD_ID );


 }


/***************************************************************************
 D<a name="sxc_p_hx_puttxt"> SXC_P_HX_PUTTXT  </a>-- Write text to help panel (XWindows)

    alan penny           ral                       1990-02-01
  pat morris             leeds        1992 Jan
*/

dsxc_p_hx_puttxt ( text, kl, kx, ky, kc )

char    *text;			/* i: Text to write */
int     kl;			/* i: No of characters to write */
int     kx;			/* i: X position */
int     ky;       		/* i: Y position */
int     kc;			/* i: Colour code (1=red;2=green;3=blue;
				   4=yellow;5=cyan;6=mauve;7=tan;
				   8=pink;9=black;10=white) */
{
/* C-- */
      int jy, kkcol;
/* Cbegin */


      switch (kc) {
         case 9  : kkcol = BY_PC_ID[10];
                   break;
         case 10 : kkcol = BY_PC_ID[14];
                   break;
         default : kkcol = BY_PC_ID[1+imin(8,imax(0,kc))];
      }


      XSetForeground ( VD_ID, GC_PH_ID, kkcol );
      XFlush ( VD_ID );

      jy = PHNY - ky;

      XDrawString ( VD_ID, WD_PH_ID, GC_PH_ID, kx, jy, text, kl );
      XDrawString ( VD_ID, PH_PIXMAP, GC_PH_ID, kx, jy, text, kl );
      XFlush ( VD_ID );


 }



/**********************************************************************
 D<a name="sxc_p_line"> SXC_P_LINE  </a>-- Put a line at a position (XWindows)

  alan penny             ral             1990 May
  pat morris             leeds        1992 jan
*/

dsxc_p_line ( xs, ys, xe, ye, kc )

    float   xs;		/* i: Line start X position(image pixels) */
    float   ys;		/* i: Line start Y position (image pixels) */
    float   xe;		/* i: Line end X position(image pixels) */
    float   ye;		/* i: Line end Y position (image pixels) */
    int     kc;		/* i: Colour (1=red;2=green;3=blue;4=yellow;
			              5=cyan;6=mauve;7=tan;8=pink)
			              9=black;10=white) */

/* C-- */
{
      int jxs, jxe, jys, jye, jysi, jyei;
/* Cbegin */


      PNSNY = F77_NAMED_COMMON(ds_panel).pnsny;

      (void) dsxc_p_setthecol ( kc );

      jxs = xs;
      jxe = xe;
      jys = ys;
      jye = ye;

      jysi = PNSNY - jys;
      jyei = PNSNY - jye;
      XDrawLine ( VD_ID,  WD_P_ID, GC_P_ID, jxs, jysi, jxe, jyei ); 	/* Paint line */
      XDrawLine ( VD_ID,  P_PIXMAP, GC_P_ID, jxs, jysi, jxe, jyei );
      XFlush ( VD_ID );


 }


/**************************************************************************
 D<a name="sxc_p_setthecol"> SXC_P_SETTHECOL  </a>-- Set writing colour for panel (XWindows)

  alan penny           ral                         1990-06-09
  pat morris             leeds        1992 Jan
*/

dsxc_p_setthecol ( kc )

int  kc;		/* i: Colour (1=red;2=green;3=blue;4=yellow;
				          5=cyan;6=mauve;7=tan;8=pink;
				          9=black;10=white) */
/* C-- */
{
      int kkcol;
/* Cbegin */


      (void) dsxc_p_scolnum ( kc, &kkcol );

      XSetForeground ( VD_ID, GC_P_ID, kkcol );
      XFlush ( VD_ID );


}


/***************************************************************************
 D<a name="sxc_p_scolnum"> SXC_P_SCOLNUM  </a>-- Calc panel colour pixel number from colour number (XWindows)

  alan penny             ral             1990 May
  pat morris             leeds        1992 Jan
*/

dsxc_p_scolnum ( kc, kkcol )

int   kc;		/* i: Colour number */
int   *kkcol;		/* o: Display colour pixel number */

/* C-- */
{
/* Cbegin */


      switch (kc) {
         case 9  : *kkcol = BY_PC_ID[10];
                   break;
         case 10 : *kkcol = BY_PC_ID[14];
                   break;
         default : *kkcol = BY_PC_ID[1+imin(8,imax(0,kc))];
      }


}



/**************************************************************************
 D<a name="sxc_p_hstat"> SXC_P_HSTAT  </a>-- Write status in the help panel box (XWindows)

    alan penny           ral                       1990-02-01
  pat morris             leeds        1992 Jan
*/

dsxc_p_hstat ( kin )

int   kin;		/* i: Work/Wait/Help/Command/Pan/Zoom/Not Yet/Ready/One Got/ */
			/*    (0/1/2/3/4/5/6/7/8) */
/* C-- */
{
      int kx, ky;
      static char *atext[9] = { "WORKING", "WAITING", "HELPING", "COMMAND",
                  "PANNING", "ZOOMING", "NOT YET", "READY  ", "ONE GOT" };
/* Cbegin */


      PDSOPEN = F77_NAMED_COMMON(ds_panelb).pdsopen;

      if ( (kin<0) || (kin>7) ) return;
      if ( !PDSOPEN ) return;

      kx = F77_NAMED_COMMON(ds_panel).pnhposx;
      ky = F77_NAMED_COMMON(ds_panel).pnhposy;
      kx = kx + 9;
      ky = ky + 24;

      if ( kin==1 )
         (void) dsxc_p_putim ( IG, 67, 16, kx, ky );
      else
         (void) dsxc_p_putim ( IR, 67, 16, kx, ky );

      (void) dsxc_p_puttxt ( atext[kin], 7, kx+3, ky+2, 9 );


}


/**************************************************************************
 D<a name="sxc_p_clear"> SXC_P_CLEAR  </a>-- Clear panel (XWindows)

    a j penny                    ral         1990 jan
*/

dsxc_p_clear ( kopt )

int     kopt;		/* i: panel or help panel (1:2)? */
/* C-- */
{
      int j, ks, nx, ny;
      char *ipd;
      XImage  *image;
/* Cbegin */


      if ( kopt==1 ) {
         nx = F77_NAMED_COMMON(ds_panel).pnsnx;
         ny = F77_NAMED_COMMON(ds_panel).pnsny;
      } else {
         nx = PHNX;
         ny = PHNY;
      }

      ks = (nx*ny)+1;
      ipd = calloc ( ks, sizeof(char) ); 				/* Set temp virtual screen */
      if ( ipd == NULL ) {
           if ( kopt==1 )
              (void) c_printo ("ERROR: P_CLEAR - Cant get workspace");
           else
              (void) c_printo ("ERROR: PH_CLEAR - Cant get workspace");
           return;
      }
      ( void ) dsxc_p_putcol ( ipd, ks, GL );

      image = XCreateImage( VD_ID, P_VISUAL, P_DEPTH, ZPixmap, 0, 	/* Point to image */
                            ipd, nx, ny, 8, nx );
			
      if ( kopt==1 ) {							/* Put image in pixmap and panel */
         XPutImage ( VD_ID, P_PIXMAP, GC_P_ID, image, 0, 0, 0, 0, nx, ny );
         XCopyArea ( VD_ID, P_PIXMAP, WD_P_ID, GC_P_ID, 0, 0, nx, ny, 0, 0 );
      }
      if ( kopt==2 ) {
         XPutImage ( VD_ID, PH_PIXMAP, GC_PH_ID, image, 0, 0, 0, 0, nx, ny );
         XCopyArea ( VD_ID, PH_PIXMAP, WD_PH_ID, GC_PH_ID, 0, 0, nx, ny, 0, 0 );
      }
								
      XDestroyImage ( image );
      XFlush ( VD_ID );
      free (ipd);


}


/**************************************************************************
 D<a name="sxc_p_putcol"> SXC_P_PUTCOL  </a>-- Put a colour into an array (XWindows)

    a j penny                    ral         1990 jan
*/

dsxc_p_putcol ( data, ks, col )

char   data[];		/* o: Array to load */
int    ks;		/* i: Size of array */
char   col;		/* i: Colour */
/* C-- */
{
      int j;
/* Cbegin */

      for ( j=0; j<ks; j++ )
          data[j] = col;							/* to light grey */



}


/**********************************************************************
 D<a name="sxc_p_hx_putim"> SXC_P_HX_PUTIM  </a>-- Put an image into help panel (XWindows)

    alan penny           ral                       1990-02-01
  pat morris             leeds        1992 Jan
*/

dsxc_p_hx_putim ( data, kxl, kyl, kx, ky )

char  *data;		/* i: Input data */
int   kxl;		/* i: X size of data */
int   kyl;		/* i: Y size of data */
int   kx;		/* i: X start of data position */
int   ky;		/* i: Y start of data position */
{
/* C-- */

      int xkx, xky;
      XImage  *image;
      char *ipd;
      int i;
/* Cbegin */


      PNSNY = F77_NAMED_COMMON(ds_panel).pnsny;

      ipd = malloc ( kxl*kyl );
      for ( i=0;i<kxl*kyl;i++ )
          ipd[i] = data[i];

      image = XCreateImage ( VD_ID, P_VISUAL, P_DEPTH, ZPixmap, 0, ipd,
                              kxl, kyl, 8, kxl );
									/* Point to image */
      XFlush ( VD_ID );
      xkx = kx - 1;
      xky = PNSNY - ky - kyl + 2;
      XPutImage ( VD_ID, PH_PIXMAP, GC_PH_ID, image, 0, 0, xkx,
                  xky, kxl, kyl );					/* Put image in pixmap */
      XCopyArea ( VD_ID, PH_PIXMAP, WD_PH_ID, GC_PH_ID,
			    xkx, xky, kxl, kyl, xkx, xky );		/* Put pixmap area on screen */

      XDestroyImage ( image );
      XFlush ( VD_ID );
      free (ipd);


}



/**********************************************************************
 D<a name="sxc_p_hx_load"> SXC_P_HX_LOAD  </a>-- Put help panel start information (XWindows)

    alan penny           ral                       1990-02-01
  pat morris             leeds        1992 Jan
*/

dsxc_p_hx_load ( title )

      char   *title;		/* i: Title of image */
{
/* C-- */
      static char *texta[6] = {
        "To execute a choice, click mouse with pointer in the panel button.",
        "To return from a choice, generally, click on mouse right-hand button.",
        "For guide to options displayed on buttons, click on HELP panel button.",
        "For help on individual options, position pointer on button, and a ",
        "    short help will automatically appear in the Panel Help window.",
        "(Usually cursor has to be in a relevant, ACTIVE, window.)" };

      int j, k, kl;
      char textb[200];
/* Cbegin */


      (void) dsxc_p_clear ( 2 );
      (void) dsxc_p_hx_putim ( XPM, PHNX, PHNY, 0, 0 );

      strcpy ( textb, "Help for:   " );
      strncat ( textb, title, 80 );
      XStoreName ( VD_ID, WD_PH_ID, textb );

      j = 86;
      for ( k=0; k<=5; k++ ) {
         strcpy ( textb, texta[k] );
         kl = strlen(textb);
         kl = imin(68,kl);

         (void) dsxc_p_hx_puttxt ( textb, kl, 5, j, 9 );
         j = j - 16;
      }


}


/**********************************************************************
 D<a name="sxc_p_hx_hload"> SXC_P_HX_HLOAD  </a>-- Put help panel information (XWindows)

    alan penny           ral                       1990-02-01
  pat morris             leeds        1992 Jan
*/

dsxc_p_hx_hload ( topt, thelp )

      char   *topt;		/* i: One line description of Option */
      char   *thelp;		/* i: Help text */
{
/* C-- */
      char texta[68];
      int k, ka;
/* Cbegin */


      (void) dsxc_p_clear ( 2 );
      (void) dsxc_p_hx_putim ( XPM, PHNX, PHNY, 0, 0 );

      XStoreName ( VD_ID, WD_PH_ID, topt );

      for ( k=1; k<=2; k++ ) {
          (void) aj_scpy ( texta, thelp, k );
          ka = 108 - (k-1)*15;
         (void) dsxc_p_hx_puttxt ( texta, 68, 5, ka, 9 );
      }
      for ( k=3; k<=8; k++ ) {
          (void) aj_scpy ( texta, thelp, k );
          ka = 115 - (k-1)*15;
         (void) dsxc_p_hx_puttxt ( texta, 68, 5, ka, 9 );
      }

      XSetForeground ( VD_ID, GC_PH_ID, BY_PC_ID[10] );
      XDrawLine ( VD_ID,  WD_PH_ID, GC_PH_ID, 0, 20, PHNX, 20 ); 	/* Paint line */
      XDrawLine ( VD_ID,  PH_PIXMAP, GC_PH_ID, 0, 20, PHNX, 20 );
      XFlush ( VD_ID );

}



/**********************************************************************
 A<a name="j_scpy"> J_SCPY  </a>-- Copy text

    alan penny           ral                       1990-02-01
*/

aj_scpy ( texta, textb, k )

      char   *texta;		/* i: One line description of Option */
      char   *textb;		/* i: Help text */
      int    k;			/* i: Row to copy (k=1-6) */
{
/* C-- */
      int j, ja;
/* Cbegin */


      for ( j=0; j<=67; j++ ) {
          ja = j + (k-1)*68;
          texta[j] = textb[ja];
      }
      texta[68] = '\0';

}
/***************************************************
 DSX_UTILC.C

  Contains-
-
 C_PRINTO    Print out text
 C_TYHELP    Put out help
 C_GCMDLST   Squeeze command list and get defaults
 C_GET1I     Get 1 integer from command line
 C_GET2I     Get 2 integers from command line
 C_GET1B     Get 1 Boolean from command line
-
*/


/* Include files */

#include <stdlib.h>
#include <string.h>


#if defined(vms)
#include "starman_x11_xlib"
#else
#include <X11/Xlib.h>
#include <malloc.h>
#endif

#include "f77.h"
#include "cnf.h"

#define Bool int

/* Fortran routines to be used */

extern void F77_EXTERNAL_NAME(printo)
    ( CHARACTER(c1_0) TRAIL(c1_0) );

DECLARE_CHARACTER(c1_0,2000);

extern void F77_EXTERNAL_NAME(tyhelp)
    ( CHARACTER_ARRAY(ca1_1), INTEGER(i1_1), CHARACTER(c2_1),
      INTEGER_ARRAY(ia1_1), INTEGER_ARRAY(ia2_1), INTEGER_ARRAY(ia3_1),
      INTEGER(i2_1) TRAIL(ca1_1) TRAIL(c2_1) );

DECLARE_CHARACTER_ARRAY(ca1_1,68,200);
DECLARE_CHARACTER(c2_1,10000);
DECLARE_INTEGER_ARRAY(ia1_1,200);
DECLARE_INTEGER_ARRAY(ia2_1,200);
DECLARE_INTEGER_ARRAY(ia3_1,200);
DECLARE_INTEGER(i1_1);
DECLARE_INTEGER(i2_1);

extern void F77_EXTERNAL_NAME(gcmdlst)
    ( CHARACTER(c1_2), CHARACTER(c2_2), INTEGER(i1_2), INTEGER(i2_2),
      INTEGER(i3_2), INTEGER(i4_2), INTEGER(i5_2), INTEGER(i6_2),
      INTEGER_ARRAY(ia1_2), INTEGER_ARRAY(ia2_2), INTEGER_ARRAY(ia3_2)
      TRAIL(c1_2) TRAIL(c2_2)  );

DECLARE_CHARACTER(c1_2,2000);
DECLARE_CHARACTER(c2_2,2000);
DECLARE_INTEGER(i1_2);
DECLARE_INTEGER(i2_2);
DECLARE_INTEGER(i3_2);
DECLARE_INTEGER(i4_2);
DECLARE_INTEGER(i5_2);
DECLARE_INTEGER(i6_2);
DECLARE_INTEGER_ARRAY(ia1_2,200);
DECLARE_INTEGER_ARRAY(ia2_2,200);
DECLARE_INTEGER_ARRAY(ia3_2,200);

extern void F77_EXTERNAL_NAME(get1i)
    ( CHARACTER(param_3), INTEGER(i1_3), INTEGER(i2_3), INTEGER(i3_3),
      INTEGER(i4_3) TRAIL(param_3) );

DECLARE_CHARACTER(param_3,512);
DECLARE_INTEGER(i1_3);
DECLARE_INTEGER(i2_3);
DECLARE_INTEGER(i3_3);
DECLARE_INTEGER(i4_3);

extern void F77_EXTERNAL_NAME(get2i)
    ( CHARACTER(param_4), INTEGER(i1_4), INTEGER(i2_4), LOGICAL(b1_4),
      INTEGER(i3_4), INTEGER(i4_4) TRAIL(param_4) );

DECLARE_CHARACTER(param_4,512);
DECLARE_INTEGER(i1_4);
DECLARE_INTEGER(i2_4);
DECLARE_INTEGER(i3_4);
DECLARE_INTEGER(i4_4);
DECLARE_LOGICAL(b1_4);

extern void F77_EXTERNAL_NAME(get1b)
    ( CHARACTER(param_5), LOGICAL(b1_5), LOGICAL(b2_5) TRAIL(param_5) );
DECLARE_CHARACTER(param_5,512);
DECLARE_LOGICAL(b1_5);
DECLARE_LOGICAL(b2_5);


DECLARE_CHARACTER(istr,2000);
DECLARE_CHARACTER(istra,10000);
DECLARE_CHARACTER(ostr,2000);


DECLARE_LOGICAL(b2);



/***********************************************************************
  <a name="c_printo"> C_PRINTO  </a>-- Buffers call to Fortran rountine printo  (Xwindows)

  Patrick Morris        leeds             1992 jan
*/

void c_printo ( text )

   char *text;
{
/* C-- */
/* Cbegin */

     cnf_exprt ( text, c1_0, c1_0_length );

     (void) F77_CALL(printo) ( CHARACTER_ARG(c1_0) TRAIL_ARG(c1_0) );

}


/**************************************************************************
 C<a name="_tyhelp"> _TYHELP  </a>-- Put out help

    a j penny                    ral         1990 jan
*/

c_tyhelp ( cca1, i1_1, cc2, ia1_1, ia2_1, ia3_1, i2_1 )

char* cca1;
char* cc2;

/* i: i: i: i: i: i: i: */
{
/* C-- */
/* Cbegin */


     cnf_exprt ( cca1, istra, istra_length );
     cnf_exprt ( cc2, istr, istr_length );

     (void) F77_CALL(tyhelp) ( CHARACTER_ARRAY_ARG(istra), INTEGER_ARG(&i1_1),
                               CHARACTER_ARG(istr), INTEGER_ARRAY_ARG(&ia1_1),
                               INTEGER_ARRAY_ARG(&ia2_1), INTEGER_ARRAY_ARG(&ia3_1),
                               INTEGER_ARG(&i2_1) TRAIL_ARG(istra) TRAIL_ARG(istra) );

}



/**************************************************************************
 C<a name="_gcmdlst"> _GCMDLST  </a>-- Squeeze command list and get defaults

    a j penny                    ral         1990 jan
*/

c_gcmdlst ( cc1, cc2, i1_2, i2_2, i3_2, i4_2, i5_2, i6_2, ia1_2, ia2_2,
            ia3_2 )

char* cc1;
char* cc2;
/* i: o: i: o: o: o: o: o: o: o: o: */
{
/* C-- */
/* Cbegin */


      cnf_exprt ( cc1, istr, istr_length );

      (void) F77_CALL(gcmdlst) ( CHARACTER_ARG(istr), CHARACTER_ARG(ostr),
                INTEGER_ARG(&i1_2), INTEGER_ARG(&i2_2), INTEGER_ARG(&i3_2),
                INTEGER_ARG(&i4_2),   INTEGER_ARG(&i5_2),  INTEGER_ARG(&i6_2),
                INTEGER_ARRAY_ARG(&ia1_2), INTEGER_ARRAY_ARG(&ia2_2),
                INTEGER_ARRAY_ARG(&ia3_2) TRAIL_ARG(istr) TRAIL_ARG(ostr) );
                             			
      cnf_imprt ( ostr, ostr_length, cc2 );

}


/**************************************************************************
 C<a name="_get1i"> _GET1I  </a>-- Get 1 integer from command line

    a j penny                    ral         1990 jan
*/

   c_get1i ( text, iv1, iv2, iv3, iv4 )

    char  *text;	/* i: */
    int   *iv1;		/* o: */
    int   iv2;		/* i: */
    int   iv3;		/* i: */
{
/* C-- */
/* Cbegin */

      cnf_exprt ( text, param_3, param_3_length );
      i2_3 = iv2; i3_3 = iv3; i4_3 = iv4;

      (void) F77_CALL(get1i) ( CHARACTER_ARG(param_3), INTEGER_ARG(&i1_3),
                               INTEGER_ARG(&i2_3), INTEGER_ARG(&i3_3),
                               INTEGER_ARG(&i4_3) TRAIL_ARG(param_3) );

      *iv1 = i1_3;
}


/**************************************************************************
 C<a name="_get2i"> _GET2I  </a>-- Get 2 integers from command line

    a j penny                    ral         1990 jan
*/

   c_get2i ( text, iv1, iv2, bv1, iv3, iv4 )

    char  *text;	/* i: */
    int   *iv1;		/* i/o: */
    int   *iv2;		/* i/o: */
    Bool  bv1;		/* i: */
    int   iv3;		/* i: */
    int   iv4;		/* i: */
{
/* C-- */

/* Cbegin */

         cnf_exprt ( text, param_4, param_4_length );
         if ( bv1 )
            b1_4 = F77_TRUE;
         else
            b1_4 = F77_FALSE;
         i1_4 = *iv1; i2_4 = *iv2; i3_4 = iv3; i4_4 = iv4;

         (void) F77_CALL(get2i) ( CHARACTER_ARG(param_4), INTEGER_ARG(&i1_4),
                 INTEGER_ARG(&i2_4), LOGICAL_ARG(&b1_4), INTEGER_ARG(&i3_4),
                 INTEGER_ARG(&i4_4) TRAIL_ARG(param_4) );

         *iv1 = i1_4; *iv2 = i2_4;

}


/**************************************************************************
 C<a name="_get1b"> _GET1B  </a>-- Get 1 Boolean from command line

    a j penny                    ral         1990 jan
*/

    c_get1b ( text, bout, bin )

    char   *text;	/* i: */
    Bool   *bout;	/* o: */
    Bool   bin;		/* i: */
{
/* C-- */
/* Cbegin */

        cnf_exprt ( text, param_5, param_5_length );
        if ( bin )
           b2_5 = F77_TRUE;
        else
           b2_5 = F77_FALSE;

        (void) F77_CALL(get1b) ( CHARACTER_ARG(param_5), LOGICAL_ARG(&b1_5),
                                 LOGICAL_ARG(&b2_5) TRAIL_ARG(param_5) );

        if ( b1_5==F77_TRUE )
           *bout = True;
        else
           *bout = False;

}
/********************************************************
  <a name="s_refresh"> s_refresh  </a>-- Refreshes  Starman X window when it is revealed

  pat morris                      Leeds             1993 Jan
*/


/*
**
**  INCLUDE FILES
**
*/

#include <stdio.h>
#include <stdlib.h>

#if defined(vms)
#include "starman_x11_xlib"
#include "starman_x11_xutil"
#else
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#endif

int main ( int argc, char *argv[] )

{
   Display *vd_id;
   Window  wd_id;
   Pixmap pixmap;
   GC gc_id;
   XGCValues xgcvl;
   XEvent event;
   Bool found, loop;
   unsigned int kx, ky;
   char display_name[100];

#if defined(vms)
      sscanf ( argv[0], "%d", &wd_id );
      sscanf ( argv[1], "%d", &pixmap );
#else
      sscanf ( argv[1], "%lu", &wd_id );
      sscanf ( argv[2], "%lu", &pixmap );
#endif

      sscanf ( argv[3], "%s", display_name );
      vd_id = XOpenDisplay ( display_name );
      XSelectInput ( vd_id, wd_id, StructureNotifyMask | SubstructureNotifyMask
                        | ExposureMask );
      gc_id = XCreateGC ( vd_id, wd_id, None, &xgcvl );
      loop = True;
      while ( loop )
      {

         XNextEvent ( vd_id, &event );
         kx = event.xexpose.width ;
         ky = event.xexpose.height ;
         switch ( event.type ) {
            case Expose:
               if ( kx > 0 && ky > 0 && event.xexpose.window==wd_id ) {
                XCopyArea ( vd_id, pixmap, wd_id, gc_id,
                      event.xexpose.x, event.xexpose.y, kx, ky,
                      event.xexpose.x, event.xexpose.y ) ;
                XFlush (vd_id);
               }
               break;
            case DestroyNotify :
                loop=False;
                break;
         }
       }
       XCloseDisplay (vd_id);
}
/* VT_GENC.C    Screen, image, virtual image transformations
-
  Includes:-
-
 VTC_TIS     Translate image to screen coords
 VTC_TSI     Translate screen to image coords
 VTC_TSV     Translate screen to virtual coords
 VTC_TVS     Translate virtual to screen coords
 VTC_TIV     Translate image to virtual coords
 VTC_TVI     Translate virtual to image coords
*/


#define Bool int
#include "f77.h"
#include "ds_gen.h"

extern int DSNXS, DSNYS ;
extern int DSCOMFX, DSCOMFY, DSIXS, DSIYS, DSSNX, DSSNY ;
extern int DSZM, DSZPX, DSZPY;

char TEXTAA[200];



/* ***************************************************************
  <a name="vtc_tis"> VTC_TIS  </a>-- Translate image cords to screen coords

    alan penny           ral                       1990-02-01
*/

vtc_tis ( kxi, kyi, kxo, kyo )

int    kxi;		/* i: Image X position */
int    kyi;		/* i: Image Y position */
int    *kxo;		/* o: Screen X position at b.l.h. of image pixel */
int    *kyo;		/* o: Screen Y position at b.l.h. of image pixel */
/* C-- */
{
      float x, y, xa, ya;
/* Cbegin */


      DSIXS = F77_NAMED_COMMON(ds_gen).dsixs;
      DSIYS = F77_NAMED_COMMON(ds_gen).dsiys;
      DSNXS = F77_NAMED_COMMON(ds_gen).dsnxs;
      DSNYS = F77_NAMED_COMMON(ds_gen).dsnys;
      DSZPX = F77_NAMED_COMMON(ds_gen).dszpx;
      DSZPY = F77_NAMED_COMMON(ds_gen).dszpy;
      DSCOMFX = F77_NAMED_COMMON(ds_gen).dscomfx;
      DSCOMFY = F77_NAMED_COMMON(ds_gen).dscomfy;
      DSZM = F77_NAMED_COMMON(ds_gen).dszm;

      x = (float) DSIXS + (float) (kxi-DSNXS) / (float) DSCOMFX;	/*Convert image to virtual */
      y = (float) DSIYS + (float) (kyi-DSNYS) / (float) DSCOMFY;

      xa = 1.0 + (float) DSZM * (x-(float) DSZPX);			/*Convert virtual to screen */
      ya = 1.0 + (float) DSZM * (y-(float) DSZPY);

      *kxo = (int) xa;
      *kyo = (int) ya;


/*
 (void) sprintf ( TEXTAA, " C TIS i: %d %d o: %d %d ", kxi, kyi, *kxo, *kyo );
 (void) c_printo ( TEXTAA );
*/


}


/* ***************************************************************
VT<a name="c_tsi"> C_TSI  </a>-- Translate screen coords to image coords

    alan penny           ral                       1990-02-01
*/

vtc_tsi ( kxi, kyi, kxo, kyo )

int   kxi;		/* i: Screen X position */
int   kyi;		/* i: Screen Y position */
int   *kxo;		/* o: Image X position */
int   *kyo;		/* o: Image Y position */
/* C-- */
{
      float x, y, xa, ya;
/* Cbegin */


      DSIXS = F77_NAMED_COMMON(ds_gen).dsixs;
      DSIYS = F77_NAMED_COMMON(ds_gen).dsiys;
      DSSNY = F77_NAMED_COMMON(ds_gen).dssny;
      DSNXS = F77_NAMED_COMMON(ds_gen).dsnxs;
      DSNYS = F77_NAMED_COMMON(ds_gen).dsnys;
      DSZPX = F77_NAMED_COMMON(ds_gen).dszpx;
      DSZPY = F77_NAMED_COMMON(ds_gen).dszpy;
      DSCOMFX = F77_NAMED_COMMON(ds_gen).dscomfx;
      DSCOMFY = F77_NAMED_COMMON(ds_gen).dscomfy;
      DSZM = F77_NAMED_COMMON(ds_gen).dszm;

      x = (float) DSZPX + (float) (kxi-1) / (float) DSZM ;				/* Screen to virtual */
      y = (float) DSZPY + (float) (kyi-1) / (float) DSZM ;

      xa = (float) DSNXS + ( x - (float) DSIXS ) * (float) DSCOMFX ;	/* Virtual to image */
      ya = (float) DSNYS + ( y - (float) DSIYS ) * (float) DSCOMFY ;

      *kxo = (int) xa;
      *kyo = (int) ya;


/*
 (void) sprintf ( TEXTAA, " C TSI i: %d %d o: %d %d ", kxi, kyi, *kxo, *kyo );
 (void) c_printo ( TEXTAA );
*/


}


/* ***************************************************************
  <a name="vtc_tsv">  VTC_TSV  </a>-- Translate screen to virtual screen coords

    alan penny           ral                       1990-02-01
*/

vtc_tsv ( kxi, kyi, kxo, kyo )

int    kxi;		/* i: Screen X position */
int    kyi;		/* i: Screen Y position */
int    *kxo;		/* o: Virtual X position */
int    *kyo;		/* o: Virtual Y position */
/* C-- */
{
      float x, y;
/* Cbegin */


      DSSNY = F77_NAMED_COMMON(ds_gen).dssny;
      DSZPX = F77_NAMED_COMMON(ds_gen).dszpx;
      DSZPY = F77_NAMED_COMMON(ds_gen).dszpy;
      DSZM = F77_NAMED_COMMON(ds_gen).dszm;

      x = (float) DSZPX + (float) (kxi-1) / (float) DSZM ;
      y = (float) DSZPY + (float) (kyi-1) / (float) DSZM ;

      *kxo = (int) x;
      *kyo = (int) y;

/*
 (void) sprintf ( TEXTAA, " C TSV i: %d %d o: %d %d ", kxi, kyi, *kxo, *kyo );
 (void) c_printo ( TEXTAA );
*/


}


/* ***************************************************************
  <a name="vtc_tvs">  VTC_TVS  </a>-- Translate virtual to screen coords

    alan penny           ral                       1990-02-01
*/

vtc_tvs ( kxi, kyi, kxo, kyo )

int    kxi;		/* i: Virtual X position */
int    kyi;		/* i: Virtual Y position */
int    *kxo;		/* o: Screen X position at t.l.h. of image pixel */
int    *kyo;		/* o: Screen Y position at t.l.h. of image pixel */
/* C-- */
{
      float x, y;
/* Cbegin */


      DSSNY = F77_NAMED_COMMON(ds_gen).dssny;
      DSZPX = F77_NAMED_COMMON(ds_gen).dszpx;
      DSZPY = F77_NAMED_COMMON(ds_gen).dszpy;
      DSZM = F77_NAMED_COMMON(ds_gen).dszm;

      x = 1.0 + (float) DSZM * (float) (kxi-DSZPX) ;
      y = 1.0 + (float) DSZM * (float) (kyi-DSZPY);

      *kxo = (int) x;
      *kyo = (int) y;

/*
 (void) sprintf ( TEXTAA, " C TVS i: %d %d o: %d %d ", kxi, kyi, *kxo, *kyo );
 (void) c_printo ( TEXTAA );
*/


}


/* ***************************************************************
  <a name="vtc_tvi">  VTC_TVI  </a>-- Covert virtual coordinates to image ones

    alan penny           ral                       1993 March
*/

vtc_tvi ( kxi, kyi, kxo, kyo )

int    kxi;		/* i: Virtual X position */
int    kyi;		/* i: Virtual Y position */
int   *kxo;		/* o: Image X position */
int   *kyo;		/* o: Image Y position */
/* C-- */
{
  float x, y;
/* Cbegin */


      DSIXS = F77_NAMED_COMMON(ds_gen).dsixs;
      DSIYS = F77_NAMED_COMMON(ds_gen).dsiys;
      DSNXS = F77_NAMED_COMMON(ds_gen).dsnxs;
      DSNYS = F77_NAMED_COMMON(ds_gen).dsnys;
      DSCOMFX = F77_NAMED_COMMON(ds_gen).dscomfx;
      DSCOMFY = F77_NAMED_COMMON(ds_gen).dscomfy;

       x = (float) DSNXS + (float) ( kxi - DSIXS ) * (float) DSCOMFX ;
       y = (float) DSNYS + (float) ( kyi - DSIYS ) * (float) DSCOMFY ;

       *kxo = (int) x;
       *kyo = (int) y;

/*
 (void) sprintf ( TEXTAA, " C TVI i: %d %d o: %d %d ", kxi, kyi, *kxo, *kyo );
 (void) c_printo ( TEXTAA );
*/

}


/* ***************************************************************
  <a name="vtc_tiv">  VTC_TIV  </a>-- Covert image coordinates to virtual ones

    alan penny           ral                       1993 March
*/

vtc_tiv ( kxi, kyi, kxo, kyo )

int    kxi;		/* i: Image X position */
int    kyi;		/* i: Image Y position */
int    *kxo;		/* o: Virtual X position */
int    *kyo;		/* o: Virtual Y position */
/* C-- */
{
float x, y;
/* Cbegin */


      DSIXS = F77_NAMED_COMMON(ds_gen).dsixs;
      DSIYS = F77_NAMED_COMMON(ds_gen).dsiys;
      DSNXS = F77_NAMED_COMMON(ds_gen).dsnxs;
      DSNYS = F77_NAMED_COMMON(ds_gen).dsnys;
      DSCOMFX = F77_NAMED_COMMON(ds_gen).dscomfx;
      DSCOMFY = F77_NAMED_COMMON(ds_gen).dscomfy;

       x = (float) DSIXS + (float) ( kxi - DSNXS ) / (float) DSCOMFX ;
       y = (float) DSIYS + (float) ( kyi - DSNYS ) / (float) DSCOMFY ;

       *kxo = (int) x;
       *kyo = (int) y;

/*
 (void) sprintf ( TEXTAA, " C TIV i: %d %d o: %d %d ", kxi, kyi, *kxo, *kyo );
 (void) c_printo ( TEXTAA );
*/

}
/* DS_GEN.H */


extern struct
{
      F77_INTEGER_TYPE dscomfx;		/* Displayed X image compression factor to virtual image */
      F77_INTEGER_TYPE dscomfy;		/* Displayed Y image compression factor to virtual image */

      F77_INTEGER_TYPE dsnxs;           /* Displayed image blh pixel X true image pixel number */
      F77_INTEGER_TYPE dsnys;           /* Displayed image blh pixel Y true image pixel number */
      F77_INTEGER_TYPE dsnxe;           /* Displayed image trh pixel X true image pixel number */
      F77_INTEGER_TYPE dsnye;           /* Displayed image trh pixel X true image pixel number */

      F77_INTEGER_TYPE dsixs;           /* Displayed image blh pixel X virtual image position */
      F77_INTEGER_TYPE dsiys;           /* Displayed image blh pixel Y virtual image position */

      F77_INTEGER_TYPE dssnx;		/* Screen (and virtual image) X size */
      F77_INTEGER_TYPE dssny;		/* Screen (and virtual image) Y size */

      F77_INTEGER_TYPE dszm;		/* Screen zoom factor */
      F77_INTEGER_TYPE dstype;		/* Display type (2=vws_vaxstation;3=ikon;4=x11_dec) */

      F77_REAL_TYPE dsvmin;		/* Displayed image unscaled display min value */
      F77_REAL_TYPE dsvmax;		/* Displayed image unscaled display max value */
      F77_REAL_TYPE dscrsl;		/* Size of crosses to be painted */
      F77_INTEGER_TYPE dszpx;		/* X position in virtual image that is at tlh of screen */
      F77_INTEGER_TYPE dszpy;		/* Y position in virtual image that is at tlh of screen */

      F77_INTEGER_TYPE dswindx;		/* x min offset of window edge from screen edge (cms) */
      F77_INTEGER_TYPE dswindy;		/* y min offset of window edge from screen edge (cms) */
      F77_INTEGER_TYPE dswindxm;	/* max x min offset of window edge from screen edge (cms) */
      F77_REAL_TYPE dscurposx;		/* Cursor X screen position */
      F77_REAL_TYPE dscurposy;		/* Cursor Y screen position */
      F77_INTEGER_TYPE dskvrange;	/* image contrast scale got? (0=no;1=yes) */
      F77_INTEGER_TYPE dszoommax;	/* Maximum zoom the display allows*/
      F77_INTEGER_TYPE numxbuttons;	/* Number of buttons on mouse with X windows (2 or 3) */
} F77_NAMED_COMMON(ds_gen);


extern struct
{
      F77_LOGICAL_TYPE dswrap;		/* Displayed image wrap display values around min/max (t/f)? */
      F77_LOGICAL_TYPE dsscur;		/* Cursor started? */
      F77_LOGICAL_TYPE dsopen;		/* Display open? */
      F77_LOGICAL_TYPE dscurset;	/* Cursor placed? */
} F77_NAMED_COMMON(ds_genb);
/* DS_LUT.H */



extern struct
{
      F77_LOGICAL_TYPE lut_flipped;	/* Is LUT flipped? */
      F77_LOGICAL_TYPE lut_dum1;
      F77_LOGICAL_TYPE lut_dum2;
      F77_LOGICAL_TYPE lut_dum3;
} F77_NAMED_COMMON(lutbcom);

extern struct
{
      F77_INTEGER_TYPE lut_ends;              /* LUT end types (1=black/white;2=wh/bl;3=col/col;4=wrap  */
      F77_INTEGER_TYPE lut_stored;            /* Number of stored LUTs  */
      F77_REAL_TYPE    lut_val[3][150];       /* RGB arrays  */
      F77_INTEGER_TYPE lut_num;               /* Present LUT number  */
      F77_REAL_TYPE    lut_sc;                /* LUT scale  */
      F77_REAL_TYPE    lut_ze;                /* LUT zero  */
      F77_INTEGER_TYPE numddcol;	      /* No of colours in LUT  */
      F77_INTEGER_TYPE depth;		      /* No of memory planes  */
} F77_NAMED_COMMON(lutacom);

/* DS_PANEL.H */

extern struct
{
      F77_INTEGER_TYPE pnsnx;		/* Panel X size */
      F77_INTEGER_TYPE pnsny;		/* Panel Y size */
      F77_INTEGER_TYPE pnnum;		/* Panel number of options */
      F77_INTEGER_TYPE pnjcon[200];	/* Panel option order */
      F77_INTEGER_TYPE pnnrow;		/* Panel number of rows */
      F77_INTEGER_TYPE pnncol;		/* Panel number of columns */
      F77_INTEGER_TYPE pdstype;
      F77_INTEGER_TYPE pdnuml;		/* Panel option list code number -
					(which `option list' loaded at present) */
      F77_INTEGER_TYPE pnhposx;		/* Panel X location of help button */
      F77_INTEGER_TYPE pnhposy;		/* Panel Y location of help button */
      F77_INTEGER_TYPE pncposx;		/* Panel X location of command button */
      F77_INTEGER_TYPE pncposy;		/* Panel Y location of command button */
      F77_INTEGER_TYPE pnvposx;		/* Panel X location of Posn, Value box */
      F77_INTEGER_TYPE pnvposy;		/* Panel Y location of Posn, Value box */
      F77_INTEGER_TYPE pnnums[200];	/* Panel number of options (sections) */
      F77_INTEGER_TYPE pnx[200];	/* Panel X locations of buttons */
      F77_INTEGER_TYPE pny[200];	/* Panel Y locations of buttons */
      F77_INTEGER_TYPE pnbhposx;	/* Panel X location of button help button */
      F77_INTEGER_TYPE pnbhposy;	/* Panel Y location of button help button */
} F77_NAMED_COMMON(ds_panel);


extern struct
{
      F77_LOGICAL_TYPE dopanel;		/* Panel use? */
      F77_LOGICAL_TYPE dohpanel;	/* Help Panel use? */
      F77_LOGICAL_TYPE pdsopen;		/* Panel opened? */
      F77_LOGICAL_TYPE pds_dum1;	 /* Dummy to make up 4 */
} F77_NAMED_COMMON(ds_panelb);

/* DSX_GEN.H */

/* The largest screen that can be supported is one that is less
   than 1.5kx1.5k.

   The virtual arrays that are used, are filled up as X likes,
   that is the start is at [0,0] and at the top left hand of
   the picture.

   The three coordinate systems used are 'image' 'virtual' and
   'screen'. These all start at (1,1) from the bottom left hand.

  Thus in filling the virtual arrays and in any action writing
  to the screen, coordinates have to be transformed.

     screen x =  array x - 1
     screen y =  screen size - array y

*/

int       SC_ID;			/* Screen identifier */
Display   *VD_ID; 			/* Display identifier */
Window    WD_ID;			/* Window identifier */
Window    RW_ID;			/* Root window of screen identifier */
GC        GC_ID;			/* Graphic context identifier */
Colormap  CM_ID;			/* Default colour map identifier */
unsigned long int  PC_ID[256];		/* Colour indexes pointers */
XColor    COLOUR[256];			/* Colour index */
Pixmap    PIXMAP;			/* Image display pixmap */


Visual    *D_VISUAL;			/* Visual type */
char      BY_PC_ID[256];		/* Byte equivalents of PC_ID */
int       PID;

Bool      OWNCOL;			/* Use own colours in loading display LUT  */


/* DSX_PANEL.H */


extern Window      WD_P_ID;
extern char        XPM[500*500];	/* Panel area */


/* DS_GEN.H */

int   DSWINDX, DSWINDXM,   DSWINDY, DSZOOMMAX, DSTYPE, DSNXS, DSNYS,  DSKVRANGE;
int   DSNXE,      DSNYE,    DSCOMFX, DSCOMFY,    DSIXS,  DSIYS, DSSNX, DSSNY, NUMXBUTTONS;
int   DSZM,       DSZPX,     DSZPY;
float DSVMIN,    DSVMAX, DSCURPOSX, DSCURPOSY, DSCRSL;
Bool  DSWRAP,    DSSCUR,    DSOPEN,  DSCURSET;

/* DS_PANEL.H */

extern int PNSNX, PNSNY, PNNUM, PNNROW, PNNCOL, PDSTYPE, PDNUML, PNHPOSX, PNHPOSY;
extern int* PNJCON;
extern int* PNNUMS;
extern Bool DOPANEL, PDSOPEN, PDS_DUM1, PDS_DUM2;


/* VIRT.H */

#define MAXVIRT 1536*1536
      char      VT_IM[MAXVIRT];         /* Display virtual image */


/* IMAGE.H */

int NX, NY, INVAL;
float BS, BZ, RINVAL;
POINTER(IPIM);

/*
 LUT.H
					/* No of colours in LUT */
#define NUMDCOL 150
int   NUMDDCOL;				/* No of colours in display for LUT colours */
int   DEPTH;				/* No of memory planes */
extern int	LUT_STORED; 		/* Number of stored LUTs */
extern int	LUT_ENDS;		/* LUT end types (1=black/white;2=wh/bl;3=col/col;4=wrap */
extern int       LUT_NUM;		/* Present LUT number */
extern float     LUT_SC; 		/* LUT scale */
extern float     LUT_ZE;		/* LUT zero */
extern Bool      LUT_FLIPPED;		/* Is LUT flipped? */
/* DSX_LUT.H */

extern Display   *VD_ID; 		/* Display identifier */
extern Colormap  CM_ID;			/* Default colour map identifier */
extern unsigned long PC_ID[256];	/* Colour indexes pointers */
extern XColor    COLOUR[256];		/* Colours */

extern char      BY_PC_ID[256];		/* Byte equivalents of PC_ID */

extern Bool      OWNCOL;		/* Use own colours in loading display LUT  */

/* DSX_PANEL.H */


extern Display     *VD_P_ID;		/* Panel display identifier */
/*extern Colormap    CM_P_ID;		 Panel Default Colour map identifier */
/*extern unsigned long PC_P_ID[256];	 Panel Colour index identifiers */
/*extern XColor      P_COLOUR[256];	 Panel Colour index */

/* DS_GEN.H */

extern int DSWINDX,DSWINDXM,DSWINDY,DSZOOMMAX,DSTYPE,DSNXS,DSNYS,DSKVRANGE;
extern int DSNXE,DSNYE,DSCOMFX,DSCOMFY,DSIXS,DSIYS,DSSNX,DSSNY,NUMXBUTTONS;
extern int DSZM ,DSZPX ,DSZPY;
extern float DSVMIN, DSVMAX, DSCURPOSX, DSCURPOSY, DSCRSL;
extern Bool DSWRAP, DSSCUR, DSOPEN, DSCURSET;

/* DS_PANEL.H */

extern int PNSNX, PNSNY, PNNUM, PNNROW, PNNCOL, PDSTYPE,
           PDNUML, PNHPOSX, PNHPOSY;
extern int* PNJCON;
extern int* PNNUMS;
extern Bool DOPANEL, PDSOPEN;


/* LUT.H */

#define NUMDCOL 150		/* No of colours in LUT */
extern int   NUMDDCOL;		/* No of colours in display for LUT colours */
#define NLENT   25              /* 'Length' of a LUT storage table */
extern int   DEPTH;		/* No of memory planes */
/* DSX_GEN.H */

extern Display        *VD_ID; 		/* Display identifier */
extern char           BY_PC_ID[256]; 	/* Byte equivalents of PC_ID */
extern Colormap       CM_ID;		/* Panel Default Colour map identifier */
extern unsigned long  PC_ID[256];	/* Panel Colour index identifiers */
extern XColor         COLOUR[256];	 /*Panel Colour index */

extern Bool      OWNCOL;		/* Use own colours in loading display LUT  */


/* DSX_PANEL.H */


int         SC_P_ID;		/* Panel screen identifier */
Window      RW_P_ID;		/* Panel root window of screen identifier */
Window      WD_P_ID;		/* Panel window identifier */
GC          GC_P_ID;		/* Panel graphic context identifier */
XFontStruct *FT_P_ID;		/* Panel font identifier */
Pixmap      P_PIXMAP;		/* Panel image pixmap */
int         P_DEPTH;		/* No of planes of panel screen */
Visual      *P_VISUAL;

int         PID;

Window      WD_PH_ID;		/* Panel Help window identifier */
GC          GC_PH_ID;		/* Panel Help graphic context identifier */
Pixmap      PH_PIXMAP;		/* Panel Help image pixmap */
int         PHNX;
int         PHNY;

char        XPM[500*500];	/* Panel areas */
char        XPD[2000];
char        XPL[2000];
char        GL, GM, GD;
char        XDU[86*21];		/* Panel buttons */
char        XDD[86*21];
char        IR[67*16];
char        IG[67*16];
char        XDH[86*46];


/* DS_GEN.H */

extern int DSWINDX,DSWINDXM,DSWINDY,DSZOOMMAX,DSTYPE,DSNXS,DSNYS,DSKVRANGE;
extern int DSNXE,DSNYE,DSCOMFX,DSCOMFY,DSIXS,DSIYS,DSSNX,DSSNY,NUMXBUTTONS;
extern int DSZM ,DSZPX ,DSZPY;
extern float DSVMIN, DSVMAX, DSCURPOSX, DSCURPOSY, DSCRSL;
extern Bool DSWRAP, DSSCUR, DSOPEN, DSCURSET;

/* DS_PANEL.H */

int PNSNX, PNSNY, PNNUM, PNNROW, PNNCOL, PDSTYPE, PDNUML, PNHPOSX, PNHPOSY;
int* PNJCON;
int* PNNUMS;
Bool DOPANEL, PDSOPEN, PDS_DUM1, PDS_DUM2;


/******************************************************************
 LUT.H

  Color tables copyright Smithsonian Astrophysical Observatory 1989
*/

#define NUMDCOL 150			/* No of colours in LUT */
extern int   NUMDDCOL;			/* No of colours in display for LUT colours */

/* IMAGE.H */

extern int NX, NY, INVAL;
extern float BS, BZ, RINVAL;
extern POINTER(IPIM);

/****************************************
 IMAGE.H

*/

extern struct
{
      F77_INTEGER_TYPE  ipim;	 	/* Image pointer */
      F77_INTEGER_TYPE  nx;		/* Image X size */
      F77_INTEGER_TYPE  ny;		/* Image Y size */
      F77_REAL_TYPE     bs;		/* Image value scale */
      F77_REAL_TYPE     bz;		/* Image value zero */
      F77_INTEGER_TYPE  inval;		/* Image bad pixel value */
      F77_REAL_TYPE     rinval;		/* Image real bad pixel value */
} F77_NAMED_COMMON(imagecoma);

extern struct
{
      F77_CHARACTER_TYPE  imtitle[70];	/* Image title */
      F77_CHARACTER_TYPE  imtype[6];	/* Image type ('REAL':'INT':'SHORT') */
} F77_NAMED_COMMON(imagecomc);
/*
 LUT.H

  Color tables copyright Smithsonian Astrophysical Observatory 1989 */

#define LVX NUMDCOL

      int	LUTC_STORED; 		/* Number of stored LUTs */
      int	LUTC_ENDS;		/* LUT end types (1=black/white;2=wh/bl;3=col/col;4=wrap */
      float     LUTC_VAL[150][3];	/* RGB arrays */
      int       LUTC_NUM;		/* Present LUT number */
      float     LUTC_SC; 		/* LUT scale */
      float     LUTC_ZE;		/* LUT zero */

      Bool      LUTC_FLIPPED;		/* Is LUT flipped? */
/* VIRT.H */

#define MAXVIRT 1536*1536
      char      VT_IM[MAXVIRT];		/* Display virtual image */


</pre>

<HR>

<address>
<a href="http://ast.star.rl.ac.uk/dev/ajp_page.html">
Alan J Penny </a>
 - <a href="http://www.rl.ac.uk/rutherford.html">
 Rutherford Appleton Laboratory </a> (RAL) </address>
<i> a.j.penny@rl.ac.uk </i> -
<i> This page last modified: 1994 Oct 23  </i>

