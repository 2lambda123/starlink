<HTML><HEAD>
<TITLE> Source Code for
IMCALC
</TITLE>
</HEAD> <BODY>

<h1> Source Code for
IMCALC
</h1>

All rights reserved. &copy 1995 RAL. <i>Starlink</i> disclaimers and
conditions apply. <br>
<hr>

Go to the Starman <a href="source_top.html#imcalc_source_back"> Source Code </a> Page at the pointer to this page.
<hr>
Starman general purpose subroutines called by this program
can be found via the subroutine libraries and general
include files, pointed to at the top of the
<a href="source_top.html"> Source Code page. </a>
<hr>
Any include files are the end of the page. <p>
Subroutines for this program:- <p>

<a href="#imcalc">
imcalc  </a>  (Program) Create an image by calculations on other images       <br>
<a href="#t_imcalc">
t_imcalc  </a>  Do image calculations       <br>
<a href="#imca_sdef">
imca_sdef  </a>  Set up defaults       <br>
<a href="#imca_gcl">
imca_gcl  </a>  Get input and output info from the command line       <br>
<a href="#imca_outts">
imca_outts  </a>  Get output image type and scale       <br>
<a href="#imca_space">
imca_space  </a>  Get work space for line stack and line       <br>
<a href="#imca_polish">
imca_polish  </a>  Decode equation and sort into reverse Polish       <br>
<a href="#imca_eqnerr">
imca_eqnerr  </a>  Put out equation error       <br>
<a href="#imca_doit">
imca_doit  </a>  Combine the lines from the stack of images into one line       <br>
<a href="#imca_imdiff">
imca_imdiff  </a>  Get number of diff input images and point to stack       <br>
<a href="#imca_vardiff">
imca_vardiff  </a>  Get number of diff input variables and point to stack       <br>
<a href="#imca_loadr">
imca_loadr  </a>  Copy real image into a 3-D stack       <br>
<a href="#imca_loads">
imca_loads  </a>  Copy int*2 image into a 3-D stack       <br>
<a href="#imca_outlr">
imca_outlr  </a>  Load a line to the real output image       <br>
<a href="#imca_outls">
imca_outls  </a>  Load a line to the int*2 output image       <br>
<a href="#imca_sort">
imca_sort  </a>  Sort identifiers to alphabetical order       <br>

<HR>
<pre>

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="imcalc"> IMCALC  </a>-- (Program) Create an image by calculations on other images
C
C  alan penny                       ral                       1992 Dec

      subroutine imcalc ( ierradam )

      implicit none

      integer     ierradam           !o: ADAM error flag
C--
Cbegin

      call starman_start

      call t_imcalc

      call starman_end ( ierradam )


      end
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C T_IMCALC.F
C
C  Contains:-
C
C T_IMCALC      Do image maths
C IMCA_SDEF     Set up defaults
C IMCA_GCL      Get input and output info from the command line
C IMCA_OUTTS    Get output image type and scale
C IMCA_SPACE    Get work space for line stack and line
C IMCA_POLISH   Decode equation and sort into reverse Polish
C IMCA_EQNERR   Put out equation error
C IMCA_DOIT     Combine the lines from the stack of images into one line
C IMCA_IMDIFF   Get number of diff input images and point to stack
C IMCA_VARDIFF  Get number of diff input variables and point to stack
C IMCA_LOAD(RS) Copy image into a 3-D stack
C IMCA_OUTL(RS) Load a line to the output image
C IMCA_SORT     Sort identifiers to alphabetical order



CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="t_imcalc"> T_IMCALC  </a>-- Do image calculations
C
C  alan penny                  ral              1991 Dec

      subroutine t_imcalc ()

      implicit none
      include 'imcalc.inc'
      include 'STARMAN_INC'
C--
      integer k, kk, ierr
Cbegin

      call imca_sdef							!Set up defaults

      call imca_gcl							!Get input/output info
      if ( ST_FAILED ) return

      call imca_space							!Get work space
      if ( ST_FAILED ) return

      do k = 1, NYO

         if ( ANYIN ) then						!Load input images into stack
            do kk = 1, NZ
               if ( IMTY(kk).eq.'SHORT' ) then
                  call imca_loads ( %val(IP(kk)), NX(kk), NY(kk),
     +                              BS(kk), BZ(kk), INVALI(kk), k, kk,
     +                              %val(IPSTK), NXO, NZ )
               else
                  call imca_loadr ( %val(IP(kk)), NX(kk), NY(kk),
     +                              BS(kk), BZ(kk), RINVALI(kk), k, kk,
     +                              %val(IPSTK), NXO, NZ )
               endif
            enddo
         endif

         call imca_doit ( %val(IPSTK), NXO, NZ, K, OPCODE, NOPCODE, 	!Do the calculations
     +                    IMP, IMPV, VAR, CON, %val(ipl), KSEED, ierr )
         if ( ierr.ne.0 ) then
            ST_FAILED = .true.
            return
         endif

         if ( OUTTYPE.eq.'SHORT' ) then
            call imca_outls ( %val(ipl), %val(IPO), NXO, NYO, BSO,
     +                        BZO, INVALO, k )
         else
            call imca_outlr ( %val(ipl), %val(IPO), NXO, NYO, BSO,
     +                        BZO, RINVALO, k )
         endif

      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="imca_sdef"> IMCA_SDEF  </a>-- Set up defaults
C
C  alan penny                         RAL                1991 Dec

      subroutine imca_sdef ( )

      implicit none
      include 'imcalc.inc'
      include 'ST_LIMITS_INC'
C--
Cbegin


      IPL = 1
      IPSTK = 1

      NXO = 1
      NYO = 1

      ANYIN = .false.
      NZ = 1
      BSO = 1.0
      BZO = 0.0
      INVALO = INT_INVALSI
      RINVALO = INT_INVALR

      call azeroi ( IMP, 70 )						!Zero locators for images and varaibles
      call azeroi ( IMPV, 70 )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="imca_gcl"> IMCA_GCL  </a>-- Get input and output info from the command line
C
C  alan penny                         RAL                1991 Dec

      subroutine imca_gcl ( )

      implicit none
      include 'imcalc.inc'
      include 'STARMAN_INC'
C--
      integer k, ierr
      character title*50, texta*132, inim*3
Cbegin


      if ( ST_FAILED ) return

      call get1c ( 'EQN', texta, ' ', .false. )
      call lbgone ( texta )
      call charln ( texta, k )
      if ( k.eq.0 ) then
         call printo ( 'ERROR: Must have an equation' )
         ST_FAILED = .true.
         return
      endif
      EXPRS = texta

      call imca_polish ( EXPRS, OPCODE, NOPCODE, IMID, NIM,		!Translate it into reverse polish notation
     +                   IMP, VARID, NVAR, IMPV, CON, NCON, ierr )
      if ( ierr.ne.0 ) then						
         ST_FAILED = .true.
         return
      endif

      call imca_imdiff							!How many diff images?

      if ( .not.ANYIN ) then						!Get images
         NXO = 1
         NYO = 1
         call get2i ( 'NXY', NXO, NYO, .true., 1, 100000 )
      else
         do k = 1, NZ
            inim = 'IN'//IMTOT(k)(2:2)
            call opimzr ( inim, IP(k), NX(k), NY(k), IMTY(k), .false.,
     +                    ierr )
            if ( ierr.ne.0 ) then
               ST_FAILED = .true.
               return
            endif
            call gtimzd ( inim, IMTY(k), BS(k), BZ(k), INVALI(k),
     +                    RINVALI(k), texta, ierr)
            if ( ierr.ne.0 ) then
               ST_FAILED = .true.
               return
            endif
            if ( k.eq.1 ) then
               NXO = NX(k)
               NYO = NY(k)
               title = texta(1:50)
            else
               NXO = min(NXO,NX(k))
               NYO = min(NYO,NY(k))
            endif
         enddo
      endif

      call imca_vardiff							!How many diff variables?

      if ( NVARTOT.gt.0 ) then						!Get input variables
         do k = 1, NVARTOT		
            call get1r ( VARTOT(k), VAR(k), 0.0, -1.0e37, +1.0e37 )
         enddo
      endif

      KSEED = 1								!Random generator seed
      call uppcase ( EXPRS, texta )
      if ( index(texta,'RAN').ne.0 .or. index(texta,'GAUSS').ne.0 )
     +   then
         call get1i ( 'SEED', KSEED, 1234567891, 1200000001,
     +                        1400000001 )
         call ajseed ( KSEED )
      endif

      call imca_outts							!Output image type and scale

      call opimzw ( 'OUT', OUTTYPE, IPO, NXO, NYO, .true., ierr )	!Get output image
      if ( ierr.eq.1 ) then
         ST_FAILED = .true.
         return
      endif

      inim = 'IN'//IMTOT(1)(2:2)
      if ( ANYIN ) then
         call icopdes ( inim, 'OUT', ierr )
         if ( ierr.eq.1 ) then
            ST_FAILED = .true.
            return
         endif
      endif

      if ( .not.ANYIN ) title = 'Output from IMCALC' 			!Output image title
      call get1c  ( 'TITLE', title, title, .true. )
      call ptdesc ( 'OUT', 'TITLE', title )

      call ptdesr ( 'OUT', 'BSCALE', BSO )
      call ptdesr ( 'OUT', 'BZERO', BZO )
      if ( OUTTYPE.eq.'REAL' ) then
         call ptdesr ( 'OUT', 'INVAL', RINVALO )
      else
         call ptdesi ( 'OUT', 'INVAL', INVALO )
      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="imca_outts"> IMCA_OUTTS  </a>-- Get output image type and scale
C
C  alan penny                RAL                1991 Dec

      subroutine imca_outts ( )

      implicit none
      include 'imcalc.inc'
      include 'STARMAN_INC'
      include 'ST_LIMITS_INC'
C--
      integer k
      logical bv

      integer kopt, kinr, kins
      integer nth
      parameter ( nth=5 )
      character*68 th(nth)
      data th /
     + 'Are the output data ? :- ',
     + 'Option   Choice',
     + '------   --------',
     + 'Real     Real 32-bit numbers',
     + 'Short    Signed 16-bit integer '/
Cbegin


      if ( ST_FAILED ) return

      if ( ANYIN ) then
         kins = 0
         kinr = 0
         do k = 1, NZ
            if ( IMTY(k).eq.'REAL' .and. kinr.eq.0 ) kinr = k
            if ( IMTY(k).eq.'SHORT'.and. kins.eq.0 ) kins = k
         enddo
      endif

      call printo ( ' ' )
      call printo ( 'Default output image type is REAL' )
      if ( ANYIN ) then
         if ( kins.ne.0 .and. kinr.eq.0 ) then
            call printo ( 'All input images have SHORT type -' )
            call printo ( 'Perhaps you want to keep the SHORT type' )
         elseif ( kins.ne.0 .and. kinr.ne.0 ) then
            call printo ( 'Input images are a mixture of REAL and'//
     +                    ' SHORT type -' )
            call printo ( 'Perhaps you want to have SHORT type' )
         else
            call printo ( 'All input images have REAL type -' )
            call printo ( 'Perhaps you want to change to SHORT type' )
         endif
      else
         call printo ( 'Perhaps you want to have SHORT type' )
      endif
      OUTTYPE = 'REAL'
      call get_job ( 'OUTTYPE', 'real:short', kopt, 1, th, nth )
      if ( kopt.eq.2 ) OUTTYPE = 'SHORT'
      if ( ST_FAILED ) return

      if ( ANYIN ) then

         if ( OUTTYPE.eq.'SHORT' ) then
            call printo ( ' ' )
            call printo ( 'The pixel values are stored as 16-bit'//
     +                     ' integers, as ((value-BZERO)/BSCALE)' )
            call printo ( 'As these are integers in the range '//
     +                    ' -32765 to +32767,' )
            call printo ( 'you may wish to change the -scale and '//
     +                    'zero-,' )
            call printo ( 'either to prevent integer steps being'//
     +                    ' important, or to store big numbers' )
            call get1r ( 'BSCALE', BSO, BS(1), -1.0e10, 1.0e10 )
            call get1r ( 'BZERO', BZO, BZ(1), -1.0e10, 1.0e10 )
            if ( kins.ne.0 ) then
               INVALO = INVALI(kins)
            else
               INVALO = INT_INVALSI
            endif
         else
            if ( BS(1).ne.1.0 .or. BZ(1).ne.0.0 ) then
               call printo ( ' ' )
               call pargr ( BS(1) )
               call pargr ( BZ(1) )
               call printd ( 'Output BSCALE and BZERO are %f %f ' )
               call printo ( 'For REAL images like this 1.0 and 0.0'//
     +                       ' are often more sensible.' )
               call get1b ( 'BCHOICE', bv, .true. )
               if ( bv ) then
                  BSO = 1.0
                  BZO = 0.0
               else
                  BSO = BS(1)
                  BZO = BZ(1)
               endif
            endif
            if ( kinr.ne.0 ) then
               RINVALO = RINVALI(kinr)
            else
               RINVALO = INT_INVALR
            endif
         endif

      else

         if ( OUTTYPE.eq.'SHORT' ) then
            call printo ( ' ' )
            call printo ( 'The pixel values are stored as 16-bit'//
     +                     ' integers, as ((value-BZERO)/BSCALE)' )
            call printo ( 'As these are integers in the range '//
     +                    ' -32765 to +32767,' )
            call printo ( 'you may wish to change the -scale and '//
     +                    'zero-,' )
            call printo ( 'either to prevent integer steps being'//
     +                    ' important, or to store big numbers' )
            call get1r ( 'BSCALE', BSO, 1.0, -1.0e10, 1.0e10 )
            call get1r ( 'BZERO', BZO, 0.0, -1.0e10, 1.0e10 )
            INVALO = INT_INVALSI
         else
            BSO = 1.0
            BZO = 0.0
            RINVALO = INT_INVALR
         endif

      endif


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="imca_space"> IMCA_SPACE  </a>-- Get work space for line stack and line
C
C  alan penny                RAL                1991 Dec

      subroutine imca_space ( )

      implicit none
      include 'imcalc.inc'
      include 'STARMAN_INC'
C--
      integer ierr
Cbegin


      if ( .not.ANYIN ) then							!Work space for stack
         call gtwrkr ( 'STACK', 1, IPSTK, ierr )
         call azeror ( %val(IPSTK), 1 )
      else
         call gtwrkr ( 'STACK', NXO*NZ, IPSTK, ierr )
         call azeror ( %val(IPSTK), NXO*NZ )
      endif
      if ( ierr.ne.0 ) then
         ST_FAILED = .true.
         return
      endif

      call gtwrkr ( 'LINE', NXO, IPL, ierr )				!Work space for stack
      if ( ierr.ne.0 ) then
         ST_FAILED = .true.
         return
      endif


      end

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="imca_polish"> IMCA_POLISH  </a>-- Decode equation and sort into reverse Polish
C
C  alan penny                RAL                1991 Dec

      subroutine imca_polish ( exprs, opcode, noper, imid,
     +                         nim, imp, varid, nvar, impv, con,
     +                         ncon, ierr)

      implicit none

      character*132    exprs		!i: Equation to decode
      character*6      opcode(70)	!o: Polish stack of commands
      integer          noper		!o: No of operations
      character*2      imid(26)		!o: images identifiers
      integer          nim		!o: Number of different images
      integer          imp(70)		!o: Pointers to images
      character*1      varid(70)	!o: Variables identifiers
      integer          nvar		!o: Number of variable
      integer          impv(70)		!o: Pointers to variables
      real             con(70)		!o: Constants
      integer          ncon		!o: Number of constants
      integer          ierr		!o: Error flag (0=ok;bad 2=;3=;4=)
C--

      character in*133, numchr*132, test*7, testa*7,
     +          output*7, fin*2, fina*3
      integer j, k, tos, stk(0:132), symb(132), ll, ncin, nnum,
     +        nsymb, iok, isymb, ndiff, istat, jj
      real    const
      logical opnext, found, ischar, isnumb, issign, lmore, atend,
     +        thisok, isfile
      external ischar, isnumb, issign

      integer maxsym
      parameter ( maxsym=38 )

      integer numendoper
      parameter ( numendoper=7 )
      character*1 endoper(numendoper)

      character*7 oper(-3:maxsym), opsymb(-3:maxsym)
      integer opl(-3:maxsym), opr(-3:maxsym), l(-3:maxsym),
     +        prl(-3:maxsym), prr(-3:maxsym)

      data ( oper(j), opsymb(j), l(j), opl(j), opr(j), prl(j),		!Set up image of operators,
     +        prr(j),j=-3,10 ) /					! symbols and their priorities
     +  '       ', 'LDCON  ', 1, 0, 0, 10, 10,
     +  '       ', 'LDVAR  ', 1, 0, 0, 10, 10,
     +  '       ', 'LDIM   ', 2, 0, 0, 10, 10,
     +  '=      ', '=      ', 1, 1, 1,  0,  0,
     +  ')      ', ')      ', 1, 1, 0,  2, 10,
     +  '(      ', '(      ', 1, 0, 1, 10,  1,
     +  '-      ', '-      ', 1, 1, 1,  4,  4,
     +  '+      ', '+      ', 1, 1, 1,  4,  4,
     +  '**     ', '**     ', 2, 1, 1,  9,  6,
     +  '*      ', '*      ', 1, 1, 1,  5,  5,
     +  '/      ', '/      ', 1, 1, 1,  5,  5,
     +  ':      ', ':      ', 1, 1, 1,  2,  2,
     +  '-      ', 'NEG    ', 1, 0, 1,  8,  7,
     +  '+      ', 'POS    ', 1, 0, 1,  8,  7 /

      data ( oper(j), opsymb(j), l(j), opl(j), opr(j), prl(j),
     +        prr(j),j=11,20 ) /
     +  'SQRT(  ', 'SQRT(  ', 5, 0, 1, 10,  1,
     +  'EXP(   ', 'EXP(   ', 4, 0, 1, 10,  1,
     +  'LOG10( ', 'LOG10( ', 6, 0, 1, 10,  1,
     +  'LOG(   ', 'LOG(   ', 4, 0, 1, 10,  1,
     +  'SIN(   ', 'SIN(   ', 4, 0, 1, 10,  1,
     +  'COS(   ', 'COS(   ', 4, 0, 1, 10,  1,
     +  'TAN(   ', 'TAN(   ', 4, 0, 1, 10,  1,
     +  'ASIN(  ', 'ASIN(  ', 5, 0, 1, 10,  1,
     +  'ACOS(  ', 'ACOS(  ', 5, 0, 1, 10,  1,
     +  'ATAN(  ', 'ATAN(  ', 5, 0, 1, 10,  1 /

      data ( oper(j), opsymb(j), l(j), opl(j), opr(j), prl(j),
     +        prr(j),j=21,30 ) /
     +  'ATAN2( ', 'ATAN2( ', 6, 0, 1, 10,  1,
     +  'SINH(  ', 'SINH(  ', 5, 0, 1, 10,  1,
     +  'COSH(  ', 'COSH(  ', 5, 0, 1, 10,  1,
     +  'TANH(  ', 'TANH(  ', 5, 0, 1, 10,  1,
     +  'ABS(   ', 'ABS(   ', 4, 0, 1, 10,  1,
     +  'AINT(  ', 'AINT(  ', 5, 0, 1, 10,  1,
     +  'ANINT( ', 'ANINT( ', 6, 0, 1, 10,  1,
     +  'MOD(   ', 'MOD(   ', 4, 0, 1, 10,  1,
     +  'SIGN(  ', 'SIGN(  ', 5, 0, 1, 10,  1,
     +  'DIM(   ', 'DIM(   ', 4, 0, 1, 10,  1 /

      data ( oper(j), opsymb(j), l(j), opl(j), opr(j), prl(j),
     +       prr(j),j=31,maxsym ) /
     +  'MIN(   ', 'MIN(   ', 4, 0, 1, 10,  1,
     +  'MAX(   ', 'MAX(   ', 4, 0, 1, 10,  1,
     +  'XX     ', 'XX     ', 2, 0, 0, 10, 10,
     +  'YY     ', 'YY     ', 2, 0, 0, 10, 10,
     +  'CLIP(  ', 'CLIP(  ', 5, 0, 1, 10,  1,
     +  'GAUSS( ', 'GAUSS( ', 6, 0, 1, 10,  1,
     +  'RAN(   ', 'RAN(   ', 4, 0, 1, 10,  1,
     +  '%      ', '/      ', 1, 1, 1,  5,  5 /

      data endoper / '+', '-', '/', '*', ')', '=', ' ' /
Cbegin


      ierr = 0
      ncin = 0

      do k = 1, len(exprs)						!Remove embedded blanks
         if ( exprs(k:k).ne.' ' .and. ncin.lt.132  ) then		!Count no of characters
            ncin = ncin + 1
            in(ncin:ncin) = exprs(k:k)
         endif
      enddo

      exprs = in(1:ncin)						!Return the expression with blanks removed

      ncin = ncin + 1							!Append an '= ' operator to terminate the expression
      in(ncin:ncin) = '='

      nim = 0								!Initiallise counters
      nvar = 0
      ncon = 0
      k = 1
      j = 0

      opnext = .false.							!Indicates if an operator is expected next
									! first entity must not look like an operator

      lmore = .true.							!Loop thru OPLs until '='found
      do while ( lmore )
         found = .false.						!Search through the list of symbols to
         nsymb = -1							! identify which comes next
         do while ( nsymb.lt.maxsym .and. .not.found )
            nsymb = nsymb + 1
            if ( opnext.eqv.(opl(nsymb).eq.1) ) then			!Symbol is only valid if it looks like
               test = in(k:min(k+l(nsymb)-1,81))			! an operator or operand from the left, as appropriate
               call uppcase ( test, testa )
               if ( testa.eq.oper(nsymb) ) found = .true.
            endif
         enddo

         isfile = .false.
         if ( .not.found ) then						!If symbol was not found: -

            if ( opnext ) then						!Error if an operator expected
               ierr = 3
               call printo ( ' ' )
               call printo ( 'ERROR: Cant understand Equation - ' )
               call pargi ( k )
               call printd (
     +              'ERROR:   An Operator missing, at character: %d' )
               call printo (
     +              'ERROR:   - that is a plus, or a minus, etc')
               call imca_eqnerr ( exprs, k )
               return
            elseif ( in(k:k).eq.'!' ) then				!Is it marked as filename?

               nnum = 0			
               numchr = ' '						!extract contiguous characters

               ll = index(in(k+1:),'!')					!File name would end with an !
               if ( ll.eq.0 ) then
                  ierr = 3
                  call printo ( ' ' )
                  call printo ( 'ERROR: Cant understand Equation - ' )
                  call pargi ( k )
                  call printd (
     +              'ERROR:   An ! at character: %d marks start of' )
                  call printo (
     +              'ERROR:   filename - but there is no end !')
                  call imca_eqnerr ( exprs, k )
                  return
               elseif ( ll.eq.1 ) then
                  ierr = 3
                  call printo ( ' ' )
                  call printo ( 'ERROR: Cant understand Equation - ' )
                  call pargi ( k )
                  call printd (
     +              'ERROR:   An ! at character: %d marks start of' )
                  call printo (
     +              'ERROR:   filename - but only another ! follows')
                  call imca_eqnerr ( exprs, k )
                  return
               endif
               nnum = ll + 1
               numchr = in(k+1:k+ll-1)

               call file_is ( numchr(:nnum-2), isfile )			!Try to read this as a file
               if ( isfile ) then
                  thisok = .true.
                  nsymb = -1						
                  nim = nim + 1						!If it is a image, add name to image stack
                  fin(1:1) = 'I'
                  fin(2:2) = char(64+nim)
                  imid(nim) = fin
                  fina(1:2) = 'IN'
                  fina(3:3) = char(64+nim)
                  call file_par ( numchr(:nnum-2), fina, istat )
               endif

            else if ( (in(k:k).eq.'I' .or. in(k:k).eq.'i')		!If an operand was expected, it may be
     +                 .and. ischar(in(k+1:k+1)) ) then
               nsymb = -1						! a image, variable or const.
               nim = nim + 1						!If it is a image, add name to image stack
               imid(nim) = in(k:k+1)
            else if ( ischar(in(k:k)) ) then
               nsymb = -2						!If it is a variable, add name to variable stack
               nvar = nvar + 1
               varid(nvar) = in(k:k)
            else

               thisok = .false.

               nnum = 0							!Otherwise it may be a constant...
               numchr = ' '						! extract contiguous numerical characters

               atend = .false.						!Character may be part of a numerical constant
               ll = k - 1						! if it is 0..9 or '.'
               do while ( ll.lt.ncin .and. .not.atend )			! or if it is an 'e' following one of the above
                  ll = ll + 1						! or if it is a sign following an 'e'
                  if ( isnumb(in(ll:ll)) .or. (in(ll:ll).eq.'E') .or.
     +                 (in(ll:ll).eq.'E') .or.
     +                 (issign(in(ll:ll)).and.
     +               ((in(ll-1:ll-1).eq.'E').or.(in(ll-1:ll-1).eq.'E'))
     +               ) ) then
                     nnum = nnum + 1
                     numchr(nnum:nnum) = in(ll:ll)
                  else
                     atend = .true.					!End of number as soon as one of the above tests fails
                  endif
               enddo
               call chartor ( numchr(:nnum), const, iok )

               if ( iok.eq.0 .and. nnum.ne.0 ) then			!If successful, add constant to stack
                  thisok = .true.
                  ncon = ncon + 1
                  con(ncon) = const
                  nsymb = -3
                  l(nsymb) = nnum
               endif

               if ( .not.thisok ) then					!May be filename

                  nnum = 0						!Otherwise it may be a filename..
                  numchr = ' '						! extract contiguous characters

                  atend = .false.					!File name would end with an operator
                  ll = k - 1						
                  do while ( ll.lt.ncin .and. .not.atend )
                     ll = ll + 1
                     do jj = 1, numendoper
                        if ( in(ll:ll).eq.endoper(jj) ) atend = .true.
                     enddo
                     if ( .not.atend ) then
                        nnum = nnum + 1
                        numchr(nnum:nnum) = in(ll:ll)
                     endif
                  enddo

                  call file_is ( numchr(:nnum), isfile )			!Try to read this as a file
                  if ( isfile .and. nnum.ne.0 ) then
                     thisok = .true.
                     nsymb = -1						!
                     nim = nim + 1						!If it is a image, add name to image stack
                     fin(1:1) = 'I'
                     fin(2:2) = char(64+nim)
                     imid(nim) = fin
                     fina(1:2) = 'IN'
                     fina(3:3) = char(64+nim)
                     call file_par ( numchr(:nnum), fina, istat )
                  endif

               endif

               if ( .not.thisok ) then
                  ierr = 2						!Otherwise there is a bad operand error
                  call printo ( ' ' )
                  call printo ( 'ERROR: Cant understand Equation -' )
                  call pargi ( k )
                  call printd (
     +            'ERROR:   Operand missing or bad, at character: %d' )
                  call printo ( 'ERROR:   - that is a file, '//
     +                      'a parameter, a constant, or a variable' )
                  call printo (
     +            'ERROR:   - If file name, the file may not exist' )
                  call imca_eqnerr ( exprs, k )
                  return
               endif

            endif
         endif

         j = j + 1							!Put the identified symbol into the output
         symb(j) = nsymb						! array and move the input pointer to the
         if ( isfile ) then
            k = k + nnum
         else
            k = k + l(nsymb)						! next symbol
         endif

         opnext = opr(nsymb).ne.1					!Decide whether an operator or operand follows
         if ( opsymb(nsymb).eq.'=' ) lmore = .false.
      enddo

      call azeroi ( stk(0), j+1 )					!Zero operator stack for converting to reverse polish
      tos = 0
      isymb = 1
      noper = 0

      lmore = .true.
      do while ( lmore )
         lmore = .false.

         if ( index(oper(stk(tos)),'(').ne.0 .and.			!If the top of stack and input stream have
     +        oper(symb(isymb)).eq.')' ) then				! matching parentheses, cancel them

            if ( oper(stk(tos)).ne.'(' ) then				!If there is a function asssociated with the
 									! opening parenthesis then send it to the output stream

               output = opsymb(stk(tos))				!Remove the enclosed '(' from functions first
               output(index(output,'('):index(output,'(')) = ' '
               tos = tos - 1
               isymb = isymb + 1
             else
               tos = tos - 1
               isymb = isymb + 1
               lmore = .true.
             endif

         else if ( prr(stk(tos)).ge.prl(symb(isymb)) ) then		!If the symbol on the top of the stack has
            output = opsymb(stk(tos))					! a high enough priority, transfer it to
            tos = tos - 1						! the output stream
         else
            tos = tos + 1						!Otherwise, transfer the next symbol to the stack
            stk(tos) = symb(isymb)
            isymb = isymb + 1
            lmore = .true. 						!Return for next test
         endif

         if ( .not.lmore ) then

            if ( index(output,'(').ne.0 ) then				!If a bracket appears in the output,
               ierr = 4							! it results from unpaired parentheses
               call printo ( ' ' )
               call printo ( 'ERROR: ) missing from Equation -' )	! in the input expression...quit qith error
               call printo ( 'ERROR: '//exprs(1:70) )
               return
            elseif ( index(output,')').ne.0 ) then
               ierr = 4
               call printo ( 'ERROR: (  missing from Equation -' )
               call printo ( 'ERROR: '//exprs(1:70) )
               call printo ( ' ' )
               return
            endif

            if ( output.ne.'POS'.and.output.ne.':' ) then		!If there is some output, disregard it
               noper = noper + 1					! if it is unary + or a comma
               opcode(noper) = output
            endif

            if ( output.ne.'=' ) lmore = .true.				!Return for next symbol if not the end

         endif

      enddo

      if ( nim.ge.1 ) then						!If images or variables are referenced, sort
         call imca_sort ( imid, nim, imp, ndiff, symb )			! their names into alphabetical order and obtain
         nim = ndiff							! pointers to allow them to be accessed in their
      endif								! original order
      if ( nvar.ge.1 ) then
         call imca_sort ( varid, nvar, impv, ndiff, symb )
         nvar = ndiff
      endif


      end



CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="imca_eqnerr"> IMCA_EQNERR  </a>-- Put out equation error
C
C  alan penny                     RAL            1994 Jul

      subroutine imca_eqnerr ( exprs, k )

      implicit none

      character*(*)     exprs	!i: Equation
      integer           k	!i: Character where error is
C--
      character texto*90
Cbegin


      call printo ( 'ERROR:   Eqn: '//exprs(1:70) )
      texto(1:90) = 'ERROR:   Err: '
      if ( k.le.14 ) then
         texto(14+k:14+k+14) = '^ Here is error'
         call printo ( texto )
      elseif ( k.le.70 ) then
         texto(14+k-14:14+k) = 'Error is here ^'
         call printo ( texto )
      endif
      call printo ( ' ' )


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="imca_doit"> IMCA_DOIT  </a>-- Combine the lines from the stack of images into one line
C
C  alan penny                     RAL            1991 Dec

      subroutine imca_doit ( riml, nx, nz, ky, opcode, nopcode, imp,
     +                       impv, var, con, rimo, kseed, ierr )

      implicit none
      include 'ST_LIMITS_INC'

      integer      nx			!i: X size of input lines
      integer      nz			!i: Z size of input lines
      real         riml(nx,nz)		!i: Input lines
      integer      ky			!i: Y line in output image being done
      integer      nopcode		!i: Number of operations
      character*6  opcode(70)		!i: Code for operations
      integer      imp(70)		!i: Number of image in (i)th posn
      integer      impv(70)		!i: Number variable in (i)th posn
      real         var(26)		!i: Variables
      real         con(70)		!i: Constants
      real         rimo(nx)		!o: Output line
      integer      kseed		!i/o: Random number seed
      integer      ierr			!o: Error flag (0=ok;1=bad)
C--
      logical found, bad, more
      integer j, k, tos, numiim, nvar, ncon, ib, nop
      real    rv
      double precision s(0:132), a, b, c, dib, dvmin, dvmax, dv
      integer opwhich(70)

      integer nsymb
      parameter ( nsymb=37 )

      character opsymb(nsymb)*6						!Recognised operations
      data opsymb /
     + 'LDCON ', 'LDVAR ', 'LDIM  ', '=     ',
     + '-     ', '+     ', '**    ', '*     ', '/     ', 'NEG   ',
     + 'SQRT  ', 'EXP   ', 'LOG10 ', 'LOG   ', 'SIN   ', 'COS   ',
     + 'TAN   ', 'ASIN  ', 'ACOS  ', 'ATAN  ', 'ATAN2 ', 'SINH  ',
     + 'COSH  ', 'TANH  ', 'ABS   ', 'AINT  ', 'ANINT ', 'MOD   ',
     + 'SIGN  ', 'DIM   ', 'MIN   ', 'MAX   ', 'XX    ', 'YY    ',
     + 'CLIP  ', 'GAUSS ', 'RAN   ' /
Cbegin


      ierr = 0								!Failure flag

      dvmax = INT_MAXRR							!Set (dble precision) max and min vals
      dvmin = INT_MINRR

      do k = 1, nopcode							!Find `opcode' for each input operator
         found = .false.
         j = 0
         do while ( j.lt.nsymb .and. .not.found )
            j = j + 1
            if ( opcode(k).eq.opsymb(j) ) then
               opwhich(k) = j
               found = .true.
            endif
         enddo
         if ( .not.found ) then
            ierr = 1
            return
         endif
      enddo

      do j = 1, nx							!Do for all pixels in line

         tos = 0							!Initialise the arith, image,
         numiim = 0							! variable, constant stack pointers
         nvar = 0
         ncon = 0

         nop = 0							!Do the operations
         more = .true.
         bad = .false.

         do while ( nop.lt.nopcode .and. more )
            nop = nop + 1

            go to ( 101,102,103,104,105,106,107,108,109,110,111,112,
     +              113,114,115,116,117,118,119,120,121,122,123,124,
     +              125,126,127,128,129,130,131,132,133,134,135,136,
     +              137 ),
     +            opwhich(nop)

 101        continue
               tos = tos + 1						!Load constant on to stack
               ncon = ncon + 1
               s(tos) = con(ncon)
            go to 100
 102        continue
               tos = tos + 1						!Load variable onto stack
               nvar = nvar + 1
               s(tos) = var(impv(nvar))
            go to 100
 103        continue
               tos = tos + 1						!Load image pixel on to stack
               numiim = numiim + 1
               rv = riml(j,imp(numiim))
               if ( rv.ne.INT_INVALR ) then
                  s(tos) = rv
               else
                  bad = .true.
               endif
            go to 100
 104        continue
               dv = s(tos)						!=  : end of calculation
               if ( dv.ge.dvmax .or. dv.le.dvmin ) then
                  rimo(j) = INT_INVALR
               else
                  rimo(j) = dv
               endif
               more = .false.
            go to 100
 105        continue
               s(tos-1) = s(tos-1) - s(tos)				!- : subtract tos
               tos = tos - 1
            go to 100
 106        continue
               s(tos-1) = s(tos-1) + s(tos)				!+ : add tos
               tos = tos - 1
            go to 100
 107        continue
               a = s(tos-1)						!** : raise to power
               b = s(tos)
               if ( a.ge.0.0 ) then
                  c = a**b
               else
                  ib = nint(b)
                  dib = ib
                  if ( abs(dib-b).le.1.0d-7 ) then
                     c = a**ib
                  else
                     bad = .true.
                  endif
               endif
               tos = tos - 1
               s(tos) = c
            go to 100
 108        continue
               s(tos-1) = s(tos-1)*s(tos)				!* : multiply tos
               tos = tos - 1
            go to 100
 109        continue
               a = s(tos)						!/ : Divide tos
               if ( a.ne.0.0d0 ) then
                  s(tos-1) = s(tos-1)/a
                  tos = tos - 1
               else
                  bad = .true.
               endif
            go to 100
 110        continue
               s(tos) = -s(tos)						!NEG : Negate tos
            go to 100
 111        continue
              a = s(tos)						!SQRT : Square root tos
               if ( a.ge.0.0d0 ) then
                  s(tos) = sqrt(a)
               else
                  bad = .true.
               endif
            go to 100
 112        continue
               a = s(tos)						!EXP : E to power tos
               if ( a.le.100.0d0 ) then
                  s(tos) = exp(a)
               else
                  bad = .true.
               endif
            go to 100
 113        continue
               a = s(tos)						!LOG10 : Log tos base 10
               if ( a.gt.0.0d0 ) then
                  s(tos) = log10(a)
               else
                  bad = .true.
               endif
            go to 100
 114        continue
               a = s(tos)						!LOG : Natural log of tos
               if ( a.gt.0.0d0 ) then
                  s(tos) = log(a)
               else
                  bad = .true.
               endif
            go to 100
 115        continue
               s(tos) = sin(s(tos))					!SIN : Sine of tos
            go to 100
 116        continue
               s(tos) = cos(s(tos))					!COS : Cosine of tos
            go to 100
 117        continue
               a = s(tos)						!TAN : Tangent of tos
               s(tos) = tan(a)
            go to 100
 118        continue
            a = s(tos)							!ASIN : Arcsine of tos
               if ( abs(a).le.1.0d0 ) then
                  s(tos) = asin(a)
               else
                  bad = .true.
               endif
            go to 100
 119        continue
               a = s(tos)						!ACOS : Arccosine of tos
               if ( abs(a).le.1.0d0 ) then
                  s(tos) = acos(a)
               else
                  bad = .true.
               endif
            go to 100
 120        continue
               s(tos) = atan(s(tos))					!ATAN : Arctangent of tos
            go to 100
 121        continue
               a = s(tos-1)						!ATAN2 : Arctangent of tos ratio
               b = s(tos)
               if ( a.ne.0.0d0 .or. b.ne.0.0d0 ) then
                  tos = tos - 1
                  s(tos) = atan2(a,b)
               else
                  bad = .true.
               endif
            go to 100
 122        continue
               a = s(tos)						!SINH : Hyperbolic sine of tos
               if ( abs(a).le.100.0d0 ) then
                  s(tos) = sinh(a)
               else
                  bad = .true.
               endif
            go to 100
 123        continue
               a = s(tos)						!COSH : Hyperbolic cosine of tos
               if ( abs(a).le.100.0d0 ) then
                  s(tos) = cosh(a)
               else
                  bad = .true.
               endif
            go to 100
 124        continue
               s(tos) = tanh(s(tos))					!TANH : Hyperbolic tangent of tos
            go to 100
 125        continue
               s(tos) = abs(s(tos)) 					!ABS : Absolute value of tos
            go to 100
 126        continue
               s(tos) = aint(s(tos))					!AINT : Truncate tos
            go to 100
 127        continue
               s(tos) = anint(s(tos))					!ANINT : Nearest integer to tos
            go to 100
 128        continue
               a = s(tos-1)						!MOD : Modulo on two tos entries
               b = s(tos)
               if ( b.ne.0.0d0 ) then
                  tos = tos - 1
                  s(tos) = mod(a,b)
               else
                  bad = .true.
               endif
            go to 100
 129        continue
               s(tos-1) = sign(s(tos-1),s(tos))				!SIGN : Transfer of sign between two tos entries
               tos = tos - 1
            go to 100
 130        continue
               s(tos-1) = dim(s(tos-1),s(tos))				!DIM : Positive difference of two tos entries
               tos = tos - 1
            go to 100
 131        continue
              s(tos-1) = min(s(tos-1),s(tos))				!MIN : Minimum of two tos entries
               tos = tos - 1
            go to 100
 132        continue
               s(tos-1) = max(s(tos-1),s(tos))				!MAX : Maximum of two tos entries
               tos = tos - 1
            go to 100
 133        continue
               tos = tos + 1						!XX : X position in output image
               s(tos) = j
            go to 100
 134        continue
               tos = tos + 1						!YY : Y position in output image
               s(tos) = ky
            go to 100
 135        continue
               a = s(tos-2)						!CLIP : Abort if tos lies outside window
               b = s(tos-1)
               c = s(tos)
               if ( a.le.b .and. b.le.c ) then
                  tos = tos - 2
                  s(tos) = b
               else
                  bad = .true.
               endif
            go to 100
 136        continue
               call gasdev ( rv, kseed )				!GAUSS : Put gaussian noise on tos
               s(tos) = s(tos)*dble(rv)
            go to 100
 137        continue
               call rano ( rv, kseed )					!RAN : Uniform random noise
               s(tos) = s(tos)*dble(rv)
            go to 100
 100        continue

            if ( bad ) then						!Invalid arithmetic operation done
               rimo(j) = INT_INVALR
               more = .false.
            endif

         enddo

      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="imca_imdiff"> IMCA_IMDIFF  </a>-- Get number of diff input images and point to stack
C
C  alan penny                         RAL                1991 Dec

      subroutine imca_imdiff ( )

      implicit none
      include 'imcalc.inc'
C--
      integer j, kk
      character ch*2
      logical found
Cbegin


      NZ = 0

      if ( NIM.ne.0 ) then
         do j = 1, NIM
            if ( NZ.eq.0 ) then
               NZ = 1
               IMTOT(NZ) = IMID(j)(1:2)
            else
               found = .false.
               ch = IMID(j)(1:2)
               do kk = 1, NZ
                  if ( ch.eq.IMTOT(kk) ) found = .true.
               enddo
               if ( .not.found ) then
                  NZ = NZ + 1
                  IMTOT(NZ) = IMID(j)(1:2)
               endif
            endif
         enddo
      endif

      if ( NZ.ne.0 ) then
         ANYIN = .true.
      else
         ANYIN = .false.
         NZ = 1
      endif

      do j = 1, 70
         if ( IMP(j).ne.0 ) then
            ch = IMID(IMP(j))(1:2)
            do kk = 1, NZ
               if ( ch.eq.IMTOT(kk) ) IMP(j) = kk
            enddo
         endif
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="imca_vardiff"> IMCA_VARDIFF  </a>-- Get number of diff input variables and point to stack
C
C  alan penny                         RAL                1991 Dec

      subroutine imca_vardiff ( )

      implicit none
      include 'imcalc.inc'
C--
      integer j, kk
      character ch*1
      logical found
Cbegin


      NVARTOT = 0

      if ( NVAR.ne.0 ) then
         do j = 1, NVAR
            if ( NVARTOT.eq.0 ) then
               NVARTOT = 1
               VARTOT(NVARTOT) = VARID(j)(1:1)
            else
               found = .false.
               ch = VARID(j)(1:1)
               do kk = 1, NVARTOT
                  if ( ch.eq.VARTOT(kk) ) found = .true.
               enddo
               if ( .not.found ) then
                  NVARTOT = NVARTOT + 1
                  VARTOT(NVARTOT) = VARID(j)(1:1)
               endif
            endif
         enddo
      endif

      do j = 1, 70
         if ( IMPV(j).ne.0 ) then
            ch = VARID(IMPV(j))(1:1)
            do kk = 1, NVARTOT
               if ( ch.eq.VARTOT(kk) ) IMPV(j) = kk
            enddo
         endif
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="imca_loadr"> IMCA_LOADR  </a>-- Copy real image into a 3-D stack
C
C  alan penny                 ral                     1991 Dec

      subroutine imca_loadr ( im, nx, ny, bs, bz, rinvali, jn, jzn,
     +                        rim, nxo, nz )

      implicit none
      include 'ST_LIMITS_INC'

      integer     nx			!i: X size of input image
      integer     ny			!i: Y size of input image
      real        im(nx,ny)		!i: Input image
      real        bs			!i: Scale of input image
      real        bz			!i: Zero of input image
      real        rinvali		!i: Invalid flag of input image
      integer     jn			!i: Y line of input image to take
      integer     jzn			!i: Z line to put it in
      integer     nxo			!i: X size of stack line
      integer     nz			!i: Z size of stack line
      real        rim(nxo,nz)		!i/o: stack image of a line
C--
      integer k
      real    rv
Cbegin


      do k = 1, nxo
         rv = im(k,jn)
         if ( rv.eq.rinvali ) then
            rim(k,jzn) = INT_INVALR
         else
            rim(k,jzn) = bs*rv + bz
         endif
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="imca_loads"> IMCA_LOADS  </a>-- Copy int*2 image into a 3-D stack
C
C  alan penny                 ral                     1991 Dec

      subroutine imca_loads ( im, nx, ny, bs, bz, invali, jn, jzn,
     +                        rim, nxo, nz )

      implicit none
      include 'ST_LIMITS_INC'

      integer     nx			!i: X size of input image
      integer     ny			!i: Y size of input image
      integer*2   im(nx,ny)		!i: Input image
      real        bs			!i: Scale of input image
      real        bz			!i: Zero of input image
      integer     invali		!i: Invalid flag of input image
      integer     jn			!i: Y line of input image to take
      integer     jzn			!i: Z line to put it in
      integer     nxo			!i: X size of stack line
      integer     nz			!i: Z size of stack line
      real        rim(nxo,nz)		!i/o: stack image of a line
C--
      integer k, kv
Cbegin


      do k = 1, nxo
         kv = im(k,jn)
         if ( kv.eq.invali ) then
            rim(k,jzn) = INT_INVALR
         else
            rim(k,jzn) = bs*real(kv) + bz
         endif
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="imca_outlr"> IMCA_OUTLR  </a>-- Load a line to the real output image
C
C  alan penny            ral                     1991 Dec

      subroutine imca_outlr  ( rimi, rimo, nx, ny, bs, bz, rinval, kl )

      implicit none
      include 'ST_LIMITS_INC'

      integer    nx		!i: length of line (= X size of output)
      integer    ny		!i: Y Size of output
      real       rimi(nx)	!i: Line
      real       rimo(nx,ny)	!o: Output image
      real       bs             !i: Image scale
      real       bz             !i: Image zero
      real       rinval         !i: Image invalid flag
      integer    kl             !i: Y Line to load
C--
      integer j
      real rv
Cbegin


      do j = 1, nx
         rv = rimi(j)
         if ( rv.eq.INT_INVALR ) then
            rimo(j,kl) = rinval
         else
            rv = (rv-bz)/bs
            if ( rv.lt.INT_MINRR .or. rv.gt.INT_MAXRR ) then
               rimo(j,kl) = rinval
            else
               rimo(j,kl) = rv
            endif
         endif
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="imca_outls"> IMCA_OUTLS  </a>-- Load a line to the int*2 output image
C
C  alan penny            ral                     1991 Dec

      subroutine imca_outls  ( rim, imo, nx, ny, bs, bz, inval, kl )

      implicit none
      include 'ST_LIMITS_INC'

      integer    nx		!i: length of line (= X size of output)
      integer    ny		!i: Y Size of output
      real       rim(nx)	!i: Line
      integer*2  imo(nx,ny)	!o: Output image
      real       bs             !i: Image scale
      real       bz             !i: Image zero
      integer    inval          !i: Image invalid flag
      integer    kl             !i: Y Line to load
C--
      integer j
      real rv
Cbegin


      do j = 1, nx
         rv = rim(j)
         if ( rv.eq.INT_INVALR ) then
            imo(j,kl) = inval
         else
            rv = (rv-bz)/bs
            if ( rv.lt.INT_MINSR .or. rv.gt.INT_MAXSR ) then
               imo(j,kl) = inval
            else
               imo(j,kl) = rv
            endif
         endif
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C <a name="imca_sort"> IMCA_SORT  </a>-- Sort identifiers to alphabetical order
C
C  alan penny            ral                     1991 Dec

      subroutine imca_sort ( c, nc, imp, ndiff, iw )

      implicit none

      integer        nc		!i: Number of identifiers
      character*(*)  c(nc)	!i/o: Identiers
      integer        imp(nc)	!o: pointer to identifier place in stack
      integer        ndiff	!o: Number of different identifiers
      integer        iw(nc)	!o: Work space
C--
      integer k, nn, it
      character*132 text
      logical repeat
Cbegin


      ndiff = 1								!Only 1?
      iw(1) = 1
      imp(1) = 1
      if ( nc.le.1 ) return

      nn = min(132,len(c(1)))						!Length of input strings

      do k = 1, nc							!Initiallise pointers in workspace
         iw(k) = k
      enddo

      repeat = .true.							!Perform a bubble sort to put
      do while ( repeat ) 						! character strings into alphabetical order
         repeat = .false.
         do k = 1, nc-1
            if ( c(k+1).lt.c(k) ) then
               repeat = .true.
               text(:nn) = c(k+1)					!Swap pairs which are in the wrong order
               c(k+1) = c(k)
               c(k) = text(:nn)
               it = iw(k+1)						!Permute the pointers in the same way
               iw(k+1) = iw(k)
               iw(k) = it
            endif
         enddo
      enddo

      ndiff = 1								!Pointers now point to original positions. scan list to
      imp(iw(1)) = 1							! remove repeated entries and reverse the pointing direction
      do k = 2, nc
         if ( c(k).ne.c(ndiff) ) then					!If a different character string is found, count it and
            ndiff = ndiff + 1						! put it in the correct place in the list
            c(ndiff) = c(k)
         endif
         imp(iw(k)) = ndiff						!Set the appropriate output pointer to its new location
      enddo


      end


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C IMCALC.INC     for IMCALC.FOR
C

      character*132 exprs		!Input Equation
      character*6   opcode(70)		!(i)th operation in stack
      character*1   varid(70)		!Identifiers of input variables
      character*2   imid(26)		!Identifiers of input images
      character*6   imty(26)		!Types (SHORT,REAL) of input images
      character*2   imtot(26)		!List of all unique image names
      character*1   vartot(26)		!List of all unique variable names
      character*6   outtype		!Output image type (REAL,SHORT)

      integer       ip(26)		!Pointer to input images
      integer       ipo			!Pointer to output image
      integer       nx(26)		!X size of input images
      integer       ny(26)		!Y size of input images
      integer       nz			!Number of different input images
      integer       nxo			!X size of output image
      integer       nyo			!Y size of output image
      integer       imp(70)		!Number of image to use for (i)th op in stack
      integer       impv(70)		!Number of Variable to use for (i)th op in stack
      integer       nim			!Number of input images mentioned
      integer       nvar		!Number of input variables mentioned
      integer       ncon		!Number of constants mentioned
      integer       nopcode		!Number of operations in stack
      integer       nvartot		!Total number of input variables
      integer       kseed		!Random number generator seed
      integer       invali(26)		!Invalid flags for int*2 input images
      real          rinvali(26)		!Invalid flags for real input images
      integer       invalo		!Invalid flag for int*2 output image
      real          rinvalo		!Invalid flag for real output image
      integer       ipstk		!Pointer to working stack
      integer       ipl			!Pointer to lines stack

      real          var(26)		!Input variables
      real          con(70)		!Constant to use for (i)th op in stack
      real          bs(26)		!Scales for input images
      real          bz(26)		!Zeroes for input images
      real          bso			!Scale for output image
      real          bzo			!Zeroe for output image

      logical       anyin		!Any input images?

      logical    imca_dum1		!4*n logicals
      logical    imca_dum2
      logical    imca_dum3


      common / imcalca /  nvartot,    nx,    ny,     nz,   imp,
     +                    nopcode,   con,  ncon,    nyo,   nxo,
     +                      kseed,   ipo,    ip,    nim,  nvar,
     +                       impv,   var,    bs,     bz,   bso,
     +                     invali, invalo,  bzo,  ipstk,   ipl,
     +                    rinvali, rinvalo

      common /imcalcb / anyin,   imca_dum1,  imca_dum2, imca_dum3

      common / imcalcc / exprs,  opcode,  imid,  varid,  imtot,
     +                   vartot, imty,  outtype


</pre>

<HR>

<address>
<a href="http://ast.star.rl.ac.uk/dev/ajp_page.html">
Alan J Penny </a>
 - <a href="http://www.rl.ac.uk/rutherford.html">
 Rutherford Appleton Laboratory </a> (RAL) </address>
<i> a.j.penny@rl.ac.uk </i> -
<i> This page last modified: 1994 Oct 23  </i>

