C+
      SUBROUTINE GEN_ASTATE (ARRAY,QDATA, NX,NY, IXST,IXEN,IYST,IYEN,
     :           TOTAL,AMAX,AMIN,MEAN,XMAX,XMIN,YMAX,YMIN,SIGMA,SIZE, 
     :           QUAL, FLAGS, FBAD)
C
C     G E N _ A S T A T E
C
C     Examines a subset of a 2-dimensional array and returns a number
C     of statistics about the data in it. Quality or flagged values
C     are used to indicate bad pixels. If there is no good data
C     in the subset selected, SIZE returns zero and the other
C     parameters are undefined.
C
C     Parameters -  (">" input, "<" output)
C
C     (>) ARRAY   (Real array ARRAY(NX,NY)) The input array.
C     (>) QDATA   (Byte array QDATA(NX,NY)) The input Quality data.
C     (>) NX      (Integer) The first (x) dimension of ARRAY.
C     (>) NY      (Integer) The second (y) dimension of ARRAY.
C     (>) IXST    (Integer) The first x-value of the subset.
C     (>) IXEN    (Integer) The last    "     "   "    "
C     (>) IYST    (Integer) The first y-value "   "    "
C     (>) IYEN    (Integer) The last    "     "   "    "
C     (<) TOTAL   (Real) The total data in the subset.
C     (<) AMAX    (Real) The maximum value in the subset.
C     (<) AMIN    (Real) The minimum   "   "   "   "
C     (<) MEAN    (Real) The mean      "   "   "   "
C     (<) XMAX    (Real) ) These four quantities return the positions
C     (<) XMIN    (Real) ) in x and y (ie the values of the array indices)
C     (<) YMAX    (Real) ) at which the maximum and minimum data values
C     (<) YMIN    (Real) ) were found.
C     (<) SIGMA   (Real) The standard deviation of the data in the subset
C     (<) SIZE    (Real) The number of pixels in the subset (this is
C                 not necessarily that implied by IXST,IYST etc, if these
C                 parameters would take the subset outside the array
C                 bounds.  SIZE is the number of pixels actually examined.
C     (>) QUAL    (Logical)    True if input has quality information
C     (>) FLAGS   (Logical)    True if input has flagged data values
C     (>) FBAD    (Real)       Flag value
C
C                                               KS / CIT  6th March 1983
C     Modified:
C
C     19th March 1987.  KS / AAO. Double precision now used for total values 
C                       in the internal calculations.
C     Modified:
C
C     17th Nov  1990  PRB / ROE.  Modified from GEN_ASTAT 
C     to handle quality and flagged values on data.
C+
      IMPLICIT NONE
C
C     Parameters
C
      INTEGER NX,NY,IXST,IXEN,IYST,IYEN
      REAL TOTAL,AMAX,AMIN,MEAN,XMAX,XMIN,YMAX,YMIN
      REAL SIGMA, SIZE, FBAD
      REAL ARRAY(NX*NY)
      BYTE QDATA(NX*NY)
      LOGICAL QUAL, FLAGS
C
C          (Slightly more efficient than (NX,NY) in terms of code
C           generated by the compiler.)
C
C     Local variables
C
      INTEGER NXST,NYST,NXEN,NYEN,IX,IY,IPTR,IPBASE
      REAL    VALUE
      DOUBLE PRECISION TOTALDP,TOTSQ
C
C     Quality values defined symbolically
C
      BYTE GOOD
      PARAMETER (GOOD = 0)
C
C     FMIN, FMAX close to floating point limits
C
      REAL FMIN, FMAX
      PARAMETER (FMAX=1.0E+36, FMIN=1.0E-36)
C
C     Check array limits
C
      NXST=MAX(1,IXST)
      NYST=MAX(1,IYST)
      NXEN=MIN(NX,IXEN)
      NYEN=MIN(NY,IYEN)
      SIZE=0.0
C
C     Initial values
C
      IPBASE=(NYST-1)*NX+NXST
      AMAX=FMIN
      AMIN=FMAX
      TOTALDP=0.
      TOTSQ=0.
      XMIN=NXST
      XMAX=NXST
      YMIN=NYST
      YMAX=NYST
C
C     Pass through data
C
C     Handle different quality methods separately...
C
      IF (QUAL) THEN
C
C       Use quality information
C
        DO IY=NYST,NYEN
           IPTR=IPBASE
           DO IX=NXST,NXEN
              IF (QDATA(IPTR).EQ.GOOD) THEN
                 VALUE=ARRAY(IPTR)
                 SIZE=SIZE+1.0
                 IF (VALUE.LT.AMIN) THEN
                   AMIN=VALUE
                   XMIN=IX
                   YMIN=IY
                 END IF
                 IF (VALUE.GT.AMAX) THEN
                   AMAX=VALUE
                   XMAX=IX
                   YMAX=IY
                 END IF
                 TOTALDP=TOTALDP+VALUE
                 TOTSQ=TOTSQ+VALUE*VALUE
              END IF ! (qdata(ix).eq.good)
              IPTR=IPTR+1
           END DO
           IPBASE=IPBASE+NX
        END DO
C
      ELSEIF (FLAGS) THEN
C
C       Use flagged values
C
        DO IY=NYST,NYEN
           IPTR=IPBASE
           DO IX=NXST,NXEN
              VALUE=ARRAY(IPTR)
             IF (VALUE.NE.FBAD) THEN
                  SIZE=SIZE+1.0
                 IF (VALUE.LT.AMIN) THEN
                   AMIN=VALUE
                   XMIN=IX
                   YMIN=IY
                 END IF
                 IF (VALUE.GT.AMAX) THEN
                   AMAX=VALUE
                   XMAX=IX
                   YMAX=IY
                 END IF
                 TOTALDP=TOTALDP+VALUE
                 TOTSQ=TOTSQ+VALUE*VALUE
              END IF ! (qdata(ix).ne.fbad)
              IPTR=IPTR+1
           END DO
           IPBASE=IPBASE+NX
        END DO
        ELSE
C
C       data has no quality information
C
        SIZE=FLOAT(NXEN-NXST+1)*FLOAT(NYEN-NYST+1)
C
        DO IY=NYST,NYEN
           IPTR=IPBASE
           DO IX=NXST,NXEN
              VALUE=ARRAY(IPTR)
              IPTR=IPTR+1
              IF (VALUE.LT.AMIN) THEN
                 AMIN=VALUE
                 XMIN=IX
                 YMIN=IY
              END IF
              IF (VALUE.GT.AMAX) THEN
                 AMAX=VALUE
                 XMAX=IX
                 YMAX=IY
              END IF
              TOTALDP=TOTALDP+VALUE
              TOTSQ=TOTSQ+VALUE*VALUE
           END DO
           IPBASE=IPBASE+NX
        END DO
C
      END IF ! (Quality or Flagged values)
C
      IF (SIZE.GT.0.0) MEAN=SNGL(TOTALDP/DBLE(SIZE))
      TOTAL=SNGL(TOTALDP)
C
C     Calculate sigma 
C
      IF (SIZE.GT.1.0) THEN
         SIGMA=SQRT(ABS((TOTSQ-(TOTALDP*TOTALDP)/SIZE)/(SIZE-1.0)))
      ELSE 
         SIGMA=0.0
      ENDIF
C
      END
