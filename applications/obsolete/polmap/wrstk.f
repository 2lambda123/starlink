      SUBROUTINE WRSTK(CPARAM,STK_NPTS,STK_STOKES_I,STK_STOKES_Q,
     &                STK_STOKES_QV,STK_STOKES_U,
     &                STK_STOKES_UV,STK_LAMBDA,STK_TITLE,TOP_STK,OUT_LU)
C+
C
C Subroutine:
C
C    W R S T K
C
C
C Author: Tim Harries (tjh@st-and.ac.uk)
C
C Parameters:
C
C CPARAM (<), STK_NPTS (<), STK_STOKES_I (<), STK_STOKES_Q (<),
C STK_STOKES_QV (<), STK_STOKES_U (<),
C STK_STOKES_UV (<), STK_LAMBDA (<), STK_TITLE (<), TOP_STK (<),
C OUT_LU (<)
C
C History:
C
C   May 1994 Created
C
C
C
C
C
C This routine writes out a polarization spectrum into a TSP format file
C
C
C
C-
C
      IMPLICIT NONE
      INTEGER OUT_LU
C
C HDS includes
C
      INCLUDE 'SAE_PAR'
      INCLUDE 'DAT_PAR'
      INCLUDE 'array_size.inc'
C
C The stack arrays
C
      INTEGER STK_NPTS(MAXSPEC)
      REAL STK_STOKES_I(MAXPTS,MAXSPEC)
      REAL STK_STOKES_Q(MAXPTS,MAXSPEC)
      REAL STK_STOKES_QV(MAXPTS,MAXSPEC)
      REAL STK_STOKES_U(MAXPTS,MAXSPEC)
      REAL STK_STOKES_UV(MAXPTS,MAXSPEC)
      REAL STK_LAMBDA(MAXPTS,MAXSPEC)
      INTEGER TOP_STK
C
C Misc.
C
      INTEGER SP
      INTEGER X
      CHARACTER*(*) CPARAM
      CHARACTER*80 PATH,STK_TITLE(MAXSPEC)
C
C
      INTEGER UBND(2),LBND(2),NDFO,NDFQ,NDFU,QPTR,NDFN,NPTR
C
      INTEGER NDFA,APTR
      INTEGER UPTR,QVPTR,UVPTR,PLACE
      INTEGER NELM,IPTR
C
C
      CHARACTER*(DAT__SZLOC) PLOC,LOC
      INTEGER STATUS
C
      STATUS = SAI__OK
C
C Add the .sdf if necessary
C
      CALL SSTRIP(CPARAM)
      SP = INDEX(CPARAM,' ')
      SP = SP-1
      PATH = CPARAM(:SP)
      IF ( PATH((SP-3):SP).NE.'.sdf') THEN
       PATH = PATH(1:SP)//'.sdf'
      ENDIF
      LBND(1) = 1
      LBND(2) = 1
      UBND(1) = MAXPTS
      UBND(2) = TOP_STK
      NELM = MAXPTS*MAXSPEC
C
C Start up the ndf and hds
C
      CALL NDF_BEGIN
      CALL HDS_START(STATUS)
C
C Create a new ndf structure and map arrays
C
      CALL HDS_NEW(PATH,'STACK','NDF',0,0,LOC,STATUS)
      CALL DAT_NEW(LOC,'DATA_ARRAY','_REAL',2,UBND,STATUS)
      CALL NDF_IMPRT(LOC,NDFO,STATUS)
      CALL NDF_XNEW(NDFO,'POLARIMETRY','EXT',0,0,PLOC,STATUS)
      CALL NDF_PLACE(PLOC,'STOKES_Q',PLACE,STATUS)
      CALL NDF_NEW('_REAL',2,LBND,UBND,PLACE,NDFQ,STATUS)
      CALL NDF_PLACE(PLOC,'STOKES_U',PLACE,STATUS)
      CALL NDF_NEW('_REAL',2,LBND,UBND,PLACE,NDFU,STATUS)
      CALL NDF_PLACE(PLOC,'NPTS',PLACE,STATUS)
      CALL NDF_NEW('_INTEGER',1,1,TOP_STK,PLACE,NDFN,STATUS)
      CALL NDF_PLACE(PLOC,'LAMBDA',PLACE,STATUS)
      CALL NDF_NEW('_REAL',2,LBND,UBND,PLACE,NDFA,STATUS)
      CALL CMP_MOD(PLOC,'TITLES','_CHAR*80',1,TOP_STK,STATUS)

      CALL NDF_MAP(NDFO,'DATA','_REAL','WRITE',IPTR,NELM,STATUS)
      CALL NDF_MAP(NDFQ,'DATA','_REAL','WRITE',QPTR,NELM,STATUS)
      CALL NDF_MAP(NDFU,'DATA','_REAL','WRITE',UPTR,NELM,STATUS)
      CALL NDF_MAP(NDFQ,'VARIANCE','_REAL','WRITE',QVPTR,NELM,STATUS)
      CALL NDF_MAP(NDFU,'VARIANCE','_REAL','WRITE',UVPTR,NELM,STATUS)
      CALL NDF_MAP(NDFN,'DATA','_INTEGER','WRITE',NPTR,X,STATUS)
      CALL NDF_MAP(NDFA,'DATA','_REAL','WRITE',APTR,NELM,STATUS)
      CALL CMP_PUTVC(PLOC,'TITLES',TOP_STK,STK_TITLE,STATUS)
C
C Write out the stack if everything was OK
C
      IF (STATUS.EQ.SAI__OK) THEN
      CALL WRITE_STK(STK_NPTS,STK_LAMBDA,STK_STOKES_I,STK_STOKES_Q,
     &      STK_STOKES_QV,STK_STOKES_U,STK_STOKES_UV,
     &TOP_STK,%VAL(NPTR),%VAL(APTR),%VAL(IPTR),%VAL(QPTR),
     &%VAL(QVPTR),%VAL(UPTR),%VAL(UVPTR))
      ENDIF
C
C Annul the locators and quit
C
      CALL DAT_ANNUL(PLOC,STATUS)
      CALL NDF_END(STATUS)
      CALL HDS_CLOSE(LOC,STATUS)
      CALL HDS_STOP(STATUS)
      END
