*+SORT_CRE_ASTERIX - Create an ASTERIX structure (and write history)
	SUBROUTINE SORT_CRE_ASTERIX(OLOC, SRT, STATUS)
	IMPLICIT NONE

	INCLUDE 'SORT_DEF.INC'
	INCLUDE 'CONSTANTS.INC'
        include 'DAT_PAR'

* Input
	CHARACTER*(DAT__SZLOC) OLOC		! Locator to IMDS file
	RECORD /SORT_DEF/ SRT

* Output
	INTEGER		STATUS
* M Denby
* P McGale Apr 95
*-

* Local variables:
	INTEGER   	LOOP		! Loop counter
	INTEGER		NW
	INTEGER		MX_LASTPC, NC

	REAL		TOT

	REAL*8		DURTN(10000)
	REAL*8		POS_ANGLE
	REAL*8		SLA_DAT, STAI

	CHARACTER*(DAT__SZLOC)  	MOR
	CHARACTER*(DAT__SZLOC)  	AST
	CHARACTER*(DAT__SZLOC)  	HEA
	CHARACTER*(DAT__SZLOC)  	LIV
	CHARACTER*(DAT__SZLOC)  	PRO
	CHARACTER*(DAT__SZLOC)  	COR
	CHARACTER*(DAT__SZLOC)  	PSF
	CHARACTER*(DAT__SZLOC)  	INS
	CHARACTER*(DAT__SZLOC)  	SOR

	CHARACTER*20	SDATE

	EXTERNAL	SLA_DAT

*   Check status - return if bad
	IF (STATUS .NE. 0) RETURN

*   Create the MORE box.
	CALL DAT_NEW (OLOC, 'MORE', 'EXTENSION', 0, 0, STATUS)
	CALL DAT_FIND(OLOC, 'MORE', MOR,	  	 STATUS)

*   Create the ASTERIX structure.
	CALL DAT_NEW (MOR, 'ASTERIX', 'EXTENSION', 0, 0,   STATUS)
	CALL DAT_FIND(MOR, 'ASTERIX',  AST,	    	   STATUS)

*   Create the HEADER component.......
	CALL DAT_NEW  (AST, 'HEADER', 'EXTENSION', 0, 0,  STATUS)

	CALL DAT_FIND (AST, 'HEADER',  HEA,	     STATUS)
	CALL DAT_NEWC (HEA, 'TARGET',	40, 0, 0,    STATUS)
	CALL DAT_NEWC (HEA, 'OBSERVER',    40, 0, 0, STATUS)
	CALL DAT_NEWC (HEA, 'OBSERVATORY', 40, 0, 0, STATUS)
	CALL DAT_NEWC (HEA, 'INSTRUMENT',  40, 0, 0, STATUS)
	CALL DAT_NEW  (HEA, 'AXIS_RA',   '_DOUBLE', 0, 0, STATUS)
	CALL DAT_NEW  (HEA, 'AXIS_DEC',  '_DOUBLE', 0, 0, STATUS)
	CALL DAT_NEW  (HEA, 'FIELD_RA',  '_DOUBLE', 0, 0, STATUS)
	CALL DAT_NEW  (HEA, 'FIELD_DEC', '_DOUBLE', 0, 0, STATUS)
	CALL DAT_NEW  (HEA, 'EQUINOX', '_INTEGER', 0, 0,  STATUS)
	CALL DAT_NEW  (HEA, 'POSITION_ANGLE', '_DOUBLE', 0, 0, STATUS)
	CALL DAT_NEWC (HEA, 'BASE_DATE',   11, 0, 0, STATUS)
	CALL DAT_NEW  (HEA, 'BASE_MJD', '_INTEGER', 0, 0, STATUS)
	CALL DAT_NEW  (HEA, 'BASE_UTC', '_DOUBLE', 0, 0, STATUS)
	CALL DAT_NEW  (HEA, 'BASE_TAI', '_DOUBLE', 0, 0, STATUS)
	CALL DAT_NEW  (HEA, 'OBS_LENGTH', '_REAL', 0, 0, STATUS)

	CALL CMP_PUT0C(HEA, 'TARGET',	   SRT.TARG, STATUS)
	CALL CMP_PUT0C(HEA, 'OBSERVER',    SRT.OBSR, STATUS)
	CALL CMP_PUT0C(HEA, 'OBSERVATORY', SRT.OBSY, STATUS)
	CALL CMP_PUT0C(HEA, 'INSTRUMENT',  SRT.INST, STATUS)

	CALL AX_MJDDAT(SRT.SMJD, SDATE)
	CALL CMP_PUT0C(HEA, 'BASE_DATE', SDATE(1:11), STATUS)
	CALL CMP_PUT0D(HEA, 'BASE_UTC',
     :		(SRT.SMJD - INT(SRT.SMJD))*86400.D0,  STATUS)

	CALL CMP_PUT0D(HEA,'AXIS_RA', DBLE(SRT.ARA/DTOR),   STATUS)
	CALL CMP_PUT0D(HEA,'AXIS_DEC',DBLE(SRT.ADEC/DTOR),  STATUS)
	CALL CMP_PUT0D(HEA,'FIELD_RA',DBLE(SRT.FRA/DTOR),   STATUS)
	CALL CMP_PUT0D(HEA,'FIELD_DEC',DBLE(SRT.FDEC/DTOR), STATUS)
	CALL CMP_PUT0I(HEA, 'EQUINOX', 2000, STATUS)


	POS_ANGLE = MOD(DBLE(TWOPI - SRT.ROLL), DBLE(TWOPI))
	IF (POS_ANGLE .LT. -PI) POS_ANGLE = POS_ANGLE + TWOPI
	IF (POS_ANGLE .GT.  PI) POS_ANGLE = POS_ANGLE - TWOPI

	CALL CMP_PUT0D(HEA, 'POSITION_ANGLE', POS_ANGLE/DTOR, STATUS)
	CALL CMP_PUT0I(HEA, 'BASE_MJD', INT(SRT.SMJD),        STATUS)

	STAI = SRT.SMJD + ((SLA_DAT(SRT.SMJD) - 32.184D0) /
     :						86400.D0) - 41317.D0
	CALL CMP_PUT0D(HEA, 'BASE_TAI', STAI,	  STATUS)
	CALL CMP_PUT0R(HEA, 'OBS_LENGTH',
     :		REAL((SRT.EMJD - SRT.SMJD)*86400.D0),     STATUS)

*    Create and write PROCESSING structure
	CALL DAT_NEW  (AST, 'PROCESSING',  'EXTENSION', 0, 0, STATUS)
	CALL DAT_FIND (AST, 'PROCESSING',  PRO,	    	      STATUS)
	CALL DAT_NEW  (PRO, 'BGND_SUBTRACTED', '_LOGICAL', 0, 0, STATUS)
	CALL CMP_PUT0L(PRO, 'BGND_SUBTRACTED', .FALSE.,       STATUS)
	CALL DAT_NEW  (PRO, 'CORRECTED', 'EXTENSION', 0, 0,   STATUS)
	CALL DAT_FIND (PRO, 'CORRECTED', COR,		STATUS)
	CALL DAT_NEW  (COR,  'DEAD_TIME', '_LOGICAL', 0, 0, STATUS)
	CALL CMP_PUT0L(COR,  'DEAD_TIME', .FALSE.,	STATUS)
	CALL DAT_NEW  (COR,  'VIGNETTING', '_LOGICAL', 0, 0, STATUS)
	CALL CMP_PUT0L(COR,  'VIGNETTING', .FALSE.,	STATUS)

*   Create and write PSF structure......
	CALL DAT_NEW  (AST, 'PSF',	    'EXTENSION',  0, 0, STATUS)
	CALL DAT_FIND (AST, 'PSF', PSF, 			STATUS)
	CALL DAT_NEWC (PSF, 'LIBRARY_NAME', 20, 0, 0, 		STATUS)
	CALL CMP_PUT0C(PSF, 'LIBRARY_NAME', 'PSFLIB',		STATUS)
	CALL DAT_NEWC (PSF, 'ROUTINE_NAME', 20, 0,0,		STATUS)
	IF (SRT.MODE(1:1) .EQ. 'P') THEN
	  CALL CMP_PUT0C (PSF, 'ROUTINE_NAME',	'PSF_PWFC',	STATUS)
	ELSE
	  CALL CMP_PUT0C (PSF, 'ROUTINE_NAME',	'PSF_WFC',	STATUS)
	ENDIF

*    Create and write INSTRUMENT.SORT structure .........
	CALL DAT_NEW  (AST, 'INSTRUMENT',  'EXTENSION', 0, 0,	STATUS)
	CALL DAT_FIND (AST, 'INSTRUMENT',  INS,		STATUS)
	CALL DAT_NEW  (INS,'SORT','EXTENSION', 0, 0, 	STATUS)
	CALL DAT_FIND (INS,'SORT',  SOR, 		STATUS)

	CALL DAT_NEW (SOR, 'BGND_REJ', '_LOGICAL', 0, 0, STATUS)
	CALL CMP_PUT0L (SOR, 'BGND_REJ', SRT.BREJ, STATUS)
	CALL DAT_NEW (SOR, 'MOON_REJ', '_LOGICAL', 0, 0, STATUS)
	CALL CMP_PUT0L (SOR, 'MOON_REJ', SRT.MREJ, STATUS)
	IF (SRT.DTYPE(1:1) .EQ. 'T') THEN
	  CALL DAT_NEW (SOR, 'INRAD', '_DOUBLE', 0, 0, STATUS)
	  CALL CMP_PUT0D (SOR, 'INRAD', DBLE(SRT.INR/DTOR), STATUS)
	  CALL DAT_NEW (SOR, 'OUTRAD', '_DOUBLE', 0, 0, STATUS)
	  CALL CMP_PUT0D (SOR, 'OUTRAD', DBLE(SRT.OUTR/DTOR), STATUS)
	ENDIF
	CALL DAT_NEW (SOR, 'HALF_AZ', '_DOUBLE', 0, 0, STATUS)
	CALL CMP_PUT0D (SOR, 'HALF_AZ', DBLE(SRT.DAZ/DTOR), STATUS)
	CALL DAT_NEW (SOR, 'HALF_EL', '_DOUBLE', 0, 0, STATUS)
	CALL CMP_PUT0D (SOR, 'HALF_EL', DBLE(SRT.DEL/DTOR), STATUS)

	CALL DAT_NEW (SOR, 'ROLL', '_DOUBLE', 0, 0, STATUS)
	CALL CMP_PUT0D (SOR, 'ROLL', DBLE(SRT.ROLL/DTOR),        STATUS)
	CALL DAT_NEW (SOR, 'IRIS', '_REAL', 0, 0, STATUS)
	CALL CMP_PUT0R (SOR, 'IRIS',   SRT.IRIS/DTOR,		 STATUS)
	CALL DAT_NEW0I (SOR, 'FILTER',	     STATUS)
	CALL CMP_PUT0I (SOR, 'FILTER', SRT.FILT,	         STATUS)
	CALL DAT_NEW0I (SOR, 'DETECTOR',     STATUS)
	CALL CMP_PUT0I (SOR, 'DETECTOR', SRT.DET,                STATUS)
	NC = MX_LASTPC (SRT.EVE)
	CALL DAT_NEWC  (SOR, 'ROOT', NC, 0, 0, STATUS)
	CALL CMP_PUT0C (SOR, 'ROOT', SRT.EVE(1:NC),	 	 STATUS)

	CALL DAT_ANNUL (SOR, STATUS)
	CALL DAT_ANNUL (INS, STATUS)
*	CALL DAT_ANNUL (LIV, STATUS)
	CALL DAT_ANNUL (COR, STATUS)
	CALL DAT_ANNUL (PRO, STATUS)
	CALL DAT_ANNUL (PSF, STATUS)
	CALL DAT_ANNUL (HEA, STATUS)
	CALL DAT_ANNUL (AST, STATUS)
	CALL DAT_ANNUL (MOR, STATUS)

*	Create a HISTORY component
*	CALL HIST_ADD(OLOC, 'Created by RE_SORT', STATUS)

999     IF (STATUS .NE. 0) THEN
	WRITE(*,*) '   Error in SORT_CRE_ASTERIX'
	ENDIF

	END
