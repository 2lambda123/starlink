\documentstyle{article} 
\pagestyle{myheadings}

%------------------------------------------------------------------------------
\newcommand{\irasdoccategory}  {IRAS90 Document}
\newcommand{\irasdocinitials}  {ID}
\newcommand{\irasdocnumber}    {8.13}
\newcommand{\irasdocauthors}   {D.S. Berry \& W. Gong}
\newcommand{\irasdocdate}      {2nd June 1994.}
\newcommand{\irasdoctitle}     {IRM: A package of miscellaneous utility subroutines}
%------------------------------------------------------------------------------

\newcommand{\irasdocname}{\irasdocinitials /\irasdocnumber}
\renewcommand{\_}{{\tt\char'137}}     % re-centres the underscore
\markright{\irasdocname}
\setlength{\textwidth}{160mm}
\setlength{\textheight}{240mm}
\setlength{\topmargin}{-5mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\setlength{\unitlength}{1mm}

%------------------------------------------------------------------------------
% Add any \newcommand or \newenvironment commands here
%------------------------------------------------------------------------------

\begin{document}
\thispagestyle{empty}
SCIENCE \& ENGINEERING RESEARCH COUNCIL \hfill \irasdocname\\
RUTHERFORD APPLETON LABORATORY\\
{\large\bf IRAS90\\}
{\large\bf \irasdoccategory\ \irasdocnumber}
\begin{flushright}
\irasdocauthors\\
\irasdocdate
\end{flushright}
\vspace{-4mm}
\rule{\textwidth}{0.5mm}
\vspace{5mm}
\begin{center}
{\Large\bf \irasdoctitle}
\end{center}
\vspace{5mm}

\setlength{\parskip}{0mm}
\tableofcontents
\setlength{\parskip}{\medskipamount}
\markright{\irasdocname}

\section {Introduction}
This document contains the specifications for a miscellaneous selection of
utility subroutines which may be of use in several applications in the IRAS90 
package. It contains a list of all the subroutines, giving a one line 
description of what the subroutine does, and also the complete specification 
for each subroutine.


\section {Compiling and Linking with IRM}
\label{SEC:LINK}
This section describes how to compile and link applications which use IRM
subroutines, on both VMS and UNIX systems. It is assumed that the IRAS90 package
is installed as part of the Starlink Software Collection.

\subsection{VMS}
Each terminal session which is to include the compilation or linking of 
applications which use the IRM package should start by issuing the commands:

\begin{verbatim}
$ ADAMSTART
$ ADAMDEV
$ IRAS90
$ IRAS90_DEV
\end{verbatim}

These commands set up logical names related to all the IRAS90
subsystems, including IRM. 

To link a VMS ADAM application with the IRM package, the linker options file
IRAS90\_LINK\_ADAM should be used. For example, to compile and link an ADAM
application called PROG with the IRM library, the following commands should be
used: 

\begin{verbatim}
$ ADAMSTART
$ ADAMDEV
$ IRAS90
$ IRAS90_DEV
$ FORT PROG
$ ALINK PROG, IRAS90_LINK_ADAM/OPT 
\end{verbatim}

Stand-alone (i.e. non-ADAM) applications can be linked with the ``standalone''
version of IRM. This version excludes the routines described in appendix
\ref{APP:ADAM}. To do this the link options file IRAS90\_LINK should be used
instead of IRAS90\_LINK\_ADAM. Thus to compile and link a stand-alone
application with the IRM package, the following commands should be given: 

\begin{verbatim}
$ IRAS90
$ IRAS90_DEV
$ FORT PROG
$ LINK PROG, IRAS90_LINK/OPT 
\end{verbatim}

\subsection{UNIX}

Each terminal session which is to include the compilation or linking of 
applications which use the IRM package should do the following:

\begin{enumerate}
\item Execute the {\bf iras90} command. This sets up an alias for the 
{\bf iras90\_dev} command.

\item Execute the {\bf iras90\_dev} command.  This sets up three
environment variables; IRAS90\_DIR pointing to the top level directory
in the IRAS90 package, IRAS90\_LIB pointing to the directory in which
the IRAS90 sub-system libraries are stored (including IRM), and
IRAS90\_INC pointing to the directory which contains all the IRAS90
include files. It also adds the {\bf bin} sub-directory of IRAS90\_DIR
on to the end of the current value for the environment variable PATH. 

\item If a UNIX application accesses any include files (such as
IRM\_PAR) then it should be ensured that the files can be found by the
compiler. All IRAS90 include files are contained in the directory
pointed to by environment variable IRAS90\_INC (set up by {\bf
iras90\_dev}, so a soft link to the IRM\_PAR file (for instance) can be
set up with the command: 

\verb+% ln -s $IRAS90_INC/irm_par IRM_PAR+\\

Include files associated with Starlink subroutine libraries and the
ADAM system are stored in the directory {\bf /star/include}. So to set
up a link for the include file SAE\_PAR (for instance) use the command:

\verb+% ln -s /star/include/sae_par SAE_PAR+\\

Soft links can be deleted (using the {\bf rm} command) when no longer needed.
Note, soft links are only accessable in the directory from which the {bf ln} 
command was issued.

\item For ADAM applications the following {\bf alink} command should be used:

\verb+% alink prog.f -L$IRAS90_LIB `irm_link_adam`+\\

where {\bf prog.f} is the fortran source file for the ATASK.
Note the use of opening apostrophies (`) instead of the more usual closing
apostrophy (') in the above {\bf alink} command.

\item For a stand-alone program the following {\bf f77} command should be used:

\verb+% f77 prog.f -o prog -L$IRAS90_LIB `irm_link`+\\
\end{enumerate}


\appendix
\section {Routine Descriptions}
\label {APP:ROUTS}

% Command for displaying routines in routine lists:
% =================================================
\newcommand{\noteroutine}[2]{{\small \bf #1} \\
                              \hspace*{3em} {\em #2} \\[1.5ex]}
\noteroutine{IRM\_AGFND( NAME, PICID, STATUS )}
  {Selects the highest picture of a given name within the current AGI picture}
\noteroutine{IRM\_AGREF( PICID, ACCESS, THERE, LOC, STATUS )}
  {Obtains a locator to an object referenced in the graphics database}
\noteroutine{IRM\_ANTSO( STATUS )}
  {Reverse the effect of routine IRM\_SOLIN}
\noteroutine{IRM\_ASFIO( PNFILE, ACMODE, FORM, RECSZ, FD, OPEN, STATUS )}
  {Open a text file obtaining the name through the parameter system}
\noteroutine{IRM\_AVERG(  NSMP, DATA, THRD, NITRN, AVG, STATUS )}
  {Estimate the average of a data series}
\noteroutine{IRM\_BILN1( X, Y, XLO, XHI, YLO, YHI, DATA, INTERP, STATUS )}
  {Perform bi-linear interpolation checking for bad values}
\noteroutine{IRM\_BILN2( X, Y, XLO, XHI, YLO, YHI, DATA, INTERP, STATUS )}
  {Perform bi-linear interpolation with no checking for bad values}
\noteroutine{IRM\_BLOCR( BAD, SAMBAD, VAR, NX, NY, A, IBOXX, IBOXY, NLIM, ...)}
  {Smooth a data array using a box filter}
\noteroutine{IRM\_CDESC( LEN, POINT, STATUS )}
  {Modify a pointer so that it can be used to pass character data}
\noteroutine{IRM\_CFF2R( NX, NY, INARR, VAR, NVAR, INVAR, BOXSZ, NITER, ...)}
  {Reject sources from a substantially smooth 2-D data array}
\noteroutine{IRM\_CHKOB( LOC, INNAME, INTYPE, NDIMS, DIMS, STATUS )}
  {Check a component of an object exists and has correct attributes}
\noteroutine{IRM\_CLEAN( LBND, UBND, DATIN, WLBND, WUBND, HBOX, NITER, ...)}
  {Reject sources from a substantially smooth 1-D array of data}
\noteroutine{IRM\_COMNT( NCARD, BUFFER, STCARD, THERE, VALUE, CARD, STATUS )}
  {Get a comment card from a set of FITS header cards.}
\noteroutine{IRM\_CPOIN( POINT, STATUS )}
  {Modify a pointer to remove the effects of IRM\_CDESC}
\noteroutine{IRM\_CRTYP( NCRDD, NDFID, TYPE, STATUS )}
  {Check the type of a group of CRDD NDF files}
\noteroutine{IRM\_CVDET( NDET, ADET, NDETS1, DETS1, DETS2, NDETS2, STATUS )}
  {Find the detectors not included in a supplied list of detectors}
\noteroutine{IRM\_DELOB( LOC, STATUS )}
  {Delete an HDS object given its locator}
\noteroutine{IRM\_DIMEN( PARAM, DEFLT, LIMIT, DIMENS, STATUS )}
  {Obtain a pair of dimensions using the parameter system}
\noteroutine{IRM\_ELLIP( X, Y, XSIZE, YSIZE, STATUS )}
  {Draw an ellipse}
\noteroutine{IRM\_FILNM( INSTR, OUTSTR, STATUS )}
  {Extract a file name from a file specification}
\noteroutine{IRM\_FIT2( LBND, UBND, Y, X, M, C, RMS, STATUS )}
  {Fit a least squares straight line to supplied data}
\noteroutine{IRM\_GDTYP( GPTYPE, GDTYPE, STATUS )}
  {Get the graphic device type}
\noteroutine{IRM\_GETQX( PARAM, QEXP, STATUS )}
  {Get a quality expression from the user and check for syntax errors}
\noteroutine{IRM\_GETTD( PARAM, TIMDAT, MJD, STATUS )}
  {Get a date and time string from the environment}
\noteroutine{IRM\_GKCMT( NCARD, BUFFER, STCARD, NAME, CMTBGN, CMTCRD, ...)}
  {Get a comment from a FITS keyword.}
\noteroutine{IRM\_GKEYC( NCARD, BUFFER, SCARD, NAME, THERE, VALUE, CARD, STATUS )}
  {Get a character valued FITS keyword.}
\noteroutine{IRM\_GKEYR( NCARD, BUFFER, SCARD, NAME, THERE, VALUE, CARD, STATUS )}
  {Get a real valued FITS keyword.}
\noteroutine{IRM\_GROPN( PDEV, PXSZ, PYSZ, CLEAR, COMMNT, PIC0, PIC1, ...)}
  {Open an SGS workstation for use with NCAR}
\noteroutine{IRM\_GTAST( PARAM, PICID, LBND, UBND, IDA, STATUS )}
  {Get astrometry information associated with an AGI picture}
\noteroutine{IRM\_GTBND( PARAM, DEFAUL, NULL, BAND, STATUS )}
  {Get a survey waveband from the user}
\noteroutine{IRM\_GTCUN( PARAM, DEFAUL, UNITS, STATUS )}
  {Get a valid CRDD units system from the environment}
\noteroutine{IRM\_GTDET( DETS, NDET, ADET, DETOUT, NOUT, STATUS )}
  {Get a set of detector numbers from the user}
\noteroutine{IRM\_GTHLP( HELPLB, KEYWRD,STATUS )}
  {Display help information from a starlink help library.}
\noteroutine{IRM\_HIST( PARAM, INDF, COMMND, SIZE, TEXT, STATUS )}
  {Add history information to an NDF}
\noteroutine{IRM\_HMENU( NITEM, INMENU, NROW, DEFNO, X1, X2, Y1, Y2, ...)}
  {Draw a horizontal menu and select an item from it}
\noteroutine{IRM\_HMFFT( IN, NPIX, NLIN, WORK, FORWRD, OUT, STATUS )}
  {Take the FFT of an Hermitian image}
\noteroutine{IRM\_HMSG( TOKEN, LOC )}
  {Assign the name of an HDS object to a message token}
\noteroutine{IRM\_HMULT( IN1, IN2, M, N, OUT, STATUS )}
  {Multiply two Hermitian images together}
\noteroutine{IRM\_IATTR( ITEM, CURVE, IVAL, LVAL, STATUS )}
  {Return a graphical attribute set by another IRM routine}
\noteroutine{IRM\_LISTN( PARAM, IGRP, APPNAM, STATUS )}
  {Create a text file holding the names of the NDFs created by an application}
\noteroutine{IRM\_LINR( DIS1, DIS2, VAL1, VAL2, OUT, STATUS )}
  {Perform a linear interpolation}
\noteroutine{IRM\_LINTR( N, XA, YA, XB, YB, IFIT, C, MAXERR, RMSERR, STATUS )}
  {Calculate a least squares linear transformation between two sets of 
   positions}
\noteroutine{IRM\_LITRR( SCALE, OFFSET, STATUS )}
  {Store a linear transformation in the AGI database}
\noteroutine{IRM\_MEDN( EL, DATA, MEDIAN, NGOOD, STATUS )}
  {Find the median value in a data array}
\noteroutine{IRM\_MLINE( NX, NLINE, ONEXDT, XDAT, YDAT, XORDER,...)}
  {Draw multi-curve plot with annotated and labelled axes}
\noteroutine{IRM\_NOISE( NSMP, DATA, WINDSZ, THRD, VAL, AVG, VAR, RMS, STATUS )}
  {Estimate the noise of a data series}
\noteroutine{IRM\_PAGE( STRING )}
  {Start a new page of output produced by IRM\_PTOUT.}
\noteroutine{IRM\_PROFL( PFILE, NSMP, NPROF, DPNTR, XPNTR, NDF, STATUS )}
  {Input a point source profile from the environment}
\noteroutine{IRM\_PTAST( PICID, IDA, STATUS )}
  {Store astrometry information with an AGI picture}
\noteroutine{IRM\_PTOUT( STRING )}
  {Display a line of text, pausing when screen is full.}
\noteroutine{IRM\_QCOL( COLOUR, STATUS )}
  {Tests whether the current graphics device supports colour}
\noteroutine{IRM\_QNDF( INDF, QEXP, CONT, HELD, ONDF, STATUS )}
  {Set NDF DATA elements bad on the basis of quality}
\noteroutine{IRM\_QNTLR( USEWT, INTERP, FRACT, EL, X, W, IP, Q, STATUS )}
  {Find a quantile in a (possibly weighted) set of data}
\noteroutine{IRM\_RDNDF( PARAM, MAXSIZ, MINSIZ, TEXT, IGRP, SIZE, STATUS )}
  {Get a group of existing NDFs}
\noteroutine{IRM\_READF( PARAM, REJECT, IGRP, SIZE, STATUS )}
  {Read contents of a text file into a GRP group}
\noteroutine{IRM\_RLFFT( IN, NPIX, NLIN, WORK, FORWRD, OUT, STATUS )}
  {Take the FFT of a purely real image}
\noteroutine{IRM\_SKCUR( IDA, SCS, LBND, UBND, LON, LAT, OUT, STATUS )}
  {Get the sky coordinates of a position specified by a cursor}
\noteroutine{IRM\_SOLIN( STATUS )}
  {Set all GKS poly lines solid}
\noteroutine{IRM\_SORTD( ASCEND, KEYROW, NVAL, NROWS, DATA, NGOOD, STATUS )}
  {Sort an array of values into ascending or descending order}
\noteroutine{IRM\_SPAGE( ON )}
  {Determine if paged screen output is currently enabled}
\noteroutine{IRM\_SQFLT( NSMP, INDAT, OUTDAT, STATUS )}
  {Square wave filter a data series}
\noteroutine{IRM\_STATS( BSMP, ESMP, BROW, EROW, IN, NCLIP, CLIP,...)}
  {Statistically analyse each row of a 2-D array}
\noteroutine{IRM\_STAXS( XBMT, YLFT, XLAB, YLAB, LABSZE, MAJTIC, ...)}
  {Set the axes attributes of a NCAR graph}
\noteroutine{IRM\_STGRD( X1, X2, Y1, Y2, STATUS )}
  {Set the position and the size of grid window of NCAR package}
\noteroutine{IRM\_STLMT( LMTX, LMTY, XLMT, YLMT, STATUS )}
  {Set axes limits of a NCAR graph}
\noteroutine{IRM\_STLOG( XLOG, YLOG, STATUS )}
  {Set axes to logarithmic where required}
\noteroutine{IRM\_STMAP( XORDER, YORDER, STATUS )}
  {Set the ways of mapping coordinates to axes of NCAR display}
\noteroutine{IRM\_STNUL( NX, SET, YDAT, STATUS )}
  {Set bad pixels to NCAR null value, or vice versa}
\noteroutine{IRM\_STPEN( NCURV, CURPEN, SOLID, INLPEN, AXSPEN,...)}
  {Set pen number various portions of an NCAR display}
\noteroutine{IRM\_STPHA( LNLAB, NPATTN, LNLBPS, STATUS )}
  {Set dashed-line pattern for NCAR routine EZMXY}
\noteroutine{IRM\_SUBST( INSTR, OLD, NEW, ALL, OUTSTR, NSUB, STATUS )}
  {Substitute one substring for another}
\noteroutine{IRM\_TABLE( TITLE, NROW, NCOL TABLE, X1, X2, Y1, Y2,...)}
  {Draw a table at specify position with specify size}
\noteroutine{IRM\_TD( STRING, IY, IM, ID, IHOUR, IMIN, SEC, MJD, STATUS )}
  {Extract individual fields from a time and date string and convert 
   to a Modified Julian Date}
\noteroutine{IRM\_TMENU( INMENU, INTITL, PARAM, ITEMNO, STATUS )}
  {Display a menu on user's terminal and get an item from it}
\noteroutine{IRM\_TRCON( C1, C2, C3, STATUS )}
  {Concatenate two linear transformations}
\noteroutine{IRM\_TRINV( C, D, STATUS )}
  {Invert a linear transformation}
\noteroutine{IRM\_UNTCV( UTS1, UTS2, NDET, DET, SCALE, STATUS )}
  {Calculate scale factor for valid CRDD units conversions}
\noteroutine{IRM\_UNTIM( INDF, UNITS, SCALE, BAND, STATUS )}
  {Calculate scale factor to apply to an NDF to get specified units}
\noteroutine{IRM\_UNTIV( UTS1, UTS2, BAND, PIXSIZ, SCALE, STATUS )}
  {Calculate scale factor for valid image units conversions}
\noteroutine{IRM\_VMENU( NITEM, INMENU, NROW, DEFNO, X1, X2, Y1, Y2,...)}
  {Draw a vertical menu and select an item from it}
\noteroutine{IRM\_WRNDF( PARAM, GID0, MAXSIZ, MINSIZ, TEXT, GID, SIZE, STATUS )}
  {Get a group of output NDFs}


\section{Classified List of Routines}

\subsection {Accessing FITS Header Cards}
\noteroutine{IRM\_COMNT( NCARD, BUFFER, STCARD, THERE, VALUE, CARD, STATUS )}
  {Get a comment card from a set of FITS header cards.}
\noteroutine{IRM\_GKCMT( NCARD, BUFFER, STCARD, NAME, CMTBGN, CMTCRD, ...)}
  {Get a comment from a FITS keyword.}
\noteroutine{IRM\_GKEYC( NCARD, BUFFER, SCARD, NAME, THERE, VALUE, CARD, STATUS )}
  {Get a character valued FITS keyword.}
\noteroutine{IRM\_GKEYR( NCARD, BUFFER, SCARD, NAME, THERE, VALUE, CARD, STATUS )}
  {Get a real valued FITS keyword.}


\subsection {Accessing ADAM Parameters}
\label{APP:ADAM}
\noteroutine{IRM\_ASFIO ( PNFILE, ACMODE, FORM, RECSZ, FD, OPEN, STATUS )}
  {Open a text file obtaining the name through the parameter system}
\noteroutine{IRM\_DIMEN( PARAM, DEFLT, LIMIT, DIMENS, STATUS )}
  {Obtain a pair of dimensions using the parameter system}
\noteroutine{IRM\_GETQX( PARAM, QEXP, STATUS )}
  {Get a quality expression from the user and check for syntax errors}
\noteroutine{IRM\_GETTD( PARAM, TIMDAT, MJD, STATUS )}
  {Get a date and time string from the environment}
\noteroutine{IRM\_GROPN( PDEV, PXSZ, PYSZ, CLEAR, COMMNT, PIC0, PIC1, ...)}
  {Open an SGS workstation for use with NCAR}
\noteroutine{IRM\_GTAST( PARAM, PICID, LBND, UBND, IDA, STATUS )}
  {Get astrometry information associated with an AGI picture}
\noteroutine{IRM\_GTBND( PARAM, DEFAUL, NULL, BAND, STATUS )}
  {Get a survey waveband from the user}
\noteroutine{IRM\_GTCUN( PARAM, DEFAUL, UNITS, STATUS )}
  {Get a valid CRDD units system from the environment}
\noteroutine{IRM\_GTDET( DETS, NDET, ADET, DETOUT, NOUT, STATUS )}
  {Get a set of detector numbers from the user}
\noteroutine{IRM\_HIST( PARAM, INDF, COMMND, SIZE, TEXT, STATUS )}
  {Add history information to an NDF}
\noteroutine{IRM\_LISTN( PARAM, IGRP, APPNAM, STATUS )}
  {Create a text file holding the names of the NDFs created by an application}
\noteroutine{IRM\_RDNDF( PARAM, MAXSIZ, MINSIZ, TEXT, IGRP, SIZE, STATUS )}
  {Get a group of existing NDFs}
\noteroutine{IRM\_READF( PARAM, REJECT, IGRP, SIZE, STATUS )}
  {Read contents of a text file into a GRP group}
\noteroutine{IRM\_TMENU( INMENU, INTITL, PARAM, ITEMNO, STATUS )}
  {Display a menu on user's terminal and get an item from it}
\noteroutine{IRM\_WRNDF( PARAM, GID0, MAXSIZ, MINSIZ, TEXT, GID, SIZE, STATUS )}
  {Get a group of output NDFs}


\subsection {Handling HDS Objects}
\noteroutine{IRM\_CHKOB( LOC, INNAME, INTYPE, NDIMS, DIMS, STATUS )}
  {Check a component of an object exists and has correct attributes}
\noteroutine{IRM\_DELOB( LOC, STATUS )}
  {Delete an HDS object given its locator}
\noteroutine{IRM\_HMSG( TOKEN, LOC )}
  {Assign the name of an HDS object to a message token}


\subsection {Handling IRAS Detector Numbers and IRAS Data Units}
\noteroutine{IRM\_CRTYP( NCRDD, NDFID, TYPE, STATUS )}
  {Check the type of a group of CRDD NDF files}
\noteroutine{IRM\_CVDET( NDET, ADET, NDETS1, DETS1, DETS2, NDETS2, STATUS )}
  {Find the detectors not included in a supplied list of detectors}
\noteroutine{IRM\_GTDET( DETS, NDET, ADET, DETOUT, NOUT, STATUS )}
  {Get a set of detector numbers from the user}
\noteroutine{IRM\_UNTCV( UNITS1, UNITS2, NDET, DET, SCALE, STATUS )}
  {Calculate scale factor for valid CRDD units conversions}
\noteroutine{IRM\_UNTIM( INDF, UNITS, SCALE, BAND, STATUS )}
  {Calculate scale factor to apply to an NDF to get specified units}
\noteroutine{IRM\_UNTIV( UTS1, UTS2, BAND, PIXSIZ, SCALE, STATUS )}
  {Calculate scale factor for valid image units conversions}


\subsection {Handling Six Coefficient Linear Transformations}
\noteroutine{IRM\_LINTR( N, XA, YA, XB, YB, IFIT, C, MAXERR, RMSERR, STATUS )}
  {Calculate a least squares linear transformation between two sets of 
   positions}
\noteroutine{IRM\_TRCON( C1, C2, C3, STATUS )}
  {Concatenate two linear transformations}
\noteroutine{IRM\_TRINV( C, D, STATUS )}
  {Invert a linear transformation}


\subsection{Producing Paged Screen Output}
\noteroutine{IRM\_PAGE( STRING )}
  {Start a new page of output produced by IRM\_PTOUT.}
\noteroutine{IRM\_PTOUT( STRING )}
  {Display a line of text, pausing when screen is full.}
\noteroutine{IRM\_SPAGE( ON )}
  {Determine if paged screen output is currently enabled}

\subsection {Handling QUALITY}
\noteroutine{IRM\_GETQX( PARAM, QEXP, STATUS )}
  {Get a quality expression from the user and check for syntax errors}
\noteroutine{IRM\_QNDF( INDF, QEXP, CONT, HELD, ONDF, STATUS )}
  {Set NDF DATA elements bad on the basis of quality}


\subsection {Handling HISTORY}
\noteroutine{IRM\_HIST( PARAM, INDF, COMMND, SIZE, TEXT, STATUS )}
  {Add history information to an NDF}


\subsection {Handling Character Strings}
\noteroutine{IRM\_SUBST( INSTR, OLD, NEW, ALL, OUTSTR, NSUB, STATUS )}
  {Substitute one substring for another}
\noteroutine{IRM\_TD( STRING, IY, IM, ID, IHOUR, IMIN, SEC, MJD, STATUS )}
  {Extract individual fields from a time and date string and convert 
   to a Modified Julian Date}
\noteroutine{IRM\_CDESC( LEN, POINT, STATUS )}
  {Modify a pointer so that it can be used to pass character data}
\noteroutine{IRM\_CPOIN( POINT, STATUS )}
  {Modify a pointer to remove the effects of IRM\_CDESC}


\subsection {Fourier Transform Routines}
\noteroutine{IRM\_HMFFT( IN, NPIX, NLIN, WORK, FORWRD, OUT, STATUS )}
  {Take the FFT of an Hermitian image}
\noteroutine{IRM\_HMULT( IN1, IN2, M, N, OUT, STATUS )}
  {Multiply two Hermitian images together}
\noteroutine{IRM\_RLFFT( IN, NPIX, NLIN, WORK, FORWRD, OUT, STATUS )}
  {Take the FFT of a purely real image}

\subsection {Processing Arrays of Numbers}
\noteroutine{IRM\_AVERG(  NSMP, DATA, THRD, NITRN, AVG, STATUS )}
  {Estimate the average of a data series}
\noteroutine{IRM\_BILN1( X, Y, XLO, XHI, YLO, YHI, DATA, INTERP, STATUS )}
  {Perform bi-linear interpolation checking for bad values}
\noteroutine{IRM\_BILN2( X, Y, XLO, XHI, YLO, YHI, DATA, INTERP, STATUS )}
  {Perform bi-linear interpolation with no checking for bad values}
\noteroutine{IRM\_BLOCR( BAD, SAMBAD, VAR, NX, NY, A, IBOXX, IBOXY, NLIM, ...)}
  {Smooth a data array using a box filter}
\noteroutine{IRM\_CFF2R( NX, NY, INARR, VAR, NVAR, INVAR, BOXSZ, NITER, ...)}
  {Reject sources from a substantially smooth 2-D data array}
\noteroutine{IRM\_CLEAN( LBND, UBND, DATIN, WLBND, WUBND, HBOX, NITER, ...)}
  {Reject sources from a substantially smooth 1-D array of data}
\noteroutine{IRM\_FIT2( LBND, UBND, Y, X, M, C, RMS, STATUS )}
  {Fit a least squares straight line to supplied data}
\noteroutine{IRM\_HMFFT( IN, NPIX, NLIN, WORK, FORWRD, OUT, STATUS )}
  {Take the FFT of an Hermitian image}
\noteroutine{IRM\_HMULT( IN1, IN2, M, N, OUT, STATUS )}
  {Multiply two Hermitian images together}
\noteroutine{IRM\_LINR( DIS1, DIS2, VAL1, VAL2, OUT, STATUS )}
  {Perform a linear interpolation}
\noteroutine{IRM\_MEDN( EL, DATA, MEDIAN, NGOOD, STATUS )}
  {Find the median value in a data array}
\noteroutine{IRM\_NOISE( NSMP, DATA, WINDSZ, THRD, VAL, AVG, VAR, RMS, STATUS )}
  {Estimate the noise of a data series}
\noteroutine{IRM\_QNTLR( USEWT, INTERP, FRACT, EL, X, W, IP, Q, STATUS )}
  {Find a quantile in a (possibly weighted) set of data}
\noteroutine{IRM\_RLFFT( IN, NPIX, NLIN, WORK, FORWRD, OUT, STATUS )}
  {Take the FFT of a purely real image}
\noteroutine{IRM\_SORTD( ASCEND, KEYROW, NVAL, NROWS, DATA, NGOOD, STATUS )}
  {Sort an array of values into ascending or descending order}
\noteroutine{IRM\_SQFLT( NSMP, INDAT, OUTDAT, STATUS )}
  {Square wave filter a data series}
\noteroutine{IRM\_STATS( BSMP, ESMP, BROW, EROW, IN, NCLIP, CLIP,...)}
  {Statistically analyse each row of a 2-D array}


\subsection {Handling Time and Date}
\noteroutine{IRM\_GETTD( PARAM, TIMDAT, MJD, STATUS )}
  {Get a date and time string from the environment}
\noteroutine{IRM\_TD( STRING, IY, IM, ID, IHOUR, IMIN, SEC, MJD, STATUS )}
  {Extract individual fields from a time and date string and convert 
   to a Modified Julian Date}


\subsection {Handling File Specifications}
\noteroutine{IRM\_FILNM( INSTR, OUTSTR, STATUS )}
  {Extract a file name from a file specification}

\subsection {Graphics subroutines}
\noteroutine{IRM\_AGFND( NAME, PICID, STATUS )}
  {Selects the highest picture of a given name within the current AGI picture}
\noteroutine{IRM\_AGREF( PICID, ACCESS, THERE, LOC, STATUS )}
  {Obtains a locator to an object referenced in the graphics database}
\noteroutine{IRM\_ANTSO( STATUS )}
  {Reverse the effect of routine IRM\_SOLIN}
\noteroutine{IRM\_ELLIP( X, Y, XSIZE, YSIZE, STATUS )}
  {Draw an ellipse}
\noteroutine{IRM\_GDTYP( GPTYPE, GDTYPE, STATUS )}
  {Get the graphic device type}
\noteroutine{IRM\_GROPN( PDEV, PXSZ, PYSZ, CLEAR, COMMNT, PIC0, PIC1, ...)}
  {Open an SGS workstation for use with NCAR}
\noteroutine{IRM\_GTAST( PARAM, PICID, LBND, UBND, IDA, STATUS )}
  {Get astrometry information associated with an AGI picture}
\noteroutine{IRM\_HMENU( NITEM, INMENU, NROW, DEFNO, X1, X2, Y1, Y2, ...)}
  {Draw a horizontal menu and select an item from it}
\noteroutine{IRM\_IATTR( ITEM, CURVE, IVAL, LVAL, STATUS )}
  {Return a graphical attribute set by another IRM routine}
\noteroutine{IRM\_LITRR( SCALE, OFFSET, STATUS )}
  {Store a linear transformation in the AGI database}
\noteroutine{IRM\_MLINE( NX, NLINE, ONEXDT, XDAT, YDAT, XORDER,...)}
  {Draw multi-curve plot with annotated and labelled axes}
\noteroutine{IRM\_PTAST( PICID, IDA, STATUS )}
  {Store astrometry information with an AGI picture}
\noteroutine{IRM\_QCOL( COLOUR, STATUS )}
  {Tests whether the current graphics device supports colour}
\noteroutine{IRM\_SKCUR( IDA, SCS, LBND, UBND, LON, LAT, OUT, STATUS )}
  {Get the sky coordinates of a position specified by a cursor}
\noteroutine{IRM\_SOLIN( STATUS )}
  {Set all GKS poly lines solid}
\noteroutine{IRM\_STAXS( XBMT, YLFT, XLAB, YLAB, LABSZE, MAJTIC, ...)}
  {Set the axes attributes of a NCAR graph}
\noteroutine{IRM\_STGRD( X1, X2, Y1, Y2, STATUS )}
  {Set the position and the size of grid window of NCAR package}
\noteroutine{IRM\_STLMT( LMTX, LMTY, XLMT, YLMT, STATUS )}
  {Set axes limits of a NCAR graph}
\noteroutine{IRM\_STLOG( XLOG, YLOG, STATUS )}
  {Set axes to logarithmic where required}
\noteroutine{IRM\_STMAP( XORDER, YORDER, STATUS )}
  {Set the ways of mapping coordinates to axes of NCAR display}
\noteroutine{IRM\_STNUL( NX, SET, YDAT, STATUS )}
  {Set bad pixels to NCAR null value, or vice versa}
\noteroutine{IRM\_STPEN( NCURV, CURPEN, SOLID, INLPEN, AXSPEN,...)}
  {Set pen number various portions of an NCAR display}
\noteroutine{IRM\_STPHA( LNLAB, NPATTN, LNLBPS, STATUS )}
  {Set dashed-line pattern for NCAR routine EZMXY}
\noteroutine{IRM\_TABLE( TITLE, NROW, NCOL TABLE, X1, X2, Y1, Y2,...)}
  {Draw a table at specify position with specify size}
\noteroutine{IRM\_VMENU( NITEM, INMENU, NROW, DEFNO, X1, X2, Y1, Y2,...)}
  {Draw a vertical menu and select an item from it}

%------------------------------------------------------------------------------
\section {Full Routine Specifications}

\renewcommand{\_}{{\tt\char'137}}

%  Define length variables.
\newlength{\sstbannerlength}
\newlength{\sstcaptionlength}

%  Define a \tt font of the required size.
\font\ssttt=cmtt10 scaled 1095

%  Define a command to produce a routine header, including its name,
%  a purpose description and the rest of the routine's documentation.
\newcommand{\sstroutine}[3]{
   \goodbreak
   \rule{\textwidth}{0.5mm}
   \vspace{-7ex}
   \newline
   \settowidth{\sstbannerlength}{{\Large {\bf #1}}}
   \setlength{\sstcaptionlength}{\textwidth}
   \addtolength{\sstbannerlength}{0.5em}
   \addtolength{\sstcaptionlength}{-2.0\sstbannerlength}
   \addtolength{\sstcaptionlength}{-4.45pt}
   \parbox[t]{\sstbannerlength}{\flushleft{\Large {\bf #1}}}
   \parbox[t]{\sstcaptionlength}{\center{\Large #2}}
   \parbox[t]{\sstbannerlength}{\flushright{\Large {\bf #1}}}
   \begin{description}
      #3
   \end{description}
}

%  Format the description section.
\newcommand{\sstdescription}[1]{\item[Description:] #1}

%  Format the usage section.
\newcommand{\sstusage}[1]{\item[Usage:] \mbox{} \\[1.3ex] {\ssttt #1}}

%  Format the invocation section.
\newcommand{\sstinvocation}[1]{\item[Invocation:]\hspace{0.4em}{\tt #1}}

%  Format the arguments section.
\newcommand{\sstarguments}[1]{
   \item[Arguments:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the returned value section (for a function).
\newcommand{\sstreturnedvalue}[1]{
   \item[Returned Value:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the parameters section (for an application).
\newcommand{\sstparameters}[1]{
   \item[Parameters:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the examples section.
\newcommand{\sstexamples}[1]{
   \item[Examples:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Define the format of a subsection in a normal section.
\newcommand{\sstsubsection}[1]{\item[{#1}] \mbox{} \\}

%  Define the format of a subsection in the examples section.
\newcommand{\sstexamplesubsection}[1]{\item[{\ssttt #1}] \mbox{} \\}

%  Format the notes section.
\newcommand{\sstnotes}[1]{\item[Notes:] \mbox{} \\[1.3ex] #1}

%  Provide a general-purpose format for additional (DIY) sections.
\newcommand{\sstdiytopic}[2]{\item[{\hspace{-0.35em}#1\hspace{-0.35em}:}] \mbox{} \\[1.3ex] #2}

%  Format the implementation status section.
\newcommand{\sstimplementationstatus}[1]{
   \item[{Implementation Status:}] \mbox{} \\[1.3ex] #1}

%  Format the bugs section.
\newcommand{\sstbugs}[1]{\item[Bugs:] #1}

%  Format a list of items while in paragraph mode.
\newcommand{\sstitemlist}[1]{
  \mbox{} \\
  \vspace{-3.5ex}
  \begin{itemize}
     #1
  \end{itemize}
}

%  Define the format of an item.
\newcommand{\sstitem}{\item}

%  End of LAYOUT.TEX layout definitions.
%.


\sstroutine{
   IRM\_AGFND
}{
   Selects the highest picture of a given name within the current AGI
   picture
}{
   \sstdescription{
      This routine searches forwards through the AGI database for a
      picture of a given name that lies within the current picture,
      including the current picture itself.  If one is found it
      becomes the new current picture.  If it could not be found a
      bad status will be returned, and the current picture is unchanged.
   }
   \sstinvocation{
      CALL IRM\_AGFND( NAME, PICID, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the picture to be searched for in the graphics
         database.
      }
      \sstsubsection{
         PICID = INTEGER (Returned)
      }{
         The picture identifier of the most-recent picture named NAME.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_AGREF
}{
   Obtains a locator to an object referenced in the graphics
   database
}{
   \sstdescription{
      This routine determines whether a given picture in the AGI
      graphics database has an object associated with it by reference.
      If it has, a locator to the object is returned with the desired
      access mode.
   }
   \sstinvocation{
      CALL IRM\_AGREF( PICID, ACCESS, THERE, LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PICID = INTEGER (Given)
      }{
         The identifier of the picture with which a data object may
         be associated by reference.
      }
      \sstsubsection{
         ACCESS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Access mode to the object: {\tt '}READ{\tt '}, {\tt '}WRITE{\tt '} or {\tt '}UPDATE{\tt '}.
      }
      \sstsubsection{
         THERE = LOGICAL (Returned)
      }{
         If true the picture has an associated object and the returned
         locator is meaningful.
      }
      \sstsubsection{
         LOC = CHARACTER $*$ ( DAT\_\_SZLOC ) (Returned)
      }{
         The locator to the data object referenced by picture PICID.
         It should be ignored if THERE is false.  This locator should
         be annulled by REF\_ANNUL.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_ANTSO
}{
   Sets the aspect source flag of the GKS linetype to bundled
}{
   \sstdescription{
      The routine sets the aspect source flag of the linetype of the
      current workstation to bundled.
   }
   \sstinvocation{
      CALL IRM\_ANTSO( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      A GKS workstation should be open and active.
   }
}
\sstroutine{
   IRM\_ASFIO
}{
   Opens a sequential file via a parameter
}{
   \sstdescription{
      This routine opens a sequential file via FIO\_ASSOC.  Up to four
      attempts may be made to open the file.  If a null response is
      supplied the file is not opened, and the flag returned indicates
      this fact.
   }
   \sstinvocation{
      CALL IRM\_ASFIO ( PNFILE, ACMODE, FORM, RECSZ, FD, OPEN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNFILE = CHARACTER$*$($*$)
      }{
         Parameter name by which file is to be opened
      }
      \sstsubsection{
         ACMODE = CHARACTER$*$($*$)
      }{
         Expression giving the required access mode.
           Valid modes are: {\tt '}READ{\tt '}, {\tt '}WRITE{\tt '}, {\tt '}UPDATE{\tt '} and {\tt '}APPEND{\tt '}.
           For details, see FIO\_OPEN.
      }
      \sstsubsection{
         FORM = CHARACTER$*$($*$)( READ )
      }{
         Expression giving the required formatting of the file.
           Valid formats are: {\tt '}FORTRAN{\tt '}, {\tt '}LIST{\tt '}, {\tt '}NONE{\tt '} and
           {\tt '}UNFORMATTED{\tt '}. For details, see FIO\_OPEN.
      }
      \sstsubsection{
         RECSZ = INTEGER( READ )
      }{
         Expression giving the maximum record size in bytes.
           Set it to zero if the Fortran default is required.
      }
      \sstsubsection{
         FD = INTEGER( WRITE )
      }{
         Variable to contain the file descriptor.
      }
      \sstsubsection{
         OPEN = LOGICAL( WRITE )
      }{
         If true the file has been opened.
      }
      \sstsubsection{
         STATUS = INTEGER( READ, WRITE )
      }{
         Global status value
      }
   }
}
\sstroutine{
   IRM\_AVERG
}{
   Estimate the average of a data series
}{
   \sstdescription{
      This subroutine estimates the average of a data series by
      iteratively calculating the average of the data series with the
      data samples which are too far away from the current data average
      being excluded. The samples whose distances from the current data
      average are more than THRD $*$ (Current standard deviation ) will
      be regarded as too far from the current average and will be
      excluded from the next iteration to calculate the new average and
      standard deviation. This procedure will be repeated until the
      successive standard deviations are the same or specified iteration
      number (NITRN) is rearched.
   }
   \sstinvocation{
      CALL IRM\_AVERG(  NSMP, DATA, THRD, NITRN, AVG, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NSMP = INTEGER (Given)
      }{
         Number of samples in the input data series.
      }
      \sstsubsection{
         DATA( NSMP ) = REAL (Given)
      }{
         The inut data series.
      }
      \sstsubsection{
         THRD = REAL (Given)
      }{
         The multiple of the standard deviation. Samples will not be
         included in the calculation of the average and standart
         deviation of the next iteration if they are more than this
         multiple away from the current average.
      }
      \sstsubsection{
         NITRN = INTEGER (Given)
      }{
         Max. number of iterations at which the standard deviation will
         be returned as the estimated noise no matter the convergence
         has achieved.
      }
      \sstsubsection{
         AVG = REAL (Returned)
      }{
         The average of the data series.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_BILN1
}{
   Perform bi-linear interpolation checking for bad values
}{
   \sstdescription{
      An imaginary pixel is centred on the supplied interpolation
      position. The area of the overlap between this imaginary pixel
      and each of the four surrounding real pixels is found, and used
      as the weight for the corresponding pixel value. The returned
      interpolated value is the weighted mean of the four surrounding
      pixel values. A bad value is returned if any of these four pixels
      lie outside the image or have a bad value.
   }
   \sstinvocation{
      CALL IRM\_BILN1( X, Y, XLO, XHI, YLO, YHI, DATA, INTERP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         X = REAL (Given)
      }{
         The pixel X coordinate at which to perform the interpolation.
      }
      \sstsubsection{
         Y = REAL (Given)
      }{
         The pixel Y coordinate at which to perform the interpolation.
      }
      \sstsubsection{
         XLO = INTEGER (Given)
      }{
         The lower bound on the array X axis.
      }
      \sstsubsection{
         XHI = INTEGER (Given)
      }{
         The upper bound on the array X axis.
      }
      \sstsubsection{
         YLO = INTEGER (Given)
      }{
         The lower bound on the array Y axis.
      }
      \sstsubsection{
         YHI = INTEGER (Given)
      }{
         The upper bound on the array Y axis.
      }
      \sstsubsection{
         DATA( XLO:XHI, YLO:YHI ) = REAL (Given)
      }{
         The data array to be interpolated.
      }
      \sstsubsection{
         INTERP = REAL (Returned)
      }{
         The interpolated value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_BILN2
}{
   Perform bi-linear interpolation with no checking for bad values
}{
   \sstdescription{
      An imaginary pixel is centred on the supplied interpolation
      position. The area of the overlap between this imaginary pixel
      and each of the four surrounding real pixels is found, and used
      as the weight for the corresponding pixel value. The returned
      interpolated value is the weighted mean of the four surrounding
      pixel values. A bad value is returned if any of these four pixels
      lie outside the image.
   }
   \sstinvocation{
      CALL IRM\_BILN2( X, Y, XLO, XHI, YLO, YHI, DATA, INTERP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         X = REAL (Given)
      }{
         The pixel X coordinate at which to perform the interpolation.
      }
      \sstsubsection{
         Y = REAL (Given)
      }{
         The pixel Y coordinate at which to perform the interpolation.
      }
      \sstsubsection{
         XLO = INTEGER (Given)
      }{
         The lower bound on the array X axis.
      }
      \sstsubsection{
         XHI = INTEGER (Given)
      }{
         The upper bound on the array X axis.
      }
      \sstsubsection{
         YLO = INTEGER (Given)
      }{
         The lower bound on the array Y axis.
      }
      \sstsubsection{
         YHI = INTEGER (Given)
      }{
         The upper bound on the array Y axis.
      }
      \sstsubsection{
         DATA( XLO:XHI, YLO:YHI ) = REAL (Given)
      }{
         The data array to be interpolated.
      }
      \sstsubsection{
         INTERP = REAL (Returned)
      }{
         The interpolated value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_BLOCR
}{
   Smooth a 2-dimensional image using a rectangular box filter
}{
   \sstdescription{
      The routine smooths a 2-dimensional image using a rectangular box
      filter; each pixel is replaced by the mean of those good
      neighbours which lie within a box of specified size.
   }
   \sstinvocation{
      CALL IRM\_BLOCR( BAD, SAMBAD, VAR, NX, NY, A, IBOXX,
                      IBOXY, NLIM, B, BADOUT, ASUM, NSUM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether it is necessary to check for bad pixels in the input
         image.
      }
      \sstsubsection{
         SAMBAD = LOGICAL (Given)
      }{
         If a .TRUE. value is given for this argument, then bad input
         pixels will be propagated to the output image unchanged (a
         smoothed output value will be calculated for all other
         pixels). If a .FALSE. value is given, then the NLIM argument
         determines whether an output pixel is good or bad.  The value
         of NLIM is not relevant if SAMBAD is .TRUE..
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If a .FALSE. value is given for this argument, then the
         smoothing applied will be appropriate to a data image. If a
         .TRUE. value is given, then the smoothing will be appropriate
         to an image containing variance values. In the latter case the
         output values will be (on average) smaller than the input
         values to take account of the variance-reducing effect which
         smoothing produces.
      }
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         First dimension of the image to be smoothed.
      }
      \sstsubsection{
         NY = INTEGER (Given)
      }{
         Second dimension of the image to be smoothed.
      }
      \sstsubsection{
         A( NX, NY ) = REAL (Given)
      }{
         Input image to be smoothed.
      }
      \sstsubsection{
         IBOXX = INTEGER (Given)
      }{
         Half-size of the smoothing box in pixels in the X direction
         (the actual size of the box used will be 2$*$IBOXX$+$1 pixels).
      }
      \sstsubsection{
         IBOXY = INTEGER (Given)
      }{
         Half-size of the smoothing box in pixels in the Y direction
         (the actual size of the box used will be 2$*$IBOXY$+$1 pixels).
      }
      \sstsubsection{
         NLIM = INTEGER (Given)
      }{
         Minimum number of good pixels which must be present in the
         smoothing box in order to calculate a smoothed output pixel.
         If this minimum number is not satisfied, then a bad output
         pixel will result. A value between 1 and the total number of
         pixels in the smoothing box should be supplied.
      }
      \sstsubsection{
         B( NX, NY ) = REAL (Returned)
      }{
         The smoothed output image.
      }
      \sstsubsection{
         BADOUT = LOGICAL (Returned)
      }{
         Whether bad pixels are present in the output image.
      }
      \sstsubsection{
         ASUM( NX ) = REAL (Returned)
      }{
         Workspace for the pixel sums.
      }
      \sstsubsection{
         NSUM( NX ) = INTEGER (Returned)
      }{
         Workspace for counting good pixels.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_CDESC
}{
   Convert a pointer to an area of mapped memory into a pointer to a
   character array descriptor
}{
   \sstdescription{
      The supplied pointer locates a section of memory to be used as a
      character array. This routine constructs a descriptor for the
      character array and replaces the supplied pointer with a pointer
      to this descriptor. The returned pointer can then be passed to a
      subroutine using the \%VAL construct, and the corresponding dummy
      argument can be declared as a passed length character array in
      the normal way.

      IRM\_CPOIN should be called to un-do the effect of this routine
      before releasing the mapped memory.
   }
   \sstinvocation{
      CALL IRM\_CDESC( LEN, POINT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LEN = INTEGER (Given)
      }{
         The number of characters in each element of the array.
      }
      \sstsubsection{
         POINT = INTEGER (Given and Returned)
      }{
         On input, this is a pointer to an area of memory mapped using
         (for instance) PSX\_CALLOC. On exit, it is a pointer to a
         character string descriptor.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_CFF2R
}{
   Rejects iteratively defects in a substantially smooth 2-d array
}{
   \sstdescription{
      This routine sets pixels in a 2-d array to be invalid if they
      deviate too far from {\tt '}local mean{\tt '} and lie within a nominated
      range of values.  The local mean is obtained by a rectangular
      neighbourhood block-average smooth of the input array.  An
      iterative procedure is followed where the cleaned array becomes
      the new array to be cleaned at another threshold, and is itself
      smoothed to find whether its pixels deviate from their smoothed
      counterparts. A pixel that does deviate is set to the bad value,
      as is its variance. Otherwise the pixel and variance are
      propagated to the cleaned array.  Iterations stop and status is
      set to SAI\_\_ERROR when the array is entirely composed of bad
      values or all pixels have been rejected.
   }
   \sstinvocation{
      CALL IRM\_CFF2R( NX, NY, INARR, VAR, NVAR, INVAR, BOXSZ, NITER,
                      CLIP, LIMITS, ILEVEL, SAMBAD, NLIM, CINARR,
                      OUTARR, OUTVAR, NGOOD, SIGMA, ASUM, NSUM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         First dimension of the image to be cleaned.
      }
      \sstsubsection{
         NY = INTEGER (Given)
      }{
         Second dimension of the image to be cleaned.
      }
      \sstsubsection{
         INARR( NX $*$ NY ) = REAL (Given)
      }{
         The input array containing the image from which the pixels
         with large deviation will be rejected.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         The state of the variance component of the input NDF.  If the
         variance component exists it is true.
      }
      \sstsubsection{
         NVAR = INTEGER (Given)
      }{
         The number of elements of the variance array.
      }
      \sstsubsection{
         INVAR( NVAR ) = REAL (Given)
      }{
         The variance array of the input array to be cleaned.  If the
         variance is present the dimensions should be NX by NY, as for
         the data arrays.
      }
      \sstsubsection{
         BOXSZ( 2 ) = INTEGER (Given)
      }{
         The size of smoothing box in pixels.
      }
      \sstsubsection{
         NITER = INTEGER (Given)
      }{
         The number of iterations in the rejection algorithm.
      }
      \sstsubsection{
         CLIP( NITER ) = REAL (Given)
      }{
         The maximum number of standard deviations for the rejection
         threshold at each iteration.
      }
      \sstsubsection{
         LIMITS( 2 ) = REAL (Given)
      }{
         The thresholds outside which any pixel data value will not be
         cleaned. The order is not important.
      }
      \sstsubsection{
         ILEVEL = INTEGER (Given)
      }{
         The interaction level.  If it is greater than one, the
         intermediate result of each iteration will be reported to the
         user.
      }
      \sstsubsection{
         SAMBAD = LOGICAL (Given)
      }{
         If a .TRUE. value is given for this argument, then bad input
         pixels will be propagated to the output image unchanged during
         smoothing (a smoothed output value will be calculated for all
         other pixels). If a .FALSE. value is given, then the NLIM
         argument determines whether an output pixel is good or bad.
         The value of NLIM is not relevant if SAMBAD is .TRUE.
      }
      \sstsubsection{
         NLIM = INTEGER (Given)
      }{
         Minimum number of good pixels which must be present in the
         smoothing box in order to calculate a smoothed output pixel.
         If this minimum number is not satisfied, then a bad output
         pixel will result. A value between 1 and the total number of
         pixels in the smoothing box should be supplied.
      }
      \sstsubsection{
         CINARR( NX $*$ NY ) = REAL (Given)
      }{
         Work array for containing the latest cleaned iteration,
         initially the input array to be supplied to the local-mean
         routine.  Thus on exit it contains the cleaned image before the
         last iteration.
      }
      \sstsubsection{
         OUTARR( NX $*$ NY ) = REAL (Returned)
      }{
         The output array to contain the processed image.
      }
      \sstsubsection{
         OUTVAR( NVAR ) = REAL (Returned)
      }{
         The variance of the output array.
      }
      \sstsubsection{
         NGOOD = INTEGER (Returned)
      }{
         The valid pixels in the output array. If input array has no
         valid pixel at all, it will be set to -1.
      }
      \sstsubsection{
         SIGMA = DOUBLE PRECISION (Returned)
      }{
         The estimate of the RMS noise per pixel in the output image.
      }
      \sstsubsection{
         ASUM( NX ) = REAL (Returned)
      }{
         Work array for pixel sums during smoothing the image.
      }
      \sstsubsection{
         NSUM( NX ) = INTEGER (Returned)
      }{
         Work array for counting good pixels during smoothing the image.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_CHKOB
}{
   Check a component of an object
}{
   \sstdescription{
      This routine checks that a component exists within the enclosing
      object, with the specified name, HDS type and shape. If no such
      component exists, and error status is returned.
   }
   \sstinvocation{
      CALL IRM\_CHKOB( LOC, INNAME, INTYPE, NDIMS, DIMS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Locator to the enclosing HDS object.
      }
      \sstsubsection{
         INNAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the component to be checked.
      }
      \sstsubsection{
         INTYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The expected HDS type for the component.
      }
      \sstsubsection{
         NDIMS = INTEGER (Given)
      }{
         The expected number of dimensions for the component. This
         should be set to zero for a scalar object, in which case the
         DIMS argument is ignored.
      }
      \sstsubsection{
         DIMS( $*$ ) = INTEGER (Given)
      }{
         The expected size of each dimension of the component.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_CLEAN
}{
   Clean a one dimensional data array by removing bright sources
}{
   \sstdescription{
      The output data is a copy of the input data except that bright
      sources are replaced by bad values.

      The input data is smoothed with a box filter of given width, and
      the residuals between the smoothed data and the original data are
      found. The RMS residual is then found and data values are set bad
      if they differ from the smoothed data values by more than a
      specified multiple of the RMS residual. The process is then
      repeated NITER times. An error is reported if all the data is bad
      on entry  or if all the data is removed by the cleaning algorithm.
   }
   \sstinvocation{
      CALL IRM\_CLEAN( LBND, UBND, DATIN, LBNDW, UBNDW, HBOX, NITER,
                      NSIGMA, DATOUT, RMS, WORK1, WORK2, WORK3, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The lower bound of the data.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The upper bound of the data.
      }
      \sstsubsection{
         DATIN( LBND : UBND ) = REAL (Given)
      }{
         The input data.
      }
      \sstsubsection{
         LBNDW = INTEGER (Given)
      }{
         The lower bound of the work arrays. This should be equal to
         LBND - HBOX - 1.
      }
      \sstsubsection{
         UBNDW = INTEGER (Given)
      }{
         The upper bound of the work arrays. This should be equal to
         UBND $+$ HBOX.
      }
      \sstsubsection{
         HBOX = INTEGER (Given)
      }{
         Half the width of the smoothing box. The full size is
         2$*$HBOX$+$1.
      }
      \sstsubsection{
         NITER = INTEGER (Given)
      }{
         The number of cleaning iterations to perform.
      }
      \sstsubsection{
         NSIGMA = REAL (Given)
      }{
         The multiple of the RMS residual at which points will be
         rejected.
      }
      \sstsubsection{
         DATOUT( LBND : UBND ) = REAL (Returned)
      }{
         The cleaned data.
      }
      \sstsubsection{
         RMS = REAL (Returned)
      }{
         An estimate of the standard deviation of the noise in the input
         data.
      }
      \sstsubsection{
         WORK1( LBNDW : UBNDW ) = REAL (Returned)
      }{
         Work space.
      }
      \sstsubsection{
         WORK2( LBNDW : UBNDW ) = REAL (Returned)
      }{
         Work space.
      }
      \sstsubsection{
         WORK3( LBNDW : UBNDW ) = INTEGER (Returned)
      }{
         Work space.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_COMNT
}{
   Get the value of a FITS COMMENT card from a buffer of cards
}{
   \sstdescription{
      This routine searches a buffer containing the header card images
      from a FITS file for the next card with keyword COMMENT.  The
      search begins at a defined card image; and ends when the next end
      of a header block, marked by the END keyword, is encountered or
      the buffer is exhausted.  The routine returns the comment string,
      and the number of the card image within the buffer array that
      contains the comment.  If the keyword is is present \%THERE is
      true, otherwise it is false.
   }
   \sstinvocation{
      CALL IRM\_COMNT( NCARD, BUFFER, STCARD, THERE, VALUE, CARD,
                      STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of card images in the buffer.
      }
      \sstsubsection{
         BUFFER( NCARD ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The buffer containing the header card images.
      }
      \sstsubsection{
         STCARD = INTEGER (Given)
      }{
         The number of the card from which to search for the next
         comment card
      }
      \sstsubsection{
         THERE = LOGICAL (Returned)
      }{
         If true the parameter \%NAME is present.
      }
      \sstsubsection{
         VALUE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The comment string of the first COMMENT keyword found at or
         after \%STCARD.  The length should be at least 72 characters.
      }
      \sstsubsection{
         CARD = INTEGER(Returned)
      }{
         The number of the card containing the first COMMENT card. If
         no COMMENT card could be found this is returned with a value of
         zero.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   IRM\_CPOIN
}{
   Convert a pointer to a character array descriptor into a
   pointer to the area of mapped memory which holds the characters
}{
   \sstdescription{
      This routine performs the opposite function to IRM\_CDESC, i.e.
      it converts a pointer to a character array descriptor into a
      pointer to the memory used to store the characters. The dynamic
      memory used to hold the character string descriptor (if any) is
      released, but the memory used to store the actual characters is
      not released.
   }
   \sstinvocation{
      CALL IRM\_CPOIN( POINT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         POINT = INTEGER (Given and Returned)
      }{
         On input, this is a pointer to a character array
         descriptor obtained using IRM\_CDESC. On exit, it is a pointer
         to the area of memory containing the actual character data.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_CRTYP
}{
   Check the type of a group of CRDD NDF files
}{
   \sstdescription{
      This subroutine is used to check whether a group of CRDD NDF files
      come from the same CRDD type. If not, the status will be set.
   }
   \sstinvocation{
      CALL IRM\_CRTYP( NCRDD, NDFID, TYPE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCRDD = INTEGER (Given)
      }{
         The number of CRDD NDF files.
      }
      \sstsubsection{
         NDFID( NCRDD ) = INTEGER (Given)
      }{
         The IDs of the CRDD NDF files.
      }
      \sstsubsection{
         TYPE = CHARACTER (Returned)
      }{
         The type of the CRDD files if they are from the same type.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_CVDET
}{
   Find the detectors not included in a supplied list of detectors
}{
   \sstdescription{
      Argument ADET is supplied holding a list of available detector
      numbers. The argument DETS1 is supplied holding a subset of the
      available detector numbers.  DETS2 is returned holding all the
      detectors in ADET which are not also in DETS1. NDETS2 returns the
      number of such detectors. Any detector numbers supplied in DETS1
      which are not also in ADET are ignored. Any numbers which are not
      legal detector numbers are also ignored.
   }
   \sstinvocation{
      CALL IRM\_CVDET( NDET, ADET, NDETS1, DETS1, DETS2, NDETS2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDET = INTEGER (Given)
      }{
         The size of the ADET and DETS2 arrays.
      }
      \sstsubsection{
         ADET( NDET ) = INTEGER (Given)
      }{
         The list of all available detector numbers.
      }
      \sstsubsection{
         NDETS1 = INTEGER (Given)
      }{
         The number of detectors listed in the DETS1 array.
      }
      \sstsubsection{
         DETS1( $*$ ) = INTEGER (Given)
      }{
         A list of detector numbers selected from those contained
         in ADET.
      }
      \sstsubsection{
         DETS2( NDET ) = INTEGER (Returned)
      }{
         A list of the detector numbers which are included in ADET, but
         not in DETS1.
      }
      \sstsubsection{
         NDETS2 = INTEGER (Returned)
      }{
         The number of detector numbers stored in DETS2. The detector
         numbers are stored in elements 1 to NDETS2.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_DELOB
}{
   Delete an HDS object given its locator
}{
   \sstdescription{
      The parent object is found, together with the name of the object
      to be deleted. The locator to the object is annulled and the object
      deleted, together with all lower level components. If the object
      to be deleted does not have a parent object, then an error occurs.
   }
   \sstinvocation{
      CALL IRM\_DELOB( LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Given)
      }{
         An HDS locator to the object to be deleted, NOT the enclosing
         object.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_DIMEN
}{
   Obtain a pair of dimensions using the ADAM parameter system
}{
   \sstdescription{
      This routine can be used to get pixel dimensions, image
      dimensions, etc. An attempt is made to obtain an array of two
      values for the supplied ADAM parameter. These are interpreted as
      dimension sizes in arc-minutes. If only one value is obtained, the
      same value is used for both dimensions.  If either dimension
      is less than the value of LIMIT, it is set equal to LIMIT and the
      user is warned of this.
   }
   \sstinvocation{
      CALL IRM\_DIMEN( PARAM, DEFLT, LIMIT, DIMENS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The ADAM parameter to associate with the dimensions.
      }
      \sstsubsection{
         DEFLT = LOGICAL (Given)
      }{
         If true, the values of DIMENS on entry are supplied to the
         user as run-time defaults.
      }
      \sstsubsection{
         LIMIT = REAL (Given)
      }{
         The smallest acceptable dimension, in radians.
      }
      \sstsubsection{
         DIMENS( 2 ) = REAL (Given and Returned)
      }{
         If DEFLT is true, then on entry DIMENS contains the values to
         use as the run-time default for the given ADAM parameter (in
         radians). On exit, DIMENS contains the required dimensions,
         in radians.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_ELLIP
}{
   Draw an ellipse
}{
   \sstdescription{
      An ellipse is drawn using the current SGS pen. Nothing is drawn
      if any of the supplied argument values are bad (but no error is
      reported).
   }
   \sstinvocation{
      CALL IRM\_ELLIP( X, Y, XSIZE, YSIZE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         X = REAL (Given)
      }{
         World X coordinate of ellipse centre
      }
      \sstsubsection{
         Y = REAL (Given)
      }{
         World Y coordinate of ellipse centre
      }
      \sstsubsection{
         XSIZE = REAL (Given)
      }{
         Half-axis size in world X coordinate
      }
      \sstsubsection{
         YSIZE = REAL (Given)
      }{
         Half-axis size in world Y coordinate
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_FILNM
}{
   Extract a file name from an NDG file specification
}{
   \sstdescription{
      The file name is considered to be everything occurring after the
      final {\tt "}]{\tt "} (VMS) or {\tt "}/{\tt "} (UNIX) character. If neither of these two
      characters are found in the string then the supplied string is
      returned unchanged.
   }
   \sstinvocation{
      CALL IRM\_FILNM( INSTR, OUTSTR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INSTR = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The full file specification (as retrieved from an NDG group).
      }
      \sstsubsection{
         OUTSTR = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The file name.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_FIT2
}{
   Fit a least squares straight line to supplied data
}{
   \sstdescription{
      A straight line is fitted to the data supplied in X and Y, using
      the least squares criterion. The returned values of M and C are
      the gradient and intercept of the fit, so that y = M.x $+$ C. The
      RMS residual of the Y data from the fit is returned in RMS.

      An error is reported if there are less than two good data values
      in Y, or if the X values cover a range of zero.
   }
   \sstinvocation{
      CALL IRM\_FIT2( LBND, UBND, Y, X, M, C, RMS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The lower bound of the X and Y arrays.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The upper bound of the X and Y arrays.
      }
      \sstsubsection{
         Y( LBND : UBND ) = REAL (Given)
      }{
         The Y data values. Any bad values are ignored.
      }
      \sstsubsection{
         X( LBND : UBND ) = REAL (Given)
      }{
         The X positions corresponding to each Y data value.
      }
      \sstsubsection{
         M = REAL (Returned)
      }{
         The gradient.
      }
      \sstsubsection{
         C = REAL (Returned)
      }{
         The intercept.
      }
      \sstsubsection{
         RMS = REAL (Returned)
      }{
         The RMS residual between the Y values and the fit.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_GDTYP
}{
   Get the graphic device type
}{
   \sstdescription{
      This subroutine inquires the workstation class of the current
      graphic workstation. See document SUN57 (appendix A ) for the
      defined classes.
      A graphic workstation should have been opened before calling
      this routine.
   }
   \sstinvocation{
      CALL IRM\_GDTYP( GPTYPE, GDTYPE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         GPTYPE = CHARACTER$*$( $*$ ) (Given)
      }{
         The graphics system. It must be {\tt '}SGS{\tt '}, or {\tt '}GKS{\tt '} at present.
      }
      \sstsubsection{
         GDTYPE = CHARACTER $*$ ( $*$ )$*$( GNS\_\_SZKEY ) (Given)
      }{
         The current workstation class. It should have defined length
         no less than GNS\_\_SZKEY
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_GETQX
}{
   Get a quality expression from the user and check for syntax
   errors
}{
   \sstdescription{
      A string is obtained from the environment using the supplied ADAM
      parameter. This string is check to see if it has correct syntax
      for a quality expression (no checks are made to ensure that the
      quality names referenced within the expression are defined within
      any specific NDF). If a syntax error is detected, the quality
      expression is displayed with an exclamation mark under the
      position at which the syntax error was detected. If any problem is
      found with the supplied expression, a new value is obtained from
      the environment. The returned string is converted to upper case
      and leading blanks are removed.
   }
   \sstinvocation{
      CALL IRM\_GETQX( PARAM, QEXP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of an ADAM parameter of type LITERAL.
      }
      \sstsubsection{
         QEXP = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The returned quality expression.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_GETTD
}{
   Get a valid date and time string from the environment
}{
   \sstdescription{
      This routine gets a string from the environment using the
      specified parameter, and checks that it is a valid date and time
      string, as described in routine IRM\_TD. If it is, the
      corresponding Modified Julian Date is returned. If it is not a
      valid date and time string, the parameter is cancelled and another
      string is obtained.
   }
   \sstinvocation{
      CALL IRM\_GETTD( PARAM, TIMDAT, MJD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The parameter.
      }
      \sstsubsection{
         TIMDAT = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The string obtained from the environment. The variable
         specified for this argument should be at least 25 characters
         long.
      }
      \sstsubsection{
         MJD = DOUBLE PRECISION (Returned)
      }{
         The Modified Julian Date corresponding to the date and time
         string. A blank string causes the current time to be returned.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_GKCMT
}{
   Get the comment string of a specified FITS keyword
}{
   \sstdescription{
      This routine searches a buffer containing the header card images
      from a FITS file for the next card with the specified keyword, and
      returns the comment string of the found keyword. The search
      begins at a defined card image; and ends when the next end of a
      header block, marked by the END keyword, is encountered or the
      buffer is exhausted.

      The comment string of a keyword begins with a comment indicator
      character, specified by the argument CMTBGN, in the same card as
      the keyword and may extend several cards with the continuation
      cards having the keyword COMMENT or being blank at its keyword
      position and preceded by a comment indicator. The argument
      CMTCRD specifies maximum number of continuation comment cards
      whose contents will be included in the returned string.

      If the keyword is present, \%THERE is true, otherwise it is false.
      If there is no comment string for this keyword the returned
      string will be blank.
   }
   \sstinvocation{
      CALL IRM\_GKCMT( NCARD, BUFFER, STCARD, NAME, CMTBGN, CMTCRD,
                      THERE, COMNT, CARDNO, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of card images in the buffer.
      }
      \sstsubsection{
         BUFFER( NCARD ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The buffer containing the header card images.
      }
      \sstsubsection{
         STCARD = INTEGER (Given)
      }{
         The number of the card from which to start the search.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the keyword whose comment is required. This may be
         a compound name to handle hierarchical keywords, and it has the
         form keyword1.keyword2.keyword3 etc. The maximum number of
         keywords per FITS card is 20. Comparisons are performed in
         uppercase and blanks are removed. Each keyword must be no
         longer than 8 characters.
      }
      \sstsubsection{
         CMTBGN = CHARACTER $*$ ( 1 ) (Given)
      }{
         The character which indicates the beginning of the comment
         string of a keyword. Normally it is {\tt '}/{\tt '}.
      }
      \sstsubsection{
         CMTCRD = INTEGER (Given)
      }{
         The maximum number of continuation comment cards whose
         contents will be included in the returned string. If it is 0,
         only the comment string in the same card as keyword will be
         returned.  If the actual number of continuation comment cards
         is less than that specified by CMTCRD, the contents of actual
         number of cards will be included in the returned string.
      }
      \sstsubsection{
         THERE = LOGICAL (Returned)
      }{
         If true the specified keyword is present.
      }
      \sstsubsection{
         COMNT = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The comment string of the specified keyword. It should have
         length not less than 72 $+$ 72$*$CMTCRD characters.
      }
      \sstsubsection{
         CARDNO = INTEGER ( Returned)
      }{
         The number of the last continuation comment card whose contents
         are included in the returned string.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_GKEYC
}{
   Get the value of a named header of type CHARACTER from a buffer of
   FITS header card images
}{
   \sstdescription{
      This routine searches a buffer containing the header card images
      from a FITS file for card with keyword \%NAME; and returns its
      CHARACTER value, \%VALUE, and the number of the card image within
      the buffer array that contains the named keyword.  The search
      ends when the next end of a header block, marked by the END
      keyword, is encountered or the buffer is exhausted.  If the
      keyword is present \%THERE is true, otherwise it is false.  If the
      parameter is present more than once in the header, only the first
      occurrence will be used.

      The name may be compound to permit reading of hierarchical
      keywords.  This routine will also work for HISTORY and COMMENTS
      provided there is but one value given on the line, i.e. only
      one {\tt "}keyword = {\tt '}value{\tt '}{\tt "} before any comment marker. An error will
      result otherwise.
   }
   \sstinvocation{
      CALL IRM\_GKEYC( NCARD, BUFFER, SCARD, NAME, THERE, VALUE, CARD,
                      STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of card images in the buffer.
      }
      \sstsubsection{
         BUFFER( NCARD ) = CHARACTER $*$ 80 (Given)
      }{
         The buffer containing the header card images.
      }
      \sstsubsection{
         SCARD = INTEGER (Given)
      }{
         The number of the card from where the search will begin.  This
         is needed because the headers make contain a dummy header
         prior to an extension.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the keyword whose value is required.  This may be
         a compound name to handle hierarchical keywords, and it has
         the form keyword1.keyword2.keyword3 etc.  The maximum number of
         keywords per FITS card is 20.  Comparisons are performed in
         uppercase and blanks are removed.  Each keyword must be no
         longer than 8 characters.
      }
      \sstsubsection{
         THERE = LOGICAL (Returned)
      }{
         If true the keyword \%NAME is present.
      }
      \sstsubsection{
         VALUE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The value of the keyword.  The string is truncated to the
         length of VALUE if the FITS value contains more characters than
         tat.
      }
      \sstsubsection{
         CARD = INTEGER (Returned)
      }{
         The number of the card containing the named keyword.
         If the card could not be found this is set to zero.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   IRM\_GKEYR
}{
   Get the value of a named header of type \_REAL from a buffer of
   FITS header card images
}{
   \sstdescription{
      This routine searches a buffer containing the header card images
      from a FITS file for card named \%NAME; and returns its \_REAL
      value, \%VALUE, and the number of the card image within the buffer
      array that contains the named keyword.  The search ends when the
      next end of a header block, marked by the END keyword, is
      encountered or the buffer is exhausted.  If the keyword is
      present \%THERE is true, otherwise it is false.   Since all images
      are in character format, type conversion is performed.  An error
      status will be returned if the conversion has failed.  If the
      keyword is present more than once in the header, only the first
      occurence will be used.

      The name may be compound to permit reading of hierarchical
      keywords.  This routine will also work for HISTORY and COMMENTS
      provided there is but one value given on the line, i.e. only
      one {\tt "}keyword = value{\tt "} before any comment marker. An error will
      result otherwise.
   }
   \sstinvocation{
      CALL IRM\_GKEYR( NCARD, BUFFER, SCARD, NAME, THERE, VALUE, CARD,
                      STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of card images in the buffer.
      }
      \sstsubsection{
         BUFFER( NCARD ) = CHARACTER $*$ 80 (Given)
      }{
         The buffer containing the header card images.
      }
      \sstsubsection{
         SCARD = INTEGER (Given)
      }{
         The number of the card from where the search will begin.  This
         is needed because the headers make contain a dummy header
         prior to an extension.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the keyword whose value is required.  This may be
         a compound name to handle hierarchical keywords, and it has
         the form keyword1.keyword2.keyword3 etc.  The maximum number of
         keywords per FITS card is 20.  Comparisons are performed in
         uppercase and blanks are removed.  Each keyword must be no
         longer than 8 characters.
      }
      \sstsubsection{
         THERE = LOGICAL (Returned)
      }{
         If true the keyword \%NAME is present.
      }
      \sstsubsection{
         VALUE = REAL (Returned)
      }{
         The value of the keyword.
      }
      \sstsubsection{
         CARD = INTEGER (Returned)
      }{
         The number of the card containing the named keyword.
         If the card could not be found this is set to zero.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstbugs{
      None known.
   }
}
\sstroutine{
   IRM\_GROPN
}{
   Open an SGS workstation for use with NCAR
}{
   \sstdescription{
      This routine gets the name of an SGS workstation from the user and
      opens it, using AGI to create a zone corresponding to the current
      AGI picture. The zone will be cleared upon opening if requested.
      A new zone is reated within this first zone of a size specified by
      the user. This new zone is stored in the AGI database as the
      {\tt '}FRAME{\tt '} picture for future plotting and is the current SGS zone on
      on exit from this routine. A call to SNX\_AGWV is made before
      returning to ensure that AUTOGRAPH uses the full zone for
      plotting. Some attributes of the graphic device, such as whether
      the cursor and colour are available on the device and whether the
      zone can be partially cleared, is also returned. If colour is
      available on the device and the colour representation is
      changeable, the routine will set the colour representation to the
      standard SGS pen colour.
   }
   \sstinvocation{
      CALL IRM\_GROPN( PDEV, PXSZ, PYSZ, CLEAR, COMMNT, PIC0, PIC1,
                   ZONE, COLOUR, CURSOR, CLRBLK, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PDEV = CHARACTER$*$( $*$ ) (Given)
      }{
         The name of an ADAM parameter used to get a graphics
         workstation.
      }
      \sstsubsection{
         PXSZ = CHARACTER$*$( $*$ ) (Given)
      }{
         The name of an ADAM parameter used to get the required X extent
         of the FRAME picture in metres.
      }
      \sstsubsection{
         PYSZ = CHARACTER$*$( $*$ ) (Given)
      }{
         The name of an ADAM parameter used to get the required Y extent
         of the FRAME picture in metres.
      }
      \sstsubsection{
         CLEAR = LOGICAL (Given)
      }{
         If true, the display will be cleared upon opening.
      }
      \sstsubsection{
         COMMNT = CHARACTER$*$( $*$ )
      }{
         Comment write to the AGI database with the FRAME picture.
      }
      \sstsubsection{
         PIC0 = INTEGER (Returned)
      }{
         The picture identifier for the picture on entry.
      }
      \sstsubsection{
         PIC1 = INTEGER (Returned)
      }{
         The picture identifier for the new FRAME picture.
      }
      \sstsubsection{
         ZONE = INTEGER (Returned)
      }{
         The SGS zone identifier for the current zone on exit.
      }
      \sstsubsection{
         COLOUR = LOGICAL (Returned)
      }{
         If the graphics workstation has colour available, it is true.
         Otherwise it is false.
      }
      \sstsubsection{
         CURSOR = LOGICAL (Returned)
      }{
         If the cursor is available on the device, it is true.
         Otherwise, it is false.
      }
      \sstsubsection{
         CLRBLK = LOGICAL (Returned)
      }{
         If the zone can be partially cleared, it is true. Otherwise, it
         is false.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_GTAST
}{
   Get an IRA astrometry structure associated with an AGI picture
}{
   \sstdescription{
      An attempt is made to get an NDF from the environment using the
      supplied parameter. If this is successful, astrometry information
      is read from the NDF. If a null value is obtained, then an attempt
      is made to get astrometry information from the MORE structure
      stored with the picture in the AGI database. If this fails, an
      attempt is made to get astrometry information from the reference
      object stored with the picture in the AGI database. If this fails,
      the supplied parameter value is cancelled and another attempt is
      made to get an NDF from the environment.

      If the conditional message filter level is not set to MSG\_\_QUIET
      then an informational message is displayed if the astrometry
      information is obtained from the MORE structure or from the
      reference object.
   }
   \sstinvocation{
      CALL IRM\_GTAST( PARAM, PICID, LBND, UBND, IDA, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The parameter to use.
      }
      \sstsubsection{
         PICID = INTEGER (Given)
      }{
         The AGI identifier for the picture for which the associated
         astrometry structure is required.
      }
      \sstsubsection{
         LBND( 2 ) = INTEGER (Returned)
      }{
         The lower pixel bounds of the NDF given by parameter PARAM or
         stored as the reference object. If the astrometry structure is
         obtained from the MORE structure of the picture, then LBND is
         returned holding the pixel indices corresponding to the lower
         bounds of the picture (assuming the pictures world coordinates
         are pixel coordinates).
      }
      \sstsubsection{
         UBND( 2 ) = INTEGER (Returned)
      }{
         The upper pixel bounds of the NDF given by parameter PARAM or
         stored as the reference object. If the astrometry structure is
         obtained from the MORE structure of the picture, then UBND is
         returned holding the pixel indices corresponding to the upper
         bounds of the picture (assuming the pictures world coordinates
         are pixel coordinates).
      }
      \sstsubsection{
         IDA = INTEGER (Returned)
      }{
         The IRA identifier for the astrometry information.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_GTBND
}{
   Get a survey waveband index from the environment
}{
   \sstdescription{
      This routine gets an index for a survey waveband from the
      environment using the supplied parameter. The user specifies the
      waveband by giving its central wavelength in microns (eg 12, 25,
      etc ), but the corresponding index ( 1, 2, etc ) is returned in
      argument BAND. The user is re-prompted if a bad value is
      obtained.
   }
   \sstinvocation{
      CALL IRM\_GTBND( PARAM, DEFAUL, NULL, BAND, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The parameter to use (integer valued)
      }
      \sstsubsection{
         DEFAUL = INTEGER (Given)
      }{
         The default waveband index. If  a legal value is supplied
         (1-4), then this value is established as the dynamic default
         for the parameter before getting a value for the parameter. If
         an illegal value is supplied, no dynamic default is set up, but
         no error is reported.
      }
      \sstsubsection{
         NULL = LOGICAL (Given)
      }{
         If true, then a null response for the parameter does not cause
         an error status to be returned, but is treated as being
         equivalent to the user specifying the band given by DEFAUL.
      }
      \sstsubsection{
         BAND = INTEGER (Returned)
      }{
         The waveband index. Returned equal to DEFAUL if an error
         occurs (unless DEFAUL is an invalid waveband index, in which
         case 1 is returned).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_GTCUN
}{
   Get a CRDD units system from the environment
}{
   \sstdescription{
      This routine returns a system of units in mixed case (unlike
      PAR\_CHOIC which always returns strings in upper case).
   }
   \sstinvocation{
      CALL IRM\_GTCUN( PARAM, DEFAUL, UNITS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The parameter name.
      }
      \sstsubsection{
         DEFAUL = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The suggested default value.
      }
      \sstsubsection{
         UNITS = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The units string obtained from the environment.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_GTDET
}{
   Get a set of detector numbers from the user
}{
   \sstdescription{
      This routine obtains a set of detector numbers from the
      environment using the parameter specified by PARAM. The detectors
      must be selected from the set of available detectors specified by
      ADET. The detectors are specified by a group expression in which
      each member of the group can be any of the following:

      \sstitemlist{

         \sstitem
         An integer in the range 1 to 62 specifying an explicit
         detector number.

         \sstitem
         One of the strings {\tt "}12um{\tt "}, {\tt "}25um{\tt "}, {\tt "}60um{\tt "} and {\tt "}100um{\tt "}. These
         cause all available detectors from the specified wave band to be
         selected.

         \sstitem
         A range of detectors, specified by two detector numbers
         sepatated by a colon ({\tt "}:{\tt "}). All available detectors whose
         focal plane Z positions are between those of the two detectors are
         selected. If the first detector number is omitted, no lower limit
         is imposed. If the second detector is omitted, no upper limit is
         imposed.

         \sstitem
          The string {\tt "}ALL{\tt "}. This specifies that all available detectors
          should be selected.

         \sstitem
          The string {\tt "}SMALL{\tt "}. This specifies that all available small
          detectors (i.e. less than 4 arc-minutes cross-scan size) should
          be selected.

         \sstitem
          The string {\tt "}LARGE{\tt "}. This specifies that all available detectors
          should be selected, excluding the small detectors.

         \sstitem
          The string {\tt "}NONE{\tt "}. This specifies that no detectors should be
          selected, and may not be mixed with other options. A null
          parameter value is equivalent to {\tt "}NONE{\tt "}.

         \sstitem
          The string {\tt "}LIST{\tt "}. This causes a list of available detectors
          to be displayed, but no detectors are selected. The user is
          re-prompted if this option is selected. This option may not be
          mixed with any other options.
      }
   }
   \sstinvocation{
      CALL IRM\_GTDET( PARAM, NDET, ADET, DETOUT, NOUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The ADAM parameter.
      }
      \sstsubsection{
         NDET = INTEGER (Given)
      }{
         The total number of available detectors.
      }
      \sstsubsection{
         ADET( NDET ) = INTEGER (Given)
      }{
         Array holding the available detector numbers
      }
      \sstsubsection{
         DETOUT( NDET ) = INTEGER (Returned)
      }{
         Array holding the selected detector numbers in the order of
         increasing focal plane Z coordinate.
      }
      \sstsubsection{
         NOUT = INTEGER (Returned)
      }{
         The number of selected detectors. Returned equal to 1 if an
         error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         {\tt "}ALL{\tt "}, {\tt "}SMALL{\tt "}, {\tt "}LARGE{\tt "}, {\tt "}NONE{\tt "} and {\tt "}LIST{\tt "} can be abbreviated.

         \sstitem
         The union of the specified detectors are returned. Thus for
         instance, if all 62 detectors are available, and the group
         expression {\tt "}12um,small{\tt "} is supplied, the returned set of
         detectors consists of all 12um detectors together with all small
         detectors from all 4 bands, not just the small detectors from the
         12um band.
      }
   }
}
\sstroutine{
   IRM\_GTHLP
}{
   Prints help text from a library of help information
}{
   \sstdescription{
      Prints help text from an help library. A specific keyword/topic
      can be specified.
   }
   \sstinvocation{
      CALL IRM\_GTHLP( HELPLB, KEYWRD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         HELPLB = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the help library file.
      }
      \sstsubsection{
         KEYWRD = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The keyword about which help is required.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This is the VMS version.
      }
   }
}
\sstroutine{
   IRM\_HIST
}{
   Add history information to an NDF
}{
   \sstdescription{
      A value is obtained for the given ADAM parameter (which should be
      of type LOGICAL). If a false value is obtained then the routine
      deletes any existing history information from the supplied NDF.
      Otherwise, the supplied history information is added to the
      supplied NDF. If the NDF does not have a defined HISTORY
      component, then an empty HISTORY component is created and the
      supplied information is added to it. The HISTORY structure created
      conforms with the description of HISTORY contained in SGP/38.2.
   }
   \sstinvocation{
      CALL IRM\_HIST( PARAM, INDF, COMMND, SIZE, TEXT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of an ADAM parameter which is used to allow the user
         to enable or disable HISTORY recording. This parameter must
         be of type LOGICAL.
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         The identifier for the NDF to which history information is to
         be added.
      }
      \sstsubsection{
         COMMND = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the application currently running.
      }
      \sstsubsection{
         SIZE = INTEGER (Given)
      }{
         The number of lines of text to be stored in the new history
         record.
      }
      \sstsubsection{
         TEXT( SIZE ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The lines of history text to be stored.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_HMENU
}{
   Draw a horizontal menu and select an item from it
}{
   \sstdescription{
      This routine draw a horizontal menu in the current SGS zone,
      or display a menu on the user{\tt '}s terminal, and select one of the
      items of the menu with cursor.

      The extent of the menu are specified with world coordinate.
      The menu is composed of a number of horizontally arranged
      identical boxes, each of which contains one item of the menu.
      The routine is not clever enough to decide the best number of
      lines when writing the content of the item into the box. So the
      calling routine must specifies approximately how many lines the
      content of an item should be split into when writing it into
      the box. The routine will find the best way to split the content
      of the item into the approximately specified number of lines.
      The actual number of lines may be more or less than the
      specified number.

      If selecting an item is requested, the routine will loop
      until one item is selected. When selecting an item from the
      menu, put the cursor in the box of that item and press any key.
      The routine will put the cursor on the default item specified by
      DEFNO after drawing the menu and after each invalid selection.

      A SGS device must be opened before calling this routine.
   }
   \sstinvocation{
      CALL IRM\_HMENU( NITEM, INMENU, NROW, DEFNO, X1, X2, Y1, Y2,
                      INTITL, COLOUR, FONT, TXTHT, GTITM, ITEMNO,
                      STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NITEM = INTEGER (Given)
      }{
         The number of items in the menu.
      }
      \sstsubsection{
         INMENU = CHARACTER$*$($*$) (Given)
      }{
         The list of the items in the menu separated by comma. No space
         is allowed after each comma.
      }
      \sstsubsection{
         NROW( NITEM ) = INTEGER (Given)
      }{
         The approximate number of lines into which the content of
         each item should be split when writing it into its menu box.
      }
      \sstsubsection{
         DEFNO = INTEGER
      }{
         Specifies the item number which will be used as default item.
      }
      \sstsubsection{
         X1, X2, Y1, Y2 = REAL (Given)
      }{
         The extent of menu bar in the current world coordinate system.
      }
      \sstsubsection{
         INTITL = CHARACTER$*$($*$) (Given)
      }{
         The title of the menu.
      }
      \sstsubsection{
         COLOUR = LOGICAL (Given)
      }{
         If it is true, colour is available on the current graphic
         device. The frame of the menu box will draw in green while the
         contents of menu will written in white. Otherwise, the colour
         is not available, both the frame and the contents will be in
         white.
      }
      \sstsubsection{
         FONT = INTEGER (Given)
      }{
         Font code, 1 is ordinary Roman letters and Arabic numbers. For
         other available font code, see GKS User Guide.
      }
      \sstsubsection{
         TXTHT = REAL (Given)
      }{
         The height of the text in the menu.
      }
      \sstsubsection{
         GTITM = LOGICAL (Given)
      }{
         If true, an item will be selected by cursor, otherwise, no item
         will be selected before exit.
      }
      \sstsubsection{
         ITEMNO = INTEGER (Returned)
      }{
         The item number which user selected from the menu.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_HMFFT
}{
   Takes the FFT of an Hermitian image
}{
   \sstdescription{
      NAG routines are used to produce the FFT of the input Hermitian
      image. The input must be stored in transposed form (i.e rows and
      columns swapped). Because the input is Hermitian, the output will
      be a purely real image ( in normal non-transposed form).
      Hermitian FFTs are much faster than normal FFTs and require only
      half the space to store them. See the NAG manual chapter C06 for
      more information about Hermitian FFTs.
   }
   \sstinvocation{
      CALL IRM\_HMFFT( IN, NPIX, NLIN, WORK, FORWRD, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IN( NLIN, NPIX ) = DOUBLE PRECISION (Given)
      }{
         The input Hermitian image, in transposed form (i.e. rows and
         columns are swapped).
      }
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         No. of pixels per line in the input image.
      }
      \sstsubsection{
         NLIN = INTEGER (Given)
      }{
         No. of lines in the input image.
      }
      \sstsubsection{
         WORK( NLIN, NPIX) = DOUBLE PRECISION (Given)
      }{
         Work space.
      }
      \sstsubsection{
         FORWRD = LOGICAL (Given)
      }{
         True if a forward transformation is required, otherwise an
         inverse transformation is performed.
      }
      \sstsubsection{
         OUT( NPIX, NLIN ) = DOUBLE PRECISION (Returned)
      }{
         The FFT of the input. A purely real image in normal
         (non-tranmsposed) form (i.e rows and columns are not swapped).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_HMSG
}{
   Assign the name of an HDS object to a message token
}{
   \sstdescription{
      The routine assigns the full name (including the file name) of an
      HDS object to a message token for use with the ERR\_ and MSG\_
      routines (SUN/104). Appropriate syntax is used to represent file
      names which do not have the standard (.SDF) file type.
   }
   \sstinvocation{
      CALL IRM\_HMSG( TOKEN, LOC )
   }
   \sstarguments{
      \sstsubsection{
         TOKEN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the message token.
      }
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Locator to the HDS object.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine has no STATUS argument and does not perform
         normal error checking. If it should fail, then no value will be
         assigned to the message token and this will be apparent in the
         final message.
      }
   }
   \sstdiytopic{
      VAX-specific features used
   }{
      \sstitemlist{

         \sstitem
         This routine makes assumptions about the form of a VMS file
         name (but WILL run OK on UNIX).
      }
   }
}
\sstroutine{
   IRM\_HMULT
}{
   Multiply two Hermitian images
}{
   \sstdescription{
      Each input Hermitian image represents a COMPLEX image in which
      certain symetries exist. These symetries allow all the
      information stored in the COMPLEX image to be compressed into a
      single REAL image. This routine effectively unpacks the two REAL
      images given as input into two COMPLEX images, multiplies them
      together pixel-by-pixel to produce another COMPLEX image, and
      then packs the COMPLEX image back into a single Hermitian REAL
      image. In fact it is not necessary to do the actual unpacking and
      packing of these Hermitian images; this algorithm generates the
      output Hermitian image directly and thus saves time.

      NB, to make this routine consistent with the routines RLFFT and
      HMFFT which also handle Hermitian images, the input and output
      Hermitian images are all defined to be in {\tt "}transposed{\tt "} form, in
      which the rows and columns are reversed from their normal form.
      Thus the first array index is in what is normally called the
      {\tt "}line{\tt "} direction and the second is in the {\tt "}pixel{\tt "} direction.

      Each of the supplied FFTs can be thought of as being derived as
      follows (see the NAG manual, introduction to chapter C06 for more
      information on the storage of Hermitian FFTs):
   }
   \sstinvocation{
      CALL IRM\_HMULT( IN1, IN2, M, N, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IN1( N, M ) = DOUBLE PRECISION (Given)
      }{
         The first input transposed Hermitian image.
      }
      \sstsubsection{
         IN2( N, M ) = DOUBLE PRECISION (Given)
      }{
         The first input transposed Hermitian image.
      }
      \sstsubsection{
         M = INTEGER (Given)
      }{
         No. of pixels per line in the non-transposed image from which
         the Hermitian images were created.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         No. of lines in the non-transposed image from which the
         Hermitian images were created.
      }
      \sstsubsection{
         OUT( N, M ) = DOUBLE PRECISION (Returned)
      }{
         The product of the two input images, in transposed Hermitian
         form.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_IATTR
}{
   Get an item of graphical information from IRM common blocks
}{
   \sstdescription{
      Various IRM routines (written by Wei Gong) allow attributes of an
      NCAR plot to be set up (eg colour, dashed line pattern, etc).
      These routines store items of information in internal IRM common
      blocks. However, NCAR applications such as TRACECRDD need to get
      at these values stored in common. It is bad practice for an
      application to attempt to directly access common blocks declared
      internally within a (supposedly) independent subroutine package,
      as it means that the implementation of IRM cannot be changed
      without also changing the applications.  Also, IRM is usually
      distributed in a sharable form, which makes it difficult for
      applications to access its internal common blocks.

      This routine gets round these problems by providing a subroutine
      interface for accessing these common values.
   }
   \sstinvocation{
      CALL IRM\_IATTR( ITEM, CURVE, IVAL, LVAL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         ITEM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The attribute required. These are listed in the {\tt "}Notes:{\tt "}
         section below.
      }
      \sstsubsection{
         CURVE = INTEGER (Given)
      }{
         The curve to which the returned value should refer. An error
         is reported if this is out of bounds (1 to the value of the
         NCURV attribute). It is ignored if the item does not have a
         separate value for each curve.
      }
      \sstsubsection{
         IVAL = INTEGER (Returned)
      }{
         The value of an integer-type attribute. The data type of each
         attribute is listed in the {\tt "}Notes:{\tt "} section below.
      }
      \sstsubsection{
         LVAL = LOGICAL (Returned)
      }{
         The value of an logical-type attribute.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         MXCURV: Maximum no. of curves (\_INTEGER).

         \sstitem
         OLDPX: Original GKS polyline colour index (\_INTEGER).

         \sstitem
         OLDTX: Original GKS polyline text index (\_INTEGER).

         \sstitem
         SOCUR: True if polylines are drawn solid (\_LOGICAL).

         \sstitem
         NCURV: The no. of curves with defined attributes. The
         argument CURVE must be supplied with a value no greater than
         NCURV.

         \sstitem
         CRPN: Pen number for each curve. (\_INTEGER)

         \sstitem
         INCL: Colour indices of the in-line labels for each curve. (\_INTEGER)

         \sstitem
         AXPN: Pen number of axis lines (\_INTEGER)

         \sstitem
         TKPN: Pen number of tick marks (\_INTEGER)

         \sstitem
         NLBCL: Colour index of numeric labels. (\_INTEGER)

         \sstitem
         TITCL: Colour indices of title. (\_INTEGER)

         \sstitem
         ALBCL: Colour indices of axes labels. (\_INTEGER)

         \sstitem
         STDAT: True if values have already been assigned for these
         attributes. (\_LOGICAL)
      }
   }
}
\sstroutine{
   IRM\_LINR
}{
   Performe a linear interpolation
}{
   \sstdescription{
      This subroutine performes a linear interpolation between two known
      points. If one of the points has bad value, the output will take
      the value of the other point. If both points are bad, the output
      will be bad as well.
   }
   \sstinvocation{
      CALL IRM\_LINR( DIS1, DIS2, VAL1, VAL2, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DIS1, DIS2 = REAL (Given)
      }{
         Distances of the position to the first point and second point,
         respectively.
      }
      \sstsubsection{
         VAL1, VAL2 = REAL (Given)
      }{
         Values on the first point and second point, respectively.
      }
      \sstsubsection{
         OUT = REAL (Returned)
      }{
         The value at the position found by linear interpolation.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_LINTR
}{
   To obtain a linear transformation between 2 sets of x,y positions
   with least squared error
}{
   \sstdescription{
      The co-efficients of a linear transformation are returned which
      maps the (XA,YA) positions to the corresponding (XB,YB) positions
      with least squares error. The type of fit can be specified as:

        o  A shift of origin only (IFIT 1)

        o  A shift and rotation (IFIT = 2)

        o  A shift, rotation and magnification (IFIT = 3)

        o  A shift, rotation, magnification and shear (IFIT = 4)

      If the value of IFIT is too high for the supplied data, a lower
      value will be used and returned in IFIT. The returned coefficients
      are such that:

        Fitted XB position = C(1) $+$ C(2)$*$XA $+$ C(3)$*$YA

        Fitted YB position = C(4) $+$ C(5)$*$XA $+$ C(6)$*$YA
   }
   \sstinvocation{
      CALL IRM\_LINTR( N, XA, YA, XB, YB, IFIT, C, MAXERR, RMSERR,
                      STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         The number of supplied positions.
      }
      \sstsubsection{
         XA( N ) = REAL (Given)
      }{
         The X image coordinates at the first set of positions.
      }
      \sstsubsection{
         YA( N ) = REAL (Given)
      }{
         The Y image coordinates at the first set of positions.
      }
      \sstsubsection{
         XB( N ) = REAL (Given)
      }{
         The X image coordinates at the second set of positions.
      }
      \sstsubsection{
         YB( N ) = REAL (Given)
      }{
         The Y image coordinates at the second set of positions.
      }
      \sstsubsection{
         IFIT = INTEGER (Given and Returned)
      }{
         The type of fit required. A lower value will be used (and
         returned) if a fit of the specified type could not be
         obtained.
      }
      \sstsubsection{
         C( 6 ) = REAL (Returned)
      }{
         The coefficients of the linear fit.
      }
      \sstsubsection{
         MAXERR = REAL (Returned)
      }{
         The maximum error between the supplied (XB,YB) positions and
         the fitted (XB,YB) positions, in pixels.
      }
      \sstsubsection{
         RMSERR = REAL (Returned)
      }{
         The RMS error between the supplied (XB,YB) positions and
         the fitted (XB,YB) positions, in pixels.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_LISTN
}{
   Create a text file holding a list of NDF names
}{
   \sstdescription{
      This routine can be used to pass on lists of NDFs from one
      applications to another. It creates a text file holding the NDF
      names contained within the group identified by IGRP. The text
      file is created within the users home (or login) directory and is
      called iras90\_ndfs.lis. Any existing version of this file is
      first deleted. The name of the file is then written out to the
      parameter specified by PARAM, so long as there is more than one
      NDF in the group. If this is not the case, then the name of the
      single NDF is written out to the parameter. If the group contains
      no names, an error is reported. The parameter should have a type
      of NDF, a vpath of DYNAMIC and should be associated with a
      global parameter used to pass NDFs between applications.
   }
   \sstinvocation{
      CALL IRM\_LISTN( PARAM, IGRP, APPNAM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A parameter to which the name of the newly created text file
         will be written. IRAS90 applications should use parameter
         NDFLIST.
      }
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         The GRP identifier for the group containing the names of the
         NDFs.
      }
      \sstsubsection{
         APPNAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the calling application. This is included in a
         comment at the start of the created text file.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_LITRR
}{
   Saves a transformation for a linear plot in the AGI database
}{
   \sstdescription{
      This routine defines the transformations between world and a
      linear data co-ordinate system that has either, neither or both
      axes with reversed polarity (increasing right to left or top to
      bottom), and saves the transformation in the AGI database with
      the current picture.
   }
   \sstinvocation{
      CALL IRM\_LITRR( SCALE, OFFSET, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SCALE( 2 ) = REAL (Given)
      }{
         The scale factors of each linear axis to transform from world
         co-ordinates to data co-ordinates.
      }
      \sstsubsection{
         OFFSET( 2 ) = REAL (Given)
      }{
         The offsets of each linear axis at pixel 0 to transform from
         world co-ordinates to data co-ordinates.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         There must be a current AGI picture.
      }
   }
}
\sstroutine{
   IRM\_MEDN
}{
   To find the median value of a data set
}{
   \sstdescription{
      This routine finds the median value of the supplied data array,
      using the facilities of the routine IRM\_QNTLR. A median value of
      VAL\_\_BADR is returned if all the input data is bad, but no error
      is reported. The number of good data values is also returned.
   }
   \sstinvocation{
      CALL IRM\_MEDN( EL, DATA, MEDIAN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the data array.
      }
      \sstsubsection{
         DATA( EL ) = REAL (Given)
      }{
         The data array.
      }
      \sstsubsection{
         MEDIAN = REAL (Returned)
      }{
         The median value. Returned equal to VAD\_\_BADR if an error
         occurs.
      }
      \sstsubsection{
         NGOOD = INTEGER (Returned)
      }{
         The number of good data values in DATA.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_MLINE
}{
   Draw multi-curve plot with annotated and labelled axes
}{
   \sstdescription{
      This subroutine uses NCAR to draw multi-curve plot with
      annotated and labelled axes within the current SGS zone. In the
      plot, each curve is a solid line interrupted at a specified
      position by a specified in-line label. The current SGS zone is
      the NCAR graph window (in which a graph including labels, is to
      be drawn ). The position and the size of NCAR grid window (along
      the edges of which the axes are to be drawn and within which
      curves are to be drawn ) are determined by the user. The axes are
      started and ended at the start and end of the data rather than at
      major tick marks as NCAR{\tt '}s default setting. In addition, the user
      also has following controlling options towards the plot.

      1) Control the extents of the x and y axes, rather than letting
         NCAR decide;
      2) Specify the number of minor tick marks, and approximate
         number of major tick marks. The actual number of major tick
         marks will be between 2$*$maj and 5$*$maj/2$+$4, where the maj is
         the specified number.
      3) Plot the tick marks outside the grid;
      4) have either or both axes logarithmic;
      5) Select either bottom or top edge as X axis;
      6) Select either left or right edge as Y axis;

      An edge which is not selected as an axis will only be a
      straight line and have no tick marks and numeric label on it.

      Before using this routine an SGS device must be opened. A call
      should be made to SNX\_AGWV which marched the NCAR graph window
      with the current SGS zone.

      Warning:
      After using this routine the world coordinates of the SGS zone
      will be AUTOGRAPH grid coordinates, that is, the grid window has
      bounds ( 0.0, 1.0, 0.0, 1.0 ).
      And after this routine the NCAR setting is changed to present
      setting.
   }
   \sstinvocation{
      CALL IRM\_MLINE( NX, NLINE, ONEXDT, XDAT, YDAT, XORDER,
                      YORDER, CURPEN, SOLID, X1, X2, Y1, Y2,
                      AXSPEN, TITLE, TITPEN, XLAB, YLAB, LBSZ,
                      ALBPEN, INLAB, INLBPS, INLPEN, LMTX, LMTY,
                      XLMT, YLMT, LOGX, LOGY, XAXS, YAXS, MAJTIC,
                      MINTIC, TCKLN, OUTIC, TCKPEN, NLBPEN,
                      BAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         The number of x data.
      }
      \sstsubsection{
         NLINE = INTEGER (Given)
      }{
         The total number of curves .
      }
      \sstsubsection{
         ONEXDT = LOGICAL (Given)
      }{
         When it is true, all the curves to be plotted will have the
         same x data at the same horizontal grid, otherwise, the
         curves have different x data at the same horizontal grid.
      }
      \sstsubsection{
         XDAT( NX, $*$ ) = REAL (Given)
      }{
         The x data of the curves. When ONEXDT is true, it should be
         a vector (or a 2-dimension array with the 2 dimension having
         size 1 ) giving the x data for all curves. When ONEXDT is
         false, it should be a 2-dimensional array with its second
         dimension having size NLINE. Each of its row gives the x
         data of the corresponding curve.
      }
      \sstsubsection{
         YDAT( NX, NLINE ) = REAL (Given)
      }{
         The y data of NLINE curves.
      }
      \sstsubsection{
         XORDER = INTEGER (Given)
      }{
         When it is 0, the values of user x coordinates mapped to the
         horizontal axis of the grid window should increase from left to
         right. When it is 1, the values of user x coordinates mapped to
         the horizontal axis of the grid window should decrease from
         left to right.
      }
      \sstsubsection{
         YORDER = INTEGER (Given)
      }{
         When it is 0, the values of user y coordinates mapped to the
         vertical axis of the grid window should increase from bottom to
         top. When it is 0, the values of user y coordinates mapped to
         the vertical axis of the grid window should decrease from
         bottom to top.
      }
      \sstsubsection{
         CURPEN( NLINE ) = INTEGER (Given)
      }{
         The SGS pen number used to draw each curve.
      }
      \sstsubsection{
         SOLID = LOGICAL (Given)
      }{
         The flag to show whether to draw the curves in the solid line
         regardless of the pen number of the curves.  If it is true the
         curves in the plot will all be solid regardless of their pen
         number and graphic device, otherwise, the line types of the
         the curves depends on both their pen number and the graphic
         device type.
      }
      \sstsubsection{
         X1, X2 = REAL (Given)
      }{
         The X extent of the NCAR grid window, given in the fraction
         of the graph-window (current SGS zone ) width.
      }
      \sstsubsection{
         Y1, Y2 = REAL (Given)
      }{
         The Y extent of the NCAR grid window, given in the fraction
         of the graph-window (current SGS zone ) height.
      }
      \sstsubsection{
         AXSPEN = INTEGER (Given)
      }{
         The SGS pen number used to draw four axes.
      }
      \sstsubsection{
         TITLE = CHARACTER$*$($*$) (Given)
      }{
         The title of the plot.
      }
      \sstsubsection{
         TITPEN = INTEGER (Given)
      }{
         The SGS pen number used to write the title of the plot.
      }
      \sstsubsection{
         XLAB = CHARACTER$*$($*$) (Given)
      }{
         The label of x axis.
      }
      \sstsubsection{
         YLAB = CHARACTER$*$($*$) (Given)
      }{
         The label of y axis.
      }
      \sstsubsection{
         LBSZ = REAL (Given)
      }{
         The text height of the x and y labels given as a fraction of
         the smaller dimension of the grid window. The value less than
         or equal to zero means using NCAR default setting. Title of
         the display will have the text height of 1.2$*$LBSZ.
      }
      \sstsubsection{
         ALBPEN = INTEGER (Given)
      }{
         The SGS pen number used to write the axis labels.
      }
      \sstsubsection{
         INLAB( NLINE ) = CHARACTER$*$($*$) (Given)
      }{
         The in-line label of each curve.
      }
      \sstsubsection{
         INLBPS( NLINE ) = REAL (Given)
      }{
         The position of in-line label on each curve given in fraction
         of the smaller one of XSIZE and YSIXE from the left. A
         negative value or a value greater than 1.0 means that the
         corresponding line will be drawn with solid line.
      }
      \sstsubsection{
         INLPEN( NLINE ) = REAL(Given)
      }{
         The SGS pen number used to write each in-line label.
      }
      \sstsubsection{
         LMTX = INTEGER (Given)
      }{
         Its value determines how the lower and upper limits of the X
         axis is set. It can take following values:

         \sstitemlist{

            \sstitem
              1 :The values given in XLMT( 1 ) and XLMT( 2 ) will be
                  used as lower and upper limits of X axis, respectively.

         }
            0 :The graph package will examine the user{\tt '}s x coordinate
               data and find the minimum and maximum value as the axis
               lower and upper limits.

            1 :The values given in XLMT( 1 ) will be used as the lower
               limit of the axis. The graph package uses the maximum
               value of user{\tt '}s x coordinate as the axis upper limit.

            2 :The values given in XLMT( 2 ) will be uses as the upper
               limit of the axis.  The graph package uses the minimum
               value of user{\tt '}s x coordinate as the axis lower limit.
      }
      \sstsubsection{
         LMTY = INTEGER (Given)
      }{
         Its value determines how the lower and upper limits of the Y
         axis is set. It can take following values:

         \sstitemlist{

            \sstitem
              1 :The values given in YLMT( 1 ) and YLMT( 2 ) will be
                  used as lower and upper limits of Y axis, respectively.

         }
            0 :The graph package will examine the user{\tt '}s Y coordinate
               data and find the minimum and maximum value as the axis
               lower and upper limits.

            1 :The values given in YLMT( 1 ) will be used as the lower
               limit of the axis. The graph package uses the maximum
               value of user{\tt '}s Y coordinate as the axis upper limit.

            2 :The values given in YLMT( 2 ) will be uses as the upper
               limit of the axis.  The graph package uses the minimum
               value of user{\tt '}s Y coordinate as the axis lower limit.
      }
      \sstsubsection{
         XLMT( 2 ) = REAL (Given)
      }{
         The user specified lower limit and higher limit of x axis,
         respectively.
      }
      \sstsubsection{
         YLMT( 2 ) = REAL (Given)
      }{
         The user specified lower limit and higher limit of y axis,
         respectively.
      }
      \sstsubsection{
         LOGX = LOGICAL (Given)
      }{
         If it is true, the x axis will be set to logarithmic,
         otherwise, to linear.
      }
      \sstsubsection{
         LOGY = LOGICAL (Given)
      }{
         If it is true, the y axis will be set to logarithmic,
         otherwise, to linear.
      }
      \sstsubsection{
         XAXS = LOGICAL (Given)
      }{
         If it is true, the bottom edge of grid window is to be selected
         as x axis. Otherwise, top edge as x axis.
      }
      \sstsubsection{
         YAXS = LOGICAL (Given)
      }{
         If it is true, the left edge of grid window is to be selected
         as y axis. Otherwise, top edge as y axis.
      }
      \sstsubsection{
         MAJTIC( 2 ) = REAL (Given)
      }{
         The number of major ticks on X and Y axes, respectively. Number
         used is between MAJTIC$*$2 AND 5$*$MAJTIC/2$+$4. A negative value
         forces the NCAR to compute appropriate values.
      }
      \sstsubsection{
         MINTIC( 2 ) = REAL (Given)
      }{
         The number of minor tick marks between each major tick mark for
         the x and y axes. A negative value forces the NCAR to compute
         appropriate values. A value less than 1.0 but greater than 0.0
         will suppresses minor tick completely.
      }
      \sstsubsection{
         TCKLN = REAL (Given)
      }{
         The length of the major tick marks given in the fraction of the
         small dimension of the NCAR grid window. Its value should be
         within range ( 0.0, 0.05 ). A value outside this range means
         NCAR default. The minor tick marks will have the length
         0.66 $*$ TCKLN.
      }
      \sstsubsection{
         OUTTIC = LOGICAL (Given)
      }{
         If it is true, the axis tick marks are drawn outside the grid
         window. Otherwise, inside grid window.
      }
      \sstsubsection{
         TCKPEN = INTEGER (Given)
      }{
         The SGS pen number used to draw the tick marks.
      }
      \sstsubsection{
         NLBPEN = INTEGER (Given)
      }{
         The SGS pen number used to draw the numeric labels.
      }
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If it is true, the bad input data are flag by ADAM magic value.
         Otherwise, no bad input data or the bad input data is flag by
         NCAR null value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_NOISE
}{
   Estimate the noise of a data series
}{
   \sstdescription{
      This subroutine is used to estimate the RMS noise of a data
      series. To reduce the effect of the background, a window of size
      WINDSZ is sliding along the series and the variances of the data
      within the window at each window position are calculated. The
      square root of the average of these local variances, excluding
      those variances which is too far away from the average, is
      returned as RMS noise of the data serise. The criterion to regard
      a variance as too far away from the average is its distance from
      the average more than THRD $*$ (standard deviate of the variance ).
   }
   \sstinvocation{
      CALL IRM\_NOISE( NSMP, DATA, WINDSZ, THRD, VAL, AVG, VAR,
                      RMS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NSMP = INTEGER (Given)
      }{
         The number of samples in the data series.
      }
      \sstsubsection{
         DATA( NSMP ) = REAL (Given)
      }{
         The input data series.
      }
      \sstsubsection{
         WINDSZ = INTEGER (Given)
      }{
         The size of the window used to calculate local variances.
      }
      \sstsubsection{
         THRD = REAL (Given)
      }{
         The threshold used to exclude {\tt "}too far away{\tt "} variances from the
         average.
      }
      \sstsubsection{
         VAL( NSMP ) = REAL (Given)
      }{
         A temporary working array.
      }
      \sstsubsection{
         AVG( NSMP ) = REAL (Given)
      }{
         A temporary working array.
      }
      \sstsubsection{
         VAR( NSMP ) = REAL (Given)
      }{
         A termproary working array.
      }
      \sstsubsection{
         RMS = REAL (Given)
      }{
         The estimated RMS noise.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_PAGE
}{
   Start a new page of output by routine IRM\_PTOUT
}{
   \sstdescription{
      Routine IRM\_PTOUT displays text in pages. This routine forces the
      start of a new page.
   }
   \sstinvocation{
      SUBROUTINE IRM\_PAGE
   }
}
\sstroutine{
   IRM\_PROFL
}{
   Input a point source profile from the environment
}{
   \sstdescription{
      This subroutine is used to input a point source profile from the
      environment. See the help on application MAKEPORF for a
      description of the required format on the input NDF. The returned
      pointer DPNTR points to the first element of the mapped data
      array and XPNTR points to the mapped AXIS CENTRE array of the
      mapped data array.
   }
   \sstinvocation{
      CALL IRM\_PROFL( PFILE, NSMP, NPROF, DPNTR, XPNTR, NDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PFILE = CHARACTER (Given)
      }{
         The name of the parameter used to get the NDF file which
         contains the point source profile.
      }
      \sstsubsection{
         NSMP = INTEGER (Returned)
      }{
         Number of samples in the obtained point source profile.
      }
      \sstsubsection{
         NPROF = INTEGER (Returned)
      }{
         The number of profile contained in the input NDF. It must be
         either 4 (one for each waveband) or 1 (one for all wavebands).
      }
      \sstsubsection{
         DPNTR = INTEGER (Returned)
      }{
         The pointer to the first element of the mapped data array.
      }
      \sstsubsection{
         XPNTR = INTEGER (Returned)
      }{
         The pointer to the mapped AXIS CENTER array for the in-scan
         axis.
      }
      \sstsubsection{
         NDF = INTEGER (Returned)
      }{
         The ID of the point source profile NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_PTAST
}{
   Associate an astrometry structure with a picture in the AGI
   database
}{
   \sstdescription{
      The astrometry information identified by IDA is copied to the
      MORE structure associated with a given picture in the AGI
      database.  If an astrometry structure already exists in MORE,
      then the routine returns without doing anything.
   }
   \sstinvocation{
      CALL IRM\_PTAST( PICID, IDA, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PICID = INTEGER (Given)
      }{
         The AGI identifier for the picture with which to associate the
         astrometry information.
      }
      \sstsubsection{
         IDA = INTEGER (Given)
      }{
         The IRA identifier for the astrometry information.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_PTOUT
}{
   Outputs one line of text, waiting at end of each screenful
}{
   \sstdescription{
      Analogue of VAX/VMS RTL routine LIB\$PUT\_OUTPUT.  Outputs one
      line of text, waiting at the end of each screenful. VAX DEPENDENT!
      However, the Vax extensions used are available on SUN and
      DECstation compilers.  Note, inherited status is not used.
   }
   \sstinvocation{
      ISTAT = IRM\_PTOUT( STRING )
   }
   \sstarguments{
      \sstsubsection{
         STRING = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The line of text to be output to the screen.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         IRM\_PTOUT = INTEGER
      }{
         The status.  If the line was output correctly a value of 1 is
         returned, otherwise 0 is returned.
      }
   }
}
\sstroutine{
   IRM\_QCOL
}{
   Tests whether the current graphics device supports colour
}{
   \sstdescription{
      This routine determines whether the current GKS graphics device
      supports colour.
   }
   \sstinvocation{
      CALL IRM\_QCOL( COLOUR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         COLOUR = LOGICAL (Returned)
      }{
         If true the device supports colour.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         An SGS workstation must be open.
      }
   }
}
\sstroutine{
   IRM\_QNDF
}{
   Set NDF DATA elements bad on the basis of quality
}{
   \sstdescription{
      An attempt is made to compile the supplied quality expression
      using the quality name information stored in the supplied NDF. If
      successful, a copy of the NDF is created in which DATA elements
      are set BAD if they hold (or do not hold, depending on argument
      HELD) a quality which satisfies the supplied quality expression.
      An identifier for this copy of the input NDF is returned. The BAD
      pixel flag for the returned NDF is set appropriately.

      If the supplied quality expression references any quality names
      which are not defined within the supplied NDF, then an error
      status may or may not be returned depending on the supplied value
      of the argument CONT. If CONT is .FALSE. then an error status is
      returned, but if CONT is .TRUE. then no error status is returned.
      In this case the returned NDF identifier is a cloned copy of the
      supplied NDF. A warning message is reported if this happens, so
      long as the current conditional message filter level is not equal
      to MSG\_\_QUIET.

      If the supplied quality expression is equal to {\tt "}ANY{\tt "} then the
      returned NDF identifier is just a cloned copy of the input
      identifier.
   }
   \sstinvocation{
      CALL IRM\_QNDF( INDF, QEXP, CONT, HELD, ONDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         An identifier for the input NDF.
      }
      \sstsubsection{
         QEXP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A quality expression, this should be upper case and have no
         leading blanks.
      }
      \sstsubsection{
         CONT = LOGICAL (Given)
      }{
         If TRUE then the application can continue even if the quality
         expression cannot be evaluated because of undefined quality
         names. In this case the DATA array of the NDF is left as it is
         (i.e. no elements are set BAD). If CONT is FALSE, then the
         application cannot continue without evaluating the quality
         expression, and an error is therefore reported if any of the
         quality names referenced in the quality expression are not
         defined within the supplied NDF.
      }
      \sstsubsection{
         HELD = LOGICAL (Given)
      }{
         If TRUE then the elements of the DATA array which have
         associated QUALITY values which satisfy the supplied quality
         expression are set BAD (other elements are unaffected).
         Otherwise, the elements of the DATA array which have
         associated QUALITY values which do not satisfy the supplied
         quality expression are set BAD (other elements are
         unaffected).
      }
      \sstsubsection{
         ONDF = INTEGER (Returned)
      }{
         An NDF identifier of a copy (or clone) of the input NDF, in
         which selected elements of the DATA array are set BAD.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_QNTLR
}{
   Find a quantile in a (possibly weighted) set of data
}{
   \sstdescription{
      The routine calculates the value of a specified quantile in a set
      of data values, which may be weighted. In concept (although not
      in practice) it sorts the supplied data values into ascending
      order along with their associated positive weights, if supplied.
      It then finds a quantile Q such that the sum of the weights
      associated with all data values less than Q is a specified
      fraction FRACT of the sum of all the weights supplied. If no
      weights are supplied, then each data value is assigned unit
      weight. There are two main applications of this algorithm:

      a) To find specified quantiles of a distribution of data values
      for statistical purposes. In this case, the weights may
      optionally be used to represent the number of times each data
      value occurs. In such cases, it may be useful to regard the
      distribution as continuous, and therefore to interpolate linearly
      between data values when obtaining the result.

      b) Alternatively, the values may represent residuals from some
      fitted function. In this case, by setting FRACT to 0.5, the
      {\tt "}weighted median residual{\tt "} may be found. This has the property
      that if it is subtracted from all the original residuals, then
      the weighted sum of the absolute values of the corrected
      residuals will be minimised. Thus, it may be used as the basis
      for iteratively finding an {\tt "}L1{\tt "} fit. In such cases, the required
      result will be equal to one of the data values (or may lie
      mid-way between two of them) and interpolation between values is
      not normally required.
   }
   \sstinvocation{
      CALL IRM\_QNTLR( USEWT, INTERP, FRACT, EL, X, W, IP, Q, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         USEWT = LOGICAL (Given)
      }{
         Whether the data have associated weights.
      }
      \sstsubsection{
         INTERP = LOGICAL (Given)
      }{
         Whether interpolation between data values should be performed
         when obtaining the result.
      }
      \sstsubsection{
         FRACT = REAL (Given)
      }{
         The fraction specifying the required quantile, in the range
         0.0 to 1.0.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of values in the IP array. This will be less than the
         size of the X and W arrays if any values form X and W are to
         be omitted from the estimation.
      }
      \sstsubsection{
         X( $*$ ) = REAL (Given)
      }{
         Array of data values.
      }
      \sstsubsection{
         W( $*$ ) = REAL (Given)
      }{
         Array of associated positive weights (if required). This
         argument will only be referenced if USEWT is .TRUE..
      }
      \sstsubsection{
         IP( EL ) = INTEGER (Given and Returned)
      }{
         On entry, an array of indices into the array X (and W if
         supplied) identifying the data values to be included in the
         calculation. These will normally be set up by the calling
         application to exclude any bad values in the data arrays (no
         explicit checks for bad values are performed by this routine).
         On exit, these indices will have been permuted to access the
         specified data elements in an order which is more nearly
         sorted than before (although in general it will not represent
         a complete sort of the data).
      }
      \sstsubsection{
         Q = REAL (Returned)
      }{
         The value of the requested quantile.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There are versions of this routine for processing both REAL
         and DOUBLE PRECISION data; replace the {\tt "}x{\tt "} in the routine name by
         R or D as appropriate. The types of the FACT, X, W and Q
         arguments should match the routine being used.  -  This routine
         is optimised for use when the number of data values is large. In
         general, only a partial sort of the data will be performed, so
         this routine will perform better than most other methods of
         finding quantiles, which typically require a complete sort.

         \sstitem
         The order in which the input pointers are supplied in the
         array IP is arbitrary, but there will often be an efficiency
         advantage in supplying them so that they access the data in
         nearly-sorted order. Thus, re-supplying the array of pointers
         generated by a previous invocation of this routine (for the same
         or similar data) may be worthwhile.
      }
   }
   \sstdiytopic{
      Timing
   }{
      Details of the asymptotic time required to execute the original
      SELECT algorithm are not altogether clear from the published
      papers. It appears that this algorithm may have better average
      performance than other methods and the time required may
      approximate to EL $*$ LOG( MIN( K, EL - K $+$ 1 ) ) where K is the
      rank of the largest data value which is smaller than the quantile
      being sought. However, Sedgewick (see References) indicates that
      such algorithms should, in general, complete in time proportional
      to EL, so the above formula may be incorrect.  When using
      weighted data, the time will be multiplied by a further factor
      reflecting the non-linearity of the cumulative weight versus rank
      function and the difficulty of inverting it.
   }
   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         Comm. of the ACM, vol 18, no. 3 (March 1975), p165.

         \sstitem
         Also see page 173.

         \sstitem
         In addition, see the algorithm assessment by T. Brown in
         Collected Algorithms of the ACM, (algorithm no. 489).

         \sstitem
         Sedgwick, R., 1988, {\tt "}Algorithms{\tt "} (Addison-Wesley).
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1992 Science \& Engineering Research Council
   }
}
\sstroutine{
   IRM\_RDNDF
}{
   Get a group of existing NDFs
}{
   \sstdescription{
      The supplied parameter is used to get a GRP group expression (see
      SUN/150 ) holding a list of existing NDFs (the syntax of the
      group expression is defined by the current default GRP control
      characters).  If the group expression is flagged, then the
      current parameter value is cancelled, the string supplied in TEXT
      is displayed (if it is not blank) and another group expression is
      obtained. The NDFs specified by the second group expression are
      added to the group holding the NDFs specified by the first group
      expression. The group continues to be expanded in this way until
      a group expression is obtained which is not flagged, or a null
      value is given, or the limit on the number of NDFs (MAXSIZ) is
      reached. If any of the specified NDFs do not exist, the user is
      warned, and re-prompted. If the final group contains more than
      MAXSIZ NDFs, then all but the first MAXSIZ NDFs are removed from
      the group. The user is warned if this happens. If MAXSIZ is
      supplied with the value zero no limit is imposed on the number of
      NDFs within the group.  If the final group contains less than the
      minimum no. of NDFs specified by argument MINSIZ, then the user is
      asked to supply more NDFs. All messages issued by this routine
      have a priority level of MSG\_\_NORM.
   }
   \sstinvocation{
      CALL IRM\_RDNDF( PARAM, MAXSIZ, MINSIZ, TEXT, IGRP, SIZE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The parameter (of type LITERAL).
      }
      \sstsubsection{
         MAXSIZ = INTEGER (Given)
      }{
         The maximum number of NDFs which can be allowed in the
         returned group. If zero is supplied, no limit is imposed.
      }
      \sstsubsection{
         MINSIZ = INTEGER (Given)
      }{
         The minimum number of NDFs which can be allowed in the
         returned group. If zero is supplied, then the returned group
         may contain no NDFs.
      }
      \sstsubsection{
         TEXT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The text to display between issuing prompts for successive
         group expressions. If blank then no text is displayed.
      }
      \sstsubsection{
         IGRP = INTEGER (Returned)
      }{
         The GRP identifier for the returned group holding all the
         specified NDFs. The group should be deleted using GRP\_DELET
         when it is no longer needed. If an error occurs, the value
         GRP\_\_NOID is returned.
      }
      \sstsubsection{
         SIZE = INTEGER (Returned)
      }{
         The number of files in the output group. SIZE is returned equal
         to 1 if STATUS is returned not equal to SAI\_\_OK.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_READF
}{
   Read the contents of a text file into a GRP group
}{
   \sstdescription{
      The supplied parameter is used to obtain the name of a text file
      from the environment. The contents of this text file are read and
      stored in a GRP group. The default GRP control characters are used
      to interpret the contents of the file. For instance, this means
      that fields separated by commas are placed in adjacent elements
      of the group, strings starting with \# are ignored as comments,
      strings starting with $\wedge$ are treated as indirection elements, etc.
      If REJECT is supplied .TRUE., all blanks elements are removed from
      the group before it is returned. The group is set
      case-insensitive.
   }
   \sstinvocation{
      CALL IRM\_READF( PARAM, REJECT, IGRP, SIZE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = INTEGER (Given)
      }{
         The name of the parameter used to get the name of the text
         file.
      }
      \sstsubsection{
         REJECT = LOGICAL (Given)
      }{
         If true, blanks are removed from the group.
      }
      \sstsubsection{
         IGRP = INTEGER (Returned)
      }{
         The GRP identifier for the returned group.
      }
      \sstsubsection{
         SIZE = INTEGER (Returned)
      }{
         The number of elements in the returned group.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_RLFFT
}{
   Takes the FFT of a purely real image
}{
   \sstdescription{
      NAG routines are used to produce an Hermitian FFT of the input
      image stored in transposed form (i.e rows and columns swapped).
      Hermitian FFTs are much faster than normal FFTs and require only
      half the space to store them. See the NAG manual chapter C06 for
      more information about Hermitian FFTs.
   }
   \sstinvocation{
      CALL IRM\_RLFFT( IN, NPIX, NLIN, WORK, FORWRD, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IN( NPIX, NLIN ) = DOUBLE PRECISION (Given)
      }{
         The input image.
      }
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         No. of pixels per line in the input image.
      }
      \sstsubsection{
         NLIN = INTEGER (Given)
      }{
         No. of lines in the input image.
      }
      \sstsubsection{
         WORK( NPIX, NLIN ) = DOUBLE PRECISION (Given)
      }{
         Work space.
      }
      \sstsubsection{
         FORWRD = LOGICAL (Given)
      }{
         True if a forward transformation is required, otherwise an
         inverse transformation is performed.
      }
      \sstsubsection{
         OUT( NLIN, NPIX ) = DOUBLE PRECISION (Returned)
      }{
         The FFT in transposed Hermitian form (i.e rows and columns
         swapped).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_SKCUR
}{
   Get the sky coordinate of the cursor position
}{
   \sstdescription{
      This subroutine is used to get the sky coordinate of the cursor
      position over the current SGS zone. A cursor should be available
      on the graphic device in use, otherwise an error is reported. If
      the selected cursor position is outside a specified area of the
      SGS zone, a flag will be set and the output sky coordinates will
      be the starlink bad value (VAL\_\_BADD).

      SGS must previously have been activated.
   }
   \sstinvocation{
      CALL IRM\_SKCUR( IDA, SCS, LBND, UBND, LON, LAT, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IDA = INTEGER (Given)
      }{
         An IRA identifier for the astrometry information.
      }
      \sstsubsection{
         SCS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The sky coordinate system in which LON and LAT are required.
      }
      \sstsubsection{
         LBND( 2 ) = REAL (Given)
      }{
         The lower bounds of the area in which cursor positions are
         consider valid, in image coordinates.
      }
      \sstsubsection{
         UBND( 2 ) = REAL (Given)
      }{
         The upper bounds of the area in which cursor positions are
         consider valid, in image coordinates.
      }
      \sstsubsection{
         LON = DOUBLE PRECISION (Returned)
      }{
         The longitude of the cursor position.
      }
      \sstsubsection{
         LAT = DOUBLE PRECISION (Returned)
      }{
         The latitude of the cursor position.
      }
      \sstsubsection{
         OUT = LOGICAL (Returned)
      }{
         Returned true if the selected cursor position is outside the
         area specified by LBND and UBND.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_SOLIN
}{
   Sets the GKS line type to solid for all polylines
}{
   \sstdescription{
      The routine sets the linetype of the current workstation to
      solid for all polylines by setting the aspect source flag
      to individual.
   }
   \sstinvocation{
      CALL IRM\_SOLIN( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      A GKS workstation should be open and active.
   }
}
\sstroutine{
   IRM\_SORTD
}{
   Sort an array of values into ascending or descending order
}{
   \sstdescription{
      The values in a specified row of the data array are sorted in to
      ascending or descending order, using simple bubblesort method.
      Any bad values present are stored at the end of the sorted array.
      At the same time, corresponding elements in all the other rows are
      moved to keep track with the elements in the sorted row.
   }
   \sstinvocation{
      CALL IRM\_SORTD( ASCEND, KEYROW, NVAL, NROWS, DATA, NGOOD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         ASCEND = LOGICAL (Given)
      }{
         If true the values are sorted so that the last is greater than
         the first. Otherwise the reverse is done.
      }
      \sstsubsection{
         KEYROW = INTEGER (Given)
      }{
         The row to use as the basis for the rearrangement. The values
         in this row are sorted into order, and the other rows are
         rearranged so that corresponding elements stay together,
      }
      \sstsubsection{
         NVAL = INTEGER (Given)
      }{
         The no. of elements in each row of the array.
      }
      \sstsubsection{
         NROWS = INTEGER (Given)
      }{
         The no. of rows of the array.
      }
      \sstsubsection{
         DATA( NVAL, NROWS ) = DOUBLE PRECISION (Given and Returned)
      }{
         The data.
      }
      \sstsubsection{
         NGOOD = INTEGER (Returned)
      }{
         The number of good values in the sorted row. These will occupy
         elements 1 to NGOOD in row KEYROW of the output array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_SPAGE
}{
   See if paged screen output is currently enabled
}{
   \sstdescription{
      Routine IRM\_PTOUT produces paged output on the screen. Such
      output may be suppressed by the user by supplying a non-blank
      string when asked to {\tt "}Press RETURN to continue{\tt "}. This routine
      returns a flag indicating if output is currently enabled or
      suppressed.
   }
   \sstinvocation{
      CALL IRM\_SPAGE( ON )
   }
   \sstarguments{
      \sstsubsection{
         ON = LOGICAL (Returned)
      }{
         True if text passed to IRM\_PTOUT will actually appear on the
         screen. False if the user has suppressed such output.
      }
   }
}
\sstroutine{
   IRM\_SQFLT
}{
   Square wave filter a data series
}{
   \sstdescription{
      This subroutine filters an input data series with an eight-point
      zero-sum square-wave filter which is defined as:

      Y(i) = - X(i) - X(i$+$1) $+$ X(i$+$2) $+$ X(i$+$3)
             $+$ X(i$+$4) $+$ X(i$+$5) - X(i$+$6) - X(i$+$7)

      All samples in the input series should be valid..
   }
   \sstinvocation{
      CALL IRM\_SQFLT( NSMP, INDAT, OUTDAT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NSMP = INTEGER (Given)
      }{
         Number of samples in the data series.
      }
      \sstsubsection{
         INDAT( NSMP ) = REAL (Given)
      }{
         Input data series.
      }
      \sstsubsection{
         OUTDAT( NSMP ) = REAL(Returned)
      }{
         Filtered output series.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_STATS
}{
   Statistically analyse each row of a 2-D array
}{
   \sstdescription{
      This routine returns the statistical information about each row
      of a 2-D array, comprising the mean, the maximum and minimum,
      the standard deviation, and the number of valid samples of each
      row. The statistics can be computed either with or without
      clipping. If a row contains no valid sample, the returned max.
      min. and standard deviation of the row will be the Starlink bad
      values, VAL\_\_BADR.
   }
   \sstinvocation{
      CALL IRM\_STATS( BSMP, ESMP, BROW, EROW, IN, NCLIP, CLIP,
                      MXMNCL, MEANCL, SGMACL, MX, MN, MEAN, SGMA,
                      NVAL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BSMP = INTEGER (Given)
      }{
         The begin index of the samples in each row of the input array.
      }
      \sstsubsection{
         ESMP = INTEGER (Given)
      }{
         The end index of the samples in each row of the input array.
      }
      \sstsubsection{
         BROW = INTEGER (Given)
      }{
         The begin index of the rows in each row of the input array.
      }
      \sstsubsection{
         EROW = INTEGER (Given)
      }{
         The end index of the rows in each row of the input array.
      }
      \sstsubsection{
         IN( BSMP: ESMP, BROW: EROW ) = REAL (Given)
      }{
         Input array whose rows are to be analysed.
      }
      \sstsubsection{
         NCLIP = INTEGER (Given)
      }{
         The number of clipping cycles.
      }
      \sstsubsection{
         CLIP( NCLIP ) = REAL (Given)
      }{
         The array of standard deviation thresholds. The analysis will
         only take into account those samples whose values are in tha
         range MEAN-CLIP$*$SIGMA to MEAN$+$CLIP$*$SIGMA.
      }
      \sstsubsection{
         MXMNCL = LOGICAL (Given)
      }{
         MXMNCL=TRUE means that the returned maximum and minimum values
         should be those after clipping; MXMNCL=FALSE causes the routine
         to return unclipped extreme values.
      }
      \sstsubsection{
         MEANCL = LOGICAL (Given)
      }{
         MEANCL=TRUE causes the returned mean values to be those after
         clipping; MEANCL=FALSE causes the routine to return unclipped
         averages.
      }
      \sstsubsection{
         SGMACL = LOGICAL (Given)
      }{
         SGMACL=TRUE means that the returned standard deviations should
         be those after clipping; SGMACL=FALSE causes the routine
         to return unclipped standard deviations.
      }
      \sstsubsection{
         MX( BROW: EROW ) = REAL (Returned)
      }{
         Maximum value of each row with or without clipping, depending
         on the value of MXMNCL.
      }
      \sstsubsection{
         MN( BROW: EROW ) = REAL (Returned)
      }{
         Minimum value of each row with or without clipping, depending
         on the value of MXMNCL.
      }
      \sstsubsection{
         MEAN( BROW: EROW ) = REAL (Returned)
      }{
         Mean value of each row with or without clipping, depending
         on the value of MEANCL.
      }
      \sstsubsection{
         SGMA( BROW: EROW ) = REAL (Returned)
      }{
         Standard deviations of each row with or without clipping,
         depending on the value of SGMACL.
      }
      \sstsubsection{
         NVAL( BROW: EROW ) = INTEGER (Returned)
      }{
         Number of valid samples in each row.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_STAXS
}{
   Set the axes attributes of a NCAR graph
}{
   \sstdescription{
      This routine decides the attributes of four axes, the labels
      of the axes, the number of major and minor ticks of axes, and
      the direction of ticks. Calling routine can select either left
      or right edge of grid window as y axis, and either bottom or
      top edge of grid window as x axis. The edges selected as axes
      will have specified labels and tick marks associating with them.
      The edges which are not selected will only have a line to be
      drawn.
   }
   \sstinvocation{
      CALL IRM\_STAXS( XBMT, YLFT, XLAB, YLAB, LABSZE, MAJTIC, MINTIC,
                      TCKSZE, OUTIC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         XBMT = LOGICAL (Given)
      }{
         It is true, if bottom edge of grid window is to be selected
         as x axis. Otherwise, top edge as x axis.
      }
      \sstsubsection{
         YLFT = LOGICAL (Given)
      }{
         It is true, if left edge of grid window is to be selected as
         y axis. Otherwise, right edge as y axis.
      }
      \sstsubsection{
         XLAB = CHARACTER$*$($*$) (Given)
      }{
         Label associated with X axis.
      }
      \sstsubsection{
         YLAB = CHARACTER$*$($*$) (Given)
      }{
         Label associated with Y axis.
      }
      \sstsubsection{
         LABSZE = REAL (Given)
      }{
         The character size of the axes labels, stated as a fraction
         of the smaller dimension of the grid window. The value less
         than or equal to zero will set the character as NCAR default.
      }
      \sstsubsection{
         MAJTIC( 2 ) = REAL (Given)
      }{
         The number of major ticks on X and Y axes, respectively.
         Number used is between MAJTIC$*$2 and 5$*$MAJTIC/2$+$4. A negative
         value forces the NCAR to compute appropriate values.
      }
      \sstsubsection{
         MINTIC( 2 ) = REAL (Given)
      }{
         The number of minor tick marks between each major tick mark for
         the x and y axes. A negative value forces the NCAR to compute
         appropriate values. A value less than 1.0 but greater than 0.0
         will suppresses minor tick completely.
      }
      \sstsubsection{
         TSZE = REAL (Given)
      }{
         The length of the major tick marks, stated as a fraction of the
         smaller dimension of the grid window. Its value should be within
         the range ( 0, 0.05 ). The value outsid this range means using
         NCAR default. The minor tick marks will always have length of
         2/3 length of major tick marks.
      }
      \sstsubsection{
         OUTIC = LOGICAL (Given)
      }{
         If true the axis tick marks are drawn outside the box.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_STGRD
}{
   Set the position and the size of grid window of NCAR package
}{
   \sstdescription{
      This routine set the NCAR parameters {\tt '}GRID/LEFT.{\tt '}, {\tt '}GID/RIGHT{\tt '},
      {\tt '}GRID/BOTTOM.{\tt '} and {\tt '}GRID/TOP.{\tt '} according to the given
      specifications to specifies the position and the shape of the grid
      window within the graph window.
   }
   \sstinvocation{
      CALL IRM\_STGRD( X1, X2, Y1, Y2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         X1, X2 = REAL (Given)
      }{
         The X extent of the NCAR grid window, given in fraction of the
         graph-window (current SGS zone ) width.
      }
      \sstsubsection{
         Y1, Y2 = REAL (Given)
      }{
         The Y extent of the NCAR grid window, given in fraction of the
         graph-window (current SGS zone ) hight.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_STLMT
}{
   Set axes limits of a NCAR graph
}{
   \sstdescription{
      This routine sets the NCAR parameters {\tt '}X/MINIMUM.{\tt '}, X/MAXIMUM.{\tt '},
      {\tt '}Y/MINIMUM.{\tt '} and {\tt '}Y/MAXIMUM.{\tt '} to specify the limits of the
      coordinates to be considered. If either X or Y axis has its limit
      set differently from the limits of data values, the parameter
      {\tt '}WINDOW.{\tt '} is set so that the curve portion falling outside the
      grid window will be omitted. The parameters {\tt '}X/NICE.{\tt '} and {\tt '}Y/NICE.{\tt '}
      are set as well so that the start and the end of the axes are at
      the start and the end pixels rather than at major marks.
   }
   \sstinvocation{
      CALL IRM\_STLMT( LMTX, LMTY, XLMT, YLMT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LMTX = INTEGER (Given)
      }{
         Its value determines how the lower and upper limits of the X
         axis is set. It can take following values:

         \sstitemlist{

            \sstitem
              1 :The values given in XLMT( 1 ) and XLMT( 2 ) will be
                  used as lower and upper limits of X axis, respectively.

         }
            0 :The graph package will examine the user{\tt '}s x coordinate
               data and find the minimum and maximum value as the axis
               lower and upper limits.

            1 :The values given in XLMT( 1 ) will be used as the lower
               limit of the axis. The graph package uses the maximum
               value of user{\tt '}s x coordinate as the axis upper limit.

            2 :The values given in XLMT( 2 ) will be uses as the upper
               limit of the axis.  The graph package uses the minimum
               value of user{\tt '}s x coordinate as the axis lower limit.
      }
      \sstsubsection{
         LMTY = INTEGER (Given)
      }{
         Its value determines how the lower and upper limits of the Y
         axis is set. It can take following values:

         \sstitemlist{

            \sstitem
              1 :The values given in YLMT( 1 ) and YLMT( 2 ) will be
                  used as lower and upper limits of Y axis, respectively.

         }
            0 :The graph package will examine the user{\tt '}s Y coordinate
               data and find the minimum and maximum value as the axis
               lower and upper limits.

            1 :The values given in YLMT( 1 ) will be used as the lower
               limit of the axis. The graph package uses the maximum
               value of user{\tt '}s Y coordinate as the axis upper limit.

            2 :The values given in YLMT( 2 ) will be uses as the upper
               limit of the axis.  The graph package uses the minimum
               value of user{\tt '}s Y coordinate as the axis lower limit.
      }
      \sstsubsection{
         XLMT( 2 ) = REAL (Given)
      }{
         The user specified lower limit and higher limit of x axis,
         respectively.
      }
      \sstsubsection{
         YLMT( 2 ) = REAL (Given)
      }{
         The user specified lower limit and upper limit of y axis,
         respectively.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_STLOG
}{
   Set axes to logarithmic where required
}{
   \sstdescription{
      This routine sets the axes to logarithmic where required.
   }
   \sstinvocation{
      CALL IRM\_STLOG( XLOG, YLOG, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         XLOG = LOGICAL (Given)
      }{
         If it is true, the x axis will be set to logarithmic,
         otherwise, to linear.
      }
      \sstsubsection{
         YLOG = LOGICAL (Given)
      }{
         If it is true, the y axis will be set to logarithmic,
         otherwise, to linear.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_STMAP
}{
   Set the ways of mapping coordinates to axes of NCAR display
}{
   \sstdescription{
      This routine set the way of mapping x coordinates to the
      horizontal axis of the grid window, and the way of mapping y
      coordinates to the vertical axis of the grid window.
   }
   \sstinvocation{
      CALL IRM\_STMAP( XORDER, YORDER, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         XORDER = INTEGER (Given)
      }{
         When it is 0, the values of user x coordinates mapped to the
         horizontal axis of the grid window should increase from left to
         right. When it is 1, the values of user x coordinates mapped to
         the horizontal axis of the grid window should decrease from
         left to right.
      }
      \sstsubsection{
         YORDER = INTEGER (Given)
      }{
         When it is 0, the values of user y coordinates mapped to the
         vertical axis of the grid window should increase from bottom to
         top. When it is 0, the values of user y coordinates mapped to
         the vertical axis of the grid window should decrease from
         bottom to top.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_STNUL
}{
   Set bad pixels having ADAM magic value to NCAR null value, or vice
   versa
}{
   \sstdescription{
      This routine convert the value of bad pixels from ADAM magic value
      to NCAR null value, or vice versa.
   }
   \sstinvocation{
      CALL IRM\_STNUL( NX, SET, YDAT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NY = INTEGER (Given)
      }{
         Number of pixels in input array
      }
      \sstsubsection{
         SET = LOGICAL (Given)
      }{
         If it is true, the convert is from ADAM magic value to NCAR
         null value. Otherwise, from NCAR null value to ADAM magic
         value.
      }
      \sstsubsection{
         YDAT( NY ) = REAL (Given and Return)
      }{
         As given, it contains input data whose bad pixel value to be
         converted. On return, it contains output data whose bad pixel
         value having been converted.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_STPEN
}{
   Set pen number various portions of an NCAR display
}{
   \sstdescription{
      The routine is used, together with a user version of AGCHCU,
      AGCHAX and AGCHIL to set the pen number for each curve, axis
      lines, tick marks, numeric labels, axis labels and title of
      an NCAR display. Since AGCHCU, AGCHAX and AGCHIL can not be
      called by user program directly, the user program has to call
      this routine to set the pen number before NCAR{\tt '}s drawing. The
      routine will save the pen number setting in a common block
      which will be accessed by the new AGCHCU, AGCHAX and AGCHIL
      to set the pen number when each portion is about to be drawn.

      The title referred to is the title written by NCAR (AUTOGRAPH)
      routines EZY, EZMY etc. which have the name of {\tt '}T{\tt '} and line
      number of 100. The axis labels have the name either {\tt '}T{\tt '} or
      {\tt '}B{\tt '} or {\tt '}R{\tt '} or {\tt '}L{\tt '}.

      To make this routine take effect, the user program must be
      linked with the new version of AGCHCU, AGCHAX and AGCHIL
      explicitly instead of the default ones in NCAR library.
   }
   \sstinvocation{
      CALL IRM\_STPEN( NCURV, CURPEN, SOLID, INLPEN, AXSPEN,
                      TCKPEN, NLBPEN, ALBPEN, TITPEN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCURV = INTEGER (Given)
      }{
         The number of curves
      }
      \sstsubsection{
         CURPEN( NCURV ) = INTEGER (Given)
      }{
         The SGS pen number for each curve.
      }
      \sstsubsection{
         SOLID = LOGICAL (Given)
      }{
         The flag to show whether to draw the curves in the solid line
         regardless of the pen number of the curves.  If it is true the
         curves in the plot will all be solid regardless of their pen
         number and graphic device, otherwise, the line types of the
         the curves depends on both their pen number and the graphic
         device type.
      }
      \sstsubsection{
         INLPEN( NCURV ) = INTEGER (Given)
      }{
         The SGS pen number for each in-line label.
      }
      \sstsubsection{
         AXSPEN = INTEGER (Given)
      }{
         The pen number for the axis lines.
      }
      \sstsubsection{
         TCKPEN = INTEGER (Given)
      }{
         The pen number for the tick marks.
      }
      \sstsubsection{
         NLBPEN = INTEGER (Given)
      }{
         The pen number for the numeric labels.
      }
      \sstsubsection{
         ALBPEN = INTEGER (Given)
      }{
         The pen number for the axis labels.
      }
      \sstsubsection{
         TITPEN = INTEGER (Given)
      }{
         The pen number for the title of the display.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      Before calling this routine, a SGS graphic device must have been
      opened.

      The following settings of the GKS ASF flag are assumed (they are
      SGS initial settings ):
          POLYLINE - bundled
          TEXT - individual
   }
}
\sstroutine{
   IRM\_STPHA
}{
   Set dashed-line pattern for NCAR routine EZMXY
}{
   \sstdescription{
      With the dashed-line pattern set by this routine, the NCAR routine
      EZMXY (or EZMY ) will draw a multi-line graph in which each curve
      is a solid line interrupted at a specified position by a specified
      label.  26 different dashed-line patterns can be defined. The
      EXMAY (or EZMY ) will use the set patterns in a circular fashion.
   }
   \sstinvocation{
      CALL IRM\_STPHA( LNLAB, NPATTN, LNLBPS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LNLAB( NPATTN ) = CHARACTER$*$($*$) (Given)
      }{
         The in-line label for each dashed-line pattern.
      }
      \sstsubsection{
         NPATTN = INTEGER (Given)
      }{
         The number of different pattern. A value greater than 26
         means that EZMXY (or EZMY ) should use the {\tt "}alphabetic{\tt "} set of
         26 dashed line patterns.
      }
      \sstsubsection{
         LNLBPS( NPATTN ) = REAL (Given)
      }{
         The position of in-line label on each curve given in fraction
         of the small dimension of the NCAR grid window from the
         beginning of the curve.
         A negative value or a value greater than 1.0 means that the
         corresponding will be drawn with solid line.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_SUBST
}{
   Substitute one substring for another
}{
   \sstdescription{
      This routine copies the input string to the output string,
      replacing occurrences of a given substring with another given
      string. The substitution is case sensitive.
   }
   \sstinvocation{
      CALL IRM\_SUBST( INSTR, OLD, NEW, ALL, OUTSTR, NSUB, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INSTR = CHARACTER$*$($*$) (Given)
      }{
         The input string.
      }
      \sstsubsection{
         OLD = CHARACTER$*$($*$) (Given)
      }{
         The substring which is to be replaced. All blanks (including
         trailing blanks) must be matched for a substitution to be made.
      }
      \sstsubsection{
         NEW = CHARACTER$*$($*$) (Given)
      }{
         The string which is to replace the substring specified by OLD.
         NEW an OLD need not be the same length. Any trailing blanks
         are included in the substitution.
      }
      \sstsubsection{
         ALL = LOGICAL (Given)
      }{
         If true, then all occurrences of OLD will be replaced.
         Otherwise, only the first occurrence will be replaced.
      }
      \sstsubsection{
         OUTSTR = CHARACTER$*$($*$) (Returned)
      }{
         The output string. A copy of INSTR, but with the required
         substitutions made.
      }
      \sstsubsection{
         NSUB = INTEGER (Returned)
      }{
         The number of substitutions actually made. If OUTSTR is filled
         before the end of INSTR has been reached, then NSUB may be less
         than the total number of occurrences of OLD within INSTR. If ALL
         is false, then NSUB will always be less than or equal to one.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_TABLE
}{
   Draw a table at specify position with specify size
}{
   \sstdescription{
      This routine draw a table in the current SGS zone at the specified
      position. The X extent of the table is specified by calling routine
      while the Y extent will be determined by number of rows of the table.
      with the max. limit given by the calling routine.
      The columns in the table are separated by vertical lines.
      The rows are separated by a space of a text height except the first
      row which is separated from the second by a horizontal line.
      Therefore it is suggested that using first item of each column as
      the title of this column.

      The size of the text is determined by the size of the table and
      its contents.

      The title of the table is put at the top of the table.

      Before calling this routine the SGS device must be opened.
   }
   \sstinvocation{
      CALL IRM\_TABLE( TITLE, NROW, NCOL, TABLE, X1, X2, Y1, Y2,
                      COLOUR, FONT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TITLE = CHARACTER$*$($*$) (Given)
      }{
         The title of the table, a blank string will suppress the title.
      }
      \sstsubsection{
         NROW = INTEGER (Given)
      }{
         The number of rows of the table.
      }
      \sstsubsection{
         NCOL = INTEGER (Given)
      }{
         The number of columns of the table.
      }
      \sstsubsection{
         TABLE( NROW, NCOL ) = CHARACTER$*$($*$) (Given)
      }{
         The contents of the table to be displayed.
      }
      \sstsubsection{
         X1, X2 = REAL (Given)
      }{
         The X extent of the table in world coordinate.
      }
      \sstsubsection{
         Y1 = REAL (Given)
      }{
         The lower limit of the bottom margin of the table.
      }
      \sstsubsection{
         Y2 = REAL (Given)
      }{
         Y position of the Top margin of the table.
      }
      \sstsubsection{
         COLOUR = LOGICAL (Given)
      }{
         If true, the frame of the table will be draw in green while
         the contents of the table will be write in white. Otherwise
         both will be in white.
      }
      \sstsubsection{
         FONT = INTEGER (Given)
      }{
         Font code, 1 is ordinary Roman letters and Arabic numbers. For
         other available font code, See GKS User Guide.
      }
      \sstsubsection{
         YBTTM = REAL (Returned)
      }{
         The real Y position of the bottom margin of the table.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_TD
}{
   Extract separate fields from a time/date string and convert to
   a Modified Julian Date
}{
   \sstdescription{
      The string should be in the same format as the follow example:

      1992-JAN-1 11:23:23.22

      If the string is valid, separate fields are returned identifying
      the year, month, day, hour, minutes and seconds. The corresponding
      Modified Julian Date is also returned. If the string is invalid an
      error is reported. A blank string causes the current time to be
      returned.
   }
   \sstinvocation{
      CALL IRM\_TD( STRING, IY, IM, ID, IHOUR, IMIN, SEC, MJD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STRING = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The string holding the time and date.
      }
      \sstsubsection{
         IY = INTEGER (Returned)
      }{
         The year.
      }
      \sstsubsection{
         IM = INTEGER (Returned)
      }{
         The month, in the range 1 to 12.
      }
      \sstsubsection{
         ID = INTEGER (Returned)
      }{
         The day of the month, starting at 1.
      }
      \sstsubsection{
         IHOUR = INTEGER (Returned)
      }{
         The hour, in the range 0 to 23.
      }
      \sstsubsection{
         IMIN = INTEGER (Returned)
      }{
         The minute in the range 0 to 59.
      }
      \sstsubsection{
         SEC = REAL (Returned)
      }{
         The seconds, in the range 0.0 to 59.999...
      }
      \sstsubsection{
         MJD = DOUBLE PRECISION (Returned)
      }{
         The Modified Julian Date corresponding to the date and time
         specified by STRING.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If any leading fields are omitted in the string, they default
         to the values for the current time.

         \sstitem
         If any trailing fields are omitted in the string, they default
         to zero (or 1 for the day and month).

         \sstitem
         Years in the range 0 to 49 are interpreted as 2000 to 2049.

         \sstitem
         Years in the range 50 to 99 are interpreted as 1950 to 1999.

         \sstitem
         No spaces are allowed in the string except to separate the time
         and date sections.
      }
   }
}
\sstroutine{
   IRM\_TEST
}{
   Test installation of the IRAS90 miscellaneous utilities
   package, IRM
}{
   \sstdescription{
      This routine tests the installation of the IRAS90 IRM package.
      Note, it is not an exhaustive test of the IRM\_ system itself.
   }
   \sstinvocation{
      IRM\_TEST
   }
}
\sstroutine{
   IRM\_TMENU
}{
   Display a menu on user{\tt '}s terminal and get an item from it
}{
   \sstdescription{
      This routine displays a menu on the user{\tt '}s terminal and let user
      select an item from the menu. This menu is displayed an item per
      line with each item has a sequence number. When selecting an item,
      the user can key in its sequence number, or key in the item itself
      in this case the user can abbreviate the item to an unambiguous
      length. The Title are displayed at the top of the menu and
      underlined. The first item is set as default selection.
   }
   \sstinvocation{
      CALL IRM\_TMENU( INMENU, INTITL, PARAM, ITEMNO, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INMENU = CHARACTER$*$($*$) (Given)
      }{
         The menu list of the items separated by comma.
      }
      \sstsubsection{
         INTITL = CHARACTER$*$($*$) (Given)
      }{
         The title of the menu.
      }
      \sstsubsection{
         PARAM = CHARACTER$*$($*$) (Given)
      }{
         The name of the parameter used to select one of the items from
         the menu.
      }
      \sstsubsection{
         ITEMNO = INTEGER (Returned)
      }{
         The selected item number.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_TRCON
}{
   Concatenate two linear transformations
}{
   \sstdescription{
      A linear transformation mapping (X,Y) to (U,V) is described by 6
      coefficients such that:

      U = C1 $+$ C2$*$X $+$ C3$*$Y

      V = C4 $+$ C5$*$X $+$ C6$*$Y

      This routine concatenates two such transformation to produce a
      third transformation. If C1 contains the coefficients of the
      transformation from (X,Y) to (U,V), and C2 contains the
      coefficients of the transformation from (U,V) to (A,B), then C3
      is returned holding the coefficients of the transformation from
      (X,Y) to (A,B).
   }
   \sstinvocation{
      CALL IRM\_TRCON( C1, C2, C3, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         C1( 6 ) = REAL (Given)
      }{
         The coefficients of the first transformation.
      }
      \sstsubsection{
         C2( 6 ) = REAL (Given)
      }{
         The coefficients of the second transformation.
      }
      \sstsubsection{
         C3( 6 ) = RETURNED (Given)
      }{
         The coefficients of the concatenated transformation.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_TRINV
}{
   Invert a linear transformation
}{
   \sstdescription{
      A linear transformation mapping (X,Y) to (U,V) is described by 6
      coefficients such that:

      U = C1 $+$ C2$*$X $+$ C3$*$Y

      V = C4 $+$ C5$*$X $+$ C6$*$Y

      This routine returns the coefficients, D, of the inverse mapping
      from (U,V) to (X,Y), where

      X = D1 $+$ D2$*$U $+$ D3$*$V

      Y = D4 $+$ D5$*$U $+$ D6$*$V

      An error is reported if the inverse transformation is singular.
   }
   \sstinvocation{
      CALL IRM\_TRINV( C, D, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         C( 6 ) = REAL (Given)
      }{
         The coefficients of the forward transformation.
      }
      \sstsubsection{
         D( 6 ) = RETURNED (Given)
      }{
         The coefficients of the inverse transformation.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_UNTCV
}{
   Calculate scale factor for valid CRDD units conversions
}{
   \sstdescription{
      This routine calculates the scale factors needed to convert CRDD
      data in UNITS1 to that in UNITS2. Systems of units should be
      specified using the symbolic constants listed below, rather than
      by the corresponding character strings. These constants are made
      available by including the IRC\_PAR file. Presently, this routine
      supports conversion between any pair of following units:

      IRC\_\_F - Flux value in units of Pico-Watts per square metre

      IRC\_\_J - Flux density values in Janskys.

      IRC\_\_JPS - Surface brightness values in Janskys per steradian.

      IRC\_\_MJPS - Surface brightness values in Mega-Janskys per steradian.

      IRC\_\_FPS - Surface brightness values in Pico-Watts per square
                     metre, per steradian.

      The conversion between flux and surface brightness is via the
      effective solid angle of each detector. Since the dead detectors
      have zero effective solid angle, the conversion scale for the dead
      detectors will be the starlink bad value {\tt "}VAL\_\_BADR{\tt "}, but no error
      is reported.
   }
   \sstinvocation{
      CALL IRM\_UNTCV( UNITS1, UNITS2, NDET, DET, SCALE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         UNITS1 = CHARACTER$*$( $*$ ) (Given)
      }{
         The original units of the CRDD data.
      }
      \sstsubsection{
         UNITS2 = CHARACTER$*$( $*$ ) (Given)
      }{
         The new units to which the CRDD data will be converted.
      }
      \sstsubsection{
         NDET = INTEGER (Given)
      }{
         The number of detectors whose data units are to be converted.
      }
      \sstsubsection{
         DET( NDET ) = INTEGER (Given)
      }{
         Detector numbers of the detectors whose data units are to be
         converted.
      }
      \sstsubsection{
         SCALE( NDET ) = REAL (Returned)
      }{
         The scale factor needed to convert CRDD data of each detector
         from UNITS1 to UNITS2.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_UNTIM
}{
   Find a factor to convert NDF image data values to specified units
}{
   \sstdescription{
      A scaling factor is returned which converts data values from the
      specified NDF into values in the specified units. An error may be
      reported if the NDF contains CPC data, depending on the specific
      conversion required (some can be performed for CPC data, and some
      cannot). An error is also reported if the input data is in colour
      corrected flux density based system, and the requested units are
      a flux based system.
   }
   \sstinvocation{
      CALL IRM\_UNTIM( INDF, UNITS, SCALE, BAND, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         An NDF identifier for an IRAS90 image.
      }
      \sstsubsection{
         UNITS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The required units (see IRI document ID1).
      }
      \sstsubsection{
         SCALE = REAL (Returned)
      }{
         The scale factor for converting the NDF data values to the
         required units.
      }
      \sstsubsection{
         BAND = INTEGER (Returned)
      }{
         The survey waveband index. Negative values are returned for
         CPC waveband indices (eg -1 or -2 ).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_UNTIV
}{
   Calculate scale factor for valid image units conversions
}{
   \sstdescription{
      If the input and output units are recognised, then SCALE is
      returned holding the factor which converts values in the input
      units to the output units. If either of the two units systems are
      unrecognised, an error is reported.
   }
   \sstinvocation{
      CALL IRM\_UNTIV( UTS1, UTS2, BAND, PIXSIZ, SCALE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         UTS1 = CHARACTER $*$ ( $*$ )  (Given)
      }{
         The units of the input image.
      }
      \sstsubsection{
         UTS2 = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The units required for the output image.
      }
      \sstsubsection{
         BAND = INTEGER (Given)
      }{
         The survey waveband index. If CPC data is being used an
         illegal survey waveband index should be supplied. An error
         will only be reported if the scale factor explicitly depends
         on the waveband.
      }
      \sstsubsection{
         PIXSIZ = DOUBLE PRECISION (Given)
      }{
         The nominal solid angle of an image pixel, in steradians.
      }
      \sstsubsection{
         SCALE = REAL (Returned)
      }{
         The scale factor for converting between the input and output
         units.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_VMENU
}{
   Draw a vertical menu and select an item from it
}{
   \sstdescription{
      This routine draw a vertical menu in the current SGS zone,
      and select one of item from the menu with cursor.

      The extent of the menu are specified with world coordinate.
      The menu is composed of a number of vertically arranged
      identical boxes, each of which contains one item of the menu.

      The routine is not clever enough to decide the best number of
      lines when writing the content of an item into the box. So
      the calling routine must specifies approximately how many
      lines the content of an item should be split into when writing
      the item into the box. The routine will find the best way to
      split the content of the item into the approximately specified
      number of lines. The actual number of line may be more or less
      than the specified number.

      If selecting an item is requested, the routine will loop until
      one item is selected.  To selecting an item from the menu with
      the cursor, put the cursor in the box of that item and press any
      key. The routine will put cursor on the default item specified
      by DEFNO after drawing the menu and after each invalid selection.

      Before calling this routine a SGS device must be opened.
   }
   \sstinvocation{
      CALL IRM\_VMENU( NITEM, INMENU, NROW, DEFNO, X1, X2, Y1, Y2,
                      INTITL, COLOUR, FONT, TXTHT, GTITM, ITEMNO,
                      STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NITEM = INTEGER (Given)
      }{
         The number of items in the menu.
      }
      \sstsubsection{
         INMENU = CHARACTER$*$($*$) (Given)
      }{
         The list of the items in the menu separated by comma. No space
         is allowed after each comma.
      }
      \sstsubsection{
         NROW( NITEM ) = INTEGER (Given)
      }{
         The approximate number of lines into which the content of
         each item should be split when writing it into its menu box.
      }
      \sstsubsection{
         DEFNO = INTEGER (Given)
      }{
         Specifies the item number which will be used as default item.
      }
      \sstsubsection{
         X1, X2, Y1, Y2 = REAL (Given)
      }{
         The extent of menu bar in the current world coordinate system.
      }
      \sstsubsection{
         INTITL = CHARACTER$*$($*$) (Given)
      }{
         The title of the menu.
      }
      \sstsubsection{
         COLOUR = LOGICAL (Given)
      }{
         If it is true, colour is available on the current graphic
         device. The frame of the menu box will draw in green while the
         contents of menu will written in white. Otherwise, the colour
         is not available, both the frame and the contents will be in
         white.
      }
      \sstsubsection{
         FONT = INTEGER (Given)
      }{
         Font code, 1 is ordinary Roman letters and Arabic numbers. For
         other available font code, see GKS User Guide.
      }
      \sstsubsection{
         TXTHT = REAL (Given)
      }{
         The height of the text in the menu.
      }
      \sstsubsection{
         GTITM = LOGICAL (Given)
      }{
         If true, an item will be selected from the menu, otherwise no
         item will be selected before exit.
      }
      \sstsubsection{
         ITEMNO = INTEGER (Returned)
      }{
         The item number which user selected from the menu.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRM\_WRNDF
}{
   Get a group of output NDF names
}{
   \sstdescription{
      The supplied parameter is used to get a GRP group expression (see
      SUN/150 ) holding a list of NDFs which are to be created by the
      calling application (the syntax of the group expression is
      defined by the current default GRP control characters).
      Modification elements within the group expression are based on
      the group identified by IGRP0. If the group expression is flagged,
      then the current parameter value is cancelled, the string
      supplied in TEXT is displayed (if it is not blank) and another
      group expression is obtained. The NDFs specified by the second
      group expression are added to the group holding the NDFs
      specified by the first group expression. The group continues to
      be expanded in this way until a group expression is obtained
      which is not flagged, or a null value is given, or the limit on
      the number of NDFs (MAXSIZ) is reached.  If the final group
      contains more than MAXSIZ NDFs, then all but the first MAXSIZ
      NDFs are removed from the group. The user is warned if this
      happens. If MAXSIZ is supplied with the value zero no limit is
      imposed on the number of NDFs within the group.  If the final
      group contains less than MINSIZ NDFs then the user is told to
      supply more, and is re-prompted for further NDF names. All
      messages issued by this routine have a priority level of
      MSG\_\_NORM.
   }
   \sstinvocation{
      CALL IRM\_WRNDF( PARAM, IGRP0, MAXSIZ, MINSIZ, TEXT, IGRP, SIZE,
                      STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The parameter (of type LITERAL).
      }
      \sstsubsection{
         IGRP0 = INTEGER (Given)
      }{
         The NDG identifier for a group containing a set of NDF names
         to be used as the basis for any modification elements contained
         within the group expressions. If this is supplied equal to
         GRP\_\_NOID then modification elements are left un-expanded.
      }
      \sstsubsection{
         MAXSIZ = INTEGER (Given)
      }{
         The maximum number of NDFs which can be allowed in the
         returned group. If zero is supplied, no limit is imposed.
      }
      \sstsubsection{
         MINSIZ = INTEGER (Given)
      }{
         The minimum number of NDFs which can be allowed in the
         returned group. If zero is supplied, then the returned group
         may contain no NDFs.
      }
      \sstsubsection{
         TEXT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The text to display between issuing prompts for successive
         group expressions. If blank then no text is displayed.
      }
      \sstsubsection{
         IGRP = INTEGER (Returned)
      }{
         The NDG identifier for the returned group holding all the
         specified NDFs.
      }
      \sstsubsection{
         SIZE = INTEGER (Returned)
      }{
         The number of files in the output group. Returned equal to 1 if
         STATUS is not equal to SAI\_\_OK.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\section {Templates for IRM Routines Within the VAX LSE Editor}
The STARLSE package (see SUN/105) provides facilities for initialising the VAX
Language Sensitive Editor (LSE) to simplify the generation of Fortran
code conforming to the Starlink programming standard (see SGP/16). One of the
facilities provided by LSE is the automatic production of argument lists for
subroutine calls. Templates for all the subroutines in the IRM package can be 
made available within LSE by performing the following steps (within LSE):
\begin{enumerate}
\item Issue the LSE command GOTO FILE/READ IRM\_DIR:IRM.LSE
\item Issue the LSE command DO
\item Issue the LSE command DELETE BUFFER
\item Move to a buffer holding a .FOR of a .GEN file in the usual way.
\item IRM subroutine templates are then available by typing in the name of an 
IRM subroutine (or an abbreviation) and expanding it (CTRL-E).
\item Help on the subroutine and its arguments can be obtained by placing the
cursor at a point in the buffer at which the subroutine name has been entered 
and pressing GOLD-PF2.
\end{enumerate}

\section {Packages Called by IRM}
IRM\_ makes calls to the following packages:
\begin {description}
\item [AGI\_] - The ADAM graphics database; see SUN/48.
\item [CHR\_] - The CHR character handling package; see SUN/40.
\item [CMP\_] - HDS; see SUN/92.
\item [DAT\_] - HDS; see SUN/92.
\item [ERR\_] - The Starlink error reporting package; see SUN/104.
\item [FIO\_] - The Starlink file nadling package.
\item [GKS\_] - The GKS graphics package; see SUN/113.
\item [GNS\_] - The Graphics device naming system; see SUN/57.
\item [GRP\_] - Group handling package; see SUN/150.
\item [HLP\_] - The Starlink portable help system; see SUN/124.
\item [I90\_] - The IRAS90 satellite and mission data system.
\item [IRA\_] - The IRAS90 astrometry system; see ID/2.
\item [IRC\_] - The IRAS90 CRDD file handling system; see ID/1.
\item [IRQ\_] - The IRAS90 Quality handling system; see ID/6.
\item [MSG\_] - The Starlink message reporting package; see SUN/104.
\item [NAG]   - Double precision NAG library.
\item [NCAR\_] - The NCAR high level graphics package; see SUN/88.
\item [NDF\_] - The NDF access package; see SUN/33.
\item [PAR\_] - The ADAM parameter system; see SUN/114.
\item [PSX\_] - The Starlink POSIX interface library; see SUN/121.
\item [REF\_] - Handling references to HDS objects; see SUN/31.
\item [SLALIB\_] - A package for handling times and positions; see SUN/67.
\item [SNX\_] - The Starlink NCAR extension package; see SUN/90.
\item [TRN\_] - The Starlink coordinate transformation package; see SUN/61.
\end{description}

Access to these packages, together with packages called from within these 
packages, is necessary to use IRM. 

\section {Changes Introduced in the Current Version of this Document}
\label {SEC:CHANGES}

Changes introduced in version 12 of ID8:
\begin{enumerate}
\item IRM\_UNTIV ignores the supplied waveband index unless it is actually
needed. An error ``CPC data cannot be handled'' is reported if a waveband index
is needed but an illegal value was supplied. 
\item IRM\_UNTIM only reports an error for CPC data if the conversion factor 
cannot be found. CPC waveband indices are returned with negative values.
\item New routines IRM\_ELLIP, IRM\_GTCUN, IRM\_FILNM.
\end{enumerate}

Changes introduced in version 11 of ID8:
\begin {enumerate}
\item New routines: IRM\_SPAGE, IRM\_UNTIV, IRM\_RLFFT, IRM\_HMFFT, 
IRM\_HMULT, IRM\_AGFND, IRM\_AGREF, IRM\_HMSG, IRM\_QCOL, IRM\_GTAST,
IRM\_PTAST, IRM\_SKCUR, IRM\_LINTR, IRM\_READF
\end {enumerate}

Changes introduced in version 10 of ID8:
\begin {enumerate}
\item New routines: IRM\_RDNDF, IRM\_WRNDF, IRM\_TD, IRM\_GETTD, IRM\_ASFIO, 
IRM\_LISTN, IRM\_CDESC, IRM\_CPOIN, IRM\_GTHLP, IRM\_PTOUT, IRM\_PAGE,
IRM\_BLOCR, IRM\_CFF2R, IRM\_MEDN, IRM\_QNTLR, IRM\_CLEAN, IRM\_GTBND,
IRM\_FIT2, IRM\_LITRR, IRM\_SOLIN, IRM\_ANTSO, IRM\_IATTR, IRM\_COMNT,
IRM\_GKCMT, IRM\_GKEYC, IRM\_GKEYR

\item Routine IRM\_CRDDF withdrawn (replaced by IRM\_RDNDF).
\item Routine IRM\_UNTCV is now sensitive to the case of the supplied strings.
\item Description of the use of IRM on UNIX machines included.
\item STARLSE templates and help available for IRM subroutines.
\item The VMS version of IRM is now released in the form of a sharable image 
rather than an object library. Applications linked with the sharable image have 
the advantage that they will not need to be {\em re}-linked when IRM is upgraded 
in future. Note, the object library has been removed from the IRM system.
\item The linking and development procedures have been modified to bring them 
into line with Starlink standards (see SSN/8).
\end {enumerate}

\end{document}
