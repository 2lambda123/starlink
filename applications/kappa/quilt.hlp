.help quilt Starlink kappa
.nf
    Generates a mosaic from equally sized 2-d data arrays,
    optionally specified from an ASCII file
 
   This routine provides a more-sophisticated version of the MOSAIC
   application for combining many 2-d data arrays into one large
   output data array. All the data arrays are stored in IMAGE
   structures.  The pixels in overlapping regions may be averaged or
   summed.
 
   The names of IMAGE structures to be concatenated and their
   respective offsets of their data arrays from a central
   data array can be input either one by one from the interface, or
   all at once from a free-format file.  The format of the file is
   as follows:
 
      Mosaic title                        ! header
      central_image                       ! name of central IMAGE
      125                                 ! total no. frames
      345  229                            ! maximum x-y offsets
      -356  -232                          ! minimum x-y offsets
      image_2                             ! subsequent IMAGE and
      35  34                              ! its x-y offsets
      image_3
      36  -33
      .
      .
      .
      .
 
   Only like-sized data arrays may be input. The reason for this is
   that it is difficult to work out how big the output data array
   needs to be until all the input data arrays and their offsets have
   been read in. By confining the data arrays to be the same size,
   only the maximum and minimum x and y offsets from the central data
   array need be input by the user, then the output image size can be
   worked out from these numbers along with the size of the central
   data array.
 
   Bad pixels are processed by the magic-value method.

AUTHORS

   Mark McCaughrean UoE ( REVA::MJM )
   Malcolm J. Currie STARLINK (RAL::CUR)

BUGS

   None known.

DEFICIENCIES

   Works with like-sized images only and uses Fortran i/o for getting
   stuff from a file. Also, SUBPAR_ calls are used in some of the
   subroutines to associate a string from the file with an HDS
   structure.

HISTORY

   29-12-1986 : First implementation (from MOSAIC) (REVA::MJM)
   1988 May 29: KAPPA version, using magic-value bad pixels only
                (RAL::CUR).
   1989 Jun 13: Allow for processing primitive NDFs (RAL::CUR)
   1989 Aug  7: Passed array dimensions as separate variables
                to MOSCAD, MOSCDV and ZERO2D (RAL::CUR).
   1989 Dec 21: Workspace managed by AIF_TEMP (RAL::CUR).
   1991 Oct 25: Propagates UNITS, LABEL, and HISTORY (RAL::CUR).
   1992 Feb 26: Limited processing of simple NDFs (RAL::CUR).
   1992 Mar  3: Replaced AIF parameter-system calls by the extended
                PAR library (RAL::CUR).

PARAMETERS

   WHERE  =  CHAR( READ )
       Whether input comes from an ASCII 'File' or from the
         'Interface'.
   FNAME  =  CHAR( READ )
       Name of the ASCII file holding the input information to define
         the mosaic.
   NUMBER  =  INTEGER( READ )
       Number of data arrays to form the mosaic.
   INPICI  =  IMAGE( READ )
       IMAGE structure containing the central data array (offset 0,0)
   MAXX  =  INTEGER( READ )
       Maximum x offset of any data array from the central data array
         (must be >= 0) (Interface mode)
   MAXY  =  INTEGER( READ )
       Maximum y offset of any data array from the central data array
         (must be >= 0) (Interface mode)
   MINX  =  INTEGER( READ )
       Minimum x offset of any data array from the central data array
         (must be =< 0) (Interface mode)
   MINY  =  INTEGER( READ )
       Minimum y offset of any data array from the central data array
         (must be =< 0) (Interface mode)
   AVERAGE  = LOGICAL( READ )
       If true overlap regions are averaged, alternatively, they are
         summed.
   OUTPIC  =  IMAGE( WRITE )
       Output IMAGE structure.
   OTITLE  =  CHAR( READ )
       Title string for output IMAGE structure.
   CURPIC  =  IMAGE( READ )
       IMAGE containing the current data array being concatenated to
         the mosaic.
   OFFSETX  =  INTEGER( READ )
       x offset of current data array from the central one (Interface
         mode).
   OFFSETY  =  INTEGER( READ )
       y offset of current data array from the central one (Interface
         mode).

WHERE

  keyword     'WHERE'
  type        'LITERAL'
  vpath       'PROMPT'
  ppath       'CURRENT,DEFAULT'
  prompt      'Input source'
  default     'File'
  help        'Choose File (ASCII file) or Interface as the source of
              frames and offsets.'

FNAME

  keyword     'FNAME'
  type        'FILENAME'
  access      'READ'
  vpath       'PROMPT'
  ppath       'CURRENT'
  prompt      'Source file name'
  help        'Name of ASCII file holding mosaic information (header, 
              number of arrays, max-min offsets, names and offsets).'

NUMBER

  keyword     'NUMBER'
  type        '_INTEGER'
  access      'READ'
  vpath       'PROMPT'
  prompt      'Number of data arrays'
  help        'Give total number of 2-d data arrays to form a mosaic, 
              including the central one.'

INPICI

  keyword     'INPICI'
  type        'IMAGE'
  access      'READ'
  vpath       'PROMPT'
  ppath       'GLOBAL'
  association '<-GLOBAL.DATA_ARRAY'
  prompt      'Central image'
  help        'Name of IMAGE structure containing the central 2-d 
              data array to be added.'

MAXX

  keyword     'MAXX'
  type        '_INTEGER'
  access      'READ'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'Maximum x offset'
  help        'Give the maximum x offset of any data array (including 
              the central one).'

MAXY

  keyword     'MAXY'
  type        '_INTEGER'
  access      'READ'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'Maximum y offset'
  help        'Give the maximum y offset of any data array (including 
              the central one).'

MINX

  keyword     'MINX'
  type        '_INTEGER'
  access      'READ'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'Minimum x offset'
  help        'Give the minimum x offset of any data array (including 
              the central one).'

MINY

  keyword     'MINY'
  type        '_INTEGER'
  access      'READ'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'Minimum y offset'
  help        'Give the minimum y offset of any data array (including 
              the central one).'

AVERAGE

  keyword     'AVERAGE'
  type        '_LOGICAL'
  access      'READ'
  vpath       'PROMPT'
  prompt      'Are overlapped input pixels to be averaged in the 
              output array?'
  help        'Input pixels may be occupy the same position in the 
              output array. So output pixels can be averaged or 
              summed.'
  default     YES

OUTPIC

  keyword     'OUTPIC'
  type        'IMAGE'
  access      'WRITE'
  vpath       'PROMPT'
  association '->GLOBAL.DATA_ARRAY'
  prompt      'Output mosaic image'
  help        'Name given to the IMAGE structure to hold the mosaic 
              data array.'

OTITLE

  keyword     'OTITLE'
  type        '_CHAR'
  vpath       'DEFAULT'
  prompt      'Title for output image'
  default     'KAPPA - Quilt'
  help        'Character string used as a title for the output IMAGE 
              structure.'

CURPIC

  keyword     'CURPIC'
  type        'IMAGE'
  access      'READ'
  vpath       'PROMPT'
  prompt      'Next Image'
  help        'Give the name of the current IMAGE structure 
              containing the 2-d data array to be part of the
              mosaic.'

OFFSETX

  keyword     'OFFSETX'
  type        '_INTEGER'
  access      'READ'
  vpath       'PROMPT'
  prompt      'x offset of the array from the first'
  help        'Give x offset in pixels of the current data array from 
              the central one.'

OFFSETY

  keyword     'OFFSETY'
  type        '_INTEGER'
  access      'READ'
  vpath       'PROMPT'
  prompt      'y offset of the array from the first'
  help        'Give y offset in pixels of the current data array from 
              the central one.'
 1 Requests
 KAPPA is continuing to be developed and additional applications
functionality are envisaged, particularly a graphical-user interface
for image processing.  If you wish to suggest new tasks or
enhancements to existing ones please contact the author
(mjc@star.rl.ac.uk).  Small jobs may be undertaken quite quickly.
Requests involving substantial pieces of work need to gain the
support of others to be included in Starlink's software plans, and
so the best way to influence the priority given to KAPPA is to
contact the chairman of the Image Processing Software Strategy
Group. The Starlink World Wide Web pages will periodically contain
news of plans and work in progress.  KAPPA also receives a high
level of support, and bug reports are dealt with promptly. 
 1 RESHAPE
Reshapes an NDF, treating its arrays as vectors.
 Usage:
    reshape in out shape=?
 Description:
    This application reshapes an NDF to create another NDF by copying
   array values.  The array components in the input NDF are treated
   as vectors.  Each output array is filled in order with values from
   the input vector, until it is full or the input vector is
   exhausted.  Output data and variance pixels not filled are set to
   the bad value; unfilled quality pixels are set to zero.  The
   filling is in Fortran order, namely the first dimension, followed
   by the second dimension,... to the highest dimension.
    It is possible to form a vectorized NDF using parameter VECTORIZE
   without having to specify the shape.

Parameters

For information on individual parameters, select from the list below:

IN

IN = NDF (Read)
   The input NDF to be reshaped.

OUT

OUT = NDF (Read)
   The NDF after reshaping.

SHAPE

SHAPE( ) = _INTEGER (Read)
   The shape of the output NDF.  For example, [50,30,20] would
   create 50 columns by 30 lines by 20 bands.  It is only
   accessed when VECTORIZE = FALSE.

TITLE

TITLE = LITERAL (Read)
   Title for the output NDF structure.  A null value (!)
   propagates the title from the base NDF to the output NDF. [!]

VECTORIZE

VECTORIZE = _LOGICAL (Read)
   If TRUE, the output NDF is the vectorized form of the input
   NDF.  If FALSE, parameter SHAPE is used to specify the new
   shape.  [FALSE]

Examples

reshape shear normal shape=[511,512]
   This reshapes the NDF called shear to form NDF normal, whose
   shape is 511 x 512 pixels.  One example is where the original
   image has 512 x 512 pixels but one pixel was omitted from each
   line during some data capture, causing the image to be sheared
   between lines.
 reshape cube cube1d vectorize
   This vectorizes the NDF called cube to form NDF cube1d.  This
   could be used for a task that only permits one-dimensional
   data.

Related_Applications

   KAPPA: CHAIN, PASTE, RESHAPE.

Authors

MJC: Malcolm J. Currie (STARLINK)

History

 1997 June 15 (MJC):
    Original version.

Implementation_Status

   -  This routine correctly processes the DATA, QUALITY,
   VARIANCE, LABEL, TITLE, UNITS, and HISTORY, components of an NDF
   data structure and propagates all extensions.  WCS and AXIS information 
   is lost.
    -  All non-complex numeric data types can be handled.
    -  Any number of NDF dimensions is supported.
 1 RIFT
Adds a scalar to a section of an NDF data structure to correct
rift-valley defects.
 Usage:
    rift in scalar out section
 Description:
    The routine adds a scalar (i.e. constant) value to each pixel of
   an NDF's data array within a sub-section to produce a new NDF
   data structure.

Parameters

For information on individual parameters, select from the list below:

IN

IN = NDF (Read)
   Input NDF data structure, to which the value is to be added.

OUT

OUT = NDF (Write)
   Output NDF data structure.

SCALAR

SCALAR = _DOUBLE (Read)
   The value to be added to the NDF's data array within the
   section.

SECTION

SECTION = LITERAL (Read)
   The pixels to which a scalar is to be added.  This is defined
   as an NDF section, so that ranges can be defined along any
   axis, and be given as pixel indices or axis (data)
   co-ordinates.  So for example "3,4,5" would select the pixel
   at (3,4,5); "3:5," would select all elements in columns 3 to
   5; ",4" selects line 4.  See "NDF Sections" in SUN/95, or the
   online documentation for details.

TITLE

TITLE = LITERAL (Read)
   Value for the title of the output NDF.  A null value will cause
   the title of the NDF supplied for parameter IN to be used
   instead. [!]

Examples

rift aa 10.7 bb "100:105" 20
   This adds 10 in the columns 100 to 105 in the data array of
   the NDF called aa and stores the result in the NDF called bb.
   In other respects bb is a copy of aa.
 rift cubein -100 cubeout ",,4"
   This adds -100 to all values in the fourth plane of the data
   array of the NDF called cubein and stores the result in the
   NDF called cubeout.  In other respects cubeout is a copy of
   cubeout.
 rift in=aa scalar=2 out=bb section="-10:5,200~9"
   This adds 2 to the rectangular section between columns -10 to
   5 and lines 196 to 204 of the data array of the NDF called aa
   and stores the result in the NDF called bb.  In other respects
   bb is a copy of aa.

Notes

For similar operations performed on a subset, use the appropriate
application to process the relevant section and then run PASTE to
paste the result back into the full array.

Related_Applications

   KAPPA: CADD, CHPIX, GLITCH, PASTE, SEGMENT, ZAPLIN; Figaro: CSET,
   ICSET, NCSET, TIPPEX.

Authors

MJC: Malcolm J. Currie (STARLINK)
 DSB: David S. Berry (STARLINK)

History

 1991 October 31 (MJC):
    Original version based on RFWS's CADD.
  1995 April 28 (MJC):
    Used the SECTION parameter instead of pixel bounds.  Made Usage
    and Examples Lowercase.  Added Related Applications, Examples,
    and Implementation Status.
  5-JUN-1998 (DSB):
    Added propagation of the WCS component.

Implementation_Status

   -  This routine correctly processes the AXIS, DATA, QUALITY,
   VARIANCE, LABEL, TITLE, UNITS, WCS and HISTORY components of an NDF
   data structure and propagates all extensions.
    -  Processing of bad pixels and automatic quality masking are
   supported.
    -  The bad-pixel flag is set to TRUE if undefined values are
   created during the arithmetic.
    -  All non-complex numeric data types can be handled.
.endhelp
