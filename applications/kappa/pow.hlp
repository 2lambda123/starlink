.help pow Starlink kappa
.nf
    Takes the specified power of each pixel of a data array
 
   This routine takes the specified power of each pixel of the
   data array in the input IMAGE structure. The result goes into a
   new output array, also in an IMAGE structure.
 
   The magic-value method is used for processing bad data.  Output
   pixels become bad if the result raising to the specified power is
   undefined or out of range.  Negative pixel values will only
   generate good output pixels when the power is an even integer.

AUTHORS

   Mark McCaughrean UoE ( REVA::MJM )
   Malcolm Currie  STARLINK (RAL::CUR)

BUGS

   None known.

HISTORY

   03-07-1986 : First implementation (REVA::MJM)
   1986 Aug 7 : Renamed algorithm subroutine (POWARR), changed new
                2nd argument to total number of pixels (RAL::CUR).
   1986 Aug 29: Add argument section, generalised to vector and
                tidied (RAL::CUR).
   1987 Oct 16: Reordered tidying and used CMP_SHAPE (RAL::CUR)
   1988 Mar 17: Referred to `array' rather than `image'
                (RAL::CUR)
   1988 May 31: More reporting of error context (RAL::CUR)
   1989 Jun 13: Allow for processing primitive NDFs (RAL::CUR)
   1991 Oct 25: Propagates AXIS, LABEL, and HISTORY (RAL::CUR).
   1992 Feb 25: Limited processing of simple NDFs (RAL::CUR).
   1992 Mar  3: Replaced AIF parameter-system calls by the extended
                PAR library (RAL::CUR).

PARAMETERS

   INPIC  =  IMAGE( READ )
       Input IMAGE structure containing the data array to be
         processed
   POWER  =  REAL( READ )
       Power to be taken of each input data-array pixel
   OUTPIC  =  IMAGE( WRITE )
       Output IMAGE structure holding result of the processed data
         array
   OTITLE  =  CHAR( READ )
       Title string for the output IMAGE structure

INPIC

  position    1
  keyword     'INPIC'
  type        'IMAGE'
  access      'READ'
  vpath       'PROMPT'
  ppath       'GLOBAL'
  association '<-GLOBAL.DATA_ARRAY'
  prompt      'Input image'
  help        'Name of the IMAGE structure containing the input data 
              array'

POWER

  position    2
  keyword     'POWER'
  type        '_REAL'
  access      'READ'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC'
  prompt      'Power'
  help        'Power to be taken of each input data-array pixel'

OUTPIC

  position    3
  keyword     'OUTPIC'
  type        'IMAGE'
  access      'WRITE'
  vpath       'PROMPT'
  association '->GLOBAL.DATA_ARRAY'
  prompt      'Output image'
  help        'Name given to the IMAGE structure holding the data 
              array resulting from taking power'

OTITLE

  position    4
  keyword     'OTITLE'
  type        'LITERAL'
  vpath       'DEFAULT'
  prompt      'Title for output image'
  default     'KAPPA - Pow'
  help        'Character string used as a title for the output IMAGE 
              structure.'
 1 Problems_Problems
A detailed list of error codes and their meanings is not available.
KAPPA produces descriptive contextual error messages, which are
usually straightforward to comprehend.  Some of these originate in
the underlying infrastructure software, though there are still some
systems yet to do that.  These are being corrected, and so imprecise
error reports should soon be a thing of the past.  Error messages
from KAPPA begin with the name of the application reporting the
error. The routine may have detected the error, or it has something
to say about the context of the error. 
 The sub-topics describe some difficulties you may encounter and how
to hurdle them.  Please suggest additions to this compilation.
 2 Unable_to_Obtain_Work_Space
One group of error messages which may puzzle you, mostly because
they are incomplete reads like ``Unable to create work array''.
Many applications require temporary or work space to perform their
calculations.  This space is stored in an HDS file within directory
$HDS_SCRATCH and most likely is charged to your disc quota.  (If you
have not redefined this environment variable, it will point to your
current directory.)  So one cause for the message is insufficient
disc quota available to store the work space container file or to
extend it.
 A second reason for the message is that your computer cannot provide
sufficient virtual memory to map the workspace.  In this case you
can try increasing your process limits using the C-shell built-in
function called limit.  You can find your current limits by entering
limit.  You should see a list something like this.
      cputime         unlimited
     filesize        unlimited
     datasize        131072 kbytes
     stacksize       2048 kbytes
     coredumpsize    unlimited
     memoryuse       89232 kbytes
     vmemoryuse      1048576 kbytes
     descriptors     4096 
 The relevant keywords are datasize and the vmemoryuse.  In effect
datasize specifies the maximum total size of data files you can map at
one time in a single programme.  The default should be adequate for
most purposes and only need be modified for those working with large
images or cubes.  The vmemoryuse specifies the maximum virtual memory
you can use.
     % limit datasize 32768
 sets the maximum size of mapped data to 32 megabytes.  Values cannot
exceed the system limits.  You can list these with the -h qualifier.
      % limit -h
     cputime         unlimited
     filesize        unlimited
     datasize        1048576 kbytes
     stacksize       32768 kbytes
     coredumpsize    unlimited
     memoryuse       89232 kbytes
     vmemoryuse      1048576 kbytes
     descriptors     4096 
 Although you can set your limits to the system maxima, it doesn't
mean that you should just increase your quotas to the limits.  You
might become unpopular with some of your colleagues, especially if
you accidentally try to access a huge amount of memory.  
 If you cannot accommodate your large datasets this way, you should
fragment your data array, and process the pieces separately.
 After receiving this error message in an ICL session you may need
to delete the scratch file by hand.  The file is called txxx.sdf,
where xxxx is a process identifier.  A normal exit from ICL will
delete the work-space container file.
  2 Application_Automatically_pPcks_up_the_Wrong_NDF
Some applications read the name of the NDF used to create a plot or
image from the graphics database in order to save typing.  Rarely,
you'll say ``that's not the one I wanted''.  This is because AGI
finds the last DATA picture situated within the current picture.
Abort the application via !!, then use PICCUR or PICLIST to select
the required FRAME picture enclosing the DATA picture, or even
select the latter directly.  You can override the AGI NDF also by
specifying the required NDF on the command line, provided it has
pixels whose indices lies within the world co-ordinates of the
DATA picture.  Thus
 
     % inspect myndf
 
will inspect the NDF called myndf.  The command PICIN will show the
last DATA picture and its associated NDF.
 2 Unable_to_Store_a_Picture_in_the_Graphics_Database
You may receive an error message, which says failed to store
such-and-such picture in the graphics database.  For some reason the
database was corrupted due to reasons external to KAPPA.  Don't
worry, usually your plot will have appeared, and to fix the problem
run GDCLEAR/IDCLEAR or delete the database file
($AGI_USER/agi_<node>.sdf, where you substitute your system's node
name for <node>).  You will need to redraw the last plot if you
still require it, say for interaction.
 2 Line_Graphics_are_Invisible_on_an_Image_Display
The reason for invisible line graphics on your image display is
because it is drawn in black or a dark grey.  Most likely is that
some person has been using other software on your image display or
that is has been reset.  PALDEF will set up the default colours for
the palette, and so most line graphics will then appear in white.
Alternatively,
 
     % palentry 1 white
 
will normally suffice.
 2 Error_Obtaining_a_Locator_to_a_Slice_of_an_HDS_array
 If the above error appears from DAT_SLICE and you are (re)prompted
for an NDF, the most likely cause is that you have asked an IMAGE
application to process an NDF section.  Use NDFCOPY to make a
subset before running the application in question, or process the
whole NDF.
 2 Badly_placed_()'s
This means that you have forgotten to `escape' parentheses, probably
when defining an NDF section.  Try inserting a backslash before each
parenthesis.
      % stats myndf\(100:200,\)
 2 Attempt_to_use_'positional'_parameter_value_(x)_in_an_unallocated_position
Check the usage of the application you are running.  One way of
adding positional parameters unintentionally, is to forget to escape
the " from the shell when supplying a string with spaces or
wildcards.  For example, this error would arise if we entered
      % settitle myndf "A title"
 instead of say
      % settitle myndf '"A title"'
 which protects all special characters between the single quotes.
 2 The_choice_x_is_not_in_the_menu.
You have either made an incorrect selection, or you have forgotten
to escape a metacharacter.  For the former, you can select a new
value from the list of valid values presented in the error message.
For the latter, part of another value is being interpreted as a
positional value for the parameter the task is complaining about.
      % linplot $KAPPA_DIR/spectrum pltitl="Red-giant plot"
     !! The choice plot is not in the menu.  The options are
     !     Data,Quality,Error,Variance.
     !  Invalid selection for parameter COMP.
 Here it thinks that plot is a positional value.  Escape the " to
cure the problem.
      % linplot $KAPPA_DIR/spectrum pltitl='"Red-giant plot"'
 2 I've_Got_This_FITS_Tape
 Certain combinations of magnetic tape produced on one model of tape
drive but read on a different model seem to generate parity errors
that are detected by the MAG_ library that FITSIN uses.  However,
this doesn't mean that you won't be able to read your FITS tape.
The UNIX tape-reading commands seem less sensitive to these parity
errors.
 Thus you should first attempt to convert the inaccessible FITS files
on tape to disc files using the UNIX dd command, and then use the
FITSDIN application to generate the output NDF or foreign format.
For example to convert a FITS file from device /dev/nrst0 to an NDF
called ndfname, you might enter
      % dd if=/dev/nrst0 ibs=2880 of=file.fits
     % fitsdin files=file.fits out=ndfname
     % rm file.fits
 where file.fits is the temporary disc-FITS file.  The 2880 is the
length of a FITS record in bytes.   Repeated dd commands to a
no-rewind tape device (those with the `n' prefix on OSF/1 and the
`n' suffix on Solaris) will copy successive files.  To skip over
files or rewind the tape, use the mt command.  For example,
      % mt -f /dev/rmt/1n fsf 3
           :       :       :
     % mt -f /dev/rmt/1n asf 4
 moves the tape on device /dev/rmt/1n forward three files, then moves
to the fourth file on the same device,
      % mt bsf 2
 moves back two files on the default tape drive (defined by the
environment variable TAPE), and
      % mt -f /dev/nrmt0h rewind
 rewinds to the start of the tape on device /dev/nrmt0h.  Thus it is
possible to write a script for extracting and converting a series of
files including ranges, just like FITSIN does.
 If the above approach fails, try another tape drive.
 2 FITSIN_does_not_Recognise_my_FITS_Tape
 If you attempt to read a FITS magnetic tape with FITSIN, you might
receive an error like this
      % fitsin
     % MT - Tape deck /@/dev/nrmt1h/ > /dev/nrmt3l
     !! Object '/DEV/NRMT3L' not found.
     !  DAT_FIND: Error finding a named component in an HDS structure.
     !  /dev/nrmt3l: MAG__UNKDV, Unable to locate device in DEVDATASET
 when you enter the device name.  The magnetic-tape system uses an
\HDSref\ file called the device dataset (DEVDATASET) to store the
position of the tape between invocations of Starlink applications.
 When FITSIN is given a name, the magnetic-tape system validates the
name to check that it is a known device.  There should be a
{\tt devdataset.sdf} file (within {\tt /star/etc} at Starlink sites)
containing a list of at least all the available drives at your site.
What FITSIN is complaining about above, is that the device you have
given is not included in the DEVDATASET file.  Now this might be
because you mistyped the device name, or that the particular device is
not accessible on the particular machine, or because your computer
manager
has not maintained the DEVDATASET when a drive was added.  You can look
at the contents of the DEVDATASET with this command.
      % hdstrace /star/etc/devdataset
 Oh and one other point: make sure the tape is loaded in the drive.
Yes this mistake has happened (not mentioning any names) and it is
very hard to diagnose remotely.
 2 It_Used_to_Work... and Weird Errors
There is a class of error that arises when an HDS file is corrupted.
The specific message will depend on the file concerned and where
in the file the corruption occurred.  The most likely reason for
file corruption is breaking into a task at the wrong moment, or
trying to write to a file at the same time.
 If you want to process simultaneously from different sessions---say
one interactive and another in batch---it is wise to redefine the
environment variables $ADAM_USER, and $AGI_USER if you want graphics
on the same machine.  The environment variables should point to a
separate existing directory for each additional session.  This will
keep the global and application parameters, and the graphics
database separate for each session. 
 The way to look for corrupted HDS files is trace them.  Assuming
that $ADAM_USER and $AGI_USER are defined,
      % hdstrace $ADAM_USER/GLOBALS full
     % hdstrace $ADAM_USER/ardmask full
     % hdstrace $AGI_USER/agi_cacvad full
 traces the GLOBALS file, the application you were running when the
weird error occurred (here ARDMASK), and the graphics database for
machine cacvad.  Once you have identified the problem file, delete
it.  If that proves to be the globals file, you might want to retain
the output from HDSTRACE, so that you can restore their former
values.  Deleting the graphics database is something you should do
regularly, so that's not a problem.
 If you have been running KAPPA from ICL, you will need to check of
the integrity of the monolith parameter file, instead the
individual parameter file.  It will be one of these depending on
the type of task that failed: graphics, NDF components, or the
rest (mostly image processing) corresponding to these three
monolith interface files.
      % hdstrace $ADAM_USER/kapview_mon full
     % hdstrace $ADAM_USER/ndfpack_mon full
     % hdstrace $ADAM_USER/kappa_mon full
  If that doesn't cure the problem, send me mjc@star.rl.ac.uk or the
Starlink Software Librarian ussc@star.rl.ac.uk a log of the session
demonstrating the problem, and we shall endeavour to interpret it
for you, and find out what's going wrong.
 1 Procedures
 Applications from KAPPA and other packages can be combined in
procedures and scripts to customise and automate data processing.
In addition to giving literal values to application parameters, you
can include ICL or C-shell variables on the command line, whose
values are substituted at run time.  It is also possible to write
parameter data into variables, and hence pass them to another
application, or use the variables to control subsequent processing.
 2 C-shell_scripts
 The "C-shell Cookbook" (SC/4) contains many ingredients and recipes,
and features many KAPPA commands.  So there is little point
repeating them here other than to direct you to a documented script
in $KAPPA_DIR/multiplot.csh.
 

ICL_Procedures

 You should consult the "ICL Users' Guide" (SG/5) for details
about writing ICL syntax, procedures, and functions, but you're
a busy researcher...   For a quick overview the *two-page* summary
on "Writing ICL command files and procedures" in SUN/101 is
recommended reading, even though much of the document is dated and
still refers to VMS.  Here we'll just show some example procedures
that can be adapted and cover points not mentioned in SUN/101.
 Let's start with something simple.  You want to `flash' a series of
images, each with a yellow border.  First you write the following
procedure called FLASH.  It has one argument INPIC, that passes the
name of the NDF you want to display.  When you substitute an ICL
variable for a parameter value you enclose it in parentheses.  The
lines beginning with { are comments.
      PROC FLASH INPIC
     {
     { Procedure for displaying an image without scaling and a
     { yellow border.
     {
        DISPLAY IN=(INPIC) MODE=FL BORDER BCOLOUR=Yellow
     END PROC
 To make ICL recognise your procedure you must `load' it.  The command
      ICL> LOAD FLASH
 will load the file FLASH.ICL.  Thereafter in the ICL session you can
invoke FLASH for many NDFs.  The following will display the NDFs
called GORDON and FLOOD side-by-side.
      ICL> PICGRID 2 1 
     ICL> FLASH GORDON
     ICL> PICSEL 2
     ICL> FLASH FLOOD
 It would be tedious to have to load lots of individual procedures,
but you don't.  If you have related procedures that you regularly
require they can be concatenated into a single file which you load.
Better still is to add definitions for each of the procedures in
your ICL login file.  This is defined as the value of the ICL_LOGIN
environment variable.  A reasonable place is in your home directory
and you'd define it like this.
      % setenv ICL_LOGIN $HOME/login.icl
 However, the file doesn't have to be in your home directory, or
called login.icl, but it's convenient to do so.  Suppose you have
three procedures: FLASH, PICGREY in file $MY_DIR/display_proc.icl,
and FILTER in /home/user1/dro/improc.icl.  In your $HOME/login.icl
you could add the following
      defproc  flash     $MY_DIR/display_proc.icl
     defproc  sfilt     $HOME/user1/dro/improc.icl filter
     defproc  picgr(ey) $MY_DIR/display_proc.icl
 which defines three commands that will be available each time you
use ICL: FLASH which will run your FLASH procedure, PICGREY to
execute the PICGREY procedure, and SFILT which runs the FILTER
procedure.  In addition PICGREY can be abbreviated to PICGR or
PICGRE.  So now you can load and run your procedure.
 Let's have some more example procedures.  Suppose you have a series
of commands to run on a number of files.  You could create a
procedure to perform all the stages of the processing, deleting the
intermediate files that it creates.
      PROC UNSHARPMASK NDFIN CLIP NDFOUT
      { Insert ampersands to tell the command-line interpreter than
     { these strings are file names.
        IF SUBSTR( NDFIN, 1, 1 ) <> '@'
           NDFIN = '@' & (NDFIN)
        END IF
        IF SUBSTR( JUNK, 1, 1 ) <> '@'
           NDFOUT = '@' & (NDFOUT)
        END IF
      { Clip the image to remove the cores of stars and galaxies
     { above a nominated threshold.
        THRESH (NDFIN) TMP1 THRHI=(CLIP) NEWHI=(CLIP) \
      { Apply a couple of block smoothings with boxsizes of 5 and 13
     { pixels.  Delete the temporary files as we go along.
        BLOCK tmp1 tmp2 BOX=5
        ! rm tmp1.sdf
        BLOCK tmp2 tmp3 BOX=13
        ! rm tmp2.sdf
      { Multiply the smoothed image by a scalar.
        CMULT tmp3 0.8 tmp4
        ! rm tmp3.sdf
      { Subtract the smoothed and renormalised image from the input
     { image.   The effect is to highlight the fine detail, but
     { still retain some of the low-frequency features.
        SUB (NDFIN) tmp4 (NDFOUT)
        ! rm tmp4.sdf
     END PROC
 There is a piece of syntax to note which often catches people out.
Filenames, data objects, and devices passed via ICL variables
to applications, such as NDFIN and NDFOUT in the above example,
must be preceded by an @.
 A common use of procedures is likely to be to duplicate processing
for several files.  Here is an example procedure that does that.
It uses some intrinsic functions which look just like Fortran.
      PROC MULTISTAT
      { Prompt for the number of NDFs to analyse.  Ensure that it
     { is positive.
        INPUTI Number of frames:  (NUM)
        NUM = MAX( 1, NUM )
      { Find the number of characters required to format the number
     { as a string using a couple of ICL functions.
        NC = INT( LOG10( I ) ) + 1
      { Loop NUM times.
        LOOP FOR I=1 TO (NUM)
      { Generate the name of the NDF to be analysed via the ICL
     { function SNAME.
          FILE = '@' & SNAME('REDX',I,NC)
      { Form the statistics of the image.
          STATS NDF=(FILE)
        END LOOP
     END PROC
 If NUM is set to 10, the above procedure obtains the statistics of
the images named REDX1, REDX2, ... REDX10.  The ICL variable FILE
is in parentheses because its value is to be substituted into
parameter NDF. 
 Here is another example, which could be used to flat field a series
of CCD frames.  Instead of executing a specific number of files, you
can enter an arbitrary sequence of NDFs.  When processing is
completed a !! is entered rather than an NDF name, and that exits
the loop.  Note the ~ continuation character (it's not required but
it's included for pedagogical reasons).
      PROC FLATFIELD
      { Obtain the name of the flat-field NDF.  If it does not have
     { a leading @ insert one.
        INPUT "Which flat field frame?: " (FF)
        IF SUBSTR( FF, 1, 1 ) <> '@'
           FF = '@' & (FF)
        END IF
      { Loop until there are no further NDFs to flat field.
        MOREDATA = TRUE
        LOOP WHILE MOREDATA
      { Obtain the frame to flat field.  Assume that it will not have
     { an @ prefix.  Generate a title for the flattened frame.
           INPUT "Enter frame to flat field (!! to exit): " (IMAGE)
           MOREDATA = IMAGE <> '!!'
           IF MOREDATA
              TITLE = 'Flat field of ' & (IMAGE)
              IMAGE = '@' & (IMAGE)
      { Generate the name of the flattened NDF.
              IMAGEOUT = (IMAGE) & 'F'
              PRINT Writing to (IMAGEOUT) 
      { Divide the image by the flat field.
              DIV IN1=(IMAGE) IN2=(FF) OUT=(IMAGEOUT) ~
                TITLE=(TITLE)
           END IF
        END LOOP
     END PROC
  Some KAPPA applications, particularly the statistical ones, produce
output parameters which can be passed between applications via ICL
variables.  Here is an example to draw a contour plot centred about
a star in a nominated data array from only the star's approximate
position.  The region about the star is stored in an output NDF file.
Note the syntax required to define the value of parameter INIT; the
space between the left bracket and parenthesis is essential.
      PROC COLSTAR FILE,X,Y,SIZE,OUTFILE
      {+
     {  Arguments:
     {     FILE = FILENAME (Given)
     {        Input NDF containing one or more star images.
     {     X = REAL (Given)
     {        The approximate x position of the star.
     {     Y = REAL (Given)
     {        The approximate y position of the star.
     {     SIZE = REAL (Given)
     {        The half-width of the region about the star's centroid to be
     {        plotted and saved in the output file.
     {     OUTFILE = FILENAME (Given)
     {        Output primitive NDF of 2*%SIZE+1 pixels square (unless
     {        constrained by the size of the data array or because the
     {        location of the star is near an edge of the data array.
     {-
      { Ensure that the filenames have the @ prefix.
        IF SUBSTR( FILE, 1, 1 ) <> '@'
           NDF = '@' & (FILE)
        ELSE
           NDF = (FILE)
        END IF
        IF SUBSTR( OUTFILE, 1, 1 ) <> '@'
           NDFOUT = '@' & (OUTFILE)
        ELSE
           NDFOUT = (OUTFILE)
        END IF
      { Search for the star in a 21x21 pixel box.  The centroid of the
     { star is stored in the ICL variables XC and YC.
        CENTROID NDF=(NDF) INIT=[ (X&','&Y)] XCEN=(XC) YCEN=(YC) ~
          MODE=INTERFACE SEARCH=21 MAXSHIFT=14
      { Convert the co-ordinates to pixel indices.
        IX = NINT( XC + 0.5 )
        IY = NINT( YC + 0.5 )
      { Find the upper and lower bounds of the data array to plot.  Note
     { this assumes no origin information in stored in the data file.
        XL = MAX( 1, IX - SIZE )
        YL = MAX( 1, IY - SIZE )
        XU = MAX( 1, IX + SIZE )
        YU = MAX( 1, IY + SIZE )
      { Create a new NDF centred on the star.
        NDFCOPY IN=(NDF)((XL):(XU),(YL):(YU)) OUT=(NDFOUT)
      { Draw a contour plot around the star on the current graphics
     { device at the given percentiles.
        TURBOCONT NDF=(NDFOUT) MODE=PE PERCENTILES=[80,90,95,99]
      { Exit if an error occurred, such as not being able to find a star
     { near the supplied position, or being unable to make the plot.
        EXCEPTION ADAMERR
           PRINT Unable to find or plot the star.
        END EXCEPTION
     END PROC
\end{verbatim}
\normalsize
 Here is another that creates a fancy display of an image with axes and
a key showing data values.  Besides ICL syntax, it illustrates the use
of some graphics-database commands.  Again note the need to give an
expression combining the $x$-$y$ bounds of the key to the LBOUND and
UBOUND parameter arrays.
      PROC FANCYLOOK NDF
      { Function:
     {    Plots a image with axes and colour-table key.
      { Insert the prefix to tell the parser that this is a file.
        IF SUBSTR( NDF, 1, 1 ) <> '@'
           FILE = '@' & (NDF)
        ELSE
           FILE = (NDF)
        END IF
      { Clear the current window.
        GDCLEAR CURRENT
      { Set the background and annotation colours.
        PALENTRY 0 Sienna
        PALENTRY 1 Yellow
      { Find the extent of the current picture and its aspect ratio.
        GDSTATE NCX1=(FX1) NCX2=(FX2) NCY1=(FY1) NCY2=(FY2) NOREPORT
        ASP = ( FX2 - FX1 ) / ( FY2 - FY1 )
      { Inquire the label of the current picture.  If it does not
     { have one label the current picture
        PICIN CURRENT LABEL=(ORIGLABEL) NOREPORT NAME=!
        IF ORIGLABEL = " "
           PICLABEL ORIGIN
           ORIGLABEL = "ORIGIN"
        END IF
      { Display the image with axes using the most-ornate fount.
        DISPLAY (FILE) MODE=PE AXES FONT=NCAR COSYS=D ~
                SCALOW=(LOW) SCAHIGH=(HIGH) \
      { Find the extent of the last frame picture, i.e. the one
     { associated with the last displayed image.
        PICFRAME
        GDSTATE NCX1=(DX1) NCX2=(DX2) NCY1=(DY1) NCY2=(DY2) NOREPORT
      { Determine the widths of the borders.
        XL = DX1 - FX1
        XR = FX2 - DX2
        YB = DY1 - FY1
        YT = FY2 - DY2
      { Restore the original current picture.
        PICSEL (ORIGLABEL)
      { Only plot a key if there is room. 
        IF MAX( XL, XR, YB, YT ) > 0.055
      { Determine which side has most room for the key.  First, see if
     { the key is vertical.
           IF MAX( XL, XR ) >= MAX( YB, YT )
      { Determine the width and height of the vertical key.  Bias to
     { select the right-hand side.  Part of the 0.75 is to allow for
     { the wider border to the left (0.19:0.05 of frame).  Try to
     { obtain the same width, subject to the constraint that it must
     { fit inside the current picture. 
              ASPOBL = MAX( ASP, 1.0 )
              WIDTH = MIN( 1.2 * MAX( 0.75 * XL, XR ), 0.14 / ASPOBL )
              HEIGHT = 0.7 * ( DY2 - DY1 )
      { Define the bounds of the colour-table key.   Offset the key so
     { that there is no large gap between it and the image's axes.
     { The factors are empirical, and no doubt could be improved with
     { a more-sophisticated algorithm.
              DELTA = 0.12 * MAX( 0.0, DX2 - DX1 - 0.6 / ASPOBL )
              IF XL > 1.333 * XR
                 XK1 = MAX( 0.01, DX1 - WIDTH + DELTA )
              ELSE
                 XK1 = DX2 - DELTA * 5.0 / 19.0
              END IF
              XK2 = XK1 + WIDTH
              YK1 = 0.5 * ( DY2 + DY1 - HEIGHT )
              YK2 = YK1 + HEIGHT
           ELSE
      { Determine the width and height of the horizontal key.  Try to
     { obtain the same width, subject to the constraint that it must
     { fit inside the current picture. 
              ASPPRO = MIN( ASP, 1.0 )
              WIDTH = MIN( 1.2 * MAX( YB, YT ), 0.1 * ASPPRO )
              HEIGHT = 0.7 * ( DX2 - DX1 )
      { Define the bounds of the colour-table key.   Offset the key so
     { that there is no large gap between it and the image's axes.
     { The factors are empirical, and no doubt could be improved with
     { a more-sophisticated algorithm.
              DELTA = 0.11 * MAX( 0.0, DY2 - DY1 - 0.6 * ASPPRO )
              IF YB > YT
                 YK1 = MAX( 0.01, DY1 - WIDTH + DELTA )
              ELSE
                 YK1 = DY1 - DELTA * 9.0 / 15.0
              END IF
              YK2 = YK1 + WIDTH
              XK1 = 0.5 * ( DX2 + DX1 - HEIGHT )
              XK2 = XK1 + HEIGHT
           END IF
      { So far the units are in NDC.  LUTVIEW uses co-ordinates which
     { go from (0,0) to (1,1) for both axes.  So transform some of the
     { co-ordinates.
           IF ASP >= 1
              YK1 = YK1 * ASP
              YK2 = YK2 * ASP
           ELSE
              XK1 = XK1 / ASP
              XK2 = XK2 / ASP
           END IF
      { Draw the key to fit within the current picture annotating with 
     { the scaling used in DISPLAY.
           LUTVIEW LOW=(LOW) HIGH=(HIGH) LBOUND=[ (XK1&','&YK1)] ~
             UBOUND=[ (XK2&','&YK2)] MODE=XY
        END IF
     END PROC
.endhelp
