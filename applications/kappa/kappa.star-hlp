0 Help
 Welcome to the KAPPA online help system.  Here you can display
 details about a specific KAPPA command or more-general information
 such as what KAPPA can do and how to use it.  If you need assistance
 using this help system, enter "Using_help" in response to the
 "Topic?" prompt.  If you need information how to obtain help
 specifically about KAPPA, see the help sub-topics in the "Hints" item.
 (Enter "Hints" at the "Topic?" prompt.)  New users are recommended to
 consult the "Hints" topic.

1 ADD
Adds two NDF data structures.

Usage:

   add in1 in2 out

Description:

   The routine adds two NDF data structures pixel-by-pixel to produce
   a new NDF.
2 Parameters
For information on individual parameters, select from the list below:
3 IN1
IN1 = NDF (Read)
   First NDF to be added.
3 IN2
IN2 = NDF (Read)
   Second NDF to be added.
3 OUT
OUT = NDF (Write)
   Output NDF to contain the sum of the two input NDFs.
3 TITLE
TITLE = LITERAL (Read)
   Value for the title of the output NDF.  A null value will cause
   the title of the NDF supplied for parameter IN1 to be used
   instead. [!]
2 Examples
add a b c
   This adds the NDF called b to the NDF called a, to make the
   NDF called c.  NDF c inherits its title from a.

add out=c in1=a in2=b title="Co-added image"
   This adds the NDF called b to the NDF called a, to make the
   NDF called c.  NDF c has the title "Co-added image".
2 Notes
If the two input NDFs have different pixel-index bounds, then
they will be trimmed to match before being added.  An error will
result if they have no pixels in common.
2 Related_Applications
   KAPPA: CADD, CDIV, CMULT, CSUB, DIV, MATHS, MULT, SUB.
2 Authors
RFWS: R.F. Warren-Smith (STARLINK)

MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 4-APR-1990 (RFWS):
    Original version, derived from the previous non-NDF routine of
    the same name.

 1992 January 15 (MJC):
    Added Usage and Examples items.

 1995 September 12 (MJC):
    Title inherited by default.  Usage and examples to lowercase.
    Added Related Applications.

 5-JUN-1998 (DSB):
    Added propagation of WCS component.
2 Implementation_Status
   -  This routine correctly processes the WCS, AXIS, DATA, QUALITY,
   LABEL, TITLE, HISTORY, and VARIANCE components of an NDF data
   structure and propagates all extensions.

   -  Units processing is not supported at present and therefore the
   UNITS component is not propagated.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.
1 APERADD
    Derives statistics of pixels within a specified circle of a 2-d
    data array.
 
   This routine takes an input 2-d data array in an IMAGE structure
   and bins up all the pixels that lie within specified circles to
   either increase the signal-to-noise over that region, or to
   simulate a circular-aperture measurement of the image.

   WARNING: This simple task does not divide the light of pixels
   spanning the circle.  If the pixel's centre lies within the circle,
   its full value is included in the summation; if it lies outside
   the circle, the pixel value is excluded from the summation.
   Therefore this task is not suitable for accurate aperture
   photometry, especially where the aperture diameter is less than
   about ten times the pixel size.  Use PHOTOM where accuracy, rather
   than speed, is paramount.

   The following are displayed: the standard deviation of the
   intensity of the pixels within the aperture before binning, the
   integrated value over the aperture, and the calculated mean level
   and reduced noise after binning.
 
   The magic-value method is used for processing bad data.
2 AUTHORS
   Mark McCaughrean UoE ( REVA::MJM )
   Malcolm Currie  STARLINK (RAL::CUR)
2 DEFICIENCIES
   The circle centre must lie somewhere on the array, which is
   by far the most likely option, but it not totally general.
2 HISTORY
   22-10-1985 : First implementation (REVA::MJM)
   17-01-1986 : More error checking and tidying (REVA::MJM)
   1986 Aug 3 : Renamed algorithm subroutine (APADSB) (RAL::CUR)
   1986 Aug 27: Argument section added and nearly conformed to
                Starlink standards (RAL::CUR)
   1987 Oct 13: Extra status check for mapping image (RAL::CUR)
   1988 Feb 14: Removed SCALE parameter and references to intensity
                and referred to `array' rather than `image'
                (RAL::CUR)
   1988 Apr 30: Correct labelling of output and a loop introduced
                to measure in more than one aperture (RAL::CUR).
   1988 May 29: More reporting of error context (RAL::CUR)
   1989 Jul 27: Passed array dimensions as separate variables
                to APADSB (RAL::CUR).
   1990 Mar 10: Logfile option added (RAL::CUR).
   1990 Sep 18: Added results parameters (RAL::CUR).
   1992 Feb 23: Limited processing of simple NDFs (RAL::CUR).
   1992 Mar  3: Replaced AIF parameter-system calls by the extended
                PAR library (RAL::CUR).
   1995 Sep 19: Clarified the limitations of APERADD.  Made it use
                the floating-point centre co-ordinates rather than
                pixel indices. (MJC)
2 PARAMETERS
   LOGFILE = FILENAME( READ )
       Name of the text file to record the statistics. If null,
         there will be no logging.
   INPIC = IMAGE( READ )
       Input IMAGE structure containing data array to be processed
   XCEN = REAL( READ )
       x co-ordinate of the circle centre
   YCEN = REAL( READ )
       y co-ordinate of the circle centre
   DIAM = REAL( READ )
       Diameter of the circle in pixels
   AGAIN = LOGICAL( READ )
       If true then another aperture can be chosen
   NUMPIX = INTEGER( WRITE )
       The number of pixels within the aperture.
   TOTAL = REAL( WRITE )
       The total of the pixel values within the aperture.
   MEAN = REAL( WRITE )
       The mean of the pixel values within the aperture.
   SIGMA = REAL( WRITE )
       The standard deviation of the pixel values within the
       aperture.
   NOISE = REAL( WRITE )
       The standard deviation of the pixel values within the
       aperture after binning.
3 INPIC
  position    1
  keyword     'INPIC'
  type        'IMAGE'
  access      'READ'
  vpath       'PROMPT'
  ppath       'GLOBAL'
  association '<->GLOBAL.DATA_ARRAY'
  prompt      'Image to be binned'
  help        'Name of the IMAGE structure containing the 2-d data 
              array to be examined'
3 XCEN
  position    2
  keyword     'XCEN'
  type        '_REAL'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'x co-ordinate of circle centre'
  help        'Give the x co-ordinate of the centre of the circle to 
              be binned up'
3 YCEN
  position    3
  keyword     'YCEN'
  type        '_REAL'
  ppath       'DYNAMIC'
  vpath       'PROMPT'
  prompt      'y co-ordinate of circle centre'
  help        'Give the y co-ordinate of the centre of the circle to 
              be binned up'
3 DIAM
  position    4 
  keyword     'DIAM'
  type        '_REAL'
  ppath       'DYNAMIC,DEFAULT'
  vpath       'PROMPT'
  prompt      'Diameter of circle'
  help        'Give diameter (in pixels) of the circle to be binned'
  default     10.0
3 LOGFILE
  position    5
  keyword     'LOGFILE'
  type        'FILENAME'
  access      'READ'
  vpath       'DEFAULT'
  ppath       'CURRENT,DEFAULT'
  prompt      'File to log the results'
  default     !
  help        'Name of the ASCII file to be used to record the 
              statistics.'
3 AGAIN
  position    6
  keyword     'AGAIN'
  type        '_LOGICAL'
  ppath       'DEFAULT'
  vpath       'PROMPT'
  prompt      'Do you another aperture in the same 2-d array?'
  help        'Option to select another aperture in same input data 
              array. Type N to exit'
  default     N
3 NUMPIX
  keyword     'NUMPIX'
  access      'WRITE'
  type        '_INTEGER'
  vpath       'DEFAULT'
  prompt      'Object to contain the number of pixels'
  default     0
3 TOTAL
  keyword     'TOTAL'
  access      'WRITE'
  type        '_REAL'
  vpath       'DEFAULT'
  prompt      'Object to contain the total value'
  default     0.0
3 MEAN
  keyword     'MEAN'
  access      'WRITE'
  type        '_REAL'
  vpath       'DEFAULT'
  prompt      'Object to contain the mean value'
  default     0.0
3 SIGMA
  keyword     'SIGMA'
  access      'WRITE'
  type        '_REAL'
  vpath       'DEFAULT'
  prompt      'Object to contain the standard deviation'
  default     0.0
3 NOISE
  keyword     'NOISE'
  access      'WRITE'
  type        '_REAL'
  vpath       'DEFAULT'
  prompt      'Object to contain the standard deviation after
              binning'
  default     0.0
1 ARDGEN
Creates a text file describing selected regions of an image.

Usage:

   ardgen ardout shape option [device] [startup]
      { operands=? operator=?
      { regions=?
      option

Description:

   This is an interactive tool for selecting regions of a displayed
   image using a cursor, and then storing a description of the
   selected regions in a text file in the form of an `ARD
   Description' (see SUN/183).  This text file may subsequently be
   used in conjunction with packages such as CCDPACK or ESP.

   The application initially obtains a value for the SHAPE parameter
   and then allows you to identify either one or many regions of the
   specified shape, dependent on the value of parameter STARTUP.
   When the required regions have been identified, a value is
   obtained for parameter OPTION, and that value determines what
   happens next.  Options include obtaining further regions,
   changing the current region shape, listing the currently defined
   regions, leaving the application, etc.  Once the selected action
   has been performed, another value is obtained for OPTION, and
   this continues until you choose to leave the application.

   Instructions on the use of the cursor are displayed when the
   application is run.  The points required to define a region of
   the requested shape are described whenever the current region
   shape is changed using parameter SHAPE.  Once the points required
   to define a region have been given an outline of the entire
   region is drawn on the graphics device using the pen specified by
   parameter PALNUM.

   In the absence of any other information, subsequent application
   will use the union (i.e. the logical OR) of all the defined
   regions.  However, regions can be combined in other ways using the
   COMBINE option (see parameter OPTION).  For instance, two regions
   originally defined using the cursor could be replaced by their
   region of intersection (logical AND), or a single region could be
   replaced by its own exterior (logical NOT).  Other operators can
   also be used (see parameter OPERATOR).
2 Parameters
For information on individual parameters, select from the list below:
3 ARDOUT
ARDOUT = FILENAME (Write)
   Name of the text file in which to store the description of the
   selected regions.
3 DEVICE
DEVICE = DEVICE (Read)
   The graphics device on which the regions are to be selected.
   [Current graphics device]
3 OPERANDS
OPERANDS() = _INTEGER (Read)
   A pair of indices for the regions which are to be combined
   together using the operator specified by parameter OPERATOR.
   If the operator is "NOT", then only one region index need be
   supplied.  Region indices are displayed by the "List" option
   (see parameter OPTION).
3 OPERATOR
OPERATOR = LITERAL (Read)
   The operator to use when combining two regions into a single
   region.  The pixels included in the resulting region depend on
   which of the following operators is selected.

   "AND" - Pixels are included if they are in both of the regions
           specified by parameter OPERANDS.
   "EQV" - Pixels are included if they are in both or neither of
           the regions specified by parameter OPERANDS.
   "NOT" - Pixels are included if they are not inside the region
           specified by parameter OPERANDS.
   "OR"  - Pixels are included if they are in either of the
           regions specified by parameter OPERANDS.  Note, an OR
           operator is implicitly assumed to exist between each
           pair of adjacent regions unless some other operator is
           specified.
   "XOR" - Pixels are included if they are in one, but not both,
           of the regions specified by parameter OPERANDS.
3 OPTION
OPTION= LITERAL (Read)
   A value for this parameter is obtained when you choose to end
   cursor input (by pressing the relevant button as described
   when the application starts up).  It determines what to do
   next.  The following options are available:

   "Combine" - Combine two previously defined regions into a
               single region using a Boolean operator, or invert
               a previously defined region using a Boolean .NOT.
               operator.  See parameters OPERANDS and OPERATOR.  The
               original regions are deleted and the new combined
               (or inverted) region is added to the end of the
               list of defined regions.
   "Delete"  - Delete previously defined regions, see parameter
               REGIONS.
   "Draw"    - Draw the outline of the union of one or more previously
               defined regions, see parameter REGIONS.
   "Exit"    - Write out the currently defined regions to a text
               file and exit the application.
   "List"    - List the textual descriptions of the currently
               defined regions on the screen.  Each region is
               described by an index value, a "keyword"
               corresponding to the shape, and various arguments
               describing the extent and position of the shape.
               These arguments are described in the "Notes"
               section below.
   "Multi"   - The cursor is displayed and you can then identify
               multiple regions of the current shape, without
               being re-prompted for OPTION after each one.  These
               regions are added to the end of the list of
               currently defined regions.  If the current shape is
               "Polygon", "Frame" or "Whole" (see parameter SHAPE)
               then multiple regions cannot be defined and the
               selected option automatically reverts to "Single".
   "Single"  - The cursor is displayed and you can then identify a
               single region of the current shape.  You are
               re-prompted for parameter OPTION once you have
               defined the region.  The identified region is
               added to the end of the list of currently defined
               regions.
   "Shape"   - Change the shape of the regions created by the
               "Single" and "Multi" options.  This causes a new
               value for parameter SHAPE to be obtained.
   "Style"   - Change the drawing style by providing a new value
               for parameter STYLE.
   "Quit"    - Quit the application without saving the currently
               defined regions.
   "Undo"    - Undo the changes made to the list of ARD regions by
               the previous option. Note, the undo list can contain
               upto 30 entries. Entries are only stored for options
               which actually produce a change in the list of regions.
3 REGIONS
REGIONS() = LITERAL (Read)
   The list of regions to be deleted or drawn.  Regions are numbered
   consecutively from 1 and can be listed using the "List" option
   (see parameter OPTION).  Single regions or a set of adjacent
   regions may be specified, e.g. assigning [4,6-9,12,14-16] will
   delete regions 4,6,7,8,9,12,14,15,16.  (Note that the brackets
   are required to distinguish this array of characters from a
   single string including commas.  The brackets are unnecessary
   when there is only one item.)  The numbers need not be in
   ascending order.

   If you wish to delete or draw all the regions enter the wildcard *.
   5-* will delete or draw from 5 to the last region.
3 SHAPE
SHAPE = LITERAL (Read)
   The shape of the regions to be defined using the cursor.
   After selecting a new shape, you are immediately requested to
   identify multiple regions as if "Multi" had been specified for
   parameter OPTION.  The currently available shapes are listed
   below.

   "Box"       - A rectangular box with sides parallel to the
                 co-ordinate axes, defined by its centre and one of its
                 corners.
   "Circle"    - A circle, defined by its centre and radius.
   "Column"    - A single value on axis 1, spanning all values on
                 axis 2.
   "Ellipse"   - An ellipse, defined by its centre, one end of
                 the major axis, and one other point which can be
                 anywhere on the ellipse.
   "Frame"     - The whole image excluding a border of constant
                 width, defined by a single point on the frame.
   "Point"     - A single pixel.
   "Polygon"   - Any general polygonal region, defined by up to
                 200 vertices.
   "Rectangle" - A rectangular box with sides parallel to the
                 co-ordinate axes, defined by a pair of diagonally
                 opposite corners.
   "Rotbox"    - A rotated box, defined by both ends of an edge,
                 and one point on the opposite edge.
   "Row"       - A single value on axis 2, spanning all values on
                 axis 1.
   "Whole"     - The whole of the displayed image.
3 STARTUP
STARTUP = LITERAL (Read)
   Determines if the application starts up in "Multi" or "Single"
   mode (see parameter OPTION). ["Multi"]
3 UNDO
UNDO = _LOGICAL (Read)
   Used to confirm that it is OK to proceed with an "Undo" option.
   The consequences of proceeding are described before the parameter
   is obtained.
2 Examples
ardgen extract.txt circle exit startup=single
   This example allows you to create a text file (extract.txt)
   describing a single circular region of the image displayed on
   the current graphics device.  The application immediately exits
   after the region has been identified.  This example may be
   useful in scripts or command procedures since there is no
   prompting.
2 Notes
-  An image must previously have been displayed on the graphics
device.

-  The arguments for the textual description of each shape are as
follows :

"Box"       - The co-ordinates of the centre, followed by the
              lengths of the two sides.
"Circle"    - The co-ordinates of the centre, followed by the
              radius.
"Column"    - The axis 1 co-ordinate of the column.
"Ellipse"   - The co-ordinates of the centre, followed by the
              lengths of the semi-major and semi-minor axes,
              followed by the angle between axis 1 and the
              semi-major axis (in radians).
"Frame"     - The width of the border.
"Point"     - The co-ordinates of the pixel.
"Polygon"   - The co-ordinates of each vertex in the order given.
"Rectangle" - The co-ordinates of two diagonally opposite corners.
"Rotbox"    - The co-ordinates of the box centre, followed by the
              lengths of the two sides, followed by the angle
              between the first side and axis 1 (in radians).
"Row"       - The axis 2 co-ordinate of the row.
"Whole"     - No arguments.

 -  The shapes are defined within the current co-ordinate
 Frame of the displayed NDF. For instance, if the current
 co-ordinate Frame of the displayed NDF is RA/DEC, then "COLUMN"
 regions will be curves of constant DEC, "ROW" regions will be curves
 of constant RA (assuming axis 1 is RA and axis 2 is DEC), straight
 lines will correspond to geodesics, etc. Numerical values will be
 stored in the output text file in the current coordinate Frame of
 the NDF. WCS information will also be stored in the output text
 file allowing the stored positions to be converted to other systems
 (pixel coordinates, for instance).
2 Related_Applications
   KAPPA: ARDMASK; CCDPACK; ESP.
2 Authors
GJP: Grant Privett (STARLINK)

DSB: David Berry (STARLINK)

MJC: Malcolm J. Currie (STARLINK)
2 History
 15-JUL-1994 (GJP)
    Original version

 11-NOV-1994 (GJP)
    Added ARD further keywords.

 30-NOV-1994 (DSB)
    Prologue largely re-written.  Re-formatted the code to
    EDSTAR-style.  Removed redundant checks on STATUS.  KEYWORD
    parameter renamed SHAPE.  Button assignments changed.  PIXEL
    removed as a shape option.  OPTION parameter introduced.
    Re-structured.  Store ARD descriptions internally in a GRP
    group instead of a text file.  LIST, DELETE, COMBINE and QUIT
    options added.  STARTUP parameter added.

 1995 March 15 (MJC):
    Added commentary, and corrected typographical errors.
    Standardised the variable declarations and style.  Removed
    the impersonal "the user".

 1995 December 16 (MJC):
    Devices with a mouse can use it instead of the keyboard.

 30-AUG-1999 (DSB):
    Do not cancel DEVICE when the graphics system is closed down.

 30-AUG-2001 (DSB):
    Modify to use AST/PGPLOT and ARD V2. Added options Draw.
1 ARDMASK
Uses an ARD file to set some pixels of an NDF to be bad.

Usage:

   ardmask in ardfile out

Description:

   This task allows regions of a NDF's data array to be masked, so
   that they can be excluded from subsequent data processing.  ARD
   (ASCII Region Definition) descriptions stored in a text
   file define which pixels of the data array are masked.  An
   output NDF is created which is the same as the input file except
   that all pixels specified by the ARD file have been assigned the
   bad value.
2 Parameters
For information on individual parameters, select from the list below:
3 ARDFILE
ARDFILE = FILENAME (Read)
   The name of the ARD file containing a description of the parts
   of the image to be masked out, i.e. set to bad.  The suggested
   default is the current value or ardfile.dat if there is no
   current value.
3 COSYS
COSYS = LITERAL (Read)
   The co-ordinate system to be used.  This can be either "World"
   or "Data".  If COSYS = "World" the co-ordinates used in the
   ARD file are pixel co-ordinates or indices.  If COSYS = "Data"
   the co-ordinates used in the ARD file are interpreted as data
   co-ordinates, provided the NDF contains axes that map onto
   pixel co-ordinates using linear transformations.  If there are
   no axes, pixel co-ordinates are assumed; if axes are present
   but non-linear, the task fails.  COSYS="World" is recommended.
   [Current co-ordinate system]
3 IN
IN = NDF (Read)
   The name of the source NDF.
3 OUT
OUT = NDF (Write)
   The name of the masked NDF.
3 TITLE
TITLE = LITERAL (Read)
   Title for the output NDF structure.  A null value (!)
   propagates the title from the input NDF to the output NDF. [!]
2 Examples
ardmask a1060 galaxies.ard a1060_sky title="A1060 galaxies masked"
   This flags pixels defined by the ARD file galaxies.ard within
   the NDF called a1060 to create a new NDF called a1060_sky.
   a1060_sky has a title="A1060 galaxies masked".  This might be
   to flag the pixels where bright galaxies are located to
   exclude them from sky-background fitting.

ardmask in=ic3374 ardfil=ardfile.txt out=ic3374a
   This example uses as the source image the NDF called ic3374
   and sets the pixels specified by the ARD description contained
   in ardfile.txt to the bad value.  The resultant image is
   output to the NDF called ic3374a.  The title is unchanged.

ardmask in=ic3374 ardfil=ardfile.txt out=ic3374a cosys=data
   As the previous example except that the ARD file is
   written using data co-ordinates.
2 ASCII-region-definition_Descriptors
   The ARD file may be created by ARDGEN or written manually.  In the
   latter case consult SUN/183 for full details of the ARD
   descriptors and syntax; however, much may be learnt from looking
   at the ARD files created by ARDGEN and the ARDGEN documentation.
   There is also a summary with examples in the main body of SUN/95
   and the online help.
2 Related_Applications
   KAPPA: ARDGEN.
2 Authors
GJP: Grant Privett (STARLINK)

MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 08-Jun-1994 (GJP):
    Original version.

 1995 June 29 (MJC):
    Converted for KAPPA use: completed and re-ordered the
    prologue, lowercase usage and examples, various stylistic
    changes, standard comment indentation, removed unnecessary
    status checks and code, allowed all numeric data types, added
    handling of data co-ordinates and COSYS parameter, propagates
    other components (axes, units, variance and quality), made to
    work on n-dimensional NDFs, validated the input text file and
    removed the need for the leading caret, and made the output
    TITLE a parameter.

 1996 July 31 (MJC):
    Made ARDFILE have type FILENAME for IRAF usage.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.
2 Implementation_Status
   -  This routine correctly processes the WCS, AXIS, DATA, QUALITY,
   LABEL, TITLE, UNITS, HISTORY, and VARIANCE components of an NDF
   data structure and propagates all extensions.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  Bad pixels and automatic quality masking are supported.

   -  All non-complex numeric data types can be handled.
1 ARDPLOT
Plot regions described in an ARD file.

Usage:

   ardplot ardfile [device] [regval]

Description:

   This application draws the outlines of regions described in
   a supplied 2-dimensional ARD file. The outlines are drawn over
   the top of a previously displayed picture, aligned (if possible)
   in the current coordinate Frame of the previously drawn picture.
2 Parameters
For information on individual parameters, select from the list below:
3 ARDFILE
ARDFILE = FILENAME (Read)
   The name of the ARD file containing a description of the regions
   to be outlined. The co-ordinate system in which positions within
   this file are given should be indicated by including suitable
   COFRAME or WCS statements within the file (see SUN/183). For
   instance, starting the file with a line containing the text
   "COFRAME(PIXEL)" will indicate that positions are specified in
   pixel coordinates. The statement "COFRAME(SKY,System=FK5)" would
   indicate that positions are specified in RA/DEC (FK5,J2000). If
   no such statements are included, then it is assumed that positions
   are given within the current co-ordinate system of the existing
   DATA picture.
3 DEVICE
DEVICE = DEVICE (Read)
   The plotting device. [Current graphics device]
3 REGVAL
REGVAL = _INTEGER (Read)
   Indicates which regions within the ARD description are to be
   outlined. If zero (the default) is supplied, then the plotted
   boundary encloses all the regions within the ARD file. If a
   positive value is supplied, then only the region with the
   specified index is outlined (the first region in the ARD file
   has index 2, for historical reasons). If a negative value is
   supplied, then all regions with indices greater than or equal
   to the absolute value of the supplied index are outlined. See
   SUN/183 for further information on the numbering of regions
   within an ARD description. [0]
3 STYLE
STYLE = GROUP (Read)
   A group of attribute settings describing the plotting style to use
   for the curves.

   A comma-separated list of strings should be given in which each
   string is either an attribute setting, or the name of a text file
   preceded by an up-arrow character "^". Such text files should
   contain further comma-separated lists which will be read and
   interpreted in the same manner. Attribute settings are applied in
   the order in which they occur within the list, with later settings
   over-riding any earlier settings given for the same attribute.

   Each individual attribute setting should be of the form:

      <name>=<value>

   where <name> is the name of a plotting attribute, and <value> is
   the value to assign to the attribute. Default values will be
   used for any unspecified attributes. All attributes will be
   defaulted if a null value (!) is supplied. See section "Plotting
   Attributes" in SUN/95 for a description of the available
   attributes. Any unrecognised attributes are ignored (no error is
   reported).

   The appearance of the plotted curves is controlled by the attributes
   Colour(Curves), Width(Curves), etc. [current value]
2 Examples
ardplot bulge
   Draws an outline around all the regions included in the ardfile
   named "bulge". The outline is drawn on the current graphics device
   and is drawn in alignment with the previous picture.
2 Notes
-  A DATA picture must already exist on the selected graphics
device before running this command. An error will be reported if no
DATA picture can be found.

-  The application stores a new DATA picture in the graphics
database. On exit the current database picture for the chosen
device reverts to the input picture.
2 Related_Applications
   KAPPA: ARDGEN, ARDMASK.
2 Authors
DSB: David Berry (STARLINK)
2 History
 13-SEP-2001 (DSB):
    Original version.
1 Automatic_Data_Conversion

Although KAPPA tasks do not work directly with `foreign' formats,
they can made to appear that they do.  What happens is that the
format is converted `on-the-fly' to a scratch NDF, which is then
processed by KAPPA.  If the processing creates an output NDF or
modifies the scratch NDF, this may be back-converted `on-the-fly'
too, and not necessarily to the original data format.  At the end,
the scratch NDF is deleted.  So for example you could have an IRAF
image file, use BLOCK to filter the array, and output the
resultant array as a FITS file.

We must first define the names of the recognised formats and a file
extension associated with each format.  In practice you'll most
likely do this with the convert command, which creates these
definitions for many popular formats.  The file extension determines
in which format a file is written.  There is an environment variable
called NDF_FORMATS_IN which defines the allowed formats in a
comma-separated list with the file extensions in parentheses.  Here
is an example. 

     % setenv NDF_FORMATS_IN 'FITS(.fit),IRAF(.imh),FIGARO(.dst)'

Once defined it lets you run KAPPA tasks on FITS, IRAF, or Figaro
files, like

     % stats m51.fit
     % stats m51.dst

would compute the statistics of a FITS file m51.fit, and then a
Figaro file m51.dst.

The environment variable also defines a search order.  Had you entered

     % stats m51

STATS would first look for an NDF called m51 (stored in file
m51.sdf).  If it could not locate that NDF, STATS would then look
for a file called m51.fit, and then m51.imh, and finally m51.dst,
stopping once a file was found and associating the appropriate
format with it.  If none of the files exist, you'll receive a
"file not found" error message.

You can still define an NDF section (see topic "NDF_Sections") when
you access an existing data file in a foreign format.  Thus

     % stats m51.imh"(100:200,200~81)"

would derive the statistics for x pixels between 100 and 200, and
y pixels 160 to 240 in the IRAF file m51.imh.

The conversion tasks may be your own for some private format, but
normally they will come from the CONVERT package (SUN/55).  If you
want to learn how to add conversions to the standard ones, you
should consult SSN/20.

There is an environment variable that defines the format of new data
files.  This could be assigned the same value as NDF_FORMATS_OUT,
though they don't have to be.

     % setenv NDF_FORMATS_OUT 'FITS(.fit),IRAF(.imh),FIGARO(.dst)'

If you supply the file extension when a KAPPA task creates a new
dataset, and it appears in NDF_FORMATS_OUT, you'll get a file in
that format.  So for instance,

     % ffclean in=m51.dst out=m51_cleaned.dst \\

cleans m51.dst and stores the result in m51_cleaned.dst.  On the
other hand, if you only give the dataset name

     % ffclean in=m51.dst out=m51_cleaned \\

the output dataset would be the first in the NDF_FORMATS_OUT list.
Thus if you want to work predominantly in a foreign format, place it
first in the NDF_FORMATS_IN and NDF_FORMATS_OUT lists.

If you want to create an output NDF, you must insert a full stop at
the head of the list.

     % setenv NDF_FORMATS_OUT '.,FITS(.fit),IRAF(.imh),FIGARO(.dst)'

This is the recommended behaviour.

If you just want to propagate the input data format, insert an asterisk
at the start of the output-format list.

     % setenv NDF_FORMATS_OUT '*,.,FITS(.fit),IRAF(.imh),FIGARO(.dst)'

This only affects applications which create a dataset using information
propagated from an existing dataset.  For instance, if the above
NDF_FORMATS_OUT were defined,

     % ffclean in=m51.dst out=m51_cleaned \\

would now create m51_cleaned.dst.  If there is no propagation
in the given application, the asterisk is ignored. 

You can retain the scratch NDF by setting the environment variable
NDF_KEEP to 1.  This is useful if you intend to work mostly with NDFs
and will save the conversion each time you access the dataset.

The convert command, which sets up definitions for the CONVERT package
defines the lists of input and output formats as follows.

     % setenv NDF_FORMATS_IN \
     'FITS(.fit),FIGARO(.dst),IRAF(.imh),GASP(.hdr),UNFORMATTED(.unf),
     UNF0(.dat),ASCII(.asc),TEXT(.txt),GIF(.gif),TIFF(.tif),
     COMPRESSED(.sdf.Z)'

     % setenv NDF_FORMATS_OUT \
     '.,FITS(.fit),FIGARO(.dst),IRAF(.imh),GASP(.hdr),UNFORMATTED(.unf),
     UNF0(.dat),ASCII(.asc),TEXT(.txt),GIF(.gif),TIFF(.tif),
     COMPRESSED(.sdf.Z)'

See the CONVERT documentation for more details of these conversions.

1 AXCONV
Expands spaced axes in an NDF into the primitive form.

Usage:

   axconv ndf

Description:

   This application routine converts in situ an NDF's axis centres
   in the `spaced' form into `simple' form.  Applications using the
   NDF_ library, such as KAPPA, are not currently capable of
   supporting spaced arrays, but there are packages that produce NDF
   files with this form of axis, notably Asterix.  This application
   provides a temporary method of allowing KAPPA et al. to handle
   these NDF datasets.
2 Parameters
For information on individual parameters, select from the list below:
3 NDF
NDF = NDF (Read and Write)
   The NDF to be modified.
2 Examples
axconv rosat256
   This converts the spaced axes in the NDF called rosat256 into
   simple form.
2 Related_Applications
   KAPPA: SETAXIS.
2 Authors
RDS: Richard Saxton  (STARLINK, Leicester)

MJC: Malcolm J. Currie (STARLINK)
2 History
 22-JUN-1992 (RDS):
    Original version.

 1992 November 26 (MJC):
    Brought up to KAPPA standards, and various improvements to the
    prologue.

 1995 April 24 (MJC):
    Made Usage lowercase.  Added Related Applications and an
    example.  Guessed previous history entry.
2 Implementation_Status
   -  Only axes with a real data type are created.
1 AXLABEL
Sets a new label value for an axis within an NDF data structure.

Usage:

   axlabel ndf label dim

Description:

   This routine sets a new value for a label component of an
   existing NDF AXIS data structure.  The NDF is accessed in update
   mode and any pre-existing label component is over-written with a
   new value.  Alternatively, if a `null' value (!) is given for the
   LABEL parameter, then the NDF's axis label component will be
   erased.  If an AXIS structure does not exist, a new one whose
   centres are pixel co-ordinates is created.
2 Parameters
For information on individual parameters, select from the list below:
3 DIM
DIM = _INTEGER (Read)
   The axis dimension for which the label is to be modified.
   There are separate labels for each NDF dimension.  The value
   must lie between 1 and the number of dimensions of the NDF.
   This defaults to 1 for a 1-dimensional NDF.  The suggested
   default is the current value. []
3 NDF
NDF = NDF (Read and Write)
   The NDF data structure in which an axis label component is to
   be modified.
3 LABEL
LABEL = LITERAL (Read)
   The value to be assigned to the NDF's axis label component
   (e.g. "Wavelength" or "Fibre index").  LABEL describes the
   quantity measured along the axis.  This value may later be
   used by other applications for labelling graphs or as a
   heading for columns in tabulated output.  The suggested
   default is the current value.
2 Examples
axlabel ngc253 "Offset from nucleus" 2
   Sets the label component of the second axis dimension of the
   NDF structure ngc253 to have the value "Offset from nucleus".

axlabel ndf=spect label=Wavelength
   Sets the axis label component of the 1-dimensional NDF
   structure spect to have the value "Wavelength".

axlabel datafile label=! dim=3
   By specifying a null value (!), this example erases any
   previous value of the label component for the third dimension
   in the NDF structure datafile.
2 Related_Applications
   KAPPA: AXUNITS, SETAXIS, SETLABEL.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1995 April 21 (MJC):
    Original version.
1 AXUNITS
Sets a new units value for an axis within an NDF data structure.

Usage:

   axunits ndf units dim

Description:

   This routine sets a new value for a units component of an
   existing NDF AXIS data structure.  The NDF is accessed in update
   mode and any pre-existing units component is over-written with a
   new value.  Alternatively, if a `null' value (!) is given for the
   UNITS parameter, then the NDF's axis units component will be
   erased.  If an AXIS structure does not exist, a new one whose
   centres are pixel co-ordinates is created.
2 Parameters
For information on individual parameters, select from the list below:
3 DIM
DIM = _INTEGER (Read)
   The axis dimension for which the units is to be modified.
   There are separate units for each NDF dimension.  The value
   must lie between 1 and the number of dimensions of the NDF.
   This defaults to 1 for a 1-dimensional NDF.  The suggested
   default is the current value. []
3 NDF
NDF = NDF (Read and Write)
   The NDF data structure in which an axis units component is to
   be modified.
3 UNITS
UNITS = LITERAL (Read)
   The value to be assigned to the NDF's axis units component
   (e.g. "Pixels" or "km/s").  UNITS describes the physical units
   of the quantity measured along the axis.  This value may later
   be used by other applications for labelling graphs and other
   forms of display where the NDF's axis co-ordinates are shown.
   The suggested default is the current value.
2 Examples
axunits ngc253 "arcsec" 2
   Sets the units component of the second axis dimension of the
   NDF structure ngc253 to have the value "arcsec".

axunits ndf=spect units=Angstrom
   Sets the axis units component of the 1-dimensional NDF
   structure spect to have the value "Angstrom".

axunits datafile units=! dim=3
   By specifying a null value (!), this example erases any
   previous value of the units component for the third dimension
   in the NDF structure datafile.
2 Related_Applications
   KAPPA: AXLABEL, SETAXIS, SETUNITS.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1995 April 21 (MJC):
    Original version.
1 BLOCK
Smooths a 1- or 2-dimensional image using a square or rectangular
box filter.

Usage:

   block in out box [estimator]

Description:

   This application applies a square or rectangular box filter to a
   1- or 2-dimensional image so as to smooth it.  Each output pixel
   is either the mean or the median of the input pixels within the
   filter box.  The mean estimator provides one of the fastest
   methods of smoothing an image and is often useful as a
   general-purpose smoothing algorithm when the exact form of the
   smoothing point-spread function is not important.  The image is
   held in an NDF data structure.
2 Parameters
For information on individual parameters, select from the list below:
3 BOX
BOX(2) = _INTEGER (Read)
   The x and y sizes (in pixels) of the rectangular box to be
   applied to smooth the image.  If only a single value is given,
   then it will be duplicated so that a square filter is used,
   except where the image is 1-dimensional, for which the box size
   along the insignificant dimension is set to 1.  The values
   given will be rounded up to positive odd integers, if
   necessary.
3 ESTIMATOR
ESTIMATOR = LITERAL (Read)
   The method to use for estimating the output pixel values.  It
   can be either "Mean" or "Median". ["Mean"]
3 IN
IN = NDF (Read)
   The input NDF containing the 1- or 2-dimensional image to which
   box smoothing is to be applied.
3 OUT
OUT = NDF (Write)
   The output NDF which is to contain the smoothed image.
3 TITLE
TITLE = LITERAL (Read)
   Value for the title of the output NDF. A null value will cause
   the title of the input NDF to be used. [!]
3 WLIM
WLIM = _REAL (Read)
   If the input image contains bad pixels, then this parameter
   may be used to determine the number of good pixels which must
   be present within the smoothing box before a valid output
   pixel is generated.  It can be used, for example, to prevent
   output pixels from being generated in regions where there are
   relatively few good pixels to contribute to the smoothed
   result.

   By default, a null (!) value is used for WLIM, which causes
   the pattern of bad pixels to be propagated from the input
   image to the output image unchanged. In this case, smoothed
   output values are only calculated for those pixels which are
   not bad in the input image.

   If a numerical value is given for WLIM, then it specifies the
   minimum fraction of good pixels which must be present in the
   smoothing box in order to generate a good output pixel.  If
   this specified minimum fraction of good input pixels is not
   present, then a bad output pixel will result, otherwise a
   smoothed output value will be calculated.  The value of this
   parameter should lie between 0.0 and 1.0 (the actual number
   used will be rounded up if necessary to correspond to at least
   1 pixel). [!]
2 Examples
block aa bb 9
   Smooths the 2-dimensional image held in the NDF structure aa,
   writing the result into the structure bb.  The smoothing box is
   9 pixels square.  If any pixels in the input image are bad,
   then the corresponding pixels in the output image will also be
   bad.  Each output pixel is the mean of the corresponding input
   pixels.

block spectrum spectrums 5 median title="Smoothed spectrum"
   Smooths the 1-dimensional data in the NDF called spectrum
   using a box size of 5 pixels, and stores the result in the NDF
   structure spectrums.  Each output pixel is the median of the
   corresponding input pixels.  If any pixels in the input image
   are bad, then the corresponding pixels in the output image
   will also be bad.  The output NDF has the title "Smoothed
   spectrum".

block ccdin(123,) ccdcol [1,9]
   Smooths the 123rd column in the 2-dimensional NDF called ccdin
   using a box size of 9 pixels, and stores the result in the NDF
   structure ccdcol.  The first value of the smoothing box is
   ignored as the first dimension has only one element.  Each
   output pixel is the mean of the corresponding input pixels.

block in=image1 out=image2 box=[5,7] estimator=median
   Smooths the 2-dimensional image held in the NDF structure
   image1 using a rectangular box of size 5x7 pixels.  The
   smoothed image is written to the structure image2.  Each
   output pixel is the median of the corresponding input pixels.

block etacar etacars box=[7,1] wlim=0.6
   Smooths the specified image data using a rectangular box 7x1
   pixels in size.  Smoothed output values are generated only if
   at least 60% of the pixels in the smoothing box are good,
   otherwise the affected output pixel is bad.
2 Timing
   When using the mean estimator, the execution time is
   approximately proportional to the number of pixels in the image
   to be smoothed and is largely independent of the smoothing box
   size. This makes the routine particularly suitable for applying
   heavy smoothing to an image.  Execution time will be
   approximately doubled if a variance array is present in the input
   NDF.

   The median estimator is much slower than the mean estimator, and is
   heavily dependent on the smoothing box size.
2 Related_Applications
   KAPPA: CONVOLVE, FFCLEAN, GAUSMOOTH, MEDIAN; Figaro: ICONV3,
   ISMOOTH, IXSMOOTH, MEDFILT.
2 Authors
RFWS: R.F. Warren-Smith (STARLINK)

MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 18-SEP-1990 (RFWS):
    Original version.

 1990 November 28 (MJC):
    Corrected call to generic routine for double-precision
    variance.

 1992 March 3 (MJC):
    Replaced AIF parameter-system calls by the extended PAR
    library.

 1992 April 4 (MJC):
    Made to handle significant dimensions for user-defined
    sections.

 16-DEC-1994 (DSB):
    Title propagated by default from input to output NDF.
    Introduced ESTIMATOR parameter.  Replaced AIF VM calls with PSX
    calls.

 1995 March 16 (MJC):
    Made to operate on 1-dimensional arrays.  Enabled the writing
    of the bad-pixel flags.  Usage and examples to lowercase.
    Added a "Related Applications" section.  Fixed bug that
    attempted to create an output variance array when the median
    estimator was selected.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   LABEL, TITLE, UNITS, WCS and HISTORY components of the input NDF and
   propagates all extensions.  In addition, if the mean estimator is
   used, the VARIANCE component is also processed.  If the median
   estimator is used, then the output NDF will have no VARIANCE
   component, even if there is a VARIANCE component in the input
   NDF.

   -  Processing of bad pixels and automatic quality masking are
   supported.  The bad-pixel flag is also written for the data and
   variance arrays.

   -  All non-complex numeric data types can be handled.  Arithmetic
   is performed using single-precision floating point, or double
   precision, if appropriate.
1 CADD
Adds a scalar to an NDF data structure.

Usage:

   cadd in scalar out

Description:

   The routine adds a scalar (i.e. constant) value to each pixel of
   an NDF's data array to produce a new NDF data structure.
2 Parameters
For information on individual parameters, select from the list below:
3 IN
IN = NDF (Read)
   Input NDF data structure, to which the value is to be added.
3 OUT
OUT = NDF (Write)
   Output NDF data structure.
3 SCALAR
SCALAR = _DOUBLE (Read)
   The value to be added to the NDF's data array.
3 TITLE
TITLE = LITERAL (Read)
   Value for the title of the output NDF.  A null value will cause
   the title of the NDF supplied for parameter IN to be used
   instead. [!]
2 Examples
cadd a 10 b
   This adds ten to the NDF called a, to make the NDF called b.
   NDF b inherits its title from a.

cadd title="HD123456" out=b in=a scalar=17.3
   This adds 17.3 to the NDF called a, to make the NDF called b.
   NDF b has the title "HD123456".
2 Related_Applications
   KAPPA: ADD, CDIV, CMULT, CSUB, DIV, MATHS, MULT, SUB.
2 Authors
RFWS: R.F. Warren-Smith (STARLINK)

MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 11-APR-1990 (RFWS):
    Original version.

 1992 January 15 (MJC):
    Added Usage and Examples items.

 1995 September 12 (MJC):
    Title inherited by default.  Usage and examples to lowercase.
    Added Related Applications.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   LABEL, TITLE, UNITS, HISTORY, WCS and VARIANCE components of an NDF
   data structure and propagates all extensions.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.
1 CALC
Evaluates a mathematical expression.

Usage:

   calc exp [prec] fa-fz=? pa-pz=?

Description:

   This task evaluates an arithmetic expression and reports the
   result.  It main role is to perform floating-point arithmetic in
   scripts.  A value "Bad" is reported if there was an error
   during the calculation, such as a divide by zero.
2 Parameters
For information on individual parameters, select from the list below:
3 EXP
EXP = LITERAL (Read)
   The mathematical expression to be evaluated, e.g.
   "-2.5*LOG10(PA)".  In this expression constants may either be
   given literally or represented by the variables PA, PB, ...
   PZ.  The expression may contain sub-expressions represented by
   the variables FA, FB, ... FZ.  Values for those
   sub-expressions and constants which appear in the expression
   will be requested via the application's parameter of the same
   name.

   FORTRAN 77 syntax is used for specifying the expression, which
   may contain the usual intrinsic functions, plus a few extra
   ones.  An appendix in SUN/61 gives a full description of the
   syntax used and an up-to-date list of the functions available.
   The arithmetic operators (+,-,/,*,**) follow the normal order
   of precedence.  Using matching (nested) parentheses will
   explicitly define the order of expression evaluation.  The
   expression may be up to 132 characters long.
3 FA-FZ
FA-FZ = LITERAL (Read)
   These parameters supply the values of `sub-expressions' used
   in the expression EXP.  Any of the 26 may appear; there is no
   restriction on order.  These parameters should be used when
   repeated expressions are present in complex expressions, or to
   shorten the value of EXP to fit within the 132-character limit.
   Sub-expressions may contain references to other
   sub-expressions and constants (PA-PZ).  An example of using
   sub-expressions is:
      EXP > PA*ASIND(FA/PA)*X/FA
      FA > SQRT(X*X+Y*Y)
      PA > 10.1
   where the parameter name is to the left of > and its value is
   to the right of the >.
3 PA-PZ
PA-PZ = _DOUBLE (Read)
   These parameters supply the values of constants used in the
   expression EXP and sub-expressions FA-FZ.  Any of the 26 may
   appear; there is no restriction on order.  Using parameters
   allows the substitution of repeated constants using one
   reference.  This is especially convenient for constants with
   many significant digits.  It also allows easy modification of
   parameterised expressions provided the application has not
   been used with a different EXP in the interim.  The parameter
   PI has a default value of 3.14159265359D0.  An example of
   using parameters is:
      EXP > SQRT(PX*PX+PY*PY)*EXP(PX-PY)
      PX > 2.345
      PY > -0.987
   where the parameter name is to the left of > and its value is
   to the right of the >.
3 PREC
PREC = LITERAL (Read)
   The arithmetic precision with which the transformation
   functions will be evaluated when used.  This may be either
   "_REAL" for single precision, "_DOUBLE" for double precision,
   or "_INTEGER" for integer precision.  Elastic precisions are
   used, such that a higher precision will be used if the input
   data warrant it.  So for example if PREC = "_REAL", but
   double-precision data were to be transformed, double-precision
   arithmetic would actually be used.  The result is reported
   using the chosen precision.  ["_REAL"]
3 RESULT
RESULT = LITERAL (Write)
   The result of the evaluation.
2 Examples
The syntax in the following examples apply to the shell.

calc "27.3*1.26"
   The reports the value of the expression 27.3*1.26, i.e. 34.398.

calc exp="(pa+pb+pc+pd)/4.0" pa=$med1 pb=$med2 pc=$med3 pd=$med4
   This reports the average of four values defined by script
   variables med1, med2, med3, and med4.

calc "42.6*pi/180"
   This reports the value in radians of 42.6 degrees.

calc "(mod(PO,3)+1)/2" prec=_integer po=$count
   This reports the value of the expression "(mod($count,3)+1)/2)"
   where $count is the value of the shell variable count.  The
   calculation is performed in integer arithmetic, thus if
   count equals 2, the result is 1 not 1.5.

calc "sind(pa/fa)*fa" fa="log(abs(pb+pc))" pa=2.0e-4 pb=-1 pc=$x
   This evaluates sind(0.0002/log(abs($x-1)))*log(abs($x-1)) where
   $x is the value of the shell variable x.

For ICL usage only those expressions containing parentheses need

to be in quotes, though ICL itself provides the arithmetic.  So

the above examples would be

calc 27.3*1.26
   The reports the value of the expression 27.3*1.26, i.e. 34.398.

calc exp="(pa+pb+pc+pd)/4.0" pa=(med1) pb=(med2) pc=(med3)
     pd=(med4)
   This reports the average of four values defined by ICL
   variables med1, med2, med3, and med4.

calc 42.6*pi/180
   This reports the value in radians of 42.6 degrees.

calc "(mod(PO,3)+1)/2" prec=_integer po=(count)
   This reports the value of the expression "(mod(count,3)+1)/2)"
   where (count) is the value of the ICL variable count.  The
   calculation is performed in integer arithmetic, thus if
   count equals 2, the result is 1 not 1.5.

calc "sind(pa/fa)*fa" fa="log(abs(pb+pc))" pa=2.0e-4 pb=-1 pc=(x)
   This evaluates sind(0.0002/log(abs((x)-1)))*log(abs((x)-1)) where
   (x) is the value of the ICL variable x.
2 Related_Applications
   KAPPA: MATHS.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1995 August 14 (MJC):
    Original version.
2 Implementation_Status
   On OSF/1 systems an error during the calculation results in a
   core dump.  On Solaris, undefined values are set to one.  These
   are due to problems with the TRANSFORM infrastructure.
1 CALPOL
Calculates polarisation parameters.

Usage:

   calpol in1 in2 in3 in4 p theta i

Description:

   This routine calculates various parameters describing the
   polarisation described by four intensity arrays analysed at 0, 45,
   90, and 135 degrees to a reference direction.  Variance values are
   stored in the output NDFs if all the input NDFs have variances and
   you give a true value for parameter VARIANCE.

   By default, three output NDFs are created holding percentage
   polarisation, polarisation angle and total intensity. However,
   NDFs holding other quantities, such as the Stokes parameters, can
   also be produced by over-riding the default null values
   associated with the corresponding parameters.  The creation of any
   output NDF can be suppressed by supplying a null value for the
   corresponding parameter.

   There is an option to correct the calculated values of percentage
   polarisation and polarised intensity to take account of the
   statistical bias introduced by the asymmetric distribution of
   percentage polarisation (see parameter DEBIAS).  This correction
   subtracts the variance of the percentage polarisation from the
   squared percentage polarisation, and uses the square root of this
   as the corrected percentage polarisation.  The corresponding
   polarised intensity is then found by multiplying the corrected
   percentage polarisation by the total intensity.  Returned variance
   values take no account of this correction.
2 Parameters
For information on individual parameters, select from the list below:
3 DEBIAS
DEBIAS = _LOGICAL (Read)
   TRUE if a correction for statistical bias is to be made to
   percentage polarisation and polarised intensity.  This
   correction cannot be used if any of the input NDFs do not
   contain variance values, or if you supply a FALSE value
   for parameter VARIANCE. [FALSE]
3 I
I = NDF (Write)
   An output NDF holding the total intensity derived from all four
   input NDFs.
3 IN1
IN1 = NDF (Read)
   An NDF holding the measured intensity analysed at an angle of 0
   degrees to the reference direction.  The primary input NDF.
3 IN2
IN2 = NDF (Read)
   An NDF holding the measured intensity analysed at an angle of
   45 degrees to the reference direction.  The suggested default
   is the current value.
3 IN3
IN3 = NDF (Read)
   An NDF holding the measured intensity analysed at an angle of
   90 degrees to the reference direction.  The suggested default
   is the current value.
3 IN4
IN4 = NDF (Read)
   An NDF holding the measured intensity analysed at an angle of
   135 degrees to the reference direction.  The suggested default
   is the current value.
3 IA
IA = NDF (Write)
   An output NDF holding the total intensity derived from input
   NDFs IN1 and IN3. [!]
3 IB
IB = NDF (Write)
   An output NDF holding the total intensity derived from input
   NDFs IN2 and IN4. [!]
3 IP
IP = NDF (Write)
   An output NDF holding the polarised intensity. [!]
3 P
P = NDF (Write)
   An output NDF holding percentage polarisation.
3 Q
Q = NDF (Write)
   An output NDF holding the normalised Stokes parameter, Q. [!]
3 U
U = NDF (Write)
   An output NDF holding the normalised Stokes parameter, U. [!]
3 THETA
THETA = NDF (Write)
   An output NDF holding the polarisation angle in degrees.
3 VARIANCE
VARIANCE = _LOGICAL (Read)
   TRUE if output variances are to be calculated.  This parameter
   is only accessed if all input NDFs contain variances, otherwise
   no variances are generated.  [TRUE]
2 Examples
calpol m51_0 m51_45 m51_90 m51_135 m51_p m51_t m51_i ip=m51_ip
   This example produces NDFs holding percentage polarisation,
   polarisation angle, total intensity and polarised intensity,
   based on the four NDFs M51_0, m51_45, m51_90 and m51_135.

calpol m51_0 m51_45 m51_90 m51_135 m51_p m51_t m51_i ip=m51_ip

novariance
   As above except that variance arrays are not computed.

calpol m51_0 m51_45 m51_90 m51_135 m51_p m51_t m51_i ip=m51_ip
   As the first example except that there is a correction for
   statistical bias in the percentage polarisation and polarised
   intensity, assuming that all the input NDFs have a VARIANCE
   array.

calpol m51_0 m51_45 m51_90 m51_135 q=m51_q p=m51_p
   This example produces NDFs holding the Stokes Q and U
   parameters, again based on the four NDFs M51_0, m51_45, m51_90
   and m51_135.
2 Notes
-  A bad value will appear in the output data and variance arrays
when any of the four input data values is bad, or if the total
intensity in the pixel is not positive.  The output variance
values are also undefined when any of the four input variances is
bad or negative, or any computed variance is not positive, or
the percentage polarisation is not positive.

-  If the four input NDFs have different pixel-index bounds, then
they will be trimmed to match before being added.  An error will
result if they have no pixels in common.

-  The output NDFs are deleted if there is an error during the
formation of the polarisation parameters.

-  The output NDFs obtain their QUALITY, AXIS information, and
TITLE from the IN1 NDF.  The following labels and units are also
assigned:
   I       "Total Intensity"            UNITS of IN1
   IA      "Total Intensity"            UNITS of IN1
   IB      "Total Intensity"            UNITS of IN1
   IP      "Polarised Intensity"        UNITS of IN1
   P       "Percentage Polarisation"    "%"
   Q       "Stokes Q"                   ---
   U       "Stokes U"                   ---
   THETA   "Polarisation Angle"         "Degrees"
2 Related_Applications
   KAPPA: VECPLOT; IRCAMPACK: POLCAL, POLMAPC, POLMAPD, POLSKY,
   POLSMOOTH, POLZAP; TSP.
2 Authors
DSB: David Berry (STARLINK)

MJC: Malcolm J. Currie (STARLINK)
2 History
 23-SEP-1993 (DSB):
    Original version.

 1995 April 10 (MJC):
    Added Notes, Related Applications, Implementation Status,
    three examples, and headings in the commentary.  Corrected
    spelling, and other errors.  Used a modern-style variable
    declaration.  Usage and Examples to lowercase.  Made the
    parameter names consistent.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   VARIANCE, LABEL, TITLE, UNITS, WCS and HISTORY components of the
   input NDF and propagates all extensions.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.  Arithmetic
   is performed using single-precision floating point.
1 CDIV
Divides an NDF by a scalar.

Usage:

   cdiv in scalar out

Description:

   This application divides each pixel of an NDF by a scalar
   (constant) value to produce a new NDF.
2 Parameters
For information on individual parameters, select from the list below:
3 IN
IN = NDF (Read)
   Input NDF structure whose pixels are to be divided by a
   scalar.
3 OUT
OUT = NDF (Write)
   Output NDF structure.
3 SCALAR
SCALAR = _DOUBLE (Read)
   The value by which the NDF's pixels are to be divided.
3 TITLE
TITLE = LITERAL (Read)
   A title for the output NDF.  A null value will cause the title
   of the NDF supplied for parameter IN to be used instead.
   [!]
2 Examples
cdiv a 100.0 b
   Divides all the pixels in the NDF called a by the constant
   value 100.0 to produce a new NDF called b.

cdiv in=data1 out=data2 scalar=-38
   Divides all the pixels in the NDF called data1 by -38 to give
   data2.
2 Related_Applications
   KAPPA: ADD, CADD, CMULT, CSUB, DIV, MATHS, MULT, SUB.
2 Authors
RFWS: R.F. Warren-Smith (STARLINK)

MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 12-MAR-1991 (RFWS):
    Original version.

 1995 September 12 (MJC):
    Title inherited by default.  Usage and examples to lowercase.
    Added Related Applications.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   LABEL, TITLE, UNITS, HISTORY, WCS and VARIANCE components of an NDF
   data structure and propagates all extensions.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.  Arithmetic
   is carried out using the appropriate floating-point type, but the
   numeric type of the input pixels is preserved in the output NDF.
1 CENTROID
Finds the centroids of star-like features in an NDF.

Usage:

   centroid ndf [mode] init [search] [maxiter] [maxshift] [toler]

Description:

   This routine takes an NDF and returns the co-ordinates of the
   centroids of features in its data array given approximate initial
   co-ordinates.  A feature is a set of connected pixels which are
   above or below the surrounding background region.  For example, a
   feature could be a star or galaxy on the sky, although the
   applications is not restricted to 2-dimensional NDFs.

   Four methods are available for obtaining the initial positions,
   selected using parameter MODE:

   - From the parameter system (see parameter INIT).

   - Using a graphics cursor to indicate the feature in a previously
   displayed data array (see parameter DEVICE).

   - From a specified positions list (see parameter INCAT).

   - From a simple text file containing a list of co-ordinates (see
   parameter COIN).

   In the first two modes the application loops, asking for new
   feature co-ordinates until it is told to quit or encounters an error.

   The results may optionally be written to an output positions list
   which can be used to pass the positions on to another application
   (see parameter OUTCAT), or to a log file geared more towards human
   readers, including details of the input parameters (see parameter
   LOGFILE).

   The uncertainty in the centroid positions may be estimated if
   variance values are available within the supplied NDF (see
   parameter CERROR).
2 Parameters
For information on individual parameters, select from the list below:
3 CENTRE
CENTRE  = LITERAL (Write)
   The formatted co-ordinates of the last centroid position, in
   the current Frame of the NDF.
3 CERROR
CERROR = _LOGICAL (Read)
   If TRUE, errors in the centroided position will be calculated.
   The input NDF must contain a Variance component in order to
   compute errors. [FALSE]
3 COIN
COIN =  FILENAME (Read)
   Name of a text file containing the initial guesses at the
   co-ordinates of features to be centroided. Only accessed if
   parameter MODE is given the value "File". Each line should
   contain the formatted axis values for a single position, in the
   current Frame of the NDF. Axis values can be separated by
   spaces, tabs or commas. The file may contain comment lines
   with the first character # or !.
3 DESCRIBE
DESCRIBE = LOGICAL (Read)
   If TRUE, a detailed description of the co-ordinate Frame in which
   the centroided positions will be reported is displayed before the
   positions themselves. [current value]
3 DEVICE
DEVICE = DEVICE (Read)
   The graphics device which is to be used to give the initial
   guesses at the centroid positions. Only accessed if parameter
   MODE is given the value "Cursor". [Current graphics device]
3 ERROR
ERROR  =  LITERAL (Write)
   The errors associated with the position written to parameter
   CENTRE.
3 GUESS
GUESS = _LOGICAL (Read)
   If TRUE, then the supplied guesses for the centroid positions
   will be included in the screen and log file output, together
   with the accurate positions. [current value]
3 INCAT
INCAT = FILENAME (Read)
   A catalogue containing a positions list giving the initial
   guesses at the centroid positions, such as produced by
   applications CURSOR, LISTMAKE, etc. Only accessed if parameter
   MODE is given the value "Catalogue".
3 INIT
INIT  = LITERAL (Read)
   An initial guess at the co-ordinates of the next feature to be
   centroided, in the current co-ordinate Frame of the NDF (supplying
   a colon ":" will display details of the current co-ordinate Frame).
   The position should be supplied as a list of formatted axis values
   separated by spaces or commas. INIT is only accessed if parameter
   MODE is given the value "Interface". If the initial co-ordinates
   are supplied on the command line only one centroid will be found;
   otherwise the application will ask for further guesses, which may
   be terminated by supplying the null value (!).
3 LOGFILE
LOGFILE  =  FILENAME (Read)
   Name of the text file to log the results.  If null, there
   will be no logging.  Note this is intended for the human reader
   and is not intended for passing to other applications. [!]
3 MARK
MARK = LITERAL (Read)
   Only accessed if parameter MODE is given the value "Cursor". It
   indicates which positions are to be marked on the screen using the
   marker type given by parameter MARKER. It can take any of the
   following values:

   - "Initial": The position of the cursor when the mouse button is
   pressed is marked.

   - "Centroid": The corresponding centroid position is marked.

   - "None": No positions are marked.

   [current value]
3 MARKER
MARKER = INTEGER (Read)
   This parameter is only accessed if parameter MARK is set TRUE.
   It specifies the type of marker with which each cursor position
   should be marked, and should be given as an integer PGPLOT marker
   type. For instance, 0 gives a box, 1 gives a dot, 2 gives a cross,
   3 gives an asterisk, 7 gives a triangle. The value must be larger
   than or equal to -31. [current value]
3 MAXITER
MAXITER  =  _INTEGER (Read)
   Maximum number of iterations to be used in the search.  It must
   be in the range 1--9.  The dynamic default is 3. [9]
3 MAXSHIFT
MAXSHIFT()  =  _REAL (Read)
   Maximum shift in each dimension allowed between the guess and
   output positions in pixels.  Each must lie in the range
   0.0--26.0.  If only a single value is given, then it will be
   duplicated to all dimensions. The dynamic default is half of
   SEARCH + 1. [9.0]
3 MODE
MODE  =  LITERAL (Read)
   The mode in which the initial co-ordinates are to be obtained. The
   supplied string can be one of the following:

   - "Interface": positions are obtained using parameter INIT.

   - "Cursor": positions are obtained using the graphics cursor of
      the device specified by parameter DEVICE.

   - "Catalogue": positions are obtained from a positions list
      using parameter INCAT.

   -  "File": positions are obtained from a text file using parameter
      COIN. [current value]
3 NDF
NDF = NDF (Read)
   The NDF structure containing the data array to be analysed. In
   cursor mode (see parameter MODE), the run-time default is the
   displayed data, as recorded in the graphics database. In other
   modes, there is no run-time default and the user must supply a
   value. []
3 NSIM
NSIM =  _INTEGER (Read)
   The number of simulations or realisations using the variance
   information in order to estimate the error in the centroid
   position.  The uncertainty in the centroid error decreases
   as one over the square root of NSIM. The range of acceptable
   values is 3--10000. [100]
3 OUTCAT
OUTCAT = FILENAME (Write)
   The output catalogue in which to store the centroided positions.
   If a null value (!) is supplied, no output catalogue is produced.
   [!]
3 PLOTSTYLE
PLOTSTYLE = LITERAL (Read)
   A group of attribute settings describing the style to use when
   drawing the graphics markers specified by parameter MARK.

   A comma-separated list of strings should be given in which each
   string is either an attribute setting, or the name of a text file
   preceded by an up-arrow character "^". Such text files should
   contain further comma-separated lists which will be read and
   interpreted in the same manner. Attribute settings are applied in
   the order in which they occur within the list, with later settings
   over-riding any earlier settings given for the same attribute.

   Each individual attribute setting should be of the form:

      <name>=<value>

   where <name> is the name of a plotting attribute, and <value> is
   the value to assign to the attribute. Default values will be
   used for any unspecified attributes. All attributes will be
   defaulted if a null value (!) is supplied. See section "Plotting
   Attributes" in SUN/95 for a description of the available
   attributes. Any unrecognised attributes are ignored (no error is
   reported). [current value]
3 POSITIVE
POSITIVE  =  _LOGICAL (Read)
   TRUE, if array features are positive above the background. [TRUE]
3 QUIET
QUIET = LOGICAL (Read)
   If TRUE then the centroid positions are not displayed on the
   screen. Output parameters and files are still created. [FALSE]
3 SEARCH
SEARCH()  =  _INTEGER (Read)
   Size in pixels of the search box to be used. If only a single
   value is given, then it will be duplicated to all dimensions
   so that a square, cube or hypercube region is searched.
   Each value must be odd and lie in the range 3--51.  [9]
3 TITLE
TITLE =  LITERAL (Read)
   A title to store with the output catalogue specified by
   parameter OUTCAT, and to display before the centroid positions
   are listed. The run-time default is taken from any input
   catalogue specified by parameter INCAT, or is a fixed string
   including the name of the NDF. []
3 TOLER
TOLER  =  _REAL (Read)
   Accuracy in pixels required in centroiding.  Iterations will
   stop when the shift between successive centroid positions
   is less than the accuracy.  The accuracy must lie in the range
   0.0--2.0. [0.05]
3 XCEN
XCEN  =  LITERAL (Write)
   The formatted X co-ordinate of the last centroid position, in the
   current co-ordinate Frame of the NDF.
3 XERR
XERR =  LITERAL (Write)
   The error associated with the value written to parameter XCEN.
3 YCEN
YCEN  =  LITERAL (Write)
   The formatted Y co-ordinate of the last centroid position, in the
   current co-ordinate Frame of the NDF.
3 YERR
YERR =  LITERAL (Write)
   The error associated with the value written to parameter YCEN.
2 Examples
centroid cluster cu
   This finds the centroids in the NDF called cluster via the
   graphics cursor on the current graphics device.

centroid cluster cu search=21 mark=ce plotstyle='colour=red'
   This finds the centroids in the NDF called cluster via the
   graphics cursor on the current graphics device.  The search
   box for the centroid is 21 pixels in each dimension. The centroid
   positions are marked using a red symbol.

centroid cluster i '"21.7,5007.1"'
   This finds the centroid of the object in the 2-dimensional NDF
   called cluster around the current Frame co-ordinate (21.7,5007.1).

centroid arp244(6,,) i '"40,30"' toler=0.01
   This finds the 2-dimensional centroid of the feature near
   pixel (6,40,30) in the 3-dimensional NDF called arp244 (assuming
   the current co-ordinate Frame of the NDF is PIXEL). The centroid
   must be found to 0.01 pixels.

centroid cluster cu xcen=(xp) ycen=(yp)
   This finds the centroid of an object in the 2-dimensional NDF
   called cluster using a graphics cursor, and writes the centroid
   co-ordinates to ICL variables XP and YP for use in other applications.

centroid cluster mode=file coin=objects.dat logfile=centroids.log
   This finds the centroids in the NDF called cluster.  The
   initial positions are given in the text file objects.dat in
   the current co-ordinate Frame.  A log of the input parameter
   values, initial and centroid positions is written to the text
   file centroids.log.

centroid cluster mode=cat incat=a outcat=b
   This example reads the initial guess positions from the
   positions list in file a.FIT, and writes the accurate centroid
   positions to positions list file b.FIT. The input file may, for
   instance, have been created using the application CURSOR.
2 Notes
-  All positions are supplied and reported in the current co-ordinate
Frame of the NDF. A description of the co-ordinate Frame being used
is given if parameter DESCRIBE is set to a TRUE value. Application
WCSFRAME can be used to change the current co-ordinate Frame of the
NDF before running this application if required.

-  In Cursor or Interface mode, only the first 200 supplied positions
will be stored in the output catalogue. Any further positions will be
displayed on the screen but not stored in the output catalogue.
2 Estimation_of_Centroid_Positions
   Each centroid position is obtained by projecting the data values
   within a search box centred on the supplied position, on to each
   axis in turn. This forms a set of profiles for the feature, one for
   each axis. An estimate of the background at each point in these
   profiles is made and subtracted from the profile. This flattens the
   profile backgrounds, removing any slope in the data. Once the
   profiles have been flattened in this way, and estimate of the
   background noise in each is made. The centroid of the feature is
   then found using only the data above the noise level.

   Successive estimates of the centroid position are made by using the
   previous estimate of the centroid as the initial position for
   another estimation. This loop is repeated up to a maximum number of
   iterations, though it normally terminates when a desired accuracy
   has been achieved.

   The achieved accuracy is affected by noise, and the presence of
   non-Gaussian or overlapping features, but typically an accuracy
   better than 0.1 pixel is readily attainable for stars. The error in
   the centroid position may be estimated by a Monte-Carlo method
   using the data variance to generate realisations of the data about
   the feature (see parameter CERROR).  Each realisation is processed
   identically to the actual data, and statistics are formed to derive
   the standard deviations.
2 Related_Applications
   KAPPA: PSF, CURSOR, LISTSHOW, LISTMAKE.
2 Authors
MJC: Malcolm J. Currie  (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 1991 March 24 (MJC):
    Original NDF version based on the pre-0.8 version.

 1991 July 12 (MJC):
    Added COOUT file.

 1992 March 3 (MJC):
    Replaced AIF parameter-system calls by the extended PAR
    library.

 1992 April 14 (MJC):
    Handles arbitrary user-defined sections.

 1992 November 30 (MJC):
    Does not use non-monotonic axis centres.

 5-JUN-1998 (DSB):
    Report an error if an even value is supplied for SEARCH.

 25-JUN-1999 (DSB):
    Many major changes to make use of AST/PGPLOT.
2 Implementation_Status
   -  The processing of bad pixels and all non-complex numeric types
   is supported.
1 CHAIN
Concatenates a series of vectorized NDFs.

Usage:

   chain in c1 [c2] [c3] ... [c25] out=?

Description:

   This application concatenates a series of NDFs, in the order
   supplied and treated as vectors, to form a 1-dimensional output
   NDF.  The dimensions of the NDFs may be different, and indeed so
   may their dimensionalities.
2 Parameters
For information on individual parameters, select from the list below:
3 IN
IN = NDF (Read)
   The base NDF after which the other input NDFs will be
   concatenated.
3 OUT
OUT = NDF (Write)
   The one-dimensional NDF resulting from concatenating the input
   NDFs.
3 C1-C25
C1-C25 = NDF (Read)
   The NDFs to be concatenated to the base NDF.  The NDFs are
   joined in the order C1, C2, ... C25.  There can be no missing
   NDFs, e.g. in order for C3 to be processed there must be a C2
   given as well.   A null value (!) indicates that there is no
   NDF.  NDFs C2 to C25 are defaulted to !.  At least one NDF
   must be pasted, therefore C1 may not be null.
3 TITLE
TITLE = LITERAL (Read)
   Title for the output NDF structure.  A null value (!)
   propagates the title from the base NDF to the output NDF. [!]
2 Examples
chain obs1 obs2 out=stream
   This concatenates the NDF called obs2 on to the arrays in the
   NDF called obs1 to produce the 1-dimensional NDF stream.

chain c1=obs2 c2=obs1 in=obs3 out=stream
   This concatenates the NDF called obs2 on to the arrays in the
   NDF called obs3, and then concatenates the arrays from obs1
   to them to produce the 1-dimensional NDF stream.
2 Related_Applications
   KAPPA: PASTE, RESHAPE.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1997 June 14 (MJC):
    Original version.
2 Implementation_Status
   -  This routine correctly processes the DATA, QUALITY,
   VARIANCE, LABEL, TITLE, UNITS, and HISTORY, components of an NDF
   data structure and propagates all extensions.  Propagation is from
   the base NDF.  WCS and AXIS information is lost.

   -  All non-complex numeric data types can be handled.

   -  Any number of NDF dimensions is supported.

1 CHPIX
Replaces the values of selected pixels in an NDF.

Usage:

   chpix in out section newval [comp]

Description:

   This application replaces selected elements of an NDF array
   component with specified values.  The task loops until there are
   no more elements to change, indicated by a null value in response
   to a prompt.  For non-interactive processing, supply the value of
   parameter NEWVAL on the command line.
2 Parameters
For information on individual parameters, select from the list below:
3 COMP
COMP = LITERAL (Read)
   The name of the NDF array component to be modified.  The
   options are: "Data", "Error", "Quality" or "Variance".
   "Error" is the alternative to "Variance" and causes the
   square of the supplied replacement value to be stored in the
   output VARIANCE array.
3 IN
IN = NDF (Read)
   NDF structure containing the array component to be modified.
3 NEWVAL
NEWVAL = LITERAL (Read)
   Value to substitute in the output array element or elements.
   The range of allowed values depends on the data type of the
   array being modified.  NEWVAL="Bad" instructs that the bad
   value appropriate for the array data type be substituted.
   Placing NEWVAL on the command line permits only one section
   to be replaced.  If there are multiple replacements, a null
   value (!) terminates the loop.
3 OUT
OUT = NDF (Write)
   Output NDF structure containing the modified version of
   the array component.
3 SECTION
SECTION = LITERAL (Read)
   The elements to change.  This is defined as an NDF section, so
   that ranges can be defined along any axis, and be given as
   pixel indices or axis (data) co-ordinates.  So for example
   "3,4,5" would select the pixel at (3,4,5); "3:5," would
   replace all elements in columns 3 to 5; ",4" replaces line 4.
   See "NDF sections" in SUN/95, or the online documentation for
   details.  A null value (!) terminates the loop during multiple
   replacements.
3 TITLE
TITLE = LITERAL (Read)
   Title for the output NDF structure.  A null value (!)
   propagates the title from the input NDF to the output NDF. [!]
2 Examples
chpix rawspec spectrum 55 100
   Assigns the value 100 to the pixel at index 55 within the
   one-dimensional NDF called rawspec, creating the output NDF
   called spectrum.

chpix rawspec spectrum 10:19 0 error
   Assigns the value 0 to the error values at indices 10 to 19
   within the one-dimensional NDF called rawspec, creating the
   output NDF called spectrum.  The rawspec dataset must have a
   variance compoenent.

chpix in=rawimage out=galaxy section="~20,100:109" newval=bad
   Assigns the bad value to the pixels in the section ~20,100:109
   within the two-dimensional NDF called rawimage, creating the
   output NDF called galaxy.  This section is the central
   20 pixels along the first axis, and pixels 110 to 199 along the
   second.

chpix in=zzcha out=zzcha_c section="45,21," newval=-1
   Assigns value -1 to the pixels at index (45,21) within all
   planes of the three-dimensional NDF called zzcha, creating
   the output NDF called zzcha_c.
2 Related_Applications
   KAPPA: ARDMASK, FILLBAD, GLITCH, NOMAGIC, SEGMENT, SETMAGIC
   SUBSTITUTE, ZAPLIN; Figaro: CSET, ICSET, NCSET, TIPPEX.
2 Authors
MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 1995 April 25 (MJC):
    Original NDF version.

 27-FEB-1998 (DSB):
    Use NUM_ functions to convert lower precision integer values to
    _INTEGER when calling PAR_MIX0I.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.

2 Implementation_Status
   -  The routine correctly processes the AXIS, DATA, QUALITY, LABEL,
   TITLE, UNITS, HISTORY, WCS and VARIANCE components of an NDF; and
   propagates all extensions.  Bad pixels and all non-complex
   numeric data types can be handled.

   -  The HISTORY component, if present, is simply propagated without
   change.
1 Classified_commands
KAPPA applications may be classified in terms of their functions as 
follows:


2 Data_import_&_export

3 Image_generation_and_input
CREFRAME    - Generates a test 2-d data array from a selection of
              several types.
FITSDIN     - Reads a FITS disc file composed of simple, group or table
              objects.
FITSHEAD    - Lists the headers of FITS files.
FITSIMP     - Imports FITS information into an NDF extension.
FITSIN      - Reads a FITS tape composed of simple, group or table
              files.
MATHS       - Evaluates mathematical expressions applied to NDF data
              structures.
TRANDAT     - Converts free-format data into an NDF.

3 Preparation_for_output
FITSEDIT    - Edits the FITS extension of an NDF.
FITSEXP     - Exports NDF-extension information into an NDF FITS
              extension.
FITSMOD     - Edits an NDF FITS extension via a text file or parameters.
FITSTEXT    - Creates an NDF FITS extension from a text file.
FITSWRITE   - Writes a new keyword to the FITS extension.

2 Data_display

3 Detail_enhancement
HISTEQ      - Performs an histogram equalisation on an NDF.
LAPLACE     - Performs a Laplacian convolution as an edge detector in a
              2-d data array.
SHADOW      - Enhances edges in a 2-dimensional NDF using a shadow
              effect.
THRESH      - Edits an NDF such that array values below and above two
              thresholds take constant values.

3 Device_selection
GDNAMES     - Shows which graphics devices are available.
GDSET       - Selects a current graphics device.
IDSET       - Selects a current image-display device.
OVSET       - Selects a current image-display overlay.

3 Display_control
CURSOR      - Reports the co-ordinates of points selected using the
              cursor.
GDCLEAR     - Clears a graphics device and purges its database entries.
GDSTATE     - Shows the current status of a graphics device.
IDCLEAR     - Clears an image display and purges its database entries.
IDINVISIBLE - Makes memory planes of an image-display device invisible.
IDPAZO      - Pans and zooms an image-display device.
IDSTATE     - Shows the current status of an image display.
OVCLEAR     - Clears an image-display overlay.

3 Graphics_database
PICBASE     - Selects the BASE picture from the graphics database.
PICCUR      - Uses a cursor to select the current picture and to report
              the co-ordinates of points.
PICDATA     - Selects the last DATA picture from the graphics database.
PICDEF      - Defines a new graphics-database FRAME picture or an array
              of FRAME pictures.
PICEMPTY    - Finds the first empty FRAME picture in the graphics
              database.
PICENTIRE   - Finds the first unobscured and unobscuring FRAME picture
              in the graphics database.
PICFRAME    - Selects the last FRAME picture from the graphics database.
PICGRID     - Creates an array of FRAME pictures.
PICIN       - Finds the attributes of a picture interior to the current
              picture.
PICLABEL    - Labels the current graphics-database picture.
PICLAST     - Selects the last picture from the graphics database.
PICLIST     - Lists the pictures in the graphics database for a device.
PICSEL      - Selects a graphics-database picture by its label.
PICTRANS    - Transforms co-ordinates between the current and BASE
              pictures.
PICVIS      - Finds the first unobscured FRAME picture in the graphics
              database.
PICXY       - Creates a new picture defined by co-ordinate bounds.

3 Lookup/colour_tables
CRELUT      - Creates or manipulates an image-display lookup table using
              a palette.
LUTABLE     - Manipulates an image-display colour table.
LUTBGYRW    - Loads the BGYRW  lookup table.
LUTCOL      - Loads the standard colour lookup table.
LUTCONT     - Loads a lookup table to give the display the appearance of
              a contour plot.
LUTFC       - Loads the standard false-colour lookup table.
LUTFLIP     - Flips the colour table of an image-display device.
LUTGREY     - Loads the standard greyscale lookup table.
LUTHEAT     - Loads the heat  lookup table.
LUTHILITE   - Highlights a colour table of an image-display device.
LUTIKON     - Loads the default Ikon  lookup table.
LUTNEG      - Loads the standard negative greyscale lookup table.
LUTRAMPS    - Loads the coloured-ramps lookup table.
LUTREAD     - Loads an image-display lookup table from an NDF.
LUTROT      - Rotates the colour table of an image-display device.
LUTSAVE     - Saves the current colour table of an image-display device
              in an NDF.
LUTSPEC     - Loads a spectrum-like lookup table.
LUTTWEAK    - Tweaks a colour table of an image-display device.
LUTVIEW     - Draws a colour-table key.
LUTWARM     - Loads the warm lookup table.
LUTZEBRA    - Loads a pseudo-contour lookup table.

3 Output
ARDPLOT     - Draws outlines of regions described in an ARD file.
CONTOUR     - Contours a 2-d NDF.
DISPLAY     - Displays a 1-d or 2-d NDF.
DRAWSIG     - Draws n standard-deviation lines on a line plot.
ELPROF      - Creates a radial or azimuthal profile of a 2-dimensional
              image.
LINPLOT     - Draws a line plot of the data values in a 1-d NDF.
LISTSHOW    - Displays the positions stored in a positions list.
LOOK        - Outputs the values of a sub-array of a 2-d data array to
              the screen or a text file.
MLINPLOT    - Draws a multi-line plot of a 2-d NDF's data values against
              their axis co-ordinates.
SCATTER     - Displays a scatter plot between data in 2 n-dimensional NDFs.
VECPLOT     - Plots a 2-dimensional vector map.

3 Palette
PALDEF      - Loads the default palette to a colour table.
PALENTRY    - Enters a colour into an image display's palette.
PALREAD     - Fills the palette of a colour table from an NDF.
PALSAVE     - Saves the current palette of a colour table to an NDF.

2 Data_manipulation

3 Arithmetic
ADD         - Adds two NDF data structures.
CADD        - Adds a scalar to an NDF data structure.
CDIV        - Divides an NDF by a scalar.
CMULT       - Multiplies an NDF by a scalar.
CSUB        - Subtracts a scalar from an NDF data structure.
DIV         - Divides one NDF data structure by another.
EXP10       - Takes the base-10 exponential of each pixel of an NDF.
EXPE        - Takes the exponential of each pixel of an NDF (base e).
EXPON       - Takes the exponential of each pixel of a NDF (specified base).
LOG10       - Takes the base-10 logarithm of each pixel of an NDF.
LOGAR       - Takes the logarithm of each pixel of an NDF (specified base).
LOGE        - Takes the natural logarithm of each pixel of an NDF. 
MATHS       - Evaluates mathematical expressions applied to NDF data
              structures.
MULT        - Multiplies two NDF data structures.
POW         - Takes the specified power of each pixel of a data array.
SUB         - Subtracts one NDF data structure from another.
TRIG        - Performs a trigonometric transformation on a data array.

3 Combination
CALPOL      - Calculates polarisation parameters.
KSTEST      - Compares data sets using the Kolmogorov-Smirnov test.
NORMALIZE   - Normalises one NDF to a similar NDF by calculating a scale
              factor and zero difference.

3 Compression_and_expansion
COLLAPSE    - Reduce the number of axes in an NDF by collapsing it along
              a nominated axis.
COMPADD     - Reduces the size of an NDF by adding values in rectangular
              boxes.
COMPAVE     - Reduces the size of an NDF by averaging values in
              rectangular boxes.
COMPICK     - Reduces the size of an NDF by picking equally spaced
              pixels.
PIXDUPE     - Expands an NDF by pixel duplication.
SQORST      - Squashes or stretches a 2-d data array in either or both
              axes.
TRANSFORMER - Applies a transformation to an NDF.
WCSALIGN    - Aligns a group of 2-d NDFs using WCS information.

3 Configuration_change
CHAIN       - Concatenates a series of vectorized NDFs.
FLIP        - Reverses an NDF's pixels along a specified dimension.
MANIC       - Converts all or part of a data array from one
              dimensionality to another.
NDFCOPY     - Copies an NDF (or NDF section) to a new location.
PERMAXES    - Permute the axes of an NDF
PROFILE     - Creates a 1-d profile through an N-d NDF.
RESHAPE     - Reshapes an NDF, treating its arrays as vectors.
ROTATE      - Rotates a 2-dimensional NDF about its centre through any
              angle.
SETBOUND    - Sets new bounds for an NDF.
SLIDE       - Realigns a 2-d data array via an x-y shift.

3 Filtering
BLOCK       - Smooths a 1- or 2-dimensional image using a square or
              rectangular box filter.
CONVOLVE    - Convolves a pair of 1- or 2-dimensional NDFs together.
FFCLEAN     - Removes defects from a substantially flat 1- or
              2-dimensional NDF.
FOURIER     - Performs forward and inverse Fourier transforms of 1- or
              2-dimensional NDFs.
GAUSMOOTH   - Smooths a 1- or 2-dimensional image using a Gaussian
              filter.
LUCY        - Performs a Richardson-Lucy deconvolution of a 1- or
              2-dimensional array.
MEDIAN      - Smooths a 2-dimensional data array using a weighted median
              filter.
MEM2D       - Performs a Maximum-Entropy deconvolution of a
              2-dimensional NDF.
WIENER      - Applies a Wiener filter to a 1- or 2-dimensional array.

3 HDS_components
ERASE       - Erases an HDS object.
NATIVE      - Converts an HDS object to native machine data
              representation.

3 NDF_array_components
NDFCOPY     - Copies an NDF (or NDF section) to a new location.
PERMAXES    - Permute the axes of an NDF
SETBAD      - Sets new bad-pixel flag values for an NDF.
SETBB       - Sets a new value for the quality bad-bits mask of an NDF.
SETBOUND    - Sets new bounds for an NDF.
SETTYPE     - Sets a new numeric type for the data and variance
              components of an NDF.
SETVAR      - Sets new values for the variance component of an NDF data
              structure.

3 NDF_axis_components
AXCONV      - Expands spaced axes in an NDF into the primitive form.
AXLABEL     - Sets a new label value for an axis within an NDF data
              structure.
AXUNITS     - Sets a new units value for an axis within an NDF data
              structure.
PERMAXES    - Permute the axes of an NDF
SETAXIS     - Sets values for an axis array component within an NDF data
              structure.
SETNORM     - Sets a new value for one or all of an NDF's
              axis-normalisation flags.

3 NDF_character_components
SETLABEL    - Sets a new label for an NDF data structure.
SETTITLE    - Sets a new title for an NDF data structure.
SETUNITS    - Sets a new units value for an NDF data structure.

3 NDF_extensions
FITSEDIT    - Edits the FITS extension of an NDF.
FITSEXIST   - Inquires whether or not a keyword exists in a FITS
              extension.
FITSEXP     - Exports NDF-extension information into an NDF FITS
              extension.
FITSLIST    - Lists the FITS extension of an NDF.
FITSMOD     - Edits an NDF FITS extension via a text file or parameters.
FITSTEXT    - Creates an NDF FITS extension from a text file.
FITSVAL     - Reports the value of a keyword in the FITS extension.
FITSWRITE   - Writes a new keyword to the FITS extension.
SETEXT      - Manipulates the contents of a specified NDF extension.
SETSKY      - Makes an IRAS astrometry extension.

3 NDF_history
HISCOM      - Adds commentary to the history of an NDF.
HISLIST     - Lists NDF history records.
HISSET      - Sets the NDF history update mode.

3 NDF_world_coordinate_systems
PERMAXES    - Permute the axes of an NDF
WCSADD      - Adds a new co-ordinate Frame into the WCS component of an
              NDF.
WCSALIGN    - Aligns a group of 2-d NDFs using WCS information.
WCSATTRIB   - Manages attribute values associated with the WCS component
              of an NDF.
WCSCOPY     - Copies WCS information from one NDF to another.
WCSFRAME    - Changes the current co-ordinate Frame in the WCS component
              of an NDF.
WCSREMOVE   - Removes co-ordinate Frames from the WCS component of an
              NDF.
WCSTRAN     - Transforms a position from one NDF co-ordinate Frame to
              another.

3 Pixel_editing_and_masking
ARDGEN      - Creates a text file describing selected regions of an
              image.
ARDMASK     - Uses an ARD file to set some pixels of an NDF to be bad.
ARDPLOT     - Draws outlines of regions described in an ARD file.
CHPIX       - Replaces the values of selected pixels in an NDF.
COPYBAD     - Copies the bad pixel mask from one NDF to another.
ERRCLIP     - Removes pixels with large errors from an NDF.
FFCLEAN     - Removes defects from a substantially flat 1- or
              2-dimensional NDF.
FILLBAD     - Removes regions of bad values from a 2-dimensional NDF.
GLITCH      - Replaces bad pixels in a 2-dimensional NDF with the local
              median.
NOMAGIC     - Replaces all occurrences of magic value pixels in an NDF
              array with a new value.
OUTSET      - Sets pixels outside a specified circle in a 2-d data array
              to a specified value.
PASTE       - Pastes a series of NDFs upon each other.
RIFT        - Adds a scalar to a section of an NDF data structure to
              correct rift-valley defects.
SEGMENT     - Copies polygonal segments from one NDF to another.
SETMAGIC    - Replaces all occurrences of a given value in an NDF array
              with the bad value.
SUBSTITUTE  - Replaces all occurrences of a given value in an NDF array
              with another value.
ZAPLIN      - Replaces regions in a 2-d NDF by bad values or by linear
              interpolation.

3 Polarimetry
CALPOL      - Calculates polarisation parameters.

3 Resampling_and_transformations
TRANINVERT  - Inverts a transformation.
TRANJOIN    - Joins two transformations.
TRANMAKE    - Makes a transformation structure given its co-ordinate
              mappings.
TRANSFORMER - Applies a transformation to an NDF.
TRANTRACE   - Lists the contents of a transformation structure.
WCSALIGN    - Aligns a group of 2-d NDFs using WCS information.

3 Surface_fitting
FITSURFACE  - FITS a polynomial surface to 2-dimensional data array.
MAKESURFACE - Creates a 2-dimensional NDF from the coefficients of a
              polynomial surface.
SURFIT      - FITS a polynomial or spline surface to a 2-d data array
              using blocking.

2 Data_analysis

3 Statistics
APERADD     - Derives statistics of pixels within a specified circle of
              a 2-d data array.
HISTAT      - Computes ordered statistics for an NDF's pixels using an
              histogram.
HISTOGRAM   - Computes an histogram of an NDF's values.
MSTATS      - Does cumulative statistics on a 2-d sub-array over a
              sequence of data arrays.
NUMB        - Counts the number of elements of an NDF with values or
              absolute values above or below a threshold.
STATS       - Computes simple statistics for an NDF's pixels.

3 Other
CENTROID    - Finds the centroids of star-like features in an NDF.
NORMALIZE   - Normalises one NDF to a similar NDF by calculating a scale
              factor and zero-point difference.
PSF         - Determines the parameters of a model star profile by
              fitting star images in a two-dimensional NDF.
SURFIT      - FITS a polynomial or spline surface to a 2-d data array.

2 Scripting_tools
CALC        - Evaluates a mathematical expression.
PARGET      - Obtains the value or values of an application parameter.

2 Inquiries_&_status
GLOBALS     - Displays the values of the KAPPA global parameters.
FITSEXIST   - Inquires whether or not a keyword exists in a FITS
              extension.
FITSLIST    - Lists the FITS extension of an NDF.
FITSVAL     - Reports the value of a keyword in the FITS extension.
NDFTRACE    - Displays the attributes of an NDF data structure.
NOGLOBALS   - Resets the KAPPA global parameters.

2 Miscellaneous
KAPHELP     - Gives help about KAPPA.
LISTMAKE    - Create a catalogue holding a positions list.

1 CMULT
Multiplies an NDF by a scalar.

Usage:

   cmult in scalar out

Description:

   This application multiplies each pixel of an NDF by a scalar
   (constant) value to produce a new NDF.
2 Parameters
For information on individual parameters, select from the list below:
3 IN
IN = NDF (Read)
   Input NDF structure whose pixels are to be multiplied by a
   scalar.
3 OUT
OUT = NDF (Write)
   Output NDF structure.
3 SCALAR
SCALAR = _DOUBLE (Read)
   The value by which the NDF's pixels are to be multiplied.
3 TITLE
TITLE = LITERAL (Read)
   A title for the output NDF.  A null value will cause the title
   of the NDF supplied for parameter IN to be used instead.
   [!]
2 Examples
cmult a 12.5 b
   Multiplies all the pixels in the NDF called a by the constant
   value 12.5 to produce a new NDF called b.

cmult in=rawdata out=newdata scalar=-19
   Multiplies all the pixels in the NDF called rawdata by -19 to
   give newdata.
2 Related_Applications
   KAPPA: ADD, CADD, CDIV, CSUB, DIV, MATHS, MULT, SUB.
2 Authors
RFWS: R.F. Warren-Smith (STARLINK)

MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 17-APR-1990 (RFWS):
    Original version.

 11-MAR-1991 (RFWS):
    Finished writing the new prologue and fixed a minor typo in
    the code.

 1995 September 12 (MJC):
    Title inherited by default.  Usage and examples to lowercase.
    Added Related Applications.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   LABEL, TITLE, UNITS, HISTORY, WCS and VARIANCE components of an NDF
   data structure and propagates all extensions.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.  Arithmetic
   is carried out using the appropriate floating-point type, but the
   numeric type of the input pixels is preserved in the output NDF.
1 COLCOMP
Produces a colour composite of up to three 2-dimensional NDFs.

Usage:

   colcomp inr ing inb out lut device

Description:

   This application combines up to three 2-dimensional NDFs, using a
   different primary colour (red, green or blue) to represent each NDF.
   The resulting colour composite image is available in two forms; as an
   NDF with an associated colour table (see parameters OUT and LUT), and
   as an ASCII PPM image file (see parameter PPM). The full pixel
   resolution of the input NDFs is retained. Note, this application
   does not actually display the image, it just creates various output
   files which must be displayed using other tools (see below).

   The data values in each of the input NDFs which are to be mapped onto
   zero intensity and full intensity can be given manually using
   parameters RLOW, RHIGH, GLOW, GHIGH, BLOW and BHIGH, but by default
   they are evaluated automatically. This is done by finding specified
   percentile points within the data histograms of each of the input
   images (see parameter PERCENTILES).

   The NDF outputs are intended to be displayed with KAPPA application
   DISPLAY, using the command:

      display <out> scale=no lut=<lut>

   where "<out>" and "<lut>" are the names of the NDF image and colour
   table created by this application using parameters OUT and LUT. The
   main advantage of this NDF form of output over the PPM form is that
   any WCS or AXIS information in the input NDFs is still available, and
   can be used to create axis annotations by the DISPLAY command. The
   graphics device which will be used to display the image must be
   specified when running this application (see parameter DEVICE).

   The PPM form of output can be displayed using tools such as "xv", or
   converted into other forms (GIF or JPEG, for instance) using tools
   such as "ppmtogif" and "cjpeg" from the NetPbm or PbmPlus packages.
   These tools provide more sophisticated colour quantisation methods
   than are used by this application when creating the NDF outputs, and
   so may give better visual results.
2 Parameters
For information on individual parameters, select from the list below:
3 BADCOL
BADCOL = LITERAL (Read)
   The colour with which to mark any bad (i.e. missing) pixels in the
   display.  There are a number of options described below:

   - "MAX" -- The maximum colour index used for the display of the image.

   - "MIN" -- The minimum colour index used for the display of the image.

   - An integer -- The actual colour index.  It is constrained between
   0 and the maximum colour index available on the device.

   - A named colour -- Uses the named colour from the palette, and if it
   is not present, the nearest colour from the palette is selected.

   If the colour is to remain unaltered as the lookup table is
   manipulated choose an integer between 0 and 15, or a named
   colour.  Note, if only the PPM output is to be created (see
   parameter PPM), then a named colour must be given for BADCOL.
   [current value]
3 BHIGH
BHIGH = _DOUBLE (Read)
   The data value corresponding to full blue intensity. If a null
   (!) value is supplied, the value actually used will be determined
   by forming a histogram of the data values in the NDF specified by
   parameter INB, and finding the data value at the second histogram
   percentile specified by parameter PERCENTILES. [!]
3 BLOW
BLOW = _DOUBLE (Read)
   The data value corresponding to zero blue intensity. If a null
   (!) value is supplied, the value actually used will be determined
   by forming a histogram of the data values in the NDF specified by
   parameter INB, and finding the data value at the first histogram
   percentile specified by parameter PERCENTILES. [!]
3 DEVICE
DEVICE = DEVICE (Read)
   The name of the graphics device which will be used to display
   the NDF output (see parameter OUT). This is needed only to
   determine the number of available colours. No graphics output
   is created by this application. This parameter is not accessed
   if a null (!) value is supplied for parameter OUT. The device
   must have at least 24 colour indices or greyscale intensities.
   [current image-display device]
3 GHIGH
GHIGH = _DOUBLE (Read)
   The data value corresponding to full green intensity. If a null
   (!) value is supplied, the value actually used will be determined
   by forming a histogram of the data values in the NDF specified by
   parameter ING, and finding the data value at the second histogram
   percentile specified by parameter PERCENTILES. [!]
3 GLOW
GLOW = _DOUBLE (Read)
   The data value corresponding to zero green intensity. If a null
   (!) value is supplied, the value actually used will be determined
   by forming a histogram of the data values in the NDF specified by
   parameter ING, and finding the data value at the first histogram
   percentile specified by parameter PERCENTILES. [!]
3 INB
INB = NDF (Read)
   The input NDF containing the data to be displayed in blue. A null
   (!) value may be supplied in which case the blue intensity in the
   output will be zero at every pixel.
3 ING
ING = NDF (Read)
   The input NDF containing the data to be displayed in green. A null
   (!) value may be supplied in which case the green intensity in the
   output will be zero at every pixel.
3 INR
INR = NDF (Read)
   The input NDF containing the data to be displayed in red. A null
   (!) value may be supplied in which case the red intensity in the
   output will be zero at every pixel.
3 LUT
LUT = NDF (Write)
   Name of the output NDF to contain the colour lookup table which
   should be used when displaying the NDF created using parameter OUT.
   This colour table can be loaded using LUTREAD, or specified when
   the image is displayed. This parameter is not accessed if a null
   (!) value is given for parameter OUT.
3 RHIGH
RHIGH = _DOUBLE (Read)
   The data value corresponding to full red intensity. If a null
   (!) value is supplied, the value actually used will be determined
   by forming a histogram of the data values in the NDF specified by
   parameter INR, and finding the data value at the second histogram
   percentile specified by parameter PERCENTILES. [!]
3 RLOW
RLOW = _DOUBLE (Read)
   The data value corresponding to zero red intensity. If a null
   (!) value is supplied, the value actually used will be determined
   by forming a histogram of the data values in the NDF specified by
   parameter INR, and finding the data value at the first histogram
   percentile specified by parameter PERCENTILES. [!]
3 OUT
OUT = NDF (Write)
   The output colour composite image in NDF format. Values in
   this output image are integer colour indices into the colour
   table created using parameter LUT. The values are shifted to
   account for the indices reserved for the palette (i.e. the first
   entry in the colour table is addressed as entry 16, not entry 1).
   The NDF is intended to be used as the input data in conjunction with
   DISPLAY SCALE=FALSE. If a null value (!) is supplied, no output NDF
   will be created.
3 PERCENTILES
PERCENTILES( 2 ) = _REAL (Read)
   The percentiles that define the default scaling limits. For example,
   [25,75] would scale between the quartile values. [5,95]
3 PPM
PPM = FILE (Write)
   The name of the output text file to contain the PPM form of the
   colour composite image. The colours specified in this file
   represent the input data values directly. They are not quantised or
   dithered in any way. Also note that because this is a text file,
   containing formatted data values, it is portable, but can be
   very large, and slow to read and write. If a null (!) value is
   supplied, no PPM output is created. [!]
2 Examples
colcomp m31_r m31_g m31_b m31_col m31_lut
   Combines the 3 NDFs m31_r, m31_g, and m31_b to create a colour
   composite image stored in NDF m31_col. A colour look up table is
   also created and stored in NDF m31_lut. It is assumed that the
   output image will be displayed on the current graphics device.
   The created colour composite image should be dislayed using the
   command:

      display m31_col scale=no lut=m31_lut

colcomp m31_r m31_g m31_b out=\! ppm=m31.ppm
   As above, but no NDF outputs are created. Instead, a file called
   m31.ppm is created which (for instance) can be displayed using
   the command:

      xv m31.ppm

   It can be converted to a GIF (for instance, for inclusion in
   WWW pages) using the command:

      ppmquant 256 m31.ppm | ppmtogif > m31.gif

   These commands assume you have "xv", "ppmquant" and "ppmtogif"
   installed at your site. None of them command are part of KAPPA.
2 Notes
-  The output image (PPM or NDF) covers the area of overlap between
the input NDFs at full resolution.

-  The output image is based on the values in the DATA components
of the input NDFs. Any VARIANCE and QUALITY arrays in the input NDFs
are ignored.
2 Related_Applications
   KAPPA: DISPLAY, LUTREAD; XV; PBMPLUS; NETPBM.
2 Authors
DSB: David S. Berry (STARLINK)
2 History
 25-NOV-1999 (DSB):
    Original version.
2 Implementation_Status
   -  The HISTORY, WCS and AXIS components, together with any extensions
   are propagated to the output NDF, from the first supplied input NDF.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  Only data of type _REAL can be processed directly. Data of other
   types will be converted to _REAL before being processed.
1 Co-ordinate_Systems

     KAPPA is currently undergoing major changes in the way
     it handles co-ordinate information. The new system uses
     the WCS (World Co-ordinate System) component of the NDF
     structure to allow access to a much wider range of
     co-ordinate systems than has previously been available.
     For this reason, you will find some inconsistencies in
     the way co-ordinate information is handled by different
     applications. This situation will be rectified once all
     applications have been modified to use the WCS
     component. Until then, please pay particular attention
     to the descriptions of the co-ordinate handling
     facilities of each application you use.

     The new (converted) applications are identified by the
     fact that their descriptions in this help library and in
     SUN/95 include references to the "WCS component" or to
     "WCS information". In the new system, each NDF has a
     "current co-ordinate Frame". The converted applications
     use this co-ordinate Frame when referring to any
     position within the NDF, for instance when producing
     axis annotation, or requesting a position from the user.
     Each NDF has its own current co-ordinate Frame, and the
     global parameter GLOBAL.COORD_SYSTEM is ignored. These
     application do not have a COSYS parameter which has
     previously been used to specify a co-ordinate system.

     In the previous system, there was a "global" co-ordinate
     system which was used by all applications irrespective
     of the contents of the NDF. This co-ordinate system was
     either data or world and was obtained by each
     application using a COSYS parameter. These parameters
     were associated with the global parameter
     GLOBAL.COORD_SYSTEM.

     The rest of this section describes the old pre-WCS
     system and will be removed when the conversion process
     is complete. The new system is described in SUN/95
     section "Using World Co-ordinate Systems"


KAPPA uses a number of co-ordinate systems; this topic describes
them, and how to select one.  NDFTRACE reports the bounds of an NDF
in these various co-ordinate systems. 

2 Pixel_Indices

The elements in an NDF's array can be addressed by their
n-dimensional integer pixel indices.  The first or origin pixel in
an NDF need not have pixel index equal to one in each dimension,
though it usually will.  An NDF can have an arbitrary origin.  By
adjusting the origins of NDFs with SETORIGIN you may combine the
NDFs differently.  For example, ADD adds two NDFs where they overlap.
The overlap is defined in terms of pixel indices.  Thus only those
pixels with the same pixel index in both NDFs will be added.  The
resultant NDF is the addition in the intersection of the two input
NDFs. 

If you wish to select rectangular sections of pixels within an NDF
indices are fine and precise. Since they are integer quantities,
these indices cannot represent a continuous co-ordinate system,
although the information stored in an NDF will almost always require
that positions within it be describable to sub-pixel accuracy.  For
example, when CENTROID determines the position of a star in a
2-dimensional image it will inevitably give rise to a non-integer
result, for which a continuous (x-y) co-ordinate system is required.
See "Pixel_Co-ordinates".

2 Pixel_Co-ordinates
There are a number of ways in which a continuous co-ordinate system
can be defined for a regular array of pixels.  In the absence of
other information, the Starlink convention is to use a pixel
co-ordinate system in which a pixel with indices (i,j) has its
centre at the position

                        (i-1/2,j-1/2)

and is taken to be one unit in extent in each dimension.  Pixel
(1,1) would therefore be centred at the position (0.5,0.5) and would
have its `lower' and `upper' corners located at positions (0.0,0.0)
and (1.0,1.0) respectively, as follows

                                      (1.0,1.0)
                                      v
                        ---------------
                        |             |
                        |             |
                        |      + <----|---- (0.5,0.5)
                        |             |
                        |             |
                        ---------------
                        ^
                (0.0,0.0)

This makes it possible to refer to fractional pixel positions---in
this case within a 2-dimensional array, although the principle can
obviously be extended to other numbers of dimensions.

2 Data_Co-ordinates
The pixel co-ordinate system described in subtopic
"Pixel_Co-ordinates" how to convert pixel indices into a set of
continuous co-ordinates and therefore introduces a co-ordinate axis
which runs along each dimension of the NDF.

The use of the pixel size to determine the units of these axes is
rather restrictive, however, and in practice we may want to use more
realistic physical units. This would allow a spectrum to be
calibrated in wavelength, for instance, or the output from a
plate-measuring machine to be related to axes calibrated in microns.
In KAPPA these are called Data co-ordinates.

The NDF's axis components are designed to hold the extra information
needed to define more useful co-ordinate systems, so that realistic
axes can be associated with a NDF, along with labels and units for
these axes. 

2 Selecting_a_Co-ordinate_System
The pixel co-ordinate system is the default choice, and although it
is intended to be used only in the absence of other information,
KAPPA offers you a choice of co-ordinate system, even if your NDF
has physical co-ordinates in its axis centres.

There is a global parameter---the current co-ordinate system---that
may be WORLD or DATA.  It is set by a parameter called COSYS in each
application that processes data co-ordinates. For instance,
 
     % display cosys=w axes \\
     % centroid
 
makes the axes about the displayed image and the centroid positions
in the following task appear in pixel co-ordinates, regardless of
whether there are axes present or not. 

Conversely,
 
     % display cosys=d axes \\
     % centroid
 
makes the axes about the displayed image and the centroid positions
appear in data co-ordinates, provided there are axes present.  Of
course, the axes may just have a pixel co-ordinate system.

If the global parameter is undefined, applications will adopt 
a suitable default, depending on the application.  All default to
"Data" except ARDMASK, CENTROID, FITSURFACE, PSF, SEGMENT,
TRANSFORMER, and ZAPLIN.

When you draw a plot or an image, the graphics database records the
co-ordinate extents of the picture.  What was not said explicitly
was which co-ordinate system.  Looking at the output from GDSTATE
and CURSOR shows that the database deals in world co-ordinates.
Graphics packages like GKS require co-ordinates to be linear and
increase from left to right and bottom to top.  This is not
necessarily the case for physical axes.  So are we going to lose our
co-ordinate system between applications?  No... well almost
certainly not.  KAPPA strives to find a linear transformation
between your data co-ordinates and pixel co-ordinates, or a
logarithmic one in some cases.  If it succeeds the transformation is
stored in the database.  Thus if you plot a spectrum with wavelength
along the abscissa, you can then use CURSOR to identify lines.
 
     % linplot adam_examples:spectrum cosys=d \\
     % cursor

     Use the graphics cursor to define the next point...
        Press left button on mouse/trackerball to select a point.
        Press right button on mouse/trackerball to end input.

     X=3934.254, Y=196.118 in KAPPA_LINPLOT( DATA )
     X=3969.148, Y=196.118 in KAPPA_LINPLOT( DATA )
 
The x co-ordinates are the wavelengths in Angstroms of the Calcium
II H and K lines.

If the global parameter is undefined you will be prompted for a
co-ordinate as required.

1 Colour_Set
The standard set of named colours recognised by KAPPA is tabulated
below together with their red, green, and blue relative intensities.
Since the list contains over 450 colours, it is divided into
sub-topics classified by the first letter of the colour's name.
For example "H-K" includes all colours beginning with H or I or K.

It is the X-windows standard colour set so don't blame KAPPA if you
think some of them are anomalous.  In addition to those tabulated,
there are grey levels at each percentage between "Black" and
"White".  These are called "Grey1", "Grey2", ..., "Grey99".  All
the names containing "Grey" have synonyms spelt with "Gray". 
2 A

  ------------------------------------------------
  |             Standard Colour Set              |
  ------------------------------------------------
  | Name                 |   R   |   G   |   B   |
  ------------------------------------------------
  | AliceBlue            | 0.941 | 0.973 | 1.000 | 
  | AntiqueWhite         | 0.980 | 0.922 | 0.843 | 
  | AntiqueWhite1        | 1.000 | 0.937 | 0.859 | 
  | AntiqueWhite2        | 0.933 | 0.875 | 0.800 | 
  | AntiqueWhite3        | 0.804 | 0.753 | 0.690 | 
  | AntiqueWhite4        | 0.545 | 0.514 | 0.471 | 
  | Aquamarine           | 0.498 | 1.000 | 0.831 | 
  | Aquamarine1          | 0.498 | 1.000 | 0.831 | 
  | Aquamarine2          | 0.463 | 0.933 | 0.776 | 
  | Aquamarine3          | 0.400 | 0.804 | 0.667 | 
  | Aquamarine4          | 0.271 | 0.545 | 0.455 | 
  | Azure                | 0.941 | 1.000 | 1.000 | 
  | Azure1               | 0.941 | 1.000 | 1.000 | 
  | Azure2               | 0.878 | 0.933 | 0.933 | 
  | Azure3               | 0.757 | 0.804 | 0.804 | 
  | Azure4               | 0.514 | 0.545 | 0.545 | 
  ------------------------------------------------

2 B
  ------------------------------------------------
  |             Standard Colour Set              |
  ------------------------------------------------
  | Name                 |   R   |   G   |   B   |
  ------------------------------------------------
  | Beige                | 0.961 | 0.961 | 0.863 | 
  | Bisque               | 1.000 | 0.894 | 0.769 | 
  | Bisque1              | 1.000 | 0.894 | 0.769 | 
  | Bisque2              | 0.933 | 0.835 | 0.718 | 
  | Bisque3              | 0.804 | 0.718 | 0.620 | 
  | Bisque4              | 0.545 | 0.490 | 0.420 | 
  | Black                | 0.000 | 0.000 | 0.000 | 
  | BlanchedAlmond       | 1.000 | 0.922 | 0.804 | 
  | Blue                 | 0.000 | 0.000 | 1.000 | 
  | Blue1                | 0.000 | 0.000 | 1.000 | 
  | Blue2                | 0.000 | 0.000 | 0.933 | 
  | Blue3                | 0.000 | 0.000 | 0.804 | 
  | Blue4                | 0.000 | 0.000 | 0.545 | 
  | BlueViolet           | 0.541 | 0.169 | 0.886 | 
  | Brown                | 0.647 | 0.165 | 0.165 | 
  | Brown1               | 1.000 | 0.251 | 0.251 | 
  | Brown2               | 0.933 | 0.231 | 0.231 | 
  | Brown3               | 0.804 | 0.200 | 0.200 | 
  | Brown4               | 0.545 | 0.137 | 0.137 | 
  | Burlywood            | 0.871 | 0.722 | 0.529 | 
  | Burlywood1           | 1.000 | 0.827 | 0.608 | 
  | Burlywood2           | 0.933 | 0.773 | 0.569 | 
  | Burlywood3           | 0.804 | 0.667 | 0.490 | 
  | Burlywood4           | 0.545 | 0.451 | 0.333 | 
  ------------------------------------------------

2 C
  ------------------------------------------------
  |             Standard Colour Set              |
  ------------------------------------------------
  | Name                 |   R   |   G   |   B   |
  ------------------------------------------------
  | CadetBlue            | 0.373 | 0.620 | 0.627 | 
  | CadetBlue1           | 0.596 | 0.961 | 1.000 | 
  | CadetBlue2           | 0.557 | 0.898 | 0.933 | 
  | CadetBlue3           | 0.478 | 0.773 | 0.804 | 
  | CadetBlue4           | 0.325 | 0.525 | 0.545 | 
  | Chartreuse           | 0.498 | 1.000 | 0.000 | 
  | Chartreuse1          | 0.498 | 1.000 | 0.000 | 
  | Chartreuse2          | 0.463 | 0.933 | 0.000 | 
  | Chartreuse3          | 0.400 | 0.804 | 0.000 | 
  | Chartreuse4          | 0.271 | 0.545 | 0.000 | 
  | Chocolate            | 0.824 | 0.412 | 0.118 | 
  | Chocolate1           | 1.000 | 0.498 | 0.141 | 
  | Chocolate2           | 0.933 | 0.463 | 0.129 | 
  | Chocolate3           | 0.804 | 0.400 | 0.114 | 
  | Chocolate4           | 0.545 | 0.271 | 0.075 | 
  | Coral                | 1.000 | 0.498 | 0.314 | 
  | Coral1               | 1.000 | 0.447 | 0.337 | 
  | Coral2               | 0.933 | 0.416 | 0.314 | 
  | Coral3               | 0.804 | 0.357 | 0.271 | 
  | Coral4               | 0.545 | 0.243 | 0.184 | 
  | CornflowerBlue       | 0.392 | 0.584 | 0.929 | 
  | Cornsilk             | 1.000 | 0.973 | 0.863 | 
  | Cornsilk1            | 1.000 | 0.973 | 0.863 | 
  | Cornsilk2            | 0.933 | 0.910 | 0.804 | 
  | Cornsilk3            | 0.804 | 0.784 | 0.694 | 
  | Cornsilk4            | 0.545 | 0.533 | 0.471 | 
  | Cyan                 | 0.000 | 1.000 | 1.000 | 
  | Cyan1                | 0.000 | 1.000 | 1.000 | 
  | Cyan2                | 0.000 | 0.933 | 0.933 | 
  | Cyan3                | 0.000 | 0.804 | 0.804 | 
  | Cyan4                | 0.000 | 0.545 | 0.545 | 

  ------------------------------------------------

2 D
  ------------------------------------------------
  |             Standard Colour Set              |
  ------------------------------------------------
  | Name                 |   R   |   G   |   B   |
  ------------------------------------------------
  | DarkGoldenrod        | 0.722 | 0.525 | 0.043 | 
  | DarkGoldenrod1       | 1.000 | 0.725 | 0.059 | 
  | DarkGoldenrod2       | 0.933 | 0.678 | 0.055 | 
  | DarkGoldenrod3       | 0.804 | 0.584 | 0.047 | 
  | DarkGoldenrod4       | 0.545 | 0.396 | 0.031 | 
  | DarkGreen            | 0.000 | 0.392 | 0.000 | 
  | DarkKhaki            | 0.741 | 0.718 | 0.420 | 
  | DarkOliveGreen       | 0.333 | 0.420 | 0.184 | 
  | DarkOliveGreen1      | 0.792 | 1.000 | 0.439 | 
  | DarkOliveGreen2      | 0.737 | 0.933 | 0.408 | 
  | DarkOliveGreen3      | 0.635 | 0.804 | 0.353 | 
  | DarkOliveGreen4      | 0.431 | 0.545 | 0.239 | 
  | DarkOrange           | 1.000 | 0.549 | 0.000 | 
  | DarkOrange1          | 1.000 | 0.498 | 0.000 | 
  | DarkOrange2          | 0.933 | 0.463 | 0.000 | 
  | DarkOrange3          | 0.804 | 0.400 | 0.000 | 
  | DarkOrange4          | 0.545 | 0.271 | 0.000 | 
  | DarkOrchid           | 0.600 | 0.196 | 0.800 | 
  | DarkOrchid1          | 0.749 | 0.243 | 1.000 | 
  | DarkOrchid2          | 0.698 | 0.227 | 0.933 | 
  | DarkOrchid3          | 0.604 | 0.196 | 0.804 | 
  | DarkOrchid4          | 0.408 | 0.133 | 0.545 | 
  | DarkSalmon           | 0.914 | 0.588 | 0.478 | 
  | DarkSeaGreen         | 0.561 | 0.737 | 0.561 | 
  | DarkSeaGreen1        | 0.757 | 1.000 | 0.757 | 
  | DarkSeaGreen2        | 0.706 | 0.933 | 0.706 | 
  | DarkSeaGreen3        | 0.608 | 0.804 | 0.608 | 
  | DarkSeaGreen4        | 0.412 | 0.545 | 0.412 | 
  | DarkSlateBlue        | 0.282 | 0.239 | 0.545 | 
  | DarkSlateGrey        | 0.184 | 0.310 | 0.310 | 
  | DarkSlateGrey1       | 0.592 | 1.000 | 1.000 | 
  | DarkSlateGrey2       | 0.553 | 0.933 | 0.933 | 
  | DarkSlateGrey3       | 0.475 | 0.804 | 0.804 | 
  | DarkSlateGrey4       | 0.322 | 0.545 | 0.545 | 
  | DarkTurquoise        | 0.000 | 0.808 | 0.820 | 
  | DarkViolet           | 0.580 | 0.000 | 0.827 | 
  | DeepPink             | 1.000 | 0.078 | 0.576 | 
  | DeepPink1            | 1.000 | 0.078 | 0.576 | 
  | DeepPink2            | 0.933 | 0.071 | 0.537 | 
  | DeepPink3            | 0.804 | 0.063 | 0.463 | 
  | DeepPink4            | 0.545 | 0.039 | 0.314 | 
  | DeepSkyBlue          | 0.000 | 0.749 | 1.000 | 
  | DeepSkyBlue1         | 0.000 | 0.749 | 1.000 | 
  | DeepSkyBlue2         | 0.000 | 0.698 | 0.933 | 
  | DeepSkyBlue3         | 0.000 | 0.604 | 0.804 | 
  | DeepSkyBlue4         | 0.000 | 0.408 | 0.545 | 
  | DimGrey              | 0.412 | 0.412 | 0.412 | 
  | DodgerBlue           | 0.118 | 0.565 | 1.000 | 
  | DodgerBlue1          | 0.118 | 0.565 | 1.000 | 
  | DodgerBlue2          | 0.110 | 0.525 | 0.933 | 
  | DodgerBlue3          | 0.094 | 0.455 | 0.804 | 
  | DodgerBlue4          | 0.063 | 0.306 | 0.545 | 
  ------------------------------------------------

2 F-G
  ------------------------------------------------
  |             Standard Colour Set              |
  ------------------------------------------------
  | Name                 |   R   |   G   |   B   |
  ------------------------------------------------
  | Firebrick            | 0.698 | 0.133 | 0.133 | 
  | Firebrick1           | 1.000 | 0.188 | 0.188 | 
  | Firebrick2           | 0.933 | 0.173 | 0.173 | 
  | Firebrick3           | 0.804 | 0.149 | 0.149 | 
  | Firebrick4           | 0.545 | 0.102 | 0.102 | 
  | FloralWhite          | 1.000 | 0.980 | 0.941 | 
  | ForestGreen          | 0.133 | 0.545 | 0.133 | 
  | Gainsboro            | 0.863 | 0.863 | 0.863 | 
  | GhostWhite           | 0.973 | 0.973 | 1.000 | 
  | Gold                 | 1.000 | 0.843 | 0.000 | 
  | Gold1                | 1.000 | 0.843 | 0.000 | 
  | Gold2                | 0.933 | 0.788 | 0.000 | 
  | Gold3                | 0.804 | 0.678 | 0.000 | 
  | Gold4                | 0.545 | 0.459 | 0.000 | 
  | Goldenrod            | 0.855 | 0.647 | 0.125 | 
  | Goldenrod1           | 1.000 | 0.757 | 0.145 | 
  | Goldenrod2           | 0.933 | 0.706 | 0.133 | 
  | Goldenrod3           | 0.804 | 0.608 | 0.114 | 
  | Goldenrod4           | 0.545 | 0.412 | 0.078 | 
  | Green                | 0.000 | 1.000 | 0.000 | 
  | Green1               | 0.000 | 1.000 | 0.000 | 
  | Green2               | 0.000 | 0.933 | 0.000 | 
  | Green3               | 0.000 | 0.804 | 0.000 | 
  | Green4               | 0.000 | 0.545 | 0.000 | 
  | GreenYellow          | 0.678 | 1.000 | 0.184 | 
  | Grey                 | 0.753 | 0.753 | 0.753 | 
  ------------------------------------------------

2 H-K
  ------------------------------------------------
  |             Standard Colour Set              |
  ------------------------------------------------
  | Name                 |   R   |   G   |   B   |
  ------------------------------------------------
  | Honeydew             | 0.941 | 1.000 | 0.941 | 
  | Honeydew1            | 0.941 | 1.000 | 0.941 | 
  | Honeydew2            | 0.878 | 0.933 | 0.878 | 
  | Honeydew3            | 0.757 | 0.804 | 0.757 | 
  | Honeydew4            | 0.514 | 0.545 | 0.514 | 
  | HotPink              | 1.000 | 0.412 | 0.706 | 
  | HotPink1             | 1.000 | 0.431 | 0.706 | 
  | HotPink2             | 0.933 | 0.416 | 0.655 | 
  | HotPink3             | 0.804 | 0.376 | 0.565 | 
  | HotPink4             | 0.545 | 0.227 | 0.384 | 
  | IndianRed            | 0.804 | 0.361 | 0.361 | 
  | IndianRed1           | 1.000 | 0.416 | 0.416 | 
  | IndianRed2           | 0.933 | 0.388 | 0.388 | 
  | IndianRed3           | 0.804 | 0.333 | 0.333 | 
  | IndianRed4           | 0.545 | 0.227 | 0.227 | 
  | Ivory                | 1.000 | 1.000 | 0.941 | 
  | Ivory2               | 0.933 | 0.933 | 0.878 | 
  | Ivory3               | 0.804 | 0.804 | 0.757 | 
  | Ivory4               | 0.545 | 0.545 | 0.514 | 
  | Khaki                | 0.941 | 0.902 | 0.549 | 
  | Khaki1               | 1.000 | 0.965 | 0.561 | 
  | Khaki2               | 0.933 | 0.902 | 0.522 | 
  | Khaki3               | 0.804 | 0.776 | 0.451 | 
  | Khaki4               | 0.545 | 0.525 | 0.306 | 
  ------------------------------------------------

2 L
  ------------------------------------------------
  |             Standard Colour Set              |
  ------------------------------------------------
  | Name                 |   R   |   G   |   B   |
  ------------------------------------------------
  | Lavender             | 0.902 | 0.902 | 0.980 | 
  | LavenderBlush        | 1.000 | 0.941 | 0.961 | 
  | LavenderBlush1       | 1.000 | 0.941 | 0.961 | 
  | LavenderBlush2       | 0.933 | 0.878 | 0.898 | 
  | LavenderBlush3       | 0.804 | 0.757 | 0.773 | 
  | LavenderBlush4       | 0.545 | 0.514 | 0.525 | 
  | LawnGreen            | 0.486 | 0.988 | 0.000 | 
  | LemonChiffon         | 1.000 | 0.980 | 0.804 | 
  | LemonChiffon1        | 1.000 | 0.980 | 0.804 | 
  | LemonChiffon2        | 0.933 | 0.914 | 0.749 | 
  | LemonChiffon3        | 0.804 | 0.788 | 0.647 | 
  | LemonChiffon4        | 0.545 | 0.537 | 0.439 | 
  | LightBlue            | 0.678 | 0.847 | 0.902 | 
  | LightBlue1           | 0.749 | 0.937 | 1.000 | 
  | LightBlue2           | 0.698 | 0.875 | 0.933 | 
  | LightBlue3           | 0.604 | 0.753 | 0.804 | 
  | LightBlue4           | 0.408 | 0.514 | 0.545 | 
  | LightCoral           | 0.941 | 0.502 | 0.502 | 
  | LightCyan            | 0.878 | 1.000 | 1.000 | 
  | LightCyan1           | 0.878 | 1.000 | 1.000 | 
  | LightCyan2           | 0.820 | 0.933 | 0.933 | 
  | LightCyan3           | 0.706 | 0.804 | 0.804 | 
  | LightCyan4           | 0.478 | 0.545 | 0.545 | 
  | LightGoldenrod       | 0.933 | 0.867 | 0.510 | 
  | LightGoldenrod1      | 1.000 | 0.925 | 0.545 | 
  | LightGoldenrod2      | 0.933 | 0.863 | 0.510 | 
  | LightGoldenrod3      | 0.804 | 0.745 | 0.439 | 
  | LightGoldenrod4      | 0.545 | 0.506 | 0.298 | 
  | LightGoldenrodYellow | 0.980 | 0.980 | 0.824 | 
  | LightGrey            | 0.827 | 0.827 | 0.827 | 
  | LightPink            | 1.000 | 0.714 | 0.757 | 
  | LightPink1           | 1.000 | 0.682 | 0.725 | 
  | LightPink2           | 0.933 | 0.635 | 0.678 | 
  | LightPink3           | 0.804 | 0.549 | 0.584 | 
  | LightPink4           | 0.545 | 0.373 | 0.396 | 
  | LightSalmon          | 1.000 | 0.627 | 0.478 | 
  | LightSalmon1         | 1.000 | 0.627 | 0.478 | 
  | LightSalmon2         | 0.933 | 0.584 | 0.447 | 
  | LightSalmon3         | 0.804 | 0.506 | 0.384 | 
  | LightSalmon4         | 0.545 | 0.341 | 0.259 | 
  | LightSeaGreen        | 0.125 | 0.698 | 0.667 | 
  | LightSkyBlue         | 0.529 | 0.808 | 0.980 | 
  | LightSkyBlue1        | 0.690 | 0.886 | 1.000 | 
  | LightSkyBlue2        | 0.643 | 0.827 | 0.933 | 
  | LightSkyBlue3        | 0.553 | 0.714 | 0.804 | 
  | LightSkyBlue4        | 0.376 | 0.482 | 0.545 | 
  | LightSlateBlue       | 0.518 | 0.439 | 1.000 | 
  | LightSlateGrey       | 0.467 | 0.533 | 0.600 | 
  | LightSteelBlue       | 0.690 | 0.769 | 0.871 | 
  | LightSteelBlue1      | 0.792 | 0.882 | 1.000 | 
  | LightSteelBlue2      | 0.737 | 0.824 | 0.933 | 
  | LightSteelBlue3      | 0.635 | 0.710 | 0.804 | 
  | LightSteelBlue4      | 0.431 | 0.482 | 0.545 | 
  | LightYellow          | 1.000 | 1.000 | 0.878 | 
  | LightYellow1         | 1.000 | 1.000 | 0.878 | 
  | LightYellow2         | 0.933 | 0.933 | 0.820 | 
  | LightYellow3         | 0.804 | 0.804 | 0.706 | 
  | LightYellow4         | 0.545 | 0.545 | 0.478 | 
  | LimeGreen            | 0.196 | 0.804 | 0.196 | 
  | Linen                | 0.980 | 0.941 | 0.902 | 
  ------------------------------------------------

2 M
  ------------------------------------------------
  |             Standard Colour Set              |
  ------------------------------------------------
  | Name                 |   R   |   G   |   B   |
  ------------------------------------------------
  | Magenta              | 1.000 | 0.000 | 1.000 | 
  | Magenta1             | 1.000 | 0.000 | 1.000 | 
  | Magenta2             | 0.933 | 0.000 | 0.933 | 
  | Magenta3             | 0.804 | 0.000 | 0.804 | 
  | Magenta4             | 0.545 | 0.000 | 0.545 | 
  | Maroon               | 0.690 | 0.188 | 0.376 | 
  | Maroon1              | 1.000 | 0.204 | 0.702 | 
  | Maroon2              | 0.933 | 0.188 | 0.655 | 
  | Maroon3              | 0.804 | 0.161 | 0.565 | 
  | Maroon4              | 0.545 | 0.110 | 0.384 | 
  | MediumAquamarine     | 0.400 | 0.804 | 0.667 | 
  | MediumBlue           | 0.000 | 0.000 | 0.804 | 
  | MediumOrchid         | 0.729 | 0.333 | 0.827 | 
  | MediumOrchid1        | 0.878 | 0.400 | 1.000 | 
  | MediumOrchid2        | 0.820 | 0.373 | 0.933 | 
  | MediumOrchid3        | 0.706 | 0.322 | 0.804 | 
  | MediumOrchid4        | 0.478 | 0.216 | 0.545 | 
  | MediumPurple         | 0.576 | 0.439 | 0.859 | 
  | MediumPurple1        | 0.671 | 0.510 | 1.000 | 
  | MediumPurple2        | 0.624 | 0.475 | 0.933 | 
  | MediumPurple3        | 0.537 | 0.408 | 0.804 | 
  | MediumPurple4        | 0.365 | 0.278 | 0.545 | 
  | MediumSeaGreen       | 0.235 | 0.702 | 0.443 | 
  | MediumSlateBlue      | 0.482 | 0.408 | 0.933 | 
  | MediumSpringGreen    | 0.000 | 0.980 | 0.604 | 
  | MediumTurquoise      | 0.282 | 0.820 | 0.800 | 
  | MediumVioletRed      | 0.780 | 0.082 | 0.522 | 
  | MidnightBlue         | 0.098 | 0.098 | 0.439 | 
  | MintCream            | 0.961 | 1.000 | 0.980 | 
  | MistyRose            | 1.000 | 0.894 | 0.882 | 
  | MistyRose1           | 1.000 | 0.894 | 0.882 | 
  | MistyRose2           | 0.933 | 0.835 | 0.824 | 
  | MistyRose3           | 0.804 | 0.718 | 0.710 | 
  | MistyRose4           | 0.545 | 0.490 | 0.482 | 
  | Moccasin             | 1.000 | 0.894 | 0.710 | 
  ------------------------------------------------

2 N-O
  ------------------------------------------------
  |             Standard Colour Set              |
  ------------------------------------------------
  | Name                 |   R   |   G   |   B   |
  ------------------------------------------------
  | NavajoWhite          | 1.000 | 0.871 | 0.678 | 
  | NavajoWhite1         | 1.000 | 0.871 | 0.678 | 
  | NavajoWhite2         | 0.933 | 0.812 | 0.631 | 
  | NavajoWhite3         | 0.804 | 0.702 | 0.545 | 
  | NavajoWhite4         | 0.545 | 0.475 | 0.369 | 
  | Navy                 | 0.000 | 0.000 | 0.502 | 
  | NavyBlue             | 0.000 | 0.000 | 0.502 | 
  | OldLace              | 0.992 | 0.961 | 0.902 | 
  | OliveDrab            | 0.420 | 0.557 | 0.137 | 
  | OliveDrab1           | 0.753 | 1.000 | 0.243 | 
  | OliveDrab2           | 0.702 | 0.933 | 0.227 | 
  | OliveDrab3           | 0.604 | 0.804 | 0.196 | 
  | OliveDrab4           | 0.412 | 0.545 | 0.133 | 
  | Orange               | 1.000 | 0.647 | 0.000 | 
  | Orange1              | 1.000 | 0.647 | 0.000 | 
  | Orange2              | 0.933 | 0.604 | 0.000 | 
  | Orange3              | 0.804 | 0.522 | 0.000 | 
  | Orange4              | 0.545 | 0.353 | 0.000 | 
  | OrangeRed            | 1.000 | 0.271 | 0.000 | 
  | OrangeRed1           | 1.000 | 0.271 | 0.000 | 
  | OrangeRed2           | 0.933 | 0.251 | 0.000 | 
  | OrangeRed3           | 0.804 | 0.216 | 0.000 | 
  | OrangeRed4           | 0.545 | 0.145 | 0.000 | 
  | Orchid               | 0.855 | 0.439 | 0.839 | 
  | Orchid1              | 1.000 | 0.514 | 0.980 | 
  | Orchid2              | 0.933 | 0.478 | 0.914 | 
  | Orchid3              | 0.804 | 0.412 | 0.788 | 
  | Orchid4              | 0.545 | 0.278 | 0.537 | 
  ------------------------------------------------

2 P
  ------------------------------------------------
  |             Standard Colour Set              |
  ------------------------------------------------
  | Name                 |   R   |   G   |   B   |
  ------------------------------------------------
  | PaleGoldenrod        | 0.933 | 0.910 | 0.667 | 
  | PaleGreen            | 0.596 | 0.984 | 0.596 | 
  | PaleGreen1           | 0.604 | 1.000 | 0.604 | 
  | PaleGreen2           | 0.565 | 0.933 | 0.565 | 
  | PaleGreen3           | 0.486 | 0.804 | 0.486 | 
  | PaleGreen4           | 0.329 | 0.545 | 0.329 | 
  | PaleTurquoise        | 0.686 | 0.933 | 0.933 | 
  | PaleTurquoise1       | 0.733 | 1.000 | 1.000 | 
  | PaleTurquoise2       | 0.682 | 0.933 | 0.933 | 
  | PaleTurquoise3       | 0.588 | 0.804 | 0.804 | 
  | PaleTurquoise4       | 0.400 | 0.545 | 0.545 | 
  | PaleVioletRed        | 0.859 | 0.439 | 0.576 | 
  | PaleVioletRed1       | 1.000 | 0.510 | 0.671 | 
  | PaleVioletRed2       | 0.933 | 0.475 | 0.624 | 
  | PaleVioletRed3       | 0.804 | 0.408 | 0.537 | 
  | PaleVioletRed4       | 0.545 | 0.278 | 0.365 | 
  | PapayaWhip           | 1.000 | 0.937 | 0.835 | 
  | PeachPuff            | 1.000 | 0.855 | 0.725 | 
  | PeachPuff1           | 1.000 | 0.855 | 0.725 | 
  | PeachPuff2           | 0.933 | 0.796 | 0.678 | 
  | PeachPuff3           | 0.804 | 0.686 | 0.584 | 
  | PeachPuff4           | 0.545 | 0.467 | 0.396 | 
  | Peru                 | 0.804 | 0.522 | 0.247 | 
  | Pink                 | 1.000 | 0.753 | 0.796 | 
  | Pink1                | 1.000 | 0.710 | 0.773 | 
  | Pink2                | 0.933 | 0.663 | 0.722 | 
  | Pink3                | 0.804 | 0.569 | 0.620 | 
  | Pink4                | 0.545 | 0.388 | 0.424 | 
  | Plum                 | 0.867 | 0.627 | 0.867 | 
  | Plum1                | 1.000 | 0.733 | 1.000 | 
  | Plum2                | 0.933 | 0.682 | 0.933 | 
  | Plum3                | 0.804 | 0.588 | 0.804 | 
  | Plum4                | 0.545 | 0.400 | 0.545 | 
  | PowderBlue           | 0.690 | 0.878 | 0.902 | 
  | Purple               | 0.627 | 0.125 | 0.941 | 
  | Purple1              | 0.608 | 0.188 | 1.000 | 
  | Purple2              | 0.569 | 0.173 | 0.933 | 
  | Purple3              | 0.490 | 0.149 | 0.804 | 
  | Purple4              | 0.333 | 0.102 | 0.545 | 
  ------------------------------------------------

2 R
  ------------------------------------------------
  |             Standard Colour Set              |
  ------------------------------------------------
  | Name                 |   R   |   G   |   B   |
  ------------------------------------------------
  | Red                  | 1.000 | 0.000 | 0.000 | 
  | Red1                 | 1.000 | 0.000 | 0.000 | 
  | Red2                 | 0.933 | 0.000 | 0.000 | 
  | Red3                 | 0.804 | 0.000 | 0.000 | 
  | Red4                 | 0.545 | 0.000 | 0.000 | 
  | RosyBrown            | 0.737 | 0.561 | 0.561 | 
  | RosyBrown1           | 1.000 | 0.757 | 0.757 | 
  | RosyBrown2           | 0.933 | 0.706 | 0.706 | 
  | RosyBrown3           | 0.804 | 0.608 | 0.608 | 
  | RosyBrown4           | 0.545 | 0.412 | 0.412 | 
  | RoyalBlue            | 0.255 | 0.412 | 0.882 | 
  | RoyalBlue1           | 0.282 | 0.463 | 1.000 | 
  | RoyalBlue2           | 0.263 | 0.431 | 0.933 | 
  | RoyalBlue3           | 0.227 | 0.373 | 0.804 | 
  | RoyalBlue4           | 0.153 | 0.251 | 0.545 | 
  ------------------------------------------------

2 S
  ------------------------------------------------
  |             Standard Colour Set              |
  ------------------------------------------------
  | Name                 |   R   |   G   |   B   |
  ------------------------------------------------
  | SaddleBrown          | 0.545 | 0.271 | 0.075 | 
  | Salmon               | 0.980 | 0.502 | 0.447 | 
  | Salmon1              | 1.000 | 0.549 | 0.412 | 
  | Salmon2              | 0.933 | 0.510 | 0.384 | 
  | Salmon3              | 0.804 | 0.439 | 0.329 | 
  | Salmon4              | 0.545 | 0.298 | 0.224 | 
  | SandyBrown           | 0.957 | 0.643 | 0.376 | 
  | SeaGreen             | 0.180 | 0.545 | 0.341 | 
  | SeaGreen1            | 0.329 | 1.000 | 0.624 | 
  | SeaGreen2            | 0.306 | 0.933 | 0.580 | 
  | SeaGreen3            | 0.263 | 0.804 | 0.502 | 
  | SeaGreen4            | 0.180 | 0.545 | 0.341 | 
  | Seashell             | 1.000 | 0.961 | 0.933 | 
  | Seashell1            | 1.000 | 0.961 | 0.933 | 
  | Seashell2            | 0.933 | 0.898 | 0.871 | 
  | Seashell3            | 0.804 | 0.773 | 0.749 | 
  | Seashell4            | 0.545 | 0.525 | 0.510 | 
  | Sienna               | 0.627 | 0.322 | 0.176 | 
  | Sienna1              | 1.000 | 0.510 | 0.278 | 
  | Sienna2              | 0.933 | 0.475 | 0.259 | 
  | Sienna3              | 0.804 | 0.408 | 0.224 | 
  | Sienna4              | 0.545 | 0.278 | 0.149 | 
  | SkyBlue              | 0.529 | 0.808 | 0.922 | 
  | SkyBlue1             | 0.529 | 0.808 | 1.000 | 
  | SkyBlue2             | 0.494 | 0.753 | 0.933 | 
  | SkyBlue3             | 0.424 | 0.651 | 0.804 | 
  | SkyBlue4             | 0.290 | 0.439 | 0.545 | 
  | SlateBlue            | 0.416 | 0.353 | 0.804 | 
  | SlateBlue1           | 0.514 | 0.435 | 1.000 | 
  | SlateBlue2           | 0.478 | 0.404 | 0.933 | 
  | SlateBlue3           | 0.412 | 0.349 | 0.804 | 
  | SlateBlue4           | 0.278 | 0.235 | 0.545 | 
  | SlateGrey            | 0.439 | 0.502 | 0.565 | 
  | SlateGrey1           | 0.776 | 0.886 | 1.000 | 
  | SlateGrey2           | 0.725 | 0.827 | 0.933 | 
  | SlateGrey3           | 0.624 | 0.714 | 0.804 | 
  | SlateGrey4           | 0.424 | 0.482 | 0.545 | 
  | Snow                 | 1.000 | 0.980 | 0.980 | 
  | Snow1                | 1.000 | 0.980 | 0.980 | 
  | Snow2                | 0.933 | 0.914 | 0.914 | 
  | Snow3                | 0.804 | 0.788 | 0.788 | 
  | Snow4                | 0.545 | 0.537 | 0.537 | 
  | SpringGreen          | 0.000 | 1.000 | 0.498 | 
  | SpringGreen1         | 0.000 | 1.000 | 0.498 | 
  | SpringGreen2         | 0.000 | 0.933 | 0.463 | 
  | SpringGreen3         | 0.000 | 0.804 | 0.400 | 
  | SpringGreen4         | 0.000 | 0.545 | 0.271 | 
  | SteelBlue            | 0.275 | 0.510 | 0.706 | 
  | SteelBlue1           | 0.388 | 0.722 | 1.000 | 
  | SteelBlue2           | 0.361 | 0.675 | 0.933 | 
  | SteelBlue3           | 0.310 | 0.580 | 0.804 | 
  | SteelBlue4           | 0.212 | 0.392 | 0.545 | 
  ------------------------------------------------

2 T
  ------------------------------------------------
  |             Standard Colour Set              |
  ------------------------------------------------
  | Name                 |   R   |   G   |   B   |
  ------------------------------------------------
  | Tan                  | 0.824 | 0.706 | 0.549 | 
  | Tan1                 | 1.000 | 0.647 | 0.310 | 
  | Tan2                 | 0.933 | 0.604 | 0.286 | 
  | Tan3                 | 0.804 | 0.522 | 0.247 | 
  | Tan4                 | 0.545 | 0.353 | 0.169 | 
  | Thistle              | 0.847 | 0.749 | 0.847 | 
  | Thistle1             | 1.000 | 0.882 | 1.000 | 
  | Thistle2             | 0.933 | 0.824 | 0.933 | 
  | Thistle3             | 0.804 | 0.710 | 0.804 | 
  | Thistle4             | 0.545 | 0.482 | 0.545 | 
  | Tomato               | 1.000 | 0.388 | 0.278 | 
  | Tomato1              | 1.000 | 0.388 | 0.278 | 
  | Tomato2              | 0.933 | 0.361 | 0.259 | 
  | Tomato3              | 0.804 | 0.310 | 0.224 | 
  | Tomato4              | 0.545 | 0.212 | 0.149 | 
  | Turquoise            | 0.251 | 0.878 | 0.816 | 
  | Turquoise1           | 0.000 | 0.961 | 1.000 | 
  | Turquoise2           | 0.000 | 0.898 | 0.933 | 
  | Turquoise3           | 0.000 | 0.773 | 0.804 | 
  | Turquoise4           | 0.000 | 0.525 | 0.545 | 
  ------------------------------------------------

2 V-Y
  ------------------------------------------------
  |             Standard Colour Set              |
  ------------------------------------------------
  | Name                 |   R   |   G   |   B   |
  ------------------------------------------------
  | Violet               | 0.933 | 0.510 | 0.933 | 
  | VioletRed            | 0.816 | 0.125 | 0.565 | 
  | VioletRed1           | 1.000 | 0.243 | 0.588 | 
  | VioletRed2           | 0.933 | 0.227 | 0.549 | 
  | VioletRed3           | 0.804 | 0.196 | 0.471 | 
  | VioletRed4           | 0.545 | 0.133 | 0.322 | 
  | Vory1                | 1.000 | 1.000 | 0.941 | 
  | Wheat                | 0.961 | 0.871 | 0.702 | 
  | Wheat1               | 1.000 | 0.906 | 0.729 | 
  | Wheat2               | 0.933 | 0.847 | 0.682 | 
  | Wheat3               | 0.804 | 0.729 | 0.588 | 
  | Wheat4               | 0.545 | 0.494 | 0.400 | 
  | White                | 1.000 | 1.000 | 1.000 | 
  | WhiteSmoke           | 0.961 | 0.961 | 0.961 | 
  | Yellow               | 1.000 | 1.000 | 0.000 | 
  | Yellow1              | 1.000 | 1.000 | 0.000 | 
  | Yellow2              | 0.933 | 0.933 | 0.000 | 
  | Yellow3              | 0.804 | 0.804 | 0.000 | 
  | Yellow4              | 0.545 | 0.545 | 0.000 | 
  | YellowGreen          | 0.604 | 0.804 | 0.196 | 
  ------------------------------------------------
1 Colour_Table_and_Palette
An image display has a colour table which converts integer values
in the display's memory into the colours that you see on the monitor.
(Aside: Some people would call the colour table a video lookup
table, but the term lookup table is needed for another purpose.)
There are usually somewhere between 64 and 256 entries or indices
in the colour table that are numbered consecutively increasing from
0.  For example, if there were 256 colour indices then you would be
able display 256 different colours simultaneously;  and when you
display an image your data values would be scaled to map onto the
integer range of the colour indices, 0--255.

In many systems the full colour table is used.  This has the
disadvantage that if you want to annotate images with captions or
axes, plot coloured borders about images, plot graphs etc., yet
simultaneously display images with certain colour tables, there may
be conflict of interests.  For instance, a linear greyscale colour
table's first few colour indices will be almost black.  By default,
these same indices, particularly index 1, are used by GKS/SGS for
line graphics, thus any plots will be invisible.  If you reset
colour index 1 to white, the appearance of your image alters.
Whenever you alter the colour table to enhance the look of your
image, it will affect the line graphics.

To circumvent this dilemma, KAPPA reserves a portion of the colour
table, called the palette, that is unaffected by changes to the rest
of the colour table. It is shown schematically below.  The palette
contains 16 indices.  N is the total number of indices.  In KAPPA
the remainder of colour indices is called the colour table.

  0                              15 16                           N-1
 _____________________________________________________ ... _________
 | | | | | | | | | | | | | | | | | | | | | | | | | | |     | | | | |
 ----------------------------------------------------- ... ---------
 <-----------  Palette  -----------><-------  Colour Table  ------->

2 Manipulating_Colour_Tables
KAPPA provides a number of commands for adjusting a colour table.
LUTFLIP, LUTHILITE, LUTROT, LUTTWEAK are all IDI-based. Remember
that only the colour table will be flipped; highlighted; rotated;
stretched, or squashed, and/or have its origin moved.  Thus during
flipping, colour index 16 will swap with N-1, 17 with N-2 etc. 
CRELUT uses an enlarged palette to modify a lookup table. 

2 Lookup_Tables
In order to distinguish between the set of colours in the physical
image display (the colour table) and some external table of colours,
the latter is called a lookup table.  Lookup tables comprise a
series of red, green and blue (RGB) intensities, each normalised to
1.0; they may be stored in NDFs---indeed some are provided with
KAPPA---or be coded within applications.

A lookup table may be transferred into the display's colour table.
However, the number of indices in the colour table is usually not
the same as the number of colours in the lookup table and so a
simple substiution is not possible.  Therefore, KAPPA squeezes or
stretches the lookup table to make it fit in the available number of
colour-table indices.  Normally, linear interpolation between
adjacent lookup-table entries defines the resultant colour, though
you can select a nearest-neighbour algorithm.  The latter is suited
to lookup tables with sharp boundaries between contrasting colours,
e.g. a series of coloured blocks, and the former to smoothly varying
lookup tables where there are no obvious discontinuities, e.g.
spectrum-like.

Let's have a few examples.
 
     % lutheat
     % lutramps
     % lutread pastel
     % lutable li ex sawtooth nn
     % lutsave pirated
 
LUTHEAT loads the standard `heat' lookup table into the colour table
using linear interpolation, whilst LUTRAMPS loads the standard
coloured ramps using the nearest neighbours in the lookup table.
LUTREAD reads the lookup table stored in the DATA_ARRAY of the NDF
called pastel and maps it onto the colour table via linear
interpolation.  In the fourth example the lookup table in NDF
sawtooth is mapped onto the colour table via a linear
nearest-neighbour method.  The "ex" tells LUTABLE to read an
external file.  In the final example LUTSAVE saves the current
colour table into a lookup-table NDF called pirated.  LUTSAVE is
quite useful as you can steal other people's attractive colour
tables that they've carelessly left in the display's memory!  It
does not matter should the display not have a palette, since 
 
     ICL> lutsave pirated full
 
will save the full set of colour indices to the NDF.

3 Creating_Lookup_Tables

4 From_a_Text_File
You can make a text file of the RGB intensities and use TRANDAT to
create the NDF, or manipulate the colour table and then save it in a
lookup-table NDF.  If you choose the second option remember that all
RGB intensities must lie in the range 0.0--1.0, where 1.0 is the
maximum intensity; and that equal red, green, and blue intensities
yields a shade of grey. So for example if you want a six equal blocks
of red, blue, yellow, pink, sienna and turquoise you could create the
text file col6.dat with contents
 
     # Red, blue, yellow, pink, sienna, and turquoise LUT
     1.0 0.0 0.0
     0.0 0.0 1.0
     1.0 1.0 0.0
     0.9 0.56 0.56
     0.56 0.42 0.14
     0.68 0.92 0.92
 
and then run TRANDAT to make the NDF called collut6.
 
     % trandat col6 collut6 shape='[3,6]' auto

4 Running_CRELUT
There is an interactive task called CRELUT for creating lookup tables.
Let's be honest; it's a bit dated compared with what is possible today
with X-windows, but it works, and I still use it.

CRELUT has a number of stages that cannot be expressed via the
examples in the reference manual, so here is a walk through with
commentary.  It would be a good idea to find an image display and
repeat the example yourself.  CRELUT asks for an initial lookup
table.  Since we don't have one we enter !; this results in a
greyscale being loaded in the colour table.  Next we nominate an
image for which we want to tailor the lookup table.  In order to
display it and to compute an histogram we must also provide scaling
limits. The chosen limits encompass most data values.
 
     ICL> crelut 
     INLUT - NDF containing input lookup table /@$KAPPA_DIR/spectrum_lut/ > ! 
     NDF - Image to be displayed /@$KAPPA_DIR/ccdframec/ > 
     LOW - Low value for image scaling /2250/ >
     HIGH - High value for image scaling /30790.990234375/ > 3000
 
The image appears in grey above the histogram of values between 2250
and 3000.  Notice that the histogram shows the appearance of data
values given along the data-value axis, currently just grey
intensities.  Had we entered ! to parameter NDF, a ramp would appear
rather than the histogram. Below the histogram are two rows of 16
enumerated colours and grey levels.  The bottom line is the standard
palette, as would be given by command PALDEF, and an adjustable
upper line. To manipulate the colour table (and hence generate a new
lookup table) we select palette colours and data-value ranges.
First we want to add some colours of our own to the palette. 

We first add a named colour, sienna, to the palette, followed by a
pale yellow given as RGB intensities.  We try Violetred, but don't
like it so the previous grey value is restored.  Orchid is paler
than Violetred and more like what we want.  A null ends the loop.
Note that once you have completed this section you cannot add more
colours to the palette.  The current RGB is given so minor
adjustments can be made.  Also you don't have to add palette colours
in numerical order.
 
     Now you may add to the predefined palette. Numbers 16 to 31, are
     available. 
     Type ! to complete the modifications. 
     PALNUM - Number of the palette entry to be modified /16/ > 
     The current RGB is 0,0,0. 
     COLOUR - New palette colour > sienna 
     OK - Accept this colour (Y/N)? /NO/ > y 
     PALNUM - Number of the palette entry to be modified /17/ > 
     The current RGB is 6.666667E-02,6.666667E-02,6.666667E-02. 
     COLOUR - New palette colour > 1.0,1.0,0.3 
     OK - Accept this colour (Y/N)? /NO/ > y 
     PALNUM - Number of the palette entry to be modified /18/ > 
     The current RGB is 0.1333333,0.1333333,0.1333333. 
     COLOUR - New palette colour > violetred 
     OK - Accept this colour (Y/N)? /NO/ > 
     PALNUM - Number of the palette entry to be modified /18/ > 
     The current RGB is 0.1333333,0.1333333,0.1333333. 
     OUR - New palette colour > orchid 
     OK - Accept this colour (Y/N)? /NO/ > y 
     PALNUM - Number of the palette entry to be modified /19/ > ! 
 
Now we change the colour table.  Notice the appearance of the histogram
alters.  Between 2300 and 2380 the colour smoothly varies from blue to
orchid. (We tried a narrower range but did not like it.)  Next a
block of sienna represents values in the range 2375--2400.  Notice that
the order of the colours matters, c.f. the 2500--2600 range
where 2500 appears pale yellow and 2600 is red.  A null ends the 
manipulation.
 
     Now you may interactively change the lookup table (LUT). You
     give ranges of data values (that map to LUT pens) to be
     assigned colours obtained by interpolation of pairs of numbered
     colours selected from the palette.  Type ! to complete the
     creation of the LUT. 

     VALRANGE - Data-value range to be assigned colours > 2300,2350 
     COLRANGE - Select one or two colours from the palette > 4,18 

     VALRANGE - Data-value range to be assigned colours > 2300,2380 
     COLRANGE - Select one or two colours from the palette > 4,18 
  
     VALRANGE - Data-value range to be assigned colours > 2375,2400 
     COLRANGE - Select one or two colours from the palette > 16 
  
     VALRANGE - Data-value range to be assigned colours > 2900,3000 
     COLRANGE - Select one or two colours from the palette > 6 
  
     VALRANGE - Data-value range to be assigned colours > 2500,2600 
     COLRANGE - Select one or two colours from the palette > 17,2
  
     VALRANGE - Data-value range to be assigned colours > ! 
 
Finally, we save the lookup table in an NDF called YUK, but not the
palette.  The original palette is restored.
 
     Type the null character, !, if the created LUT is not to be saved. 
     OUTLUT - NDF to save the lookup table > YUK 
     OUTPAL - NDF to save the palette /!/ > 
 
2 Palette
There are four commands for controlling the palette all beginning
PAL. If you inherit the image display after a non-KAPPA user or
after a device reset, you will probably have to reset the palette.
You can do this either by loading the default palette---black,
white, the primary then secondary colours, and eight equidistant
grey levels---with the command PALDEF; or load a palette you've
created yourself via PALREAD.  You modify the palette by changing
individual colours within it using PALENTRY.  The colour
specification can be a named colour (see topic "Colour_Set" for a
list), or RGB intensities.  For example,
 
     % palentry 1 Skyblue
     % palentry 14 [1.0,1.0,0.3]
 
would make palette index 1 sky blue and index 14 a pale yellow.
Once you have a palette you like, save it in an NDF with PALSAVE.
IDSTATE reports the current palette colours by name, picking the
nearest named colour from the standard colour set given in
"Colour_Set".

The palette has limited direct use in KAPPA so far, but it is
expected to grow as more applications support different colouring
of the components of a plot.  One example, is in DISPLAY where you
can have a coloured border for effect (as seen on television news
programmes).  The colour of the border is selected from the palette
or the nearest colour in the palette is used.

Indirectly, the appearance of existing plots may be changed.
Palette entry 0 is the background colour, and entries 1--5
correspond to SGS pens or PGPLOT colour indices of the same number.
By choosing a palette colour equal to the background colour,
features may be `erased'.

Note that X-windows overlays only have one colour, and so do not
have a palette.

1 COLLAPSE
Reduce the number of axes in an N-dimensional NDF by compressing it
along a nominated axis.

Usage:

   collapse in out axis [low] [high] [estimator] [wlim]

Description:

   This application collapses a nominated axis of an N-dimensional NDF,
   producing an output NDF with one fewer axes than the input NDF. A
   specified range of axis values can be used instead of the whole axis
   (see parameters LOW and HIGH).

   For each output pixel, all corresponding input pixel values between
   the specified bounds of the the nominated axis to be collapsed are
   combined together using either a mean, mode or median estimator to
   produce the output pixel value.

   Possible uses include such things as collapsing a range of
   wavelength planes in a 3-D RA/DEC/Wavelength cube to produce a
   single 2-D RA/DEC image, or collapsing a range of slit positions in
   a 2-D slit position/wavelength image to produce a 1-D wavelength
   array
2 Parameters
For information on individual parameters, select from the list below:
3 AXIS
AXIS = LITERAL (Read)
   The axis along which to collapse the NDF. This can be specified
   by its integer index within the current Frame of the input
   NDF (in the range 1 to the number of axes in the current Frame),
   or by its symbol string. A list of acceptable values is displayed
   if an illegal value is supplied. If the axes of the current Frame
   are not parallel to the NDF pixel axes, then the pixel axis which
   is most nearly parallel to the specified current Frame axis will
   be used.
3 ESTIMATOR
ESTIMATOR = LITERAL (Read)
   The method to use for estimating the output pixel values.  It
   can be either "Mean", "Mode" or "Median". ["Mean"]
3 HIGH
HIGH = LITERAL (Read)
   A value for the axis specified by parameter AXIS. For example,
   if AXIS is 3 and the current Frame of the input NDF has axes
   RA/DEC/Wavelength, then a wavelength value should be supplied.
   If, on the other hand, the current Frame in the NDF was the PIXEL
   Frame, then a pixel co-ordinate value would be required for the
   third axis (note, the pixel with index I covers a range of pixel
   co-ordinates from (I-1) to I). Together with parameter LOW, this
   parameter gives the range of axis values to be compressed. Note,
   HIGH and LOW should not be equal since. If a null value (!) is
   supplied for either HIGH or LOW, the entire range of the axis
   is collapsed. [!]
3 IN
IN  = NDF (Read)
   The input NDF.
3 LOW
LOW = LITERAL (Read)
   A value for the axis specified by parameter AXIS. For example,
   if AXIS is 3 and the current Frame of the input NDF has axes
   RA/DEC/Wavelength, then a wavelength value should be supplied.
   If, on the other hand, the current Frame in the NDF was the PIXEL
   Frame, then a pixel co-ordinate value would be required for the
   third axis (note, the pixel with index I covers a range of pixel
   co-ordinates from (I-1) to I). Together with parameter HIGH, this
   parameter gives the range of axis values to be compressed. Note,
   LOW and HIGH should not be equal since. If a null value (!) is
   supplied for either LOW or HIGH, the entire range of the axis
   is collapsed. [!]
3 OUT
OUT = NDF (Write)
   The output NDF.
3 TITLE
TITLE = LITERAL (Read)
   Title for the output NDF structure.  A null value (!)
   propagates the title from the input NDF to the output NDF. [!]
3 WLIM
WLIM = _REAL (Read)
   If the input NDF contains bad pixels, then this parameter
   may be used to determine the number of good pixels which must
   be present within the range of collapsed input pixels before a
   valid output pixel is generated. It can be used, for example, to
   prevent output pixels from being generated in regions where there
   are relatively few good pixels to contribute to the collapsed
   result.

   WLIM specifies the minimum fraction of good pixels which must
   be present in order to generate a good output pixel. If this
   specified minimum fraction of good input pixels is not present,
   then a bad output pixel will result, otherwise an good output
   value will be calculated. The value of this parameter should lie
   between 0.0 and 1.0 (the actual number used will be rounded up if
   necessary to correspond to at least 1 pixel). [0.3]
2 Examples
collapse cube slab lambda 4500 4550
   The current Frame in the input 3-dimensional NDF called cube has
   axes with labels "RA", "DEC" and "Lambda", with the lambda axis
   being parallel to the third pixel axis. The above command
   extracts a slab of the input cube between wavelengths 4500 and
   4550 Angstroms, and collapses this slab into a single
   2-dimensional output NDF called slab with RA and DEC axes. Each
   pixel in the output NDF is the mean of the corresponding input
   pixels with wavelengths between 4500 and 4550 Angstroms.

collapse cube slab 3 4500 4550
   The same as above except the axis to collapse along is specified
   by index (3) rather than label (lambda).

collapse cube slab 3 101.0 134.0
   This is the same as the above examples, except that the current
   Frame in the input NDF has been set to the PIXEL Frame (using
   WCSFRAME), and so the high and low axis values are specified in
   pixel co-ordinates instead of Angstroms. Note the difference
   between floating point pixel co-ordinates, and integer pixel
   indices (for instance the pixel with index 10 extends from pixel
   co-ordinate 9.0 to pixel co-ordinate 10.0).

collapse cube slab 3 low=99.0 high=100.0
   This is the same as the above examples, except that a single
   pixel plane in the cube (pixel 100) is used to create the output
   NDF. Following the usual definition of pixel co-ordinates, pixel
   100 extends from pixel co-ordinate 99.0 to pixel co-ordinate
   100.0. So the given HIGH and LOW values encompass the single
   pixel plane at pixel 100.
2 Notes
-  The collapse is always performed along one of the pixel axes,
even if the current Frame in the input NDF is not the PIXEL Frame.
Special care should be taken if the current Frame axes are not
parallel to the pixel axes. The algorithm used to choose the pixel axis
and the range of values to collapse along this pixel axis proceeds as
follows:

The current Frame co-ordinates of the central pixel in the input
NDF are determined (or some other point if the co-ordinates of the
central pixel are undefined). Two current Frame positions are then
generated by substituting in turn into this central position each
of the HIGH and LOW values for the current Frame axis specified by
parameter AXIS. These two current Frame positions are transformed
into pixel co-ordinates, and the projections of the vector joining
these two pixel positions onto the pixel axes are found. The pixel
axis with the largest projection is selected as the collapse axis,
and the two end points of the projection define the range of axis
values to collapse.
2 Related_Applications
   KAPPA: WCSFRAME, COMPAVE, COMPICK, COMPADD.
2 Authors
DSB: David S. Berry (STARLINK)
2 History
 31-AUG-2000 (DSB):
    Original version.

 {enter_further_changes}
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, VARIANCE,
   LABEL, TITLE, UNITS, WCS and HISTORY components of the input NDF and
   propagates all extensions.  QUALITY is not propagated.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.

   -  Any number of NDF dimensions is supported.

1 COMPADD
Reduces the size of an NDF by adding values in rectangular boxes.

Usage:

   compadd in out compress [wlim]

Description:

   This application takes an NDF data structure and reduces it in
   size by integer factors along each dimension.  The compression
   is achieved by adding the values of the input NDF within
   non-overlapping `rectangular' boxes whose dimensions are the
   compression factors.  The additions may be normalised to correct
   for any bad values present in the input NDF. The exact placement of
   the boxes can be controlled using parameter ALIGN.
2 Parameters
For information on individual parameters, select from the list below:
3 ALIGN
ALIGN = LITERAL (Read)
   This parameter controls the placement of the compression boxes
   within the input NDF (also see parameter TRIM). It can take any
   of the following values:

   - "ORIGIN" --- The compression boxes are placed so that the
   origin of the pixel co-ordinate Frame in the input NDF
   corresponds to a corner of a compression box. This results in
   the pixel origin being retain in the output NDF. For instance,
   if a pair of 2-dimensional images which have previously been
   aligned in pixel co-ordinates are compressed, then using this
   option ensures that the compressed images will also be aligned
   in pixel co-ordinates.

   - "FIRST" --- The compression boxes are placed so that the
   first pixel in the input NDF (for instance, the bottom left
   pixel in a 2-dimensional image) corresponds to the first pixel
   in a compression box. This can result in the pixel origin being
   shifted by up to one compression box in the output image. Thus,
   images which were previously aligned in pixel co-ordinates may
   not be aligned after compression. You may want to use this option
   if you are using a very large box to reduce the number of
   dimensions in the data (for instance summing across the entire
   width of an image to produce a 1-dimensional array).

   - "LAST" --- The compression boxes are placed so that the
   last pixel in the input NDF (for instance, the top right
   pixel in a 2-dimensional image) corresponds to the last pixel
   in a compression box. See the "FIRST" option above for further
   comments.
                                                        ["ORIGIN"]
3 AXWEIGHT
AXWEIGHT = _LOGICAL (Read)
   When there is an AXIS variance array present in the NDF and
   AXWEIGHT=TRUE the application forms weighted averages of the
   axis centres using the variance.  For all other conditions
   the non-bad axis centres are given equal weight during the
   averaging to form the output axis centres. [FALSE]
3 COMPRESS
COMPRESS( ) = _INTEGER (Read)
   Linear compression factors to be used to create the output
   NDF.  There should be one for each dimension of the NDF.  If
   fewer are supplied the last value in the list of compression
   factors is given to the remaining dimensions.  Thus if a
   uniform compression is required in all dimensions, just one
   value need be entered.  All values are constrained to be in
   the range one to the size of its corresponding dimension.  The
   suggested default is the current value.
3 IN
IN  = NDF (Read)
   The NDF structure to be reduced in size.
3 NORMAL
NORMAL = _LOGICAL (Read)
   When there are bad pixels present in the summation box these
   are ignored.  Therefore a simple addition of the input-array
   component's values will yield a result discordant with
   neighbouring output pixels that were formed from summation of
   all the pixels in the box.  When NORMAL=TRUE the output values
   are normalised: the addition is multiplied by the ratio of the
   number of pixels in the box to the number of good pixels
   therein to arrive at the output value.  When NORMAL=FALSE the
   output values are always just the sum of the good pixels.
   [TRUE]
3 OUT
OUT = NDF (Write)
   NDF structure to contain compressed version of the input NDF.
3 PRESERVE
PRESERVE = _LOGICAL (Read)
   If the input data type is to be preserved on output then this
   parameter should be set true.   However, this may result in
   overflows for integer types and hence additional bad values
   written to the output NDF.  If this parameter is set false
   then the output data type will be one of _REAL or _DOUBLE,
   depending on the input type. [FALSE]
3 TITLE
TITLE = LITERAL (Read)
   Title for the output NDF structure.  A null value (!)
   propagates the title from the input NDF to the output NDF. [!]
3 TRIM
TRIM = _LOGICAL (Read)
   If parameter TRIM is set TRUE, the output NDF only contains data
   for compression boxes which are entirely contained within the
   input NDF. Any pixels around the edge of the input NDF which are
   not contained within a compression box are ignored. If TRIM is set
   FALSE, the output NDF contains data for all compression boxes which
   have any overlap with the input NDF.  All pixels outside the
   bounds of the NDF are assumed to be bad. That is, any boxes which
   extend beyond the bounds of the input NDF are padded with bad
   pixels. See also parameter ALIGN. [current value]
3 WLIM
WLIM = _REAL (Read)
   If the input NDF contains bad pixels, then this parameter
   may be used to determine the number of good pixels which must
   be present within the addition box before a valid output
   pixel is generated.  It can be used, for example, to prevent
   output pixels from being generated in regions where there are
   relatively few good pixels to contribute to the smoothed
   result.

   WLIM specifies the minimum fraction of good pixels which must
   be present in the summation box in order to generate a good
   output pixel.  If this specified minimum fraction of good
   input pixels is not present, then a bad output pixel will
   result, otherwise the output value will be the sum of the
   good values.  The value of this parameter should lie between
   0.0 and 1.0 (the actual number used will be rounded up if
   necessary to correspond to at least 1 pixel). [0.3]
2 Examples
compadd cosmos galaxy 4
   This compresses the NDF called cosmos summing four times in
   each dimension, and stores the reduced data in the NDF called
   galaxy.  Thus if cosmos is two-dimensional, this command
   would result in a sixteen-fold reduction in the array
   components.

compave cosmos profile [10000,1] wlim=0 align=first trim=no
   This compresses the 2-dimensional NDF called cosmos to produce a
   1-dimensional NDF called profile. This is done using a
   compression box which is 1 pixel high, but which is wider than
   the whole input image. Each pixel in the output NDF thus
   corresponds to the sum of the corresponding row in the
   input image. WLIM is set to zero to ensure that bad pixels
   are ignored. ALIGN is set to FIRST so that each compression box
   is flush with the left edge of the input image. TRIM is set to
   NO so that compression boxes which extend outside the bounds of
   the input image (which will be all of them if the input image is
   narrower than 10000 pixels) are retained in the output NDF.

compadd cosmos galaxy 4 wlim=1.0
   This compresses the NDF called cosmos adding four times in
   each dimension, and stores the reduced data in the NDF called
   galaxy.  Thus if cosmos is two-dimensional, this command
   would result in a sixteen-fold reduction in the array
   components.  If a summation box contains any bad pixels, the
   output pixel is set to bad.

compadd cosmos galaxy 4 0.0 preserve
   As above except that a summation box need only contains a
   single non-bad pixels for the output pixel to be good, and
   galaxy's array components will have the same as those in
   cosmos.

compadd cosmos galaxy [4,3] nonormal title="COSMOS compressed"
   This compresses the NDF called cosmos adding four times in
   the first dimension and three times in higher dimensions, and
   stores the reduced data in the NDF called galaxy.  Thus if
   cosmos is two-dimensional, this command would result in a
   twelve-fold reduction in the array components.  Also, if there
   are bad pixels there will be no normalisation correction for the
   missing values.  The title of the output NDF is "COSMOS
   compressed".

compadd in=arp244 compress=[1,1,3] out=arp244cs
   Suppose arp244 is a huge NDF storing a spectral-line data
   cube, with the third dimension being the spectral axis.
   This command compresses arp244 in the spectral dimension,
   adding every three pixels to form the NDF called arp244cs.
2 Notes
-  The axis centres and variances are averaged, whilst the widths
are summed and always normalised for bad values.
2 Related_Applications
   KAPPA: BLOCK, COMPAVE, COMPICK, PIXDUPE, SQORST, TRANSFORMER;
   Figaro: ISTRETCH, YSTRACT.
2 Authors
MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 1991 November 30 (MJC):
    Original version.

 1995 January 11 (MJC):
    Made TITLE propagate from the input NDF.  Used PSX for
    workspace.

 27-FEB-1998 (DSB):
    Type of local variable AXWT corrected from INTEGER to LOGICAL.

 10-JUN-1998 (DSB):
    Propagate WCS component. Ensure each output dimension is at least
    one pixel long.

 12-OCT-1998 (DSB):
    Changed the way in which the bounds of the output image are
    determined so that pixel origin information is retained.

 1998 October 23 (MJC):
    Fixed bug for 1-dimensional data with axes.  It now uses the
    the actual dimensionality as opposed to 2, as needed by the
    resampling tasks.

 9-DEC-1999 (DSB):
    Corrected propagation of WCS (an erroneous shift was previously
    introduced if the lower bounds of the input NDF were not (1,1) ).

 25-APR-2000 (DSB):
    Added parameters TRIM and ALIGN.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, VARIANCE,
   LABEL, TITLE, UNITS, WCS and HISTORY components of the input NDF and
   propagates all extensions.  QUALITY is not processed since it is
   a series of flags, not numerical values.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.

   -  Any number of NDF dimensions is supported.

1 COMPAVE
Reduces the size of an NDF by averaging values in rectangular
boxes.

Usage:

   compave in out compress [wlim]

Description:

   This application takes an NDF data structure and reduces it in
   size by integer factors along each dimension.  The compression
   is achieved by averaging the input NDF within non-overlapping
   `rectangular' boxes whose dimensions are the compression factors.
   The averages may be weighted when there is a variance array
   present. The exact placement of the boxes can be controlled using
   parameter ALIGN.
2 Parameters
For information on individual parameters, select from the list below:
3 ALIGN
ALIGN = LITERAL (Read)
   This parameter controls the placement of the compression boxes
   within the input NDF (also see parameter TRIM). It can take any
   of the following values:

   - "ORIGIN" --- The compression boxes are placed so that the
   origin of the pixel co-ordinate Frame in the input NDF
   corresponds to a corner of a compression box. This results in
   the pixel origin being retain in the output NDF. For instance,
   if a pair of 2-dimensional images which have previously been
   aligned in pixel co-ordinates are compressed, then using this
   option ensures that the compressed images will also be aligned
   in pixel co-ordinates.

   - "FIRST" --- The compression boxes are placed so that the
   first pixel in the input NDF (for instance, the bottom left
   pixel in a 2-dimensional image) corresponds to the first pixel
   in a compression box. This can result in the pixel origin being
   shifted by up to one compression box in the output image. Thus,
   images which were previously aligned in pixel co-ordinates may
   not be aligned after compression. You may want to use this option
   if you are using a very large box to reduce the number of
   dimensions in the data (for instance averaging across the entire
   width of an image to produce a 1-dimensional array).

   - "LAST" --- The compression boxes are placed so that the
   last pixel in the input NDF (for instance, the top right
   pixel in a 2-dimensional image) corresponds to the last pixel
   in a compression box. See the "FIRST" option above for further
   comments.
                                                        ["ORIGIN"]
3 AXWEIGHT
AXWEIGHT = _LOGICAL (Read)
   When there is an AXIS variance array present in the NDF and
   AXWEIGHT=TRUE the application forms weighted averages of the
   axis centres using the variance.  For all other conditions
   the non-bad axis centres are given equal weight during the
   averaging to form the output axis centres. [FALSE]
3 COMPRESS
COMPRESS( ) = _INTEGER (Read)
   Linear compression factors to be used to create the output
   NDF.  There should be one for each dimension of the NDF.  If
   fewer are supplied the last value in the list of compression
   factors is given to the remaining dimensions.  Thus if a
   uniform compression is required in all dimensions, just one
   value need be entered. The suggested default is the current value.
3 IN
IN  = NDF (Read)
   The NDF structure to be reduced in size.
3 OUT
OUT = NDF (Write)
   NDF structure to contain compressed version of the input NDF.
3 PRESERVE
PRESERVE = _LOGICAL (Read)
   If the input data type is to be preserved on output then this
   parameter should be set true.   However, this will probably
   result in a loss of precision.  If this parameter is set false
   then the output data type will be one of _REAL or _DOUBLE,
   depending on the input type. [FALSE]
3 TITLE
TITLE = LITERAL (Read)
   Title for the output NDF structure.  A null value (!)
   propagates the title from the input NDF to the output NDF. [!]
3 TRIM
TRIM = _LOGICAL (Read)
   If parameter TRIM is set TRUE, the output NDF only contains data
   for compression boxes which are entirely contained within the
   input NDF. Any pixels around the edge of the input NDF which are
   not contained within a compression box are ignored. If TRIM is set
   FALSE, the output NDF contains data for all compression boxes which
   have any overlap with the input NDF. All pixels outside the
   bounds of the NDF are assumed to be bad. That is, any boxes which
   extend beyond the bounds of the input NDF are padded with bad
   pixels. See also parameter ALIGN. [current value]
3 WEIGHT
WEIGHT = _LOGICAL (Read)
   When there is a variance array present in the NDF and
   WEIGHT=TRUE the application forms weighted averages of the
   data array using the variance.  For all other conditions
   the non-bad pixels are given equal weight during averaging.
   [FALSE]
3 WLIM
WLIM = _REAL (Read)
   If the input NDF contains bad pixels, then this parameter
   may be used to determine the number of good pixels which must
   be present within the averaging box before a valid output
   pixel is generated.  It can be used, for example, to prevent
   output pixels from being generated in regions where there are
   relatively few good pixels to contribute to the smoothed
   result.

   WLIM specifies the minimum fraction of good pixels which must
   be present in the averaging box in order to generate a good
   output pixel.  If this specified minimum fraction of good
   input pixels is not present, then a bad output pixel will
   result, otherwise an averaged output value will be calculated.
   The value of this parameter should lie between 0.0 and 1.0
   (the actual number used will be rounded up if necessary to
   correspond to at least 1 pixel). [0.3]
2 Examples
compave cosmos galaxy 4
   This compresses the NDF called cosmos averaging four times in
   each dimension, and stores the reduced data in the NDF called
   galaxy.  Thus if cosmos is two-dimensional, this command
   would result in a sixteen-fold reduction in the array
   components.

compave cosmos profile [10000,1] wlim=0 align=first trim=no
   This compresses the 2-dimensional NDF called cosmos to produce a
   1-dimensional NDF called profile. This is done using a
   compression box which is 1 pixel high, but which is wider than
   the whole input image. Each pixel in the output NDF thus
   corresponds to the average of the corresponding row in the
   input image. WLIM is set to zero to ensure that bad pixels
   are ignored. ALIGN is set to FIRST so that each compression box
   is flush with the left edge of the input image. TRIM is set to
   NO so that compression boxes which extend outside the bounds of
   the input image (which will be all of them if the input image is
   narrower than 10000 pixels) are retained in the output NDF.

compave cosmos galaxy 4 wlim=1.0
   This compresses the NDF called cosmos averaging four times in
   each dimension, and stores the reduced data in the NDF called
   galaxy.  Thus if cosmos is two-dimensional, this command
   would result in a sixteen-fold reduction in the array
   components.  If an averaging box contains any bad pixels, the
   output pixel is set to bad.

compave cosmos galaxy 4 0.0 preserve
   As above except that an averaging box need only contains a
   single non-bad pixels for the output pixel to be good, and
   galaxy's array components will have the same as those in
   cosmos.

compave cosmos galaxy [4,3] weight title="COSMOS compressed"
   This compresses the NDF called cosmos averaging four times in
   the first dimension and three times in higher dimensions, and
   stores the reduced data in the NDF called galaxy.  Thus if
   cosmos is two-dimensional, this command would result in a
   twelve-fold reduction in the array components.  Also, if there
   is a variance array present it is used to form weighted means
   of the data array.   The title of the output NDF is "COSMOS
   compressed".

compave in=arp244 compress=[1,1,3] out=arp244cs
   Suppose arp244 is a huge NDF storing a spectral-line data
   cube, with the third dimension being the spectral axis.
   This command compresses arp244 in the spectral dimension,
   averaging every three pixels to form the NDF called arp244cs.
2 Notes
-  The axis centres and variances are averaged, whilst the widths
are summed and always normalised for bad values.
2 Related_Applications
   KAPPA: BLOCK, COMPADD, COMPICK, PIXDUPE, SQORST, TRANSFORMER;
   Figaro: ISTRETCH.
2 Authors
MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 1991 November 27 (MJC):
    Original version.

 1995 January 11 (MJC):
    Made TITLE propagate from the input NDF.  Used PSX for
    workspace.

 27-FEB-1998 (DSB):
    Type of local variable AXWT corrected from INTEGER to LOGICAL.

 10-JUN-1998 (DSB):
    Propagate WCS component. Ensure each output dimension is at least
    one pixel long.

 12-OCT-1998 (DSB):
    Changed the way in which the bounds of the output image are
    determined so that pixel origin information is retained.

 1998 October 23 (MJC):
    Fixed bug for 1-dimensional data with axes.  It now uses the
    the actual dimensionality as opposed to 2, as needed by the
    resampling tasks.

 9-DEC-1999 (DSB):
    Corrected propagation of WCS (an erroneous shift was previously
    introduced if the lower bounds of the input NDF were not (1,1) ).

 25-APR-2000 (DSB):
    Added parameters TRIM and ALIGN.

 {enter_further_changes}
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, VARIANCE,
   LABEL, TITLE, UNITS, WCS and HISTORY components of the input NDF and
   propagates all extensions.  QUALITY is not processed since it is
   a series of flags, not numerical values.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.

   -  Any number of NDF dimensions is supported.

1 COMPICK
Reduces the size of an NDF by picking equally spaced pixels.

Usage:

   compick in out compress [origin]

Description:

   This application takes an NDF data structure and reduces it in
   size by integer factors along each dimension.  The input NDF is
   sampled at these constant compression factors or intervals along
   each dimension, starting from a defined origin, to form an output
   NDF structure.  The compression factors may be different in each
   dimension.
2 Parameters
For information on individual parameters, select from the list below:
3 COMPRESS
COMPRESS( ) = _INTEGER (Read)
   Linear compression factors to be used to create the output
   NDF.  There should be one for each dimension of the NDF.  If
   fewer are supplied the last value in the list of compression
   factors is given to the remaining dimensions.  Thus if a
   uniform compression is required in all dimensions, just one
   value need be entered.  All values are constrained to be in
   the range one to the size of its corresponding dimension.  The
   suggested default is the current value.
3 IN
IN  = NDF (Read)
   The NDF structure to be reduced in size.
3 ORIGIN
ORIGIN( ) = _INTEGER (Read)
   The pixel indices of the first pixel to be selected.
   Thereafter the selected pixels will be spaced equally by
   COMPRESS() pixels.  The origin must lie within the first
   selection intervals, therefore the ith origin must be in the
   range LBND(i) to LBND(i)+COMPRESS(i)-1, where LBND(i) is the
   lower bound of the ith dimension.  The suggested default is
   the first array element.
3 OUT
OUT = NDF (Write)
   NDF structure to contain compressed version of the input NDF.
3 TITLE
TITLE = LITERAL (Read)
   Title for the output NDF structure.  A null value (!)
   propagates the title from the input NDF to the output NDF. [!]
2 Examples
compick cosmos galaxy 4
   This compresses the NDF called cosmos selecting every fourth
   array element along each dimension, starting from the first
   element in the NDF, and stores the reduced data in the NDF
   called galaxy.

compick cosmos galaxy 4 [3,2]
   This compresses the two-dimensional NDF called cosmos
   selecting every fourth array element along each dimension,
   starting from the pixel index (3,2), and stores the
   reduced data in the NDF called galaxy.

compick in=arp244 compress=[1,1,3] out=arp244cs
   Suppose arp244 is a huge NDF storing a spectral-line data
   cube, with the third dimension being the spectral axis.
   This command compresses arp244 in the spectral dimension,
   sampling every third pixel, starting from the first wavelength
   at each image position, to form the NDF called arp244cs.
2 Notes
-  The compression is centred on the origin of the pixel co-ordinate
Frame. That is, if a position has a value p(i) on the i'th pixel
co-ordinate axis of the input NDF, then it will have position
p(i)/COMPRESS(i) on the corresponding axis of the output NDF. The
pixel index bounds of the output NDF are chosen accordingly.
2 Related_Applications
   KAPPA: BLOCK, COMPADD, COMPAVE, PIXDUPE, SQORST, TRANSFORMER;
   Figaro: ISTRETCH.
2 Authors
MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 1991 November 27 (MJC):
    Original version.

 1995 January 11 (MJC):
    Made TITLE propagate from the input NDF.

 10-JUN-1998 (DSB):
    Propagate WCS component. Ensure each output dimension is at least
    one pixel long.

 12-OCT-1998 (DSB):
    Changed the way in which the bounds of the output image are
    determined so that pixel origin information is retained.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   VARIANCE, LABEL, TITLE, UNITS, WCS and HISTORY components of the
   input NDF and propagates all extensions.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.

   -  Any number of NDF dimensions is supported.

1 CONTOUR
Contours a 2-d NDF.

Usage:

   contour ndf [comp] mode ncont [key] [device]
     { firstcnt=? stepcnt=?
     { heights=?
     { percentiles=?
     mode

Description:

   This application produces a contour map of a 2-dimensional NDF on
   the current graphics device, with single-pixel resolution. Contour
   levels can be chosen automatically in various ways, or specified
   explicitly (see parameter MODE). In addition, this application can
   also draw an outline around either the whole data array, or around
   the good pixels in the data array (set MODE to "Bounds" or "Good").

   The plot is produced within the current graphics database picture,
   and may be aligned with an existing DATA picture if the existing
   picture contains suitable co-ordinate Frame information (see
   parameter CLEAR).

   The appearance of each contour can be controlled in several ways. The
   pens used can be rotated automatically (see parameter PENROT). Contours
   below a given threshold value can be drawn dashed (see parameter DASHED).
   Alternatively, the appearance of each contour can be set explicitly
   (see parameter PENS).

   Annotated axes can be produced (see parameter AXES), and the appearance
   of the axes can be controlled in detail (see parameter STYLE). The
   axes show co-ordinates in the current co-ordinate Frame of the supplied
   NDF.

   A list of the contour levels can be displayed to the right of the
   contour map (see parameter KEY). The appearance and position of this
   key may be controlled using parameters KEYSTYLE and KEYPOS.
2 Parameters
For information on individual parameters, select from the list below:
3 AXES
AXES = _LOGICAL (Read)
   TRUE if labelled and annotated axes are to be drawn around the
   contour map, showing the current co-ordinate Frame of the
   supplied NDF. The appearance of the axes can be controlled using
   the STYLE parameter. [TRUE]
3 CLEAR
CLEAR = _LOGICAL (Read)
   TRUE if the graphics device is to be cleared before displaying
   the contour map. If you want the contour map to be drawn over
   the top of an existing DATA picture, then set CLEAR to FALSE. The
   contour map will then be drawn in alignment with the displayed
   data. If possible, alignment occurs within the current co-ordinate
   Frame of the NDF. If this is not possible, (for instance if
   suitable WCS information was not stored with the existing DATA
   picture), then alignment is attempted in PIXEL
   co-ordinates. If this is not possible, then alignment is
   attempted in GRID co-ordinates. If this is not possible, then
   alignment is attempted in the first suitable Frame found in the NDF
   irrespective of its domain. A message is displayed indicating the
   domain in which alignment occurred. If there are no suitable Frames
   in the NDF then an error is reported. [TRUE]
3 COMP
COMP = LITERAL (Read)
   The NDF component to be contoured.  It may be "Data",
   "Quality", "Variance", or "Error" (where "Error" is an
   alternative to "Variance" and causes the square root of the
   variance values to be displayed).  If
   "Quality" is specified, then the quality values are treated as
   numerical values (in the range 0 to 255). ["Data"]
3 DASHED
DASHED = _REAL (Read)
   The height below which the contours will be drawn with dashed
   lines (if possible).  A null value (!) results in contours being
   drawn with the styles specified by parameters PENS, PENROT and
   STYLE. [!]
3 DEVICE
DEVICE = DEVICE (Read)
   The plotting device. [current image-display device]
3 FAST
FAST = _LOGICAL (Read)
   If TRUE, then a faster, but in certain cases less accurate, method
   is used to draw the contours. In fast mode, contours may be
   incorrectly placed on the display if the mapping between graphics
   co-ordinates and the current co-ordinate Frame of the supplied NDF
   has any discontinuities, or is strongly non-linear. This may be
   the case, for instance, when displaying all-sky maps on top of
   each other. [TRUE]
3 FILL
FILL = _LOGICAL (Read)
   The contour plot normally has square pixels, in other words
   a specified length along each axis corresponds to the same number
   of pixels.  However, for images with markedly different
   dimensions this default behaviour may not be suitable or give
   the clearest plot.  When FILL is TRUE, the square-pixel
   constraint is relaxed and the contour plot is the largest
   possible within the current picture.  When FILL is FALSE, the
   pixels are square.  [FALSE]
3 FIRSTCNT
FIRSTCNT = _REAL (Read)
   Height of the first contour (Linear and Magnitude modes).
3 HEIGHTS
HEIGHTS() = _REAL (Read)
   The required contour levels (Free mode).
3 KEY
KEY = _LOGICAL (Read)
   TRUE if a key of the contour level versus pixel value is to be
   produced. The appearance of this key can be controlled using
   parameter KEYSTYLE, and its position can be controlled using
   parameter KEYPOS. [TRUE]
3 KEYPOS
KEYPOS() = _REAL (Read)
   Two values giving the position of the key. The first value gives
   the gap between the right hand edge of the contour map and the left
   hand edge of the key (0.0 for no gap, 1.0 for the largest gap). The
   second value gives the vertical position of the top of the key (1.0
   for the highest position, 0.0 for the lowest). If the second value
   is not given, the top of the key is placed level with the top of the
   contour map. Both values should be in the range 0.0 to 1.0. If a
   key is produced, then the right hand margin specified by parameter
   MARGIN is ignored. [current value]
3 KEYSTYLE
KEYSTYLE = GROUP (Read)
   A group of attribute settings describing the plotting style to use
   for the key (see parameter KEY).

   A comma-separated list of strings should be given in which each
   string is either an attribute setting, or the name of a text file
   preceded by an up-arrow character "^". Such text files should
   contain further comma-separated lists which will be read and
   interpreted in the same manner. Attribute settings are applied in
   the order in which they occur within the list, with later settings
   over-riding any earlier settings given for the same attribute.

   Each individual attribute setting should be of the form:

      <name>=<value>

   where <name> is the name of a plotting attribute, and <value> is
   the value to assign to the attribute. Default values will be
   used for any unspecified attributes. All attributes will be
   defaulted if a null value (!) is supplied. See section "Plotting
   Attributes" in SUN/95 for a description of the available
   attributes. Any unrecognised attributes are ignored (no error is
   reported).

   The heading in the key can be changed by setting a value for the
   Title attribute (the supplied heading is split into lines of no more
   than 17 characters). The appearance of the heading is controlled
   by attributes Colour(Title), Font(Title), etc. The appearance of
   the contour indices is controlled by attributes Colour(TextLab),
   Font(TextLab), etc (the synonym Index can be used in place of
   TextLab). The appearance of the contour values is controlled by
   attributes Colour(NumLab), Font(NumLab), etc (the synonym Value
   can be used in place of NumLab). Contour indices are formatted
   using attributes Format(1), Digits(1), etc (the synonym Index can
   be used in place of value 1). Contour values are formatted
   using attributes Format(2), etc (the synonym Value can be used in
   place of the value 2). [current value]
3 LABPOS
LABPOS = _REAL() (Read)
   Only used if parameter MODE is set to "Good" or "Bounds". It
   specifies the position at which to place a label identifying the
   input NDF within the plot. The label is drawn parallel to the
   first pixel axis. Two values should be supplied for LABPOS. The 
   first value specifies the distance in millimetres along the first
   pixel axis from the centre of the bottom left pixel to the left 
   edge of the label. The second value specifies the distance in 
   millimetres along the second pixel axis from the centre of the 
   bottom left pixel to the baseline of the label. If a null (!) 
   value is given, no label is produced. The appearance of the label 
   can be set by using the STYLE parameter (for instance 
   "Size(strings)=2"). [current value]
3 LENGTH
LENGTH() = _REAL (Write)
   On exit this holds the total length in pixels of the contours at each
   selected height.  These values are only computed when parameter STATS
   is TRUE.
3 MARGIN
MARGIN( 4 ) = _REAL (Read)
   The widths of the margins to leave around the contour map for
   axis annotation. The widths should be given as fractions of the
   corresponding dimension of the current picture. The actual margins
   used may be increased to preserve the aspect ratio of the DATA
   picture. Four values may be given, in the order; bottom, right,
   top, left. If fewer than four values are given, extra values are
   used equal to the first supplied value. If these margins are too
   narrow any axis annotation may be clipped. If a null (!) value is
   supplied, the value used is 0.15 (for all edges) if annotated axes
   are being produced, and zero otherwise. See also parameter KEYPOS.
   [current value]
3 MODE
MODE = LITERAL (Read)
   The method used to select the contour levels. The options are:

     - "Area" -- The contours enclose areas of the array for which
     the equivalent radius increases by equal increments.  You
     specify the number of levels.

     - "Automatic" -- The contour levels are equally spaced between
     the maximum and minimum pixel values in the array.  You supply
     the number of contour levels.

     - "Bounds" -- A single "contour" is drawn representing the
     bounds of the input array. A label may also be added (see
     parameter LABPOS).

     - "Equalised" -- You define the number of equally spaced
     percentiles.

     - "Free" -- You specify a series of contour values explicitly.

     - "Good" -- A single "contour" is drawn outlining the good pixel
     values. A label may also be added (see parameter LABPOS).

     - "Linear" -- You define the number of contours, the start
     contour level and linear step between contours.

     - "Magnitude" -- You define the number of contours, the start
     contour level and step between contours.  The step size is in
     magnitudes so the nth contour is dex(-0.4*(n-1)*step) times the
     start contour level.

     - "Percentiles" -- You specify a series of percentiles.

   If the contour map is aligned with an existing DATA picture (see
   parameter CLEAR), then only part of the supplied NDF may be
   displayed. In this case, the choice of contour levels is based
   on the data within a rectangular section of the input NDF
   enclosing the existing DATA picture. Data values outside this
   section are ignored.
3 NCONT
NCONT = _INTEGER (Read)
   The number of contours to draw (only required in certain modes).
   It must be between 1 and 50.  If the number is large, the plot
   may be cluttered and take longer to produce. The initial
   suggested default of 6 gives reasonable results.
3 NDF
NDF = NDF (Read)
   NDF structure containing the 2-dimensional image to be
   contoured.
3 NUMBER
NUMBER() = _INTEGER (Write)
   On exit this holds the number of closed contours at each selected
   height. Contours are not closed if they intersect a bad pixel or the
   edge of the image.  These values are only computed when
   parameter STATS is TRUE.
3 PENROT
PENROT = _LOGICAL (Read)
   If TRUE, the plotting pens are cycled through the contours to
   aid identification of the contour heights.  Only accessed if
   pen definitions are not supplied using parameter PENS. [FALSE]
3 PENS
PENS = GROUP (Read)
   A group of strings, separated by semi-colons, each of which specifies
   the appearance of a pen to be used to draw a contour. The first
   string in the group describes the pen to use for the first contour,
   the second string describes the pen for the second contour, etc. If
   there are fewer strings than contours, then the supplied pens are
   cycled through again, starting at the beginning. Each string should
   be a comma-separated list of plotting attributes to be used when drawing
   the contour. For instance, the string "width=0.02,colour=red,style=2"
   produces a thick, red, dashed contour. Attributes which are
   unspecified in a string default to the values implied by parameter
   STYLE. If a null value (!) is given for PENS, then the pens
   implied by parameters PENROT, DASHED and STYLE are used. [!]
3 PERCENTILES
PERCENTILES() = _REAL (Read)
   Contour levels given as percentiles.  The values must lie
   between 0.0 and 100.0. (Percentiles mode).
3 STATS
STATS = _LOGICAL (Read)
   If TRUE, the LENGTH and NUMBER statistics are computed. [FALSE].
3 STEPCNT
STEPCNT = _REAL (Read)
   Separation between contour levels, linear for Linear mode
   and in magnitudes for Magnitude mode.
3 STYLE
STYLE = GROUP (Read)
   A group of attribute settings describing the plotting style to use
   for the contours and annotated axes.

   A comma-separated list of strings should be given in which each
   string is either an attribute setting, or the name of a text file
   preceded by an up-arrow character "^". Such text files should
   contain further comma-separated lists which will be read and
   interpreted in the same manner. Attribute settings are applied in
   the order in which they occur within the list, with later settings
   over-riding any earlier settings given for the same attribute.

   Each individual attribute setting should be of the form:

      <name>=<value>

   where <name> is the name of a plotting attribute, and <value> is
   the value to assign to the attribute. Default values will be
   used for any unspecified attributes. All attributes will be
   defaulted if a null value (!) is supplied. See section "Plotting
   Attributes" in SUN/95 for a description of the available
   attributes. Any unrecognised attributes are ignored (no error is
   reported).

   The appearance of the contours is controlled by the attributes
   Colour(Curves), Width(Curves), etc (the synonym Contours may be
   used in place of Curves). The contour appearance established in
   this way may be modified using parameters PENS, PENROT and DASHED.
   [current value]
3 USEAXIS
USEAXIS = GROUP (Read)
   USEAXIS is only accessed if the current co-ordinate Frame of the
   NDF has more than 2 axes. A group of two strings should be
   supplied specifying the 2 axes which are to be used when annotating
   and aligning the contour map. Each axis can be specified either by
   its integer index within the current Frame (in the range 1 to the
   number of axes in the current Frame), or by its Symbol attribute. A
   list of acceptable values is displayed if an illegal value is
   supplied. If a null (!) value is supplied, the axes with the same
   indices as the 2 significant NDF pixel axes are used. [!]
2 Examples
contour myfile
   Contours the data array in the NDF called myfile on the current
   graphics device.  All other settings are defaulted, so for
   example the current mode for determining heights is used, and
   a key is plotted.

contour taurus1(100:199,150:269,4)
   Contours a 2-dimensional section of the 3-dimensional NDF called
   taurus1 on the current graphics device. The section extends from
   pixel (100,150,4) to pixel (199,269,4).

contour ngc6872 mode=au ncont=5 device=ps_l pens="style=1;style=2"
   Contours the data array in the NDF called ngc6872 on the ps_l
   graphics device.  Five equally spaced contours between the
   maximum and minimum data values are drawn, alternating between
   line styles 1 and 2 (solid and dashed).

contour ndf=ngc6872 mode=au ncont=5 penrot style="^mysty,grid=1"
   As above except that the current graphics device is used, pens
   are cycled automatically, and the appearance of the axes is read
   from text file mysty. The plotting attribute Grid is set
   explicitly to 1 to ensure that a co-ordinate grid is drawn over
   the plot. The text file mysty could, for instance, contain the
   two lines "Title=NGC6872 at 25 microns" and "grid=0". The Title
   setting gives the title to display at the top of the axes. The
   Grid setting would normally prevent a co-ordinate grid being
   drawn, but is over-ridden in this example by the explicit setting
   for Grid which follows the file name.

contour m51 mode=li firstcnt=10 stepcnt=2 ncont=4 keystyle=^keysty
   Contours the data array in the NDF called m51 on the
   current graphics device.  Four contours at heights 10, 12, 14,
   and 16 are drawn.  A key is plotted using the style specified
   in the text file keysty. This file could, for instance, contain
   the two lines "font=3" and "digits(2)=4" to cause all text in
   the key to be drawn using PGPLOT font 3 (an italic font), and
   4 digits to be used when formatting the contour values.

contour ss443 mode=pe percentiles=[80,90,95] stats keypos=0.02
   Contours the data array in the NDF called ss443 on the current
   graphics device.  Contours at heights corresponding to the 80,
   90 and 95 percentiles are drawn.  The key is placed closer
   to the contour map than usual.  Contour statistics are computed.

contour skyflux mode=eq ncont=5 dashed=0 pens='colour=red' noclear
   Contours the data array in the NDF called skyflux on the current
   graphics device.  The contour map is automatically aligned with
   any existing DATA picture, if possible. Contours at heights
   corresponding to the 10, 30, 50, 70 and 90 percentiles (of the
   data within the picture) are drawn in red.  Those contours whose
   values are negative will appear as dashed lines.

contour comp=d nokey penrot style="grid=1,title=My data" \
   Contours the data array in the current NDF on
   the current graphics device using the current method for
   height selection.  No key is drawn.  The appearance of the
   contours cycles every third contour. A co-ordinate grid is
   drawn over the plot, and a title of "My data" is displayed at
   the top.

contour comp=v mode=fr heights=[10,20,40,80] \
   Contours the variance array in the current NDF on the
   current graphics device.  Contours at 10, 20, 40 and 80 are
   drawn.
2 Notes
-  The Title component in the NDF is used as the default title for
the annotated axes. If the NDF does not have a Title component, then
the default title is taken from current co-ordinate Frame stored in the
WCS component of the NDF. This
default may be over-ridden by specifying a value for the Title
attribute using the STYLE parameter.

-  The application stores a number of pictures in the graphics
database in the following order: a FRAME picture containing the
annotated axes, contours, and key; a KEY picture to store
the key if present; and a DATA picture containing just the contours.
Note, the FRAME picture is only created if annotated axes or a key
has been drawn, or if non-zero margins were specified using parameter
MARGIN. The world co-ordinates in the DATA picture will be pixel
co-ordinates. A reference to the supplied NDF, together with a copy
of the WCS information in the NDF are stored in the DATA picture. On
exit the current database picture for the chosen device reverts to the
input picture.
2 Related_Applications
   KAPPA: WCSFRAME, PICDEF; Figaro: ICONT; SPECDRE: SPECCONT.
2 Authors
MJC: Malcolm J. Currie  (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 1988 Aug  1 (MJC):
    Original version.

 1989 Feb  1 (MJC):
    Made defaults for PXSIZE and PYSIZE parameters slightly
    smaller to accommodate a change to ADAM, where pressing the
    default could result in a value out of range and a confusing
    error message.

 1989 Apr  3 (MJC):
    Added graphics database V1.0.

 1989 Apr 14 (MJC):
    Redefined colours of SGS pens to predefined state if
    workstation has dynamic colour representation.

 1989 Jun 23 (MJC):
    AGI/SGS rounding error bugs fixed so workarounds for fuzzy
    edges removed; new AGI_ANNUL routine used.

 1989 Aug  8 (MJC):.
    Passed array dimensions as separate variables to CNTDRA,
    CNTDRW and CNTSEL.

 1989 Aug 29 (MJC):
    Used NAG routine to produce sub-pixel resolution and annotated
    contours replacing CNTDRA, removed NOISY parameter as this
    functionality is not provided in the routine, added LABELFREQ
    parameter.

 1989 Oct 17 (MJC):
    Revised the world co-ordinates of the contour picture to the
    Starlink standard --- had to create a smaller zone for NAG
    plotting, but still record the full image zone in the
    database.

 1989 Dec 21 (MJC):
    Workspace managed by AIF_TEMP.

 1990 Jan 9  (MJC):
    Corrected SGS status.

 1990 Feb 18 (MJC):
    Large blocks of bad pixels removed before contouring.

 1990 Mar 30 (MJC):
    Added axis annotation parameters and reports the chosen
    contour heights to the user.

 1990 May 22 (MJC):
    Corrected aspect ratio of the contour region to give the same
    scale factor in x and y.

 1990 Aug 29 (MJC):
    NDF version supporting variance and quality, bad-pixel checks,
    units and title to annotate the plot.

 1991 February 7 (MJC):
    Added NDF reference into the database, AGI context control and
    removed fuzzy-picture fudge.

 1991 April 8 (MJC):
    Added data co-ordinate transformation and optional axes.
    Re-organised world co-ordinates so that CNTDRW no longer
    handles the full array, merely the section.

 1991 May 1 (MJC):
    Renamed IN parameter to NDF for consistency.

 1991 July 31 (MJC):
    No longer redefines colours of SGS pens to predefined state if
    workstation has dynamic colour representation, now there is
    palette control.

 1991 August 20 (MJC):
    Added FONT parameter.

 1991 September 17 (MJC):
    Moved getting the PENROT and LABELFREQ parameters until after
    the number of contour heights is known to fix a bug in the
    permitted range of LABELFREQ.

 1992 March 3 (MJC):
    Replaced AIF parameter-system calls by the extended PAR
    library.

 1992 April 4 (MJC):
    Made to handle significant dimensions for user-defined
    sections.

 1992 November 28 (MJC):
    Does not use non-monotonic axis centres.

 1992 December 17 (MJC):
    Added the FILL option.

 1993 January 19 (MJC):
    Added the BORDER option.

 1995 October 19 (MJC):
    Supports Error component.

 1997 May 28 (MJC):
    Added percentiles and equalised options for the MODE including
    a new parameter PERCENTILES.  Added CONCOL and DASHED
    parameters, and further examples.  Improved efficiency by
    using PSX to obtain workspace.  Increased the maximum
    thickness from 5 to 10.  Rewrote the Notes on contour colour
    and line style.  Obtained the contour heights before line
    style parameters.

 1997 May 30 (MJC):
    Removed NAG library calls and smooth and/or annotated contours
    are no longer available.  Parameters ANNOTA, LABELFREQ, MAXRES,
    NOISY, RESOLUTION, and SMOOTHING withdrawn.

 1997 May 31 (MJC):
    Added STATS, LENGTH, and NUMBER.

 12-AUG-1998 (DSB):
    Major changes to base graphics on PGPLOT and handling of co-ordinate
    systems on the AST library.

 26-OCT-1999 (DSB):
    Margin changed to be a fraction of the current picture instead
    of the DATA picture.

 25-JAN-2001 (DSB):
    Added modes Good and Bounds, and parameter LABPOS.
2 Implementation_Status
   -  Only real data can be processed directly.  Other non-complex
   numeric data types will undergo a type conversion before the
   contour plot is drawn.

   -  Bad pixels and automatic quality masking are supported.

1 CONVOLVE
Convolves a pair of 1- or 2-dimensional NDFs together

Usage:

   convolve in psf out xcentre ycentre

Description:

   This application smooths a 1- or 2-dimensional NDF using a Point-
   Spread Function given by a second NDF.  The output NDF is
   normalised to the same mean data value as the input NDF,
   and is the same size as the input NDF.
2 Parameters
For information on individual parameters, select from the list below:
3 IN
IN = NDF (Read)
   The input NDF containing the array to be smoothed.
3 OUT
OUT = NDF (Write)
   The output NDF which is to contain the smoothed array.
3 PSF
PSF = NDF (Read)
   An NDF holding the Point-Spread Function (PSF) with which the
   input array is to be smoothed.  An error is reported if the
   PSF contains any bad pixels.  The PSF can be centred anywhere
   within the array (see parameters XCENTRE and YCENTRE).  A
   constant background is removed from the PSF before use.  This
   background level is equal to the minimum of the absolute value
   in the four corner pixel values.  The PSF is assumed to be
   zero beyond the bounds of the supplied NDF.
3 TITLE
TITLE = LITERAL (Read)
   A title for the output NDF.  A null (!) value means using the
   title of the input NDF. [!]
3 WLIM
WLIM = _REAL (Read)
   If the input array contains bad pixels, then this parameter
   may be used to determine the number of good pixels which must
   be present within the smoothing box before a valid output
   pixel is generated.  It can be used, for example, to prevent
   output pixels from being generated in regions where there are
   relatively few good pixels to contribute to the smoothed
   result.

   By default, a null (!) value is used for WLIM, which causes
   the pattern of bad pixels to be propagated from the input
   array to the output array unchanged.  In this case, smoothed
   output values are only calculated for those pixels which are
   not bad in the input array.

   If a numerical value is given for WLIM, then it specifies the
   minimum total weight associated with the good pixels in the
   smoothing box required to generate a good output pixel
   (weights for each pixel are defined by the normalised PSF).
   If this specified minimum weight is not present, then a bad
   output pixel will result, otherwise a smoothed output value
   will be calculated.  The value of this parameter should lie
   between 0.0 and 1.0.  A value of 0.0 will result in a good
   output pixel being created even if only one good input pixel
   contributes to it.  A value of 1.0 will result in a good output
   pixel being created only if all the input pixels which
   contribute to it are good. [!]
3 XCENTRE
XCENTRE = _INTEGER (Read)
   The x pixel index (column number) of the centre of the PSF
   within the supplied PSF array.  The suggested default is the
   centre of the PSF array.  (This is how the PSF command would
   generate the array.)
3 YCENTRE
YCENTRE = _INTEGER (Read)
   The y pixel index (line number) of the centre of the PSF
   within the supplied PSF array.  The suggested default is the
   centre of the PSF array.  (This is how the PSF command would
   generate the array.)
2 Examples
convolve ccdframe iraspsf ccdlores 50 50
   The image in the NDF called ccdframe is convolved using the
   PSF in NDF iraspsf to create the smoothed image ccdlores.  The
   centre of the PSF image in iraspsf is at pixel indices
   (50,50).  Any bad pixels in the input image are propagated to
   the output.

convolve ccdframe iraspsf ccdlores 50 50 wlim=1.0
   As above, but good output values are only created for pixels
   which have no contributions from bad input pixels.

convolve ccdframe iraspsf ccdlores \
   As in the first example except the centre of the PSF is located
   at the centre of the PSF array.
2 Notes
-  The algorithm used is based on the multiplication of the
Fourier transforms of the input array and PSF array.

-  A PSF can be created using the PSF command or MATHS if the
PSF is an analytic function.
2 Related_Applications
   KAPPA: BLOCK, FFCLEAN, GAUSMOOTH, MATHS, MEDIAN, PSF; Figaro:
   ICONV3, ISMOOTH, IXSMOOTH, MEDFILT.
2 Authors
RAHM: Rhys Morris (STARLINK, University of Wales, Cardiff)

DSB: David Berry (STARLINK)

MJC: Malcolm J. Currie (STARLINK)
2 History
 12-MAY-1992 (RAHM):
    Original version.

 10-JAN-1995 (DSB):
    Major changes for inclusion in KAPPA.

 1995 March 17 (MJC):
    Improvements to the documentation including remarks about
    suggested defaults for XCENTRE and YCENTRE, and a related
    example, and a list of related applications.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   VARIANCE, LABEL, TITLE, UNITS, WCS and HISTORY components of the
   input NDF and propagates all extensions.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.  Arithmetic
   is performed using double-precision floating point.

1 COPYBAD
Copies bad pixels from one NDF file to another.

Usage:

   copybad in ref out title

Description:

   This application copies bad pixels from one NDF file to another. It
   takes in two NDFs (parameters IN and REF), and creates a third
   (parameter OUT) which is a copy of IN, except that any pixel which
   is set bad in the DATA array of REF, is also set bad in the DATA
   and VARIANCE (if available) arrays in OUT.
2 Parameters
For information on individual parameters, select from the list below:
3 IN
IN = NDF (Read)
   NDF containing the data to be copied to OUT.
3 REF
REF = NDF (Read)
   NDF containing the bad pixels to be copied to OUT.
3 OUT
OUT = NDF (Write)
   The output NDF.
3 TITLE
TITLE = LITERAL (Read)
   Value for the title of the output NDF.  A null value will cause
   the title of the NDF supplied for parameter IN to be used
   instead. [!]
2 Examples
copybad in=a ref=b out=c title="New image"
   This creates a NDF called c, which is a copy of the NDF called a.
   Any bad pixels present in the NDF called b are copied into the
   corresponding positions in c (non-bad pixels in b are ignored).
   The title of c is "New image".
2 Notes
- If the two input NDFs have different pixel-index bounds, then
they will be trimmed to match before being processed.  An error
will result if they have no pixels in common.
2 Related_Applications
   KAPPA: SUBSTITUTE, NOMAGIC, FILLBAD, PASTE, GLITCH
2 Authors
TDCA: Tim D.C. Ash(STARLINK)
   DSB: David S. Berry (STARLINK)
2 History
 10-OCT-1998 (TDCA):
    Original version, partially based on the KAPPA routine ADD

 13-OCT-1998 (DSB):
    - Tidied up the prologue and code a touch.

    - Corrected distinction between the data type in which values are
      processed, and the data type in which values are stored in the
      output NDF.

    - Use ERR_REP in place of MSG_OUT to report an error if an
      unrecognised data type is obtained. Also reformat the error
      report to include the unrecognised data type, and a friendly
      message to explain to the user that the problem is not of their
      doing.

    - Changes the KPS routine names to use a consistent root
      ("kps1_cpb").

    - Replaced the message which reports the number of bad pixels
      copied, with a message reporting the number of bad pixels in
      the output NDF. This is easier for a user to understand.

    - Removed un-required initialisation of NBAD.

    - Make the grammar of the NBAD message dependant on the value of
      NBAD, and include the name of the output NDF.

    - Sort local variable declarations into alphabetical order.
2 Implementation_Status
   -  This routine correctly processes the WCS, AXIS, DATA, QUALITY,
   LABEL, TITLE, HISTORY, and VARIANCE components of an NDF data
   structure and propagates all extensions.

   -  All non-complex numeric data types can be handled.

1 CREFRAME
    Generates a test 2-d data array from a selection of several
    types
 
   This routine allows you to generate several different types of
   2-d data array for test purposes. The data array is written to an
   output IMAGE structure.  The types of array are summarised as
   follows:
     [Random]   - between 0 and 1, or specified limits
     [Constant] - 0 or at a specified value
     [Noisy]    - Poissonian or Gaussian noise about a specified mean
     [Ramped]   - between specified minimum and maximum values and a
                  choice of four directions
     [Gaussian] - a random distribution of 2-d Gaussians of defined
                  FWHM and range of maximum peak values on a specified
                  background, with optional invalid pixels and bad
                  column. There is a choice of distributions for the
                  Gaussians: fixed, or inverse square radially from the
                  array centre. (In essence it is equivalent to a
                  simulated star field.) The x-y position and peak
                  value of each Gaussian may be stored in a Fortran
                  formatted file, or reported to you. Magic-value
                  bad data may be included randomly, and/or in a column
                  or line of the array.
 
2 AUTHORS
   Mark McCaughrean UoE (REVA::MJM)
   Malcolm Currie  STARLINK (RAL::CUR)
2 BUGS
   None known.
2 HISTORY
   29-07-1985 : First implementation, explicitly for testing
              : of A-tasks. (REVA::MJM)
   14-10-1985 : Added simulated starfield option (REVA::MJM)
   09-01-1986 : Added blank option (again) (REVA::MJM)
   14-01-1986 : Added option to display or store the star
              : parameters if GS option chosen (REVA::MJM)
   1986 Aug 5 : Renamed algorithm subroutine (CRFRSB), correctly
                ordered arguments in MANYG (2nd to 7th) and in
                CRFRSB (2nd to penultimate). Added list of options
                to the prologue (RAL::CUR).
   1986 Aug 28: Completed the prologue and nearly conformed to
                Starlink programming standards (RAL::CUR).
   1987 Oct 13: Modified status check of output array mapping
                (RAL::CUR)
   1988 Mar 17: Referred to `array' rather than `image'
                (RAL::CUR)
   1988 May 23: Added Gaussian noise option (RAL::CUR).
   1988 Jun 7 : More error reporting (RAL::CUR).
   1988 Jun 30: File name obtained in MANYG (RAL::CUR).
   1988 Aug 5 : Removed lingering astronomical references and
                SCALE parameter (RAL::CUR).
   1989 Jul 25: Altered MANYG argument list; removed DISPLAY
                parameter and reordered alternatives of DISTRIB
                parameter (RAL::CUR)
   1989 Aug  7: Passed array dimensions as separate variables
                to CRFRSB (RAL::CUR).
   1992 Mar  3: Replaced AIF parameter-system calls by the extended
                PAR library (RAL::CUR).
2 PARAMETERS
   OUTPIC   =  IMAGE( WRITE )
       Output IMAGE structure for the generated data array
   OTITLE   =  CHAR( READ )
       Label for the output IMAGE structure
   IDIMS    =  INTEGER( READ )
       x and y dimensions of the output data array
   TYPED    =  CHAR( READ )
       Type of data to be generated. The options are GS - Gaussian;
         RR - random 0 -- 1; RP - random Poisson noise about mean;
         RL - random with set limits; FL - flat; BL - zeroes;
         RA - ramps; and GN - Gaussian noise about mean.
   HIGH     =  REAL( READ )
       High value used in the generated data array (RA and RL types)
   LOW      =  REAL( READ )
       Low value used in the generated data array (RA and RL types)
   DIRN     =  INTEGER( READ )
       Direction of the ramp. 1 means left to right, 2 is right to
         left, 3 is bottom to top, and 4 is top to bottom. (RA type)
   MEAN     =  REAL( READ )
       Mean value used in the generated data array (FL and RP types)
   SIGMA    =  REAL( READ )
       Standard deviation of noise to be used in the generated data
         array (GN type)
   MAX      =  REAL( READ )
       Peak Gaussian intensity to be used in the generated data array
         (GS type)
   MIN      =  REAL( READ )
       Lowest Gaussian intensity to be used in the generated data
         array (GS type)
   BACKGROUND  =  REAL( READ )
       Background intensity to be used in the generated data array
         (GS type)
   NGAUSS   =  INTEGER( READ )
       Number of Gaussian star-like images to be generated (GS type)
   SEEING   =  REAL( READ )
       Seeing (FWHM) in pixels (not the same as the standard
         deviation) (GS type)
   DISTRIB  =  CHAR( READ )
       Radial distribution of the Gaussians to be used; alternatives
         weightings are FIX = fixed distance; and RSQ = one over
         radius squared. (GS type)
   BADPIX   =  LOGICAL( READ )
       Whether or not bad pixels are to be included (GS type)
   FRACTION =  REAL( READ )
       Fraction of bad pixels to be included (GS type)
   BADCOL   =  LOGICAL( READ )
       Whether or not a bad column is to be included (GS type)
   SCREEN   =  LOGICAL( READ )
       True if the Gaussian parameters are reported to you (GS type)
   FILENAME =  CHAR( READ )
       Filename for the output of the Gaussian parameters (GS type)
3 XDIM
  position    1
  keyword     'XDIM'
  type        '_INTEGER'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC'
  prompt      'x dimension of output array'
  help        'Give the x dimension of the array to contain the 
              generated data'
3 YDIM
  position    2
  keyword     'YDIM'
  type        '_INTEGER'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC'
  prompt      'y dimension of output array'
  help        'Give the y dimension of the array to contain the 
              generated data'
3 TYPED
  position    4
  keyword     'TYPED'
  type        'LITERAL'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'Type of data to be generated'
  help        'Current allowable types : GS,RR,RL,RP,RA,FL,BL,GN - 
              see full help or paper documentation for further 
              details'
 #in          'GS', 'RR', 'RL', 'RP', 'RA', 'FL', 'BL', 'GN'
3 LOW
  keyword     'LOW'
  type        '_REAL'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'Lower limit for data'
  help        'Give the lower intensity limit for the generated data 
              array'
3 HIGH
  keyword     'HIGH'
  type        '_REAL'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'Upper limit for data'
  help        'Give the upper intensity limit for the generated data 
              array'
3 MEAN
  keyword     'MEAN'
  type        '_REAL'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'Mean intensity'
  help        'Give the mean intensity figure for the generated data 
              array'
3 SIGMA
  keyword     'SIGMA'
  type        '_REAL'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'Standard deviation of the noise.'
  help        'Give the standard deviation of the noise about the 
              mean for the generated data array'
3 DIRN
  keyword     'DIRN'
  type        '_INTEGER'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'Direction of ramping'
  help        '1 = L-R : 2 = R-L : 3 = B-T : 4 = T-B, where L is 
              left, R is right, B is bottom and T is top'
 #in          1, 2, 3, 4
3 MAX
  keyword     'MAX'
  type        '_REAL'
  access      'READ'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC'
  prompt      'Maximum peak intensity for Gaussians'
  help        'Give the value to be used as the upper limit to 
              Gaussians" peak values'
3 MIN
  keyword     'MIN'
  type        '_REAL'
  access      'READ'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC'
  prompt      'Minimum peak intensity for Gaussians'
  help        'Give the value to be used as the lower limit to 
              Gaussians" peak values'
3 BACKGROUND
  keyword     'BACKGROUND'
  type        '_REAL'
  access      'READ'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC'
  prompt      'Background value'
  help        'Give the value to be taken for the background in the 
              data array'
3 NGAUSS
  keyword     'NGAUSS'
  type        '_INTEGER'
  access      'READ'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC'
  prompt      'Number of Gaussians'
  help        'Give the number of Gaussians to be generated by the 
              application'
3 SEEING
  keyword     'SEEING'
  type        '_REAL'
  access      'READ'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC'
  prompt      'Full-width half-maximum of Gaussians in pixels'
  help        'FWHM is equivalent to the seeing or 2.354 standard 
              deviations'
3 DISTRIB
  keyword     'DISTRIB'
  type        'LITERAL'
  vpath       'DYNAMIC'
  ppath       'CURRENT,DYNAMIC'
  prompt      'Type of radial distribution (RSQ,FIX)'
  help        'Give the radial distribution type - 1/r-squared or fixed'
 #in          'RSQ', 'FIX'
3 BADPIX
  keyword     'BADPIX'
  type        '_LOGICAL'
  access      'READ'
  vpath       'DEFAULT'
  ppath       'CURRENT,DYNAMIC,DEFAULT'
  prompt      'Bad pixels to be included ?'
  help        'Whether or not bad pixels are to be included in the 
              array'
  default     N
3 FRACTION
  keyword     'FRACTION'
  type        '_REAL'
  access      'READ'
  vpath       'DYNAMIC'
  ppath       'CURRENT,DYNAMIC'
  prompt      'Fraction of bad pixels'
  help        'Give the fraction of pixels in the data array to be 
              set to bad-pixel value'
3 BADCOL
  keyword     'BADCOL'
  type        '_LOGICAL'
  access      'READ'
  vpath       'DEFAULT'
  ppath       'CURRENT,DYNAMIC,DEFAULT'
  prompt      'Bad column to be included ?'
  help        'Whether or not a bad column is to be placed in the 
              data array'
  default     N
3 SCREEN
  keyword     'SCREEN'
  type        '_LOGICAL'
  access      'READ'
  vpath       'DYNAMIC'
  ppath       'CURRENT,DYNAMIC,DEFAULT'
  prompt      'Report Gaussian parameters?'
  default     NO
  help        'If yes, the Gaussian parameters will be printed on the 
              screen. Otherwise in a file'
3 FILENAME
  keyword     'FILENAME'
  type        'FILENAME'
  access      'READ'
  vpath       'DEFAULT'
  ppath       'CURRENT,DEFAULT'
  prompt      'Filename for output'
  default     !
  help        'Name of the ASCII file to be used for storing the 
              Gaussian parameters'
3 OUTPIC
  position    3
  keyword     'OUTPIC'
  type        'IMAGE'
  access      'WRITE'
  vpath       'PROMPT'
  association '->GLOBAL.DATA_ARRAY'
  prompt      'Image for output data'
  help        'Name given to the IMAGE data structure to hold the 
              generated data array'
3 OTITLE
  keyword     'OTITLE'
  type        '_CHAR'
  vpath       'DEFAULT'
  prompt      'Title for output array'
  default     'KAPPA - Creframe'
  help        'Character string used as a title for the output IMAGE 
              structure.'

1 CRELUT
Creates or manipulates an image-display lookup table using a
palette.

Usage:

   crelut inlut outlut ndf [comp] low high [inpal] [outpal] [device]

Description:

   This application allows a lookup table to be created or modified
   interactively on a chosen image display from a palette of
   colours.  All plotting is performed within the current
   graphics-database picture for that device.  The phases in the
   creation or manipulation of the lookup table are enumerated below.
   1. The initial colour table is read from an NDF lookup-table file
      or a greyscale used if there is no input lookup table.
   2. The name of an NDF containing a 2-dimensional array is obtained
      and the array is scaled and displayed in the top half of the
      picture at the largest magnification without distortion.  Below
      this an histogram of the values between the scaling limits is
      drawn with the colour index of each bin corresponding to the
      bin's scaled value.  Thus colours in the image and the
      histogram match.   Axes of number versus data value are plotted
      about the histogram.  If a null character, !, is given then no NDF
      array is read and a ramp is produced instead of the histogram.
      An axis of pen numbers in the lookup table is drawn around the
      ramp.
   3. A numbered palette is drawn below the histogram.  A palette
      created in an earlier run of CRELUT may be restored from an
      NDF.  Otherwise the palette comprises eight coloured blocks
      (black, white, red, green, blue, yellow, magenta and cyan)
      with palette numbers 0--7, an eight-level greyscale (8--15)
      and a sixteen-level greyscale (16--31).  Palette numbers
      16--31 may be replaced randomly by colours you define.  The
      colours are specified by either the giving the red, green, blue
      intensities; or by name.  The loop is terminated by a null.
   4. Inside a loop you select the palette colour(s) to be assigned
      to the first and last pen numbers of a band within the lookup
      table.  For convenience, where there is an image and histogram
      the equivalent data values are entered rather than pen numbers
      directly, though they are converted to the nearest pens in the
      lookup table.  Linear interpolation between the two palette
      colours yields the lookup-table colours inside the band.
      Should only one colour be given then all the pens in the
      requested range are set to that colour.  Pen numbers may be
      re-used indefinitely and assigned new colours if the desired
      effect is not obtained.  (The histogram of the array is
      produced to assist in a sensible choice).  The loop is
      terminated by a null in response to either of the prompts.
   5. The lookup table may be saved in an NDF.  A null response, !,
      to the request for the name of the file in which the table is
      to be stored will result in the table not being saved.
      Likewise the palette may be saved in an NDF.
2 Parameters
For information on individual parameters, select from the list below:
3 COLOUR
COLOUR() = LITERAL (Read)
   A colour to be added to the palette at the entry given by
   parameter PALNUM.  It is specified in one of two ways.

     o  A named colour from the standard colour set, which may
     be abbreviated.  If the abbreviated name is ambiguous the
     first match is selected.  The case of the name is ignored.
     Some examples are "Seagreen", "Violet", and "Orchid".

     o  Normalised red, green, and blue intensities separated by
     commas or spaces.  Each value must lie in the range 0.0--1.0.
     For example, "1.0,1.0,0.5" would give a pale yellow.

   To exit the loop that obtains new palette colours enter a null
   character (!) in response to the prompt.
3 COLRANGE
COLRANGE() = _INTEGER (Read)
   The numbers of the palette colours to be allocated to a range
   of pens within the lookup table.  One or two palette colours
   may be entered.  If only one is given all the range of pens
   are assigned that colour.  If two palette colours are given
   the colour of a pen is obtained by linear interpolation
   between the two colours at the fractional position of the pen
   in the range of colour indices.  Allowed values are 0--31.
3 COMP
COMP = LITERAL (Read)
   The NDF component to be displayed.  It may be "Data",
   "Quality", "Variance", or "Error" (where "Error" is the
   alternative to "Variance" and causes the square root of the
   variance values to be displayed).  If "Quality" is specified,
   then the quality values are treated as numerical values (in
   the range 0 to 255). ["Data"]
3 DEVICE
DEVICE = DEVICE (Read)
   Name of the image display to be used.  The device must be in
   one of the following GNS categories: IMAGE_DISPLAY,
   IMAGE_OVERLAY, or WINDOW, and have at least 48 colour indices.
   At least 120 colour indices is recommended.  The device must
   also not reset when the device is opened (since the new colour
   table would be lost).  [Current image-display device]
3 HIGH
HIGH = _DOUBLE (Read)
   This is the highest value in the 2-dimensional data array used
   for scaling and computing the histogram.  All larger array
   values are set to the highest colour index when HIGH is
   greater than LOW, otherwise all array values greater than HIGH
   are set to the lowest colour index.  The dynamic default is
   the maximum data value.
3 INLUT
INLUT = NDF (Read)
   Name of the NDF containing the initial lookup table as its data
   array.  The LUT must be 2-dimensional, the first dimension
   being 3, and the second being arbitrary.  The method used to
   compress or expand the colour table if the second dimension is
   different from the number of unreserved colour indices is
   controlled by parameter NN.  Also the LUT's values must lie in
   the range 0.0--1.0.  If INLUT is null (!) a greyscale is used.
3 INPAL
INPAL = NDF (Read)
   Name of the NDF containing the initial palette as its data
   array.  The palette must be 2-dimensional, the first dimension
   being 3, and the second 32.  If the second dimension is
   greater than 32 only the first 32 colours are used; if it has
   less than 32 just fill as much of the palette as is possible
   starting from the first colour.  The palette's values must lie
   in the range 0.0--1.0.  If INPAL is null (!) the default
   palette is loaded.
3 LOW
LOW = _DOUBLE (Read)
   The array value that scales to the lowest pen in the colour
   table, and the minimum value to be included in the histogram.
   All smaller array values are set to the lowest colour
   index when LOW is less than HIGH, otherwise all array values
   smaller than LOW are set to the highest colour index.   The
   dynamic default is the minimum data value.
3 NDF
NDF = NDF (Read)
   Input NDF data structure containing the image to be displayed
   to show the effect of the created colour table.
3 NN
NN = _LOGICAL (Read)
   If TRUE, the input lookup table is mapped to the colour table by
   using the nearest-neighbour method.  This preserves sharp
   edges and is better for lookup tables with blocks of colour.
   If NN is FALSE, linear interpolation is used, and this is
   suitable for smoothly varying colour tables. [FALSE]
3 OK
OK = _LOGICAL (Read)
   TRUE when the palette colour just produced is acceptable.
3 OUTLUT
OUTLUT = NDF (Write)
   The output lookup table.
3 OUTPAL
OUTPAL = NDF (Write)
   The palette used to create the lookup table.
3 PALNUM
PALNUM = _INTEGER (Read)
   The number of the palette entry whose colour is to be
   modified.  (The numbers are plotted on the palette.) It is
   used within a loop to modify up to sixteen entries in the
   palette.  Entering a null, !, will end that loop.  The
   suggested default is the next palette number.  PALNUM must lie
   in the range 16--31.
3 PENRANGE
PENRANGE() = _INTEGER (Read)
   The range of pen numbers in the lookup table which is about to
   be allocated a set of colours from the palette.  PENRANGE is
   only used when there is no image and histogram plotted.  The
   pen number can be read from the axis below the ramp.  If one
   pen number is given, only this pen is altered, and it is given
   the first palette colour of COLRANGE.  If two are supplied,
   the first pen number entered will take the first palette
   colour entered, and the second pen is assigned the second
   palette colour.  The pens must lie in the range zero to the
   maximum number of available pens.
3 PTITLE
PTITLE = LITERAL (Read)
   Title for the output palette NDF. ["KAPPA - Crelut"]
3 TITLE
TITLE = LITERAL (Read)
   Title for the output lookup table NDF. ["KAPPA - Crelut"]
3 VALRANGE
VALRANGE() = _DOUBLE (Read)
   The range of data values in the histogram/image which is to
   be allocated a set of colours from the palette, and hence be
   assigned to a part of the lookup table.  VALRANGE is only used
   when there is an image and histogram plotted.  The data value
   may be read from the axis below the histogram.  If one data
   value is given, only the single pen in the lookup table
   corresponding to the value is altered, and it is given the
   first palette colour of COLRANGE.  If two values are supplied,
   the first data value entered will take the first palette
   colour entered, and the second data value is assigned the
   second palette colour.  The data values must lie in the range
   PVLO--PVHI.
2 Examples
Note:
   Since the application is highly interactive and contains loops
   it is not possible to give one-line commands to perform a
   complete operation.  Therefore the examples show how to
   control the input and output data and not the interactive
   manipulation of the colour table.

crelut heat bizarre hh12 \
   Reads a lookup table in an NDF called heat.  If resampling of
   the lookup table is required it achieved via linear
   interpolation. The lookup table after the manipulation is
   stored in NDF bizarre.  The data array in NDF hh12 is scaled
   between its minimum and maximum values and displayed in the
   top half of the current picture on the current image-display
   device.  Also drawn is an histogram of the intensities.

crelut heat bizarre hh12 inpal=mypal \
   As above except a palette created previously via the OUTPAL
   parameter.  This palette is in an NDF called mypal.

crelut inlut=! deluxe hh12 v low=100 high=400 \
   A greyscale lookup table is manipulated and the result
   is stored in NDF deluxe.  The variance array in NDF hh12 is
   scaled between 100 and 400, and displayed in the top half of
   the current picture on the current image-display device.  Also
   drawn is an histogram of the intensities between those limits.

crelut heat bizarre ndf=! device=xwindows \
   Reads a lookup table in an NDF called heat.  If resampling of
   the lookup table is required it achieved via the
   nearest-neighbour method.  The lookup table after the
   manipulation is stored in NDF bizarre.  A linear ramp is
   displayed in the lower half of the current picture on the
   xwindows device.
2 Notes
-  The application stores, in the order given, the following
pictures in the graphics database: a frame comprising the data
picture, the histogram or ramp and the palette; the data-array
picture with world co-ordinates in units of data pixels; the
histogram/ramp frame picture including the histogram/ramp plus
the annotated axes; and the histogram with world co-ordinates in
units of data values and number, or the ramp with units of pen
numbers and normalised frequency.   The NDF associated with the
image/histogram plots is stored by reference with the DATA
picture.  On exit the current database picture for the chosen
device reverts to the input picture.

-  Bad pixels will appear with the lowest colour index in the
plot.
2 Related_Applications
   KAPPA: LUTABLE, LUTFLIP, LUTREAD, LUTROT, LUTSAVE, LUTTWEAK,
   LUTVIEW, PALREAD, PALSAVE; Figaro: COLOUR.
2 Authors
MJC: Malcolm J. Currie  (STARLINK)
2 History
 1991 May 10 (MJC):
    Original NDF version based on the pre-0.8 version.

 1991 June 27 (MJC):
    Improved the clarity of the documentation and instructions,
    especially concerning the meaning of "pen".  Improved the user
    interface by permitting nominated palette entries to be
    revised, and showing the value of the existing entry.  Added
    facilities to save and restore the palette.  Used full axes
    including a correctly scaled ordinate, and data values on the
    abscissa of the histogram.  LUT pens can be specified via data
    values.  Stored data co-ordinates with the DATA picture
    associated with the image.

 1991 July 22 (MJC):
    Replaced the RGB parameter by the more-powerful COLOUR.

 1992 March 3 (MJC):
    Replaced AIF parameter-system calls by the extended PAR
    library.

 1992 April 23 (MJC):
    Made to handle significant dimensions for user-defined
    sections of the image.

 1992 November 30 (MJC):
    Does not use non-monotonic axis centres.

 1995 October 19 (MJC):
    Supports Error component.
2 Implementation_Status
   -  The magic-value method is used for processing bad data.

   -  This application will handle data in all numeric types, though
   type conversion to integer will occur for unsigned byte and word
   images.

1 CSUB
Subtracts a scalar from an NDF data structure.

Usage:

   csub in scalar out

Description:

   The routine subtracts a scalar (i.e. constant) value from each
   pixel of an NDF's data array to produce a new NDF data structure.
2 Parameters
For information on individual parameters, select from the list below:
3 IN
IN = NDF (Read)
   Input NDF data structure, from which the value is to be
   subtracted.
3 OUT
OUT = NDF (Write)
   Output NDF data structure.
3 SCALAR
SCALAR = _DOUBLE (Read)
   The value to be subtracted from the NDF's data array.
3 TITLE
TITLE = LITERAL (Read)
   Value for the title of the output NDF.  A null value will cause
   the title of the NDF supplied for parameter IN to be used
   instead. [!]
2 Examples
csub a 10 b
   This subtracts ten from the NDF called a, to make the NDF
   called b.  NDF b inherits its title from a.

csub title="HD123456" out=b in=a scalar=21.9
   This subtracts 21.9 from the NDF called a, to make the NDF
   called b.  NDF b has the title "HD123456".
2 Related_Applications
   KAPPA: ADD, CADD, CDIV, CMULT, DIV, MATHS, MULT, SUB.
2 Authors
RFWS: R.F. Warren-Smith (STARLINK)

MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 12-APR-1990 (RFWS):
    Original version.

 1992 January 15 (MJC):
    Added Usage and Examples items.

 1995 September 12 (MJC):
    Title inherited by default.  Usage and examples to lowercase.
    Added Related Applications.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   LABEL, TITLE, UNITS, HISTORY, WCS and VARIANCE components of an NDF
   data structure and propagates all extensions.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.

1 CURSOR
Reports the co-ordinates of positions selected using the cursor.

Usage:

   cursor [mode] [name] [outcat] [device]

Description:

   This application reads co-ordinates from the chosen graphics device
   using a cursor and displays them on your terminal. The selected
   positions may be marked in various ways on the device (see parameter
   PLOT), and can be written to an output positions list so that subsequent
   applications can make use of them (see parameter OUTCAT). The format
   of the displayed positions may be controlled using parameter STYLE.

   Positions may be reported in several different co-ordinate Frames
   (see parameter FRAME). Optionally, the corresponding pixel
   co-ordinates at each position may also be reported (see parameter
   SHOWPIXEL).

   The picture or pictures within which positions are required can be
   selected in several ways (see parameters MODE and NAME).

   Restrictions can be made on the number of positions to be given (see
   parameters MAXPOS and MINPOS), and screen output can be suppressed
   (see parameter QUIET).
2 Parameters
For information on individual parameters, select from the list below:
3 CLOSE
CLOSE = _LOGICAL (Read)
   This parameter is only accessed if parameter PLOT is set to
   "Chain" or "Poly". If TRUE, polygons will be closed by joining
   the first position to the last position. [current value]
3 DESCRIBE
DESCRIBE = _LOGICAL (Read)
   If TRUE, a detailed description of the co-ordinate Frame in which
   subsequent positions will be reported is produced each time a
   position is reported within a new picture. [current value]
3 DEVICE
DEVICE = DEVICE (Read)
   The graphics workstation.  This device must support cursor
   interaction. [current graphics device]
3 EPOCH
EPOCH = _DOUBLE (Read)
   If a "Sky Co-ordinate System" specification is supplied (using
   parameter FRAME) for a celestial co-ordinate system, then an
   epoch value is needed to qualify it. This is the epoch at
   which the supplied sky positions were determined. It should be
   given as a decimal years value, with or without decimal places
   ("1996.8" for example). Such values are interpreted as a Besselian
   epoch if less than 1984.0 and as a Julian epoch otherwise.
3 FRAME
FRAME = LITERAL (Read)
   A string determining the co-ordinate Frame in which positions are
   to be reported. When a data array is displayed by an application
   such as DISPLAY, CONTOUR, etc, WCS information describing the co-ordinate
   systems known to the data array are stored with the DATA picture
   in the graphics database. This application can report positions in
   any of the co-ordinate Frames stored with each picture. The
   string supplied for FRAME can be one of the following:

   - A domain name such as SKY, AXIS, PIXEL, etc. The special domains
   AGI_WORLD and AGI_DATA are used to refer to the world and data
   co-ordinate system stored in the AGI graphics database. They can
   be useful if no WCS information was store with the picture when
   it was created.

   - An integer value giving the index of the required Frame.

   - A "Sky Co-ordinate System" (SCS) value such as EQUAT(J2000) (see
   section "Sky Co-ordinate Systems" in SUN/95).

   If a null value (!) is supplied, positions are reported in the
   co-ordinate Frame which was current when the picture was created.
   [!]
3 GEODESIC
GEODESIC = _LOGICAL (Read)
   This parameter is only accessed if parameter PLOT is set to
   "Chain" or "Poly". It specifies whether the curves drawn between
   positions should be straight lines, or should be geodesic curves.
   In many co-ordinate Frames geodesic curves will be simple straight
   lines. However, in others (such as the majority of celestial
   co-ordinates Frames) geodesic curves will be more complex curves
   tracing the shortest path between two positions in a non-linear
   projection. [FALSE]
3 INFO
INFO = _LOGICAL (Read)
   If TRUE then messages are displayed describing the use of the
   mouse prior to obtaining the first position. Note, these
   informational messages are not suppressed by setting parameter
   QUIET to TRUE. [TRUE]
3 JUST 
JUST = LITERAL (Read)
   A string specifying the justification to be used when displaying text
   strings at the supplied cursor positions. This parameter is only
   accessed if parameter PLOT is set to "Text". The supplied string
   should contain two characters; the first should be "B", "C" or "T",
   meaning bottom, centre or top. The second should be "L", "C" or "R",
   meaning left, centre or right. The text is displayed so that the
   supplied position is at the specified point within the displayed text
   string. [CC]
3 LASTDIM
LASTDIM = _INTEGER (Write)
   The number of axis values written to parameter LASTPOS.
3 LASTPOS
LASTPOS() = _DOUBLE (Write)
   The unformatted co-ordinates of the last valid position selected
   with the cursor, in the co-ordinate Frame which was used to
   report the position. The number of axis values is written to output
   parameter LASTDIM.
3 LOGFILE
LOGFILE = FILENAME (Write)
   The name of the text file in which the formatted co-ordinates of
   positions selected with the cursor may be stored. This is intended
   primarily for recording the screen output, and not for communicating
   positions to subsequent applications (use parameter OUTCAT for this
   purpose). A null string (!) means that no file is created.  [!]
3 MARKER
MARKER = _INTEGER (Read)
   This parameter is only accessed if parameter PLOT is set to
   "Chain" or "Mark". It specifies the symbol with which each
   position should be marked, and should be given as an integer
   PGPLOT marker type. For instance, 0 gives a box, 1 gives a dot,
   2 gives a cross, 3 gives an asterisk, 7 gives a triangle. The
   value must be larger than or equal to -31. [current value]
3 MAXPOS
MAXPOS = _INTEGER (Read)
   The maximum number of positions which may be supplied before the
   application terminates. The number must be in the range 1 to 200.
   [200]
3 MINPOS
MINPOS = _INTEGER (Read)
   The minimum number of positions which may be supplied. The user
   is asked to supply more if necessary. The number must be in the
   range 0 to the value of parameter MAXPOS. [0]
3 MODE
MODE = LITERAL (Read)
   The method used to select the pictures in which cursor positions are
   to be reported. There are three options:

   - "Current" -- reports positions within the current picture in the
   AGI database. If a position does not lie within the current picture,
   an extrapolated position is reported, if possible.

   - "Dynamic" -- reports positions within the top-most picture
   under the cursor in the AGI  database.  Thus the second and
   subsequent cursor hits may result in the selection of a new picture.

   - "Anchor" -- lets the first cursor hit select the picture in
   which all positions are to be reported. If a subsequent cursor hit
   falls outside this picture, an extrapolated position is reported if
   possible.

   ["Dynamic"]
3 NAME
NAME = LITERAL (Read)
   Only pictures of this name are to be selected.  For instance, if
   you want positions in a DATA picture which is covered by a
   transparent FRAME picture, then you could specify NAME=DATA.
   A null (!) or blank string means that pictures of all names may
   be selected. NAME is ignored when MODE = "Current". [!]
3 NUMBER
NUMBER = _INTEGER (Write)
   The number of positions selected with the cursor (excluding
   invalid positions).
3 OUTCAT
OUTCAT = FILENAME (Write)
   An output catalogue in which to store the valid selected positions.
   The catalogue has the form of a positions list such as created by
   application LISTMAKE. Only positions in the first selected picture
   are recorded. This application uses the conventions of the CURSA
   package (SUN/190) for determining the format of the catalogue. If a
   file type of .fit is given, then the catalogue is stored as a FITS
   binary table. If a file type of .txt is given, then the catalogue
   is stored in a text file in "Small Text List" (STL) format. If no
   file type is given, then ".fit" is assumed. If a null value is
   supplied, no output positions list is produced. [!]
3 PLOT
PLOT = LITERAL (Read)
   The type of graphics to be used to mark the selected positions
   which have valid co-ordinates.  The appearance of these graphics
   (colour, size, etc ) is controlled by the STYLE parameter. PLOT
   can take any of the following values:

   - "None" -- No graphics are produced.

   - "Mark" -- Each position is marked by the symbol specified
   by parameter MARKER.

   - "Poly" -- Causes each position to be joined by a line to the
   previous position.  These lines may be simple straight lines or
   geodesic curves (see parameter GEODESIC). The polygons may
   optionally be closed by joining the last position to the first (see
   parameter CLOSE).

   - "Chain" -- This is a combination of "Mark" and "Poly". Each
   position is marked by a symbol and joined by a line to the previous
   position. Parameters MARKER, GEODESIC and CLOSE are used to
   specify the symbols and lines to use.

   - "Box" -- A rectangular box with edges parallel to the edges of
   the graphics device is drawn with the specified position at one
   corner, and the previously specified position at the diagonally
   opposite corner.

   - "Vline" -- A vertial line is drawn through each specified
   position, extending the entire height of the selected picture.

   - "Hline" -- A horizontal line is drawn through each specified
   position, extending the entire width of the selected picture.

   - "Cross" -- A combination of "Vline" and "Hline".

   - "Text" -- A text string is used to mark each position. The string is
   drawn horizontally with the justification specified by parameter JUST.
   The strings to use for each position are specified using parameter
   STRINGS.

   [current value]
3 QUIET
QUIET = _LOGICAL (Read)
   If TRUE then positions are not reported on the screen. Output
   parameters and files are still created. The display of informational
   messages describing the use of the cursor is controlled by the
   parameter INFO. [FALSE]
3 SHOWPIXEL
SHOWPIXEL = _LOGICAL (Read)
   If TRUE, the pixel co-ordinates of each selected position are
   shown on a separate line, following the co-ordinates requested
   using parameter FRAME. If pixel co-ordinates are being displayed
   anyway (see parameter FRAME) then a value of FALSE is used for.
   SHOWPIXEL. [current value]
3 STRINGS
STRINGS = LITERAL (Read)
   A group of text strings which are used to mark the supplied positions
   if parameter PLOT is set to "TEXT". The first string in the
   group is used to mark the first position, the second string is
   used to mark the second position, etc. If more positions are
   given than there are strings in the group, then the extra
   positions will be marked with an integer value indicating the
   index within the list of supplied positions. If a null value (!)
   is given for the parameter, then all positions will be marked
   with integer indices, starting at 1.

   A comma-separated list should be given in which each element is
   either a marker string, or the name of a text file preceded by an
   up-arrow character "^". Such text files should contain further
   comma-separated lists which will be read and interpreted in the
   same manner. Note, strings within text files can be separated by
   new lines as well as commas.
3 STYLE
STYLE = LITERAL (Read)
   A group of attribute settings describing the plotting style to use
   when drawing the graphics specified by parameter PLOT. The format
   of the positions reported on the screen may also be controlled.

   A comma-separated list of strings should be given in which each
   string is either an attribute setting, or the name of a text file
   preceded by an up-arrow character "^". Such text files should
   contain further comma-separated lists which will be read and
   interpreted in the same manner. Attribute settings are applied in
   the order in which they occur within the list, with later settings
   over-riding any earlier settings given for the same attribute.

   Each individual attribute setting should be of the form:

      <name>=<value>

   where <name> is the name of a plotting attribute, and <value> is
   the value to assign to the attribute. Default values will be
   used for any unspecified attributes. All attributes will be
   defaulted if a null value (!) is supplied. See section "Plotting
   Attributes" in SUN/95 for a description of the available
   attributes. Any unrecognised attributes are ignored (no error is
   reported). [current value]

   In addition to the attributes which control the appearance of
   the graphics (Colour, Font, etc), the following attributes may
   be set in order to control the appearance of the formatted axis
   values reported on the screen: Format, Digits, Symbol, Unit. These
   may be suffixed with an axis number (eg "Digits(2)") to refer to
   the values displayed for a specific axis. [current value]
2 Examples
cursor frame=pixel
   This obtains co-ordinates within any visible picture for the
   current graphics device by use of the cursor. Positions are
   reported in pixel co-ordinates if available, and in the current
   co-ordinate Frame of the picture otherwise.

cursor frame=equat(J2010)
   This obtains co-ordinates within any visible picture for the
   current graphics device by use of the cursor. Positions are
   reported in equatorial RA/DEC co-ordinates (referenced to the
   J2010 equinox) if available, and in the current co-ordinate Frame
   of the picture otherwise.

cursor describe plot=mark marker=3 style="colour=red,size=2"
   As above except, positions are always reported in the current
   co-ordinate Frame of each picture. The details of these co-ordinate
   Frames are described as they are used. Each selected point is
   marked with PGPLOT marker 3 (an asterisk). The markers are
   red and are twice the default size.

cursor current maxpos=2 minpos=2 plot=poly quiet outcat=slice
   Exactly two positions are obtained within the current picture,
   and are joined with a straight line. The positions are written to
   a FITS binary catalogue called slice.FIT but are not displayed on
   the screen. The catalogue may be used to communicate the positions
   to later applications (LISTSHOW, PROFILE, etc).

cursor name=data style="^mystyle,digits(1)=5,digits(2)=7"
   This obtains co-ordinates within any visible DATA picture on
   the current graphics device.  The style to use is read from
   text file mystyle, but is then modified so that 5 digits are used
   to format axis 1 values, and 7 to format axis 2 values.

cursor plot=box style="width=3,colour=red" maxpos=2 minpos=2
   Exactly two positions must be given using the cursor, and a red box
   is drawn joining the two positions. The lines making up the box
   are three times the default width.

cursor plot=text style="size=2,textbackcolour=clear"
   Positions are marked using integer values, starting at 1 for the
   first position. The text drawn is twice as large as normal, and
   the background is not cleared before drawing the text.
2 Notes
-  The unformatted values stored in the output parameter LASTPOS,
may not be in the same units as the formatted values shown on
the screen and logged to the log file. For instance, unformatted
celestial co-ordinate values are stored in radians.

-  The current picture is unchanged by this application.

-  In DYNAMIC and ANCHOR modes, if the cursor is situated at a
position where there are no pictures of the selected name, the
co-ordinates in the BASE picture are reported.

-  Pixel co-ordinates are formatted with 1 decimal place unless a
format has already been specified by setting the Format attributes
for the axes of the PIXEL co-ordinate Frame (eg using application
WCSATTRIB).

-  Positions can be removed (the instructions state how), starting
from the most-recent one.  Such positions are excluded from the
output positions list and log file (if applicable). If graphics
are being used to mark the positions, then removed positions will
be highlighted by drawing a marker of type 8 (a circle containing a
cross) over the removed positions in a different colour.
2 Related_Applications
   KAPPA: LISTSHOW, LISTMAKE, PICCUR; Figaro: ICUR, IGCUR.
2 Authors
JM: Jo Murray  (STARLINK)

MJC: Malcolm J. Currie  (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 22-MAY-1989 (JM):
    Original version.

 1989 Jun 28 (MJC):
    Added error checking, some tidying, fixed several bugs, only
    reports the picture name and comment when it changes.

 1989 Jul 10 (MJC):
    Fixed "SGS zone too small" bug by reordering the code so that
    the MODE is obtained before the device; extended the prologue.

 1989 Oct 19 (MJC):
    Fixed the synchronisation for terminals, and added commentary
    for both terminals and image displays.

 1989 Oct 24 (MJC):
    Added the log file and name options, and redesigned the
    description.

 1989 Nov 10 (MJC):
    Calls a subroutine to prepare the cursor.

 1990 Jan 9 (MJC):
    Corrected SGS status.

 1990 Apr 20:
    Added output of the current picture's label, if it exists.

 1991 February 8 (MJC):
    Added AGI context control, and tidied unwanted picture
    identifiers.

 1991 March 19 (MJC):
    Converted to SST prologue.

 1991 April 9 (MJC):
    Added AGI begin-and-end block.  Obtains data co-ordinates if
    present.

 1991 May 14 (MJC):
    Added COSYS parameter.

 1992 January 29 (MJC):
    Fixed bug in list of options for MODE.

 1992 February 19 (MJC):
    AGI behaviour has changed, so call new AGI routine to test
    whether or not the picture has changed between cursor
    selections.

 1992 March 3 (MJC):
    Replaced AIF parameter-system calls by the extended PAR
    library.

 1993 May 24 (MJC):
    Added XC and YC output parameters.

 1995 August 24 (MJC):
    Added the COLOUR and PLOT parameters and example of their use.
    No longer selects a new current picture (use PICCUR instead).
    Made usage and examples lowercase.  Added Related Applications.

 1995 December 16 (MJC):
    Added NUMBER, XP, and YP output parameters.  Allowed erasure
    of previous position.

 1996 May 31 (MJC):
    Improved and simplified the graphics, so the marker has a
    uniform size, and plotting can occur outside the current
    SGS picture in ANCHOR and CURRENT modes.

 1997 March 11 (MJC):
    Fixed initialisation bug for parameter NUMBER, and hence XP and
    YP.  Fixed bug where SGS pen was being set when PLOT="None".

 28-AUG-1998 (DSB):
    Radical changes to use PGPLOT and AST for graphics and
    co-ordinate handling.
1 Custom_KAPPA

KAPPA applications can be modified to suit your particular
requirements.  Since this help documentation is not a programmer's
guide, instructions are not given here.  Programmers should contact
the author for details until a new Programmer's Guide appears to
replace the old SUN/101, which was a good summary of Starlink
infrastructure libraries and programming. 

All the source files can be found in /star/kappa/*.tar on Starlink
machines.  The /star path may be different outside of Starlink, so
check with your computer manager.  There is a separate tar file for
each KAPPA subroutine library (with a _sub suffix) and the
interface files, with obvious names.  The remaining files: the
monolith routines, link scripts, include files, the help source,
shell scripts, ICL procedures, and test data are in
kappa_source.tar.  There is also a Starlink standard makefile and
mk script. 

Here is a worked example.  Suppose that you have _REAL-type datasets
for which you want to compute statistics including the skewness and
kurtosis.  One way is to modify STATS.  First to save typing define
environment variables, say STAR and KAP to point to where the
Starlink software and KAPPA source is stored.  Next we extract the
source files to change. 

     % setenv STAR /star
     % setenv KAP /star/kappa
     % tar xf $KAP/kappa_sub.tar stats.
     % tar xf $KAP/kappa_ifls.tar stats.ifl
     % tar xf $KAP/kapgen_sub.tar kpg1_statr.f
     % tar xf $KAP/kapgen_sub.tar kpg1_stdsr.f
     % tar xf $KAP/kappa_source.tar kappa_link_adam

We modify kpg1_statr.f to compute the additional statistics;
kpg1_stdsr.f to list the statistics; stats.f to update the
documentation, to use the revised argument lists of the subroutines,
and to output the new statistics to parameters; and stats.ifl to add
the output parameters.  kappa_link_adam need not be modified, but it
is needed during linking. 

Next some soft links to include files need to be made.

     % star_dev
     % ndf_dev
     % prm_dev
     % par_dev

For some other application and subroutines, you can find what is
needed by trying to compile them and see which include files the
compiler cannot locate.  You then invoke the appropriate package
definitions: pkg_dev, where pkg is the three-letter package
abbreviation.  Now compile the modified code.  This is for OSF/1 

     % f77 -O -c -nowarn stats.f kpg1_statr.f kpg1_stdsr.f

and this is for Solaris.

     % f77 -O -PIC -c -w stats.f kpg1_statr.f kpg1_stdsr.f

The -nowarn and -w prevent warning messages appearing.

Now link the task to produce a new stats executable.

     % alink stats.o -o stats kpg1_statr.o kpg1_stdsr.o \
     $KAPPA_DIR/libkapgen.a -L$STAR/lib `./kappa_link_adam`

For other tasks you may need more KAPPA object libraries in addition
to libkapgen.a.  There is a full list in $KAP/makefile
(look for OBJECT_LIBRARIES).  If you add further libraries, add
them in the order given within the makefile.

If you want to use KAPPA subroutines for your own application here
are words of warning: the code may undergo alterations of subroutine
name or argument lists, and those without a pkg_ prefix will either
be replaced or renamed. Therefore, you should copy the modules you
need. 

2 Parameters

If you don't like KAPPA's parameter defaults, or its choice of which
parameters get prompted for and which get defaulted, then you can
change them.  Extract the interface file from
/star/kappa/kappa_ifls.tar to your work directory and make the
required modifications, and then recompile it.  See SUN/115 on the
meanings and possible values of the fieldnames, and how to recompile
the interface file.  If you use ICL, you'll need to modify a
monolith interface file: $KAPPA_DIR/kappa_mon.ifl, kapview_mon.ifl
or ndfpack_mon.ifl.  Finally, you will need to specify a search path
that includes the directory containing your modified interface file.

     % setenv ADAM_IFL /home/scratch/dro/ifls:/usr/local/kappa

This asks Starlink programmes to look in /home/scratch/dro/ifls to
find the interface file, and if there isn't one to look in
/usr/local/kappa.  If the interface file search is unsuccessful, the
directory containing the executable is assumed.  Thus if you've not
created your own interface file for a task, you'll get the released
version.  Of course, once you have done this, the documentation in
the application specifications in this help will no longer be correct.

2 Commands

There is an easier method of tailoring KAPPA to your requirements. 
If you frequently use certain commands, especially those with a long
list of keywords and fixed values, you can define some C-shell
aliases or ICL symbols for the commands.  Like the shell's
$HOME/.login, ICL has a login file. (See the "ICL for Unix"
Appendix in SUN/144, or SSN/64 for details.)  If you add symbols to
this file, each time you activate ICL these abbreviations will be
available to you without further typing.  What you should do is to
create a login.icl in a convenient directory, and assign the
environment variable ICL_LOGIN to that directory in your
$HOME/.login file. 

It is possible to have several ICL login files, each for different
work in different directories.  Now to abbreviate a command you put
a DEFSTRING entry into the ICL login file.  For example, 

     DEFSTRING MYC{ON CONTOUR CLEAR=F AXES=NO

defines MYC or MYCO or MYCON to run CONTOUR without clearing the screen
or drawing axes. The symbols are not limited to KAPPA.  Indeed they can
include shorthands for shell commands.  For example,

     DEFSTRING DA ls -al 

would make DA produce a directory listing of all files with sizes and
modification dates.

You can check what the current login files are as follows.

     % printenv | grep ICL_LOGIN

For shell usage similar definitions can be made with aliases.  For
example, 

     % alias mycon contour clear=f axes=no

is the equivalent of the DEFSTRING above, except that in keeping with
UNIX tradition the command is in lowercase, and the alias cannot be
abbreviated.
1 Data_structures
In an ideal world you would not need to know how your data are
stored.  It would be transparent.  (The trendies call it object
orientation.)  To some extent Starlink applications achieve that
through standard, but extensible, data structures, and the ability
to apparently operate on other formats through the so-called
`on-the-fly conversion' (see topic "Automatic_format_conversion"
and SUN/55).  However, for historical reasons there are a number of
data formats in Starlink software, and at the moment KAPPA is no
exception in that it has two formats.

The main one is official standard data format for Starlink
applications---the NDF (Extensible N-dimensional Data Format,
SUN/33).  The second is the historical and flawed IMAGE structure,
which is gradually being phased out, and only affects twenty-one
commands (the functionality of which can mostly be achieved with
other applications).  Both formats, though, use HDS which has
numerous advantages, not least that _HDS files are portable between
operating systems_; both have file extension .sdf.

The NDF is more detailed and has been carefully designed to
facilitate processing by both general applications like KAPPA and
specialist packages.  It contains an n-dimensional data array that
can store most astronomical data such as spectra, images and
spectral-line data cubes.  The NDF may also contain information like
a title, axis labels and units, error and quality arrays.  There are
also places in the NDF, called extensions, to store any ancillary
data associated with the data array, even other NDFs.

The two formats and the meaning of their components are described in
topics "NDF_format" and "IMAGE_format".   The former includes the
commands for manipulating the components.  Suffice to say here that
the IMAGE format is more or less a degenerate form of the NDF, and
so both formats can be used in parallel throughout KAPPA; those
applications using the IMAGE format will have restricted
functionality, for example limited axis and quality processing, an
inability to handle NDF sections (cf. topic "NDF_sections") and
cannot use the `on-the-fly' data-conversion scheme (cf. topic
"Automatic_Format_Conversion").

Both formats permit arrays to have seven dimensions, but some
applications only handle one-dimensional and/or two-dimensional data
arrays.  The data and variance arrays are not constrained to a
single data type.  Valid types are the HDS numeric primitive types,
see topic "HDS_Data_Types"

Many applications are generic, that is they can work on all or some
of these data types directly.  This makes these applications faster,
since there is no need to make a copy of the data converted to the
type supported by the application.  If an application is not generic
it only processes _REAL data.   Look in the "Implementation_Status"
in the help or the reference manual.  If none is given you can
assume that processing will occur in _REAL.

In KAPPA the elements of the data array are often called pixels,
even if the NDF is not two-dimensional.

2 Looking_at_the_Data_Structures

You can look at a summary of the NDF or IMAGE structure using the
task NDFTRACE, and obtain the values of NDF extension components
with the

     % setext option=get

command.  HDSTRACE (SUN/102) can be used to look at array values
and extensions.

2 Editing_the_Data_Structures

There are facilities for editing HDS components, though these should
be used with care, lest you invalidate the file.  For instance, if
you were to erase the DATA_ARRAY component of an NDF, the file would
no longer be regarded as an NDF by applications software.

In KAPPA, ERASE will let you remove any component from within
an HDS container file, but you have to know the full path to the
component.  SETEXT has options to erase extensions and their
contents, without needing to know how these are stored within the
HDS file.  It also permits you to create and rename extension
components, and assign new values to existing components.  There are
a number of commands for manipulating FITS-header information stored
in the NDF's FITS extension.  These are described in the topic
"FITS_Airlock".

Figaro offers some additional tasks (CREOBJ, DELOBJ, and RENOBJ) for
editing HDS components.

2 Native_Format

Although HDS files are portable you are recommended to copy them to
the host machine, and run application NATIVE on them for efficiency
gains.  NATIVE converts the data to the native format of the machine
on which you issue the command.  If you don't do this, every time
you access the data in your NDF, say, this conversion process occurs.
In the C-shell you can use a foreach construct to process several
files.  The following converts all the HDS files in the current
directory.

     % foreach file (*.sdf)
     > native $file:r
     > echo Converted $file
     > end

The > is a prompt from the shell, which you don't type.

2 NDF_format

An NDF comprises a main data array plus a collection of objects
drawn from a set of standard items and extensions (see SUN/33).
Only the main data array must be present; all the other items are
optional.

$KAPPA_DIR/example.sdf is an NDF which contains all the standard 
NDF components, except a FITS extension; it also has a FIGARO
extension.  The structure of the file (as revealed by

     % hdstrace $KAPPA_DIR/example

is shown below.  The layout is

     NAME(dimensions)    <TYPE>     VALUE(S)

Note that scalar objects have no dimensions and that each level down
the hierarchy is indented.

   EXAMPLE  <NDF>

      DATA_ARRAY(856)  <_REAL>       *,0.2284551,-2.040089,45.84504,56.47374,
                                     ... 746.2602,820.8976,570.0729,*,449.574
      TITLE          <_CHAR*30>      'HR6259 - AAT fibre data'
      LABEL          <_CHAR*20>      'Flux'
      UNITS          <_CHAR*20>      'Counts/s'
      QUALITY        <QUALITY>       {structure
         BADBITS        <_UBYTE>        1
         QUALITY(856)   <_UBYTE>        1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,
                                     ... 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0

      VARIANCE(856)  <_REAL>         2.1,0.1713413,1.5301,34.38378,42.35531,
                                     ... 615.6732,427.5547,353.9127,337.1805
      AXIS(1)        <AXIS>          {structure

      Contents of AXIS(1)
         DATA_ARRAY(856)  <_REAL>       3847.142,3847.672,3848.201,3848.731,
                                        ... 4298.309,4298.838,4299.368,4299.897
         LABEL          <_CHAR*20>      'Wavelength'
         UNITS          <_CHAR*20>      'Angstroms'

      HISTORY        <HISTORY>       {structure
         CREATED        <_CHAR*30>      '1990-DEC-12 08:21:02.324'
         CURRENT_RECORD  <_INTEGER>     3
         RECORDS(10)    <HIST_REC>      {array of structures

         Contents of RECORDS(1)
            TEXT           <_CHAR*40>      'Extracted spectrum from fibre data.'
            DATE           <_CHAR*25>      '1990-DEC-19 08:43:03.08'
            COMMAND        <_CHAR*30>      'FIGARO V2.4 FINDSP command'


      MORE           <EXT>           {structure
         FIGARO         <EXT>           {structure
            TIME           <_REAL>         1275
            SECZ           <_REAL>         2.13

   End of Trace.

Of course, this is only an example format.  There are various ways
of representing some of the components.  These _variants_ are
described in SGP/38, but not all are currently supported.

The components are considered in detail below.  The names (in bold
typeface) are significant as they are used by the NDF access
routines to identify the components. 

3 DATA
The main data array is the only component which must be present in
an NDF.  In the case of example.sdf, the data component is a
1-dimensional array of real type with 856 elements.  It can have up
to seven dimensions.  It is particularly referenced via parameter
names IN, OUT, and NDF.

3 TITLE
The character string "HR6259 - AAT fibre data" describes the contents
of the NDF.  The NDF's TITLE might be used as the title of a graph
etc.  It may be set with task SETTITLE.  Applications that create an
NDF assign a TITLE to the NDF via a parameter, called TITLE unless
the application generates several NDFs.

3 LABEL
The character string "Flux" describes the quantity represented in
the NDF's main data array.  The LABEL is intended for use on the
axis of graphs etc.  It may be set using the task SETLABEL.

3 UNITS
This character string describes the physical units of the quantity
stored in the main data array, in this case, "Counts/s".  It may be
set via the command SETUNITS.  

3 QUALITY
This component is used to indicate the quality of each element in
the main data array, for example whether each pixel is vignetted
or not.  The quality structure contains a quality array and a
BADBITS value, both of which must be of type _UBYTE.  The quality
array has the same shape and size as the main data array and is
used in conjunction with the BADBITS value to decide the quality of
a pixel in the main data array.  In example.sdf the BADBITS
component has value 1.  This means that a value of 1 in the quality
array indicates a bad pixel in the main data array, whereas any
other value indicates that the associated pixel is good.  (Note
that the pixel is bad if the bit-wise comparison QUALITY "AND"
BADBITS is non-zero).  The meanings of the QUALITY bits are
arbitrary.  See the command SETBB.  To enter new quality
information, use the SETQUAL command of IRAS90.

3 VARIANCE
The variance array is the same shape and size as the main data array
and contains the errors associated with the individual data values.
These are stored as variance estimates for each pixel.  VARIANCE may
be set with the SETVAR command.

3 AXIS
The AXIS structure may contain axis information for any dimension
of the NDF's main array.  In this case, the main data array is only
1-dimensional, therefore only the AXIS(1) structure is present.
This structure contains the actual axis data array of pixel
centres, and also label and units information.  KAPPA uses the
label and units for axis annotations.  Not shown in this example
are optional array components for storing pixel widths and the
variance of the axis centres.  All axes or none must be present.
Use SETAXIS to set the values of an AXIS array component; AXLABEL
and AXUNITS to set an axis LABEL or UNITS component; and SETNORM
to set an axis normalisation flag.

3 WCS 
This component provides an alternative, and superior, method for
storing co-ordinate information. The AXIS structure described
above has the severe limitation that it can only describe
co-ordinate systems in which all axes are independant (i.e. the
value on any axis can be changed without needing to change the
values on any other axes). This means for instance that axes
cannot be rotated (other than by multiples of 90 degrees), and
cannot be used to describe celestial co-ordinates over a large
field, or near a pole. The WCS component overcomes these
restrictions. It contains descriptions of an arbitrary number of
different co-ordinate Frames, together with the mappings required
to convert positions between these Frames. All NDFs have three
default Frames available; these are known as the GRID, PIXEL and
AXIS Frames. The PIXEL Frame corresponds to pixel co-ordinates.
The AXIS Frame corresponds to the co-ordinate Frame implied by
the NDF AXIS structures. The GRID Frame is similar to the PIXEL
Frame, the main difference being that it has a different origin;
the centre of the first ("bottom left") pixel is always (1.0,1.0)
in the GRID Frame regardless of the pixel origin of the NDF.
Other Frames can be added to the WCS component in various ways,
for instance, by importing them from appropriate FIST headers
(FITSIN, FITSDIN), or using an appropriate application to create
them from scratch (eg WCSADD, SETSKY or GAIA ).

3 HISTORY
This component provides a record of the processing history of the
NDF.  Only the first of three records is shown for example.sdf.
This indicates that the spectrum was extracted from fibre data
using the Figaro FINDSP command on 1990 December 19.  The history
recording level is set by task HISSET.  This task also allows you
to switch off history recording or delete the history records.
HISLIST lists an NDF's history.  You can add commentary with HISCOM.

3 EXTENSIONs
The purpose of extensions is to store non-standard items.  These
auxiliary data could be information about the original observing
setup, such as the airmass during the observation or the
temperature of the detector; they may be calibration data or results
produced during processing of the data array, e.g. spectral-line
fits.  example.sdf began life as a Figaro file.  It was converted
to an NDF using the command DST2NDF (see SUN/55).  It contains
values for the airmass and exposure time associated with the
observations.  These are stored in the FIGARO extension, and the
intention is that the Figaro applications which use these values
will know where to find them.  Task SETEXT lets the contents of
extensions be listed, created, deleted, renamed and assigned new
values.

One extension that is used by KAPPA is the FITS extension.  This
holds the FITS headers as an array of 80-character elements,
i.e. one FITS card image per array element.  You can extract the
values of ancillary items from the FITS extension to a non-standard
extension via FITSIMP.  Use FITSEXP to do the reverse operation.
The extension can be listed via the command FITSLIST.  FITSEDIT
allows you to edit the headers prior to export of the dataset to
another format such as FITS or IRAF.

2 IMAGE_format

The IMAGE format as used by some of KAPPA is a simple HDS structure,
comprising a floating-point data array, a character title, and the
maximum and minimum data values.  It is variant of the original
Wright-Giddings IMAGE structure.  There are others is use that
contain more items.  An example structure is shown schematically
below using the HDSTRACE (SUN/102) notation; see topic "NDF_format".

   HORSEHEAD  <IMAGE>

      DATA_ARRAY(384,512)  <_REAL>   100.5,102.6,110.1,109.8,105.3,107.6,
                                     ... 123.1,117.3,119,120.5,127.3,108.4
      TITLE          <_CHAR*72>      'KAPPA - Flip'
      DATA_MIN       <_REAL>         28.513
      DATA_MAX       <_REAL>         255.94

   End of Trace.

Currently, the DATA_ARRAY may have up to seven dimensions.  IMAGE
structures are associated with parameters like INPIC and OUTPIC.
The TITLE object of new IMAGE structures takes the value of the
parameter OTITLE.  DATA_MIN and DATA_MAX are now ignored in KAPPA.

The IMAGE format is not too dissimilar from a primitive NDF with
no extensions.  Indeed if it did not have DATA_MAX and DATA_MIN it
would be a bona fide NDF.  Thus applications that handle the IMAGE 
format can follow the rules of SGP/38 and process it like an NDF.
In effect this means that all extensions are propagated to output
files, and a quality array is propagated where the processing does
not invalidate its values.  The IMAGE applications also handle most
simple NDFs correctly (those where the data array is an array of
numbers at the second level of the hierarchical structure).  This
similarity in formats enables NDF and IMAGE applications to work in
co-operation, and the conversion within KAPPA can be undertaken
piecemeal.  Note that the primitive variant is no longer the norm
for NDFs, since for example, it does not support origin information.

1 DISPLAY
Displays a 1-d or 2-d NDF.

Usage:

   display in [comp] clear [device] mode [centre] [xmagn] [ymagn]
      [out] { low=? high=?
            { percentiles=?
            { sigmas=?
            mode

Description:

   This application displays a 1- or 2-dimensional NDF as an image
   on the current image-display device. The minimum and maximum data
   values to be displayed can be selected in several ways (see
   parameter MODE). Data values outside these limits are displayed
   with the colour of the nearest limit. A colour ramp showing the
   relationship between colour and data value can be displayed (see
   parameter KEY).

   Annotated axes or a simple border can be drawn around the image (see
   parameters AXES and BORDER). The appearance of these may be controlled
   in detail (see parameters STYLE and BORSTYLE).

   A specified colour lookup table may optionally be loaded prior to
   displaying the image (see parameter LUT). For devices which reset
   the colour table when opened (such as postscript files), this may
   be the only way of controlling the colour table.

   The image is produced within the current graphics database picture
   The co-ordinates at the centre of the image, and the scale of the
   image can be controlled using parameters CENTRE, XMAGN and YMAGN. Only
   the parts of the image that lie within the current picture are visible;
   the rest is clipped.  The image is padded with bad pixels if necessary.
2 Parameters
For information on individual parameters, select from the list below:
3 AXES
AXES = _LOGICAL (Read)
   TRUE if labelled and annotated axes are to be drawn around the
   image. These display co-ordinates in the current co-ordinate Frame
   of the supplied NDF - which may be changed using application WCSFRAME
   (see also parameter USEAXIS). The width of the margins left for
   the annotation may be controlled using parameter MARGIN. The
   appearance of the axes (colours, fonts, etc) can be controlled
   using the STYLE parameter. [current value]
3 BADCOL
BADCOL = LITERAL (Read)
   The colour with which to mark any bad (i.e. missing) pixels in the
   display.  There are a number of options described below:

   - "MAX" -- The maximum colour index used for the display of the image.

   - "MIN" -- The minimum colour index used for the display of the image.

   - An integer -- The actual colour index.  It is constrained between
   0 and the maximum colour index available on the device.

   - A named colour -- Uses the named colour from the palette, and if it
   is not present, the nearest colour from the palette is selected.

   If the colour is to remain unaltered as the lookup table is
   manipulated choose an integer between 0 and 15, or a named
   colour.  The suggested default is the current value. [current value]
3 BORDER
BORDER = _LOGICAL (Read)
   TRUE if a border is to be drawn around the regions of the
   displayed image containing valid co-ordinates in the current
   co-ordinate Frame of the NDF. For instance, if the NDF contains
   an Aitoff all-sky map, then an elliptical border will be drawn
   if the current co-ordinate Frame is galactic longitude and
   latitude. This is because pixels outside this ellipse have
   undefined positions in galactic co-ordinates. If, instead, the
   current co-ordinate Frame had been pixel co-ordinates, then a
   simple box would have been drawn containing the whole image.
   This is because every pixel has a defined position in pixel
   co-ordinates. The appearance of the border (colour, width, etc)
   can be controlled using parameter BORSTYLE. [current value]
3 BORSTYLE
BORSTYLE = GROUP (Read)
   A group of attribute settings describing the plotting style to use
   for the border (see parameter BORDER).

   A comma-separated list of strings should be given in which each
   string is either an attribute setting, or the name of a text file
   preceded by an up-arrow character "^". Such text files should
   contain further comma-separated lists which will be read and
   interpreted in the same manner. Attribute settings are applied in
   the order in which they occur within the list, with later settings
   over-riding any earlier settings given for the same attribute.

   Each individual attribute setting should be of the form:

      <name>=<value>

   where <name> is the name of a plotting attribute, and <value> is
   the value to assign to the attribute. Default values will be
   used for any unspecified attributes. All attributes will be
   defaulted if a null value (!) is supplied. See section "Plotting
   Attributes" in SUN/95 for a description of the available
   attributes. Any unrecognised attributes are ignored (no error is
   reported). [current value]
3 CENTRE
CENTRE = LITERAL (Read)
   The co-ordinates of the data pixel to be placed at the centre of
   the image, in the current co-ordinate Frame of the NDF (supplying
   a colon ":" will display details of the current co-ordinate Frame).
   The position should be supplied as a list of formatted axis values
   separated by spaces or commas. See also parameter USEAXIS.  A
   null (!) value causes the centre of the image to be used. [!]
3 CLEAR
CLEAR = _LOGICAL (Read)
   TRUE if the current picture is to be cleared before the image is
   displayed. [current value]
3 COMP
COMP = LITERAL (Read)
   The NDF array component to be displayed.  It may be "Data",
   "Quality", "Variance", or "Error" (where "Error" is an
   alternative to "Variance" and causes the square root of the
   variance values to be displayed).  If "Quality" is specified,
   then the quality values are treated as numerical values (in
   the range 0 to 255). ["Data"]
3 DEVICE
DEVICE = DEVICE (Read)
   The name of the graphics device used to display the image.
   The device must have at least 24 colour indices or greyscale
   intensities. [current image-display device]
3 FILL
FILL = _LOGICAL (Read)
   If FILL is set to TRUE, then the image will be "stretched" to fill
   the current picture in both directions. This can be useful when
   displaying images with markedly different dimensions, such as
   two-dimensional spectra. The dynamic default is TRUE if the array
   being displayed is 1-dimensional, and FALSE otherwise. []
3 HIGH
HIGH = _DOUBLE (Read)
   The data value corresponding to the highest pen in the colour
   table.  All larger data values are set to the highest colour
   index when HIGH is greater than LOW, otherwise all data values
   greater than HIGH are set to the lowest colour index.  The
   dynamic default is the maximum data value.  There is an
   efficiency gain when both LOW and HIGH are given on the
   command line, because the extreme values need not be computed.
   (Scale mode)
3 IN
IN = NDF (Read)
   The input NDF structure containing the data to be displayed.
3 KEY
KEY = _LOGICAL (Read)
   TRUE if a key to the colour table is to be produced to the right
   of the display. This takes the form of a colour ramp, annotated
   with data value. The appearance of this key can be controlled using
   parameter KEYSTYLE, and its horizontal position can be controlled
   using parameter KEYPOS. If the key is required in a different
   location, set KEY=NO and use application LUTVIEW after
   displaying the image. [TRUE]
3 KEYPOS
KEYPOS = _REAL (Read)
   A value giving the gap between the right hand edge of the display
   and the left hand edge of the key, given as a fraction of the
   width of the current picture. If a key is produced, then the 
   right hand margin specified by parameter MARGIN is ignored, and
   the value supplied for KEYPOS is used instead. [current value]
3 KEYSTYLE
KEYSTYLE = GROUP (Read)
   A group of attribute settings describing the plotting style to use
   for the key (see parameter KEY).

   A comma-separated list of strings should be given in which each
   string is either an attribute setting, or the name of a text file
   preceded by an up-arrow character "^". Such text files should
   contain further comma-separated lists which will be read and
   interpreted in the same manner. Attribute settings are applied in
   the order in which they occur within the list, with later settings
   over-riding any earlier settings given for the same attribute.

   Each individual attribute setting should be of the form:

      <name>=<value>

   where <name> is the name of a plotting attribute, and <value> is
   the value to assign to the attribute. Default values will be
   used for any unspecified attributes. All attributes will be
   defaulted if a null value (!) is supplied. See section "Plotting
   Attributes" in SUN/95 for a description of the available
   attributes. Any unrecognised attributes are ignored (no error is
   reported).

   Axis 1 is always the "data value" axis. So for instance, to set
   the label for the data value axis, assign a value to "Label(1)"
   in the supplied style. [current value]
3 LOW
LOW = _DOUBLE (Read)
   The data value corresponding to the lowest pen in the colour
   table.  All smaller data values are set to the lowest colour
   index when LOW is less than HIGH, otherwise all data values
   smaller than LOW are set to the highest colour index.   The
   dynamic default is the minimum data value.  There is an
   efficiency gain when both LOW and HIGH are given on the
   command line, because the extreme values need not be computed.
   (Scale mode)
3 LUT
LUT = NDF (Read)
   Name of the NDF containing a colour lookup table in its Data
   array; the lookup table is written to the image-display's colour
   table.  The purpose of this parameter is to provide a means of
   controlling the appearance of the image on certain devices,
   such as colour printers, that do not have a dynamic colour
   table (i.e. the colour table is reset when the device is
   opened).  If used with dynamic devices (such as X-windows),
   the new colour table remains after this application has
   completed. A null value (! ) causes the existing colour table to
   be used.

   The LUT must be 2-dimensional, the dimension of the first axis
   being 3, and the second being arbitrary.  The method used to
   compress or expand the colour table if the second dimension is
   different from the number of unreserved colour indices is
   controlled by parameter NN.  Also the LUT's values must lie in
   the range 0.0--1.0. [!]
3 MARGIN
MARGIN( 4 ) = _REAL (Read)
   The widths of the margins to leave around the image for axis
   annotations, given as fractions of the corresponding dimension
   of the current picture. The actual margins used may be increased to
   preserve the aspect ratio of the data. Four values may be given, in
   the order - bottom, right, top, left. If less than four values are
   given, extra values are used equal to the first supplied value. If
   these margins are too narrow any axis annotation may be clipped.
   If a null (!) value is supplied, the value used is (for all edges);
   0.15 if annotated axes are being produced; 0.04, if a simple border
   is being produced; and 0.0 if neither border nor axes are being
   produced. [current value]
3 MODE
MODE = LITERAL (Read)
   The method by which the maximum and minimum data values to be
   displayed are chosen. The options are:

   - "Faint" -- The image is scaled between the mean data value minus
   one standard deviation and the mean data value plus seven standard
   deviations. The scaling values are reported so that the faster
   Scale mode may be utilised later.

   - "Flash" -- The image is flashed onto the screen without any
   scaling at all.  This is the fastest option.

   - "Percentiles" -- The image is scaled between the data values
   corresponding to two percentiles.  The scaling values are reported
   so that the faster Scale mode may be utilised later.

   - "Range" -- The image is scaled between the minimum and maximum
   data values.

   - "Scale" -- You define the upper and lower limits between which
   the image is to be scaled.  The application reports the maximum
   and the minimum data values for reference and makes these the
   suggested defaults.

   - "Sigmas" -- The image is scaled between two standard-deviation
   limits.  The scaling values used are reported so that the faster
   Scale mode may be utilised later.
3 NN
NN = _LOGICAL (Read)
   If TRUE the input lookup table is mapped to the colour table by
   using the nearest-neighbour method.  This preserves sharp
   edges and is better for lookup tables with blocks of colour.
   If NN is FALSE linear interpolation is used, and this is
   suitable for smoothly varying colour tables.  NN is ignored
   unless LUT is not null. [FALSE]
3 NUMBIN
NUMBIN  =  _INTEGER (Read)
   The number of histogram bins used to compute percentiles for
   scaling. (Percentiles mode) [2048]
3 OUT
OUT = NDF (Write)
   A scaled copy of the displayed section of the image. Values in
   this output image are integer colour indices shifted to exclude
   the indices reserved for the palette (i.e. the value zero refers
   to the first colour index following the palette). The output NDF
   is intended to be used as the input data in conjunction with
   SCALE=FALSE. If a null value (!) is supplied, no output NDF will
   be created.  This parameter is not accessed when SCALE=FALSE. [!]
3 PERCENTILES
PERCENTILES( 2 ) = _REAL (Read)
   The percentiles that define the scaling limits. For example,
   [25,75] would scale between the quartile values. (Percentile
   mode)
3 SCAHIGH
SCAHIGH = _DOUBLE (Write)
   On exit, this holds the data value which corresponds to the maximum
   colour index in the displayed image. In Flash mode or when there is
   no scaling the highest colour index is returned.
3 SCALE
SCALE = _LOGICAL (Read)
   If TRUE the input data is to be scaled according to the value of
   parameter MODE.  If it is FALSE, MODE is ignored, and the input
   data is displayed as is (i.e. the data values are simply converted
   to integer type and used as indices into the colour table). A value
   of zero refers to the first pen following the palette. A FALSE
   value is intended to be used with data previously scaled by this
   or similar applications which have already performed the required
   scaling (see parameter OUT). It provides the quickest method of
   image display within this application. [TRUE]
3 SCALOW
SCALOW = _DOUBLE (Write)
   The data value scaled to the minimum colour index for display.
   In Flash mode or when there is no scaling the lowest colour
   index is used.  The current display linear-scaling minimum is
   set to this value.
3 SIGMAS
SIGMAS( 2 ) = _REAL (Read)
   The standard-deviation bounds that define the scaling limits.
   To obtain values either side of the mean both a negative and
   a positive value are required.  Thus [-2,3] would scale
   between the mean minus two and the mean plus three standard
   deviations.  [3,-2] would give the negative of that.
3 STYLE
STYLE = GROUP (Read)
   A group of attribute settings describing the plotting style to use
   for the annotated axes (see parameter AXES).

   A comma-separated list of strings should be given in which each
   string is either an attribute setting, or the name of a text file
   preceded by an up-arrow character "^". Such text files should
   contain further comma-separated lists which will be read and
   interpreted in the same manner. Attribute settings are applied in
   the order in which they occur within the list, with later settings
   over-riding any earlier settings given for the same attribute.

   Each individual attribute setting should be of the form:

      <name>=<value>

   where <name> is the name of a plotting attribute, and <value> is
   the value to assign to the attribute. Default values will be
   used for any unspecified attributes. All attributes will be
   defaulted if a null value (!) is supplied. See section "Plotting
   Attributes" in SUN/95 for a description of the available
   attributes. Any unrecognised attributes are ignored (no error is
   reported). [current value]
3 USEAXIS
USEAXIS = GROUP (Read)
   USEAXIS is only accessed if the current co-ordinate Frame of the
   NDF has more than 2 axes. A group of two strings should be
   supplied specifying the 2 axes which are to be used when annotating
   the image, and when supplying a value for parameter CENTRE. Each
   axis can be specified either by its integer index within the current
   Frame (in the range 1 to the number of axes in the current Frame), or
   by its symbol string. A list of acceptable values is displayed if an
   illegal value is supplied. If a null (!) value is supplied, the axes
   with the same indices as the 2 used pixel axes within the NDF
   are used. [!]
3 XMAGN
XMAGN = _REAL (Read)
   The horizontal magnification for the image.  The default
   value of 1.0 corresponds to 'normal' magnification in which the
   the image fills the available space in at least one dimension.
   A value larger than 1.0 makes each data pixel wider. If this
   results in the image being wider than the available space then
   the the image will be clipped to display fewer pixels. See also
   parameters YMAGN, CENTRE and FILL. [1.0]
3 YMAGN
YMAGN = _REAL (Read)
   The vertical magnification for the image.  The default
   value of 1.0 corresponds to 'normal' magnification in which the
   the image fills the available space in at least one dimension.
   A value larger than 1.0 makes each data pixel taller. If this
   results in the image being taller than the available space then
   the image will be clipped to display fewer pixels. See also
   parameters XMAGN, CENTRE and FILL. If a null (!) value is supplied,
   the value used is the value supplied for XMAGN. [!]
2 Examples
display ngc6872 mode=p percentiles=[10,90] noaxes
   Displays the NDF called ngc6872 on the current image-display
   device.  The scaling is between the 10 and 90 per cent
   percentiles of the image. No annotated axes are produced.

display vv256 mode=flash noaxes border borstyle="colour=blue,style=2"
   Displays the NDF called vv256 on the current image-display
   device.  There is no scaling of the data; instead the modulus
   of each pixel with respect to the number of colour-table
   indices is shown.  No annotated axes are drawn, but a blue border
   is drawn around the image using PGPLOT line style number 2 (i.e.
   dashed lines).

display mode=fa axes style="^sty,grid=1" margin=0.2 clear out=video \
   Displays the current NDF data component with annotated axes
   after clearing the current picture on the current image-display
   device. The appearance of the axes is specified in the text
   file sty, but this is modified by setting the Grid attribute
   to 1 so that a co-ordinate grid is drawn across the plot. The
   margins around the image containing the axes are made slightly
   wider than normal. The scaling is between the -1 and +7 standard
   deviations of the image around its mean. The scaled data are
   stored in an NDF called video.

display video noscale \
   Displays the data component of the NDF called video (created
   in the previous example) without scaling within the current
   picture on the current image-display device.

display in=cgs4a comp=v mode=sc low=1 high=5.2 device=xwindows
   Displays the variance component of NDF cgs4a on the xwindows
   device, scaling between 1 and 5.2.

display mydata centre="12:23:34 -22:12:23" xmagn=2 badcol="red" \
   Displays the NDF called mydata centred on the position RA=12:23:34,
   DEC=-22:12:23. This assumes that the current co-ordinate Frame in the
   NDF is an equatorial (RA/DEC) Frame. The image is displayed with
   a magnification of 2 so that each data pixel appears twice as large
   (on each axis) as normal. Fewer data pixels may be displayed
   to ensure the image fits within the available space in the current
   picture. The current scaling is used, and bad pixels are shown
   in red.

display ngc6872 mode=ra device=lj250 lut=pizza
   Displays the NDF called ngc6872 on the LJ250 device. The
   lookup table in the NDF called pizza is mapped on the LJ250's
   colour table.  The scaling is between the minimum and maximum
   of the image.
2 Notes
-  For large images the resolution of the graphics device may allow
only a fraction of the detail in the data to be plotted.  Therefore,
large images will be compressed by block averaging when this can be
done without loss of resolution in the displayed image.  This saves
time scaling the data and transmitting them to the image display.
Note that the default values for parameters LOW and HIGH are
the minimum and maximum values in the compressed floating-point
data.

-  The Title component in the NDF is used as the default title for
the annotated axes. If the NDF does not have a Title component, then
the default title is taken from current co-ordinate Frame in the NDF. This
default may be over-ridden by specifying a value for the Title
attribute using the STYLE parameter.

-  The application stores a number of pictures in the graphics
database in the following order: a FRAME picture containing the
annotated axes, the image area, and the border; a DATA picture
containing just the image area. Note, the FRAME picture is only
created if annotated axes or a border have been drawn, or if non-zero
margins were specified using parameter MARGIN. The world co-ordinates
in the DATA picture will be pixel co-ordinates. A reference to the
supplied NDF, together with a copy of the WCS information in the NDF
are stored in the DATA picture. On exit the current database picture
for the chosen device reverts to the input picture.

-  The data type of the output NDF depends on the number of colour
indices: _UBYTE for no more than 256, _UWORD for 257 to 65535,
and _INTEGER otherwise.   The output NDF will not contain any
extensions, UNITS, QUALITY, and VARIANCE; but LABEL, TITLE, WCS and
AXIS information are propagated from the input NDF.  The output
NDF does not become the new current data array.  It is a Simple
NDF (because the bad-pixel flag is set to false in order to
access the maximum colour index, and to handle sections),
therefore only NDF-compliant applications can process it.
2 Related_Applications
   KAPPA: WCSFRAME, PICDEF; Figaro: IGREY, IMAGE; SPECDRE: MOVIE.
2 Authors
MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 1990 July 12 (MJC):
    Original version based on the pre-V0.7 DISPLAY.

 1990 August 19 (MJC):
    Only the visible portion is scaled and displayed.  Redefined
    CENTRE (ex XCENTR and YCENTR) in terms of image pixels.

 1990 November 9 (MJC):
    Block averaging added.

 1991 February 7 (MJC):
    Added NDF reference into the database, AGI context control and
    removed fuzzy-picture fudge.

 1991 March 19 (MJC):
    Added output parameters for the scaling limits.

 1991 April 4 (MJC):
    Added data co-ordinate transformation.

 1991 May 7 (MJC):
    Added the input and output of NDFs containing scaled data.

 1991 May 14 (MJC):
    Added direct processing of _BYTE and _WORD data.

 1991 July 22 (MJC):
    Added coloured-border option, and user-controlled colouring of
    bad pixels.

 1991 July 31 (MJC):
    No longer redefines first SGS pen to white if workstation has
    dynamic colour representation, now there is palette control.

 1991 August 20 (MJC):
    Added FONT parameter.

 1991 August 22 (MJC):
    Added input lookup-table facility via LUT and NN parameters,
    and an illustrative example of same.

 1992 January 22 (MJC):
    Fixed a bug that could cause the NOSCALE option to scale.

 1992 March 3 (MJC):
    Replaced AIF parameter-system calls by the extended PAR
    library.

 1992 March 30 (MJC):
    Revised defaulting behaviour of BADCOL and BCOLOUR, and
    corrected the notes.  Added an example of their use.  Handles
    arbitrary user-defined 2-d sections.

 1992 November 27 (MJC):
    Does not use non-monotonic axis centres.

 1992 December 17 (MJC):
    Added the FILL option.

 1995 October 19 (MJC):
    Supports Error component.

 1997 May 28 (MJC):
    QUALITY and HISTORY no longer propagated to the OUT NDF.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.

 14-JUL-1998 (DSB):
    Use '_DOUBLE' instead of 'DOUBLE' in call to NDF_MTYPE.

 26-AUG-1998 (DSB)
    Radical changes to use AST and PGPLOT.

 3-SEP-1999 (DSB):
    Added NULL argument to KPG1_GTPOS call.

 18-OCT-1999 (DSB):
    Added parameters KEY, KEYPOS and KEYSTYLE.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   VARIANCE, LABEL, TITLE, WCS and UNITS components of the input NDF.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  This application will handle data in all numeric types, though
   type conversion to integer will occur for unsigned byte and word
   images.  However, when there is no scaling only integer data will
   not be type converted, but this is not expensive for the expected
   byte-type data.

1 DIV
Divides one NDF data structure by another.

Usage:

   div in1 in2 out

Description:

   The routine divides one NDF data structure by another
   pixel-by-pixel to produce a new NDF.
2 Parameters
For information on individual parameters, select from the list below:
3 IN1
IN1 = NDF (Read)
   First NDF, to be divided by the second NDF.
3 IN2
IN2 = NDF (Read)
   Second NDF, to be divided into the first NDF.
3 OUT
OUT = NDF (Write)
   Output NDF to contain the ratio of the two input NDFs.
3 TITLE
TITLE = LITERAL (Read)
   Value for the title of the output NDF.  A null value will cause
   the title of the NDF supplied for parameter IN1 to be used
   instead. [!]
2 Examples
div a b c
   This divides the NDF called a by the NDF called b, to make the
   NDF called c.  NDF c inherits its title from a.

div out=c in1=a in2=b title="Normalised data"
   This divides the NDF called a by the NDF called b, to make the
   NDF called c.  NDF c has the title "Normalised data".
2 Notes
If the two input NDFs have different pixel-index bounds, then
they will be trimmed to match before being divided.  An error will
result if they have no pixels in common.
2 Related_Applications
   KAPPA: ADD, CADD, CDIV, CMULT, CSUB, MATHS, MULT, SUB.
2 Authors
RFWS: R.F. Warren-Smith (STARLINK)

MJC: Malcolm J. Currie (STARLINK)
2 History
 9-APR-1990 (RFWS):
    Original version.

 1992 January 15 (MJC):
    Added Usage and Examples items.

 1995 September 12 (MJC):
    Title inherited by default.  Usage and examples to lowercase.
    Added Related Applications.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   LABEL, TITLE, HISTORY, and VARIANCE components of an NDF data
   structure and propagates all extensions.

   -  Units processing is not supported at present and therefore the
   UNITS component is not propagated.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.
   Calculations will be performed using either real or double
   precision arithmetic, whichever is more appropriate.  If the
   input NDF structures contain values with other data types, then
   conversion will be performed as necessary.
1 DRAWSIG
Draws +/-n standard-deviation lines on a line plot.

Usage:

   drawsig ndf nsigma [axis] [comp]

Description:

   This routine draws straight lines on an existing plot stored in
   the graphics database, such as produced by LINPLOT or HISTOGRAM.
   The lines are located at arbitrary multiples of the standard
   deviation (NSIGMA) either side of the mean of a given dataset.
   The default dataset is the one used to draw the existing plot.
   You can plot the lines horizontally or vertically as appropriate.
   The lines extend the full width or height of the plot's data
   area.  Up to five different multiples of the standard deviation
   may be presented in this fashion. Each line can be drawn with a
   different style (see parameter STYLE).

   The application also computes statistics for those array values
   that lie between each pair of plotted lines.  In other words it
   finds the statistics between clipping limits defined by each
   2*NSIGMA range centred on the unclipped mean.

   The task tabulates NSIGMA, the mean, the standard deviation, and
   the error in the mean after the application of each pair of
   clipping limits.  For comparison purposes the first line of the
   table presents these values without clipping.  The table is
   written at the normal reporting level.
2 Parameters
For information on individual parameters, select from the list below:
3 AXIS
AXIS = LITERAL (Read)
   The orientation of the lines, or put another way, the axis
   which represents data value.  Thus the allowed values are
   "Horizontal", "Vertical", "X", or "Y".  "Horizontal" is
   equivalent to "Y" and "Vertical" is a synonym for "X".  On
   LINPLOT output AXIS would be "Y", but on a plot from HISTOGRAM
   it would be "X".  The suggested default is the current value.
   ["Y"]
3 COMP
COMP = LITERAL (Read)
   The name of the NDF array component from which to derive the
   mean and standard deviation used to draw the lines: "Data",
   "Error", "Quality" or "Variance" (where "Error" is the
   alternative to "Variance" and causes the square root of the
   variance values to be taken before computing the statistics).
   If "Quality" is specified, then the quality values are treated
   as numerical values (in the range 0 to 255).  ["Data"]
3 DEVICE
DEVICE = DEVICE (Read)
   The graphics device to draw the sigma lines on.
   [Current graphics device]
3 NDF
NDF = NDF (Read)
   The NDF structure containing the data array whose error limits
   are to be plotted.  Usually this parameter is not defined
   thereby causing the statistics to be derived from the dataset
   used to draw the plot.  If, however, you had plotted a section
   of a dataset but wanted to plot the statistics from the whole
   dataset, you would specify the full dataset with parameter NDF.
   [The dataset used to create the existing plot.]
3 NSIGMA
NSIGMA() = _REAL (Read)
   Number of standard deviations about the mean at which the
   lines should be drawn.  The null value or 0.0 causes a line to
   be drawn at the mean value.
3 STYLE
STYLE = GROUP (Read)
   A group of attribute settings describing the plotting style to use
   for the lines.

   A comma-separated list of strings should be given in which each
   string is either an attribute setting, or the name of a text file
   preceded by an up-arrow character "^". Such text files should
   contain further comma-separated lists which will be read and
   interpreted in the same manner. Attribute settings are applied in
   the order in which they occur within the list, with later settings
   over-riding any earlier settings given for the same attribute.

   Each individual attribute setting should be of the form:

      <name>=<value>

   where <name> is the name of a plotting attribute, and <value> is
   the value to assign to the attribute. Default values will be
   used for any unspecified attributes. All attributes will be
   defaulted if a null value (!) is supplied. See section "Plotting
   Attributes" in SUN/95 for a description of the available
   attributes. Any unrecognised attributes are ignored (no error is
   reported).

   The attributes Colour(Curves), Width(Curves), etc, can be used to
   specify the style for the lines ("Lines" is recognised as a
   synonymn for "Curves"). These values apply to all lines unless
   subsequent attributes over-ride them. Attributes for individual
   clipping levels can be given by replacing "Curves" above by a
   string of the form "Nsig<i>" where "<i>" is an integer index into
   the list of clipping levels supplied for parameter NSIGMA. Thus,
   "Colour(Nsig1)" will set the colour for the lines associated with
   the first clipping level, etc. The attribute settings can be
   restricted to one of the two lines by appending either a "+" or a
   "-" to the "Nsig<i>" string. Thus, "Width(Nsig2-)" sets the line
   width for the lower of the two lines associated with the second
   clipping level, and "Width(Nsig2+)" sets the width for the upper
   of the two lines. [current value]

2 Examples
drawsig nsigma=3 style='style=1'
   This draws solid horizontal lines on the last DATA picture on
   the current graphics device located at plus and minus 3
   standard deviations about the mean.  The statistics come from
   the data array used to draw the DATA picture.

drawsig phot 2.5
   This draws horizontal plus and minus 2.5 standard-deviation
   lines about the mean for the data in the NDF called phot on
   the default graphics device.

drawsig phot 2.5 style='"colour(nsig1-)=red,colour(nsig1+)=green"'
   As above, but the lower line is drawn in red and the upper line
   is drawn in green.

drawsig cluster [2,3] X Error
   This draws vertical lines at plus and minus 2 and 3
   standard deviations about the mean for the error data in the
   NDF called cluster on the default graphics device.

drawsig device=xwindows phot(20:119) 3 style="'colour=red,style=4'"
   This draws red dotted horizontal lines on the xwindows device
   at +/- 3 standard deviations using the 100 pixels in NDF
   phot(20:119).
2 Notes
There must be an existing DATA picture stored within the graphics
database for the chosen device.  Lines will only be plotted
within this picture.
2 Related_Applications
   KAPPA: HISTOGRAM, LINPLOT, MLINPLOT, STATS.
2 Authors
TIMJ: Tim Jenness (JACH)

MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 1996 October 14 (TIMJ):
    Original version

 1996 October 16 (MJC):
    Expanded the documentation.  Fixed a bug that caused the final
    line always to be solid.  Added AXIS parameter.  Standardised
    the code style.  Renamed parameter LINSTYLE to LINESTYLE.

 6-MAY-1998 (DSB):
    Update the GKS workstation after changing polyline
    representations, and do not re-instate original representations
    at end. This prevents the screen being cleared when the
    workstation is closed.

 27-OCT-1999 (DSB):
    Major changes to use AST/PGPLOT for the graphics.
2 Implementation_Status
   -  This routine correctly processes the DATA, VARIANCE, and
   QUALITY, components of the NDF.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.  The
   statistics are calculated using double-precision floating point.

   -  Any number of NDF dimensions is supported.
1 ELPROF
Creates a radial or azimuthal profile of a 2-dimensional image.

Usage:

   elprof in out nbin xc yc { angmaj=?
                            { ratio=?
                            { rmin=?
                            { rmax=?
                            radial

Description:

   This application will bin the input image into elliptical
   annuli, or into a `fan' of adjacent sectors, centred on a
   specified position. The typical data values in each bin are
   found (see parameter ESTIMATOR), and stored in a
   1-dimensional NDF which can be examined using LINPLOT,
   INSPECT, etc.  A 2-dimensional mask image can optionally be
   produced indicating which bin each input pixel was placed
   in.

   If radial binning is selected (the default), then each bin
   is an elliptical annulus of shape and size determined by
   parameters RMIN, RMAX, ANGMAJ, RATIO, XC, YC, and WIDTH.
   The bins can be restricted to a specified sector of these
   annuli using parameter ANGLIM.

   If azimuthal binning is selected, then each bin is a sector
   (i.e. a wedge-shape), with its vertex given by parameters XC
   and YC, and its opening angle given by parameters WIDTH.
   The range of azimuthal angles to be binned can be specified
   by parameter ANGLIM.  The bins can be restricted to the
   intersection of these sectors with an elliptical annulus by
   specified values for parameters RMIN, RMAX, ANGMAJ and
   RATIO.
2 Parameters
For information on individual parameters, select from the list below:
3 ANGLIM
ANGLIM( 2 ) = _REAL (Read)
   Defines the wedge-shaped sector within which binning is to be
   performed.  The first value should be the azimuthal angle of
   the clockwise boundary of the sector, and the second should be
   the azimuthal angle of the anti-clockwise boundary.  The angles
   are measured in degrees from the x-axis, and rotation from the
   x-axis to the y-axis is positive.  If only a single value is
   supplied, or if both values are equal, the sector starts at
   the given angle and extends for 360 degrees. [0]
3 ANGMAJ
ANGMAJ = _REAL (Read)
   The angle between the x-axis and the major axis of the
   ellipse, in degrees.  Rotation from the x-axis to the y-axis is
   positive.  If an azimuthal profile (see parameter RADIAL) is
   being produced a run-time default of zero is used, otherwise
   you will be prompted for a value. []
3 ESTIMATOR 
ESTIMATOR = LITERAL (Read)
   The method to use for estimating the output pixel values.  It
   can be either "Mean" or "Weighted Mean". If the weighted mean
   option is selected but no variances are available in the input
   data, the unweighted mean will be used instead. ["Mean"]
3 IN
IN = NDF (Read)
   The input NDF containing the 2-dimensional image from which a
   profile is to be generated.
3 MASK
MASK = NDF (Write)
   An output NDF of the same shape and size as the input NDF
   indicating the bin into which each input pixel was placed.
   For radial profiles, the bins are identified by a mask value
   equal to the radius (in pixels) measured on the major axis, at
   the centre of the annular bin.  For azimuthal profiles, the
   bins are identified by a mask value equal to the angle from
   the x-axis to the centre of the sector-shaped bin (in
   degrees).  If a null value is supplied, then no mask NDF is
   produced. [!]
3 MTITLE
MTITLE = LITERAL (Read)
   A title for the mask NDF.  If a null value is given, the title
   is propagated from the input NDF.  This is only prompted for
   if MASK is given a non-null value. ["Mask created by KAPPA -
   Elprof"]
3 NBIN
NBIN = _INTEGER (Read)
   The number of radial or azimuthal bins required.
3 OUT
OUT = NDF (Write)
   The output 1-dimensional NDF containing the required profile.
   For radial profiles, it has associated axis information
   describing the radius, in pixels, at the centre of each
   annular bin (the radius is measured on the major axis).  For
   azimuthal profiles, the axis information describes the
   azimuthal angle, in degrees, at the centre of each
   sector-shaped bin.  It will contain associated variance
   information if the input NDF has associated variance
   information.
3 RADIAL
RADIAL = _LOGICAL (Read)
   Specifies the sort of profile required.  If RADIAL is TRUE,
   then a radial profile is produced in which each bin is an
   elliptical annulus.  Otherwise, an azimuthal profile is
   produced in which each bin is a wedge-shaped sector. [TRUE]
3 RATIO
RATIO = _REAL (Read)
   The ratio of the length of the minor axis of the ellipse to
   the length of the major axis.  It must be in the range 0.0 to
   1.0.  If an azimuthal profile (see parameter RADIAL) is being
   produced a run-time default of 1.0 is used, otherwise you are
   prompted for a value. []
3 RMAX
RMAX = _REAL (Read)
   The radius in pixels, measured on the major axis, at the outer edge
   of the elliptical region to be binned.  If an azimuthal profile
   (see parameter RADIAL) is being produced, a large run-time
   default is used which results in the entire image being
   binned, otherwise you are prompted for a value. []
3 RMIN
RMIN = _REAL (Read)
   The radius in pixels, measured on the major axis, at the inner edge
   of the elliptical region to be binned.  If an azimuthal profile
   (see parameter RADIAL) is being produced a run-time default of
   0.0 is used, otherwise you are prompted a value. []
3 TITLE
TITLE = LITERAL (Read)
   A title for the output profile NDF.  If a null value is
   supplied the title is propagated from the input NDF. ["KAPPA -
   Elprof"]
3 WIDTH
WIDTH = _REAL (Read)
   The width of each bin.  If a radial profile is being created
   (see parameter RADIAL) this is the width of each annulus in
   pixels (measured on the major axis).  If an azimuthal profile
   is being created, it is the opening angle of each sector, in
   degrees.  The run-time default is chosen so that there are no
   gaps between adjacent bins.  Smaller values will result in gaps
   appearing between adjacent bins.  The supplied value must be
   small enough to ensure that adjacent bins do not overlap. []
3 XC
XC = _REAL (Read)
   The x pixel co-ordinate of the centre of the ellipse, and the
   vertex of the sectors.
3 YC
YC = _REAL (Read)
   The y pixel co-ordinate of the centre of the ellipse, and the
   vertex of the sectors.
2 Examples
elprof galaxy galprof 20 113 210 angmaj=49 rmin=10 rmax=210 ratio=0.5
   This example will create a 1-dimensional NDF called galprof
   containing a radial profile of the 2-dimensional NDF called
   galaxy.  The profile will contain 20 bins and it will be
   centred on the pixel co-ordinates (113,210).  Each bin will be
   an annulus of an ellipse with axis ratio of 0.5 and
   inclination of 49 degrees to the x-axis.  The image will be
   binned between radii of 10 pixels, and 210 pixels (measured on
   the major axis), and there will be no gaps between adjacent
   bins (i.e. each bin will have a width on the major axis of
   about 10 pixels).

elprof galaxy galprof 10 113 210 radial=f anglim=20 rmin=50

rmax=60
   This example also creates a 1-dimensional NDF called galprof,
   this time containing an azimuthal profile of the 2-dimensional
   NDF called "galaxy", containing 10 bins.  Each bin will be a
   wedge-shaped sector with vertex at pixel co-ordinates
   (113,210).  The clockwise edge of the first bin will be at an
   angle of 20 degrees to the x-axis, and each bin will have a
   width (opening angle) of 36 degrees (so that 360 degrees are
   covered in total).  Only the section of each sector bounded by
   radii of 50 and 60 pixels is included in the profile.  In this
   case the default value of 1.0 is accepted for parameter RATIO
   and so the bins will form a circular annulus of width 10
   pixels.
2 Related_Applications
   ESP: ELLFOU, ELLPRO, SECTOR.
2 Authors
DSB: David Berry (STARLINK)

MJC: Malcolm J. Currie (STARLINK)
2 History
 2-FEB-1995 (DSB):
    Original version.

 1995 March 27 (MJC):
    Some improvements to the documentation, removed tabs, used
    modern variable-declaration style and other stylish changes,
    removed long lines, mapped the input arrays together for
    efficiency.

 13-JUN-2001 (DSB):
    Added parameter ESTIMATOR.
2 Implementation_Status
   -  This routine correctly processes the DATA, VARIANCE, TITLE,
   UNITS, and HISTORY components of the input NDF.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.  Arithmetic
   is performed using single-precision floating point.
1 ERASE
Erases an HDS object.

Usage:

   erase object

Description:

   This routine erases a specified HDS object or container file.  If
   the object is a structure, then all the structure's components
   (and sub-components, etc.) are also erased.  If a slice or cell of
   an array is specified, then the entire array is erased.
2 Parameters
For information on individual parameters, select from the list below:
3 OBJECT
OBJECT = UNIV (Write)
   The HDS object or container file to be erased.
3 OK
OK = _LOGICAL (Read)
   This parameter is used to seek confirmation before an object
   is erased.  If a TRUE value is given, then the HDS object will
   be erased.  If a FALSE value is given, then the object will not
   be erased and a message will be issued to this effect.
2 Examples
erase horse
   This erases the HDS container file called horse.sdf.

erase fig123.axis
   This erases the AXIS component of the HDS file called
   fig123.sdf.  If AXIS is a structure, all its components are
   erased too.

erase fig123.axis(1).label
   This erases the LABEL component within the first element of
   the AXIS structure of the HDS file called fig123.sdf.

erase $AGI_USER/agi_restar.agi_3200_1
   This erases the AGIDEV_3200_1 structure of the HDS file called
   $AGI_USER/agi_restar.sdf.
2 Related_Applications
   Figaro: CREOBJ, DELOBJ, RENOBJ.
2 Authors
RFWS: R.F. Warren-Smith (STARLINK)

MJC: Malcolm J. Currie (STARLINK)
2 History
 5-APR-1990 (RFWS):
    Original version.

 6-APR-1990 (RFWS):
    Added workaround for HDS top-level locator problem.

 1992 February 7 (MJC):
    Added Usage and Examples items.

 1995 April 24 (MJC):
    Made usage and examples lowercase.  Added Related Applications.
    Sorted the variable declarations.
1 ERRCLIP
Removes pixels with large errors from an NDF.

Usage:

   errclip in out limit [mode]

Description:

   This application produces a copy of the input NDF in which pixels
   with errors greater than a specified limit are set invalid in
   both DATA and VARIANCE components.  The error limit may be
   specified as the maximum acceptable standard deviation (or
   variance), or the minimum acceptable signal-to-noise ratio.
2 Parameters
For information on individual parameters, select from the list below:
3 IN
IN = NDF (Read)
   The input NDF.  An error is reported if it contains no VARIANCE
   component.
3 OUT
OUT = NDF (Write)
   The output NDF.
3 LIMIT
LIMIT = _DOUBLE (Read)
   Either the maximum acceptable standard deviation or variance
   value, or the minimum acceptable signal-to-noise ratio
   (depending on the value given for MODE).  It must be positive.
3 MODE
MODE = LITERAL (Read)
   Determines how the value supplied for LIMIT is to be
   interpreted: "Sigma" for a standard deviation, "Variance"
   for variance, or "SNR" for minimum signal-to-noise ratio.
   ["Sigma"]
2 Examples
errclip m51 m51_good 2.0
   The NDF m51_good is created holding a copy of m51 in which all
   pixels with standard deviation greater than 2 are set invalid.

errclip m51 m51_good 2.0 snr
   The NDF m51_good is created holding a copy of m51 in which all
   pixels with a signal-to-noise ratio less than 2 are set
   invalid.

errclip m51 m51_good mode=v limit=100
   The NDF m51_good is created holding a copy of m51 in which all
   pixels with a variance greater than 100 are set invalid.
2 Notes
-  The limit and the number of rejected pixels are reported.

-  A pair of output data and variance values are set bad when
either of the input data or variances values is bad.

-  For MODE="SNR" the comparison is with respect to the absolute
data value.
2 Related_Applications
   KAPPA: FFCLEAN, PASTE, SEGMENT, SETMAGIC, THRESH.
2 Authors
DSB: David Berry (STARLINK)

MJC: Malcolm J. Currie (STARLINK)
2 History
 16-SEP-1993 (DSB):
    Original version.

 1995 April 11 (MJC):
    Renamed parameter TYPE to MODE.  Added Notes, Implementation
    Status, Related Applications sections, and two additional
    examples.  Corrected typo's.  Made the array mapping more
    efficient.  Made message reporting conditional.  Ensured that
    the LIMIT could not be zero. Used a modern-style of variable
    declaration and other minor stylistic changes.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   VARIANCE, LABEL, TITLE, UNITS, WCS and HISTORY components of an NDF
   data structure and propagates all extensions.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.  The output
   NDF has the same numeric type as the input NDF.  However, all
   internal calculations are performed in double precision.
1 EXP10
Takes the base-10 exponential of an NDF data structure.

Usage:

   exp10 in out

Description:

   This routine takes the base-10 exponential of each  pixel of a NDF
   to produce a new NDF data structure.

   This command is a synonym for "expon base=10D0".
2 Parameters
For information on individual parameters, select from the list below:
3 IN
IN = NDF (Read)
   Input NDF data structure.
3 OUT
OUT = NDF (Write)
   Output NDF data structure being the exponential of the input NDF.
3 TITLE
TITLE = LITERAL (Read)
   Value for the title of the output NDF.  A null value will cause
   the title of the NDF supplied for parameter IN to be used
   instead. [!]
2 Examples
exp10 a b
   This takes exponentials to base ten of the pixels in the NDF
   called a, to make the NDF called b.  NDF b inherits its title
   from a.

exp10 title="Abell 4321" out=b in=a
   This takes exponentials to base ten of the pixels in the NDF
   called a, to make the NDF called b.  NDF b has the title
   "Abell 4321".
2 Related_Applications
   KAPPA: LOG10, LOGAR, LOGE, EXPE, EXPON, POW; Figaro: IALOG, ILOG,
   IPOWER.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1997 June 13 (MJC):
    Original NDF version.
 1997 November 5 (MJC):
    Added WCS propagation.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   LABEL, TITLE, UNITS, HISTORY, WCS, and VARIANCE components of an
   NDF data structure and propagates all extensions.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.

1 EXPE
Takes the natural exponential of an NDF data structure.

Usage:

   expe in out

Description:

   This routine takes the natural exponential of each pixel of a NDF
   to produce a new NDF data structure.

   This command is a synonym for "expon base=natural".
2 Parameters
For information on individual parameters, select from the list below:
3 IN
IN = NDF (Read)
   Input NDF data structure.
3 OUT
OUT = NDF (Write)
   Output NDF data structure being the exponential of the input NDF.
3 TITLE
TITLE = LITERAL (Read)
   Value for the title of the output NDF.  A null value will cause
   the title of the NDF supplied for parameter IN to be used
   instead. [!]
2 Examples
expe a b
   This takes the natural exponential of the pixels in the NDF called
   a, to make the NDF called b.  NDF b inherits its title from a.

expe title="Cas A" out=b in=a
   This takes the natural exponential of the pixels in the NDF called
   a, to make the NDF called b.  NDF b has the title "Cas A".
2 Related_Applications
   KAPPA: LOG10, LOGAR, LOGE, EXP10, EXPON, POW; Figaro: IALOG, ILOG,
   IPOWER.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1997 June 13 (MJC):
    Original NDF version.
 1997 November 5 (MJC):
    Added WCS propagation.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   LABEL, TITLE, UNITS, HISTORY, WCS, and VARIANCE components of an
   NDF data structure and propagates all extensions.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.

1 EXPON
Takes the exponential (specified base) of an NDF data structure.

Usage:

   expon in out base

Description:

   This routine takes the exponential to a specified base of each
   pixel of a NDF to produce a new NDF data structure.
2 Parameters
For information on individual parameters, select from the list below:
3 BASE
BASE = LITERAL (Read)
   The base of the exponential to be applied.  A special value
   "Natural" gives natural (base-e) exponentiation.
3 IN
IN = NDF (Read)
   Input NDF data structure.
3 OUT
OUT = NDF (Write)
   Output NDF data structure being the exponential of the input NDF.
3 TITLE
TITLE = LITERAL (Read)
   Value for the title of the output NDF.  A null value will cause
   the title of the NDF supplied for parameter IN to be used
   instead. [!]
2 Examples
expon a b 10
   This takes exponentials to base ten of the pixels in the NDF
   called a, to make the NDF called b.  NDF b inherits its title
   from a.

expon base=8 title="HD123456" out=b in=a
   This takes exponentials to base eight of the pixels in the NDF
   called a, to make the NDF called b.  NDF b has the title
   "HD123456".
2 Related_Applications
   KAPPA: LOG10, LOGAR, LOGE, EXP10, EXPE, POW; Figaro: IALOG, ILOG,
   IPOWER.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1997 June 13 (MJC):
    Original NDF version.
 1997 November 5 (MJC):
    Added WCS propagation.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   LABEL, TITLE, UNITS, HISTORY, WCS, and VARIANCE components of an
   NDF data structure and propagates all extensions.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.

1 Feedback
Bug reports should be mailed to ussc@star.rl.ac.uk in the normal
way.  

Constructive comments are always welcome.  If you wish to suggest
new tasks or enhancements to existing ones please contact the
author.  Small jobs may be undertaken quite quickly.  Requests
involving substantial pieces of work need to gain the support of
others to be included in Starlink's, and so the best way to
influence the priority given to KAPPA is to contact the chairman of
the Image Processing Software Strategy Group.  The Starlink
World-Wide-Web pages will periodically contain news of plans and
work in progress.
1 FFCLEAN
Removes defects from a substantially flat 1- or 2-dimensional NDF.

Usage:

   ffclean in out clip box [thresh] [wlim] [ilevel]

Description:

   This application cleans a 1- or 2-dimensional NDF by removing
   defects smaller than a specified size.  The defects are flagged
   with the bad value.  The defects are found by looking for pixels
   that deviate from the image's smoothed version by more than an
   arbitrary number of standard deviations from the local mean,
   and that lie within a specified range of values.  Therefore, the
   image must be substantially flat.  The data variances provide the
   local-noise estimate for the threshold, but if these are not
   available a variance for the whole of the image is derived from
   the mean squared deviations of the original and smoothed images.
   The smoothed version of the image is obtained by block averaging
   over a rectangular box.  An iterative process progressively
   removes the outliers from the image.
2 Parameters
For information on individual parameters, select from the list below:
3 BOX
BOX( 2 ) = _INTEGER (Read)
   The x and y sizes (in pixels) of the rectangular box to be
   applied to smooth the image.  If only a single value is given,
   then it will be duplicated so that a square filter is used
   except where the image is 1-dimensional for which the box size
   along the insignificant dimension is set to 1.  The values
   given will be rounded up to positive odd integers if
   necessary.
3 CLIP
CLIP( ) = _REAL (Read)
   The number of standard deviations for the rejection threshold
   of each iteration.  Pixels that deviate from their counterpart
   in the smoothed image by more than CLIP times the noise are
   made bad.  The number of values given specifies the number of
   iterations.  Values should lie in the range 0.5--100.  Up to
   one hundred values may be given.  [3.0, 3.0, 3.0]
3 ILEVEL
ILEVEL = _INTEGER (Read)
   The interactive level of the routine.  When it is greater or
   equal to two, the application will report the intermediate
   results after each iteration during processing.  It should lie
   between 1 and 3. [2]
3 IN
IN = NDF (Read)
   The 1- or 2-dimensional NDF containing the input image to be
   cleaned.
3 OUT
OUT = NDF (Write)
   The NDF to contain the cleaned image.
3 SIGMA
SIGMA = _DOUBLE (Write)
   The estimation of the RMS noise per pixel of the output image.
3 THRESH
THRESH( 2 ) = _DOUBLE (Read)
   The range between which data values must lie if cleaning is to
   occur.  Thus it is possible to clean the background without
   removing the cores of images by a judicious choice of these
   thresholds.  If null, !, is given, then there is no limit on
   the data range. [!]
3 TITLE
TITLE = LITERAL (Read)
   The title of the output NDF.  A null (!) value means using the
   title of the input NDF. [!]
3 WLIM
WLIM = _REAL (Read)
   If the input image contains bad pixels, then this parameter
   may be used to determine the number of good pixels which must
   be present within the smoothing box before a valid output
   pixel is generated.  It can be used, for example, to prevent
   output pixels from being generated in regions where there are
   relatively few good pixels to contribute to the smoothed
   result.

   By default, a null (!) value is used for WLIM, which causes
   the pattern of bad pixels to be propagated from the input
   image to the output image unchanged.  In this case, smoothed
   output values are only calculated for those pixels which are
   not bad in the input image.

   If a numerical value is given for WLIM, then it specifies the
   minimum fraction of good pixels which must be present in the
   smoothing box in order to generate a good output pixel.  If
   this specified minimum fraction of good input pixels is not
   present, then a bad output pixel will result, otherwise a
   smoothed output value will be calculated.  The value of this
   parameter should lie between 0.0 and 1.0 (the actual number
   used will be rounded up if necessary to correspond to at least
   1 pixel). [!]
2 Examples
ffclean dirty clean \
   The NDF called dirty is filtered such that pixels that deviate
   by more than three standard deviations from the smoothed
   version of dirty are rejected.  Three iterations are performed.
   Each pixel in the smoothed image is the average of the
   neighbouring nine pixels.  The filtered NDF is called clean.

ffclean out=clean in=dirty thresh=[-100,200]
   As above except only those pixels whose values lie between -100
   and 200 can be cleaned.

ffclean poxy dazed [2.5,2.8] [5,5]
   The 2-dimensional NDF called poxy is filtered such that pixels
   that deviate by more than 2.5 then 2.8 standard deviations from
   the smoothed version of poxy are rejected.  The smoothing is an
   average of a 5-by-5-pixel neighbourhood.  The filtered NDF is
   called dazed.
2 Related_Applications
   KAPPA: CHPIX, FILLBAD, GLITCH, MEDIAN, MSTATS, ZAPLIN;
   Figaro: BCLEAN, COSREJ, CLEAN, ISEDIT, MEDFILT, MEDSKY, TIPPEX.
2 Authors
RFWS: R. F. Warren-Smith (STARLINK)

WG: Wei Gong  (STARLINK)

MJC: Malcolm J. Currie (STARLINK)
2 History
 1981 July (RFWS):
    Original INTERIM version.

 5-OCT-1990 (WG):
    Converted to the KAPPA/ADAM version.

 1991 June 30 (MJC):
    Made generic; completed and expanded the prologue, renaming
    some parameters for consistency with other applications;
    introduced WLIM parameter for fraction; corrected error
    reporting; and added thresholds.

 1992 March 3 (MJC):
    Replaced AIF parameter-system calls by the extended PAR
    library.

 1992 April 21 (MJC):
    Made to handle significant dimensions for user-defined
    sections.

 1992 December 17 (MJC):
    Sets the bad-pixel flag in the output NDF.

 1995 April 5 (MJC):
    Renamed from CLEANER to avoid name clash with Figaro.  Made to
    work on 1-dimensional arrays.  Used lowercase examples and
    usage.  Added Related Applications and additional commentary.
    Changed the default of TITLE to null.  Used PSX to obtain
    workspace.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   VARIANCE, LABEL, TITLE, UNITS, WCS and HISTORY components of an NDF
   data structure and propagates all extensions.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.  Arithmetic
   is performed using single- or double-precision floating point as
   appropriate.
1 FILLBAD
Removes regions of bad values from a 2-dimensional NDF.

Usage:

   fillbad in out [niter] [size]

Description:

   This application replaces bad values in a 2-dimensional NDF with
   a smooth function which matches the surrounding data.  It can fill
   arbitrarily shaped regions of bad values within images.

   It forms a smooth replacement function for the regions of bad
   values by forming successive approximations to a solution of
   Laplace's equation, with the surrounding valid data providing the
   boundary conditions.
2 Parameters
For information on individual parameters, select from the list below:
3 BLOCK
BLOCK = _INTEGER (Read)
   The maximum number of pixels along either dimension when the
   array is divided into blocks for processing.  It is ignored
   unless MEMORY=TRUE.  This must be at least 256.  [512]
3 CNGMAX
CNGMAX = _DOUBLE (Write)
   The maximum absolute change in output values which occurred in
   the final iteration.
3 CNGRMS
CNGRMS = _DOUBLE (Write)
   The root-mean-squared change in output values which occurred
   in the last iteration.
3 IN
IN = NDF (Read)
   The 2-dimensional NDF containing the input image with bad
   values.
3 MEMORY
MEMORY = _LOGICAL (Read)
   If this is FALSE, the whole array is processed at the same
   time.  If it is TRUE, the array is divided into chunks whose
   maximum dimension along an axis is given by parameter BLOCK.
   [FALSE]
3 NITER
NITER = INTEGER (Given)
   The number of iterations of the relaxation algorithm.  This
   value cannot be less than two, since this is the minimum
   number required to ensure that all bad values are assigned a
   replacement value.  The more iterations used, the finer the
   detail in the replacement function and the closer it will
   match the surrounding good data.  [2]
3 OUT
OUT = NDF (Write)
   The NDF to contain the image free of bad values.
3 SIZE
SIZE  = _REAL (Read)
   The initial scale length in pixels to be used in the first
   iteration.  For maximum efficiency, it should normally have a
   value about half the `size' of the largest invalid region to
   be replaced.  (See the Notes section for more details.) [5.0]
3 TITLE
TITLE = LITERAL (Read)
   The title of the output NDF.  A null (!) value means using the
   title of the input NDF. [!]
3 VARIANCE
VARIANCE = _LOGICAL (Read)
   If VARIANCE is TRUE, variance information is to be propagated;
   any bad values therein are filled.  Also the variance is used
   to weight the calculation of the replacement data values.  If
   VARIANCE is FALSE, there will be no variance processing thus
   requiring two less arrays in memory.  This parameter is only
   accessed if the input NDF contains a VARIANCE component.
   [TRUE]
2 Examples
fillbad aa bb
   The NDF called aa has its bad pixels replaced by good values
   derived from the surrounding good pixel values using two
   iterations of a relaxation algorithm.  The initial scale length
   is 5 pixels.  The resultant NDF is called bb.

fillbad aa bb 6 20 title="Cleaned image"
   As above except the initial scale length is 20 pixels, 5
   iterations will be performed, and the output title is "Cleaned
   image" instead of the title of NDF aa.

fillbad aa bb memory novariance
   As in the first example except that processing is performed
   with blocks up to 512 by 512 pixels to reduce the memory
   requirements, and no variance information will be used or
   propagated.
2 Notes
-  The algorithm is based on the relaxation method of repeatedly
replacing each bad pixel with the mean of its four nearest
neighbours.  Such a method converges to the required solution,
but information about the good regions only propagates at a rate
of about one pixel per iteration into the bad regions, resulting
in slow convergence if large areas are to be filled.

This application speeds convergence to an acceptable function by
forming the replacement mean from all the pixels in the same
image row and column, using a weight which decreases
exponentially with distance and goes to zero after the first good
pixel is encountered in any direction.  If there is variance
information, this is included in the weighting so as to give more
weight to surrounding values with lower variance.  The scale
length of the exponential weight is initially set large, to allow
rapid propagation of an approximate `smooth' solution into the
bad regions---an initially acceptable solution is thus rapidly
obtained (often in the first one or two iterations).  The scale
length is subsequently reduced by a factor of 2 whenever the
maximum absolute change occurring in an iteration has decreased
by a factor of 4 since the current scale length was first used.
In this way, later iterations introduce progressively finer
detail into the solution.  Since this fine detail occurs
predominantly close to the `crinkly' edges of the bad regions,
the slower propagation of the solution in the later iterations is
then less important.

When there is variance processing the output variance is
reassigned if either the input variance or data value was bad.
Where the input value is good but its associated variance is bad,
the calculation proceeds as if the data value were bad, except
that only the variance is substituted in the output.  The new
variance is approximated as twice the inverse of the sum of the
weights.

-  The price of the above efficiency means that considerable
workspace is required, typically two or three times the size of
the input image, but even larger for the one and two-byte integer
types.  If memory is at a premium, there is an option to process
in blocks (cf. parameter MEMORY).  However, this may not give as
good results as processing the array in full, especially when the
bad-pixel regions span blocks.

-  The value of the parameter SIZE is not critical and the
default value will normally prove effective.  It primarily
affects the efficiency of the algorithm on various size scales.
If the smoothing scale is set to a large value, large scale
variations in the replacement function are rapidly found, while
smaller scale variations may require many iterations.
Conversely, a small value will rapidly produce the small scale
variations but not the larger scale ones.  The aim is to select
an initial value SIZE such that during the course of a few
iterations, the range of size scales in the replacement function
are all used.  In practice this means that the value of SIZE
should be about half the size of the largest scale variations
expected.  Unless the valid pixels are very sparse, this is
usually determined by the `size' of the largest invalid region to
be replaced.

-  An error results if the input NDF has no bad values to replace.

-  The progress of the iterations is reported.
2 Timing
   The time taken increases in proportion to the value of NITER.
   Adjusting the SIZE parameter to correspond to the largest regions
   of bad values will reduce the processing time.  See the Notes
   section.
2 Related_Applications
   KAPPA: CHPIX, GLITCH, MEDIAN, ZAPLIN; Figaro: BCLEAN,
   COSREJ, CLEAN, ISEDIT, MEDFILT, MEDSKY, REMBAD, TIPPEX.
2 Authors
MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 1995 April 16 (MJC):
    Original version.  Some of the documentation was derived from
    R.F. Warren-Smith's EDRS manual.

 21-MAY-1998 (DSB):
    Check that input variances are not all bad or zero, and ignore
    them if they are.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   VARIANCE, LABEL, TITLE, UNITS, WCS and HISTORY components of an NDF
   data structure and propagates all extensions.

   -  Processing of bad pixels and automatic quality masking are
   supported.  The output bad-pixel flag is set to indicate no bad
   values in the data and variance arrays.

   -  All non-complex numeric data types can be handled.  Arithmetic
   is performed using single- or double-precision floating point as
   appropriate.
1 FITSDIN
Reads a FITS disc file composed of simple, group or table objects.

Usage:

   fitsdin files out [auto] fmtcnv [logfile] dscftable=? table=?

Description:

   This application reads selected disc-FITS files.  The files may
   be Basic (simple) FITS, and/or have TABLE extensions (Harten et
   al. 1988).

   The programme reads a simple or a random-groups-format FITS file
   (Wells et al. 1981; Greisen & Harten 1981), and writes the data
   into an NDF, and the headers into the NDF's FITS extension.
   Table-format files (Grosbol et al. 1988) are read, and the
   application creates two files: a text formatted table/catalogue
   and a FACTS description file (as used by SCAR) based upon the FITS
   header cards.  Composite FITS files can be processed.  You may
   specify a list of files, including wildcards.  A record of the
   FITS headers, and group parameters (for a group-format file) can
   be stored in a text file.

   There is an option to run in automatic mode, where the names of
   output NDF data structures are generated automatically, and you
   can decide whether or not format conversion is to be applied to
   all files (rather than being prompted for each).  This is very
   useful if there is a large number of files to be processed.  Even
   if you want unique file names, format-conversion prompting may be
   switched off globally.
2 Parameters
For information on individual parameters, select from the list below:
3 AUTO
AUTO = _LOGICAL (Read)
   It is TRUE if automatic mode is required, where the name of
   each output NDF structure or table file is to be generated by
   the application, and therefore not prompted; and a global
   format-conversion switch may be set.  In manual mode the FITS
   header is reported, but not in automatic.

   In automatic mode the application generates a filename
   beginning with the input filename, less any extension.  For
   example, if the input file was SATURN.FITS the filename of the
   output NDF would be SATURN.SDF, and an output table would be
   SATURN.DAT with a description file dscfSATURN.DAT.  If there
   are sub-files (more than one FITS object in the file) a suffix
   _<subfile> is appended.  So if SATURN.FITS comprised a simple
   file followed by a table, the table would be called
   SATURN_2.DAT and the description file DSCFSATURN_2.DAT.  For
   group format a suffix G<groupnumber> is appended.  Thus if
   SATURN.FITS is a group format file, the first NDF created
   would be called SATURN.SDF, the second would be SATURNG2.SDF.
   [FALSE]
3 DSCFTABLE
DSCFTABLE = FILENAME (Read)
   Name of the text file to contain the FACTS descriptors, which
   defines the table's format for SCAR.  Since SCAR is now
   deprecated, this parameter has little use, except perhaps to
   give a summary of the format of the file specified by parameter
   TABLE.  A null value (!) means that no description file will
   be created, so this is now the recommended usage.  If your
   FITS file comprises just tables, you should consider other
   tools such as the CURSA package, which has facilities for
   examining and processing ASCII and binary tables in FITS files.

   A suggested filename for the description file is reported
   immediately prior to prompting in manual mode.  It is the name
   of the catalogue, as written in the FITS header, with a "dscf"
   prefix.
3 ENCODINGS
ENCODINGS = LITERAL (Read)
   Determines which FITS keywords should be used to define the
   world co-ordinate information stored in NDF's WCS component.
   The allowed values (case-insensitive) are:

   "FITS-IRAF" --- This uses keywords CRVALi CRPIXi, CDi_j, and is the
     system commonly used by IRAF. It is described in the document
     "World Coordinate Systems Representations Within the FITS Format" 
     by R.J. Hanisch and D.G. Wells, 1988, available by ftp from
     fits.cv.nrao.edu /fits/documents/wcs/wcs88.ps.Z. 

   "FITS-WCS" --- This is the proposed FITS standard WCS encoding scheme
     described in the paper "Representation of celestial coordinates 
     in FITS" (http://www.cv.nrao.edu/fits/documents/wcs/wcs.html).
     It is very similar to FITS-IRAF but supports a wider range of
     projections and co-ordinate systems. Once the standard has been 
     agreed, this encoding should be understood by any FITS-WCS 
     compliant software and it is likely to be adopted widely for FITS 
     data in future. 

   "FITS-PC" --- This uses keywords CRVALi, CDELTi, CRPIXi, PCiiijjj, 
     etc, as described in a previous (now superceded) draft of the 
     above FITS world co-ordinate system paper by E.W.Greisen and 
     M.Calabretta.

   "FITS-AIPS" --- This uses conventions described in the document
     "Non-linear Coordinate Systems in AIPS" by Eric W. Greisen 
     (revised 9th September, 1994), available by ftp from 
     fits.cv.nrao.edu /fits/documents/wcs/aips27.ps.Z. It is currently 
     employed by the AIPS data analysis facility, so its use will 
     facilitate data exchange with AIPS. This encoding uses CROTAi 
     and CDELTi keywords to describe axis rotation and scaling.

   "DSS" --- This is the system used by the Digital Sky Survey, and 
     uses keywords AMDXn, AMDYn, PLTRAH, etc.

   "NATIVE" --- This is the native system used by the AST library (see
     SUN/210) and provides a loss-free method for transferring WCS
     information between AST-based application. It allows more
     complicated WCS information to be stored and retrieved than any of 
     the other encodings.

   A comma-separated list of up to six values may be supplied,
   in which case the value actually used is in the first in the
   list for which corresponding keywords can be found in the FITS
   header.
   
   A FITS header may contain keywords from more than one of these
   encodings, in which case it is possible for the encodings to
   be inconsistent with each other.  This may happen for instance
   if an application modifies the keyword associated with one
   encoding but fails to make equivalent modifications to the
   others.  If a null parameter value (!) is supplied for
   ENCODINGS, then an attempt is made to determine the most
   reliable encoding to use as follows.  If both native and
   non-native encodings are available, then the first non-native
   encoding to be found which is inconsistent with the native
   encoding is used.  If all encodings are consistent, then the
   native encoding is used (if present). [!]
3 FILES
FILES() = LITERAL (Read)
   A list of (optionally wild-carded) file specifications which
   identify the disc-FITS files to be processed.  Up to 10 values
   may be given, but only a single specification such as "*.FITS"
   is normally required.  Be careful not to include non-FITS files
   in this list.
3 FMTCNV
FMTCNV = _LOGICAL (Read)
   This specifies whether or not format conversion will occur.
   If FALSE, the HDS type of the data array in the NDF will be
   the equivalent of the FITS data format in the file (e.g.
   BITPIX = 16 creates a _WORD array).  If TRUE, the data array
   in the current file, or all files in automatic mode, will be
   converted from the FITS data type in the FITS file to _REAL in
   the NDF.  The conversion applies the values of the FITS
   keywords BSCALE and BZERO to the FITS data to generate the
   "true" data values.  If BSCALE and BZERO are not given in the
   FITS header, they are taken to be 1.0 and 0.0 respectively.
   The suggested default is TRUE.
3 GLOCON
GLOCON  = _LOGICAL (Read)
   If FALSE, a format-conversion query occurs for each FITS file.
   If TRUE, the value of parameter FMTCNV is obtained before any
   file numbers and will apply to all data arrays.  It is ignored
   in automatic mode---in effect it becomes true. [FALSE]
3 LOGFILE
LOGFILE = FILENAME (Read)
   The file name of the text log of the FITS header cards.
   For group-format data the group parameters are evaluated
   and appended to the full header.  The log includes the names of
   the output files used to store the data array or table. A null
   value (!) means that no log file is produced. [!]
3 OUT
OUT = NDF (Write)
   Output NDF structure holding the full contents of the FITS
   file.  If the null value (!) is given no NDF will be created.
   This offers an opportunity to review the descriptors before
   deciding whether or not the data are to be extracted.
3 TABLE
TABLE = FILENAME (Read)
   Name of the text file to contain the table itself, read from
   the file.  In manual mode, the suggested default filename is
   the name of description file less the "DSCF" prefix, or if
   there is no description file or if the description file does
   not have the DSCF prefix, the suggested name reverts to the
   catalogue name in the FITS header.
2 Examples
fitsdin files=*.fit auto nofmtcnv
   This reads all the files with extension "fit" in the default
   directory.  If the files were sao.fit and moimp.fit and each
   contained just an image array, the output NDFs will be sao and
   moimp respectively.  The data will not have format conversion.

fitsdin files=ccd.ifits fmtcnv logfile=jkt.log
   This reads the file ccd.ifits and processes all the FITS
   objects within it.  Integer data arrays are converted to real
   using the scale and zero found in the FITS header.  A record
   of the headers and the names of the output files are written
   to the text file jkt.log.

fitsdin files="*.*fits,*.mt" glocon fmtcnv
   This reads the files *.*fits and *.mt and processes all the
   FITS objects within them.  Integer data arrays are converted
   to real using the scale and zero found in the FITS header.
   Any IEEE-format data will not be converted although the global
   conversion switch is on.
2 References
   Wells, D.C., Greisen, E.W. & Harten, R.H. 1981,
      Astron. Astrophys. Suppl. Ser. 44, 363.
   Greisen, E.W. & Harten, R.H. 1981,
      Astron. Astrophys. Suppl. Ser. 44, 371.
   Grosbol, P., Harten, R.H., Greisen, E.W & Wells, D.C.
      1988 Astron. Astrophys. Suppl. Ser. 73, 359.
   Harten, R.H., Grosbol, P., Greisen, E.W & Wells, D.C.
      1988 Astron. Astrophys. Suppl. Ser. 73, 365.
2 Related_Applications
   KAPPA: FITSHEAD, FITSIMP, FITSIMP, FITSLIST; CONVERT: FITS2NDF;
   CURSA; Figaro: RDFITS.
2 Authors
MJC: Malcolm J. Currie (STARLINK)

RDS: Richard D. Saxton (STARLINK, Leicester)

DSB: David S. Berry (STARLINK)
2 History
 1990 December 4 (MJC):
    Original version.

 1991 February 28 (MJC):
    Added the NCARD argument for various revised FTS1_x calls.

 1991 October 10 (MJC):
    Fixed bug when GLOCON and FMTCNV set to true and dealing with
    IEEE-format data.

 1992 February 24 (MJC):
    Ensured that HDS file mapping will occur after tuning option
    is added.

 1992 March 3 (MJC):
    Replaced AIF parameter-system calls by the extended PAR
    library.

 1992 December (RDS):
    Modifications to improve the portability, including: BUFFER
    and RECORD now mapped as BYTE arrays and passed into the
    various subroutines as character arrays using descriptors
    created by GRP1_CDESC.  File names are obtained using GRP,
    wildcarding is done with a portable subroutine.  The FITS
    files are opened for sequential access on the VAX but for
    direct access on other platforms.  Calls to subroutines using
    the BUFFER and RECORD mapped arrays, have generally had their
    arguments reordered.

 1993 January 5 (MJC):
    Fixed bugs: tidied workspace, processing of integer data, and
    multiple FITS objects.

 1993 January 20 (MJC):
    Made to work for DECstations.

 1993 December 3 (MJC):
    Made to work for Alphas.

 1995 October 5 (MJC):
    Documentation overhaul.  Changed dynamic default of FMTCNV.

 1996 June 6 (MJC):
    Linux usage enabled.

 9-JUN-1998 (DSB):
    Added support for WCS component.
2 Implementation_Status
   -  The application processes files blocked at other than an
   integer multiple of 2880 bytes up to a maximum of 28800, provided
   it is a multiple of the number of bytes per data value.

   -  For simple or group format FITS:

      -  IEEE floating point is supported.

      -  If BUNIT is present its value will appear as the NDF's units
      component.

      -  If OBJECT is present its value will appear as the NDF's
      title component.

      -  If the BLANK item is present in the header, undefined pixels
      are converted from the BLANK value to Starlink-standard bad
      value during data conversion.

      -  An AXIS component will be stored in the NDF if the CRVALn
      keyword is present.  (n is the number of the dimension.)  If
      the CRPIXn keyword is absent it defaults to 1, and likewise
      for the CDELTn keyword.  The value of CRTYPEn is made the label
      of the axis structure.

   -  For groups format, a new NDF is created for each data array.
   The name of the NDF of the second and subsequent data arrays is
   generated by the application as the <filename>G<number>, where
   <filename> is the name of the first NDF, you supply or generated
   automatically, and <number> is the number of the group.

   Each group NDF contains the full header in the FITS extension,
   appended by the set of group parameters.  The group parameters
   are evaluated using their scales and offsets, and made to look
   like FITS cards, whose keywords are derived from the values of
   PTYPEm in the main header.  (m is the number of the group
   parameter.) The same format is used in the log file.

   -  If there is no data array in the FITS file, i.e. the FITS file
   comprises header cards only, then a dummy vector data array of
   dimension two is created to make the output a valid NDF.  This
   data array is undefined.
1 FITSEDIT
Edits the FITS extension of an NDF.

Usage:

   fitsedit ndf

Description:

   This procedure allows you to use your favourite editor to
   modify the FITS headers stored in an NDF's FITS extension.
   There is limited validation of the FITS headers after editing.
   A FITS extension is created if the NDF does not already have 
   one.
2 Parameters
For information on individual parameters, select from the list below:
3 NDF
NDF = NDF (Read)
   The name of the NDF whose FITS extension is to be edited.
2 Examples
fitsedit m51b
   This allows editing of the FITS headers in the NDF called m51b.
2 Notes
-  This uses the environmental variable, EDITOR, to select
the editor.  If this variable is undefined vi is assumed.

-  The script lists the headers to a temporary file; allows text
editing; and then replaces the former FITS extension with the
modified version, performing some validation at this stage.
2 Related_Applications
   KAPPA: FITSMOD, FITSEXP, FITSHEAD, FITSIMP, FITSLIST; Figaro: FITSKEYS.
2 Authors
Malcolm J. Currie (STARLINK)
David S. Berry (DSB):
2 History
 1994 September 28 (MJC):
    Original version.

 1994 November 4 (MJC):
    Added ADAM-like help and abort facility for the parameter.

 1996 January 16 (MJC):
    Added suggested default and search path for foreign data
    formats.

 5-JUN-1998 (DSB):
    Added facility to create a new FITS extension if there is no 
    existing FITS extension in the NDF.
1 FITSEXIST
Inquires whether or not a keyword exists in a FITS extension.

Usage:

   fitsexist ndf keyword

Description:

   This application reports whether or not a keyword exists in an
   NDF's FITS extension.

   It is a synonym for "fitsmod edit=exist mode=interface".
2 Parameters
For information on individual parameters, select from the list below:
3 KEYWORD
KEYWORD = LITERAL (Given)

   The name of the keyword whose existence in the FITS extension is
   to be tested.  A name may be compound to handle hierarchical
   keywords, and it has the form keyword1.keyword2.keyword3 etc.  The
   maximum number of keywords per FITS card is 20.  Each keyword must
   be no longer than 8 characters, and be a valid FITS keyword
   comprising only alphanumeric characters, hyphen, and underscore.
   Any lowercase letters are converted to uppercase and blanks are
   removed before comparison with the existing keywords.

   KEYWORD may have an occurrence specified in brackets []
   following the name.  This enables testing for the existence of
   multiple occurrences.  Note that it is not normal to have
   multiple occurrences of a keyword in a FITS header, unless it
   is blank, COMMENT or HISTORY.  Any text between the brackets
   other than a positive integer is interpreted as the first
   occurrence.

   The suggested value is the current value.
3 NDF
NDF = NDF (Read)
   The NDF containing the FITS keyword.
2 Examples
fitsexist abc bscale
   This reports TRUE or FALSE depending on whether or not the
   FITS keyword BSCALE exists in the FITS extension of the NDF
   called abc.

fitsexist ndf=abc keyword=date[2]
   This reports TRUE or FALSEdepending on whether or not the
   FITS there are at least two occurrences of the keyword DATE.

2 Related_Applications
   KAPPA: FITSEDIT, FITSHEAD, FITSLIST, FITSMOD, FITSVAL.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1996 December 4 (MJC):
    Original version.
1 FITSEXP
Exports NDF-extension information into an NDF FITS extension.

Usage:

   fitsexp ndf table

Description:

   This application places the values of components of an NDF
   extension into the FITS extension within the same NDF.  This
   operation is needed if auxiliary data are to appear in the header
   of a FITS file converted from the NDF.  The list of extension
   components whose values are to be copied, their corresponding
   FITS keyword names, optional FITS inline comments, and the
   location of the new FITS header are specified in a "keyword
   translation table" held in a separate text file.
2 Parameters
For information on individual parameters, select from the list below:
3 NDF
NDF = NDF (Read and Write)
   The NDF in which the extension data are to be exported to
   the FITS extension.
3 TABLE
TABLE = FILE (Read)
   The text file containing the keyword translation table. The
   format of this file is described under "Table Format".
2 Examples
fitsexp datafile fitstable.txt
   This writes new FITS-extension elements for the NDF called
   datafile, creating the FITS extension if it does not exist.
   The selection of auxiliary components to export to the FITS
   extension, their keyword names, locations, and comments
   are under the control of a keyword translation table held in
   the file fitstable.txt.
2 Notes
-  Requests to assign values to the following reserved keywords
in the FITS extension are ignored: SIMPLE, BITPIX, NAXIS, NAXISn,
EXTEND, PCOUNT, GCOUNT, XTENSION, BLOCKED, and END.

-  Only scalar or one-element vector components may be
transferred to the FITS extension.

-  The data type of the component selects the type of the FITS
value.

-  If the destination keyword exists, the existing value and
comment are replaced with the new values.

-  If an error is found within a line, processing continues
to the next line and the error reported.

-  To be sure that the resultant FITS extension is what you
desired, you should inspect it using the command fitslist before
exporting the data.  If there is something wrong, you may find it
convenient to use command FITSEDIT to make minor corrections.
2 Timing
   Approximately proportional to the number of FITS keywords to be
   translated.
2 Table_Format
   The keyword translation table should be held in a text file, with
   one extension component specified per line.  Each line should
   contain two or three fields, separated by spaces and/or tabs, as
   follows.

   -  Field 1:
      The name of the input extension component whose value is to be
      copied to the FITS extension.  For example, CCDPACK.FILTER
      would copy the value of the component called FILTER in the
      extension called CCDPACK; and IRAS90.ASTROMETRY.EQUINOX would
      copy the value of component EQUINOX in the structure
      ASTROMETRY in the extension IRAS90.  The extension may not be
      FITS.

   -  Field 2:
      The name of the FITS keyword to which the value is to be
      copied.  Hierarchical keywords are not permissible.  The
      keyword name may be followed by a further keyword name in
      parentheses (and no spaces).  This second keyword defines the
      card before which the new keyword is to be placed.  If this
      second keyword is not present in the FITS extension or is not
      supplied, the new header card is placed at the end of the
      existing cards, but immediately before any END card.  For
      example, EQUINOX(EPOCH) would write the keyword EQUINOX
      immediately before the existing card with keyword EPOCH.  FITS
      keywords are limited to 8 characters and may only comprise
      uppercase alphabetic characters, digits, underscore, and
      hyphen.  While it is possible to have multiple occurrences of
      the same keyword in a FITS header, it is regarded as bad
      practice.  For this and efficiency reasons, this programme
      only looks for the first appearance of a keyword when
      substituting the values, and so only the last value inserted
      appears in the final FITS extension.  (See "Implementation
      Status".)

   -  Field 3:
      The comment to appear in the FITS header card for the chosen
      keyword.  This field is optional.  As much of the comment will
      appear in the header card as the value permits up to a maximum
      of 47 characters.

   Comments may appear at any point in the table and should begin
   with an exclamation mark.  The remainder of the line will then be
   ignored.
2 References
   "A User's Guide for the Flexible Image Transport System (FITS)",
   NASA/Science Office of Science and Technology (1994).
2 Related_Applications
   KAPPA: FITSEDIT, FITSHEAD, FITSLIST, FITSMOD; CONVERT: NDF2FITS.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1994 July 15 (MJC):
    Original version.

2 Implementation_Status
   -  The replacements are made in blocks of 32 to reduce the number
   of time-consuming shuffles of the FITS extension.  Thus it is
   possible to locate a new keyword before another keyword, provided
   the latter keyword appears in an earlier block, though reliance
   on this feature is discouraged; instead run the application
   twice.

   -  For each block the application inserts new cards or relocates
   old ones, marking each with different tokens, and then sorts the
   FITS extension into the requested order, removing the relocated
   cards.  It then inserts the new values.  If there are multiple
   occurrences of a keyword, this process can leave behind cards
   having the token value '{undefined'.
1 FITSHEAD
Lists the headers of FITS files.

Usage:

   fitshead file [block] [start] [finish]

Description:

   This procedure lists to standard output the headers of the primary
   header and data unit, and any extensions present that are
   contained within a set of input FITS files, or a range of
   specified files on a tape.
2 Parameters
For information on individual parameters, select from the list below:
3 FILE
FILE  = FILENAME (Read)
   A space-separated list of FITS files whose headers are to be
   listed, or the name of a single no-rewind tape device.  The list
   of files can include wildcard characters.
3 BLOCK
BLOCK = _INTEGER (Read)
   The FITS blocking factor of the tape to list.  This is the tape
   blocksize in bytes divided by the FITS record length of 2880
   bytes.  BLOCK must be a positive integer, between 1 and 12,
   otherwise you will be prompted for a new value.  Should the first
   argument not be a tape device, this argument will be treated as
   a file name. [1]
3 START
START = _INTEGER (Read)
   The first file on the tape to list.  This defaults to 1, i.e.
   the start of the tape.  It must be a positive integer,
   otherwise you will be prompted for a new value.  Should the
   first argument not be a tape device, this argument will be
   treated as a file name. [1]
3 FINISH
FINISH = _INTEGER (Read)
   The last file on the tape to list.  This defaults to the end
   of the tape.  It must be a positive integer and at least equal
   to the value of start, otherwise you will be prompted for a new
   value.  Should the first argument not be a tape device, this
   argument will be treated as a file name. []
2 Examples
fitshead /dev/nrmt1
   This lists the FITS headers for all the files of the tape mounted
   on device /dev/nrmt1.  The tape block size is 2880 bytes.

fitshead /dev/nrmt1 10 > tape.lis
   This lists to file tape.lis the FITS headers for all the files of
   the tape mounted on device /dev/nrmt1.  The tape blocking factor is
   10, the tape's blocksize is 28800 bytes.

fitshead /dev/rmt/0n 2 3 5 >> tape.lis
   This appends the FITS headers for files 3 to 5 of the tape mounted
   on device /dev/rmt/0n to the file tape.lis.  The tape blocking factor
   is 2, i.e. the tape's blocksize is 5760 bytes.

fitshead /dev/nrst2 prompt
   This lists the FITS headers for files of the tape mounted on
   device /dev/nrst2.  The command prompts you for the file limits
   and tape blocking factor.

fitshead ~/fits/*.fit ~/data/p?.fi* | lpr
   This prints the FITS headers in the files ~/fits/*.fit and
   ~/data/p?.fi*.
2 Notes
-  Prompting is directed to the standard error, so that the listings
may be redirected to a file.

-  If the blocking factor is unknown it is possible to obtain only
a part of the headers and some of the FITS data.  Unless the FITS
file is small, it is usually safe to set parameter BLOCK higher
than its true value.
2 Related_Applications
   KAPPA: FITSEDIT, FITSEXP, FITSIMP, FITSLIST; Figaro: FITSKEYS.
2 Authors
Malcolm J. Currie (STARLINK)
2 History
 1994 November 4 (MJC):
    Original version.

 1994 November 10 (MJC):
    Added ADAM-like prompting user interface.
1 FITSIMP
Imports FITS information into an NDF extension.

Usage:

   fitsimp ndf table xname xtype

Description:

   This application extracts the values of FITS keywords from a FITS
   extension in an NDF and uses them to construct another NDF
   extension.  The list of new extension components required, their
   data types and the names of the FITS keywords from which to
   derive their values are specified in a "keyword translation
   table" held in a separate text file.
2 Parameters
For information on individual parameters, select from the list below:
3 NDF
NDF = NDF (Read and Write)
   The NDF in which the new extension is to be created.
3 TABLE
TABLE = FILENAME (Read)
   The text file containing the keyword translation table.  The
   format of this file is described under "Table Format".
3 XNAME
XNAME = LITERAL (Read)
   The name of the NDF extension which is to receive the values
   read from the FITS extension.  If this extension does not
   already exist, then it will be created.  Otherwise, it should
   be a scalar structure extension within which new components
   may be created (existing components of the same name will be
   over-written).  Extension names may contain up to 15
   alpha-numeric characters, beginning with an alphabetic
   character.
3 XTYPE
XTYPE = LITERAL (Read)
   The HDS data type of the output extension.  This value will
   only be required if the extension does not initially exist and
   must be created.  New extensions will be created as scalar
   structures.
2 Examples
fitsimp datafile fitstable ccdinfo ccd_ext
   Creates a new extension called CCDINFO (with a data type of
   CCD_EXT) in the NDF structure called datafile.  Keyword values
   are read from the NDF's FITS extension and written into the new
   extension as separate components under control of a keyword
   translation table held in the file fitstable.

fitsimp ndf=n1429 table=std_table xname=std_extn
   FITS keyword values are read from the FITS extension in the
   NDF structure n1429 and written into the pre-existing
   extension STD_EXTN under control of the translation table
   std_table.  Components which already exist within the
   extension may be over-written by this process.
2 Timing
   Approximately proportional to the number of FITS keywords to be
   translated.
2 Table_Format
   The keyword translation table should be held in a text file, with
   one extension component specified per line.  Each line should
   contain 3 fields, separated by spaces and/or tabs, as follows.

   -  Field 1:
      The name of the component in the output extension for which a
      value is to be obtained.

   -  Field 2:
      The data type of the output component, to which the keyword
      value will be converted (one of _INTEGER, _REAL, _DOUBLE,
      _LOGICAL or _CHAR).

   -  Field 3:
      The name of the FITS keyword from which the value is to be
      obtained.  Hierarchical keywords are permissible; the format
      is concatenated keywords joined with full stops and no spaces,
      e.g. HIERARCH.ESO.NTT.HUMIDITY, ING.DETHEAD.

   Comments may appear at any point in the table and should begin
   with an exclamation mark. The remainder of the line will then be
   ignored.
2 Related_Applications
   KAPPA: FITSHEAD, FITSLIST, FITSDIN, FITSIN; CONVERT: FITS2NDF;
   Figaro: RDFITS.
2 Authors
RFWS: R.F. Warren-Smith (STARLINK, RAL)

MJC: Malcolm J. Currie (STARLINK)
2 History
 28-FEB-1991 (RFWS):
    Original version.

 1991 July 15 (MJC):
    Added hierarchical keywords.
1 FITSIN
Reads a FITS tape composed of simple, group or table files.

Usage:

   fitsin mt files out [auto] fmtcnv [logfile] more=? dscftable=?
      table=?

Description:

   This application reads selected files from a FITS tape.  The
   files may be Basic (simple) FITS, and/or have TABLE extensions
   (Harten et al. 1988).

   The programme reads a simple or a random-groups-format FITS file
   (Wells et al. 1981; Greisen & Harten 1981), and writes the data
   into an NDF, and the headers into the NDF's FITS extension.
   Table-format files (Grosbol et al. 1988) are read, and the
   application creates two files: a text formatted table/catalogue
   and a FACTS description file (as used by SCAR) based upon the FITS
   header cards.  Composite FITS files can be processed.  You may
   specify a list of files, including wildcards.  A record of the
   FITS headers, and group parameters (for a group-format file) can
   be stored in a text file.

   There is an option to run in automatic mode, where the names of
   output NDF data structures are generated automatically, and you
   can decide whether or not format conversion is to be applied to
   all files (rather than being prompted for each).  This is very
   useful if there is a large number of files to be processed.  Even
   if you want unique file names, format-conversion prompting may be
   switched off globally.
2 Parameters
For information on individual parameters, select from the list below:
3 AUTO
AUTO = _LOGICAL (Read)
   It is TRUE if automatic mode is required, where the name of
   each output NDF structure or table file is to be generated by
   the application, and therefore not prompted; and a global
   format-conversion switch may be set.  In manual mode the FITS
   header is reported, but not in automatic.

   For simple or group format FITS objects in automatic mode the
   application generates a filename beginning with a defined
   prefix followed by the number of the file on tape.  For
   example, if the prefix was "XRAY" and the 25th file of the
   tape was being processed, the filename of the NDF would be
   XRAY25.

   For table-format FITS objects in the automatic mode the
   application generates a filename beginning with a defined
   prefix followed by the number of the file on tape.  For
   example, if the prefix was "cat" and the 9th file of the tape
   was being processed, the filename of the table and its
   associated FACTS description file would be cat9.dat and
   dscfcat9.dat respectively.
   [FALSE]
3 DSCFTABLE
DSCFTABLE = FILENAME (Read)
   Name of the text file to contain the FACTS descriptors, which
   defines the table's format for SCAR.  Since SCAR is now
   deprecated, this parameter has little use, except perhaps to
   give a summary of the format of the file specified by parameter
   TABLE.  A null value (!) means that no description file will
   be created, so this is now the recommended usage.  If your
   FITS file comprises just tables, you should consider other
   tools such as the CURSA package, which has facilities for
   examining and processing ASCII and binary FITS tables.

   A suggested filename for the description file is reported
   immediately prior to prompting in manual mode.  It is the name
   of the catalogue, as written in the FITS header, with a "dscf"
   prefix.
3 ENCODINGS
ENCODINGS = LITERAL (Read)
   Determines which FITS keywords should be used to define the
   world co-ordinate information stored in NDF's WCS component.
   The allowed values (case-insensitive) are:

   "FITS-IRAF" --- This uses keywords CRVALi CRPIXi, CDi_j, and is the
     system commonly used by IRAF. It is described in the document
     "World Coordinate Systems Representations Within the FITS Format" 
     by R.J. Hanisch and D.G. Wells, 1988, available by ftp from
     fits.cv.nrao.edu /fits/documents/wcs/wcs88.ps.Z. 

   "FITS-WCS" --- This is the proposed FITS standard WCS encoding scheme
     described in the paper "Representation of celestial coordinates 
     in FITS" (http://www.cv.nrao.edu/fits/documents/wcs/wcs.html).
     It is very similar to FITS-IRAF but supports a wider range of
     projections and co-ordinate systems. Once the standard has been 
     agreed, this encoding should be understood by any FITS-WCS 
     compliant software and it is likely to be adopted widely for FITS 
     data in future. 

   "FITS-PC" --- This uses keywords CRVALi, CDELTi, CRPIXi, PCiiijjj, 
     etc, as described in a previous (now superceded) draft of the 
     above FITS world co-ordinate system paper by E.W.Greisen and 
     M.Calabretta.

   "FITS-AIPS" --- This uses conventions described in the document
     "Non-linear Coordinate Systems in AIPS" by Eric W. Greisen 
     (revised 9th September, 1994), available by ftp from 
     fits.cv.nrao.edu /fits/documents/wcs/aips27.ps.Z. It is currently 
     employed by the AIPS data analysis facility, so its use will 
     facilitate data exchange with AIPS. This encoding uses CROTAi 
     and CDELTi keywords to describe axis rotation and scaling.

   "DSS" --- This is the system used by the Digital Sky Survey, and 
     uses keywords AMDXn, AMDYn, PLTRAH, etc.

   "NATIVE" --- This is the native system used by the AST library (see
     SUN/210) and provides a loss-free method for transferring WCS
     information between AST-based application. It allows more
     complicated WCS information to be stored and retrieved than any of 
     the other encodings.

   A comma-separated list of up to six values may be supplied,
   in which case the value actually used is in the first in the
   list for which corresponding keywords can be found in the FITS
   header.
   
   A FITS header may contain keywords from more than one of these
   encodings, in which case it is possible for the encodings to
   be inconsistent with each other.  This may happen for instance
   if an application modifies the keyword associated with one
   encoding but fails to make equivalent modifications to the
   others.  If a null parameter value (!) is supplied for
   ENCODINGS, then an attempt is made to determine the most
   reliable encoding to use as follows.  If both native and
   non-native encodings are available, then the first non-native
   encoding to be found which is inconsistent with the native
   encoding is used.  If all encodings are consistent, then the
   native encoding is used (if present). [!]
3 FILES
FILES()  = _CHAR (Read)
   The list of the file numbers to be processed.  Files are
   numbered consecutively from 1 from the start of the tape.
   Single files or a set of adjacent files may be specified, e.g.
   typing [4,6-9,12,14-16] will read files 4,6,7,8,9,12,14,15,16.
   (Note that the brackets are required to distinguish this array
   of characters from a single string including commas.  The
   brackets are unnecessary when there only one item.) For
   efficiency reasons it is sensible to give the file numbers in
   ascending order.

   If you wish to extract all the files enter the wildcard *.
   5-* will read from 5 to the last file.  The processing will
   continue until the end of the tape is reached; no error
   will result from this.
3 FMTCNV
FMTCNV = _LOGICAL (Read)
   This specifies whether or not format conversion will occur.
   If FALSE, the HDS type of the data array in the NDF will be
   the equivalent of the FITS data format on tape (e.g. BITPIX =
   16 creates a _WORD array).  If TRUE, the data array in the
   current file, or all files in automatic mode, will be
   converted from the FITS data type on tape to _REAL in the NDF.
   The conversion applies the values of the FITS keywords BSCALE
   and BZERO to the tape data to generate the `true' data values.
   If BSCALE and BZERO are not given in the FITS header, they are
   taken to be 1.0 and 0.0 respectively.  The suggested default
   is TRUE.
3 GLOCON
GLOCON  = _LOGICAL (Read)
   If FALSE, a format-conversion query occurs for each FITS file.
   If TRUE, the value of FMTCNV is obtained before any file
   numbers and will apply to all data arrays.  It is ignored
   in automatic mode---in effect it becomes true. [FALSE]
3 LABEL
LABEL  = _LOGICAL (Read)
   It should be TRUE if the tape has labelled files.  Labelled
   files are non-standard.  If TRUE, the application skips three
   file marks per file, rather that one. [FALSE]
3 LOGFILE
LOGFILE = FILENAME (Read)
   The file name of the text log of the FITS header cards.
   For group-format data the group parameters are evaluated
   and appended to the full header.  The log includes the names of
   the output files used to store the data array or table. A null
   value (!) means that no log file is produced. [!]
3 MORE
MORE   = _LOGICAL (Read)
   A prompt asking if any more files are to be processed once the
   current list has been exhausted.
3 MT
MT = DEVICE (Read)
   Tape deck containing the data, usually an explicit device,
   though it can be a pre-assigned environment variable.
3 OUT
OUT = NDF (Write)
   Output NDF structure holding the full contents of the FITS
   file.  If the null value (!) is given no NDF will be created.
   This offers an opportunity to review the descriptors before
   deciding whether or not the data are to be extracted.
3 PREFIX
PREFIX = LITERAL (Read)
   The prefix of the NDF's or table's file name.  It is only used
   in the automatic mode.
3 REWIND
REWIND = _LOGICAL (Read)
   If it is TRUE, the tape drive is rewound before the reading of
   the FITS files commences.  If it is FALSE, the tape is not
   rewound, and the current tape position is read from file
   USRDEVDATASET.sdf.  Note that file numbers are absolute and
   not relative.  REWIND = FALSE is useful if you need to read a
   series of files, process them, then read some more, without
   having to remember the tape's position or apply unnecessary
   wear to the tape.  [TRUE]
3 TABLE
TABLE = FILENAME (Read)
   Name of the text file to contain the table itself, read from
   the tape.  In manual mode the suggested default filename is
   the name of description file less the "dscf" prefix, or if
   there is no description file or if the description file does
   not have the dscf prefix, the suggested name reverts to the
   catalogue name in the FITS header.
2 Examples
fitsin mt=/dev/rmt/1n files=[2-4,9] auto prefix=ccd nofmtcnv
   This reads files 2, 3, 4, and 9 from the FITS tape on
   device /dev/rmt/1n.  The output NDF names will be ccd2, ccd3,
   ccd4, and ccd9 (assuming there are no groups).  The data will
   not have format conversion.

fitsin mt=$TAPE files=* auto prefix=ccd fmtcnv logfile=jkt.log
   This reads all the files from the FITS tape on the device
   assigned to the environment variable TAPE.  The output files
   begin with a prefix "ccd".  Integer data arrays are converted
   to real using the scale and zero found in the FITS header.  A
   record of the headers and the names of the output files are
   written to the text file jkt.log.
2 References
   Wells, D.C., Greisen, E.W. & Harten, R.H. 1981,
      Astron. Astrophys. Suppl. Ser. 44, 363.
   Greisen, E.W. & Harten, R.H. 1981,
      Astron. Astrophys. Suppl. Ser. 44, 371.
   Grosbol, P., Harten, R.H., Greisen, E.W & Wells, D.C.
      1988 Astron. Astrophys. Suppl. Ser. 73, 359.
   Harten, R.H., Grosbol, P., Greisen, E.W & Wells, D.C.
      1988 Astron. Astrophys. Suppl. Ser. 73, 365.
2 Related_Applications
   KAPPA: FITSDIN, FITSHEAD, FITSIMP, FITSLIST; CONVERT: FITS2NDF;
   CURSA; Figaro: RDFITS.
2 Authors
MJC: Malcolm J. Currie (STARLINK)

PMA: Peter Allan (University of Manchester)

DSB: David S. Berry (STARLINK)
2 History
 1987 Jul  8 (PMA):
    Uses HDS but not the NDF format as it was not then defined.

 1988 Mar 25 (PMA):
    Second version. Modified to use FITS extension to standard NDF
    format.

 1988 Apr 19 (PMA):
    Allow a null parameter for the output dataset, which skips the
    processing of that file. This allows the user to read the fits
    header and to then decide not to create an output file.

 1988 May (MJC):
    Converted to KAPPA style, added further error checks and
    aborts, removed references to the Interim environment.

 1988 Sept  (MJC):
    Greatly expanded and rewritten to process group-format files
    and blocked records.

 1988 Nov  2 (MJC):
    Corrected some of the tidying, particularly cancelling OUTPUT,
    annulling FLOC and fixing an editing typo' unmapping and
    annulling of the work array.

 1988 Nov  3 (MJC):
    Added automatic mode, no data-conversion option and more
    commentary as each file is processed.

 1988 Nov  4 (MJC):
    Close HDS files created by HDS_NEW to prevent lots of files
    being open .

 1988 Nov  5 (MJC):
    Version that uses MORE.FITS instead of MORE.FITS.IN in case we
    change our minds! .

 1989 Feb 15 (MJC):
    Corrected tidying of all workspace .

 1989 Jul 19 (MJC):
    Removed LOGHDR parameter and tested for a null log-file name;
    reported all groups' completed via the same method, so that
    logical prefixes appears for the first group.

 1989 Aug  1 (MJC):
    Converted to read tables format.

 1989 Sep 18 (MJC):
    NOCON is now a global-format-conversion PROMPTING switch,
    formerly it could only set no format conversion globally (when
    not in automatic mode), the name of the output file is written
    to the logfile.

 1989 Nov 22 (MJC):
    Loops for multiple FITS files/extensions within a tape file,
    and sub file numbers written to the log file.

 1989 Nov 24 (MJC):
    Change to use OFFSET=ACTSIZ meaning block is exhausted rather
    than the counter-intuitive 0; skip over data for null output
    files.

 1989 Dec 21 (MJC):
    Workspace managed by AIF_TEMP.

 1990 Jan 11 (MJC):
    Fixed bug in the test for multiple files so that it tests for
    blank data in the current block.

 1990 Feb 20 (MJC):
    Auto mode is available for table files, replaced SUBPAR calls
    by AIF_FLNAM call, AIF_OPFIO call renamed AIF_ASFIO, and
    logging of table and description file names.

 1990 Nov 15 (MJC):
    NDF version featuring axes, title and units; expanded and
    restructured prologue; parameter NOCON renamed GLOCON so that
    a NO prefix may be used to indicate false.

 1990 November 30 (MJC):
    Altered logic to process FITS records rather than blocks and
    modified subroutine calls to reflect this (record-processing is
    needed to handle disk files and tape consistently by the same
    subroutines). IEEE floating-point supported.

 1991 February 28 (MJC):
    Added the NCARD argument for various revised FTS1_x calls.

 1991 October 10 (MJC):
    Fixed bug when GLOCON and FMTCNV set to true and dealing with
    IEEE-format data.

 1991 October 11 (MJC):
    Increased the maximum buffer size to 22 FITS records in order
    to accommodate IRAF's non-standard blocking factors.

 1992 February 24 (MJC):
    Ensured that HDS file mapping will occur after tuning option
    is added.

 1992 March 3 (MJC):
    Replaced AIF parameter-system calls by the extended PAR
    library.

 1993 April 15 (MJC):
    Made to work on UNIX.

 1993 December 3 (MJC):
    Made to work for Alphas.

 1995 October 5 (MJC):
    Documentation overhaul.  Changed dynamic default of FMTCNV.

 1995 November 18 (MJC):
    The tape drive is no longer rewound.

 1996 June 11 (MJC):
    Added REWIND parameter to control initial rewinding.  Linux
    usage enabled.

 18-FEB-1998 (DSB):
    Call to FTS1_GKEYL had arguments THERE and NOCCUR swapped, causing
    a segmentation violation.

 9-JUN-1998 (DSB):
    Added support for WCS component.
2 Implementation_Status
   -  The application processes tapes blocked at other than an
   integer multiple of 2880 bytes up to a maximum of 63360, provided
   it is a multiple of the number of bytes per data value.

   -  For simple or group format FITS:

      -  IEEE floating point is supported.

      -  If BUNIT is present its value will appear as the NDF's units
      component.

      -  If OBJECT is present its value will appear as the NDF's
      title component.

      -  If the BLANK item is present in the header, undefined pixels
      are converted from the BLANK value to Starlink-standard bad
      value during data conversion.

      -  An AXIS component will be stored in the NDF if the CRVALn
      keyword is present.  (n is the number of the dimension.)  If
      the CRPIXn keyword is absent it defaults to 1, and likewise
      for the CDELTn keyword.  The value of CRTYPEn is made the label
      of the axis structure.

   -  For groups format, a new NDF is created for each data array.
   The name of the NDF of the second and subsequent data arrays is
   generated by the application as the <filename>G<number>, where
   filename is the name of the first NDF, supplied by you or
   generated automatically, and <number> is the number of the group.

   Each group NDF contains the full header in the FITS extension,
   appended by the set of group parameters.  The group parameters
   are evaluated using their scales and offsets, and made to look
   like FITS cards, whose keywords are derived from the values of
   PTYPEm in the main header.  (m is the number of the group
   parameter.) The same format is used in the log file.

   -  If there is no data array on tape, i.e. the FITS file comprises
   header cards only, then a dummy vector data array of dimension
   two is created to make the output a valid NDF.  This data array
   is undefined.
1 FITSLIST
Lists the FITS extension of an NDF.

Usage:

   fitslist in [logfile]

Description:

   This application lists the FITS header stored in an NDF FITS
   extension.  The list may either be reported directly to you,
   or written to a text file.
2 Parameters
For information on individual parameters, select from the list below:
3 IN
IN = NDF (Read)
   The NDF whose FITS extension is to be listed.
3 LOGFILE
LOGFILE = FILENAME (Read)
   The name of the text file to store a list of the FITS
   extension.  If it is null (!) the list of the FITS extension
   is reported directly to you. [!]
2 Examples
fitslist saturn
   The contents of the FITS extension in NDF saturn are
   reported to you.

fitslist ngc205 logfile=ngcfits.lis
   The contents of the FITS extension in NDF ngc205 are
   written to the text file ngcfits.lis.
2 Notes
-  If the NDF does not have a FITS extension the application will
exit.
2 Related_Applications
   KAPPA: FITSEDIT, FITSHEAD; Figaro: FITSKEYS.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1991 February 28 (MJC):
    Original version.
1 FITSMOD
Edits an NDF FITS extension via a text file or parameters.

Usage:

   fitsmod ndf { keyword edit value comment position
               { table=?
              mode

Description:

   This application edits the FITS extension of an NDF file in a
   variety of ways.  It permits insersion of new keywords, including
   comment lines; revision of existing keyword, values, and inline
   comments; relocation of keywords; deletion of keywords; printing
   of keyword values; and it can test whether or not a keyword
   exists.  The occurrence of keywords may be defined, when there
   are more than one cards of the same name.  The location of each
   insertion or move is immediately before some occurrence of a
   corresponding keyword.

   Control of the editing can be through parameters, or from a text
   file whose format is described in topic "File Format".
2 Parameters
For information on individual parameters, select from the list below:
3 COMMENT
COMMENT = LITERAL (Read)
   The comments to be written to the KEYWORD keyword for the
   "Update" and "Write" editing commands.  A null value (!)
   gives a blank comment.  The special value "$C" means use the
   current comment.  In addition "$C(keyword)" requests that the
   comment of the keyword given between the parentheses be
   assigned to the keyword being edited.  If this positional
   keyword does not exist, the comment is unchanged for "Update",
   and is blank for a "Write" edit.
3 EDIT
EDIT = LITERAL (Read)
   The editing command to apply to the keyword.  The allowed
   options are listed below.

   "Delete" removes a named keyword.

   "Exist" reports TRUE to standard output if the named keyword
   exists in the header, and FALSE if the keyword is not present.
   The same value is also stored in output parameter EXISTS.

   "Move" relocates a named keyword to be immediately before a
   second keyword (see parameter POSITION).  When this positional
   keyword is not supplied, it defaults to the END card, and if
   the END card is absent, the new location is at the end of the
   headers.

   "Print" causes the value of a named keyword to be displayed to
   standard output.  This will be a blank for a comment card.

   "Rename" renames a keyword, using parameter NEWKEY to obtain
   the new keyword.

   "Update" revises the value and/or the comment.  If a secondary
   keyword is defined explicitly (parameter POSITION), the card
   may be relocated at the same time.  If the secondary keyword
   does not exist, the card being edited is not moved.  "Update"
   requires that the keyword being edited exists.

   "Write" creates a new card given a value and an optional
   comment.  Its location uses the same rules as for the "Move"
   command.  The FITS extension is created first should it not
   exist.
3 EXISTS
EXISTS = _LOGICAL (Write)
   An output parameter which is set to the result of the final
   "Exist" operation (see parameter EDIT).
3 KEYWORD
KEYWORD = LITERAL (Read)
   The name of the keyword to be edited in the FITS extension.  A
   name may be compound to handle hierarchical keywords, and it
   has the form keyword1.keyword2.keyword3 etc.  The maximum
   number of keywords per FITS card is 20.  Each keyword must be
   no longer than 8 characters, and be a valid FITS keyword
   comprising only alphanumeric characters, hyphen, and
   underscore.  Any lowercase letters are converted to uppercase
   and blanks are removed before insertion, or comparison with the
   existing keywords.

   The keywords " ", "COMMENT", and "HISTORY" are comment cards
   and do not have a value.

   The keyword must exist except for the "Write" and "Exist"
   commands.

   Both KEYWORD and POSITION keywords may have an occurrence
   specified in brackets [] following the name (the value of
   KEYWORD should then appear in quotes).  This enables editing of
   a keyword that is not the first occurrence of that keyword, or
   locate a edited keyword not at the first occurrence of the
   positional keyword.  Note that it is not normal to have
   multiple occurrences of a keyword in a FITS header, unless it
   is blank, COMMENT or HISTORY.  Any text between the brackets
   other than a positive integer is interpreted as the first
   occurrence.
3 MODE
MODE = LITERAL (Read)
   The mode by which the editing instructions are supplied.  The
   alternatives are "File", which uses a text file; and
   "Interface" which uses parameters. ["Interface"]
3 NDF
NDF = NDF (Read and Write)
   The NDF in which the FITS extension is to be edited.
3 NEWKEY
NEWKEY = LITERAL (Read)
   The name of the keyword to replace the KEYWORD keyword.  It is
   only accessed when EDIT="Rename".  A name may be compound to
   handle hierarchical keywords, and it has the form
   keyword1.keyword2.keyword3 etc.  The maximum number of
   keywords per FITS card is 20.  Each keyword must be no longer
   than 8 characters, and be a valid FITS keyword comprising only
   alphanumeric characters, hyphen, and underscore.
3 POSITION
POSITION = LITERAL (Read)
   The position keyword name.  A position name may be compound to
   handle hierarchical keywords, and it has the form
   keyword1.keyword2.keyword3 etc.  The maximum number of
   keywords per FITS card is 20.  Each keyword must be no longer
   than 8 characters.  When locating the position card,
   comparisons are made in uppercase and with the blanks removed.
   An occurrence may be specified (see parameter KEYWORD for
   details).

   The new keywords are inserted immediately before each
   corresponding position keyword.  If any name in it does not
   exist in FITS array, or the null value (!) is supplied the
   consequences will be as follows.  For a "Write" or "Move" edit,
   the KEYWORD keyword will be inserted just before the END card
   or appended to FITS array when the END card does not exist;
   for an "Update" edit, the edit keyword is not relocated.

   A positional keyword is only accessed by the "Move", "Write",
   and "Update" editing commands.
3 STRING
STRING = _LOGICAL (Read)
   When STRING is FALSE, inferred data typing is used for the
   "Write" and "Update" editing commands.  So for instance, if
   parameter VALUE = "Y", it would appears as logical TRUE rather
   than the string 'Y       ' in the FITS header.  See topic
   "Value Data Type".  When STRING is TRUE, the value will be
   treated as a string for the purpose of writing the FITS
   header.  [FALSE]
3 TABLE
TABLE = FILENAME (Read)
   The text file containing the keyword translation table.  The
   format of this file is described under "File Format".  For
   illustrations, see under "Examples of the File Format".
3 VALUE
VALUE = LITERAL (Read)
   The new value of the KEYWORD keyword for the "Update" and
   "Write" editing commands.  The special value "$V" means use the
   current value of the KEYWORD keyword.  This makes it possible
   to modify a comment, leaving the value unaltered.  In addition
   "$V(keyword)" requests that the value of the reference keyword
   given between the parentheses be assigned to the keyword being
   edited.  This reference keyword must exist and have a value
   for a "Write" edit; whereas the FITS-header value is unchanged
   for "Update" if there are problems with this reference keyword.
2 Examples
fitsmod dro42 bscale exist
   This reports TRUE or FALSE depending on whether or not the
   FITS keyword BSCALE exists in the FITS extension of the NDF
   called dro42.

fitsmod dro42 bscale p
   This reports the value of the keyword BSCALE stored in the
   FITS extension of the NDF called dro42.  An error message will
   appear if BSCALE does not exist.

fitsmod abc edit=move keyword=bscale position=bzero
   This moves the keyword BSCALE to lie immediately before keyword
   BZERO in the FITS extension of the NDF called abc.  An error
   will result if either BSCALE or BZERO does not exist.

fitsmod dro42 airmass dele
   This deletes the keyword AIRMASS, if it exists, in the FITS
   extension of the NDF called dro42.

fitsmod ndf=dro42 edit=d keyword="airmass[2]"
   This deletes the second occurrence of keyword AIRMASS, if it
   exists, in the FITS extension of the NDF called dro42.

fitsmod @100 airmass w 1.456 "Airmass at mid-observation"
   This creates the keyword AIRMASS in the FITS extension of the
   NDF called 100, assigning the keyword the real value 1.456 and
   comment "Airmass at mid-observation".  The header is
   located just before the end.  The FITS extension is created if
   it does not exist.

fitsmod @100 airmass w 1.456 "Airmass at mid-observation" phase
   As the previous example except that the new keyword is written
   immediately before keyword PHASE.

fitsmod obe observer u value="O'Leary" comment=$C
   This updates the keyword OBSERVER with value "O'Leary",
   retaining its old comment.  The modified FITS extension lies
   within the NDF called obe.

fitsmod test filter w position=end value=27 comment=! string
   This creates the keyword FILTER in the FITS extension of the
   NDF called test, assigning the keyword the string value "27".
   There is no comment.  The keyword is located at the end of the
   headers, but before any END card.  The FITS extension is
   created if it does not exist.

fitsmod test edit=w keyword=detector value=$V(ing.dethead)
        comment="   Detector name" accept
   This creates the keyword DETECTOR in the FITS extension of the
   NDF called test, assigning the keyword the value of the
   existing hierarchical keyword ING.DETHEAD.  The comment is
   "   Detector name", the leading spaces are significant.  The
   keyword is located at the current position keyword.  The FITS
   extension is created if it does not exist.

fitsmod datafile mode=file table=fitstable.txt
   This edits the FITS-extension of the NDF called
   datafile, creating the FITS extension if it does not exist.
   The editing instructions are stored in the text file called
   fitstable.txt.
2 Notes
-  Requests to move, assign values or comments, the following
reserved keywords in the FITS extension are ignored: SIMPLE,
BITPIX, NAXIS, NAXISn, EXTEND, PCOUNT, GCOUNT, XTENSION, BLOCKED,
and END.

-  When an error occurs during editing, warning messages are sent
at the normal reporting level, and processing continues to the
next editing command.

-  The FITS fixed format is used for writing or updating
headers, except for double-precision values requiring more space.
The comment is delineated from the value by the string " / ".

-  The comments in comment cards begin one space following the
keyword or from column 10 whichever is greater.

-  To be sure that the resultant FITS extension is what you
desired, you should inspect it using the command FITSLIST before
exporting the data.  If there is something wrong, you may find it
convenient to use command FITSEDIT to make minor corrections.
2 Timing
   Approximately proportional to the number of FITS keywords to be
   edited.  "Update" and "Write" edits require the most time.
2 File_Format
   The file consists of a series of lines, one per editing
   instruction, although blank lines and lines beginning with a ! or
   # are treated as comments.  Note that the order does matter, as
   the edits are performed in the order given.

   The format is summarised below:

     command keyword{[occur]}{(keyword{[occur]})} {value {comment}}

   where braces indicate optional values, and occur is the
   occurrence of the keyword.  In effect there are four fields
   delineated by spaces that define the edit operation, keyword,
   value and comment.

   -  Field 1:
      This specifies the editing operation.  Allowed values are
      Delete, Exist, Move, Read, Write, and Update, and can be
      abbreviated to the initial letter.  Delete removes a named
      keyword.  Read causes the value of a named keyword to be
      displayed to standard output.  Exist reports TRUE to standard
      output if the named keyword exists in the header, and FALSE if
      the keyword is not present.  Move relocates a named keyword to
      be immediately before a second keyword.  When this positional
      keyword is not supplied, it defaults to the END card, and if
      the END card is absent, the new location is at the end of the
      headers.  Write creates a new card given a value and an
      optional comment.  Its location uses the same rules as for the
      Move command.  Update revises the value and/or the comment.
      If a secondary keyword is defined explicitly, the card may be
      relocated at the same time.  Update requires that the keyword
      exists.

   -  Field 2:
      This specifies the keyword to edit, and optionally the
      position of that keyword in the header after the edit (for
      Move, Write and Update edits).  The new position in the header
      is immediately before a positional keyword, whose name is
      given in parentheses concatenated to the edit keyword.  See
      "Field 1" for defaulting when the position parameter is not
      defined or is null.

      Both the editing keyword and position keyword may be compound
      to handle hierarchical keywords.  In this case the form is
      keyword1.keyword2.keyword3 etc.  All keywords must be valid
      FITS keywords.  This means they must be no more than 8
      characters long, and the only permitted characters are
      uppercase alphabetic, numbers, hyphen, and underscore.
      Invalid keywords will be rejected.

      Both the edit and position keyword may have an occurrence
      specified in brackets [].  This enables editing of a keyword
      that is not the first occurrence of that keyword, or locate a
      edited keyword not at the first occurrence of the positional
      keyword.  Note that it is not normal to have multiple
      occurrences of a keyword in a FITS header, unless it is blank,
      COMMENT or HISTORY.  Any text between the brackets other than
      a positive integer is interpreted as the first occurrence.

      Use a null value ('' or "") if you want the card to be a
      comment with keyword other than COMMENT or HISTORY.  As blank
      keywords are used for hierarchical keywords, to write a
      comment in a blank keyword you must give a null edit keyword.
      These have no keyword appearing before the left parenthesis
      or bracket, such as (), [], [2], or (EPOCH).

   -  Field 3:
      This specifies the value to assign to the edited keyword in
      the Write and Update operations, or the name of the new
      keyword in the Rename modification.  If the keyword exists,
      the existing value or keyword is replaced, as appropriate.
      The data type used to store the value is inferred from the
      value itself.  See topic "Value Data Type".

      For the Update and Write modifications there is a special
      value, $V, which means use the current value of the edited
      keyword, provided that keyword exists.  This makes it possible
      to modify a comment, leaving the value unaltered.  In addition
      $V(keyword) requests that the value of the keyword given
      between the parentheses be assigned to the keyword being
      edited.

      The value field is ignored when the keyword is COMMENT,
      HISTORY or blank, and the modification is to Update or Write.

   -  Field 4:
      This specifies the comment to assign to the edited keyword for
      the Write and Update operations.  A leading "/" should not be
      supplied.

      There is a special value, $C, which means use the current
      comment of the edited keyword, provided that keyword exists.
      This makes it possible to modify a value, leaving the comment
      unaltered.  In addition $C(keyword) requests that the comment
      of the keyword given between the parentheses be assigned to
      the edited keyword.

      To obtain leading spaces before some commentary, use a quote
      (') or double quote (") as the first character of the comment.
      There is no need to terminate the comment with a trailing and
      matching quotation character.  Also do not double quotes
      should one form part of the comment.
2 Value_Data_Type
   The data type of a value is determined as follows:

      -  For the text-file, values enclosed in quotes (') or doubled
      quotes (") are strings.  Note that numeric or logical string
      values must be quoted to prevent them being converted to a
      numeric or logical value in the FITS extension.

      -  For prompting the value is a string when parameter STRING
      is TRUE.

      -  Otherwise type conversions of the first word after the
      keywords are made to integer, double precision, and logical
      types in turn.  If a conversion is successful, that becomes the
      data type.  In the case of double precision, the type is set
      to real when the number of significant digits only warrants
      single precision.  If all the conversions failed the value
      is deemed to be a string.
2 Examples_of_the_File_Format
   The best way to illustrate the options is by listing some example
   lines.

       P AIRMASS
   This reports the value of keyword AIRMASS to standard output.

       E FILTER
   This determines whether keyword FILTER exists and reports TRUE or
   FALSE to standard output.

       D OFFSET
   This deletes the keyword OFFSET.

       Delete OFFSET[2]
   This deletes any second occurrence of keyword OFFSET.

       Rename OFFSET1[2] OFFSET2
   This renames the second occurrence of keyword OFFSET1 to have
   keyword OFFSET2.

       W AIRMASS 1.379
   This writes a real value to new keyword AIRMASS, which will be
   located at the end of the FITS extension.

       W FILTER(AIRMASS) Y
   This writes a logical true value to new keyword FILTER, which
   will be located just before the AIRMASS keyword, if it exists.

       Write FILTER(AIRMASS) 'Y'
   As the preceding example except that this writes a character
   value "Y".

       W COMMENT(AIRMASS) . Following values apply to mid-observation
   This writes a COMMENT card immediately before the AIRMASS card,
   the comment being "Following values apply to mid-observation".
   Note the full stop.

       W DROCOM(AIRMASS) '' Following values apply to mid-observation
   As the preceding example but this writes to a non-standard
   comment keyword called DROCOM.  Note the need to supply a null
   value.

       W (AIRMASS) '' Following values apply to mid-observation
   As the preceding example but this writes to a blank-keyword
   comment.

       U OBSERVER "Dr. Peter O'Leary" Name of principal observer
   This updates the OBSERVER keyword with the string value
   "Dr. Peter O'Leary", and comment "Name of principal observer".
   Note that had the value been enclosed in single quotes ('), the
   apostrophe would need to be doubled.

       M OFFSET
   This moves the keyword OFFSET to just before the END card.

       Move OFFSET(SCALE)
   This moves the keyword OFFSET to just before the SCALE card.

       Move OFFSET[2](COMMENT[3])
   This moves the second occurrence of keyword OFFSET to just
   before the third COMMENT card.
2 References
   "A User's Guide for the Flexible Image Transport System (FITS)",
   NASA/Science Office of Science and Technology (1994).
2 Related_Applications
   KAPPA: FITSEDIT, FITSEXIST, FITSEXP, FITSHEAD, FITSIMP, FITSLIST,
   FITSVAL, FITSWRITE.
2 Authors
MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 1996 November 8 (MJC):
    Original version.

 22-SEP-1999 (DSB):
    Added EXISTS parameter.

 {enter_any_changes_here}
1 FITSTEXT
Creates an NDF FITS extension from a text file.

Usage:

   fitstext ndf file

Description:

   This application takes a version of a FITS header stored in a
   text file, and inserts it into the FITS extension of an NDF.  The
   header is not copied verbatim as some validation of the headers
   as legal FITS occurs.  An existing FITS extension is removed.
2 Parameters
For information on individual parameters, select from the list below:
3 NDF
NDF = NDF (Read and Write)
   The name of the NDF to store the FITS header information.
3 FILE
FILE = FILENAME (Read)
   The text file containing the FITS headers.  Each record should
   be the standard 80-character `card image'.  If the file has
   been edited care is needed to ensure that none of the cards
   are wrapped onto a second line.
2 Examples
fitstext hh73 headers.lis
   This places the FITS headers stored in the text file called
   headers.lis in the FITS extension of the NDF called hh73.
2 Notes
- The validation process performs the following checks on each
header `card':
  a) the length of the header is no more than 80 characters,
  otherwise it is truncated;
  b) the keyword only contains uppercase Latin alphabetic
  characters, numbers, underscore, and hyphen (the header will
  not be copied to the extension except when the invalid
  characters are lowercase letters);
  c) value cards have an equals sign in column 9 and a space in
  column 10;
  d) quotes enclose character values;
  e) single quotes inside string values are doubled;
  f) character values are left justified to column 11 (retaining
  leading blanks) and contain at least 8 characters (padding with
  spaces if necessary);
  g) non-character values are right justified to column 30, except
  for non-mandatory keywords which have a double-precision value
  requiring more than 20 digits;
  h) the comment delimiter is in column 32 or two characters
  following the value, whichever is greater;
  i) an equals sign in column 9 of a commentary card is replaced
  by a space; and
  j) comments begin at least two columns after the end of the
  comment delimiter.

- The validation issues warning messages at the normal reporting
level for violations a), b), c), d), and i).

-  The validation can only go so far.  If any of your header lines
are ambiguous, the resulting entry in the FITS extension may not
be what you intended.  Therefore, you should inspect the
resulting FITS extension using the command FITSLIST before
exporting the data.  If there is something wrong, you may find it
convenient to use command FITSEDIT to make minor corrections.
2 Related_Applications
   KAPPA: FITSEDIT, FITSEXP, FITSLIST; CONVERT: NDF2FITS.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1994 September 8 (MJC):
    Original version.

 1996 July 26 (MJC):
    Uses improved validation routine.
1 FITSURFACE
Fits a polynomial surface to 2-dimensional data array.

Usage:

   fitsurface ndf [fittype] nxpar nypar

Description:

   This task fits a surface to a 2-dimensional data array stored
   array within an NDF data structure.  At present it only
   permits a fit with a polynomial, and the coefficients of that
   surface are stored in a POLYNOMIAL structure (SGP/38) as an
   extension to that NDF.

   Unlike SURFIT, neither does it bin the data nor does it reject
   outliers.
2 Parameters
For information on individual parameters, select from the list below:
3 COSYS
COSYS = LITERAL (Read)
   The co-ordinate system to be used.  This can be either "World"
   or "Data".  If COSYS = "World" the co-ordinates used to fits
   the surface are pixel co-ordinates.  If COSYS = "Data" the
   data co-ordinates used are used in the fit, provided there are
   axis centres present in the NDF.  COSYS="World" is
   recommended.  [Current co-ordinate system]
3 FITTYPE
FITTYPE = LITERAL (Read)
   The type of fit.  It must be either "Polynomial" for a
   polynomial or "Spline" for a bi-cubic spline. ["Polynomial"]
3 NDF
NDF  = NDF (Update)
   The NDF containing the 2-dimensional data array to be fitted.
3 NXPAR
NXPAR = _INTEGER (Read)
   The number of fitting parameters to be used in the x
   direction.  It must be in the range 1 to 15 for a polynomial
   fit, and 4 to 15 for a bi-cubic-spline fit.  Thus 1 gives a
   constant, 2 a linear fit, 3 a quadratic etc.  Increasing this
   parameter increases the flexibility of the surface in the x
   direction.  The upper limit of acceptable values will be
   reduced for arrays with an x dimension less than 29.
3 NYPAR
NYPAR = _INTEGER (Read)
   The number of fitting parameters to be used in the y
   direction.  It must be in the range 1 to 15 for a polynomial
   fit, and 4 to 15 for a bi-cubic-spline fit.  Thus 1 gives a
   constant, 2 a linear fit, 3 a quadratic etc.  Increasing this
   parameter increases the flexibility of the surface in the y
   direction.  The upper limit of acceptable values will be
   reduced for arrays with a y dimension less than 29.
3 OVERWRITE
OVERWRITE = _LOGICAL (Read)
   OVERWRITE=TRUE, allows an NDF extension containing an existing
   surface fit to be overwritten.  OVERWRITE=FALSE protects an
   existing surface-fit extension, and should one exist, an error
   condition will result and the task terminated.  [TRUE]
3 VARIANCE
VARIANCE = _LOGICAL (Read)
   A flag indicating whether any variance array present in the
   NDF is used to define the weights for the fit.  If VARIANCE
   is TRUE and the NDF contains a variance array this will be
   used to define the weights, otherwise all the weights will be
   set equal.  [TRUE]
3 XMAX
XMAX = _DOUBLE (Read)
   The maximum x value to be used in the fit.  This must be
   greater than or equal to the x co-ordinate of the right-hand
   pixel in the data array.  Normally this parameter is
   automatically set to the maximum x co-ordinate found in the
   data, but this mechanism can be overridden by specifying XMAX
   on the command line.  The parameter is provided to allow the
   fit limits to be fine tuned for special purposes.  It should
   not normally be altered. [Maximum x co-ordinate of the fitted
   data]
3 XMIN
XMIN = _DOUBLE (Read)
   The minimum x value to be used in the fit.  This must be
   smaller than or equal to the x co-ordinate of the left-hand
   pixel in the data array.  Normally this parameter is
   automatically set to the minimum x co-ordinate found in the
   data, but this mechanism can be overridden by specifying XMIN
   on the command line.  The parameter is provided to allow the
   fit limits to be fine tuned for special purposes.  It should
   not normally be altered.  [Minimum x co-ordinate of the fitted
   data]
3 YMAX
YMAX = _DOUBLE (Read)
   The maximum y value to be used in the fit.  This must be
   greater than or equal to the y co-ordinate of the top pixel in
   the data array.  Normally this parameter is automatically set
   to the maximum y co-ordinate found in the data, but this
   mechanism can be overridden by specifying YMAX on the command
   line.  The parameter is provided to allow the fit limits to be
   fine tuned for special purposes.  It should not normally be
   altered. [Maximum y co-ordinate of the fitted data]
3 YMIN
YMIN = _DOUBLE (Read)
   The minimum y value to be used in the fit.  This must be
   smaller than or equal to the y co-ordinate of the bottom pixel
   in the data array.  Normally this parameter is automatically
   set to the minimum y co-ordinate found in the data, but this
   mechanism can be overridden by specifying YMIN on the command
   line.  The parameter is provided to allow the fit limits to be
   fine tuned for special purposes.  It should not normally be
   altered. [Minimum y co-ordinate of the fitted data]
2 Examples
fitsurface virgo nxpar=4 nypar=4 novariance
   This fits a bi-cubic polynomial surface to the data array
   in the NDF called virgo.  All the data values are given
   equal weight.  The coefficients of the fitted surface are
   stored in an extension of virgo.

fitsurface virgo nxpar=4 nypar=4
   As the first example except the data variance, if present,
   is used to weight the data values.

fitsurface mkn231 nxpar=6 nypar=2 cosys=d xmin=-10.0 xmax=8.5
   This fits a polynomial surface to the data array in the NDF
   called mkn231.  A fifth order is used along the x direction,
   but only a linear fit along the y direction.  The fit is made
   between x data co-ordinates -10.0 to 8.5.  The variance
   weights the data values.  The coefficients of the fitted
   surface are stored in an extension of mkn231.
2 Notes
The polynomial surface fit is stored in SURFACEFIT extension,
component FIT of type POLYNOMIAL, variant CHEBYSHEV.  This is
read by MAKESURFACE to create a NDF of the fitted surface.  Also
stored in the SURFACEFIT extension are the r.m.s. deviation to the
fit (component RMS), the maximum absolute deviation (component
RSMAX), and the co-ordinate system (component COSYS).
2 Related_Applications
   KAPPA: MAKESURFACE, SURFIT.
2 Authors
SMB: Steven M. Beard (ROE)

MJC: Malcolm J. Currie (STARLINK)
2 History
 20-Apr-1993 (SMB):
    Original version, based on the KAPPA function SURFIT written
    by Malcolm Currie.

 22-Apr-1993 (SMB):
    Modified to use PLYPUT2D.

 23-Apr-1993 (SMB):
    DAT_PAR included (commented out) so the routine can work in a
    UNIX environment.

 06-May-1993 (SMB):
    DAT_PAR does not need to be commented out.

 02-Jun-1993 (SMB):
    Modified to report some goodness of fit information.

 08-Nov-1993 (SMB):
    Modified to allow the x and y extrema returned by ARXYZW to be
    overridden by specifying XMIN, XMAX, YMIN, YMAX parameters.

 07-Dec-1993 (SMB):
    Comments tidied up.

 1995 August 2 (MJC):
    Used a modern prologue and completed it.  Renamed many of the
    routines and called existing subroutines rather than use SMB's
    new ones.  Added COSYS parameter, and stored its value in the
    SURFACEFIT extension.  Obtain axis centres in double
    precision.  Insisted on two significant dimensions in the NDF.
    Used PSX to get workspace to improve efficiency.

 1996 October 10 (MJC):
    Remove one work array no longer needed for NAG-free
    subroutines.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   VARIANCE, and HISTORY components of an NDF data structure.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.  Arithmetic
   is performed using double-precision floating point.
1 FITSVAL
Reports the value of a keyword in the FITS extension.

Usage:

   fitsval ndf keyword

Description:

   This application reports the value of a keyword in an NDF's FITS
   extension.

   It is a synonym for "fitsmod edit=print mode=interface".
2 Parameters
For information on individual parameters, select from the list below:
3 KEYWORD
KEYWORD = LITERAL (Given)

   The name of an existing keyword in the FITS extension whose value
   is to be reported.  A name may be compound to handle hierarchical
   keywords, and it has the form keyword1.keyword2.keyword3 etc.  The
   maximum number of keywords per FITS card is 20.  Each keyword must
   be no longer than 8 characters, and be a valid FITS keyword
   comprising only alphanumeric characters, hyphen, and underscore.
   Any lowercase letters are converted to uppercase and blanks are
   removed before comparison with the existing keywords.

   KEYWORD may have an occurrence specified in brackets [] following
   the name.  This enables the values to be obtained for keywords that
   appear more than once.  Note that it is not normal to have multiple
   occurrences of a keyword in a FITS header, unless it is blank,
   COMMENT or HISTORY.  Any text between the brackets other than a
   positive integer is interpreted as the first occurrence.

   The suggested value is the current value.
3 NDF
NDF = NDF (Read)
   The NDF containing the FITS keyword.
2 Examples
fitsval abc bscale
   This reports the value of the FITS keyword BSCALE, which is
   located within the FITS extension of the NDF called abc.

fitsval ndf=abc keyword=date[2]
   This reports the value of the second occurrence FITS keyword DATE,
   which is located within the FITS extension of the NDF called abc.

2 Related_Applications
   KAPPA: FITSEDIT, FITSEXIST, FITSHEAD, FITSLIST, FITSMOD.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1996 December 4 (MJC):
    Original version.
1 FITSWRITE
Writes a new keyword to the FITS extension.

Usage:

   fitswrite ndf keyword value=? comment=?

Description:

   This application writes a new keyword in an NDF's FITS extension
   given a value and an optional inline comment.  It allows the
   location of the new keyword to be specified.  The FITS extension
   is created if it does not exist.

   It is a synonym for "fitsmod edit=write mode=interface position=!".
2 Parameters
For information on individual parameters, select from the list below:
3 COMMENT
COMMENT = LITERAL (Given)
   The comments to be written to the KEYWORD keyword.  A null value
   (!) gives a blank comment.  The special value "$C" means use the
   current comment.  In addition "$C(keyword)" requests that the
   comment of the keyword given between the parentheses be assigned
   to the keyword being edited.  If this positional keyword does not
   exist, the comment is is blank.
3 KEYWORD
KEYWORD = LITERAL (Given)
   The name of the new keyword in the FITS extension.  A name may
   be compound to handle hierarchical keywords, and it has the
   form keyword1.keyword2.keyword3 etc.  The maximum number of
   keywords per FITS card is 20.  Each keyword must be no longer than
   8 characters, and be a valid FITS keyword comprising only
   alphanumeric characters, hyphen, and underscore.  Any lowercase
   letters are converted to uppercase and blanks are removed before
   comparison with the existing keywords.

   Note that it is not normal to have multiple occurrences of a
   keyword in a FITS header, unless it is blank, COMMENT or HISTORY.

   The suggested value is the current value.
3 NDF
NDF = NDF (Read)
   The NDF containing the FITS extension into which the new FITS
   keyword.
3 POSITION
POSITION = LITERAL (Given)
   The position keyword name.  A position name may be compound to
   handle hierarchical keywords, and it has the form
   keyword1.keyword2.keyword3 etc.  The maximum number of keywords
   per FITS card is 20.  Each keyword must be no longer than 8
   characters.  When locating the position card, comparisons are
   made in uppercase and with the blanks removed.  An occurrence
   may be specified (see parameter KEYWORD for details).

   The new keywords are inserted immediately before each
   corresponding position keyword.  If any name in it does not
   exist in FITS array, or the null value (!) is supplied, the
   KEYWORD keyword will be inserted just before the END card
   or appended to FITS array when the END card does not exist. [!]
3 STRING
STRING = _LOGICAL (Read)
   When STRING is FALSE, inferred data typing is used.  So for
   instance if parameter VALUE = "Y", it would appears as logical
   TRUE rather than the string 'Y       ' in the FITS header.  See
   topic "Value Data Type".  When STRING is TRUE, the value will be
   treated as a string for the purpose of writing the FITS header.
   [FALSE]
3 VALUE
VALUE = LITERAL (Given)
   The new value of the KEYWORD keyword.  The special value "$V"
   means use the current value of the KEYWORD keyword.  This makes
   it possible to modify a comment, leaving the value unaltered.
   In addition "$V(keyword" requests that the value of the
   reference keyword given between the parentheses be assigned to
   the keyword being written.  This reference keyword must exist and
   have a value.
2 Examples
fitswrite abc bscale value=1.234
   This writes the FITS keyword BSCALE just before the end of the
   FITS extension, which is located within the NDF called abc.  It
   assigns BSCALE a value of 1.234.  There is no inline comment.

fitswrite @100 airmass value=1.456 comment="Airmass at mid-observation"
   This creates the keyword AIRMASS in the FITS extension of the
   NDF called 100, assigning the keyword the real value 1.456 and
   comment "Airmass at mid-observation".  The header is located just
   before the end.

fitswrite @100 airmass value=1.456 "Airmass at mid-observation"
  position=phase
    As the previous example except that the new keyword is written
    immediately before keyword PHASE.

fitswrite afcyg observer value="O'Leary" comment=$C(prininv)
   This writes the keyword OBSERVER with value "O'Leary", and its
   comment is copied from keyword PRININV.  The modified FITS
   extension lies within the NDF called afcyg.

fitswrite test filter position=end value=27 comment=! string
   This creates the keyword FILTER in the FITS extension of the
   NDF called test, assigning the keyword the string value "27".
   There is no comment.  The keyword is located at the end of the
   headers, but before any END card.

fitswrite ndf=test keyword=detector comment="    Detector name"
  value=$V(ing.dethead) accept
   This creates the keyword DETECTOR in the FITS extension of the
   NDF called test, assigning the keyword the value of the
   existing hierarchical keyword ING.DETHEAD.  The comment is
   "    Detector name", the leading spaces are significant.  The
   keyword is located at the current position keyword.
2 Value_Data_Type
   The data type of a value is determined as follows:

      -  For the text-file, values enclosed in quotes (') or doubled
      quotes (") are strings.  Note that numeric or logical string
      values must be quoted to prevent them being converted to a
      numeric or logical value in the FITS extension.

      -  For prompting the value is a string when parameter STRING
      is TRUE.

      -  Otherwise type conversions of the first word after the
      keywords are made to integer, double precision, and logical
      types in turn.  If a conversion is successful, that becomes the
      data type.  In the case of double precision, the type is set
      to real when the number of significant digits only warrants
      single precision.  If all the conversions failed the value
      is deemed to be a string.
2 Related_Applications
   KAPPA: FITSEDIT, FITSEXP, FITSMOD.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1996 December 4 (MJC):
    Original version.
1 FLIP
Reverses an NDF's pixels along a specified dimension.

Usage:

   flip in out dim

Description:

   This application reverses the order of an NDF's pixels along a
   specified dimension, leaving all other aspects of the data
   structure unchanged.
2 Parameters
For information on individual parameters, select from the list below:
3 AXIS
AXIS = _LOGICAL (Read)
   If a TRUE value is given for this parameter (the default),
   then any axis values and WCS information associated with the
   NDF dimension being reversed will also be reversed in the same
   way.  If a FALSE value is given, then all axis values and WCS
   information will be left unchanged. [TRUE]
3 DIM
DIM = _INTEGER (Read)
   The number of the dimension along which the NDF's pixels
   should be reversed.  The value should lie between 1 and the
   total number of NDF dimensions.  If the NDF has only a single
   dimension, then this parameter is not used, a value of 1 being
   assumed.
3 IN
IN = NDF (Read)
   The input NDF data structure whose pixel order is to be
   reversed.
3 OUT
OUT = NDF (Write)
   The output NDF data structure.
3 TITLE
TITLE = LITERAL (Read)
   A title for the output NDF.  A null value will cause the title
   of the NDF supplied for parameter IN to be used instead. [!]
2 Examples
flip a b 2
   Reverses the pixels in the NDF called a along its second
   dimension to create the new NDF called b.

flip specin specout
   If specin is a 1-dimensional spectrum, then this example
   reverses the order of its pixels to create a new spectrum
   specout.  Note that no value for the DIM parameter need be
   supplied in this case.

flip in=cube out=newcube dim=2 noaxis
   Reverses the order of the pixels along dimension 2 of the NDF
   called cube to give newcube, but leaves the associated axis
   values in their original order.
2 Notes
The pixel-index bounds of the NDF are unchanged by this routine.
2 Related_Applications
   KAPPA: ROTATE, TRANSFORMER; Figaro: IREVX, IREVY, IROT90.
2 Authors
RFWS: R.F. Warren-Smith (STARLINK, RAL)

MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 13-MAR-1991 (RFWS):
    Original version.

 1992 March 3 (MJC):
    Replaced AIF parameter-system calls by the extended PAR
    library.

 11-JUN-1998 (DSB):
    Added propagation of the NDF WCS component.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   VARIANCE, LABEL, TITLE, UNITS, WCS and HISTORY components of the
   input NDF and propagates all extensions.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.  The data
   type of the input pixels is preserved in the output NDF.
1 FOURIER
Performs forward and inverse Fourier transforms of 1- or
2-dimensional NDFs.

Usage:

   fourier in hermout

Description:

   This application performs forward or reverse Fast Fourier
   Transforms (FFTs) of 1- or 2-dimensional NDFs.  The output in the
   forward transformation (from the space domain to the Fourier) can
   be produced in Hermitian form in a single NDF, or as two NDFs
   giving the real and imaginary parts of the complex transform, or
   as two NDFs giving the power and phase of the complex transform.
   Any combination of these may also be produced.  The inverse
   procedure accepts any of these NDFs and produces a purely real
   output NDF.

   Any bad pixels in the input NDF may be replaced by a constant
   value.  Input NDFs need neither be square, nor be a power of 2 in
   size in either dimension; their shape is arbitrary.

   The Hermitian transform is a single image in which each quadrant
   consists of a linear combination of the real and imaginary
   parts of the transform.  This form is useful if you just want to
   multiply the Fourier transform by some known purely real mask and
   then invert it to get a filtered image.  However, if you want to
   multiply the Fourier transform by a complex mask (e.g. the
   Fourier transform of another NDF), or do any other operation
   involving combining complex values, then the Hermitian NDF must
   be untangled into separate real and imaginary parts.

   There is an option to swap the quadrants of the input NDF around
   before performing a forward FFT.  This is useful if you want to
   perform convolutions with the FFTs, since the point-spread
   function (PSF) image can be created with the PSF centre at the
   array centre, rather than at pixel (1,1) as is usually required.
2 Parameters
For information on individual parameters, select from the list below:
3 FILLVAL
FILLVAL = LITERAL (Read)
   A value to replace bad pixels before performing the transform.
   The input image is also padded with this value if necessary to
   form an image of acceptable size.  A value of "Mean" will cause
   the mean value in the array to be used. [0.0]
3 HERMIN
HERMIN = NDF (Read)
   Hermitian frequency-domain input NDF containing the complex
   transform.  If null is entered no Hermitian NDF is read and
   then the application should be supplied either separate real
   and imaginary NDFs, or the power and phase NDFs. Prompting
   will not occur if one of the other (inverse) input NDFs has
   been given on the command line, but not HERMIN as well.  This
   parameter is only relevant for an inverse transformation.
3 HERMOUT
HERMOUT = NDF (Write)
   Hermitian output NDF from a forward transform.  If a null value
   is given then this NDF is not produced.
3 HM_TITLE
HM_TITLE = LITERAL (Read)
   Title for the Hermitian Fourier-transform output NDF.
   A null (!) value means using the title of the input NDF.
   ["KAPPA - Fourier - Hermitian"]
3 IM_TITLE
IM_TITLE = LITERAL (Read)
   Title for the frequency-domain imaginary output NDF.
   A null (!) value means using the title of the input NDF.
   ["KAPPA - Fourier - Imaginary"]
3 IMAGIN
IMAGIN = NDF (Read)
   Input frequency-domain NDF containing the imaginary part of the
   complex transform.  If a null is given then an image of zeros
   is assumed unless a null is also given for REALIN, in which
   case the input is requested in power and phase form.  This
   parameter is only available if HERMIN is not used.  One way to
   achieve that is to supply IMAGIN, but not HERMIN, on the
   command line.  This parameter is only relevant for an inverse
   transformation.
3 IMAGOUT
IMAGOUT = NDF (Write)
   Frequency-domain output NDF containing the imaginary part of
   the complex Fourier transform.  If a null value is given then
   this NDF is not produced. [!]
3 IN
IN = NDF (Read)
   Real (space-domain) input NDF for a forward transformation.
   There are no restrictions on the size or shape of the input
   NDF, although the it may have to be padded or trimmed before
   being transformed. This parameter is only used if a forward
   transformation was requested.
3 INVERSE
INVERSE = _LOGICAL (Read)
   If TRUE, then the inverse transform---frequency domain to
   space domain---is required, otherwise a transform from the
   space to the frequency domain is undertaken. [FALSE]
3 OUT
OUT = NDF (Write)
   Real space-domain output NDF.  This parameter is only used if
   an inverse transformation is requested.
3 PH_TITLE
PH_TITLE = LITERAL (Read)
   Title for the frequency-domain phase output NDF.
   A null (!) value means using the title of the input NDF.
   ["KAPPA - Fourier - Phase"]
3 PHASEIN
PHASEIN = NDF (Read)
   Input frequency-domain NDF containing the phase of the complex
   transform.  If a null is given then an image of zeros is
   assumed unless a null is also given for PHASEIN, in which
   case the application quits.  This parameter is only available
   if HERMIN, REALIN and IMAGIN are all not used.   One way to
   achieve that is to supply PHASEIN, but none of the
   aforementioned parameters, on the command line.  This
   parameter is only relevant for an inverse transformation.
3 PHASEOUT
PHASEOUT = NDF (Write)
   Frequency-domain output NDF containing the phase of the
   complex Fourier transform.  If a null value is given then this
   NDF is not produced. [!]
3 POWERIN
POWERIN = NDF (Read)
   Input frequency-domain NDF containing the modulus of the
   complex transform.  Note, this should be the square root of the
   power rather than the power itself.  If a null is given then an
   image of zeros is assumed unless a null is also given for
   PHASEIN, in which case the application quits.  This parameter
   is only available if HERMIN, REALIN and IMAGIN are all not
   used.  One way to achieve that is to supply POWERIN, but none
   of the aforementioned parameters, on the command line.  This
   parameter is only relevant for an inverse transformation.
3 POWEROUT
POWEROUT = NDF (Write)
   Frequency-domain output NDF containing the modulus of the
   complex Fourier transform.  Note, this is the square root of
   the power rather than the power itself.  If a null value is
   given then this NDF is not produced. [!]
3 PW_TITLE
PW_TITLE = LITERAL (Read)
   Title for the frequency-domain power output NDF.
   A null (!) value means using the title of the input NDF.
   ["KAPPA - Fourier - Power"]
3 REALIN
REALIN = NDF (Read)
   Input frequency-domain NDF containing the real part of the
   complex transform.  If a null is given then an image of zeros is
   assumed unless a null is also given for IMAGIN, in which case
   the input is requested in power and phase form.  This parameter
   is only available if HERMIN is not used.  One way to achieve
   that is to supply REALIN, but not HERMIN, on the command
   line.  This parameter is only relevant for an inverse
   transformation.
3 REALOUT
REALOUT = NDF (Write)
   Frequency-domain output NDF containing the real part of the
   complex Fourier transform.  If a null value is given then this
   NDF is not produced. [!]
3 RL_TITLE
RL_TITLE = LITERAL (Read)
   Title for the frequency-domain real output NDF.
   A null (!) value means using the title of the input NDF.
   ["KAPPA - Fourier - Real"]
3 SHIFT
SHIFT = _LOGICAL (Read)
   If TRUE, the transform origin is to be located at the array's
   centre.  This is implemented by swapping bottom-left and
   top-right, and bottom-right and top-left array quadrants,
   before doing the transform.  This results in the transformation
   effectively being done about pixel x = INT(NAXIS1/2)+1 and
   y = INT(NAXIS2/2)+1, where NAXISn are the padded or trimmed
   dimensions of the NDF. [FALSE]
3 TRIM
TRIM = LOGICAL (Read)
   If TRUE, when the input array dimension cannot be processed by
   the transform, the output arrays will be trimmed rather than
   padded with the fill value. [FALSE]
3 TITLE
TITLE = LITERAL (Read)
   Title for the real space-domain output NDF.
   A null (!) value means using the title of the input NDF.
   ["KAPPA - Fourier"]
2 Examples
fourier galaxy ft_gal
   Makes an Hermitian Fourier transform stored in an NDF called
   ft_gal from the 2-d NDF called galaxy.

fourier hermin=ft_gal out=galaxy inverse
   Takes an Hermitian Fourier transform stored in an NDF called
   ft_gal and performs the inverse transformation to yield a
   normal (spatial domain) image in NDF galaxy.

fourier in=galaxy powerout=galpow hermout=ft_gal fillval=mean
   Makes an Hermitian Fourier transform stored in an NDF called
   ft_gal from the 2-d NDF called galaxy.  Any bad values in
   galaxy are replaced by the mean data value of galaxy.  In
   addition the power of the transform is written to an NDF
   called galpow.

fourier realin=real_gal out=galaxy inverse
   Takes the real component of a Fourier transform stored in an
   NDF called real_gal and performs the inverse transformation to
   yield a normal image in NDF galaxy.
2 Notes
- See the NAG documentation, Chapter C06, and/or KAPPA routine
KPG1_HMLTX.GEN for more details of Hermitian Fourier transforms.
2 Related_Applications
   KAPPA: CONVOLVE, LUCY, MEM2D, WIENER; Figaro: BFFT, CMPLX*,
   COSBELL, FFT, *2CMPLX.
2 Authors
DSB: D.S. Berry (STARLINK)

MJC: Malcolm J. Currie (STARLINK)
2 History
 1988 Jun 6 (DSB):
    Original version.

 1990 Mar 19 (MJC):
    Converted to KAPPA/ADAM style.

 1990 Mar 29 (MJC):
    Added mean option for fill values and the trim option.

 20-MAY-1991 (DSB):
    Bug fixed which caused incorrect power and phase images to be
    used when performing an inverse transformation.

 1991 May 20 (MJC):
    Added error reports when no input or output NDFs are specified.
    There is less prompting for input NDFs during an inverse
    transformation when the values of one or more input NDFs are
    supplied on the command line.

 1992 March 3 (MJC):
    Replaced AIF parameter-system calls by the extended PAR
    library.

 1992 April 21 (MJC):
    Made to handle significant dimensions for user-defined
    sections.

 6-JAN-1995 (DSB):
    SUBPAR constants replaced by PAR constants.  AIF VM routines
    replaced by PSX routines.  Re-format to edstar-style
    commenting.  Add final context error report.  Changed to use
    double precision arithmetic.  Use of STATV replaced by
    KPG1_MEAND.

 1995 March 29 (MJC):
    Changed the Usage and Examples to lowercase, added Related
    Applications section, removed redundant variables previously
    needed by STATV, used a modern-style variable declaration,
    made message reporting conditional, revised the commentary for
    the 1-d case and no NAG usage and used headings to break up
    the code, and various minor stylistic changes.

 1995 March 30 (MJC):
    Made to work on single precision too.
2 Implementation_Status
   - AXIS, VARIANCE and QUALITY are not propagated from the input to
     output NDFs, but the LABEL, TITLE, HISTORY components and all
     extensions are.  Arithmetic is performed using single- or
     double-precision floating point, as appropriate for the type of
     the data array.
1 GAUSMOOTH
Smooths a 1- or 2-dimensional image using a Gaussian filter.

Usage:

   gausmooth in out fwhm

Description:

   This application applies a symmetrical filter to a 1- or
   2-dimensional image so as to convolve it with a Gaussian point
   spread function (PSF) of specified width, or widths and
   orientation.  The image is held in an NDF data structure.
2 Parameters
For information on individual parameters, select from the list below:
3 BOX
BOX() = _INTEGER (Read)
   The x and y sizes (in pixels) of the rectangular region over
   which the Gaussian PSF should be applied at each point.  The
   smoothing PSF will be set to zero outside this rectangle,
   which should therefore be sufficiently large not to truncate
   the PSF too early.  A square region is defined should only one
   size be given.  For a 1-dimensional or circular Gaussian a
   second size is ignored.  Two values are expected when an
   elliptical PSF is requested (see the description of parameter
   FWHM).

   The values given will be rounded up to positive odd integers
   if necessary.  A dynamic default value is calculated which is
   just sufficient to accommodate the Gaussian PSF out to a
   radius of 3 standard deviations.  Note that the time taken to
   perform the smoothing increases in approximate proportion to
   the value of this parameter for a circular Gaussian, and in
   proportion to the product of the two box sizes for an
   elliptical Gaussian. []
3 FWHM
FWHM() = _REAL (Read)
   This specifies whether a circular or elliptical Gaussian
   point-spread function is used in smoothing a 2-dimensional
   image.  If one value is given it is the full-width at
   half-maximum of a 1-dimensional or circular Gaussian PSF.
   (Indeed only one value is permitted for a 1-dimensional
   array.)  If two values are supplied, this parameter becomes the
   full-width at half-maximum of the major and minor axes of an
   elliptical Gaussian PSF.  Values between 0.1 and 10000.0 pixels
   should be given.  Note that unless a non-default value is
   specified for the BOX parameter, the time taken to perform the
   smoothing will increase in approximate proportion to the
   value(s) of FWHM.  The suggested default is the current value.
3 IN
IN = NDF (Read)
   The input NDF containing the 1- or 2-dimensional image to which
   Gaussian smoothing is to be applied.
3 ORIENT
ORIENT = _REAL (Read)
   The orientation of the major axis of the elliptical Gaussian
   PSF, measured in degrees in an anti-clockwise direction from
   the x axis of the NDF.  ORIENT is not obtained if FWHM has one
   value, i.e. a circular Gaussian PSF will be used to smooth the
   image, or the input NDF is 1-dimensional.  The suggested
   default is the current value.
3 OUT
OUT = NDF (Write)
   The output NDF which is to contain the smoothed image.
3 TITLE
TITLE = LITERAL (Read)
   Value for the title of the output NDF.  A null value will cause
   the title of the input NDF to be used.  [!]
3 WLIM
WLIM = _DOUBLE (Read)
   If the input image contains bad pixels, then this parameter
   may be used to determine the number of good pixels which must
   be present within the PSF area before a valid output pixel is
   generated.  It can be used, for example, to prevent output
   pixels from being generated in regions where good pixels are
   only present in the wings of the PSF.

   By default, a null (!) value is used for WLIM, which causes
   the pattern of bad pixels to be propagated from the input
   image to the output image unchanged. In this case, smoothed
   output values are only calculated for those pixels which are
   not bad in the input image.

   If a numerical value is given for WLIM, then it specifies the
   minimum PSF-weighted fraction of good pixels which must be
   present in the PSF area (i.e. box) in order to generate a good
   output pixel.  The maximum value, in the absence of bad
   pixels, is unity.  If the specified minimum fraction of good
   input pixels is not present, then a bad output pixel will
   result, otherwise a smoothed output value will be calculated.
   The value of this parameter should lie between 1E-6 and 1.0.
   [!]
2 Examples
gausmooth image1 image2 5.0
   Smooths the 2-dimensional image held in the NDF structure
   image1 using a symmetrical Gaussian PSF with a full-width at
   half-maximum of 5 pixels.  The smoothed image is written to
   image2.  If any pixels in the input image are bad, then the
   corresponding pixels in the output image will also be bad.

gausmooth spectrum1 spectrum2 5.0 box=9
   Smooths the 1-dimensional image held in the NDF structure
   spectrum1 using a symmetrical Gaussian PSF with a full-width
   at half-maximum of 5, and is evaluated over a length of 9
   pixels.  The smoothed image is written to spectrum2.  If any
   pixels in the input image are bad, then the corresponding
   pixels in the output image will also be bad.

gausmooth in=a out=b fwhm=3.5 box=31
   Smooths the 2-dimensional image held in the NDF structure a,
   writing the result into the structure b. The Gaussian
   smoothing PSF has a full-width at half-maximum of 3.5 pixels
   and is evaluated over a large square of size 31x31 pixels.

gausmooth in=a out=b fwhm=[4,3] orient=52.7 box=[29,33]
   Smooths the 2-dimensional image held in the NDF structure a,
   writing the result into the structure b.  The elliptical
   Gaussian smoothing PSF has full-width at half-maximum of 4
   pixels along its major axis and three pixels along its minor
   axis, and is evaluated over a large rectangle of size 29x33
   pixels.  The major axis of the PSF is oriented 52.7 degrees
   anti-clockwise from the x axis of the data array.

gausmooth ngc1097 ngc1097s fwhm=7.2 wlim=0.1
   Smooths the specified image data using a Gaussian PSF with a
   full-width at half-maximum of 7.2.  An output value is
   calculated for any pixel for which the PSF-weighted fraction
   of good input pixels is at least 0.1.  This will cause the
   smoothing operation to fill in moderately sized regions of bad
   pixels.
2 Timing
   For a circular PSF, the execution time is approximately
   proportional to the number of pixels in the image to be smoothed
   and to the value given for the BOX parameter.  By default, this
   latter value is proportional to the value given for FWHM.  For an
   elliptical PSF, the execution time is approximately proportional
   to the number of pixels in the image to be smoothed and to the
   product of the values given for the BOX parameter.  By default,
   these latter values are approximately proportional to the values
   given for FWHM.  Execution time will be approximately doubled if
   a variance array is present in the input NDF.
2 Related_Applications
   KAPPA: BLOCK, CONVOLVE, FFCLEAN, MATHS, MEDIAN, PSF; Figaro:
   ICONV3, ISMOOTH, IXSMOOTH, MEDFILT.
2 Authors
RFWS: R.F. Warren-Smith (STARLINK)

MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 7-AUG-1990 (RFWS):
    Original version.

 24-SEP-1990 (RFWS):
    Fixed error in the smoothing of the variance component.

 25-SEP-1990 (RFWS):
    Added calls to ERR_MARK and ERR_RLSE when checking for null
    parameter values.

 25-SEP-1990 (RFWS):
    Converted to use full-width at half-maximum (FWHM) rather than
    standard deviation (SIGMA).

 1992 March 3 (MJC):
    Replaced AIF parameter-system calls by the extended PAR
    library.

 1992 April 4 (MJC):
    Made to handle significant dimensions for user-defined
    sections.

 1992 November 13 (MJC):
    Added support for elliptical Gaussian PSFs.

 1995 April 5 (MJC):
    Renamed from GAUSS to avoid clash with Figaro.  Made to work on
    1-dimensional arrays.  Used lowercase examples and usage.
    Added Related Applications and additional commentary.  Changed
    default of TITLE to null.  Used PSX to obtain workspace.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   VARIANCE, LABEL, TITLE, UNITS, WCS and HISTORY components of the
   input NDF and propagates all extensions.

   -  Processing of bad pixels and automatic quality masking are
   supported.  The bad-pixel flag is also written for the data and
   variance arrays.

   -  All non-complex numeric data types can be handled.  Arithmetic
   is performed using single-precision floating point, or double
   precision, if appropriate.
1 GDCLEAR
Clears a graphics device and purges its database entries.

Usage:

   gdclear [device] [current]

Description:

   This application software resets an SGS graphics device. In effect
   the device is cleared.  It purges the graphics-database entries
   for the device.  Optionally, only the current picture is cleared
   and the database unchanged. (Note the clearing of the current
   picture may not work on some graphics devices.)
2 Parameters
For information on individual parameters, select from the list below:
3 CURRENT
CURRENT = _LOGICAL (Read)
   If TRUE then only the current picture is cleared. [FALSE]
3 DEVICE
DEVICE = DEVICE (Read)
   The graphics device to be cleared. [Current graphics device]
2 Examples
gdclear
   Clears the current graphics device and purges its graphics
   database entries.

gdclear current
   Clears the current picture on the current graphics device.

gdclear xw
   Clears the xw device and purges its graphics database entries.
2 Related_Applications
   KAPPA: GDSET, GDSTATE, IDCLEAR, OVCLEAR.
2 Authors
MJC: Malcolm J. Currie  (STARLINK)
2 History
 1989 Apr 13 (MJC):
    Original version.

 1989 Jul 24 (MJC):
    Uses SGS to get device names consistent with the rest of KAPPA
    in the partial GNS era.

 1990 Jan 12 (MJC):
    Option to clear the current picture added.

 1991 March 24 (MJC):
    Converted to SST prologue.

 1991 April 9 (MJC):
    Added AGI begin-and-end block.

 1992 March 3 (MJC):
    Replaced AIF parameter-system calls by the extended PAR
    library.
1 GDNAMES
Shows which graphics devices are available.

Usage:

   gdnames

Description:

   The routine displays a list of the graphics devices available and
   the names which identify them.  Each name is accompanied by a
   brief descriptive comment.
2 Authors
RFWS: R.F. Warren-Smith (STARLINK)

MJC: Malcolm J. Currie (STARLINK)
2 History
 4-MAY-1989 (RFWS):
    Original version (RFWS).

 1990 Mar 31 (MJC):
    Renamed from SHODEV to GDNAMES for consistency (MJC).
1 GDSET
Selects a current graphics device.

Usage:

   gdset device

Description:

   This application selects a current graphics device.  This device
   will be used for all applications requiring an image-display
   until changed explicitly.
2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   The graphics device to become the current graphics device.
2 Examples
gdset xwindows
   Makes the xwindows device the current graphics device.
2 Authors
MJC: Malcolm J. Currie  (STARLINK)
2 History
 1991 June 27 (MJC):
    Original version.

 1991 October 17 (MJC):
    Added an AGI_ANNUL to ensure that the global parameter is
    updated every invocation.
1 GDSTATE
Shows the current status of a graphics device.

Usage:

   gdstate [device] [frame] 

Description:

   This application displays information about the current graphics
   database picture on a graphics device, including the extreme axis
   values in any requested co-ordinate Frame (see parameter FRAME).
   Information is written to various output parameters for use by
   other applications, and is also written to the screen by default
   (see parameter REPORT). An outline may be drawn around the current
   picture if required (see parameter OUTLINE).
2 Parameters
For information on individual parameters, select from the list below:
3 COMMENT
COMMENT = LITERAL (Write)
   The comment of the current picture.  Up to 132 characters
   will be written.
3 DESCRIBE
DESCRIBE = _LOGICAL (Read)
   If TRUE, a detailed description is displayed of the co-ordinate
   Frame in which the picture bounds are reported (see parameter
   FRAME). [current value]
3 DEVICE
DEVICE = DEVICE (Read)
   Name of the graphics device about which information is
   required. [Current graphics device]
3 DOMAIN
DOMAIN = LITERAL (Write)
   The Domain name of the current co-ordinate Frame for the current
   picture.
3 EPOCH
EPOCH = _DOUBLE (Read)
   If a "Sky Co-ordinate System" specification is supplied (using
   parameter FRAME) for a celestial co-ordinate system, then an
   epoch value is needed to qualify it. This is the epoch at
   which the displayed sky co-ordinates were determined. It should
   be given as a decimal years value, with or without decimal places
   ("1996.8" for example). Such values are interpreted as a Besselian
   epoch if less than 1984.0 and as a Julian epoch otherwise.
3 FRAME
FRAME = LITERAL (Read)
   A string determining the co-ordinate Frame in which the bounds
   of the current picture are to be reported. When a picture is
   created by an application such as PICDEF, DISPLAY, etc, WCS
   information describing the available co-ordinate systems are stored
   with the picture in the graphics database. This application can
   report bounds in any of the co-ordinate Frames stored with the
   current picture. The string supplied for FRAME can be one of the
   following:

   - A domain name such as SKY, AXIS, PIXEL, BASEPIC, CURPIC, etc. The
   special domain AGI_WORLD is used to refer to the world co-ordinate
   system stored in the AGI graphics database. This can be useful if
   no WCS information was store with the picture when it was created.

   - An integer value giving the index of the required Frame.

   - A "Sky Co-ordinate System" (SCS) value such as EQUAT(J2000) (see
   section "Sky Co-ordinate Systems" in SUN/95).

   If a null value (!) is supplied, bounds are reported in the
   co-ordinate Frame which was current when the picture was created.
   [!]
3 LABEL
LABEL = LITERAL (Write)
   The label of the current picture.  It is blank if there is no
   label.
3 NAME
NAME = LITERAL (Write)
   The name of the current picture.
3 OUTLINE
OUTLINE = _LOGICAL (Read)
   If OUTLINE is TRUE, then an outline will be drawn around the
   current picture to indicate its position. [FALSE]
3 REFNAM
REFNAM = LITERAL (Write)
   The reference object associated with the current picture.  It
   is blank if there is no reference object.  Up to 132 characters
   will be written.
3 REPORT
REPORT = _LOGICAL (Read)
   If this is FALSE the state of the graphics device is not
   reported, merely the results are written to the output
   parameters.  It is intended for use within procedures. [TRUE]
3 STYLE
STYLE = LITERAL (Read)
   A group of attribute settings describing the plotting style to use
   when drawing the outline (see parameter OUTLINE). The format
   of the axis values reported on the screen may also be controlled.

   A comma-separated list of strings should be given in which each
   string is either an attribute setting, or the name of a text file
   preceded by an up-arrow character "^". Such text files should
   contain further comma-separated lists which will be read and
   interpreted in the same manner. Attribute settings are applied in
   the order in which they occur within the list, with later settings
   over-riding any earlier settings given for the same attribute.

   Each individual attribute setting should be of the form:

      <name>=<value>

   where <name> is the name of a plotting attribute, and <value> is
   the value to assign to the attribute. Default values will be
   used for any unspecified attributes. All attributes will be
   defaulted if a null value (!) is supplied. See section "Plotting
   Attributes" in SUN/95 for a description of the available
   attributes. Any unrecognised attributes are ignored (no error is
   reported).

   The appearance of the outline is controlled by the attributes
   Colour(Border), Width(Border), etc (the synonym "Outline" may be
   used in place of "Border"). In addition, the following attributes
   may be set in order to control the appearance of the formatted axis
   values reported on the screen: Format, Digits, Symbol, Unit. These
   may be suffixed with an axis number (e.g. "Digits(2)") to refer to
   the values displayed for a specific axis. [current value]
3 X1
X1 = LITERAL (Write)
   The lowest value found within the current picture for axis 1 of the
   requested co-ordinate Frame (see parameter FRAME).
3 X2
X2 = LITERAL (Write)
   The highest value found within the current picture for axis 1 of the
   requested co-ordinate Frame (see parameter FRAME).
3 Y1
Y1 = LITERAL (Write)
   The lowest value found within the current picture for axis 2 of the
   requested co-ordinate Frame (see parameter FRAME).
3 Y2
Y2 = LITERAL (Write)
   The highest value found within the current picture for axis 2 of the
   requested co-ordinate Frame (see parameter FRAME).
2 Examples
gdstate
   Shows the status of the current graphics device. The bounds of
   the picture are displayed in the current co-ordinate Frame of
   the picture.

gdstate ps_l basepic
   Shows the status of the ps_l device. The bounds of the picture
   are displayed in the BASEPIC Frame (normalised device co-ordinates
   in which the short of the two dimensions of the display surface
   has length 1.0).

gdstate outline frame=pixel style="'colour=red,width=3'"
   Shows the status of the current graphics device and draws a
   thick, red outline around the current database picture. The
   bounds of the picture are displayed in the PIXEL co-ordinate
   Frame (if available).

gdstate refnam=(ndfname)
   Shows the status of the current graphics device.  If there
   is a reference data object, its name is written to the ICL
   variable NDFNAME.

gdstate x1=(x1) x2=(x2) y1=(y1) y2=(y2) frame=basepic
   Shows the status of the current graphics device.  The bounds
   of the current picture in normalised device co-ordinates
   are written to the ICL variables: X1, X2, Y1, Y2.
2 Notes
-  The displayed bounds are the extreme axis values found anywhere
within the current picture. In some situations these extreme
values may not occur on the edges of the picture. For instance, if
the current picture represents a region including the north
celestial pole, then displaying the picture bounds in celestial
co-ordinates will give a declination upper limit of +90 degrees,
whilst the RA limits will be 0 hours and (close to) 24 hours.

-  Previous versions of this application reported bounds in
"Normalised Device Co-ordinates". Similar functionality is now
provided by setting parameter FRAME to "BASEPIC". Be aware though,
that "Normalised Device Co-ordinates" were normalised so that the
longer of the two axes had a length of 1.0, but BASEPIC co-ordinates
are normalised so that the shorter of the two axes has length 1.0.
2 Related_Applications
   KAPPA: IDSTATE.
2 Authors
RFWS: R.F. Warren-Smith (STARLINK)

MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 1-DEC-1989 (RFWS):
    Original version.

 13-DEC-1989 (RFWS):
    Added call to MSG_SYNC to synchonise message system and
    graphical output.

 1990 Jan 16 (MJC):
    Added output of the current picture's label, if it exists.

 1991 February 8 (MJC):
    Added output of the current picture's reference object, if it
    exists.

 1991 March 24 (MJC):
    Converted to SST prologue.

 1991 August 20 (MJC):
    Added output parameters and REPORT parameter.

 7-JAN-2000 (DSB):
    Big changes for the first AST/PGPLOT version.
1 Getting_Data_into_KAPPA

KAPPA utilises general data structures within an HDS container file,
with file extension .sdf.  Elsewhere in this help, processing was
performed on data in this format generated from within KAPPA.
Generally, you will already have data in `foreign' formats, that is
formats other than the Starlink standard, particularly in the FITS
(Flexible Image Transport System), IRAF, and Figaro DST formats.
The topic "Automatic_Data_Conversion" describes how you can make
these work `directly' with KAPPA.

You can run CONVERT (cf. SUN/55) directly to perform conversions.
There is also TRANDAT, which will read a text file of data values,
or co-ordinates and data values into an NDF, and ASCIN in the
FIGARO package.

2 FITS_Readers
Automatic conversion does not allow you the full control of the
conversion that direct use of a FITS reader offers and it does not
deal with the special properties of tape.  FITSIN will read, amongst
others, simple FITS files including blocked or group format and
floating-point data from tape.  FITSDIN is its counterpart for disc
files.  The sub-topics show the FITS readers in action. 

2 Tape

FITSIN reads FITS files stored on tape.  For efficiency, you should
select the "no-rewind" device for the particular tape drive, for
example /dev/nrmt0h on OSF and /dev/rmt/1n on Solaris.

We ask for the second file on the tape, and the headers are
displayed so we can decide whether this is the file we want.  It is
so we supply a name of an NDF to receive the FITS file.  If it
wasn't we would enter ! to the OUT prompt.  The FMTCNV parameter
asks whether the data are to be converted to _REAL, using the FITS
keywords BSCALE and BZERO, if present.  If you are wondering why
there is (1) after the file number, that's present because FITS
files can have sub-files, stored as FITS extensions. 

     % fitsin
     MT - Tape deck /@/dev/nrmt0h/ >
     The tape is currently positioned at file 1.
     FILES - Give a list of the numbers of the files to be processed > 2
     File # 2(1)  Descriptors follow:
     SIMPLE  =                    T
     BITPIX  =                   16
     NAXIS   =                    2
     NAXIS1  =                  400
     NAXIS2  =                  590
     DATE    = '03/07/88'                    /Date tape file created
     ORIGIN  = 'ING     '                    /Tape writing institution
     OBSERVER= 'CL      '                    /Name of the Observer
     TELESCOP= 'JKT     '                    /Name of the Telescope
     INSTRUME= 'AGBX    '                    /Instrument configuration
     OBJECT  = 'SYS:ARCCL.002'               /Name of the Object
     BSCALE  =                  1.0          /Multiplier for pixel values
     BZERO   =                  0.0          /Offset for pixel values
     BUNIT   = 'ADU     '                    /Physical units of data array
     BLANK   =                    0          /Value indicating undefined pixel
                 :                :                :
                 :                :                :
                 :                :                :
     END
     FMTCNV - Convert data? /NO/ >
     OUT - Output image > ff1
     Completed processing of tape file 2 to ff1.
     MORE - Any more files? /NO/ >

We can trace the structure to reveal the 2-byte integer CCD image.
Notice that the FITS headers are stored verbatim in a component
.MORE.FITS. This is the FITS extension.  The extension contents can
be listed with FITSLIST.  There is more on this NDF extension and
its purpose in sub-topic "FITS_Airlock". 

     % hdstrace ff1
     FF1  <NDF>
 
        DATA_ARRAY(400,590)  <_WORD>   216,204,220,221,202,222,220,206,218,221,
                                       ... 216,218,218,204,221,218,219,222,221,218
        TITLE          <_CHAR*13>      'SYS:ARCCL.002'
        UNITS          <_CHAR*3>       'ADU'
        MORE           <EXT>           {structure
           FITS(84)       <_CHAR*80>      'SIMPLE  =                    T','BI...'
                                          ... '   ...','         ING PACKEND','END'
   
     End of Trace.

If you have many FITS files to read there is a quick method for
extracting all files or a selection.  In automatic mode the output
files are generated without manual intervention and the headers
aren't reported for efficiency.  Should you want to see the headers,
write them to a text file via the LOGFILE parameter.  The cost of
automation is a restriction on the names of the output files, but
if you have over a hundred files on a tape are you really going to
name them individually?

The following example extracts the fourth to sixth, and eighth files.
Note that the [] are needed because the value for parameter FILES is
a character array. 

     % fitsin auto
     MT - Tape deck /@/dev/nrmt0h/ >
     FMTCNV - Convert data? /NO/ > y
     PREFIX - Prefix for the NDF file names? /'FITS'/ > JKT
     FILES - Give a list of the numbers of the files to be processed > [4-6,8]
     Completed processing of tape file 4 to JKT4.
     Completed processing of tape file 5 to JKT5.
     Completed processing of tape file 6 to JKT6.
     Completed processing of tape file 8 to JKT8.
     MORE - Any more files? /NO/ >

You can list selected FITS headers from a FITS tape without
attempting to read in the data into NDFs by using FITSHEAD.  You can
redirect its output to a file to browse at your leisure, and
identify the files you want to convert.  So for instance, 

     % fitshead /dev/nrmt1h > headers.lis

lists all the FITS headers from a FITS tape on device /dev/nrmt1h
to file headers.lis.

After running FITSIN you may notice a file USRDEVDATASET.sdf in
the current directory.  This HDS file records the current position
of the tape, so you can use FITSIN to read a few files, and then run
it again a little later, and FITSIN can carry on from where you left
off.  In other words FITSIN does not have to rewind to the beginning
of the tape to count files.  When you're finished you should delete
this file.

3 Disc
Until comparatively recently there was officially no such thing as
disc FITS.  However, for many years ad hoc implementations have
existed.  Of these, FITSDIN will handle files adhering to the FITS
rules for blocking (and more), but it doesn't process byte-swapped
`FITS' files.  Thus it can process files with fixed-length records
of semi-arbitrary length; so, for example, files mangled during
network transfer, which have 512-byte records rather than the
customary 2880, may be read.  However, it will not handle, VAX FITS
files as may be produced with Figaro's WDFITS.  FITSDIN will accept
a list of files with wildcards.  However, a comma-separated list
must be enclosed in quotation marks.  Also wildcards must be
protected. Here are some examples so you get the idea. 

     % fitsdin '*.fit'
     % fitsdin \*.fit
     ICL> fitsdin *.fit
     % fitsdin '"i*.fit,abc123.fts"'
     ICL> fitsdin "i*.fit,abc123.fts"

In the following example a floating-point file is read (BITPIX=-32)
and so FMTCNV is not required.

     % fitsdin '*.fits'

        2 files to be processed...

     Processing file number 1: /home/scratch/dro/gr.fits.
     File /scratch/dro/gr.fits(1)  Descriptors follow:
     SIMPLE  =                    T / Standard FITS format
     BITPIX  =                  -32 / No. of bits per pixel
     NAXIS   =                    2 / No. of axes in image
     NAXIS1  =                  512 / No. of pixels
     NAXIS2  =                  256 / No. of pixels
     EXTEND  =                    T / FITS extension may be present
     BLOCKED =                    T / FITS file may be blocked
     
     BUNIT   = 'none given      '   / Units of data values
     
     CRPIX1  =   1.000000000000E+00 / Reference pixel
     CRVAL1  =   0.000000000000E+00 / Coordinate at reference pixel
     CDELT1  =   1.000000000000E+00 / Coordinate increment per pixel
     CTYPE1  = '                '   / Units of coordinate
     CRPIX2  =   1.000000000000E+00 / Reference pixel
     CRVAL2  =   0.000000000000E+00 / Coordinate at reference pixel
     CDELT2  =   1.000000000000E+00 / Coordinate increment per pixel
     CTYPE2  = '                '   / Units of coordinate
 
     ORIGIN  = 'ESO-MIDAS'          / Written by MIDAS
     OBJECT  = 'artificial image'   / MIDAS desc.: IDENT(1)
             :                :                :
             :                :                :
             :                :                :
     HISTORY  ESO-DESCRIPTORS END     ................
     
     END
     OUT - Output image > gr
     Completed processing of disk file /home/scratch/dro/gr.fits to gr.
     File has illegal-length blocks (512). Blocks should be a multiple (1--10) of the
     FITS record length of 2880 bytes.
     Processing file number 2: /home/scratch/dro/indef.fits.
     File /home/scratch/dro/indef.fits(1)  Descriptors follow:
     SIMPLE  =                    T  /  FITS STANDARD
     BITPIX  =                   32  /  FITS BITS/PIXEL
     NAXIS   =                    2  /  NUMBER OF AXES
     NAXIS1  =                  256  /
     NAXIS2  =                   20  /
     BSCALE  =      3.7252940008E28  /  REAL = TAPE*BSCALE + BZERO
     BZERO   =      7.9999999471E37  /
     OBJECT  = 'JUNK[1/1]'  /
     ORIGIN  = 'KPNO-IRAF'  /
             :                :                :
             :                :                :
             :                :                :
     END
     OUT - Output image > iraf
     Completed processing of disk file /home/scratch/dro/indef.fits to iraf.

NDFTRACE shows that the object name is written to the NDF's title,
that axes derived from the FITS headers are present, and that gr is
a _REAL NDF.

     % ndftrace gr
 
        NDF structure /home/scratch/dro/iraf:
           Title:  artificial image
           Units:  none given
 
        Shape:
           No. of dimensions:  2
           Dimension size(s):  512 x 256
           Pixel bounds     :  1:512, 1:256
           Total pixels     :  131072
 
        Axes:
           Axis 1:
              Label : Axis 1
              Units : pixel
              Extent: -0.5 to 511.5
 
           Axis 2:
              Label : Axis 2
              Units : pixel
              Extent: -0.5 to 255.5
 
        Data Component:
           Type        :  _REAL
           Storage form:  PRIMITIVE
           Bad pixels may be present
 
        Extensions:
              FITS             <_CHAR*80>
 
Both FITSIN and FITSDIN write the FITS headers into an NDF extension
called FITS within your NDF.  The extension is a literal copy of all
the 80-character `card images' in order.  These can be inspected or
written to a file via the command FITSLIST.  There is more on this
NDF extension and its purpose in topic "FITS_Airlock".

2 FITS_Airlock

3 NDF_Extensions
An important feature of the NDF is that it is designed to be
extensible.  The NDF has components whose meanings are well defined
and universal, and so they can be accessed by general-purpose
software, such as KAPPA and CONVERT provide; but the NDF also allows
independent extensions to be defined and added, which can store
auxiliary information to suit the needs of a specialised software
package.  (Note that the term extension here refers to a structure
within the NDF for storing additional data, and is neither the file
extension .sdf nor extensions like BINTABLE within the FITS file.)
An extension is only processed by software that understands the
meanings obeys the processing rules of the various components of
the extension. Other programmes propagate the extension information
unaltered.

The existence of extensions makes it straightforward to write
general utilities for converting an arbitrary format into an NDF.
The idea being that every specialist package should not have to
have its own conversion tools such as a FITS reader.  However, this
still leaves the additional data that requires specialist knowledge
to move it into the appropriate extension components.  The aim is to
make the conversions themselves extensible, with add-on operations
to move the specialist information to and from the extensions.  This
is where the FITS `airlock' comes in.

The FITS data format comprises a header followed by the data array
or table.  The header contains a series of 80-character lines each
of which contains the keyword name, a value and an optional comment.
There are also some special keywords for commentary.  The meanings
of most keywords are undefined, and so can be used to transport
arbitrary ancillary information, subject to FITS syntax limitations.
There is a special NDF extension called FITS, which mirrors this
functionality, and may be added to an NDF.  It therefore can act as
an airlock between the general-purpose conversion tools and
specialist packages.

3 Importing_and_Exporting_from_and_to_the_FITS_Extension

The FITS extension comprises a 1-dimensional array of 80-character
strings that follow FITS-header formatting rules.  In the case of
FITSIN and FITSDIN, each FITS extension is a verbatim copy of the
FITS header of the input file.  Other conversion tools like
IRAF2NDF and UNF2NDF of CONVERT can also create a FITS extension in
the same fashion.  On export, standard conversion tools propagate
the FITS extension to any FITS headers or equivalent in the foreign
format.  However, information which is derivable from the standard
NDF components, such as the array dimensions, data units, and
linear axes, replaces any equivalent headers from FITS extension.

You use your knowledge, or the writer of the specialist package
provides import tools, to recognise certain FITS keywords and to
attribute meaning to them, and then to move or process their values
to make the specialist extensions.  One such is the PREPARE task in
IRAS90.  Similarly, the reverse operation---exporting the extension
information---can occur too, prior to converting the NDF into
another data format.

KAPPA offers two simple tools for the importing and exporting
of extension information: FITSIMP and FITSEXP.  They both use a text
file which acts as a translation table between the FITS keyword and
extension components.  Starting with FITSIMP, its translation table
might look like this.

     ORDER_NUMBER _INTEGER  ORDNUM 
     PLATE_SCALE  _REAL SCALE         ! The plate scale in arcsec/mm
     SMOOTHED  _LOGICAL FILTERED 

It consists of three fields: the first is the name of the component
in the chosen extension, the second is the HDS data type of that
component, and the third is the FITS keyword.  Optional comments can
appear following an exclamation mark.  So if we placed these lines
in file imptable, we could create an extension called MYEXT of data
type MJC_EXT (if it did not already exist) containing components
ORDER_NUMBER, PLATE_SCALE, and SMOOTHED.

     % fitsimp mydata imptable myext mjc_ext

Should any of the keywords not exist in the FITS extension, you'll
be warned.  If the extension already exists, you don't need to
specify the extension data type.  FITSIMP will even handle
hierarchical keywords and those much-loved ING packets from La
Palma.

Going in the opposite direction, the text translation file could look
like this

     MYEXT.ORDER_NUMBER  ORDNUM(LAST) The spectral order number
     MYEXT.PLATE_SCALE   SCALE   The plate scale in arcsec/mm
     MYEXT.SMOOTHED  FILTERED 

where the first column is the `name' of the extension component to
be copied to the FITS extension.  The `name' includes the extension
name and substructures.  The second column gives the FITS keyword to
which to write the value.  A further keyword in parentheses
instructs FITSEXP to place the new FITS header immediately before
the header with that keyword.  If the second keyword is absent from
the translation-table record or the FITS extension, the new header
appears immediately before the END header line in the FITS
extension.  Thus the value of ORDER_NUMBER in extension MYEXT,
creates a new keyword in the FITS extension called ORDNUM, and it is
located immediately prior the keyword LAST.

3 Listing_the_FITS_extension_and_keywords

If you don't want to be bothered with NDF extensions, you might just
want to know the value of some FITS keyword, say the exposure time,
as part of your data processing.  FITSLIST lists the contents of the
FITS extension of an NDF or file.  You can even search for keywords
with grep.

     % fitslist myndf | grep "ELAPSED ="

This would find the keyword ELAPSED in the FITS extension of NDF
myndf.  (Keywords are 8 characters long and those with values are
immediately followed by an equals sign.)  However, the recommended
way is to use the FITSVAL command.  Since this command only reports
the value, it is particularly useful in scripts that need
ancillary-data values during processing.  The following obtains the
value of keyword ELAPSED.

     % fitsval myndf ELAPSED

In a script you may need to know whether the keyword exists and take
appropriate action.

     filterpre = `fitsexist myndf filter`
     if ( $filterpre == "TRUE" ) then
        filter = `fitsval myndf filter`
     else
        prompt -n "Filter > "
        set filter = $<
     endif

Shell variable filterpres would be assigned "TRUE" when the FILTER
card is present, and "FALSE" otherwise.  (The ` ` quotes cause the
enclosed command to be executed.)  So the user of the script would
be prompted for a filter name whenever the NDF did not contain that
information.

3 Creating_and_Editing_the_FITS_Extension

Besides the conversion utilities, you can import your own FITS
extension using FITSTEXT.  You first prepare a FITS-like header in
a text file.  For example,

     % fitstext myndf myfile

places the contents of myfile in the NDF called myndf.  This is not
advised unless you are familiar with the rules for writing FITS
headers.  See the NOST "A User's Guide to FITS".  You find this and
other useful FITS documents, test files, and software at the FITS
Support Office Home Page (URL
http://www.gsfc.nasa.gov/astro/fits/fits_home.html).  FITSTEXT does
perform some limited validation of the FITS headers, and informs you
of any problems it detects.  See the "FITSHEAD Notes" topic for
details. 

A safer bet for a hand-crafted FITS extension is to edit an existing
FITS extension to change a value, or use existing lines as templates
for any new keywords you wish to add.  FITSEDIT lets you do this
with your favourite text editor.  Define the environment variable
EDITOR to your editor, say

     % setenv EDITOR jed

to choose jed.  If you don't do this, and EDITOR is unassigned,
FITSEDIT selects the vi editor.  Then to edit the NDF extension
is simple.

     % fitsedit myndf

This edits the FITS extension of the NDF called myndf.  FITSEDIT
extracts the file into a temporary file (zzfitsedit.tmp) which you
edit, and then uses FITSTEXT to restore the FITS extension.  It
therefore has the same parsing of the edited FITS headers as
FITSTEXT provides.

3 Easy Easy_way_to_create_and_edit_the_FITS_Extension

Should you wish to write a new value without knowing about FITS,
or in a script where manual editing is undesirable, the FITSWRITE
command does the job.  So for example,

     % fitswrite myndf filter value=K

will create a keyword FILTER with value K in the FITS extension
of the NDF called myndf.  If the extension does not exist, this
command will first create it.

The FITSMOD command has several editing options including the
ability to delete a keyword:

    % fitsmod myndf airmass edit=delete

here it removes the AIRMASS header; or rename a keyword:

     % fitsmod myndf band rename newkey=filter

as in this example, where keyword BAND becomes keyword FILTER; or
update an existing keyword:

     % fitsmod myndf filter edit=u value=\$V \
       comment='"Standard filter name"'

this example modifies the comment string associated with the FILTER
keyword, leaving the value unchanged.

For routine operations requiring many operations on a dataset,
FITSMOD lets you specify the editing instructions in a text file.


1 Getting_Started
Look at help topic "Hints", and the sub-topics and references
therein.

1 GLITCH
Replaces bad pixels in a 2-d NDF with the local median

Usage:

   glitch in out [title]

Description:

   This routine removes bad pixels from a 2-d NDF, replacing them with
   the median of the eight (or less at the edges) neighbouring pixels.
   At least three of these eight neighbouring pixels must have good
   values (that is, they must not set to the bad value) otherwise the
   resultant pixel becomes bad.

   The positions of the pixels to be removed can be supplied in four
   ways (see parameter MODE):

   - In response to parameter prompts. A single bad pixel position is
   supplied at each prompt, and the user is re-prompted until a null value
   is supplied.

   - Within a positions list such as produced by applications CURSOR,
   LISTMAKE, etc.

   - Within a simple text file. Each line contains the position of a
   pixel to be replaced.

   - Alternatively, each bad pixel in the input NDF can be used
   (subject to the above requirement that at least three out of the
   eight neighbouring pixels are not bad).
2 Parameters
For information on individual parameters, select from the list below:
3 IN
IN  =  NDF (Read)
   The input image.
3 INCAT
INCAT = FILENAME (Read)
   A catalogue containing a positions list giving the pixels
   to be replaced, such as produced by applications CURSOR, LISTMAKE,
   etc. Only accessed if parameter MODE is given the value "Catalogue".
3 INFILE
INFILE = FILENAME (Read)
   The name of a text file containing the positions of the pixels
   to be replaced. The positions should be given in the current
   co-ordinate Frame of the input NDF, one per line. Spaces or
   commas can be used as delimiters between axis values. The file
   may contain comment lines with the first character # or !. This
   parameter is  only used if parameter MODE is set to "File".
3 MODE
MODE =  LITERAL (Read)
   The method used to obtain the positions of the pixels to be
   replaced. The supplied string can be one of the following:

   - "Bad": The bad pixels in the input NDF are used.

   - "Catalogue": positions are obtained from a positions list
      using parameter INCAT.

   - "File": The pixel positions are read from a text file specified
      by parameter INFILE.

   - "Interface": The position of each pixel is obtained using
      parameter PIXPOS. The number of positions supplied must not
      exceed 200.

   [current value]
3 OUT
OUT  =  NDF (Write)
   The output image.
3 PIXPOS
PIXPOS = LITERAL (Read)
   The position of a pixel to be replaced, in the current
   co-ordinate Frame of the input NDF. Axis values should be
   separated by spaces or commas. This parameter is only used if
   parameter MODE is set to "Interface". If a value is supplied on
   the command line, then the application exits after processing the
   single specified pixel. Otherwise, the application loops to
   obtain multiple pixels to replace, until a null (!) value is
   supplied. Entering a colon (":") will result in a description of
   the required co-ordinate Frame being displayed, followed by a
   prompt for a new value.
3 TITLE
TITLE  =  LITERAL (Read)
   Title for the output image.  A null value (!) propagates the title
   from the input image to the output image. [!]
2 Examples
glitch m51 cleaned mode=cat incat=badpix.FIT
   Reads pixel positions from the positions list stored in the FITS
   file badpix.FIT, and replaces the corresponding pixels in the
   2-d NDF m51.sdf by the median of the surrounding neighbouring
   pixels. The cleaned image is written to cleaned.sdf.
2 Notes
-  If the current co-ordinate Frame of the input NDF is not PIXEL,
then the supplied positions are first mapped into the PIXEL Frame
before being used.
2 Related_Applications
   KAPPA: ARDMASK, CHPIX, FILLBAD, ZAPLIN, NOMAGIC, SEGMENT,
   SETMAGIC; Figaro: CSET, ICSET, NCSET, TIPPEX.
2 Authors
DSB: David S. Berry (STARLINK)
2 History
 7-MAY-2000 (DSB):
    First NDF version.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   VARIANCE, LABEL, TITLE, UNITS, WCS and HISTORY components of the
   input NDF and propagates all extensions.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  Only single and double precision floating point data can be
   processed directly. All integer data will be converted to floating
   point before being processed.

1 GLOBALS
Displays the values of the KAPPA global parameters.

Usage:

   globals

Description:

   This procedure lists the meanings and values of the KAPPA global
   parameters.  If a global parameter does not have a value, the
   string "<undefined>" is substituted where the value would have
   been written.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1991 July 18 (MJC):
    Original version.

 1992 June 5 (MJC):
    Finds the operating system in order to define the path to the
    global file.

 1995 August 31 (MJC):
    Lists the current transformation.

 1995 December 6 (MJC):
    Revised the displayed wording for the current DATA_ARRAY to
    apply to foreign formats too.
1 HDS_Data_Types
KAPPA applications can process NDFs in one or more of the following
HDS data types. The correspondence between Fortran types and HDS
data types is as follows: 

   ------------------------------------------
   | HDS Type | Number   | VAX FORTRAN Type |
   |          | of bytes |                  |
   ------------------------------------------
   | _DOUBLE  |    8     | DOUBLE PRECISION |
   | _INTEGER |    4     | INTEGER          |
   | _REAL    |    8     | REAL             |
   | _UBYTE   |    1     | BYTE             |
   | _BYTE    |    1     | BYTE             |
   | _UWORD   |    2     | INTEGER*2        |
   | _WORD    |    2     | INTEGER*2        |
   ------------------------------------------

_UBYTE and _UWORD types are unsigned and so permit data ranges of
0--255 and 0--65535 respectively.

1 Hints
This topic contains hints for new and intermediate user.

2 Aborting_an_Application
In normal circumstances when you've finished using KAPPA nothing
need be done from the shell, but to end an ICL session, enter the
EXIT command to return to the shell.

What if you've done something wrong, like entering the wrong value
for a parameter?  If there are further prompts you can enter the
abort code !! to exit the application.  This is recommended even
from the shell because certain files like your NDFs may become
corrupted if you use a crude CTRL/C.  If, however, processing of the
data has begun in the application, it is probably best to let the
task complete, unless it is a long job like image deconvolution.
If you really must abort, CTRL/C should be hit.  From ICL this ought
to return you to a prompt, but the processing will continue.  Then
you can stop the running process by `killing' it.  First find the
task name

     ICL> tasks
                           TASKNAME  Process Id

                   ndfpack_mon16528  15186

and then kill it.

     ICL> kill ndfpack_mon16528

for a task in the NDFPACK monolith.  NDFPACK will be loaded again
once you enter one its commands.  If several attempts with CTRL/C
fail to return you to an ICL prompt then it's time for the heavy
artillery---you may have to kill your window.  Once back to the
shell enter icl to return to ICL, and then kill the process as
described above.

If you have interrupted a task, it may be necessary to delete the
parameter file (topic "Parameters Defaults") and the graphics
database (topic "Graphics_Database").

2 Starlink_initialisation

Before you can run a Starlink application you need to make the
startup scripts available and define some environment variables.
The easiest way is to insert the line

     source /star/etc/cshrc

into your .cshrc or .tcshrc file, and in .login file you include the
equivalent line

     source /star/etc/login

which you've presumably done to be reading this.  It's here for
completeness in case you need to show someone else how to do it.

At non-Starlink sites the /star path may be different.

2 Data_conversion
See topics "Getting_Data_into_KAPPA", "Automatic_Data_Conversion",
and SUN/55.

2 Finding_an_Application
Help Topic "Summary" lists in alphabetical order the 181 commands
and their functions, and "Classified_Commands" is a classified list
of the same commands.  Many examples are given throughout the help
library.

2 Getting_Started
A good place to start is to look at the tutorials on pages 3--9 of
SUN/95.  Also look at the other help sub-topics in the "Hints", and
the "Parameters Summary" topic, which describe how to obtain help,
how to run programmes, and controlling parameters to applications.
If you want to produce graphics, first see
"Selecting_Graphics_Devices".

2 Graphics
See topic "Selecting_Graphics_Devices" for selecting an output
device for your plots.  If you are using an image display topic
"Colour_Table_and_Palette" gives details of how to control the
appearance of colour tables and the annotation palette.  There
are also examples of how to create lookup tables. SUN/95 has a
section called "The Graphics Database" containing illustrated
examples of how to use the AGI graphics database.  The topics on
"Co-ordinate_Systems" and "Interaction_Mode" are partially
related to the graphics database.

2 Issuing_Commands
To run an application you then can just give its name---you will be
prompted for any required parameters.  Alternatively, you may enter
parameter values on the command line specified by position or by
keyword.  More on this in the "Parameters" topic.

Commands are interpreted in a case-independent way from ICL, but
from the shell they must be given in lowercase.  In ICL, commands
may also be abbreviated provided they are unambiguous strings with
at least four characters.  Commands shorter than five characters,
therefore, cannot be shortened. So

     ICL> CREF
     ICL> CREFR
     ICL> CreFra
     ICL> CREFRAM
 
would all run CREFRAME.  Whereas
 
     ICL> FITS
     ICL> FITSI
 
would be ambiguous, since there are several commands beginning
FITS, and two starting FITSI, namely FITSIN and FITSIMP.

Note if other packages are active there is the small possibility of
a command-name clash.  Issuing such a command will run that command
in the package last activated.  You can ensure running the KAPPA
command by inserting a kap_ prefix before the command name.  For
example,

      % kap_rotate

will execute KAPPA's ROTATE application.  There may also be a clash
with UNIX commands and shell built-in functions, though there are
now far fewer conflicts than in earlier versions of KAPPA, with
only look being ambiguous.  There is also a glob in the C-shell
which might confuse you should you forget that GLOBALS cannot be
abbreviated from the shell.

Since the KAPPA commands are the same in both the shell and ICL,
the % and ICL> prompts in the examples and description throughout
this help library are interchangeable unless noted otherwise.

2 Obtaining_Help
To access the KAPPA help use KAPHELP.

     ICL> kaphelp

The system responds by introducing KAPPA's help library, followed by
a long list of topics for which help is available, followed by the
prompt "Topic?".  These topics are mostly the commands for running
applications, but they also include global information on matters
such as parameters, data structures and selecting a graphics device.

From ICL you can issue other commands for obtaining help about KAPPA.

     ICL> help kappa
     ICL> help packages

The former is nearly equivalent to entering kaphelp.  However, it is
less easy to use as it lacks many of the navigational aids of
KAPHELP.  The latter gives a summary of Starlink packages available
from ICL.  If you select the KAPPA subtopic, you'll get a precis of
the package's facilities.  (This is part of an index of Starlink
packages.)

If you have commenced running an application you can still access
the help library whenever you are prompted for a parameter.  See
the topic "Parameters Help" for details. 

2 Navigating_Help_Hierarchies
The help information is arranged hierarchically.  The help system
enables you to navigate the library by prompting when it has either
presented a screen's worth of text or has completed displaying the
previously requested help.  The information displayed by the help
system on a particular topic includes a description of the topic
and a list of subtopics that further describe the topic.

You can select a new topic by entering its name or an unambiguous
abbreviation.  If you press the carriage-return key (<CR>) you will
either continue reading a topic where there is further text to show,
or move up one level in the hierarchy.  Entering a CTRL/D (pressing
D whilst holding the CTRL key) terminates the help session.  See the
description of KAPHELP for a full list of the options available at
prompts inside the help system, and the rules for wildcarding and
abbreviating topics.

2 Help_on_KAPPA_commands
Help on an individual KAPPA application is simply achieved by
entering kaphelp followed by the command name, for example

     % kaphelp centroid

will give the description and usage of the CENTROID command.  There
are subtopics which contain details of the parameters, including
defaults, and valid ranges; examples; notes expanding on the
description; implementation status; and occasionally timing.
For example,

     ICL> kaphelp hist param ndf

gives details of parameter NDF in all applications prefixed by
HIST.

(From ICL you can also invoke its help system, thus

     ICL> help centroid

is similar to kaphelp centroid, though the ICL system has drawbacks,
and you are recommended to run KAPHELP.

The instruction

     ICL> kaphelp help classified

displays a list of subject areas as subtopics.  Each subtopic lists
and gives the function of each KAPPA application in that
classification.  There is also an alphabetic list which can be
obtained directly via the command

     ICL> help summary

2 Hypertext_Help
A modified version of the KAPPA documentention exists in hypertext
form.  One way to access it is to use the showme command

     % showme sun95

and a Web browser will appear, presenting the index to the hypertext
form of this document.  The hypertext permits easy location of
referenced documents and applications.  It also includes colour
illustrations.

The findme command lets you search the Starlink documents by
keywords.  For instance,

     % findme masking

searches the document looking for the word "masking" in them.  The
level of searching depends on whether a match is found.  The search
starts with the document title, the page (section) titles, and
finally the document text.  The deeper the search, the longer it
will take.  There are switches provided to limit the level of the
search.  The search string may include sed or grep regular
expressions.  See SUN/188 or enter

     % findme findme
     % findme showme 

to learn more about the findme and showme commands.

2 Changing_the_Current_Directory_in_ICL
You should change default directories in ICL using its
DEFAULT command, and not cd.  Thus

     ICL> default /home/scratch/dro

makes /home/scratch/dro the default directory for the ICL session,
and for existing and future subprocesses, including application
packages.

2 Problems
Solutions to some common problems using KAPPA are given in topic
"Problems_Problems".

2 Running_KAPPA
KAPPA runs from the C-shell and variants, and also from the
interactive command language---ICL.  Both run monolithic programmes
for efficiency.  Both have their advantages and disadvantages.  Of
the latter, the shell forces you to escape certain characters, and
ICL does not have a foreach to loop through a wildcarded list of
NDFs.  You may simply prefer the familiar shell to ICL, though
UNIX commands, including editing, are accessible from ICL via a !
prefix.  This is not the place to expound the intrinsic merits of
the two command languages, but where there are differences affecting
KAPPA, they'll be indicated.  The choice is yours.

To run KAPPA from the shell just enter the following command.

     % kappa

This executes a procedure setting up aliases for KAPPA's command
names and to make help information available.  Then you'll be able
to mix KAPPA commands with the familiar shell ones. 

To run KAPPA from ICL you have to start up the command language if
you are not already using it.  This requires just one extra command,
namely

     % icl

You will see any messages produced by system and user procedures,
followed by the ICL> prompt.  Again there is a procedure for making
the commands known to the command language, and not unexpectedly, it
too is

     ICL> kappa

Then you are ready to go.  In either case you'll see message from
KAPPA telling you which version is ready for use.

2 Subsets
See topic "NDF_sections" to find a concise and convenient way of
making KAPPA process only a subset of your dataset.
1 HISCOM
Adds commentary to the history of an NDF.

Usage:

   hiscom ndf [mode] { file=?
                     { comment=?
                    mode

Description:

   This task allows application-independent commentary to be added
   to the history records of an NDF.  The text may be read from a
   text file or obtained through a parameter.
2 Parameters
For information on individual parameters, select from the list below:
3 COMMENT
COMMENT = LITERAL (Read)
   A line of commentary limited to 72 characters.  If the value is
   supplied on the command line only that line of commentary will
   be written into the history.  Otherwise repeated prompting
   enables a series of commentary lines to be supplied.  A null
   value (!) terminates the loop.  Blank lines delimit
   paragraphs.  Paragraph wrapping is enabled by parameter WRAP.
   There is no suggested default to allow more room for entering
   the value.
3 FILE
FILE =  FILENAME (Read)
   Name of the text file containing the commentary.  It is only
   accessed if MODE="File".
3 MODE
MODE = LITERAL (Read)
   The interaction mode.  The allowed values are described below.

      "File"      ---  The commentary is to be read from a text
                       file.  The formatting and layout of the
                       text is preserved in the history unless
                       WRAP=TRUE and there are lines longer than
                       the width of the history records.
      "Interface" ---  The commentary is to be supplied through a
                       parameter.  See parameter COMMENT.

   ["Interface"]
3 NDF
NDF = (Read and Write)
   The NDF for which commentary is to be added to the history.
3 WRAP
WRAP = _LOGICAL (Read)
   WRAP=TRUE requests that the paragraphs of comments are wrapped
   to make as much text fit on to each line of the history record
   as possible.  WRAP=FALSE means that the commentary text beyond
   the width of the history records (72 characters) is lost.  The
   default is TRUE when MODE="Interface" and FALSE if
   MODE="File".  The suggested default is the current value. []
2 Examples
hiscom frame256 comment="This image has a non-uniform background"
   This adds the comment "This image has a non-uniform background"
   to the history records of the NDF called frame256.

hiscom ndf=eso146-g14 comment="This galaxy is retarded" mode=i
   This adds the comment "This galaxy is retarded" to the history
   records of the NDF called eso146-g14.

hiscom hh14_k file file=ircam_info.lis
   This reads the file ircam_info.lis and places the text
   contained therein into the history records of the NDF called
   hh14_k.  Any lines longer than 72 characters are truncated to
   that length.

hiscom hh14_k file file=ircam_info.lis wrap
   As the previous example except the text in each paragraph is
   wrapped to a width of 72 characters within the history
   records.
2 Notes
-  A history component is created if it does not exist within the
NDF.  The width of the history record is 72 characters.

-  An error will result if the current history update mode of the
NDF is "Disabled", and no commentary is written.  Otherwise the
commentary is written at the priority equal to the current
history update mode.

-  A warning messages (at the normal reporting level) is issued
if lines in the text file are too long for the history record and
WRAP=FALSE, though the first 72 characters are stored.

-  The maximum line length in the file is 200 characters.

-  Paragraphs should have fewer than 33 lines.  Longer ones will
be divided.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1995 June 28 (MJC):
    Original version.
1 HISLIST
Lists NDF history records.

Usage:

   hislist ndf

Description:

   This lists all the history records in an NDF.  The reported
   information comprises the date, time, and application name,
   and optionally the history text.
2 Parameters
For information on individual parameters, select from the list below:
3 BRIEF
BRIEF = _LOGICAL (Read)
   This controls whether a summary or the full history information
   is reported.  BRIEF=TRUE requests that only the date and
   application name in each history record is listed.  BRIEF=FALSE
   causes the task to report the history text in addition.
   [FALSE]
3 NDF
NDF = NDF (Read)
   The NDF whose history information is to be reported.
2 Examples
hislist vcc953
   This lists the full history information for the NDF called
   vcc935.  The information comprises the names of the
   applications and the times they were used, and the associated
   history text.

hislist vcc953 brief
   This gives a summary of the history information for the NDF
   called vcc935.  It comprises the names of the applications
   and the times they were used.
2 Related_Applications
   KAPPA: HISCOM, HISSET, NDFTRACE.
2 Authors
RFWS: R.F.Warren-Smith (STARLINK, RAL)

MJC: Malcolm J. Currie (STARLINK)
2 History
 1993 June 2 (RFWS):
    Original version.

 1995 June 24 (MJC):
    Added the documentation.
1 HISSET
Sets the NDF history update mode.

Usage:

   hisset ndf [mode] ok=?

Description:

   This task controls the level of history recording in an NDF,
   and can also erase the history information.

   The level is called the history update mode and it is a permanent
   attribute of the history component of the NDF, and remains with
   the NDF and any NDF created therefrom until the history is erased
   or the update mode is modified (say by this task).
2 Parameters
For information on individual parameters, select from the list below:
3 MODE
MODE = LITERAL (Read)
   The history update mode.  It can take one of the following
   values.

      "Disabled"  ---  No history recording is to take place.
      "Erase"     ---  Erases the history of the NDF.
      "Normal"    ---  Normal history recording is required.
      "Quiet"     ---  Only brief history information is to be
                       recorded.
      "Verbose"   ---  The fullest-possible history information
                       is to be recorded.

   The suggested default is "Normal".  ["Normal"]
3 NDF
NDF = (Read and Write)
   The NDF whose history update mode to be modified or history
   information erased.
3 OK
OK = _LOGICAL (Read)
   This is used to confirm whether or not the history should be
   erased.  OK=TRUE lets the history records be erased; if
   OK=FALSE the history is retained and a message will be issued
   to this effect.
2 Examples
hisset final
   This sets the history-recording level to be normal for the NDF
   called final.

hisset final erase ok
   This erases the history information from the NDF called final.

hisset mode=disabled ndf=spectrum
   This disables history recording in the NDF called spectrum.

hisset test42 v
   This sets the history-recording level to be verbose for the NDF
   called test42 so that the fullest-possible history is included.

hisset ndf=test42 mode=q
   This sets the history-recording level to be quiet for the NDF
   called test42, so that only brief information is recorded.
2 Notes
-  A history component is created if it does not exist within the
NDF, except for MODE="Erase".

-  The task records the new history update mode within the
history records, even if MODE="Disabled" provided the mode has
changed.  Thus the history information will show where there may
be gaps in the recording.
2 Related_Applications
   KAPPA: HISCOM, HISLIST, NDFTRACE.
2 Authors
RFWS: R.F.Warren-Smith (STARLINK, RAL)

MJC: Malcolm J. Currie (STARLINK)
2 History
 1993 June 3 (RFWS):
    Original version.

 1995 June 24 (MJC):
    Added the documentation.  Corrected some typo's and placed
    the local variables in alphabetical order.  Used PAR_CHOIC.
    Corrected bug in NDF_HINFO call.
1 HISTAT
Computes ordered statistics for an NDF's pixels using an
histogram.

Usage:

   histat ndf [comp] [percentiles] [logfile]

Description:

   This application computes and displays simple ordered statistics
   for the pixels in an NDF's data, quality, error, or variance
   array.  The statistics available are:

   -  the pixel sum,

   -  the pixel mean,

   -  the pixel median,

   -  the pixel mode,

   -  the pixel value at selected percentiles,

   -  the value and position of the minimum- and maximum-valued
   pixels,

   -  the total number of pixels in the NDF,

   -  the number of pixels used in the statistics, and

   -  the number of pixels omitted.
2 Parameters
For information on individual parameters, select from the list below:
3 COMP
COMP = LITERAL (Read)
   The name of the NDF array component for which statistics are
   required.  The options are limited to the arrays within the
   supplied NDF.  In general the value may "Data", "Error",
   "Quality" or "Variance" (note that "Error" is the alternative
   to "Variance" and causes the square root of the variance
   values to be taken before computing the statistics).  If
   "Quality" is specified, then the quality values are treated as
   numerical values (in the range 0 to 255).  ["Data"]
3 LOGFILE
LOGFILE = FILENAME (Write)
   A text file into which the results should be logged.  If a null
   value is supplied (the default), then no logging of results
   will take place. [!]
3 MAXCOORD
MAXCOORD( ) = _DOUBLE (Write)
   A 1-dimensional array of values giving the user co-ordinates of
   the centre of the (first) maximum-valued pixel found in the
   NDF array.  The number of co-ordinates is equal to the number
   of NDF dimensions.
3 MAXIMUM
MAXIMUM = _DOUBLE (Write)
   The maximum pixel value found in the NDF array.
3 MAXPOS
MAXPOS( ) = _INTEGER (Write)
   A 1-dimensional array of pixel indices identifying the (first)
   maximum-valued pixel found in the NDF array.  The number of
   indices is equal to the number of NDF dimensions.
3 MEAN
MEAN = _DOUBLE (Write)
   The mean value of all the valid pixels in the NDF array.
3 MEDIAN
MEDIAN = _DOUBLE (Write)
   The median value of all the valid pixels in the NDF array.
3 MINCOORD
MINCOORD( ) = _DOUBLE (Write)
   A 1-dimensional array of values giving the user co-ordinates of
   the centre of the (first) minimum-valued pixel found in the
   NDF array.  The number of co-ordinates is equal to the number
   of NDF dimensions.
3 MINIMUM
MINIMUM = _DOUBLE (Write)
   The minimum pixel value found in the NDF array.
3 MINPOS
MINPOS( ) = _INTEGER (Write)
   A 1-dimensional array of pixel indices identifying the (first)
   minimum-valued pixel found in the NDF array. The number of
   indices is equal to the number of NDF dimensions.
3 MODE
MODE = _DOUBLE (Write)
   The modal value of all the valid pixels in the NDF array.  It
   is estimated from 3 * median - 2 * mean.  This is only valid
   for moderately skew distributions.
3 NDF
NDF = NDF (Read)
   The NDF data structure to be analysed.
3 NUMBAD
NUMBAD = _INTEGER (Write)
   The number of pixels which were either not valid or were
   rejected from the statistics during iterative K-sigma
   clipping.
3 NUMGOOD
NUMGOOD = _INTEGER (Write)
   The number of NDF pixels which actually contributed to the
   computed statistics.
3 NUMPIX
NUMPIX = _INTEGER (Write)
   The total number of pixels in the NDF (both good and bad).
3 PERCENTILES
PERCENTILES( 100 ) = _REAL (Read)
   A list of percentiles to be found.  None are computed if this
   parameter is null (!).  The percentiles must be in the range
   0.0 to 100.0 [!]
3 PERVAL
PERVAL() = _DOUBLE (Write)
   The values of the percentiles of the good pixels in the NDF
   array.  This parameter is only written when one or more
   percentiles have been requested.
3 TOTAL
TOTAL = _DOUBLE (Write)
   The sum of the pixel values in the NDF array.
2 Examples
histat image
   Computes and displays simple ordered statistics for the data
   array in the NDF called image.

histat ndf=spectrum variance
   Computes and displays simple ordered statistics for the
   variance array in the NDF called spectrum.

histat spectrum error
   Computes and displays ordered statistics for the variance
   array in the NDF called spectrum, but takes the square root of
   the variance values before doing so.

histat halley logfile=stats.dat
   Computes ordered statistics for the data array in the NDF
   called halley, and writes the results to a logfile called
   stats.dat.

histat ngc1333 percentiles=[0.25,0.75]
   Computes ordered statistics for the data array in the NDF
   called ngc1333, including the quartile values.
2 Notes
-  Where the histogram contains a few extreme outliers, the
histogram limits are adjusted to reduce greatly the bias upon
the statistics, even if a chosen percentile corresponds to an
extreme outlier.  The outliers are still accounted in the median
and percentiles.  The histogram normally uses 10000 bins.  For
small arrays the number of bins is at most a half of the number
of array elements.  Integer arrays have a minimum bin width of
one; this can also reduce the number of bins.  The goal is to
avoid most histogram bins being empty artificially, since the
sparseness of the histogram is the main criterion for detecting
outliers.  Outliers can also be removed (flagged) via application
THRESH prior to using this application.

-  There is quantisation bias in the statistics, but for
non-pathological distributions this should be insignificant.
Accuracy to better than 0.01 of a percentile is normal.  Linear
interpolation within a bin is used, so the largest errors arise
near the median.
2 Related_Applications
   KAPPA: HISTOGRAM, MSTATS, NDFTRACE, NUMB, STATS;
   Figaro: ISTAT.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1991 November 13 (MJC):
    Original NDF version.

 1994 September 27 (MJC):
    Replaced AIF calls with PAR, FIO, and PSX.  Made messages
    conditional and used modern names for subroutines (_$ to 1_).

 2000 June 13 (MJC):
    Removed NUMBIN parameter.  No longer obtains dynamic space
    for the histogram.  Uses improved algorithm for calculating
    the median and percentiles.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, VARIANCE,
   QUALITY, TITLE, and HISTORY components of the NDF.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.  Arithmetic
   is performed using single- or double-precision floating point,
   as appropriate.

   -  Any number of NDF dimensions is supported.
1 HISTEQ
Performs an histogram equalisation on an NDF.

Usage:

   histeq in out [numbin]

Description:

   This application transforms an NDF via histogram equalisation.
   Histogram equalisation is an image-processing technique in which
   the distribution (between limits) of data values in the input
   array is adjusted so that in the output array there are
   approximately equal numbers of elements in each histogram bin.
   To achieve this the histogram bin size is no longer a constant.
   This technique is commonly known as histogram equalisation.  It
   is useful for displaying features across a wide dynamic range,
   sometimes called a maximum information picture.  The transformed
   array is output to a new NDF.
2 Parameters
For information on individual parameters, select from the list below:
3 IN
IN  = NDF (Read)
   The NDF structure to be transformed.
3 NUMBIN
NUMBIN = INTEGER (Read)
   The number of histogram bins to be used.  This should be a
   large number, say 2000, to reduce quantisation errors.  It
   must be in the range 100 to 10000. [2048]
3 OUT
OUT = NDF (Write)
   The NDF structure to contain the transformed data array.
3 TITLE
TITLE = LITERAL (Read)
   Title for the output NDF structure.  A null value (!)
   propagates the title from the input NDF to the output NDF. [!]
2 Examples
histeq halley maxinf
   The data array in the NDF called halley is remapped via
   histogram equalisation to form the new NDF called maxinf.

histeq halley maxinf 10000 title="Maximum information of Halley"
   The data array in the NDF called halley is remapped via
   histogram equalisation to form the new NDF called maxinf.
   Ten thousand bins in the histogram are required rather than
   the default of 2048.  The title of NDF maxinf is
   "Maximum information of Halley".
2 Notes
If there are a few outliers in the data and most of the points
concentrated about a value it may be wise to truncate the
data array via THRESH, or have a large number of histogram bins.
2 Related_Applications
   KAPPA: LAPLACE, LUTABLE, SHADOW, THRESH; Figaro: HOPT.
2 Authors
MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 1991 November 8 (MJC):
    Original NDF version.

 1995 January 12 (MJC):
    Replaced AIF calls with PAR and PSX.  Lowercase examples and
    usage.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   LABEL, TITLE, WCS and HISTORY components of an NDF data structure and
   propagates all extensions.  UNITS and VARIANCE become undefined
   by the transformation, and so are not propagated.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.

   -  Any number of NDF dimensions is supported.
1 HISTOGRAM
Computes an histogram of an NDF's values.

Usage:

   histogram in numbin range [comp] [logfile]

Description:

   This application derives histogram information for an NDF array
   between specified limits.  The histogram is reported, and may
   optionally be written to a text log file, and/or plotted
   graphically.
2 Parameters
For information on individual parameters, select from the list below:
3 AXES
AXES = _LOGICAL (Read)
   TRUE if labelled and annotated axes are to be drawn around the
   plot. The width of the margins left for the annotation may be
   controlled using parameter MARGIN. The appearance of the axes
   (colours, fonts, etc) can be controlled using the parameter
   STYLE.  [TRUE]
3 CLEAR
CLEAR = _LOGICAL (Read)
   If TRUE the current picture is cleared before the plot is
   drawn. If CLEAR is FALSE not only is the existing plot retained,
   but also an attempt is made to align the new picture with the
   existing picture. Thus you can generate a composite plot within
   a single set of axes, say using different colours or modes to
   distinguish data from different datasets.  [TRUE]
3 COMP
COMP = LITERAL (Read)
   The name of the NDF array component to have its histogram
   computed: "Data", "Error", "Quality" or "Variance" (where
   "Error" is the alternative to "Variance" and causes the square
   root of the variance values to be taken before computing the
   statistics).  If "Quality" is specified, then the quality
   values are treated as numerical values (in the range 0 to
   255).  ["Data"]
3 DEVICE
DEVICE = DEVICE (Read)
   The graphics workstation on which to produce the plot.  If it
   is null (!), no plot will be made.  [Current graphics device]
3 IN
IN = NDF (Read)
   The NDF data structure to be analysed.
3 LOGFILE
LOGFILE = FILENAME (Write)
   A text file into which the results should be logged.  If a null
   value is supplied (the default), then no logging of results
   will take place.  [!]
3 MARGIN
MARGIN( 4 ) = _REAL (Read)
   The widths of the margins to leave for axis annotation, given
   as fractions of the corresponding dimension of the current
   picture.  Four values may be given, in the order bottom, right,
   top, left.   If fewer than four values are given, extra values
   are used equal to the first supplied value.  If these margins
   are too narrow any axis annotation may be clipped.  If a null
   (!) value is supplied, the value used is 0.15 (for all edges)
   if either annotated axes or a key are produced, and zero
   otherwise.  [current value]
3 NUMBIN
NUMBIN = _INTEGER (Read)
   The number of histogram bins to be used.  This must lie in the
   range 2 to 10000.  The suggested default is the current value.
3 OUT
OUT = NDF (Read)
   Name of the NDF structure to save the histogram in its data
   array.  If null (!) is entered the histogram NDF is not
   created. [!]
3 RANGE
RANGE = LITERAL (Read)
   RANGE specifies the range of values for which the histogram is
   to be computed.  The supplied string should consist of up to
   three sub-strings, separated by commas.  For all but the option
   where you give explicit numerical limits, the first sub-string
   must specify the method to use.  If supplied, the other two
   sub-strings should be numerical values as described below
   (default values will be used if these sub-strings are not
   provided).  The following options are available.

   - lower,upper -- You can supply explicit lower and upper
   limiting values.  For example, "10,200" would set the histogram
   lower limit to 10 and its upper limit to 200.  No method name
   prefixes the two values.  If only one value is supplied,
   the "Range" method is adopted.  The limits must be within the
   dynamic range for the data type of the NDF array component.

   - "Percentiles" -- The default values for the histogram data
   range are set to the specified percentiles of the data.  For
   instance, if the value "Per,10,99" is supplied, then the lowest
   10% and highest 1% of the data values are excluded from the
   histogram.  If only one value, p1, is supplied, the second
   value, p2, defaults to (100 - p1).  If no values are supplied,
   the values default to "5,95".  Values must be in the range 0 to
   100.

   - "Range" -- The minimum and maximum array values are used.  No
   other sub-strings are needed by this option.  Null (!) is a
   synonym for the "Range" method.

   - "Sigmas" -- The histogram limiting values are set to the
   specified numbers of standard deviations below and above the
   mean of the data.  For instance, if the supplied value is
   "sig,1.5,3.0", then the histogram extends from the mean of the
   data minus 1.5 standard deviations to the mean plus 3 standard
   deviations.  If only one value is supplied, the second value
   defaults to the supplied value.  If no values are supplied,
   both default to "3.0".

   The "Percentiles" and "Sigmas" methods are useful to generate
   a first pass at the histogram.  They reduce the likelihood
   that all but a small number of values lie within a few
   histogram bins.

   The extreme values are reported unless parameter RANGE is
   specified on the command line.  In this case extreme values
   are only calculated where necessary for the chosen method.

   The method name can be abbreviated to a single character, and is
   case insensitive.  The initial value is "Range".  The suggested
   defaults are the current values, or ! if these do not exist.
   [current value]
3 STYLE
STYLE = GROUP (Read)
   A group of attribute settings describing the plotting style to
   use when drawing the annotated axes and data values.

   A comma-separated list of strings should be given in which each
   string is either an attribute setting, or the name of a text
   file preceded by an up-arrow character "^".  Such text files
   should contain further comma-separated lists which will be read
   and interpreted in the same manner.  Attribute settings are
   applied in the order in which they occur within the list, with
   later settings overriding any earlier settings given for the
   same attribute.

   Each individual attribute setting should be of the form:

      <name>=<value>

   where <name> is the name of a plotting attribute, and <value>
   is the value to assign to the attribute. Default values will be
   used for any unspecified attributes.  All attributes will be
   defaulted if a null value (!) is supplied.  See section
   "Plotting Attributes" in SUN/95 for a description of the
   available attributes.  Any unrecognised attributes are ignored
   (no error is reported).

   The appearance of the histogram curve is controlled by the
   attributes Colour(Curves), Width(Curves), etc. (The synonym
   Line may be used in place of Curves.)   [current value]
3 TITLE
TITLE = LITERAL (Read)
   Title for the histogram NDF.  ["KAPPA - Histogram"]
3 XLEFT
XLEFT = _REAL (Read)
   The axis value to place at the left hand end of the horizontal
   axis of the plot. If a null (!) value is supplied, the minimum
   data value in the histogram is used.  The value supplied may be
   greater than or less than the value supplied for XRIGHT.  [!]
3 XLOG
XLOG = _LOGICAL (Read)
   TRUE if the plot X axis is to be logarithmic.  Any histogram
   bins  which have negative or zero central data values are
   omitted from the plot.  [FALSE]
3 XRIGHT
XRIGHT = _REAL (Read)
   The axis value to place at the right hand end of the horizontal
   axis of the plot.  If a null (!) value is supplied, the maximum
   data value in the histogram is used.  The value supplied may be
   greater than or less than the value supplied for XLEFT.  [!]
3 YBOT
YBOT = _REAL (Read)
   The axis value to place at the bottom end of the vertical axis
   of the plot.  If a null (!) value is supplied, the lowest count
   the histogram is used.  The value supplied may be greater than
   or less than the value supplied for YTOP.  [!]
3 YLOG
YLOG = _LOGICAL (Read)
   TRUE if the plot Y axis is to be logarithmic.  Empty bins are
   removed from the plot if the Y axis is logarithmic.  [FALSE]
3 YTOP
YTOP = _REAL (Read)
   The axis value to place at the top end of the vertical axis of
   the plot.  If a null (!) value is supplied, the largest count
   in the histogram is used.  The value supplied may be greater
   than or less than the value supplied for YBOT.  [!]
2 Examples
histogram image 100 ! device=!
   Computes and reports the histogram for the data array in the
   NDF called image.  The histogram has 100 bins and spans the
   full range of data values.

histogram ndf=spectrum comp=variance range="100,200" numbin=20
   Computes and reports the histogram for the variance array in
   the NDF called spectrum.  The histogram has 20 bins and spans
   the values between 100 and 200.  A plot is made to the current
   graphics device.

histogram cube(3,4,) 10 si out=c3_4_hist device=!
   Computes and reports the histogram for the z-vector at (x,y)
   element (3,4) of the data array in the 3-dimensional NDF called
   cube.  The histogram has 10 bins and spans a range three
   standard deviations either side of the mean of the data values.
   The histogram is written to a one-dimensional NDF called
   c3_4_hist.

histogram cube numbin=32 ! device=xwindows style="'title=cube'"
   Computes and reports the histogram for the data array in
   the NDF called cube.  The histogram has 32 bins and spans the
   full range of data values.  A plot of the histogram is made to
   the XWINDOWS device, and is titled "cube".

histogram cube numbin=32 ! device=xwindows ylog style=^style.dat
   As in the previous example except the logarithm of the number
   in each histogram bin is plotted, and the contents of the text
   file style.dat control the style of the resulting graph.

histogram halley(~200,~300) "pe,10,90" logfile=hist.dat \
   Computes the histogram for the central 200 by 300 elements of
   the data array in the NDF called halley, and writes the
   results to a logfile called hist.dat.  The histogram uses the
   current number of bins, and includes data values between the 10
   and 90 percentiles.  A plot appears on the current graphics
   device.
2 Related_Applications
   KAPPA: HISTAT, MSTATS, NUMB, STATS; Figaro: HIST, ISTAT.
2 Authors
MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)

TDCA: Tim Ash (STARLINK)
2 History
 1992 March 9 (MJC):
    Original NDF version.

 1995 May 1 (MJC):
    Made examples and usage lowercase.  Moved position of COMP
    parameter.  Added Related Applications.  Shortened the section
    getting the range values.  Used PSX for workspace.  Fixed a
    bug in RANGE reporting.  Allowed for Error as a COMP option.
    Added PXSIZE and PYSIZE parameters.

 27-FEB-1998 (DSB):
    Corrected the reporting of the upper limit of _DOUBLE data by
    replacing call to CHR_PUTI by CHR_PUTD.

 12-JUL-1999 (TDCA):
    Converted graphics to AST/PGPLOT

 17-SEP-1999 (DSB):
    Tidied up. NDF calls changed to LPG to use auto-looping. Dynamic
    default parameters changed to use null default.

 26-OCT-1999 (DSB):
    Made MARGIN a fraction of the current picture, not the DATA
    picture.

 2000 February 16 (MJC):
    Made the RANGE parameter literal and allowed additional methods
    by which to specify the data-value limits of the histogram.
    Moved the reporting the data range and obtaining the RANGE
    parameter to a subroutine.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, VARIANCE,
   QUALITY, LABEL, TITLE, UNITS, and HISTORY components of the input
   NDF.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.

   -  Any number of NDF dimensions is supported.
1 IDCLEAR
Clears an image display and purges its database entries.

Usage:

   idclear [device] [current]

Description:

   This application software resets an image-display device. In effect
   the device is cleared.  It purges the graphics-database entries
   for the device.  Optionally, only the current picture is cleared
   and the database unchanged.  (Note that the clearing of the current
   picture may not work on some image-display devices.)
2 Parameters
For information on individual parameters, select from the list below:
3 CURRENT
CURRENT = _LOGICAL (Read)
   If true then only the current picture is cleared. [FALSE]
3 DEVICE
DEVICE = DEVICE (Read)
   The graphics device to be cleared. [Current image-display
   device]
2 Examples
idclear
   Clears the current image display and purges its graphics
   database entries.

idclear current
   Clears the current picture on the current image display.

idclear xwindows
   Clears the xwindows device and purges its graphics-database
   entries.
2 Related_Applications
   KAPPA: GDCLEAR, IDINVISIBLE, IDSTATE, OVCLEAR.
2 Authors
MJC: Malcolm J. Currie  (STARLINK)
2 History
 1991 Apr 30 (MJC):
    Original version.

 1992 March 3 (MJC):
    Replaced AIF parameter-system calls by the extended PAR
    library.
1 IDINVISIBLE
Makes memory planes of an image-display device invisible.

Usage:

   idinvisible [planes] [device]

Description:

   This routine makes invisible nominated planes of an IDI-supported
   image display, such as X-windows.
2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   The name of the image-display device whose memory plane is to
   be made invisible.  The name of the base plane should be given
   even if an overlay plane is to be made invisible.
   [Current image display]
3 PLANES
PLANES() = _INTEGER (Read)
   The numbers of the memory planes to be made invisible.  All
   unspecified planes become visible.  If it is null the base
   (image) memory is made invisible.  The base memory is 0 and
   overlays are numbered consecutively from 1.  For an Ikon the
   only overlay plane is 1.
   [0]
2 Examples
idinvisible [0,1]
   Makes only planes 0 and 1 invisible on the current image
   display device.

idinvisible device=xwindows
   Makes the base plane invisible on the xwindows device.

idinvisible 1 ikon
   Makes the first overlay plane invisible on the Ikon device.
2 Notes
-  On some devices making a memory invisible may have the effect
of making other memories visible.

-  On the Ikon the visibilities are set to visible on start up,
so that any set up change introduced by an application calling
GKS are not lost, therefore all planes to be made invisible must
be given in one invocation.
2 Related_Applications
   KAPPA: IDCLEAR, IDSTATE.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1990 July 23 (MJC):
    Original version.

 1992 February 21 (MJC):
    Made all the memories visible first to cope with the changed
    behaviour of the IDI implementation.

 1992 March 26 (MJC):
    Replaced AIF parameter-system calls by the extended PAR
    library.
1 IDPAZO
Pans and zooms an image-display device.

Description:

   This routine pans all planes of an IDI-supported image display,
   such as X-windows.  The zoom factor is controlled by the mouse
   or trackerball buttons.

   For an X-windows device, pressing the left button of the mouse
   increases the zooming, the centre button reduces the zoom factor,
   and the right-hand button ends the pan and zoom operation.
2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   The name of the image-display device to be panned and zoomed.
   The name of the base plane should be given.
   [Current image display]
2 Examples
idpazo xwindows
   Pans and zooms the xwindows device

idpazo
   Pans and zooms the current image-display device.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1990 Apr 11 (MJC):
    Original version.

 1991 October 28 (MJC):
    Made exit trigger number 2.  Inceased maximum number of
    triggers to 64.  Added a memory-visibility call.

 1992 February 19 (MJC):
    Removed the memory-visibility call.
1 IDSET
Selects a current image-display device.

Usage:

   idset device

Description:

   This application selects a current image-display device. This
   device will be used for all applications requiring an
   image-display until changed explicitly.
2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   The image-display device to become the current image-display
   device.  The device must be in one of the following GNS
   categories: IMAGE_DISPLAY, IMAGE_OVERLAY, MATRIX_PRINTER, or
   WINDOW, and have at least 24 colour indices or greyscale
   intensities.
2 Examples
idset xwindows
   Makes the xwindows device the current image-display device.
2 Related_Applications
   KAPPA: GDSET, IDSTATE, OVSET; Figaro: SOFT.
2 Authors
MJC: Malcolm J. Currie  (STARLINK)
2 History
 1991 June 27 (MJC):
    Original version.
1 IDSTATE
Shows the current status of a graphics device.

Usage:

   idstate [device] [frame]

Description:

   This application displays information about the current graphics
   database picture on a graphics device, including the extreme axis
   values in any requested co-ordinate Frame (see parameter FRAME).
   Information is written to various output parameters for use by
   other applications, and is also written to the screen by default
   (see parameter REPORT). An outline may be drawn around the current
   picture if required (see parameter OUTLINE).
2 Parameters
For information on individual parameters, select from the list below:
3 COMMENT
COMMENT = LITERAL (Write)
   The comment of the current picture.  Up to 132 characters
   will be written.
3 DESCRIBE
DESCRIBE = _LOGICAL (Read)
   If TRUE, a detailed description is displayed of the co-ordinate
   Frame in which the picture bounds are reported (see parameter
   FRAME). [current value]
3 DEVICE
DEVICE = DEVICE (Read)
   Name of the graphics device about which information is
   required. [Current graphics device]
3 DOMAIN
DOMAIN = LITERAL (Write)
   The Domain name of the current co-ordinate Frame for the current
   picture.
3 EPOCH
EPOCH = _DOUBLE (Read)
   If a "Sky Co-ordinate System" specification is supplied (using
   parameter FRAME) for a celestial co-ordinate system, then an
   epoch value is needed to qualify it. This is the epoch at
   which the displayed sky co-ordinates were determined. It should
   be given as a decimal years value, with or without decimal places
   ("1996.8" for example). Such values are interpreted as a Besselian
   epoch if less than 1984.0 and as a Julian epoch otherwise.
3 FRAME
FRAME = LITERAL (Read)
   A string determining the co-ordinate Frame in which the bounds
   of the current picture are to be reported. When a picture is
   created by an application such as PICDEF, DISPLAY, etc, WCS
   information describing the available co-ordinate systems are stored
   with the picture in the graphics database. This application can
   report bounds in any of the co-ordinate Frames stored with the
   current picture. The string supplied for FRAME can be one of the
   following:

   - A domain name such as SKY, AXIS, PIXEL, BASEPIC, CURPIC, etc. The
   special domain AGI_WORLD is used to refer to the world co-ordinate
   system stored in the AGI graphics database. This can be useful if
   no WCS information was store with the picture when it was created.

   - An integer value giving the index of the required Frame.

   - A "Sky Co-ordinate System" (SCS) value such as EQUAT(J2000) (see
   section "Sky Co-ordinate Systems" in SUN/95).

   If a null value (!) is supplied, bounds are reported in the
   co-ordinate Frame which was current when the picture was created.
   [!]
3 LABEL
LABEL = LITERAL (Write)
   The label of the current picture.  It is blank if there is no
   label.
3 NAME
NAME = LITERAL (Write)
   The name of the current picture.
3 OUTLINE
OUTLINE = _LOGICAL (Read)
   If OUTLINE is TRUE, then an outline will be drawn around the
   current picture to indicate its position. [FALSE]
3 REFNAM
REFNAM = LITERAL (Write)
   The reference object associated with the current picture.  It
   is blank if there is no reference object.  Up to 132 characters
   will be written.
3 REPORT
REPORT = _LOGICAL (Read)
   If this is FALSE the state of the graphics device is not
   reported, merely the results are written to the output
   parameters.  It is intended for use within procedures. [TRUE]
3 STYLE
STYLE = LITERAL (Read)
   A group of attribute settings describing the plotting style to use
   when drawing the outline (see parameter OUTLINE). The format
   of the axis values reported on the screen may also be controlled.

   A comma-separated list of strings should be given in which each
   string is either an attribute setting, or the name of a text file
   preceded by an up-arrow character "^". Such text files should
   contain further comma-separated lists which will be read and
   interpreted in the same manner. Attribute settings are applied in
   the order in which they occur within the list, with later settings
   over-riding any earlier settings given for the same attribute.

   Each individual attribute setting should be of the form:

      <name>=<value>

   where <name> is the name of a plotting attribute, and <value> is
   the value to assign to the attribute. Default values will be
   used for any unspecified attributes. All attributes will be
   defaulted if a null value (!) is supplied. See section "Plotting
   Attributes" in SUN/95 for a description of the available
   attributes. Any unrecognised attributes are ignored (no error is
   reported).

   The appearance of the outline is controlled by the attributes
   Colour(Border), Width(Border), etc (the synonym "Outline" may be
   used in place of "Border"). In addition, the following attributes
   may be set in order to control the appearance of the formatted axis
   values reported on the screen: Format, Digits, Symbol, Unit. These
   may be suffixed with an axis number (e.g. "Digits(2)") to refer to
   the values displayed for a specific axis. [current value]
3 X1
X1 = LITERAL (Write)
   The lowest value found within the current picture for axis 1 of the
   requested co-ordinate Frame (see parameter FRAME).
3 X2
X2 = LITERAL (Write)
   The highest value found within the current picture for axis 1 of the
   requested co-ordinate Frame (see parameter FRAME).
3 Y1
Y1 = LITERAL (Write)
   The lowest value found within the current picture for axis 2 of the
   requested co-ordinate Frame (see parameter FRAME).
3 Y2
Y2 = LITERAL (Write)
   The highest value found within the current picture for axis 2 of the
   requested co-ordinate Frame (see parameter FRAME).
2 Examples
idstate
   Shows the status of the current graphics device. The bounds of
   the picture are displayed in the current co-ordinate Frame of
   the picture.

idstate ps_l basepic
   Shows the status of the ps_l device. The bounds of the picture
   are displayed in the BASEPIC Frame (normalised device co-ordinates
   in which the short of the two dimensions of the display surface
   has length 1.0).

idstate outline frame=pixel style="'colour=red,width=3'"
   Shows the status of the current graphics device and draws a
   thick, red outline around the current database picture. The
   bounds of the picture are displayed in the PIXEL co-ordinate
   Frame (if available).

idstate refnam=(ndfname)
   Shows the status of the current graphics device.  If there
   is a reference data object, its name is written to the ICL
   variable NDFNAME.

idstate x1=(x1) x2=(x2) y1=(y1) y2=(y2) frame=basepic
   Shows the status of the current graphics device.  The bounds
   of the current picture in normalised device co-ordinates
   are written to the ICL variables: X1, X2, Y1, Y2.
2 Notes
-  The displayed bounds are the extreme axis values found anywhere
within the current picture. In some situations these extreme
values may not occur on the edges of the picture. For instance, if
the current picture represents a region including the north
celestial pole, then displaying the picture bounds in celestial
co-ordinates will give a declination upper limit of +90 degrees,
whilst the RA limits will be 0 hours and (close to) 24 hours.

-  Previous versions of this application reported bounds in
"Normalised Device Co-ordinates". Similar functionality is now
provided by setting parameter FRAME to "BASEPIC". Be aware though,
that "Normalised Device Co-ordinates" were normalised so that the
longer of the two axes had a length of 1.0, but BASEPIC co-ordinates
are normalised so that the shorter of the two axes has length 1.0.
2 Related_Applications
   KAPPA: IDSTATE.
2 Authors
RFWS: R.F. Warren-Smith (STARLINK)

MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 1-DEC-1989 (RFWS):
    Original version.

 13-DEC-1989 (RFWS):
    Added call to MSG_SYNC to synchonise message system and
    graphical output.

 1990 Jan 16 (MJC):
    Added output of the current picture's label, if it exists.

 1991 February 8 (MJC):
    Added output of the current picture's reference object, if it
    exists.

 1991 March 24 (MJC):
    Converted to SST prologue.

 1991 August 20 (MJC):
    Added output parameters and REPORT parameter.

 7-JAN-2000 (DSB):
    Big changes for the first AST/PGPLOT version.
1 Image-display_Interface

KAPPA utilises IDI (Image-display Interface) for some interactions
with images.  However, GKS is still called to display images, plot
line graphics, and perform cursor interactions.  IDI is much faster
for some interactions, such as manipulating the colour table, and
provides functionality that is excluded from GKS, such as pan and
zoom.  The two graphics packages share windows through the
Graphics Window Manager (GWM, SUN/130) so that you need not know
which KAPPA command calls which package.

Not all IDI functionality is available in the Starlink X-windows
implementation.  For instance, there is no blinking capability on
X-windows.  IDUNZOOM is ineffective, since once a window is panned
and/or zoomed, the original data are lost due to a not unreasonable
limitation of GWM.  The same applies if you run IDINVISIBLE;
IDVISIBLE is unable to restore the window.  This is actually not
serious since images cannot be displayed on the X-windows overlay.
You will probably want IDINVISIBLE to erase only the overlay plane
of an X-window.

IDI and GKS were selected for device independence, but since this
is less important today as X-windows and PostScript have become de
facto standards.  By relaxing the GKS straightjacket, GUI-based
image-processing and display tools dedicated to X-windows, will
offer much-improved interaction and performance.

1 Interaction_Mode
This topic addresses how the applications obtain co-ordinate
information.  See topic "Co-ordinate_Systems" for details of the
different co-ordinate systems KAPPA uses.
Applications that require co-ordinates are being modified to permit
a variety of mechanisms for obtaining those co-ordinates.  Those
converted so far are ARDMASK, CENTROID, and ZAPLIN.  The
possibilities are as follows. 

   o  Cursor    --- This mode utilises the cursor of the current
                    graphics device. For this to work the array must
                    already be displayed as an image, or a contour
                    plot, or line plot (provided the application
                    handles 1-dimensional data), and the picture is
                    stored in the graphics database.
   o  Interface --- This mode obtains co-ordinates from the
                    parameter system, usually in response to
                    prompting.
   o  File      --- In this mode the application reads a text file
                    containing a list of co-ordinates in free
                    format, one object per record.  There may be
                    commentary lines in the file beginning with
                    # or !.  The format and syntax of the files are
                    ad hoc, and are described in the application
                    documentation.

Applications that permit these options have a parameter, called
MODE, by which you can control how positional data are to be
acquired.  It would be tedious to have to specify a mode for each
application, therefore KAPPA has a global parameter---the
interaction mode---to which each application's interaction-mode
parameter is defaulted.  The global value remains in force until you
change it by assigning an application's interaction mode on the
command line.  The following examples shows the effect of the global
parameter.  For compactness GLOBALS will merely show the interaction
mode.

First we display an image on the xw windows device.
 
     ICL> gdset xw
     ICL> idset xw
     ICL> display $KAPPA_DIR/ccdframec mode=pe \ 
     Data will be scaled from 2366.001 to 2614.864. 
     ICL> globals 
     The current interaction mode is      : <undefined>
 
Now we obtain the centroids of a couple of stellar/galaxian images
via each of the interaction modes.  First in cursor mode.  Note that
CENTROID obtains the name of the input NDF from the graphics
database in this mode.  If you need to preview which NDF is going to
be selected use the PICIN command.
 
     ICL> centroid mode=c
     Current picture has name: DATA, comment: KAPPA_DISPLAY. 
     Using /star/bin/kappa/ccdframec as the input NDF
      
     To select a point press the left button on the mouse or trackerball. 
     To exit press the right button. 
     Use the cursor to select one point. 
  
     Input guess position was     86.23534, 295.0848
     Output centroid position is  86.41057, 295.1141
  
     Use the cursor to select one point. 
  
     Input guess position was     73.32529, 318.9757
     Output centroid position is  72.76437, 318.9484
  
     Use the cursor to select one point. 
 
If we look at the global parameters again, indeed we see that it has
become cursor mode.  To show that it is global we can run INSPECT.
Yes a cursor appears rather than a prompt for the pixel value.
 
     ICL> globals 
     The current interaction mode is      : CURSOR
     ICL> inspect 

     For certain options, boxes will appear.  The functions are controlled
     by the mouse/trackerball buttons and keyboard...
        Press left button to select the operation shown in the left box.
        Press middle button/keyboard "2" to select the operation shown in the middle box
        Press right button to select the operation shown in the right box.

     Current picture has name: DATA, comment: KAPPA_DISPLAY. 
     Using /star/bin/kappa/ccdframec as the input NDF
     GDEVICE - Graphics device to be used for line plots /@xov/ > 
     OPTION - Option required /'Region'/ > VA 
  
        VALUE of image at 59, 294 is 2753.928 
        
        VALUE of image at 149, 311 is 3727.465 
  
     OPTION - Option required /'Region'/ > ex 
 
Now we'll see the effect of changing the mode parameter.  Note that
unless it is undefined or the application does not support the
current mode, you must change the mode on the command line.  First
we shall prompt for the co-ordinates.  A null ends the loop.
 
     ICL> centroid mode=i 
     NDF - Array to be analysed /@/star/bin/kappa/ccdframec/ >
     INIT - Guess at co-ordinates of star-like feature /108.8,403.5/ > 86,295 

     Input guess position was     86, 295 
     Output centroid position is  86.41057, 295.1141
      
     INIT - Guess at co-ordinates of star-like feature /86,295/ > 73.3,319 
  
     Input guess position was     73.3, 319 
     Output centroid position is  72.76437, 318.9484
  
     INIT - Guess at co-ordinates of star-like feature /73.3,319/ > !
 
Finally, we can create a text file called starlist.dat and run
CENTROID in file mode.   
 
     ICL> cat > starlist.dat 
     Creating DCL subprocess 
     86 295
     73 320
     CTRL/D
     ICL> centroid mode=f 
     COIN - File of initial positions /@centroid.lis/ > starlist.dat
     NDF - Array to be analysed /@$KAPPA_DIR/ccdframec/ >

     Input guess position was     86, 295 
     Output centroid position is  86.41057, 295.1141
  
     Input guess position was     73, 320 
     Output centroid position is  72.76437, 318.9484
 
Such co-ordinate files can also be created interactively with images by
CURSOR or PICCUR.

1 IRAF_usage
KAPPA may be run from the IRAF CL with automatic data conversion to and
from IRAF or FITS image format. For general advice on running Starlink
applications from IRAF, see SUN/217.

Assuming that the required software has been installed as recommended,
KAPPA is loaded by typing kappa at the cl> prompt.  Applications are
invoked and parameter values generally given as for normal IRAF tasks.
There are a few anomalies and these are described in SUN/217.

1 DIV
Divides one NDF data structure by another.

Usage:

   div in1 in2 out

Description:

   The routine divides one NDF data structure by another
   pixel-by-pixel to produce a new NDF.
2 Parameters
For information on individual parameters, select from the list below:
3 IN1
IN1 = NDF (Read)
   First NDF, to be divided by the second NDF.
3 IN2
IN2 = NDF (Read)
   Second NDF, to be divided into the first NDF.
3 OUT
OUT = NDF (Write)
   Output NDF to contain the ratio of the two input NDFs.
3 TITLE
TITLE = LITERAL (Read)
   Value for the title of the output NDF.  A null value will cause
   the title of the NDF supplied for parameter IN1 to be used
   instead. [!]
2 Examples
div a b c
   This divides the NDF called a by the NDF called b, to make the
   NDF called c.  NDF c inherits its title from a.

div out=c in1=a in2=b title="Normalised data"
   This divides the NDF called a by the NDF called b, to make the
   NDF called c.  NDF c has the title "Normalised data".
2 Notes
If the two input NDFs have different pixel-index bounds, then
they will be trimmed to match before being divided.  An error will
result if they have no pixels in common.
2 Related_Applications
   KAPPA: ADD, CADD, CDIV, CMULT, CSUB, MATHS, MULT, SUB.
2 Authors
RFWS: R.F. Warren-Smith (STARLINK)

MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 9-APR-1990 (RFWS):
    Original version.

 1992 January 15 (MJC):
    Added Usage and Examples items.

 1995 September 12 (MJC):
    Title inherited by default.  Usage and examples to lowercase.
    Added Related Applications.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   LABEL, TITLE, HISTORY, WCS and VARIANCE components of an NDF data
   structure and propagates all extensions.

   -  Units processing is not supported at present and therefore the
   UNITS component is not propagated.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.
   Calculations will be performed using either real or double
   precision arithmetic, whichever is more appropriate.  If the
   input NDF structures contain values with other data types, then
   conversion will be performed as necessary.
1 KAPHELP
Gives help about KAPPA.

Usage:

   kaphelp [topic] [subtopic] [subsubtopic] [subsubsubtopic]

Description:

   Displays help about KAPPA.  The help information has classified
   and alphabetical lists of commands, general information about
   KAPPA and related material; it describes individual commands in
   detail.

   Here are some of the main options.
      kaphelp
         No parameter is given so the introduction and the top-level
         help index is displayed.
      kaphelp application/topic
         This gives help about the specified application or topic.
      kaphelp application/topic subtopic
         This lists help about a subtopic of the specified
         application or topic. The hierarchy of topics has a maximum
         of four levels.
      kaphelp Hints
         This gives hints for new and intermediate users.
      kaphelp summary
         This shows a one-line summary of each application.
      kaphelp classified classification
         This lists a one-line summary of each application in the
         given functionality classification.

   See the Section "Navigating the Help Library" for details how to
   move around the help information, and to select the topics you
   want to view.
2 Parameters
For information on individual parameters, select from the list below:
3 TOPIC
TOPIC = LITERAL (Read)
   Topic for which help is to be given. [" "]
3 SUBTOPIC
SUBTOPIC = LITERAL (Read)
   Subtopic for which help is to be given. [" "]
3 SUBSUBTOPIC
SUBSUBTOPIC = LITERAL (Read)
   Subsubtopic for which help is to be given. [" "]
3 SUBSUBSUBTOPIC
SUBSUBSUBTOPIC = LITERAL (Read)
   Subsubsubtopic for which help is to be given. [" "]
2 Navigating_the_Help_Library
   The help information is arranged hierarchically.  You can move
   around the help information whenever KAPHELP prompts.  This
   occurs when it has either presented a screen's worth of text or
   has completed displaying the previously requested help.  The
   information displayed by KAPHELP on a particular topic includes a
   description of the topic and a list of subtopics that further
   describe the topic.

   At a prompt you may enter:
      o  a topic and/or subtopic name(s) to display the help for that
         topic or subtopic, so for example, "block parameters box"
         gives help on BOX, which is a subtopic of Parameters, which
         in turn is a subtopic of BLOCK;

      o  a <CR> to see more text at a "Press RETURN to continue ..."
         request;

      o  a <CR> at topic and subtopic prompts to move up one level
         in the hierarchy, and if you are at the top level it will
         terminate the help session;

      o  a CTRL/D (pressing the CTRL and D keys simultaneously) in
         response to any prompt will terminate the help session;

      o  a question mark "?" to redisplay the text for the current
         topic, including the list of topic or subtopic names; or

      o  an ellipsis "..." to display all the text below the
         current point in the hierarchy.  For example, "BLOCK..."
         displays information on the BLOCK topic as well as
         information on all the subtopics under BLOCK.

   You can abbreviate any topic or subtopic using the following
   rules.

      o  Just give the first few characters, e.g. "PARA" for
         Parameters.

      o  Some topics are composed of several words separated by
         underscores.  Each word of the keyword may be abbreviated,
         e.g. "Colour_Set" can be shortened to "C_S".

      o  The characters "%" and "*" act as wildcards, where the
         percent sign matches any single character, and asterisk
         matches any sequence of characters.  Thus to display
         information on all available topics, type an asterisk in
         reply to a prompt.

      o  If a word contains, but does end with an asterisk wildcard,
         it must not be truncated.

      o  The entered string must not contain leading or embedded
         spaces.

   Ambiguous abbreviations result in all matches being displayed.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1986 November 14 (MJC):
    Original.

 1988 October 11 (MJC):
    Fixed bug to enable subtopics to be accessed from the command
    line.

 1991 September 25 (MJC):
    Corrected the description for the new layout in the new help
    library, KAPPA.

 1992 June 17 (MJC):
    UNIX version using portable HELP.

 1992 August 19 (MJC):
    Rewrote the description, added usage and implementation status.

 1995 November 9 (MJC):
    Modified for UNIX and added the Topic on Navigation.
2 Implementation_Status
   -  Uses the portable help system.
1 KAPPA

KAPPA---the Kernel APplication PAckage---comprises general-purpose
applications, particularly for image processing, data visualisation,
and manipulating components in the Starlink standard data format:
the NDF.  KAPPA provides facilities that integrate with specialised
packages such as CCDPACK, ESP, Figaro, IRAS90, JCMTDR, PHOTOM, PISA,
and TSP.  Topic "Role of KAPPA" explains this more fully.

KAPPA commands are available from both the UNIX C-shell (and
variants) and from the ICL command language.  The "Functionality"
topics summarise the specific data-processing facilities, and
general processing style of KAPPA.  

Type ? to see the main help topics.

2 Functionality_Commands
Currently, KAPPA has about 180 commands in total, and provides
the following facilities for data processing:

  o FITS readers that generate NDFs and text tables, and the import
    and export of ancillary data through the NDF FITS extension;
  o generation of test data, and NDF creation from text files;
  o setting and examining NDF components;
  o definition or calculation of a sky co-ordinate system for use in
    conjunction with IRAS90 tools;
  o arithmetic including a powerful application that handles
    expressions;
  o pixel and region editing, including polygons and circles; 
    re-flagging of bad pixels by value or by median filtering; and 
    pasting arrays over others;
  o masking of regions, and of pixels whose variances are too large;
  o configuration change: flip, rotate, shift, subset, change
    dimensionality;
  o forming image mosaics; normalisation of NDF pairs;
  o compression and expansion of images;
  o generalised resampling of NDFs using arbitrary transformations;
  o filtering: box, Gaussian, and median smoothing; very efficient
    Fourier transform, convolution;
  o deconvolution: maximum-entropy, Lucy-Richardson, Wiener filter;
  o two-dimensional-surface fitting;
  o statistics including ordered statistics, histogram; pixel-by-pixel
    statistics over a sequence of images;
  o inspection of image values;
  o centroids of features, particularly stars; stellar PSF fitting;
  o detail enhancement using histogram equalisation and Laplacian
    convolution, edge enhancement via a shadow effect, thresholding;
  o calculation of polarimetry images;

There are also many applications for data visualisation:

  o use of the graphics database, AGI, to pass information about
    pictures between tasks; tools for the creation, labelling,
    selection of pictures, and obtaining world and data co-ordinate
    information from them;
  o image and greyscale plots with a selection of scaling modes and
    many options such as axes;
  o creation, selection, saving and manipulation of colour tables and
    palettes (for axes, annotation, coloured markers and borders);
  o blinking and visibility of image-display planes; and
  o line graphics: contouring, including overlay; columnar and
    hidden-line plots of images; histogram; line plots of
    1-dimensional arrays, and multiple-line plot of images; pie
    sections and slices through an image; vector plot of image; all
    of which offer some control of the appearance of plots.

2 Functionality_General
KAPPA handles bad pixels, and processes quality, variance, and other
information stored within NDFs (cf. topic "Data_Structures" and
SUN/33).  Although oriented to image processing, many commands will
work on NDFs of arbitrary dimension and others operate on both
spectra and images.  In order to achieve generality KAPPA does not
process non-standard extensions; however, it does not lose
non-standard ancillary data since it copies extensions to any NDFs
that it creates.

KAPPA can also process data in other formats, such as FITS and IRAF,
using an automatic-data conversion facility (SUN/55, SSN/20).  For
historical reasons, 21 commands in KAPPA still use the old IMAGE
format (see topic "Data_Structures IMAGE_format"), which does not
include all the features of the NDF.  A low-priority conversion
process is underway to transform the remaining to use the NDF-access
interface (SUN/33).  Once completed KAPPA can finally reach version
1.0.  See the specifications of individual KAPPA applications for
details of which applications use the NDF.

Although oriented to image processing, many commands will work on NDFs
of arbitrary dimension and others operate on both spectra and images.
Many applications handle all non-complex data types directly, for
efficient memory and disc usage.  Those that do not will usually
undergo automatic data conversion to produce the desired result.

KAPPA's graphics are device independent.  X-windows and overlays are
supported.

2 Requests
KAPPA is continuing to be developed and additional applications
functionality are envisaged, particularly a graphical-user interface
for image processing.  [If you wish to suggest new tasks or
enhancements to existing ones please contact the author.  Small jobs
may be undertaken quite quickly.  Requests involving substantial
pieces of work need to gain the support of others to be included in
Starlink's software plans, and so the best way to influence the
priority given to KAPPA is to contact the chairman of the Image
Processing Software Strategy Group.  The Starlink World Wide Web
pages will periodically contain news of plans and work in progress.]
KAPPA also receives a high level of support, and bug reports are
dealt with promptly.
1 KSTEST
Compares data sets using the Kolmogorov-Smirnov test.

Usage:

   kstest in out [limit]

Description:

   This routine reads in a data array and performs a two sided
   Kolmogorov-Smirnov test on the vectorised data.  It does this in
   two ways:

     1) If only one dataset is to be tested the data array is
        divided into subsamples.  First it compares subsample 1 with
        subsample 2, if they are thought to be from the same sample
        they are concatenated.  This enlarged sample is then
        compared with subsample 3 etc., concatenating if consistent,
        until no more subsamples remain.

     2) If more than one dataset is specified, the datasets are
        compared to the reference dataset in turn.  If the
        probability the two are from the same sample is greater than
        the specified confidence level, the datasets are
        concatenated, and the next sample is tested against this
        enlarged reference dataset.

   The probability and maximum separation of the cumulative
   distribution function is displayed for each comparison (at the
   normal reporting level).  The mean value of the consistent data
   and its error are also reported.  In all cases the consistent
   data can be output to a new dataset.  The statistics and
   probabilities are written to results parameters.
2 Parameters
For information on individual parameters, select from the list below:
3 COMP
COMP = LITERAL (Read)
   The name of the NDF array component to be tested for
   consistency: "Data", "Error", "Quality" or "Variance" (where
   "Error" is the alternative to "Variance" and causes the square
   root of the variance values to be taken before performing the
   comparisons).  If "Quality" is specified, then the quality
   values are treated as numerical values (in the range 0 to
   255).  ["Data"]
3 DIST
DIST() = _REAL (Write)
   Maximum separation found in the cumulative distributions for
   each comparison subsample.  Note that it excludes the
   reference dataset.
3 ERRMEAN
ERRMEAN = _DOUBLE (Write)
   Error in the mean value of the consistent data.
3 FILES
FILES() = LITERAL (Write)
   The names of the datasets intercompared.  The first is the
   reference dataset.
3 LIMIT
LIMIT = _REAL (Read)
   Confidence level at which samples are thought to be
   consistent.  This must lie in the range 0 to 1. [0.05]
3 IN
IN = LITERAL (Read)
   The names of the NDFs to be tested.  If just one dataset is
   supplied, it is divided into subsamples, which are compared
   (see parameter NSAMPLE).  When more than one dataset is
   provided, the first becomes the reference dataset to which all
   the remainder are compared.

   It may be a list of NDF names or direction specifications
   separated by commas.  If a list is supplied on the command
   line, the list must be enclosed in double quotes.  NDF names
   may include the regular expressions ("*", "?", "[a-z]" etc.).
   Indirection may occur through text files (nested up to seven
   deep).  The indirection character is "^".  If extra prompt
   lines are required, append the continuation character "-" to
   the end of the line.  Comments in the indirection file begin
   with the character "#".
3 MEAN
MEAN = _DOUBLE (Write)
   Mean value of the consistent data.
3 NKEPT
NKEPT = _INTEGER (Write)
   Number of consistent data.
3 NSAMPLE
NSAMPLE = _INTEGER (Read)
   The number of the subsamples into which to divide the reference
   dataset.  This parameter is only requested when a single NDF
   is to be analysed, i.e. when only one dataset name is supplied
   via parameter IN.  The allowed range is 2 to 20.  [3]
3 OUT
OUT = NDF (Write)
   Output 1-dimensional NDF to which the consistent data is
   written.  A null value (!)---the suggested default---prevents
   creation of this output dataset.
3 PROB
PROB() = _REAL (Write)
   Probability that each comparison subsample is drawn from the
   same sample.  Note that this excludes the reference sample.
3 SIGMA
SIGMA = _DOUBLE (Write)
   Standard deviation of the consistent data.
2 Examples
kstest arlac accept
   This tests the NDF called arlac for self-consistency at the 95%
   confidence level using three subsamples.  No output dataset is
   created.

   The following applies to all the examples.  If the reference
   dataset and a comparison subsample are consistent, the two
   merge to form an expanded reference dataset, which is then
   used for the next comparison.  Details of the comparisons are
   presented.

kstest arlac arlac_filt 0.10 nsample=10
   As above except data are retained if they exceed the 90%
   probability level, the comparisons are made with ten
   subsamples, and the consistent data are written to the
   one-dimensional NDF called arlac_filt.

kstest in="ref,obs*" comp=v out=master
   This compares the variance in the NDF called ref with that in
   a series of other NDFs whose names begin "obs".  The variance
   consistent with the reference dataset are written to the data
   array in the NDF called master.  To be consistent, they must be
   the same at 95% probability.

kstest "ref,^96lc.lis,obs*" master comp=v
   As the previous example, except the comparison files include
   those listed in the text file 96lc.lis.
2 Notes
- The COMP array MUST exist in each NDF to be compared.  The
COMP array becomes the data array in the output dataset.  When
COMP="Data", the variance values corresponding to consistent data
are propagated to the output dataset.

- Pixel bounds are ignored for the comparisons.

- The internal comparison of a single dataset follows the method
outlined in Hughes D., 1993, JCMT-UKIRT Newsletter, #4, p32.

- The maximum number of files is 20.
2 Authors
TIMJ: T. Jenness (JACH)

MJC: Malcolm J. Currie (STARLINK)
2 History
 1996 September (TIMJ):
    Original version.

 1996 September 19 (MJC):
    Completed the prologue and modified for consistency within
    KAPPA.

 1997 May 12 (MJC):
    Redesigned to use GRP and NDF chunks, thus removing the REF
    parameter and renaming NDF to IN.  Better propagation of NDF
    components.  Improved the table formatting.  Made efficiency
    improvements.  Replaced SUBSAMPLE parameter with NSAMPLE.
2 Implementation_Status
   - This routine correctly processes DATA, VARIANCE, HISTORY, LABEL,
   TITLE, and UNITS components, and propagates all extensions.  AXIS
   information is lost.  Propagation is from the reference dataset.

   - Processing of bad pixels and automatic quality masking are
   supported.

   - All numeric data types are supported, however, processing uses
   the _REAL data type, and the output dataset has this type.

1 LAPLACE
    Performs a Laplacian convolution as an edge detector in a 2-d
    data array
 
   This routine works out the Laplacian of the 2-d data array, in the
   input IMAGE structure, and subtracts it from the original array to
   create a new data array in the output IMAGE structure. The
   subtractions can be done a specified integer number of times.
   This operation can be approximated with a convolution by
 
                         -N   -N   -N
                         -N   +8N  -N
                         -N   -N   -N
 
   where N is the integer number of times the Laplacian is
   subtracted.  This convolution is used as a uni-directional edge
   detector.  Areas where the input data array is flat become zero
   in the output data array.
 
   The magic-value method is used for processing bad data.
2 AUTHORS
   Mark McCaughrean UoE ( REVA::MJM )
   Malcolm Currie  STARLINK (RAL::CUR)
2 BUGS
   None known.
2 HISTORY
   10-12-1985 : First implementation (UKTH::MARK)
   17-04-1986 : Tidied and more error checking (REVA::MJM)
   1986 Aug 7 : Renamed algorithmic subroutine to LAPLSB.
   1986 Aug 29: Added argument section to prologue, and nearly
                conformed to Starlink standards (RAL::CUR).
   1987 Oct 15: Reordered tidying and extra status checks
                (RAL::CUR)
   1988 Mar 17: Referred to `array' rather than `image'
                (RAL::CUR)
   1988 May 31: More reporting of error context (RAL::CUR)
   1989 Jun 13: Allow for processing primitive NDFs (RAL::CUR)
   1989 Aug  8: Passed array dimensions as separate variables
                to LAPLSB (RAL::CUR).
   1991 Oct 25: Propagates AXIS, LABEL, and HISTORY (RAL::CUR).
   1992 Feb 25: Limited processing of simple NDFs (RAL::CUR).
   1992 Mar  3: Replaced AIF parameter-system calls by the extended
                PAR library (RAL::CUR).
   1992 Mar  3: Replaced AIF parameter-system calls by the extended
                PAR library (RAL::CUR).
2 PARAMETERS
   INPIC = IMAGE( READ )
       Input IMAGE structure containing the 2-d data array to be
         processed
   NUMBER = INTEGER( READ )
       Number of times the Laplacian is to be subtracted
   OUTPIC = IMAGE( WRITE )
       Output IMAGE structure containing the processed data array
   OTITLE = CHAR( READ )
       Title string for output IMAGE structure
3 INPIC
  position    1
  keyword     'INPIC'
  type        'IMAGE'
  access      'READ'
  vpath       'PROMPT'
  ppath       'GLOBAL'
  association '<-GLOBAL.DATA_ARRAY'
  prompt      'Image to be convolved'
  help        'Name of the IMAGE structure containing the 2-d data 
              array on which the Laplacian convolution is performed'
3 NUMBER
  position    2
  keyword     'NUMBER'
  type        '_INTEGER'
  vpath       'DEFAULT'
  default     1
  prompt      'Number of Laplacians removed'
  help        'Give the integer number of Laplacians to be removed 
              from the input data array'
3 OUTPIC
  position    3
  keyword     'OUTPIC'
  type        'IMAGE'
  access      'WRITE'
  vpath       'PROMPT'
  association '->GLOBAL.DATA_ARRAY'
  prompt      'Image after convolution'
  help        'Name given to the IMAGE structure to hold the 
              convolved data array'
3 OTITLE
  position    4
  keyword     'OTITLE'
  type        '_CHAR'
  vpath       'DEFAULT'
  prompt      'Title for output image'
  default     'KAPPA - Laplace'
  help        'Character string to be used as a title for the output 
              IMAGE data structure'

1 LINPLOT
Draws a line plot of the data values in a 1-dimensional NDF.

Usage:

   linplot ndf [comp] [mode] [xleft] [xright] [ybot] [ytop] [device]

Description:

   This application creates a plot of array value against position for
   a 1-dimensional NDF. The vertical axis of the plot represents array
   value (or the logarithm of the array value - see parameter YLOG),
   and the horizontal axis represents position.

   The plot may take several different forms such as a "join-the-dots"
   plot, a "staircase" plot, a "chain" plot, etc, (see parameter MODE).
   Errors on both the data values and the data positions may be represented
   in several different ways (see parameters ERRBAR and SHAPE). The
   plotting style (colour, fonts, text size, etc) may be specified in
   detail using parameter STYLE.

   The bounds of the plot on both axes can be specified using
   parameters XLEFT, XRIGHT, YBOT and YTOP. If not specified they take
   default values which encompass the entire supplied data set. The
   current picture is usually cleared before plotting the new picture,
   but parameter CLEAR can be used to prevent this, allowing several
   plots to be "stacked" together. If a new plot is drawn over an
   existing plot, then there is an option to allow the bounds of the
   new plot to be set to the bounds of the existing plot (see parameter
   ALIGN).

   The input NDF may, for instance, contain a spectrum of data values
   against wavelength, or it may contain data values along a
   1-dimensional profile through an NDF of higher dimensionality. In
   the latter case, the current co-ordinate Frame of the NDF may have
   more than 1 axis. Any of the axes in the current co-ordinate Frame
   of the input NDF may be used to annotate the horizontal axis of the
   plot produced by this application. Alternatively, the horizontal
   axis may be annotated with offset from the first array element
   measured within the current co-ordinate Frame of the NDF. For
   instance, a 1-d slice through a 2-d image calibrated in RA/DEC could
   be annotated with RA, or DEC, or offset from the first element (in
   arc-minutes, degrees, etc). This offset is measured along the path
   of the profile. The choice of annotation for the horizontal axis is
   controlled by parameter USEAXIS.
2 Parameters
For information on individual parameters, select from the list below:
3 ALIGN
ALIGN = _LOGICAL (Read)
   Controls the way in which the bounds of a new plot are
   determined if it is drawn over an existing plot. If ALIGN
   is FALSE, then the bounds of the new plot are specified
   using parameters XLEFT, XRIGHT, YBOT and YTOP as usual. If ALIGN
   is TRUE, then the bounds of the new plot are set equal to
   the bounds of the existing plot (on both axes), and parameters
   XLEFT, XRIGHT, YBOT and YTOP are ignored. This parameter is only
   accessed if parameter CLEAR is FALSE, and if there is another line
   plot within the current picture. The dynamic default is to align
   the plots if the labels on the horizontal axes are the same, and
   not to align the plots if the labels are different. []
3 AXES
AXES = _LOGICAL (Read)
   TRUE if labelled and annotated axes are to be drawn around the
   plot. The dynamic default is FALSE if the plot is being
   aligned with an existing plot (see parameter ALIGN), and
   TRUE otherwise. Parameters USEAXIS and YLOG determine the
   quantities used to annotated the horizontal and vertical axes
   respectively. The width of the margins left for the annotation
   may be controlled using parameter MARGIN. The appearance of the
   axes (colours, fonts, etc) can be controlled using the parameter
   STYLE. []
3 CLEAR
CLEAR = _LOGICAL (Read)
   If TRUE the current picture is cleared before the plot is
   drawn. If CLEAR is FALSE not only is the existing plot retained,
   but also the previous plot can be used to specify the axis
   limits (see parameter ALIGN). Thus you can generate a composite
   plot within a single set of axes, say using different colours or
   modes to distinguish data from different datasets.
3 COMP
COMP = LITERAL (Read)
   The NDF component to be plotted.  It may be "Data", "Quality",
   "Variance", or "Error" (where "Error" is an alternative to
   "Variance" and causes the square root of the variance values
   to be displayed).  If "Quality" is specified, then the quality
   values are treated as numerical values (in the range 0 to
   255). ["Data"]
3 DEVICE
DEVICE = DEVICE (Read)
   The plotting device. [current graphics device]
3 ERRBAR
ERRBAR = _LOGICAL (Read)
   TRUE if error bars are to be drawn. The error bars can
   comprise either or both of the data and axis-centre errors,
   depending on what is available in the supplied dataset.  The
   parameter SHAPE controls the appearance of the error bars, and
   XSIGMA and YSIGMA control their lengths. The ERRBAR parameter is
   ignored unless the parameter COMP is set to "Data". [FALSE]
3 FREQ
FREQ = _INTEGER (Read)
   The frequency at which error bars are to be plotted.  For
   instance, a value of 2 would mean that alternate points have
   error bars plotted.  This lets some plots be less cluttered.
   FREQ must lie in the range 1 to half of the number of points
   to be plotted.  FREQ is only accessed when parameter ERRBAR is
   TRUE.  [1]
3 KEY
KEY = _LOGICAL (Read)
   TRUE if a key is to be plotted below the horizontal axis giving
   the positions at the start and end of the plot, within the
   current co-ordinate Frame of the NDF. If parameter USEAXIS is
   null (i.e. if the horizontal axis is annotated with offset from
   the first array element), then the positions refer to the centres
   of the first and last elements in the supplied NDF, whether or not
   these elements are actually visible in the plot. If USEAXIS is not
   null (i.e. if the horizontal axis is annotated with the value on
   one of the axes of the NDFs current co-ordinate Frame), then the
   displayed positions correspond to the two ends of the visible
   section of the horizontal axis. The appearance of the key can be
   controlled using parameter KEYSTYLE. The dynamic default is to
   produce a key if the current co-ordinate Frame of the supplied NDF
   has 2 or more axes, and not to if it only has 1 axis. []
3 KEYSTYLE
KEYSTYLE = LITERAL (Read)
   A group of attribute settings describing the plotting style to use
   for the key (see parameter KEY).

   A comma-separated list of strings should be given in which each
   string is either an attribute setting, or the name of a text file
   preceded by an up-arrow character "^". Such text files should
   contain further comma-separated lists which will be read and
   interpreted in the same manner. Attribute settings are applied in
   the order in which they occur within the list, with later settings
   over-riding any earlier settings given for the same attribute.

   Each individual attribute setting should be of the form:

      <name>=<value>

   where <name> is the name of a plotting attribute, and <value> is
   the value to assign to the attribute. Default values will be
   used for any unspecified attributes. All attributes will be
   defaulted if a null value (!) is supplied. See section "Plotting
   Attributes" in SUN/95 for a description of the available
   attributes. Any unrecognised attributes are ignored (no error is
   reported). [current value]
3 LMODE
LMODE = LITERAL (Read)
   LMODE specifies how the defaults for parameters YBOT and YTOP (the 
   lower and upper limit of the vertical axis of the plot) should be 
   found. The supplied string should consist of up to three sub-strings,
   separated by commas. The first sub-string must specify the method 
   to use. If supplied, the other two sub-strings should be numerical 
   values as described below (default values will be used if these
   sub-strings are not supplied). The following methods are available:
 
   - "Range" -- The minimum and maximum data values (including any
   error bars) are used as the defaults for YBOT and YTOP. No other
   sub-strings are needed by this option.
 
   - "Extended" -- The minimum and maximum data values (including error 
   bars) are extended by percentages of the data range, specified by 
   the second and third sub-strings. For instance, if the value
   "Ex,10,5" is supplied, then the default for YBOT is set to the
   minimum data value minus 10% of the data range, and the default
   for YTOP is set to the maximum data value plus 5% of the data range.
   If only one value is supplied, the second value defaults to the
   supplied value. If no values are supplied, both values default to
   "2.5".
 
   - "Percentile" -- The default values for YBOT and YTOP are set to 
   the specified percentiles of the data (excluding error bars). For 
   instance, if the value "Per,10,99" is supplied, then the default 
   for YBOT is set so that the lowest 10% of the plotted points are 
   off the bottom of the plot, and the default for YTOP is set so
   that the highest 1% of the points are off the top of the plot.
   If only one value, p1, is supplied, the second value, p2, defaults 
   to (100 - p1). If no values are supplied, the values default to
   "5,95".
 
   - "Sigma" -- The default values for YBOT and YTOP are set to the 
   specified numbers of standard deviations below and above the mean 
   of the data. For instance, if the value "sig,1.5,3.0" is supplied, 
   then the default for YBOT is set to the mean of the data minus 1.5 
   standard deviations, and the default for YTOP is set to the mean
   plus 3 standard deviations. If only one value is supplied, the
   second value defaults to the supplied value. If no values are
   supplied, both default to "3.0".
 
   The method name can be abbreviated to a single character, and is
   case insensitive. The initial value is "Extended". [current value]
3 MARGIN
MARGIN( 4 ) = _REAL (Read)
   The widths of the margins to leave for axis annotation, given
   as fractions of the corresponding dimension of the current picture.
   Four values may be given, in the order - bottom, right, top, left.
   If less than four values are given, extra values are used equal to
   the first supplied value. If these margins are too narrow any axis
   annotation may be clipped. The dynamic default is 0.15 (for all
   edges) if either annotated axes or a key are produced, and zero
   otherwise. []
3 MARKER
MARKER = _INTEGER (Read)
   This parameter is only accessed if parameter MODE is set to
   "Chain" or "Mark". It specifies the symbol with which each
   position should be marked, and should be given as an integer
   PGPLOT marker type. For instance, 0 gives a box, 1 gives a dot,
   2 gives a cross, 3 gives an asterisk, 7 gives a triangle. The
   value must be larger than or equal to -31. [current value]
3 MODE
MODE = LITERAL (Read)
   Specifies the way in which data values are represented. MODE
   can take the following values:

   - "Histogram" -- An histogram of the points is plotted in the
   style of a "staircase" (with vertical lines only joining the y
   values and not extending to the base of the plot).  The vertical
   lines are placed midway between adjacent x positions.

   - "Line" -- The points are joined by straight lines.

   - "Point" -- A dot is plotted at each point.

   - "Mark" -- Each point is marker with a symbol specified by
   parameter MARKER.

   - "Chain" -- A combination of "Line" and "Mark".

   - "Step" -- Each point is displayed as a horizontal line, whose
   length is specified by the axis width of the pixel.

   [current value]
3 NDF
NDF = NDF (Read)
   NDF structure containing the array to be plotted.
3 SHAPE
SHAPE = LITERAL (Read)
   Specifies the way in which errors are represented. SHAPE
   can take the following values:

   - "Bars" -- Bars with serifs (i.e. cross pieces at each end) are
   drawn joining the x error limits and the y error limits. The plotting
   attribute "Size(ErrBars)" (see parameter STYLE) can be used to
   control the size of these serifs (the attribute value should be
   a magnification factor - 1.0 gives default serifs).

   - "Cross" -- San-serif bars are drawn joining the x error limits and
   the y error limits.

   - "Diamond" -- Adjacent error limits are joined to form an
   error diamond.

   The length of the error bars can be controlled using parameters
   XSIGMA and YSIGMA. The colour, line width and line style used to
   draw them can be controlled using the plotting attributes
   "Colour(ErrBars)", "Width(ErrBars)" and "Style(ErrBars)" (see
   parameter STYLE). SHAPE is only accessed when parameter ERRBAR
   is TRUE.  [current value]
3 STYLE
STYLE = LITERAL (Read)
   A group of attribute settings describing the plotting style to use
   when drawing the annotated axes, data values, and error markers.

   A comma-separated list of strings should be given in which each
   string is either an attribute setting, or the name of a text file
   preceded by an up-arrow character "^". Such text files should
   contain further comma-separated lists which will be read and
   interpreted in the same manner. Attribute settings are applied in
   the order in which they occur within the list, with later settings
   over-riding any earlier settings given for the same attribute.

   Each individual attribute setting should be of the form:

      <name>=<value>

   where <name> is the name of a plotting attribute, and <value> is
   the value to assign to the attribute. Default values will be
   used for any unspecified attributes. All attributes will be
   defaulted if a null value (!) is supplied. See section "Plotting
   Attributes" in SUN/95 for a description of the available
   attributes. Any unrecognised attributes are ignored (no error is
   reported).

   The appearance of the data values is controlled by the attributes
   Colour(Curves), Width(Curves), etc (the synonym Lines may be used
   in place of Curves). The appearance of markers used if parameter
   MODE is set to "Point", "Mark" or "Chain" is controlled by
   Colour(Markers), Width(Markers), etc (the synonym Symbols may be
   used in place of Markers). The appearance of the error symbols is
   controlled using Colour(ErrBars), Width(ErrBars), etc, (see
   parameter SHAPE). [current value]
3 USEAXIS
USEAXIS = LITERAL (Read)
   Specifies the quantity to be used to annotate the horizontal axis
   of the plot. If USEAXIS is given a null (!) value, then the
   distance along the profile from the centre of the first element in
   the supplied NDF will be used. This will be measured in the current
   co-ordinate Frame of the NDF. If USEAXIS is not null, then it
   gives the index of the axis which is to be used, and must be less
   than or equal to the number of axes in the current co-ordinate
   Frame of the NDF.

   The quantity used to annotate the horizontal axis must have a
   defined value at all points in the array, and must increase or
   decrease monotonically along the array. For instance, if RA is
   used to annotate the horizontal axis, then an error will be
   reported if the profile passes through RA=0 because it will
   introduce a non-monotonic jump in axis value (from 0h to 24h, or
   24h to 0h). The dynamic default is 1 if the current co-ordinate
   Frame in the NDF is 1-dimensional an null (!) otherwise. []
3 XLEFT
XLEFT = LITERAL (Read)
   The axis value to place at the left hand end of the horizontal
   axis. The dynamic default is the value for the first element in the
   supplied NDF (with a margin to include any horizontal error bar).
   The value supplied may be greater than or less than the value
   supplied for XRIGHT. A formatted value for the quantity specified
   by parameter USEAXIS should be supplied. See also parameter ALIGN. []
3 XRIGHT
XRIGHT = LITERAL (Read)
   The axis value to place at the right hand end of the horizontal
   axis. The dynamic default is the value for the last element in the
   supplied NDF (with a margin to include any horizontal error bar).
   The value supplied may be greater than or less than the value
   supplied for XLEFT. A formatted value for the quantity specified
   by parameter USEAXIS should be supplied. See also parameter ALIGN. []
3 XSIGMA
XSIGMA = LITERAL (Read)
   If horizontal error bars are produced (see parameter ERRBAR), then
   XSIGMA gives the number of standard deviations which the error
   bars are to represent. [current value]
3 YBOT
YBOT = LITERAL (Read)
   The axis value to place at the bottom end of the vertical
   axis. If a null (!) value is supplied, the value used is
   determined by parameter LMODE. The value of LBOT may be 
   greater than or less than the value supplied for YTOP, and
   should be supplied as a floating point value for the quantity
   specified by parameter YLOG. See also parameter ALIGN. [!]
3 YLOG
YLOG = _LOGICAL (Read)
   TRUE if the value displayed on the vertical axis is to be the
   logarithm of the supplied data values. If TRUE, then the values
   supplied for parameters YTOP and YBOT should be values for the
   logarithm of the data value, not the data value itself. [FALSE]
3 YSIGMA
YSIGMA = LITERAL (Read)
   If vertical error bars are produced (see parameter ERRBAR), then
   YSIGMA gives the number of standard deviations which the error
   bars are to represent. [current value]
3 YTOP
YTOP = LITERAL (Read)
   The axis value to place at the top end of the vertical
   axis. If a null (!) value is supplied, the value used is
   determined by parameter LMODE. The value of LTOP may be 
   greater than or less than the value supplied for YBOT, and
   should be supplied as a floating point value for the quantity
   specified by parameter YLOG. See also parameter ALIGN. [!]
2 Examples
linplot spectrum
   Plots data values versus position for the whole of the
   1-dimensional NDF called spectrum on the current graphics
   device.  If the current co-ordinate Frame of the NDF is also
   1-dimensional, then the horizontal axis will be labelled with
   values on axis 1 of the current co-ordinate Frame. Otherwise, it
   will be labelled with offset from the first element.

linplot map(,100)
   Plots data values versus position for row 100 in the 2-dimensional
   NDF called map on the current graphics device.

linplot spectrum(1:500) device=ps_l
   Plots data values versus position for the first 500 elements
   of the 1-dimensional NDF called spectrum. The output goes to a
   text file which can be printed on a PostScript printer.

linplot ironarc v style="title=Fe Arc variance"
   Plots variance values versus position for the whole of the
   1-dimensional NDF called ironarc on the current graphics device.
   The plot has a title of "Fe Arc variance".

linplot prof useaxis=dec xleft="23:30:22" xright="23:30:45"
   This plots data values versus declination for those elements of the
   1-dimensional NDF called prof with declination value between 23d
   30m 22s, and 23d 30m 45s. This assumes that the current
   co-ordinate Frame in the NDF has an axis with symbol "dec".

linplot prof useaxis=2 ybot=1.0 ytop=3.0 ylog
   This plots the logarithm (base 10) of the data values in the
   entire 1-dimensional NDF called prof, against the value described
   by the second axis in the current co-ordinate Frame of the NDF.
   The bottom of the vertical axis corresponds to a data value of
   10.0 and the top corresponds to a data value of 1000.0 (10 to
   the power 3.0).

linplot xspec mode=p errbar xsigma=3 ysigma=3 shape=d style=^my_sty
   This plots the data values versus position for the dataset called
   xspec. Each pixel is plotted as a point surrounded by diamond-shaped
   error bars.  The error bars are 3 sigma error bars. The plotting
   style is read from text file my_sty. This could, for instance,
   contain strings such as; colour(err)=pink, colour(sym)=red,
   tickall=0, edge(2)=right. These cause the error bars to be drawn
   in pink, the points to be drawn in red, tick marks to be restricted
   to the labelled edges of the plot, and the vertical axis (axis 2)
   to be annotated on the right hand edge of the plot.

linplot ndf=spectrum noclear align
   Plots data values versus pixel co-ordinate for the whole of
   the 1-dimensional NDF called spectrum on the current graphics
   device.  The plot is drawn over any existing plot and inherits
   the bounds of the previous plot on both axes. A warning will be
   reported if the labels for the horizontal axes of the two plots
   are different.
2 Notes
-  The Title component in the NDF is used as the default title for
the annotated axes. If the NDF does not have a Title component, then
the default title is taken from current co-ordinate Frame in the NDF.
This default may be over-ridden by specifying a value for the Title
attribute using the STYLE parameter.

-  Default axis errors and widths are used, if none are present in
the NDF. The defaults are the constants 0 and 1 respectively.

-  The application stores a number of pictures in the graphics
database in the following order: a FRAME picture containing the
annotated axes, data plot, and optional key; a KEY picture to store
the key if present; and a DATA picture containing just the data plot.
Note, the FRAME picture is only created if annotated axes or a key
has been drawn, or if non-zero margins were specified using parameter
MARGIN. The world co-ordinates in the DATA picture will correspond
to offset along the profile on the horizontal axis, and data value
(or logarithm of data value) on the vertical axis. On exit the current
database picture for the chosen device reverts to the input picture.
2 Related_Applications
   KAPPA: PROFILE, MLINPLOT; Figaro: ESPLOT, IPLOTS, MSPLOT, SPLOT,
   SPECGRID.
2 Authors
Malcolm Currie STARLINK (RAL::CUR)

DSB: David S. Berry (STARLINK)
2 History
 1-OCT-1998 (DSB):
    Original AST version, based on earlier version by MJC.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, VARIANCE,
   QUALITY, LABEL, TITLE, WCS and UNITS components of the NDF.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.  Only
   double-precision floating-point data can be processed directly.
   Other non-complex data types will undergo a type conversion
   before the plot is drawn.

1 LISTMAKE
Creates a catalogue holding a positions list.

Usage:

   listmake outcat [ndf] [mode] [file]

Description:

   This application creates a catalogue containing a list of positions
   supplied by the user, together with information describing the
   co-ordinate Frames in which the positions are defined. Integer
   position identifiers which allow positions to be distinguished are
   also stored in the catalogue. The catalogue may be manipulated
   using the CURSA package (SUN/190), and is stored in either FITS
   binary format or the "Small Text List" (STL) format defined by CURSA.

   If an NDF is specified using parameter NDF, then the positions should
   be given in the current co-ordinate Frame of the NDF. Information
   describing the co-ordinate Frames available within the NDF will be
   copied to the output positions list. Subsequent applications can
   use this information in order to align the positions with other
   data sets.

   If no NDF is specified, then the user must indicate the co-ordinate
   Frame in which the positions will be supplied using parameter FRAME.
   A description of this Frame will be written to the output positions
   list for use by subsequent applications.

   The positions themselves may be supplied within a text file,
   or may be given in response to repeated prompts for a parameter.
   Alternatively, the pixel centres in the NDF supplied for parameter
   NDF can be used (see parameter MODE).

   The output can be initialised by copying positions from an existing
   positions list. Any positions supplied directly by the user are then
   appended to the end of this initial list (see parameter INCAT).
2 Parameters
For information on individual parameters, select from the list below:
3 DESCRIBE
DESCRIBE = LOGICAL (Read)
   If TRUE, a detailed description of the co-ordinate Frame in which
   positions are required will be displayed before the positions
   are obtained using either parameter POSITION or FILE. [Current value]
3 DIM
DIM = _INTEGER (Read)
   The number of axes for each position. Only accessed if a null
   value is supplied for parameter NDF.
3 FRAME
FRAME = LITERAL (Read)
   Specifies the co-ordinate Frame of the positions supplied
   using parameter POSITION or FILE. If an IRAS90 Sky
   Co-ordinate System (SCS) string such as EQUAT(J2000) is
   supplied (see SUN/163), then the positions are assumed to be
   2-dimensional celestial co-ordinates in the specified
   system. Otherwise, the given string is used as a Domain name
   without any interpretation. Any string may be supplied, but
   normally one of the standard Domain names such as GRID,
   PIXEL, GRAPHICS, etc, should be given. Parameter DIM is used
   to determine the number of axes in the Frame. This parameter
   is only accessed if the parameter NDF is given a null value.
3 EPOCH
EPOCH = DOUBLE PRECISION (Read)
   If an IRAS90 Sky Co-ordinate System specification is supplied
   (using parameter FRAME) for a celestial co-ordinate system,
   then an epoch value is needed to qualify it. This is the epoch at
   which the supplied sky positions were determined. It should be
   given as a decimal years value, with or without decimal places
   ("1996.8" for example). Such values are interpreted as a Besselian
   epoch if less than 1984.0 and as a Julian epoch otherwise.
3 FILE
FILE = FILENAME (Read)
   A text file containing the positions to be stored in the output
   positions list. Each line should contain the formatted axis values
   for a single position, separated by white space. Only accessed if
   parameter MODE is given the value "File".
3 INCAT
INCAT = FILENAME (Read)
   A catalogue containing an existing positions list which is to be
   included at the start of the output positions list. These positions
   are mapped into the current co-ordinate Frame of the supplied
   NDF, or into the Frame specified by parameter FRAME if no NDF was
   supplied. A message is displayed indicating the Frame in which
   alignment occurred. They are then stored in the output list before
   any further positions are added. A null value may be supplied
   if there is no input positions list. [!]
3 MODE
MODE = LITERAL (Read)
   The mode by which the positions are to be obtained. The options are
   as follows:

   - "Interface" -- The positions are obtained using parameter
   POSITION.

   - "File" -- The positions are to be read from a text file
   specified using parameter FILE.

   - "Pixel" -- The positions used are the pixel centres in the data
   file specified by parameter NDF.

   [Interface]
3 NDF
NDF = NDF (READ)
   The NDF which defines the available co-ordinate Frames in the
   output positions list. If an NDF is supplied, the positions
   obtained using parameter POSITION or FILE are assumed to be in
   the current co-ordinate Frame of the NDF, and the WCS component
   of the NDF is copied to the output positions list. If a null
   value is supplied, the single co-ordinate Frame defined by parameter
   FRAME is stored in the output positions list, and supplied
   positions are assumed to be in the same Frame. [!]
3 OUTCAT
OUTCAT = FILENAME (Write)
   The catalogue holding the output positions list.
3 POSITION
POSITION = LITERAL (Read)
   The co-ordinates of a single position to be stored in the output
   positions list. Supplying ":" will display details of the co-ordinate
   Frame in which the position is required. The position should be
   given as a list of formatted axis values separated by white space.
   You are prompted for new values for this parameter until a null
   value is entered. Only accessed if parameter MODE is given the
   value "Interface".
3 TITLE
TITLE = LITERAL (Read)
   A title for the output positions list. The dynamic default
   is obtained from the input positions list if one is supplied.
   Otherwise, the dynamic default is obtained from the NDF if one
   is supplied. Otherwise, the dynamic default is "Output from
   LISTMAKE". []
2 Examples
listmake newlist frame=pixel dim=2
   This creates a FITS binary catalogue called newlist.fit containing a
   list of positions, together with a description of a single
   2-dimensional pixel co-ordinate Frame. The positions are supplied as
   a set of space-separated pixel co-ordinates in response to repeated
   prompts for the parameter POSITION.

listmake stars.txt frame=equat(B1950) epoch=1962.3
   This creates a catalogue called stars.txt containing a list of
   positions, together with a description of a single FK4 equatorial
   RA/DEC co-ordinate Frame (referenced to the B1950 equinox). The
   catalogue is stored in a text file using the CAT "Small Text List"
   format ("STL" - see SUN/190). The positions were determined at epoch
   B1962.3. The epoch of observation is required since the underlying
   model on which the FK4 system is based is non-inertial and rotates
   slowly with time, introducing fictitious proper motions. The
   positions are supplied hours and degrees values in reponse to
   repeated prompts for parameter POSITIONS.

listmake outlist ndf=allsky mode=file file=stars
   This creates a FITS binary catalogue called outlist.fit containing a
   list of positions, together with descriptions of all the co-ordinate
   Frames contained in the NDF allsky. The positions are supplied
   as co-ordinates within the current co-ordinate Frame of the NDF.
   Application WCSFRAME can be used to find out what this Frame is.
   The positions are supplied in a text file called stars.

listmake out.txt incat=old.fit frame=gal
   This creates an STL format catalogue stored in a text file called
   out.txt containing a list of positions, together with a description
   of a single galactic co-ordinate Frame. The positions contained in
   the existing binary FITS catalogue old.fit are mapped into galactic
   co-ordinates (if possible) and stored in the output positions list.
   Further galactic co-ordinate positions are then obtained by repeated
   prompting for the parameter POSITION. These positions are
   appended to the positions obtained from file old.fit.

listmake out.txt incat=old.fit ndf=cobe
   As above but the output positions list contains copies of all the
   Frames in the NDF cobe. The positions in old.fit are mapped into
   the current co-ordinate Frame of the NDF (if possible) before
   being stored in the output positions list. The new positons must
   also be supplied in the same Frame (using parameter POSITION).

listmake profpos ndf=prof1 mode=pixel
   This creates a positions list called profpos.fit containing the
   positions of all the pixel centres in the 1-dimensional NDF
   called prof. This could for instance be used as input to
   application PROFILE in order to produce another profile in which
   the samples are at the same positions as those in NDF prof.
2 Notes
-  This application uses the conventions of the CURSA package
for determining the formats of input and output catalogues. If a file
type of .fits is given, then the catalogue is assumed to be a FITS
binary table. If a file type of .txt is given, then the catalogue is
assumed to be stored in a text file in STL format. If no file type is
given, then ".fit" is assumed.

-  There is a limit of 200 on the number of positions which can be
given using parameter POSITION. There is no limit on the number of
positions which can be given using parameter FILE.

-  Position identifiers are asigned to the supplied positions in
the order in which they are supplied. If no input positions list is
given using parameter INCAT, then the first supplied position will
be assigned the identifier "1". If an input positions list is
given, then the first supplied position is assigned an identifier
one greater than the largest identifier in the input positions list.
2 Related_Applications
   KAPPA: CURSOR, LISTSHOW; CURSA: XCATVIEW, CATSELECT
2 Authors
DSB: David S. Berry (STARLINK)
2 History
 16-SEP-1998 (DSB):
    Original version.

1 LISTSHOW
Reports the positions stored in a positions list.

Usage:

   listshow incat [frame] [first] [last] [plot] [device]

Description:

   This application reports positions contained in a catalogue. The
   catalogue should have the form of a positions list as produced (for
   instance) by applications LISTMAKE and CURSOR. By default all positions
   in the catalogue are reported, but a subset may be reported by
   specifying a range of "position identifiers" (see parameters FIRST
   and LAST).

   Positions may be reported in a range of co-ordinate Frames dependant
   on the information stored in the supplied positions list (see parameter
   FRAME). The selected positions are written to an output parameter
   (parameter POSNS), and may also be written to an output positions
   list (see parameter OUTCAT). The formatted screen output can be saved
   in a logfile (see parameter LOGFILE). The formats used to report the
   axis values can be controlled using parameter STYLE.

   Graphics may also be drawn marking the selected positions (see
   parameters PLOT and LABEL). The supplied positions are aligned with
   the picture specified by parameter NAME. If possible, this alignment
   occurs within the co-ordinate Frame specified using parameter FRAME.
   If this is not possible, alignment may occur in some other suitable
   Frame. A message is displayed indicating the Frame in which alignment
   occurred if parameter QUIET is set to FALSE. If the supplied positions
   are aligned succesfully with a picture, then the range of Frames in
   which the positions may be reported on the screen is extended to
   include all those associated with the picture.
2 Parameters
For information on individual parameters, select from the list below:
3 CLOSE
CLOSE = LOGICAL (Read)
   This parameter is only accessed if parameter PLOT is set to
   "Chain" or "Poly". If TRUE, polgons will be closed by joining
   the first position to the last position. [Current value]
3 DESCRIBE
DESCRIBE = LOGICAL (Read)
   If TRUE, a detailed description of the co-ordinate Frame in which
   the positions will be reported is displayed before the
   positions. [Current value]
3 DEVICE
DEVICE = DEVICE (Read)
   The graphics workstation.  Only accessed if parameter PLOT
   indicates that graphics are required. [The current graphics device]
3 DIM
DIM = _INTEGER (Write)
   The number of axes for each position written to output parameter
   POSNS.
3 EPOCH
EPOCH = DOUBLE PRECISION (Read)
   If an IRAS90 Sky Co-ordinate System specification is supplied
   (using parameter FRAME) for a celestial co-ordinate system,
   then an epoch value is needed to qualify it. This is the epoch at
   which the supplied sky positions were determined. It should be
   given as a decimal years value, with or without decimal places
   ("1996.8" for example). Such values are interpreted as a Besselian
   epoch if less than 1984.0 and as a Julian epoch otherwise.
3 FIRST
FIRST = INTEGER (Read)
   The identifier for the first position to be displayed. Positions
   are only displayed which have identifiers in the range given by
   parameters FIRST and LAST. The dynamic default is the lowest
   identifier value in the positions list. []
3 FRAME
FRAME = LITERAL (Read)
   A string determining the co-ordinate Frame in which positions are
   to be reported. This application can report positions in
   any of the co-ordinate Frames stored with the positions list. The
   string supplied for FRAME can be one of the following:

   - A Domain name such as SKY, AXIS, PIXEL, etc.

   - An integer value giving the index of the required Frame.

   - An IRAS90 Sky Co-ordinate System (SCS) values such as
   EQUAT(J2000) (see SUN/163).

   If a null value (!) is supplied, positions are reported in the
   co-ordinate Frame which was current when the positions list was
   created. The user is re-prompted if the specified Frame is not
   available within the positions list. The range of Frames available
   will include all those read from the supplied positions list. In
   addition, if a graphics device is opened (i.e. if parameter PLOT
   is set to anything other than NONE), then all the Frames associated 
   with the picture specified by parameter NAME will also be available. 
   [!]
3 GEODESIC
GEODESIC = LOGICAL (Read)
   This parameter is only accessed if parameter PLOT is set to
   "Chain" or "Poly". It specifies whether the curves drawn between
   positions should be stright lines, or should be geodesic curves.
   In many co-ordinate Frames geodesic curves will be simple straight
   lines. However, in others (such as the majority of celestial
   co-ordinates Frames) geodesic curves will be more complex curves
   tracing the shortest path between two positions in a non-linear
   projection. [FALSE]
3 INCAT
INCAT = FILENAME (Read)
   A catalogue containing a positions list such as produced by
   applications LISTMAKE, CURSOR, etc.
3 JUST 
JUST = LITERAL (Read)
   A string specifying the justification to be used when displaying text
   strings at the supplied positions. This parameter is only accessed if
   parameter PLOT is set to "Text". The supplied string should contain
   two characters; the first should be "B", "C" or "T", meaning bottom,
   centre or top. The second should be "L", "C" or "R", meaning left,
   centre or right. The text is displayed so that the supplied position
   is at the specified point within the displayed text string. [CC]
3 LABEL
LABEL = LOGICAL (Read)
   If TRUE the positions are labelled with the corresponding integer
   identifiers on the graphics device specified by parameter DEVICE.
   The offset from each position to the centre of the corresponding
   label is controlled using the "NumLabGap(1)" and "NumLabGap(2)"
   plotting attributes, and the appearance of the labels is
   controlled using attributes "Colour(NumLab)", "Size(NumLab)", etc.
   These attributes may be specified using parameter STYLE. [FALSE]
3 LAST
LAST = INTEGER (Read)
   The identifier for the last position to be displayed. Positions
   are only displayed which have identifiers in the range given by
   parameters FIRST and LAST. parameters FIRST and LAST. The dynamic
   default is the highest identifier value in the positions list. []
3 LOGFILE
LOGFILE = FILENAME (Write)
   The name of the text file in which the formatted co-ordinates of
   the selected positions may be stored. This is intended primarily
   for recording the screen output, and not for communicating
   positions to subsequent applications. A null string (!) means that
   no file is created.  [!]
3 MARKER
MARKER = INTEGER (Read)
   This parameter is only accessed if parameter PLOT is set to
   "Chain" or "Mark". It specifies the symbol with which each
   position should be marked, and should be given as an integer
   PGPLOT marker type. For instance, 0 gives a box, 1 gives a dot,
   2 gives a cross, 3 gives an asterisk, 7 gives a triangle. The
   value must be larger than or equal to -31. [current value]
3 NAME
NAME = LITERAL (Read)
   Determines the graphics database picture with which the supplied
   positions are to be aligned. Only accessed if parameter PLOT
   indicates that some graphics are to be produced. A search is made
   for the most recent picture with the specified name (eg DATA,
   FRAME or KEY) within the current picture. If no such picture can
   be found, or if a null value is supplied, the current picture
   itself is used. The name BASE can also be supplied as a special
   case, which causes the BASE picture to be used even though it
   will not in general fall within the current picture. ["DATA"]
3 NUMBER
NUMBER = _INTEGER (Write)
   The number of positions selected.
3 OUTCAT
OUTCAT = FILENAME (Write)
   The output catalogue in which to store the selected positions. If a
   null value is supplied, no output catalogue is produced. [!]
3 PLOT
PLOT = LITERAL (Read)
   The type of graphics to be used to mark the positions on the
   graphics device specified by parameter DEVICE. The appearance of
   these graphics (colour, size, etc ) is controlled by the STYLE
   parameter. PLOT can take any of the following values:

   - "None" -- No graphics are produced.

   - "Mark" -- Each position is marked by the symbol specified
   by parameter MARKER.

   - "Poly" -- Causes each position to be joined by a line to the
   previous position.  These lines may be simple straight lines or
   geodesic curves (see parameter GEODESIC). The polygons may
   optionally be closed by joining the last position to the first (see
   parameter CLOSE).

   - "Chain" -- This is a combination of "Mark" and "Poly". Each
   position is marked by a symbol and joined by a line to the previous
   position. Parameters MARKER, GEODESIC and CLOSE are used to
   specify the symbols and lines to use.

   - "Box" -- A rectangular box with edges parallel to the edges of
   the graphics device is drawn between each pair of positions.

   - "Vline" -- A vertial line is drawn through each position,
   extending the entire height of the selected picture.

   - "Hline" -- A horizontal line is drawn through each position,
   extending the entire width of the selected picture.

   - "Cross" -- A combination of "Vline" and "Hline".

   - "Text" -- A text string is used to mark each position. The string is
   drawn horizontally with the justification specified by parameter JUST.
   The strings to use for each position are specified using parameter
   STRINGS.

   - "Blank" -- The graphics device is opened and the picture specified 
   by parameter NAME is found, but no actual graphics are drawn to mark 
   the positions. This can be usefull if you just want to transform 
   the supplied positions into one of the co-ordinate Frames associated 
   with the picture, without drawing anything (see parameter FRAME).

   Each position may also be separately labelled with its integer
   identifier value by giving a TRUE value for parameter LABEL. [None]
3 POSNS
POSNS() = _DOUBLE (Write)
   The unformatted co-ordinates of the positions selected by
   parameters FIRST and LAST, in the co-ordinate Frame selected by
   FRAME. The axis values are stored as a 1-dimensional vector. All
   the axis 1 values for the selected positions are stored first,
   followed by the axis 2 values, etc. The number of positions in
   the vector is written to the output parameter NUMBER, and the
   number of axes per position is written to the output parameter
   DIM. The axis values may not be in the same units as the
   formatted values shown on the screen. For instance, unformatted
   celestial co-ordinate values are stored in units of radians.
3 QUIET
QUIET = LOGICAL (Read)
   If TRUE then nothing is displayed on the screen while the
   application is running (other than error messages). Output
   parameters and files are still created. The dynamic default is
   to run quietly if any graphics or labels are being plotted (see
   parameters PLOT and LABEL). []
3 STRINGS
STRINGS = LITERAL (Read)
   A group of text strings which are used to mark the supplied positions
   if parameter PLOT is set to "TEXT". The first string in the
   group is used to mark the first position, the second string is
   used to mark the second position, etc. If more positions are given than 
   there are strings in the group, then the extra positions will be marked 
   with an integer value indicating the index within the list of supplied 
   positions (note, these integers may be different to the position 
   identifiers in the supplied positions list - if you want to see the 
   position identifiers, use parameter LABEL). If a null value (!) is 
   given for the parameter, then all positions will be marked with integer 
   indices, starting at 1.

   A comma-separated list should be given in which each element is
   either a marker string, or the name of a text file preceded by an
   up-arrow character "^". Such text files should contain further
   comma-separated lists which will be read and interpreted in the
   same manner. Note, strings within text files can be separated by
   new lines as well as commas.
3 STYLE
STYLE = LITERAL (Read)
   A group of attribute settings describing the style to use when
   formatting the co-ordinate values displayed on the screen, and 
   when drawing the graphics specified by parameter PLOT. 

   A comma-separated list of strings should be given in which each
   string is either an attribute setting, or the name of a text file
   preceded by an up-arrow character "^". Such text files should
   contain further comma-separated lists which will be read and 
   interpreted in the same manner. Attribute settings are applied in 
   the order in which they occur within the list, with later settings
   over-riding any earlier settings given for the same attribute.
   Each individual attribute setting should be of the form:

      <name>=<value>

   where <name> is the name of a plotting attribute, and <value> is
   the value to assign to the attribute. Default values will be
   used for any unspecified attributes. All attributes will be
   defaulted if a null value (!) is supplied. See section "Plotting
   Attributes" in SUN/95 for a description of the available
   attributes. Any unrecognised attributes are ignored (no error is
   reported). 

   In addition to the attributes which control the appearance of
   the graphics (Colour, Font, etc), the following attributes may
   be set in order to control the appearance of the formatted axis 
   values reported on the screen: Format, Digits, Symbol, Unit. These
   may be suffixed with an axis number (eg "Digits(2)") to refer to 
   the values displayed for a specific axis. [current value]
2 Examples
listshow stars pixel
   This displays the pixel co-ordinates of all the positions
   stored in the FITS binary catalogue stars.fit. They are all written
   to the output parameter POSNS as well as to the screen.

listshow stars.fit equat(J2010) first=3 last=3 quiet
   This extracts position 3 from the catalogue stars.fit transforming
   it into FK5 equatorial RA/DEC co-ordinates (referenced to the
   J2010 equinox) if possible. The RA/DEC values (in radians) are
   written to the output parameter POSNS, but not to the screen.

listshow stars_2.txt style="digits(1)=5,digits(2)=7"
   This lists the positions in the STL format catalogue contained
   in text file stars_2.txt in their original co-ordinate Frame. By
   default, 5 digits are used to format axis 1 values, and 7 to format
   axis 2 values. These defaults are over-ridden if the attributes
   Format(1) and/or Format(2) are assigned values in the description
   of the current Frame stored in the positions list.

listshow s.txt plot=mark marker=3 style="colour(marker)=red,size=2"
   This marks the positions in s.txt on the currently selected graphics 
   device using PGPLOT marker 3 (an asterisk). The positions are aligned
   with the most recent DATA picture in the current picture. The markers 
   are red and are twice the default size. The positions are not reported 
   on the screen.
2 Notes
-  This application uses the conventions of the CURSA package (SUN/190)
for determining the formats of input and output catalogues. If a file
type of .fits is given, then the catalogue is assumed to be a FITS
binary table. If a file type of .txt is given, then the catalogue is
assumed to be stored in a text file in "Small Text List" (STL) format.
If no file type is given, then ".fit" is assumed.
2 Related_Applications
   KAPPA: CURSOR, LISTMAKE; CURSA: XCATVIEW, CATSELECT
2 Authors
DSB: David S. Berry (STARLINK)
2 History
 16-SEP-1998 (DSB):
    Original version.

1 LOG10
Takes the base-10 logarithm of an NDF data structure.

Usage:

   log10 in out

Description:

   This routine takes the base-10 logarithm of each  pixel of a NDF
   to produce a new NDF data structure.

   This command is a synonym for "logar base=10D0".
2 Parameters
For information on individual parameters, select from the list below:
3 IN
IN = NDF (Read)
   Input NDF data structure.
3 OUT
OUT = NDF (Write)
   Output NDF data structure being the logarithm of the input NDF.
3 TITLE
TITLE = LITERAL (Read)
   Value for the title of the output NDF.  A null value will cause
   the title of the NDF supplied for parameter IN to be used
   instead. [!]
2 Examples
log10 a b
   This takes logarithms to base ten of the pixels in the NDF
   called a, to make the NDF called b.  NDF b inherits its title
   from a.

log10 title="Abell 4321" out=b in=a
   This takes logarithms to base ten of the pixels in the NDF
   called a, to make the NDF called b.  NDF b has the title
   "Abell 4321".
2 Related_Applications
   KAPPA: LOGAR, LOGE, EXP10, EXPE, EXPON, POW; Figaro: IALOG, ILOG,
   IPOWER.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1997 June 13 (MJC):
    Original NDF version.
 1997 November 5 (MJC):
    Added WCS propagation.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   LABEL, TITLE, UNITS, HISTORY, WCS, and VARIANCE components of an
   NDF data structure and propagates all extensions.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.
1 LOGAR
Takes the logarithm (specified base) of an NDF data structure.

Usage:

   logar in out base

Description:

   This routine takes the logarithm to a specified base of each
   pixel of a NDF to produce a new NDF data structure.
2 Parameters
For information on individual parameters, select from the list below:
3 BASE
BASE = LITERAL (Read)
   The base of the logarithm to be applied.  A special value
   "Natural" gives natural (base-e) logarithms.
3 IN
IN = NDF (Read)
   Input NDF data structure.
3 OUT
OUT = NDF (Write)
   Output NDF data structure being the logarithm of the input NDF.
3 TITLE
TITLE = LITERAL (Read)
   Value for the title of the output NDF.  A null value will cause
   the title of the NDF supplied for parameter IN to be used
   instead. [!]
2 Examples
logar a b 10
   This takes logarithms to base ten of the pixels in the NDF
   called a, to make the NDF called b.  NDF b inherits its title
   from a.

logar base=8 title="HD123456" out=b in=a
   This takes logarithms to base eight of the pixels in the NDF
   called a, to make the NDF called b.  NDF b has the title
   "HD123456".
2 Related_Applications
   KAPPA: LOG10, LOGE, EXP10, EXPE, EXPON, POW; Figaro: IALOG, ILOG,
   IPOWER.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1997 June 13 (MJC):
    Original NDF version.
 1997 November 5 (MJC):
    Added WCS propagation.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   LABEL, TITLE, UNITS, HISTORY, WCS, and VARIANCE components of an
   NDF data structure and propagates all extensions.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.
1 LOGE
Takes the natural logarithm of an NDF data structure.

Usage:

   loge in out

Description:

   This routine takes the natural logarithm of each pixel of a NDF
   to produce a new NDF data structure.

   This command is a synonym for "logar base=natural".
2 Parameters
For information on individual parameters, select from the list below:
3 IN
IN = NDF (Read)
   Input NDF data structure.
3 OUT
OUT = NDF (Write)
   Output NDF data structure being the logarithm of the input NDF.
3 TITLE
TITLE = LITERAL (Read)
   Value for the title of the output NDF.  A null value will cause
   the title of the NDF supplied for parameter IN to be used
   instead. [!]
2 Examples
loge a b
   This takes the natural logarithm of the pixels in the NDF called
   a, to make the NDF called b.  NDF b inherits its title from a.

loge title="Cas A" out=b in=a
   This takes the natural logarithm of the pixels in the NDF called
   a, to make the NDF called b.  NDF b has the title "Cas A".
2 Related_Applications
   KAPPA: LOG10, LOGAR, EXP10, EXPE, EXPON, POW; Figaro: IALOG, ILOG,
   IPOWER.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1997 June 13 (MJC):
    Original NDF version.
 1997 November 5 (MJC):
    Added WCS propagation.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   LABEL, TITLE, UNITS, HISTORY, WCS, and VARIANCE components of an
   NDF data structure and propagates all extensions.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.

1 LOOK
    Outputs the values of a sub-array of a 2-d data array to the
    screen or a text file.
 
   This routine reports to user or writes to a text file the values
   in a specified sub-array of the 2-d data array in the input IMAGE
   structure.  Three options are allowed --- Peep gives a fixed 7x7
   box on the screen, centred on a given pixel; Examine gives an NxM
   box on the screen, with lower left pixel as specified; List
   outputs the specified sub-array to a text text file (maximum
   width 132 characters) of a defined name.  Beware that the List
   option can produce very large files if it is not used sensibly.
 
   The magic-value method is used for processing bad data. Bad pixels
   are denoted in the display or file by INVALID rather than a
   numerical value.
2 AUTHORS
   Mark McCaughrean UoE ( REVA::MJM )
   Malcolm Currie  STARLINK (RAL::CUR)
2 BUGS
   None known.
2 HISTORY
   11-06-1986 : First implementation (REVA::MJM)
   15-06-1986 : Modified to include Examine option (REVA::MJM)
   1986 Aug 7 : Renamed algorithmic routines to PEEPSB and LISTSB
                (RAL::CUR).
   1986 Aug 29: Added argument section to prologue, and nearly
                conformed to Starlink standards (RAL::CUR).
   1987 Oct 15: Reordered tidying and extra status check
                (RAL::CUR)
   1988 Mar 17: Referred to `array' rather than `image'
                (RAL::CUR)
   1988 Jun 4 : More reporting of error context (RAL::CUR)
   1988 Jun 30: File name obtained in LISTSB (RAL::CUR).
   1988 Dec  6: Improved Examine XSIZE default (RAL::CUR).
   1989 Jul 27: Passed array dimensions to PEEPSB and LISTSB as
                separate variables (RAL::CUR).
   1990 Feb 22: Modified the calling sequence for the new
                more-modular version of LISTSB (RAL::CUR).
   1992 Feb 25: Limited processing of simple NDFs (RAL::CUR).
   1992 Mar  3: Replaced AIF parameter-system calls by the extended
                PAR library (RAL::CUR).
2 PARAMETERS
   INPIC  =  IMAGE( READ )
       IMAGE structure containing the 2-d data array to be inspected.
   CHOICE = LITERAL( READ )
       The means by which the data array is examined.  The options
         are 'Peep' --- reports the values in a 7x7 pixel region;
         'Examine' --- reports the values of a region whose size is
         defined by the user; and 'List' is similar to 'Examine',
         but it generates a listing to a text file.
   XCEN  =  INTEGER( READ )
       x centre of box to be examined on the screen.
   YCEN  =  INTEGER( READ )
       y centre of box to be examined on the screen.
   XLOW  =  INTEGER( READ )
       x pixel index of the lower left of the sub-array to be output.
   YLOW  =  INTEGER( READ )
       y pixel index of the lower left of the sub-array to be output.
   XSIZE  =  INTEGER( READ )
       x size of the sub-array to be output.
   YSIZE  =  INTEGER( READ )
       y size of the sub-array to be output.
   FILENAME  =  FILENAME( READ )
       Name of the file to be used for the output of the sub-array
         listing.
   ANOTHER = LOGICAL( READ )
       If true, another look at the data is required.
3 INPIC
  position    1
  keyword     'INPIC'
  type        'IMAGE'
  access      'READ'
  vpath       'PROMPT'
  ppath       'GLOBAL'
  association '<->GLOBAL.DATA_ARRAY'
  prompt      'Image to be inspected'
  help        'Give name of the IMAGE structure holding the 2-d data 
              array to be inspected.'
3 CHOICE
  position    2
  keyword     'CHOICE'
  type        'LITERAL'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC,DEFAULT'
  default     'Peep'
  prompt      'Peep, Examine or List'
  help        'Peep lists a 7x7 neighbourhood to screen, Examine
              reports an NxM box to screen, List gives a listing to
              a file.'
 #in          'Peep', 'Examine', 'List'
3 XCEN
  keyword     'XCEN'
  type        '_INTEGER'
  access      'READ'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC'
  prompt      'x centre pixel index of 7x7 box'
  help        'Give the x centre pixel index of the sub-array to be 
              peeped.'
3 YCEN
  keyword     'YCEN'
  type        '_INTEGER'
  vpath       'PROMPT'
  access      'READ'
  ppath       'CURRENT,DYNAMIC'
  prompt      'y centre pixel index of 7x7 box'
  help        'Give the y centre pixel index of the sub-array to be 
              peeped.'
3 XLOW
  keyword     'XLOW'
  type        '_INTEGER'
  vpath       'PROMPT'
  access      'READ'
  ppath       'CURRENT,DYNAMIC'
  prompt      'x start pixel index of sub-array'
  help        'Give the x start pixel index of the sub-array to be 
              inspected.'
3 YLOW
  keyword     'YLOW'
  type        '_INTEGER'
  vpath       'PROMPT'
  access      'READ'
  ppath       'CURRENT,DYNAMIC'
  prompt      'y start pixel index of sub-array'
  help        'Give the y start pixel index of the sub-array to be 
              inspected.'
3 XSIZE
  keyword     'XSIZE'
  type        '_INTEGER'
  vpath       'PROMPT'
  access      'READ'
  ppath       'DYNAMIC'
  prompt      'x size of sub-array'
  help        'Give the x size of the sub-array to be inspected.'
3 YSIZE
  keyword     'YSIZE'
  type        '_INTEGER'
  access      'READ'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'y size of sub-array'
  help        'Give the y size of the sub-array to be inspected.'
3 FILENAME
  keyword     'FILENAME'
  type        'FILENAME'
  access      'READ'
  vpath       'PROMPT'
  ppath       'DEFAULT'
  default     LOOKOUT.LIS
  prompt      'Name of listing file'
  help        'Give name of the ASCII file to contain the sub-array 
              listing.'
3 ANOTHER
  keyword     'ANOTHER'
  type        '_LOGICAL'
  access      'READ'
  vpath       'PROMPT'
  ppath       'DEFAULT'
  default     Y
  prompt      'Another inspection ?'
  help        'Answer YES if another sub-array is to be peeped or 
              listed.'

1 LUCY
Performs a Richardson-Lucy deconvolution of a 1- or 2-dimensional
array.

Usage:

   lucy in psf out [aim]

Description:

   This application deconvolves the supplied 1- or 2-dimensional
   array using the Richardson-Lucy (R-L) algorithm.  It takes an
   array holding observed data and another holding a Point-Spread
   Function (PSF) as input and produces an output array with higher
   resolution.  The algorithm is iterative, each iteration producing
   a new estimate of the restored array which (usually) fits the
   observed data more closely than the previous estimate (in the
   sense that simulated data generated from the restored array is
   closer to the observed data).  The closeness of the fit is
   indicated after each iteration by a normalised chi-squared value
   (i.e. the chi-squared per pixel).  The algorithm terminates when
   the normalised chi-squared given by parameter AIM is reached, or
   the maximum number of iterations given by parameter NITER have
   been performed.  The current estimate of the restored array is
   then written to the output NDF.

   Before the first iteration, the restored array is initialised
   either to the array given by parameter START, or, if no array is
   given, to the difference between the mean value in the input data
   array and the mean value in the background (specified by
   parameters BACK and BACKVAL).  Simulated data is then created from
   this trial array by smoothing it with the supplied PSF, and then
   adding the background on.  The chi-squared value describing the
   deviation of this simulated data from the observed data is then
   found and displayed.  If the required chi-squared is not reached
   by this simulated data, the first iteration commences, which
   consists of creating a new version of the restored array and then
   creating new simulated data from this new restored array (the
   corresponding chi-squared value is displayed).  Repeated
   iterations are performed until the required chi-squared is
   reached, or the iteration limit is reached.  The new version of
   the restored array is created as follows.

      1 - A correction factor is found for each data value.  This is
      the ratio of the observed data value to the simulated data
      value.  An option exists to use the Snyder modification as
      used by the LUCY program in the STSDAS package within IRAF.
      With this option selected, the variance of the observed data
      value is added to both the numerator and the denominator when
      finding the correction factors.

      2 - These correction factors are mapped into an array by
      smoothing the array of correction factors with the transposed
      PSF.

      3 - The current version of the restored array is multiplied by
      this correction factor array to produce the new version of the
      restored array.

   For further background to the algorithm, see L. B. Lucy,
   Astron.J. 1974, Vol 79, No. 6.
2 Parameters
For information on individual parameters, select from the list below:
3 AIM
AIM = _REAL (Read)
   The chi-squared value at which the algorithm should terminate.
   Smaller values of AIM will result in higher apparent resolution
   in the output array but will also cause noise in the observed
   data to be interpreted as real structure.  Small values will
   require larger number of iterations, so NITER may need to be
   given a larger value.  Very-small values may be completely
   un-achievable, indicated by chi-squared not decreasing (or
   sometimes increasing) between iterations.  Larger values will
   result in smoother output arrays with less noise.  [1.0]
3 BACK
BACK = NDF (Read)
   An NDF holding the background value for each observed data
   value.  If a null value is supplied, a constant background
   value given by parameter BACKVAL is used. [!]
3 BACKVAL
BACKVAL = _REAL (Read)
   The constant background value to use if BACK is given a null
   value. [0.0]
3 CHIFAC
CHIFAC = _REAL (Read)
   The normalised chi-squared value which is used to determine if
   the algorithm should terminate is the mean of the following
   expression (the mean is taken over the entire input array,
   the margins used to pad the input array are excluded):

      ( D - S )**2 / ( CHIFAC*S - V )

   where D is the observed data value, S is the simulated data
   value based on the current version of the restored array, V is
   the variance of the error associated with D, and CHIFAC is the
   value of parameter CHIFAC.  Using 0 for CHIFAC results in the
   standard expression for chi-squared.  However, the algorithm
   sometimes has difficulty fitting bright features and so may
   not reach the required normalised chi-squared value.  Setting
   CHIFAC to 1 (as is done by the LUCY program in the STSDAS
   package within IRAF) causes larger data values to be given
   less weight in the chi-squared calculation, and so encourages
   lower chi-squared values. [1.0]
3 IN
IN= NDF (Read)
   The input NDF containing the observed data.
3 NITER
NITER = _INTEGER (Read)
   The maximum number of iterations to perform. [50]
3 OUT
OUT = NDF (Write)
   The restored output array.  The background specified by
   parameters BACK and BACKVAL will have been removed from this
   array.  The output is the same size as the input.  There is no
   VARIANCE component in the output, but any QUALITY values are
   propagated from the input to the output.
3 PSF
PSF = NDF (Read)
   An NDF holding an estimate of the Point-Spread Function (PSF)
   of the input array.  This could, for instance, be produced
   using the KAPPA application `PSF'. There should be no bad
   pixels in the PSF otherwise an error will be reported.  The
   PSF can be centred anywhere within the array, but the location
   of the centre must be specified using parameters XCENTRE and
   YCENTRE.  The PSF is assumed to have the value zero outside
   the supplied NDF.
3 SIGMA
SIGMA = _REAL (Read)
   The standard deviation of the noise in the observed data.
   This is only used if parameter VARIANCE is given the value
   FALSE.  The run-time default is an estimate of the noise
   based on the difference between adjacent pixel values in the
   observed data. []
3 START
START = NDF (Read)
   An NDF containing an initial guess at the restored array.
   This could, for instance, be the output from a previous run of
   LUCY, in which case the deconvolution would continue from the
   point it had previously reached.  If a null value is given,
   then the restored array is initialised to a constant value
   equal to the difference between the mean observed data value
   and the mean background value. [!]
3 SNYDER
SNYDER = _LOGICAL (Read)
   If TRUE then the variance of the observed data sample is added
   to both the numerator and denominator when evaluating the
   correction factor for each data sample.  This is the modified
   form of the R-L algorithm used by the LUCY program in the
   STSDAS package within IRAF. [TRUE]
3 THRESH
THRESH = _REAL (Read)
   The fraction of the PSF peak amplitude at which the extents of
   the PSF are determined.  These extents are used to determine
   the size of the margins used to pad the supplied input array.
   Lower values of THRESH will result in larger margins being
   used.  THRESH must be positive and less than 0.5.  [0.0625]
3 TITLE
TITLE = LITERAL (Read)
   A title for the output NDF.  A null (!) value means using the
   title of the input NDF. [!]
3 VARIANCE
VARIANCE = _LOGICAL (Read)
   If TRUE, then the variance of each input data sample will be
   obtained from the VARIANCE component of the input NDF.  An
   error is reported if this option is selected and the NDF has
   no VARIANCE component.  If FALSE, then a constant variance
   equal to the square of the value given for parameter SIGMA is
   used for all data samples.  The run-time default is TRUE if the
   input NDF has a VARIANCE component, and FALSE otherwise. []
3 WLIM
WLIM = _REAL (Read)
   If the input array contains bad pixels, then this parameter
   may be used to determine the number of good data values which
   must contribute to an output pixel before a valid value is
   stored in the restored array.  It can be used, for example, to
   prevent output pixels from being generated in regions where
   there are relatively few good data values to contribute to the
   restored result. It can also be used to `fill in' small areas
   (i.e. smaller than the PSF) of bad pixels.

   The numerical value given for WLIM specifies the minimum total
   weight associated with the good pixels in a smoothing box
   required to generate a good output pixel (weights for each
   pixel are defined by the normalised PSF).  If this specified
   minimum weight is not present, then a bad output pixel will
   result, otherwise a smoothed output value will be calculated.
   The value of this parameter should lie between 0.0 and
   1.0.  WLIM=0 causes a good output value to be created even if
   there is only one good input value, whereas WLIM=1 causes a
   good output value to be created only if all input values are
   good.  Values less than 0.5 will tend to reduce the number of
   bad pixels, whereas values larger than 0.5 will tend to
   increase the number of bad pixels.

   This threshold is applied each time a smoothing operation is
   performed.  Many smoothing operations are typically performed
   in a run of LUCY, and if WLIM is larger than 0.5 the effects
   of bad pixels will propagate further through the array at each
   iteration.  After several iterations this could result in there
   being no good data left.  An error is reported if this
   happens. [0.001]
3 XCENTRE
XCENTRE = _INTEGER (Read)
   The x pixel index of the centre of the PSF within the supplied
   PSF array.  The run-time default is the middle pixel (rounded
   down if there are an even number of pixels per line). []
3 YCENTRE
YCENTRE = _INTEGER (Read)
   The y pixel index of the centre of the PSF within the supplied
   PSF array. The run-time default is the middle line (rounded
   down if there are an even number of lines). []
2 Examples
lucy m51 star m51_hires
   This example deconvolves the array in the NDF called m51,
   putting the resulting array in the NDF called m51_hires.  The
   PSF is defined by the array in NDF star (the centre of the
   PSF is assumed to be at the central pixel).  The deconvolution
   terminates when a normalised chi-squared value of 1.0 is
   reached.

lucy m51 star m51_hires 0.5 niter=60
   This example performs the same function as the previous
   example, except that the deconvolution terminates when a
   normalised chi-squared value of 0.5 is reached, giving higher
   apparent resolution at the expense of extra spurious
   noise-based structure.  The maximum number of iterations is
   increased to 60 to give the algorithm greater opportunity to
   reach the reduced chi-squared value.

lucy m51 star m51_hires2 0.1 start=m51_hires
   This example continues the deconvolution started by the
   previous example in order to achieve a normalised chi-squared
   of 0.1.  The output array from the previous example is used to
   initialise the restored array.
2 Notes
- The convolutions required by the R-L algorithm are performed by
the multiplication of Fourier transforms.  The supplied input
array is extended by a margin along each edge to avoid problems
of wrap-around between opposite edges of the array.  The width of
this margin is about equal to the width of the significant part
of the PSF (as determined by parameter THRESH).  The application
displays the width of these margins.  The margins are filled by
replicating the edge pixels from the supplied input NDFs.

- The R-L algorithm works best for arrays which have zero
background.  Non-zero backgrounds cause dark rings to appear
around bright, compact sources.  To avoid this a background array
should be created before running LUCY and assigned to the
parameter BACK.  The SEGMENT and SURFIT applications within KAPPA
can be used to create such a background array.
2 Related_Applications
   KAPPA: FOURIER, MEM2D, WIENER.
2 Authors
DSB: David Berry (STARLINK)

MJC: Malcolm J. Currie (STARLINK)
2 History
 6-MAR-1995 (DSB):
    Original version, based on MEM2D and Rhys Morris's LUCY.

 1995 April 6 (MJC):
    Used conditional message reporting and modern-style variable
    declarations.  Added Related Applications.  Corrected typo's
    and made stylistic changes.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   VARIANCE, LABEL, TITLE, UNITS, WCS and HISTORY components of the
   input NDF and propagates all extensions.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.  Arithmetic
   is performed using single-precision floating point.

1 LUTABLE
Manipulates an image-display colour table.

Usage:

   lutable mapping coltab lut [device] ndf percentiles shade

Description:

   This application allows manipulation of the colour table of an
   image-display device provided some data are, according to the
   graphics database, already displayed upon the device.  A
   2-dimensional data array, stored in the input NDF structure, may
   be nominated to assist in defining the colour table via an
   histogram equalisation.  There are two stages to the running of
   this application.

   1. The way in which the lookup table (LUT) is to distributed
   amongst the pens (colour indices) of the colour table is
   required.  Some pens are reserved by KAPPA as a palette,
   particularly for annotation.  This application only modifies the
   unreserved portion of the colour table.

   2. The lookup table is now chosen from a programmed selection or
   read from an NDF.

   The two stages may be repeated cyclically if desired.  To exit the
   loop give the null response, !, to a prompt.  Looping will not
   occur if the lookup table and the distribution method are supplied
   on the command line.
2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   Name of the image display to be used.  The device must be in
   one of the following GNS categories: IMAGE_DISPLAY,
   IMAGE_OVERLAY, MATRIX_PRINTER, or WINDOW, and have at least 24
   greyscale intensities or colour indices when parameter FULL is
   FALSE, and at least 8 when FULL is TRUE.  It must also not
   reset when the device is opened (since the new colour table
   would be lost).  [Current image-display device]
3 COLTAB
COLTAB = LITERAL (Read)
   The lookup table required.  The options are listed below.
     "Negative"  - This is negative grey scale with black assigned
                   to the highest pen, and white assigned to the
                   lowest available pen.
     "Colour"    - This consists of eighteen standard colour
                   blocks.
     "Grey"      - This a standard grey scale.
     "External"  - Obtain a lookup table stored in an NDF's data
                   array.  If the table cannot be found in the
                   specified NDF or if it is not a LUT then a
                   grey scale is used.
3 FULL
FULL = _LOGICAL (Read)
   If TRUE the whole colour-table for the device is stored
   including the reserved pens.  This is necessary to save a
   colour table written by another package that does not reserve
   colour indices.  For colour tables produced by KAPPA this
   should be FALSE. [FALSE]
3 LUT
LUT = NDF (Read)
   Name of the NDF containing the lookup table as its data
   array.  The LUT must be 2-dimensional, the first dimension
   being 3, and the second being arbitrary.  The method used to
   compress or expand the colour table if the second dimension is
   different from the number of unreserved colour indices is
   controlled by parameter NN.  Also the LUT's values must lie in
   the range 0.0--1.0.
3 MAPPING
MAPPING = LITERAL (Read)
   The way in which the colours are to be distributed among
   the pens.  If NINTS is the number of unreserved colour indices
   the mapping options are described below.

     "Histogram"   - The colours are fitted to the pens using
                     histogram equalisation of an NDF, given by
                     parameter IN, so that the colours
                     approximately have an even distribution. In
                     other words each pen is used approximately
                     an equal number of times to display the
                     2-dimensional NDF array.  There must be an
                     existing image displayed.  This is
                     determined by looking for a DATA picture in
                     the database.  This is not foolproof as this
                     may be a line plot rather an image.
     "Linear"      - The colours are fitted directly to the pens.
     "Logarithmic" - The colours are fitted logarithmically to
                     the pens, with colour 1 given to the first
                     available pen and colour NINTS given to the
                     last pen.
3 NDF
NDF = NDF (Read)
   The input NDF structure containing the 2-dimensional data
   array to be used for the histogram-equalisation mapping of the
   pens.  The the data object referenced by the last DATA picture
   in the graphics database is reported.  This assumes that the
   displayed data picture was derived from the nominated NDF data
   array.
3 NN
NN = _LOGICAL (Read)
   If TRUE the input lookup table is mapped to the colour table by
   using the nearest-neighbour method.  This preserves sharp
   edges and is better for lookup tables with blocks of colour.
   If NN is FALSE linear interpolation is used, and this is
   suitable for smoothly varying colour tables. [FALSE]
3 PERCENTILES
PERCENTILES( 2 ) = _REAL (Read)
   The percentiles that define the range of the histogram to be
   equalised. For example, [25,75] would scale between the
   quartile values. It is advisable not to choose the limits
   less than 3 per cent and greater than 97.  The percentiles are
   only required for histogram mapping.  All values in the NDF's
   data array less than the value corresponding to the lower
   percentile will have the colour of the first unreserved pen.
   All values greater than the value corresponding to the upper
   percentile will have the colour of the last unreserved pen.
3 SHADE
SHADE = _REAL (Read)
   The type of shading.  This only required for the histogram
   mapping.  A value of -1 emphasises low values; +1 emphasises
   high values; 0 is neutral, all values have equal weight.  The
   shade must lie in the range -1 to +1.
2 Examples
lutable lo co
   Changes the colour table on the current image-display device
   to a series of coloured blocks whose size increase
   logarithmically with the table index number.

lutable li ex rococo
   This maps the lookup table stored in the NDF called rococo
   linearly to the colour table on the current image-display
   device.

lutable li ex rococo full
   This maps the lookup table stored in the NDF called rococo
   linearly to the full colour table on the current image-display
   device, i.e. ignoring the reserved pens.

lutable hi gr ndf=nebula shade=0 percentiles=[5,90]
   This maps the greyscale lookup table via histogram
   equalisation between the 5 and 90 percentiles of an NDF called
   nebula to the colour table on the current image-display
   device.  There is no bias or shading to white or black.
2 Related_Applications
   KAPPA: CRELUT, LUTFLIP, LUTHILITE, LUTREAD, LUTROT, LUTSAVE,
   LUTTWEAK, LUTVIEW; Figaro: COLOUR.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1991 Apr 14:
    NDF version based on the pre-V0.8 KAPPA version.

 1991 May 1 (MJC):
    Renamed IN parameter to NDF for consistency.

 1992 March 3 (MJC):
    Replaced AIF parameter-system calls by the extended PAR
    library.

 1994 April 29 (MJC):
    Allowed to work with only 8 pens when FULL is TRUE and 24 pens
    when FULL is FALSE.

 1995 May 1 (MJC):
    Works directly on double-precision NDFs.  Replaced old
    subroutines.  Use PSX for workspace.  Used modern-style
    commenting and variable declarations.
2 Implementation_Status
   -  Processing of bad pixels and automatic quality masking are
   supported for the image NDF

   -  All non-complex numeric data types can be handled.  Processing
   is performed using single- or double-precision floating point,
   as appropriate.

1 LUTBGYRW
Loads the BGYRW lookup table.

Usage:

   lutbgyrw

Description:

   This procedure loads the "BGYRW" lookup table with linear scaling
   into the current image-display device.  It is a continuous LUT
   starting with blue, followed by green, yellow, red and a splash of
   white.
2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   Name of the image display whose colour table is to be changed.
   [Current image-display device]
2 Notes
This is a procedure that calls LUTABLE.  Therefore, the 
parameter cannot be specified on the command line.  You will 
only be prompted for the DEVICE parameter if the current
image display is not suitable or not available.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1990 Apr 10 (MJC):
    Original version.

 1991 April 24 (MJC):
    NDF version of LUTABLE and extended the prologue.

1 LUTCOL
Loads the standard colour lookup table.

Usage:

   lutcol

Description:

   Procedure for loading the standard colour lookup table into
   the current image-display device with linear scaling.
2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   Name of the image display whose colour table is to be changed.
   [Current image-display device]
2 Notes
This is a procedure that calls LUTABLE.  Therefore, the parameter
cannot be specified on the command line.  You will only be
prompted for the DEVICE parameter if the current image display
is not suitable or not available.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1990 Mar 2 (MJC):
    Original version.

 1991 April 24 (MJC):
    NDF version of LUTABLE and extended the prologue.

1 LUTCONT
Loads a lookup table to give the display the appearance of a
contour plot.

Usage:

   lutcont

Description:

   This procedure loads a lookup table that gives a contour-plot
   appearance into the current image-display device.  The lookup table
   is mainly black with a set of white stripes and it is loaded with
   linear scaling.
2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   Name of the image display whose colour table is to be changed.
   [Current image-display device]
2 Notes
This is a procedure that calls LUTABLE.  Therefore, the parameter
cannot be specified on the command line.  You will only be
prompted for the DEVICE parameter if the current image display
is not suitable or not available.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1990 Apr 16 (MJC):
    Original version.

 1991 April 24 (MJC):
    NDF version of LUTABLE and extended the prologue.

1 LUTFC
Loads the standard false-colour lookup table.

Usage:

   lutfc

Description:

   This procedure loads the standard false-colour lookup table with
   linear scaling into the current image-display device.
2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   Name of the image display whose colour table is to be changed.
   [Current image-display device]
2 Notes
This is a procedure that calls LUTABLE.  Therefore, the parameter
cannot be specified on the command line.  You will only be
prompted for the DEVICE parameter if the current image display
is not suitable or not available.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1991 April 24 (MJC):
    Original version.

1 LUTFLIP
Flips the colour table of an image-display device.

Usage:

   lutflip [device] [plane]

Description:

   This routine `flips' the colour table of a nominated plane of
   an IDI-supported image display, such as X-windows.  The flip
   reverses the order of the colours, so that the first colour
   becomes the last and vice versa, etc.
2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   The name of the image-display device whose colour table is to
   be flipped.  The name of the base plane should be given even if
   the overlay colour table is to be flipped.
   [Current image display]
3 PLANE
PLANE = _INTEGER (Read)
   The number of the memory plane whose colour table is to be
   flipped.  If it is null the base (image) memory's colour table
   is reversed.  The base memory is 0 and overlays are numbered
   consecutively from 1.  For an Ikon the only overlay plane is 1.
   PLANE is only permitted to have a value in the range 0 to the
   number of planes minus one. [0]
2 Examples
lutflip
   This reverses the colour table on the current image-display
   device.

lutflip xwindows
   This reverses the colour table on the xwindows device.

lutflip ikon 1
   This flips the colour table on the Ikon overlay plane.
2 Notes
-  Only Ikons and X-windows are supported.

-  Reserved pens are not flipped.
2 Related_Applications
   KAPPA: CRELUT, LUTHILITE, LUTROT, LUTTWEAK.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1990 Apr 13 (MJC):
    Original version.

 1991 April 10 (MJC):
    Modified for colour-table management, specifically the reserved
    pens are not flipped.

 1991 June 5 (MJC):
    Altered for new, X-windows, IDI.  Capability 14 is 2**n rather
    than n.

 1992 March 26 (MJC):
    Replaced AIF parameter-system calls by the extended PAR
    library.

 1992 August 5 (MJC):
    Used new capability 18 to obtain the true number of
    colour-table entries, which may not be a power of 2, as
    returned by capability 14.

1 LUTGREY
Loads the standard greyscale lookup table.

Usage:

   lutgrey

Description:

   Procedure for loading the standard greyscale lookup table into
   the current image-display device with linear scaling.
2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   Name of the image display whose colour table is to be changed.
   [Current image-display device]
2 Notes
This is a procedure that calls LUTABLE.  Therefore, the parameter
cannot be specified on the command line.  You will only be
prompted for the DEVICE parameter if the current image display
is not suitable or not available.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1990 Mar 2 (MJC):
    Original version.

 1991 April 24 (MJC):
    NDF version of LUTABLE and extended the prologue.

1 LUTHEAT
Loads the heat lookup table.

Usage:

   lutheat

Description:

   This procedure loads the "heat" lookup table with linear scaling
   into the current image-display device.
2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   Name of the image display whose colour table is to be changed.
   [Current image-display device]
2 Notes
This is a procedure that calls LUTABLE.  Therefore, the parameter
cannot be specified on the command line.  You will only be
prompted for the DEVICE parameter if the current image display
is not suitable or not available.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1990 Apr 10 (MJC):
    Original version.

 1991 April 24 (MJC):
    NDF version of LUTABLE and extended the prologue.

1 LUTHILITE
Highlights a colour table of an image-display device.

Usage:

   luthilite colour [device] [plane] [view]

Description:

   This routine adjusts the colour table of a nominated plane of
   an IDI-supported image display, such as X-windows.  The adjustment
   is like a highlight pen, only here it can traverse the colour
   table, widen or thin is under mouse, joystick or trackerball
   button control; and the colour of the highlight is arbitrary.
   Thus particular features in an image may readily become visible.

   For an Ikon or X-windows, moving the mouse left or right shifts
   the highlight in the colour table towards lower and higher colour
   indices respectively.  The highlight does not rotate around the
   colour table.  Pressing the left button of the mouse reduces the
   width of the highlight by one colour index.  Pressing the centre
   button increases the width of the highlight by one colour index.
   Hitting the right-hand button ends the modification of the colour
   table.

   The colour table may be viewed during its manipulation without
   permanently altering the display memory.  The colour-table
   display is situated via the cursor, and will disappear once the
   highlighting is complete.
2 Parameters
For information on individual parameters, select from the list below:
3 COLOUR
COLOUR() = LITERAL (Read)
   The colour to be used as a highlight.  It is either of these
   alternatives.

     o  A named colour from the standard colour set, which may
     be abbreviated.  If the abbreviated name is ambiguous the
     first match is selected.  The case of the name is ignored.
     Some examples are "Seagreen", "Violet", and "Orchid".

     o  Normalised red, green, and blue intensities separated by
     commas or spaces.  Each value must lie in the range 0.0--1.0.
     For example, "1.0,1.0,0.5" would give a pale yellow.
3 DEVICE
DEVICE = DEVICE (Read)
   The name of the image-display device whose lookup table is to
   be adjusted.  The name of the base plane should be given even
   if the overlay lookup table is to be adjusted.
   [Current image display]
3 FULL
FULL = _LOGICAL (Read)
   If FULL is TRUE, the whole colour-table for the device is
   may be highlighted, including the reserved pens.  When FULL
   is FALSE, the reserved pens in the palette are unaltered.
   [FALSE]
3 PLANE
PLANE = _INTEGER (Read)
   The number of the memory plane whose lookup table is to be
   manipulated.  If it is null the base (image) memory's lookup
   table is adjusted.  The base memory is 0 and overlays are
   numbered consecutively from 1.  For an Ikon the only overlay
   plane is 1.  PLANE is only permitted to have a value in the
   range 0 to the number of planes minus one. [0]
3 VIEW
VIEW = _LOGICAL (Read)
   If TRUE the colour table is displayed during its manipulation.
   [FALSE]
2 Examples
luthilite red
   Highlights the colour table on the current image-display
   device with a red marker.

luthilite red full
   Highlights the colour table and palette on the current
   image-display device with a red marker.

luthilite skyblue xwindows
   Highlights the colour table on the xwindows device with a
   sky-blue marker.

luthilite [1.0,1.0,0.3] ikon 1
   Highlights the colour table on the Ikon overlay plane in a
   pale yellow.

luthilite red view
   Highlights the colour table on the current image-display
   device with a red marker.  The colour table is displayed
   during the highlighting.
2 Notes
-  Only Ikons and X-windows are supported.

-  Initially, the highlight has a width of two colour indices,
and it is located at the second lowest colour index.  The maximum
width of the highlight is the larger of six and a quarter of the
colour table, but may be narrower when there are less than 12
colour indices.  Should the highlight prove to be unsuitable, it
may be made invisible by reducing the width to zero.

-  The rate of motion of the highlight is a function of the
speed of cursor movement in addition to the cursor position.
For a given cursor displacement slow motion moves the highlight
more slowly, and faster motion moves it more rapidly.  This
permits both fine control and swift change in the highlight's
location.
2 Related_Applications
   KAPPA: CRELUT, LUTFLIP, LUTROT, LUTTWEAK.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1991 April 30 (MJC):
    Original version.

 1991 June 5 (MJC):
    Altered for new, X-windows, IDI.  Capability 14 is 2**n rather
    than n.

 1991 July 22 (MJC):
    Converted RGB parameter to the more-sophisticated COLOUR.

 1991 November 15 (MJC):
    Made exit trigger number 2.  Inceased maximum number of
    triggers to 64.

 1991 November 21 (MJC):
    Fixed bug so that highlight may appear in but one colour index.

 1992 February 10 (MJC):
    Permit the highlight width to be zero.  Normalised the
    highlight displacement by the effective number of colour
    indices.

 1992 February 29 (MJC):
    Added fine tuning using the cursor speed, and computed the
    displacements in floating point to give a smoother feel.

 1992 March 26 (MJC):
    Replaced AIF parameter-system calls by the extended PAR
    library.

 1992 August 5 (MJC):
    Used new capability 18 to obtain the true number of
    colour-table entries, which may not be a power of 2, as
    returned by capability 14.

 1992 November 24 (MJC):
    Reinstated the one-to-one correspondence between the lookup
    table and the intensity transformation table, lost by an
    undocumented change to X-windows driver.

 1994 April 29 (MJC):
    Added FULL parameter.

1 LUTIKON
Loads the default Ikon lookup table.

Usage:

   lutikon

Description:

   This procedure loads the default Ikon lookup table with linear
   scaling into the current image-display device.
2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   Name of the image display whose colour table is to be changed.
   [Current image-display device]
2 Notes
-  This is a procedure that calls LUTABLE.  Therefore, the parameter
   cannot be specified on the command line.  You will only be
   prompted for the DEVICE parameter if the current image display
   is not suitable or not available.

-  The device need not be an Ikon.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1990 July 9 (MJC):
    Original version.

 1991 April 24 (MJC):
    NDF version of LUTABLE and extended the prologue.

1 LUTNEG
Loads the standard negative greyscale lookup table.

Usage:

   lutneg

Description:

   Procedure for loading the standard greyscale lookup table into
   the current image-display device with negative linear scaling.
2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   Name of the image display whose colour table is to be changed.
   [Current image-display device]
2 Notes
This is a procedure that calls LUTABLE.  Therefore, the parameter
cannot be specified on the command line.  You will only be
prompted for the DEVICE parameter if the current image display
is not suitable or not available.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1990 Mar 2 (MJC):
    Original version.

 1991 April 24 (MJC):
    NDF version of LUTABLE and extended the prologue.

1 LUTRAMPS
Loads the coloured-ramps lookup table.

Usage:

   lutramps

Description:

   This procedure loads the coloured-ramps lookup table with linear
   scaling into the current image-display device.
2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   Name of the image display whose colour table is to be changed.
   [Current image-display device]
2 Notes
This is a procedure that calls LUTABLE.  Therefore, the parameter
cannot be specified on the command line.  You will only be
prompted for the DEVICE parameter if the current image display
is not suitable or not available.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1990 Apr 10 (MJC):
    Original version.

 1991 April 24 (MJC):
    NDF version of LUTABLE and extended the prologue.

1 LUTREAD
Loads an image-display lookup table from an NDF.

Usage:

   lutread lut

Description:

   This application reads a lookup table stored in an NDF with
   the standard format, and loads it into the current image-display
   device.
2 Arguments
For information on individual arguments, select from the list below:
3 LUT
LUT = LITERAL (Given)
   The file containing the lookup table.  It is passed to the
   parameter LUT but not validated.
2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   Name of the image display whose colour table is to be changed.
   [Current image-display device]
3 LUT
LUT = NDF (Read)
   Name of the NDF containing the lookup table as its data
   array.  The LUT must be 2-dimensional, the first dimension
   being 3, and the second being arbitrary.  Linear interpolation
   is used to compress or expand the colour table if the second
   dimension is different from the number of unreserved colour
   indices.  Also the LUT's values must lie in the range 0.0--1.0.
2 Notes
This is a procedure that calls LUTABLE.  Therefore, the parameters
cannot be specified on the command line.  You will only be
prompted for the parameters if the device is not suitable or not
available, and/or the lookup table file could not be accessed.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1990 Mar 2 (MJC):
    Original version.

 1991 April 24 (MJC):
    NDF version of LUTABLE and extended the prologue.

 1995 October 2 (MJC):
    Made LUT an optional argument from ICL.

1 LUTROT
Rotates the colour table of an image-display device.

Usage:

   lutrot [device] [plane]

Description:

   This routine rotates the colour table of a nominated plane of
   an IDI-supported image display, such as X-windows.  The rotation
   is under mouse, joystick or trackerball button control.

   For an Ikon or X-windows, moving the mouse left or right
   rotates the colour table towards lower and higher pen numbers
   respectively.  Pressing the left button of the mouse resets the
   colour table to its input state, and hitting the right-hand
   button ends the rotation.
2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   The name of the image-display device whose colour table is to
   be rotated.  The name of the base plane should be given even if
   the overlay colour table is to be rotated.
   [Current image-display device]
3 FULL
FULL = _LOGICAL (Read)
   If FULL is TRUE, the whole colour-table for the device is
   rotated, including the reserved pens.  When FULL is FALSE, the
   reserved pens in the palette are unaltered.  [FALSE]
3 PLANE
PLANE = _INTEGER (Read)
   The number of the memory plane whose colour table is to be
   rotated.  If it is null the base (image) memory's colour table
   is rotated.  The base memory is 0 and overlays are numbered
   consecutively from 1.  For an Ikon the only overlay plane is 1.
   PLANE is only permitted to have a value in the range 0 to the
   number of planes minus one. [0]
2 Examples
lutrot
   This enables rotation of the colour table on the current
   image-display device.

lutrot xwindows
   This enables rotation of the colour table on the xwindows
   device.

lutrot full
   This enables rotation of the colour table and palette on the
   current image-display device.

lutrot ikon 1
   This enables rotation of the colour table on the Ikon overlay
   plane.
2 Notes
-  Only Ikons and X-windows are supported.

-  The rate of motion of the colour table is a function of the
speed of cursor movement in addition to the cursor position.
For a given cursor displacement slow motion rotates the colour
table more slowly, and faster motion moves it more rapidly.  This
permits both fine control and swift rotation.
2 Related_Applications
   KAPPA: CRELUT, LUTFLIP, LUTHILITE, LUTTWEAK.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1990 Apr 15 (MJC):
    Original version.

 1991 April 10 (MJC):
    Modified for colour-table management, specifically the reserved
    pens are not rotated.

 1991 June 5 (MJC):
    Altered for new, X-windows, IDI.  Capability 14 is 2**n rather
    than n.

 1991 November 15 (MJC):
    Made exit trigger number 2.  Inceased maximum number of
    triggers to 64.

 1992 February 10 (MJC):
    Normalised the rotation displacement by the effective number
    of colour indices.

 1992 February 29 (MJC):
    Added fine tuning using the cursor speed, and computed the
    displacements in floating point to give a smoother feel.

 1992 March 26 (MJC):
    Replaced AIF parameter-system calls by the extended PAR
    library.

 1992 August 5 (MJC):
    Used new capability 18 to obtain the true number of
    colour-table entries, which may not be a power of 2, as
    returned by capability 14.

 1994 April 29 (MJC):
    Added FULL parameter.

1 LUTSAVE
Saves the current colour table of an image-display device in an
NDF.

Usage:

   lutsave lut [device] [plane]

Description:

   This routine reads the colour table of a nominated plane of
   an IDI-supported image display, such as X-windows, and then copies
   it to an NDF LUT file.
2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   The name of the image-display device whose colour table is to
   be saved.  The name of the base plane should be given even if
   the overlay colour table is to be saved.
   [Current image display]
3 FULL
FULL = _LOGICAL (Read)
   If TRUE the whole colour-table for the device is stored
   including the reserved pens.  This is necessary to save a
   colour table written by another package that does not reserve
   colour indices.  For colour tables produced by KAPPA this
   should be FALSE. [FALSE]
3 LUT
LUT = NDF (Write)
   The output NDF into which the colour table is to be stored.
   Its second dimension equals the number of colour-table
   entries that are stored.  This will be less than the
   total number of colour indices on the device if FULL is FALSE.
3 PLANE
PLANE = _INTEGER (Read)
   The number of the memory plane whose colour table is to be
   saved.  If it is null the base (image) memory's colour table
   is reversed.  The base memory is 0 and overlays are numbered
   consecutively from 1.  For an Ikon the only overlay plane is 1.
   PLANE is only permitted to have a value in the range 0 to the
   number of planes minus one. [0]
3 TITLE
TITLE = LITERAL (Read)
   The title for the output NDF. ["KAPPA - Lutsave"]
2 Examples
lutsave pizza
   This saves the current colour table on the current
   image-display device to an NDF called pizza.

lutsave ramps ikon 1
   This saves the current colour table on the Ikon overlay plane
   an NDF called ramps.

lutsave redshift full
   This saves in full the current colour table on the current
   image-display device to an NDF called redshift.
2 Notes
-  Only Ikons and X-windows are supported.

-  Only the non-reserved portion of the colour table is saved.
2 Related_Applications
   KAPPA: CRELUT, LUTFLIP, LUTHILITE, LUTREAD, LUTROT, LUTTWEAK.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1990 Apr 13 (MJC):
    Original version.

 1991 April 10 (MJC):
    Modified for colour-table management, specifically the reserved
    pens are not saved.

 1991 June 5 (MJC):
    Altered for new, X-windows, IDI.  Capability 14 is 2**n rather
    than n.

 1992 March 26 (MJC):
    Replaced AIF parameter-system calls by the extended PAR
    library.

 1992 August 5 (MJC):
    Used new capability 18 to obtain the true number of
    colour-table entries, which may not be a power of 2, as
    returned by capability 14.

1 LUTSPEC
   Loads a spectrum-like lookup table.

Usage:

   lutspec

Description:

   This procedure loads an optical-spectrum-like lookup table with linear
   scaling into the current image-display device.
2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   Name of the image display whose colour table is to be changed.
   [Current image-display device]
2 Notes
This is a procedure that calls LUTABLE.  Therefore, the parameter
cannot be specified on the command line.  You will only be
prompted for the DEVICE parameter if the current image display
is not suitable or not available.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1990 Apr 16 (MJC):
    Original version.

 1991 April 24 (MJC):
    NDF version of LUTABLE and extended the prologue.

1 LUTTWEAK
Tweaks a colour table of an image-display device.

Usage:

   luttweak [device] [plane] [view]

Description:

   This routine adjusts the colour table of a nominated plane of
   an IDI-supported image display, such as X-windows.  The adjustment
   is under mouse, joystick or trackerball button control.

   For an Ikon or X-windows, moving the mouse left or right shifts
   the colour table towards lower and higher colour indices
   respectively.  Moving the mouse up stretches the lookup table,
   and moving it down squashes the lookup table until it disappears,
   then the lookup table is flipped.  If the lookup table is
   reversed, moving down stretches, and moving up squashes.
   Pressing the left button of the mouse resets the colour table to
   its input state.  Pressing the centre button alters the way in
   which a squashed lookup table is padded.  The two states are
   white or to use the first and last colours of the input lookup
   table, the sense depending on whether the lookup table is
   flipped.  Hitting the right-hand button ends the modification of
   the colour table.

   The colour table may be viewed during its manipulation without
   permanently altering the display memory.  The colour-table
   display is situated via the cursor, and will disappear once the
   tweaking is complete.
2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   The name of the image-display device whose lookup table is to
   be adjusted.  The name of the base plane should be given even
   if the overlay lookup table is to be adjusted.
   [Current image-display device]
3 FULL
FULL = _LOGICAL (Read)
   If FULL is TRUE, the whole colour-table for the device is
   may be modified, including the reserved pens.  When FULL
   is FALSE, the reserved pens in the palette are unaltered.
   [FALSE]
3 PLANE
PLANE = _INTEGER (Read)
   The number of the memory plane whose lookup table is to be
   manipulated.  If it is null the base (image) memory's lookup
   table is adjusted.  The base memory is 0 and overlays are
   numbered consecutively from 1.  For an Ikon the only overlay
   plane is 1.  PLANE is only permitted to have a value in the
   range 0 to the number of planes minus one. [0]
3 VIEW
VIEW = _LOGICAL (Read)
   If TRUE the colour table is displayed during its manipulation.
   [FALSE]
2 Examples
luttweak
   Tweaks the colour table on the current image-display device.

luttweak xwindows
   Tweaks the colour table on the xwindows device.

luttweak xwindows full
   Tweaks the colour table and palette on the xwindows device.

luttweak ikon 1
   Tweaks the colour table on the Ikon overlay plane.

luttweak view
   Tweaks the colour table on the current image-display device.
   The colour table is displayed during the tweaking.
2 Notes
-  Only Ikons and X-windows are supported.

-  The speed of the colour-table rotation is not linearly
proportional to the mouse displacement; the speed of displacement
tunes the effect so that slow motion makes a small change than
a faster motion.  The squashing and stretching factors are also
non-linear.
2 Related_Applications
   KAPPA: CRELUT, LUTFLIP, LUTHILITE, LUTROT.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1991 April 22 (MJC):
    Original version.

 1991 June 5 (MJC):
    Altered for new, X-windows, IDI.  Capability 14 is 2**n rather
    than n.

 1991 November 15 (MJC):
    Made exit trigger number 2.  Inceased maximum number of
    triggers to 64.

 1992 February 10 (MJC):
    Normalised the rotation displacement by the effective number
    of colour indices.

 1992 February 19 (MJC):
    Added fine tuning using the cursor speed, and computed the
    displacements in floating point to give a smoother feel.

 1992 March 26 (MJC):
    Replaced AIF parameter-system calls by the extended PAR
    library.

 1992 August 5 (MJC):
    Used new capability 18 to obtain the true number of
    colour-table entries, which may not be a power of 2, as
    returned by capability 14.

 1992 November 24 (MJC):
    Reinstated the one-to-one correspondence between the lookup
    table and the intensity transformation table, lost by an
    undocumented change to X-windows driver.

 1994 April 29 (MJC):
    Added FULL parameter.

1 LUTVIEW
Draws a colour-table key.

Usage:

   lutview [mode] [low] [high] [curpic] [device]

Description:

   This application displays a ramp of colours on the specified image
   display device using the whole of the current colour table (excluding
   the low 16 pens which are reserved for axis annotation ,etc). By
   default, numerical values are displayed along the long edge of the
   ramp. The values corresponding to the maximum and minimum colour
   index are supplied using parameters HIGH and LOW. Intermediate colour
   indices are labelled with values which are linearly interpolated
   between these two extreme values.

   The rectangular area in which the ramp (plus annotations) is drawn
   may be specified either using a graphics cursor, or by specifying the
   co-ordinates of two corners using parameters LBOUND and UBOUND.
   Additionally, there is an option to make the ramp fill the current
   picture. See parameter MODE. The ramp may be constrained to the
   current picture using parameter CURPIC.

   The appearance of the annotation my be controlled in detail using
   the STYLE parameter.
2 Parameters
For information on individual parameters, select from the list below:
3 CURPIC
CURPIC = _LOGICAL (Read)
   If CURPIC is TRUE, the colour table key is to lie within the
   current picture, otherwise the new picture can lie anywhere
   within the BASE picture.  This parameter ignored if the
   current-picture mode is selected. [FALSE]
3 DEVICE
DEVICE = DEVICE (Read)
   The image-display device on which the colour table is to be
   drawn.  The device must be in one of the following GNS
   categories: IMAGE_DISPLAY, IMAGE_OVERLAY, MATRIX_PRINTER, or
   WINDOW, and have at least 24 greyscale intensities or colour
   indices.  It must also not reset when the device is opened
   (since the colour table would be lost) unless parameter LUT
   does not have the null value.  [Current image-display device]
3 FRAME
FRAME = LITERAL (Read)
   Specifies the co-ordinate Frame of the positions supplied using
   parameters LBOUND and UBOUND. The following Frames will always
   be available:

   - GRAPHICS -- gives positions in millimetres from the bottom left
   corner of the plotting surface.

   - BASEPIC -- gives positions in a normalised system in which the
   bottom left corner of the plotting surface is (0,0) and the
   shortest dimension of the plotting surface has length 1.0. The
   scales on the two axes are equal.

   - CURPIC -- gives positions in a normalised system in which the
   bottom left corner of the current picture is (0,0) and the
   shortest dimension of the current picture has length 1.0. The
   scales on the two axes are equal.

   There may be additional Frames available, describing previously
   displayed data. If a null value is supplied, the current Frame
   associated with the displayed data (if any) is used. This parameter
   is only accessed if parameter MODE is set to "XY". [BASEPIC]
3 HIGH
HIGH = _REAL (Read)
   The value corresponding to the maximum colour index.  It is
   used to calculate the annotation scale for the key.  If it
   is null (!) the maximum colour index is used.
   [Current display linear-scaling maximum]
3 LBOUND
LBOUND = LITERAL (Read)
   Co-ordinates of the lower left corner of the rectangular region
   containing the colour ramp and annotation, in the co-ordinate
   Frame specified by parameter FRAME (supplying a colon ":" will
   display details of the selected co-ordinate Frame). The position
   should be supplied as a list of formatted axis values separated
   by spaces or commas. A null (!) value causes the lower left corner
   of the BASE or (if CURPIC is TRUE) current picture to be used.
3 LOW
LOW = _REAL (Read)
   The value corresponding to the minimum colour index.  It is
   used to calculate the annotation scale for the key.  If it
   is null (!) the minimum colour index is used.
   [Current display linear-scaling minimum]
3 LUT
LUT = NDF (Read)
   Name of the NDF containing a lookup table as its data array;
   the lookup table is written to the image-display's colour
   table.  The purpose of this parameter is to provide a means of
   controlling the appearance of the image on certain devices,
   such as colour printers, that do not have a dynamic colour
   table, i.e. the colour table is reset when the device is
   opened.  If used with dynamic devices, such as windows or
   Ikons, the new colour table remains after this application has
   completed.  A null, !, means that the existing colour table
   will be used.

   The LUT must be two-dimensional, the first dimension
   being 3, and the second being arbitrary.  The method used to
   compress or expand the colour table if the second dimension is
   different from the number of unreserved colour indices is
   controlled by parameter NN.  Also the LUT's values must lie in
   the range 0.0--1.0. [!]
3 MODE
MODE = LITERAL (Read)
   Method for defining the position, size and shape of the
   rectangular region containing the colour ramp and annotation.
   The options are:

   - "Cursor" --  The graphics cursor is used to supply two
   diametrically opposite corners or the region.

   - "XY" -- The parameters LBOUND and UBOUND are used to get the
   limits.

   - "Picture" -- The whole of the current picture is used.
   Additional positioning options are available by using other
   KAPPA applications to create new pictures and then specifying
   the picture mode.

   ["Cursor"]
3 NN
NN = _LOGICAL (Read)
   If NN is TRUE, the input lookup table is mapped to the colour
   table by using the nearest-neighbour method.  This preserves
   sharp edges and is better for lookup tables with blocks of
   colour.  If NN is FALSE, linear interpolation is used, and
   this is suitable for smoothly varying colour tables.  NN is
   ignored unless LUT is not null. [FALSE]
3 STYLE
STYLE = GROUP (Read)
   A group of attribute settings describing the plotting style to use
   for the annotation.

   A comma-separated list of strings should be given in which each
   string is either an attribute setting, or the name of a text file
   preceded by an up-arrow character "^". Such text files should
   contain further comma-separated lists which will be read and
   interpreted in the same manner. Attribute settings are applied in
   the order in which they occur within the list, with later settings
   over-riding any earlier settings given for the same attribute.

   Each individual attribute setting should be of the form:

      <name>=<value>

   where <name> is the name of a plotting attribute, and <value> is
   the value to assign to the attribute. Default values will be
   used for any unspecified attributes. All attributes will be
   defaulted if a null value (!) is supplied. See section "Plotting
   Attributes" in SUN/95 for a description of the available
   attributes. Any unrecognised attributes are ignored (no error is
   reported).

   Axis 1 is always the "data value" axis, whether it is displayed
   horizontally or vertically. So for instance, to set the label
   for the data value axis, assign a value to "Label(1)" in the
   supplied style. [current value]
3 UBOUND
UBOUND = LITERAL (Read)
   Co-ordinates of the upper right corner of the rectangular region
   containing the colour ramp and annotation, in the co-ordinate
   Frame specified by parameter FRAME (supplying a colon ":" will
   display details of the selected co-ordinate Frame). The position
   should be supplied as a list of formatted axis values separated
   by spaces or commas. A null (!) value causes the lower left corner
   of the BASE or (if CURPIC is TRUE) current picture to be used.
2 Examples
lutview
   Draws an annotated colour table at a position selected via
   the cursor on the current image-display device.

lutview style="'edge(1)=right,label(1)=Data value in m31'"
   As above, but the data values are labelled on the right edge of
   the box, and the values are labelled with the string "Data value
   in m31".

lutview style='"textlab(1)=0,width(border)=3,colour(border)=white"'
   No textual label is drawn for the data values, and a thicker than
   usual white box is drawn around the colour ramp.

lutview style="'textlab(1)=0,numlab(1)=0,majticklen(1)=0'"
   Only the border is drawn around the colour ramp.

lutview style="'textlab(1)=0,numlab(1)=0,majticklen(1)=0,border=0'"
   No annotation at all is drawn.

lutview p
   Draws a colour table that fills the current picture on the
   current image-display device.

lutview curpic
   Draws a colour table within the current picture positioned
   via the cursor.

lutview xy lut=my_lut device=ps_p lbound=[0.92,0.2] ubound=[0.98,0.8]
   Draws the colour table in the NDF called my_lut with an
   outline within the BASE picture on the device ps_p, defined
   by the x-y bounds (0.92,0.2) and (0.98,0.8).  In other words
   the plot is to the right-hand side with increasing colour
   index with increasing y position.
2 Related_Applications
   KAPPA: DISPLAY, LUTABLE; Figaro: COLOUR.
2 Authors
MJC: Malcolm J. Currie  (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 15-OCT-1999 (DSB):
    Original AST/PGPLOT version. Based on previous version by MJC.

1 LUTWARM
Loads the warm lookup table.

Usage:

   lutwarm

Description:

   This procedure loads the "warm" lookup table with linear scaling
   into the current image-display device.  It is a continuous LUT
   going from black to white, passing through warm shades of yellow
   and brown.
2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   Name of the image display whose colour table is to be changed.
   [Current image-display device]
2 Notes
This is a procedure that calls LUTABLE.  Therefore, the 
parameter cannot be specified on the command line.  You will 
only be prompted for the DEVICE parameter if the current
image display is not suitable or not available.
2 Authors
DSB: David S. Berry (STARLINK)
2 History
 2000 Oct 31 (MJC):
    Original version.

1 LUTZEBRA
Loads a pseudo-contour lookup table.

Usage:

   lutzebra

Description:

   This procedure loads a pseudo-contour lookup table with linear
   scaling into the current image-display device. The lookup table
   is mainly black with a set of white stripes.
2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   Name of the image display whose colour table is to be changed.
   [Current image-display device]
2 Notes
This is a procedure that calls LUTABLE.  Therefore, the parameter
cannot be specified on the command line.  You will only be
prompted for the DEVICE parameter if the current image display
is not suitable or not available.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1990 Apr 10 (MJC):
    Original version.

 1991 April 24 (MJC):
    NDF version of LUTABLE and extended the prologue.
1 MAKESURFACE
Creates a 2-dimensional NDF from the coefficients of a polynomial
surface

Usage:

   makesurface in out [like] type=? lbound=? ubound=? xlimit=?
      ylimit=?

Description:

   The coefficients describing a 2-dimensional polynomial surface
   are read from a SURFACEFIT extension in an NDF (written by
   FITSURFACE), and are used to create a 2-dimensional surface of
   specified size and extent.  The surface is written to a new NDF.

   The size and extent of the surface may be obtained from a template
   NDF or given explicitly.

   Elements in the new NDF outside the defined range of the
   polynomial will be set to bad values.
2 Parameters
For information on individual parameters, select from the list below:
3 IN
IN  = NDF (Read)
   The NDF containing the SURFACEFIT extension.
3 LBOUND
LBOUND( 2 ) = _INTEGER (Read)
   Lower bounds of new NDF (if LIKE=!).  The suggested defaults
   are the lower bounds of the IN NDF.
3 LIKE
LIKE = NDF (Read)
   An optional template NDF which, if specified, will be used to
   define the labels, size, shape, data type and axis range of
   the new NDF.  If a null response (!) is given, the label,
   units, axis labels, and axis units are taken from the IN NDF.
   The task prompts for the data type and bounds, using those of
   the IN NDF as defaults, and the axis ranges. [!]
3 OUT
OUT = NDF (Write)
   The new NDF to contain the surface fit.
3 TITLE
TITLE = LITERAL (Read)
   A title for the new NDF.  If a null response (!) is given,
   the title will be propagated either from LIKE, or from IN
   if LIKE=!. [!]
3 TYPE
TYPE = LITERAL (Read)
   Data type for the new NDF (if LIKE=!).  It must be one of
   the following: "_DOUBLE", "_REAL", "_INTEGER", "_WORD",
   "_BYTE", "_UBYTE".  The suggested default is the data type of
   the data array in the IN NDF.
3 UBOUND
UBOUND( 2 ) = _INTEGER (Read)
   Upper bounds of new NDF (if LIKE=!).  The suggested defaults
   are the upper bounds of the IN NDF.
3 VARIANCE
VARIANCE = _LOGICAL (Read)
   If TRUE, a variance array is created in the output NDF
   provided the SURFACEFIT.FIT structure contains variance
   information.
3 XLIMIT
XLIMIT( 2 ) = _DOUBLE (Read)
   Co-ordinates of the left then right edges of the x axis (if
   LIKE=!).  The suggested defaults are respectively the minimum
   and maximum x co-ordinates of the IN NDF.
3 YLIMIT
YLIMIT( 2 ) = _DOUBLE (Read)
   Co-ordinates of the bottom then top edges of the y axis (if
   LIKE=!).  The suggested defaults are respectively the minimum
   and maximum y co-ordinates of the IN NDF.
2 Examples
makesurface flatin flatout \
   This generates a 2-dimensional image in the NDF called flatout
   using the surface fit stored in the 2-dimensional NDF flatin.
   The created image has the same data type, bounds, and
   co-ordinate limits as the data array of flatin.

makesurface flatin flatout type=_wo lbound=[1,1] ubound=[320,512]
   As the previous example, except that the data array in flatout
   has data type _WORD, and the bounds of flatout are 1:320,
   1:512.

makesurface flatin flatout like=flatin
   This has the same effect as the first example, except it has
   an advantage.  If the current co-ordinate system is "Data" and
   either or both of the axes are inverted (values decrease with
   increasing pixel index), the output image will be correctly
   oriented.

makesurface flatin flatout template title="Surface fit"
   This generates a 2-dimensional image in the NDF called flatout
   using the surface fit stored in the 2-dimensional NDF flatin.
   The created image inherits the attributes of the NDF called
   template.  The title of flatout is "Surface fit".
2 Notes
-  The polynomial surface fit is stored in SURFACEFIT extension,
component FIT of type POLYNOMIAL, variant CHEBYSHEV.  This
extension is created by FITSURFACE.    Also read from the
SURFACEFIT extension is the co-ordinate system (component COSYS).

-  When LIKE=!, COSYS="Data" and the original NDF had an axis that
decreased with increasing pixel index, you may want to flip the
co-ordinate limits (via parameters XLIMIT or YLIMIT) to match
the original sense of the axis, otherwise the created surface will
be flipped with respect to the image from which it was fitted.
2 Related_Applications
   KAPPA: FITSURFACE, SURFIT.
2 Authors
SMB: Steven M. Beard (ROE)

MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 11-May-1993 (SMB):
    Original version.

 03-Jun-1993 (SMB):
    Modified to read the new data structure produced by FITSURFACE.

 07-Dec-1993 (SMB):
    Comments tidied up.

 1995 August 8 (MJC):
    Used a modern prologue and completed it.  Corrected the
    description of LIKE and some data types.  Merged XMIN and XMAX
    into parameter XLIMIT, and YMIN and YMAX into YLIMIT.  Renamed
    many of the routines and called existing subroutines rather
    than use SMB's new ones.  Read COSYS component from the
    FITSURFACE.  Restructured for clarity and efficiency.  Removed
    PAR_GETs for labels and units when LIKE=!.  Insisted on two
    significant dimensions in IN and LIKE.

 1997 May 10 (MJC):
    Added support for creating a variance array.  Obtained
    workspace by PSX for efficiency.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   VARIANCE, LABEL, TITLE, UNITS, WCS and HISTORY components of an NDF
   data structure and propagates all extensions.  However, neither
   QUALITY nor a SURFACEFIT extension is propagated when LIKE is not
   null.

   -  All non-complex numeric data types can be handled.  Processing
   is performed in single- or double-precision floating point, as
   appropriate.
1 MANIC
    Converts all or part of a data array from one dimensionality
    to another.
 
   This application copies or converts all or part of a 1, 2 or
   3-dimensional data array to one or more output data arrays, each
   of 1, 2 or 3 dimensions. All data arrays are stored in IMAGE
   structures. Windows may be set in any of the dimensions of the
   input data array. All or part of the input array may be projected
   on to any of the rectangular planes or axes of the input before
   being written to an output array; or a 1- or 2-dimensional data
   array may be grown to more dimensions to fill an output data
   array. Many output data arrays, each of a different configuration
   if required, may be extracted from a single input data array with
   one call to the routine.
2 AUTHORS
   C D Pike    (RGO::CDP)
   Roger Wood  (RGO::RW)
   Dave Baines (ROE::ASOC5)
   Malcolm Currie  STARLINK (RAL::CUR)
2 BUGS
   None known.
2 HISTORY
   15/08/1981 : Original version    (RGO::CDP)
   30/03/1983 : Amended  version    (RGO::RW)
   21/02/1984 : Revised SSE version (ROE::ASOC5)
   1986 Aug 7 : Standardised prologue formatting. Status check on
                entry added (RAL::CUR).
   1986 Aug 29: Renamed APP routines into AIF_. Added argument
                section to prologue and tidied. Revised output
                of dimensions via DIMLST routine (RAL::CUR).
   1986 Oct 30: Allowed for bad pixel handling in routines MA3TO1,
                MA3TO2 and MA2TO1 for which workspace of the
                appropriate dimension is now found (RAL::CUR).
   1987 Oct 15: Reordered tidying and extra status checks
                (RAL::CUR)
   1988 Mar 16: Substituted AIF_ANTMP to annul workspace
                (RAL::CUR).
   1988 Mar 17: Referred to `array' rather than `image'
                (RAL::CUR).
   1988 Jun 20: More reporting of error context (RAL::CUR).
   1989 Jun 13: Allow for processing primitive NDFs (RAL::CUR)
   1989 Aug  8: Passed array dimensions as separate variables
                to COPY2D, COPY3D, MA1TO2, MA1TO3, MA2TO1, MA2TO3,
                MA3TO1 and MA3TO2 (RAL::CUR).
   1989 Dec 21: Workspace managed by AIF_TEMP (RAL::CUR).
   1991 Oct 25: Propagates UNITS, LABEL and HISTORY (RAL::CUR).
   1992 Feb 25: Limited processing of simple NDFs (RAL::CUR).
   1992 Mar  3: Replaced AIF parameter-system calls by the extended
                PAR library (RAL::CUR).
2 PARAMETERS
   INPUT      = IMAGE( READ )
       IMAGE structure holding the input data array.
   ONDIM      = INTEGER( READ )
       Dimensionality of an output data array.
   XLIMITS(2) = INTEGER( READ )
       The X-axis window on the input data array to be used in
         forming an output data array.
   YLIMITS(2) = INTEGER( READ )
       The Y-axis window on the input data array to be used in
         forming an output data array.
   ZLIMITS(2) = INTEGER( READ )
       The Z-axis window on the input data array to be used in
         forming an output data array.
   XRANGE(2)  = INTEGER( READ )
       The X-axis range for summation in the input data array in
         forming an output data array.
   YRANGE(2)  = INTEGER( READ )
       The Y-axis range for summation in the input data array in
         forming an output data array.
   ZRANGE(2)  = INTEGER( READ )
       The Z-axis range for summation in the input data array in
         forming an output data array.
   EPLANE     = CHAR( READ )
       Plane to be extracted from the input 3-d data array.  The
         options are 'XY', 'YZ', 'ZX', 'YX', 'ZY', 'XZ'.
   GPLANE     = CHAR( READ )
       Input 2-d data array forms this plane when being grown into
         a 3-d data array.  The options are 'XY', 'YZ', 'ZX', 'YX',
         'ZY', 'XZ'.
   ELINE1     = CHAR( READ )
       Axis of input 2-d data array to be extracted to form an output
         1-d data array.  The alternatives are 'X', 'Y'.
   ELINE2     = CHAR( READ )
       Axis of input 3-d data array to be extracted to form an output
         1-d data array.  The options are 'X', 'Y', 'Z'.
   GLINE1     = CHAR( READ )
       Input 1-d data array will form this axis of an output 2-d
         data array.  The alternatives are 'X', 'Y'.
   GLINE2     = CHAR( READ )
       Input 1-d data array will form this axis of an output 3-d
         data array.  The options are 'X', 'Y', 'Z'.
   XDIM       = INTEGER( READ )
       X-dimension of output 2-d or 3-d data array grown from input
         1-d or 2-d data array.
   YDIM       = INTEGER( READ )
       Y-dimension of output 2-d or 3-d data array grown from input
         1-d or 2-d data array.
   ZDIM       = INTEGER( READ )
       Z-dimension of output 2-d or 3-d data array grown from input
         1-d or 2-d data array.
   OUTPUT     = IMAGE( WRITE )
       IMAGE structure to hold an output data array.
   OTITLE     = CHAR( WRITE )
       Title for IMAGE structure holding an output data array.
   LOOP       = LOGICAL( READ )
       Extract or grow further output data arrays from the same input
         data array.
3 INPUT
  position    1
  keyword     'INPUT'
  type        'IMAGE'
  access      'READ'
  vpath       'PROMPT'
  ppath       'GLOBAL'
  association '<-GLOBAL.DATA_ARRAY'
  prompt      'Input image'
  help        'Name of the IMAGE structure containing the input data 
              array.'
3 OUTPUT
  position    2
  keyword     'OUTPUT'
  type        'IMAGE'
  access      'WRITE'
  vpath       'PROMPT'
  association '->GLOBAL.DATA_ARRAY'
  prompt      'Output image'
  help        'Name of the IMAGE structure to store output data array.'
3 OTITLE
  position    3
  keyword     'OTITLE'
  type        '_CHAR'
  vpath       'DEFAULT'
  prompt      'Output image title'
  default     'KAPPA - Manic'
  help        'Character string used as a title for the output IMAGE 
              structure.'
3 ONDIM
  position    4
  keyword     'ONDIM'
  type        '_INTEGER'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'Dimensionality of output image'
  help        'Number of dimensions for the output image. It must be 1, 2 or 3.'
 #in          1, 2, 3
3 XLIMITS
  position    5
  keyword     'XLIMITS'
  type        '_INTEGER'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'Window limits for the X-axis of the input data array'
  help        'Give a contiguous range of X-axis pixels that form the 
              output data array.'
3 YLIMITS
  position    6
  keyword     'YLIMITS'
  type        '_INTEGER'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'Window limits for the Y-axis of the input data array'
  help        'Give a contiguous range of Y-axis pixels that form the 
              output data array.'
3 ZLIMITS
  position    7
  keyword     'ZLIMITS'
  type        '_INTEGER'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'Window limits for the Z-axis of the input data array'
  help        'Give a contiguous range of Z-axis pixels that form the 
              output data array.'
3 XRANGE
  position    8
  keyword     'XRANGE'
  type        '_INTEGER'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'Range for summation over the X-axis of the input data
              array'
  help        'Give a contiguous range of X-axis pixels that are 
              going to be summed in forming the output data array'
3 YRANGE
  position    9
  keyword     'YRANGE'
  type        '_INTEGER'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'Range for summation over the Y-axis of the input data
              array'
  help        'Give a contiguous range of Y-axis pixels that are 
              going to be summed in forming the output data array'
3 ZRANGE
  position    10
  keyword     'ZRANGE'
  type        '_INTEGER'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'Range for summation over the Z-axis of the input data
              array'
  help        'Give a contiguous range of Z-axis pixels that are 
              going to be summed in forming the output data array.'
3 EPLANE
  position    11
  keyword     'EPLANE'
  type        '_CHAR'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC'
  prompt      'Plane of the input data array from which the output
              array is to be extracted'
  help        'Options are: XY, YZ, or XZ.'
 #in          'XY', 'YZ', 'ZX', 'YX', 'ZY', 'XZ'
3 GPLANE
  position    12
  keyword     'GPLANE'
  type        '_CHAR'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC'
  prompt      'Plane of the output data array which the input
              data array will form'
  help        'Options are: XY, YZ, or XZ.'
 #in          'XY', 'YZ', 'ZX', 'YX', 'ZY', 'XZ'
3 ELINE1
  position    13
  keyword     'ELINE1'
  type        '_CHAR'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC'
  prompt      'Axis of the input data array that will be used to
              form the output data array?'
  help        'Alternatives are X or Y.'
 #in          'X', 'Y'
3 ELINE2
  position    14
  keyword     'ELINE2'
  type        '_CHAR'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC'
  prompt      'Axis of the input data array that will be used to
              form the output data array'
  help        'Options are X, Y or Z.'
 #in          'X', 'Y', 'Z'
3 GLINE1
  position    15
  keyword     'GLINE1'
  type        '_CHAR'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC'
  prompt      'Axis of the output data array that the input data
              array will form'
  help        'Alternatives are X or Y.'
 #in          'X', 'Y'
3 GLINE2
  position    16
  keyword     'GLINE2'
  type        '_CHAR'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC'
  prompt      'Axis of the output data array that the input data
              array will form'
  help        'Options are X, Y or Z.'
 #in          'X', 'Y', 'Z'
3 XDIM
  position    17
  keyword     'XDIM'
  type        '_INTEGER'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC'
  prompt      'X-dimension for the output data array'
3 YDIM
  position    18
  keyword     'YDIM'
  type        '_INTEGER'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC'
  prompt      'Y-dimension for the output data array'
3 ZDIM
  position    19
  keyword     'ZDIM'
  type        '_INTEGER'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC'
  prompt      'Z-dimension for the output data array'
3 LOOP
  position    20
  keyword     'LOOP'
  type        '_LOGICAL'
  vpath       'PROMPT'
  ppath       'DEFAULT'
  default     N
  prompt      'Produce another output IMAGE structure and data array?'

1 Masking,_Bad Values,_and_Quality

Masking is the process by which you can exclude portions of your
data from data processing or analysis.  Suppose that you are doing
surface photometry of a bright galaxy, part of the data reduction
is to measure the background contribution around the galaxy and to
subtract it.  What you want to avoid is to include light from the
galaxy in your estimation of the background.  A convenient method
for doing this is to mask the galaxy during the background fitting.

There are two techniques used for masking.  One employs special bad
values, which are synonymous with magic or invalid values.  These
appear within the data or variance arrays instead of the actual
values, and indicate that the value is to be ignored or is
undefined.  They are destructive and so some people don't like them,
but you can always mask your data into a new, temporary NDF.  If bad
values weren't used what is a programme supposed to do if it cannot
compute a value, say divide by zero?  With a little care, bad values
are quite effective and they are used throughout KAPPA.  By its
nature, a bad value can only indicate a logical condition about a
data element---it is either good or bad---and so this technique is
sometimes called flagging. 

In contrast, the second technique, uses a quality array.  This
permits many more attributes or qualities of the data to be
associated with each pixel.  In the current implementation there may
be up to 255 integer values or 8 1-bit logical.  Thus quality can be
regarded as offering 8 logical masks extending over the data or
variance arrays, and can signify the presence or absence of a
particular property if the bit has value 1 or 0 respectively.  An
application of quality to satellite data might include the detector
used to measure the value, some indicator of the time each pixel was
observed, was the observation made within the Earth's radiation
belts, and whether or not the pixel contains a reseau mark.  By
selecting only those data with the appropriate quality values, you
process only the data with the desired properties.  This can be
very powerful.  However, it does have the drawback of having to
store at least an extra byte per pixel in your NDF.

The two methods are not mutually exclusive; the NDF permits their
simultaneous use in a dataset. 

Now we'll look at both of these techniques in detail and
demonstrating the relevant KAPPA tasks.

2 Bad-pixel_Masking
Bad pixels are flagged with the Starlink standard values (see
Section 5 of SUN/39), which for _REAL is the most-negative value
possible.

In addition to tasks which routinely create bad values in the output
value is undefined, KAPPA offers many applications for flagging
pixels with certain properties or locations.

3 Doing_it_the_ARD_way
To mask a region or a series of regions within an NDF, you can
create an ASCII Region Definition (ARD) file.

     % cat myard.ard
     PIXEL( 23, -17 )
     CIRCLE( -14.5, 318.7, 44.3 )
     ELLIPSE( 75.2, 296.6, 33, 16, 78 )
     POLYGON( 110, 115, 123, 132, 130, 125 )
     CIRCLE( 10, 10, 40 ) .AND. .NOT. CIRCLE( 10, 10, 30 )
     CTRL/D

In this example, the regions are: the pixel with index (23,-17), a
circle of radius 44.3 pixels about pixel co-ordinates (-14.5,318.7),
an ellipse centred at (75.2,296.6) with semi-major axis of 33 pixels
and semi-minor axis of 16 pixels, at orientation 78 degrees clockwise
from the x axis, and an annulus centred on pixel (10,10) between
radius 30 and 40 pixels.  There are several other keywords besides
those shown here.  ARD also has a powerful syntax for combining
regions, and you can set it up to use linear data co-ordinates or
your co-ordinate system.  These are described fully in SUN/183, but
you'll be relieved to learn that there is a shortcut.

If you are dealing with 2-dimensional data, KAPPA offers an
interactive graphical tool for generating ARD files.  To use ARDGEN
you must first display your data on a device with a cursor, such as
an X-terminal.  DISPLAY with a greyscale lookup table is probably
best for doing that.  The grey lets you see the coloured overlays
clearly.

     % ardgen demo.ard

     Current picture has name: DATA, comment: KAPPA_DISPLAY.
     Using NDF '/star/bin/kappa/ccdframec'

     Instructions for using the cursor...
        Press left button on mouse/trackerball to select a point.
        Press middle button on mouse/trackerball to see current
        cursor co-ordinates.
        Press right button on mouse/trackerball to end input.

     SHAPE - Region shape /'CIRCLE'/ >

At this point you can select a shape.  Enter ? to get the the list.
Once you've selected a shape you'll receive instructions.

     SHAPE - Region shape /'COLUMN'/ > ellipse

     Region type is "ELLIPSE". Identify the centre, then one end of
     the semi-major axis, and finally one other point on the ellipse.

Once you have defined one ellipse, you can define another or exit to
the OPTION prompt.  In addition to keyboard 1, pressing the right-hand
mouse button has the same effect.  Thus in the example, the new shape is
a rotated box.

     Region completed. Identify another 'ELLIPSE' region...
     OPTION - Next operation to perform /'SHAPE'/ > rotbox

     Region type is "ROTBOX". Identify the two end points of any
     edge and then give a point on the opposite edge.
     Region completed. Identify another 'ROTBOX' region...

If you make a mistake, enter List at the OPTION prompt to see a list
of the regions.  Note the "Region Index" of the region(s) you wish
to remove, and select the Delete option.  At the REGION prompt,
give a list of the regions you want to remove.  If you change your
mind, enter ! at the prompt for parameter REGIONS, and no regions are
deleted.

Now suppose you want to combine or invert regions in some way, you
supply Combine at the OPTION prompt.  So suppose we have
created the following regions in $KAPPA_DIR/ccdframe.

       Region          Region Description
       Index
 
         1   -  ELLIPSE( 174.1, 234.4, 82.2, -43.5, 65.64783 )
         2   -  ELLIPSE( 168.1, 209.1, 29.4, -19.7, 9.441798 )
         3   -  ELLIPSE( 42.2, 244.1, 13, -10.3, 111.8452 )
         4   -  ROTBOX( 40.5, 219.2, 63.8, 38.3, 37.24281 )
         5   -  RECT( 141.5, 1.4, 143.9, 358.8 )
         6   -  POLYGON( 229.8, 247.7,
                         233.4, 247.7,
                         233.4, 258.6,
                         231, 267,
                         229.8, 265.8,
                         228.6, 256.2 )

We want to form the region inside the first ellipse but not inside
the second.  This done in two stages.  First we invert the second
ellipse, meaning that pixels are included if they are not inside
this ellipse, by combining with the NOT operator.

     OPTION - Next operation to perform /'SHAPE'/ > comb
     OPERATOR - How to combine the regions /'AND'/ > not  
     OPERANDS - Indices of regions to combine or invert /6/ > 2

This removes the original region 2, decrements the region numbers of
the other regions following 2 by one, so that region 3 becomes 2, 4
becomes 3, and so on.  A new region 7 is the inverted ellipse.  The
renumbering makes it worth listing the regions before combining
regions.  The second stage is to combine it with region 1, using the
AND operator.  This includes pixels if they are in both regions.
In this example, that means all the pixels outside the second
ellipse but which lie within the first.

    OPTION - Next operation to perform /'SHAPE'/ > com
    OPERATOR - How to combine the regions /'AND'/ > 
    OPERANDS - Indices of regions to combine or invert /[6,7]/ > 1,6

Here is another example of combination.  This creates a region for
pixels are included provided they are in one of two regions, but not
in both.  Here we apply the XOR operator to the small ellipse
and the first rotated box.

     OPTION - Next operation to perform /'SHAPE'/ > comb
     OPERATOR - How to combine the regions /'AND'/ > xor
     OPERANDS - Indices of regions to combine or invert /[4,5]/ > 1,2

Here is the final set of regions.

     OPTION - Next operation to perform /'SHAPE'/ > list

       Region          Region Description
       Index
 
         1   -  RECT( 141.5, 1.4, 143.9, 358.8 )
         2   -  POLYGON( 229.8, 247.7,
                         233.4, 247.7,
                         233.4, 258.6,
                         231, 267,
                         229.8, 265.8,
                         228.6, 256.2 )
 
         3   -  ( ELLIPSE( 174.1, 234.4, 82.2, -43.5, 65.64783 )
                  .AND.
                  ( .NOT. ELLIPSE( 168.1, 209.1, 29.4, -19.7, 9.441798 ) ) )
 
         4   -  ( ELLIPSE( 42.2, 244.1, 13, -10.3, 111.8452 )
                  .XOR.
                  ROTBOX( 40.5, 219.2, 63.8, 38.3, 37.24281 ) )

Once you are done, enter "Exit" at the OPTION prompt, and the
ARD file is created.  "Quit" also leaves the programme, but
the ARD file is not made.

Having created the ARD file it is straightforward to generate a
masked image with ARDMASK.

     % ardmask $KAPPA_DIR/ccdframec demo.ard ardccdmask

If you have duplicated the above tutorial you should have an
image on view with the original regions outlined.  To see where you
have masked, use DISPLAY, which lets you define a colour for bad
pixels using the BADCOL parameter.

     % display ardccdmask badcol=red \\

3 SEGMENT_and_ZAPLIN

SEGMENT is ostensibly for copying polygonal regions from one NDF to
another.  You may also use SEGMENT to copy bad pixels into the
polygonal regions by giving the null value for one of the two input
NDFs.  For instance,

     % segment in1=! in2=$KAPPA_DIR/ccdframec out=ccdmask

NDF ccdmask will have bad values inside the polygons, whereas

     % segment in2=! in1=$KAPPA_DIR/ccdframec out=ccdmask

the pixels exterior to the polygons are flagged.  SEGMENT lets you
define the polygon vertices interactively, like in ARDGEN, but you
can also use text files, or respond to prompting.

ZAPLIN also has an option to fill in rectangular areas when parameter
ZAPTYPE has value Bad.

3 Special_Filters_for_Inserting_Bad_Values
There are applications that mask pixels if their values meet certain
criteria.

SETMAGIC flags those pixels with a nominated value.  It is most
useful during conversion of imported data whose data system uses
bad-pixel values different from Starlink's.

FFCLEAN removes defects smaller than a nominated size from an image
or vector NDF.  It flags those pixels that deviate from a smoothed
version of the NDF by more than some number of standard deviations
from the local mean.

ERRCLIP flags pixels that have errors larger than some supplied
limit or signal-to-noise ratios below a threshold.  The errors come
from the VARIANCE component of the NDF.  Thus you can exclude
unreliable data from analysis.

2 Quality_Masking
All the NDF tasks in KAPPA use quality yet there is no obvious sign
in individual applications how particular values of quality are
selected.  What gives?  The meanings attached to the quality bits
will inevitably be quite specific for specialist software packages,
but KAPPA tasks aim to be general purpose.  To circumvent this
conflict there is an NDF component called the bad-bits mask that
forms part of the quality information.  Like a QUALITY value, the
bad-bits mask is an unsigned byte.  Its purpose is to convert the
eight quality flags into a single logical value for each pixel,
which can then be processed just like a bad pixel. 

When data are read from the NDF by mapping into memory, the quality
of each pixel is combined with the bad-bits mask; if a result of
this quality masking is FALSE, that pixel is assigned the bad value
for processing.  This does not change the original values stored in
the NDF; it only affects the mapped data.

So how do the quality and bad-bits mask combine to form a logical
value?  They form the bit-wise `AND' and test it for equality for 0.
None the wiser?  Regard each bit in the bad-bits mask as a switch
to activate detection of the corresponding bit in a pixel's quality.
The switch is on if it has value 1, and is off if it has value 0.
Thus if the pixel is flagged only if one or more of the 8 bits
has both quality and the corresponding bad-bit set to 1.  Here
are some examples:

QUALITY:     10000001    10000001
Bad-bits:    01000100    01000101
Bits on:                        ^
Result:      TRUE        FALSE

The application SETBB allows you to modify the bad-bits mask in
an NDF.  It allows you to specify the bit pattern in a number of
ways including decimal and binary as illustrated below.

     % setbb RO950124 5
     % setbb RO950124 b101

These both set the bad-bits mask to 00000101 for the NDF RO950124.
SETBB also allows you to combine an existing NDF bad-bits mask with
another mask using the operators AND and OR.  OR lets you switch on
additional bits without affecting those already on; AND lets you
turn off selected bits leaving the rest unchanged.

     % setbb RO950124 b00010001 or
     % setbb RO950124 b11101110 and

The first example sets bits 1 and 5 but leaves the other bits of
the mask unaltered, whereas the second switches off the same bits.

Now remembering which bit corresponds to which could be a strain on
the memory.  It would be better if some meaning was attached to each
bit through a name.  There are four general tasks in the IRAS90
package which address this. [We plan to integrate them into the
more-natural home of the NDFPACK sub-package of KAPPA.]  SETQUAL
sets quality values and names; SHOWQUAL lists the named qualities;
REMQUAL removes named qualities; and QUALTOBAD uses a logical
expression containing the named quality properties to create a
copy of your NDF in which pixels satisfying the quality expression
are set bad.  See Section 4.3 of SUN/163 for details.

2 Removing_bad_pixels

Sometimes having bad pixels present in your data is a nuisance, say
because some application outside of KAPPA does not recognise them, or
you want to integrate the flux of a source.  KAPPA offers a number of
options for removing bad values.  Which of these is appropriate
depends on the reason why you want to remove the bad pixels.

First you could replace the bad values with some other reasonable value,
such as zero.

     % nomagic old new 0 comp=all

Here dataset new is the same as dataset old except that any bad value
in the data or variance array has now become zero.

If you wanted some representative value used based upon neighbouring
pixels, use the GLITCH command.

     % fillbad old new size=4

The value of parameter SIZE should be about half the diameter of the
largest region of bad pixels.  Both the data array and variance arrays
are filled.

You may replace individual pixels or rectangular sections using CHPIX.

     % chpix old new
     SECTION - Section to be set to a constant /'55,123'/ >
     NEWVAL - New value for the section /'60'/ >
     SECTION - Section to be set to a constant /'1:30,-10:24'/ >
     NEWVAL - New value for the section /'-1'/ >
     SECTION - Section to be set to a constant /'1:30,-10:24'/ > !

This replaces pixel (55,123) with value 60, and the region from
(1,-10) to (30,24) with -1.  The final ! ends the loop of
replacements.  If you supply NEWVAL on the command line, only one
replacement occurs.

It is also possible to paste other datasets where your bad values
lie with the PASTE and SEGMENT tasks.

     % paste old fudge"(10:20,29:30)" out=new

The dataset old is a copy of dataset new, except in the 22-pixel
region (10,29) to (20,30), where the values originate from the fudge
dataset.
1 MATHS
Evaluates mathematical expressions applied to NDF data structures.

Usage:

   maths exp out ia-iz=? va-vz=? fa-fz=? pa-pz=? lbound=? ubound=?

Description:

   This application allows arithmetic and mathematical functions to
   be applied pixel-by-pixel to a number of NDF data structures and
   constants so as to produce a new NDF.  The operations to be
   performed are specified using a Fortran-like mathematical
   expression.  Up to 26 each input NDF data and variance arrays, 26
   parameterised `constants', and pixel and data co-ordinates along
   up to 7 dimensions may be combined in wide variety of ways using
   this application.  The task can also calculate variance estimates
   for the result when there is at least one input NDF array.
2 Parameters
For information on individual parameters, select from the list below:
3 EXP
EXP = LITERAL (Read)
   The mathematical expression to be evaluated for each NDF
   pixel, e.g. "(IA-IB+2)*PX".  In this expression, input NDFs are
   denoted by the variables IA, IB, ... IZ, while constants may
   either be given literally or represented by the variables PA,
   PB, ...  PZ.  Values for those NDFs and constants which appear
   in the expression will be requested via the application's
   parameter of the same name.

   Fortran-77 syntax is used for specifying the expression, which
   may contain the usual intrinsic functions, plus a few extra
   ones. An appendix in SUN/61 gives a full description of the
   syntax used and an up to date list of the functions available.
   The expression may be up to 132 characters long and is case
   insensitive.
3 FA-FZ
FA-FZ = LITERAL (Read)
   These parameters supply the values of `sub-expressions' used
   in the expression EXP.  Any of the 26 (FA, FB, ... FZ) may
   appear; there is no restriction on order.  These parameters
   should be used when repeated expressions are present in
   complex expressions, or to shorten the value of EXP to fit
   within the 132-character limit.  Sub-expressions may contain
   references to other sub-expressions and constants (PA-PZ).  An
   example of using sub-expressions is:
      EXP > PA*ASIND(FA/PA)*XA/FA
      FA > SQRT(XA*XA+XB*YB)
      PA > 10.1
   where the parameter name is to the left of > and its value is
   to the right of the >.
3 IA-IZ
IA-IZ = NDF (Read)
   The set of 26 parameters named IA, IB, ... IZ is used to
   obtain the input NDF data structure(s) to which the
   mathematical expression is to be applied.  Only those
   parameters which actually appear in the expression are used,
   and their values are obtained in alphabetical order.  For
   instance, if the expression were "SQRT(IB+IA)", then the
   parameters IA and IB would be used (in this order) to obtain
   the two input NDF data structures.
3 LBOUND
LBOUND( ) = _INTEGER (Read)
   Lower bounds of new NDF, if LIKE=! and there is no input NDF
   referenced in the expression.  The number of values required
   is the number of pixel co-ordinate axes in the expression.
3 LIKE
LIKE = NDF (Read)
   An optional template NDF which, if specified, will be used to
   define bounds and data type of the new NDF, when the expression
   does not contain a reference to an NDF.  If a null response
   (!) is given the bounds are obtained via parameters LBOUND
   and UBOUND, and the data type through parameter TYPE. [!]
3 OUT
OUT = NDF (Write)
   Output NDF to contain the result of evaluating the expression
   at each pixel.
3 PA-PZ
PA-PZ = _DOUBLE (Read)
   The set of 26 parameters named PA, PB, ... PZ is used to
   obtain the numerical values of any parameterised `constants'
   which appear in the expression being evaluated.  Only those
   parameters which actually appear in the expression are used,
   and their values are obtained in alphabetical order.  For
   instance, if the expression were "PT*SIN(IA/PS)", then the
   parameters PS and PT (in this order) would be used to obtain
   numerical values for substitution into the expression at the
   appropriate points.

   These parameters are particularly useful for supplying the
   values of constants when writing procedures, where the
   constant may be determined by a command-language variable, or
   when the constant is stored in a data structure such as a
   global parameter.  In other cases, constants should normally be
   given literally as part of the expression, as in "IZ**2.77".
3 QUICK
QUICK = _LOGICAL (Read)
   Specifies the method by which values for the variance
   component of the output NDF are calculated.  The algorithm used
   to determine these values involves perturbing each of the
   input NDF data arrays in turn by an appropriate amount, and
   then combining the resulting output perturbations.  If QUICK
   is set to TRUE, then each input data array will be perturbed
   once, in the positive direction only.  If QUICK is set to
   FALSE, then each will be perturbed twice, in the positive and
   negative directions, and the maximum resultant output
   perturbation will be used to calculate the output variance.
   The former approach (the normal default) executes more
   quickly, but the latter is likely to be more accurate in cases
   where the function being evaluated is highly non-linear,
   and/or the errors on the data are large.  [TRUE]
3 TITLE
TITLE = LITERAL (Read)
   Value for the title of the output NDF.  A null value will cause
   the title of the (alphabetically) first input NDF to be used
   instead. [!]
3 TYPE
TYPE = LITERAL (Read)
   Data type for the new NDF, if LIKE=! and no input NDFs are
   referenced in the expression.  It must be one either
   "_DOUBLE" or "_REAL". 
3 UBOUND
UBOUND( ) = _INTEGER (Read)
   Upper bounds of new NDF, if LIKE=! and there is no input NDF
   referenced in the expression.  These must not be smaller
   than the corresponding LBOUND.  The number of values required
   is the number of pixel co-ordinate axes in the expression.
3 UNITS
UNITS = _LOGICAL (Read)
   Specifies whether the units component of the (alphabetically)
   first input NDF or the template NDF will be propagated to the
   output NDF.  By default this component is not propagated since,
   in most cases, the units of the output data will differ from
   those of any of the input data structures.  In simple cases,
   however, the units may be unchanged, and this parameter then
   allows the units component to be preserved.  This parameter is
   ignored if the expression does not contain a token to at least
   one input NDF structure and LIKE=!.  [FALSE]
3 VA-VZ
VA-VZ = NDF (Read)
   The set of 26 parameters named VA, VB, ... VZ is used to
   obtain the input NDF variance array(s) to which the
   mathematical expression is to be applied.  The variance VA
   corresponds to the data array specified by parameter IA, and
   so on.  Only those parameters which actually appear in the
   expression, and do not have their corresponding data-array
   parameter IA-IZ present, have their values obtained in
   alphabetical order.  For instance, if the expression were
   "IB+SQRT(VB+VA)", then the parameters VA and IB would be used
   (in this order) to obtain the two input NDF data structures.
   The first would use just the variance array, whilst the second
   would read both data and variance arrays.
3 VARIANCE
VARIANCE = _LOGICAL (Read)
   Specifies whether values for the variance component of the
   output NDF should be calculated.  If this parameter is set to
   TRUE (the normal default), then output variance values will be
   calculated if any of the input NDFs contain variance
   information.  Any which do not are regarded as having zero
   variance.  Variance calculations will normally be omitted only
   if none of the input NDFs contain variance information.
   However, if VARIANCE is set to FALSE, then calculation of
   output variance values will be disabled under all
   circumstances, with a consequent saving in execution time.
   This parameter is ignored if the expression does not contain
   a token to at least one input NDF structure. [TRUE]
2 Examples
maths "ia-1" dat2 ia=dat1
   The expression "ia-1" is evaluated to subtract 1 from each
   pixel of the input NDF referred to as IA, whose values reside
   in the data structure dat1.  The result is written to the NDF
   structure dat2.

maths "(ia-ib)/ic" ia=data ib=back ic=flat out=result units
   The expression "(ia-ib)/ic" is evaluated to remove a
   background from an image and to divide it by a flat-field.
   All the images are held in NDF data structures, the input
   image being obtained from the data structure data, the
   background image from back and the flat-field from flat.  The
   result is written to the NDF structure result.  The data units
   are unchanged and are therefore propagated to the output NDF.

maths "-2.5*log10(ii)+25.7" ii=file1 out=file2
   The expression "-2.5*log10(ii)+25.7" is evaluated to convert
   intensity measurements into magnitudes, including a zero
   point.  Token II represents the input measurements held in the
   NDF structure file1.  The result is written to the NDF
   structure file2.  If file1 contains variance values, then
   corresponding variance values will also be calculated for
   file2.

maths exp="pa*exp(ia+pb)" out=outfile pb=13.7 novariance
   The expression "pa*exp(ia+pb)" is evaluated with a value of
   13.7 for the constant PB, and output is written to the NDF
   structure outfile.  The input NDF structure to be used for
   token IA and the value of the other numerical constant PA will
   be prompted for.  NOVARIANCE has been specified so that output
   variance values will not be calculated.

maths exp="mod(XA,32)+mod(XB,64)" out=outfile like=comwest
   The expression "mod(XA,32)+mod(XB,64)" is evaluated, and
   output is written to the NDF structure outfile.  The output
   NDF inherits the shape, bounds, and other properties (except the
   variance) of the NDF called comwest.  The data type of outfile
   is _REAL unless comwest has type _DOUBLE.  XA and XB represent
   the pixel co-ordinates along the x and y axes respectively.

maths "xf*xf+0*xa" ord2 lbound=[-20,10] ubound=[20,50]
   The expression "xf*xf+0*xa" is evaluated, and output is
   written to the NDF structure ord2.  The output NDF has data
   type _REAL, is two-dimensional with bounds -20:20, 10:50.  The
   XA is needed to indicate that XF represents pixel co-ordinates
   along the y axis.

maths "xa/max(1,xb)+sqrt(va)" ord2 va=fuzz title="Fuzz correction"
   The expression "xa/max(1,xb)+sqrt(va)" is evaluated, and output
   is written to the NDF structure ord2.  Token VA represents the
   input variance array held in the NDF structure fuzz.  The
   output NDF inherits the shape, bounds, and other properties of
   fuzz.  The title of ord2 is "Fuzz correction".  The data type
   of ord2 is _REAL unless fuzz has type _DOUBLE.  XA and XB
   represent the pixel co-ordinates along the x and y axes
   respectively.
2 Notes
-  The alphabetically first input NDF is regarded as the primary
input dataset. NDF components whose values are not changed by
this application will be propagated from this NDF to the output.
The same propagation rules apply to the LIKE template NDF,
except that the output NDF does have inherit any variance
information.

-  There are additional tokens which can appear in the expression.

The set of 7 tokens named CA, CB, ... CG is used to obtain the
data co-ordinates from the primary input NDF data structure.  Any
of the 7 parameters may appear in the expression.  The order
defines which axis is which, so for example, "2*CF+CB*CB" means
the first-axis data co-ordinates squared, plus twice the
co-ordinates along the second axis.  There must be at least one
input NDF in the expression to use the CA-CG tokens, and it must
have dimensionality of at least the number of CA-CG tokens given.

The set of 7 tokens named XA, XB, ... XG is used to obtain the
pixel co-ordinates from the primary input NDF data structure.  Any
of the 7 parameters may appear in the expression.  The order
defines which axis is which, so for example, "SQRT(XE)+XC" means
the first-axis pixel co-ordinates plus the square root of the
co-ordinates along the second axis.  Here no input NDF need be
supplied.  In this case the dimensionality of the output NDF is equal to the
number of XA-XG tokens in the expression.  However, if there is at
least one NDF in the expression, there should not be more XA-XG
tokens than the dimensionality of the output NDF (given as the
intersection of the bounds of the input NDFs).

-  If illegal arithmetic operations (e.g. division by zero, or
square root of a negative number) are attempted, then a bad pixel
will be generated as a result.  (However, the infrastructure
software that detects this currently does not work on OSF/1
systems, and therefore MATHS will crash in this circumstance.)

-  All arithmetic performed by this application is floating
point.  Single-precision will normally be used, but
double-precision will be employed if any of the input NDF arrays
has a numeric type of _DOUBLE.
2 Calculating_Variance
   The algorithm used to calculate output variance values is
   general-purpose and will give correct results for any reasonably
   well-behaved mathematical expression.  However, this application
   as a whole, and the variance calculations in particular, are
   likely to be less efficient than a more specialised application
   written knowing the form of the mathematical expression in
   advance.  For simple operations (addition, subtraction, etc.) the
   use of other applications (ADD, SUB, etc.) is therefore
   recommended, particularly if variance calculations are required.

   The main value of the variance estimation algorithm used here
   arises when the expression to be evaluated is too complicated, or
   too infrequently used, to justify the work of deriving a direct
   formula for the variance.  It is also of value when the data
   errors are especially large, so that the linear approximation
   normally used in error analysis breaks down.

   There is no variance processing when there are no tokens for
   input NDF structures.
2 Timing
   If variance calculations are not being performed, then the time
   taken is approximately proportional to the number of NDF pixels
   being processed.  The execution time also increases with the
   complexity of the expression being evaluated, depending in the
   usual way on the nature of any arithmetic operations and
   intrinsic functions used. If certain parts of the expression will
   often give rise to illegal operations (resulting in bad pixels),
   then execution time may be minimised by placing these operations
   near the beginning of the expression, so that later parts may not
   need to be evaluated.

   If output variance values are being calculated and the QUICK
   parameter is set to TRUE, then the execution time will be
   multiplied by an approximate factor (N+1), where N is the number
   of input NDFs which contain a variance component.  If QUICK is set
   to FALSE, then the execution time will be multiplied by an
   approximate factor (2N+1).
2 Related_Applications
   KAPPA: CREFRAME, SETAXIS, and numerous arithmetic tasks; Figaro:
   numerous arithmetic tasks.
2 Authors
MJC: Malcolm Currie (STARLINK)

RFWS: R.F. Warren-Smith (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 1989 August 20 (MJC):
    First implementation.

 1989 December 21 (MJC):
    Workspace managed by AIF_TEMP.

 1990 June 28 (RFWS):
    Substantial re-write to use the NDF_ access routines and to
    calculate output variance values.

 1990 August 7 (RFWS):
    Fixed bug in data type of the PARVAL variable.

 1995 September 18 (MJC):
    Added FA-FZ, LBOUND, LIKE, PA-PZ, TYPE, UBOUND, VA-VZ
    parameters, Usage, Related Applications, and additional
    examples.  Enabled use of variance and co-ordinates in the
    expression.  Examples changed to lowercase.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   VARIANCE, LABEL, TITLE, UNITS, WCS and HISTORY components of the
   input NDFs.  HISTORY and extensions are propagated from both the
   primary NDF and template NDF.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.

   -  NDFs with any number of dimensions can be processed.  The NDFs
   supplied as input need not all be the same shape.
1 MEDIAN
Smooths a 2-dimensional data array using a weighted median filter.

Usage:

   median in out [mode] [diff] [bound] [numit] corner side centre

Description:

   This task filters the 2-dimensional data array in the input NDF
   structure with a Weighted Median Filter (WMF) in a 3-by-3-pixel
   kernel to create a new NDF.  There are a number of predefined
   weighting functions and parameters that permit other symmetric
   weighting functions.  See parameter MODE and the topic
   "User-defined Weighting Functions".

   A threshold for replacement of a value by the median can be set.
   If the absolute value of the difference between the actual value
   and the median is less than the threshold, the replacement will
   not occur.  The array boundary is dealt by either pixel
   replication or a reflection about the edge pixels of the array.

   The WMF can be repeated iteratively a specified number of times,
   or it can be left to iterate continuously until convergence is
   achieved and no further changes are made to the data.  In the
   latter case a damping algorithm is used if the number of
   iterations exceeds some critical value, which prevents the result
   oscillating between two solutions (which can sometimes happen).
   When damping is switched on data values are replaced not by the
   median value, but by a value midway between the original and the
   median.

   Bad pixels are not included in the calculation of the median.
   There is a defined threshold which specifies minimum-allowable
   median position as a fraction of the median position when there
   are no bad pixels.  For neighbourhoods with too many bad pixels,
   and so the median position is too small, the resulting output
   pixel is bad.
2 Parameters
For information on individual parameters, select from the list below:
3 BOUND
BOUND = LITERAL (Read)
   Determines the type of padding required at the array edges
   before the filtering starts.  The alternatives are described
   below.

     "Replication" - The values at the edge of the data array
                     are replicated into the padded area.  For
                     example, with STEP=2 one corner of the
                     original and padded arrays would appear
                     as follows:
                                                   1 1 1 1 1 1 1
                                                   1 1 1 1 1 1 1
          corner of     1 1 1 1 1   corresponding  1 1 1 1 1 1 1
          original      1 2 2 2 2   corner of      1 1 1 2 2 2 2
          array:        1 2 3 3 3   padded array:  1 1 1 2 3 3 3
                        1 2 3 4 4                  1 1 1 2 3 4 4
                        1 2 3 4 5                  1 1 1 2 3 4 5

     "Reflection"  - The values near the edge of the data array
                     are reflected about the array's edge pixels.
                     For example, with STEP=2 one corner of the
                     original and padded arrays would appear as
                     follows:
                                                   3 2 1 2 3 3 3
                                                   2 2 1 2 2 2 2
             corner of  1 1 1 1 1   corresponding  1 1 1 1 1 1 1
             original   1 2 2 2 2   corner of      2 2 1 2 2 2 2
             array:     1 2 3 3 3   padded array:  3 2 1 2 3 3 3
                        1 2 3 4 4                  3 2 1 2 3 4 4
                        1 2 3 4 5                  3 2 1 2 3 4 5

    ["Replication"]
3 CENTRE
CENTRE = _INTEGER (Read)
   Central value for weighting function, required if MODE = -1.
   It must be an odd value in the range 1 to 21. [1]
3 CORNER
CORNER = _INTEGER (Read)
   Corner value for weighting function, required if MODE = -1.
   It must be in the range 0 to 10. [1]
3 DIFF
DIFF  = _DOUBLE (Read)
   Replacement of a value by the median occurs if the absolute
   difference of the value and the median is greater than DIFF.
   [0.0]
3 IN
IN = NDF (Read)
   NDF structure containing the 2-dimensional data array to be
   filtered.
3 ITERATE
ITERATE = LITERAL (Read)
   Determines the type of iteration used.  The alternatives are
   described below.

     "Specified"   - You specify the number of iterations
                     at each step size in the parameter NUMIT.

     "Continuous"  - The filter iterates continuously until
                     convergence is achieved and the array is no
                     longer changed by the filter.  A damping
                     algorithm comes into play after MAXIT
                     iterations, and the filter will give up
                     altogether after MAXIT * 1.5 iterations
                     (rounded up to the next highest integer).

   "Continuous" mode is recommended only for images which are
   substantially smooth to start with (such as a sky background
   frame from a measuring machine).  Complex images may take many
   iterations, and a great deal of time, to converge.
   ["Specified"]
3 MAXIT
MAXIT = _INTEGER (Read)
   The maximum number of iterations of the filter before the
   damping algorithm comes into play, when ITERATE =
   "Continuous".  It must lie in the range 1 to 30.  [10]
3 MEDTHR
MEDTHR = _REAL (Read)
   Minimum-allowable actual median position as a fraction of the
   median position when there are no bad pixels, for the
   computation of the median at a given pixel. [0.8]
3 MODE
MODE = _INTEGER (Read)
   Determines type of weighting used, -1 allows you to define the
   weighting, and 0 to 7 the predefined filters.  The predefined
   modes have the following weighting functions:

     0:  1 1 1   1:  0 1 0   2:  1 0 1   3:  1 1 1   4:  0 1 0
         1 1 1       1 1 1       0 1 0       1 3 1       1 3 1
         1 1 1       0 1 0       1 0 1       1 1 1       0 1 0

     5:  1 0 1   6:  1 2 1   7:  1 3 1
         0 3 0       2 3 2       3 3 3
         1 0 1       1 2 1       1 3 1

   [0]
3 NUMIT
NUMIT = _INTEGER (Read)
   The specified number of iterations of the filter, when ITERATE
   = "Specified".  [1]
3 OUT
OUT = NDF (Write)
   NDF structure to contain the 2-dimensional data array after
   filtering.
3 SIDE
SIDE = _INTEGER (Read)
   Side value for weighting function, required if MODE = -1.
   It must be in the range 0 to 10. [1]
3 STEP
STEP() = _INTEGER (Read)
   The spacings between the median filter elements to be used.
   The data may be filtered at one particular spacing by
   specifying a single value, such as STEP=4, or may be filtered
   at a whole series of spacings in turn by specifying a list of
   values, such as STEP=[4,3,2,1].  There is a limit of 32 values.
   [1]
3 TITLE
TITLE = LITERAL (Read)
   Value for the title of the output NDF.  A null value will cause
   the title of the NDF supplied for parameter IN to be used
   instead. [!]
2 Examples
median a100 a100med
   This applies an equally weighted median filter to the NDF
   called a100 and writes the result to the NDF a100med.  It uses
   the default settings, which are a single step size of one
   pixel, and a difference threshold of 0.0.  The task pads the
   array by replication to deals with the edge pixels, and runs
   the filter once only.

median a100 a100med bound=ref
   As in the previous example except that it uses reflection
   rather than replication when padding the array.

median abc sabc mode=3 step=4 diff=1.0 numit=2
   This applies a median filter to the NDF called abc with a
   1 1 1
   1 3 1  weighting mask (MODE=3), a step size of 4 pixels
   1 1 1
   (STEP=4) and a difference threshold of 1.0 (DIFF=1.0).  It
   runs the filter twice (NUMIT=2) and writes the result to
   the NDF called sabc.

median abc sabc mode=3 step=[4,3,2,1] diff=1.0 numit=2
   This applies a median filter as in the previous example,
   only this time run the filter at step sizes of 4, 3, 2,
   and 1 pixels, in that order (STEP=[4,3,2,1]).  It runs the
   filter twice at each step size (NUMIT=2).  Note that the
   filter will be run a total of EIGHT times (number of step
   sizes times the number of iterations).

median in=spotty step=[4,3,2,1] iterate=cont maxit=6 out=clean
   This applies a median filter to the NDF called spotty with
   the default settings for the mode and difference threshold.
   It runs the filter at step sizes of 4, 3, 2, and 1 pixels,
   operating continuously at each step size until the result
   converges (ITERATE=CONT).  Damping will begin after 6
   iterations (MAXIT=6), and the filtering will stop regardless
   after 10 iterations (1 + INT(1.5 * MAXIT)).  Note that the
   filter will run an indeterminate number of times, up to a
   maximum of 40 (number of step sizes * maximum number of
   iterations), and may take a long time.  The resultant data
   array are written to the NDF called clean.
2 User-defined_Weighting_Functions
   Parameters CORNER, SIDE, and CENTRE allow other symmetric
   functions in addition to those offered by MODE=0 to 7.  A step
   size has to be specified too; this determines the spacing of the
   elements of the weighting function. The data can be filtered at
   one step size only, or using a whole series of step sizes in
   sequence.  The weighting function has the form:

             %CORNER  .   %SIDE   .  %CORNER
                .           .           .
              %SIDE   .  %CENTRE  .   %SIDE
                .           .           .
             %CORNER  .   %SIDE   .  %CORNER

   The . indicates that the weights are separated by the
   stepsize-minus-one zeros.
2 Related_Applications
   KAPPA: BLOCK, CONVOLVE, FFCLEAN, GAUSMOOTH; Figaro: ICONV3,
   ISMOOTH, IXSMOOTH, MEDFILT.
2 Authors
DB: Dave Baines (ROE)

MJC: Malcolm J. Currie (STARLINK)

SMB: Steven Beard (ROE)

DSB: David S. Berry (STARLINK)
2 History
 20/10/1983 (DB):
    Original version.

 17/02/1984 (DB):
    Modified to use TITLE component.

 1986 August 7 (MJC):
    Standardised prologue formatting. Made 10th argument of MEDWTS
    the 12th.  Added status check on entry.

 1986 August 29 (MJC):
    Replaced KERGEN routines by their nearest AIF_ equivalent.
    Added arguments section to the prologue, added extra parameter
    MEDTHR and tidied.

 1987 October 15 (MJC):
    Reordered tidying and extra status checks.

 1988 March 8 (MJC):
    Substituted AIF_ANTMP to annul workspace.

 1988 March 17 (MJC):
    Referred to `array' rather than `image'.

 1988 June 8 (MJC):
    More reporting of error context.

 1989 June 13 (MJC):
    Allow for processing primitive NDFs.

 1989 August  8 (MJC):
    Passed array dimensions as separate variables to COPY2D,
    MEDREF, MEDREP and MEDWTS.

 1989 December 21 (MJC):
    Workspace managed by AIF_TEMP.

 1991 October 25 (MJC):
    Propagates AXIS, UNITS, LABEL and HISTORY.

 1992 February 25 (MJC):
    Limited processing of simple NDFs.

 1992 March 3 (MJC):
    Replaced AIF parameter-system calls by the extended PAR
    library.

 1993 July 20 (SMB):
    SKYMEDIAN cloned from MEDIAN.  KPG1 calls replaced by NDF.
    COSMOS sky-background-filtering algorithm used.  Instead of
    having a specified number of iterations this algorithm will
    iterate until no further changes are made to the data, with a
    damping algorithm coming into play after a certain number of
    iterations.  Parameter NUMIT replaced by MAXIT.  1.0E38
    replaced by VAL__MAXR.

 1993 July 21 (SMB):
    SKYMEDIAN combined with MEDIAN to create a more general median
    filtering program which can replace MEDIAN (as suggested by
    Malcolm Currie).  ITERATION parameter introduced. Parameter
    NUMIT reinstated.  Parameter STEP converted from a scalar to a
    vector, which will allow the filter to run at a whole series
    of step sizes.

 1995 July 27 (MJC):
    Made to operate on all numeric data types.  Used a modern-style
    prologue with additional topics.  Modern-style coding.  Made
    messages conditional.  Removed a couple of unnecessary calls.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, LABEL, TITLE,
   UNITS, WCS and HISTORY components of an NDF data structure and
   propagates all extensions.  VARIANCE is not used to weight the
   median filter and is not propagated.  QUALITY is also lost.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.
1 MEM2D
Performs a Maximum-Entropy deconvolution of a 2-dimensional NDF.

Usage:

   mem2d in out mask=? { fwhmpsf=?
                       { psf=?
                       psftype

Description:

   MEM2D is based on the Gull and Skilling Maximum-Entropy package
   MEMSYS3.  It takes an image and a Point-Spread Function as input
   and produces an equal-sized image as output with higher
   resolution.  Facilities are provided to `analyse' the resulting
   deconvolved image, i.e. to calculate an integrated flux in some
   area of the deconvolved image and also an estimate of the
   uncertainty in the integrated flux.  This allows the significance
   of structure visible in the deconvolution to be checked.

   For a detailed description of the algorithm, and further
   references, see the MEMSYS Users' Manual, and SUN/117.
2 Parameters
For information on individual parameters, select from the list below:
3 ANALYSE
ANALYSE = _LOGICAL (Read)
   ANALYSE should be given a TRUE value if an analysis of a
   previously generated deconvolution is to be performed, instead
   of a whole new deconvolution being started.  An analysis
   returns the integrated flux in some area of the deconvolved
   image you specify, together with the standard deviation on the
   integrated flux value.  The area to be integrated over is
   specified by an image associated with parameter MASK.  This
   facility can, for instance, be used to assess the significance
   of structure seen in the deconvolution.  An analysis can only
   be performed if the input NDF (see parameter IN) contains a
   MEM2D extension (see parameter EXTEND).  If the input does
   contain such an extension, and if the extension shows that the
   deconvolution was completed, then ANALYSE is defaulted to
   TRUE, otherwise it is defaulted to FALSE. []
3 DEF
DEF = _REAL (Read)
   This is the value to which the output image will default in
   areas for which there is no valid data in the input.  The `zero
   entropy' image is defined to be a flat surface with value
   given by parameter DEF.  Any deviation of the output image away
   from this image will cause its entropy to become negative.
   Thus a maximum-entropy criterion causes the output image to be
   as similar as possible to a flat surface with value DEF
   (within the constraints of the data).  DEF is defaulted to the
   mean data value in the input image and must always be strictly
   positive. []
3 DSUM
DSUM = _REAL (Write)
   This is an output parameter to which is written the standard
   deviation of the integrated-flux value calculated if an
   analysis is performed (see parameter ANALYSE).
3 EXTEND
EXTEND = _LOGICAL (Read)
   If EXTEND has a TRUE value, then the output NDF will contain
   an extension called MEM2D which will contain all the
   information required to either restart or analyse the
   deconvolution.  Note, including this extension makes the output
   file much bigger (by about a factor of seven).  [TRUE]
3 FWHMICF
FWHMICF = _REAL (Read)
   This is the Full Width at Half Maximum (in pixels) of a
   Gaussian Intrinsic Correlation Function (ICF) to be used in
   the deconvolution.  The ICF can be used to encode prior
   knowledge of pixel-to-pixel correlations in the output image.
   A value of zero for FWHMICF causes no ICF to be used, and so
   no correlations are expected in the output.  Larger values
   encourage smoothness in the output on the scale of the ICF.  If
   a non-zero ICF is used, the image entropy which is maximised
   is not the output image, but a `hidden' image.  This hidden
   image is the deconvolution of the output image with the ICF,
   and is assumed to have no pixel-to-pixel correlations. [2]
3 FWHMPSF
FWHMPSF = _REAL (Read)
   This is the Full Width at Half Maximum (in pixels) of a
   Gaussian Point-Spread Function (PSF).  This PSF is used to
   deconvolve the input only if parameter PSFTYPE has the value
   "Gaussian".
3 ILEVEL
ILEVEL = _INTEGER (Read)
   ILEVEL controls the amount of information displayed as MEM2D
   runs.  If set to zero then no information is displayed.  Larger
   values up to a maximum of 3, give larger amounts of
   information.  A value of 3 gives full MEMSYS3 diagnostics
   after each iteration. [1]
3 IN
IN = NDF (Read)
   The input NDF.  This can either contain an image to be
   deconvolved, or the output from a previous run of MEM2D.  The
   NDF is considered to be an output from MEM2D if it contains an
   extension called MEM2D (see parameter EXTEND).  If such an
   extension is found, a check is made to see if the NDF contains
   a completed deconvolution or a partial deconvolution.  If the
   deconvolution is complete, the ANALYSE parameter is defaulted
   to TRUE, and unless you override this default, an analysis of
   the deconvolution contained in the input NDF is performed.  If
   the input deconvolution is not complete, then the
   deconvolution process is restarted from where it left off.  If
   no MEM2D extension is found, then a new deconvolution is
   started from scratch.
3 MASK
MASK = NDF (Read)
   An image to use as a mask to define the areas to be integrated
   when performing an analysis (see parameter ANALYSE).  The
   integrated-flux value calculated by the analysis is actually
   the total data sum in the product of the mask and the
   deconvolved image.  Mask pixel values can be positive or
   negative (or zero) and so, for instance, masks can be arranged
   which subtract off a background brightness from a source
   before returning the integrated source flux.
3 MODEL
MODEL = NDF (Read)
   An image to use as the default model for the reconstruction.
   If a null value is given, then a constant value given by the
   parameter DEF is used to define a flat default model.  The
   section of the given image which matches the bounds of the
   input image is used.  Any bad pixels in the image cause the
   corresponding pixels in the input image to be ignored.  Such
   pixels are set bad in the output.  The model image should
   contain no pixels with a value of zero or less.  The default
   model is defined to have zero entropy.  The hidden image will
   tend to the default model in the absence of data.  It should be
   noted that this model applies to the `hidden' image, not the
   actually required reconstructed image.  The reconstructed image
   is obtained from the hidden image by blurring the hidden image
   with the ICF. [!]
3 MODELOUT
MODELOUT = NDF (Write)
   An image which can be used for the default model in a further
   run of MEM2D.  Each pixel value in the created image is a
   linear combination of the model value at the corresponding
   pixel in the current reconstruction, and the hidden image
   pixel value.  Pixels for which the hidden image is well away
   from the current model, tend towards the value of the hidden
   image; pixels for which the hidden image is close to the
   current model tend towards the model.  Running MEM2D several
   times, using the new model created on the previous run as the
   model for the current run, can reduce the `mottling' often
   seen in MEM2D reconstructions. [!]
3 NITER
NITER = _INTEGER (Read)
   The maximum number of maximum-entropy iterations to perform.
   MEM2D continues the deconvolution until either MEMSYS3
   indicates that the termination criterion (omega=1.0) has been
   reached, or the maximum number of iterations is reached.  If a
   deconvolution requires more iterations than was allowed by
   NITER, then you can choose to continue the deconvolution by
   giving the prematurely terminated output from MEM2D as the
   input to another run of MEM2D, specifying a larger value for
   NITER. [50]
3 NOISE
NOISE = LITERAL (Read)
   NOISE defines the noise statistics within the input image.  It
   can take the value "Gaussian" or "Poisson".  If Gaussian noise
   is selected, the data variances are set initially to the
   values stored in the VARIANCE component of the input NDF.  If
   no such component exists, then the data variances are set to a
   constant value equal to the RMS difference between adjacent
   pixels in the x direction.  MEMSYS3 scales these initial noise
   estimates to maximise the data `evidence'.  The evidence is
   displayed as "LOG(PROB)" and the noise scaling factor as
   "SIGMA", if parameter ILEVEL is set to 2 or more.  If Poisson
   statistics are selected the uncertainty in each data value is,
   as usual, of the order of the square root of the data value.
   When using Poisson statistics, there is no equivalent to the
   noise scaling performed when using Gaussian statistics.  Any
   input VARIANCE component is ignored. ["Gaussian"]
3 OUT
OUT = NDF (Write)
   The output image in a `primitive' NDF.  The output is the same
   size as the input.  Any pixels which were flagged as bad in
   the input will also be bad in the output.  If parameter EXTEND
   is TRUE, then the output NDF contains an extension called
   MEM2D containing information which allows the deconvolution to
   be either continued or analysed.  There is no VARIANCE
   component in the output, but any QUALITY values are propagated
   from the input to the output.  If parameter UPDATE is TRUE
   then the output NDF is created after the first iteration and
   is updated after each subsequent iteration.
3 PSF
PSF = NDF (Read)
   An NDF holding an estimate of the Point Spread Function (PSF)
   of the input image.  This PSF is used to deconvolve the input
   only if parameter PSFTYPE has the value "NDF".  The PSF can be
   centred anywhere within the image, the location of the centre
   is specified using parameters XCENTRE and YCENTRE.  The
   extent of the PSF actually used is controlled by parameter
   THRESH.
3 PSFTYPE
PSFTYPE = LITERAL (Read)
   PSFTYPE determines if the Point Spread Function used in the
   deconvolution is to be Gaussian (if PSFTYPE = "Gaussian"), or
   is to be defined by an image that you supply (if PSFTYPE
   = "NDF").  ["NDF"]
3 RATE
RATE = _REAL (Read)
   This is the value to use for the MEMSYS3 RATE parameter.  It
   determines the rate at which the convergence is allowed to
   proceed.  If RATE is high, each maximum-entropy iteration is
   allowed to make a big change to the current reconstruction.
   This can cause numeric problems within MEMSYS3 resulting in
   MEM2D crashing with a "floating overflow" error.  If this
   happens, try reducing RATE.  Useful values will normally be of
   the order of unity, and must lie in the interval 0.0001 to
   100.  [0.5]
3 SUM
SUM = _REAL (Write)
   This is an output parameter to which is written the
   integrated-flux value calculated if an analysis is performed
   (see parameter ANALYSE).
3 THRESH
THRESH = _REAL (Read)
   The fraction of the PSF peak amplitude at which the extents of
   the NDF PSF are determined.  It must be positive and less than
   0.5.  This parameter is only used when PSFTYPE = "NDF".  An
   error will result if the input PSF is truncated above this
   threshold. [0.0625]
3 TITLE
TITLE = LITERAL (Read)
   A title for the output NDF.  A null (!) value means using the
   title of the input NDF.  [!]
3 UPDATE
UPDATE = _LOGICAL (Read)
   If UPDATE is given a TRUE value, then the output NDF will be
   created after the first iteration, and will then be updated
   after each subsequent iteration.  This means that the current
   reconstruction can be examined without aborting the
   application.  Also, if parameter EXTEND is TRUE, then if the
   job aborts for any reason, it can be restarted from the last
   completed iteration (see parameter IN). [TRUE]
3 XCENTRE
XCENTRE = _INTEGER (Read)
   The x pixel index of the centre of the PSF within the supplied
   PSF image.  This is only required if PSFTYPE is NDF.  XCENTRE
   is defaulted to the middle pixel (rounded down if there are an
   even number of pixels per line). []
3 YCENTRE
YCENTRE = _INTEGER (Read)
   The y pixel index (line number) of the centre of the PSF
   within the supplied PSF image.  This is only required if
   PSFTYPE is NDF.  YCENTRE is defaulted to the middle line
   (rounded down if there are an even number of lines). []
2 Examples
mem2d m51 m51_hires psftype=gaussian fwhmpsf=3
   This example deconvolves the data array in the NDF called m51,
   putting the resulting image in the data array of the NDF called
   m51_hires.  A circular Gaussian Point-Spread Function is used
   with a Full Width at Half Maximum of 3 pixels.

mem2d m51 m51_hires psf=star xcentre=20 ycentre=20
   This example performs the same function as the previous
   example, but the PSF is defined by the data array of the NDF
   called star, instead of being defined to be Gaussian.  This
   allows the PSF to be any arbitrary 2-dimensional function.
   NDF star could be produced for example, by the KAPPA
   application called PSF.  Parameters XCENTRE and YCENTRE give
   the pixel indices of the centre of the beam defined by the PSF
   in star.  The PSF is truncated to one sixteenth of its peak
   amplitude.

mem2d m51_hires m51_hires niter=70 psf=star
   If the previous example failed to converge within the default
   50 iterations, the deconvolution can be started again from
   its current state, rather than having to start again from
   scratch.  Here NITER gives the upper limit on the total number
   of iterations which can be performed (including those performed
   in the previous run of MEM2D), NOT just the number performed in
   this single run of MEM2D.  This facility can also be used if a
   MEM2D run is interrupted for any reason, such as the host
   computer going down, or a batch-queue CPU limit being reached.
   To use this facility the parameters EXTEND and UPDATE should
   have the default values of TRUE.

mem2d m51_hires mask=nucleus
   Once a deconvolved image has been produced, the significance
   of features seen in the deconvolution can be assessed.  This
   example takes in the NDF m51_hires produced by a previous run
   of MEM2D.  If this is a completed deconvolution then the
   parameter ANALYSE will be defaulted to TRUE, and an analysis
   will be performed.  This effectively results in the
   deconvolution being multiplied by the data array of the NDF
   called nucleus, and the total data sum in the resulting image
   being displayed, together with the standard deviation on the
   total data sum.  The image in m51_hires is the most probable
   deconvolution, but there may be other deconvolutions only
   slightly less probable than m51_hires.  The standard deviation
   produced by an analysis takes account of the spread between
   such deconvolutions.  If the total data sum is not
   significantly greater than the standard deviation, then the
   feature selected by the mask image (called nucleus in this
   case) may well be spurious.  The mask image itself may for
   instance consist of an area of uniform value +1 covering some
   feature of interest, and the bad value (or equivalently the
   value zero) everywhere else.  The analysis would then give the
   integrated flux in the feature, assuming that the background
   is known to be zero.  If the background is not zero, then the
   mask may contain a background region containing the value -1,
   of equal area to the region containing the value +1.  The
   resulting integrated flux would then be the total flux in the
   source minus the flux in a background region of equal area.
2 Notes
-  MEM2D requires a large quantity of memory--- almost as much as
the rest of KAPPA.  In order for the KAPPA monolith to load
without you having to increase your memory or datasize resources,
and because MEM2D is batch oriented (see Timing) it is only
available as a separate application.

-  Memory is required to store several intermediate images while
the deconvolution is in progress.  If the input image is small
enough, these images are stored in a statically declared, internal
array.  Otherwise, they are stored in dynamically mapped external
arrays.  There is no limit on the size of image which can be
processed by MEM2D (other than those imposed by limited resources
on the host computer).

-  It is sometimes desirable for the pixels in the output image
to be smaller than those in the input image.  For instance, if
the input data are critically sampled (two samples per PSF), the
output image may not be a very good deconvolution.  In such cases
sub-dividing the output pixels would give better results.  At the
moment MEM2D cannot do this.  Be warned that sub-dividing the
input pixels and then running the current version of MEM2D will
not have the same effect, since the noise in the input image will
then have pixel-to-pixel correlations, and be interpreted as real
structure.
2 Timing
   MEM deconvolution is extremely CPU intensive.  The total CPU time
   taken depends partly on the size of the image, and partly on the
   complexity of the structure within the image.  As a typical
   example, a 100x100 image containing 20 Gaussians on a flat
   background took about 34 minutes of elapsed time on an unloaded
   DEC Alpha 2000.  Deconvolution jobs should therefore always be
   done in batch.  To perform an analysis on a deconvolution takes
   about the same length of time as a single deconvolution
   iteration.
2 Related_Applications
   KAPPA: FOURIER, LUCY, WIENER.
2 Authors
DSB: David Berry (STARLINK)

MJC: Malcolm J. Currie (STARLINK)
2 History
 24-SEP-1990 (DSB):
    Original version.

 26-FEB-1991 (DSB):
    MODEL and MODELOUT parameters added.

 27-FEB-1991 (DSB):
    KAPPA subroutine prefixes added (KPS_ and KPG_)

 1991 July 4 (MJC):
    Propagated AXIS and UNITS.  Added Usage and Implementation
    Status to the documentation.  Made error reports more helpful
    and added a missing bad status assignment.

 1991 July 18 (MJC):
    Called renamed routines---KPS1_MEM*.

 1991 October 18 (MJC):
    Added the THRESH parameter.

 1992 March 3 (MJC):
    Replaced AIF parameter-system calls by the extended PAR
    library.

 1992 April 13 (MJC):
    Made to handle significant dimensions for user-defined
    sections.

 1992 October 15 (MJC):
    Increased the permitted length of the image name stored in the
    MEM2D extension from 40 to 132.

 22-FEB-1995 (DSB):
    Comments re-formatted to edstar style.  Replace AIF VM routines
    with PSX.  Replaced calls to NDF_ASSOC, KPG1_SGDIM, etc. with a
    single call to KPG1_GTNDF.  "Usage" and "Examples" commands
    in the prologue converted to lower case.  Removed calls to
    FTSIZE since the FFTPACK routines can handled images of any
    size.  Increased the size of each image until one image will
    provide enough workspace for the FFT routines.

 20-MAR-1995 (DSB):
    Modified to allow use of external storage for intermediate
    files.  This removes the restriction on the size of image
    which can be deconvolved using MEM2D.

 1995 April 10 (MJC):
    Corrected typo's, and made minor stylistic changes and
    improvements to the documentation including a Related
    Applications section.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   VARIANCE, LABEL, TITLE, UNITS, WCS and HISTORY components of an NDF
   data structure and propagates all extensions.

   -  Processing of bad pixels and automatic quality masking are
   supported, though only to remove them by the DEF value.

   -  All non-complex numeric data types can be handled.  Arithmetic is
   performed using single-precision floating point.
1 MLINPLOT
Draws a multi-line plot of the data values in a 2-dimensional NDF.

Usage:

   mlinplot ndf [comp] lnindx [mode] [xleft] [xright] [ybot] [ytop]
            [device]

Description:

   This application plots a set of curves giving array value against
   position in a 2-dimensional NDF. All the curves are drawn within a
   single set of annotated axes. Each curve is displaced vertically by
   a specified offset to minimise overlap between the curves. These
   offsets may be chosen automatically or specified by the user (see
   parameter SPACE). The curves may be drawn in several different ways
   such as a "join-the-dots" plot, a "staircase" plot, a "chain" plot,
   etc, (see parameter MODE).

   The data represented by each curve can be either a row or column
   (chosen using parameter ABSAXS) of any array component within the
   supplied NDF (see parameter COMP). Vertical error bars may be drawn if
   the NDF contains a Variance component (see parameter ERRBAR). The
   vertical axis of the plot represents array value (or the logarithm of
   the array value - see parameter YLOG). The horizontal axis represents
   position, and may be annotated using an axis selected from the Current
   Frame of the NDF (see parameter USEAXIS).

   Each curve may be labelled using its pixel index or a label specified
   by the user (see parameters LINLAB and LABELS). The appearance of these
   labels (size, colour, font, horizontal position, etc.) can be
   controlled using parameter STYLE. A key may be produced to the left
   of the main plot listing the vertical offsets of the curves (see
   parameter KEY). The appearance of the key may be controlled using
   parameter KEYSTYLE. Its position may be controlled using parameter
   KEYOFF. Markers indicating the zero point for each curve may also be
   drawn within the main plot (see parameter ZMARK).

   The bounds of the plot on both axes can be specified using
   parameters XLEFT, XRIGHT, YBOT and YTOP. If not specified they take
   default values which encompass the entire supplied data set. The
   current picture is usually cleared before plotting the new picture,
   but parameter CLEAR can be used to prevent this, allowing several
   plots to be "stacked" together. If a new plot is drawn over an
   existing plot, then the bounds of the new plot are set automatically
   to the bounds of the existing plot (XLEFT, XRIGHT, YBOT and YTOP are
   then ignored).
2 Parameters
For information on individual parameters, select from the list below:
3 ABSAXS
ABSAXS = _INTEGER (Read)
   This selects whether to plot rows or columns within the NDF.
   If ABSAXS is 1, each curve will represent the array values within
   a single row of pixels within the NDF. If it is 2, each curve will
   represent the array values within a single column of pixels within
   the NDF. [1]
3 AXES
AXES = _LOGICAL (Read)
   TRUE if labelled and annotated axes are to be drawn around the
   plot. The dynamic default is FALSE if the plot is being
   aligned with an existing plot (see parameter CLEAR), and
   TRUE otherwise. Parameters USEAXIS and YLOG determine the
   quantities used to annotated the horizontal and vertical axes
   respectively. The width of the margins left for the annotation
   may be controlled using parameter MARGIN. The appearance of the
   axes (colours, fonts, etc) can be controlled using the parameter
   STYLE. []
3 CLEAR
CLEAR = _LOGICAL (Read)
   If TRUE the current picture is cleared before the plot is
   drawn. If CLEAR is FALSE not only is the existing plot retained,
   but also the previous plot is used to specify the axis limits.
   [TRUE]
3 COMP
COMP = LITERAL (Read)
   The NDF component to be plotted.  It may be "Data", "Quality",
   "Variance", or "Error" (where "Error" is an alternative to
   "Variance" and causes the square root of the variance values
   to be displayed).  If "Quality" is specified, then the quality
   values are treated as numerical values (in the range 0 to
   255). ["Data"]
3 DEVICE
DEVICE = DEVICE (Read)
   The plotting device. [current graphics device]
3 ERRBAR
ERRBAR = _LOGICAL (Read)
   TRUE if vertical error bars are to be drawn. This is only
   possible if the NDF contains a Variance component, and parameter
   COMP is set to "Data". The length of the error bars (in terms of
   standard deviations) is set by parameter SIGMA. The appearance
   of the error bars (width, colour, etc) can be controlled using
   parameter STYLE. See also parameter FREQ. [FALSE]
3 FREQ
FREQ = _INTEGER (Read)
   The frequency at which error bars are to be plotted.  For
   instance, a value of 2 would mean that alternate points have
   error bars plotted.  This lets some plots be less cluttered.
   FREQ must lie in the range 1 to half of the number of points
   to be plotted.  FREQ is only accessed when parameter ERRBAR is
   TRUE.  [1]
3 KEY
KEY = _LOGICAL (Read)
   TRUE if a key giving the offset of each curve is to be produced.
   The appearance of this key can be controlled using parameter
   KEYSTYLE, and its position can be controlled using parameter
   KEYPOS. [TRUE]
3 KEYPOS
KEYPOS() = _REAL (Read)
   Two values giving the position of the key. The first value gives
   the gap between the right hand edge of the contour map and the left
   hand edge of the key (0.0 for no gap, 1.0 for the largest gap). The
   second value gives the vertical position of the top of the key (1.0
   for the highest position, 0.0 for the lowest). If the second value
   is not given, the top of the key is placed level with the top of the
   contour map. Both values should be in the range 0.0 to 1.0. If a
   key is produced, then the right hand margin specified by parameter
   MARGIN is ignored. [current value]
3 KEYSTYLE
KEYSTYLE = GROUP (Read)
   A group of attribute settings describing the plotting style to use
   for the key (see parameter KEY).

   A comma-separated list of strings should be given in which each
   string is either an attribute setting, or the name of a text file
   preceded by an up-arrow character "^". Such text files should
   contain further comma-separated lists which will be read and
   interpreted in the same manner. Attribute settings are applied in
   the order in which they occur within the list, with later settings
   over-riding any earlier settings given for the same attribute.

   Each individual attribute setting should be of the form:

      <name>=<value>

   where <name> is the name of a plotting attribute, and <value> is
   the value to assign to the attribute. Default values will be
   used for any unspecified attributes. All attributes will be
   defaulted if a null value (!) is supplied. See section "Plotting
   Attributes" in SUN/95 for a description of the available
   attributes. Any unrecognised attributes are ignored (no error is
   reported).

   The heading in the key can be changed by setting a value for the
   Title attribute (the supplied heading is split into lines of no more
   than 17 characters). The appearance of the heading is controlled
   by attributes Colour(Title), Font(Title), etc. The appearance of
   the curve labels is controlled by attributes Colour(TextLab),
   Font(TextLab), etc (the synonym Labels can be used in place of
   TextLab). The appearance of the offset values is controlled by
   attributes Colour(NumLab), Font(NumLab), etc (the synonym Offset
   can be used in place of NumLab). Offset values are formatted
   using attributes Format(2), etc (the synonym Offset can be used in
   place of the value 2). [current value]
3 LABELS
LABELS = LITERAL (Read)
   A group of strings with which to label the plotted curves. A
   comma-separated list of strings should be given, or the name
   of a text file preceded by an up-arrow character "^". Such text
   files should contain further comma-separated lists which will be
   read and interpreted in the same manner. The first string
   obtained is used as the label for the first curve requested
   using parameter LNINDX, the second string is used as the label
   for the second curve, etc. If the number of supplied strings is
   less than the number of curves requested using LNINDX, then
   extra default labels are used. These are equal to the NDF pixel
   index of the row or column, preceded by a hash character ("#").
   If a null (!) value is supplied for LABELS, then default labels are
   used for all curves. [!]
3 LINLAB
LINLAB = _LOGICAL (Read)
   If TRUE, the curves in the plot will be labelled using the labels
   specified by parameter LABELS. A single label is placed in-line
   with the curve. The horizontal position and appearance of these
   labels can be controlled using parameter STYLE. [TRUE]
3 LNINDX
LNINDX = LITERAL (Read)
   Specifies the NDF pixel indices of the rows or columns to be
   displayed (see parameter ABSAXS). A maximum of 100 lines may be
   selected.  It can take any of the following values:

   - "ALL" or "*" --  All lines (rows or columns).

   - "xx,yy,zz" -- A list of line indices.

   - "xx:yy" --  Line indices between xx and yy inclusively.  When
   xx is omitted the range begins from the lower bound of the line
   dimension; when yy is omitted the range ends with the maximum
   value it can take, that is the upper bound of the line dimension
   or the maximum number of lines this routine can plot.

   - Any reasonable combination of above values separated by commas.
3 MARGIN
MARGIN( 4 ) = _REAL (Read)
   The widths of the margins to leave around the contour map for axis
   annotation. The widths should be given as fractions of the
   corresponding dimension of the current picture. Four values may be
   given, in the order; bottom, right, top, left. If fewer than four
   values are given, extra values are used equal to the first supplied
   value. If these margins are too narrow any axis annotation may be
   clipped. See also parameter KEYPOS. [current value]
3 MARKER
MARKER = _INTEGER (Read)
   This parameter is only accessed if parameter MODE is set to
   "Chain" or "Mark". It specifies the symbol with which each
   position should be marked, and should be given as an integer
   PGPLOT marker type. For instance, 0 gives a box, 1 gives a dot,
   2 gives a cross, 3 gives an asterisk, 7 gives a triangle. The
   value must be larger than or equal to -31. [current value]
3 MODE
MODE = LITERAL (Read)
   Specifies the way in which each curve is drawn. MODE can take the
   following values:

   - "Histogram" -- An histogram of the points is plotted in the
   style of a "staircase" (with vertical lines only joining the y
   values and not extending to the base of the plot).  The vertical
   lines are placed midway between adjacent x positions.

   - "Line" -- The points are joined by straight lines.

   - "Point" -- A dot is plotted at each point.

   - "Mark" -- Each point is marker with a symbol specified by
   parameter MARKER.

   - "Chain" -- A combination of "Line" and "Mark".

   [current value]
3 NDF
NDF = NDF (Read)
   NDF structure containing the array to be plotted.
3 OFFSET
OFFSET() = _DOUBLE (Read)
   This parameter is used to obtain the vertical offsets for the data
   curve when parameter SPACE is given the value "Free". The number
   of values supplied should equal the number of curves being drawn.
3 PENS
PENS = GROUP (Read)
   A group of strings, separated by semi-colons, each of which specifies
   the appearance of a pen to be used to draw a curve. The first
   string in the group describes the pen to use for the first curve,
   the second string describes the pen for the second curve, etc. If
   there are fewer strings than curves, then the supplied pens are
   cycled through again, starting at the beginning. Each string should
   be a comma-separated list of plotting attributes to be used when drawing
   the curve. For instance, the string "width=0.02,colour=red,style=2"
   produces a thick, red, dashed curve. Attributes which are
   unspecified in a string default to the values implied by parameter
   STYLE. If a null value (!) is given for PENS, then the pen
   attributes implied by parameter STYLE are used. [!]
3 SIGMA
SIGMA = LITERAL (Read)
   If vertical error bars are produced (see parameter ERRBAR), then
   SIGMA gives the number of standard deviations which the error
   bars are to represent. [current value]
3 SPACE
SPACE = LITERAL (Read)
   The value of this parameter specifies how the vertical offset for
   each data curve is determined. It should be given one of
   the following values:

   - "Average" -- The offsets are chosen automatically so that
   the average data values of the curves are evenly spaced between
   the upper and lower limits of the plotting area.  Any line-
   to-line striping is thus hidden and the amount of overlap of
   adjacent traces is minimised.

   - "Constant" -- The offsets are chosen automatically so that
   the zero points of the curves are evenly spaced between the upper
   and lower limits of the plotting area.  The width of any line-
   to-line strip is constant, which could result in the curves
   becoming confused if the bias of a curve from its zero point is
   so large that it overlaps another curve.

   - "Free" -- The offsets to use are obtained explicitly using
   parameter OFFSET.

   - "None" -- No vertical offsets are used. All curves are
   displayed with the same zero point.

   The input can be abbreviated to an unambiguous length and
   is case insensitive. ["Average"]
3 STYLE
STYLE = LITERAL (Read)
   A group of attribute settings describing the plotting style to use
   when drawing the annotated axes, data curves, error bars, zero
   markers and curve labels.

   A comma-separated list of strings should be given in which each
   string is either an attribute setting, or the name of a text file
   preceded by an up-arrow character "^". Such text files should
   contain further comma-separated lists which will be read and
   interpreted in the same manner. Attribute settings are applied in
   the order in which they occur within the list, with later settings
   over-riding any earlier settings given for the same attribute.

   Each individual attribute setting should be of the form:

      <name>=<value>

   where <name> is the name of a plotting attribute, and <value> is
   the value to assign to the attribute. Default values will be
   used for any unspecified attributes. All attributes will be
   defaulted if a null value (!) is supplied. See section "Plotting
   Attributes" in SUN/95 for a description of the available
   attributes. Any unrecognised attributes are ignored (no error is
   reported).

   The appearance of the data curves is controlled by the attributes
   Colour(Curves), Width(Curves), etc (the synonym Lines may be used
   in place of Curves). The appearance of markers used if parameter
   MODE is set to "Point", "Mark" or "Chain" is controlled by
   Colour(Markers), Width(Markers), etc (the synonym Symbols may be
   used in place of Markers). The appearance of the error bars is
   controlled using Colour(ErrBars), Width(ErrBars), etc. (see
   parameter ERRBAR). The appearance of the zero point markers is
   controlled using Colour(ZeroMark), Size(ZeroMark), etc. The
   appearance of the curve labels is controlled using Colour(Labels),
   Size(Labels), etc. LabPos(Left) controls the horizontal position
   of the in-line curve label (see parameter LINLAB), and
   LabPos(Right) controls the horizontal position of the curve
   label associated with the right hand zero point marker (see
   parameter ZMARK). LabPos without any qualifier is equivalent to
   LabPos(Left). LabPos values are floating point, with 0.0 meaning
   the left edge of the plotting area, and 1.0 the right edge. Values
   outside the range 0 to 1 may be used. [current value]
3 USEAXIS
USEAXIS = LITERAL (Read)
   The index of the axis which is to be used to annotate the
   horizontal axis of the plot. It must be less than or equal to
   the number of axes in the current co-ordinate Frame of the NDF.

   The quantity used to annotate the horizontal axis must have a
   defined value at all points in the array, and must increase or
   decrease monotonically along the array. For instance, if RA is
   used to annotate the horizontal axis, then an error will be
   reported if the profile passes through RA=0 because it will
   introduce a non-monotonic jump in axis value (from 0h to 24h, or
   24h to 0h). [1]
3 XLEFT
XLEFT = LITERAL (Read)
   The axis value to place at the left hand end of the horizontal
   axis. The dynamic default is the value for the first element in the
   data being displayed. The value supplied may be greater than or
   less than the value supplied for XRIGHT. A formatted value for the
   quantity specified by parameter USEAXIS should be supplied. []
3 XRIGHT
XRIGHT = LITERAL (Read)
   The axis value to place at the right hand end of the horizontal
   axis. The dynamic default is the value for the last element in the
   data being displayed. The value supplied may be greater than or
   less than the value supplied for XLEFT. A formatted value for the
   quantity specified by parameter USEAXIS should be supplied. []
3 YBOT
YBOT = _DOUBLE (Read)
   The data value to place at the bottom end of the vertical axis.
   The dynamic default is the lowest data value to be displayed,
   after addition of the vertical offsets. The value supplied may be
   greater than or less than the value supplied for YTOP. []
3 YLOG
YLOG = _LOGICAL (Read)
   TRUE if the value displayed on the vertical axis is to be the
   logarithm of the supplied data values. If TRUE, then the values
   supplied for parameters YTOP and YBOT should be values for the
   logarithm of the data value, not the data value itself. [FALSE]
3 YTOP
YTOP = _DOUBLE (Read)
   The data value to place at the top end of the vertical axis.
   The dynamic default is the highest data value to be displayed,
   after addition of the vertical offsets. The value supplied may be
   greater than or less than the value supplied for YBOT. []
3 ZMARK
ZMARK = _LOGICAL (Read)
   If TRUE, then a pair of short horizontal lines are drawn at the left
   and right edges of the main plot for each curve. The vertical
   position of these lines corresponds to the zero point for the
   corresponding curve. The right hand marker is annotated with the
   curve label (see parameter LABELS). The appearance of these
   markers can be controlled using the parameter STYLE. [TRUE]
2 Examples
mlinplot rcw3_b1 reset \
   Plot the first five rows of the 2-dimensional NDF file,
   rcw3_b1 on the current graphics device. The lines are offset
   such that the averages of the rows are evenly separated in the
   direction of the vertical axis.

mlinplot rcw3_b1 lnindx="1,3,5,7:10" \
   Plot the rows 1, 3, 5, 7, 8, 9 and 10 of the 2-dimensional
   NDF file, rcw3_b1, on the current graphics device.

mlinplot rcw3_b1 lnindx=* \
   Plot all rows of the 2-dimensional NDF file, rcw3_b1, on the
   current graphics device.

mlinplot rcw3_b1 absaxs=2 lnindx="20:25,30,31" \
   Plot columns 20, 21, 22, 23, 24, 25, 30 and 31 of the
   2-dimensional NDF file, rcw3_b1, on the current graphics device.

mlinplot rcw3_b1 style="Title=CRDD rcw3_b1" \
   Plot the currently selected rows of the 2-dimensional NDF
   file, rcw3_b1, on the current graphics device. The plot has a
   title of "CRDD rcw3_b1".

mlinplot rcw3_b1(100:500,) ybot=0.0 ytop=1.0E-3 \
   Plot the currently selected rows of the 2-dimensional NDF, rcw3_b1,
   between column 100 and column 500.  The vertical display range is
   from 0.0 to 1.0E-3.

mlinplot rcw3_b1 space=constant device=ps_p \
   Plot the currently selected rows of the 2-dimensional NDF
   file, rcw3_b1, on the ps_p device.  The base lines are evenly
   distributed over the range of the vertical axis.

mlinplot rcw3_b1 space=free offset=[0.,2.0E-4,4.0E-4,6.0E-4,0.1] \
   Plot the currently selected rows of the 2-dimensional NDF
   file, rcw3_b1. The base lines are set at 0.0 for the first row,
   2.0E-4 for the second, 4.0E-4 for the third, 6.0E-4 for the fourth
   and 0.1 for the fifth.
2 Notes
-  The Title component in the NDF is used as the default title for
the annotated axes. If the NDF does not have a Title component, then
the default title is taken from current co-ordinate Frame in the NDF.
This default may be over-ridden by specifying a value for the Title
attribute using the STYLE parameter.

-  The application stores a number of pictures in the graphics
database in the following order: a FRAME picture containing the
annotated axes, data plot, and optional key; a KEY picture to store
the key if present; and a DATA picture containing just the data plot.
Note, the FRAME picture is only created if annotated axes or a key
has been drawn, or if non-zero margins were specified using parameter
MARGIN.
2 Related_Applications
   KAPPA: LINPLOT; Figaro: ESPLOT, IPLOTS, MSPLOT, SPLOT, SPECGRID.
2 Authors
Malcolm Currie STARLINK (RAL::CUR)

DSB: David S. Berry (STARLINK)
2 History
 16-AUG-1999 (DSB):
    Original AST version, based on earlier version by MJC.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, VARIANCE,
   QUALITY, LABEL, TITLE, WCS and UNITS components of the NDF.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.  Only
   double-precision floating-point data can be processed directly.
   Other non-complex data types will undergo a type conversion
   before the plot is drawn.
1 MSTATS
    Does cumulative statistics on a 2-d sub-array over a sequence of
    data arrays
 
   This routine is used for the statistics of multiple 2-d data
   arrays. The data arrays must have the same dimensions and reside
   in IMAGE structures. The user is asked to specify a number of
   data arrays (up to a fixed limit) either by naming each file
   or defining a sequence of IMAGE structures (frames). If the latter
   option is chosen the files must adopt the following naming scheme:
   groupnamennnn, where nnnn is a four-digit number, and groupname is
   the collective name for the set of arrays, e.g. ORION0001. Missing
   container files, data arrays, or data arrays of the wrong
   dimensions are skipped. The maximum number of data files is 1000.
 
   Then either Single pixel or Box mode is chosen. In the former
   case the pixel of interest is specified, and in the latter, the
   sub-array of interest. In the Single pixel mode, the value for the
   same pixel is pulled out of each array in sequence, and this
   sequence of values is then statistically analysed over the
   sequence of input frames. The resultant values (mean, median
   and standard deviation) are reported directly to the user.
   In Box mode, a choice of statistics is selected.  The alternatives
   are mean and standard deviation (the default), or median. The
   statistic(s) are formed over the sequence of arrays at each pixel
   position in the box. The output is in the form of one or two 2-d
   data arrays, each being the size of the defined sub-array and
   contains a chosen statistic (mean, standard deviation or median)
   in each pixel. Each output data array is stored in an IMAGE
   structure.
 
   The magic-value method is used for processing bad data.
2 AUTHORS
   Mark McCaughrean UoE ( REVA::MJM )
   Malcolm Currie  STARLINK (RAL::CUR)
2 BUGS
   None known.
2 HISTORY
   03-06-1986 : First implementation (REVA::MJM)
   15-06-1986 : Major upgrade for result image outputting (REVA::MJM)
   1986 Aug 7 : Renamed routines NEXT_NAME, SLICE2TO3, STATS3D to
                NXTNAM, SLC2T3, STAT3D respectively. SLC2T3 parameter
                order corrected (7th to 9th) (RAL::CUR).
   1986 Sep 1 : Added arguments section, nearly conformed to Starlink
                standards, replaced UPCASE by CHR_UCASE and tidied
                (RAL::CUR).
   1987 Oct 17: Two extra status checks (RAL::CUR)
   1988 Feb 19: Added check for equality of arrays' dimensions
                (RAL::CUR).
   1988 Mar 16: Tidied workspace using AIF_ANTMP (RAL::CUR).
   1988 Mar 17: Referred to `array' rather than `image'
                (RAL::CUR)
   1988 Jun 21: More reporting of error context and tidying
                (RAL::CUR)
   1989 May 26: Added ordered statistics option (RAL::CUR).
   1989 Aug  8: Passed array dimensions as separate variables
                to MED3D, SLC2T3 and STAT3D (RAL::CUR).
   1989 Dec 21: Workspace managed by AIF_TEMP (RAL::CUR).
   1990 Feb 22: Replaced SUBPAR calls by AIF_PTFNM (RAL::CUR).
   1992 Feb 26: Limited processing of simple NDFs (RAL::CUR).
   1992 Mar  3: Replaced AIF parameter-system calls by the extended
                PAR library (RAL::CUR).
2 PARAMETERS
   INMODE  =  CHAR( READ )
       Mode of data array input, the alternatives being
         'Sequential' or 'Random'.
   PIXMODE  =  CHAR( READ )
       Mode of calculation, the alternatives being a 'Single'
         pixel or a 'Box' of pixels.
   INPIC  =  IMAGE( READ )
       One of the sequence of input IMAGE structures.
   FIRSTFILE  =  CHAR( READ )
       Name of first container filename in the sequence.
   NUMSEQ  =  INTEGER( READ )
       Number of sequential frames to be processed.
   NUMRAN  =  INTEGER( READ )
       Number of random frames to be processed.
   XPIX  = INTEGER( READ )
       x pixel index of the pixel to be used in Single mode.
   YPIX  = INTEGER( READ )
       y pixel index of the pixel to be used in Single mode.
   ORDRST  =  LOGICAL( READ )
       If true ordered statistics will be computed in Box mode,
         currently only the median, otherwise the mean and standard
         deviation are derived.
   XSTART  =  INTEGER( READ )
       x start pixel index of the sub-arrays to be analysed.
   YSTART  =  INTEGER( READ )
       y start pixel index of the sub-arrays to be analysed.
   XSIZE  =  INTEGER( READ )
       x size of the sub-array to be analysed.
   YSIZE  =  INTEGER( READ )
       y size of the sub-array to be analysed.
   MEDIAN  =  IMAGE( WRITE )
       Output IMAGE structure containing array of medians for Box
         option.
   OMTITLE  =  CHAR( READ )
       Title string for IMAGE structure containing the median array.
   MEAN  =  IMAGE( WRITE )
       Output IMAGE structure containing array of means for Box
         option.
   MTITLE  =  CHAR( READ )
       Title string for IMAGE structure containing the mean array.
   STDDEV  =  IMAGE( WRITE )
       Output IMAGE structure containing standard deviations for Box
         option.
   STITLE  =  CHAR( READ )
       Title string for IMAGE structure containing the standard-
         deviation array.
3 INMODE
  keyword     'INMODE'
  type        'LITERAL'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC,DEFAULT'
  prompt      'File input mode'
  default     'Sequential'
  help        'Sequential works out a sequence from the first
              IMAGE name, Random asks for each name.'
 #in          'Sequential', 'Random'
3 PIXMODE
  keyword     'PIXMODE'
  type        'LITERAL'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC,DEFAULT'
  prompt      'Pixel mode'
  default     'Box'
  help        'Single is for just one pixel, Box is for a defined 
              sub-array'
 #in          'Box', 'Single'
3 INPIC
  keyword     'INPIC'
  type        'IMAGE'
  access      'READ'
  vpath       'PROMPT'
  ppath       'GLOBAL'
  association '<->GLOBAL.DATA_ARRAY'
  prompt      'Image to be processed'
  help        'Give name of the IMAGE structure holding the 2-d data 
              array to be processed.'
3 FIRSTFILE
  keyword     'FIRSTFILE'
  type        'LITERAL'
  access      'READ'
  vpath       'PROMPT'
  prompt      'Name of first file'
  help        'Give name of first IMAGE file in sequence to be 
              processed. Format for sequential is namennnn, e.g. 
              SKY0010.'
3 NUMSEQ
  keyword     'NUMSEQ'
  type        '_INTEGER'
  access      'READ'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'Number of frames in sequence'
  help        'Give the number of frames in sequence (including first 
              and last), e.g. there are 10 frames in F0011 to F0020.'
3 NUMRAN
  keyword     'NUMRAN'
  type        '_INTEGER'
  access      'READ'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'Number of random frames'
  help        'Give the number of frames to be typed in by hand, one 
              by one.'
3 XPIX
  keyword     'XPIX'
  type        '_INTEGER'
  access      'READ'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'x pixel index of pixel'
  help        'Give the x pixel index of the single pixel to be 
              examined.'
3 YPIX
  keyword     'YPIX'
  type        '_INTEGER'
  access      'READ'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'y pixel index of pixel'
  help        'Give the y pixel index of the single pixel to be 
              examined.'
3 ORDRST
  keyword     'ORDRST'
  type        '_LOGICAL'
  access      'READ'
  vpath       'DEFAULT'
  ppath       'DYNAMIC,DEFAULT'
  prompt      'Are ordered statistics required ?'
  default     NO
  help        'If no arrays containing means and standard deviations 
              will be created, else an array of medians is produced.'
3 XSTART
  keyword     'XSTART'
  type        '_INTEGER'
  access      'READ'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'x start pixel index of sub-array'
  help        'Give the x start pixel index of the sub-array to be 
              analysed.'
3 YSTART
  keyword     'YSTART'
  type        '_INTEGER'
  access      'READ'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'y start pixel index of sub-array'
  help        'Give the y start pixel index of the sub-array to be 
              analysed.'
3 XSIZE
  keyword     'XSIZE'
  type        '_INTEGER'
  access      'READ'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'x size of sub-array'
  help        'Give the x size of the sub-array to be analysed.'
3 YSIZE
  keyword     'YSIZE'
  type        '_INTEGER'
  access      'READ'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'y size of sub-array'
  help        'Give the y size of the sub-array to be analysed.'
3 MEDIAN
  keyword     'MEDIAN'
  type        'IMAGE'
  access      'WRITE'
  vpath       'PROMPT'
  prompt      'Output array for medians'
  help        'Give the name of the IMAGE structure to hold the array 
              of medians.'
3 OMTITLE
  keyword     'OMTITLE'
  type        'LITERAL'
  access      'READ'
  vpath       'DEFAULT'
  default     'KAPPA - Mstats - Medians'
  prompt      'Title for medians array'
  help        'Character string used as title for the IMAGE structure 
              holding medians array.'
3 MEAN
  keyword     'MEAN'
  type        'IMAGE'
  access      'WRITE'
  vpath       'PROMPT'
  prompt      'Output array for means'
  help        'Give the name of the IMAGE structure to hold the array 
              of means.'
3 MTITLE
  keyword     'MTITLE'
  type        'LITERAL'
  access      'READ'
  vpath       'DEFAULT'
  default     'KAPPA - Mstats - Means'
  prompt      'Title for means array'
  help        'Character string used as title for the IMAGE structure 
              holding means array.'
3 STDDEV
  keyword     'STDDEV'
  type        'IMAGE'
  access      'WRITE'
  vpath       'PROMPT'
  prompt      'Output array for standard deviations'
  help        'Give the name of the IMAGE structure to hold the array 
              of standard deviations.'
3 STITLE
  keyword     'STITLE'
  type        'LITERAL'
  access      'READ'
  vpath       'DEFAULT'
  prompt      'Title for standard deviation array'
  default     'KAPPA - Mstats - Stddevs'
  help        'Character string used as title for the IMAGE structure 
              holding standard-deviation array.'

1 MULT
Multiplies two NDF data structures.

Usage:

   mult in1 in2 out

Description:

   The routine multiplies two NDF data structures pixel-by-pixel to
   produce a new NDF.
2 Parameters
For information on individual parameters, select from the list below:
3 IN1
IN1 = NDF (Read)
   First NDF to be multiplied.
3 IN2
IN2 = NDF (Read)
   Second NDF to be multiplied.
3 OUT
OUT = NDF (Write)
   Output NDF to contain the product of the two input NDFs.
3 TITLE
TITLE = LITERAL (Read)
   Value for the title of the output NDF.  A null value will cause
   the title of the NDF supplied for parameter IN1 to be used
   instead. [!]
2 Examples
mult a b c
   This multiplies the NDF called a by the NDF called b, to make
   the NDF called c.  NDF c inherits its title from a.

mult out=c in1=a in2=b title="Normalised spectrum"
   This multiplies the NDF called a by the NDF called b, to make
   the NDF called c.  NDF c has the title "Normalised spectrum".
2 Notes
If the two input NDFs have different pixel-index bounds, then
they will be trimmed to match before being multiplied.  An error
will result if they have no pixels in common.
2 Related_Applications
   KAPPA: ADD, CADD, CDIV, CMULT, CSUB, DIV, MATHS, SUB.
2 Authors
RFWS: R.F. Warren-Smith (STARLINK)

MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 9-APR-1990 (RFWS):
    Original version.

 1992 January 15 (MJC):
    Added Usage and Examples items.

 1995 September 12 (MJC):
    Title inherited by default.  Usage and examples to lowercase.
    Added Related Applications.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   LABEL, TITLE, HISTORY, WCS and VARIANCE components of an NDF data
   structure and propagates all extensions.

   -  Units processing is not supported at present and therefore the
   UNITS component is not propagated.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.
   Calculations will be performed using either real or double
   precision arithmetic, whichever is more appropriate.  If the
   input NDF structures contain values with other data types, then
   conversion will be performed as necessary.

1 NATIVE
Converts an HDS object to native machine data representation.

Usage:

   native object

Description:

   This application converts an HDS object (or structure) so that
   all primitive data values within it are represented using the
   appropriate native data representation for the machine in use
   (this includes the appropriate number format and byte ordering).
   This may typically be required after moving HDS files from
   another machine which uses a different number format and/or byte
   order, and will minimise the subsequent access time on the new
   machine.  Conversion is performed by modifying the data in situ.
   No separate output file is produced.

   This application can also be used to replace any IEEE floating point
   NaN or Inf values in an HDS object with the appropriate Starlink
   bad value. This conversion is performed even if the data values
   within the object are already represented using the appropriate
   native data representation for the machine in use.
2 Parameters
For information on individual parameters, select from the list below:
3 OBJECT
OBJECT = UNIVERSAL (Read and Write)
   The HDS structure to be converted; either an entire container
   file or a particular object or structure within the file may
   be specified.  If a structure is given, all components (and
   sub-components, etc.) within it will also be converted.
2 Examples
native myfile
   Converts all the primitive data in the HDS container file
   myfile to be held using the appropriate native machine
   representation for faster subsequent access.

native yourfile.data_array
   Converts just the DATA_ARRAY component (and its contents, if a
   structure) in the container file yourfile to the appropriate
   native machine data representation.  Other file contents remain
   unchanged.
2 Authors
RFWS: R.F. Warren-Smith (STARLINK, RAL)

MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 5-MAY-1992 (RFWS):
    Original version.

 1995 April 24 (MJC):
    Made usage and examples lowercase.  Sorted the variable
    declarations.

 12-OCT-1998 (DSB):
    Added prologue comment about conversion of NaN and Inf values.

1 NDF_History

During a spring clean of directories to free some space, most of us
will have encountered data files whose purpose and worth are long
forgotten.  We're reluctant to remove them in case they contain
irreplaceable data.  Some people are very good and make copious
notes...  Even then the result of a casual experiment might not be
recorded.  For those who are lazy, such files can be a frequent
dilemma.  Even a quick look at a plot of the data is often little
assistance.  As you've probably surmised, the NDF offers a solution.

Within an NDF you may record history information.  This is usually a
chronicle of the processing stages used to form the NDF, including
the parameter values of the applications invoked; but it may also
include commentary you provide, for example, the rationale for doing
certain operations.

History is associated with individual NDFs; it is not some global
attribute of a data-processing session.  An NDF has a history
update mode, which remains with the NDF and any descendant NDF,
until the update mode is altered or the history erased.  By default,
the update mode is "Disabled", meaning that no history recording
occurs.  To permit history recording you must first switch it on,
selecting from three update modes---"Quiet", "Normal", and 
"Verbose"---which give increasingly more detailed information.

2 Control_and_Content_of_History_Recording
Task HISSET lets you set the history update mode.  The default is
"Normal", thus here the command

     % hisset hr1068

switches normal history recording on for NDF hr1068.  Thereafter
whenever you alter this NDF, or create another NDF from it, the
task automatically records the name of the application which was
run, the date and time, a reference name that identifies the NDF,
your a username, and some text comprising the command-line
parameters and the full path of the application.  In KAPPA the
package  name and version is appended to the application name.
This default history recording facility will gradually become
available in other Starlink packages as they are rebuilt.  Some of
these packages may provide task-dependent additional text. 

If disc space is not a concern, you might prefer the verbose level.

     % hisset hr1068 verbose

the supplementary information being the machine type, and its
operating system name and version.

For small datasets, such as spectra, the history can amount to a
significant part of the NDF's size, so for these you might prefer
the quiet level.  This does not record the command line.

HISSET lets you switch off history recording, if you want to do
something `off the record', or erase the history altogether.

     % hisset hr1068 disabled
     % hisset hr1068 erase


2 Adding_Commentary_to_History_Recording
Once history recording is enabled, you can add commentary to an NDF
using HISCOM.

     % hiscom hr1068 i "There may have been cloud during the integration."

You aren't limited to single lines if you respond to the prompt for 
the comment.  You can give a series of lines, terminated by supplying
!.

     % hiscom hr1068
     COMMENT - Comment line > The dome may have been obstructing the telescope 
     COMMENT - Comment line > during the integration.  We are not sure that the
     COMMENT - Comment line > filter is correct either.
     COMMENT - Comment line > !

If you prefer, you may edit some text into a file and append its
contents to the history records.  Thus

     % hiscom hr1068 f file=comments.lis

appends the text contained in comments.lis to the history
records of NDF hr1068.

2 Listing_History_Records
At some point you will want to refer back to the history records.
The HISLIST task does this.

     % hislist hr1068

        History listing for NDF structure /home/scratch/dro/hr1068:

        History structure created 1995 Sep 24 11:16:15.000

     1: 1995 Sep 24 11:16:15.000 - HISSET          (NDFPACK V1.0)

        Parameters: MODE='Normal' NDF=@hr1068
        Software: /star/bin/kappa/hisset

Before you ask... at present there are no parameters for selecting a
time interval and there is no output of the machine and username,
but they're not forgotten.

Here is another example showing a series of history records.

     % hislist hr1068 \\

        History listing for NDF structure /home/scratch/dro/hr1068sm2:

        History structure created 1995 Nov 24 11:16:15.000

     1: 1995 Sep 24 11:16:15.000 - HISSET          (NDFPACK V1.0)

        Parameters: MODE='Normal' NDF=@hr1068
        Software: /star/bin/kappa/hisset

     2: 1995 Sep 24 11:19:53.000 - GAUSMOOTH       (KAPPA V0.9)

        Parameters: BOX=13 FWHM=5 IN=@hr1068 OUT=@hr1068sm TITLE=! WLIM=!
        Software: /star/bin/kappa/gausmooth

     3: 1995 Sep 24 11:20:15.000 - HISSET          (NDFPACK V1.0)

        History update mode changed from NORMAL to VERBOSE.
        Parameters: MODE='Normal' NDF=@hr1068sm
        Software: /star/bin/kappa/hisset

     4: 1995 Sep 24 11:20:49.000 - GAUSMOOTH       (KAPPA V0.9)

        Parameters: BOX=9 FWHM=3 IN=@hr1068sm OUT=@hr1068sm2 TITLE=! WLIM=!
        Software: /star/bin/kappa/gausmooth
        Machine: alpha, System: OSF1 214 (release V3.2)

     5: 1995 Sep 24 11:22:32.000 - HISCOM          (NDFPACK V1.0)

        Parameters: MODE='Interface' NDF=@hr1068sm2 WRAP=TRUE
        Software: /star/bin/kappa/hiscom
        The dome may have been obstructing the telescope during the
        integration.  We are not sure that the filter is correct either.

The first history item HISSET enabling history.  This was followed by
a smooth of the data with GAUSMOOTH.  Then the recording level was set
to verbose.  The fourth record recalls another smooth, and this time
you can see the machine details.  Finally, some commentary is added
with HISSET.
1 NDF_Sections

 You will frequently want to examine or process only a portion of
 your dataset, be it to focus on a given object in an image, or a
 single spectrum between nominated wavelengths, or a plane of a
 cube.  You could use NDFCOPY or MANIC in some circumstances to
 make a new NDF containing the required data, but this would be
 inconvenient as you would need more disc space, and to invent and
 remember a new filename.  In addition, MANIC currently does not
 fully support the NDF, and so you could lose axis information, for
 example.  You will be pleased to learn that there is a succinct and
 powerful alternative that obviates the need to create a new
 file---the NDF section.  The application just processes a
 `rectangular' subset, or section, of the NDF that you nominate.
 Certainly, it requires you to learn a little syntax, but after you
 use it a few times it will seem cheap at the price for the
 advantages it offers.  Please note however, that sections
 cannot be given to an IMAGE-format application. 

 An NDF section is defined by specifying the bounds of the portion
 of the NDF to be processed immediately following the name of the
 NDF.  You can do this in any place where an NDF name alone would
 suffice, for example, on the command line or in response to a
 prompt or as a default in an interface file.  The syntax is a
 series of subscripts within parentheses and may be given in several
 ways.  Here is a simple example.

      ICL> stats cluster(101:200,51:150)

 This would derive statistics of a 100-by-100-pixel region starting
 at pixel indices (101,51) in the NDF called cluster. 
 Alternatively, ranges of axis co-ordinates may be given instead of
 pixel indices.  Besides giving lower and upper bounds as above, you
 may specify a centre and extent.  Sections are not limited to
 subsets---supersets are allowed.  See the subtopic below for more
 details of these features.

 If you do want to make a new NDF from a portion of an existing one,
 you should use the command NDFCOPY.  An NDF's shape may be changed
 in situ by SETBOUND.

 ******************************************************************
 *  Note if you supply an NDF section on a C-shell command line,  *
 *  you must escape the parentheses.  For example,                *
 *                                                                *
 *     % stats cluster"(101:200,51:150)"                          *
 *     % stats cluster\(101:200,51:150\)                          *
 *                                                                *
 *  are both equivalent to the earlier example.                   *
 ******************************************************************

2 Specifying_Lower_and_Upper_Bounds

 The subscript expression appended to an NDF name to specify a
 section may be given as the lower and upper bounds in each
 dimension, as follows

                      NAME( a:b, c:d, ... )

 where `a:b', `c:d', (etc.) specify the lower and upper bounds.  The
 bounds specified need not necessarily lie within the actual bounds
 of the NDF, because bad pixels will be supplied in the usual way,
 if required, to pad out the NDF's array components whenever they
 are accessed.  However, none of the lower bounds should exceed the
 corresponding upper bound. 

 Omitting any of the bounds from the subscript expression will cause
 the appropriate (lower or upper) bound of the NDF to be used
 instead. If you also omit the separating `:', then the lower and
 upper bounds of the section will both be set to the same value, so
 that a single pixel will be selected for that dimension.  Omitting
 the bounds entirely for a dimension (but still retaining the comma)
 will cause the entire extent of that dimension to be used. Thus, 

                            IMAGE(,64)

 could be used to specify row 64 of a 2-dimensional image, while:

                       CUBE( 1, 257:, 100 )

 would specify column 1, pixels 257 onwards, selected from plane
 number 100 of a 3-dimensional `data cube', forming a
 one-dimensional section.

2 Specifying_Centre_and_Extent

 An alternative form for the subscript expression involves
 specifying the centre and extent of the region required along each
 dimension, as follows

                       NAME( p~q, r~s, ... )

 where `p~q', `r~s', etc. specify the centre and extent. Thus, 

                        NAME(100~11,200~5)

 would refer to an 11-by-5-pixel region of an image centred on pixel
 (100, 200).

 If the value before the delimiting `~' (tilde) is omitted, it will
 default to the index of the central pixel in that dimension
 (rounded downwards if there are an even number of pixels).  If the
 value following the `~' is omitted, it will default to the number
 of pixels in that dimension. Thus, 

                        IMAGE( ~100, ~100)

 could be used to refer to a 100-by-100-pixel region located
 centrally within an image, while 

                         IMAGE( 10~, 20~)

 would specify a section which is the same size as the original
 image, but displaced so that it is centred on pixel (10,20). 

2 Using_Axis_Co-ordinates_to_Specify_Sections

 A further variation is that numerical values in subscript
 expressions may be specified either as integers, in which case they
 refer to pixel indices, or as floating-point numbers, in which case
 they refer to axis or data co-ordinates (for a description of data
 co-ordinates, see topic "Co-ordinate_systems").  Here, a
 floating-point number is one containing a decimal point and/or an
 exponent. Double precision arithmetic is used to process these
 values, but either double- or single-precision notation may be used
 when supplying them. Both linear and non-linear axis co-ordinates
 are supported, the values supplied being automatically converted
 into the corresponding pixel indices before use.  For instance

                    SPECTRUM(6500.0:7250.0)

 could be used to select the appropriate region of a spectrum
 calibrated in Angstroms, while

                    SPECTRUM(6000.0~500.0)

 would select a region of the spectrum approximately from 5750 to 
 6250.0 Angstroms (the exact extent depending the values of the axis
 co-ordinates), and

                      SPECTRUM(5500.0~21)

 would select a 21-pixel-wide region of the spectrum centred on
 5500.0 Angstroms. 

 Command NDFTRACE will show whether or not an NDF has axis
 co-ordinates, and if so, it reports their extents.


2 Changing_Dimensionality

 The number of dimensions given when specifying an NDF section need
 not necessarily correspond with the actual number of NDF
 dimensions, although usually it will do so. 

 If you specify fewer dimensions than there are NDF dimensions, then
 any unspecified bounds will be set to (1:1) for the purposes of
 identifying the pixels to which the section should refer.
 Conversely, if extra dimensions are given, then the shape of the
 NDF will be padded with extra bounds set to (1:1) in order to match
 the number of dimensions.  In all cases, the resulting section will
 have the number of dimensions you have actually specified, the
 padding serving only to identify the pixels to which the section
 should refer. 

 In KAPPA there are a number of applications that can only handle a
 fixed number of dimensions (e.g. DISPLAY, LINPLOT).  NDF sections
 permit such applications to have wider applicability since they can
 operate on full NDFs of arbitrary dimensionality.  So for instance,
 DISPLAY could show planes of a datacube.


2 Mixing_Bounds_Expressions

 Any of the features described in the other subtopics may be
 combined when specifying an NDF section, the only restriction being
 that when the shape of the resulting section is expressed in pixel
 indices, the lower bound must not exceed the upper bound in any
 dimension. Thus, all the following might be used as valid
 specifications for NDF sections

                        NDF(3.7)
                        NDF(,5:)
                        NDF(-77:13.8,,4)
                        NDF(66~9,4:17)
                        NDF(~5,6~)
                        NDF(~,:)
                        NDF(5500.0~150,)
                        NDF(3.0~1.5,-78.06D-3:13.0545,,,,)

 Many other combinations are obviously possible.

1 NDFCOPY
Copies an NDF (or NDF section) to a new location.

Usage:

   ndfcopy in out

Description:

   This application copies an NDF to a new location.  By supplying an
   NDF section as input it may be used to extract a subset, or to
   change the size or dimensionality of an NDF. A second NDF may
   also be supplied to act as a shape template, and hence to define
   the region of the first NDF which is to be copied.

   Any unused space will be eliminated by the copying operation
   performed by this routine, so it may be used as a way of
   compressing NDF structures from which components have been
   deleted.  This ability also makes NDFCOPY a useful alternative to
   SETBOUND in cases where an NDF's size is to be reduced.
2 Parameters
For information on individual parameters, select from the list below:
3 IN
IN = NDF (Read)
   The input NDF (or section) which is to be copied.
3 LIKE
LIKE = NDF (Read)
   This parameter may be used to supply an NDF to be used as a
   shape template during the copying operation.  If such a
   template is supplied, then its shape will be used to select a
   matching section from the input NDF before copying takes
   place.  By default, no template will be used and the shape of
   the output NDF will therefore match that of the input NDF (or
   NDF section). [!]
3 OUT
OUT = NDF (Write)
   The output NDF data structure.
3 TITLE
TITLE = LITERAL (Read)
   A title for the output NDF.  A null value (the default) will
   cause the title of the NDF supplied for parameter IN to be
   used instead. [!]
3 TRIM
TRIM = _LOGICAL (Read)
   If TRUE, then the number of pixel axes in the output NDF will be
   reduced if necessary to remove any pixel axes which span only a
   single pixel. For instance if "stokes" is a 3D data cube with
   pixel bounds (1:100,-50:40,1:3), and the parameter IN is given the
   value "stokes(,,2)", then the dimensionality of the output depends
   on the setting of TRIM: if TRIM=NO the output is 3D with pixel
   bounds (1:100,-50:40,2:2) and if TRIM=YES the output is 2D with
   pixel bounds (1:100,-50:40). In this example, the third pixel
   axis spans only a single pixel and is consequently removed if
   TRIM=YES.  [FALSE]
3 TRIMWCS
TRIMWCS = _LOGICAL (Read)
   This parameter is only accessed if parameter TRIM is TRUE. It
   controls the number of axes in the current WCS co-ordinate Frame
   of the output NDF. If TRIMWCS=YES, then the current Frame in the
   output NDF will have the same number of axes as there are pixel
   axes in the output NDF. If this involves removing axes, then the
   axes to ratain are specified by parameter USEAXIS. If TRIMWCS=NO
   then all axes are retained in the current WCS Frame of the
   output NDF. Using the example in the description of the TRIM
   parameter, if the input NDF "stokes" has a 3D current WCS Frame
   with axes (Ra,Dec,Stokes) and TRIMWSC=YES, then an axis will be
   removed from the current Frame to make it 2 dimensional (that
   is, to match the number of pixel axes remaining after the
   removal of insignificant pixel axes). The choice of which two
   axes to retain is controlled by parameter USEAXIS. If, on the
   other hand, TRIMWCS was set to FALSE, then the output NDF would
   still have two pixel axes, but the current WCS Frame would retain
   all three axes from the input NDF. If one or more current Frame
   axes are removed, the transformation from the current Frame to
   pixel Frame may become undefined resulting in some WCS operations
   being unusable. The inverse of this transformation (from pixel
   Frame to current Frame) is unchanged however. [TRUE]
3 USEAXIS
USEAXIS = LITERAL (Read)
   This parameter is only accessed if TRIM and TRIMWCS are both TRUE
   and some axes need to be removed from the current WCS Frame of
   the output NDF. It gives the axes which are to be retained in
   the current WCS Frame of the output NDF. Each axis can be
   specified either by giving its index within the Current Frame
   of the input NDF in the range 1 to the number of axes in the Frame,
   or by giving its symbol. The dynamic default selects the axes with
   the same indices as the pixel axes being copied. The value should
   be given as a comma separated list. []
2 Examples
ndfcopy infile outfile
   Copies the contents of the NDF structure infile to the new
   structure outfile.  Any unused space will be eliminated during
   the copying operation.

ndfcopy in=data1(3:40,-3:17) out=data2 title="Extracted section"
   Copies the section (3:40,-3:17) of the NDF called data1 to a
   new NDF called data2.  The output NDF is assigned the new title
   "Extracted section", which replaces the title derived from the
   input NDF.

ndfcopy galaxy newgalaxy like=oldgalaxy
   Copies a section of the NDF called galaxy to form a new NDF
   called newgalaxy.  The section which is copied will correspond
   in shape with the template oldgalaxy.  Thus, after the copying
   operation, both newgalaxy and oldgalaxy will have the same
   pixel-index bounds.

ndfcopy aa(20~11,20~11) bb like=aa
   Copies from the NDF section consisting of an 11x11 pixel
   region of aa centred on pixel (20,20), into a new NDF called
   bb.  The shape of the region copied is made to match the
   original shape of aa.  The effect is to extract the selected
   square region of pixels into a new NDF of the same shape as
   the original, setting the surrounding region to the bad-pixel
   value.
2 Related_Applications
   KAPPA: SETBOUND; Figaro: ISUBSET.
2 Authors
RFWS: R.F. Warren-Smith (STARLINK, RAL)

MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 27-FEB-1991 (RFWS):
    Original version.

 19-MAR-1991 (RFWS):
    Added the LIKE parameter to allow the use of a shape template.

 22-MAR-1991 (RFWS):
    Added the TITLE parameter.

 1995 April 24 (MJC):
    Made usage and examples lowercase.  Added Related Applications.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.

 12-APR-2000 (DSB):
    Added TRIM, TRIMWCS and USEAXIS parameters.
2 Implementation_Status
   If present, an NDF's TITLE, LABEL, UNITS, DATA, VARIANCE,
   QUALITY, AXIS WCS and HISTORY components are copied by this routine,
   together with all extensions.  The output NDF's title may be
   modified, if required, by specifying a new value via the TITLE
   parameter.
1 NDFTRACE
Displays the attributes of an NDF data structure.

Usage:

   ndftrace ndf

Description:

   This routine displays the attributes of an NDF data structure
   including:

   -  its name;

   -  the values of its character components (title, label and
   units);

   -  its shape (pixel bounds, dimension sizes, number of dimensions
   and total number of pixels);

   -  axis co-ordinate information (axis labels, units and extents);

   -  optionally, axis array attributes (type and storage form) and
   the values of the axis normalisation flags;

   -  attributes of the main data array and any other array
   components present (including the type and storage form and an
   indication of whether `bad' pixels may be present);

   -  attributes of the current co-ordinate Frame in the WCS component
   (title, domain, and ,optionally, axis labels and axis units, plus the
   system epoch and projection for sky co-ordinate Frames).

   -  optionally, attributes of all other co-ordinate Frames in the WCS
   component.

   -  a list of any NDF extensions present, together with their data
   types; and

   -  history information (creation and last-updated dates, the
   update mode and the number of history records).

   Most of this information is output to parameters.
2 Parameters
For information on individual parameters, select from the list below:
3 AEND
AEND( ) = _DOUBLE (Write)
   The axis upper extents of the NDF.  For non-monotonic axes,
   zero is used.  See parameter AMONO.  This is not assigned if
   AXIS is FALSE.
3 AFORM
AFORM( ) = LITERAL (Write)
   The storage forms of the axis centres of the NDF.  This is
   only written when FULLAXIS is TRUE and AXIS is TRUE.
3 ALABEL
ALABEL( ) = LITERAL (Write)
   The axis labels of the NDF.  This is not assigned if AXIS is
   FALSE.
3 AMONO
AMONO( ) = _LOGICAL (Write)
   These are TRUE when the axis centres are monotonic, and FALSE
   otherwise.  This is not assigned if AXIS is FALSE.
3 ANORM
ANORM( ) = _LOGICAL (Write)
   The axis normalisation flags of the NDF.  This is only written
   when FULLAXIS is TRUE and AXIS is TRUE.
3 ASTART
ASTART( ) = _DOUBLE (Write)
   The axis lower extents of the NDF.  For non-monotonic axes,
   zero is used.  See parameter AMONO.  This is not assigned if
   AXIS is FALSE.
3 ATYPE
ATYPE( ) = LITERAL (Write)
   The data types of the axis centres of the NDF.  This is only
   written when FULLAXIS is TRUE and AXIS is TRUE.
3 AUNITS
AUNITS( ) = LITERAL (Write)
   The axis units of the NDF.  This is not assigned if AXIS is
   FALSE.
3 AVARIANCE
AVARIANCE( ) = _LOGICAL (Write)
   Whether or not there are axis variance arrays present in the
   NDF.  This is only written when FULLAXIS is TRUE and AXIS is
   TRUE.
3 AXIS
AXIS = _LOGICAL (Write)
   Whether or not the NDF has an axis system.
3 BAD
BAD = _LOGICAL (Write)
   If TRUE, the NDF's data array may contain bad values.
3 BADBITS
BADBITS = LITERAL (Write)
   The BADBITS mask.  This is only valid when QUALITY is TRUE.
3 CURRENT
CURRENT = _INTEGER (Write)
   The integer Frame index of the current co-ordinate Frame in the
   WCS component.
3 DIMS
DIMS( ) = _INTEGER (Write)
   The dimensions of the NDF.
3 EXTNAME
EXTNAME( ) = LITERAL (Write)
   The names of the extensions in the NDF.  It is only written
   when NEXTN is positive.
3 EXTTYPE
EXTTYPE( ) = LITERAL (Write)
   The types of the extensions in the NDF.  Their order
   corresponds to the names in EXTNAME.  It is only written when
   NEXTN is positive.
3 FDIM
FDIM( ) = _INTEGER (Write)
   The numbers of axes in each co-ordinate Frame stored in the WCS
   component of the NDF. The elements in this parameter correspond to
   those in the FDOMAIN and FTITLE parameters. The number of elements
   in each of these parameters is given by NFRAME.
3 FDOMAIN
FDOMAIN( ) = LITERAL (Write)
   The domain of each co-ordinate Frame stored in the WCS component
   of the NDF. The elements in this parameter correspond to
   those in the FDIM and FTITLE parameters. The number of elements
   in each of these parameters is given by NFRAME.
3 FORM
FORM = LITERAL (Write)
   The storage form of the NDF's data array.
3 FTITLE
FTITLE( ) = LITERAL (Write)
   The title of each co-ordinate Frame stored in the WCS component of
   the NDF. The elements in this parameter correspond to those in the
   FDOMAIN and FDIM parameters. The number of elements in each
   of these parameters is given by NFRAME.
3 FULLAXIS
FULLAXIS = _LOGICAL (Read)
   If the NDF being examined has an axis co-ordinate system
   defined, then by default only the label, units and extent of
   each axis will be displayed.  However, if a TRUE value is given
   for this parameter, full details of the attributes of all the
   axis arrays will also be given. [FALSE]
3 FULLFRAME
FULLFRAME = _LOGICAL (Read)
   If a FALSE value is given for this parameter then only the
   Title and Domain attributes are displayed for a co-ordinate Frame.
   Otherwise, a more complete description is given.   [FALSE]
3 FULLWCS
FULLWCS = _LOGICAL (Read)
   If a TRUE value is given for this parameter then all co-ordinate
   Frames in the WCS component of the NDF are displayed. Otherwise,
   only the current co-ordinate Frame is displayed. [FALSE]
3 HISTORY
HISTORY = _LOGICAL (Write)
   Whether or not the NDF contains HISTORY records.
3 LABEL
LABEL = LITERAL (Write)
   The label of the NDF.
3 LBOUND
LBOUND( ) = _INTEGER (Write)
   The lower bounds of the NDF.
3 NDF
NDF = NDF (Read)
   The NDF data structure whose attributes are to be displayed.
3 NDIM
NDIM = _INTEGER (Write)
   The number of dimensions of the NDF.
3 NEXTN
NEXTN = _INTEGER (Write)
   The number of extensions in the NDF.
3 NFRAME
NFRAME = _INTEGER (Write)
   The number of WCS Frames described by parameters FDIM, FDOMAIN and
   FTITLE. Set to zero if WCS is FALSE.
3 QUALITY
QUALITY = _LOGICAL (Write)
   Whether or not the NDF contains a QUALITY array.
3 QUIET
QUIET = _LOGICAL (Read)
   A TRUE value suppresses the reporting of the NDF's attributes.
   It is intended for procedures and scripts where only the
   output parameters are needed. [FALSE]
3 TITLE
TITLE = LITERAL (Write)
   The title of the NDF.
3 TYPE
TYPE = LITERAL (Write)
   The data type of the NDF's data array.
3 UBOUND
UBOUND( ) = _INTEGER (Write)
   The upper bounds of the NDF.
3 UNITS
UNITS = LITERAL (Write)
   The units of the NDF.
3 VARIANCE
VARIANCE = _LOGICAL (Write)
   Whether or not the NDF contains a VARIANCE array.
3 WCS
WCS = _LOGICAL (Write)
   Whether or not the NDF has any WCS co-ordinate Frames, over
   and above the default GRID, PIXEL and AXIS Frames.
3 WIDTH
WIDTH( ) = _LOGICAL (Write)
   Whether or not there are axis width arrays present in the NDF.
   This is only written when FULLAXIS is TRUE and AXIS is TRUE.
2 Examples
ndftrace mydata
   Displays information about the attributes of the NDF structure
   called mydata.

ndftrace ndf=r106 fullaxis
   Displays information about the NDF structure r106, including
   full details of any axis arrays present.

ndftrace mydata quiet ndim=(mdim)
   Passes the number of dimensions of the NDF called mydata
   into the ICL variable mdim.  No information is displayed.
2 Notes
-  If the WCS component of the NDF is undefined, then an attempt is
made to find WCS information from two other sources: firstly, an
IRAS90 astrometry structure, and secondly, the FITS extension. If
either of these sources yield usable WCS information, then it is
displayed in the same way as the NDF WCS component. Other KAPPA
applications will use this WCS information as if it were stored in
the WCS component.
2 Related_Applications
   KAPPA: WCSFRAME; HDSTRACE
2 Authors
RFWS: R.F. Warren-Smith (STARLINK)

MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 1990 April 6 (RFWS):
    Original version.

 1991 April 29 (RFWS):
    Added support for axis components and added the usage and
    examples sections to the prologue.

 1992 November 30 (MJC):
    Reports non-monotonic axis centres.

 1993 February 4 (MJC):
    Fixed bug that caused incorrect axis extents to be reported
    when there were no axis-width arrays and the axis centres did
    not increment by one.

 1994 July 29 (RFWS):
    Adapted to handle history information.

 1995 April 24 (MJC):
    Made usage and examples lowercase.  Added Related Applications.
    Added History to the Description.  Sorted the variable
    declarations and other tidying.

 1995 June 18 (MJC):
    Added QUIET option and the output parameters.

 1997 November 27 (DSB):
    Added support for WCS component.
1 NOGLOBALS
Resets the KAPPA global parameters.

Usage:

   noglobals

Description:

   This application resets the KAPPA global parameters, and so makes
   their values undefined.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1992 December 1 (MJC):
    Original version.

 1995 August 31 (MJC):
    Removes the current transformation.
1 NOMAGIC
Replaces all occurrences of magic value pixels in an NDF array
with a new value.

Usage:

   nomagic in out repval sigma [comp]

Description:

   This function replaces the standard `magic value' assigned to bad
   pixels in an NDF with an alternative value, or with random
   samples taken from a Normal distribution.  Input pixels which do
   not have the magic value are left unchanged.  The number of
   replacements is reported.  NOMAGIC's applications include the
   export of data to software that has different magic values or
   does not support bad values.

   If a constant value is used to replace magic values (which will
   be the case if parameter SIGMA is given the value zero), then the
   same replacement value is used for both the data and variance
   arrays when COMP="All".  If the variance is being processed, the
   replacement value is constrained to be non-negative.

   Magic values are replaced by random values if the parameter SIGMA
   is given a non-zero value.  If both Data and Variance components
   are being processed, then the random values are only stored in
   the Data component; a constant value equal to SIGMA squared is
   used to replace all magic values in the variance component.  If
   only a single component is being processed (whether it be Data,
   Variance, or Error), then the random values are used to replace
   the magic values.  If random values are generated which will not
   fit into the allowed numeric range of the output NDF, then they
   are discarded and new random values are obtained instead.  This
   continues until a useable value is obtained.  This could introduce
   some statistical bias if many such re-tries are performed.  For
   this reason SIGMA is restricted so that there are at least 4
   standard deviations between the mean (given by REPVAL) and the
   nearest limit.  NOMAGIC notifies of any re-tries that are
   required.
2 Parameters
For information on individual parameters, select from the list below:
3 COMP
COMP = LITERAL (Read)
   The components whose flagged values are to be substituted. It
   may be "Data", "Error", "Variance", or "All".  The last of the
   options forces substitution of bad pixels in both the data and
   variance arrays.  This parameter is ignored if the data array
   is the only array component within the NDF.  ["Data"]
3 IN
IN = NDF  (Read)
   Input NDF structure containing the data and/or variance array
   to have its elements flagged with the magic value replaced by
   another value.
3 OUT
OUT = NDF (Write)
   Output NDF structure containing the data and/or variance array
   without any elements flagged with the magic value.
3 REPVAL
REPVAL = _DOUBLE (Read)
   The constant value to substitute for the magic values, or (if
   parameter SIGMA is given a non-zero value) the mean of the
   distribution from which replacement values are obtained.  It
   must lie within the minimum and maximum values of the data
   type of the array with higher precision, except when variance
   is being processed, in which case the minimum is constrained
   to be non-negative.  The replacement value is converted to the
   data type of the array being converted.  The suggested default
   is the current value.
3 SIGMA
SIGMA = _DOUBLE (Read)
   The standard deviation of the random values used to replace
   magic values in the input NDF.  If this is zero (or if a null
   value is given), then a constant replacement value is
   used.  The supplied value must be positive and must be small
   enough to allow at least 4 standard deviations between the
   mean value (given by REPVAL) and the closest limit. [!]
3 TITLE
TITLE = LITERAL (Read)
   Title for the output NDF structure.  A null value (!)
   propagates the title from the input NDF to the output NDF. [!]
2 Examples
nomagic aitoff irasmap repval=-2000000
   This copies the NDF called aitoff to the NDF irasmap, except
   that any bad values in the data array are replaced with the
   IPAC blank value, -2000000, in the NDF called irasmap.

nomagic saturnb saturn 9999.0 comp=all
   This copies the NDF called saturnb to the NDF saturn, except
   that any bad values in the data and variance arrays are
   replaced with 9999 in the NDF called saturn.

nomagic in=cleaned out=filled  repval=0 sigma=10 comp=all
   This copies the NDF called cleaned to the NDF filled, except
   that any bad values in the data array are replaced by random
   samples taken from a Normal distribition of mean zero and
   standard deviation 10.  Bad values in the variance array are
   replaced by the constant value 100.
2 Notes
-  If the NDF arrays have no bad pixels the application will
abort.

-  Use GLITCH if a neighbourhood context is required to remove
the bad values.
2 Related_Applications
   KAPPA: CHPIX, FILLBAD, GLITCH, SEGMENT, SETMAGIC, SUBSTITUTE,
   ZAPLIN; FIGARO: GOODVAR.
2 Authors
MJC: Malcolm J. Currie  (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 1991 November 4 (MJC):
    Original NDF_ version.

 1994 September 26 (MJC):
    Replaced AIF calls, and used a modern style of commenting.
    Made messages conditional.

 1994 December 15 (DSB):
    Added SIGMA parameter and associated code.  Unmap '*'
    components rather than COMP( I ) component to avoid
    possibility of NDF_UNMAP being asked to unmap the 'Error'
    component.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   VARIANCE, LABEL, TITLE, UNITS, WCS and HISTORY components of an NDF
   data structure and propagates all extensions.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.

   -  Any number of NDF dimensions is supported.
1 NORMALIZE
Normalises one NDF to a similar NDF by calculating a scale factor
and zero-point difference.

Usage:

   normalize in1 in2 out

Description:

   This application compares the data values in one NDF against the
   corresponding values in the other NDF.  A least-squares
   straight-line is then fitted to the relationship between the two
   sets of data values in order to determine the relative scale
   factor and any zero-level offset between the NDFs.  To reduce
   computation time, the data points are binned according to the
   data value in the first NDF.  The mean data value within each bin
   is used to find the fit and weights are applied according to the
   number of pixels which contribute to each bin.

   To guard against erroneous data values, which can corrupt the fit
   obtained, the application then performs a number of iterations.
   It calculates a noise estimate for each bin according to the rms
   deviation of data values in the bin from the straight-line fit
   obtained previously.  It then re-bins the data, omitting values
   which lie more than a specified number of standard deviations
   from the expected value in each bin.  The straight-line fit is
   then re-calculated.  You can specify the number of standard
   deviations and the number of iterations used.

   A plot is produced after the final iteration showing the bin
   centres, with error bars representing the spread of values in each
   bin.  The best fitting straight line is overlayed on this plot.

   Optionally, an output NDF can be created containing a normalised
   version of the data array from the first input NDF.
2 Parameters
For information on individual parameters, select from the list below:
3 AXES
AXES = _LOGICAL (Read)
   TRUE if labelled and annotated axes are to be drawn around the
   plot. The width of the margins left for the annotation may be
   controlled using parameter MARGIN. The appearance of the axes
   (colours, fonts, etc) can be controlled using the parameter
   STYLE. [TRUE]
3 CLEAR
CLEAR = _LOGICAL (Read)
   If TRUE the current picture is cleared before the plot is
   drawn. If CLEAR is FALSE not only is the existing plot retained,
   but also an attempt is made to align the new picture with the
   existing picture. Thus you can generate a composite plot within
   a single set of axes, say using different colours or modes to
   distinguish data from different datasets. [TRUE]
3 DATARANGE
DATARANGE( 2 ) = _REAL (Read)
   This parameter may be used to override the auto-scaling
   feature.  If given, two real numbers should be supplied
   specifying the lower and upper data values in IN2, between
   which data will be used.  If not given, the default is to use
   the auto-scaled values, calculated according to the value of
   PCRANGE. Note, this parameter controls the range of data used in
   the fitting algorithm. The range of data displayed in the plot can
   be specified separately using parameters XLEFT, XRIGHT, YBOT and
   YTOP. [,]
3 DEVICE
DEVICE = DEVICE (Read)
   The graphics workstation on which to produce the plot.  If a
   null value (!) is supplied no plot will be made. [Current graphics
   device]
3 IN1
IN1 = NDF (Read)
   The NDF to be normalised.
3 IN2
IN2 = NDF (Read)
   The NDF to which IN1 will be normalised.
3 MARGIN
MARGIN( 4 ) = _REAL (Read)
   The widths of the margins to leave for axis annotation, given
   as fractions of the corresponding dimension of the current picture.
   Four values may be given, in the order - bottom, right, top, left.
   If less than four values are given, extra values are used equal to
   the first supplied value. If these margins are too narrow any axis
   annotation may be clipped. The dynamic default is 0.15 (for all
   edges) if annotated axes are produced, and zero otherwise. []
3 MARKER
MARKER = _INTEGER (Read)
   Specifies the symbol with which each position should be marked in
   the plot. It should be given as an integer PGPLOT marker type. For
   instance, 0 gives a box, 1 gives a dot, 2 gives a cross, 3 gives
   an asterisk, 7 gives a triangle. The value must be larger than or
   equal to -31. [current value]
3 MINPIX
MINPIX = _INTEGER (Read)
   The minimum number of good pixels required in a bin before it
   contributes to the fitted line.  It must be in the range 1 to
   the number of pixels per bin. [2]
3 NBIN
NBIN = _INTEGER (Read)
   The number of bins to use when binning the scatter plot prior
   to fitting a straight line, in the range 2 to 10000. [50]
3 NITER
NITER = _INTEGER (Read)
   The number of iterations performed to reject bad data values
   in the range 0 to 100. [2]
3 NSIGMA
NSIGMA = _REAL (Read)
   The number of standard deviations at which bad data is
   rejected.  It must lie in the range 0.1 to 1.0E6. [3.0]
3 OFFSET
OFFSET = _REAL (Write)
   An output parameter giving the offset in the linear
   normalisation expression: IN1 = SLOPE * IN2 + OFFSET.
3 OUT
OUT = NDF (Write)
   An optional output NDF to hold a version of IN1 which is
   normalised to IN2.  A null (!) value indicates that an output
   NDF is not required.
3 PCRANGE
PCRANGE( 2 ) = _REAL (Read)
   This parameter takes two real values in the range 0 to 100 and
   is used to modify the action of the auto-scaling algorithm
   which selects the data to use in the fitting algorithm. The two
   values correspond to the percentage points in the histogram of
   IN2 at which the lower and upper cuts on data value are placed.
   With the default value, the plots will omit those pixels which
   lie in the lower and upper 2 percent intensity range of IN2.
   Note, this parameter controls the range of data used in the
   fitting algorithm. The range of data displayed in the plot can
   be specified separately using parameters XLEFT, XRIGHT, YBOT and
   YTOP. [2,98]
3 SLOPE
SLOPE = _REAL (Write)
   An output parameter giving the slope of the linear
   normalisation expression: IN1 = SLOPE * IN2 + OFFSET.
3 STYLE
STYLE = LITERAL (Read)
   A group of attribute settings describing the plotting style to use
   when drawing the annotated axes, data values, error bars, and
   best fitting line.

   A comma-separated list of strings should be given in which each
   string is either an attribute setting, or the name of a text file
   preceded by an up-arrow character "^". Such text files should
   contain further comma-separated lists which will be read and
   interpreted in the same manner. Attribute settings are applied in
   the order in which they occur within the list, with later settings
   over-riding any earlier settings given for the same attribute.

   Each individual attribute setting should be of the form:

      <name>=<value>

   where <name> is the name of a plotting attribute, and <value> is
   the value to assign to the attribute. Default values will be
   used for any unspecified attributes. All attributes will be
   defaulted if a null value (!) is supplied. See section "Plotting
   Attributes" in SUN/95 for a description of the available
   attributes. Any unrecognised attributes are ignored (no error is
   reported).

   The appearance of the best fitting straight line is controlled by
   the attributes Colour(Curves), Width(Curves), etc (the synonym Line
   may be used in place of Curves). The appearance of markers is
   controlled by Colour(Markers), Width(Markers), etc (the synonym
   Symbols may be used in place of Markers). The appearance of the
   error bars is controlled using Colour(ErrBars), Width(ErrBars),
   etc. Note, Size(ErrBars) controls the length of the serifs (i.e.
   the cross pieces at each end of the error bar), and defaults to
   1.0. [current value]
3 TITLE
TITLE = LITERAL (Read)
   Value for the title of the output NDF.  A null value will cause
   the title of the NDF supplied for parameter IN1 to be used
   instead. [!]
3 XLEFT
XLEFT = _REAL (Read)
   The axis value to place at the left hand end of the horizontal
   axis of the plot. The dynamic default is the minimum data value
   used by the fitting algorithm from IN2 (with a small margin).
   The value supplied may be greater than or less than the value
   supplied for XRIGHT. []
3 XRIGHT
XRIGHT = _REAL (Read)
   The axis value to place at the right hand end of the horizontal
   axis of the plot. The dynamic default is the maximum data value
   used by the fitting algorithm from IN2 (with a small margin).
   The value supplied may be greater than or less than the value
   supplied for XLEFT. []
3 YBOT
YBOT = _REAL (Read)
   The axis value to place at the bottom end of the vertical axis of
   the plot. The dynamic default is the minimum data value used by
   the fitting algorithm from IN1 (with a small margin). The value
   supplied may be greater than or less than the value supplied for
   YTOP. []
3 YTOP
YTOP = _REAL (Read)
   The axis value to place at the top end of the vertical axis of
   the plot. The dynamic default is the maximum data value used by
   the fitting algorithm from IN1 (with a small margin). The value
   supplied may be greater than or less than the value supplied for
   YBOT. []
2 Examples
normalize cl123a cl123b cl123c
   This normalises NDF cl123a to the NDF cl123b.  A plot of the
   fit is made on the current graphics device, and the resulting
   normalisation scale and offset are written only to the
   normalize.sdf parameter file (as in the all the examples below
   except where noted).  The NDF cl123c is the normalised version
   of the input cl123a.

normalize cl123a cl123b style="'size(errba)=0,title=Gain calibration'"
   This normalises NDF cl123a to the NDF cl123b.  A plot of the
   fit is made on the current graphics device with the title
   "Gain calibration".  The error bars are drawn with no serifs.

normalize cl123a cl123b cl123c offset=(shift) slope=(scale)
   This normalises NDF cl123a to the NDF cl123b.  A plot of the
   fit is made on the current graphics device.  The resulting
   normalisation scale and offset are written to the ICL
   variables SCALE and SHIFT respectively, where they could be
   passed to another application via an ICL procedure.  The NDF
   cl123c is the normalised version of the input cl123a.

normalize in2=old in1=new out=! device=xwindows style=^normstyle
   This normalises NDF new to the NDF old.  A plot of the fit is
   made on the xwindows device, using the plotting style defined in
   text file normstyle.  No output NDF is produced.

normalize in1=new in2=old out=young niter=5 pcrange=[3,98.5]
   This normalises NDF new to the NDF old.  It has five iterations
   to reject outliers from the linear regression, and forms the
   regression using pixels in old whose data values lie between
   the 3 and 98.5 percentiles, comparing with the corresponding
   pixels in new.  A plot of the fit is made on the current
   graphics device.  The NDF young is the normalised version of
   the input new.
2 Notes
-  The application stores two pictures in the graphics database in
the following order: a FRAME picture containing the annotated axes
and data plot, and a DATA picture containing just the data plot.
Note, the FRAME picture is only created if annotated axes have been
drawn, or if non-zero margins were specified using parameter
MARGIN. The world co-ordinates in the DATA picture will correspond
to data value in the two NDFs.
2 Related_Applications
   CCDPACK: MAKEMOS.
2 Authors
DSB: David Berry (STARLINK)

MJC: Malcolm J. Currie (STARLINK)
2 History
 1-JUN-1990 (DSB):
    Original version.

 22-JUN-1990 (DSB):
    Graphics added.

 1990 October 4 (MJC):
    Added standard KAPPA axis-style parameters, removed tabs,
    extended and reformatted the prologue, added some contextual
    error messages, passed pointers as arrays, and added unmapping
    calls to prevent the output NDF from being deleted.

 1991 August 20 (MJC):
    Added FONT parameter.

 1992 March 3 (MJC):
    Replaced AIF parameter-system calls by the extended PAR
    library.

 1995 May 2 (MJC):
    Sets the bad-pixel flags.  Removed old histogram subroutine
    calls.  Used PSX for workspace.  Made the Usage and Examples
    lowercase.  Added Related Applications.  Title propagated.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.

 17-JUN-1998 (DSB):
    Converted graphics to AST/PGPLOT.
2 Implementation_Status
   -  The routine correctly processes the AXIS, DATA, QUALITY,
   VARIANCE, LABEL, TITLE, UNITS, WCS and HISTORY components of an NDF,
   and propagates all extensions to the output NDF.  All propagated
   components come from the NDF to be normalised.

   -  At the moment, variance values are not used in the fitting
   algorithm but are modified in the output NDF to take account of
   the scaling introduced by the normalisation.  (A later version may
   take account of variances in the fitting algorithm.)

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  Only _REAL data can be processed directly.  Other non-complex
   numeric data types will undergo a type conversion before
   processing occurs.  _DOUBLE data cannot be processed due to a
   loss of precision.

   -  The pixel bounds of the two input NDFs are matched by trimming
   before calculating the normalisation constants, and are mapped as
   vectors to allow processing of NDFs of any dimensionality.  An
   output NDF may optionally be produced which is based on the
   first input NDF (IN1) by applying the calculated normalisation
   constants to IN1.
1 NUMB
Counts the number of elements of an NDF with values or absolute
values above or below a threshold.

Usage:

   numb in value [comp]

Description:

   This routine counts and reports the number of elements of an
   array within an input NDF structure that have a value or absolute
   value greater or less than a specified threshold.  This statistic
   is also shown as a percentage of the total number of array
   elements.
2 Parameters
For information on individual parameters, select from the list below:
3 ABS
ABS = _LOGICAL (Read)
   If ABS is TRUE, the criterion is a comparison of the absolute
   value with the threshold; if FALSE, the criterion is a
   comparison of the actual value with the threshold.  The
   current value is the suggested default. [FALSE]
3 ABOVE
ABOVE = _LOGICAL (Read)
   If ABOVE is TRUE the criterion tests whether values are
   greater than the threshold; if FALSE the criterion tests
   whether values are less than the threshold.  The current value
   of ABOVE is the suggested default. [TRUE]
3 COMP
COMP = LITERAL (Read)
   The components whose flagged values are to be substituted.
   It may be "Data", "Error", "Variance", or "Quality".  If
   "Quality" is specified, then the quality values are treated as
   numerical values in the range 0 to 255. ["Data"]
3 IN
IN  = NDF (Read)
   Input NDF structure containing the array to be tested.
3 NUMBER
NUMBER = _INTEGER (Write)
   The number of elements that satisfied the criterion.
3 VALUE
VALUE  = _DOUBLE (Read)
   Threshold against which the values of the array elements will
   be tested.  It must lie in within the minimum and maximum
   values of the data type of the array being processed, unless
   ABS = TRUE or the component is the variance or quality
   array, in which case the minimum is zero.  The suggested
   default is the current value.
2 Examples
numb image 100
   This counts the number of elements in the data array of the NDF
   called image that exceed 100.

numb spectrum 100 noabove
   This counts the number of elements in the data array of the NDF
   called spectrum that are less than 100.

numb cube 100 abs
   This counts the number of elements in the data array of the NDF
   called cube whose absolute values exceed 100.

numb image -100 number=(count)
   This counts the number of elements in the data array of the NDF
   called image that exceed -100 and write the number to ICL
   variable COUNT.

numb image 200 v
   This counts the number of elements in the variance array of
   the NDF called image that exceed 200.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1991 November 11 (MJC):
    Original NDF version.

 1995 January 16 (MJC):
    Replaced AIF by PAR.  Added ERROR option to parameter COMP.
2 Implementation_Status
   -  This routine correctly processes the DATA, QUALITY,
   TITLE, and VARIANCE components of an NDF data structure.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.

   -  Any number of NDF dimensions is supported.

1 OUTLINE
Draws an outline of a 2-d NDF.

Usage:

   outline

Description:

   This application draws an outline of a 2-dimensional NDF on the
   current graphics device, aligning it with any existing plot.

   Annotated axes can be produced (see parameter AXES), and the
   appearance of the axes and curve can be controlled in detail (see
   parameter STYLE). The axes show co-ordinates in the current
   co-ordinate Frame of the supplied NDF.

   This command is a synonym for "contour mode=bounds penrot=yes".

2 Parameters
For information on individual parameters, select from the list below:
3 AXES
AXES = _LOGICAL (Read)
   TRUE if labelled and annotated axes are to be drawn around the
   outline, showing the current co-ordinate Frame of the
   supplied NDF. The appearance of the axes can be controlled using
   the STYLE parameter. [TRUE]
3 DEVICE
DEVICE = DEVICE (Read)
   The plotting device. [current image-display device]
3 LABPOS
LABPOS = _REAL() (Read)
   Specifies the position at which to place a label identifying the
   input NDF within the plot. The label is drawn parallel to the
   first pixel axis. Two values should be supplied for LABPOS. The 
   first value specifies the distance in millimetres along the first
   pixel axis from the centre of the bottom left pixel to the left 
   edge of the label. The second value specifies the distance in 
   millimetres along the second pixel axis from the centre of the 
   bottom left pixel to the baseline of the label. If a null (!) 
   value is given, no label is produced. The appearance of the label 
   can be set by using the STYLE parameter (for instance 
   "Size(strings)=2"). [current value]
3 MARGIN
MARGIN( 4 ) = _REAL (Read)
   The widths of the margins to leave around the outline for
   axis annotation. The widths should be given as fractions of the
   corresponding dimension of the current picture. The actual margins
   used may be increased to preserve the aspect ratio of the DATA
   picture. Four values may be given, in the order; bottom, right,
   top, left. If fewer than four values are given, extra values are
   used equal to the first supplied value. If these margins are too
   narrow any axis annotation may be clipped. If a null (!) value is
   supplied, the value used is 0.15 (for all edges) if annotated axes
   are being produced, and zero otherwise. See also parameter KEYPOS.
   [current value]
3 NDF
NDF = NDF (Read)
   NDF structure containing the 2-dimensional image to be
   contoured.
3 STYLE
STYLE = GROUP (Read)
   A group of attribute settings describing the plotting style to use
   for the contours and annotated axes.

   A comma-separated list of strings should be given in which each
   string is either an attribute setting, or the name of a text file
   preceded by an up-arrow character "^". Such text files should
   contain further comma-separated lists which will be read and
   interpreted in the same manner. Attribute settings are applied in
   the order in which they occur within the list, with later settings
   over-riding any earlier settings given for the same attribute.

   Each individual attribute setting should be of the form:

      <name>=<value>

   where <name> is the name of a plotting attribute, and <value> is
   the value to assign to the attribute. Default values will be
   used for any unspecified attributes. All attributes will be
   defaulted if a null value (!) is supplied. See section "Plotting
   Attributes" in SUN/95 for a description of the available
   attributes. Any unrecognised attributes are ignored (no error is
   reported).

   The appearance of the contours is controlled by the attributes
   Colour(Curves), Width(Curves), etc (the synonym Contours may be
   used in place of Curves). The contour appearance established in
   this way may be modified using parameters PENS, PENROT and DASHED.
   [current value]
2 Related_Applications
   KAPPA: WCSFRAME, CONTOUR, PICDEF.
2 Authors
DSB: David S. Berry (STARLINK)

2 History
 31-JAN-2001 (DSB):
    Original version.

1 OUTSET
    Sets pixels outside a specified circle in a 2-d data array to a
    specified value
 
   A circle of a given centre and diameter within the 2-d data array
   of the input IMAGE structure is specified.  The data array written
   to the output IMAGE structure, is a copy of the input data array
   except pixels outside the circle are set to a specified value.
2 AUTHORS
   Mark McCaughrean UoE (REVA::MJM)
   Malcolm Currie  STARLINK (RAL::CUR)
2 BUGS
   None known.
2 HISTORY
   17-09-1985 : First implementation (REVA::MJM)
   03-07-1986 : Tidied and more error checking (REVA::MJM)
   1986 Aug 7 : Renamed algorithmic routine to OTSTSB, reordered
                arguments (2nd to 7th). (RAL::CUR).
   1986 Aug 29: Added arguments section to the prologue, nearly
                conformed to Starlink standards (RAL::CUR).
   1988 Mar 17: Referred to `array' rather than `image'
                (RAL::CUR)
   1988 May 31: More reporting of error context (RAL::CUR)
   1989 Jun 13: Allow for processing primitive NDFs (RAL::CUR)
   1989 Aug  8: Passed array dimensions as separate variables
                to OTSTSB (RAL::CUR).
   1990 Oct  9: x-y centre is co-ordinates rather than pixel
                indices; added bad-value option for the replacement
                value (RAL::CUR).
   1991 Oct 25: Propagates AXIS, UNITS, LABEL, and HISTORY
                (RAL::CUR).
   1992 Feb 25: Limited processing of simple NDFs (RAL::CUR).
   1992 Mar  3: Replaced AIF parameter-system calls by the extended
                PAR library (RAL::CUR).
2 PARAMETERS
   INPIC  =  IMAGE( READ )
       IMAGE structure containing the array to be modified
   OUTPIC  =  IMAGE( WRITE )
       Output IMAGE structure containing the modified array
   OTITLE  =  CHARACTER( READ )
       Title for the output IMAGE structure
   XCENTRE  =  REAL( READ )
       x co-ordinate of the centre of the circle to be used
   YCENTRE  =  REAL( READ )
       y co-ordinate of the centre of the circle to be used
   DIAMETER  =  REAL( READ )
       Diameter of the circle to be used
   NEWVAL  =  REAL( READ )
       Value to replace old values in the pixels outside the circle
       If this is set to 'Bad' the magic-value is used.
3 INPIC
  position    1
  keyword     'INPIC'
  type        'IMAGE'
  access      'READ'
  vpath       'PROMPT'
  ppath       'GLOBAL'
  association '<-GLOBAL.DATA_ARRAY'
  prompt      'Image to be modified'
  help        'Name of IMAGE structure containing the 2-d data array 
              to be modified'
3 OUTPIC
  position    2
  keyword     'OUTPIC'
  type        'IMAGE'
  access      'WRITE'
  vpath       'PROMPT'
  association '->GLOBAL.DATA_ARRAY'
  prompt      'Image after being modified'
  help        'Name given to the IMAGE structure to hold the data 
              array after being modified'
3 OTITLE
  position    3
  keyword     'OTITLE'
  type        '_CHAR'
  vpath       'DEFAULT'
  prompt      'Title for output image'
  default     'KAPPA - Outset'
  help        'Character string used as a title for the output IMAGE 
              structure.'
3 XCENTRE
  position    4
  keyword     'XCENTRE'
  type        '_REAL'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'x co-ordinate of circle centre'
  help        'Give the x co-ordinate of the centre of the circle to 
              be used'
3 YCENTRE
  position    5
  keyword     'YCENTRE'
  type        '_REAL'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'y co-ordinate of circle centre'
  help        'Give the y co-ordinate of the centre of the circle to 
              be used'
3 DIAMETER
  position    6
  keyword     'DIAMETER'
  type        '_REAL'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'Diameter of circle'
  help        'Give the diameter in pixels of the circle to be used'
3 NEWVAL
  position    7
  keyword     'NEWVAL'
  type        '_LITERAL'
  vpath       'PROMPT'
  ppath       'DEFAULT'
  prompt      'New value for pixels outside circle'
  default     0.0
  help        'This will become the new value for all pixels outside 
              the circle.  BAD gives the bad-pixel value.'

1 OVCLEAR
Clears an image-display overlay.

Usage:

   ovclear [device] [current]

Description:

   This application clears an overlay device, but without purging
   the graphics-database entries for the device.  Optionally, only
   the current picture is cleared.
2 Parameters
For information on individual parameters, select from the list below:
3 CURRENT
CURRENT = _LOGICAL (Read)
   If TRUE, then only the current picture is cleared. [FALSE]
3 DEVICE
DEVICE = DEVICE (Read)
   The graphics device to be cleared.  It must be in GNS classes
   IMAGE_OVERLAY or WINDOW_OVERLAY. [Current image-display-overlay
   device]
2 Examples
ovclear
   Clears the current image-overlay device.

ovclear current
   Clears the current picture on the current image-overlay device.

ovclear xoverlay
   Clears the xoverlay device.
2 Related_Applications
   KAPPA: GDCLEAR, IDCLEAR, OVSET.
2 Authors
MJC: Malcolm J. Currie  (STARLINK)
2 History
 1992 November 30 (MJC):
    Original version.
1 OVSET
Selects a current image-display overlay.

Usage:

   ovset device

Description:

   This application selects a current image-display overlay. This
   device will be used for all applications requiring an
   image-display overlay until changed explicitly.
2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   The image-display overlay to become the current image-display
   overlay device.  The device must be in GNS categories
   IMAGE_OVERLAY or WINDOW_OVERLAY.
2 Examples
ovset xov
   Makes the xov device the current image-display overlay.
2 Authors
MJC: Malcolm J. Currie  (STARLINK)
2 History
 1991 June 27 (MJC):
    Original version.

 1992 June 16 (MJC):
    Made to work with WINDOW_OVERLAY class.  The restriction on the
    number of colour indices has therefore been been relaxed.
1 PALDEF
Loads the default palette to a colour table.

Usage:

   paldef [device]

Description:

   This application loads the standard palette of colours to fill
   the portion of the current image display's colour table which is
   reserved for the palette.  The palette comprises 16 colours and
   is intended to provide coloured annotations, borders, axes,
   graphs etc. that are unaffected by changes to the lookup table
   used for images.

   The standard palette is as follows
     0: Black     1: White     2: Red       3: Green     4: Blue
     5: Yellow    6: Magenta   7: Cyan      8--15: Black
2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   Name of the image display to be used.  The device must be in
   one of the following GNS categories: IMAGE_DISPLAY,
   IMAGE_OVERLAY, MATRIX_PRINTER or WINDOW, and have at least 24
   colour indices.  [Current image-display device]
2 Examples
paldef
   This loads the standard palette into the reserved portion of
   the colour table of the current image display.

paldef xwindows
   This loads the standard palette into the reserved portion of
   the colour table of the xwindows device.
2 Related_Applications
   KAPPA: PALENTRY, PALREAD, PALSAVE.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1991 July 19 (MJC):
    Original version.

 1994 January 24 (MJC):
    Allowed the device to be a MATRIX_PRINTER.
1 PALENTRY
Enters a colour into an image display's palette.

Usage:

   palentry palnum colour [device]

Description:

   This application obtains a colour and enters it into the palette
   portion of the current image display's colour table.  The palette
   comprises up to 16 colours and is intended to provide coloured
   annotations, borders, axes, graphs etc. that are unaffected by
   changes to the lookup table used for images.

   A colour is specified either by the giving the red, green, blue
   intensities; or named colours.
2 Parameters
For information on individual parameters, select from the list below:
3 COLOUR
COLOUR() = LITERAL (Read)
   A colour to be added to the palette at the entry given by
   parameter PALNUM.  It is either:

     o  A named colour from the standard colour set, which may
     be abbreviated.  If the abbreviated name is ambiguous the
     first match (in alphabetical order) is selected.  The case
     of the name is ignored.  Some examples are "Pink", "Yellow",
     "Aquamarine", and "Orchid".

     o  Normalised red, green, and blue intensities separated by
     commas or spaces.  Each value must lie in the range 0.0--1.0.
     For example, "0.7,0.7,1.0" would give a pale blue.
3 DEVICE
DEVICE = DEVICE (Read)
   Name of the image display to be used.  The device must be in
   one of the following GNS categories: IMAGE_DISPLAY,
   IMAGE_OVERLAY, WINDOW, WINDOW_OVERLAY, or MATRIX_PRINTER and
   have at least 2 colour indices.  [Current image-display device]
3 PALNUM
PALNUM = _INTEGER (Read)
   The number of the palette entry whose colour is to be
   modified.  PALNUM must lie in the range zero to the minimum
   of 15 or the number of colour indices minus one.  The
   suggested default is 1.
2 Examples
palentry 5 gold
   This makes palette entry number 5 have the colour gold in the
   reserved portion of the colour table of the current image
   display.

palentry 12 [1.0,1.0,0.3] xwindows
   This makes the xwindows device's palette entry number 12 have
   a pale-yellow colour.
2 Related_Applications
   KAPPA: PALDEF, PALREAD, PALSAVE.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1991 July 19 (MJC):
    Original version.

 1992 March 3 (MJC):
    Replaced AIF parameter-system calls by the extended PAR
    library.

 1992 December 1 (MJC):
    Made to work with WINDOW_OVERLAY devices.
1 PALREAD
Fills the palette of a colour table from an NDF.

Usage:

   palread palette [device]

Description:

   This application reads a palette of colours from an NDF, stored as
   red, green and blue intensities, to fill the portion of
   the current image display's colour table which is reserved for
   the palette.  The palette comprises 16 colours and is intended
   to provide coloured annotations, borders, axes, graphs etc. that
   are unaffected by changes to the lookup table used for images.
2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   Name of the image display to be used.  The device must be in
   one of the following GNS categories: IMAGE_DISPLAY,
   IMAGE_OVERLAY, or WINDOW, and have at least 24 colour indices.
   The device must also not reset when the device is opened
   (since the existing colour table would be lost).  [Current
   image-display device]
3 PALETTE
PALETTE = NDF (Read)
   The name of the NDF containing the palette of reserved colours
   as its data array.  The palette must be 2-dimensional, the
   first dimension being 3, and the second 16.  If the second
   dimension is greater than 16 only the first 16 colours are
   used; if it has less than 16 just fill as much of the palette
   as is possible starting from the first colour.  The palette's
   values must lie in the range 0.0--1.0.
2 Examples
palread rustic
   This loads the palette stored in the NDF called rustic into
   the reserved portion of the colour table of the current
   image display.

palread rustic xwindows
   This loads the palette stored in the NDF called rustic into
   the reserved portion of the colour table of the xwindows
   device.
2 Related_Applications
   KAPPA: PALDEF, PALENTRY, PALSAVE.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1991 July 19 (MJC):
    Original version.
1 PALSAVE
Saves the current palette of a colour table to an NDF.

Usage:

   palsave palette [device] [title]

Description:

   This application reads the palette portion of the current image
   display's colour table and saves it in an NDF.  The palette
   comprises 16 colours and is intended to provide coloured
   annotations, borders, axes, graphs etc. that are unaffected by
   changes to the lookup table used for images.  Thus once you have
   established a palette of colours you prefer, it is straightforward
   to recover the palette at a future time.
2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   Name of the image display to be used.  The device must be in
   one of the following GNS categories: IMAGE_DISPLAY,
   IMAGE_OVERLAY, or WINDOW, and have at least 24 colour indices.
   The device must also not reset when the device is opened
   (since the existing colour table would be lost).  [Current
   image-display device]
3 PALETTE
PALETTE = NDF (Write)
   The NDF in which the current colour-table reserved pens are
   to be stored.  Thus if you have created non-standard colours
   for annotation, doodling, colour of axes etc. they may be
   stored for future use.
3 TITLE
TITLE = LITERAL (Read)
   Title for the output NDF. ["KAPPA - Palsave"]
2 Examples
palsave rustic
   This saves the palette of the colour table of the current
   image display into the NDF called RUSTIC.

palsave hitec xwindows title="Hi-tech-look palette"
   This saves the palette of the colour table of the xwindows
   device in the NDF called hitec.  The NDF has a title called
   "Hi-tech-look palette".
2 Related_Applications
   KAPPA: PALDEF, PALENTRY, PALREAD.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1991 July 19 (MJC):
    Original version.
1 Parameters
KAPPA is a command-driven package.  Commands have parameters by
which you can qualify their behaviour.  Parameters are obtained in
response to prompts or supplied on a command line.

For convenience, the main aspects of the ADAM parameter system as
seen by a user of KAPPA are described below, but note that most of
what follows is applicable to any Starlink application.

2 Summary
For your convenience, here is a summary of how to use parameters.
If you want more information, go to the appropriate sub-topic
of "Parameters".

  o  Command-line values

    On the command line you can supply values by keyword or by
    position.  Sub-topic
    "Specifying_Parameter_Values_on_Command_Lines" has more
    details including abbreviated keywords.

  o  ACCEPT, PROMPT, RESET command-line special keywords

    ACCEPT accepts all the suggested defaults that would otherwise
    be prompted.  PROMPT prompts for all the parameters not given
    on the command line, and RESET resets all the suggested
    defaults to their initial values.  You can find more details
    and examples in sub-topic
    "Special_Keywords:_ACCEPT,_PROMPT,_RESET".

  o  NAME - Prompt string /Suggested default/ >

    This is a schematic of a prompt.  NAME is the parameter's name.
    You normally respond with the value for the parameter, but
    there are special responses available (see below).  If you just
    hit the return key, the suggested default becomes the parameter
    value.  Many parameters are defaulted without prompting.
    Sub-topics "Defaults" and "Globals" have more details.

Here is a list of some example parameter values to illustrate the
possible ways you can respond to a prompt.  Where there are
command-line differences, they are noted.

  o  5409.12

    This is a scalar.  Numerical values can be integer, real, or
    double precision.

  o  12,34,56,78

    This is a vector.  They must be enclosed in [] if the array is
    supplied on the command line, or for character arrays.

  o  [[11,21,31],[12,22,32]]

    This is a 3x2 array.  Arrays of dimension greater than 2 should
    appear in nested brackets.  See sub-topic "Arrays" for more
    about array values. 

  o  T
  o  no

   This is a TRUE value for a logical parameter.  Acceptable values
   are TRUE, FALSE, YES, NO, T, F, Y, N and their lowercase
   equivalents.  On the command line, the parameter name as a
   keyword means TRUE.  If the name is prefixed with NO, the value is
   set to FALSE.

  o  a string
  o  "a string"

    This is a string.  Strings need not be quoted at prompts.
    Quotes are required on the command line if the string includes
    spaces or wildcards, or is a comma-separated array of strings.
    There is more in sub-topic "Strings".  Some parameters offer a
    selection from a menu to which you give an unambiguous
    abbreviation to select an option.  Other parameters can be
    numerical or a string.  See sub-topic "Menus" for more
    information.

  o  filename
  o  @123

    This enters a filename (or tape drive).  You give a text
    filename verbatim, and NDFs without the file extension.
    Foreign formats will  usually have the file extension.  Should
    the filename be a numerical value, it must be preceded by an @.
    There is more in sub-topic "Strings".

  o  min
  o  max

    This selects the minimum- or maximum-allowed value, but not all
    parameters have a defined a range of permitted values.  See
    sub-topic "MIN_MAX".

  o  !

    Enters the null value.  This has a variety of special meanings;
    which one will depend on the particular parameter.  For example,
    null might indicate that an output file is not to be created, or
    a loop is to be ended.  There are more examples in sub-topic
    "Abort_and_Null".

  o  !!
    This aborts the application cleanly.

  o  ?
  o  ??

    A single question mark presents the online help for the
    parameter, and then reprompts.  A double question mark leaves
    you in the help system to explore other help information.  See
    sub-topic "Help" for examples.   These special values are not
    supported from the command line.

  o  \
    This accepts the suggested default for the prompted parameter
    and the respective suggested defaults for all subsequent
    parameters for which prompting would otherwise occur.  On the
    command line \ is an abbreviation of the ACCEPT keyword, and it
    applies to all parameters that would otherwise be prompted.
    Note that from the shell you write \\, as \ is a shell
    metacharacter.


2 Defaults
Command-line values are used mostly for those parameters that are
normally defaulted by the application.  Defaulted parameters enable
applications to have many options, say for controlling the
appearance of some graphical output, without making routine
operations tedious because of a large number of prompts.  The values
of normally defaulted parameters are given in the help for each
parameter within each application.  They are enclosed in square
brackets at the end of the parameter description for NDF
applications.
 
     icl> help median param *
 
gives details of all parameters in application MEDIAN.  Other
packages have similar help commands.  (Aside: IMAGE-format
applications have their parameter help arranged differently.  For
each parameter there is a line that begins "vpath" which tells
the parameter system from where it should try to obtain a value or
values for that parameter.  If it does not begin 'PROMPT' the
parameter will be defaulted.  A vpath of 'DEFAULT' indicates that
the parameter will take the value given by the default field; a
vpath of 'DYNAMIC' means that the application has computed a
suitable default, usually depending on the values of other
parameters or the dimensions of your data array.  If you want to
override one of these defaults, then you must specify the
parameter's value on the command line.)

When you are prompted you will usually be given a suggested default
value in / / delimiters.  You can choose to accept the default by
pressing carriage return.  For example, 64 is the suggested value
below.
 
     XDIM - x dimension of output array /64/ >
 
Alternatively, enter a different value
 
     XDIM - x dimension of output array /64/ > 109
 
to override the default.  Some defaults begin with an @.
 
     INPIC - Input image /@starfield/ > 
 
These are associated with files (text and HDS) and devices
(graphics and tape).  If you want to override the default given,
you do not have to prefix your value with an @, e.g.
 
     DEVICE - Name of display device /@xwindows/ > x2w
 
There are rare cases when the syntax is ambiguous, and it is then
that you need to include the @.  The sub-topic "Strings" describes
when the @ is needed.

From ICL the default value can be edited to save typing by first
pressing the <TAB> key.  The editor behaves like the shell
command-line editor.  Defaults may change as data are processed by
KAPPA.  Often the current (last) value of the parameter will be
substituted, or a dynamic value is suggested depending on the
values of other parameters.  Here is an example comprising a loop
within an application. 
 
     INPIC - Image to be inspected /@horsehead/ >
     Title = KAPPA - Gauss 
     Array is 109 by 64 pixels 
     CHOICE - Peep, Examine or List /'P'/ >

     XCEN - x centre pixel index of 7x7 box /55/ > 60 
     YCEN - y centre pixel index of 7x7 box /32/ > 28
        .              .               .              .
        .              .               .              .
        .              .               .              .
     ANOTHER - Another inspection ? /YES/ >
     CHOICE - Peep, Examine or List /'P'/ >

     XCEN - x centre co-ordinate of 7x7 box /60/ > 66 
     YCEN - y centre co-ordinate of 7x7 box /28/ > 
 
and so on.  Notice that the current values of the centres are the
suggested values at the second pair of prompts.

Current values of parameters are stored in a parameter file, and
so they persist between sessions.  For tasks run from the shell,
this is an HDS file $ADAM_USER/<application>.sdf, where
<application> is the name of the application.  (If the environment
variable $ADAM_USER is not defined the parameter file is situated
in $HOME/adam).

Unfortunately, tasks invoked from ICL use a monolith parameter
file, which contains the individual application parameter files for
the members.  So for example, KAPPA has kappa_mon.sdf,
kapview_mon.sdf, and ndfpack_mon.sdf stored in same directory as
the individual files.  This duality means that there are two
independent sets of current values for each task depending on
where you ran it from.

The parameter file should not be deleted unless the parameters
values are to be completely reset, or the file has been corrupted
in some way.  If you suspect the latter case, say after
interrupting a task, run HDSTRACE (SUN/102) on the file to check
its integrity.

2 Globals
KAPPA stores a number of global parameters that are used as
defaults to reduce typing in response to prompts.  Global means
that they are shared between applications.  The most common is the
last IMAGE structure or NDF written or accessed.  In the example
in the "Defaults" sub-topic, this was horsehead.sdf.  If you just
press <CR> to the prompt, the global value is unchanged.  Only when
you modify the parameter and the application completes without error
is the global value updated.

All global parameters are stored in HDS file $ADAM_USER/GLOBAL.sdf,
or $HOME/adam/GLOBAL.sdf if the $ADAM_USER environment variable is not
defined.  The full list is given below.

GLOBAL.COORD_SYSTEM     Current co-ordinate system.
GLOBAL.DATA_ARRAY       Last NDF/foreign dataset accessed or written.
GLOBAL.GRAPHICS_DEVICE  Current GKS workstation.
GLOBAL.IMAGE_DISPLAY    Current image display (base).
GLOBAL.IMAGE_OVERLAY    Current image-display overlay.
GLOBAL.INTERACTIONMODE  Current interaction mode. 
GLOBAL.LUT              Last lookup table file accessed or written. 
GLOBAL.TRANSFORM        Current transformation structure.

KAPPA uses the last DATA_ARRAY written or accessed as the suggested
default value for the next prompt for an NDF structure or foreign
data format.  The same applies to the current lookup table and
transformation structure.  However, the remaining, including the
three graphics global parameters are defaulted---you will not be
prompted.  Details of how to control these parameters are given in
various topics:
   "Selecting_Graphics_Devices" for the graphics devices,
   "Interaction_Mode" for the interaction mode, and
   "Co-ordinate_Systems" for the co-ordinate systems.

The values of all global parameters may be inspected with the 
GLOBALS task.  You can make them undefined using NOGLOBALS.

     ICL> globals
     The current data file                : @/home/dro/jkt/ccdpic
     The current graphics device is       : @ps_l
     The current image-display device is  : @xwindows
     The current image-display overlay is : <undefined>
     The current transformation is        : @/home/dro/deform/warpit
     The current interaction mode is      : <undefined>
     The current co-ordinate system is    : WORLD

In the above example no interaction mode is defined.  The next time
you call an application which uses the interaction mode you would be
prompted for a value.   Likewise for the image-display overlay. 
(Under normal circumstances you will not have to enter the @ prefix
yourself.) 

2 Strings
Notice that the single or double quotes around strings given in
response to prompts for a character parameter can be omitted.  However,
on the command line these delimiters are needed if the string
contains spaces, otherwise the second and subsequent words could be
treated as separate positional parameters.

From the shell the quotes must be escaped.  For example,

     % settitle myndf \"A new title\"

would assign the title "A new title" to the NDF called myndf.

To indicate that the parameter should come from a data-structure
object, prefix the name with an @ to tell the parameter system that
it is a file name, and not a literal value.

     PLTITL - Plot title /' '/ @$ADAM_USER/galaxy.mytitle

In this example PLTITL has the value of object MYTITLE in
galaxy.sdf.  If the @ were omitted PLTITL would be
"$ADAM_USER/galaxy.mytitle".  You will need the @ prefix if your
file name is a number.  Note that the file extension should not be
included when giving the name of an HDS data file, including NDFs.
Otherwise HDS will look for an object called SDF nested within the
file.

Responses to prompts are case insensitive for comparison purposes.
Strings for character components in NDFs, plot captions and labels
are treated literally.

2 Arrays
If a parameter requires an array of values, the series should be in
brackets separated by commas or spaces.  For example,

     PERCENTILES - List of percentiles > [25,95.5,75]

would input three values: 25, 95.5, and 75 into the real parameter
PERCENTILES.  If the application is expecting an exact number of
values you will be reprompted, either for all the values if you
give too many, or the remaining values if you supply too few.
There is one exception where you can omit the brackets---a fairly
common one---and that is in response to a prompt for a
one-dimensional numeric array as above.

From the shell you must escape the brackets.

     % display mode=pe percentiles=\[95,5\]
     % display mode=pe percentiles='[95,5]'
     % display mode=pe percentiles="[95,5]"

All the above do this.  Single quotes have the advantage that you
can protect all the metacharacters that lie between the quotes, so
you don't need to escape each metacharacter.

Arrays of parameter values should appear in nested brackets.  For
example,

     CVALUE - Component values > [[2,3],[5,4],[7,1]]

supplies the values for a 2x3-element parameter array, where
element (1,3) has value 7.

2 Abort_and_Null
Responding to a prompt with a null value ! will not necessarily
cause the application to abort, but it can force a suitable default
to be used, where this is the most-sensible action.  A further use
is when an optional file may be created, such as a lookup table; a
! entered in response to the prompt for the filename means that no
file is to be output.  Many tasks use null as a default for
optional files.  In some applications, CRELUT, a null ends an
interactive loop.

Responding to a prompt with !! will abort the application.  This
process includes the various tidying operations such as the
unmapping and closing of files.  Any other method of stopping an
application prematurely can leave files mapped or corrupted.

2 Help
To get help about a parameter enter ?.  Usually, this will give
access to the help-library information for that parameter, for
example,

     BOX - Smoothing box size /3,3/ > ?

     BLOCK

       Parameters

         BOX(2) = _INTEGER (Read)
            The x and y sizes (in pixels) of the rectangular box to be
            applied to smooth the image. If only a single value is given,
            then it will be duplicated so that a square filter is used,
            except where the image is 1-dimensional, for which the box
            size along the insignificant dimension is set to 1.  The
            values given will be rounded up to positive odd integers,
            if necessary.

     BOX - Smoothing box size /3,3/ >

and then immediately reprompt you for the parameter.  There are
occasions when information about the parameter is insufficient; you
may require to examine the examples or the description of related
parameters.  This can be achieved by entering ?? to the prompt.
You can then delve anywhere in the help information.  When you exit
the help system you're reprompted for the parameter.

For the old, IMAGE-format applications, the ? does not enter
the help system, and so the help is limited to an unsatisfactory
and miserly 120 characters:

     DIRN - Direction of ramping > ?
       1 = L-R : 2 = R-L : 3 = B-T : 4 = T-B, where L is left, R is
     right, B is bottom and T is top
     DIRN - Direction of ramping > ?

Fortunately, this form of parameter help is virtually phased out.

2 Menus
Some parameters offer menus from which you select an option.  You do
not have to enter the full option string, but merely a string that
selects a choice unambiguously.  In many cases this can be as little
as a single character.  Here is an example,

     MODE - Method for selecting contour heights /'Free'/ > ?
         The method used to select the contour levels.  The options are
         described below.

           "Area"      - The contours enclose areas of the array for
                         which the equivalent radius increases by equal
                         increments.  You specify the number of levels.
           "Automatic" - The contour levels are equally spaced between
                         the maximum and minimum pixel values in the
                         array.  You supply the number of contour
                         levels.
           "Free"      - You define a series of contour values
                         explicitly.
           "Linear"    - You define the number of contours, the start
                         contour level and linear step between contours.
           "Magnitude" - You define the number of contours, the start
                         contour level and step between contours.  The
                         step size is in magnitudes so the nth contour
                         is dex(-0.4*(n-1)*step) times the start contour
                         level.

where a F would be sufficient to select the "Free" option, but at
least two characters would be needed if you wanted "Area" or
"Automatic".

Some parameters permit a mixture---a choice from a menu, or a
numerical value within a range.  The options are described in full
in the help for the specific parameter.

2 Environment_Variables
Environment variables operate both on the command line and prompts,
and both from the shell and ICL.  Thus if IMAGEDIR is an environment
variable pointing to a directory containing the NDF called ngc1365,
you could access it at a prompt as shown below.

     IN - Input image /@starfield/ > $IMAGEDIR/ngc1365

2 Specifying_Parameter_Values_on_Command_Lines
Parameters may be assigned values on the command line.  This is
useful for running tasks in batch mode and in procedures, and for
specifying the values of parameters that would otherwise be
defaulted.  A command-line parameter will prevent prompting for
that parameter unless there is an error with the given value, say
giving an alphabetic character string where a floating-point value
is demanded.

There are two ways in which parameter values may be given on the
command line: by keyword and by position.  The two forms may be
mixed with care.  The parser looks for positional parameters then
keywords, so you can have some positional values followed by keyword
values.  See some of the examples presented in the help about
specific tasks.

3 Keyword
Keywords may appear in any order. Here is an example of command-line
defaults using keywords.

     ICL> picdef current fraction=0.4

FRACTION is a real parameter.  CURRENT is a logical parameter; by
giving just its name it is assigned the value TRUE.  CURRENT=T would
have the same effect.  To obtain a FALSE value for a logical
parameter you add a NO prefix to keyword, for example,

     icl> picdef nocurrent

would be equivalent to the following.

     icl> picdef current=false

3 Abbreviations
There is an experimental system that allows you to abbreviate
parameter keywords to the minimum unambiguous length.  To use it,
you must first create an environment variable called ADAM_ABBRV
with an arbitrary value.

So for example

     % setenv ADAM_ABBRV true
     % display mo=pe pe=\[5,95\] ba=blue

would display an NDF between the 5 and 95 percentiles, and marking bad
pixels in blue.

If you give an ambiguous keyword, the parameter system will present
the list of possible keywords and ask you to select the one you
intended.  Suppose you want to display an image surrounded by axes
annotated using the NCAR fount, and you think that there is only one
parameter starting with F.

     % display axes f=ncar
     !! Ambiguous keyword F used on the command line
     !  Matches with FILL
     !           and FONT
       - Specify the keyword unambiguously > fo

When reprompted you just give an unambiguous abbreviation for the
desired parameter, that being FONT in this example.

3 Position
Alternatively, you can specify command-line values by position.
Here is an example.

     % thresh raw clipped 0 255

This applies thresholds to the NDF called raw to form a new NDF
called clipped.  The values between 0 and 255 are unchanged.  Note
that trailing parameters may be omitted---NEWLO and NEWHI in the
above example---but intermediate ones may not.  The position of a
parameter can be found in the Usage in the help for the application.
(Aside: for IMAGE-format applications look in the help topic of the
same name at the level beneath the topic "Parameters" in a given
application.)

3 Keyword_versus_Positional_Parameters
For tasks with a few parameters, using position is quick and
convenient.  However, in complex programmes with many parameters it
would be tedious not only to enter all the intermediate values
between the ones you want to define, but also to remember them all.
Another consideration is that some parameters do not have defined
positions because they are normally defaulted.  Keywords may also
be abbreviated (sub-topic "Abbreviations"). Thus the keyword
technique is recommended for most parameters, especially in
scripts and procedures.  Unabbreviated keywords insulate scripts
against new keywords and positional changes that are sometimes
needed.

See topic "Custom_KAPPA" if you want to learn how further to
abbreviate command strings to reduce typing for manual operation.

3 Special_Behaviour
Sometimes specifying a parameter on the command line induces
different behaviour, usually to inhibit a loop for procedures, or
to eliminate unnecessary processing.  For instance,

     ICL> centroid blob init=[51,42] mode=i

will determine the centroid near the point (51,42) in the NDF called
blob, and then it exits, whereas without the INIT value you would be
re-prompted for a further initial position; and

     % display galaxy mode=sc high=3000 low=1000

prevents the calculation of the extreme values of the NDF called
galaxy that are normally given as suggested defaults for parameters
HIGH and LOW, because HIGH and LOW are already known.

2 Special_Keywords:_ACCEPT,_PROMPT,_RESET
Another way in which prompts and default values can be controlled is
by use of the keywords ACCEPT, PROMPT and RESET.

The RESET keyword causes the suggested default value of all
parameters (apart from those already specified before it on the
command line) to be set to the original values specified by the
application or its interface file.  In other words global and
current values are ignored.

The PROMPT keyword forces a prompt to appear for every application
parameter.  This can be useful if you cannot remember the name of a
defaulted parameter or there would be too much to type on the
command line.  However, it may prove tedious for certain
applications that have tens of parameters, most of which you
normally never see.  You can abort if it becomes too boring.

The ACCEPT keyword forces the parameter system to accept the
suggested default values either for every application parameter if
the keyword appears on the command line, or all subsequent
parameters if it is supplied to a prompt.  In other words, those
parameters which would normally be prompted with a value between
"/ /" delimiters take the value between those delimiters.
Parameters that are normally defaulted behave as usual.  The ACCEPT
keyword needs to be used with care in scripts because not every
parameter has a default, and therefore must be given on the command
line for the application to work properly.  For example, CREFRAME
must have a value specified for parameter OUTPIC, the name of the
output data object.  If we run the application like this:

     ICL> creframe accept

it would fail in the sense that it would still have to prompt for a
value---it does not know where to write the output IMAGE
data file.  However, if we run CREFRAME like this:

     ICL> creframe outpic=stars accept

it would generate an output image using default values for all the
parameters except OUTPIC, and write the output to file stars.sdf.
Another point to be wary of is that some applications have loops,
LOOK, LUTABLE, and if you use the ACCEPT keyword it will
only operate the first time the application gets a parameter value.

Sometimes the keyword ACCEPT can be used without any parameter value
specifications on the command line.  For example, we could follow
the above command by the command:

     ICL> look accept

and the central 7x7 array of the image created by CREFRAME would
be displayed on your terminal without any parameter values being
prompted.  The symbol \ has the same effect as ACCEPT when used on
the command line or at prompts, thus:

     ICL> look \

would have the same effect as the previous example---and is quicker
to type.  In command lines from the shell, the backslash is a
metacharacter and has to be escaped.  The easiest way to do that is
to double the backslash.

     % look \\

How do you find out which parameters have suggested defaults, as
opposed to those that are normally defaulted?  Well, a good rule of
thumb is that parameters for output files (images, lookup tables
and text) will not have a default, but the remainder will.  There
are some exceptions, such as where null is the default for optional
files.  Consulting the description of the parameters should give the
suggested defaults, where appropriate.  (Aside: this information is
not given in the old-style (IMAGE-format) documentation.  For these
you can look at the interface information given for each parameter
as sub-topics of "Parameters" for the relevant application, or the
interface file itself ($KAPPA_DIR/kappa_mon.ifl).  If a parameter
is given a suggested default it will have a line beginning ppath
or a default line.)  If you want to use ACCEPT for an automatic
procedure or batch job you could do some tests to find which
parameters get prompted and then put them on the command line in
your procedure. 

The RESET and ACCEPT keywords will work in tandem.  So for instance,

     ICL> look reset accept

will reset the suggested defaults of LOOK to their original, preset
values, and accept these as the parameter values.

These special keywords may be abbreviated to no fewer than
two characters, if you have enabled keyword-abbreviation.

2 MIN_MAX
Many parameters have well-defined ranges of allowed values.  In some
cases it is useful to assign the maximum or minimum value to the
parameter.  Rather than give some numerical value, you can instead
supply MIN to select the minimum-allowed value, and MAX to select
the maximum.  This applies both on the command line and at prompts.
In the example,

     % block wlim=max

parameter WLIM takes its maximum (1.0) meaning that if any of the
input pixels in the smoothing box is bad, the corresponding output
pixel is set bad.

Consult the reference section or the online help to see if a given
parameter has such a range.  If you attempt to use MIN and
MAX where there is no range defined, you'll see an error
message like

    !! SUBPAR_MNMX: Parameter FONT - no upper limit set

and you'll be invited to give another value.

2 Output_Parameters
Not only can programmes have parameters to which you supply values,
but they can also write out the results of their calculations to 
output or results parameters.  This makes the results accessible to
subsequent tasks and to shell and ICL variables.  Example results
are statistics like the standard deviation or the FWHM of the
point-spread function, the co-ordinates of points selected by a
cursor, or the attributes of an NDF.  They are not data files
created by the application.  In the application specifications they
are listed separately from other parameters.

From the shell you can access these output parameters using the
KAPPA tool PARGET.  Suppose that you want to subtract the mean of
an NDF called myndf to make an a new NDF called outndf.

    % stats myndf > /dev/null
    % set mean = `parget mean stats`
    % csub myndf $mean outndf

STATS calculates the statistics of myndf, the displayed output being
discarded.  PARGET reports the mean value which is assigned to shell
variable mean.  Thereafter the mean value is accessible as $mean in
that process.  Thus the final command subtracts the mean value from
myndf.

You can obtain vector values too.  There is more on this in
in the section of SUN/95 on Arithmetic in C-shell scripts.

At the time of writing, ICL only permits scalar variables.  To do
the above from ICL, you would enter something like this.

    ICL> stats myndf mean=(vmean)
    ICL> csub myndf (vmean) outndf

vmean is an ICL variable.  The parentheses have the same effect
as the $ in the C-shell example, meaning "the value of" the
variable.  Note that you can't redirect the output to /dev/null.

If you use the PROMPT keyword (see sub-topic "Special_Keywords") for
an application with output parameters, the programme will bizarrely
prompt you for these.  It is not asking for a value, but a location
where to store the value.  It is strongly recommended that you just
accept the default (normally zero) so that the values are written to
their parameter file, and hence permits PARGET to work.

1 PARGET
Obtains the value or values of an application parameter.

Usage:

   parget parname applic

Description:

   This application reports the value or values of a parameter from
   a named task.  It does this by searching the parameter file of
   the task.  The purpose is to offer an easier-to-use interface for
   passing values (especially output parameters) between tasks in
   shell scripts.  The values are formatted in lines with as many
   values as can be accommodated across the screen up to a maximum of
   132 characters; values are space separated.  However, in scripts
   the values are likely to be written to a script variable.  Thus
   for example in the C-shell:

      set med = `parget histat median`

   would redirect the output to shell variable med, and thus a
   reference to $med would substitute the median value obtained the
   last time application HISTAT was invoked.  If the parameter
   comprises a vector of values these can be stored in a C-shell
   array.  For instance,

      set perval = `parget histat perval`

   would assign elements of the shell array perval[1], perval[2],
   etc. to the last-computed percentile values of HISTAT.
2 Parameters
For information on individual parameters, select from the list below:
3 APPLIC
APPLIC = LITERAL (Read)
   The name of the application from which the parameter comes.
3 PARNAME
PARNAME = LITERAL (Read)
   The parameter whose value or values are to be reported.
2 Examples
parget mean stats
   Report the value of parameter MEAN for the application STATS.

parget mincoord \
   This reports the values of parameter MINCOORD of the current
   application, in this case STATS.
2 Notes
-  The parameter file is located in the $ADAM_USER directory, if
defined, otherwise in the adam subdirectory of $HOME.  If it
cannot be located there, the task reports an error.

-  The parameter must exist in the selected application parameter
file and not be a structure, except one of type ADAM_PARNAME.

-  This task is not designed for use with ICL, where passing
parameter values is quite straightforward.  It does not operate
with monolith parameter files.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1995 August 15 (MJC):
    Original version.

1 PASTE
Pastes a series of NDFs upon each other.

Usage:

   paste in p1 [p2] ... [p25] out=?

Description:

   This application copies a series of NDFs, in the order supplied
   and taking account of origin information, on to a `base' NDF to
   produce an output NDF.  The output NDF is therefore a copy of the
   base NDF obscured wholly or partially by the other input NDFs.
   This operation is analogous to pasting in publishing.  It is
   intended for image editing and the creation of insets.

   The dimensions of the NDFs may be different, and indeed so may
   their dimensionalities.  The output NDF can be constrained to
   have the dimensions of the base NDF, so the pasted NDFs are
   clipped.  Normally, the output NDF will have dimensions such
   that all the input NDFs are accommodated in full.

   Bad values in the pasted NDFs are by default transparent, so the
   underlying data are not replaced during the copying.
2 Parameters
For information on individual parameters, select from the list below:
3 CONFINE
CONFINE = _LOGICAL (Read)
   This parameter controls the dimensions of the output NDF.  If
   CONFINE is FALSE the output NDF just accommodates all the input
   NDFs.  If CONFINE is TRUE, the output NDF's dimensions matches
   those of the base NDF. [FALSE]
3 IN
IN = NDF (Read)
   The base NDF on to which the other input NDFs will be pasted.
3 OUT
OUT = NDF (Write)
   The NDF resulting from pasting of the input NDFs onto the base
   NDF.  Its dimensions may be different from the base NDF.  See
   parameter CONFINE.
3 P1-P25
P1-P25 = NDF (Read)
   The NDFs to be pasted on to the base NDF.  The NDFs are pasted
   in the order P1, P2, ... P25.  There can be no missing NDFs,
   e.g. in order for P3 to be processed there must be a P2 given
   as well.  A null value (!) indicates that there is no NDF.
   NDFs P2 to P25 are defaulted to !.  At least one NDF must be
   pasted, therefore P1 may not be null.
3 TITLE
TITLE = LITERAL (Read)
   Title for the output NDF structure.  A null value (!)
   propagates the title from the base NDF to the output NDF. [!]
3 TRANSP
TRANSP = _LOGICAL (Read)
   If TRANSP is TRUE, bad values within the pasted NDFs are not
   copied to the output NDF as the bad values were transparent.
   If TRANSP is FALSE, all values are copied during the paste
   and a bad value will obscured an underlying value.  [TRUE]
2 Examples
paste aa inset out=bb
   This pastes the NDF called inset on to the arrays in the NDF
   called aa to produce the NDF bb.  Bad values are transparent.
   The bounds and dimensionality of bb may be larger than those of
   aa.

paste aa inset out=bb notransp
   As above except that bad values are copied from the NDF inset
   to NDF bb.

paste aa inset out=bb confine
   As the first example except that the bounds of NDF bb match
   those of NDF aa.

paste ccd fudge inset out=ccdc
   This pastes the NDF called fudge, followed by NDF inset on to
   the arrays in the NDF called ccd to produce the NDF ccdc.  Bad
   values are transparent.  The bounds and dimensionality of ccd
   may be larger than those of ccdc.
2 Authors
MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 1991 November 15 (MJC):
    Original version.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   VARIANCE, LABEL, TITLE, UNITS, WCS and HISTORY, components of an NDF
   data structure and propagates all extensions.  Propagation is from
   the base NDF.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.

   -  Any number of NDF dimensions is supported.

1 PERMAXES
Permute an NDF's pixel axes.

Usage:

   permaxes in out perm

Description:

   This application re-orders the pixel axes of an NDF, together with
   all related information (AXIS structures, and the axes of all 
   coordinate Frames stored in the WCS component of the NDF).

2 Parameters
For information on individual parameters, select from the list below:
3 IN
IN = NDF (Read)
   The input NDF data structure.
3 OUT
OUT = NDF (Write)
   The output NDF data structure.
3 PERM
PERM() = _INTEGER (Read)
   A list of integers defining how the pixel axes are to be permuted.
   The list must contain one element for each pixel axis in the NDF.
   The first element is the index of the pixel axis within the input
   NDF which is to become axis 1 in the output NDF. The second element
   is the index of the pixel axis within the input NDF which is to
   become axis 2 in the output NDF, etc. Axes are numbered from 1.
3 TITLE
TITLE = LITERAL (Read)
   A title for the output NDF.  A null value will cause the title
   of the NDF supplied for parameter IN to be used instead. [!]
2 Examples
permaxes a b [2,1]
   Swaps the axes in the 2-dimensional NDF called "a", to produce a
   new 2-dimensional NDF called "b".

permaxes a b [3,1,2]
   Creates a new 3-dimensional NDF called "b" in which axis 1
   corresponds to axis 3 in the input 3-dimension NDF called "a",
   axis 2 corresponds to input axis 1, axis 3 corresponds to input
   axis 2.
2 Notes

- If any WCS coordinate Frame has more axes then the number of pixel
axes in the NDF, then the high numbered surplus axes in the WCS Frame 
are left unchanged.

- If any WCS coordinate Frame has fewer axes then the number of pixel
axes in the NDF, then the Frame is left unchanged if the specified
permutation would change any of the high numbered surplus pixel axes.
A warning message is issued if this occurs.

2 Related_Applications
   KAPPA: ROTATE, FLIP; Figaro: IREVX, IREVY, IROT90.
2 Authors
DSB: David S. Berry (STARLINK)
2 History
 6-FEB-2001 (DSB):
    Original version.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   VARIANCE, LABEL, TITLE, UNITS, WCS and HISTORY components of the
   input NDF and propagates all extensions.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.  The data
   type of the input pixels is preserved in the output NDF.

1 PICBASE
Selects the BASE picture from the graphics database.

Usage:

   picbase

Description:

   This command selects the BASE picture.  Subsequent plotting for
   the chosen device will be in this new current picture.  The BASE
   picture is the largest picture available, and encompasses all
   other pictures.  By default the chosen device is the current one.

   This command is a synonym for "piclist picnum=1".

2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   The graphics workstation. [The current graphics device]
2 Examples
picbase
   This selects the BASE picture for the current graphics device.

picbase device=x2w
   This selects the BASE picture for the x2w device.
2 Related_Applications
   KAPPA: PICCUR, PICDATA, PICFRAME, PICLAST, PICLIST, PICSEL.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1995 August 23 (MJC):
    Original version.

1 PICCUR
Uses a cursor to select the current picture and to report the
co-ordinates of points.

Usage:

   piccur [mode] [name] [logfile] [device]

Description:

   This application allows you to select a new current picture in
   the graphics database using the cursor.  The picture associated
   with the last-selected point becomes the new current picture.

   This task also uses the cursor to read Cartesian co-ordinates
   from the chosen graphics device and displays them on your
   terminal.  In addition if the co-ordinate frame changes between
   selected positions, the comment, name, and any label associated
   with the new picture are appended to the message.  There is an
   option to let you store the co-ordinates, and their picture names
   and labels in a text file.

   There are three modes of operation to define which co-ordinate
   system/picture is to be used.  These are ANCHOR, CURRENT and
   DYNAMIC.  See the parameter MODE for details.

   In ANCHOR or DYNAMIC modes there is an option to select only
   pictures of a certain name in the database.  This is most useful
   when DATA pictures are covered by transparent FRAME pictures.
2 Parameters
For information on individual parameters, select from the list below:
3 COSYS
COSYS = LITERAL (Read)
   The co-ordinate system to be used.  This can be either "World"
   or "Data".  "World" makes the world co-ordinates of the cursor
   position to be reported.  World co-ordinates that relate to a
   location in a data array will be in array pixels.  If COSYS =
   "Data" the graphics database is examined for data co-ordinates
   stored via a transformation.  Data co-ordinates are arbitrary
   but most often they will be a linear or logarithmic
   transformation of the world co-ordinates.  For example, the x
   co-ordinate of a spectrum would be given in pixels if COSYS =
   "World", but if COSYS = "Data" the x co-ordinate could be in
   wavelength units, such as Angstroms.  If the database does not
   have a world-to-data transformation for a given picture, the
   value of this parameter is irrelevant and world co-ordinates
   will be reported for that picture. [Current co-ordinate system]
3 DEVICE
DEVICE = DEVICE (Read)
   The graphics workstation. [The current graphics device]
3 DOUBLE
DOUBLE = _LOGICAL (Read)
   If TRUE, co-ordinates will be reported, written to the output
   parameters, and stored in the text file in double precision,
   otherwise single precision is used.  [FALSE]
3 LOGFILE
LOGFILE = FILENAME (Write)
   The name of the text file in which the co-ordinates of points
   selected with the cursor may be stored.  A null string (!)
   means that no file is created.  The suggested default is the
   current value. [!]
3 MODE
MODE = LITERAL (Read)
   The mode defining the co-ordinate system/picture in which
   cursor positions are returned.  There are three options.

      "Current" selects the current picture in the AGI
      database and reports the position of a point selected by
      the cursor.  If the point does not lie within the picture,
      an extrapolated position is reported.

      "Dynamic" selects the topmost picture in the AGI
      database which encompasses that position selected.  Thus
      the second and subsequent cursor hits may result in the
      selection of a new picture.  On exit the last picture
      selected becomes the current picture.

      "Anchor" lets the first cursor hit select a
      picture which remains current throughout the running of
      the application.  If subsequent cursor hits fall outside
      the extent of this picture, a position extrapolated from
      the picture's co-ordinate system is reported.  On exit the
      anchor picture becomes the current picture.
   ["Dynamic"]
3 NAME
NAME = LITERAL (Read)
   Only pictures of this name are to be selected.  A null string
   (!) or blanks means that pictures of all names may be selected.
   [!]
3 XC
XC = _DOUBLE (Write)
   The x co-ordinate of the last point selected with the cursor.
3 YC
YC = _DOUBLE (Write)
   The y co-ordinate of the last point selected with the cursor.
2 Examples
piccur
   This obtains the co-ordinates of any visible picture for the
   current graphics device by use of the cursor.  In this and all
   the examples, the picture containing the last-selected point
   becomes the new picture.

piccur cosys=w
   This obtains the world co-ordinates of any visible picture for
   the current graphics device by use of the cursor.

piccur current device=graphon
   This obtains the co-ordinates of any visible picture in the
   reference frame of the current picture of the Graphon device.

piccur logfile=stars.dat name=data
   This obtains the co-ordinates of any visible DATA picture for
   the current graphics device.  The x-y co-ordinates, and their
   picture names and labels are stored in the text file called
   stars.dat.
2 Notes
-  Should an error occur trying to obtain the base picture for
ANCHOR or DYNAMIC modes, the current picture is unchanged.

-  In DYNAMIC and ANCHOR modes, if the cursor is situated at a
point where there are no pictures of the selected name, the
co-ordinates in the base picture are reported.
2 Related_Applications
   KAPPA: CURSOR, PICBASE, PICDATA, PICEMPTY, PICENTIRE, PICFRAME,
   PICLIST, PICSEL, PICVIS.
2 Authors
JM: Jo Murray  (STARLINK)

MJC: Malcolm J. Currie  (STARLINK)
2 History
 1995 August 25 (MJC):
    Original version based on CURSOR by MJC and JM.

1 PICDATA
Selects the last DATA picture from the graphics database.

Usage:

   picdata

Description:

   This command selects the last-created DATA picture.  Subsequent
   plotting for the chosen device will be in this new current
   picture.  By default the chosen device is the current one.

   This command is a synonym for "piclist name=data picnum=last".

2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   The graphics workstation. [The current graphics device]
2 Examples
picdata
   This selects the last DATA picture for the current graphics
   device.

picdata device=xw
   This selects the last DATA picture for the xw device.
2 Related_Applications
   KAPPA: PICCUR, PICBASE, PICFRAME, PICLAST, PICLIST, PICSEL.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1995 August 23 (MJC):
    Original version.

1 PICDEF
Defines a new graphics-database FRAME picture or an array of
FRAME pictures.

Usage:

   picdef [mode] [fraction]
      { xpic ypic prefix=?
      { lbound ubound
     mode

Description:

   This application creates either one new graphics-database FRAME
   picture or a grid of new FRAME pictures.  It offers a variety of
   ways by which you can define a new picture's location and extent.
   You may constrain a new picture to lie within either the current
   or the BASE picture, and the new picture adopts the world
   co-ordinate system of that reference picture.

   You may specify a single new picture using one of three methods:
     1.  moving a cursor to define the lower and upper bounds via
         pressing choice number 1 (the application will instruct what
         to do for the specific graphics device), provided a cursor
         is available on the chosen graphics workstation;
     2.  obtaining the bounds from the environment (in world
         co-ordinates of the reference picture);
     3.  or by giving a position and size for the new picture. The
         position is specified by a two-character code. The first
         controls the vertical location, and may be "T", "B", or "C"
         to create the new picture at the top, bottom, or in the
         centre respectively.  The second defines the horizontal
         situation, and may be "L", "R", or "C" to define a new
         picture to the left, right, or in the centre respectively.
         Thus a code of "BR" will make a new picture in the
         bottom-right corner. The size of the new picture along each
         axis may be specified either in centimetres, or as a fraction
         of the corresponding axis of the reference picture. The picture
         may also be forced to have a specified aspect ratio.

   The picture created becomes the current picture on exit.

   Alternatively, you can create an array of n-by-m equal-sized
   pictures by giving the number of pictures in the horizontal and
   vertical directions.  These may or may not be abutted.  For easy
   reference in later processing the pictures may be labelled
   automatically.  The label consists of a prefix you define,
   followed by the number of the picture.  The numbering starts at a
   defined value, usually one, and increments by one for each new
   picture starting from the bottom-left corner and moving from left
   to right to the end of the line.  This is repeated in each line
   until the top-right picture.  Thus if the prefix were "GALAXY",
   the start number is one and the array comprises three pictures
   horizontally and two vertically, the top-left picture would have
   the label "GALAXY4".  On completion the bottom-left picture in
   the array becomes the current picture.
2 Parameters
For information on individual parameters, select from the list below:
3 ASPECT
ASPECT = _REAL (Read)
   The aspect ratio (x/y) of the picture to be created in modes
   other than Cursor, Array, and XY.  The new picture is the
   largest possible with the chosen aspect ratio that will fit
   within the part of the reference picture defined by the
   fractional sizes (see parameter FRACTION).  The justification
   comes from the value of MODE.  Thus to obtain the largest
   picture parameter set FRACTION=1.0.  A null value (!) does not
   apply an aspect-ratio constraint, and therefore the new
   picture fills the part of the reference picture defined by the
   fractional sizes. [!]
3 CURRENT
CURRENT = _LOGICAL (Read)
   TRUE if the new picture is to lie within the current picture,
   otherwise the new picture can lie anywhere within the BASE
   picture.  In other words, when it is TRUE the current picture
   is the reference picture, and when FALSE the base is the
   reference picture. [FALSE]
3 DEVICE
DEVICE = DEVICE (Read)
   The graphics device. [Current graphics device]
3 FILL
FILL = _REAL (Read)
   The linear filling factor for the Array mode.  In other words
   the fractional size (applied to both co-ordinates) of the new
   picture within each of the XPIC * YPIC abutted sections of
   the picture being sub-divided.  Each new picture is located
   centrally within the section.  A filling factor of 1.0 means
   that the pictures in the array abut.  Smaller factors permit a
   gap between the pictures.  For example, FILL = 0.9 would give
   a gap between the created pictures of 10 per cent of the
   height and width of each picture, with exterior borders of 5
   per cent.  FILL must lie between 0.1 and 1.0. [1.0]
3 FRACTION
FRACTION( ) = _REAL (Read)
   The fractional size of the new picture along each axis,
   applicable for modes other than Array, Cursor, and XY.  Thus
   FRACTION controls the relative shape as well as the size of
   the new picture.  If only a single value is given then it is
   applied to both x and y axes, whereupon the new picture has
   the shape of the reference picture.  So a value of 0.5 would
   create a picture 0.25 the area of the current or BASE picture.
   The default is 0.5, unless parameter ASPECT is not null, when
   the default is 1.0. This parameter is not used if the picture
   size is specified in centimetres using parameter SIZE. []
3 LABELNO
LABELNO = _INTEGER (Read)
   The number used to form the label for the first (bottom-left)
   picture in Array mode.  It cannot be negative. [1]
3 LBOUND
LBOUND( 2 ) = _REAL (Read)
   Co-ordinates of the lower bound that defines the new picture.
   The suggested default is the bottom-left of the current
   picture.  (XY mode)
3 MODE
MODE = LITERAL (Read)
   Method for selecting the new picture. The options are "Cursor"
   for cursor mode (provided the graphics device has one), "XY"
   to select x-y limits, and "Array" to create a grid of
   equal-sized FRAME pictures.  The remainder are locations specified
   by two characters, the first corresponding to the vertical
   position and the second the horizontal.  For the vertical,
   valid positions are T(op), B(ottom), or C(entre); and for the
   horizontal the options are L(eft), R(ight), or C(entre). ["Cursor"]
3 OUTLINE
OUTLINE = _LOGICAL (Read)
   If TRUE, a box that delimits the new picture is drawn. [TRUE]
3 PREFIX
PREFIX = LITERAL (Read)
   The prefix to be given to the labels of picture created in
   Array mode.  It should contain no more than twelve characters.
   If the empty string "" is given, the pictures will have
   enumerated labels.  Note that the database can contain only
   one picture with a given label, and so merely numbering labels
   increases the chance of losing existing labels.  A ! response
   means no labelling is required.  The suggested default is the
   last-used prefix.
3 SIZE
SIZE( 2 ) = _REAL (Read)
   The size of the new picture along both axes, in centimetres,
   applicable for modes other than Array, Cursor, and XY. If a
   single value is given, it is used for both axes. If a null
   value (!) is given, then the size of the picture is determined
   by parameter FRACTION. [!]
3 UBOUND
UBOUND( 2 ) = _REAL (Read)
   Co-ordinates of the upper bound that defines the new picture.
   The suggested default is the top-right of the current picture.
   (XY mode)
3 XPIC
XPIC = _INTEGER (Read)
   The number of new pictures to be formed horizontally in the
   BASE or current picture in Array mode.  The total number of
   new pictures is XPIC * YPIC.    The value must lie in the
   range 1--20.  The suggested default is 2.
3 YPIC
YPIC = _INTEGER (Read)
   The number of new pictures to be formed vertically in the BASE
   or current picture in Array mode.  The value must lie in the
   range 1--20.  The suggested default is the value of parameter
   XPIC.
2 Examples
picdef tr
   Creates a new FRAME picture in the top-right quarter of the
   full display area on the current graphics device, and an
   outline is drawn around the new picture.  This picture becomes
   the current picture.

picdef bl aspect=1.0
   Creates a new FRAME picture within the full display area on
   the current graphics device, and an outline is drawn around
   the new picture.  This picture is the largest square possible,
   and it is justified to the bottom-left corner.  It becomes the
   current picture.

picdef bl size=[15,10]
   Creates a new FRAME picture within the full display area on
   the current graphics device, and an outline is drawn around
   the new picture.  This picture is 15 by 10 centimetres in size
   and it is justified to the bottom-left corner.  It becomes the
   current picture.

picdef cc 0.7 current nooutline
   Creates a new FRAME picture situated in the centre of the
   current picture on the current graphics device.  The new
   picture has the same shape as the current one, but it is
   linearly reduced by a factor of 0.7.  No outline is drawn
   around it.  The new picture becomes the current picture.

picdef cc [0.8,0.5] current nooutline
   As above except that its height is half that of the current
   picture, and its width is 0.8 of the current picture.

picdef cu device=graphon
   Creates a new FRAME picture within the full display area of
   the Graphon device.  The bounds of the new picture are defined
   by cursor interaction.  An outline is drawn around the new
   picture which becomes the current picture.

picdef mode=a prefix=M xpic=3 ypic=2
   Creates six new equally sized and abutting FRAME pictures
   within the full display area of the current graphics device.
   All are outlined.  They have labels M1, M2, M3, M4, M5, and
   M6.  The bottom-left picture (M1) becomes the current picture.

picdef mode=a prefix="" xpic=3 ypic=2 fill=0.8
   As above except that the pictures do not abut since each is
   0.8 times smaller in both dimensions, and the labels are 1,
   2, 3, 4, 5, and 6.
2 Related_Applications
   KAPPA: PICBASE, PICCUR, PICDATA, PICFRAME, PICGRID, PICLABEL,
          PICLIST, PICSEL, PICXY.
2 Authors
MJC: Malcolm J. Currie  (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 1989 April 30 (MJC):
    Original.

 1989 June 26 (MJC):
    Added positional code and fraction.

 1989 July 11 (MJC):
    Reordered code so as to get a zone once the reference picture
    is known to avoid "SGS zone too small" problem, and cursor
    only checked if cursor mode is selected.

 1989 November 10 (MJC):
    Added box option, and commentary for both terminals and image
    displays.

 1990 January 9 (MJC):
    Corrected SGS status.

 1990 January 14 (MJC):
    Added array option.

 1990 April 30 (MJC):
    Improved the cursor mode.

 1990 August 6 (MJC):
    Used parameters for upper and lower bounds rather than x-y
    limits.

 1991 March 19 (MJC):
    Converted to SST prologue.

 1991 April 9 (MJC):
    Added AGI begin-and-end block.

 1992 March 3 (MJC):
    Replaced AIF parameter-system calls by the extended PAR
    library.

 1992 March 24 (MJC):
    Added FILL parameter for Array mode.

 1992 July 30 (MJC):
    Changed parameter CURPIC to CURRENT for consistency.

 1993 August 18 (MJC):
    Added ASPECT parameter, and permitted FRACTION to have
    different values for x and y.

 1994 February 8 (MJC):
    Annulled SGS zone in array mode that prevented large arrays
    from being created.

 1995 August 21 (MJC):
    Made usage and examples lowercase.  Removed DEVICE as a
    positional parameter, and made XPIC and YPIC positional; this
    is to enable PICGRID to operate.  Added Related Applications.

 1995 August 23 (MJC):
    Removed CURRENT as a positional parameter, and made LBOUND and
    UBOUND positional; this is to enable PICXY to operate and to
    allow both PICGRID and PICXY to inherit the CURRENT option.

 21-AUG-1998 (DSB):
    Converted to use PGPLOT. Re-formatted code. Added parameter SIZE.

1 PICEMPTY
Finds the first empty FRAME picture in the graphics database.

Usage:

   picempty [device]

Description:

   This application selects the first, i.e. oldest, empty FRAME
   picture in the graphics database for a graphics device.  Empty
   means that there is no additional picture lying completely with
   its bounds.  This implies that the FRAME is clear for plotting.
   This task is probably most useful for plotting data in a grid of
   FRAME pictures.
2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   The graphics workstation. [The current graphics device]
2 Examples
picempty
   This selects the first empty FRAME picture for the current
   graphics device.

picempty xwindows
   This selects the first empty FRAME picture for the xwindows
   graphics device.
2 Notes
-  An error is returned if there is no empty FRAME picture, and
the current picture remains unchanged.
2 Related_Applications
   KAPPA: PICENTIRE, PICGRID, PICLAST, PICLIST, PICSEL, PICVIS.
2 Timing
   The execution time is approximately proportional to the number of
   pictures in the database before the first empty FRAME picture is
   identified.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1995 October 29 (MJC):
    Original version.

1 PICENTIRE
Finds the first unobscured and unobscuring FRAME picture in the
graphics database.

Usage:

   picentire [device]

Description:

   This application selects the first, i.e. oldest, FRAME picture in
   the graphics database for a graphics device, subject to the
   following criterion.  The picture must not obstruct any other
   picture except the BASE, and must itself not be obstructed.
   Unobstructed means that there is no younger picture overlying it
   either wholly or in part.  This means that plotting can occur
   within the selected FRAME picture without overwriting or
   obscuring earlier plots.
2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   The graphics workstation. [The current graphics device]
2 Examples
picentire
   This selects the first unobscured and unobscuring FRAME
   picture for the current graphics device.

picentire xwindows
   This selects the first unobscured and unobscuring FRAME picture
   for the xwindows graphics device.
2 Notes
-  An error is returned if there is no suitable FRAME picture,
and the current picture remains unchanged.

-  This routine cannot know whether or a picture has been cleared,
and hence is safe to reuse, as such information is not stored in
the graphics database.
2 Related_Applications
   KAPPA: PICEMPTY, PICGRID, PICLAST, PICLIST, PICSEL, PICVIS.
2 Timing
   The execution time is approximately proportional to a linear
   combination of the number of pictures in the database before the
   unobstructed FRAME picture is found, and the square of the number
   of pictures in the database.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1995 October 30 (MJC):
    Original version.

1 PICFRAME
Selects the last FRAME picture from the graphics database.

Usage:

   picframe

Description:

   This command selects the last-created FRAME picture.  Subsequent
   plotting for the chosen device will be in this new current
   picture.  By default the chosen device is the current one.

   This command is a synonym for "piclist name=frame picnum=last".

2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   The graphics workstation. [The current graphics device]
2 Examples
picframe
   This selects the last FRAME picture for the current graphics
   device.

picframe device=xw
   This selects the last FRAME picture for the xw device.
2 Related_Applications
   KAPPA: PICBASE, PICCUR, PICDATA, PICLAST, PICLIST, PICSEL.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1995 August 23 (MJC):
    Original version.


1 PICGRID
Creates an array of FRAME pictures

Usage:

   picgrid xpic ypic

Description:

   This command creates a two-dimensional grid of equally sized
   new FRAME pictures in the graphics database.  The array of
   pictures do not have to abut, but abutting is the default.  The
   new pictures are formed within either the current or BASE
   picture, and they adopt the world co-ordinate system of that
   enclosing picture.  On completion, the bottom-left picture in the
   array becomes the current picture.

   For easy reference in later processing the pictures have integer
   labels.  The numbering starts at a defined value, usually one,
   and increments by one for each new picture starting from the
   bottom-left corner and moving from left to right to the end of
   the line.  This is repeated in each line until the top-right
   picture.

   This command is a synonym for "picdef array 1.0 false prefix="".
2 Parameters
For information on individual parameters, select from the list below:
3 CURRENT
CURRENT = _LOGICAL (Read)
   TRUE if the new pictures are to lie within the current picture,
   otherwise the new pictures can lie anywhere within the BASE
   picture.  In other words, when CURRENT is TRUE the current picture
   is the reference picture, and when it is FALSE the BASE is the
   reference picture. [FALSE]
3 DEVICE
DEVICE = DEVICE (Read)
   The graphics device. [Current graphics device]
3 FILL
FILL = _REAL (Read)
   The linear filling factor for the array.  In other words the
   fractional size (applied to both co-ordinates) of the new
   picture within each of the XPIC * YPIC abutted sections of
   the picture being sub-divided.  Each new picture is located
   centrally within the section.  A filling factor of 1.0 means
   that the pictures in the array abut.  Smaller factors permit a
   gap between the pictures.  For example, FILL = 0.9 would give
   a gap between the created pictures of 10 per cent of the
   height and width of each picture, with exterior borders of 5
   per cent.  FILL must lie between 0.1 and 1.0. [1.0]
3 LABELNO
LABELNO = _INTEGER (Read)
   The number used to form the label for the first (bottom-left)
   picture.  It cannot be negative. [1]
3 OUTLINE
OUTLINE = _LOGICAL (Read)
   If TRUE, a box that delimits the new picture is drawn. [TRUE]
3 XPIC
XPIC = _INTEGER (Read)
   The number of new pictures to be formed horizontally in the
   BASE picture.  The total number of new pictures is XPIC * YPIC.
   The value must lie in the range 1--20.  The suggested default is 2.
3 YPIC
YPIC = _INTEGER (Read)
   The number of new pictures to be formed vertically in the
   BASE picture.  The total number of new pictures is XPIC * YPIC.
   The value must lie in the range 1--20.  The suggested default is 2.
   The suggested default is the value of parameter XPIC.
2 Examples
picgrid 3 2
   Creates six new equally sized and abutting FRAME pictures within
   the full display area of the current graphics device.  All the
   pictures are outlined.  They have labels 1, 2, 3, 4, 5, and 6.
   The bottom-left picture (1) becomes the current picture.

picgrid xpic=3 ypic=2 fill=0.8 labelno=11 nooutline
   As above except that the pictures do not abut since each is
   0.8 times smaller in both dimensions, the labels are 11 to
   16, and there are no picture outlines drawn.

picgrid device=xw current \
   This creates a 2-by-2 grid of new FRAME pictures within the
   current picture on device xw.
2 Related_Applications
   KAPPA: PICCUR, PICDEF, PICGRID, PICSEL.
2 Authors
MJC: Malcolm J. Currie  (STARLINK)
2 History
 1995 August 23 (MJC):
    Original version.

1 PICIN
Finds the attributes of a picture interior to the current picture.

Usage:

   picin [name] [device] [frame]

Description:

   This application finds the attributes of a picture, selected by
   name, that was created since the current picture and lies within
   the bounds of the current picture.  The search starts from the
   most-recent picture, unless the current picture is included,
   whereupon the current picture is tested first.

   The attributes reported are the name, comment, label, name of the
   reference data object, the bounds in the co-ordinate Frame selected
   by parameter FRAME.
2 Parameters
For information on individual parameters, select from the list below:
3 COMMENT
COMMENT = LITERAL (Write)
   The comment of the picture.  Up to 132 characters will be written.
3 CURRENT
CURRENT = _LOGICAL (Read)
   If this is {\tt TRUE}, the current picture is compared against the
   chosen name before searching from the most-recent picture
   within the current picture. [FALSE]
3 DEVICE
DEVICE = DEVICE (Read)
   Name of the graphics device about which information is
   required. [Current graphics device]
3 DOMAIN
DOMAIN = LITERAL (Write)
   The Domain name of the current co-ordinate Frame for the picture.
3 EPOCH
EPOCH = _DOUBLE (Read)
   If a "Sky Co-ordinate System" specification is supplied (using
   parameter FRAME) for a celestial co-ordinate system, then an
   epoch value is needed to qualify it. This is the epoch at
   which the displayed sky co-ordinates were determined. It should
   be given as a decimal years value, with or without decimal places
   ("1996.8" for example). Such values are interpreted as a Besselian
   epoch if less than 1984.0 and as a Julian epoch otherwise.
3 FRAME
FRAME = LITERAL (Read)
   A string determining the co-ordinate Frame in which the bounds
   of the picture are to be reported. When a picture is
   created by an application such as PICDEF, DISPLAY, etc, WCS
   information describing the available co-ordinate systems are stored
   with the picture in the graphics database. This application can
   report bounds in any of the co-ordinate Frames stored with the
   current picture. The string supplied for FRAME can be one of the
   following:

   - A domain name such as SKY, AXIS, PIXEL, BASEPIC, CURPIC, etc. The
   special domain AGI_WORLD is used to refer to the world co-ordinate
   system stored in the AGI graphics database. This can be useful if
   no WCS information was store with the picture when it was created.

   - An integer value giving the index of the required Frame.

   - A "Sky Co-ordinate System" (SCS) value such as EQUAT(J2000) (see
   section "Sky Co-ordinate Systems" in SUN/95).

   If a null value (!) is supplied, bounds are reported in the
   co-ordinate Frame which was current when the picture was created.
   [!]
3 LABEL
LABEL = LITERAL (Write)
   The label of the picture.  It is blank if there is no label.
3 NAME
NAME = LITERAL (Read)
   The name of the picture to be found within the current picture.
   If it is null (!), the first interior picture is selected.
   ["DATA"]
3 PNAME
PNAME = LITERAL (Write)
   The name of the picture.
3 REFNAM
REFNAM = LITERAL (Write)
   The reference object associated with the picture.  It is blank if
   there is no reference object.  Up to 132 characters will be written.
3 REPORT
REPORT = _LOGICAL (Read)
   If this is FALSE details of the picture are not reported, merely the
   results are written to the output parameters.  It is intended for
   use within procedures. [TRUE]
3 X1
X1 = LITERAL (Write)
   The lowest value found within the  picture for axis 1 of the
   requested co-ordinate Frame (see parameter FRAME).
3 X2
X2 = LITERAL (Write)
   The highest value found within the  picture for axis 1 of the
   requested co-ordinate Frame (see parameter FRAME).
3 Y1
Y1 = LITERAL (Write)
   The lowest value found within the  picture for axis 2 of the
   requested co-ordinate Frame (see parameter FRAME).
3 Y2
Y2 = LITERAL (Write)
   The highest value found within the  picture for axis 2 of the
   requested co-ordinate Frame (see parameter FRAME).
2 Examples
picin
   This reports the attributes of the last DATA picture within
   the current picture for the current graphics device. The bounds
   of the picture in its current co-ordinate Frame are reported.

picin frame=pixel
   As above but the bounds of the picture in the PIXEL Frame are
   reported.

picin refnam=(object) current
   This reports the attributes of the last data picture within
   the current picture for the current graphics device.  If there
   is a reference data object, its name is written to the ICL
   variable OBJECT.  The search includes the current picture.

picin x1=(x1) x2=(x2) y1=(y1) y2=(y2)
   This reports the attributes of the last DATA picture within
   the current picture for the current graphics device.  The
   bounds of the current picture are written to the ICL
   variables: X1, X2, Y1, Y2.
2 Notes
This application is intended for use within procedures.  Also if
a DATA picture is selected and the current picture is included in
the search, this application informs about the same picture that
an application that works in a cursor interaction mode would
select, and so acts as a check that the correct picture will be
accessed.
2 Related_Applications
   KAPPA: GDSTATE, PICDEF, PICLIST, PICTRANS, PICXY.
2 Authors
MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 1991 August 20 (MJC):
    Original version.

 1993 August 19 (MJC):
    Added raster co-ordinates.

 24-SEP-2001 (DSB):
    Converted to AST/PGPLOT.
1 PICLABEL
Labels the current graphics-database picture.

Usage:

   piclabel label [device]

Description:

   This application annotates the current graphics-database picture
   of a specified device with a label you define.  This provides an
   easy-to-remember handle for selecting pictures in subsequent
   processing.
2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   The graphics device. [Current graphics device]
3 LABEL
LABEL = LITERAL (Read)
   The label to be given to the current picture.  It is limited
   to 15 characters, but may be in mixed case.  If it is null (!)
   a blank label is inserted in the database.
2 Examples
piclabel GALAXY
   This makes the current picture of the current graphics device
   have a label of "GALAXY".

piclabel A3 xwindows
   This labels the current xwindows picture "A3".
2 Notes
The label must be unique for the chosen device.  If the new label
clashes with an existing one, then the existing label is deleted.
2 Related_Applications
   KAPPA: PICDEF, PICLIST, PICSEL.
2 Authors
MJC: Malcolm J. Currie  (STARLINK)
2 History
 1990 Jan 12 (MJC):
    Original.

 1991 March 19 (MJC):
    Converted to the SST prologue.

 1991 April 9 (MJC):
    Added AGI begin-and-end block.

1 PICLAST
Selects the last picture from the graphics datalast.

Usage:

   piclast

Description:

   This command selects the last-created picture.  Subsequent plotting
   for the chosen device will be in this new current picture.
   By default the chosen device is the current one.

   This command is a synonym for "piclist picnum=1".

2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   The graphics workstation. [The current graphics device]
2 Examples
piclast
   This selects the last picture for the current graphics device.

piclast device=x2w
   This selects the last picture for the x2w device.
2 Related_Applications
   KAPPA: PICBASE, PICCUR, PICDATA, PICFRAME, PICLIST, PICSEL.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1995 August 23 (MJC):
    Original version.

1 PICLIST
Lists the pictures in the graphics database for a device.

Usage:

   piclist [name] [logfile] [device] picnum=?

Description:

   This application produces a summary of the contents of the
   graphics database for a graphics device, and/or permits a picture
   specified by its order in the list to be made the new current
   picture.  The list may either be reported or written to a text
   file.

   The headed list has one line per picture.  Each line comprises
   a reference number; the picture's name, comment (up to 24
   characters), and label; and a flag to indicate whether or not
   there is a reference data object associated with the picture.  A
   `C' in the first column indicates that the picture that was
   current when this application was invoked.  In the text file,
   because there is more room, the name of the reference object is
   given (up to 64 characters) instead of the reference flag.
   Pictures are listed in chronological order of their creation.
2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   The graphics workstation. [The current graphics device]
3 LOGFILE
LOGFILE = FILENAME (Write)
   The name of the text file in which the list of pictures will
   be made.  A null string (!) means the list will be reported
   to you.  The suggested default is the current value. [!]
3 NAME
NAME = LITERAL (Read)
   Only pictures of this name are to be selected.  A null string
   (!) or blanks means that pictures of all names may be selected.
   [!]
3 PICNUM
PICNUM = LITERAL (Read)
   The reference number of the picture to be made the current
   picture when the application exits.  PICNUM="Last" selects the
   last picture in the database.  Parameter PICNUM is not accessed
   if the list is written to the text file.  A null (!) or any
   other error causes the current picture on entry to be current
   again on exit.  The suggested default is null.
2 Examples
piclist
   This reports all the pictures in the graphics database for the
   current graphics device.

piclist device=ps_l
   This reports all the pictures in the graphics database for the
   ps_l device.

piclist data
   This reports all the DATA pictures in the graphics database for
   the current graphics device.

piclist data logfile=datapic.dat
   This lists all the DATA pictures in the graphics database for
   the current graphics device into the text file datapic.dat.

piclist frame picnum=5
   This selects the fifth most ancient FRAME picture (in the
   graphics database for the current graphics device) as the
   current picture.  The pictures are not listed.

piclist picnum=last
   This makes the last picture in the graphics database for the
   current graphics device current.  The pictures are not listed.
2 Notes
-  The list is not reported to the user when PICNUM is specified
on the command line.  This feature is useful where a procedure
just wants to select a new current picture (hiding the details
from the user).  A new current picture cannot be selected with
text-file output, and so the presence of PICNUM on the command
line does not affect writing to a text file.
2 Related_Applications
   KAPPA: PICBASE, PICDATA, PICEMPTY, PICENTIRE, PICFRAME, PICIN,
   PICLAST, PICSEL, PICVIS.
2 Timing
   The execution time is approximately proportional to the number of
   pictures in the database for the chosen graphics device.
   Selecting only a subset by name is slightly faster.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1991 July 24 (MJC):
    Original version.

 1992 January 29 (MJC):
    Correctly Handles the case when there are no pictures of the
    given name in the database.

 1992 March 3 (MJC):
    Replaced AIF parameter-system calls by the extended PAR
    library.

 1992 December 2 (MJC):
    Added the current-picture indicator.

 1993 August 18 (MJC):
    Prevented reporting of the list when PICNUM is on the command
    line, and allowed PICNUM to select the last picture.

 1995 January 13 (MJC):
    Made examples and usage lowercase.
2 Implementation_Status
   -  Assumes that there are no more than 9999 pictures in the
   database.

1 PICSEL
Selects a graphics-database picture by its label.

Usage:

   picsel label [device]

Description:

   This application selects by label a graphics-database picture of a
   specified device.  If such a picture is found then it becomes the
   current picture on exit, otherwise the input picture remains
   current.  Labels in the database are stored in the case supplied
   when they were created.  However, the comparisons of the label you
   supply with the labels in the database are made in uppercase, and
   leading spaces are ignored.

   Should the label not be found the current picture is unchanged.
2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   The graphics device. [Current graphics device]
3 LABEL
LABEL = LITERAL (Read)
   The label of the picture to be selected.
2 Examples
picsel GALAXY
   This makes the picture labelled "GALAXY" the current picture on
   the current graphics device.  Should there be no picture of
   this name, the current picture is unchanged.

picsel A3 xwindows
   This makes the picture labelled "A3" the current picture on the
   xwindows device.  Should there be no picture of this name, the
   current picture is unchanged.
2 Authors
MJC: Malcolm J. Currie  (STARLINK)
2 History
 1990 Jan 14 (MJC):
    Original.

 1990 Apr 12 (MJC):
    Bug fix so that the last picture's label is tested, and
    improved the closedown operation when there is no match with
    the label.

 1991 February 12 (MJC):
    Annulled pictures to enable an unlimited number of pictures
    to be searched.

 1991 March 19 (MJC):
    Converted to the SST prologue.

 1991 April 9 (MJC):
    Added AGI begin-and-end block.

1 PICTRANS
Transform a graphics position from one picture co-ordinate Frame to
another.

Usage:

   pictrans posin framein [frameout] [device]

Description:

   This application transforms a position on a graphics device from one
   co-ordinate Frame to another. The input and output Frames may be chosen
   freely from the Frames available in the WCS information stored with
   the current picture in the AGI graphics database. The transformed
   position is formatted for display and written to the screen and
   also to an output parameter.
2 Parameters
For information on individual parameters, select from the list below:
3 BOUND
BOUND = _LOGICAL (Write)
   BOUND is TRUE when the supplied point lies within the bounds of
   the current picture.
3 DEVICE
DEVICE = DEVICE (Read)
   The graphics workstation. [The current graphics device]
3 EPOCHIN
EPOCHIN = _DOUBLE (Read)
   If a "Sky Co-ordinate System" specification is supplied (using
   parameter FRAMEIN) for a celestial co-ordinate system, then an epoch
   value is needed to qualify it. This is the epoch at which the
   supplied sky position was determined. It should be given as a
   decimal years value, with or without decimal places  ("1996.8" for
   example). Such values are interpreted as a Besselian epoch if less
   than 1984.0 and as a Julian epoch otherwise.
3 EPOCHOUT
EPOCHOUT = _DOUBLE (Read)
   If a "Sky Co-ordinate System" specification is supplied (using
   parameter FRAMEOUT) for a celestial co-ordinate system, then an epoch
   value is needed to qualify it. This is the epoch at which the
   transformed sky position is required. It should be given as a
   decimal years value, with or without decimal places  ("1996.8" for
   example). Such values are interpreted as a Besselian epoch if less
   than 1984.0 and as a Julian epoch otherwise.
3 FRAMEIN
FRAMEIN = LITERAL (Read)
   A string specifying the co-ordinate Frame in which the input
   position is supplied (see parameter POSIN). The string can be
   one of the following:

   - A domain name such as SKY, AXIS, PIXEL, GRAPHICS, CURPIC,
   BASEPIC, etc.

   - An integer value giving the index of the required Frame within
   the WCS component.

   - A "Sky Co-ordinate System" (SCS) value such as EQUAT(J2000) (see
   section "Sky Co-ordinate Systems" in SUN/95).

   If a null parameter value is supplied, then the current Frame in
   the current picture is used. [!]
3 FRAMEOUT
FRAMEOUT = LITERAL (Read)
   A string specifying the co-ordinate Frame in which the transformed
   position is required. If a null parameter value is supplied, then
   the current Frame in the picture is used. The string can be one of the
   following:

   - A domain name such as SKY, AXIS, PIXEL, GRAPHICS, CURPIC,
   BASEPIC, etc.

   - An integer value giving the index of the required Frame within
   the WCS component.

   - A "Sky Co-ordinate System" (SCS) value such as EQUAT(J2000) (see
   section "Sky Co-ordinate Systems" in SUN/95).

   If a null parameter value is supplied, then the BASEPIC Frame is
   used. ["BASEPIC"]
3 POSIN
POSIN = LITERAL (Read)
   The co-ordinates of the position to be transformed, in the
   co-ordinate Frame specified by parameter FRAMEIN (supplying
   a colon ":" will display details of the required co-ordinate Frame).
   The position should be supplied as a list of formatted axis values
   separated by spaces or commas.
3 POSOUT
POSOUT = LITERAL (Write)
   The formatted co-ordinates of the transformed position, in the
   co-ordinate Frame specified by parameter FRAMEOUT. The position
   will be stored as a list of formatted axis values separated by
   spaces.
3 QUIET
QUIET = _LOGICAL (Read)
   If TRUE, the transformed position is not written to the screen
   (it is still written to the output parameter OUTPOS). [FALSE]
2 Examples
pictrans "100.3,-20.1" framein=pixel
   This converts the position (100.3,-20.1), in pixel co-ordinates
   within the current picture of the current graphics device, to the
   BASEPIC co-ordinates of that point in the BASE picture.

pictrans "100.3,-20.1" framein=pixel frameout=graphics
   This converts the position (100.3,-20.1), in pixel co-ordinates
   within the current picture of the current graphics device, to the
   GRAPHICS co-ordinates of that point (i.e. millimetres from the
   bottom left corner of the graphics device).

pictrans "10 10" framein=graphics frameout=basepic
   This converts the position (10 10), in graphics co-ordinates
   (i.e. the point which is 10mm above and to the right of the
   lower left corner of the graphics device), into BASEPIC
   co-ordinates.

Notes:
   -  BASEPIC co-ordinates locate a position within the entire graphics
   device. The bottom left corner of the device screen has BASEPIC
   co-ordinates of (0,0). The shorter dimension of the screen has
   length 1.0, and the other axis has a length greater than 1.0.

   -  GRAPHICS co-ordinates also span the entire graphics device but
   are measured in millimetres from the bottom left corner.

   -  CURPIC co-ordinates locate a point within the current picture. The
   bottom left corner of the current picture has CURPIC co-ordinates of
   (0,0). The shorter dimension of the current picture has length 1.0, and
   the other axis has a length greater than 1.0.
2 Related_Applications
   KAPPA: GDSTATE, PICIN, PICXY.
2 Authors
MJC: Malcolm J. Currie (STARLINK)

DSB: David Berry (STARLINK)
2 History
 1993 August 19 (MJC):
    Original version.

 24-SEP-2001 (DSB):
    Converted to AST/PGPLOT.
1 PICVIS
Finds the first unobscured FRAME picture in the graphics database.

Usage:

   picvis [device]

Description:

   This application selects the first, i.e. oldest, unobstructed
   FRAME picture in the graphics database for a graphics device.
   Unobstructed means that there is no younger picture overlying it
   either wholly or in part.
2 Parameters
For information on individual parameters, select from the list below:
3 DEVICE
DEVICE = DEVICE (Read)
   The graphics workstation. [The current graphics device]
2 Examples
picvis
   This selects the first unobscured FRAME picture for the
   current graphics device.

picvis xwindows
   This selects the first unobscured FRAME picture for the
   xwindows graphics device.
2 Notes
-  An error is returned if there is no unobscured FRAME picture,
and the current picture remains unchanged.

-  This routine cannot know whether or a picture has been cleared,
and hence is safe to reuse, as such information is not stored in
the graphics database.
2 Related_Applications
   KAPPA: PICEMPTY, PICENTIRE, PICGRID, PICLAST, PICLIST, PICSEL.
2 Timing
   The execution time is approximately proportional to a linear
   combination of the number of pictures in the database before the
   unobstructed FRAME picture is found, and the square of the number
   of pictures in the database.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1995 October 29 (MJC):
    Original version.

1 PICXY
   Creates a new FRAME picture defined by co-ordinate bounds

Usage:

   picxy lbound ubound

Description:

   This command creates a new FRAME picture in the graphics database.
   The bounds of the new picture are defined through two parameters.
   The new picture is formed within either the current or BASE
   picture, and it adopts the world co-ordinate system of that
   reference picture.  On completion the new picture becomes the
   current picture.

   This command is a synonym for picdef xy 1.0.

2 Parameters
For information on individual parameters, select from the list below:
3 CURRENT
CURRENT = _LOGICAL (Read)
   TRUE if the new pictures are to lie within the current picture,
   otherwise the new pictures can lie anywhere within the BASE
   picture.  In other words, when CURRENT is TRUE the current picture
   is the reference picture, and when it is FALSE the base is the
   reference picture. [FALSE]
3 DEVICE
DEVICE = DEVICE (Read)
   The graphics device. [Current graphics device]
3 LBOUND
LBOUND( 2 ) = _REAL (Read)
   Co-ordinates of the lower bound that defines the new picture.
   The suggested default is the bottom-left of the current picture.
3 OUTLINE
OUTLINE = _LOGICAL (Read)
   If TRUE, a box that delimits the new picture is drawn. [TRUE]
3 UBOUND
UBOUND( 2 ) = _REAL (Read)
   Co-ordinates of the upper bound that defines the new picture.
   The suggested default is the top-right of the current picture.
2 Examples
picxy [0.1,0.2] [0.9,0.6]
   This creates a new FRAME picture in the base picture extending
   from (0.1,0.2) to (0.9,0.6), which becomes the new current
   picture.  An outline is drawn around the picture.

picxy ubound=[1.1,0.9] lbound=[0.1,0.2] current nooutline
   This creates a new FRAME picture in the current picture
   extending from (0.1,0.2) to (1.1,0.9), which becomes the new
   current picture.  No outline is drawn.

2 Related_Applications
   KAPPA: PICCUR, PICDEF, PICSEL.
2 Authors
MJC: Malcolm J. Currie  (STARLINK)
2 History
 1995 August 23 (MJC):
    Original version.

1 PIXDUPE
Expands an NDF by pixel duplication.

Usage:

   pixdupe in out expand

Description:

   This routine expands the size of an NDF structure by duplicating
   each input pixel a specified number of times along each
   dimension, to create a new NDF structure.
2 Parameters
For information on individual parameters, select from the list below:
3 EXPAND
EXPAND() = _INTEGER (Read)
   Linear expansion factors to be used to create the new data
   array.  The number of factors should equal the number of
   dimensions in the input NDF.  If fewer are supplied the last
   value in the list of expansion factors is given to the
   remaining dimensions.  Thus if a uniform expansion is required
   in all dimensions, just one value need be entered.  If the net
   expansion is one, an error results.  The suggested default is
   the current value.
3 IN
IN  = NDF (Read)
   Input NDF structure to be expanded.
3 OUT
OUT = NDF (Write)
   Output NDF structure.
3 TITLE
TITLE = LITERAL (Read)
   Title for the output NDF structure.  A null value (!)
   propagates the title from the input NDF to the output NDF. [!]
2 Examples
pixdupe aa bb 2
   This expands the NDF called aa duplicating pixels along each
   dimension, and stores the enlarged data in the NDF called bb.
   Thus if aa is 2-dimensional, this command would result in a
   four-fold increase in the array components.

pixdupe cosmos galaxy [2,1]
   This expands the NDF called cosmos by duplicating along the
   first axis, and stores the enlarged data in the NDF called
   galaxy.

pixdupe cube1 cube2 [3,1,2]  title="Reconfigured cube"
   This expands the NDF called cube1 by having three pixels for
   each pixel along the first axis and duplicating along the
   third axis, and stores the enlarged data in the NDF called
   cube2.  The title of cube2 is "Reconfigured cube".
2 Related_Applications
   KAPPA: COMPADD, COMPAVE, COMPICK.
2 Authors
MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 1995 April 28 (MJC):
    Original NDF version.

 11-JUN-1998 (DSB):
    Added propagation of the NDF WCS component.

 {enter_any_changes_here
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   VARIANCE, LABEL, TITLE, UNITS, and HISTORY, components of an NDF
   data structure and propagates all extensions.  Origin information
   becomes undefined by the duplication and so is not propagated.

   -  All non-complex numeric data types can be handled.

   -  Any number of NDF dimensions is supported.

1 POW
    Takes the specified power of each pixel of a data array
 
   This routine takes the specified power of each pixel of the
   data array in the input IMAGE structure. The result goes into a
   new output array, also in an IMAGE structure.
 
   The magic-value method is used for processing bad data.  Output
   pixels become bad if the result raising to the specified power is
   undefined or out of range.  Negative pixel values will only
   generate good output pixels when the power is an even integer.
2 AUTHORS
   Mark McCaughrean UoE ( REVA::MJM )
   Malcolm Currie  STARLINK (RAL::CUR)
2 BUGS
   None known.
2 HISTORY
   03-07-1986 : First implementation (REVA::MJM)
   1986 Aug 7 : Renamed algorithm subroutine (POWARR), changed new
                2nd argument to total number of pixels (RAL::CUR).
   1986 Aug 29: Add argument section, generalised to vector and
                tidied (RAL::CUR).
   1987 Oct 16: Reordered tidying and used CMP_SHAPE (RAL::CUR)
   1988 Mar 17: Referred to `array' rather than `image'
                (RAL::CUR)
   1988 May 31: More reporting of error context (RAL::CUR)
   1989 Jun 13: Allow for processing primitive NDFs (RAL::CUR)
   1991 Oct 25: Propagates AXIS, LABEL, and HISTORY (RAL::CUR).
   1992 Feb 25: Limited processing of simple NDFs (RAL::CUR).
   1992 Mar  3: Replaced AIF parameter-system calls by the extended
                PAR library (RAL::CUR).
2 PARAMETERS
   INPIC  =  IMAGE( READ )
       Input IMAGE structure containing the data array to be
         processed
   POWER  =  REAL( READ )
       Power to be taken of each input data-array pixel
   OUTPIC  =  IMAGE( WRITE )
       Output IMAGE structure holding result of the processed data
         array
   OTITLE  =  CHAR( READ )
       Title string for the output IMAGE structure
3 INPIC
  position    1
  keyword     'INPIC'
  type        'IMAGE'
  access      'READ'
  vpath       'PROMPT'
  ppath       'GLOBAL'
  association '<-GLOBAL.DATA_ARRAY'
  prompt      'Input image'
  help        'Name of the IMAGE structure containing the input data 
              array'
3 POWER
  position    2
  keyword     'POWER'
  type        '_REAL'
  access      'READ'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC'
  prompt      'Power'
  help        'Power to be taken of each input data-array pixel'
3 OUTPIC
  position    3
  keyword     'OUTPIC'
  type        'IMAGE'
  access      'WRITE'
  vpath       'PROMPT'
  association '->GLOBAL.DATA_ARRAY'
  prompt      'Output image'
  help        'Name given to the IMAGE structure holding the data 
              array resulting from taking power'
3 OTITLE
  position    4
  keyword     'OTITLE'
  type        'LITERAL'
  vpath       'DEFAULT'
  prompt      'Title for output image'
  default     'KAPPA - Pow'
  help        'Character string used as a title for the output IMAGE 
              structure.'

1 Problems_Problems
A detailed list of error codes and their meanings is not available.
KAPPA produces descriptive contextual error messages, which are
usually straightforward to comprehend.  Some of these originate in
the underlying infrastructure software, though there are still some
systems yet to do that.  These are being corrected, and so imprecise
error reports should soon be a thing of the past.  Error messages
from KAPPA begin with the name of the application reporting the
error. The routine may have detected the error, or it has something
to say about the context of the error. 

The sub-topics describe some difficulties you may encounter and how
to hurdle them.  Please suggest additions to this compilation.

2 Unable_to_Obtain_Work_Space
One group of error messages which may puzzle you, mostly because
they are incomplete reads like "Unable to create work array".
Many applications require temporary or work space to perform their
calculations.  This space is stored in an HDS file within directory
$HDS_SCRATCH and most likely is charged to your disc quota.  (If you
have not redefined this environment variable, it will point to your
current directory.)  So one cause for the message is insufficient
disc quota available to store the work space container file or to
extend it.

A second reason for the message is that your computer cannot provide
sufficient virtual memory to map the workspace.  In this case you
can try increasing your process limits using the C-shell built-in
function called limit.  You can find your current limits by entering
limit.  You should see a list something like this.

     cputime         unlimited
     filesize        unlimited
     datasize        131072 kbytes
     stacksize       2048 kbytes
     coredumpsize    unlimited
     memoryuse       89232 kbytes
     vmemoryuse      1048576 kbytes
     descriptors     4096 

The relevant keywords are datasize and the vmemoryuse.  In effect
datasize specifies the maximum total size of data files you can map at
one time in a single programme.  The default should be adequate for
most purposes and only need be modified for those working with large
images or cubes.  The vmemoryuse specifies the maximum virtual memory
you can use.

    % limit datasize 32768

sets the maximum size of mapped data to 32 megabytes.  Values cannot
exceed the system limits.  You can list these with the -h qualifier.

     % limit -h
     cputime         unlimited
     filesize        unlimited
     datasize        1048576 kbytes
     stacksize       32768 kbytes
     coredumpsize    unlimited
     memoryuse       89232 kbytes
     vmemoryuse      1048576 kbytes
     descriptors     4096 

Although you can set your limits to the system maxima, it doesn't
mean that you should just increase your quotas to the limits.  You
might become unpopular with some of your colleagues, especially if
you accidentally try to access a huge amount of memory.  

If you cannot accommodate your large datasets this way, you should
fragment your data array, and process the pieces separately.

After receiving this error message in an ICL session you may need
to delete the scratch file by hand.  The file is called txxx.sdf,
where xxxx is a process identifier.  A normal exit from ICL will
delete the work-space container file.


2 Application_Automatically_pPcks_up_the_Wrong_NDF
Some applications read the name of the NDF used to create a plot or
image from the graphics database in order to save typing.  Rarely,
you'll say "that's not the one I wanted".  This is because AGI
finds the last DATA picture situated within the current picture.
Abort the application via !!, then use PICCUR or PICLIST to select
the required FRAME picture enclosing the DATA picture, or even
select the latter directly.  You can override the AGI NDF also by
specifying the required NDF on the command line, provided it has
pixels whose indices lies within the world co-ordinates of the
DATA picture.  Thus
 
     % inspect myndf
 
will inspect the NDF called myndf.  The command PICIN will show the
last DATA picture and its associated NDF.

2 Unable_to_Store_a_Picture_in_the_Graphics_Database
You may receive an error message, which says failed to store
such-and-such picture in the graphics database.  For some reason the
database was corrupted due to reasons external to KAPPA.  Don't
worry, usually your plot will have appeared, and to fix the problem
run GDCLEAR/IDCLEAR or delete the database file
($AGI_USER/agi_<node>.sdf, where you substitute your system's node
name for <node>).  You will need to redraw the last plot if you
still require it, say for interaction.

2 Line_Graphics_are_Invisible_on_an_Image_Display
The reason for invisible line graphics on your image display is
because it is drawn in black or a dark grey.  Most likely is that
some person has been using other software on your image display or
that is has been reset.  PALDEF will set up the default colours for
the palette, and so most line graphics will then appear in white.
Alternatively,
 
     % palentry 1 white
 
will normally suffice.

2 Error_Obtaining_a_Locator_to_a_Slice_of_an_HDS_array

If the above error appears from DAT_SLICE and you are (re)prompted
for an NDF, the most likely cause is that you have asked an IMAGE
application to process an NDF section.  Use NDFCOPY to make a
subset before running the application in question, or process the
whole NDF.

2 Badly_placed_()'s
This means that you have forgotten to `escape' parentheses, probably
when defining an NDF section.  Try inserting a backslash before each
parenthesis.

     % stats myndf\(100:200,\)

2 Attempt_to_use_'positional'_parameter_value_(x)_in_an_unallocated_position
Check the usage of the application you are running.  One way of
adding positional parameters unintentionally, is to forget to escape
the " from the shell when supplying a string with spaces or
wildcards.  For example, this error would arise if we entered

     % settitle myndf "A title"

instead of say

     % settitle myndf '"A title"'

which protects all special characters between the single quotes.

2 The_choice_x_is_not_in_the_menu.
You have either made an incorrect selection, or you have forgotten
to escape a metacharacter.  For the former, you can select a new
value from the list of valid values presented in the error message.
For the latter, part of another value is being interpreted as a
positional value for the parameter the task is complaining about.

     % linplot $KAPPA_DIR/spectrum pltitl="Red-giant plot"
     !! The choice plot is not in the menu.  The options are
     !     Data,Quality,Error,Variance.
     !  Invalid selection for parameter COMP.

Here it thinks that plot is a positional value.  Escape the " to
cure the problem.

     % linplot $KAPPA_DIR/spectrum pltitl='"Red-giant plot"'

2 I've_Got_This_FITS_Tape

Certain combinations of magnetic tape produced on one model of tape
drive but read on a different model seem to generate parity errors
that are detected by the MAG_ library that FITSIN uses.  However,
this doesn't mean that you won't be able to read your FITS tape.
The UNIX tape-reading commands seem less sensitive to these parity
errors.

Thus you should first attempt to convert the inaccessible FITS files
on tape to disc files using the UNIX dd command, and then use the
FITSDIN application to generate the output NDF or foreign format.
For example to convert a FITS file from device /dev/nrst0 to an NDF
called ndfname, you might enter

     % dd if=/dev/nrst0 ibs=2880 of=file.fits
     % fitsdin files=file.fits out=ndfname
     % rm file.fits

where file.fits is the temporary disc-FITS file.  The 2880 is the
length of a FITS record in bytes.   Repeated dd commands to a
no-rewind tape device (those with the `n' prefix on OSF/1 and the
`n' suffix on Solaris) will copy successive files.  To skip over
files or rewind the tape, use the mt command.  For example,

     % mt -f /dev/rmt/1n fsf 3
           :       :       :
     % mt -f /dev/rmt/1n asf 4

moves the tape on device /dev/rmt/1n forward three files, then moves
to the fourth file on the same device,

     % mt bsf 2

moves back two files on the default tape drive (defined by the
environment variable TAPE), and

     % mt -f /dev/nrmt0h rewind

rewinds to the start of the tape on device /dev/nrmt0h.  Thus it is
possible to write a script for extracting and converting a series of
files including ranges, just like FITSIN does.

If the above approach fails, try another tape drive.

2 FITSIN_does_not_Recognise_my_FITS_Tape

If you attempt to read a FITS magnetic tape with FITSIN, you might
receive an error like this

     % fitsin
     % MT - Tape deck /@/dev/nrmt1h/ > /dev/nrmt3l
     !! Object '/DEV/NRMT3L' not found.
     !  DAT_FIND: Error finding a named component in an HDS structure.
     !  /dev/nrmt3l: MAG__UNKDV, Unable to locate device in DEVDATASET

when you enter the device name.  The magnetic-tape system uses an
\HDSref\ file called the device dataset (DEVDATASET) to store the
position of the tape between invocations of Starlink applications.

When FITSIN is given a name, the magnetic-tape system validates the
name to check that it is a known device.  There should be a
devdataset.sdf file (within /star/etc at Starlink sites)
containing a list of at least all the available drives at your site.
What FITSIN is complaining about above, is that the device you have
given is not included in the DEVDATASET file.  Now this might be
because you mistyped the device name, or that the particular device is
not accessible on the particular machine, or because your computer
manager
has not maintained the DEVDATASET when a drive was added.  You can look
at the contents of the DEVDATASET with this command.

     % hdstrace /star/etc/devdataset

Oh and one other point: make sure the tape is loaded in the drive.
Yes this mistake has happened (not mentioning any names) and it is
very hard to diagnose remotely.

2 It_Used_to_Work... and Weird Errors
There is a class of error that arises when an HDS file is corrupted.
The specific message will depend on the file concerned and where
in the file the corruption occurred.  The most likely reason for
file corruption is breaking into a task at the wrong moment, or
trying to write to a file at the same time.

If you want to process simultaneously from different sessions---say
one interactive and another in batch---it is wise to redefine the
environment variables $ADAM_USER, and $AGI_USER if you want graphics
on the same machine.  The environment variables should point to a
separate existing directory for each additional session.  This will
keep the global and application parameters, and the graphics
database separate for each session. 

The way to look for corrupted HDS files is trace them.  Assuming
that $ADAM_USER and $AGI_USER are defined,

     % hdstrace $ADAM_USER/GLOBALS full
     % hdstrace $ADAM_USER/ardmask full
     % hdstrace $AGI_USER/agi_cacvad full

traces the GLOBALS file, the application you were running when the
weird error occurred (here ARDMASK), and the graphics database for
machine cacvad.  Once you have identified the problem file, delete
it.  If that proves to be the globals file, you might want to retain
the output from HDSTRACE, so that you can restore their former
values.  Deleting the graphics database is something you should do
regularly, so that's not a problem.

If you have been running KAPPA from ICL, you will need to check of
the integrity of the monolith parameter file, instead the
individual parameter file.  It will be one of these depending on
the type of task that failed: graphics, NDF components, or the
rest (mostly image processing) corresponding to these three
monolith interface files.

     % hdstrace $ADAM_USER/kapview_mon full
     % hdstrace $ADAM_USER/ndfpack_mon full
     % hdstrace $ADAM_USER/kappa_mon full


If that doesn't cure the problem, send a log of the session
demonstrating the problem to the Starlink Software Librarian
ussc@star.rl.ac.uk, and we shall endeavour to interpret it for
you and find out what's going wrong.

1 Procedures

Applications from KAPPA and other packages can be combined in
procedures and scripts to customise and automate data processing.
In addition to giving literal values to application parameters, you
can include ICL or C-shell variables on the command line, whose
values are substituted at run time.  It is also possible to write
parameter data into variables, and hence pass them to another
application, or use the variables to control subsequent processing.

2 C-shell_scripts

The "C-shell Cookbook" (SC/4) contains many ingredients and recipes,
and features many KAPPA commands.  So there is little point
repeating them here other than to direct you to a documented script
in $KAPPA_DIR/multiplot.csh.
 
2 ICL_Procedures

You should consult the "ICL Users' Guide" (SG/5) for details
about writing ICL syntax, procedures, and functions, but you're
a busy researcher...   For a quick overview the *two-page* summary
on "Writing ICL command files and procedures" in SUN/101 is
recommended reading, even though much of the document is dated and
still refers to VMS.  Here we'll just show some example procedures
that can be adapted and cover points not mentioned in SUN/101.

Let's start with something simple.  You want to `flash' a series of
images, each with a yellow border.  First you write the following
procedure called FLASH.  It has one argument INPIC, that passes the
name of the NDF you want to display.  When you substitute an ICL
variable for a parameter value you enclose it in parentheses.  The
lines beginning with { are comments.

     PROC FLASH INPIC
     {
     { Procedure for displaying an image without scaling and a
     { yellow border.
     {
        DISPLAY IN=(INPIC) MODE=FL BORDER BCOLOUR=Yellow
     END PROC

To make ICL recognise your procedure you must `load' it.  The command

     ICL> LOAD FLASH

will load the file FLASH.ICL.  Thereafter in the ICL session you can
invoke FLASH for many NDFs.  The following will display the NDFs
called GORDON and FLOOD side-by-side.

     ICL> PICGRID 2 1 
     ICL> FLASH GORDON
     ICL> PICSEL 2
     ICL> FLASH FLOOD

It would be tedious to have to load lots of individual procedures,
but you don't.  If you have related procedures that you regularly
require they can be concatenated into a single file which you load.
Better still is to add definitions for each of the procedures in
your ICL login file.  This is defined as the value of the ICL_LOGIN
environment variable.  A reasonable place is in your home directory
and you'd define it like this.

     % setenv ICL_LOGIN $HOME/login.icl

However, the file doesn't have to be in your home directory, or
called login.icl, but it's convenient to do so.  Suppose you have
three procedures: FLASH, PICGREY in file $MY_DIR/display_proc.icl,
and FILTER in /home/user1/dro/improc.icl.  In your $HOME/login.icl
you could add the following

     defproc  flash     $MY_DIR/display_proc.icl
     defproc  sfilt     $HOME/user1/dro/improc.icl filter
     defproc  picgr(ey) $MY_DIR/display_proc.icl

which defines three commands that will be available each time you
use ICL: FLASH which will run your FLASH procedure, PICGREY to
execute the PICGREY procedure, and SFILT which runs the FILTER
procedure.  In addition PICGREY can be abbreviated to PICGR or
PICGRE.  So now you can load and run your procedure.

Let's have some more example procedures.  Suppose you have a series
of commands to run on a number of files.  You could create a
procedure to perform all the stages of the processing, deleting the
intermediate files that it creates.

     PROC UNSHARPMASK NDFIN CLIP NDFOUT

     { Insert ampersands to tell the command-line interpreter than
     { these strings are file names.
        IF SUBSTR( NDFIN, 1, 1 ) <> '@'
           NDFIN = '@' & (NDFIN)
        END IF
        IF SUBSTR( JUNK, 1, 1 ) <> '@'
           NDFOUT = '@' & (NDFOUT)
        END IF

     { Clip the image to remove the cores of stars and galaxies
     { above a nominated threshold.
        THRESH (NDFIN) TMP1 THRHI=(CLIP) NEWHI=(CLIP) \

     { Apply a couple of block smoothings with boxsizes of 5 and 13
     { pixels.  Delete the temporary files as we go along.
        BLOCK tmp1 tmp2 BOX=5
        ! rm tmp1.sdf
        BLOCK tmp2 tmp3 BOX=13
        ! rm tmp2.sdf

     { Multiply the smoothed image by a scalar.
        CMULT tmp3 0.8 tmp4
        ! rm tmp3.sdf

     { Subtract the smoothed and renormalised image from the input
     { image.   The effect is to highlight the fine detail, but
     { still retain some of the low-frequency features.
        SUB (NDFIN) tmp4 (NDFOUT)
        ! rm tmp4.sdf
     END PROC

There is a piece of syntax to note which often catches people out.
Filenames, data objects, and devices passed via ICL variables
to applications, such as NDFIN and NDFOUT in the above example,
must be preceded by an @.

A common use of procedures is likely to be to duplicate processing
for several files.  Here is an example procedure that does that.
It uses some intrinsic functions which look just like Fortran.

     PROC MULTISTAT

     { Prompt for the number of NDFs to analyse.  Ensure that it
     { is positive.
        INPUTI Number of frames:  (NUM)
        NUM = MAX( 1, NUM )

     { Find the number of characters required to format the number
     { as a string using a couple of ICL functions.
        NC = INT( LOG10( I ) ) + 1

     { Loop NUM times.
        LOOP FOR I=1 TO (NUM)

     { Generate the name of the NDF to be analysed via the ICL
     { function SNAME.
          FILE = '@' & SNAME('REDX',I,NC)

     { Form the statistics of the image.
          STATS NDF=(FILE)
        END LOOP
     END PROC

If NUM is set to 10, the above procedure obtains the statistics of
the images named REDX1, REDX2, ... REDX10.  The ICL variable FILE
is in parentheses because its value is to be substituted into
parameter NDF. 

Here is another example, which could be used to flat field a series
of CCD frames.  Instead of executing a specific number of files, you
can enter an arbitrary sequence of NDFs.  When processing is
completed a !! is entered rather than an NDF name, and that exits
the loop.  Note the ~ continuation character (it's not required but
it's included for pedagogical reasons).

     PROC FLATFIELD

     { Obtain the name of the flat-field NDF.  If it does not have
     { a leading @ insert one.
        INPUT "Which flat field frame?: " (FF)
        IF SUBSTR( FF, 1, 1 ) <> '@'
           FF = '@' & (FF)
        END IF

     { Loop until there are no further NDFs to flat field.
        MOREDATA = TRUE
        LOOP WHILE MOREDATA

     { Obtain the frame to flat field.  Assume that it will not have
     { an @ prefix.  Generate a title for the flattened frame.
           INPUT "Enter frame to flat field (!! to exit): " (IMAGE)
           MOREDATA = IMAGE <> '!!'
           IF MOREDATA
              TITLE = 'Flat field of ' & (IMAGE)
              IMAGE = '@' & (IMAGE)

     { Generate the name of the flattened NDF.
              IMAGEOUT = (IMAGE) & 'F'
              PRINT Writing to (IMAGEOUT) 

     { Divide the image by the flat field.
              DIV IN1=(IMAGE) IN2=(FF) OUT=(IMAGEOUT) ~
                TITLE=(TITLE)
           END IF
        END LOOP
     END PROC


Some KAPPA applications, particularly the statistical ones, produce
output parameters which can be passed between applications via ICL
variables.  Here is an example to draw a contour plot centred about
a star in a nominated data array from only the star's approximate
position.  The region about the star is stored in an output NDF file.
Note the syntax required to define the value of parameter INIT; the
space between the left bracket and parenthesis is essential.

     PROC COLSTAR FILE,X,Y,SIZE,OUTFILE

     {+
     {  Arguments:
     {     FILE = FILENAME (Given)
     {        Input NDF containing one or more star images.
     {     X = REAL (Given)
     {        The approximate x position of the star.
     {     Y = REAL (Given)
     {        The approximate y position of the star.
     {     SIZE = REAL (Given)
     {        The half-width of the region about the star's centroid to be
     {        plotted and saved in the output file.
     {     OUTFILE = FILENAME (Given)
     {        Output primitive NDF of 2*%SIZE+1 pixels square (unless
     {        constrained by the size of the data array or because the
     {        location of the star is near an edge of the data array.
     {-

     { Ensure that the filenames have the @ prefix.
        IF SUBSTR( FILE, 1, 1 ) <> '@'
           NDF = '@' & (FILE)
        ELSE
           NDF = (FILE)
        END IF
        IF SUBSTR( OUTFILE, 1, 1 ) <> '@'
           NDFOUT = '@' & (OUTFILE)
        ELSE
           NDFOUT = (OUTFILE)
        END IF

     { Search for the star in a 21x21 pixel box.  The centroid of the
     { star is stored in the ICL variables XC and YC.
        CENTROID NDF=(NDF) INIT=[ (X&','&Y)] XCEN=(XC) YCEN=(YC) ~
          MODE=INTERFACE SEARCH=21 MAXSHIFT=14

     { Convert the co-ordinates to pixel indices.
        IX = NINT( XC + 0.5 )
        IY = NINT( YC + 0.5 )

     { Find the upper and lower bounds of the data array to plot.  Note
     { this assumes no origin information in stored in the data file.
        XL = MAX( 1, IX - SIZE )
        YL = MAX( 1, IY - SIZE )
        XU = MAX( 1, IX + SIZE )
        YU = MAX( 1, IY + SIZE )

     { Create a new NDF centred on the star.
        NDFCOPY IN=(NDF)((XL):(XU),(YL):(YU)) OUT=(NDFOUT)

     { Draw a contour plot around the star on the current graphics
     { device at the given percentiles.
        CONTOUR NDF=(NDFOUT) MODE=PE PERCENTILES=[80,90,95,99]

     { Exit if an error occurred, such as not being able to find a star
     { near the supplied position, or being unable to make the plot.
        EXCEPTION ADAMERR
           PRINT Unable to find or plot the star.
        END EXCEPTION
     END PROC
\end{verbatim
\normalsize

Here is another that creates a fancy display of an image with axes and
a key showing data values.  Besides ICL syntax, it illustrates the use
of some graphics-database commands.  Again note the need to give an
expression combining the $x$-$y$ bounds of the key to the LBOUND and
UBOUND parameter arrays.

     PROC FANCYLOOK NDF

     { Function:
     {    Plots a image with axes and colour-table key.

     { Insert the prefix to tell the parser that this is a file.
        IF SUBSTR( NDF, 1, 1 ) <> '@'
           FILE = '@' & (NDF)
        ELSE
           FILE = (NDF)
        END IF

     { Clear the current window.
        GDCLEAR CURRENT

     { Set the background and annotation colours.
        PALENTRY 0 Sienna
        PALENTRY 1 Yellow

     { Find the extent of the current picture and its aspect ratio.
        GDSTATE NCX1=(FX1) NCX2=(FX2) NCY1=(FY1) NCY2=(FY2) NOREPORT
        ASP = ( FX2 - FX1 ) / ( FY2 - FY1 )

     { Inquire the label of the current picture.  If it does not
     { have one label the current picture
        PICIN CURRENT LABEL=(ORIGLABEL) NOREPORT NAME=!
        IF ORIGLABEL = " "
           PICLABEL ORIGIN
           ORIGLABEL = "ORIGIN"
        END IF

     { Display the image with axes using the most-ornate fount.
        DISPLAY (FILE) MODE=PE AXES FONT=NCAR COSYS=D ~
                SCALOW=(LOW) SCAHIGH=(HIGH) \

     { Find the extent of the last frame picture, i.e. the one
     { associated with the last displayed image.
        PICFRAME
        GDSTATE NCX1=(DX1) NCX2=(DX2) NCY1=(DY1) NCY2=(DY2) NOREPORT

     { Determine the widths of the borders.
        XL = DX1 - FX1
        XR = FX2 - DX2
        YB = DY1 - FY1
        YT = FY2 - DY2

     { Restore the original current picture.
        PICSEL (ORIGLABEL)

     { Only plot a key if there is room. 
        IF MAX( XL, XR, YB, YT ) > 0.055

     { Determine which side has most room for the key.  First, see if
     { the key is vertical.
           IF MAX( XL, XR ) >= MAX( YB, YT )

     { Determine the width and height of the vertical key.  Bias to
     { select the right-hand side.  Part of the 0.75 is to allow for
     { the wider border to the left (0.19:0.05 of frame).  Try to
     { obtain the same width, subject to the constraint that it must
     { fit inside the current picture. 
              ASPOBL = MAX( ASP, 1.0 )
              WIDTH = MIN( 1.2 * MAX( 0.75 * XL, XR ), 0.14 / ASPOBL )
              HEIGHT = 0.7 * ( DY2 - DY1 )

     { Define the bounds of the colour-table key.   Offset the key so
     { that there is no large gap between it and the image's axes.
     { The factors are empirical, and no doubt could be improved with
     { a more-sophisticated algorithm.
              DELTA = 0.12 * MAX( 0.0, DX2 - DX1 - 0.6 / ASPOBL )
              IF XL > 1.333 * XR
                 XK1 = MAX( 0.01, DX1 - WIDTH + DELTA )
              ELSE
                 XK1 = DX2 - DELTA * 5.0 / 19.0
              END IF
              XK2 = XK1 + WIDTH
              YK1 = 0.5 * ( DY2 + DY1 - HEIGHT )
              YK2 = YK1 + HEIGHT
           ELSE

     { Determine the width and height of the horizontal key.  Try to
     { obtain the same width, subject to the constraint that it must
     { fit inside the current picture. 
              ASPPRO = MIN( ASP, 1.0 )
              WIDTH = MIN( 1.2 * MAX( YB, YT ), 0.1 * ASPPRO )
              HEIGHT = 0.7 * ( DX2 - DX1 )

     { Define the bounds of the colour-table key.   Offset the key so
     { that there is no large gap between it and the image's axes.
     { The factors are empirical, and no doubt could be improved with
     { a more-sophisticated algorithm.
              DELTA = 0.11 * MAX( 0.0, DY2 - DY1 - 0.6 * ASPPRO )
              IF YB > YT
                 YK1 = MAX( 0.01, DY1 - WIDTH + DELTA )
              ELSE
                 YK1 = DY1 - DELTA * 9.0 / 15.0
              END IF
              YK2 = YK1 + WIDTH
              XK1 = 0.5 * ( DX2 + DX1 - HEIGHT )
              XK2 = XK1 + HEIGHT
           END IF

     { So far the units are in NDC.  LUTVIEW uses co-ordinates which
     { go from (0,0) to (1,1) for both axes.  So transform some of the
     { co-ordinates.
           IF ASP >= 1
              YK1 = YK1 * ASP
              YK2 = YK2 * ASP
           ELSE
              XK1 = XK1 / ASP
              XK2 = XK2 / ASP
           END IF

     { Draw the key to fit within the current picture annotating with 
     { the scaling used in DISPLAY.
           LUTVIEW LOW=(LOW) HIGH=(HIGH) LBOUND=[ (XK1&','&YK1)] ~
             UBOUND=[ (XK2&','&YK2)] MODE=XY
        END IF
     END PROC

1 PROFILE
Creates a 1-dimensional profile through an N-dimensional NDF.

Usage:

   profile in out start finish nsamp

Description:

   This application samples an N-dimensional NDF at a set of positions,
   producing a 1-dimensional output NDF containing the sample values.
   Nearest neighbour interpolation is used.

   The samples can be placed at specified positions within the input NDF,
   or can be spaced evenly along a poly-line joining a set of vertices
   (see parameter MODE). The positions of the samples may be saved in an
   output positions list (see parameter OUTCAT).
2 Parameters
For information on individual parameters, select from the list below:
3 FINISH
FINISH = LITERAL (Read)
   The co-ordinates of the last sample in the profile, in the current
   co-ordinate Frame of the NDF (supplying ":" will display details of
   the required co-ordinate Frame). The position should be supplied as
   a list of formatted axis values separated by spaces. This parameter
   is only accessed if parameter MODE is set to "Curve" and a null
   (!) value is given for INCAT. If the last (top right) pixel in the
   NDF has valid co-ordinates in the current co-ordinate Frame of the
   NDF, then these co-ordinates will be used as the suggested default.
   Otherwise there will be no suggested default.
3 GEODESIC
GEODESIC = LOGICAL (Read)
   If TRUE then the line segments which form the profile will be
   geodesic curves within the current co-ordinate Frame of the NDF.
   Otherwise, the line segments are simple straight lines. This
   parameter is only accessed if parameter MODE is set to "Curve".

   As an example, consider a profile consisting of a single line segment
   which starts at RA=0h DEC=+80d and finishes at RA=12h DEC=+80d. If
   GEODESIC is FALSE, the line segment will be a line of constant
   declination, i.e. the "straight" line from the position (0,80) to the
   position (12,80), passing through (1,80), (2,80), etc. If GEODESIC
   is TRUE, then the line segment will be the curve of shortest
   distance on the celestial sphere between the start and end. In this
   particaular case, this will be a great circle passing through the
   north celestial pole. [FALSE]
3 IN
IN = NDF (Read)
   Input NDF structure containing the data to be profiled.
3 INCAT
INCAT = FILENAME (Read)
   A catalogue containing a set of vertices or sample positions defining
   the required profile. The file should be in the format of a "positions
   list" such as produced by applications CURSOR and LISTMAKE. If a
   null value (!) is given then parameters START and FINISH will be
   used to obtain the vertex positions. If parameter MODE is given the
   value "Curve", then the parameter INCAT is only accessed if a value
   is given for it on the command line (otherwise a null value is
   assumed).
3 MODE
MODE = LITERAL (Read)
   The mode by which the sample positions are selected. The options
   are:

   - "Curve" -- The samples are placed evenly along a curve specified
   by a set of vertices obtained from the user. The line segments
   joining these vertices may be linear or geodesic (see parameter
   GEODESIC). Multiple vertices may be supplied using a text file
   (see parameter INCAT). Alternatively, a single line segment can
   be specified using parameters START and FINISH. The number of
   samples to take along the curve is specified by parameter NSAMP.

   - "Points" -- The positions at which samples should be taken are
   given explicitly by the user in a text file (see parameter
   INCAT). No other sample positions are used.

   [Curve]
3 NSAMP
NSAMP = INTEGER (Read)
   The number of samples required along the length of the profile.
   The first sample is at the first supplied vertex, and the last
   sample is at the last supplied vertex. The sample positions are
   evenly spaced within the current co-ordinate Frame of the NDF. If
   a null value is supplied, a default value is used equal to one
   more than the length of the profile in pixels. Only accessed if
   parameter MODE is given the value "Curve". [!]
3 OUT
OUT = NDF (Write)
   The output NDF. This will be 1-dimensional with length specified
   by parameter NSAMP.
3 OUTCAT
OUTCAT = FILENAME (Write)
   An output positions list in which to store the sample positions.
   This is the name of a catalogue which can be used to communicate
   positions to subsequent applications. It includes information
   describing the available WCS co-ordinate Frames as well as the
   positions themselves. If a null value is supplied, no output
   positions list is produced. [!]
3 START
START = LITERAL (Read)
   The co-ordinates of the first sample in the profile, in the current
   co-ordinate Frame of the NDF (supplying ":" will display details of
   the required co-ordinate Frame). The position should be supplied as
   a list of formatted axis values separated by spaces. This parameter
   is only accessed if parameter MODE is set to "Curve" and a null
   (!) value is given for INCAT. If the first (bottom left) pixel in
   the NDF has valid co-ordinates in the current co-ordinate Frame of
   the NDF, then these co-ordinates will be used as the suggested
   default. Otherwise there will be no suggested default.
2 Examples
profile my_data prof "0 0" "100 100" 40 outcat=samps
   Create a 1-dimensional NDF called prof, holding a profile of the
   data values in the input NDF my_data along a profile starting at
   pixel co-ordinates [0.0,0.0] and ending at pixle co-ordinates
   [100.0,100.0]. The profile consists of 40 samples spread evenly
   (in the pixel co-ordinate Frame) between these two positions.
   This example assumes that the current co-ordinate Frame in the NDF
   my_data represents pixel co-ordinates. This can be ensured by
   issuing the command "wcsframe my_data pixel" before running
   profile. A FITS binary catalogue is created called samps.fit
   containing the positions of all samples in the profile, together with
   information describing all the co-ordinate Frames in which the
   positions of the samples are known. This file may be examined
   using application LISTSHOW.

profile my_data prof "15:32:47 23:40:08" "15:32:47 23:42"
   This example is the same as the last one except that it is
   assumed that the current co-ordinate Frame in the input NDF my_data
   is an equatorial (RA/DEC) system. It creates a 1-dimensional
   profile starting at RA=15:32:47 DEC=23:40:08, and ending at the same
   RA and DEC=23:42:00. The number of points in the profile is
   determined by the resolution of the data.

profile allsky prof incat=prof_path npoint=200 geodesic outcat=aa
   This examples creates a profile of the NDF allsky through a set of
   points given in a FITS binary catalogue called prof_path.fit. Such
   catalogues can be created (for example) using application CURSOR.
   Each line segment is a geodesic curve. The profile is sampled at 200
   points. The samples positions are written to the output positions
   list aa.fit.

profile allsky2 prof2 mode=point incat=aa
   This examples creates a profile of the NDF allsky2 containing
   samples at the positions given in the positions list aa.fit. Thus,
   the profiles created by this example and the previous example
   will sample the two images allsky and allsky2 at the same
   positions and so can be compared directly.
2 Notes
-  This application uses the conventions of the CURSA package (SUN/190)
for determining the formats of input and output positions list
catalogues. If a file type of .fits is given, then the catalogue is
assumed to be a FITS binary table. If a file type of .txt is given,
then the catalogue is assumed to be stored in a text file in "Small
Text List" (STL) format. If no file type is given, then ".fit" is
assumed.
2 Related_Applications
   KAPPA: LINPLOT, CURSOR, LISTMAKE, LISTSHOW; CURSA: XCATVIEW
2 Authors
DSB: David S. Berry (STARLINK)
2 History
 10-SEP-1998 (DSB):
    Original version.
2 Implementation_Status
   -  This routine correctly processes the DATA, VARIANCE, WCS, LABEL,
   TITLE, and UNITS components of the NDF.

   -  All non-complex numeric data types can be handled.  Only
   double-precision floating-point data can be processed directly.
   Other non-complex data types will undergo a type conversion
   before the profile is produced.

1 PSF
Determines the parameters of a model star profile by fitting star
images in a two-dimensional NDF.

Usage:

   psf in incat [device] [out] [cut] [range] [isize] [poscols]

Description:

   This application finds a set of parameters to describe a model
   Gaussian star image.  It can be used for profile-fitting stellar
   photometry, to evaluate correction terms to aperture photometry,
   or for filtering.

   The model has a radial profile:

      D =  A exp(-0.5 * (r/sigma) ** gamma )

   where r is calculated from the true radial distance from the star
   centre allowing for image ellipticity, sigma is the Gaussian
   precision constant or profile width.  The application combines a
   number of star images you specify and determines a mean
   seeing-disc size, radial fall-off parameter (gamma), axis ratio,
   and orientation of a model star image.

   A table, giving details of the seeing and ellipticity of each
   star image used can be reported to an output text file.  This
   table indicates if any star could not be used.  Reasons for
   rejecting stars are too-many bad pixels present in the image,
   the star is too close to the edge of the data array, the
   `star' is a poor fit to model or it could not be located.

   An optional plot of the mean profile and the fitted function may
   be produced.  The 2-dimensional point-spread function may be stored 
   in an NDF for later use, as may the 1-dimensional fitted profile.

2 Parameters
For information on individual parameters, select from the list below:
3 AMP1
AMP1 = _REAL (Write)
   The fitted peak amplitude of the first usable star, in the data
   units of the input NDF.
3 AXES
AXES = _LOGICAL (Read)
   TRUE if labelled and annotated axes are to be drawn around the
   plot. The width of the margins left for the annotation may be
   controlled using parameter MARGIN. The appearance of the axes
   (colours, fonts, etc) can be controlled using the parameter
   STYLE. [TRUE]
3 AXISR
AXISR = _REAL (Write)
   The axis ratio of the star images: the ratio of the major
   axis length to that of the minor axis.
3 CLEAR
CLEAR = _LOGICAL (Read)
   If TRUE the current picture is cleared before the plot is
   drawn. If CLEAR is FALSE not only is the existing plot retained,
   but also an attempt is made to align the new picture with the
   existing picture. Thus you can generate a composite plot within
   a single set of axes, say using different colours or modes to
   distinguish data from different datasets. [TRUE]
3 COFILE
COFILE = FILENAME (Read)
   Name of a text file containing the co-ordinates of the stars
   to be used. Only accessed if parameter INCAT is given a null (!)
   value. Each line should contain the formatted axis values for a
   single position, in the current Frame of the NDF. Columns can be
   separated by spaces, tabs or commas. The file may contain
   comment lines with the first character # or !. Other columns may
   be included in the file, in which case the columns holding the
   required co-ordinates should be specified using parameter POSCOLS.
3 CUT
CUT = _REAL (Read)
   This parameter controls the size of the output NDF.  If it is
   null, !, the dimension of the square NDF will be the size of
   the region used to calculate the radial profile, which usually
   is given by RANGE * width in pixels * AXISR, unless truncated.
   If CUT has a value it is the threshold which must be included
   in the PSF NDF, and it is given as the fraction of the peak
   amplitude of the PSF.  For example, if CUT=0.5 the NDF would
   contain the point-spread function to half maximum.  CUT must
   be greater than 0 and less than 1.  The suggested default is
   0.0001 [!]
3 DEVICE
DEVICE = DEVICE (Read)
   The graphics workstation on which to produce a plot of the
   mean radial profile of the stars and the fitted function.  A
   null (!) name indicates that no plot is required.
   [current graphics device]
3 FWHM
FWHM = _REAL (Write)
   The seeing-disc size: the full width at half maximum across the
   minor axis of the stars.  It is in units defined by the current
   Frame of the NDF. For instance, a value in arc-seconds will be
   reported if the current Frame is a SKY Frame, but pixels will be
   used if it is a PIXEL Frame.
3 GAMMA
GAMMA = _REAL (Write)
   The radial fall-off parameter of the star images. See the
   description for more details.  A gamma of two would be a
   Gaussian.
3 GAUSS
GAUSS = _LOGICAL (Read)
   If TRUE, the gamma coefficient is fixed to be 2; in other words
   the best-fitting two-dimensional Gaussian is evaluated.  If
   FALSE, gamma is a free parameter of the fit, and the derived
   value is returned in parameter GAMMA. [FALSE]
3 IN
IN = NDF (Read)
   The NDF containing the star images to be fitted.
3 INCAT
INCAT = FILENAME (Read)
   A catalogue containing a positions list (such as produced by
   applications CURSOR, LISTMAKE, etc.) giving the star positions
   to use. If a null (!) value is supplied parameter COFILE will be
   used to get the star positions from a simple text file.
3 ISIZE
ISIZE = _INTEGER (Read)
   The side of the square area to be used when forming the marginal
   profiles for a star image, given as a number of pixels.  It should
   be sufficiently large to contain the entire star image.  It should
   be an odd number and must lie in the range from 3 to 101.  [15]
3 LOGFILE
LOGFILE = FILENAME (Read)
   Text file to contain the table of parameters for each star.  A
   null (!) name indicates that no log file is required. [!]
3 MARGIN
MARGIN( 4 ) = _REAL (Read)
   The widths of the margins to leave for axis annotation, given
   as fractions of the corresponding dimension of the current  picture.
   Four values may be given, in the order - bottom, right, top, left.
   If less than four values are given, extra values are used equal to
   the first supplied value. If these margins are too narrow any axis
   annotation may be clipped. If a null (!) value is supplied, the
   value used is 0.15 (for all edges) if either annotated axes or a
   key are produced, and zero otherwise. [current value]
3 MARKER
MARKER = INTEGER (Read)
   The PGPLOT marker type to use for the data values in the plot.
   [current value]
3 MINOR
MINOR = _LOGICAL (Read)
   If MINOR is TRUE the horizontal axis of the plot is annotated
   with distance along the minor axis from the centre of the PSF. If
   MINOR is FALSE, the distance along the major axis is used.  [TRUE]
3 NORM
NORM = _LOGICAL (Read)
   If TRUE, the model PSF is normalized so that it has a peak value
   of unity. Otherwise, its peak value is equal to the peak
   value of the first usable star, in the data units of the input
   NDF. [TRUE]
3 ORIENT
ORIENT = _REAL (Write)
   The orientation of the major axis of the star images, in degrees.
   If the current Frame of the NDF is a SKY Frame, this will be a
   position angle (measured from north through east). Otherwise, it
   will be measured from the positive direction of the first
   current Frame axis ("X") towards the second current Frame axis
   ("Y").
3 OUT
OUT = NDF (Write)
   The NDF containing the fitted point-spread function evaluated
   at each pixel. If null, !, is entered no output NDF will be
   created. The dimensions of the array are controlled by parameter
   CUT. The pixel origin is chosen to align the model PSF with the
   fitted star in pixel co-ordinates, thus allowing the NDF
   holding the model PSF to be compared directly with the input NDF.
   A WCS component is stored in the output NDF holding a copy of the
   input WCS component. An additional Frame with Domain name OFFSET
   is added, and is made the current Frame. This Frame measures the
   distance from the PSF centre in the units in which the FWHM is
   reported. [!]
3 PROFOUT
PROFOUT = NDF (Write)
   The NDF containing the 1-dimensional fitted profile as displayed
   in the plot. If null, !, is entered no output NDF will be created. 
   The DATA component of this NDF holds the fitted PSF value at each 
   radial bin. The VARIANCE component holds the square of the residuals 
   between the fitted values and the binned values derived from the 
   input NDF. An AXIS component is included in the NDF containing the 
   radial distance as displayed in the plot. [!]
3 POSCOLS
POSCOLS = _INTEGER (Read)
   Column positions of the co-ordinates (x then y) in an input record
   of the file specified by parameter COFILE.  The columns must be
   different amongst themselves. If there is duplication new values
   will be requested.  Only accessed if INCAT is given a null (!)
   value. If a null (!) value is supplied for POSCOLS, the values
   [1,2] will be used. [!]
3 RANGE
RANGE = _REAL (Read)
   The number of image profile widths out to which the radial
   star profile is to be fitted.  (There is an upper limit of 100
   pixels to the radius at which data are actually used.) [4.0]
3 STYLE
STYLE = GROUP (Read)
   A group of attribute settings describing the plotting style to use
   when drawing the annotated axes, data values, and the model profile.

   A comma-separated list of strings should be given in which each
   string is either an attribute setting, or the name of a text file
   preceded by an up-arrow character "^". Such text files should
   contain further comma-separated lists which will be read and
   interpreted in the same manner. Attribute settings are applied in
   the order in which they occur within the list, with later settings
   over-riding any earlier settings given for the same attribute.

   Each individual attribute setting should be of the form:

      <name>=<value>

   where <name> is the name of a plotting attribute, and <value> is
   the value to assign to the attribute. Default values will be
   used for any unspecified attributes. All attributes will be
   defaulted if a null value (!) is supplied. See section "Plotting
   Attributes" in SUN/95 for a description of the available
   attributes. Any unrecognised attributes are ignored (no error is
   reported).

   The appearance of the model curve is controlled by the attributes
   Colour(Curves), Width(Curves), etc (the synonym Line may be used
   in place of Curves). The appearance of the markers representing
   the real data is controlled by Colour(Markers), Width(Markers),
   etc. (the synonym Symbols may be used in place of Markers).
   [current value]
3 TITLE
TITLE = LITERAL (Read)
   The title for the NDF to contain the fitted point-spread
   function.  If null (!) is entered the NDF will not contain a
   title.  ["KAPPA - PSF"]
3 USEAXIS
USEAXIS = GROUP (Read)
   USEAXIS is only accessed if the current co-ordinate Frame of the
   NDF has more than 2 axes. A group of two strings should be
   supplied specifying the 2 axes which are to be used when
   determining distances, reporting positions, etc. Each axis can be
   specified either by its integer index within the current Frame (in
   the range 1 to the number of axes in the current Frame), or by its
   Symbol attribute. A list of acceptable values is displayed if an
   illegal value is supplied. If a null (!) value is supplied, the
   axes with the same indices as the 2 significant NDF pixel axes are
   used. [!]
3 XLEFT
XLEFT = _REAL (Read)
   The axis value to place at the left hand end of the horizontal
   axis of the plot. If a null (!) value is supplied, a suitable
   default value will be found and used. The value supplied may be
   greater than or less than the value supplied for XRIGHT. [!]
3 XRIGHT
XRIGHT = _REAL (Read)
   The axis value to place at the right hand end of the horizontal
   axis of the plot. If a null (!) value is supplied, a suitable
   default value will be found and used. The value supplied may be
   greater than or less than the value supplied for XLEFT. [!]
3 YBOT
YBOT = _REAL (Read)
   The axis value to place at the bottom end of the vertical axis of
   the plot. If a null (!) value is supplied, a suitable default
   value will be found and used. The value supplied may be greater
   than or less than the value supplied for YTOP. [!]
3 YTOP
YTOP = _REAL (Read)
   The axis value to place at the top end of the vertical axis of
   the plot. If a null (!) value is supplied, a suitable default
   value will be found and used. The value supplied may be greater
   than or less than the value supplied for YBOT. [!]
2 Examples
psf ngc6405i starlist.FIT \
   Derives the mean point-spread function for the stars images
   in the NDF called ngc6405i that are situated near the
   co-ordinates given in the positions list starlist.FIT. A
   plot of the profile is drawn on the current graphics device.

psf ngc6405i starlist device=!
   As above but there is no graphical output, and the file type of
   the input positions list is defaulted.

psf ngc6405i cofile=starlist.dat gauss \
   As the first example, except the psf is fitted to a
   two-dimensional Gaussian,and the positions are given in a simple
   text file instead of a positions list.

psf incat=starlist.FIT in=ngc6405i logfile=fit.log fwhm=(seeing) \
   As the first example, but the results, including the fits to
   each star, are written to the text file fit.log.  The
   full-width half-maximum is written to the ICL variable SEEING
   rather than the parameter file.

psf ngc6405i starlist isize=31 style="'title=Point spread function'"
   As the first example, but the area including a star image is
   31 pixels square, say because the seeing is poor or the pixels
   are smaller than normal. The graph is titled "Point spread
   function".
2 Notes
-  Values for the FWHM seeing are given in arc-seconds if the
Current co-ordinate Frame of the NDF is a SKY Frame.

-  The stars used to determine the mean image parameters should
be chosen to represent those whose magnitudes are to be found
using a stellar photometry application, and to be sufficiently
bright, uncrowded, and noise-free to allow an accurate fit to be
made.

-  It is assumed that the image scale does not vary significantly
across the image.

-  The method to calculate the fit is as follows:

   -  Marginal profiles of each star image are formed in four
   directions, inclined at 45-degree intervals.  A Gaussian curve
   and background is fitted to each profile.  Using the resulting
   four Gaussian centres, a mean centre is found for each star.

   - The four Gaussian widths of all the stars are combined,
   using a weighted average with rejection of erroneous data, and
   from the four average widths the seeing-disc size, axis ratio
   and axis inclination are calculated.

   - The data surrounding each star is then binned into
   isophotal zones which are elliptical annuli centred on the
   star---the ellipse parameters being those just calculated.
   The data in each zone is processed to remove erroneous points
   and to find an average value.  A Gaussian profile is fitted to
   these average values and the derived amplitude is used to
   normalise the values to an amplitude of unity.  The normalised
   values are put into bins together with the corresponding data
   from all other stars and this binned data represents a
   weighted average radial profile for the set of stars, with the
   image ellipticity removed.  Finally a radial profile is fitted
   to these data, giving the radial profile parameter gamma and a
   final re-estimate of the seeing-disc size.
2 Related_Applications
   PHOTOM; Starman.
2 Authors
MJC: Malcolm J. Currie (STARLINK)

TDCA: Tim Ash (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 1990 Sep 25 (MJC):
    Original version with commentary from Rodney Warren-Smith's
    EDRS documentation.

 1991 July 6 (MJC):
    Added Usage, Notes on graphics pictures stored in the database,
    and more on the Implementation Status in the documentation.

 1991 July 9 (MJC):
    An output NDF containing the PSF may now be created.  There are
    three new parameters: CUT, OUT and TITLE.

 1991 July 12 (MJC):
    Support for data co-ordinates added via new parameter COSYS.

 1991 August 20 (MJC):
    Added FONT parameter.

 1992 March 3 (MJC):
    Replaced AIF parameter-system calls by the extended PAR
    library.

 1992 April 21 (MJC):
    Made to handle significant dimensions for user-defined
    sections.

 1992 November 30 (MJC):
    Does not use non-monotonic axis centres.

 1993 August 27 (MJC):
    Added ABSLAB, ORDLAB, PLTITL, RADUNITS, SCALE, and MINOR
    parameters for adjustment of the plotting style, for scaling
    from pixels to physical units, and for minor-axis profiles.

 1998 May 26 (MJC):
    Added GAUSS parameter.  A failure to meet the tolerance test
    is no longer fatal.  Warning messages showing the requested
    and used tolerances replace the error message.

 16-JUL-1999 (TDCA):
    Converted to use AST/PGPLOT for graphics. Blank lines in
    co-ordinate file are now ignored, rather than causing a
    fatal error.

 20-SEP-1999 (DSB):
    Modified to expect input positions in the current WCS Frame of
    the NDF. Removed parameter COSYS, RADUNITS, SCALE. Added INCAT.
    USEAXIS.

 26-OCT-1999 (DSB):
    Made MARGIN a fraction of the current picture, not the DATA
    picture.

 2-MAY-2000 (DSB):
    Added parameters AMP1 and NORM.

 17-MAY-2000 (DSB):
    Added data units to Y axis label of the plot if NORM is FALSE.

 22-MAY-2000 (DSB):
    Use an inverted copy of MAP1 when creating MAP3 instead of just
    temporarily inverting MAP1 itself. This is because the call to
    AST_SIMPLIFY could otherwise sometimes return a pointer to MAP1
    (eg if MAP2 was a UnitMap), and so subsequently re-inverting
    MAP1 would also invert MAP3.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   LABEL, WCS and TITLE components of an NDF data structure.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.  The output
   point-spread-function NDF has the same type as the input NDF.
1 Requests
KAPPA is continuing to be developed and additional applications
functionality are envisaged, particularly a graphical-user
interface for image processing.  If you wish to suggest new tasks
or enhancements to existing ones please contact the
ussc@star.rl.ac.uk. Small jobs may be undertaken quite quickly.
Requests involving substantial pieces of work need to gain the
support of others to be included in Starlink's software plans,
and so the best way to influence the priority given to KAPPA is
to contact the chairman of the Image Processing Software Strategy
Group. The Starlink World Wide Web pages will periodically
contain news of plans and work in progress.  KAPPA also receives
a high level of support, and bug reports are dealt with promptly.

1 RESHAPE
Reshapes an NDF, treating its arrays as vectors.

Usage:

   reshape in out shape=?

Description:

   This application reshapes an NDF to create another NDF by copying
   array values.  The array components in the input NDF are treated
   as vectors.  Each output array is filled in order with values from
   the input vector, until it is full or the input vector is
   exhausted.  Output data and variance pixels not filled are set to
   the bad value; unfilled quality pixels are set to zero.  The
   filling is in Fortran order, namely the first dimension, followed
   by the second dimension,... to the highest dimension.

   It is possible to form a vectorized NDF using parameter VECTORIZE
   without having to specify the shape.
2 Parameters
For information on individual parameters, select from the list below:
3 IN
IN = NDF (Read)
   The input NDF to be reshaped.
3 OUT
OUT = NDF (Read)
   The NDF after reshaping.
3 SHAPE
SHAPE( ) = _INTEGER (Read)
   The shape of the output NDF.  For example, [50,30,20] would
   create 50 columns by 30 lines by 20 bands.  It is only
   accessed when VECTORIZE = FALSE.
3 TITLE
TITLE = LITERAL (Read)
   Title for the output NDF structure.  A null value (!)
   propagates the title from the base NDF to the output NDF. [!]
3 VECTORIZE
VECTORIZE = _LOGICAL (Read)
   If TRUE, the output NDF is the vectorized form of the input
   NDF.  If FALSE, parameter SHAPE is used to specify the new
   shape.  [FALSE]
2 Examples
reshape shear normal shape=[511,512]
   This reshapes the NDF called shear to form NDF normal, whose
   shape is 511 x 512 pixels.  One example is where the original
   image has 512 x 512 pixels but one pixel was omitted from each
   line during some data capture, causing the image to be sheared
   between lines.

reshape cube cube1d vectorize
   This vectorizes the NDF called cube to form NDF cube1d.  This
   could be used for a task that only permits one-dimensional
   data.
2 Related_Applications
   KAPPA: CHAIN, PASTE, RESHAPE.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1997 June 15 (MJC):
    Original version.
2 Implementation_Status
   -  This routine correctly processes the DATA, QUALITY,
   VARIANCE, LABEL, TITLE, UNITS, and HISTORY, components of an NDF
   data structure and propagates all extensions.  WCS and AXIS information
   is lost.

   -  All non-complex numeric data types can be handled.

   -  Any number of NDF dimensions is supported.

1 RIFT
Adds a scalar to a section of an NDF data structure to correct
rift-valley defects.

Usage:

   rift in scalar out section

Description:

   The routine adds a scalar (i.e. constant) value to each pixel of
   an NDF's data array within a sub-section to produce a new NDF
   data structure.
2 Parameters
For information on individual parameters, select from the list below:
3 IN
IN = NDF (Read)
   Input NDF data structure, to which the value is to be added.
3 OUT
OUT = NDF (Write)
   Output NDF data structure.
3 SCALAR
SCALAR = _DOUBLE (Read)
   The value to be added to the NDF's data array within the
   section.
3 SECTION
SECTION = LITERAL (Read)
   The pixels to which a scalar is to be added.  This is defined
   as an NDF section, so that ranges can be defined along any
   axis, and be given as pixel indices or axis (data)
   co-ordinates.  So for example "3,4,5" would select the pixel
   at (3,4,5); "3:5," would select all elements in columns 3 to
   5; ",4" selects line 4.  See "NDF Sections" in SUN/95, or the
   online documentation for details.
3 TITLE
TITLE = LITERAL (Read)
   Value for the title of the output NDF.  A null value will cause
   the title of the NDF supplied for parameter IN to be used
   instead. [!]
2 Examples
rift aa 10.7 bb "100:105" 20
   This adds 10 in the columns 100 to 105 in the data array of
   the NDF called aa and stores the result in the NDF called bb.
   In other respects bb is a copy of aa.

rift cubein -100 cubeout ",,4"
   This adds -100 to all values in the fourth plane of the data
   array of the NDF called cubein and stores the result in the
   NDF called cubeout.  In other respects cubeout is a copy of
   cubeout.

rift in=aa scalar=2 out=bb section="-10:5,200~9"
   This adds 2 to the rectangular section between columns -10 to
   5 and lines 196 to 204 of the data array of the NDF called aa
   and stores the result in the NDF called bb.  In other respects
   bb is a copy of aa.
2 Notes
For similar operations performed on a subset, use the appropriate
application to process the relevant section and then run PASTE to
paste the result back into the full array.
2 Related_Applications
   KAPPA: CADD, CHPIX, GLITCH, PASTE, SEGMENT, ZAPLIN; Figaro: CSET,
   ICSET, NCSET, TIPPEX.
2 Authors
MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 1991 October 31 (MJC):
    Original version based on RFWS's CADD.

 1995 April 28 (MJC):
    Used the SECTION parameter instead of pixel bounds.  Made Usage
    and Examples Lowercase.  Added Related Applications, Examples,
    and Implementation Status.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   VARIANCE, LABEL, TITLE, UNITS, WCS and HISTORY components of an NDF
   data structure and propagates all extensions.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  The bad-pixel flag is set to TRUE if undefined values are
   created during the arithmetic.

   -  All non-complex numeric data types can be handled.
1 Role_of_KAPPA

It is Starlink's aim to provide maintainable, portable, and
extensible applications packages that work in harmony by sharing a
common infrastructure toolkit, standards, conventions and above all,
a standard data format.  Individual packages are no longer required
to perform all functions, thus carry less inertia, and are more
adaptable to outside developments.  Additional functionality can be
added piecemeal to the relevant package.  New user interfaces, such
as graphical, could be layered within the toolkit for obtaining
parameters and so make the enhancement available to all applications
that make use of those tools.  A recent example of this approach has
allowed us to access `foreign data formats' throughout Starlink
packages, because the packages use a common infrastructure library. 

An important part of the rationalisation is that applications are
unified by sharing the same basic data structure---the NDF
(Extensible N-dimensional Data Format).  This contains an
n-dimensional data array that can store most astronomical data such
as spectra, images and spectral-line data cubes.  The NDF may also
contain information like a title, axis labels and units, error and
quality arrays.  There are also places in the NDF, called
extensions, to store any ancillary data associated with the data
array, even other NDFs. 

The backbone of the applications packages is KAPPA (Kernel
APplication PAckage).  It provides general-purpose applications
that have wide applicability, concentrating on image processing,
data visualisation, and manipulating NDF components.  KAPPA
provides facilities that integrate with specialised Starlink
packages such as those for CCD reduction (CCDPACK), stellar and
galaxy photometry (PHOTOM, PISA, ESP), spectroscopy (ECHOMOP,
Figaro, TWODSPEC), X-ray (ASTERIX), graphics (PONGO), time-series
polarimetry (TSP), instrument-specific (CGS4DR, IRAS90,
IRCAMPACK, JCMTDR) etc.  Thus the functionality of KAPPA should
not be regarded in isolation.

Nor KAPPA should not be perceived as a rival to Figaro.  As Figaro
applications become more integrated with Starlink packages, for
example by using the NDF library, they should be seen as
complementary, with Figaro concentrating on spectroscopy and KAPPA
image processing.  Of course, there is some duplication for
historical and ease-of-use reasons. 

In a wider context, KAPPA offers facilities not in IRAF, for
instance handling of data errors, quality masking, a graphics
database, availability from the shell, as well as more n-dimensional
applications, widespread use of data axes, and a different style. 
It integrates with instrument packages developed at UK
observatories.  With the automatic data conversion and the
likelihood the KAPPA and other Starlink packages will be available
from within the IRAF command language, you should be able to pick
the best or relevant tools from both systems to get the job done. 
1 ROTATE
Rotates a 2-dimensional NDF about its centre through any angle.

Usage:

   rotate in out angle

Description:

   This rotates a 2-dimensional array stored in an NDF data
   structure by an arbitrary angle.  The origin of the rotation is
   the centre of the array.  The output array dimensions just
   accommodate the rotated array.  Output pixels can be generated
   from the input array by one of two methods: nearest-neighbour
   substitution or by bi-linear interpolation.  The latter is
   slower, but gives better results.  Output pixels not
   corresponding to input pixels take the bad value.
2 Parameters
For information on individual parameters, select from the list below:
3 ANGLE
ANGLE  = _REAL (Read)
   Number of clockwise degrees by which the data array is to be
   rotated.  It must lie between 0 and 360 degrees.  The suggested
   default is the current value.
3 IN
IN = NDF (Read)
   NDF structure containing the 2-dimensional array to be rotated.
3 NNMETH
NNMETH = _LOGICAL (Read)
   If TRUE, the nearest-neighbour method will be used to evaluate
   the output data-array pixels.  This is only accessed when the
   rotation is not a multiple of 90 degrees.  [FALSE]
3 OUT
OUT = NDF (Write)
   Output NDF to contain the rotated arrays.
3 QUALITY
QUALITY = _LOGICAL (Read)
   This parameter is only accessed when NNMETH is FALSE and ANGLE
   is not a multiple of 90 degrees.  Strictly, the quality values
   are undefined by the bi-linear interpolation and hence cannot
   be propagated.  However, QUALITY = TRUE offers an
   approximation to the quality array by propagating the
   nearest-neighbour quality to the output NDF. [FALSE]
3 TITLE
TITLE = LITERAL (Read)
   A title for the output NDF.  A null value will cause the title
   of the NDF supplied for parameter IN to be used instead. [!]
3 VARIANCE
VARIANCE = _LOGICAL (Read)
   VARIANCE = TRUE instructs that variance values weight the
   pixels in the bi-linear interpolation and that output variance
   is derived from the neighbouring pixels' variance values,
   otherwise the data values are given equal weight.  This
   parameter is ignored if ANGLE is a multiple of 90 degrees or
   NNMETH=TRUE; in these cases the variance array is merely
   propagated.  The run-time default is TRUE if the input NDF has
   a VARIANCE component, and FALSE otherwise.  Note that
   following this operation the errors are no longer independent.
   []
2 Examples
rotate ns ew 90
   This rotates the array components in the NDF called ns by 90
   degrees clockwise, and stores the result in the NDF called
   ew.  The former x axis becomes the new y axis, and the former
   y axis becomes the new x axis.  The former y-axis arrays are
   also reversed in the process.

rotate angle=180 out=sn in=ns
   This rotates the array components in the NDF called ns by 180
   degrees clockwise, and stores the result in the NDF called
   sn.  The axis arrays are flipped in the output NDF.

rotate f1 f1r 37.2 novariance
   This rotates the array components in the NDF called f1 by 37.2
   degrees clockwise, and stores the result in the NDF called
   f1r.  The original axis information is lost.  Bi-linear
   interpolation is used without variance information.  No
   quality or variance information is propagated.

rotate f1 f1r 106 nnmeth title="Reoriented features map"
   This rotates the array components in the NDF called f1 by 106
   degrees clockwise, and stores the result in the NDF called
   f1r.  The original axis information is lost.  The resultant
   array components, all of which are propagated, are calculated
   by the nearest-neighbour method.  The title of the output
   NDF is "Reoriented features map".
2 Notes
-  Bad pixels are ignored in the bi-linear interpolation.  If all
four pixels are bad, the result is bad.
2 Related_Applications
   KAPPA: FLIP, TRANSFORMER; Figaro: IREVX, IREVY, IROT90.
2 Authors
MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 1995 May 14 (MJC):
    Original NDF version.

 12-JUN-1998 (DSB):
    Added propagation of the NDF WCS component.

 {enter_any_changes_here
2 Implementation_Status
   The propagation rules depend on parameters ANGLE and NNMETH.

   -  For rotations that are multiples of 90-degrees, VARIANCE,
   QUALITY, AXIS, HISTORY, LABEL WCS and UNITS components of the input
   NDF are propagated to the output NDF.  The axis and WCS components
   are switched and flipped as appropriate.

   -  For the nearest-neighbour method VARIANCE, QUALITY, HISTORY,
   LABEL, WCS and UNITS components of the input NDF are propagated to
   the output NDF.

   -  For the linear interpolation method HISTORY, LABEL, WCS and
   UNITS components of the input NDF are propagated to the output
   NDF.  In addition if parameter VARIANCE is TRUE, variance
   information is derived from the input variance; and if parameter
   QUALITY is TRUE, QUALITY is propagated using the nearest
   neighbour.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric types are supported, though for linear
   interpolation the arithmetic is performed using single- or
   double-precision floating point as appropriate; and for 90 and
   270-degree rotations _INTEGER is used for all integer types.
1 SCATTER
Displays a scatter plot between data in two NDFs.

Usage:

   scatter in1 in2 comp1 comp2 device

Description:

   This application displays a 2-dimensional plot in which the
   horizontal axis corresponds to the data value in the NDF given
   by parameter IN1, and the vertical axis corresponds to the data
   value in the NDF given by parameter IN2. Optionally, the variance,
   standard deviation or quality may be used instead of the data value for
   either axis (see parameters COMP1 and COMP2). A symbol is displayed
   at an appropriate position in the plot for each pixel which has a
   good value in both NDFs, and falls within the bounds specified by
   parameter XLEFT, XRIGHT, YBOT and YTOP. The type of symbol may be
   specified using parameter MARKER.

   The supplied arrays may be compressed prior to display (see parameter
   COMPRESS). This reduces the number of points in the scatter plot, and
   also reduces the noise in the data.
2 Parameters
For information on individual parameters, select from the list below:
3 AXES
AXES = _LOGICAL (Read)
   TRUE if labelled and annotated axes are to be drawn around the
   plot. The width of the margins left for the annotation may be
   controlled using parameter MARGIN. The appearance of the axes
   (colours, fonts, etc) can be controlled using the parameter
   STYLE. [TRUE]
3 CLEAR
CLEAR = _LOGICAL (Read)
   If TRUE the current picture is cleared before the plot is
   drawn. If CLEAR is FALSE not only is the existing plot retained,
   but also an attempt is made to align the new picture with the
   existing picture. Thus you can generate a composite plot within
   a single set of axes, say using different colours or modes to
   distinguish data from different datasets. [TRUE]
3 COMP1
COMP1 = LITERAL (Read)
   The NDF array component to be displayed on the horizontal axis.
   It may be "Data", "Quality", "Variance", or "Error" (where "Error"
   is an alternative to "Variance" and causes the square root of the
   variance values to be displayed).  If "Quality" is specified,
   then the quality values are treated as numerical values (in
   the range 0 to 255). ["Data"]
3 COMP2
COMP2 = LITERAL (Read)
   The NDF array component to be displayed on the vertical axis.
   It may be "Data", "Quality", "Variance", or "Error" (where "Error"
   is an alternative to "Variance" and causes the square root of the
   variance values to be displayed).  If "Quality" is specified,
   then the quality values are treated as numerical values (in
   the range 0 to 255). ["Data"]
3 COMPRESS
COMPRESS() = _INTEGER (Read)
   The compression factors to be used when compressing the supplied
   arrays prior to display. If any of the supplied values are greater
   than 1, then the supplied arrays are compressed prior to display
   by replacing each box of input pixels by a single pixel equal to
   the mean of the pixels in the box. The size of each box in pixels
   is given by the compression factors. No compression occurs if all
   values supplied for this parameter are 1. If the number of values
   supplied is smaller than the number of axes, the final value
   supplied is duplicated for the remaining axes. [1]
3 DEVICE
DEVICE = DEVICE (Read)
   The graphics workstation on which to produce the plot.  If a
   null value (!) is supplied no plot will be made. [Current graphics
   device]
3 IN1
IN1 = NDF (Read)
   The NDF to be displayed on the horizontal axis.
3 IN2
IN2 = NDF (Read)
   The NDF to be displayed on the vertical axis.
3 MARGIN
MARGIN( 4 ) = _REAL (Read)
   The widths of the margins to leave for axis annotation, given
   as fractions of the corresponding dimension of the current picture.
   Four values may be given, in the order - bottom, right, top, left.
   If less than four values are given, extra values are used equal to
   the first supplied value. If these margins are too narrow any axis
   annotation may be clipped. The dynamic default is 0.15 (for all
   edges) if annotated axes are produced, and zero otherwise. []
3 MARKER
MARKER = _INTEGER (Read)
   Specifies the symbol with which each position should be marked in
   the plot. It should be given as an integer PGPLOT marker type. For
   instance, 0 gives a box, 1 gives a dot, 2 gives a cross, 3 gives
   an asterisk, 7 gives a triangle. The value must be larger than or
   equal to -31. [current value]
3 PERC1
PERC1( 2 ) = _REAL (Read)
   The percentiles that define the default values for XLEFT and
   XRIGHT. For example, [5,95] would result in the lowest and
   highest 5% of the data value in IN1 being excluded from the plot
   if the default values are accepted for XLEFT and XRIGHT.
   [current value]
3 PERC2
PERC2( 2 ) = _REAL (Read)
   The percentiles that define the default values for YBOT and
   YTOP. For example, [5,95] would result in the lowest and
   highest 5% of the data value in IN2 being excluded from the plot
   if the default values are accepted for YBOT and YTOP.
   [current value]
3 STYLE
STYLE = LITERAL (Read)
   A group of attribute settings describing the plotting style to use
   when drawing the annotated axes, and markers.

   A comma-separated list of strings should be given in which each
   string is either an attribute setting, or the name of a text file
   preceded by an up-arrow character "^". Such text files should
   contain further comma-separated lists which will be read and
   interpreted in the same manner. Attribute settings are applied in
   the order in which they occur within the list, with later settings
   over-riding any earlier settings given for the same attribute.

   Each individual attribute setting should be of the form:

      <name>=<value>

   where <name> is the name of a plotting attribute, and <value> is
   the value to assign to the attribute. Default values will be
   used for any unspecified attributes. All attributes will be
   defaulted if a null value (!) is supplied. See section "Plotting
   Attributes" in SUN/95 for a description of the available
   attributes. Any unrecognised attributes are ignored (no error is
   reported).

   The appearance of markers is controlled by Colour(Markers),
   Width(Markers), etc (the synonym Symbols may be used in place
   of Markers). [current value]
3 XLEFT
XLEFT = _REAL (Read)
   The axis value to place at the left hand end of the horizontal
   axis. The dynamic default is determined by parameter PERC1. The
   value supplied may be greater than or less than the value supplied
   for XRIGHT. []
3 XRIGHT
XRIGHT = _REAL (Read)
   The axis value to place at the right hand end of the horizontal
   axis. The dynamic default is determined by parameter PERC1. The
   value supplied may be greater than or less than the value supplied
   for XLEFT. []
3 YBOT
YBOT = _REAL (Read)
   The axis value to place at the bottom end of the vertical axis.
   The dynamic default is determined by parameter PERC2. The value
   supplied may be greater than or less than the value supplied
   for YTOP. []
3 YTOP
YTOP = _REAL (Read)
   The axis value to place at the top end of the vertical axis.
   The dynamic default is determined by parameter PERC2. The value
   supplied may be greater than or less than the value supplied
   for YBOT. []
2 Examples
scatter cl123a cl123b
   This displays a scatter plot of the data value in NDF cl123b
   against the data value in NDF cl123a, on the current graphics
   device.

scatter cl123a cl123a pscol_l comp2=error compress=3
   This displays a scatter plot of the error in NDF cl123a
   against the data value in the same NDF. The graphics device used
   is "pscol_l". The data is compressed by a factor of 3 on each
   axis before forming the plot.
2 Notes
-  The application stores two pictures in the graphics database in
the following order: a FRAME picture containing the annotated axes
and data plot, and a DATA picture containing just the data plot.
Note, the FRAME picture is only created if annotated axes have been
drawn, or if non-zero margins were specified using parameter
MARGIN. The world co-ordinates in the DATA picture will correspond
to data value in the two NDFs.
2 Related_Applications
   KAPPA:NORMALIZE.
2 Authors
DSB: David Berry (STARLINK)
2 History
 17-JUN-1999 (DSB):
    Original version.
2 Implementation_Status
   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  Only _REAL data can be processed directly.  Other non-complex
   numeric data types will undergo a type conversion before
   processing occurs.
1 SEGMENT
Copies polygonal segments from one NDF into another.

Usage:

   segment in1 in2 out

Description:

   This routine copies one or more polygonal segments from the first
   input NDF (parameter IN1), and pastes them into the second input NDF
   (parameter IN2) at the same pixel co-ordinates. The resulting mosaic
   is stored in the output NDF (see OUT). Either input NDF may be
   supplied as null ("!") in which case the corresponding areas of the
   output NDF are filled with bad values. For instance, supplying a null
   value for IN2 allows segments to be cut from IN1 and pasted onto a
   background of bad values. Supplying a null value for IN1 allows
   "holes" to be cut out of IN2 and filled with bad values.

   Each polygonal segment is specified by giving the positions of its
   vertices. This may be done using a graphics cursor, by supplying
   a positions list or text file containing the positions, or by
   supplying the positions in response to a parameter prompt. The
   choice is made by parameter MODE.

   This application may also be used to cut and paste cylinders with
   polygonal cross-sections from NDFs with more than 2 dimensions. See
   the Notes section below for further details.
2 Parameters
For information on individual parameters, select from the list below:
3 COORDS
COORDS = LITERAL (Read)
   The co-ordinates of a single vertex for the current polygon. If
   parameter MODE is set to "Interface", this parameter is accessed
   repeatedly to obtain the co-ordinates of all vertices in the
   polygon. A null value should be given when the final vertex has
   been specified. Each position should be supplied within the current
   co-ordinate Frame of the output NDF (see parameter OUT). Supplying
   a colon ":" will display details of the required co-ordinate Frame.
   No more than 2 formatted axis values (separated by a comma or space)
   may be supplied. If the co-ordinate Frame being used has more than
   2 axes, then the 2 axes to use must be specified using parameter
   USEAXIS.
3 DEVICE
DEVICE = DEVICE (Read)
   The name of the graphics device on which an image is displayed.
   Only used if parameter MODE is given the value "Cursor". Any
   graphics specified by parameter PLOT will be produced on this
   device.  This device must support cursor interaction. [Current
   graphics device]
3 IN1
IN1 = NDF (Read)
   The input NDF containing the data to be copied to the inside of
   the supplied polygonal segments.  If a null value is supplied,
   the inside of the polygonal segments will be filled with bad
   values.
3 IN2
IN2 = NDF (Read)
   The input NDF containing the data to be copied to the outside
   of the supplied polygonal segments.  If a null value is
   supplied, the outside of the polygonal segments will be filled
   with bad values.
3 INCAT1-INCAT20
INCAT1-INCAT20 = FILENAME (Read)
   If MODE is "Catalogue", each of the parameters INCAT1 to INCAT20
   are used to access catalogues containing the co-ordinates of the
   vertices of a single polygon.  Suitable catalogues may be created
   using CURSOR, LISTMAKE, etc. If a value is assigned to INCAT1
   on the command line, you are not prompted for any of the remaining
   parameters in this group; additional polygon catalogues must also
   be supplied on the command line.  Otherwise, you are prompted
   for INCAT1, then INCAT2, etc. until a null value is given or
   INCAT20 is reached.

   The positions in each catalogue are mapped into the pixel
   co-ordinate Frame of the output NDF by aligning the WCS
   information stored in the catalogue with the WCS information in
   the output NDF. A message indicating the Frame in which the
   positions were aligned with the output NDF is displayed.
3 LOGFILE
LOGFILE = FILENAME (Write)
   The name of a text file in which the co-ordinates of the
   polygon vertices are to be stored.  A null value (!) means that
   no file is created. [!]
3 MARKER
MARKER = INTEGER (Read)
   This parameter is only accessed if parameter PLOT is set to
   "Chain" or "Mark". It specifies the type of marker with which
   each cursor position should be marked, and should be given as
   an integer PGPLOT marker type. For instance, 0 gives a box, 1
   gives a dot, 2 gives a cross, 3 gives an asterisk, 7 gives a
   triangle. The value must be larger than or equal to -31.
   [current value]
3 MODE
MODE = LITERAL (Read)
   The mode in which the co-ordinates of each polygon vertex are to
   be obtained. The supplied string can be one of the following:

   - "Interface": positions are obtained using parameter COORDS.
   These positions must be supplied in the current co-ordinate
   Frame of the output NDF (see parameter OUT).

   - "Cursor": positions are obtained using the graphics cursor of
   the device specified by parameter DEVICE. The WCS information
   stored with the picture in the graphics database is used to
   map the supplied cursor positions into the pixel co-ordinate
   Frame of the output NDF. A message is displayed indicating the
   co-ordinate Frame in which the picture and the output NDF were
   aligned.

   - "Catalogue": positions are obtained from positions lists
   using parameters INCAT1 to INCAT20. Each catalogue defines a
   single polygon. The WCS information in each catalogue is used to
   map the positions in the catalogue into the pixel co-ordinate
   Frame of the output NDF. A message is displayed for each catalogue
   indicating the co-ordinate Frame in which the catalogue and the
   output NDF were aligned.

   - "File": positions are obtained from text files using parameters
   POLY1 to POLY20. Each file defines a single polygon. Each line
   in a file must contain two formatted axis values in the current
   co-ordinate Frame of the output NDF (see parameter OUT),
   separated by white space or a comma.

   [current value]
3 MAXPOLY
MAXPOLY = _INTEGER (Read)
   The maximum number of polygons which can be used.  For
   instance, this can be set to 1 to ensure that no more than 1
   polygon is used (this sort of thing can be useful when writing
   procedures or scripts).  A null value causes no limit to be
   imposed (unless MODE="File" or "Catalogue" in which case a limit
   of 20 is imposed). [!]
3 MINPOLY
MINPOLY = _INTEGER (Read)
   The minimum number of polygons which can be used.  For
   instance, this can be set to 2 to ensure that at least 2
   polygons are used.  The supplied value must be less than or
   equal to the value given for MAXPOLY and must be greater than
   zero. [1]
3 OUT
OUT = NDF (Write)
   The output NDF. If only one input NDF is supplied (that is, if
   one of IN1 and IN2 is assigned a null value), then the output
   NDF has the same shape and size as the supplied input NDF. Also,
   ancillary data such as WCS information is propagated from the
   supplied input NDF. In particularly, this means that the current
   co-ordinate Frame of the output NDF (in which vertex positions
   should be supplied if MODE is "File" or "Interface") is
   inherited from the input NDF. If two input NDFs are supplied,
   then the shape and size of the output NDF corresponds to the
   area of overlap between the two input NDFs (in pixel space), and
   the WCS information and current Frame are inherited from
   the NDF associated with parameter IN1.
3 PLOT
PLOT = LITERAL (Read)
   The type of graphics to be used to mark the position of each
   selected vertex.  It is only used if parameter MODE is given
   the value "Cursor".  The appearance of these graphics (colour,
   size, etc ) is controlled by the STYLE parameter. PLOT can take
   any of the following values:

   - "None" -- No graphics are produced.

   - "Mark" -- Each position is marked with a marker of type specified
   by parameter MARKER.

   - "Poly" -- Causes each position to be joined by a line to the
   previous position.  Each polygon is closed by joining the last
   position to the first.

   - "Chain" -- This is a combination of "Mark" and "Poly". Each
   position is marked by a marker and joined by a line to the
   previous position. Parameter MARKER is used to specify the marker
   to use. [current value]
3 POLY1-POLY20
POLY1-POLY20 = FILENAME (Read)
   If MODE is "File", each of the parameters POLY1 to POLY20 are
   used to access text files containing the co-ordinates of the
   vertices of a single polygon.  If a value is assigned to POLY1 on
   the command line, you are not prompted for any of the remaining
   parameters in this group; additional polygon files must also
   be supplied on the command line.  Otherwise, you are prompted
   for POLY1, then POLY2, etc. until a null value is given or
   POLY20 is reached.

   Each position should be supplied within the current co-ordinate
   Frame of the output NDF (see parameter OUT). No more than 2
   formatted axis values (separated by a comma or space) may be
   supplied on each line. If the co-ordinate Frame being used has
   more than 2 axes, then the 2 axes to use must be specified using
   parameter USEAXIS.
3 QUALITY
QUALITY = _LOGICAL (Read)
   If a TRUE value is supplied for parameter QUALITY then quality
   information is copied from the input NDFs to the output NDFs.
   Otherwise, the quality information is not copied.  This
   parameter is only accessed if all supplied input NDFs have
   defined QUALITY components.  If any of the supplied input NDFs
   do not have defined QUALITY components, then no quality is
   copied.  Note, if a null input NDF is given then the
   corresponding output QUALITY values are set to zero. [TRUE]
3 STYLE
STYLE = LITERAL (Read)
   A group of attribute settings describing the style to use when
   drawing the graphics specified by parameter PLOT.

   A comma-separated list of strings should be given in which each
   string is either an attribute setting, or the name of a text file
   preceded by an up-arrow character "^". Such text files should
   contain further comma-separated lists which will be read and
   interpreted in the same manner. Attribute settings are applied in
   the order in which they occur within the list, with later settings
   over-riding any earlier settings given for the same attribute.

   Each individual attribute setting should be of the form:

      <name>=<value>

   where <name> is the name of a plotting attribute, and <value> is
   the value to assign to the attribute. Default values will be
   used for any unspecified attributes. All attributes will be
   defaulted if a null value (!) is supplied. See section "Plotting
   Attributes" in SUN/95 for a description of the available
   attributes. Any unrecognised attributes are ignored (no error is
   reported).

   The appearance of the lines forming the edges of each polygon is
   controlled by the attributes Colour(Curves), Width(Curves), etc
   (either of the synonyms Lines and Edges may be used in place of
   Curves). The appearance of the vertex markers is controlled by the
   attributes Colour(Markers), Size(Markers), etc (the synonyms
   Vertices may be used in place of Markers).  [current value]
3 USEAXIS
USEAXIS = GROUP (Read)
   USEAXIS is only accessed if the current co-ordinate Frame of the
   output NDF has more than 2 axes. A group of two strings should be
   supplied specifying the 2 axes spanning the plane in which the
   supplied polygons are defined. Each axis can be specified either
   by its integer index within the current Frame of the output NDF
   (in the range 1 to the number of axes in the current Frame), or
   by its Symbol attribute. A list of acceptable values is displayed
   if an illegal value is supplied. If a null (!) value is supplied,
   the axes with the same indices as the first 2 significant NDF pixel
   axes are used. [!]
3 VARIANCE
VARIANCE = _LOGICAL (Read)
   If a TRUE value is supplied for parameter VARIANCE then
   variance information is copied from the input NDFs to the
   output NDFs.  Otherwise, the variance information is not
   copied.  This parameter is only accessed if all supplied input
   NDFs have defined VARIANCE components.  If any of the supplied
   input NDFs do not have defined VARIANCE components, then no
   variances are copied.  Note, if a null input NDF is given then
   the corresponding output VARIANCE values are set bad. [TRUE]
2 Examples
segment in1=m51a in2=m51b out=m51_comp incat1=coords mode=cat
   Copies a region of the NDF m51a to the corresponding position
   in the output NDF m51_comp.  The region is defined by the list
   of vertex co-ordinates held in catalogue coords.FIT.  All
   pixels in the output NDF which fall outside this region are
   given the corresponding pixel values from NDF m51b.

segment in1=m51a out=m51_cut mode=cursor plot=poly accept
   Copies a region of the NDF m51a to the corresponding position
   in the output NDF m51_cut.  The region is defined by selecting
   vertices using a graphics cursor.  The image m51a should
   previously have been displayed.  Each vertex is joined to the
   previous vertex by a line on the graphics device.  The
   ACCEPT keyword causes the suggested null default value for IN2
   to be accepted.  This means that all pixels outside the region
   identified using the cursor will be set bad in the output NDF.
2 Notes
-  Supplied positions are mapped into the pixel co-ordinate Frame
of the output NDF before being used. This means that the two input
NDFs (if supplied) must be aligned in pixel space before using this
application.

-  The routine can handle NDFs of arbitrary dimensionality.  If
either input has three or more dimensions then all planes in the
NDF pixel arrays are processed in the same way, that is the same
polygonal regions are extracted from each plane and copied to the
corresponding plane of the output NDF.  The plane containing the
polygons must be defined using parameter USEAXIS. This plane is a
plane within the current co-ordinate Frame of the output NDF (which
is inherited from the first supplied input NDF). This scheme will
only work correctly if the selected plane in the current co-ordinate
Frame is parallel to one of the planes of the pixel array.
2 Related_Applications
   KAPPA: ARDMASK, ERRCLIP, FILLBAD, FFCLEAN, PASTE, SETMAGIC,
   THRESH.
2 Authors
DSB: David Berry (STARLINK)

MJC: Malcolm J. Currie (STARLINK)
2 History
 9-NOV-1993 (DSB):
    Original NDF version, based on MJC's IMAGE-format KAPPA
    implementation.

 1995 April 11 (MJC):
    Added Notes and Related Applications, and more examples.
    Moved old Notes to Implementation Status.  Made Examples and
    Usage lowercase.  Various tidying and stylistic changes, and
    typo's corrected.  Renamed parameter XY to COORDS.  Revised
    call to various routines for obtaining the co-ordinates
    and KPG1_XYD2W.  Used modern-style variable declarations.
    Added headings to the commentary.  Made the non-warning
    messages conditional.  Used AGI_BEGIN/END to delimit picture
    processing.

 1997 July 11 (MJC):
    When POLY1 is given on the command line in file mode, it is
    now possible to supply additional polygons through parameters
    POLY2-POLY20 also given on the command line.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.

 15-JAN-2000 (DSB):
    Big changes to use PGPLOT, and to allow positions to be
    specified in the current Frame of the output NDF.
2 Implementation_Status
   -  This routine will propagate VARIANCE component values so long
   as all supplied input NDFs have defined VARIANCE components, and
   parameter VARIANCE is not FALSE.

   -  This routine will propagate QUALITY component values so long
   as all supplied input NDFs have defined QUALITY components, and
   parameter QUALITY is not FALSE.

   -  The UNITS, AXIS, LABEL, TITLE, WCS and HISTORY components are
   propagated from the first supplied input NDF, together with all
   extensions.

   -  All non-complex numeric types are supported.  The following
   data types are processed directly: _WORD, _INTEGER, _REAL,
   _DOUBLE.
1 Selecting_Graphics_Devices

You can find the list of available devices and their names with task
GDNAMES.  Names can be abbreviated provided they remain unambiguous.

2 Globals

There are global parameters (cf. topic "Parameters Globals") for the
graphics devices:

   o  Graphics Device  --- The device used for line graphics.
   o  Image Display    --- The device used for displaying images,
                           but this does not exclude the possibility
                           of line graphics, such as axes, when they
                           are associated with the image.  The
                           image-display device should be capable of
                           showing at least 24 colours or grey
                           levels simultaneously, and more for
                           certain applications.
   o  Image-display    --- The device used for overlays on the image
      Overlay              display.  Again there is a restriction
                           there should be at least 16 colours, except
                           for X-windows overlays, since these only
                           have a single colour.

The purpose of these global parameters is ostensibly to prevent
unnecessary prompting.  However, there is an ulterior motive as well.
The selection of devices outside of the graphics applications
enables us to perform other necessary actions just once.

There are commands for selecting each type of device: GDSET, IDSET
and OVSET for the graphics device, image display and overlay
respectively.  For example,
 
     ICL> idset xwindows
     % gdset ps_l
 
A selection remains in force until you change it via another
device-selecting command, use NOGLOBALS, or delete the globals
file.  The current choices can be inspected via the GLOBALS command.
If the global parameter is undefined you will be prompted for the
device if an application requires it.

You can override the global parameter for the duration of a single
application by specifying it by keyword (normally DEVICE=), or in
some applications, by position.  Here is an example.
 
     ICL> contour device=ps_l
 
2 X-windows

The most commonly used devices are X-windows.  These can require a
little preparation before you select a device.  Starlink graphics
use GWM to manage windows.  It enables a window to persist between
separate applications; or to be shared by GKS and IDI applications,
and even programmes running on different machines.  See SUN/130 for
details of GWM and how to change your X-defaults file
($HOME/.Xdefaults), but the salient points are given below.

If the window appears on a terminal or workstation other than the one
running the KAPPA executables you will need to redirect
output to your screen, if you have not already done so for some other
software.  You either use the xdisplay command

    % xdisplay myterm.mysite.mydomain.mycountry

or set the DISPLAY environment variable to point to the address of
your screen.

    % setenv DISPLAY myterm.mysite.mydomain.mycountry:0

You substitute your machine's address or IP number. (Ask your
computer manager.)

If you do not create the window before running KAPPA, the first
graphics application to open an X-windows device will create the
window, using certain defaults.  The defaults control amongst others
the foreground and background colours, the number of colours
allocated, the size and location of the window.  These defaults may
be altered with an X-defaults file, or a window created with the
GWM xmake command.

    % xmake xwindows -geom 600x450 -fg yellow -bg black

This example makes a window of dimension 600-by-450 pixels, the
background colour is black and colour for the line graphics is
yellow. 

GWM also enables a single-colour overlay to be associated with a
window.  This lets you clear the overlay independently of the image
(task OVCLEAR), so you can annotate a picture with other graphics.
This is most useful in interactive applications like ARDGEN,
or SEGMENT.  A GWM overlay does have one drawback,
however: it halves the number of available colour indices.  If you
want to use an X-windows overlay, you must ensure that you have made
the window with the -overlay qualifier to xmake, or change your
X-defaults file, or use a + suffix to the device name.

The following set up to place in your X-defaults file is a reasonable
compromise, as it maximises the number of colour indices for the
image-display window (xwindows), has a yellow overlay (xoverlay),
and a line-graphics window (x2windows).  In the defaults file there
are the following lines

     Gwm*xwindows*colours:         80
     Gwm*xwindows*overlay:         True
     Gwm*xwindows*ovcolour:        Yellow
     Gwm*xwindows2*colours:        20

and you can also set the sizes of the windows too.  Notice that the
second device name is x2windows, but the window name is xwindows2.
Don't ask why.  An overlay on this device is called x2overlay.  This
confusing name rule applies also to all but the first window of the
maximum of four windows allowed.

The device names can be abbreviated, to give unambiguous names.
Thus you can enter xw for the xwindows device, and xo for its
overlay; x2w for the x2windows device, and x2o for its overlay; and
so on.  This is the reason for having device names as they are.  If
a window does not exist, you can create one with an overlay by
appending a + to the name, so for example a device name of x2w+
would open the x2windows device with an overlay plane.

The following tells KAPPA that these are the current devices.
These remain as global parameters, so you probably will not need to
issue these commands that often.

     % idset xwindows
     % gdset x2windows
     % ovset xoverlay


1 SETAXIS
Sets values for an axis array component within an NDF data
structure.

Usage:

   setaxis ndf dim mode [comp] { file=?
                               { index=? newval=?
                               { exprs=?
                               mode

Description:

   This routine modifies the values of an axis array component or
   system within an NDF data structure.  There are a number of
   options (see parameters LIKE and  MODE).  They permit the deletion
   of the axis system, or an individual variance or width component;
   the replacement of one or more individual values; assignment of the
   whole array using Fortran-like mathematical expressions, or values
   in a text file, or to pixel co-ordinates, or by copying from
   another NDF.

   If an AXIS structure does not exist, a new one whose centres are
   pixel co-ordinates is created before any modification.
2 Parameters
For information on individual parameters, select from the list below:
3 COMP
COMP = LITERAL (Read)
   The name of the NDF axis array component to be modified.  The
   choices are: "Centre", "Data", "Error", "Width" or "Variance".
   "Data" and "Centre" are synonyms and selects the axis centres.
   "Variance" is the variance of the axis centres, i.e. measures
   the uncertainty of the axis-centre values.  "Error" is the
   alternative to "Variance" and causes the square of the
   supplied error values to be stored.  "Width" selects the axis
   width array.  ["Data"]
3 DIM
DIM = _INTEGER (Read)
   The axis dimension for which the array component is to be
   modified.  There are separate arrays for each NDF dimension.
   The value must lie between 1 and the number of dimensions of
   the NDF.  This defaults to 1 for a 1-dimensional NDF.  DIM is
   not accessed when COMP="Centre" and MODE="Delete".  The
   suggested default is the current value. []
3 EXPRS
EXPRS = LITERAL (Read)
   A Fortran-like arithmetic expression giving the value to be
   assigned to each element of the axis array specified by
   parameter COMP.  The expression may just contain a constant
   for the axis widths or variances, but the axis-centre values
   must vary.  In the latter case and whenever a constant value
   is not required, there are two tokens available---INDEX and
   CENTRE---either or both of which may appear in the expression.
   INDEX represents the pixel index of the corresponding array
   element, and CENTRE represents the existing axis centres.
   Either the CENTRE or the INDEX token must appear in the
   expression when modifying the axis centres.  All of the
   standard Fortran-77 intrinsic functions are available for use
   in the expression, plus a few others (see SUN/61 for details
   and an up-to-date list).

   Here are some examples.  Suppose the axis centres are being
   changed, then EXPRS="INDEX-0.5" gives pixel co-ordinates,
   EXPRS="2.3 * INDEX + 10" would give a linear axis at offset 10
   and an increment of 2.3 per pixel, EXPRS="LOG(INDEX*5.2)"
   would give a logarithmic axis, and EXPRS="CENTRE+10" would add
   ten to all the array centres.  If COMP="Width", EXPRS=0.96
   would set all the widths to 0.96, and EXPRS="SIND(INDEX-30)+2"
   would assign the widths to two plus the sine of the pixel
   index with respect to index 30 measured in degrees.

   EXPRS is only accessed when MODE="Expression".
3 FILE
FILE = FILENAME (Read)
   Name of the text file containing the free-format axis data.
   This parameter is only accessed if MODE="File".  The
   suggested default is the current value.
3 INDEX
INDEX = _INTEGER (Read)
   The pixel index of the array element to change.  A null value
   (!) terminates the loop during multiple replacements.  This
   parameter is only accessed when MODE="Edit".  The suggested
   default is the current value.
3 LIKE
LIKE = NDF (Read)
   A template NDF containing axis arrays. These arrays will be
   copied into the NDF given by parameter NDF. All axes are copied.
   The other parameters are only accessed if a null (!) value is
   supplied for LIKE. If the NDF being modified extends beyond the
   edges of the template NDF, then the template axis arrays will be
   extrapolated to cover the entire NDF. This is done using linear
   extrapolation through the last two extreme axis values.  [!]
3 MODE
MODE = LITERAL (Read)
   The mode of the modification.  It can be one of the following:

      "Delete"     - Deletes the array, unless COMP="Data" or
                     "Centre" whereupon the whole axis structure
                     is deleted.
      "Edit"       - Allows the modification of individual
                     elements within the array.
      "Expression" - Allows a mathematical expression to define
                     the array values.  See parameter EXPRS.
      "File"       - The array values are read in from a
                     free-format text file.
      "Pixel"      - The axis centres are set to pixel
                     co-ordinates.  This is only available when
                     COMP="Data" or "Centre".
      "WCS"        - The axis centres are set to the values of the 
                     selected axis in the current co-ordinate Frame
                     of the NDF. This is only available when
                     COMP="Data" or "Centre".

   MODE is only accessed if a null (!) value is supplied for
   parameter LIKE. The suggested default is the current value.
3 NDF
NDF = NDF (Read and Write)
   The NDF data structure in which an axis array component is to
   be modified.
3 NEWVAL
NEWVAL = LITERAL (Read)
   Value to substitute in the array element.  The range of
   allowed values depends on the data type of the array being
   modified.  NEWVAL="Bad" instructs that the bad value
   appropriate for the array data type be substituted.  Placing
   NEWVAL on the command line permits only one element to be
   replaced.  If there are multiple replacements, a null value
   (!) terminates the loop.  This parameter is only accessed when
   MODE="Edit".
3 TYPE
TYPE = LITERAL (Read)
   The data type of the modified axis array.  TYPE can be either
   "_REAL" or "_DOUBLE".  It is only accessed for MODE="File",
   "Expression", or "Pixel".  If a null (!) value is supplied, the
   value used is the current data type of the array component if
   it exists, otherwise it is "_REAL". [!]
2 Examples
setaxis ff mode=delete
   This erases the axis structure from the NDF called ff.

setaxis ff like=hh
   This creates axis structures in the NDF called ff by copying
   them from the NDF called hh, extrapolating them as necessary to
   cover ff.

setaxis abell4 1 expr exprs="CENTRE + 0.1 * (INDEX-1)"
   This modifies the axis centres along the first axis in the NDF
   called abell4.  The new centre values are spaced by 0.1 more
   per element than previously.

setaxis cube 3 expr error exprs="25.3+0.2*MOD(INDEX,8)"
   This modifies the axis errors along the third axis in the NDF
   called cube.  The new errors values are given by the
   expression "25.3+0.2*MOD(INDEX,8)", in other words the noise
   has a constant term (25.3), and a cyclic ramp component of
   frequency 8 pixels.

setaxis spectrum mode=file file=spaxis.dat
   This assigns the axis centres along the first axis in the
   1-dimensional NDF called spectrum.  The new centre values are
   read from the free-format text file called spaxis.dat.

setaxis ndf=plate3 dim=2 mode=pixel
   This assigns pixel co-ordinates to the second axis's centres
   in the NDF called plate3.

setaxis datafile 2 expression exprs="centre" type=_real
   This modifies the data type of axis centres along the second
   dimension of the NDF called datafile to be _REAL.

setaxis cube 2 edit index=3 newval=129.916
   This assigns the value 129.916 to the axis centre at index 3
   along the second axis of the NDF called cube.

setaxis comp=width ndf=cube dim=1 mode=edit index=-16 newval=1E-05
   This assigns the value 1.0E-05 to the axis width at index -16
   along the first axis of the NDF called cube.
2 Notes
-  An end-of-file error results when MODE="File" and the file
does not contain sufficient values to assign to the whole array.
In this case the axis array is unchanged.  A warning is given if
there are more values in a file record than are needed to complete
the axis array.

-  An invalid expression when MODE="Expression" results in an
error and the axis array is unchanged.

-  The chapter entitled "The Axis Coordinate System" in SUN/33
describes the NDF axis co-ordinate system and is recommended
reading especially if you are using axis widths.

-  There is no check, apart from constraints on parameter NEWVAL,
that the variance is not negative and the widths are positive.
2 File_Format
   The format is quite flexible.  The number of axis-array values
   that may appear on a line is variable; the values are separated
   by at least a space, comma, tab or carriage return.  A line can
   have up to 255 characters.  In addition a record may have
   trailing comments designated by a hash or exclamation mark.  Here
   is an example file, though a more regular format would be clearer
   for the human reader (say 10 values per line with commenting).

       # Axis Centres along second dimension

       -3.4 -0.81
       .1 3.3 4.52 5.6 9 10.5 12.  15.3   18.1  20.2
       23 25.3 ! a comment
       26.8,27.5 29. 30.76  32.1 32.4567
        35.2 37.
       <EOF>
2 Related_Applications
   KAPPA: AXCONV, AXLABEL, AXUNITS; Figaro: LXSET, LYSET.
2 Authors
MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 1995 April 24 (MJC):
    Original version.

 16 MAY 2000 (DSB):
    Parameter LIKE added.
2 Implementation_Status
   Processing is in single- or double-precision floating point.
1 SETBAD
Sets new bad-pixel flag values for an NDF.

Usage:

   setbad ndf [value]

Description:

   This application sets new logical values for the bad-pixel flags
   associated with an NDF's data and/or variance arrays.  It may
   either be used to test whether bad pixels are actually present in
   these arrays and to set their bad-pixel flags accordingly, or to
   set explicit TRUE or FALSE values for these flags.
2 Parameters
For information on individual parameters, select from the list below:
3 DATA
DATA = _LOGICAL (Read)
   This parameter controls whether the NDF's data array is
   processed.  If a TRUE value is supplied (the default), then it
   will be processed. Otherwise it will not be processed, so that
   the variance array (if present) may be considered on its own.
   The DATA and VARIANCE parameters should not both be set to
   FALSE.  [TRUE]
3 MODIFY
MODIFY = _LOGICAL (Read)
   If a TRUE value is supplied for this parameter (the default),
   then the NDF's bad-pixel flags will be permanently modified if
   necessary.  If a FALSE value is supplied, then no modifications
   will be made.  This latter mode allows the routine to be used
   to check for the presence of bad pixels without changing the
   current state of an NDF's bad-pixel flags.  It also allows the
   routine to be used on NDFs for which write access is not
   available. [TRUE]
3 NDF
NDF = NDF (Read and Write)
   The NDF in which bad pixels are to be checked for, and/or
   whose bad-pixel flags are to be modified.  (Note that setting
   the MODIFY parameter to FALSE makes it possible to check for
   bad pixels without permanently modifying the NDF.)
3 VALUE
VALUE = _LOGICAL (Read)
   If a null (!) value is supplied for this parameter (the
   default), then the routine will check to see whether any bad
   pixels are present.  This will only involve testing the value
   of each pixel if the bad-pixel flag value is initially TRUE,
   in which case it will be reset to FALSE if no bad pixels are
   found.  If the bad-pixel flag is initially FALSE, then it will
   remain unchanged.

   If a logical (TRUE or FALSE) value is supplied for this
   parameter, then it indicates the new bad-pixel flag value
   which is to be set.  Setting a TRUE value indicates to later
   applications that there may be bad pixels present in the NDF,
   for which checks must be made.  Conversely, setting a FALSE
   value indicates that there are definitely no bad pixels
   present, in which case later applications need not check for
   them and should interpret the pixel values in the NDF
   literally.

   The VALUE parameter is not used (a null value is assumed) if
   the MODIFY parameter is set to FALSE indicating that the NDF
   is not to be permanently modified. [!]
3 VARIANCE
VARIANCE = _LOGICAL (Read)
   This parameter controls whether the NDF's variance array is
   processed.  If a TRUE value is supplied (the default), then it
   will be processed. Otherwise it will not be processed, so that
   the data array may be considered on its own.  The DATA and
   VARIANCE parameters should not both be set to FALSE.  [TRUE]
2 Examples
setbad ngc1097
   Checks the data and variance arrays (if present) in the NDF
   called ngc1097 for the presence of bad pixels.  If the initial
   bad-pixel flag values indicate that bad pixels may be present,
   but none are found, then the bad-pixel flags will be reset to
   FALSE.  The action taken will be reported.

setbad ndf=ngc1368 nomodify
   Performs the same checks as described above, this time on the
   NDF called ngc1368.  The presence or absence of bad pixels is
   reported, but the NDF is not modified.

setbad myfile nodata
   Checks the variance array (if present) in the NDF called
   myfile for the presence of bad pixels, and modifies its
   bad-pixel flag accordingly.  Specifying "nodata" inhibits
   processing of the data array, whose bad-pixel flag is left
   unchanged.

setbad halpha false
   Sets the bad-pixel flag for the NDF called halpha to FALSE.
   Any pixel values which might previously have been regarded as
   bad will subsequently be interpreted literally as valid
   pixels.

setbad hbeta true
   Sets the bad-pixel flags for the NDF called hbeta to be TRUE.
   If any pixels have the special "bad" value, then they will
   subsequently be regarded as invalid pixels.  Note that if this
   is followed by a further command such as "setbad hbeta", then
   an actual check will be made to see whether any pixels have
   this special value.  The bad-pixel flags will be returned to
   FALSE if they do not.
2 Bad-Pixel_Flag_Values
   If a bad-pixel flag is TRUE, it indicates that the associated NDF
   array may contain the special "bad" value and that affected
   pixels are to be regarded as invalid.  Subsequent applications
   will need to check for such pixels and, if found, take account of
   them.

   Conversely, if a bad-pixel flag value is FALSE, it indicates that
   there are no bad pixels present.  In this case, any special "bad"
   values appearing in the array are to be interpreted literally as
   valid pixel values.
2 Quality_Components
   Bad pixels may also be introduced into an NDF's data and variance
   arrays implicitly through the presence of an associated NDF
   quality component.  This application will not take account of such
   a component, nor will it modify it.

   However, if either of the NDF's data or variance arrays do not
   contain any bad pixels themselves, a check will be made to see
   whether a quality component is present.  If it is (and its
   associated bad-bits mask is non-zero), then a warning message
   will be issued indicating that bad pixels may be introduced via
   this quality component.  If required, these bad pixels may be
   eliminated either by setting the bad-bits mask to zero or by
   erasing the quality component.
2 Related_Applications
   KAPPA: NOMAGIC, SETMAGIC.
2 Authors
RFWS: R.F. Warren-Smith (STARLINK, RAL)

MJC: Malcolm J. Currie (STARLINK)
2 History
 19-MAR-1991 (RFWS):
    Original version.

 26-MAR-1991 (RFWS):
    Added the DATA and VARIANCE parameters.

 10-APR-1991 (RFWS):
    Improved the prologue.

 1995 April 24 (MJC):
    Made usage and examples lowercase.  Added Related Applications.
1 SETBB
Sets a new value for the quality bad-bits mask of an NDF.

Usage:

   setbb ndf bb

Description:

   This application sets a new value for the bad-bits mask
   associated with the quality component of an NDF.  This 8-bit mask
   is used to select which of the bits in the quality array should
   normally be used to generate "bad" pixels when the NDF is
   accessed.

   Wherever a bit is set to 1 in the bad-bits mask, the
   corresponding bit will be extracted from the NDF's quality array
   value for each pixel (the other quality bits being ignored).  A
   pixel is then considered "bad" if any of the extracted quality
   bits is set to 1.  Effectively, the bad-bits mask therefore allows
   selective activation of any of the eight 1-bit masks which can be
   stored in the quality array.
2 Parameters
For information on individual parameters, select from the list below:
3 AND
AND = _LOGICAL (Read)
   By default, the value supplied via the BB parameter will be
   used literally as the new bad-bits mask value.  However, if a
   TRUE value is given for the AND parameter, then a bit-wise
   `AND' will first be performed with the old value of the mask.
   This facility allows individual bits in within the mask to be
   cleared (i.e. reset to zero) without affecting the current
   state of other bits (see the "Examples" section).

   The AND parameter is not used if a TRUE value is given for the
   OR parameter. [FALSE]
3 BB
BB = LITERAL (Read)
   The new integer value for the bad-bits mask.  This may either
   be specified in normal decimal notation, or may be given using
   binary, octal or hexadecimal notation by adding a "B", "O" or
   "Z" prefix (respectively) to the appropriate string of digits.
   The value supplied should lie in the range 0 to 255 decimal (or
   8 bits of binary).

   If the AND and OR parameters are both FALSE, then the value
   supplied will be used directly as the new mask value.
   However, if either of these logical parameters is set to TRUE,
   then an appropriate bit-wise `AND' or `OR' operation with the
   old mask value will first be performed.

   The default value suggested when prompting for this value is
   chosen so as to leave the original mask value unchanged.
3 NDF
NDF = NDF (Read and Write)
   The NDF whose bad-bits mask is to be modified.
3 OR
OR = _LOGICAL (Read)
   By default, the value supplied via the BB parameter will be
   used literally as the new bad-bits mask value.  However, if a
   TRUE value is given for the OR parameter, then a bit-wise `OR'
   will first be performed with the old value of the mask.  This
   facility allows individual bits in within the mask to be set
   to 1 without affecting the current state of other bits (see
   the "Examples" section).  [FALSE]
2 Examples
setbb myframe 3
   Sets the bad-bits mask value for the quality component of the
   NDF called myframe to the value 3.  This means that bits 1 and
   2 of the associated quality array will be used to generate bad
   pixels.

setbb ndf=myframe bb=b11
   This example performs the same operation as above, but in this
   case the new mask value has been specified using binary
   notation.

setbb xspec b10001000 or
   Causes the bad-bits mask value in the NDF called xspec to
   undergo a bit-wise `OR' operation with the binary value
   10001000.  This causes bits 4 and 8 to be set without changing
   the state of any other bits in the mask.

setbb quasar ze7 and
   Causes the bad-bits mask value in the NDF called quasar to
   undergo a bit-wise `AND' operation with the hexadecimal value
   E7 (binary 11100111).  This causes bits 4 and 5 to be cleared
   (i.e. reset to zero) without changing the state of any other
   bits in the mask.
2 Notes
The bad-bits value will be disregarded if the NDF supplied does
not have a quality component present.  A warning message will be
issued if this should occur.
2 Related_Applications
   Figaro: Q2BAD; IRAS90: QUALTOBAD, REMQUAL, SETQUAL, SHOWQUAL.
2 Authors
RFWS: R.F. Warren-Smith (STARLINK, RAL)

MJC: Malcolm J. Currie (STARLINK)
2 History
 15-APR-1991 (RFWS):
    Original version.

 17-APR-1991 (RFWS):
    Added the AND and OR parameters and changed to allow binary,
    octal and hexadecimal notation.

 1995 April 24 (MJC):
    Made usage and examples lowercase.  Added Related Applications.
1 SETBOUND
Sets new bounds for an NDF.

Usage:

   setbound ndf

Description:

   This application sets new pixel-index bounds for an NDF, either
   trimming it to remove unwanted pixels, or padding it with bad
   pixels to achieve the required shape.  The number of dimensions
   may also be altered.  The NDF is accessed in update mode and
   modified in situ, preserving existing pixel values which lie
   within the new bounds.
2 Parameters
For information on individual parameters, select from the list below:
3 LIKE
LIKE = NDF (Read)
   This parameter may be used to specify an NDF which is to be
   used as a shape template.  If such a template is supplied, then
   its bounds will be used to determine the new shape required
   for the NDF specified via the NDF parameter.  By default no
   template will be used and the new shape will be determined
   by means of a section specification applied to the NDF being
   modified (see the "Examples"). [!]
3 NDF
NDF = NDF (Read and Write)
   The NDF whose bounds are to be modified.  In normal use, an NDF
   section will be specified for this parameter (see the
   "Examples") and the routine will use the bounds of this section
   to determine the new bounds required for the base NDF from
   which the section is drawn.  The base NDF is then accessed in
   update mode and its bounds are modified in situ to make them
   equal to the bounds of the section specified.  If a section is
   not specified, then the NDF's shape will only be modified if a
   shape template is supplied via the LIKE parameter.
2 Examples
setbound datafile(1:512,1:512)
   Sets the pixel-index bounds of the NDF called datafile to be
   (1:512,1:512), either by trimming off unwanted pixels or by
   padding out with bad pixels, as necessary.

setbound alpha(:7,56:)
   Modifies the NDF called alpha so that its first dimension has
   an upper bound of 7 and its second dimension has a lower bound
   of 56.  The lower bound of the first dimension and the upper
   bound of the second dimension remain unchanged.

setbound ndf=kg74b(,5500.0~100.0)
   Sets new bounds for the NDF called kg74b.  The bounds of the
   first dimension are left unchanged, but those of the second
   dimension are changed so that this dimension has an extent of
   100.0 centred on 5500.0, using the physical units in which
   this second dimension is calibrated.

setbound newspec like=oldspec
   Changes the bounds of the NDF newspec so that they are equal
   to the bounds of the NDF called oldspec.

setbound xflux(:2048) like=xflux
   Extracts the section extending from the lower bound of the
   1-dimensional NDF called xflux up to pixel 2048, and then
   modifies the bounds of this section to be equal to the
   original bounds of xflux, replacing xflux with this new NDF.
   This leaves the final shape unchanged, but sets all pixels
   from 2049 onwards to be equal to the bad-pixel value.

setbound whole(5:10,5:10) like=whole(0:15,0:15)
   Extracts the section (5:10,5:10) from the base NDF called
   whole and then sets its bounds to be equal to those of the
   section whole(0:15,0:15), replacing whole with this new NDF.
   The effect is to select a 6-pixel-square region from the
   original NDF and then to pad it with a 5-pixel-wide border of
   bad pixels.
2 Notes
This routine modifies the NDF in situ and will not release unused
file space if the size of the NDF is reduced.  If recovery of
unused file space is required, then the related application
NDFCOPY should be used.  This will copy the selected region of an
NDF to a new data structure from which any unused space will be
eliminated.
2 Related_Applications
   KAPPA: NDFCOPY, SETORIGIN; Figaro: ISUBSET.
2 Authors
RFWS: R.F. Warren-Smith (STARLINK, RAL)

MJC: Malcolm J. Currie (STARLINK)
2 History
 11-MAR-1991 (RFWS):
    Original version.

 1995 April 24 (MJC):
    Made usage and examples lowercase.  Added Related Applications.
1 SETEXT
Manipulates the contents of a specified NDF extension.

Usage:

   setext ndf xname option cname { ok
                                 { ctype=? shape=? ok
                                 { newname=?
                                 { xtype=?
                               option

Description:

   This task enables the contents of a specified NDF extension to be
   edited.  It can create a new extension or delete an existing one,
   can create new scalar components within an extension, or modify
   or display the values of existing scalar components within the
   extension.  The task operates on only one extension at a
   time, and must be closed down and restarted to work on a new
   extension.

   The task may operate in one of two modes, according to the
   LOOP parameter.  When LOOP=FALSE only a single option is
   executed at a time, making the task suitable for use from
   an ICL procedure.  When LOOP=TRUE several options may be
   executed at once, making it easier to modify several extension
   components interactively in one go.
2 Parameters
For information on individual parameters, select from the list below:
3 CNAME
CNAME = LITERAL (Read)
   The name of component (residing within the extension) to be
   examined or modified.  It is only accessed when OPTION="Erase",
   "Get", "Put", or "Rename".
3 CTYPE
CTYPE = LITERAL (Read)
   The type of component (residing within the extension) to be
   created.  Allowed values are "LITERAL", "_LOGICAL", "_DOUBLE",
   "_REAL", "_INTEGER", "_CHAR", "_BYTE", "_UBYTE", "_UWORD",
   "_WORD".  The length of the character type may be defined by
   appending the length, for example, "_CHAR*32" is a
   32-character component.  "LITERAL" and "_CHAR" generate
   80-character components.  CTYPE is only accessed when
   OPTION="Put".
3 CVALUE
CVALUE = LITERAL (Read)
   The value(s) for the component.  Each value is converted to the
   appropriate data type for the component.  CVALUE is only
   accessed when OPTION="Put".  Note that for an array of values
   the list must be enclosed in brackets, even in response to a
   prompt.  For convenience, if LOOP=TRUE, you are prompted for
   each string.
3 LOOP
LOOP = _LOGICAL (Read)
   LOOP=FALSE requests that only one operation be performed.
   This allows batch and non-interactive processing or use in
   procedures.  LOOP=TRUE makes SETEXT operate in a looping mode
   that allows several modifications and/or examinations to be
   made to the NDF for one activation.  Setting OPTION to "Exit"
   will end the looping.  [TRUE]
3 NDF
NDF = NDF (Update)
   The NDF to modify or examine.
3 NEWNAME
NEWNAME = LITERAL (Read)
   The new name of a renamed extension component.  It is only
   accessed when OPTION="Rename".
3 OK
OK = _LOGICAL (Read)
   This parameter is used to seek confirmation before a component
   is erased or overwritten.  A TRUE value permits the operation.
   A FALSE value leaves the existing component unchanged.  This
   parameter is ignored when LOOP=FALSE.
3 OPTION
OPTION = LITERAL (Read)
   The operation to perform on the extension or a component
   therein.  The recognised options are listed below.
      "Delete"   - Delete an existing NDF extension.
      "Erase"    - Erase a component within an NDF extension
      "Exit"     - Exit from the task (when LOOP=TRUE)
      "Get"      - Display the value of a component within an NDF
                   extension.  The component must exist.
      "Put"      - Change the value of a component within an NDF
                   extension or create a new component.
      "Rename"   - Renames a component.  The component must exist.
      "Select"   - Selects another extension.  If the extension
                   does not exist a new one is created.  This
                   option is not allowed when LOOP=FALSE.

   The suggested default is the current value, except for the
   first option where there is no default.
3 SHAPE
SHAPE( ) = _INTEGER (Read)
   The shape of the component.  Thus 3,2 would be a 2-dimensional
   object with three elements along each of two lines.  0 creates
   a scalar.  The suggested default is the shape of the object
   if it already exists, otherwise it is the current value.  It
   is only accessed when OPTION="Put".
3 XNAME
XNAME = LITERAL (Given)
   The name of the extension to modify.
3 XTYPE
XTYPE = LITERAL (Given)
   The type of the extension to create.  The suggested default is
   the current value or "EXT" when there is no current value.
2 Examples
setext hh50 fits delete noloop
   This deletes the FITS extension in the NDF called hh50.

setext myndf select xtype=mytype noloop
   This creates the extension MYEXT of data type MYTYPE in the
   NDF called myndf.

setext xname=ccdpack ndf=abc erase cname=filter noloop
   This deletes the FILTER component of the CCDPACK extension in
   the NDF called abc.

setext abc ccdpack put cname=filter cvalue=B ctype=_char noloop
   This assigns the character value "B" to the FILTER component
   of the CCDPACK extension a the NDF called abc.

setext virgo plate put cname=pitch shape=2 cvalue=[32,16]

ctype=_byte noloop
   This sets the byte 2-element vector of component PITCH
   of the PLATE extension in the NDF called virgo.  The first
   element of PITCH is set to 32 and the second to 16.

setext virgo plate rename cname=filter newname=waveband noloop
   This renames the FILTER component of the PLATE extension in
   the NDF called virgo to WAVEBAND.
2 Notes
-  The "PUT" option allows the creation of extension
components with any of the primitive data types.

-  The task creates the extension automatically if it does not
exist and only allows one extension to be modified at a time.
2 Related_Applications
   KAPPA: FITSIMP, FITSLIST, NDFTRACE; CCDPACK: CCDEDIT; Figaro:
   FITSKEYS; HDSTRACE; IRAS90: IRASTRACE, PREPARE.
2 Authors
SMB: Steven M Beard (ROE)

MJC: Malcolm J. Currie (STARLINK)
2 History
 19-Mar-1993: (SMB):
    Original version.

 11-May-1993 (SMB):
    Included DAT_PAR.

 07-Dec-1993 (SMB):
    Comments tidied up.

 1995 May 9 (MJC):
    Rewrote and rearranged the prologue.  Wrote the description of
    the parameters, Examples, Related Applications, Notes and
    Usage.  Allowed access to arrays and all integer data types.
    Added rename option.  Allowed more than one extension to be
    processed.
1 SETLABEL
Sets a new label for an NDF data structure.

Usage:

   setlabel ndf label

Description:

   This routine sets a new value for the label component of an
   existing NDF data structure. The NDF is accessed in update mode
   and any pre-existing label is over-written with a new value.
   Alternatively, if a `null' value (!) is given for the LABEL
   parameter, then the NDF's label will be erased.
2 Parameters
For information on individual parameters, select from the list below:
3 LABEL
LABEL = LITERAL (Read)
   The value to be assigned to the NDF's label component. This
   should describe the type of quantity represented in the NDF's
   data array (e.g. "Surface Brightness" or "Flux Density"). The
   value may later be used by other applications, for instance to
   label the axes of graphs where the NDF's data values are
   plotted.  The suggested default is the current value.
3 NDF
NDF = NDF (Read and Write)
   The NDF data structure whose label is to be modified.
2 Examples
setlabel ngc1068 "Surface Brightness"
   Sets the label component of the NDF structure ngc1068 to be
   "Surface Brightness".

setlabel ndf=datastruct label="Flux Density"
   Sets the label component of the NDF structure datastruct to be
   "Flux Density".

setlabel raw_data label=!
   By specifying a null value (!), this example erases any
   previous value of the label component in the NDF structure
   raw_data.
2 Related_Applications
   KAPPA: AXLABEL, SETTITLE, SETUNITS.
2 Authors
RFWS: R.F. Warren-Smith (STARLINK)

MJC: Malcolm J. Currie (STARLINK)
2 History
 27-APR-1990 (RFWS):
    Original version.

 25-JUN-1990 (RFWS):
    Minor changes to prologue wording.

 1992 January 22 (MJC):
    Added usage item, reordered the parameters, and minor changes
    to the punctuation for consistency.

 1995 April 21 (MJC):
    Made usage and examples lowercase.  Added closing error
    report and Related Applications.
1 SETMAGIC
Replaces all occurrences of a given value in an NDF array with
the bad value.

Usage:

   setmagic in out repval [comp]

Description:

   This application flags all pixels that have a defined value in an
   NDF with the standard bad (`magic') value.  Other values are
   unchanged.  The number of replacements is reported.  SETMAGIC's
   applications include the import of data from software that has a
   different magic value.
2 Parameters
For information on individual parameters, select from the list below:
3 COMP
COMP = LITERAL (Read)
   The components whose values are to be flagged as bad.  It may
   be "Data", "Error", "Variance", or "All".  The last of the
   options forces substitution of bad pixels in both the data and
   variance arrays.  This parameter is ignored if the data array
   is the only array component within the NDF.  ["Data"]
3 IN
IN = NDF  (Read)
   Input NDF structure containing the data and/or variance array
   to have some of its elements flagged with the magic-value.
3 OUT
OUT = NDF (Write)
   Output NDF structure containing the data and/or variance array
   that is a copy of the input array, but with bad values flagging
   the replacement value.
3 REPVAL
REPVAL = _DOUBLE (Read)
   The element value to be substituted with the bad value.  The
   same value is replaced in both the data and variance arrays
   when COMP="All".  It must lie within the minimum and maximum
   values of the data type of the array with higher precision.
   The replacement value is converted to data type of the array
   being converted before the search begins.  The suggested
   default is the current value.
3 TITLE
TITLE = LITERAL (Read)
   Title for the output NDF structure.  A null value (!)
   propagates the title from the input NDF to the output NDF. [!]
2 Examples
setmagic irasmap aitoff repval=-2000000
   This copies the NDF called irasmap to the NDF aitoff, except
   that any pixels with the IPAC blank value of -2000000 are
   flagged with the standard bad value in aitoff.

setmagic saturn saturnb 9999.0 comp=All
   This copies the NDF called saturn to the NDF saturnb, except
   that any elements in the data and variance arrays that have
   value 9999.0 are flagged with the standard bad value.
2 Notes
-  The comparison for floating-point values tests that the
difference between the replacement value and the element value is
less than their mean times the precision of the data type.
2 Related_Applications
   KAPPA: CHPIX, FILLBAD, GLITCH, NOMAGIC, SEGMENT, SUBSTITUTE,
   ZAPLIN; FIGARO: GOODVAR.
2 Authors
MJC: Malcolm J. Currie  (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 1991 November 6 (MJC):
    Original NDF_ version.

 1994 September 26 (MJC):
    Replaced AIF calls, and used a modern style of commenting.
    Made messages conditional.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   VARIANCE, LABEL, TITLE, UNITS, WCS and HISTORY components of an NDF
   data structure and propagates all extensions.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.

   -  Any number of NDF dimensions is supported.
1 SETNORM
Sets a new value for one or all of an NDF's axis-normalisation
flags.

Usage:

   setnorm ndf dim

Description:

   This routine sets a new value for one or all the normalisation
   flags in an NDF AXIS data structure.  The NDF is accessed in
   update mode.  This flag determines how the NDF's data and
   variance arrays behave when the associated axis information is
   modified.

   If an AXIS structure does not exist, a new one whose centres are
   pixel co-ordinates is created.
2 Parameters
For information on individual parameters, select from the list below:
3 ANORM
ANORM = _LOGICAL (Read)
   The normalisation flag for the axis.  TRUE means that the
   data and variance values in the NDF are normalised to the
   pixel width values for the chosen axis so that the product
   of data value and width, and variance and the squared width
   are constant if the width is altered.

   A FALSE value means that the data and variance need not alter
   as the pixel widths are varied.  This is the default for an
   axis.  The suggested default is the current value.
3 DIM
DIM = _INTEGER (Read)
   The axis dimension for which the normalisation flag is to be
   modified.  There are separate units for each NDF dimension.
   A value of 0 sets the normalisation flag for all the axes.
   The value must lie between 0 and the number of dimensions of
   the NDF.  This defaults to 1 for a 1-dimensional NDF.  The
   suggested default is the current value. []
3 NDF
NDF = NDF (Read and Write)
   The NDF data structure in which an axis-normalisation flag
   is to be modified.
2 Examples
setnorm hd23568 0 anorm
   This sets the normalisation flags along all axes of the
   NDF structure hd23568 to be true.

setnorm ndf=spect noanorm
   This sets the normalisation flag of the 1-dimensional NDF
   structure spect to be false.

setnorm borg 3 anorm
   This sets the normalisation flag for the third dimension
   in the NDF structure borg.
2 Axis_Normalisation
   In general, the axis-normalisation property is not needed.  An
   example where it is relevant is a spectrum in which data values
   representing energy per unit wavelength and each pixel has a
   known spread in wavelength.  The sum of each pixel's data value
   multiplied by its width gives the energy in a part of the
   spectrum.  A change to the axis width, say to allow for the
   redshift, necessitates a corresponding modification to the data
   value to retain this property.  In two dimensions an example is
   where the data measure flux per unit area of sky and the pixel
   widths are defined in terms of angular size.
2 Related_Applications
   KAPPA: SETAXIS.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1995 April 27 (MJC):
    Original version.
1 SETORIGIN
Sets a new pixel origin for an NDF.

Usage:

   setorigin ndf origin

Description:

   This application sets a new pixel origin value for an NDF data
   structure.  The NDF is accessed in update mode and the indices of
   the first pixel (the NDF's lower pixel-index bounds) are set to
   specified integer values, which may be positive or negative.  No
   other properties of the NDF are altered.  If required, a template
   NDF may be supplied and the new origin values will be derived
   from it.
2 Parameters
For information on individual parameters, select from the list below:
3 LIKE
LIKE = NDF (Read)
   This parameter may be used to supply an NDF which is to be
   used as a template.  If such a template is supplied, then its
   origin (its lower pixel-index bounds) will be used as the new
   origin value for the NDF supplied via the NDF parameter.  By
   default, no template will be used and the new origin will be
   specified via the ORIGIN parameter. [!]
3 NDF
NDF = NDF (Read and Write)
   The NDF data structure whose pixel origin is to be modified.
3 ORIGIN
ORIGIN() = _INTEGER (Read)
   A 1-dimensional array specifying the new pixel origin values,
   one for each NDF dimension.
2 Examples
setorigin image_2d [1,1]
   Sets the indices of the first pixel in the 2-dimensional image
   image_2d to be (1,1).  The image pixel values are unaltered.

setorigin ndf=starfield
   A new pixel origin is set for the NDF structure called
   starfield.  SETORIGIN will prompt for the new origin values,
   supplying the existing values as defaults.

setorigin ndf=cube origin=[-128,-128]
   Sets the pixel origin values for the first two dimensions of
   the 3-dimensional NDF called cube to be (-128,-128).  A value
   for the third dimension is not specified, so the origin of
   this dimension will remain unchanged.

setorigin betapic like=alphapic
   Sets the pixel origin of the NDF called betapic to be equal to
   that of the NDF called alphapic.
2 Notes
If the number of new pixel origin values is less than the number
of NDF dimensions, then the pixel origin of the extra dimensions
will remain unchanged.  If the number of values exceeds the number
of NDF dimensions, then the excess values will be ignored.
2 Timing
   Setting a new pixel origin is a quick operation whose timing does
   not depend on the size of the NDF.
2 Related_Applications
   KAPPA: SETBOUND.
2 Authors
RFWS: R.F. Warren-Smith (STARLINK)

MJC: Malcolm J. Currie (STARLINK)
2 History
 3-JUL-1990 (RFWS):
    Original version.

 4-JUL-1990 (RFWS):
    Changed to allow dimensions whose new origin is not specified
    to retain their original lower pixel-index bounds.

 3-AUG-1990 (RFWS):
    Corrected error in routine name in error message.

 13-MAR-1991 (RFWS):
    Added the LIKE parameter to permit the use of a template NDF.

 1995 April 24 (MJC):
    Made usage and examples lowercase.  Added Related Applications.
1 SETSKY
Makes an IRAS astrometry extension.

Usage:

   setsky ndf positions coords epoch [projtype] [lon] [lat]
          [refcode] [pixelsize] [orient] [tilt] [logfile]

Description:

   This application makes an IRAS astrometry extension within a
   two-dimensional NDF, therefore allowing sky co-ordinate
   information to be stored with an arbitrary image.  This
   information is used by certain IRAS90 applications (those with
   the SKY prefix) to perform various astrometric operations.  These
   include annotation of a displayed image with a grid of celestial
   co-ordinates, marking the location of a given celestial position
   given a pixel position, and aligning a group of images.  See
   SUN/163 for details.

   The astrometry is determined either by you supplying explicit
   values for certain projection parameters, or by you providing the
   sky and corresponding image co-ordinates for a set of positions
   (see parameter POSITIONS).  In the latter case, the projection
   parameters are determined automatically by searching through
   parameter space in order to minimise the sum of the squared
   residuals between the supplied pixel co-ordinates and the
   transformed sky co-ordinates.  You may force particular
   projection parameters to take certain values by assigning an
   explicit value to the corresponding application parameter listed
   below.  The individual residuals at each position can be written
   out to a logfile so that you can identify any aberrant points.
   The RMS residual (in pixels) implied by the best-fitting
   parameters is displayed.
2 Parameters
For information on individual parameters, select from the list below:
3 COORDS
COORDS = LITERAL (Read)
   The sky co-ordinate system to use.  Valid values include
   "Ecliptic" (IAU 1980), "Equatorial" (FK4 and FK5), and
   "Galactic" (IAU 1958).  Ecliptic and equatorial co-ordinates
   are referred to the mean equinox of a given epoch.  This epoch
   is specified by appending it to the system name, in
   parentheses, for example, "Equatorial(1994.5)".  The epoch may
   be preceded by a single character, "B" or "J", indicating that
   the epoch is Besselian or Julian respectively.  If this letter
   is missing, a Besselian epoch is assumed if the epoch is less than
   1984.0, and a Julian epoch is assumed otherwise.
3 EPOCH
EPOCH = DOUBLE PRECISION (Read)
   The Julian epoch at which the observation was made (e.g.
   "1994.0").
3 LAT
LAT = LITERAL (Read)
   The latitude of the reference point, in the co-ordinate system
   specified by parameter COORDS.  For example, if COORDS is
   "Equatorial", LAT is the Declination.  See SUN/163, Section
   4.7.2 for full details of the allowed syntax for specifying
   this position.  For convenience here are some examples how you
   may specify the Declination -45 degrees, 12 arcminutes: "-45 12
   00", "-45 12", "-45d 12m", "-45.2d", "-451200", "-0.78888r".
   The last of these is a radians value.  A null value causes the
   latitude of the reference point to be estimated automatically
   from the data supplied for parameter POSITIONS. [!]
3 LOGFILE
LOGFILE = FILENAME (Read)
   Name of the text file to log the final projection parameter
   values and the residual at each supplied position.  If null,
   there will be no logging.  This parameter is ignored if a null
   value is given to parameter POSITIONS. [!]
3 LON
LON= LITERAL (Read)
   The longitude of the reference point, in the co-ordinate
   system specified by parameter COORDS.  For example, if COORDS
   is "Equatorial", LON is the Right Ascension.  See SUN/163,
   Section 4.7.2 for full details of the allowed syntax for
   specifying this position.  For convenience here are some
   examples how you may specify the Right Ascension 11 hours, 34
   minutes, and 56.2 seconds: "11 34 56.2", "11h 34m 56.2s", "11
   34.9366", "11.58228", "113456.2".  See parameter LAT for
   examples of specifying a non-equatorial longitude.  A null
   value causes the longitude of the reference point to be
   estimated automatically from the data supplied for parameter
   POSITIONS. [!]
3 NDF
NDF = NDF (Read and Write)
   The NDF that is to have an IRAS astrometry extension.
3 ORIENT
ORIENT = LITERAL (Read)
   The position angle of the NDF's y axis on the celestial
   sphere, measured from north through east.  North is defined as
   the direction of increasing sky latitude, and east is the
   direction of increasing sky longitude.  Values are constrained
   to the range 0 to two-pi radians.  A null value causes the
   position angle to be estimated automatically from the data
   supplied for parameter POSITIONS. [!]
3 PIXELREF
PIXELREF( 2 ) = REAL (Read)
   The pixel co-ordinates of the reference pixel (x then y).
   This parameter is ignored unless REFCODE = "Pixel".  Remember
   that the centre of a pixel at indices i,j is (i-0.5,j-0.5).  A
   null value causes the pixel co-ordinates of the reference
   point to be estimated automatically from the data supplied for
   parameter POSITIONS. [!]
3 PIXELSIZE
PIXELSIZE( 2 ) = _REAL (Read)
   The x and y pixel sizes at the reference position.  If only
   one value is given, the pixel is deemed to be square.  Values
   may be given in a variety of units (see parameter LAT).  For
   example, 0.54 arcseconds could be specified as "0.54s" or
   "0.009m" or "2.618E-6r".  A null value causes the pixel
   dimensions to be estimated automatically from the data
   supplied for parameter POSITIONS. [!]
3 POSITIONS
POSITIONS = LITERAL (Read)
   A list of sky co-ordinates and corresponding image
   co-ordinates for the set of positions which are to be used to
   determine the astrometry.  If a null value is given then the
   astrometry is determined by the explicit values you supply for
   each of the other parameters.  Each position is defined by
   four values, the sky longitude (in the same format as for
   parameter LON), the sky latitude (in the same format as for
   parameter LAT), the image pixel x co-ordinate and the image
   pixel y co-ordinate (both decimal values).  These should be
   supplied (in the order stated) for each position.  These
   values are given in the form of a `group expression' (see
   SUN/150).  This means that values can be either typed in
   directly or supplied in a text file.  If typed in directly,
   the items in the list should be separated by commas, and you
   are re-prompted for further values if the last supplied value
   ends in a minus sign.  If conveyed in a text file, they should
   again be separated by commas, but can be split across lines.
   The name of the text file is given in response to the prompt,
   preceded by an `up arrow' symbol (^).
3 PROJTYPE
PROJTYPE = LITERAL (Read)
   The type of projection to use.  The options are:
      "Aitoff"         - Aitoff equal-area,
      "Gnomonic"       - Gnomonic or tangent plane,
      "Lambert"        - Lambert normal equivalent cylindrical,
      "Orthographic"   - Orthographic.

   The following synonyms are also recognised:
       "All_sky"       - Aitoff,
       "Cylindrical"   - Lambert,
       "Tangent_plane" - Gnomonic.

   See SUN/163 for descriptions of these projections.  A null
   value causes the projection to be determined automatically
   from the data supplied for parameter POSITIONS. [!]
3 REFCODE
REFCODE = LITERAL (Read)
   The code for the reference pixel.  If it has value "Pixel"
   this requests that pixel co-ordinates for the reference point
   be obtained through parameter PIXELREF.  The other options are
   locations specified by two characters, the first corresponding
   to the vertical position and the second the horizontal.  For
   the vertical, valid positions are T(op), B(ottom), or
   C(entre); and for the horizontal the options are L(eft),
   R(ight), or C(entre).  Thus REFCODE = "CC" means the reference
   position is at the centre of the NDF image, and "BL" specifies
   that the reference position is at the centre of the
   bottom-left pixel in the image.  A null value causes the pixel
   co-ordinates of the reference point to be estimated
   automatically from the data supplied for parameter POSITIONS.
   [!]
3 TILT
TILT = LITERAL (Read)
   The angle through which the celestial sphere is to be rotated
   prior to doing the projection.  The axis of rotation is a
   radius passing through the reference point.  The rotation is
   in an anti-clockwise sense when looking from the reference
   point towards the centre of the celestial sphere.  In common
   circumstances this can be set to zero.  Values may be given in
   a variety of units (see parameter LAT).  Values are
   constrained to the range 0 to two-pi radians.  A null value
   causes the latitude of the reference point to be estimated
   automatically from the data supplied for parameter POSITIONS.
   ["0.0"]
2 Examples
setsky m51 ^stars.lis ecl(j1994.0) 1994.0 logfile=m51.log
   This creates an astrometry extension within the two-dimensional
   NDF called m51.  The values for parameters PROJTYPE, LON, LAT,
   PIXELREF, PIXELSIZE and ORIENT are determined automatically so
   that they minimised the sum of the squared residuals (in
   pixels) at each of the positions specified in the file
   stars.lis.  This file contains a line for each position, each
   line containing an ecliptic longitude and latitude, followed
   by a pair of image co-ordinates.  These values should be
   separated by commas.  The ecliptic co-ordinates were
   determined at Julian epoch 1994.0, and are referred to the
   mean equinox at Julian epoch 1994.0.  The determined parameter
   values together with the residual at each position are logged
   to file m51.log.

setsky m51 ^stars.lis ecl(j1994.0) 1994.0 orient=0 projtype=orth
   This creates an astrometry extension within the
   two-dimensional NDF called m51.  The values for parameters
   PROJTYPE, LON, LAT, PIXELREF and PIXELSIZE are determined
   automatically as in the previous example.  In this example
   however, an Orthographic projection is forced, and the value
   zero is assigned to parameter ORIENT, resulting in north being
   `upwards' in the image.

setsky virgo "!" eq(j2000.0) 1989.3 gn "12 29" "+12 30" bl 1.1s
       0.0d
   This creates an astrometry extension within the two-dimensional
   NDF called virgo.  It is a gnomonic projection in the
   equatorial system at Julian epoch 2000.0.  The bottom-left
   pixel of the image is located at Right Ascension 12 hours 29
   minutes, Declination +12 degrees 30 minutes.  A pixel at that
   position is square and has angular size of 1.1 arcseconds.
   The image was observed at epoch 1989.3.  At the bottom-left of
   the image, north is at the top, parallel to the y-axis of the
   image.

setsky map "!" galactic(1950.0) 1993.8 aitoff 90 0 cc
   [0.5d,0.007r] 180.0d
    This creates an astrometry extension within the two-dimensional
    NDF called map.  It is an Aitoff projection in the galactic
    system at Besselian epoch 1950.0.  The centre of the image is
    located at galactic longitude 90 degrees, latitude 0 degrees.
    A pixel at that position is rectangular and has angular size
    of 0.5 degrees by 0.007 radians.  The image was made at epoch
    1993.8.  At the image centre, south is at the top and is
    parallel to the y-axis of the image.

setsky zodiac "!" ec 1983.4 or 10.3 -5.6 Pixel 20m 0.3d
   pixelref=[9.5,-11.2]
    This creates an astrometry extension within the
    two-dimensional NDF called zodiac.  It is an orthographic
    projection in the Ecliptic system at Besselian epoch 1950.0.
    The reference point at pixel co-ordinates (9.5,-11.2)
    corresponds to ecliptic longitude 10.3 degrees, latitude

    -5.6 degrees.  A pixel at that position is square and has
    angular size of 20 arcminutes.  The image was observed at
    epoch 1983.4.  At the reference point the y-axis of the image
    points to 0.3 degrees east of north.
2 Notes
-  SETSKY overwrites an existing astrometry extension within
the NDF.

-  WARNING: As is standard for NDF extensions, the transformation
stored in the NDF will be propagated to new NDFs derived from it.
However, certain operations will invalidate the transformation.
These include configuration change, a shift of origin, and
resampling.  Once there is a standard astrometry extension, KAPPA
applications will be made to process that extension correctly, by
modifying it where that's possible otherwise not copying it.
2 Related_Applications
   ASTROM; IRAS90: SKYALIGN, SKYBOX, SKYGRID, SKYLINE, SKYMARK,
   SKYPOS, SKYWRITE.
2 Authors
MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 1994 April 13 (MJC):
    Original version.

 28-OCT-1994 (DSB):
    Added parameters POSITIONS and LOGFILE.  Modified to determine
    projection parameters automatically from the data suplied for
    POSITIONS.

 1995 February 13 (MJC):
    Corrected typo's, errors in the examples, output the fitted
    pixel size in arcseconds if appropriate.  Validated the
    extension locator before annulling it.
1 SETTITLE
Sets a new title for an NDF data structure.

Usage:

   settitle ndf title

Description:

   This routine sets a new value for the title component of an
   existing NDF data structure. The NDF is accessed in update mode
   and any pre-existing title is over-written with a new value.
   Alternatively, if a "null" value (!) is given for the TITLE
   parameter, then the NDF's title will be erased.
2 Parameters
For information on individual parameters, select from the list below:
3 NDF
NDF = NDF (Read and Write)
   The NDF data structure whose title is to be modified.
3 TITLE
TITLE = LITERAL (Read)
   The value to be assigned to the NDF's title component (e.g.
   "NGC1068 with a B filter" or "Ice band in HD123456").  This
   value may later be used by other applications as a heading for
   graphs and other forms of display where the NDF's data values
   are plotted.  The suggested default is the current value.
2 Examples
settitle ngc1068 "NGC1068 with a B filter"
   Sets the title component of the NDF structure ngc1068 to be
   "NGC1068 with a B filter".

settitle ndf=myspec title="Ice band, short integration"
   Sets the title component of the NDF structure myspec to be
   "Ice band, short integration".

settitle dat123 title=!
   By specifying a null value (!), this example erases any
   previous value of the title component in the NDF structure
   dat123.
2 Related_Applications
   KAPPA: SETLABEL, SETUNITS.
2 Authors
RFWS: R.F. Warren-Smith (STARLINK)

MJC: Malcolm J. Currie (STARLINK)
2 History
 19-APR-1990 (RFWS):
    Original version.

 27-APR-1990 (RFWS):
    Added examples to prologue.

 25-JUN-1990 (RFWS):
    Minor changes to prologue text.

 1995 April 21 (MJC):
    Made usage and examples lowercase.  Added closing error
    report and Related Applications.
1 SETTYPE
Sets a new numeric type for the data and variance components of
an NDF.

Usage:

   settype ndf type

Description:

   This application allows the numeric type of the data and variance
   components of an NDF to be changed.  The NDF is accessed in update
   mode and the values stored in these components are converted
   in situ to the new type.  No other attributes of the NDF are
   changed.
2 Parameters
For information on individual parameters, select from the list below:
3 COMPLEX
COMPLEX = _LOGICAL (Read)
   If a TRUE value is given for this parameter, then the NDF's
   array components will be altered so that they hold complex
   values, an imaginary part containing zeros being created if
   necessary.  If a FALSE value is given, then the components will
   be altered so that they hold non-complex values, any imaginary
   part being deleted if necessary.  The dynamic default for this
   parameter is chosen so that no change is made to the current
   state. []
3 DATA
DATA = _LOGICAL (Read)
   If a TRUE value is given for this parameter, then the numeric
   type of the NDF's data array will be changed.  Otherwise, this
   component's type will remain unchanged. [TRUE]
3 NDF
NDF = NDF (Read and Write)
   The NDF data structure whose array components are to have
   their numeric type changed.
3 TYPE
TYPE = LITERAL (Read)
   The new numeric type to which the NDF's array components are
   to be converted.  The value given should be one of the
   following: _DOUBLE, _REAL, _INTEGER, _WORD, _UWORD, _BYTE or
   _UBYTE (note the leading underscore).  Existing pixel values
   stored in the NDF will not be lost, but will be converted to
   the new type.  Any values which cannot be represented using the
   new type will be replaced with the bad-pixel value.
3 VARIANCE
VARIANCE = _LOGICAL (Read)
   If a TRUE value is given for this parameter, then the numeric
   type of the NDF's variance array will be changed.  Otherwise,
   this component's type will remain unchanged. [TRUE]
2 Examples
settype rawdata _real
   Converts the data and variance values held in the NDF data
   structure rawdata to have a numeric type of _REAL (i.e. to be
   stored as single-precision floating-point numbers).

settype inst.run1 _word novariance
   Converts the data array in the NDF structure inst.run1 to be
   stored as word (i.e. Fortran INTEGER*2) values.  No change is
   made to the variance component.

settype hd26571 _double complex
   Causes the data and variance components of the NDF structure
   hd26571 to be altered so as to hold complex values using
   double precision numbers.  The existing pixel values are
   converted to this new type.
2 Timing
   The execution time is approximately proportional to the number of
   pixel values to be converted.
2 Related_Applications
   Figaro: RETYPE.
2 Authors
RFWS: R.F. Warren-Smith (STARLINK)

MJC: Malcolm J. Currie  (STARLINK)
2 History
 9-AUG-1990 (RFWS):
    Original version.

 25-SEP-1990 (RFWS):
    Completed initial implementation.

 1992 March 3 (MJC):
    Replaced AIF parameter-system calls by the extended PAR
    library.

 1995 April 24 (MJC):
    Made usage and examples lowercase.  Added Related Applications.
1 SETUNITS
Sets a new units value for an NDF data structure.

Usage:

   setunits ndf units

Description:

   This routine sets a new value for the units component of an
   existing NDF data structure. The NDF is accessed in update mode
   and any pre-existing units component is over-written with a new
   value.  Alternatively, if a `null' value (!) is given for the
   UNITS parameter, then the NDF's units component will be erased.
2 Parameters
For information on individual parameters, select from the list below:
3 NDF
NDF = NDF (Read and Write)
   The NDF data structure whose units component is to be
   modified.
3 UNITS
UNITS = LITERAL (Read)
   The value to be assigned to the NDF's units component (e.g.
   "J/(m**2*Ang*s)" or "count/s").  This value may later be used
   by other applications for labelling graphs and other forms of
   display where the NDF's data values are shown.  The suggested
   default is the current value.
2 Examples
setunits ngc1342 "count/s"
   Sets the units component of the NDF structure ngc1342 to have
   the value "count/s".

setunits ndf=spect units="J/(m**2*Ang*s)"
   Sets the units component of the NDF structure spect to have
   the value "J/(m**2*Ang*s)".

setunits datafile units=!
   By specifying a null value (!), this example erases any
   previous value of the units component in the NDF structure
   datafile.
2 Related_Applications
   KAPPA: AXUNITS, SETLABEL, SETTITLE.
2 Authors
RFWS: R.F. Warren-Smith (STARLINK)

MJC: Malcolm J. Currie (STARLINK)
2 History
 25-JUN-1990 (RFWS):
    Original version.

 1995 April 21 (MJC):
    Made usage and examples lowercase.  Added closing error
    report and Related Applications.
1 SETVAR
Set new values for the variance component of an NDF data
structure.

Usage:

   ndf variance

Description:

   This routine sets new values for the variance component of an NDF
   data structure. The data structure is accessed in `update' mode,
   and new variance values are generated from the NDF's data array
   by means of a Fortran-like arithmetic expression.  Any previous
   variance information is over-written with the new values.
   Alternatively, if a `null' value (!) is given for the variance,
   then any pre-existing variance information is erased.
2 Parameters
For information on individual parameters, select from the list below:
3 NDF
NDF = NDF (Read and Write)
   The NDF data structure whose variance values are to be
   modified.
3 VARIANCE
VARIANCE = LITERAL (Read)
   A Fortran-like arithmetic expression giving the variance value
   to be assigned to each pixel in terms of the variable DATA,
   which represents the value of the corresponding data array
   pixel.  For example, VARIANCE="DATA" implies normal `root N'
   error estimates, whereas VARIANCE="DATA + 50.7" might be used
   if a sky background of 50.7 units had previously been
   subtracted.

   If a `null' value (!) is given for this parameter, then no new
   variance component will be created and any pre-existing
   variance values will be erased.
2 Examples
setvar ngc4709 data
   This sets the variance component within the NDF structure
   ngc4709 to equal its corresponding data-array component.

setvar ndf=arcspec "data - 0.31"
   This sets the variance component within the NDF structure
   arcspec to be its corresponding data-array component less a
   constant 0.31.

setvar cube4 variance=!
   This erases the values of the variance component within
   the NDF structure cube4, if it exists.
2 Notes
-  All of the standard Fortran 77 intrinsic functions are
available for use in the variance expression, plus a few others
(see SUN/61 for details and an up-to-date list).

-  Calculations are performed using real arithmetic (or double
precision if appropriate) and are constrained to be non-negative.

-  The data type of the variance component is set to match that of
the data component.
2 Related_Applications
   KAPPA: ERRCLIP; Figaro: GOODVAR.
2 Authors
RFWS: R.F. Warren-Smith (STARLINK)

MJC: Malcolm J. Currie (STARLINK)
2 History
 19-DEC-1989 (RFWS):
    Original version.

 9-APR-1990 (RFWS):
    Changed name.

 1992 January 22 (MJC):
    Added Usage and Examples items.

 1995 April 24 (MJC):
    Made usage and examples lowercase.  Added Related Applications.
1 SHADOW
Enhances edges in a 2-dimensional NDF using a shadow effect.

Usage:

   shadow in out

Description:

   This routine enhances a 2-dimensional NDF by creating a
   bas-relief or shadow effect, that causes features in an array to
   appear as though they have been illuminated from the side by some
   imaginary light source.  The enhancement is useful in locating
   edges and fine detail in an array.
2 Parameters
For information on individual parameters, select from the list below:
3 IN
IN = NDF (Read)
   The 2-dimensional NDF to be enhanced.
3 OUT
OUT = NDF (Write)
   The output NDF containing the enhanced image.
3 SHIFT
SHIFT( 2 )  =  _INTEGER (Given)
   The shift in x and y pixel indices to be used in the
   enhancement.  If the x shift is positive, positive features
   in the original array will appear to be lit from the positive
   x direction, i.e. from the right.  Similarly, if the y shift
   is positive, the light source will appear to be shining from
   the top of the array.  A one- or two-pixel shift is normally
   adequate. [1,1]
3 TITLE
TITLE = LITERAL (Read)
   Value for the title of the output NDF.  A null value will cause
   the title of the NDF supplied for parameter IN to be used
   instead. [!]
2 Examples
shadow horse horse_bas
   This enhances the NDF called horse by making it appear to be
   illuminated from the top right, and stores the result in the
   NDF called horse_bas.

shadow out=aash in=aa [-1,-1] title="Bas relief"
   This enhances the NDF called aa by making it appear to be
   illuminated from the bottom left, and stores the result in the
   NDF called aash, which has the title "Bas relief".
2 Related_Applications
   KAPPA: LAPLACE, MEDIAN; Figaro: ICONV3.
2 Authors
MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 1995 April 28 (MJC):
    Original NDF version.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   VARIANCE, LABEL, TITLE, UNITS, AXIS and HISTORY components of an NDF data
   structure and propagates all extensions.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.

   -  The output NDF will be trimmed compared with the input NDF
   by the shifts applied.
1 SLIDE
    Realigns a 2-d data array via an x,y shift.
 
   The data array in the input IMAGE structure is shifted, in either
   or both of the x and y axes, to produce the new array, in the
   output image structure. The shifts in x and y are either input as
   absolute x and y shifts by the user, or alternatively, are
   calculated from the co-ordinates of two points provided by the
   user. These are a fiducial point, with co-ordinates %FIDX, %FIDY,
   and a standard object, with co-ordinates %OBJX, %OBJY. The shift
   in x is then given by %FIDX - %OBJX and the shift in y is given by
   %FIDY - %OBJY. The output data array is padded with zeros in the
   regions not occupied by the shifted input array.  Fractional
   shifts are computed by bilinear interpolation.
 
   The magic-value method is used for processing bad data.
2 AUTHORS
   Dave Baines (ROE::ASOC5)
   Mark McCaughrean (REVA::MJM)
   Malcolm Currie  STARLINK (RAL::CUR)
2 BUGS
   None known.
2 HISTORY
   18/08/1983 : Original version                   (ROE::ASOC5)
   19/02/1984 : Modified to use new SHIFTS routine (ROE::ASOC5)
   03/06/1985 : Modified to allow Relative or Absolute
              : shifting                           (REVA::MJM)
   1986 Aug 8 : Standardised prologue formatting. Added status check
                on entry (RAL::CUR).
   1986 Sep 1 : Added arguments section to the prologue and tidied
                (RAL::CUR).
   1987 Oct 16: Reordered tidying and extra status checks
                (RAL::CUR)
   1988 Mar 16: Substituted AIF_ANTMP to annul workspace
                (RAL::CUR).
   1988 Mar 17: Referred to `array' rather than `image'
                (RAL::CUR)
   1988 May 31: More reporting of error context (RAL::CUR)
   1989 Jun 13: Allow for processing primitive NDFs (RAL::CUR)
   1989 Aug  7: Passed array dimensions as separate variables
                to SHIFTX and SHIFTY (RAL::CUR).
   1989 Dec 21: Workspace managed by AIF_TEMP (RAL::CUR).
   1991 Oct 25: Propagates UNITS, LABEL, and HISTORY (RAL::CUR).
   1992 Feb 25: Limited processing of simple NDFs (RAL::CUR).
   1992 Mar  3: Replaced AIF parameter-system calls by the extended
                PAR library (RAL::CUR).
   1995 Oct 29: Renamed from SHIFT to avoid name clash with the
                C-shell shift built-in function (mjc@star.rl.ac.uk).
2 PARAMETERS
   INPIC  = IMAGE( READ )
       IMAGE structure containing the 2-d data array to be shifted.
   STYPE  = CHAR( READ )
       The sort of shift is to be used. The choice is 'Relative'
         or 'Absolute'.
   ABSX   = REAL( READ )
       Absolute x shift in pixels. (Absolute shift)
   ABSY   = REAL( READ )
       Absolute y shift in pixels. (Absolute shift)
   FIDX   = REAL( READ )
       X-co-ordinate of the fiducial point. (Relative shift)
   FIDY   = REAL( READ )
       Y-co-ordinate of the fiducial point. (Relative shift)
   OBJX   = REAL( READ )
       X-co-ordinate of the standard object. (Relative shift)
   OBJY   = REAL( READ )
       Y-co-ordinate of the standard object. (Relative shift)
   OUTPIC = IMAGE( WRITE )
       IMAGE structure to contain the 2-d data array after being
         shifted.
   OTITLE = CHAR( READ )
       Will be used as the TITLE component for the output IMAGE
         structure.
3 INPIC
  position    1
  keyword     'INPIC'
  type        'IMAGE'
  access      'READ'
  vpath       'PROMPT'
  ppath       'GLOBAL'
  association '<-GLOBAL.DATA_ARRAY'
  prompt      'Image to be shifted'
  help        'Name of the IMAGE structure containing the 2-d data 
              array to be shifted.'
3 OUTPIC
  position    2
  keyword     'OUTPIC'
  type        'IMAGE'
  access      'WRITE'
  vpath       'PROMPT'
  association '->GLOBAL.DATA_ARRAY'
  prompt      'Image after being shifted'
  help        'Name given to the IMAGE structure to hold the data 
              array after being shifted.'
3 OTITLE
  position    3
  keyword     'OTITLE'
  type        '_CHAR'
  vpath       'DEFAULT'
  prompt      'Title for output image'
  default     'KAPPA - Slide'
  help        'Character string used as a title for the output IMAGE 
              structure.'
3 STYPE
  position    4
  keyword     'STYPE'
  type        '_CHAR'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'Shift type: Relative or Absolute'
  help        'Shift relative a to known fiducial point or an absolute
              shift to be applied to the data array.'
 #in          'Relative', 'Absolute'
3 ABSX
  position    5
  keyword     'ABSX'
  type        '_REAL'
  vpath       'PROMPT'
  prompt      'Absolute shift in x'
  help        'Give the absolute shift of the data array in pixels in 
              the x direction.'
3 ABSY
  position    6
  keyword     'ABSY'
  type        '_REAL'
  vpath       'PROMPT'
  prompt      'Absolute shift in y'
  help        'Give the absolute shift of the data array in pixels in 
              the y direction.'
3 FIDX
  position    7
  keyword     'FIDX'
  type        '_REAL'
  vpath       'PROMPT'
  prompt      'x position of fiducial point'
  help        'The x position of where you would like the standard 
              object to be.'
3 FIDY
  position    8
  keyword     'FIDY'
  type        '_REAL'
  vpath       'PROMPT'
  prompt      'y position of fiducial point'
  help        'The y position of where you would like the standard 
              object to be.'
3 OBJX
  position    9
  keyword     'OBJX'
  type        '_REAL'
  vpath       'PROMPT'
  prompt      'x position of standard object'
  help        'The x position of where the standard object is.'
3 OBJY
  position    10
  keyword     'OBJY'
  type        '_REAL'
  vpath       'PROMPT'
  prompt      'y position of standard object'
  help        'The y position of where the standard object is.'
1 SQORST
    Squashes or stretches a 2-d data array in either or both axes
 
   The output data array, written to an IMAGE structure, is produced
   by either squashing or stretching the 2-d data array, in the input
   IMAGE structure, in either or both of the x and y axes. The
   dimensions of the output data array, are given by the user. The
   stretching is performed by keeping the edge pixels fixed and
   calculating the intervening pixels by bi-linear interpolation. The
   squashing is performed by calculating each pixel in the output
   array as the mean of the corresponding pixels in the input array.
 
   The magic-value method is used for processing bad data.
2 AUTHORS
   Dave Baines (ROE::ASOC5)
   Malcolm Currie  STARLINK (RAL)
2 BUGS
   None known.
2 HISTORY
   18/08/1983 : Original version                (ROE::ASOC5)
   19/02/1984 : Modified to use TITLE component (ROE::ASOC5)
   1986 Aug 8 : Standardised prologue formatting. Added status check
                on entry (RAL::CUR).
   1986 Sep 1 : Added arguments section to prologue, renamed APPG0I
                routine to AIF_GET0I and tidied (RAL::CUR).
   1987 Oct 16: Reordered tidying and extra status checks
                (RAL::CUR)
   1988 Feb 19: Extra error report (RAL::CUR).
   1988 Mar 16: Substituted AIF_ANTMP to annul workspace
                (RAL::CUR).
   1988 Mar 17: Referred to `array' rather than `image'
                (RAL::CUR)
   1988 Jun 20: More reporting of error context (RAL::CUR)
   1989 Jun 13: Allow for processing primitive NDFs (RAL::CUR)
   1989 Aug  7: Passed array dimensions as separate variables
                to STRX, STRY, SQSHX and SQSHY (RAL::CUR).
   1989 Dec 21: Workspace managed by AIF_TEMP (RAL::CUR).
   1990 Jun 25: Fixed bug that occurred when an output dimension is
                the same as the input (RAL::CUR).
   1991 Oct 25: Propagates UNITS, LABEL, and HISTORY (RAL::CUR).
   1992 Feb 25: Limited processing of simple NDFs (RAL::CUR).
   1992 Mar  3: Replaced AIF parameter-system calls by the extended
                PAR library (RAL::CUR).
2 PARAMETERS
   INPIC  = IMAGE( READ )
       IMAGE structure containing the 2-d data array to be squashed
         or stretched.
   XDIM   = INTEGER( READ )
       First dimension for the output 2-d data array.
   YDIM   = INTEGER( READ )
       Second dimension for the output 2-d data array.
   OUTPIC = IMAGE( WRITE )
       IMAGE structure to contain the 2-d data array after being
         squashed or stretched.
   OTITLE = CHAR( READ )
       Will form the TITLE component for the output IMAGE structure.
3 INPIC
  position    1
  keyword     'INPIC'
  type        'IMAGE'
  access      'READ'
  vpath       'PROMPT'
  ppath       'GLOBAL'
  association '<-GLOBAL.DATA_ARRAY'
  prompt      'Input image'
  help        'Name of the IMAGE structure containing the 2-d data 
              array to be modified'
3 XDIM
  position    2
  keyword     'XDIM'
  type        '_INTEGER'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC'
  prompt      'First dimension of output image'
  help        'First scaling factor is this value divided by the 
              first dimension of the input data array'
3 YDIM
  position    3
  keyword     'YDIM'
  type        '_INTEGER'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC'
  prompt      'Second dimension of output image'
  help        'Second scaling factor is this value divided by the 
              second dimension of the input data array'
3 OUTPIC
  position    4
  keyword     'OUTPIC'
  type        'IMAGE'
  access      'WRITE'
  vpath       'PROMPT'
  association '->GLOBAL.DATA_ARRAY'
  prompt      'Output image'
  help        'Name of the IMAGE structure to contain the data array 
              after modification'
3 OTITLE
  position    5
  keyword     'OTITLE'
  type        '_CHAR'
  vpath       'DEFAULT'
  prompt      'Title for output image'
  default     'KAPPA - Sqorst'
  help        'Character string to be used as a title for the output 
              IMAGE structure'

1 STATS
Computes simple statistics for an NDF's pixels.

Usage:

   stats ndf [comp] [clip] [logfile]

Description:

   This application computes and displays simple statistics for the
   pixels in an NDF's data, quality or variance array.  The
   statistics available are:

   -  the pixel sum,

   -  the pixel mean,

   -  the pixel standard deviation,

   -  the value and position of the minimum- and maximum-valued
   pixels,

   -  the total number of pixels in the NDF,

   -  the number of pixels used in the statistics, and

   -  the number of pixels omitted.

   Iterative K-sigma clipping may also be applied as an option.
2 Parameters
For information on individual parameters, select from the list below:
3 CLIP
CLIP( ) = _REAL (Read)
   An optional 1-dimensional array of clipping levels to be
   applied, expressed as standard deviations.  If a null value is
   supplied for this parameter (the default), then no iterative
   clipping will take place and the statistics computed will
   include all the valid NDF pixels.

   If an array of clipping levels is given, then the routine will
   first compute statistics using all the available pixels. It
   will then reject all those pixels whose values lie outside K
   standard deviations of the mean (where K is the first value
   supplied) and will then re-evaluate the statistics. This
   rejection iteration is repeated in turn for each value in the
   CLIP array.  A maximum of 5 values may be supplied, all of
   which must be positive. [!]
3 COMP
COMP = LITERAL (Read)
   The name of the NDF array component for which statistics are
   required: "Data", "Error", "Quality" or "Variance" (where
   "Error" is the alternative to "Variance" and causes the square
   root of the variance values to be taken before computing the
   statistics).  If "Quality" is specified, then the quality
   values are treated as numerical values (in the range 0 to
   255).  ["Data"]
3 LOGFILE
LOGFILE = FILENAME (Write)
   A text file into which the results should be logged.  If a null
   value is supplied (the default), then no logging of results
   will take place. [!]
3 MAXCOORD
MAXCOORD( ) = _DOUBLE (Write)
   A 1-dimensional array of values giving the data co-ordinates of
   the centre of the (first) maximum-valued pixel found in the
   NDF array.  The number of co-ordinates is equal to the number of
   NDF dimensions.
3 MAXIMUM
MAXIMUM = _DOUBLE (Write)
   The maximum pixel value found in the NDF array.
3 MAXPOS
MAXPOS( ) = _INTEGER (Write)
   A 1-dimensional array of pixel indices identifying the (first)
   maximum-valued pixel found in the NDF array.  The number of
   indices is equal to the number of NDF dimensions.
3 MEAN
MEAN = _DOUBLE (Write)
   The mean value of all the valid pixels in the NDF array.
3 MINCOORD
MINCOORD( ) = _DOUBLE (Write)
   A 1-dimensional array of values giving the data co-ordinates of
   the centre of the (first) minimum-valued pixel found in the
   NDF array.  The number of co-ordinates is equal to the number
   of NDF dimensions.
3 MINIMUM
MINIMUM = _DOUBLE (Write)
   The minimum pixel value found in the NDF array.
3 MINPOS
MINPOS( ) = _INTEGER (Write)
   A 1-dimensional array of pixel indices identifying the (first)
   minimum-valued pixel found in the NDF array.  The number of
   indices is equal to the number of NDF dimensions.
3 NDF
NDF = NDF (Read)
   The NDF data structure to be analysed.
3 NUMBAD
NUMBAD = _INTEGER (Write)
   The number of pixels which were either not valid or were
   rejected from the statistics during iterative K-sigma
   clipping.
3 NUMGOOD
NUMGOOD = _INTEGER (Write)
   The number of NDF pixels which actually contributed to the
   computed statistics.
3 NUMPIX
NUMPIX = _INTEGER (Write)
   The total number of pixels in the NDF (both good and bad).
3 SIGMA
SIGMA = _DOUBLE (Write)
   The standard deviation of the pixel values in the NDF array.
3 TOTAL
TOTAL = _DOUBLE (Write)
   The sum of the pixel values in the NDF array.
2 Examples
stats image
   Computes and displays simple statistics for the data array in
   the NDF called image.

stats ndf=spectrum variance
   Computes and displays simple statistics for the variance array
   in the NDF called spectrum.

stats spectrum error
   Computes and displays statistics for the variance array in the
   NDF called spectrum, but takes the square root of the variance
   values before doing so.

stats halley logfile=stats.dat
   Computes statistics for the data array in the NDF called
   halley, and writes the results to a logfile called stats.dat.

stats ngc1333 clip=[3.0,2.8,2.5]
   Computes statistics for the data array in the NDF called
   NGC1333, applying three iterations of K-sigma clipping.  The
   statistics are first calculated for all the valid pixels in
   the data array.  Those pixels with values lying more than 3.0
   standard deviations from the mean are then rejected, and the
   statistics are re-computed.  This process is then repeated
   twice more, rejecting pixel values lying more than 2.8 and 2.5
   standard deviations from the mean.  The final statistics are
   displayed.
2 Related_Applications
   KAPPA: HISTAT, NDFTRACE; Figaro: ISTAT.
2 Authors
RFWS: R.F. Warren-Smith (STARLINK, RAL)

MJC: Malcolm J. Currie  STARLINK
2 History
 19-MAR-1991 (RFWS):
    Complete re-write of earlier routine to use NDF_ routines and
    the extra facilities these provide.

 11-APR-1991 (RFWS):
    Improved the prologue.

 1992 March 3 (MJC):
    Replaced AIF parameter-system calls by the extended PAR
    library.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, VARIANCE,
   QUALITY, TITLE, and HISTORY components of the NDF.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.  Arithmetic
   is performed using double-precision floating point.

   -  Any number of NDF dimensions is supported.
1 SUB
Subtracts one NDF data structure from another.

Usage:

   sub in1 in2 out

Description:

   The routine subtracts one NDF data structure from another
   pixel-by-pixel to produce a new NDF.
2 Parameters
For information on individual parameters, select from the list below:
3 IN1
IN1 = NDF (Read)
   First NDF, from which the second NDF is to be subtracted.
3 IN2
IN2 = NDF (Read)
   Second NDF, to be subtracted from the first NDF.
3 OUT
OUT = NDF (Write)
   Output NDF to contain the difference of the two input NDFs.
3 TITLE
TITLE = LITERAL (Read)
   Value for the title of the output NDF.  A null value will cause
   the title of the NDF supplied for parameter IN1 to be used
   instead.  [!]
2 Examples
sub a b c
   This subtracts the NDF called b from the NDF called a, to make
   the NDF called c.  NDF c inherits its title from a.

sub out=c in1=a in2=b title="Background subtracted"
   This subtracts the NDF called b from the NDF called a, to make
   the NDF called c.  NDF c has the title "Background subtracted".
2 Notes
If the two input NDFs have different pixel-index bounds, then
they will be trimmed to match before being subtracted.  An error
will result if they have no pixels in common.
2 Related_Applications
   KAPPA: ADD, CADD, CDIV, CMULT, CSUB, DIV, MATHS, MULT.
2 Authors
RFWS: R.F. Warren-Smith (STARLINK)

MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 6-APR-1990 (RFWS):
    Original version.

 1992 January 15 (MJC):
    Added Usage and Examples items.

 1995 September 12 (MJC):
    Title inherited by default.  Usage and examples to lowercase.
    Added Related Applications.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   LABEL, TITLE, HISTORY, WCS and VARIANCE components of an NDF data
   structure and propagates all extensions.

   -  Units processing is not supported at present and therefore the
   UNITS component is not propagated.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.
1 SUBSTITUTE
Replaces all occurrences of a given value in an NDF array with
another value.

Usage:

   substitute in out oldval newval [comp]

Description:

   This application changes all pixels that have a defined value in
   an NDF with an alternate value.  Other values are unchanged.  The
   number of replacements is reported.
2 Parameters
For information on individual parameters, select from the list below:
3 COMP
COMP = LITERAL (Read)
   The components whose values are to be substituted.  It may
   be "Data", "Error", "Variance", or "All".  The last of the
   options forces substitution in both the data and variance
   arrays.  This parameter is ignored if the data array is the
   only array component within the NDF.  ["Data"]
3 IN
IN = NDF  (Read)
   Input NDF structure containing the data and/or variance array
   to have some of its elements substituted.
3 OUT
OUT = NDF (Write)
   Output NDF structure containing the data and/or variance array
   that is a copy of the input array, but with replacemeent values
   substituted.
3 NEWVAL
NEWVAL = _DOUBLE (Read)
   The value to replace occurrences of OLDVAL.  It must lie
   within the minimum and maximum values of the data type of the
   array with higher precision.  The new value is converted to
   data type of the array being converted before the search
   begins.  The suggested default is the current value.
3 OLDVAL
OLDVAL = _DOUBLE (Read)
   The element value to be replaced.  The same value is
   substituted in both the data and variance arrays when
   COMP="All".  It must lie within the minimum and maximum values
   of the data type of the array with higher precision.  The
   replacement value is converted to data type of the array being
   converted before the search begins.  The suggested default is
   the current value.
3 TITLE
TITLE = LITERAL (Read)
   Title for the output NDF structure.  A null value (!)
   propagates the title from the input NDF to the output NDF. [!]
2 Examples
substitute aa bb 1 0
   This copies the NDF called aa to the NDF bb, except
   that any pixels with value 1 in aa are altered to have value
   0 in bb.

substitute aa bb oldval=1 newval=0 comp=v
   As above except the substitution occurs to the variance
   values.

substitute in=saturn out=saturn5 oldval=2.5 newval=5 comp=All
   This copies the NDF called saturn to the NDF saturn5, except
   that any elements in the data and variance arrays that have
   value 2.5 are altered to have value 5 in saturn5.
2 Notes
-  The comparison for floating-point values tests that the
difference between the replacement value and the element value is
less than their mean times the precision of the data type.
2 Related_Applications
   KAPPA: CHPIX, FILLBAD, GLITCH, NOMAGIC, SEGMENT, SETMAGIC, ZAPLIN;
   FIGARO: GOODVAR.
2 Authors
MJC: Malcolm J. Currie  (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 1997 May 23 (MJC):
    Original version.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   VARIANCE, LABEL, TITLE, UNITS, WCS and HISTORY components of an NDF
   data structure and propagates all extensions.

   -  All non-complex numeric data types can be handled.

   -  Any number of NDF dimensions is supported.
1 Summary
The growing number of KAPPA applications makes a simple list of their
functions unwieldy.  More practically, the "Classified_commands"
topic contains commands grouped by their functionality.

ADD         - Adds two NDF data structures.
APERADD     - Derives statistics of pixels within a specified circle
              of a 2-d data array.
ARDGEN      - Creates a text file describing selected regions of an
              image.
ARDMASK     - Uses an ARD file to set some pixels of an NDF to be
              bad.
ARDPLOT     - Draws outlines of regions described in an ARD file.
AXCONV      - Expands spaced axes in an NDF into the primitive form.
AXLABEL     - Sets a new label value for an axis within an NDF data
              structure.
AXUNITS     - Sets a new units value for an axis within an NDF data
              structure.
BLOCK       - Smooths a 1- or 2-dimensional image using a square or
              rectangular box filter.
CADD        - Adds a scalar to an NDF data structure.
CALC        - Evaluates a mathematical expression.
CALPOL      - Calculates polarisation parameters.
CDIV        - Divides an NDF by a scalar.
CENTROID    - Finds the centroids of star-like features in an NDF.
CHAIN	    -  Concatenates a series of vectorized NDFs.
CHPIX       - Replaces the values of selected pixels in an NDF.
CMULT       - Multiplies an NDF by a scalar.
COMPADD     - Reduces the size of an NDF by adding values in
              rectangular boxes.
COMPAVE     - Reduces the size of an NDF by averaging values in
              rectangular boxes.
COMPICK     - Reduces the size of an NDF by picking equally spaced
              pixels.
CONTOUR     - Contours a 2-d NDF.
CONVOLVE    - Convolves a pair of 1- or 2-dimensional NDFs together.
COPYBAD	    - Copies the bad pixel mask from one NDF to another.
CREFRAME    - Generates a test 2-d data array from a selection of
              several types.
CRELUT      - Creates or manipulates an image-display lookup table
              using a palette.
CSUB        - Subtracts a scalar from an NDF data structure.
CURSOR      - Reports the co-ordinates of points selected using the
              cursor.
DISPLAY     - Displays a 1-d or 2-d NDF.
DIV         - Divides one NDF data structure by another.
DRAWSIG     - Draws +/-n standard-deviation lines on a line plot.
ELPROF      - Creates a radial or azimuthal profile of a
              2-dimensional image.
ERASE       - Erases an HDS object.
ERRCLIP     - Removes pixels with large errors from an NDF.
EXP10       - Takes the base-10 exponential of each pixel of an NDF.
EXPE        - Takes the exponential of each pixel of an NDF (base e).
EXPON       - Takes the exponential of each pixel  of a data array.
FFCLEAN     - Removes defects from a substantially flat 1- or
              2-dimensional NDF.
FILLBAD     - Removes regions of bad values from a 2-dimensional NDF.
FITSDIN     - Reads a FITS disc file composed of simple, group or
              table objects.
FITSEDIT    - Edits the FITS extension of an NDF.
FITSEXIST   - Inquires whether or not a keyword exists in a FITS
              extension.
FITSEXP     - Exports NDF-extension information into an NDF FITS
              extension.
FITSHEAD    - Lists the headers of FITS files.
FITSIMP     - Imports FITS information into an NDF extension.
FITSIN      - Reads a FITS tape composed of simple, group or table
              files.
FITSLIST    - Lists the FITS extension of an NDF.
FITSMOD     - Edits an NDF FITS extension via a text file or
              parameters.
FITSTEXT    - Creates an NDF FITS extension from a text file.
FITSURFACE  - Fits a polynomial surface to 2-dimensional data array.
FITSVAL     - Reports the value of a keyword in the FITS extension.
FITSWRITE   - Writes a new keyword to the FITS extension.
FLIP        - Reverses an NDF's pixels along a specified dimension.
FOURIER     - Performs forward and inverse Fourier transforms of
              1- or 2-dimensional NDFs.
GAUSMOOTH   - Smooths a 1- or 2-dimensional image using a Gaussian
              filter.
GDCLEAR     - Clears a graphics device and purges its database
              entries.
GDNAMES     - Shows which graphics devices are available.
GDSET       - Selects a current graphics device.
GDSTATE     - Shows the current status of a graphics device.
GLITCH      - Replaces bad pixels in a 2-d NDF with the local median.
GLOBALS     - Displays the values of the KAPPA global parameters.
HISCOM      - Adds commentary to the history of an NDF.
HISLIST     - Lists NDF history records.
HISSET      - Sets the NDF history update mode.
HISTAT      - Computes ordered statistics for an NDF's pixels using
              an histogram.
HISTEQ      - Performs an histogram equalisation on an NDF.
HISTOGRAM   - Computes an histogram of an NDF's values.
IDCLEAR     - Clears an image display and purges its database
              entries.
IDINVISIBLE - Makes memory planes of an image-display device
              invisible.
IDPAZO      - Pans and zooms an image-display device.
IDSET       - Selects a current image-display device.
IDSTATE     - Shows the current status of an image display.
KAPHELP     - Gives help about KAPPA.
KSTEST      - Compares data sets using the Kolmogorov-Smirnov test.
LAPLACE     - Performs a Laplacian convolution as an edge detector
              in a 2-d data array.
LINPLOT     - Draws a line plot of a 1-d NDF's data values against
              their axis co-ordinates.
LISTMAKE    - Create a catalogue holding a positions list.
LISTSHOW    - Reports the positions stored in a positions list.
LOG10       - Takes the base-10 logarithm of each pixel of an NDF.
LOGAR       - Takes the logarithm of each pixel of an NDF (specified base).
LOGE        - Takes the natural logarithm of each pixel of an NDF.
LOOK        - Outputs the values of a sub-array of a 2-d data array
              to the screen or a text file.
LUCY        - Performs a Richardson-Lucy deconvolution of a 1- or
              2-dimensional array.
LUTABLE     - Manipulates an image-display colour table.
LUTBGYRW    - Loads the BGYRW lookup table.
LUTCOL      - Loads the standard colour lookup table.
LUTCONT     - Loads a lookup table to give the display the
              appearance of a contour plot.
LUTFC       - Loads the standard false-colour lookup table.
LUTFLIP     - Flips the colour table of an image-display device.
LUTGREY     - Loads the standard greyscale lookup table.
LUTHEAT     - Loads the heat lookup table.
LUTHILITE   - Highlights a colour table of an image-display device.
LUTIKON     - Loads the default Ikon lookup table.
LUTNEG      - Loads the standard negative greyscale lookup table.
LUTRAMPS    - Loads the coloured-ramps lookup table.
LUTREAD     - Loads an image-display lookup table from an NDF.
LUTROT      - Rotates the colour table of an image-display device.
LUTSAVE     - Saves the current colour table of an image-display
              device in an NDF.
LUTSPEC     - Loads a spectrum-like lookup table.
LUTTWEAK    - Tweaks a colour table of an image-display device.
LUTVIEW     - Draws a colour-table key.
LUTWARM     - Loads the warm lookup table.
LUTZEBRA    - Loads a pseudo-contour lookup table.
MAKESURFACE - Creates a 2-dimensional NDF from the coefficients of
              a polynomial surface.
MANIC       - Converts all or part of a data array from one
              dimensionality to another.
MATHS       - Evaluates mathematical expressions applied to NDF
              data structures.
MEDIAN      - Smooths a 2-dimensional data array using a weighted
              median filter.
MEM2D       - Performs a Maximum-Entropy deconvolution of a
              2-dimensional NDF.
MLINPLOT    - Draws a multi-line plot of a 2-d NDF's data values
              against their axis co-ordinates.
MSTATS      - Does cumulative statistics on a 2-d sub-array over a
              sequence of data arrays.
MULT        - Multiplies two NDF data structures.
NATIVE      - Converts an HDS object to native machine data
              representation.
NDFCOPY     - Copies an NDF (or NDF section) to a new location.
NDFTRACE    - Displays the attributes of an NDF data structure.
NOGLOBALS   - Resets the KAPPA global parameters.
NOMAGIC     - Replaces all occurrences of magic value pixels in an
              NDF array with a new value.
NORMALIZE   - Normalises one NDF to a similar NDF by calculating a
              scale factor and zero difference.
NUMB        - Counts the number of elements of an NDF with values or
              absolute values above or below a threshold.
OUTSET      - Sets pixels outside a specified circle in a 2-d data
              array to a specified value.
OVCLEAR     - Clears an image-display overlay.
OVSET       - Selects a current image-display overlay.
PALDEF      - Loads the default palette to a colour table.
PALENTRY    - Enters a colour into an image display's palette.
PALREAD     - Fills the palette of a colour table from an NDF.
PALSAVE     - Saves the current palette of a colour table to an NDF.
PARGET      - Obtains the value or values of an application
              parameter.
PASTE       - Pastes a series of NDFs upon each other.
PERMAXES    - Permute the axes of an NDF
PICBASE     - Selects the BASE picture from the graphics database.
PICCUR      - Uses a cursor to select the current picture and to
              report the co-ordinates of points.
PICDATA     - Selects the last DATA picture from the graphics
              database.
PICDEF      - Defines a new graphics-database FRAME picture or an
              array of FRAME pictures.
PICEMPTY    - Finds the first empty FRAME picture in the graphics
              database.
PICENTIRE   - Finds the first unobscured and unobscuring FRAME
              picture in the graphics database.
PICFRAME    - Selects the last FRAME picture from the graphics
              database.
PICGRID     - Creates an array of FRAME pictures.
PICIN       - Finds the attributes of a picture interior to the
              current picture.
PICLABEL    - Labels the current graphics-database picture.
PICLAST     - Selects the last picture from the graphics database.
PICLIST     - Lists the pictures in the graphics database for a
              device.
PICSEL      - Selects a graphics-database picture by its label.
PICTRANS    - Transforms co-ordinates between the current and BASE
              pictures.
PICVIS      - Finds the first unobscured FRAME picture in the
              graphics database.
PICXY       - Creates a new picture defined by co-ordinate bounds.
PIXDUPE     - Expands an NDF by pixel duplication.
POW         - Takes the specified power of each pixel of a data
              array.
PROFILE	    -  Creates a 1-d profile through an N-d NDF.
PSF         - Determines the parameters of a model star profile by
              fitting star images in a two-dimensional NDF.
RESHAPE	    -  Reshapes an NDF, treating its arrays as vectors.
RIFT        - Adds a scalar to a section of an NDF data structure
              to correct rift-valley defects.
ROTATE      - Rotates a 2-dimensional NDF about its centre through
              any angle.
SCATTER     - Displays a scatter plot between data in 2 n-dimensional NDFs.
SEGMENT     - Copies polygonal segments from one NDF to another.
SETAXIS     - Sets values for an axis array component within an NDF
              data structure.
SETBAD      - Sets new bad-pixel flag values for an NDF.
SETBB       - Sets a new value for the quality bad-bits mask of an NDF.
SETBOUND    - Sets new bounds for an NDF.
SETEXT      - Manipulates the contents of a specified NDF extension.
SETLABEL    - Sets a new label for an NDF data structure.
SETMAGIC    - Replaces all occurrences of a given value in an NDF
              array with the bad value.
SETNORM     - Sets a new value for one or all of an NDF's
              axis-normalisation flags.
SETORIGIN   - Sets a new pixel origin for an NDF.
SETSKY      - Makes an IRAS astrometry extension.
SETTITLE    - Set a new title for an NDF data structure.
SETTYPE     - Sets a new numeric type for the data and variance
              components of an NDF.
SETUNITS    - Sets a new units value for an NDF data structure.
SETVAR      - Sets new values for the variance component of an NDF
              data structure.
SHADOW      - Enhances edges in a 2-dimensional NDF using a shadow
              effect.
SLIDE       - Realigns a 2-d data array via an $x$-$y$ shift.
SQORST      - Squashes or stretches a 2-d data array in either or
              both axes.
STATS       - Computes simple statistics for an NDF's pixels.
SUB         - Subtracts one NDF data structure from another.
SUBSTITUTE  - Replaces all occurrences of a given value in an NDF
              array with another value.
SURFIT      - Fits a polynomial or spline surface to a 2-d data
              array using blocking.
THRESH      - Edits an NDF such that array values below and above
              two thresholds take constant values.
TRANDAT     - Converts free-format text data into an NDF.
TRANINVERT  - Inverts a transformation.
TRANJOIN    - Joins two transformations.
TRANMAKE    - Makes a transformation structure given its
              co-ordinate mappings.
TRANSFORMER - Applies a transformation to an NDF.
TRANTRACE   - Lists the contents of a transformation structure.
TRIG        - Performs a trigonometric transformation on a data
              array.
VECPLOT     - Plots a 2-dimensional vector map.
WCSADD	    -  Adds a new co-ordinate Frame into the WCS component of an NDF.
WCSALIGN    -  Aligns a group of 2-d NDFs using WCS information.
WCSATTRIB   -  Manages attribute values associated with the WCS component of an NDF.
WCSCOPY	    -  Copies WCS information from one NDF to another.
WCSFRAME    - Changes the current co-ordinate Frame in the WCS component of an NDF.
WCSREMOVE   -  Removes co-ordinate Frames from the WCS component of an NDF.
WCSTRAN	    -  Transforms a position from one NDF co-ordinate Frame to another.
WIENER      - Applies a Wiener filter to a 1- or 2-dimensional
              array.
ZAPLIN      - Replaces regions in a 2-d NDF by bad values or by
              linear interpolation.

1 SURFIT
Fits a polynomial or bi-cubic spline surface to 2-dimensional
data array.

Usage:

   surfit in out [fittype] [estimator] [bindim] [evaluate]

Description:

   The background of a 2-dimensional data array in the supplied NDF
   structure is estimated by condensing the array into equally sized
   rectangular bins, fitting a spline or polynomial surface to the
   bin values, and finally evaluating the surface for each pixel in
   the data array.

   There is a selection of estimators by which representative
   values for each bin are determined.  There are several options to
   make the fit more accurate.  Values beyond upper and lower
   thresholds may be excluded from the binning.  Bad pixels are also
   excluded, so prior masking may help to find the background more
   rapidly.  Kappa-sigma clipping of the fitted bins is available
   so that the fit is not biased by anomalous bins, such as those
   entirely within an extended object.  If a given bin contains more
   than a prescribed fraction of bad pixels, it is excluded from the
   fit.

   The data array representing the background is evaluated at each
   pixel by one of two methods.  It is written to the output NDF
   structure.

   The raw binned data, the weights, the fitted binned data and the
   residuals to the fit may be written to a logfile.  This also
   keeps a record of the input parameters and the rms error of the
   fit.
2 Parameters
For information on individual parameters, select from the list below:
3 BINDIM
BINDIM() = _INTEGER (Read)
   The x-y dimensions of a bin used to estimate the local
   background.  If you supply only one value, it is used for
   both dimensions.  The minimum value is 2.  The maximum may be
   constrained by the number of polynomial terms, such that in
   each direction there are at least as many bins as terms.  The
   default is dynamic such that 32 bins are created along each
   axis. []
3 CLIP
CLIP() = _REAL (Read)
   Array of limits for progressive clipping of pixel values
   during the binning process in units of standard deviation.  A
   null value means only unclipped statistics are computed and
   presented.  Between 1 and 5 values may be supplied. [2,3]
3 ESTIMATOR
ESTIMATOR = LITERAL (Read)
   The estimator for the bin.  It must one of the following
   values: "Mean" for the mean value, "Ksigma" for the mean with
   kappa-sigma clipping; "Mode" for the mode, and "Median" for
   the median.  "Mode" is only available when there are at least
   twelve pixels in a bin.  It is also the default when this
   criterion is met, other the default is "Median". []
3 EVALUATE
EVALUATE = LITERAL (Read)
   The method by which the resulting data array is to be
   evaluated from the surface-fit.  It must be either
   "Interpolate" where the values at the corners of the bins are
   derived first, and then the pixel values are found by linear
   interpolation within those bins; or "All" where the
   surface-fit is evaluated for every pixel.  The latter is
   slower, but can produce more-accurate results, unless the
   surface is well behaved.  The default is the current value,
   which is initially set to "Interpolate". []
3 FITCLIP
FITCLIP() = _REAL (Read)
   Array of limits for progressive clipping of the binned array
   in units of the rms deviation of the fit.  A null value (!)
   means no clipping of the binned array will take place.
   Between 1 and 5 values may be supplied.  The default is the
   current value, which is ! initially. []
3 FITTYPE
FITTYPE = LITERAL (Read)
   The type of fit.  It must be either "Polynomial" for a
   Chebyshev polynomial or "Spline" for a bi-cubic spline.  The
   default is the current value, which initially is "Spline". []
3 LOGFILE
LOGFILE = FILENAME (Read)
   Name of the file to log the binned array and errors before and
   after fitting.  If null, there will be no logging. [!]
3 IN
IN = NDF (Read)
   NDF containing the 2-dimensional data array to be fitted.
3 KNOTS
KNOTS( 2 ) = _INTEGER (Read)
   The number of interior knots used for the bi-cubic-spline fit
   along the x and y axes.  These knots are equally spaced within
   the image.  Both values must be in the range 0 to 11.  If you
   supply a single value, it applies to both axes.  Thus 1
   creates one interior knot, [5,4] gives 5 along the x axis and
   4 along the y direction.  Increasing this parameter values
   increases the flexibility of the surface.  Normally, 4 is a
   reasonable value.  The upper limit of acceptable values will
   be reduced along each axis when its binned array dimension is
   less than 29.  KNOTS is only accessed when FITTYPE="Spline".
   The default is the current value, which is 4 initially. []
3 ORDER
ORDER( 2 ) = _INTEGER (Read)
   The orders of the fits along the x and y directions.  Both
   values must be in the range 0 to 14.  If you supply a single
   single value, it applies to both axes.  Thus 0 gives a
   constant, [3,1] gives a cubic along the x direction and a
   linear fit along the y.  Increasing this parameter values
   increases the flexibility of the surface.  The upper limit of
   acceptable values will be reduced along each axis when its
   binned array dimension is less than 29.  ORDER is only
   accessed when FITTYPE="Polynomial".  The default is the current
   value, which is 4 initially. []
3 OUT
OUT = NDF (Write)
   NDF to contain the fitted 2-dimensional data array.
3 RMS
RMS = _REAL (Write)
   An output parameter in which is stored the RMS deviation of the 
   fit from the original data (per pixel).
3 THRHI
THRHI = _REAL (Read)
   Upper threshold above which values will be excluded from the
   analysis to derive representative values for the bins.  If it
   is null (!) there will be no upper threshold. [!]
3 THRLO
THRLO = _REAL (Read)
   Lower threshold below which values will be excluded from the
   analysis to derive representative values for the bins.  If it
   is null (!) there will be no lower threshold. [!]
3 TITLE
TITLE = LITERAL (Read)
   Value for the title of the output NDF.  A null value will cause
   the title of the NDF supplied for parameter IN to be used
   instead. [!]
3 WLIM
WLIM = _REAL (Read)
   The minimum fraction of good pixels in a bin that permits the
   bin to be included in the fit.  Here good pixels are ones that
   participated in the calculation of the bin's representative
   value. So they exclude both bad pixels and ones rejected
   during estimation (e.g. ones beyond the thresholds or were
   clipped). [!]
2 Examples
surfit comaB comaB_bg
   This calculates the surface fit to the 2-dimensional NDF
   called comaB using the current defaults.  The evaluated fit is
   stored in the NDF called comaB_bg.

surfit comaB comaB_bg poly median order=5 bindim=[24,30]
   As above except that 5th-order polynomial fit is chosen,
   the median is used to derive the representative value for each
   bin, and the binning size is 24 pixels along the first axis,
   and 32 pixels along the second.

surfit comaB comaB_bg fitclip=[2,3] logfile=comaB_fit.lis
   As the first example except that the binned array is clipped at
   2 then 3 standard deviations to remove outliers before the
   final fit is computed.  The text file comaB_fit.lis records a
   log of the surface fit.

surfit comaB comaB_bg estimator=ksigma clip=[2,2,3]
   As the first example except that the representative value of
   each bin is the mean after clipping twice at 2 then once at
   3 standard deviations.

surfit in=irasorion out=sback evaluate=all fittype=s knots=7
   This calculates the surface fit to the 2-dimensional NDF called
   irasorion.  The fit is evaluated at every pixel and the
   resulting array stored in the NDF called sback.  A spline with
   seven knots along each axis is used to fit the surface.
2 Related_Applications
   KAPPA: ARDMASK, FITSURFACE, MAKESURFACE.
2 Authors
MJC: Malcolm J. Currie (STARLINK).

DSB: David S. Berry (STARLINK)
2 History
 1996 October 23 (MJC):
    Original NDF version.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   LABEL, TITLE, UNITS, WCS and HISTORY components of the input NDF.
   There is no support for VARIANCE processing.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.  Arithmetic
   is performed using single- or double-precision floating point for
   FITTYPE = "Spline" or "Polynomial" respectively.
1 THRESH
Edits an NDF to replace values between or outside given limits
with specified constant values.

Usage:

   thresh in out thrlo thrhi newlo newhi [comp]

Description:

   This application creates an output NDF by copying values from an
   input NDF, replacing all values within given data ranges by
   a user-specified constant or by the bad value. Upper and lower
   thresholds are supplied using parameters THRLO and THRHI.

   If THRLO is less than or equal to THRHI, values between and
   including the two thresholds are copied from the input to output
   array.  Any values in the input array greater than the upper
   threshold will be set to the value of parameter NEWHI, and anything
   less than the lower threshold will be set to the value of parameter
   NEWLO, in the output data array. Thus the output NDF is constrained
   to lie between the two bounds.

   If THRLO is greater than THRHI, values greater than or equal to
   THRLO are copied from the input to output array, together with
   values less than or equal to THRHI.  Any values between THRLO and
   THRHI will be set to the value of parameter NEWLO in the output NDF.

   Each replacement value may be the bad-pixel value for masking.
2 Parameters
For information on individual parameters, select from the list below:
3 COMP
COMP = LITERAL (Read)
   The components whose values are to be constrained between
   thresholds.  The options are limited to the arrays within the
   supplied NDF.  In general the value may be "Data", "Quality",
   "Error", or "Variance".  If "Quality" is specified, then the
   quality values are treated as numerical values in the range 0
   to 255.  ["Data"]
3 IN
IN = NDF  (Read)
   Input NDF structure containing the array to have thresholds
   applied.
3 NEWLO
NEWLO = LITERAL (Read)
   This gives the value to which all input array-element values
   less than the lower threshold are set.  If this is set to
   "Bad", the bad value is substituted.  Numerical values of
   NEWLO must lie in within the minimum and maximum values of the
   data type of the array being processed.  The suggested default
   is the lower threshold.
3 NEWHI
NEWHI = LITERAL (Read)
   This gives the value to which all input array-element values
   greater than the upper threshold are set.  If this is set to
   "Bad", the bad value is substituted.  Numerical values of
   NEWHI must lie in within the minimum and maximum values of the
   data type of the array being processed.  The suggested default
   is the upper threshold. This parameter is ignored if THRLO is
   greater than THRHI.
3 OUT
OUT = NDF (Write)
   Output NDF structure containing the thresholded version of
   the array.
3 THRHI
THRHI = _DOUBLE (Read)
   The upper threshold value within the input array.  It must lie
   in within the minimum and maximum values of the data type of
   the array being processed.  The suggested default is the
   current value.
3 THRLO
THRLO = _DOUBLE (Read)
   The lower threshold value within the input array.  It must lie
   within the minimum and maximum values of the data type of
   the array being processed.  The suggested default is the
   current value.
3 TITLE
TITLE = LITERAL (Read)
   Title for the output NDF structure.  A null value (!)
   propagates the title from the input NDF to the output NDF. [!]
2 Examples
thresh zzcam zzcam2 100 500 0 0
   This copies the data array in the NDF called zzcam to the NDF
   called zzcam2.  Any data value less than 100 or greater than
   500 in zzcam is set to 0 in zzcam2.

thresh zzcam zzcam2 500 100 0
   This copies the data array in the NDF called zzcam to the NDF
   called zzcam2.  Any data value less than 500 and greater than
   100 in zzcam is set to 0 in zzcam2.

thresh zzcam zzcam2 100 500 0 0 comp=Variance
   As above except that the data array is copied unchanged and the
   thresholds apply to the variance array.

thresh n253 n253cl thrlo=-0.5 thrhi=10.1 \
   This copies the data array in the NDF called n253 to the NDF
   called n253cl.  Any data value less than -0.5 in n253 is set
   to -0.5 in n253cl, and any value greater than 10.1 in n253
   becomes 10.1 in n253cl.

thresh pavo pavosky -0.02 0.02 bad bad
   All data values outside the range -0.02 to 0.02 in the NDF
   called pavo become bad in the NDF called pavosky.  All values
   within this range are copied from pavo to pavosky.
2 Related_Applications
   KAPPA: HISTEQ, MATHS; Figaro: CLIP, IDIFF, RESCALE.
2 Authors
MJC: Malcolm J. Currie  (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 1991 November 6 (MJC):
    Original NDF_ version.

 1994 September 26 (MJC):
    TITLE propagated from input NDF by default.  Lowercase examples
    and usage.

 1996 April 11 (MJC):
    Use the bad-pixel flag.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.

 6-DEC-2000 (DSB):
    Allow THRLO to be greater than THRHI in order to exclude a range
    of data values.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   VARIANCE, LABEL, TITLE, UNITS, WCS and HISTORY components of an NDF
   data structure and propagates all extensions.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.

   -  Any number of NDF dimensions is supported.
1 TRANDAT
Converts free-format text data into an NDF.

Usage:

   trandat freename out [poscols] [valcol] [pscale] [dtype] [title]

Description:

   This application takes grid data contained in a free-format text
   file and stores them in the data array of an NDF.  The data file
   could contain, for example, mapping data  or results from
   simulations which are to be converted into an image for analysis.

   There are two modes of operation which depend on whether the
   text file contains co-ordinate information, or solely data
   values (determined by parameter AUTO).

   a) AUTO=FALSE   If the file contains co-ordinate information the
   format of the data is tabular; the positions and values are
   arranged in columns and a record may contain information for only
   a single point.  Where data points are duplicated only the last
   value appears in the NDF.  Comment lines can be given, and are
   indicated by a hash or exclamation mark in the first column.
   Here is an example file (the vertical ellipses indicate missing
   lines in the file):

       # Model 5, phi = 0.25,  eta = 1.7
       1 -40.0   40.0   1121.9
       2  0.0   30.0     56.3
       3 100.0   20.0   2983.2
       4 120.0   85.0    339.3
       .    .      .       .
       .    .      .       .
       .    .      .       .
       <EOF>

   The records do not need to be ordered (but see the warning in the
   Notes), as the application searches for the maximum and minimum
   co-ordinates in each dimension so that it can define the size of
   the output image.  Also, each record may contain other data
   fields (separated by one or more spaces), which need not be all
   the same data type.  In the example above only columns 2, 3 and 4
   are required.  There are parameters (POSCOLS, VALCOL) which
   select the co-ordinate and value columns.

   The distance between adjacent pixels (given by parameter PSCALE)
   defaults to 1, and is in the same units as the read-in
   co-ordinates.  The pixel index of a data value is calculated
   using the expression

      index = IFIX( ( x - xmin ) / scale ) + 1

   where x is the supplied co-ordinate and xmin is the minimum
   supplied co-ordinate along an axis, scale is the value of
   parameter PSCALE, and IFIX converts from real to integer.

   You are informed of the number of points found and the maximum
   and minimum co-ordinate values for each dimension.  There is no
   limit imposed by the application on the number of points or the
   maximum output array size, though there may be external
   constraints.  The derived array size is reported in case you have
   made a typing error in the text file.  If you realise that this
   has indeed occurred just abort (!!) when prompted for the output
   NDF.

   b) AUTO=TRUE   If the text file contains no co-ordinates, the
   format is quite flexible, however, the data are read into the
   data array in Fortran order, i.e. the first dimension is the most
   rapidly varying, followed by the second dimension and so on.  The
   number of data values that may appear on a line is variable; data
   values are separated by at least a space, comma, tab or carriage
   return.  A line can have up to 255 characters.  In addition a
   record may have trailing comments designated by a hash or
   exclamation mark.  Here is an example file, though a more regular
   format would be clearer for the human reader.

       # test for the new TRANDAT
       23 45.3 ! a comment
       50.7,47.5 120. 46.67  47.89 42.4567
       .1 23.3 45.2 43.2  56.0 30.9 29. 27. 26. 22.4 20. 18. -12. 8.
        9.2 11.
       <EOF>

   Notice that the shape of the NDF is defined by a parameter rather
   than explicitly in the file.
2 Parameters
For information on individual parameters, select from the list below:
3 AUTO
AUTO = _LOGICAL (Read)
   If TRUE the text file does not contain co-ordinate
   information. [FALSE]
3 BAD
BAD = _LOGICAL (Read)
   If TRUE the output NDF data array is initialised with the
   bad value, otherwise it is filled with zeroes. [TRUE]
3 DTYPE
DTYPE = LITERAL (Read)
   The HDS type of the data values within the text file, and
   the type of the data array in the output NDF. The options
   are: '_REAL', '_DOUBLE', '_INTEGER', '_BYTE', '_UBYTE',
   '_WORD', '_UWORD'. (Note the leading underscore.) ['_REAL']
3 FREENAME
FREENAME = FILENAME (Read)
   Name of the text file containing the free-format data.
3 LBOUND
LBOUND( ) = _INTEGER (Read)
   The lower bounds of the NDF to be created.  The number of
   values must match the number supplied to parameter SHAPE.  It
   is only accessed in automatic mode.  It defaults to 1 along
   each axis. []
3 POSCOLS
POSCOLS() = _INTEGER (Read)
   Column positions of the co-ordinates in an input record
   of the text file, starting from x to higher dimensions.  It
   is only used in co-ordinate mode.  The columns must be
   different amongst themselves and also different from the
   column containing the values.  If there is duplication,
   new values for both POSCOLS and VALCOL will be requested.
   [1,2]
3 PSCALE
PSCALE() = _REAL (Read)
   Pixel-to-pixel distance in co-ordinate units for each
   dimension.  It is only used in co-ordinate mode.  Its purpose
   is to permit linear scaling from some arbitrary units to
   pixels. [1.0 in each co-ordinate dimension]
3 QUANTUM
QUANTUM = _INTEGER (Read)
   You can safely ignore this parameter.  It is used for fine-
   tuning performance in the co-ordinate mode.

   The application obtains work space to store the position-value
   data before they can be copied into the output NDF so that the
   array bounds can be computed.  Since the number of lines in
   the text file is unknown, the application obtains chunks of
   work space whose size is three times this parameter whenever
   it runs out of storage.  (Three because the parameter
   specifies the number of lines in the file rather than the
   number of data items.)  If you have a large number of points
   there are efficiency gains if you make this parameter either
   about 20--30 per cent or slightly greater than or equal to the
   number of lines your text file.  A value slightly less than
   the number of lines is inefficient as it creates nearly 50 per
   cent unused space.  A value that is too small can cause
   unnecessary unmapping, expansion and re-mapping of the work
   space.  For most purposes the default should give acceptable
   performance.  It must lie between 32 and 2097152. [2048]
3 SHAPE
SHAPE( ) = _INTEGER (Read)
   The shape of the NDF to be created.  For example, [50,30,20]
   would create 50 columns by 30 lines by 10 bands.  It is only
   accessed in automatic mode.
3 NDF
NDF = NDF (Write)
   Output NDF for the generated data array.
3 TITLE
TITLE = LITERAL (Read)
   Title for the output NDF. ["KAPPA - Trandat"]
3 VALCOL
VALCOL = _INTEGER (Read)
   Column position of the array values in an input record of
   the text file.  It is only used in co-ordinate mode.  The
   column position must be different from those specified for
   the co-ordinate columns.  If there is duplication, new values
   for both POSCOLS and VALCOL will be requested. [3]
2 Examples
trandat simdata.dat model
   Reads the text file simdata.dat and stores the data into the
   data array of a two-dimensional, _REAL NDF called model.  The
   input file should have the co-ordinates and real values
   arranged in columns, with the x-y positions in columns 1 and 2
   respectively, and the real data in column 3.

trandat freename=simdata out=model auto shape=[50,40,9]
   Reads the text file simdata and stores the data into the data
   array of a three-dimensional, _REAL NDF called model.  Its x
   dimension is 50, y is 40 and z is 9.  The input file only
   contains real values and comments.

trandat freename=simdata out=model auto shape=[50,40,9] dtype=_i
   As the previous example except an _INTEGER NDF is created, and
   the text file must contain integer data.

trandat simdata.dat model [6,3,4] 2
   Reads the text file simdata.dat and stores the data into the
   data array of a three-dimensional, _REAL NDF called model.  The
   input file should have the co-ordinates and real values
   arranged in columns, with the x-y-z positions in columns 6, 3
   and 4 respectively, and the real data in column 2.

trandat spectrum.dat lacertid noauto poscols=2 valcol=4 pscale=2.3
   Reads the text file spectrum.dat and stores the data into the
   data array of a one-dimensional, _REAL NDF called lacertid.
   The input file should have the co-ordinate and real values
   arranged in columns, with its co-ordinates in columns 2, and
   the real data in column 4.  A one-pixel step in the NDF
   corresponds to 2.3 in units of the supplied co-ordinates.
2 Notes
-  All non-complex numeric data types can be handled.  However,
byte, unsigned byte, word and unsigned word require data
conversion, and therefore involve additional processing.
to a vector element (for n-d generality).

-  WARNING: In non-automatic mode it is strongly advisable for
large output NDFs to place the data in Fortran order, i.e. the
first dimension is the most rapidly varying, followed by the
second dimension and so on.  This gives optimum performance.  The
meaning of "large" will depend on working-set quotas on your
system, but a few megabytes gives an idea.  If you jump randomly
backwards and forwards, or worse, have a text file in reverse-
Fortran order, this can have disastrous performance consequences
for you and other users.

-  In non-automatic mode, the co-ordinates for each dimension are
stored in the NDF axis structure.  The first centre is at the
minimum value found in the list of positions for the dimension
plus half of the scale factor.  Subsequent centres are
incremented by the scale factor.

-  The output NDF may have between one and seven dimensions.

-  In automatic mode, an error is reported if the shape does not
use all the data points in the file.
2 Related_Applications
   CONVERT: ASCII2NDF, NDF2ASCII; FIGARO: ASCIN, ASCOUT.
2 Authors
MJC: Malcolm J. Currie  (STARLINK)
2 History
 1990 June 15 (MJC):
    Original NDF version, derived from the previous non-NDF
    routine of the same number, featuring generic data processing
    and n-d arrays.

 1991 May 27 (MJC):
    Writes axis centres to the NDF in co-ordinate mode.

 1991 July 25 (MJC):
    Output NDF parameter now called NDF for consistency with other
    applications.

 1992 March 3 (MJC):
    Replaced AIF parameter-system calls by the extended PAR
    library.

 1995 November 16 (MJC):
    Added LBOUND parameter, and creates simple rather than
    primitive NDFs.

 1996 November 14 (MJC):
    Added a final error report, and improved the documentation.
1 TRANINVERT
Inverts a transformation.

Usage:

   traninvert transform

Description:

   This inverts a transformation stored in the TRANSFORM (SUN/61)
   format within an existing HDS file.
2 Parameters
For information on individual parameters, select from the list below:
3 TRANSFORM
TRANSFORM = TRN (Read and Write)
   The transformation structure to be inverted.  This may be an
   HDS container file, in which case the transformation structure
   is assumed to be called TRANSFORM at the top level of the
   file; or a path to the HDS object.  The suggested default is
   the current transformation structure.
2 Examples
traninvert shear.transform
   This inverts the transformation structure stored in object
   TRANSFORM within the HDS file called shear.

traninvert shear
   This does the same as above.

traninvert \
   This inverts the current transformation structure.

traninvert m51.more.polar
   This inverts the transformation structure called POLAR in
   the extension of the NDF called m51.
2 Notes
-  On completion, the destination structure for the
transformation information equates to the current transformation
global parameter.
2 Related_Applications
   KAPPA: TRANSFORMER, TRANJOIN, TRANMAKE, TRANTRACE;
   CCDPACK: CCDEDIT, TRANLIST, TRANNDF.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1995 March 9 (MJC):
    Original version.
1 TRANJOIN
Joins two transformations.

Usage:

   tranjoin in1 in2 out dest=?

Description:

   This joins two transformations stored in the TRANSFORM (SUN/61)
   format.  The concatenated transformation can be stored with either
   original transformation or be placed in a new file.
2 Parameters
For information on individual parameters, select from the list below:
3 DEST
DEST = LITERAL (Read)
   The destination for the concatenated transformations.  This can
   be one of the following:
      "First"  -  Appends the second transformation in the first.
                  The second transformation is unchanged.
      "Second" -  Prefixes the first transformation in the second.
                  The first transformation is unchanged.
      "New"    -  Creates a new transformation structure using
                  parameter OUT.  The input transformations are
                  unchanged.
   ["New"]
3 IN1
IN1 = TRN (Read and Write)
   The first transformation structure to be concatenated.  It
   prefixes the second supplied transformation.  This may be an
   HDS container file, in which case the transformation structure
   is assumed to be called TRANSFORM at the top level of the
   file; or a path to the HDS object.  The suggested default is
   the current value.
3 IN2
IN2 = TRN (Read and Write)
   The second transformation structure to be concatenated.  It
   appends to the first supplied transformation.  This may be an
   HDS container file, in which case the transformation structure
   is assumed to be called TRANSFORM at the top level of the
   file; or a path to the HDS object.  The suggested default is
   the current value.
3 OUT
OUT = TRN (Write)
   The path to the new transformation structure created when
   DEST="NEW" to hold the concatenated transformations.  If only
   an HDS container filename is supplied, the transformation is
   placed within a structure called TRANSFORM at the top-level of
   the file.  So for instance, if OUT=warp9, the transformation
   will be placed in the top-level structure TRANSFORM within
   the file warp9.sdf.  In this case the container file may
   already exist.  If, on the other hand, an explicit structure
   is named, the transformation information will be placed there.
   For example, to place the transformation in the extension
   GALPHOT of the NDF called NGC253, OUT would be
   NGC253.MORE.GALPHOT.  The structure name is limited to 15
   printing characters.  Note that the structure must not already
   exist.  If it does, an error condition results.
2 Examples
tranjoin tr1 tr2 tr3
   This prefixes the transformation in the HDS file called
   tr1.sdf to that in file tr2.sdf, and stores the result in HDS
   file tr3.sdf.  All three transformations are located within
   objects called TRANSFORM at the top-level.

tranjoin offset shear.tr1 shape.rotate
   This prefixes the transformation in the structure TRANSFORM at
   the top level of the HDS container file called offset.sdf
   (i.e.  OFFSET.TRANSFORM) to the transformation in the
   structure TR1 in the HDS file shear.sdf.  The resulting
   transformation is in the file called shape.sdf and is named
   ROTATE.

tranjoin norm.scale1 polar dest=S
   This prefixes the transformation structure NORM.SCALE1 to
   POLAR.TRANSFORM, the concatenation being stored in
   POLAR.TRANSFORM.

tranjoin norm.scale1 polar dest=f
   This appends the transformation structure POLAR.TRANSFORM to
   NORM.SCALE1, the concatenation being stored in NORM.SCALE1.
2 Notes
-  The number of output variables of the first transformation must
equal the number of input variables of the second.  Also it is not
permitted to concatenate a transformation in which only the
forward mapping is defined with another in which only the inverse
mapping is specified.

-  On completion, the destination structure for the
transformation information equates to the current transformation
global parameter.
2 Related_Applications
   KAPPA: TRANSFORMER, TRANINVERT, TRANMAKE, TRANTRACE;
   CCDPACK: CCDEDIT, TRANLIST, TRANNDF.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1995 March 9 (MJC):
    Original version.
1 TRANMAKE
Makes a transformation structure given its co-ordinate mappings.

Usage:

   tranmake transform trtype comment
      { nvin=? nvout=? class=? for1=? inv1=? ... for7=? inv7=?
        fa-fz=? pa-pz=?
      { tr
      trtype

Description:

   This application creates a transformation data structure from
   forward and inverse mappings that you supply.  The TRANSFORMER
   application uses such a structure to transform an NDF by
   resampling.  The structure can have classification qualifiers and
   a comment.

   For convenience, TRANMAKE can create a two-dimensional linear
   transformation merely from the six coefficients, or
   two-dimensional Cartesian-to-polar transformation given the
   origin position and angle.
2 Parameters
For information on individual parameters, select from the list below:
3 CLASS
CLASS( ) = LITERAL (Read)
   A list of classifications that describe the properties of the
   transformation.  This is optional, but the information can be
   used to make other applications run more efficiently.  This
   applies particularly to linear or constant determinants.
   Valid values are:
      "Linear"       --- linear and preserves straight lines,
      "Independent"  --- preserves the independence of the axes,
      "Diagonal"     --- preserves the axes themselves,
      "Isotropic"    --- preserves angles and shapes,
      "Positive_det" --- a component of reflection is absent,
      "Negative_det" --- a component of reflection is present,
      "Constant_det" --- the scale factor is constant,
      "Unit_det"     --- areas (or volumes etc.) are preserved.

   See SUN/61 Appendix B for more details of transformation
   classification and a table of the classifications of common
   mappings.  The suggested default is null (!) meaning unknown,
   and no classification is written to the transformation
   structure.  This parameter is ignored unless TRTYPE="Expres".
3 COMMENT
COMMENT = LITERAL (Read)
   The comment string associated with the transformation.
   A null value (!) causes a blank comment to be written into
   the transformation.  Use the "-->" symbol to indicate the
   forward transformation.  The suggested default is the null
   value.
3 FA-FZ
FA-FZ = LITERAL (Read)
   These parameters supply the values of `sub-expressions' used
   in the expressions FOR1-FOR7, and INV1-INV7.  Any of the 26
   may appear; there is no restriction on order.  These
   parameters should be used when repeated expressions are
   present in complex transformations.  Sub-expressions may
   contain references to other sub-expressions and constants
   (PA-PZ).  An example of using sub-expressions is:
      FOR1 > "XX=PA*ASIND(FA/PA)*X/FA"
      FOR2 > "YY=PA*ASIND(FA/PA)*Y/FA"
      INV1 > "X=PA*SIND(FB/PA)*XX/FB"
      INV2 > "Y=PA*SIND(FB/PA)*YY/FB"
      FA > SQRT(X*X+Y*Y)
      PA > 100D0
      FB > SQRT(XX*XX+YY*YY)
   where the parameter name is to the left of > and its value is
   to the right of the >.  This parameter is ignored unless
   TRTYPE="Expres".
3 FITTYPE
FITTYPE = _INTEGER (Read)
   The type of fit specified by coefficients supplied via the
   TR parameter.  Appropriate values are:
      1 -- shift of origin,
      2 -- shift of origin and rotation,
      3 -- shift of origin and magnification,
      4 -- shift of origin, rotation, and magnification
           (solid body), and
      5 -- a full six-parameter fit.

   The value of this parameter is used to classify the
   transformation (see the CLASS parameter).  This parameter is
   ignored unless TRTYPE="Bilinear".  [5]
3 FOR1-FOR7
FOR1-FOR7 = LITERAL (Read)
   The NVIN expressions that define the forward mapping or
   mappings of the transformation.  FOR1 applies to first
   output variable, and so on through to FOR7 for the seventh
   input variable.  The expressions are written in Fortran-like
   syntax.  The arithmetic operators (+,-,/,*,**) follow the
   normal order of precedence.  Using matching (nested)
   parentheses will explicitly define the order of expression
   evaluation.  The expression may contain constants and the
   built-in functions (LOG10, SQRT, SIN, TAND etc.) described in
   SUN/61 Appendix A.

   For a null forward transformation there must still be NVOUT
   expressions, each just containing the name of the output
   variable, for example, "X".  An example expression is
   "Z=PA*(NINT(ZP)+0.5)".

   This parameter is ignored unless TRTYPE="Expres".
3 INV1-INV7
INV1-INV7 = LITERAL (Read)
   The NVOUT expressions that define the inverse mapping or
   mappings of the transformation.  INV1 applies to first input
   variable, and so on through to INV7 for the seventh input
   variable.  The expressions are written in Fortran-like syntax.
   The arithmetic operators (+,-,/,*,**) follow the normal order
   of precedence.  Using matching (nested) parentheses will
   explicitly define the order of expression evaluation.  The
   expression may contain constants and the built-in functions
   (LOG10, SQRT, SIN, TAND etc.) described in SUN/61 Appendix A.

   For a null inverse mapping there must still be NVIN
   expressions, each just containing the name of the input
   variable, for example, "XX".  Generally, it is the inverse
   mapping that is required.  An example expression is
   "X=MOD(10*SQRT((XX+YY)*ZZ),360)"

   This parameter is ignored unless TRTYPE="Expres".
3 NVIN
NVIN = INTEGER (Read)
   The number of input variables in the transformation.  It must
   lie in the range 1 to 7.  The suggested default is the current
   value, and 2 initially.   This parameter is ignored unless
   TRTYPE="Expres".
3 NVOUT
NVOUT = INTEGER (Read)
   The number of output variables in the transformation.  It must
   lie in the range 1 to 7.  The suggested default is the number
   of input variables.  This parameter is ignored unless
   TRTYPE="Expres".
3 PA-PZ
PA-PZ = _DOUBLE (Read)
   These parameters supply the values of constants used in the
   expressions FOR1-FOR7, and INV1-INV7.  Any of the 26 may
   appear; there is no restriction on order.  Using parameters
   allows the substitution of repeated constants using one
   reference.  This is especially convenient for constants with
   many significant digits.  It also allows easy modification of
   parameterised expressions (expressions say with an adjustable
   centre) provided the application has not been used in the
   interim.  The parameter PI has a default value of
   3.14159265359D0.  An example of using parameters is:
      FOR1 > "XX=SQRT(FX*FX+FY*FY)"
      FOR2 > "YY=ATAN2D(-FY,FX)"
      INV1 > "X=XX*SIND(YY)+PA"
      INV2 > "Y=-YY*COSD(XX)+PB"
      FX > X-PA
      FY > Y-PB
      PA > X-centre-value
      PB > Y-centre-value
   where the parameter name is to the left of > and its value is
   to the right of the >.  This example maps Cartesian
   co-ordinates (x,y) to polar (r,theta) about a specified centre.
   This parameter is ignored unless TRTYPE="Expres".
3 PREC
PREC = LITERAL (Read)
   The arithmetic precision with which the transformation
   functions will be evaluated when used.  This may be either
   "_REAL" for single precision, "_DOUBLE" for double precision,
   or "_INTEGER" for integer precision.  Elastic precisions are
   used, such that a higher precision will be used if the input
   data warrant it.  So for example if PREC = "_REAL", but
   double-precision data were to be transformed, double-precision
   arithmetic would actually be used.    This parameter is
   ignored unless TRTYPE="Expres". ["_REAL"]
3 TR
TR( 6 ) = _DOUBLE (Read)
   If TRTYPE="Bilinear" is chosen then the values of this
   parameter are the 6 coefficients of a linear transformation of
   the type.
         X' = TR(1) + TR(2)*X + TR(3)*Y
         Y' = TR(4) + TR(5)*X + TR(6)*Y
   The initial suggested default is the identity transformation.
   ([0,1,0,0,0,1]).

   If TRTYPE="Polar", only three values are needed.  TR(1) and
   TR(2) are the x-y co-ordinates of the origin of the centre of
   the polar co-ordinate system.  An optional third value is
   the angular origin measured in degrees starting from the
   x-axis in an anticlockwise direction.  If this is omitted, it
   defaults to 0.  The initial suggested default is [0,0,0].

   This parameter is ignored unless TRTYPE="Bilinear" or "Polar".
3 TRANSFORM
TRANSFORM = TRN (Write)
   The actual or implied HDS object to store the created
   transformation.  It may be an HDS container file, in which
   case the transformation structure is placed within a structure
   called TRANSFORM at the top level of the file; or a path to
   the HDS object.  So for instance, if parameter
   TRANSFORM=warp9, the transformation will be placed in the
   top-level structure TRANSFORM within the HDS file warp9.sdf.
   In this case the container file may already exist.  If, on the
   other hand, the explicit structure is named, the
   transformation information will be placed there.  For example,
   to place the transformation in the extension GALPHOT of the
   NDF called NGC253, parameter TRANSFORM would be NGC253.MORE.GALPHOT.
   The structure name is limited to 15 printing characters.  Note
   that in either case the structure must not already exist.  If
   it does, an error condition results.

   This has parameter no suggested default.
3 TRTYPE
TRTYPE = LITERAL (Read)
   The type of transform which will be supplied.  Valid values are
   "Bilinear", "Expres", and "Polar".

   "Bilinear" requests that the transform will be generated from
   the six coefficients specified by parameter TR in the
   equations:
      X' = TR(1) + TR(2)*X + TR(3)*Y
      Y' = TR(4) + TR(5)*X + TR(6)*Y
   that define a linear two-dimensional transformation.

   "Expres" lets an arbitrary transformation be specified using
   algebraic-like statements of the type:
      FOR1 > "XX=PA+PC*X"
      FOR2 > "YY=PD+PE*Y"
      INV1 > "X=(XX-PA)/PC"
      INV2 > "Y=(YY-PD)/PE"
   where the parameter name is to the left of > and its value is
   to the right of the >.  The PA-PZs are reserved for constants
   (FA-FZ are also reserved for repeated expressions).  This
   example allows independent offsets and scales in x and y.  The
   inverse mapping must be supplied.

   "Polar" makes a 2-dimensional Cartesian-to-polar
   transformation, where the origin in Cartesian co-ordinates, and
   polar angle are specified by parameter TR.

   ["Expres"]
2 Examples
tranmake xyz nvin=1 nvout=1 for1="xd=1.01*x-0.34"
   inv1="x=(xd+0.34)/1.01" \
    This creates a transformation structure TRANSFORM in the HDS
    file called xyz.sdf.  It specifies mappings between one input
    and one output variable.  The output variable is 1.01 the
    output variable less 0.34.

tranmake xyz nvin=1 nvout=1 for1="xd=1.01*x-0.34" class=linear
   inv1="x=(xd+0.34)/1.01" comment="Copier correction"
    As above, except that because the transformation is linear
    (it is a magnification and translation), the classification is
    set to "Linear".  "Copier correction" is written as the comment
    in the structure.

tranmake transform=turn.more.rot45 nvin=2 nvout=2
   class=["linear","isotropic","unit_det"] pa=45
   for1="xo=cosd(pa)*xi-sind(pa)*yi"
   for2="yo=sind(pa)*xi+cosd(pa)*yi"
   inv1="xi=cosd(pa)*xo+sind(pa)*yo"
   inv2="yi=-sind(pa)*xo+cosd(pa)*yo" \
    This creates a transformation structure TURN.MORE.ROT45 (in
    HDS file turn.sdf) that rotates a two-dimensional co-ordinate
    system by 45 degrees clockwise.  Three classes---linear,
    isotropic, unit determinant---are assigned for this
    transformation.  (As it is a rotation, positive and constant
    determinants are also applicable.)

tranmake shiftim trtype=lin tr=[8.73,1,0,-64.6,0,1] fittype=1 \
   This creates an HDS file called raw_origin.sdf containing a
   transformation structure called TRANSFORM at the top-level.
   This transformation defines a shift of 8.73 of the first
   variable (usually x in an image) and a negative shift of 64.6
   in the second variable (normally y).  The shift is specified
   using the appropriate linear-transformation coefficients
   [XSHIFT,1,0,YSHIFT,0,1] and is correctly classified as a
   fit type of 1.  There is no comment.

tranmake my_ndf.more.my_extension.tran1 bilinear "15-deg rotation"

[0,0.965926,-0.258819,0,0.258819,0.965926] fittype=2
   This creates a transformation structure called TRAN1
   in the extension MY_EXTENSION of the NDF called my_ndf.  The
   structure defines a rotation by 15 degrees in about the (0,0)
   position in a plane (say x-y of an image).  The rotation
   is specified using the appropriate linear transformation
   coefficients [0,COS,-SIN,0,SIN,COS].  The comment stored in the
   structure is "15-deg rotation".

tranmake polish.origin1 trtype=p tr=[100.0,21.3] \
   This creates an HDS file called polish.sdf containing a
   transformation structure called ORIGIN1 at the top-level.
   This structure defines a Cartesian-to-polar transformation
   about an origin at (100.3,21.3) in pixel co-ordinates.
   There is no comment stored in ORIGIN1.
2 Notes
-  This routine does not check that the forward and inverse
expressions actually define a pair of complementary mappings.

-  On completion, the destination structure for the
transformation information equates to the current transformation
global parameter.
2 Related_Applications
   KAPPA: FLIP, ROTATE, SLIDE, TRANINVERT, TRANJOIN, TRANSFORMER,
   TRANTRACE; CCDPACK: CCDEDIT, TRANLIST, TRANNDF.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1993 March 22 (MJC):
    Original version.

 1995 February (MJC):
    Included tokens for constants and expressions, and the
    two-dimensional linear fit.
1 TRANSFORMER
Applies a transformation to an NDF.

Usage:

   transformer in transform out [method] [shape] { lcoord=? ucoord=?
                                                 { lbound=? ubound=?
                                               shape

Description:

   This application performs an arbitrary transformation on an NDF to
   create an output NDF.  There is full control of the shape, origin,
   and co-ordinate limits of the output NDF.  The output NDF is
   calculated by resampling within the input NDF.  Output array
   elements are set to the bad value if their inverse-transformed
   co-ordinates lie outside the input NDF's co-ordinate limits.
2 Parameters
For information on individual parameters, select from the list below:
3 CONSERVE
CONSERVE = _LOGICAL (Read)
   If CONSERVE is TRUE, the output values are normalised by the
   ratio of the output-to-input pixel areas.  In other words this
   conserves flux.  If CONSERVE is FALSE, there is no
   normalisation.  [FALSE]
3 COSYS
COSYS = LITERAL (Read)
   The co-ordinate system to be used.  This can be either "World"
   or "Data".  "World" inputs pixel co-ordinates to the supplied
   transformation to derive the co-ordinates in the output NDF.
   "Data" causes the NDF's axis information to be the input
   co-ordinates to the transformation.  See the SHAPE parameter.
   [Current co-ordinate system]
3 FULL
FULL = _LOGICAL (Read)
   When the number of input variables is less than the number
   of dimensions of input NDF (but not less than the number of
   output variables), FULL set to TRUE applies the transformation
   to all the higher dimensions.  For example, FULL = TRUE
   would apply a 2-dimensional transformation to all the planes
   along the third dimension of a cube NDF.  FULL = FALSE would
   only transformed the first plane.  [FALSE]
3 IN
IN = NDF (Read)
   The NDF to be transformed.
3 LBOUND
LBOUND() = _INTEGER (Read)
   The lower pixel-index bounds of the output NDF.  The number of
   values should equal the number of output variables in the
   transformation.  This parameter is only used when SHAPE is
   "Full" or "Bounds".  The suggested defaults are the lower
   bounds of the input NDF, and where there are more output than
   input dimensions they are set to 1.
3 LCOORD
LCOORD() = _DOUBLE (Read)
   The lower co-ordinate limits of the output NDF.  The number of
   values should equal the number of output variables in the
   transformation.  This parameter is only used when SHAPE is
   "Full" or "Limits".  The suggested defaults are the lower
   co-ordinate limits determined from applying the transformation
   to a series of test points.  Where there are more output than
   input dimensions they are set to 0.0.
3 METHOD
METHOD = LITERAL (Read)
   The interpolation method used to resample the input array.
   Permitted values are "Nearest" for nearest-neighbour, and
   "Linint" for linear interpolation.  ["Nearest"]
3 OUT
OUT = NDF (Write)
   The transformed NDF.
3 SHAPE
SHAPE = LITERAL (Read)
   The method by which to define the bounds and co-ordinate limits
   of the output NDF.  See Section "Co-ordinate Limits and
   Bounds".  The options for SHAPE are described below.
      "Bounds" - Specify the output bounds with LBOUND and UBOUND.
                 Use the default co-ordinate limits derived from
                 the transformation of test points in the input
                 NDF.
      "Full"   - Specify the output co-ordinate limits and bounds
                 with LCOORD, UCOORD, LBOUND and UBOUND.
      "Limits" - Use the bounds of the input NDF and specify the
                 output co-ordinate limits with LCOORD and UCOORD.
      "Match"  - Use the co-ordinate limits from transformed test
                 points of the input NDF, and make a co-ordinate
                 unit equivalent to one pixel.  The bounds are the
                 integer-rounded co-ordinate limits.  This option
                 results in an output NDF that is not clipped and
                 unlike the other options guarantees no further
                 linear compression or expansion.
      "Same"   - Use the bounds of the input NDF and take the
                 co-ordinate limits from transformed test points
                 of the input NDF.
   The first three also cause the co-ordinate limits to be
   reported before obtaining the limits and/or bounds.

   Not all of these are permitted simultaneously.  "Same" is not
   allowed when the number of input and output transformation
   variables are not equal.  Otherwise it is the value of
   COSYS that controls the options.  When COSYS = "Data" all but
   "Match" are allowed, and COSYS = "World" excludes "Limits" and
   "Full".  There is a special case where SHAPE is fixed to be
   "Bounds".  This is when the number of output variables exceeds
   the number of input variables, and that in turn equals the
   number of dimensions in the input NDF.

   SHAPE defaults to the dynamic default.  When COSYS = "Data"
   this is "Bounds", and when COSYS = "World" the default is
   "Match".  The suggested default is current value, or the
   dynamic default if there is not one.  []
3 TITLE
TITLE = LITERAL (Read)
   Title for the output NDF structure.  A null value (!)
   propagates the title from the input NDF to the output NDF. [!]
3 TRANSFORM
TRANSFORM = TRN (Read)
   The transformation to be applied.  This may be an HDS
   container file, in which case the transformation structure is
   assumed to be called TRANSFORM at the top level of the file;
   or a path to the HDS object.  For example, a value of
   distort.mapping would use the transformation structure called
   MAPPING in the HDS file distort.sdf; and a value of aitoff
   would make the routine look for the transformation in top-level
   object TRANSFORM within the HDS file aifoff.sdf.  Normally the
   object name is TRANSFORM.  The structure must contain both the
   forward and inverse mappings.

   Structures can be made using CCDEDIT in CCDPACK or TRANMAKE.
3 UBOUND
UBOUND() = _INTEGER (Read)
   The upper pixel-index bounds of the output NDF.  The number of
   values should equal the number of output variables in the
   transformation.  This parameter is only used when SHAPE is
   "Full" or "Bounds".  Each suggested-default value is the
   maximum of the input upper bound and the output lower bound.
3 UCOORD
UCOORD() = _DOUBLE (Read)
   The upper co-ordinate limits of the output NDF.  The number of
   values should equal the number of output variables in the
   transformation.  This parameter is only used when SHAPE is
   "Full" or "Limits".  Each suggested-default value is the
   upper co-ordinate limit determined from applying the
   transformation to a series of test points.
2 Examples
transformer curved sdist straight
   This transforms the NDF called curved into an NDF called
   straight.sdf, using the transformation TRANSFORM in the HDS
   file called sdist.sdf.  It uses nearest-neighbour resampling.
   Assuming the current co-ordinate system is world, the
   transformation is performed in pixel co-ordinates, setting the
   bounds to just enclose the transformed input array.

transformer curved sdist.transform straight linint same
   As above, except linear interpolation is used, and the array
   of NDF straight array uses the bounds of NDF curved.

transformer a119 proj.merc a119s shape=bounds lbound=[1,-20]

ubound=[256,172]
   This transforms the NDF called a119, using the transformation
   MERC in the HDS file called proj.sdf, into an NDF called
   a119s.  It uses nearest-neighbour resampling.  a119s just
   encloses the transformed arrays from a119, and has 256 x 192
   pixels from origin (1,-20).

transformer spec2d scrunch.trn full method=l out=spec2d_l

shape=limits lcoord=5000 ucoord=6500
   This transforms the 2-dimensional NDF called spec2d, using
   the 1-dimensional transformation TRN in the HDS file called
   scrunch.sdf, into an NDF called spec2d_l.  (NDF spec2d might
   be a set of spectra before scrunching.)  The
   linear-interpolation resampling is applied to all the lines in
   spec2d_l.  The NDFs have the same pixel-index bounds.
   spec2d_l is constrained to contain elements whose transformed
   co-ordinates lie between 5000 to 6500.
2 Notes
-  In general the test points to calculate the co-ordinate limits
for LCOORD and UCOORD are situated at the corners of each pixel,
assuming spaced axes.  Thus for a 2-dimensional array of 9-by-7
pixels there are 80 (10*8) test points.  For linear
transformations there is a smaller set of test points for
improved efficiency.  These are the corners of each axis and the
midpoints between them.

-  On completion, the current transformation global parameter
takes the value of parameter TRANSFORM.
2 Co-ordinate_Limits_and_Bounds
   The limits are the lower co-ordinates of the first element, and
   the upper co-ordinates of the last element of the NDF.  Using
   these limits, TRANSFORMER derives the co-ordinates of the output
   NDF's pixel centres by linear interpolation.  Therefore, the
   co-ordinate limits define the region of the input NDF that will
   appear in the output.

   The bounds of the output NDF define its shape and origin.  So
   an additional linear scaling transformation can be applied along
   each axis by adjusting the shape independently of the co-ordinate
   limits.
2 Related_Applications
   KAPPA: FLIP, ROTATE, SLIDE, TRANINVERT, TRANJOIN, TRANMAKE,
   TRANTRACE; CCDPACK: CCDEDIT, TRANLIST, TRANNDF.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1993 March 16 (MJC):
    Original version.

 1995 August 17 (MJC):
    Used PSX for workspace.  Introduced an improved determination
    of the extreme co-ordinates using the pixel vertices as test
    points.
2 Implementation_Status
   -  Flux conservation can only be applied to constant-determinant
   or linear transformations.

   -  The NDF components are processed by this application as
   follows.
      o  LABEL, UNITS, HISTORY, and extensions are propagated.
      o  TITLE is controlled by the TITLE parameter.
      o  QUALITY is not derived from the input NDF for a linearly
      interpolated NDF.  The DATA and VARIANCE arrays are resampled.
      o  Axis centre arrays are created using the co-ordinate
      limits for COSYS = "Data".

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.

   -  There can be an arbitrary number of NDF dimensions.
1 TRANTRACE
Lists the contents of a transformation structure.

Usage:

   trantrace transform [logfile]

Description:

   This application reports or write to a text file the contents of
   a TRANSFORM structure.  Items listed include:

      - the structure's name;

      - the version of the TRANSFORM software used to write the
        structure;

      - the number of input and output variables for the nett
      transformation and for each transformation where the structure
      contains more than one;

      - the classification of the forward and inverse mappings; and

      - for each transformation its precision, comment, forward and
      inverse functions.
2 Parameters
For information on individual parameters, select from the list below:
3 CLASSFOR
CLASSFOR = LITERAL (Write)
   A comma-separated list of classifications that describe the
   properties of the forward mapping of the transformation.  The
   possible values in the list are:
      "Linear"       --- linear and preserves straight lines,
      "Independent"  --- preserves the independence of the axes,
      "Diagonal"     --- preserves the axes themselves,
      "Isotropic"    --- preserves angles and shapes,
      "Positive_det" --- a component of reflection is absent,
      "Negative_det" --- a component of reflection is present,
      "Constant_det" --- the scale factor is constant,
      "Unit_det"     --- areas (or volumes etc.) are preserved.

   See SUN/61 Appendix B for more details of transformation
   classification and a table of the classifications of common
   mappings.
3 CLASSINV
CLASSINV = LITERAL (Write)
   A comma-separated list of classifications that describe the
   properties of the inverse mapping of the transformation.  See
   parameter CLASSFOR for further details.
3 COMMENT
COMMENT = LITERAL (Write)
   The comment string associated with the transformation.  A
   "-->" symbol, if present, indicates the forward
   transformation.
3 FORWARD
FORWARD = LITERAL (Write)
   The expression that defines the last forward mapping of the
   transformation.
3 INVERSE
INVERSE = LITERAL (Write)
   The expression that defines the last inverse mapping of the
   transformation.
3 LOGFILE
LOGFILE = FILENAME (Write)
   The name of the text file to store a list of the
   transformation structure.  If it is null (!) the list of the
   transformation structure is reported directly to you. [!]
3 PREC
PREC = LITERAL (Write)
   The arithmetic precision of the transformation.  This may be
   either "_REAL" for single precision, "_DOUBLE" for double
   precision, or "_INTEGER" for integer precision.
3 TRANSFORM
TRANSFORM = TRN (Read)
   The transformation structure to be listed.  This may be an HDS
   container file, in which case the transformation structure is
   assumed to be called TRANSFORM at the top level of the file;
   or a path to the HDS object.  The suggested default is the
   current transformation structure.
3 VERSION
VERSION = LITERAL (Write)
   The version number of the TRANSFORM software used to write the
   transformation structure.
2 Examples
trantrace rot45.transform
   This reports the contents of the transformation structure
   within the HDS container file rot45.sdf, component TRANSFORM.

trantrace rot45
   This has the same affect as the previous example.

trantrace \
   This reports the contents of the current TRANSFORM structure.

trantrace jkt256.more.ccdpack.transform trn.lis
   This lists to the text file trn.lis the contents of the
   transformation structure located within the HDS file
   jkt256.sdf, as component MORE.CCDPACK.TRANSFORM.

trantrace stretch.limit nvin=(nvi) comment=(trncom)
   This reports the contents of the transformation structure
   within the HDS container file stretch.sdf, component LIMIT.
   The number of input transformation variables is written to the
   ICL variable called NVI, and the transformation comment is
   stored in ICL variable TRNCOM.
2 Notes
-  Where a value is not optional but is absent, "<undefined>" appears
in the listing.

-  TRANTRACE attempts to compile the forward and inverse mappings
to check that it is a TRANSFORM structure, and will exit with an
error if both of these compilations fail.

-  On completion, the current transformation global parameter
takes the value of parameter TRANSFORM.
2 Authors
MJC: Malcolm J. Currie (STARLINK)
2 History
 1993 June 18 (MJC):
    Original version.
1 TRIG
    Performs a trigonometric transformation on a data array
 
   This routine allows the user to select one of a set of several
   basic trigonometrical functions (sine, cosine, tangent, arcsine,
   etc.) and operate on each pixel of the data array, in the input
   IMAGE structure, with this function, and then to output a
   transformed version of the array. The trigonometric functions can
   be selected to act as if the input data are to be treated as
   radians or degrees. If a scalar value rather than a data array is
   input, the application acts purely on that scalar value.
 
   The magic-value method is used for processing bad data.  Undefined
   results are set to the magic value.
2 AUTHORS
   Mark McCaughrean UoE ( REVA::MJM )
   Malcolm Currie  STARLINK (RAL)
2 BUGS
   None known.
2 HISTORY
   10-12-1985 : First implementation (UKTH::MARK)
   08-01-1986 : Allowed option of scalar processing (REVA::MJM)
   1986 Aug 8 : Renamed routines TRIGSCAL and TRIGSUB to TRGSCL and
                TRIGSB respectively. 2nd argument of TRIGSB changed
                to the number of pixels in the input array. Status
                checking of mapping of output array added
                (RAL::CUR).
   1986 Sep 1 : Added argument section to prologue, generalised to
                vector and nearly conformed to Starlink standards
                (RAL::CUR).
   1987 Oct 16: Reordered tidying (particularly in VALID loop), extra
                status checks and used CMP_SHAPE, rewrote method
                section (RAL::CUR)
   1988 Mar 17: Referred to `array' rather than `image'
                (RAL::CUR)
   1988 Jun 1 : More reporting of error context (RAL::CUR)
   1989 Jun 13: Allow for processing primitive NDFs (RAL::CUR)
   1991 Oct 25: Propagates AXIS, LABEL, and HISTORY (RAL::CUR).
   1992 Feb 25: Limited processing of simple NDFs (RAL::CUR).
2 PARAMETERS
   INPIC = IMAGE( READ )
       Input IMAGE structure containing the data array to be
         transformed.
   TRIGFUNC = CHAR( READ )
       Trigonometrical function to be applied.
   OUTPIC = IMAGE( WRITE )
       Output IMAGE structure containing the transformed data array.
   OTITLE = CHAR( READ )
       Title string for the output IMAGE structure.
3 INPUT
  position    1
  keyword     'INPUT'
  type        'UNIV'
  access      'READ'
  vpath       'PROMPT'
  ppath       'GLOBAL'
  association '<-GLOBAL.DATA_ARRAY'
  prompt      'Input to be operated on'
  help        'Give the IMAGE structure containing the data array, or 
              the scalar on which the trig function is to operate.'
3 TRIGFUNC
  position    2
  keyword     'TRIGFUNC'
  type        'LITERAL'
  vpath       'PROMPT'
  prompt      'Trig function to be used'
  help        'One of 
              SIN,COS,TAN,SIND,COSD,TAND,ASIN,ACOS,ATAN,ASIND,ACOSD,ATAND.'
 #in          'SIN', 'COS', 'TAN', 'SIND', 'COSD', 'TAND', 'ASIN', 
              'ACOS', 'ATAN', 'ASIND', 'ACOSD', 'ATAND'
3 OUTPIC
  position    3
  keyword     'OUTPIC'
  type        'IMAGE'
  access      'WRITE'
  vpath       'PROMPT'
  association '->GLOBAL.DATA_ARRAY'
  prompt      'Image for output data'
  help        'Name given to the IMAGE structure to hold the 
              generated data array.'
3 OTITLE
  position    4
  keyword     'OTITLE'
  type        '_CHAR'
  vpath       'DEFAULT'
  prompt      'Title for output image'
  default     'KAPPA - Trig'
  help        'Character string used as a title for the output IMAGE 
              structure.'

1 UNIX_usage

The following applies to operation from the shell.  To start you must
issue the usual KAPPA command, but note that it must be in lowercase. 

     % kappa

All commands must be given in full and in lowercase.  Normal command
syntax may contain shell metacharacters.  These include parenthesis,
bracket, quote, double quote and backslash.  A backslash is needed
before each metacharacter for these characters to be taken literally. 
Here are some examples: 

     % stats image\(100:199,~100\)

obtains statistics of a section of an NDF; while

     % display picture \\

displays NDF picture, accepting the suggested defaults for other 
parameters; and

     % contour psf mode=fr heights=\[10,20,40\] pltitl=\"Demo plot\"

contours the NDF called psf at array values of 10, 20, and 40,
with a title of "Demo plot".

An alternative is to enclose the metacharacters in double quotes,
for example:

     stats image"(100:199,~100)"

would have the same effect as the earlier example.

When responding to prompts neither the <TAB> function for editing the
default nor command-line recall is available.
1 Using_Help
 You are situated in a portable HELP library which contains help
 information about KAPPA arranged in an hierarchical structure.  The
 help system enables you to navigate the library by prompting when it
 has completed displaying the previously requested help.  The
 information displayed by the help system on a particular topic
 includes a description of the topic and a list of subtopics that
 further describe the topic.  These topic names are called keywords. 

 At a prompt you may enter:

   o  a topic or subtopic name to display the help for that topic or
      subtopic;

   o  just a <CR> to move up one level in the hierarchy, and if you
      are at the top level it will terminate the help session;

   o  a CTRL/D will terminate the help session;

   o  a question mark "?" to redisplay the text for the current topic,
      including the list of topic or subtopic names; or

   o  an ellipsis "..." to display all the text below the current point 
      in the hierarchy.  For example, "GLITCH..." displays information 
      on the GLITCH topic as well as information on all the subtopics
      under GLITCH.

 You can abbreviate any keyword using the following rules:

   1) Just give the first few characters, e.g. "PARA" for
   "Parameters".

   2) Some keywords are composed of several words separated by
   underscores.  Each word of the keyword may be abbreviated,
   e.g. "Colour_Set" can be shortened to "C_S".

   3) The characters "%" and "*" act as wildcards, where the percent
   sign matches any single character, and asterisk matches any
   sequence of characters.  Thus to display information on all
   available topics, type an asterisk (*) in reply to a hrlp prompt.

   4) If a word contains but does end with an asterisk wildcard, it
   must not be truncated.

   5) The entered string must not contain leading or embedded spaces.

 Ambiguous abbreviations result in all matches being displayed. 
 
2 Help_Parameters

 keyword ...

  Specifies one or more keywords that refer to the topic  or  subtopic
  on  which you  want  information from the help library.  Information
  within the help library is arranged in a hierarchical  manner.   The
  levels are:

  1.  None--- If you do not specify a keyword,  KAPHELP introduces the 
      help system  and  lists the  top-level topics.  Each item in the
      list is a keyword in the first level of the hierarchy.

  2.  Topic-name---If you specify  a keyword  by naming  a topic,  the
      help facility  describes  the  topic.  Keywords  for  additional
      information available on this topic are listed.

  3.  Topic-name subtopic---If you  specify  a  subtopic  following  a
      topic, the help facility provides a description of the specified
      subtopic.
1 VECPLOT
Plots a 2-dimensional vector map.

Usage:

   vecplot ndf1 ndf2 [comp] [step] [vscale] [arrow] [just] [device]

Description:

   This application plots vectors defined by the values contained
   within a pair of 2-dimensional NDFs, the first holding the
   magnitude of the vector quantity at each pixel, and the second
   holding the corresponding vector orientations.  It is assumed that
   the two NDFs are aligned in pixel co-ordinates. The number of
   vectors in the plot is kept to a manageable value by only
   plotting vectors for pixels on a sparse regular matrix.  The
   increment (in pixels) between plotted vectors is given by
   parameter STEP.  Zero orientation may be fixed at any position
   angle within the plot by specifying an appropriate value for
   parameter ANGROT.  Each vector may be represented either by an
   arrow or by a simple line, as selected by parameter ARROW.

   The plot is produced within the current graphics database picture,
   and may be aligned with an existing DATA picture if the existing
   picture contains suitable co-ordinate Frame information (see
   parameter CLEAR).

   Annotated axes can be produced (see parameter AXES), and the
   appearance of these can be controlled in detail using parameter
   STYLE. The axes show co-ordinates in the current co-ordinate Frame
   of NDF1.

   A key to the vector scale can be displayed to the right of the
   vector map (see parameter KEY). The appearance and position of this
   key may be controlled using parameters KEYSTYLE and KEYPOS.
2 Parameters
For information on individual parameters, select from the list below:
3 ANGROT
ANGROT = _REAL (Read)
   A rotation angle in degrees to be added to each vector
   orientation before plotting the vectors (see parameter NDF2).
   It should be in the range 0--360. [0.0]
3 ARROW
ARROW = LITERAL (Read)
   Vectors are drawn as arrows, with the size of the arrow head
   specified by this parameter. Simple lines can be drawn by setting
   the arrow head size to zero. The value should be expressed as a
   fraction of the largest dimension of the vector map. [current value]
3 AXES
AXES = _LOGICAL (Read)
   TRUE if labelled and annotated axes are to be drawn around the
   vector map. These display co-ordinates in the current co-ordinate
   Frame NDF1 - which may be changed using application WCSFRAME
   (see also parameter USEAXIS). The width of the margins left for
   the annotation may be controlled using parameter MARGIN. The
   appearance of the axes (colours, fonts, etc) can be controlled
   using the STYLE parameter. [TRUE]
3 CLEAR
CLEAR = _LOGICAL (Read)
   TRUE if the graphics device is to be cleared before displaying
   the vector map. If you want the vector map to be drawn over
   the top of an existing DATA picture, then set CLEAR to FALSE. The
   contour map will then be drawn in alignment with the displayed
   data. If possible, alignment occurs within the current co-ordinate
   Frame of the NDF. If this is not possible, (for instance if
   suitable WCS information was not stored with the existing DATA
   picture), then alignment is attempted in PIXEL
   co-ordinates. If this is not possible, then alignment is
   attempted in GRID co-ordinates. If this is not possible, then
   alignment is attempted in the first suitable Frame found in the NDF
   irrespective of its domain. A message is displayed indicating the
   domain in which alignment occurred. If there are no suitable Frames
   in the NDF then an error is reported. [TRUE]
3 COMP
COMP = LITERAL (Read)
   The component of NDF1 which is to be used to define the vector
   magnitudes.  It may be "Data", "Error" or "Variance".  The
   last two are not available if NDF1 does not contain a VARIANCE
   component.  The vector orientations are always defined by the
   "Data" component of NDF2. ["Data"]
3 DEVICE
DEVICE = DEVICE (Read)
   The plotting device. [Current graphics device]
3 FILL
FILL = _LOGICAL (Read)
   The DATA picture containing the vector map is usually produced with
   the same shape as the data. However, for maps with markedly different
   dimensions this default behaviour may not give the clearest result.
   When FILL is TRUE, the smaller dimension of the picture is expanded
   to produce the largest possible picture within the current picture.
   [FALSE]
3 JUST
JUST = LITERAL (Read)
   The justification for each vector; it can take any of the
   following values:

    - "Centre" -- the vectors are drawn centred on the
    corresponding pixel,

    - "Start"  -- the vectors are drawn starting at the
    corresponding pixel,

    - "End" -- the vectors are drawn ending at the corresponding
    pixel.

   ["Centre"]
3 KEY
KEY = _LOGICAL (Read)
   TRUE if a key indicating the vector scale is to be produced. [TRUE]
3 KEYPOS
KEYPOS() = _REAL (Read)
   Two values giving the position of the key. The first value gives
   the gap between the right hand edge of the contour map and the left
   hand edge of the key (0.0 for no gap, 1.0 for the largest gap). The
   second value gives the vertical position of the top of the key (1.0
   for the highest position, 0.0 for the lowest). If the second value
   is not given, the top of the key is placed level with the top of the
   vector map. Both values should be in the range 0.0 to 1.0. If a
   key is produced, then the right hand margin specified by parameter
   MARGIN is ignored. [current value]
3 KEYSTYLE
KEYSTYLE = GROUP (Read)
   A group of attribute settings describing the plotting style to use
   for the key (see parameter KEY).

   A comma-separated list of strings should be given in which each
   string is either an attribute setting, or the name of a text file
   preceded by an up-arrow character "^". Such text files should
   contain further comma-separated lists which will be read and
   interpreted in the same manner. Attribute settings are applied in
   the order in which they occur within the list, with later settings
   over-riding any earlier settings given for the same attribute.

   Each individual attribute setting should be of the form:

      <name>=<value>

   where <name> is the name of a plotting attribute, and <value> is
   the value to assign to the attribute. Default values will be
   used for any unspecified attributes. All attributes will be
   defaulted if a null value (!) is supplied. See section "Plotting
   Attributes" in SUN/95 for a description of the available
   attributes. Any unrecognised attributes are ignored (no error is
   reported).

   The appearance of the text in the key is controlled using "String"
   attributes (e.g. COLOUR(STRINGS), FONT(STRINGS), etc - the synonym
   TEXT can be used in place of STRINGS). Note, the Size attribute
   specifies the size of key text relative to the size of the numerical
   labels on the vector map axes. Thus a value of 2.0 for Size will
   result in text which is twice the size of the numerical axis labels.
   The appearance of the example vector is controlled using "Curve"
   attributes (e.g. COLOUR(CURVES), etc - the synonym VECTOR can be
   used in place of CURVES). The numerical scale value is formatted as
   an axis 1 value (using attributes FORMAT(1), DIGITS(1), etc - the
   synonym SCALE can be used in place of the value 1). The length of
   the example vector is formatted as an axis 2 value (using attribute
   FORMAT(2), etc - the synonym VECTOR can be used in place of the
   value 2). The vertical space between lines in the key can be
   controlled using attribute TextLabGap. A value of 1.0 is used if
   no value is set for this attribute, and produces default vertical
   spacing. Values larger than 1.0 increase the vertical space, and
   values less than 1.0 decrease the vertical space. [current value]
3 KEYVEC
KEYVEC = _REAL (Read)
   Length of the vector to be displayed in the key, in data units.
   If a null (!) value is supplied, the value used is generated
   on the basis of the spread of vector lengths in the plot. [!]
3 MARGIN
MARGIN( 4 ) = _REAL (Read)
   The widths of the margins to leave around the vector map for axis
   annotation. The widths should be given as fractions of the
   corresponding dimension of the current picture. The actual margins
   used may be increased to preserve the aspect ratio of the DATA
   picture. Four values may be given, in the order; bottom, right,
   top, left. If fewer than four values are given, extra values are
   used equal to the first supplied value. If these margins are too
   narrow any axis annotation may be clipped. If a null (!) value
   is supplied, the value used is 0.15 (for all edges) if annotated
   axes are being produced, and zero otherwise. See also parameter
   KEYPOS. [current value]
3 NDF1
NDF1 = NDF (Read)
   NDF structure containing the 2-dimensional image giving the
   vector magnitudes.
3 NDF2
NDF2 = NDF (Read)
   NDF structure containing the 2-dimensional image giving the
   vector orientations.  The values are considered to be in units
   of degrees unless the UNITS component of the NDF has the value
   "Radians" (case insensitive).  The positive y pixel axis defines
   zero orientation, and rotation from the x pixel axis to the y
   pixel is considered positive.
3 STEP
STEP = _INTEGER (Read)
   The number of pixels between adjacent displayed vectors (along
   both axes).  Increasing this value reduces the number of
   displayed vectors.  If a null (!) value is supplied, the value
   used gives about 30 vectors along the longest axis of the plot. [!]
3 STYLE
STYLE = GROUP (Read)
   A group of attribute settings describing the plotting style to use
   for the vectors and annotated axes.

   A comma-separated list of strings should be given in which each
   string is either an attribute setting, or the name of a text file
   preceded by an up-arrow character "^". Such text files should
   contain further comma-separated lists which will be read and
   interpreted in the same manner. Attribute settings are applied in
   the order in which they occur within the list, with later settings
   over-riding any earlier settings given for the same attribute.

   Each individual attribute setting should be of the form:

      <name>=<value>

   where <name> is the name of a plotting attribute, and <value> is
   the value to assign to the attribute. Default values will be
   used for any unspecified attributes. All attributes will be
   defaulted if a null value (!) is supplied. See section "Plotting
   Attributes" in SUN/95 for a description of the available
   attributes. Any unrecognised attributes are ignored (no error is
   reported).

   The appearance of the vectors is controlled by the attributes
   Colour(Curves), Width(Curves), etc (the synonym Vectors may be
   used in place of Curves). [current value]
3 VSCALE
VSCALE = _REAL (Read)
   The scale to be used for the vectors.  The supplied value
   should give the data value corresponding to a vector length of
   one centimetre.  If a null (!) value is supplied, a default value
   is used. [!]
3 USEAXIS
USEAXIS = GROUP (Read)
   USEAXIS is only accessed if the current co-ordinate Frame of the
   NDF has more than 2 axes. A group of two strings should be
   supplied specifying the 2 axes which are to be used when annotating
   and aligning the vector map. Each axis can be specified either by
   its integer index within the current Frame (in the range 1 to the
   number of axes in the current Frame), or by its Symbol attribute. A
   list of acceptable values is displayed if an illegal value is
   supplied. If a null (!) value is supplied, the axes with the same
   indices as the 2 significant NDF pixel axes are used. [!]
2 Examples
vecplot polint polang
   Produces a vector map on the current graphics device with
   vector magnitude taken from the NDF called polint and vector
   orientation taken from NDF polang.  All other settings are
   defaulted, so for example about 20 vectors are displayed along
   the longest axis, and a key is plotted.

vecplot polint polang angrot=23.4 clear=no
   Produces a vector map in which the primary axis of the vectors
   (as defined by the value zero in the NDF polang) is at the
   position angle 23.4 degrees (measured anti-clockwise from the
   positive y axis) in the displayed map. The map is drawn over the
   top of the the previously drawn DATA picture, aligned in a
   suitable co-ordinate Frame.

vecplot stack(,,2) stack(,,1) arrow=0.1 just=start nokey
   Produces a vector map in which the vectors are defined by two
   planes in the 3-dimensional NDF called stack.  There is no
   need to copy the two planes into two separate NDFs before
   running VECPLOT.  Each vector is represented by an arrow,
   starting at the position of the corresponding pixel.  No key
   to the vector scale and justification is produced.
2 Notes
-  The Title component in NDF1 is used as the default title for
the annotated axes. If the NDF does not have a Title component, then
the default title is taken from current co-ordinate Frame stored in the
WCS component of the NDF. This default may be over-ridden by specifying
a value for the Title attribute using the STYLE parameter.

-  The application stores a number of pictures in the graphics
database in the following order: a FRAME picture containing the
annotated axes, vectors, and key; a KEY picture to store
the key if present; and a DATA picture containing just the vectors.
Note, the FRAME picture is only created if annotated axes or a key
has been drawn, or if non-zero margins were specified using parameter
MARGIN. The world co-ordinates in the DATA picture will be pixel
co-ordinates. A reference to NDF1, together with a copy of the WCS
information in the NDF are stored in the DATA picture. On exit the
current database picture for the chosen device reverts to the
input picture.
2 Related_Applications
   KAPPA: CALPOL.
2 Authors
DSB: David Berry (STARLINK)

MJC: Malcolm J. Currie (STARLINK)
2 History
 16-AUG-1993 (DSB):
    Original version.

 21-SEP-1993 (DSB):
    Modified to overlay the vector plot on any existing DATA plot
    contained within the current picture.

 1995 April 12 (MJC):
    Added Related Applications and Implementation Status, and a
    further example.  Moved last paragraph of the long Description
    to Notes.  Made Examples and Usage lowercase.  KEY is no longer
    a position parameter.  Various tidying and stylistic changes,
    and typo's corrected.  Called KPG1_GTNDF.  Constrained ANGROT.
    Used modern-style variable declarations.  Added headings to
    the commentary.

 30-AUG-1999 (DSB):
    Do not cancel the DEVICE Parameter when closing the graphics
    system.

 4-OCT-1999 (DSB):
    Modified to use AST/PGPLOT.

 26-OCT-1999 (DSB):
    Made MARGIN a fraction of the current picture, not the DATA
    picture.
2 Implementation_Status
   -  Only real data can be processed directly.  Other non-complex
   numeric data types will undergo a type conversion before the
   vector plot is drawn.

   -  Bad pixels and automatic quality masking are supported.

1 KAPVERSION
Checks the package version number.

Usage:

   kapversion [compare]

Description:

   This application will display the installed package version number,
   or compare the version number of the installed package against a
   specified version number, reporting whether the installed package
   is older, or younger, or equal to the specified version.
2 Parameters
For information on individual parameters, select from the list below:
3 COMPARE
COMPARE = LITERAL (Read)
   A string specifying the version number to be compared to the
   version of the installed package. If a null (!) value is supplied,
   the version string of the installed package is displayed, but no
   comparison takes place. If a non-null value is supplied, the
   version of the installed package is not displayed.

   The supplied string should be in the format "V<ddd>.<ddd>-<ddd>,
   where "<ddd>" represents a set of digits. The leading "V" can be
   omitted, as can any number of trailing fields (missing trailing
   fields default to zero). [!]
3 RESULT
RESULT = INTEGER (Write)
   If a value is given for the COMPARE parameter, then RESULT is
   set to one of the following values:

   - 1 -- The installed package is older than the version number
   specified by the COMPARE parameter.

   - 0 -- The version of the installed package is equal to the
   version specified by the COMPARE parameter.

   - -1 -- The installed package is younger than the version number
   specified by the COMPARE parameter.

   The same value is also written to standard output.
2 Examples
kapversion
   Displays the version number of the installed package.

kapversion compare="V0.14-1"
   Compares the version of the installed package with the version
   "V0.14-1", and sets the RESULT parameter appropriately. For
   instance, if the installed package was "V0.13-6" then RESULT
   would be set to -1. If the installed package was "V0.14-1",
   RESULT would be set to 0. If the installed package was "V0.14-2"
   RESULT would be set to +1.
2 Notes
- The package version number is obtained from the "version" file
in the directory containing the package's installed executable files.
This file is created when the package is installed using the "mk
install" command. An error will be reported if this file cannot be
found.
2 Authors
DSB: David S. Berry (STARLINK)
2 History
 3-NOV-1999 (DSB):
    Original version.

1 WCSADD
Adds a new co-ordinate Frame into the WCS component of an NDF.

Usage:

   wcsadd ndf frame domain [tr]

Description:

   This application adds a new co-ordinate Frame into the WCS component
   of an NDF. The new Frame must be linearly connected to an existing
   Frame (called the "basis" Frame) in the WCS component. The linear
   transformation is specified by parameter TR. The new Frame becomes the
   current co-ordinate Frame in the NDF.

   The new Frame is a copy of the basis Frame, with the new Domain
   attribute specified by parameter DOMAIN. If necessary, other attributes
   of the Frame (Title, Label, Format, etc) can be changed using
   application WCSATTRIB.
2 Parameters
For information on individual parameters, select from the list below:
3 DOMAIN
DOMAIN = LITERAL (Read)
   The value for the Domain attribute for the new Frame. Care should be
   taken to ensure that domain names are used consistently. This
   will usually mean avoiding any domain names which are already in
   use within the WCS component, particularly the standard domain names
   such as GRID, PIXEL, AXIS and GRAPHICS. The supplied value is
   stripped of spaces, and converted to upper case before being used.
3 EPOCH
EPOCH = _DOUBLE (Read)
   If the basis Frame is specified using a "Sky Co-ordinate System"
   specification for a celestial co-ordinate system (see parameter
   FRAME), then an epoch value is needed to qualify it. This is the
   epoch at which the supplied sky positions were determined. It should
   be given as a decimal years value, with or without decimal places
   ("1996.8" for example). Such values are interpreted as a Besselian
   epoch if less than 1984.0 and as a Julian epoch otherwise. The
   suggested default is the value stored in the basis Frame.
3 FRAME
FRAME = LITERAL (Read)
   A string specifying the basis Frame. If a null value is supplied
   the current co-ordinate Frame in the NDF is used. The string can
   be one of the following:

   - A domain name such as SKY, AXIS, PIXEL, etc. The two
   "pseudo-domains" WORLD and DATA may be supplied and will be
   translated into PIXEL and AXIS respectively, so long as the WCS
   component of the NDF does not contain Frames with these domains.

   - An integer value giving the index of the required Frame within
   the WCS component.

   - A "Sky Co-ordinate System" (SCS) value such as EQUAT(J2000) (see
   section "Sky Co-ordinate Systems" in SUN/95).
3 NDF
NDF = NDF (Read and Write)
   The NDF in which the new Frame is to be stored.
3 TR
TR( ) = _DOUBLE (Read)
   The values of this parameter are the coefficients of a linear
   transformation from the basis Frame specified by parameter FRAME to
   the new Frame. For instance, if a feature has co-ordinates
   (X,Y,Z,...) in the basis Frame, and co-ordinates (U,V,W,...) in
   the new Frame, then the following transformations would be used,
   depending on how many axes the two Frames have:

   - 1-dimensional:

         U = TR(1) + TR(2)*X

   - 2-dimensional:

         U = TR(1) + TR(2)*X + TR(3)*Y

         V = TR(4) + TR(5)*X + TR(6)*Y

   - 3-dimensional:

         U = TR(1) + TR(2)*X + TR(3)*Y + TR(4)*Z

         V = TR(5) + TR(6)*X + TR(7)*Y + TR(8)*Z

         W = TR(9) + TR(10)*X + TR(11)*Y + TR(12)*Z

   The correct number of values must be supplied (that is, N*(N+1)
   where N is the number of axes in the new and old Frames). If a
   null value (!) is given it is assumed that the new Frame and the
   basis Frame are connected using a unit mapping (i.e. corresponding
   axis values are identical in the two Frames). [!]
2 Examples
wcsadd ngc5128 pixel old_pixel
   This adds a new co-ordinate Frame into the WCS component of the
   NDF called ngc5128. The new Frame is given the domain OLD_PIXEL
   and is a copy of the existing PIXEL Frame. This OLD_PIXEL Frame
   will be retained through further processing and can be used as a
   record of the original pixel co-ordinate Frame.

wcsadd my_data dist-lum dist(au)-lum [0,2.0628E5,0,0,0,1]
   This adds a new co-ordinate Frame into the WCS component of the
   NDF called my_data. The new Frame is given the domain DIST(AU)-LUM
   and is a copy of an existing Frame with domain DIST-LUM. The first
   axis in the new Frame is derived from the first axis in the basis
   Frame but is in different units (AU instead of parsecs). This
   change of units is achieved by multiplying the old Frame axis 1
   values by 2.0628E5. The values on the second axis are copied
   without change. You could then use application WCSATTRIB to set
   the "Unit" attribute for axis 1 of the new Frame to "AU".
2 Notes
-  The new Frame has the same number of axes as the basis Frame.

-  An error is reported if the transformation supplied using parameter
TR is singular.
2 Related_Applications
   KAPPA: NDFTRACE, WCSFRAME, WCSREMOVE, WCSATTRIB
2 Authors
DSB: David Berry (STARLINK)
2 History
 2-OCT-1998 (DSB):
    Original version.

1 WCSALIGN
Aligns a group of 2-dimensional NDFs using World Co-ordinate System
information.

Usage:

   wcsalign in out lbnd ubnd ref

Description:

   This application resamples a group of 2-dimensional input NDFs,
   producing corresponding output NDFs which are aligned pixel-for-pixel
   with a specified reference NDF.

   The transformations needed to produce alignment are derived from the
   co-ordinate system information stored in the WCS components of the
   supplied NDFs. For each input NDF, alignment is first attempted in
   the current co-ordinate Frame of the reference NDF. If this fails,
   alignment is attempted in the current co-ordinate Frame of the input
   NDF. If this fails, alignment occurs in the pixel co-ordinate Frame.
   A message indicating which Frame alignment was achieved in is
   displayed.

   The output image values are formed by re-sampling the input image
   values using either nearest neighbour or bi-linear interpolation
   (see parameter METHOD).

   Two methods exist for determining the bounds of the output images.
   Firstly, the user can give values for parameters LBND and UBND
   which are then used as the pixel index bounds for all output
   images. Secondly, if a null value is given for LBND or UBND,
   default values are generated separately for each output image so
   that the output image just encloses the entire area covered by the
   corresponding input image. Using the first method will ensure that
   all output images have the same pixel origin, and so the resulting
   images can be directly compared. However, this may result in the
   output images being larger than necessary. In general, the second
   method results in smaller images being produced, in less time.
   However, the output images will have differing pixel origins which
   need to be taken into account when comparing the aligned images.
2 Parameters
For information on individual parameters, select from the list below:
3 ACC
ACC = _REAL (Read)
   The positional accuracy required, as a a number of pixels. For
   highly non-linear projections, a recursive algorithm is used in
   which successively smaller regions of the projection are fitted
   with a least squares linear transformation. If such a transformation
   results in a maximum positional error greater than the value
   supplied for ACC (in pixels), then a smaller region is used. High
   accuracy is paid for by larger run times. [0.5]
3 IN
IN = NDF (Read)
   A group of 2-dimensional input images. This should be given as
   a comma separated list, in which each list element can be:

   - an NDF name, optionally containing wild-cards and/or regular
   expressions ("*", "?", "[a-z]" etc.).

   - the name of a text file, preceded by an up-arrow character "^".
   Each line in the text file should contain a comma separated list
   of elements, each of which can in turn be an NDF name (with
   optional wild-cards, etc), or another file specification
   (preceded by an up-arrow). Comments can be included in the file
   by commencing lines with a hash character "#".

   If the value supplied for this parameter ends with a minus
   sign "-", then the user is re-prompted for further input until
   a value is given which does not end with a minus sign. All the
   images given in this way are concatenated into a single group.
3 LBND
LBND(2) = _INTEGER (Read)
   A pair of values giving the lower pixel index bound on each axis
   for the output images. The given values are used for all output
   images.  If a null value (!) is given for this parameter or for
   parameter UBND, then separate default values are calculated for
   each output image which result in the output image just encompassing
   the corresponding input image. The suggested defaults are the
   lower pixel index bounds from the reference image (see parameter REF).
3 METHOD
METHOD = LITERAL (Read)
   The method to use when sampling the input pixel values, in
   order to find the corresponding output pixel value. It can
   take the following values:

   - "Bilinear" -- the output pixel values are calculated by
   bi-linear interpolation among the four nearest pixels values
   in the input image.

   - "Nearest" -- the output pixel values are assigned the value
   of the single nearest input pixel.

   Bi-linear interpolation generally produces smoother output
   images with lower noise, but is marginally slower.

   Both methods propagate variances from input to output, but the
   variance estimates produced using bi-linear interpolation need
   to be treated with care since the spatial smoothing produced by
   this interpolation method introduces correlations in the
   variances estimates. Also, the degree of smoothing produced varies
   across the image. This is because a sample taken at a pixel centre
   will have no contributions from the neighbouring pixels, whereas a
   sample taken at the corner of a pixel will have equal contributions
   from all four neighbouring pixels, resulting in greater smoothing
   and lower noise. This effect can produce complex Moire patterns
   in the output variance estimates, resulting from the
   interference of the spatial frequencies in the sample positions
   and in the pixel centre positions. For these reasons, if you
   want to use the output variances, you are generally safer using
   nearest neighbour interpolation. [current value]
3 OUT
OUT = NDF (Write)
   A group of output NDFs corresponding one-for-one with the list
   of input NDFs given for parameter IN. This should be given as
   a comma separated list, in which each list element can be:

   - an NDF name. If the name contains an asterisk character "*",
   the name of the corresponding input image (without directory or
   file suffix) is substituted for the asterisk (for instance, "*_al"
   causes the output image name to be formed by appending the string
   "_al" to the corresponding input image name). Input image names
   can also be edited by including original and replacement strings
   between vertical bars after the NDF name (for instance,
   *_al|b4|B1| causes any occurrence of the string "B4" in the input
   image name to be replaced by the string "B1" before appending the
   string "_al" to the result).

   - the name of a text file, preceded by an up-arrow character "^".
   Each line in the text file should contain a comma separated list
   of elements, each of which can in turn be an NDF name (with
   optional editing, etc), or another file specification
   (preceded by an up-arrow). Comments can be included in the file
   by commencing lines with a hash character "#".

   If the value supplied for this parameter ends with a minus
   sign "-", then the user is re-prompted for further input until
   a value is given which does not end with a minus sign. All the
   images given in this way are concatenated into a single group.
3 REF
REF = NDF (Read)
   A 2-dimensional NDF containing the image to which all the input
   images are to be aligned. If a null value is supplied for this
   parameter, the first image supplied for parameter IN is used.
3 UBND
UBND(2) = _INTEGER (Read)
   A pair of values giving the upper pixel index bound on each axis
   for the output images. The given values are used for all output
   images.  If a null value (!) is given for this parameter or for
   parameter UBND, then separate default values are calculated for
   each output image which result in the output image just encompassing
   the corresponding input image. The suggested defaults are the
   lower pixel index bounds from the reference image (see parameter REF).
2 Examples
wcsalign image1 image1_al ref=image2 accept
   This example resamples the 2-dimensional NDF called image1 so that
   it is aligned with the 2-dimensional NDF call image2, putting the
   output in image1_al. The output image has the same pixel index
   bounds as image2 and inherits WCS information from image2.

wcsalign m51* *_al lbnd=! accept
   This example resamples all the 2-dimensional NDFs with names
   starting with the string "m51" in the current directory so that
   they are aligned with the first input NDF. The output images
   have the same names as the input images, but extended with the
   string "_al". Each output image is just big enough to contain all
   the pixels in the corresponding input image.

wcsalign ^in.lis ^out.lis lbnd=! accept
   This example is like the previous example, except that the names
   of the input images are read from the text file in.lis, and the
   names of the corresponding output images are read from text file
   out.lis.
2 Notes
-  WCS information (including the current co-ordinate Frame) is
propagated from the reference NDF to all output NDFs.

-  QUALITY is propagated from input to output only if parameter
METHOD is set to Nearest.
2 Related_Applications
   KAPPA: WCSFRAME, TRANMAKE, TRANSFORMER; CCDPACK: TRANNDF
2 Authors
DSB: David Berry (STARLINK)
2 History
 6-OCT-1998 (DSB):
    Original version, based on IRAS90:SKYALIGN.
2 Implementation_Status
   -  Only real data can be processed directly.  Other non-complex
   numeric data types will undergo a type conversion before the
   resampling takes place.

1 WCSATTRIB
Manages attribute values associated with the WCS component of an NDF.

Usage:

   wcsattrib ndf mode name newval

Description:

   This application can be used to manage the values of attributes
   associated with the current co-ordinate Frame of an NDF (title, axis
   labels, axis units, etc).

   Each attribute has a name, a value, and a state. This application
   accesses all attribute values as character strings, converting to
   and from other data types as necessary. The attribute state is a
   Boolean flag (i.e. TRUE or FALSE) indicating whether or not a value
   has been assigned to the attribute. If no value has been assigned to
   an attribute, then it adopts a default value until an explicit value
   is assigned to it. An attribute value can be cleared, causing the
   attribute to revert to its default value.

   The operation performed by this application is controlled by
   parameter MODE, and can be:

   -  display the value of an attribute.

   -  set a new value for an attribute.

   -  clear an attribute value.

   -  test the state of an attribute.

   Note, the attributes of the PIXEL, GRID and AXIS Frames are managed
   internally by the NDF library. They may be examined using this
   application, but an error is reported if any attempt is made to 
   change them. The exception to this is that the DOMAIN attribute may
   be changed, resulting in a copy of the Frame being added to the WCS 
   compnent of the NDF with the new Domain name. The AXIS Frame is 
   derived from the AXIS structures within the NDF, so the AXLABEL 
   and AXUNITS commands may be used to change the axis label or units 
   string for the AXIS Frame.

2 Parameters
For information on individual parameters, select from the list below:
3 NAME
NAME = LITERAL (Read)
   The attribute name
3 NDF
NDF = NDF (Read and Write)
   The NDF to be modified.
3 MODE
MODE = LITERAL (Read)
   The operation to be performed on the attribute specified by
   parameter NAME: It can be one of:

   - "Get" -- The current value of the attribute is displayed on the
   screen and written to output parameter VALUE. If the attribute
   has not yet been assigned a value (or has been cleared), then the
   default value will be displayed.

   - "Set" -- Assigns a new value, given by parameter NEWVAL, to the
   attribute.

   - "Test" -- Displays "TRUE" if the attribute has been assigned a
   value, and "FALSE" otherwise (in which case the attribute will
   adopt its default value). This flag is written to the output
   parameter STATE.

   - "Clear" -- Clears the current attribute value, causing it to
   revert to its default value.
3 NEWVAL
NEWVAL = LITERAL (Read)
   The new value to assign to the attribute.
3 STATE
STATE = LOGICAL (Write)
   On exit, this holds the state of the attribute on entry to this
   application.
3 VALUE
VALUE = LITERAL (Write)
   On exit, this holds the value of the attribute on entry to this
   application.
2 Examples
wcsattrib ngc5128 set title "Polarization map of Centaurus-A"
   This sets the Title attribute of the current co-ordinate Frame in
   the NDF called ngc5128 to the string "Polarization map of Centaurus-A".

wcsattrib my_data set domain saved_pixel
   This sets the Domain attribute of the current co-ordinate Frame in
   the NDF called my_data to the string SAVED_PIXEL.

wcsattrib my_data set format(1) "%10.5G"
   This sets the Format attribute for axis 1 in the current co-ordinate
   Frame in the NDF called my_data, so that axis values are
   formated as floating point values using a minimum field width of
   10 characters, and displaying 5 significant figures. An exponent is
   used if necessary.

wcsattrib ngc5128 set format(2) bdms.2
   This sets the Format attribute for axis 2 in the current co-ordinate
   Frame in the NDF called ngc5128, so that axis values are formated as
   separate degrees, minutes and seconds field, separated by blanks.
   The seconds field has 2 decimal places. This assumes the current
   co-ordinate Frame in the NDF is a celestial co-ordinate Frame.

wcsattrib my_data get label(1)
   This displays the label associated with the first axis of the
   current co-ordinate Frame in the NDF called my_data. A default
   label is displayed if no value has been set for this attribute.

wcsattrib my_data test label(1)
   This displays "TRUE" if a value has been set for the Label
   attribute for the first axis of the current co-ordinate Frame in
   the NDF called my_data, and "FALSE" otherwise.

wcsattrib my_data clear label(1)
   This clears the Label attribute for the first axis of the current
   co-ordinate Frame in the NDF called my_data. It reverts to its
   default value.
2 Notes
-  An error is reported if an attempt is made to set or clear the
Base Frame in the WCS component.
-  The Domain names GRID, AXIS and PIXEL are reserved for use by
the NDF library and an error will be reported if an attempt is made 
to assign one of these Domain values to any Frame.
2 Related_Applications
   KAPPA: NDFTRACE, WCSFRAME, WCSREMOVE, WCSCOPY, WCSADD, AXUNITS, AXLABEL
2 Authors
DSB: David Berry (STARLINK)
2 History
 2-OCT-1998 (DSB):
    Original version.

1 WCSCOPY
Copies WCS information from one NDF to another.

Usage:

   wcscopy ndf like [tr] [confirm]

Description:

   This application copies the WCS component from one NDF to
   another, optionally modifying it to take account of a linear
   mapping between the pixel co-ordinates in the two NDFs. It can be
   used, for instance, to rectify the loss of WCS information produced
   by older applications which do not propagate the WCS component.
2 Parameters
For information on individual parameters, select from the list below:
3 CONFIRM
CONFIRM = _LOGICAL (Read)
   If TRUE, the user is asked for confirmation before replacing any
   existing WCS component within the input NDF. No confirmation is
   required if there is no WCS component in the input NDF. [TRUE]
3 LIKE
LIKE = NDF (Read)
   The reference NDF data structure from which WCS information is to be
   copied.
3 NDF
NDF = NDF (Read and Write)
   The input NDF data structure in which the WCS information is to be
   stored. Any existing WCS component is over-written (see parameter
   CONFIRM).
3 OK
OK = _LOGICAL (Read)
   This parameter is used to get a confirmation that an existing
   WCS component within the input NDF can be over-written.
3 TR
TR( ) = _DOUBLE (Read)
   The values of this parameter are the coefficients of a linear
   transformation from pixel co-ordinates in the reference NDF given
   for parameter LIKE, to pixel co-ordinates in the input NDF given
   for parameter NDF. For instance, if a feature has pixel co-ordinates
   (X,Y,Z,...) in the reference NDF, and pixel co-ordinates
   (U,V,W,...) in the input NDF, then the following transformations
   would be used, depending on how many axes each NDF has:

   - 1-dimensional:

         U = TR(1) + TR(2)*X

   - 2-dimensional:

         U = TR(1) + TR(2)*X + TR(3)*Y

         V = TR(4) + TR(5)*X + TR(6)*Y

   - 3-dimensional:

         U = TR(1) + TR(2)*X + TR(3)*Y + TR(4)*Z

         V = TR(5) + TR(6)*X + TR(7)*Y + TR(8)*Z

         W = TR(9) + TR(10)*X + TR(11)*Y + TR(12)*Z

   If a null value (!) is given it is assumed that the pixel
   co-ordinates of a given feature are identical in the two
   NDFs. [!]
2 Examples

wcscopy m51_sim m51
   This copies the WCS component from the NDF called m51 to the
   NDF called m51_sim, which may hold the results of a
   numerical simulation for instance. It is assumed that the
   two NDFs are aligned (i.e. the pixel co-ordinates of any
   feature are the same in both NDFs).

wcscopy m51_sqorst m51 [125,0.5,0.0,125,0.0,0.5]
   This example assumes that the application SQORST has
   previously been used to change the size of a 2-dimensional
   NDF called m51, producing a new NDF called m51_sqorst. Since
   SQORST has not yet been updated to support the full NDF
   structure, the output NDF m51_sqorst will not have a WCS
   component. More than this, SQORST also throws away the pixel
   origin information, effectively resetting the output origin
   to (1,1). This example shows how WCSCOPY can be used to
   rectify this by copying the WCS component from the original
   NDF m51 to the squashed NDF m51_sqorst, modifying it in the
   process to take account of both the squashing and the
   resetting of the pixel origin produced by sqorst. To do
   this, you need to work out the transformation in pixel
   co-ordinates produced by SQORST, and specify this when
   running WCSCOPY using the TR parameter. Let's assume the
   first axis of NDF m51 has pixel index bounds of I1:I2 (these
   values can be found using NDFTRACE). If the first axis in
   the squashed NDF m51_sqorst spans M pixels (where M is the
   value assigned to SQORST parameter XDIM), then it will have
   pixel index bounds of 1:M. Note, the lower bound is 1 since
   the pixel origin has been reset by SQORST. The squashing
   factor for the first axis is then:

    FX = M/(I2 - I1 + 1)

   and the shift in the pixel origin is:

    SX = FX*( 1 - I1 )

   Likewise, if the bounds of the second axis in m51 are J1:J2,
   and SQORST parameter YDIM is set to N, then the squashing
   factor for the second axis is:

    FY = N/(J2 - J1 + 1)

   and the shift in the pixel origin is:

    SY = FY*( 1 - J1 )

   You would then use the following values for parameter TR
   when running WCSCOPY:

    TR = [SX, FX, 0.0, SY, 0.0, FY]

   Note, the zero terms indicate that the axes are independent
   (i.e. there is no rotation of the image). The numerical
   values in the example are for an image with pixel index
   bounds of 52:251 on both axes which was squashed by SQORST
   to produce an image with 100 pixels on each axis.

wcscopy m51_pow m51 [-51,1,0,-51,0,1]
   The application POW has been used process a 2-dimensional
   NDF called m51, producing a new NDF called m51_pow. Since
   POW has not yet been updated to support the full NDF
   structure, the output NDF m51_pow will not have a WCS
   component. More than this, POW also throws away the pixel
   origin information, effectively resetting the output origin
   to (1,1). You can use WCSCOPY to rectify this by copying the
   WCS component from the original NDF m51 to the processed NDF
   m51_pow, modifying it in the process to take account of the
   resetting of the pixel origin produced by POW. To do this,
   you to work out the transformation in pixel co-ordinates
   produced by POW, and specify this when running WCSCOPY using
   the TR parameter. Let's assume the first axis of NDF m51 has
   pixel index bounds of I1:I2 (these values can be found using
   NDFTRACE). POW will produce an image with the same number of
   pixels along the axis but the first pixel will have index 1
   instead of I1. Thus the shift in the pixel origin is:

    SX = ( 1 - I1 )

   Likewise, the first pixel on the second axis will be reset to 1
   by POW, and so if the bounds of the second axis in m51 are J1:J2,
   the shift in the pixel origin for the second axis is:

    SY = ( 1 - J1 )

   You would then use the following values for parameter TR when
   running WCSCOPY:

    TR = [SX, 1.0, 0.0, SY, 0.0, 1.0]

   Note, the zero terms indicate that the axes are independent (i.e.
   there is no rotation of the image), and the 1.0 terms indicate
   that the pixels are not changed in size. The numerical values in the
   example are for an image with pixel index bounds of 52:251 on both
   axes. Another (maybe simpler) way to rectify the loss of origin
   information is to use application SETORIGIN to restore the pixel
   origin, and then use WCSCOPY, accepting the default null value for
   the parameter TR.
2 Notes
-  It is not necessary to use this application after running
KAPPA applications such as ROTATE or PIXDUPE, since all KAPPA
applications which produce a linear transformation in pixel
co-ordinates correctly copy WCS information from input to output.

-  An error is reported if the transformation supplied using parameter
TR is singular.

-  The pixel with pixel index I spans a range of pixel co-ordinate
from (I - 1.0) to (I).

-  The pixel indices of the bottom left pixel in an NDF is called
the "pixel origin" of the NDF, and can take any value. The pixel
origin can be examined using application NDFTRACE and set using
application SETORIGIN. WCSCOPY takes account of the pixel origins in
the two NDFs when modifying the WCS component. Thus, if a null
value is given for parameter TR, the supplied WCS component may still
be modified if the two NDFs have different pixel origins.
2 Related_Applications
   KAPPA: NDFTRACE, WCSFRAME, WCSREMOVE, WCSADD, WCSATTRIB
2 Authors
DSB: David Berry (STARLINK)
2 History
 13-AUG-1998 (DSB):
    Original version.

1 WCSFRAME
Change the current co-ordinate Frame in the WCS component of an NDF.

Usage:

   wcsframe ndf frame epoch

Description:

   This application displays the current co-ordinate Frame associated
   with an NDF and then allows the user to specify a new Frame. The
   current co-ordinate Frame determines the co-ordinate system in
   which positions within the NDF will be expressed when communicating
   with the user.
2 Parameters
For information on individual parameters, select from the list below:
3 EPOCH
EPOCH = _DOUBLE (Read)
   If a "Sky Co-ordinate System" specification is supplied (using
   parameter FRAME) for a celestial co-ordinate system, then an epoch
   value is needed to qualify it. This is the epoch at which the
   supplied sky positions were determined. It should be given as a
   decimal years value, with or without decimal places  ("1996.8" for
   example). Such values are interpreted as a Besselian epoch if less
   than 1984.0 and as a Julian epoch otherwise.
3 FRAME
FRAME = LITERAL (Read)
   A string specifying the new co-ordinate Frame. If a null parameter
   value is supplied, then the current Frame is left unchanged. The
   string can be one of the following:

   - A domain name such as SKY, AXIS, PIXEL, etc. The two
   "pseudo-domains" WORLD and DATA may be supplied and will be
   translated into PIXEL and AXIS respectively, so long as the WCS
   component of the NDF does not contain Frames with these domains.

   - An integer value giving the index of the required Frame within
   the WCS component.

   - A "Sky Co-ordinate System" (SCS) value such as EQUAT(J2000) (see
   section "Sky Co-ordinate Systems" in SUN/95).
3 NDF
NDF = NDF (Read and Write)
   The NDF data structure in which the current co-ordinate Frame is to
   be modified.
2 Examples
wcsframe m51 pixel
   This chooses pixel co-ordinates for the current co-ordinate
   Frame in the NDF m51.

wcsframe m51 sky
   This chooses celestial co-ordinates for the current co-ordinate
   Frame in the NDF m51. The specific celestial co-ordinate system
   will depend on the contents of the WCS component of the NDF.

wcsframe m51 equ(J2000) epoch=1998.2
   This chooses equatorial (RA/DEC) co-ordinates referred to the
   equinox at Julian epoch 2000.0 for the current co-ordinate
   Frame in the NDF m51. The positions were determined at the
   Julian epoch 1998.2 (this is needed to correct positions for
   the fictitious proper motions which may be introduced when
   converting between different celestial co-ordinate systems).

wcsframe m51 2
   This chooses the second co-ordinate Frame in the WCS component
   of the NDF.

wcsframe m51 data
   This chooses a co-ordinate Frame with domain DATA if one exists,
   or the AXIS co-ordinate Frame otherwise.

wcsframe m51 world
   This chooses a co-ordinate Frame with domain WORLD if one exists,
   or the PIXEL co-ordinate Frame otherwise.
2 Notes
-  The current co-ordinate Frame in the supplied NDF is not displayed
if a value is assigned to parameter FRAME on the command line.

-  This routine may add a new co-ordinate Frame into the WCS component
of the NDF.

-  The NDFTRACE command can be used to examine the co-ordinate
Frames in the WCS component of an NDF.
2 Related_Applications
   KAPPA: NDFTRACE, WCSREMOVE, WCSCOPY, WCSATTRIB
2 Authors
DSB: David Berry (STARLINK)
2 History
 13-AUG-1998 (DSB):
    Original version.

1 WCSREMOVE
Remove co-ordinate Frames from the WCS component of an NDF.

Usage:

   wcsremove ndf frames

Description:

   This application allows you to remove one or more co-ordinate Frames
   from the WCS component in an NDF. The indices of any remaining Frames
   are "shuffled down" to fill the gaps left by the removed Frames.
2 Parameters
For information on individual parameters, select from the list below:
3 FRAMES
FRAMES()  = LITERAL (Read
   The list of the indices (within the WCS component of the supplied NDF)
   of the Frames to be removed. Any indices outside the range of the
   available Frames are ignored. Single Frames or a set of adjacent
   Frames may be specified, e.g. typing [4,6-9,12,14-16] will remove
   Frames 4,6,7,8,9,12,14,15,16. (Note that the brackets are required to
   distinguish this array of characters from a single string including
   commas.  The brackets are unnecessary when there only one item.) If
   you wish to remove all the files enter the wildcard *. 5-* will
   remove from 5 to the last Frame.
3 NDF
NDF = NDF (Read and Write)
   The NDF data structure.
2 Examples
wcsremove m51 "3-5"
   This removes Frames 3, 4 and 5 from the NDF "m51". Any remaining
   Frames with indices higher than 5 will be re-numbered to fill the
   gaps left by the removed Frames (i.e. the original Frame 6 will
   become Frame 3, etc).
2 Notes
- The Frames within the WCS component of an NDF may be examined
using application NDFTRACE.
2 Related_Applications
   KAPPA: NDFTRACE, WCSADD, WCSFRAME, WCSATTRIB, WCSCOPY
2 Authors
DSB: David Berry (STARLINK)
2 History
 2-APR-1998 (DSB):
    Original version.

1 WCSSHOW
Examine the internal structure of an AST Object.

Usage:

   wcsshow ndf object logfile newwcs full quiet

Description:

   This application allows you to examine an AST Object stored in a
   specified NDF or HDS object. The structure can be dumped to a text
   file, or a Graphical User Interface can be used to navigate through
   the structure (see parameter LOGFILE). A new FrameSet can also be
   stored in the WCS component of the NDF (see parameter NEWWCS). This
   allows an NDF WCS component to be dumped to a text file, edited, and
   then restored to the NDF.

   The GUI main window contains the attribute values of the supplied AST
   Object. Only those associated with the Object's class are displayed
   initially, but attributes of the Objects parent classes can be
   displayed by clicking one of the class button to the top left of the
   window.

   If the Object contains attributes which are themselves AST Objects
   (such as the Frames within a FrameSet), then new windows can be
   created to examine these attributes by clicking over the attribute
   name.
2 Parameters
For information on individual parameters, select from the list below:
3 FULL
FULL = _INTEGER (Read)
   This parameter is a three-state flag and takes values of -1, 0 or
   +1. It controls the amount of information included in the output
   generated by this application. If FULL is zero, then a modest
   amount of non-essential but useful information will be included
   in the output. If FULL is negative, all non-essential information
   will be suppressed to minimise the amount of output, while if it is
   positive, the output will include the maximum amount of detailed
   information about the Object being examined. [current value]
3 LOGFILE
LOGFILE = FILENAME (Write)
   The name of the text file in which to store a dump of the
   specified AST Object. If a null (!) value is supplied, no log
   file is created. If a log file is given, the Tk browser window
   is not produced. [!]
3 NDF
NDF = NDF (Read or Update)
   If an NDF is supplied, then its WCS FrameSet is displayed. If a
   null (!) value is supplied, then the parameter OBJECT is used to
   specify the AST Object to display. Update access is required to
   the NDF if a value is given for parameter NEWWCS. Otherwise, only
   read access is required.
3 NEWWCS
NEWWCS = GROUP (Read)
   A group expression giving a dump of an AST FrameSet which
   is to be stored as the WCS component in the NDF given by parameter
   NDF. The existing WCS component is unchanged if a null value is
   supplied. The value supplied for this parameter is ignored if a
   null value is supplied for parameter NDF. The Base Frame in the
   FrameSet is assumed to be the GRID Frame. If a value is given for
   this parameter, then the log file or Tk browser will display the
   new FrameSet (after being stored in the NDF and retrieved). [!]
3 OBJECT
OBJECT = LITERAL (Read)
   The HDS object containing the AST Object to display. Only
   accessed if parameter NDF is null. It must have an HDS type
   of WCS, must be scalar, and must contain a single 1-D array component
   with name DATA and type _CHAR.
3 QUIET
QUIET = _LOGICAL (Read)
   If TRUE, then the structure of the AST Object is not displayed
   (using the Tk GUI). Other functions are unaffected. The dynamic
   default is TRUE if a non-null value is supplied for parameter
   LOGFILE or parameter NEWWCS, and FALSE otherwise. []
2 Examples
wcsshow m51
   Displays the WCS component of the NDF m51 in a Tk GUI.

wcsshow m51 logfile=m51.ast
   Dumps the WCS component of the NDF m51 to text file m51.ast.

wcsshow m51 newwcs=^m51.ast
   Reads a FrameSet from the text file m51.ast and stores it in the
   WCS component of the NDF m51. For instance, the text file m51.ast
   could be an edited version of the text file created in the
   previous example.

wcsshow object="~/agi_starprog.agi_3800_1.picture(4).more.ast_plot"
   Displays the AST Plot stored in the AGI database with X windows
   picture number 4.
2 Authors
DSB: David Berry (STARLINK)
2 History
 2-APR-1998 (DSB):
    Original version.

 5-OCT-1998 (DSB):
    Added parameter NDF.

1 WCSTRAN
Transform a position from one NDF co-ordinate Frame to another.

Usage:

   wcstran ndf posin framein [frameout]

Description:

   This application transforms a position from one NDF co-ordinate Frame
   to another. The input and output Frames may be chosen freely from the
   Frames available in the WCS component of the supplied NDF. The
   transformed position is formatted for display and written to the screen
   and also to an output parameter.
2 Parameters
For information on individual parameters, select from the list below:
3 EPOCHIN
EPOCHIN = _DOUBLE (Read)
   If a "Sky Co-ordinate System" specification is supplied (using
   parameter FRAMEIN) for a celestial co-ordinate system, then an epoch
   value is needed to qualify it. This is the epoch at which the
   supplied sky position was determined. It should be given as a
   decimal years value, with or without decimal places  ("1996.8" for
   example). Such values are interpreted as a Besselian epoch if less
   than 1984.0 and as a Julian epoch otherwise.
3 EPOCHOUT
EPOCHOUT = _DOUBLE (Read)
   If a "Sky Co-ordinate System" specification is supplied (using
   parameter FRAMEOUT) for a celestial co-ordinate system, then an epoch
   value is needed to qualify it. This is the epoch at which the
   transformed sky position is required. It should be given as a
   decimal years value, with or without decimal places  ("1996.8" for
   example). Such values are interpreted as a Besselian epoch if less
   than 1984.0 and as a Julian epoch otherwise.
3 FRAMEIN
FRAMEIN = LITERAL (Read)
   A string specifying the co-ordinate Frame in which the input
   position is supplied (see parameter POSIN). If a null parameter
   value is supplied, then the current Frame in the NDF is used. The
   string can be one of the following:

   - A domain name such as SKY, AXIS, PIXEL, etc. The two
   "pseudo-domains" WORLD and DATA may be supplied and will be
   translated into PIXEL and AXIS respectively, so long as the WCS
   component of the NDF does not contain Frames with these domains.

   - An integer value giving the index of the required Frame within
   the WCS component.

   - A "Sky Co-ordinate System" (SCS) value such as EQUAT(J2000) (see
   section "Sky Co-ordinate Systems" in SUN/95).
3 FRAMEOUT
FRAMEOUT = LITERAL (Read)
   A string specifying the co-ordinate Frame in which the transformed
   position is required. If a null parameter value is supplied, then
   the current Frame in the NDF is used. The string can be one of the
   following:

   - A domain name such as SKY, AXIS, PIXEL, etc. The two
   "pseudo-domains" WORLD and DATA may be supplied and will be
   translated into PIXEL and AXIS respectively, so long as the WCS
   component of the NDF does not contain Frames with these domains.

   - An integer value giving the index of the required Frame within
   the WCS component.

   - A "Sky Co-ordinate System" (SCS) value such as EQUAT(J2000) (see
   section "Sky Co-ordinate Systems" in SUN/95). [!]
3 NDF
NDF = NDF (Read and Write)
   The NDF data structure containing the required co-ordinate Frames.
3 POSIN
POSIN = LITERAL (Read)
   The co-ordinates of the position to be transformed, in the
   co-ordinate Frame specified by parameter FRAMEIN (supplying
   a colon ":" will display details of the required co-ordinate Frame).
   The position should be supplied as a list of formatted axis values
   separated by spaces or commas.
3 POSOUT
POSOUT = LITERAL (Write)
   The formatted co-ordinates of the transformed position, in the
   co-ordinate Frame specified by parameter FRAMEOUT. The position
   will be stored as a list of formatted axis values separated by
   spaces or commas.
3 QUIET
QUIET = _LOGICAL (Read)
   If TRUE, the transformed position is not written to the screen
   (it is still written to the output parameter POSOUT). [FALSE]
2 Examples
wcstran m51 "100.1 21.5" pixel
   This transforms the pixel position "100.1 21.5" into the current
   co-ordinate Frame of the NDF m51. The results are displayed on
   the screen and written to the output parameter POSOUT.

wcstran m51 "1:00:00 -12:30" equ(B1950) pixel quiet
   This transforms the RA/DEC position "1:00:00 -12:30" (referred
   (to the J2000 equinox) into pixel co-ordinates within the NDF m51.
   The results are written to the output parameter POSOUT, but are
   not displayed on the screen.
2 Related_Applications
   KAPPA: LISTMAKE, LISTSHOW, WCSFRAME, NDFTRACE, WCSATTRIB
2 Authors
DSB: David Berry (STARLINK)
2 History
 4-NOV-1998 (DSB):
    Original version.

1 WIENER
Applies a Wiener filter to a 1- or 2-dimensional array.

Usage:

   wiener in psf out xcentre ycentre

Description:

   This application filters the supplied 1- or 2-dimensional array
   using a Wiener filter.  It takes an array holding observed data
   and another holding a Point-Spread Function as input and produces
   an output restored array with potentially higher resolution and
   lower noise.  Generally superior results can be obtained using
   applications MEM2D or LUCY, but at the cost of much more
   processing time.

   The Wiener filter attempts to minimise the mean squared
   difference between the undegraded image and the restored image.
   To do this it needs to know the power spectrum of the undegraded
   image (i.e. the power at each spatial frequency before the
   instrumental blurring and the addition of noise).  Obviously,
   this is not usually available, and instead the power spectrum of
   some other image must be used (the `model' image).  The idea is
   that a model image should be chosen for which there is some a
   priori reason for believing it to have a power spectrum similar
   to the undegraded image.  Many different suggestions have been
   made for the best way to make this choice and the literature
   should be consulted for a detailed discussion (for instance, see
   the paper "Wiener Restoration of HST Images: Signal Models and
   Photometric Behavior" by I.C. Busko in the proceedings of the
   first Annual Conference  on Astronomical Data Analysis Software
   and Systems, Tucson).  By default, this application uses a
   `white' model image, i.e. one in which there is equal power at
   all spatial frequencies.  The default value for this constant
   power is the mean power per pixel in the input image.  There is
   also an option to use the power spectrum of a supplied model
   image.

   The filter also depends on a model of the noise in the supplied
   image.  This application assumes that the noise is 'white' and is
   constant across the image.  You can specify the noise power
   to use.  If a noise power of zero is supplied, then the Wiener
   filter just becomes a normal inverse filter which will tend to
   amplify noise in the supplied image.

   The filtering is done by multiplying the Fourier transform of the
   supplied image by the Fourier transform of the filter function.
   The output image is then created by taking the inverse Fourier
   transform of the product.  The Fourier transform of the filter
   function is given by:

               *
              H

        -------------
           2      Pn
        |H|   +  ----
                  Pg

   where H is the Fourier transform of the supplied Point-Spread
   Function, Pn is the noise power, Pg is the power in the model
   image, and the asterisk represents complex conjugation.  If the
   supplied model includes noise (as indicated by parameter QUIET)
   then Pn is subtracted from Pg before evaluating the above
   expression.
2 Parameters
For information on individual parameters, select from the list below:
3 IN
IN = NDF (Read)
   The input NDF containing the observed data.  This image may
   contain bad values, in which case the bad values will be
   replaced by zero before applying the filter.  The resulting
   filtered image is normalised by dividing each pixel value by
   the corresponding weight of the good input pixels.  These
   weights are found by filtering a mask image which holds the
   value one at every good input pixel, and zero at every bad
   input pixel.
3 MODEL
MODEL = NDF (Read)
   An NDF containing an image to use as the model for the power
   spectrum of the restored image.  Any bad values in this image
   are replaced by the mean of the good values.  If a null value
   is supplied then the model power spectrum is taken to be
   uniform with a value specified by parameter PMODEL. [!]
3 OUT
OUT = NDF (Write)
   The restored output array.  An extension named WIENER is added
   to the output NDF to indicate that the image was created by
   this application (see parameter QUIET).
3 PMODEL
PMODEL = _REAL (Read)
   The mean power per pixel in the model image.  This parameter
   is only accessed if a null value is supplied for parameter
   MODEL.  If a value is obtained for PMODEL then the model image
   is assumed to have the specified constant power at all spatial
   frequencies.  The run-time default is the mean power per pixel
   in the input image. []
3 PNOISE
PNOISE = _REAL (Read)
   The mean noise power per pixel in the observed data.  For
   Gaussian noise this is equal to the variance.  The run-time
   default is an estimate of the noise variance based on the
   difference between adjacent pixel values in the observed
   data. []
3 PSF
PSF = NDF (Read)
   An NDF holding an estimate of the Point-Spread Function (PSF)
   of the input array.  This could, for instance, be produced
   using the KAPPA application "PSF".  There should be no bad
   pixels in the PSF otherwise an error will be reported.  The
   PSF can be centred anywhere within the array, but the location
   of the centre must be specified using parameters XCENTRE and
   YCENTRE.  The PSF is assumed to have the value zero outside
   the supplied NDF.
3 QUIET
QUIET = _LOGICAL (Read)
   This specifies whether or not the image given for parameter
   MODEL (or the value given for parameter PMODEL), includes
   noise.  If the model does not include any noise then a TRUE
   value should be supplied for QUIET.  If there is any noise in
   the model then QUIET should be supplied FALSE.  The run-time
   default is FALSE, unless the image given for parameter MODEL
   was created by a previous run of WIENER (as indicated by the
   presence of a WIENER extension in the NDF), in which case the
   run time default is TRUE (i.e. the previous run of WIENER is
   assumed to have removed the noise). []
3 THRESH
THRESH = _REAL (Read)
   The fraction of the PSF peak amplitude at which the extents of
   the PSF are determined.  These extents are used to derive the
   size of the margins that pad the supplied input array.  Lower
   values of THRESH will result in larger margins being used.
   THRESH must be positive and less than 0.5.  [0.0625]
3 TITLE
TITLE = LITERAL (Read)
   A title for the output NDF.  A null (!) value means using the
   title of the input NDF. [!]
3 WLIM
WLIM = _REAL (Read)
   If the input array contains bad values, then this parameter
   may be used to determine the minimum weight of good input
   values required to create a good output value.  It can be
   used, for example, to prevent output pixels from being
   generated in regions where there are relatively few good input
   values to contribute to the restored result.  It can also be
   used to `fill in' small areas (i.e. smaller than the PSF) of
   bad pixels.

   The numerical value given for WLIM specifies the minimum total
   weight associated with the good pixels in a smoothing box
   required to generate a good output pixel (weights for each
   pixel are defined by the normalised PSF).  If this specified
   minimum weight is not present, then a bad output pixel will
   result, otherwise a smoothed output value will be calculated.
   The value of this parameter should lie between 0.0 and
   1.0.  WLIM=0 causes a good output value to be created even if
   there is only one good input value, whereas WLIM=1 causes a
   good output value to be created only if all input values are
   good. [0.001]
3 XCENTRE
XCENTRE = _INTEGER (Read)
   The x pixel index of the centre of the PSF within the supplied
   PSF array.  The suggested default is the middle pixel (rounded
   down if there are an even number of pixels per line).
3 YCENTRE
YCENTRE = _INTEGER (Read)
   The y pixel index of the centre of the PSF within the supplied
   PSF array.  The suggested default is the middle line (rounded
   down if there are an even number of lines).
2 Examples
wiener cenA star cenA_hires 11 13
   This example deconvolves the array in the NDF called cenA,
   putting the resulting array in the NDF called cenA_hires.
   The PSF is defined by the array in NDF star, and the centre
   of the PSF is at pixel (11,13).

wiener cenA star cenA_hires 11 13 pnoise=0
   This example performs the same function as the previous
   example, except that the noise power is given as zero.  This
   causes the Wiener filter to reduce to a standard inverse
   filter, which will result in more high frequencies being
   present in the restored image.

wiener cenA star cenA_hires 11 13 model=theory quiet
   This example performs the same function as the first example,
   except that the power spectrum of the restored image is
   modelled on that of NDF theory, which may for instance
   contain a theoretical model of the object in NDF cenA,
   together with a simulated star field.  The parameter QUIET is
   set to a TRUE value to indicate that the theoretical model
   contains no noise.
2 Notes
- The convolutions required by the Wiener filter are performed by
the multiplication of Fourier transforms.  The supplied input
array is extended by a margin along each edge to avoid problems
of wrap-around between opposite edges of the array.  The width of
this margin is about equal to the width of the significant part
of the PSF (as determined by parameter THRESH).  The application
displays the width of these margins.  The margins are filled by
replicating the edge pixels from the supplied input NDFs.
2 Related_Applications
   KAPPA: FOURIER, LUCY, MEM2D.
2 Authors
DSB: David Berry (STARLINK)

MJC: Malcolm J. Currie (STARLINK)
2 History
 17-MAR-1995 (DSB):
    Original version, based on MEM2D and Rhys Morris's WIENER.

 1995 March 29 (MJC):
    Added commentary and related-applications section, corrected
    typo's, used a modern-style variable declaration and other
    stylistic changes, shortened long lines, and made message
    reporting conditional.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   LABEL, TITLE, UNITS, WCS and HISTORY components of the
   input NDF and propagates all extensions.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.  Arithmetic
   is performed using single-precision floating point.
1 ZAPLIN
Replaces regions in a 2-d NDF by bad values or by linear
interpolation.

Usage:

   zaplin in out [title] colin=? lincol=? columns=? lines=?

Description:

   This routine replaces selected areas within a 2-dimensional input NDF
   (specified by parameter IN), either by filling the areas with bad
   values, or by linear interpolation between neighbouring data values
   (see parameter ZAPTYPE). Each area to be replaced can be either
   a range of pixel columns extending the full height of the image, a
   range of pixel lines extending the full width of the image, or a
   rectangular region with edges parallel to the pixel axes (see
   parameter LINCOL).

   The bounds of the area to be replaced can be specified either by
   using a graphics cursor, or directly in response to parameter prompts,
   or by supplying a text file containing the bounds (see parameter MODE).
   In the first two modes the application loops asking for new areas
   to zap, until told to quit or an error is encountered. In the last
   mode processing stops when the end of file is found. An output text
   file may be produced containing a description of the areas replaced
   (see parameter COLOUT). This file may be used to specify the
   regions to be replaced in a subsequent invocation of ZAPLIN.
2 Parameters
For information on individual parameters, select from the list below:
3 COLIN
COLIN =  FILENAME (Read)
   The name of a text file containing the bounds of the areas to be
2 Examples
zaplin out=cleaned colout=fudge.dat
   Assuming the current value of parameter MODE is "Cursor", this
   will copy the NDF associated with the last DATA picture to an
   NDF called "cleaned", interactively replacing areas using the
   current graphics device.  Linear interpolation is used to obtain
   the replacement values. A record of the areas replaced will be
   stored in a text file named "fudge.dat".

zaplin grubby cleaned i lincol=r columns=[188,190] lines=[15,16]
   This replaces a region from pixel (188,15) to (190,16) within the
   NDF called "grubby" and stores the result in the NDF called
   "cleaned".  The current co-ordinate Frame in the input NDF should
   be set to PIXEL first (using WCSFRAME). The replacement is
   performed using linear interpolation.

zaplin grubby(6,,) cleaned i lincol=r columns=[188,190]
   This replaces columns 188 to 190 in the 6th y-z plane region
   within the NDF called "grubby" and stores the result in the NDF
   called "cleaned".  The current co-ordinate Frame in the input NDF
   should be set to PIXEL first (using WCSFRAME). The replacement is
   performed using linear interpolation.

zaplin m42 m42c f colin=aaoccd1.dat zaptype=b
   This flags with bad values the regions in the NDF called "m42"
   defined in the text file called "aaoccd1.dat", and stores the
   result in an NDF called "m42c".

zaplin m42 m42c f colin=aaoccd1.dat noise
   As above except that linear interpolation plus cosmetic noise
   are used to replace the areas to be cleaned rather than bad
   pixels.
2 Notes
-  Bounds supplied in Interface and File mode are transformed into
the PIXEL Frame of the input NDF before being used.

-  Complicated results arise if the axes of the current Frame of the
input NDF are not parallel to the pixel axes. In these cases it is
usually better to switch to the PIXEL Frame (using WCSFRAME) prior to
using ZAPLIN. Roughly speaking, the range of pixel lines and/or
columns which are replaced will include any which intersect the
specified range on the current Frame axis.

-  When using input files care should be taken to ensure that
the co-ordinate system used in the file matches the current
co-ordinate Frame of the input NDF.

-  If the input NDF is a section of an NDF with a higher
dimensionality, the "lines" and "columns" are with respect to the
2-dimensional section, and do not necessarily refer to the first
and second dimensions of the NDF as a whole.  See the "Examples".
2 Authors
MJM: Mark McCaughrean (UoE)

MJC: Malcolm J. Currie (STARLINK)

DSB: David S. Berry (STARLINK)
2 History
 01-07-1985 (MJM):
    First implementation, using line/column co-ordinates read from
    the user directly, rather than by use of an interactive cursor
    on a display screen.

 09-12-1985 (MJM):
    Added Poisson noise option and corrected error checking bug.

 11-12-1985 (MJM):
    Fixed bug caused by continuous updating of read only data -
    changed program order.

 06-07-1986 (MJM):
    Tidied and more error checking.

 1986 Aug 8 (MJC):
    Added invocation. Renamed ZAPLINSUB to ZPLNSB.  Reordered
    arguments in ZPLNSB (2nd to 6th). Added status check for
    the output DATA_ARRAY component and associated indentation.

 1986 Sep 1 (MJC):
    Added arguments and deficiencies section to the prologue and
    tidied. Used CHR_UCASE rather than UPCASE. Referred to lines
    rather than rows hence some parameter names were changed.

 1987 Oct 15 (MJC):
    Reordered tidying and corrected method.

 1988 Mar 17 (MJC):
    Referred to `array' rather than `image'.

 1988 Jun 5 (MJC):
    More reporting of error context.

 1989 Jun 13 (MJC):
    Allow for processing primitive NDFs.

 1989 Aug  7 (MJC):
    Passed array dimensions as separate variables to COPY2D and
    ZPLNSB.

 1990 Mar 31 (MJC):
    Added cursor and file modes.

 1990 Apr 8 (MJC):
    Added zapping type (i.e. bad option) and the region zapping.

 1991 May 26 (MJC):
    NDF version featuring co-ordinate systems.

 1992 March 3 (MJC):
    Replaced AIF parameter-system calls by the extended PAR
    library.

 1992 April 13 (MJC):
    Made to handle significant dimensions for user-defined
    sections.

 1992 November 30 (MJC):
    Does not use non-monotonic axis centres.

 1993 December 13 (MJC):
    Fixed bug in cursor mode where the region bounds were half a
    pixel too small, i.e. in co-ordinates not pixel indices.

 1995 September 20 (MJC):
    Changed default of TITLE to null.

 5-JUN-1998 (DSB):
    Added propagation of the WCS component.

 18-JAN-2000 (DSB):
    Changed to use PGPLOT for graphics and to read and write
    co-ordinates in the current Frame of the NDF. Reformatted code
    layout.
2 Implementation_Status
   -  This routine correctly processes the AXIS, DATA, QUALITY,
   VARIANCE, LABEL, TITLE, UNITS, WCS and HISTORY components of the
   input NDF and propagates all extensions.

   -  Processing of bad pixels and automatic quality masking are
   supported.

   -  All non-complex numeric data types can be handled.
