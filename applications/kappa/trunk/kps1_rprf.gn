      SUBROUTINE KPS_$RDPRF<T>( ARRAY, DIM1, DIM2, SIG0, AXISR, THETA,
     :                          RANGE, POS, NXY, WT, PNCLER, PNDEV,
     :                          PNXSIZ, PNYSIZ, PNMINT, PNMAJT, PNOUTT,
     :                          COMMNT, FWHM, GAMMA, STATUS )
*+
*  Name:
*     KPS_$RDPRFx

*  Purpose:
*     Fits a radial profile to a set of star images.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL KPS_$RDPRFx( ARRAY, DIM1, DIM2, SIG0, AXISR, THETA, RANGE,
*    :                  POS, NXY, WT, PNCLER, PNDEV, PNXSIZ, PNYSIZ,
*    :                  PNMINT, PNMAJT, PNOUTT, COMMNT, FWHM, GAMMA,
*    :                  STATUS )

*  Description:
*     This routine combines the profiles of a number of stars whose
*     individual centroids are known, as well as the mean shape, sigma
*     and orientation for the entire sample.  It derives the two
*     parameters that define a Gaussian fit to the set of star images.

*     Optionally, the results can be displayed graphically.  This 
*     comprises the mean profile at each bin with its associated error
*     bar, and the smooth fit to those data.

*  Arguments:
*     ARRAY( DIM1, DIM2 ) = ? (Given)
*        The input array in which the star images lie.
*     DIM1 = INTEGER (Given)
*        The number of pixels per line of the array.
*     DIM2 = INTEGER (Given)
*        The number of lines in the array.
*     SIG0 = REAL (Given)
*        The star 'sigma' across the minor axis.
*     AXISR = REAL (Given)
*        The star axis ratio.
*     THETA = REAL (Given)
*        The orientation of star major axis to the x axis in radians
*        (x through y positive).
*     RANGE = REAL (Given)
*        The number of star 'sigma's out to which the radial profile is
*        fitted.
*     POS( 2, NXY ) = REAL (Given)
*        Each line comprises the accurate x then y positions of a 
*        star centre.
*     NXY = INTEGER (Given)
*        The number of stars to be fitted.
*     WT( NXY ) = REAL (Given)
*        The accurate star-centre y positions.
*     SIG( NXY ) = REAL (Given)
*        Star-present flag; positive for the stars to be used, and zero
*        for those to be omitted.
*     PNCLER = CHARACTER * ( * ) (Given)
*        The name of an ADAM parameter which will be used to see if the
*        user wishes the display to be cleared.
*     PNDEV = CHARACTER * ( * ) (Given)
*        The name of an ADAM parameter which will be associated with
*        a graphics workstation.
*     PNXSIZ = CHARACTER * ( * ) (Given)
*        The name of an ADAM parameter which will be used to get the 
*        required x extent of the FRAME picture in metres.
*     PNYSIZ = CHARACTER * ( * ) (Given)
*        The name of an ADAM parameter which will be used to get the 
*        required y extent of the FRAME picture in metres.
*     PNMINT = CHARACTER * ( * ) (Given)
*        The name of an ADAM parameter which will be used to get the 
*        numbers of minor tick marks per major tick. 
*     PNMAJT = CHARACTER * ( * ) (Given)
*        The name of an ADAM parameter which will be used to get the 
*        numbers of major tick marks.
*     PNOUTT = CHARACTER * ( * ) (Given)
*        The name of an ADAM parameter which will be used to determine
*        whether the ticks should appear inside or outside the grid
*        region of the plot.
*     COMMNT = CHARACTER * ( * ) (Given)
*        A comment to store in the AGI database with the FRAME and
*        DATA pictures.
*     FWHM = REAL (Returned)
*        An estimate of the full width at half maximum across the minor
*        axis of a star image.
*     GAMMA = REAL (Returned)
*        Star radial-profile parameter.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Notes:
*     -  There is a routine for each numeric data type: replace "x" in
*     the routine name by D, R, I, W, UW, B, UB as appropriate.  The
*     array supplied to the routine must have the data type specified.
*     -  If graphics are selected two pictures are stored in the 
*     graphics database: a FRAME picture of the requested size, and a
*     DATA picture for the grid, with radius and profile world
*     co-ordinates.

*  Algorithm:
*     -  For each star, put the data into bins representing isophotal
*     zones, allowing for image ellipticity.
*     -  Form a linked list of all the pixels in each zone, then process
*     the contents of each zone using the mode to reject erroneous data.
*     -  Fit a Gaussian to each binned star and normalise the data to
*     unit central amplitude.
*     -  Put the normalised data into a set of bins filled
*     with data for all stars.  Fit a radial profile to these combined
*     data.
*     -  Print the results.  If required, plot the mean profile and the 
*     fitted function.

*  Notes:
*     -  This is a server routine for PSF via KPS_$SPARMx.

*  Authors:
*     RFWS: R.F. Warren-Smith (Durham Univ.)
*     MJC: Malcolm J. Currie (STARLINK)
*     {enter_new_authors_here}

*  History:
*     1981 (RFWS):
*        Original version.
*     1990 September 20 (MJC):
*        Made generic, renamed from RADPRF, removed INVAL and ILEVEL,
*        passed extra arguments for the plotting and graphics database,
*        a log file, combined x and y positions into a single array,
*        commented the variables, and converted the prologue.
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}

*-
      
*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants
      INCLUDE 'PAR_ERR'          ! Parameter-system errors
      INCLUDE 'PRM_PAR'          ! Magic-value definitions

*  Arguments Given:
      INTEGER
     :  DIM1, DIM2,
     :  NXY

      <TYPE>
     :  ARRAY( DIM1 * DIM2 )
      
      REAL
     :  AXISR,
     :  RANGE,
     :  SIG0,
     :  THETA,
     :  POS( 2, NXY ),
     :  WT( NXY )

      CHARACTER * ( * )
     :  COMMNT,
     :  PNCLER,
     :  PNDEV,
     :  PNXSIZ,
     :  PNYSIZ,
     :  PNMINT,
     :  PNMAJT,
     :  PNOUTT

*  Arguments Returned:
      REAL
     :  FWHM,
     :  GAMMA

*  Status:
      INTEGER STATUS             ! Global status

*  Local Constants:
      INTEGER MAXRAD             ! Maximum radius in pixels of the
                                 ! radial profile
      PARAMETER ( MAXRAD = 50 )
      INTEGER MAXPTS             ! Maximum number of pixels to be
                                 ! considered for the radial profile
      PARAMETER ( MAXPTS = (2 * MAXRAD + 1) ** 2 )
      REAL RESOL1                ! Resolution (no. of bins per pixel
                                 ! spacing) for binning the radial
                                 ! profiles of each star
      PARAMETER ( RESOL1 = 2.5 )
      REAL RESOL2                ! Resolution (no. of bins per pixel
                                 ! spacing) for binning the mean radial
                                 ! profile
      PARAMETER ( RESOL2 = 10.0 )
      INTEGER NBIN1              ! Number of bins for each star
      PARAMETER ( NBIN1 = MAXRAD * RESOL1 + 1 )
      INTEGER NBIN2              ! Number of bins for the mean star
      PARAMETER ( NBIN2 = MAXRAD * RESOL2 + 1 )
      REAL PBAD                  ! Probability that a pixel is corrupt
      PARAMETER ( PBAD = 0.01 )
      INTEGER NITER              ! Maximum number of iterations during
                                 ! the cleaning
      PARAMETER ( NITER = 10 )
      INTEGER NITFIT             ! Maximum number of iterations during
                                 ! the fitting
      PARAMETER ( NITFIT = 20 )
      REAL TOLFIT                ! Tolerance of the fitting
      PARAMETER ( TOLFIT = 0.0005 )

*  Local Variables:

      <LTYPE>
     :  DATA( MAXPTS )           ! The pixels of a radial bin

      REAL
     :  AMP,                     ! Gaussian amplitude
     :  BACK,                    ! Background level
     :  C,                       ! Cosine of the orientation
     :  CONSTA,                  ! Constant for relating distance in
                                 ! elliptical star image to effective
                                 ! distance along the minor axis
     :  CONSTB,                  ! Constant for relating distance in
                                 ! elliptical star image to effective
                                 ! distance along the minor axis
     :  CONSTC,                  ! Constant for relating distance in
                                 ! elliptical star image to effective
                                 ! distance along the minor axis
     :  DET,                     ! Determinant
     :  DMODE( 0:NBIN1 ),        ! The mode of a radial bin
     :  DSIG,                    ! The sigma of a radial bin
     :  DX,                      ! Pixel displacement in x from the star
                                 ! centre
     :  DX0,                     ! x displacement of the first pixel in
                                 ! the box
     :  DX2,                     ! x pixel displacement squared
     :  DXY,                     ! x * y displacement
     :  DY,                      ! Pixel displacement in y from the star
                                 ! centre
     :  DY2,                     ! y pixel displacement squared
     :  FUNCT,                   ! Gaussian function at a bin
     :  FW                       ! Weighted Gaussian function at a bin

      REAL
     :  MAJTIC( 2 ),             ! Parameters controlling the numbers of
                                 ! major tick marks along x and y axes
                                 ! respectively
     :  MINTIC( 2 ),             ! Numbers of minor tick marks along x
                                 ! and y axes respectively
     :  PROFIL( 0:NBIN2 ),       ! Mean profile values
     :  PROFWT( 0:NBIN2 ),       ! Weight of mean profile
     :  PROFR( 0:NBIN2 ),        ! Mean profile radii
     :  R( 0:NBIN1 ),            ! Mean radii for each bin
     :  RADIUS,                  ! Current mean profile radius
     :  RAXISR,                  ! Reciprocal minor-axis squared
     :  RDASH,                   ! Effective radius
     :  RLIMIT,                  ! Radius limit in the minor axis
     :  RMAX,                    ! Maximum radius mean profile
     :  RSCALE,                  ! Scale factor for converting radial
                                 ! distance into bins (per star)
     :  RSCL2,                   ! Scale factor for converting radial
                                 ! distance into bins (mean star)
     :  RSIG,                    ! Reciprocal sigma
     :  S,                       ! Sine of the orientation
     :  SIGMA,                   ! Gaussian sigma
     :  XMAX, YMAX,              ! Maximum x-y values for the plot
     :  XMIN, YMIN               ! Minimum x-y values for the plot

      INTEGER
     :  BIN,                     ! Bin counter for a star
     :  BIN2,                    ! Bin counter for the mean star
     :  I, J,                    ! Loop counters for pixels in the box
                                 ! around a star
     :  IADR( MAXPTS ),          ! Linked-list pixel indices
     :  ICOUNT,                  ! Number of bin values in DATA
     :  IMIN, IMAX,              ! x pixel indices of region around a
                                 ! star
     :  IMLOCN,                  ! Index to data vector
     :  INDEX,                   ! Linked-list counter
     :  ISHIFT,                  ! Half-width of the square around the
                                 ! star image
     :  I0, J0,                  ! Pixel nearest the star centre
     :  JMIN, JMAX,              ! y pixel indices of region around a
                                 ! star
     :  LSTART( 0:NBIN1 ),       ! Linked list starts of all pixels in a
                                 ! given radial bin
     :  MXBIN1,                  ! Number of bins for each star
     :  MXBIN2,                  ! Number of bins for mean star
     :  NDATA,                   ! Number points to plot in the mean
                                 ! profile
     :  NXTADR( MAXPTS ),        ! Next pixel indices in the linked list
     :  NPTS( 0:NBIN1 ),         ! Number of pixels in each bin
     :  PICID,                   ! Input picture identifier
     :  PICIDD,                  ! Data-picture identifier
     :  STAR,                    ! Number of the star
     :  ZONE                     ! SGS zone associated with the frame
                                 ! picture

      DOUBLE PRECISION 
     :  SUMD,                    ! Sum of weighted data values
     :  SUMDF,                   ! Sum of Gaussian weighted mode
     :  SUMF,                    ! Sum of Gaussian weights
     :  SUMF2,                   ! Sum of Gaussian weights squared
     :  SUMW                     ! Sum of the number of points

      CHARACTER
     :  BUFFER * 80              ! Buffer to write results

      LOGICAL                    ! True if:
     :  OUTTIC                   ! Axis tick marks are to be placed
                                 ! outside the box instead of inside

*.

*     Check inherited global status.

      IF ( STATUS .NE. SAI__OK ) RETURN

*    Calculate the constants for relating radial distance in an
*    elliptical star image to effective distance along the minor axis.

      S = SIN( THETA )
      C = COS( THETA )
      RAXISR = ( 1.0 / AXISR ) ** 2
      CONSTA = S * S + C * C * RAXISR
      CONSTB = C * C + S * S * RAXISR
      CONSTC = 2.0 * C * S * ( RAXISR - 1.0 )

*    Calculate scale factors for converting radial distance to bins.

      RSIG = 1.0 / SIG0
      RSCALE = RESOL1 * 2.0 / MIN( 2.0, SIG0 )
      RSCL2 = RESOL2 * 2.0 / MIN( 2.0, SIG0 )

*    Find the radius limit in the minor axis direction imposed by
*    the fitting limit 'range'.

      RLIMIT = RANGE * SIG0

*    Find the size of square to be scanned around each star to
*    accommodate the radial fitting range.

      ISHIFT = MIN( MAX( 1, NINT( RLIMIT * AXISR ) ), MAXRAD )

*    Find the number of bins to be used in binning the radial profiles
*    of each star and of the mean profile.

      MXBIN1 = MIN( NBIN1, INT( RLIMIT * RSCALE ) )
      MXBIN2 = MIN( NBIN2, INT( RLIMIT * RSCL2 ) )

*    Initialise the arrays to hold the mean radial profile.

      DO BIN = 0, NBIN2
         PROFR( BIN ) = 0.0
         PROFIL( BIN ) = 0.0
         PROFWT( BIN ) = 0.0
      END DO

*    Consider each star which has positive weight.

      DO STAR = 1, NXY

         IF ( WT( STAR ) .GT. 1.0E-10 ) THEN

*          Find the edges of the search square centred on the star.

            I0 = NINT( MIN( MAX( -1.0E8, POS( 1, STAR ) ), 1.0E8 ) )
            J0 = NINT( MIN( MAX( -1.0E8, POS( 2, STAR ) ), 1.0E8 ) )
            IMIN = MAX( 1, I0 - ISHIFT )
            IMAX = MIN( DIM1, I0 + ISHIFT )
            JMIN = MAX( 1, J0 - ISHIFT )
            JMAX = MIN( DIM2, J0 + ISHIFT )

*          Initialise the arrays to point to the start of a linked list
*          of all the pixels in a given radial bin and to form the mean
*          radius for each bin.

            DO BIN = 0, MXBIN1
               R( BIN ) = 0.0
               NPTS( BIN ) = 0
               LSTART( BIN ) = 0
            END DO

*          Scan the square around the star, calculating the x and y
*          displacements from the centre.  Note the use of a vector
*          index.

            INDEX = 0
            DY = JMIN - POS( 2, STAR ) - 1.0
            DX0 = IMIN - POS( 1, STAR ) - 1.0

            DO J = JMIN, JMAX
               IMLOCN = ( J - 1 ) * DIM1 + IMIN - 1
               DY = DY + 1.0
               DY2 = DY * DY
               DX = DX0

               DO I = IMIN, IMAX
                  IMLOCN = IMLOCN + 1
                  DX = DX + 1.0

*                If the pixel is valid, calculate the effective radius.

                  IF ( ARRAY( IMLOCN ) .NE. VAL__BAD<T> ) THEN
                     DX2 = DX * DX
                     DXY = DX * DY
                     RDASH = SQRT( CONSTA * DX2 + CONSTB * DY2 +
     :                             CONSTC * DXY )

*                   Find the radial bin.

                     BIN = RDASH * RSCALE

                     IF ( BIN .LE. MXBIN1 .AND. RDASH .LE. RLIMIT ) THEN

*                      Form sums for the effective mean radius.

                        NPTS( BIN ) = NPTS( BIN ) + 1
                        R( BIN ) = R( BIN ) + RDASH

*                      Form a linked list of all the pixels in this
*                      radial bin.

                        INDEX = INDEX + 1
                        IADR( INDEX ) = IMLOCN
                        NXTADR( INDEX ) = LSTART( BIN )
                        LSTART( BIN ) = INDEX
                     END IF

                  END IF

               END DO

            END DO

*          Initialise sums for forming a least-squares Gaussian fit to
*          the star radial profile and background.

            SUMW = 0.0D0
            SUMF = 0.0D0
            SUMF2 = 0.0D0
            SUMDF = 0.0D0
            SUMD = 0.0D0

*          Consider each bin with one or more points in it.

            DO BIN = 0, MXBIN1

               IF ( LSTART( BIN ) .GT. 0 ) THEN

*                Extract the pixels in this bin from the linked list
*                and store in the array 'data'.  The linked list only
*                points to good pixels and so further bad-pixel
*                checking is not required.

                  ICOUNT = 0
                  INDEX = LSTART( BIN )

    5             CONTINUE
                  IF ( INDEX .GT. 0 ) THEN
                     ICOUNT = ICOUNT + 1
                     DATA( ICOUNT ) = ARRAY( IADR( INDEX ) )
                     INDEX = NXTADR( INDEX )
                     GO TO 5

                  END IF

*                Find the most likely value in the bin.

                  IF ( ICOUNT .EQ. 1 ) THEN
                     DMODE( BIN ) = DATA( 1 )

                  ELSE
                     CALL KPG_$MODE<T>( DATA, ICOUNT, PBAD, NITER, 0.1,
     :                                  DMODE( BIN ), DSIG, STATUS )
                  END IF

*                Form the mean effective radius for the bin.

                  R( BIN ) = R( BIN ) / NPTS( BIN )

*                Form sums for fitting a Gaussian profile using the
*                number of data points as a weight.

                  FUNCT = EXP( - 0.5 * ( R( BIN ) * RSIG ) *  * 2 )
                  FW = FUNCT * NPTS( BIN )
                  SUMW = SUMW + NPTS( BIN )
                  SUMF = SUMF + FW
                  SUMF2 = SUMF2 + ( FUNCT * FW )
                  SUMDF = SUMDF + DMODE( BIN ) * FW
                  SUMD = SUMD + DMODE( BIN ) * NPTS( BIN )
               END IF

            END DO

*          Solve the normal equations for the Gaussian fit.

            DET = SUMF2 * SUMW - SUMF * SUMF

            IF ( DET .NE. 0.0 ) THEN
               AMP = ( SUMW * SUMDF - SUMD * SUMF ) / DET
               BACK = ( SUMF2 * SUMD - SUMDF * SUMF ) / DET

*             Insert the star profile into the mean-profile bins.

               DO BIN = 0, MXBIN1

                  IF ( LSTART( BIN ) .GT. 0 ) THEN
                     BIN2 = R( BIN ) * RSCL2

                     IF ( BIN2 .LE. MXBIN2 ) THEN

*                     Use the number of points and the star amplitude
*                     as weights during the summations.

                        PROFIL( BIN2 ) = PROFIL( BIN2 ) + NPTS( BIN ) *
     :                                   ( DMODE( BIN ) - BACK )
                        PROFR( BIN2 ) = PROFR( BIN2 ) + R( BIN ) * AMP *
     :                                  NPTS( BIN )
                        PROFWT( BIN2 ) = PROFWT( BIN2 ) + AMP *
     :                                   NPTS( BIN )
                     END IF
                  END IF

               END DO

*          End of positive-determinant check.

            END IF

*       End of check to include star or not.

         END IF

*    End of the loop for each star.

      END DO

*    Having processed the individual stars we can now
*    compute a mean profile.
*    =======================

*    Calculate the mean radial profile and associated radii from the
*    binned data.

      DO BIN = 0, MXBIN2

         IF ( PROFWT( BIN ) .GT. 0.0 ) THEN
            PROFIL( BIN ) = PROFIL( BIN ) / PROFWT( BIN )
            PROFR( BIN ) = PROFR( BIN ) / PROFWT( BIN )
         END IF

      END DO

*    Set initial estimates of profile parameters and call routine to
*    obtain a full least-squares fit to the profile.

      AMP = 1.0
      BACK = 0.0
      GAMMA = 2.0
      SIGMA = SIG0
      CALL KPS_$PRGFTR( PROFIL, PROFWT, PROFR, MXBIN2 + 1, NITFIT,
     :                  TOLFIT, AMP, BACK, SIGMA, GAMMA, STATUS )

      FWHM = VAL__BADR

*    If fit was not successful.

      IF ( STATUS .EQ. SAI__OK ) THEN

*       Calculate full-width-half-maximum seeing.

         FWHM = 2.0 * SIGMA * ( 1.38629 ** ( 1.0 / GAMMA ) )

*       Plotting
*       ========

*       Start a new error context.

         CALL ERR_MARK

*       Plot an error-bar graph of the data using the NCAR graphics
*       package.

         CALL NCROPN( PNCLER, PNDEV, PNXSIZ, PNYSIZ, COMMNT,
     :                PICID, PICIDD, ZONE, STATUS )

*       Get the number of minor ticks.

         CALL AIF_GET1R( 'MINTIC', -1., VAL__MAXR, 2, MINTIC, STATUS )

*       Get the parameter controlling the number of major ticks per
*       axis.

         CALL AIF_GET1R( 'MAJTIC', -1., VAL__MAXR, 2, MAJTIC, STATUS )

*       Are the tick marks on the outside of the axes?

         CALL AIF_GTDLG( 'OUTTIC', .TRUE., OUTTIC, STATUS )

*       A null return can prevent graphical output.

         IF ( STATUS .EQ. SAI__OK ) THEN

*           Compress the data arrays to remove empty bins and also find
*           maximum and minimum values to be plotted in x and y.

            NDATA = -1

            XMAX = VAL__MINR
            XMIN = VAL__MAXR
            YMAX = VAL__MINR
            YMIN = VAL__MAXR

            DO BIN = 0, MXBIN2

               IF ( PROFWT( BIN ) .GT. 0.0 ) THEN
                  NDATA = NDATA + 1
                  PROFIL( NDATA ) = PROFIL( BIN ) - BACK
                  PROFR( NDATA ) = PROFR( BIN )
                  PROFWT( NDATA ) = 0.0

                  XMAX = MAX( XMAX, PROFR( NDATA ) )
                  XMIN = MIN( XMIN, PROFR( NDATA ) )
                  YMAX = MAX( YMAX, PROFIL( NDATA ) + PROFWT( NDATA ) )
                  YMIN = MIN( YMIN, PROFIL( NDATA ) - PROFWT( NDATA ) )
               END IF

            END DO

*          Plot the results.
*          =================

*          First the annotated axes and records the DATA picture.  There
*          will be major tick marks at the ends of each axis.

            CALL NCRBCK( XMIN, XMAX, YMIN, YMAX, 'Mean Star Profile',
     :                   'Radial Distance', 'Intensity', MINTIC, MAJTIC,
     :                   OUTTIC, .TRUE., COMMNT, PICID, PICIDD, STATUS )

*          Plot the profile points and error bars.

            CALL DREBAR( PROFR, PROFIL, PROFWT, NDATA + 1, STATUS )

*          Calculate the fitted profile over the data range.

            RMAX = PROFR( NDATA )

            DO BIN = 0, MXBIN2
               RADIUS = ( RMAX * BIN ) / MXBIN2
               PROFR( BIN ) = RADIUS
               PROFIL( BIN ) = AMP * EXP( - 0.5 * ( ( RADIUS /
     :                         MAX( 0.001, SIGMA ) ) *  * GAMMA ) )
            END DO

*          Plot the fitted function.

            CALL AGCURV( PROFR, 1, PROFIL, 1, MXBIN2 + 1, 1 )

*          Close down the database.


            CALL AGS_DEACT( STATUS )
            CALL AGI_ANNUL( PICID, STATUS )

*       Clean up after a null response (meaning no plotting).  We do not
*       want ! to become the current device.

         ELSE IF ( STATUS .EQ. PAR__NULL ) THEN
            CALL ERR_ANNUL( STATUS )
            CALL AGI_CANCL( PNDEV, STATUS )      
         END IF

*       Release the error context.

         CALL ERR_RLSE

      END IF

      END
