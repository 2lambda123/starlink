#!/bin/tcsh
# Name:
#    make_unix_release
#
# Purpose:
#    Do unix specific bits required to make a release of kappa.
#
# Type of Module:
#    Shell script
#
# Description:
#    This command creates a compressed tar file containing a release of the 
#    kappa package. It is called from within the make_release script. 
#    
# Invocation:
#    make_unix_release
#
# Authors:
#    DSB: David S. Berry (STARLINK)
#    {enter_new_authors_here}
#
# History:
#    4-DEC-1997 (DSB):
#       Original version, based on POLPACK equivalent.
#    {enter_changes_here}
#
# Bugs:
#    {note_any_bugs_here}
#-

#  Ensure the sdt grp command is available.
      source $SDT_DIR/startup.csh

#  Store the name of the release directory, and go there.
      set REL_DIR = ${TEMPDIR}/kappa_${SYSTEM}
      cd ${REL_DIR}

#  See if the hypertext documents are to be re-created.
#      echo -n "Re-create kappa.htx? (y/n): "
#      set ans = $<
#      if( $ans == "y" ) then
#         star2html sun95.tex
#         tar -cvhf ./sun95.htx_tar sun95.htx/*
#         rm -rf sun95.htx
#         mv ./sun95.htx_tar ${KAPPA_DEV}/..
#      endif

#  Expand any generic source files.
      foreach file (`grp generic_sources`)
         generic -t n -s ${file}
      end

#  Check for direct calls to NDF parameter routines. These should usually
#  be replaced by equivalent LPG routines (to allow multiple invocations to 
#  process groups of NDFs).
      set n = `grep -il "PAR_STATE\|NDF_ASSOC\|NDF_PROP\|NDF_CREAT\|NDF_CREP" *.f`
      if( "$n" != "" ) then
         echo "The following files contain references to NDF parameter routines or"
         echo "to PAR_STATE. Shouldn't these be replaced by equivalent LPG routines??"
         echo $n
         echo -n "Continue? (Y/N): "
         set ans = $<
         if( "$ans" == "n" || "$ans" == "N" ) then
            exit
         endif
      endif

#  Copy the hypertext docs to the release directory.
      cp ${KAPPA_DEV}/../sun95.htx_tar ${REL_DIR}
      cp ${KAPPA_DEV}/../sun221.htx_tar ${REL_DIR}

#  Ensure all files are accessable.
      chmod 777 *

#  Edit in the current package version number into any required source files.
      set vers = `grep "PKG_VERS = " makefile`
      if ( "$vers" == "" ) then
         echo "Can't get package version number from makefile."
         exit
      endif

      foreach file (kappa_mon.f kapview_mon.f ndfpack_mon.f kappa.ifd kappa.demo)
         sed -e "s#PKG_VERS#$vers[3]#g" $file > temp
         mv -f temp $file
      end

#  Generate the ifl files, and the icl and csh start-up scripts. 
      ifd2star kappa

#  Do any necessary post processing of the generated files to overcome 
#  deficiencies in ifd2star
      sed -e "s#picgrid 'picdef mode=array fraction=1.0#picgrid 'picdef array 1.0#g" kappa.csh > temp
      mv temp kappa.csh
      sed -e "s#picxy 'picdef mode=xy fraction=1.0#picxy 'picdef xy 1.0#g" kappa.csh > temp
      mv temp kappa.csh

      sed -e "s#picg(rid) picdef mode=array fraction=1.0#picg(rid) picdef array 1.0#g" kappa.icl > temp
      mv temp kappa.icl
      sed -e "s#picx(y) picdef mode=xy fraction=1.0#picx(y) picdef xy 1.0#g" kappa.icl > temp
      mv temp kappa.icl
            
      sed -e 's#prefix=""#prefix=\\"\\"#g' kappa.csh > temp
      mv temp kappa.csh

#  Generate the IRAF files.
      ifd2iraf kappa

#  Generate the IRAF documentation.
      mv kappa.star-hlp kappa.hlp
      ifd_irafhlpgen kappa

#  Remove entries from kappa.men and kappa.hd which do not relate to actions.
      $KAPPA_DEV/bin/mencheck.tcl
      $KAPPA_DEV/bin/hdcheck.tcl


#  Create a CL script which will create the help database on sa1.
      cat > temp.cl << FOO
set kappa = /sa1/home/dsb/iraf/kappa/
so
mkhelpdb kappa\$root.hd helpdb.mip
lo
FOO

#  Create a tcsh script to set things up on sa1 and activate the CL script.
      cat > kapiraf << FOO2
#!/usr/local/bin/tcsh
cd iraf
rm -rf kappa
mkdir kappa
cd kappa
ftp -v sl5 << FOO3
ascii
cd ${REL_DIR}
get root.hd
get _kappa.hd
get kappa.hd
get temp.cl
bye
FOO3
mv temp.cl ..
cd ..
cl < temp.cl
FOO2
      chmod u+x kapiraf

#  FTP this file to sa1.
      ftp -v sa1 << FOO4
ascii
put kapiraf
bye
FOO4
      rm kapiraf 

#  Ask the user to execute the script on sa1. Why wont rsh do this?
      echo " "
      echo " "
      echo "  Now log into sa1 and do 'source kapiraf'"
      echo " "
      echo -n "Press RETURN to continue ..."
      set ans = $<

#  Now FTP the helpdb.mip file back from sa1.
      ftp -v sa1 << FOO5
binary
cd iraf
get helpdb.mip
bye
FOO5
      rm temp.cl

#  Create each of the tar files. First do the system-independant ones
#  listed in group TAR_FILES_A...
      foreach file (`grp tar_files_a`)
         tar -cvh -f ${TEMPDIR}/${file}.tar `grp ${file}`
         rm -f `grp ${file}`
         mv ${TEMPDIR}/${file}.tar ${REL_DIR}
      end

#  Now do the system-dependant ones listed in group TAR_FILES_B. The contents
#  of these tar files have the SYSTEM value appended to the end of each file 
#  name.
      foreach file (`grp tar_files_b`)
         setenv news " "
         foreach item (`grp ${file}`)
            setenv new `echo ${item} | awk -F. '{print $1"."$2}'` 
            mv $item $new
            setenv news "$news $new"
         end

         tar -cvh -f ${TEMPDIR}/${file}.tar $news
         rm -f $news
         mv ${TEMPDIR}/${file}.tar ${REL_DIR}
      end

#  Make the ctg and lpg source tar files.
      ${CTG_SYS}/dev/bin/make_source.csh
      ${LPG_SYS}/dev/bin/make_source.csh

#  Tar up all the release files and then remove them.
      tar -cvh -f ${TEMPDIR}/kappa.tar `grp unix_total` 
      rm `grp unix_total` 
      mv ${TEMPDIR}/kappa.tar ${REL_DIR}
      rm -rf doc kappa.ifd

#  Compress it.
      compress kappa.tar

# Remove any spare .f files created by the expansion of generic source
# files but not included in the release. Also remove grp.make.
      rm -f *.f grp.make

      exit
