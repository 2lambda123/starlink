      SUBROUTINE FITSIN( STATUS )
*+
*  Name:
*     FITSIN

*  Purpose:
*     Reads a FITS tape composed of simple, group or table files.

*  Language:
*     Starlink Fortran 77

*  Type of Module:
*     ADAM A-task

*  Invocation:
*     CALL FITSIN( STATUS )

*  Arguments:
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Description:
*     This application reads selected files from a FITS tape.  The
*     files may be Basic (simple) FITS, and/or have TABLE extensions
*     (Harten et al. 1988).
*
*     The programme reads a simple or a random-groups-format FITS file
*     (Wells et al. 1981; Greisen & Harten 1981), and writes the data
*     into an NDF, and the headers into the NDF's FITS extension.
*     Table-format files (Grosbol et al. 1988) are read, and the
*     application creates two files: a text formatted table/catalogue
*     and a FACTS description file (as used by SCAR) based upon the FITS
*     header cards.  Composite FITS files can be processed.  You may
*     specify a list of files, including wildcards.  A record of the
*     FITS headers, and group parameters (for a group-format file) can
*     be stored in a text file.
*
*     There is an option to run in automatic mode, where the names of
*     output NDF data structures are generated automatically, and you
*     can decide whether or not format conversion is to be applied to
*     all files (rather than being prompted for each).  This is very
*     useful if there is a large number of files to be processed.  Even
*     if you want unique file names, format-conversion prompting may be
*     switched off globally.

*  Usage:
*     fitsin mt files out [auto] fmtcnv [logfile] more=? dscftable=?
*        table=?

*  ADAM Parameters:
*     AUTO = _LOGICAL (Read)
*        It is TRUE if automatic mode is required, where the name of
*        each output NDF structure or table file is to be generated by
*        the application, and therefore not prompted; and a global
*        format-conversion switch may be set.  In manual mode the FITS
*        header is reported, but not in automatic.
*
*        For simple or group format FITS objects in automatic mode the
*        application generates a filename beginning with a defined
*        prefix followed by the number of the file on tape.  For
*        example, if the prefix was "XRAY" and the 25th file of the
*        tape was being processed, the filename of the NDF would be
*        XRAY25.
*
*        For table-format FITS objects in the automatic mode the
*        application generates a filename beginning with a defined
*        prefix followed by the number of the file on tape.  For
*        example, if the prefix was "cat" and the 9th file of the tape
*        was being processed, the filename of the table and its
*        associated FACTS description file would be cat9.dat and
*        dscfcat9.dat respectively.
*        [FALSE]
*     DSCFTABLE = FILENAME (Read)
*        Name of the text file to contain the FACTS descriptors, which
*        defines the table's format for SCAR.  Since SCAR is now
*        deprecated, this parameter has little use, except perhaps to
*        give a summary of the format of the file specified by parameter
*        TABLE.  A null value (!) means that no description file will
*        be created, so this is now the recommended usage.  If your
*        FITS file comprises just tables, you should consider other
*        tools such as the CURSA package, which has facilities for
*        examining and processing ASCII and binary FITS tables.
*
*        A suggested filename for the description file is reported
*        immediately prior to prompting in manual mode.  It is the name
*        of the catalogue, as written in the FITS header, with a "dscf"
*        prefix.
*     ENCODINGS = LITERAL (Read)
*        Determines which FITS keywords should be used to define the
*        world co-ordinate systems to be stored in the NDF's WCS
*        component.  The allowed values (case-insensitive) are:
*
*        "FITS-IRAF" --- This uses keywords CRVALi CRPIXi, CDi_j, and is the
*           system commonly used by IRAF. It is described in the document
*           "World Coordinate Systems Representations Within the FITS Format"
*           by R.J. Hanisch and D.G. Wells, 1988, available by ftp from
*           fits.cv.nrao.edu /fits/documents/wcs/wcs88.ps.Z.
*
*        "FITS-WCS" --- This is the proposed FITS standard WCS encoding scheme
*           described in the paper "Representation of celestial coordinates
*           in FITS" (http://www.cv.nrao.edu/fits/documents/wcs/wcs.html).
*           It is very similar to FITS-IRAF but supports a wider range of
*           projections and co-ordinate systems. Once the standard has been
*           agreed, this encoding should be understood by any FITS-WCS
*           compliant software and it is likely to be adopted widely for FITS
*           data in future.
*
*        "FITS-PC" --- This uses keywords CRVALi, CDELTi, CRPIXi, PCiiijjj,
*           etc, as described in a previous (now superceded) draft of the
*           above FITS world co-ordinate system paper by E.W.Greisen and
*           M.Calabretta.
*
*        "FITS-AIPS" --- This uses conventions described in the document
*           "Non-linear Coordinate Systems in AIPS" by Eric W. Greisen
*           (revised 9th September, 1994), available by ftp from
*           fits.cv.nrao.edu /fits/documents/wcs/aips27.ps.Z. It is currently
*           employed by the AIPS data analysis facility, so its use will
*           facilitate data exchange with AIPS. This encoding uses CROTAi
*           and CDELTi keywords to describe axis rotation and scaling.
*
*        "DSS" --- This is the system used by the Digital Sky Survey, and
*           uses keywords AMDXn, AMDYn, PLTRAH, etc.
*
*        "NATIVE" --- This is the native system used by the AST library (see
*           SUN/210) and provides a loss-free method for transferring WCS
*           information between AST-based application. It allows more
*           complicated WCS information to be stored and retrieved than any of
*           the other encodings.
*
*        A comma-separated list of up to six values may be supplied,
*        in which case the value actually used is in the first in the
*        list for which corresponding keywords can be found in the FITS
*        header.
*
*        A FITS header may contain keywords from more than one of these
*        encodings, in which case it is possible for the encodings to
*        be inconsistent with each other.  This may happen for instance
*        if an application modifies the keyword associated with one
*        encoding but fails to make equivalent modifications to the
*        others.  If a null parameter value (!) is supplied for
*        ENCODINGS, then an attempt is made to determine the most
*        reliable encoding to use as follows.  If both native and
*        non-native encodings are available, then the first non-native
*        encoding to be found which is inconsistent with the native
*        encoding is used.  If all encodings are consistent, then the
*        native encoding is used (if present). [!]
*     FILES()  = _CHAR (Read)
*        The list of the file numbers to be processed.  Files are
*        numbered consecutively from 1 from the start of the tape.
*        Single files or a set of adjacent files may be specified, e.g.
*        typing [4,6-9,12,14-16] will read files 4,6,7,8,9,12,14,15,16.
*        (Note that the brackets are required to distinguish this array
*        of characters from a single string including commas.  The
*        brackets are unnecessary when there only one item.) For
*        efficiency reasons it is sensible to give the file numbers in
*        ascending order.
*
*        If you wish to extract all the files enter the wildcard *.
*        5-* will read from 5 to the last file.  The processing will
*        continue until the end of the tape is reached; no error
*        will result from this.
*     FMTCNV = _LOGICAL (Read)
*        This specifies whether or not format conversion will occur.
*        If FALSE, the HDS type of the data array in the NDF will be
*        the equivalent of the FITS data format on tape (e.g. BITPIX =
*        16 creates a _WORD array).  If TRUE, the data array in the
*        current file, or all files in automatic mode, will be
*        converted from the FITS data type on tape to _REAL in the NDF.
*        The conversion applies the values of the FITS keywords BSCALE
*        and BZERO to the tape data to generate the `true' data values.
*        If BSCALE and BZERO are not given in the FITS header, they are
*        taken to be 1.0 and 0.0 respectively.  The suggested default
*        is TRUE.
*     GLOCON  = _LOGICAL (Read)
*        If FALSE, a format-conversion query occurs for each FITS file.
*        If TRUE, the value of FMTCNV is obtained before any file
*        numbers and will apply to all data arrays.  It is ignored
*        in automatic mode---in effect it becomes true. [FALSE]
*     LABEL  = _LOGICAL (Read)
*        It should be TRUE if the tape has labelled files.  Labelled
*        files are non-standard.  If TRUE, the application skips three
*        file marks per file, rather that one. [FALSE]
*     LOGFILE = FILENAME (Read)
*        The file name of the text log of the FITS header cards.
*        For group-format data the group parameters are evaluated
*        and appended to the full header.  The log includes the names of
*        the output files used to store the data array or table. A null
*        value (!) means that no log file is produced. [!]
*     MORE   = _LOGICAL (Read)
*        A prompt asking if any more files are to be processed once the
*        current list has been exhausted.
*     MT = DEVICE (Read)
*        Tape deck containing the data, usually an explicit device,
*        though it can be a pre-assigned environment variable.
*     OUT = NDF (Write)
*        Output NDF structure holding the full contents of the FITS
*        file.  If the null value (!) is given no NDF will be created.
*        This offers an opportunity to review the descriptors before
*        deciding whether or not the data are to be extracted.
*     PREFIX = LITERAL (Read)
*        The prefix of the NDF's or table's file name.  It is only used
*        in the automatic mode.
*     REWIND = _LOGICAL (Read)
*        If it is TRUE, the tape drive is rewound before the reading of
*        the FITS files commences.  If it is FALSE, the tape is not
*        rewound, and the current tape position is read from file
*        USRDEVDATASET.sdf.  Note that file numbers are absolute and
*        not relative.  REWIND = FALSE is useful if you need to read a
*        series of files, process them, then read some more, without
*        having to remember the tape's position or apply unnecessary
*        wear to the tape.  [TRUE]
*     TABLE = FILENAME (Read)
*        Name of the text file to contain the table itself, read from
*        the tape.  In manual mode the suggested default filename is
*        the name of description file less the "dscf" prefix, or if
*        there is no description file or if the description file does
*        not have the dscf prefix, the suggested name reverts to the
*        catalogue name in the FITS header.

*  Examples:
*     fitsin mt=/dev/rmt/1n files=[2-4,9] auto prefix=ccd nofmtcnv
*        This reads files 2, 3, 4, and 9 from the FITS tape on
*        device /dev/rmt/1n.  The output NDF names will be ccd2, ccd3,
*        ccd4, and ccd9 (assuming there are no groups).  The data will
*        not have format conversion.
*     fitsin mt=$TAPE files=* auto prefix=ccd fmtcnv logfile=jkt.log
*        This reads all the files from the FITS tape on the device
*        assigned to the environment variable TAPE.  The output files
*        begin with a prefix "ccd".  Integer data arrays are converted
*        to real using the scale and zero found in the FITS header.  A
*        record of the headers and the names of the output files are
*        written to the text file jkt.log.

*  Algorithm:
*     -  Inquire the operating system
*     -  Open a logfile if required.
*     -  Get byte workspace to the character buffers.
*     -  Associate the tape drive. Find out whether the tape is
*     labelled.
*     -  Determine whether or not automatic operation is wanted. If it
*     is obtain the global format conversion and the filename prefix,
*     otherwise see whether or not a global format-conversion is
*     required, and obtain its polarity if it required.
*     -  There is a loop which applies to rest of the algorithm which
*     continues if there are more files to process.  Inquire and report
*     the tape position.  Read the list of files to be processed.
*     -  Loop for each item in the list determining the lower and upper
*     file numbers.  Move to required file.  Read the first tape
*     block to obtain the blocksize and then obtain the first record in
*     the FITS file.  Report a non-standard blocksize.
*     -  Create workspace to store the FITS headers.  Process the header
*     sections storing them in the workspace.  Find the number of
*     headers, the length and start cards of each header section.  The
*     application will not work if there is more than one dummy header
*     in each sub-file.  Obtain the mandatory headers.  See if the
*     sub-file is an extension.  Report the headers to the log file and
*     to the user in manual mode.
*     -  If the sub-file is an extension check that it is supported
*     currently TABLE alone.  If it is table, call a routine to create
*     a SCAR description file from the headers and a text table from
*     the FITS data.
*     -  If it is not an extension obtain the data type, format, scale,
*     zero and data blank.  If it is group-format find the number of
*     groups and parameters per group.  If group format extend the
*     workspace to accommodate the group parameters for each array.
*     -  For integer data decide whether or not format conversion is
*     required if not decided globally. Get the input and output
*     formats.  In automatic mode generate a file root name from the
*     prefix and file number.
*     -  Call a routine to create the output NDF, with a generated
*     name in automatic mode.  Read the tape, filling the data array.
*     Apply a format conversion if needed and substitute blank values
*     with bad-pixel values.  Make a dummy NDF data array if there is
*     no FITS array.  Convert IEEE data to their Vax representations.
*     Create axis structures if there is axis data in the FITS header.
*     Create the TITLE and UNITS components.
*     -  If there is an extension immediately following set the flag
*     to indicate that the record has been read and loop back to
*     process the sub-file, otherwise loop to the next file number.
*     When the file list has been exhausted ask if more files are
*     required.  If so return to the beginning of the main loop.  If
*     not tidy up.

*  References:
*     Wells, D.C., Greisen, E.W. & Harten, R.H. 1981,
*        Astron. Astrophys. Suppl. Ser. 44, 363.
*     Greisen, E.W. & Harten, R.H. 1981,
*        Astron. Astrophys. Suppl. Ser. 44, 371.
*     Grosbol, P., Harten, R.H., Greisen, E.W & Wells, D.C.
*        1988 Astron. Astrophys. Suppl. Ser. 73, 359.
*     Harten, R.H., Grosbol, P., Greisen, E.W & Wells, D.C.
*        1988 Astron. Astrophys. Suppl. Ser. 73, 365.

*  Related Applications:
*     KAPPA: FITSDIN, FITSHEAD, FITSIMP, FITSLIST; CONVERT: FITS2NDF;
*     CURSA; Figaro: RDFITS.

*  Implementation Status:
*     -  The application processes tapes blocked at other than an
*     integer multiple of 2880 bytes up to a maximum of 63360, provided
*     it is a multiple of the number of bytes per data value.
*
*     -  For simple or group format FITS:
*        -  IEEE floating point is supported.
*        -  If BUNIT is present its value will appear as the NDF's
*        UNITS component.
*        -  If OBJECT is present its value will appear as the NDF's
*        TITLE component.
*        -  If the BLANK item is present in the header, undefined pixels
*        are converted from the BLANK value to Starlink-standard bad
*        value during data conversion.
*        -  An AXIS component will be stored in the NDF if the CRVALn
*        keyword is present.  (n is the number of the dimension.)  If
*        the CRPIXn keyword is absent it defaults to 1, and likewise
*        for the CDELTn keyword.  The value of CRTYPEn is made the label
*        of the axis structure.
*     -  For groups format, a new NDF is created for each data array.
*     The name of the NDF of the second and subsequent data arrays is
*     generated by the application as the <filename>G<number>, where
*     filename is the name of the first NDF, supplied by you or
*     generated automatically, and <number> is the number of the group.
*
*     Each group NDF contains the full header in the FITS extension,
*     appended by the set of group parameters.  The group parameters
*     are evaluated using their scales and offsets, and made to look
*     like FITS cards, whose keywords are derived from the values of
*     PTYPEm in the main header.  (m is the number of the group
*     parameter.) The same format is used in the log file.
*     -  If there is no data array on tape, i.e. the FITS file comprises
*     header cards only, then a dummy vector data array of dimension
*     two is created to make the output a valid NDF.  This data array
*     is undefined.

*  Copyright:
*     Copyright (C) 1987-1993 Science & Engineering Research Council.
*     Copyright (C) 1995-1996, 1998, 2000, 2004 Central Laboratory of
*     the Research Councils. All Rights Reserved.

*  Licence:
*     This program is free software; you can redistribute it and/or
*     modify it under the terms of the GNU General Public License as
*     published by the Free Software Foundation; either version 2 of
*     the License, or (at your option) any later version.
*
*     This program is distributed in the hope that it will be
*     useful, but WITHOUT ANY WARRANTY; without even the implied
*     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
*     PURPOSE. See the GNU General Public License for more details.
*
*     You should have received a copy of the GNU General Public License
*     along with this program; if not, write to the Free Software
*     Foundation, Inc., 59 Temple Place,Suite 330, Boston, MA
*     02111-1307, USA

*  Authors:
*     MJC: Malcolm J. Currie (STARLINK)
*     PMA: Peter Allan (University of Manchester)
*     DSB: David S. Berry (STARLINK)
*     TIMJ: Tim Jenness (JAC, Hawaii)
*     {enter_new_authors_here}

*  History:
*     1987 Jul  8 (PMA):
*        Uses HDS but not the NDF format as it was not then defined.
*     1988 Mar 25 (PMA):
*        Second version. Modified to use FITS extension to standard NDF
*        format.
*     1988 Apr 19 (PMA):
*        Allow a null parameter for the output dataset, which skips the
*        processing of that file. This allows the user to read the fits
*        header and to then decide not to create an output file.
*     1988 May (MJC):
*        Converted to KAPPA style, added further error checks and
*        aborts, removed references to the Interim environment.
*     1988 Sept  (MJC):
*        Greatly expanded and rewritten to process group-format files
*        and blocked records.
*     1988 Nov  2 (MJC):
*        Corrected some of the tidying, particularly cancelling OUTPUT,
*        annulling FLOC and fixing an editing typo' unmapping and
*        annulling of the work array.
*     1988 Nov  3 (MJC):
*        Added automatic mode, no data-conversion option and more
*        commentary as each file is processed.
*     1988 Nov  4 (MJC):
*        Close HDS files created by HDS_NEW to prevent lots of files
*        being open .
*     1988 Nov  5 (MJC):
*        Version that uses MORE.FITS instead of MORE.FITS.IN in case we
*        change our minds! .
*     1989 Feb 15 (MJC):
*        Corrected tidying of all workspace .
*     1989 Jul 19 (MJC):
*        Removed LOGHDR parameter and tested for a null log-file name;
*        reported all groups' completed via the same method, so that
*        logical prefixes appears for the first group.
*     1989 Aug  1 (MJC):
*        Converted to read tables format.
*     1989 Sep 18 (MJC):
*        NOCON is now a global-format-conversion PROMPTING switch,
*        formerly it could only set no format conversion globally (when
*        not in automatic mode), the name of the output file is written
*        to the logfile.
*     1989 Nov 22 (MJC):
*        Loops for multiple FITS files/extensions within a tape file,
*        and sub file numbers written to the log file.
*     1989 Nov 24 (MJC):
*        Change to use OFFSET=ACTSIZ meaning block is exhausted rather
*        than the counter-intuitive 0; skip over data for null output
*        files.
*     1989 Dec 21 (MJC):
*        Workspace managed by AIF_TEMP.
*     1990 Jan 11 (MJC):
*        Fixed bug in the test for multiple files so that it tests for
*        blank data in the current block.
*     1990 Feb 20 (MJC):
*        Auto mode is available for table files, replaced SUBPAR calls
*        by AIF_FLNAM call, AIF_OPFIO call renamed AIF_ASFIO, and
*        logging of table and description file names.
*     1990 Nov 15 (MJC):
*        NDF version featuring axes, title and units; expanded and
*        restructured prologue; parameter NOCON renamed GLOCON so that
*        a NO prefix may be used to indicate false.
*     1990 November 30 (MJC):
*        Altered logic to process FITS records rather than blocks and
*        modified subroutine calls to reflect this (record-processing is
*        needed to handle disk files and tape consistently by the same
*        subroutines). IEEE floating-point supported.
*     1991 February 28 (MJC):
*        Added the NCARD argument for various revised FTS1_x calls.
*     1991 October 10 (MJC):
*        Fixed bug when GLOCON and FMTCNV set to true and dealing with
*        IEEE-format data.
*     1991 October 11 (MJC):
*        Increased the maximum buffer size to 22 FITS records in order
*        to accommodate IRAF's non-standard blocking factors.
*     1992 February 24 (MJC):
*        Ensured that HDS file mapping will occur after tuning option
*        is added.
*     1992 March 3 (MJC):
*        Replaced AIF parameter-system calls by the extended PAR
*        library.
*     1993 April 15 (MJC):
*        Made to work on UNIX.
*     1993 December 3 (MJC):
*        Made to work for Alphas.
*     1995 October 5 (MJC):
*        Documentation overhaul.  Changed dynamic default of FMTCNV.
*     1995 November 18 (MJC):
*        The tape drive is no longer rewound.
*     1996 June 11 (MJC):
*        Added REWIND parameter to control initial rewinding.  Linux
*        usage enabled.
*     18-FEB-1998 (DSB):
*        Call to FTS1_GKEYL had arguments THERE and NOCCUR swapped, causing
*        a segmentation violation.
*     9-JUN-1998 (DSB):
*        Added support for WCS component.
*     11-APR-2000 (DSB):
*        Added FITS-PC and FITS-AIPS WCS encodings.
*     2004 September 3 (TIMJ):
*        Use CNF_PVAL
*     {enter_further_changes_here}

*-

*  Type Definitions:
      IMPLICIT  NONE           ! no default typing allowed

*  Global Constants:
      INCLUDE 'SAE_PAR'        ! SSE global definitions
      INCLUDE 'DAT_PAR'        ! Data-system constants
      INCLUDE 'GRP_PAR'        ! GRP_ constants
      INCLUDE 'MAG_ERR'        ! MAG-error definitions
      INCLUDE 'PAR_ERR'        ! Parameter-system errors
      INCLUDE 'CNF_PAR'        ! For CNF_PVAL function

*  Status:
      INTEGER  STATUS

*  External References:
      INTEGER
     :  CHR_LEN                ! String length less trailing blanks

      LOGICAL
     :  FTS1_BLCAR             ! Tests whether the first card image of a
                               ! FITS record has a blank keyword

*  Local Constants:
      INTEGER
     :  BLKSIZ,                ! Maximum blocksize, which is the FITS
                               ! record length, times the maximum
                               ! blocking factor of ten
     :  MAXCOD,                ! No. of known AST encodings.
     :  MAXHDR,                ! Maximum number of header sections in a
                               ! sub-file, including dummy header
                               ! sections before the extension *with* data
     :  MXCARD,                ! Maximum number of card images per block
     :  MXFILE,                ! Maximum size of input file list
     :  MXPARM,                ! Maximum number of parameters that can
                               ! be associated with a group-format array
     :  MXAXIS,                ! Maximum number of axes
     :  RECSIZ                 ! FITS record size
      PARAMETER(
     :  RECSIZ = 2880,
     :  BLKSIZ = RECSIZ * 22,
     :  MAXCOD = 3,
     :  MAXHDR = 2,
     :  MXCARD = BLKSIZ / 80,
     :  MXFILE = 32,
     :  MXPARM = 999,
     :  MXAXIS = DAT__MXDIM )

*  Local Variables:
      INTEGER
     :  ACTSIZ,                ! Actual size of a tape block
     :  BITPIX,                ! Number of bits per pixel
     :  BLANK,                 ! Tape data value assigned to undefined-
                               ! value pixels
     :  BLKNO,                 ! Dummy returned by tape-position inquiry
     :  BPV,                   ! Number of bytes per pixel
     :  BF,                    ! number of complete FITS records per
                               ! tape block
     :  BFPNTR,                ! Pointer to FITS block buffer
     :  BFPNTD,                ! Descriptor for FITS block buffer
     :  DIMS( MXAXIS ),        ! The size of each axis
     :  FIRST,                 ! First tape file in a sequence
     :  FD,                    ! file description
     :  FN,                    ! File number of the tape
     :  FS,                    ! File sequence
     :  GCOUNT                 ! Number of groups contained in the file

      INTEGER
     :  HDNUM( MAXHDR ),       ! Number of headers cards in each header
                               ! section in the sub-file
     :  HPNTR( 1 ),            ! Pointer to array to store the header
                               ! cards for the sub-file
     :  HSTART( MAXHDR ),      ! Start card number of each header
                               ! section of the sub-file in the full
                               ! header
     :  LAST,                  ! Last tape file in a sequence
     :  MT,                    ! Tape descriptor
     :  NC,                    ! Number of characters in NDF character
                               ! component
     :  NCF,                   ! Number of characters in the file number
     :  NCH,                   ! Number of characters returned by
                               ! CHR_ITOC
     :  NCROOT,                ! Number of characters in file root name
     :  NDIM                   ! Number of dimensions in the FITS image

      INTEGER
     :  NFSPEC,                ! Number of file sequences to be
                               ! processed
     :  NHEADS,                ! Number of header sections in the FITS
                               ! sub-file and including the
                               ! dummy header section
     :  NKC,                   ! Number of a header card image that
                               ! contains a specified keyword
     :  OFFSET,                ! The number of bytes of the current tape
                               ! block that contains processed
                               ! information (equal to ACTSIZ zero means
                               ! the block has been fully processed)
     :  OLDMAP,                ! The value of the HDS MAP tuning
                               ! parameter on entry to this routine
     :  PARAMS( MXPARM ),      ! Numerical values of parameters
                               ! associated with a group-format array,
                               ! note this assumes a BITPIX of no more
                               ! 32 (4 bytes per value)
     :  PCOUNT,                ! The number of parameter values
                               ! preceeding each data array
     :  RCPNTR,                ! Pointer to FITS record
     :  RCPNTD,                ! Descriptor for FITS record
     :  SIZE,                  ! Total size of the data array
     :  SUBFIL,                ! Number of the FITS sub file
     :  WHDIM( 1 )             ! Size of the structure to store the
                               ! header cards
      INTEGER
     :  NENCOD,                ! No. of of WCS encodings supplied
     :  ADDED,                 ! Number of items added to a group
     :  ENCGRP                 ! Group identifier of ENCODINGS

      LOGICAL                  ! True if:
     :  AUTO,                  ! Automatic mode is operative
     :  BADPIX,                ! Data array has undefined pixels
     :  CURREC,                ! The current FITS record is to be used
                               ! immediately
     :  DARRAY,                ! There is a data array in the FITS file
     :  EFMTCV,                ! The type of the data on tape will be
                               ! converted to real in the output data
                               ! structure
     :  EXTEND,                ! There is a FITS extension (XTENSION=T)
     :  FMTCNV,                ! The type of the data on tape will be
                               ! converted to real in the output data
                               ! structure if it is permissible
     :  GEXTND,                ! The tape file may contain an extension
     :  IEEE,                  ! FITS data are in IEEE floating-point
                               ! format
     :  INVEXT,                ! Extension is invalid
     :  LABEL,                 ! The tape is labelled
     :  LENDIA,                ! Machine uses little-endian order of
                               ! bytes (e.g. Digital OSF, Linux), and is
                               ! not VMS
     :  LOGHDR                 ! A log of the header is written to an
                               ! text file

      LOGICAL                  ! True if:
     :  MORE,                  ! More files are to be read
     :  MOVED,                 ! Dummy return by tape-position inquiry
     :  NEXT,                  ! Go on to the next FITS sub-file even
                               ! if status is bad when creating the NDF,
                               ! otherwise abort the application
     :  NOCON,                 ! No prompting for the format conversion
                               ! of each file
     :  NONSDA,                ! There is a non-standard data array in
                               ! the FITS file
     :  PSTART,                ! Dummy returned by tape-position inquiry
     :  REWIND,                ! Rewind the tape initially?
     :  THERE,                 ! A specified descriptor is present in
                               ! the FITS header
     :  VALID,                 ! A locator is valid
     :  VMS                    ! Operating system is VMS

      LOGICAL
     :  CFLAG                  ! Group requires further input ?

      REAL
     :  BSCALE,                ! Scale factor used to convert tape
                               ! values to true values
     :  BZERO                  ! Offset applied to true pixel values

      DOUBLE PRECISION
     :  PSCALE( MXPARM ),      ! Scale factor used to convert tape
                               ! parameter values to true values
     :  PZERO( MXPARM )        ! Offset applied to true parameter values

      CHARACTER
     :  CFN * ( 10 ),          ! File number of the tape
     :  COMENT * ( 48 ),       ! Comment from card (not used)
     :  CS * ( 12 ),           ! Sub file number
     :  EXTNAM * ( 8 ),        ! Extension name
     :  FILES( MXFILE ) * ( 16 ), ! File numbers
     :  FILROO * ( 80 ),       ! Root name of HDS container file for
                               ! groups format and automatic mode
     :  FORMTI*(DAT__SZTYP),   ! Format of input data array
     :  FORMAT*(DAT__SZTYP),   ! Format of output data array
     :  MACHIN * ( 24 ),       ! Machine name
     :  NODE * ( 20 ),         ! Node name
     :  PTYPE( MXPARM ) * ( 8 ), ! Parameter names for groups format
     :  PREFIX * ( 80 ),       ! Prefix for automatic generation of NDF
                               ! file names
     :  RELEAS * ( 10 ),       ! Release of operating system
     :  SYSNAM * ( 10 ),       ! Operating system
     :  VERSIO * ( 10 )        ! Sub-version of operating system

      CHARACTER*(DAT__SZLOC)   ! Locators for:
     :  BFLOC,                 !   FITS header block
     :  RCLOC,                 !   FITS record
     :  TLOC                   !   temporary header

      CHARACTER*(GRP__SZNAM)   !
     :  ENCODS( MAXCOD )       ! AST encodings for WCS component
*.

*    Check status on entry - return if not o.k.

      IF ( STATUS .NE. SAI__OK ) RETURN

*    Inquire the current HDS MAP flag, since workspace requires that
*    the data are written by file mapping.

      CALL HDS_GTUNE( 'MAP', OLDMAP, STATUS )
      IF ( STATUS .NE. SAI__OK ) GOTO 999

*    Set the tuning parameter to the file-mapping setting.

      CALL HDS_TUNE( 'MAP', 1, STATUS )

*    Enquire which operating system is being used.

      CALL PSX_UNAME( SYSNAM, NODE, RELEAS, VERSIO, MACHIN, STATUS )
      CALL CHR_UCASE( SYSNAM )
      CALL CHR_UCASE( MACHIN )

*    Is it VAX/VMS?

      VMS = INDEX( SYSNAM, 'VMS' ) .NE. 0 .OR.
     :      INDEX( SYSNAM, 'RSX' ) .NE. 0

*    Find if the machine is not VMS and uses little-endian order of the
*    bytes.

      IF ( VMS ) THEN
         LENDIA = .FALSE.
      ELSE
         LENDIA = SYSNAM( 1:6 ) .EQ. 'ULTRIX' .OR.
     :            SYSNAM( 1:4 ) .EQ. 'OSF1' .OR.
     :            SYSNAM( 1:7 ) .EQ. 'DIGITAL' .OR.
     :            SYSNAM( 1:5 ) .EQ. 'LINUX'
      END IF

*    Attempt to obtain and open a log file to output the headers and
*    destination files.  A null value, meaning no logfile is required,
*    is handled invisibly.

      LOGHDR = .FALSE.
      CALL ERR_MARK
      CALL FIO_ASSOC( 'LOGFILE', 'WRITE', 'LIST', 132, FD, STATUS )

      IF ( STATUS .EQ. PAR__NULL ) THEN
         CALL ERR_ANNUL( STATUS )
      ELSE IF ( STATUS .EQ. SAI__OK ) THEN
         LOGHDR = .TRUE.
      END IF
      CALL ERR_RLSE
      IF ( STATUS .NE. SAI__OK ) GOTO 990

      IF ( LOGHDR ) CALL MSG_OUT( 'LOG', 'Logging to $LOGFILE', STATUS )

*    Get some BYTE workspace to store character buffers.  This is to
*    avoid the use of %REF.  First is the buffer for a FITS header
*    block, and second is a buffer to hold the current FITS record of
*    2880 bytes.

      CALL AIF_GETVM( '_BYTE', 1, BLKSIZ, BFPNTR, BFLOC, STATUS )
      CALL AIF_GETVM( '_BYTE', 1, RECSIZ, RCPNTR, RCLOC, STATUS )

      IF ( STATUS .NE. SAI__OK ) THEN
         CALL ERR_REP( 'FITSIN_WSP',
     :     'FITSDIN: Unable to get workspace for character buffers '/
     :     /'table.', STATUS )
         GOTO 990
      END IF

*    Get a descriptor for these character arrays using the GRP routines
*    These convert the mapped array pointer into a character array
*    descriptor.  N.B. this only happens on the VAX; on UNIX, the same
*    pointer is used.

      BFPNTD = BFPNTR
      RCPNTD = RCPNTR
      CALL GRP1_CDESC( 80, BFPNTD, STATUS )
      CALL GRP1_CDESC( 80, RCPNTD, STATUS )

*  Get a list of the AST Encodings to be used when creating NDF WCS
*  components.
*  ================================================================

*  Abort if there has been an error.
      IF( STATUS .NE. SAI__OK ) GO TO 999

*  Get a group from parameter ENCODINGS holding the AST encodings to use
*  when creating the WCS component from the FITS header.
      CALL GRP_NEW( 'AST Encodings', ENCGRP, STATUS )
      CALL GRP_SETCS( ENCGRP, .FALSE., STATUS )

      CFLAG = .TRUE.
      DO WHILE ( CFLAG .AND. STATUS .EQ. SAI__OK )
         CALL GRP_GROUP( 'ENCODINGS', GRP__NOID, ENCGRP, NENCOD, ADDED,
     :                   CFLAG, STATUS )
         IF ( CFLAG ) CALL PAR_CANCL( 'ENCODINGS', STATUS )
      END DO

*  If a NULL parameter value was given for ENCODINGS annul the error,
*  and find the real number of values in the group.
      IF( STATUS .EQ. PAR__NULL ) THEN
         CALL ERR_ANNUL( STATUS )
         CALL GRP_GRPSZ( ENCGRP, NENCOD, STATUS )
      END IF

*  Limit the number of encodings used to MAXCOD.
      IF( NENCOD .GT. MAXCOD ) THEN
         CALL MSG_SETI( 'MX', MAXCOD )
         CALL MSG_OUT( 'ENCODINGS', 'Only the first ^MX '//
     :                 'values for parameter %ENCODINGS will be '//
     :                 'used.', STATUS )
         NENCOD = MAXCOD
      END IF

*  Extract the encodings from the group into an array.
      CALL GRP_GET( ENCGRP, 1, NENCOD, ENCODS, STATUS )

*  Prepare the tape drive.
*  =======================

*    Is the tape to be rewound?

      REWIND = .TRUE.
      CALL PAR_GTD0L( 'REWIND', .TRUE., .TRUE., REWIND, STATUS )

*    Get the tape input device.

      CALL MAG_ASSOC( 'MT', 'READ', MT, STATUS )
      IF ( STATUS .NE. SAI__OK ) GOTO 980

*    Rewind the tape, just for the moment.

      IF ( REWIND ) THEN
         CALL MAG_REW( MT, STATUS )

         IF ( STATUS .NE. SAI__OK ) THEN
            CALL ERR_REP( 'ERR_FITSIN_REW',
     :        'FITSIN: Unable to rewind the tape --- the tape may not '/
     :        /'be mounted', STATUS )
            GOTO 980
         END IF
      END IF

*    Check if tape is labelled.

      CALL PAR_GET0L( 'LABEL', LABEL, STATUS )
      CALL PAR_CANCL( 'LABEL', STATUS )

*    Is automatic mode required?

      AUTO = .FALSE.
      CALL PAR_GTD0L( 'AUTO', .FALSE., .TRUE., AUTO, STATUS )

      IF ( AUTO ) THEN

*       Set no prompting for the format conversion of each file.

         NOCON = .TRUE.

*       Determine whether or not format conversion is to be applied to
*       all the files to be read.  The suggested default is .TRUE..

         CALL PAR_GTD0L( 'FMTCNV', .TRUE., .TRUE., FMTCNV, STATUS )

*       Get the prefix for the NDF file names and its length.

         CALL PAR_GET0C( 'PREFIX', PREFIX, STATUS )

      ELSE

*       No format conversion?

         NOCON = .FALSE.
         CALL PAR_GTD0L( 'GLOCON', .FALSE., .TRUE., NOCON, STATUS )

*       Determine whether or not format conversion is to be applied to
*       all the files to be read.  The suggested default is .TRUE..

         IF ( NOCON ) CALL PAR_GTD0L( 'FMTCNV', .TRUE., .TRUE., FMTCNV,
     :                                STATUS )

      END IF

*    Start the NDF context, even though it may just be FITS tables.
*    It's easier to follow the code this way.

      CALL NDF_BEGIN

*    Loop for more files.

      MORE = .TRUE.
      DO WHILE ( MORE .AND. STATUS .EQ. SAI__OK )

*       Inform the user of the tape's position as this may affect the
*       order in which files are to be read.

         CALL MAG_POS( MT, FN, PSTART, BLKNO, MOVED, STATUS )

         IF ( STATUS .EQ. SAI__OK ) THEN
            IF ( .NOT. AUTO ) THEN
               IF ( LABEL ) THEN
                  CALL MSG_SETI( 'FN', ( FN + 2 ) / 3 )
               ELSE
                  CALL MSG_SETI( 'FN', FN )
               END IF

               CALL MSG_OUT( 'TAPEPOS',
     :           'The tape is currently positioned at file ^FN.',
     :           STATUS )
            END IF

*       Need to report this error here to avoid having a spurious one
*       reported below.

         ELSE
            CALL ERR_REP( 'ERR_FITSIN_POS',
     :        'FITSIN: Unable to find the tape position.', STATUS )
            GOTO 970
         END IF


*       Get file list and check number of specifications.
*       =================================================

         CALL PAR_GET1C( 'FILES', MXFILE, FILES, NFSPEC, STATUS )

*       Abort if requested.

         IF ( STATUS .EQ. PAR__ABORT ) GOTO 970

*       Check for null response.

         IF ( NFSPEC .EQ. 0 .OR. STATUS .EQ. PAR__NULL ) THEN
            IF ( NFSPEC .EQ. 0 ) STATUS = SAI__ERROR
            CALL ERR_REP( 'FITSIN_NOFILES',
     :        'FITSIN: No files were specified', STATUS )
            CALL ERR_FLUSH( STATUS )

            IF ( NFSPEC .EQ. 0 ) STATUS = SAI__ERROR
            CALL PAR_CANCL( 'FILES', STATUS )
            GOTO 970
         END IF

*       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*       Scan through the tape, processing each file specification.

         DO FS = 1, NFSPEC

*          Calculate the file-limits.

            CALL KPG1_CNLIM( FILES( FS ), FIRST, LAST, STATUS )

*          Check the file specification.

            IF ( STATUS .NE. SAI__OK ) THEN
               CALL ERR_REP( 'FITSIN_BADSPEC',
     :           'FITSIN: Error in file specification', STATUS )
               CALL ERR_FLUSH( STATUS )
            ELSE

*             A wildcard in the first part of a range or a full
*             wildcard indicates the files start from beginning, i.e.
*             file one.

               FIRST = MAX( 1, FIRST )

*             Process each file in this specification.

               DO FN = FIRST, LAST

*                Get the character version of the file number for
*                passing to routines that handle both disk and tape.

                  CALL CHR_ITOC( FN, CFN, NCF )

*                Start error context.

                  CALL ERR_MARK

*                Move to the appropriate file.

                  IF ( LABEL ) THEN
                     CALL MAG_MOVE( MT, 3*FN-2, .TRUE., 1, STATUS )
                  ELSE
                     CALL MAG_MOVE( MT, FN, .TRUE., 1, STATUS )
                  END IF

*                Report error context.

                  IF ( STATUS .NE. SAI__OK ) THEN
                     IF ( FN .EQ. FIRST ) THEN
                        CALL MSG_SETI( 'FN', FN )
                        CALL ERR_REP( 'FITSIN_MOVE',
     :                    'FITSIN: Error positioning tape at file '/
     :                    /'^FN', STATUS )
                     END IF

*                   Release the new error context and exit the
*                   application.

                     CALL ERR_RLSE
                     GOTO 970

                  END IF

*                Release the new error context.

                  CALL ERR_RLSE

*                Initialise the count of the number of FITS files or
*                extensions in the current tape file.

                  SUBFIL = 0

*                The offset in bytes within the block buffer is zero
*                for a new file that has yet to be read.

                  OFFSET = 0

*                There is no current FITS record.

                  CURREC = .FALSE.

*                This is the start of the loop for multiple FITS files.

  100             CONTINUE
                  SUBFIL = SUBFIL + 1

*                Assume for the moment that there will be a data array
*                in the FITS header, and it is in a standard format.

                  DARRAY = .TRUE.
                  NONSDA = .FALSE.

*                See if the next tape record has already been read.
*                If not, read it.

                  IF ( .NOT. CURREC ) THEN

*                   Read first header block and check for error.
*                   This is needed to obtain the blocksize.

                     CALL MAG_READ( MT, BLKSIZ,
     :                              %VAL( CNF_PVAL( BFPNTR ) ),
     :                              ACTSIZ, STATUS )

*                   Obtain the first FITS record from the tape buffer.

                     CALL FTS1_TREAD( MT, BLKSIZ, ACTSIZ,
     :                                %VAL( CNF_PVAL( BFPNTR ) ),
     :                                OFFSET,
     :                                %VAL( CNF_PVAL( RCPNTR ) ),
     :                                STATUS )

*                   Do not want to process further files if we
*                   have reached the end of the tape.

                     IF ( STATUS .EQ. MAG__EOF .OR.
     :                    STATUS .EQ. MAG__EOV .OR.
     :                    STATUS .EQ. MAG__EOT ) THEN

*                      Watch for the case where all the files until
*                      the end were required.

                        IF ( FN .NE. FIRST ) THEN

*                         Assume it is the last file so there is no
*                         error, and any error reports can be annulled.

                           CALL ERR_ANNUL( STATUS )

*                         Tell the user the number of the last file.

                           CALL MSG_SETI( 'FN', FN-1 )
                           CALL MSG_OUT( 'LASTFILE',
     :                       'The last file on the tape, #^FN, has '/
     :                       /'been processed.', STATUS )
                        END IF

                        GOTO 970

                     ELSE IF ( STATUS .NE. SAI__OK ) THEN
                        CALL ERR_REP( 'FITSIN_HDREAD',
     :                    'FITSIN: Error while reading the first '/
     :                    /'record of the file', STATUS )
                        CALL ERR_FLUSH( STATUS )

*                      Loop to the next tape file.

                        GOTO 960
                     END IF

*                   Current record has been obtained succesfully.

                     CURREC = .TRUE.

*                   Blocking factor should be an integer factor from
*                   one to ten of the standard FITS record. Note this
*                   application can cope provided the actual blocksize
*                   is no large than BLKSIZ.

                     BF = ACTSIZ / 2880
                     IF ( MOD( ACTSIZ, 2880 ) .NE. 0 .OR.
     :                    BF .GT. 10 .OR. BF .LT. 1 ) THEN
                        CALL MSG_OUT( 'FITSIN_IBLOCK',
     :                    'Tape has illegal-length blocks. '/
     :                    /'Blocks should be a multiple (1--10) of '/
     :                    /'the FITS record length of 2880 bytes',
     :                    STATUS )
                     END IF
                  END IF

*                Create a dummy header structure.

                  WHDIM( 1 ) = 100
                  CALL AIF_TEMP( '_CHAR*80', 1, WHDIM, TLOC,
     :                           STATUS )
                  IF ( STATUS .NE. SAI__OK ) THEN
                     CALL ERR_REP( 'FITSIN_HDS',
     :                 'FITSIN: Error creating a dummy header '/
     :                 /'structure.', STATUS )
                     GOTO 970
                  END IF

                  IF ( .NOT. AUTO ) THEN

*                   Display file and sub-file number.

                     CALL MSG_SETI( 'FN', FN )
                     CALL MSG_SETI( 'SUBFIL', SUBFIL )
                     CALL MSG_OUT( 'FILEHEAD',
     :                 'File # ^FN(^SUBFIL)  Descriptors follow:',
     :                 STATUS )
                  END IF

*                Process the header blocks.  OFFSET is updated.

                  CALL FTS1_PHEAD( BFPNTR, RCPNTR,
     :                             %VAL( CNF_PVAL( RCPNTD ) ),
     :                             'TAPE', MT, TLOC, BLKSIZ, MAXHDR,
     :                             .NOT. AUTO, ACTSIZ, OFFSET, CURREC,
     :                             HSTART, HDNUM, EXTEND, NHEADS,
     :                             STATUS, %VAL( CNF_CVAL( 80 ) ) )

                  IF ( STATUS .NE. SAI__OK ) GOTO 970

*                Find the current size of the header structure.

                  CALL DAT_SIZE( TLOC, WHDIM( 1 ), STATUS )

*                Now map the headers for later access.  This call
*                is situated after reading in all the headers because
*                the size of the work space may have been changed, and
*                we don't want to mix mapping with direct access to
*                the work structure.

                  CALL DAT_MAPC( TLOC, 'UPDATE', 1, WHDIM, HPNTR,
     :                           STATUS )

*                Check we have a valid pointer before accessing it.

                  IF ( STATUS .NE. SAI__OK ) THEN
                     CALL ERR_REP( 'FITSIN_WKMAP',
     :                 'FITSIN: Error mapping the dummy header '/
     :                 /'structure.', STATUS )
                     GOTO 970
                  END IF

*                Could there be sub-files?  Store the global EXTEND
*                value.

                  IF ( SUBFIL .EQ. 1 ) THEN
                     CALL FTS1_GKEYL( WHDIM( 1 ),
     :                                %VAL( CNF_PVAL( HPNTR( 1 ) ) ),
     :                                HSTART( 1 ), 'EXTEND', 1, THERE,
     :                                GEXTND, COMENT, NKC, STATUS,
     :                                %VAL( CNF_CVAL( 1 ) ) )
                     GEXTND = GEXTND .AND. THERE
                  END IF

*                Now the complete header is stored in the buffer.
*                The values of certain items stored in the buffer
*                are required to generate the data array.
*                This is not the most efficient method to obtain
*                selected descriptor values, but, in the main, the
*                important descriptors will be in the early cards.
*                Efficiency has been sacrificed for more-structured and
*                flexible code.

*                Check that the mandatory descriptors are present.

                  CALL FTS1_MANDH( SUBFIL .EQ. 1, WHDIM( 1 ),
     :                             %VAL( CNF_PVAL( HPNTR( 1 ) ) ),
     :                             HSTART( NHEADS ),
     :                             BITPIX, NDIM, DIMS, DARRAY, NONSDA,
     :                             SIZE, STATUS, %VAL( CNF_CVAL( 1 ) ) )

*                Check for an error, because file is not in FITS
*                format, or has an unsupported FITS extension.

*                Start a new error context.

                  CALL ERR_MARK

                  IF ( STATUS .NE. SAI__OK ) THEN

*                   Now report error context and future action.
*                   First set up sub-file part of the message.

                     IF ( SUBFIL .EQ. 1 ) THEN
                        CALL MSG_SETC( 'SUBFIL', ' ' )
                     ELSE
                        CALL CHR_ITOC( SUBFIL, CS, NCH )
                        CALL MSG_SETC( 'SUBFIL', 'Sub file is '/
     :                                 /CS(:NCH)//'.' )
                     END IF

*                   Error occurred on the last file.

                     IF ( FN .EQ. LAST .AND. FS .EQ. NFSPEC ) THEN
                        CALL ERR_REP( 'FITSIN_IVHEADL',
     :                    'FITSIN: Unable to read the last file. '/
     :                    /'^SUBFIL.', STATUS )
                        CALL ERR_FLUSH( STATUS )
                     ELSE
                        CALL ERR_REP( 'FITSIN_IVHEAD',
     :                    'FITSIN: Unable to read the current '/
     :                    /'file. ^SUBFIL Going to next file.',
     :                    STATUS )
                        CALL ERR_FLUSH( STATUS )
                     END IF

                     CALL ERR_RLSE
                     GOTO 960
                  END IF

*                Release the new error context.

                  CALL ERR_RLSE
                  IF ( STATUS .NE. SAI__OK ) GOTO 960

*                Write header to log if required.

                  IF ( LOGHDR ) THEN

                     CALL FTS1_HDLOG( %VAL( CNF_PVAL( HPNTR( 1 ) ) ),
     :                                FD, CFN,
     :                                SUBFIL, NHEADS, HDNUM, STATUS,
     :                                %VAL( CNF_CVAL( 1 ) ) )

                     IF ( STATUS .NE. SAI__OK ) GOTO 970
                  END IF

*-----------------------------------------------------------------------
*
*                Deal with Tables extension.
*                ===========================

                  INVEXT = .FALSE.

                  IF ( EXTEND ) THEN

*                   Start a new error context.

                     CALL ERR_MARK

*                   Obtain the extension's name.

                     CALL FTS1_GKEYC( WHDIM( 1 ),
     :                                %VAL( CNF_PVAL( HPNTR( 1 ) ) ),
     :                                HSTART( NHEADS ), 'XTENSION', 1,
     :                                THERE, EXTNAM, COMENT, NKC,
     :                                STATUS, %VAL( CNF_CVAL( 1 ) ) )

*                   Report any errors.

                     IF ( NHEADS .GT. 2 ) THEN
                        STATUS = SAI__ERROR
                        CALL ERR_REP( 'FITSIN_TMEXT',
     :                    'FITSIN: Only one extension recognised',
     :                    STATUS )
                        CALL ERR_FLUSH( STATUS )
                        INVEXT = .TRUE.
                     ELSE IF ( EXTNAM( 1:8 ) .NE. 'TABLE   ' ) THEN
                        NC = CHR_LEN( EXTNAM )
                        CALL MSG_SETC( 'EXTNAM', EXTNAM( :NC ) )
                        STATUS = SAI__ERROR
                        CALL ERR_REP( 'FITSIN_TMEXT',
     :                    'FITSIN: The extension ^EXTNAM cannot be '/
     :                    /'processed.', STATUS )
                        CALL ERR_FLUSH( STATUS )
                        INVEXT = .TRUE.
                     ELSE

*                      Create the SCAR description file and text table.

                        CALL FTS1_SCTAB( %VAL( CNF_PVAL( HPNTR( 1 ) ) ),
     :                                   'DSCFTABLE', 'TABLE', 'TAPE',
     :                                   MT, WHDIM( 1 ),
     :                                   HSTART( NHEADS ), NDIM, DIMS,
     :                                   LOGHDR, FD, CFN, SUBFIL,
     :                                   PREFIX, AUTO, BLKSIZ, ACTSIZ,
     :                                   BFPNTR, OFFSET, CURREC,
     :                                   RCPNTR, STATUS,
     :                                   %VAL( CNF_CVAL( 1 ) ) )

                     END IF

                     IF ( STATUS .EQ. PAR__ABORT ) THEN

*                      Release the new error context.

                        CALL ERR_RLSE

                        GOTO 970

                     ELSE IF ( INVEXT .OR. STATUS .NE. SAI__OK ) THEN

*                      Now report error context and future action

*                      First set up sub-file part of the message.

                        IF ( SUBFIL .EQ. 1 ) THEN
                           CALL MSG_SETC( 'SUBFIL', ' ' )
                        ELSE
                           CALL CHR_ITOC( SUBFIL, CS, NCH )
                           CALL MSG_SETC( 'SUBFIL', 'Sub file is '/
     :                       /CS(:NCH)//'.' )
                        END IF

*                      Error occurred on the last file.

                        IF ( STATUS .EQ. SAI__OK ) STATUS = SAI__ERROR
                        IF ( FN .EQ. LAST .AND. FS .EQ. NFSPEC ) THEN
                           CALL ERR_REP( 'FITSIN_IVHEADL',
     :                        'FITSIN: Unable to read the last '/
     :                        /'file. ^SUBFIL.', STATUS )
                           CALL ERR_FLUSH( STATUS )

*                      Error occurred at arbitrary file.

                        ELSE
                           CALL ERR_REP( 'FITSIN_IVHEAD',
     :                       'FITSIN: Unable to read the current '/
     :                       /'file. ^SUBFIL Going to next file.',
     :                       STATUS )
                           CALL ERR_FLUSH( STATUS )
                        END IF

*                      Release the new error context.

                        CALL ERR_RLSE
                        GOTO 960

*                   End of valid-extension-present check

                     END IF

*                   Release the new error context.

                     CALL ERR_RLSE

*                   Finished with the work array for the headers.

                     CALL AIF_ANTMP( TLOC, STATUS )

*                   See whether or not there is an extension
*                   following the current sub file.

                     GOTO 940

*                 End of extension-present check

                  END IF

*                ^^^^^^^^^^^^^^^^^^^^^^^^^^^

*-----------------------------------------------------------------------
*
*                Now the rest up to 960 loop deals with n-dimensional
*                data arrays and group format.
*

*                Obtain the scale and zero, the blank value.  If
*                the FITS object is in group format, obtain the
*                number and values of the group parameters.  Reset
*                the dimensionality when there is a dummy dimension.

                  CALL FTS1_DTYPE( DARRAY, NONSDA, BITPIX,
     :                             HSTART( NHEADS ), WHDIM( 1 ),
     :                             %VAL( CNF_PVAL( HPNTR( 1 ) ) ),
     :                             MXPARM, NDIM,
     :                             DIMS, BSCALE, BZERO, BLANK, BADPIX,
     :                             IEEE, GCOUNT, PCOUNT, PTYPE, PSCALE,
     :                             PZERO, STATUS,
     :                             %VAL( CNF_CVAL( 1 ) ) )

                  IF ( STATUS .NE. SAI__OK ) THEN

*                   Report the problem now as the application is
*                   not exiting.

                     CALL ERR_FLUSH( STATUS )
                     GOTO 960
                  END IF

*                Extend the header workspace.
*                ============================
*
*                From this point a non-standard array means group
*                format.  If there are any group parameters the work
*                space for the headers needs to be extended to include
*                them.

                  IF ( NONSDA .AND. PCOUNT .GT. 0 ) THEN

*                   Unmap the structure containing the FITS header
*                   cards.

                     CALL DAT_UNMAP( TLOC, STATUS )

*                   Adjust its size to hold just the standard headers
*                   and the group parameters.

                     WHDIM( 1 ) = WHDIM( 1 ) + PCOUNT
                     CALL DAT_ALTER( TLOC, 1, WHDIM( 1 ), STATUS )

                     IF ( STATUS .NE. SAI__OK ) THEN
                        CALL ERR_REP( 'FITSIN_ENHEAD',
     :                    'FITSIN: Unable to enlarge the header '/
     :                    /'workspace for the group parameters.',
     :                    STATUS )
                        GOTO 970
                     END IF

*                   Remap the header structure with update mode to
*                   retain the existing header information.

                     CALL DAT_MAPC( TLOC, 'UPDATE', 1, WHDIM, HPNTR,
     :                              STATUS )

                     IF ( STATUS .NE. SAI__OK ) THEN
                        CALL ERR_REP( 'FTS1_GPARM_REMAP',
     :                    'FITSIN: Error mapping the enlarged '/
     :                    /'workspace for the header and group '/
     :                    /'parameters.', STATUS )
                     END IF
                  END IF

*                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^

*                Is data conversion a possible requirement?

                  IF ( ( .NOT. NOCON .AND. DARRAY ) .AND.
     :                   .NOT. IEEE ) THEN

*                   See if we wish to override the standard data TYPE.
*                   The suggested default is .TRUE..

                     CALL PAR_GTD0L( 'FMTCNV', .TRUE., .TRUE., FMTCNV,
     :                               STATUS )
                     CALL PAR_CANCL( 'FMTCNV', STATUS )

                     IF ( STATUS .EQ. PAR__ABORT ) GOTO 970

                  END IF

*                Get the effective flag for format conversion for the
*                current FITS file.  The format conversion flag may
*                have been set globally, but we don't want to have a
*                format conversion when dealing with IEEE data.

                  EFMTCV = FMTCNV .AND. .NOT. IEEE

*                Get the input and output formats.

                  CALL FTS1_FRMT( BITPIX, IEEE, FMTCNV, BPV, FORMTI,
     :                            FORMAT, STATUS )

                  IF ( STATUS .NE. SAI__OK ) THEN

*                   Report the problem now as the application is
*                   not exiting.

                     CALL ERR_FLUSH( STATUS )
                     GOTO 960
                  END IF

                  IF ( AUTO ) THEN
                     CALL FTS1_ROOTN( 'TAPE', CFN, SUBFIL, PREFIX,
     :                                FILROO, NCROOT, STATUS )
                  END IF

*                Create and fill GCOUNT NDFs, performing the necessary
*                data conversions and blank-pixel removal.
*                =====================================================

                  CALL FTS1_NDF( %VAL( CNF_PVAL( HPNTR( 1 ) ) ),
     :                           BFPNTR, RCPNTR,
     :                           AUTO, 'OUT', 'TAPE', MT, VMS, LENDIA,
     :                           SIZE, NDIM, DIMS, BPV, EFMTCV, FORMTI,
     :                           FORMAT, IEEE, BADPIX, BLANK, BSCALE,
     :                           BZERO, DARRAY, NONSDA, GCOUNT, PCOUNT,
     :                           MXPARM, PTYPE, PSCALE, PZERO, FILROO,
     :                           LOGHDR, FD, CFN, SUBFIL, GEXTND,
     :                           WHDIM( 1 ), HSTART( NHEADS ), NENCOD,
     :                           ENCODS, BLKSIZ, ACTSIZ, OFFSET, CURREC,
     :                           NEXT, PARAMS, STATUS,
     :                           %VAL( CNF_CVAL( 80 ) ) )

*                Test for exit.

                  IF ( .NOT. NEXT ) GOTO 970

*                Flush any errors before continuing.

                  IF ( STATUS .NE. SAI__OK ) CALL ERR_FLUSH( STATUS )

  940             CONTINUE

*                If there may be an extension following, it has to
*                be determined whether or not it actually exists.

                  IF ( GEXTND ) THEN

*                   Start a new error context.

                     CALL ERR_MARK

*                   Attempt to read the next record as if it were the
*                   first header whenever the next card (first in the
*                   next record) is the start of a sub-file header.
*                   There is no sub file when either the first record
*                   is blank, or when a tape mark is encountered.

                     CALL FTS1_TREAD( MT, BLKSIZ, ACTSIZ,
     :                                %VAL( CNF_PVAL( BFPNTR ) ),
     :                                OFFSET,
     :                                %VAL( CNF_PVAL( RCPNTR ) ),
     :                                STATUS )

                     IF ( .NOT. FTS1_BLCAR( %VAL( CNF_PVAL( RCPNTD ) ) )
     :                    .AND.
     :                    STATUS .EQ. SAI__OK ) THEN

*                      There is a sub file, so process its header like
*                      for any other.  Note the fact that the first
*                      record of a sub-file has been read.

                        CURREC = .TRUE.

*                      Tidy the workspace used to store the headers
*                      if it exists, before going on to the next
*                      extension.

                        CALL DAT_VALID( TLOC, VALID, STATUS )
                        IF ( VALID ) CALL AIF_ANTMP( TLOC, STATUS )
                        CALL ERR_RLSE
                        GOTO 100

*                   Ignore the error.  Tape will be correctly
*                   positioned for the next file at the start of the
*                   second main loop.  To be on the safe side look for
*                   any MAG error.

                     ELSE IF ( STATUS .NE. SAI__OK ) THEN
                        CALL ERR_ANNUL( STATUS )
                     END IF

*                   End the new error context.

                     CALL ERR_RLSE

*                End of check for possible sub files/extensions.

                  END IF


*                Go onto next file even if there has been a FITS
*                problem reading the current file.

  960             CONTINUE

*                Tidy the workspace used to store the headers if it
*                exists.

                  CALL DAT_VALID( TLOC, VALID, STATUS )
                  IF ( VALID ) CALL AIF_ANTMP( TLOC, STATUS )

*             End of process-each-file loop.

               END DO

*          End of file-specification check.

            END IF

*       End of process-each-file-specification loop.

         END DO

*       Ask for any more files.

         CALL PAR_GTD0L( 'MORE', .FALSE., .TRUE., MORE, STATUS )
         IF ( STATUS .EQ. PAR__ABORT ) THEN
            GOTO 970
         ELSE IF ( MORE ) THEN
            CALL PAR_CANCL( 'MORE', STATUS )
            CALL PAR_CANCL( 'FILES', STATUS )
         END IF

*    End of more-files loop.

      END DO

*    Clear up locators and NDF after an abort.
*    =========================================

 970  CONTINUE

*    Tidy the workspace used to store the headers if it exists.

      CALL DAT_VALID( TLOC, VALID, STATUS )
      IF ( VALID ) CALL AIF_ANTMP( TLOC, STATUS )

*    Close down the NDF system.

      CALL NDF_END( STATUS )

*    Close the tape.

 980  CONTINUE
      CALL MAG_ANNUL( MT, STATUS )

*    Close the log file.

 990  CONTINUE

*    Tidy the byte work space.

      CALL AIF_ANTMP( RCLOC, STATUS )
      CALL AIF_ANTMP( BFLOC, STATUS )

      IF ( LOGHDR ) CALL FIO_ANNUL( FD, STATUS )

*    Return to the old tuning setting being careful to ensure that this
*    is successful, even if there has been an error.

      CALL ERR_BEGIN( STATUS )
      CALL HDS_TUNE( 'MAP', OLDMAP, STATUS )
      CALL ERR_END( STATUS )

*    Exit.

 999  CONTINUE

      END
