.help manic Starlink kappa
.nf
    Converts all or part of a data array from one dimensionality
    to another.
 
   This application copies or converts all or part of a 1, 2 or
   3-dimensional data array to one or more output data arrays, each
   of 1, 2 or 3 dimensions. All data arrays are stored in IMAGE
   structures. Windows may be set in any of the dimensions of the
   input data array. All or part of the input array may be projected
   on to any of the rectangular planes or axes of the input before
   being written to an output array; or a 1- or 2-dimensional data
   array may be grown to more dimensions to fill an output data
   array. Many output data arrays, each of a different configuration
   if required, may be extracted from a single input data array with
   one call to the routine.

AUTHORS

   C D Pike    (RGO::CDP)
   Roger Wood  (RGO::RW)
   Dave Baines (ROE::ASOC5)
   Malcolm Currie  STARLINK (RAL::CUR)

BUGS

   None known.

HISTORY

   15/08/1981 : Original version    (RGO::CDP)
   30/03/1983 : Amended  version    (RGO::RW)
   21/02/1984 : Revised SSE version (ROE::ASOC5)
   1986 Aug 7 : Standardised prologue formatting. Status check on
                entry added (RAL::CUR).
   1986 Aug 29: Renamed APP routines into AIF_. Added argument
                section to prologue and tidied. Revised output
                of dimensions via DIMLST routine (RAL::CUR).
   1986 Oct 30: Allowed for bad pixel handling in routines MA3TO1,
                MA3TO2 and MA2TO1 for which workspace of the
                appropriate dimension is now found (RAL::CUR).
   1987 Oct 15: Reordered tidying and extra status checks
                (RAL::CUR)
   1988 Mar 16: Substituted AIF_ANTMP to annul workspace
                (RAL::CUR).
   1988 Mar 17: Referred to `array' rather than `image'
                (RAL::CUR).
   1988 Jun 20: More reporting of error context (RAL::CUR).
   1989 Jun 13: Allow for processing primitive NDFs (RAL::CUR)
   1989 Aug  8: Passed array dimensions as separate variables
                to COPY2D, COPY3D, MA1TO2, MA1TO3, MA2TO1, MA2TO3,
                MA3TO1 and MA3TO2 (RAL::CUR).
   1989 Dec 21: Workspace managed by AIF_TEMP (RAL::CUR).
   1991 Oct 25: Propagates UNITS, LABEL and HISTORY (RAL::CUR).
   1992 Feb 25: Limited processing of simple NDFs (RAL::CUR).
   1992 Mar  3: Replaced AIF parameter-system calls by the extended
                PAR library (RAL::CUR).

PARAMETERS

   INPUT      = IMAGE( READ )
       IMAGE structure holding the input data array.
   ONDIM      = INTEGER( READ )
       Dimensionality of an output data array.
   XLIMITS(2) = INTEGER( READ )
       The X-axis window on the input data array to be used in
         forming an output data array.
   YLIMITS(2) = INTEGER( READ )
       The Y-axis window on the input data array to be used in
         forming an output data array.
   ZLIMITS(2) = INTEGER( READ )
       The Z-axis window on the input data array to be used in
         forming an output data array.
   XRANGE(2)  = INTEGER( READ )
       The X-axis range for summation in the input data array in
         forming an output data array.
   YRANGE(2)  = INTEGER( READ )
       The Y-axis range for summation in the input data array in
         forming an output data array.
   ZRANGE(2)  = INTEGER( READ )
       The Z-axis range for summation in the input data array in
         forming an output data array.
   EPLANE     = CHAR( READ )
       Plane to be extracted from the input 3-d data array.  The
         options are 'XY', 'YZ', 'ZX', 'YX', 'ZY', 'XZ'.
   GPLANE     = CHAR( READ )
       Input 2-d data array forms this plane when being grown into
         a 3-d data array.  The options are 'XY', 'YZ', 'ZX', 'YX',
         'ZY', 'XZ'.
   ELINE1     = CHAR( READ )
       Axis of input 2-d data array to be extracted to form an output
         1-d data array.  The alternatives are 'X', 'Y'.
   ELINE2     = CHAR( READ )
       Axis of input 3-d data array to be extracted to form an output
         1-d data array.  The options are 'X', 'Y', 'Z'.
   GLINE1     = CHAR( READ )
       Input 1-d data array will form this axis of an output 2-d
         data array.  The alternatives are 'X', 'Y'.
   GLINE2     = CHAR( READ )
       Input 1-d data array will form this axis of an output 3-d
         data array.  The options are 'X', 'Y', 'Z'.
   XDIM       = INTEGER( READ )
       X-dimension of output 2-d or 3-d data array grown from input
         1-d or 2-d data array.
   YDIM       = INTEGER( READ )
       Y-dimension of output 2-d or 3-d data array grown from input
         1-d or 2-d data array.
   ZDIM       = INTEGER( READ )
       Z-dimension of output 2-d or 3-d data array grown from input
         1-d or 2-d data array.
   OUTPUT     = IMAGE( WRITE )
       IMAGE structure to hold an output data array.
   OTITLE     = CHAR( WRITE )
       Title for IMAGE structure holding an output data array.
   LOOP       = LOGICAL( READ )
       Extract or grow further output data arrays from the same input
         data array.

INPUT

  position    1
  keyword     'INPUT'
  type        'IMAGE'
  access      'READ'
  vpath       'PROMPT'
  ppath       'GLOBAL'
  association '<-GLOBAL.DATA_ARRAY'
  prompt      'Input image'
  help        'Name of the IMAGE structure containing the input data 
              array.'

OUTPUT

  position    2
  keyword     'OUTPUT'
  type        'IMAGE'
  access      'WRITE'
  vpath       'PROMPT'
  association '->GLOBAL.DATA_ARRAY'
  prompt      'Output image'
  help        'Name of the IMAGE structure to store output data array.'

OTITLE

  position    3
  keyword     'OTITLE'
  type        '_CHAR'
  vpath       'DEFAULT'
  prompt      'Output image title'
  default     'KAPPA - Manic'
  help        'Character string used as a title for the output IMAGE 
              structure.'

ONDIM

  position    4
  keyword     'ONDIM'
  type        '_INTEGER'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'Dimensionality of output image'
  help        'Number of dimensions for the output image. It must be 1, 2 or 3.'
 #in          1, 2, 3

XLIMITS

  position    5
  keyword     'XLIMITS'
  type        '_INTEGER'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'Window limits for the X-axis of the input data array'
  help        'Give a contiguous range of X-axis pixels that form the 
              output data array.'

YLIMITS

  position    6
  keyword     'YLIMITS'
  type        '_INTEGER'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'Window limits for the Y-axis of the input data array'
  help        'Give a contiguous range of Y-axis pixels that form the 
              output data array.'

ZLIMITS

  position    7
  keyword     'ZLIMITS'
  type        '_INTEGER'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'Window limits for the Z-axis of the input data array'
  help        'Give a contiguous range of Z-axis pixels that form the 
              output data array.'

XRANGE

  position    8
  keyword     'XRANGE'
  type        '_INTEGER'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'Range for summation over the X-axis of the input data
              array'
  help        'Give a contiguous range of X-axis pixels that are 
              going to be summed in forming the output data array'

YRANGE

  position    9
  keyword     'YRANGE'
  type        '_INTEGER'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'Range for summation over the Y-axis of the input data
              array'
  help        'Give a contiguous range of Y-axis pixels that are 
              going to be summed in forming the output data array'

ZRANGE

  position    10
  keyword     'ZRANGE'
  type        '_INTEGER'
  vpath       'PROMPT'
  ppath       'DYNAMIC'
  prompt      'Range for summation over the Z-axis of the input data
              array'
  help        'Give a contiguous range of Z-axis pixels that are 
              going to be summed in forming the output data array.'

EPLANE

  position    11
  keyword     'EPLANE'
  type        '_CHAR'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC'
  prompt      'Plane of the input data array from which the output
              array is to be extracted'
  help        'Options are: XY, YZ, or XZ.'
 #in          'XY', 'YZ', 'ZX', 'YX', 'ZY', 'XZ'

GPLANE

  position    12
  keyword     'GPLANE'
  type        '_CHAR'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC'
  prompt      'Plane of the output data array which the input
              data array will form'
  help        'Options are: XY, YZ, or XZ.'
 #in          'XY', 'YZ', 'ZX', 'YX', 'ZY', 'XZ'

ELINE1

  position    13
  keyword     'ELINE1'
  type        '_CHAR'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC'
  prompt      'Axis of the input data array that will be used to
              form the output data array?'
  help        'Alternatives are X or Y.'
 #in          'X', 'Y'

ELINE2

  position    14
  keyword     'ELINE2'
  type        '_CHAR'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC'
  prompt      'Axis of the input data array that will be used to
              form the output data array'
  help        'Options are X, Y or Z.'
 #in          'X', 'Y', 'Z'

GLINE1

  position    15
  keyword     'GLINE1'
  type        '_CHAR'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC'
  prompt      'Axis of the output data array that the input data
              array will form'
  help        'Alternatives are X or Y.'
 #in          'X', 'Y'

GLINE2

  position    16
  keyword     'GLINE2'
  type        '_CHAR'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC'
  prompt      'Axis of the output data array that the input data
              array will form'
  help        'Options are X, Y or Z.'
 #in          'X', 'Y', 'Z'

XDIM

  position    17
  keyword     'XDIM'
  type        '_INTEGER'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC'
  prompt      'X-dimension for the output data array'

YDIM

  position    18
  keyword     'YDIM'
  type        '_INTEGER'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC'
  prompt      'Y-dimension for the output data array'

ZDIM

  position    19
  keyword     'ZDIM'
  type        '_INTEGER'
  vpath       'PROMPT'
  ppath       'CURRENT,DYNAMIC'
  prompt      'Z-dimension for the output data array'

LOOP

  position    20
  keyword     'LOOP'
  type        '_LOGICAL'
  vpath       'PROMPT'
  ppath       'DEFAULT'
  default     N
  prompt      'Produce another output IMAGE structure and data array?'
 1 Masking,_Bad Values,_and_Quality
 Masking is the process by which you can exclude portions of your
data from data processing or analysis.  Suppose that you are doing
surface photometry of a bright galaxy, part of the data reduction
is to measure the background contribution around the galaxy and to
subtract it.  What you want to avoid is to include light from the
galaxy in your estimation of the background.  A convenient method
for doing this is to mask the galaxy during the background fitting.
 There are two techniques used for masking.  One employs special bad
values, which are synonymous with magic or invalid values.  These
appear within the data or variance arrays instead of the actual
values, and indicate that the value is to be ignored or is
undefined.  They are destructive and so some people don't like them,
but you can always mask your data into a new, temporary NDF.  If bad
values weren't used what is a programme supposed to do if it cannot
compute a value, say divide by zero?  With a little care, bad values
are quite effective and they are used throughout KAPPA.  By its
nature, a bad value can only indicate a logical condition about a
data element---it is either good or bad---and so this technique is
sometimes called flagging. 
 In contrast, the second technique, uses a quality array.  This
permits many more attributes or qualities of the data to be
associated with each pixel.  In the current implementation there may
be up to 255 integer values or 8 1-bit logical.  Thus quality can be
regarded as offering 8 logical masks extending over the data or
variance arrays, and can signify the presence or absence of a
particular property if the bit has value 1 or 0 respectively.  An
application of quality to satellite data might include the detector
used to measure the value, some indicator of the time each pixel was
observed, was the observation made within the Earth's radiation
belts, and whether or not the pixel contains a reseau mark.  By
selecting only those data with the appropriate quality values, you
process only the data with the desired properties.  This can be
very powerful.  However, it does have the drawback of having to
store at least an extra byte per pixel in your NDF.
 The two methods are not mutually exclusive; the NDF permits their
simultaneous use in a dataset. 
 Now we'll look at both of these techniques in detail and
demonstrating the relevant KAPPA tasks.
 2 Bad-pixel_Masking
Bad pixels are flagged with the Starlink standard values (see
Section 5 of SUN/39), which for _REAL is the most-negative value
possible.
 In addition to tasks which routinely create bad values in the output
value is undefined, KAPPA offers many applications for flagging
pixels with certain properties or locations.
 3 Doing_it_the_ARD_way
To mask a region or a series of regions within an NDF, you can
create an ASCII Region Definition (ARD) file.
      % cat myard.ard
     PIXEL( 23, -17 )
     CIRCLE( -14.5, 318.7, 44.3 )
     ELLIPSE( 75.2, 296.6, 33, 16, 78 )
     POLYGON( 110, 115, 123, 132, 130, 125 )
     CIRCLE( 10, 10, 40 ) .AND. .NOT. CIRCLE( 10, 10, 30 )
     CTRL/D
 In this example, the regions are: the pixel with index (23,-17), a
circle of radius 44.3 pixels about pixel co-ordinates (-14.5,318.7),
an ellipse centred at (75.2,296.6) with semi-major axis of 33 pixels
and semi-minor axis of 16 pixels, at orientation 78 degrees clockwise
from the x axis, and an annulus centred on pixel (10,10) between
radius 30 and 40 pixels.  There are several other keywords besides
those shown here.  ARD also has a powerful syntax for combining
regions, and you can set it up to use linear data co-ordinates or
your co-ordinate system.  These are described fully in SUN/183, but
you'll be relieved to learn that there is a shortcut.
 If you are dealing with 2-dimensional data, KAPPA offers an
interactive graphical tool for generating ARD files.  To use ARDGEN
you must first display your data on a device with a cursor, such as
an X-terminal.  DISPLAY with a greyscale lookup table is probably
best for doing that.  The grey lets you see the coloured overlays
clearly.
      % ardgen demo.ard
      Current picture has name: DATA, comment: KAPPA_DISPLAY.
     Using NDF '/star/bin/kappa/ccdframec'
      Instructions for using the cursor...
        Press left button on mouse/trackerball to select a point.
        Press middle button on mouse/trackerball to see current
        cursor co-ordinates.
        Press right button on mouse/trackerball to end input.
      SHAPE - Region shape /'CIRCLE'/ >
 At this point you can select a shape.  Enter ? to get the the list.
Once you've selected a shape you'll receive instructions.
      SHAPE - Region shape /'COLUMN'/ > ellipse
      Region type is "ELLIPSE". Identify the centre, then one end of
     the semi-major axis, and finally one other point on the ellipse.
 Once you have defined one ellipse, you can define another or exit to
the OPTION prompt.  In addition to keyboard 1, pressing the right-hand
mouse button has the same effect.  Thus in the example, the new shape is
a rotated box.
      Region completed. Identify another 'ELLIPSE' region...
     OPTION - Next operation to perform /'SHAPE'/ > rotbox
      Region type is "ROTBOX". Identify the two end points of any
     edge and then give a point on the opposite edge.
     Region completed. Identify another 'ROTBOX' region...
 If you make a mistake, enter List at the OPTION prompt to see a list
of the regions.  Note the ``Region Index'' of the region(s) you wish
to remove, and select the Delete option.  At the REGION prompt,
give a list of the regions you want to remove.  If you change your
mind, enter ! at the prompt for parameter REGIONS, and no regions are
deleted.
 Now suppose you want to combine or invert regions in some way, you
supply Combine at the OPTION prompt.  So suppose we have
created the following regions in $KAPPA_DIR/ccdframe.
        Region          Region Description
       Index
 
         1   -  ELLIPSE( 174.1, 234.4, 82.2, -43.5, 65.64783 )
         2   -  ELLIPSE( 168.1, 209.1, 29.4, -19.7, 9.441798 )
         3   -  ELLIPSE( 42.2, 244.1, 13, -10.3, 111.8452 )
         4   -  ROTBOX( 40.5, 219.2, 63.8, 38.3, 37.24281 )
         5   -  RECT( 141.5, 1.4, 143.9, 358.8 )
         6   -  POLYGON( 229.8, 247.7,
                         233.4, 247.7,
                         233.4, 258.6,
                         231, 267,
                         229.8, 265.8,
                         228.6, 256.2 )
 We want to form the region inside the first ellipse but not inside
the second.  This done in two stages.  First we invert the second
ellipse, meaning that pixels are included if they are not inside
this ellipse, by combining with the NOT operator.
      OPTION - Next operation to perform /'SHAPE'/ > comb
     OPERATOR - How to combine the regions /'AND'/ > not  
     OPERANDS - Indices of regions to combine or invert /6/ > 2
 This removes the original region 2, decrements the region numbers of
the other regions following 2 by one, so that region 3 becomes 2, 4
becomes 3, and so on.  A new region 7 is the inverted ellipse.  The
renumbering makes it worth listing the regions before combining
regions.  The second stage is to combine it with region 1, using the
AND operator.  This includes pixels if they are in both regions.
In this example, that means all the pixels outside the second
ellipse but which lie within the first.
     OPTION - Next operation to perform /'SHAPE'/ > com
    OPERATOR - How to combine the regions /'AND'/ > 
    OPERANDS - Indices of regions to combine or invert /[6,7]/ > 1,6
 Here is another example of combination.  This creates a region for
pixels are included provided they are in one of two regions, but not
in both.  Here we apply the XOR operator to the small ellipse
and the first rotated box.
      OPTION - Next operation to perform /'SHAPE'/ > comb
     OPERATOR - How to combine the regions /'AND'/ > xor
     OPERANDS - Indices of regions to combine or invert /[4,5]/ > 1,2
 Here is the final set of regions.
      OPTION - Next operation to perform /'SHAPE'/ > list
        Region          Region Description
       Index
 
         1   -  RECT( 141.5, 1.4, 143.9, 358.8 )
         2   -  POLYGON( 229.8, 247.7,
                         233.4, 247.7,
                         233.4, 258.6,
                         231, 267,
                         229.8, 265.8,
                         228.6, 256.2 )
 
         3   -  ( ELLIPSE( 174.1, 234.4, 82.2, -43.5, 65.64783 )
                  .AND.
                  ( .NOT. ELLIPSE( 168.1, 209.1, 29.4, -19.7, 9.441798 ) ) )
 
         4   -  ( ELLIPSE( 42.2, 244.1, 13, -10.3, 111.8452 )
                  .XOR.
                  ROTBOX( 40.5, 219.2, 63.8, 38.3, 37.24281 ) )
 Once you are done, enter "Exit" at the OPTION prompt, and the
ARD file is created.  "Quit" also leaves the programme, but
the ARD file is not made.
 Having created the ARD file it is straightforward to generate a
masked image with ARDMASK.
      % ardmask $KAPPA_DIR/ccdframec demo.ard ardccdmask
 If you have duplicated the above tutorial you should have an
image on view with the original regions outlined.  To see where you
have masked, use DISPLAY, which lets you define a colour for bad
pixels using the BADCOL parameter.
      % display ardccdmask badcol=red \\
 3 SEGMENT_and_ZAPLIN
 SEGMENT is ostensibly for copying polygonal regions from one NDF to
another.  You may also use SEGMENT to copy bad pixels into the
polygonal regions by giving the null value for one of the two input
NDFs.  For instance,
      % segment in1=! in2=$KAPPA_DIR/ccdframec out=ccdmask
 NDF ccdmask will have bad values inside the polygons, whereas
      % segment in2=! in1=$KAPPA_DIR/ccdframec out=ccdmask
 the pixels exterior to the polygons are flagged.  SEGMENT lets you
define the polygon vertices interactively, like in ARDGEN, but you
can also use text files, or respond to prompting.
 ZAPLIN also has an option to fill in rectangular areas when parameter
ZAPTYPE has value Bad.
 3 Special_Filters_for_Inserting_Bad_Values
There are applications that mask pixels if their values meet certain
criteria.
 SETMAGIC flags those pixels with a nominated value.  It is most
useful during conversion of imported data whose data system uses
bad-pixel values different from Starlink's.
 FFCLEAN removes defects smaller than a nominated size from an image
or vector NDF.  It flags those pixels that deviate from a smoothed
version of the NDF by more than some number of standard deviations
from the local mean.
 ERRCLIP flags pixels that have errors larger than some supplied
limit or signal-to-noise ratios below a threshold.  The errors come
from the VARIANCE component of the NDF.  Thus you can exclude
unreliable data from analysis.
 2 Quality_Masking
All the NDF tasks in KAPPA use quality yet there is no obvious sign
in individual applications how particular values of quality are
selected.  What gives?  The meanings attached to the quality bits
will inevitably be quite specific for specialist software packages,
but KAPPA tasks aim to be general purpose.  To circumvent this
conflict there is an NDF component called the bad-bits mask that
forms part of the quality information.  Like a QUALITY value, the
bad-bits mask is an unsigned byte.  Its purpose is to convert the
eight quality flags into a single logical value for each pixel,
which can then be processed just like a bad pixel. 
 When data are read from the NDF by mapping into memory, the quality
of each pixel is combined with the bad-bits mask; if a result of
this quality masking is FALSE, that pixel is assigned the bad value
for processing.  This does not change the original values stored in
the NDF; it only affects the mapped data.
 So how do the quality and bad-bits mask combine to form a logical
value?  They form the bit-wise `AND' and test it for equality for 0.
None the wiser?  Regard each bit in the bad-bits mask as a switch
to activate detection of the corresponding bit in a pixel's quality.
The switch is on if it has value 1, and is off if it has value 0.
Thus if the pixel is flagged only if one or more of the 8 bits
has both quality and the corresponding bad-bit set to 1.  Here
are some examples:
 QUALITY:     10000001    10000001
Bad-bits:    01000100    01000101
Bits on:                        ^
Result:      TRUE        FALSE
 The application SETBB allows you to modify the bad-bits mask in
an NDF.  It allows you to specify the bit pattern in a number of
ways including decimal and binary as illustrated below.
      % setbb RO950124 5
     % setbb RO950124 b101
 These both set the bad-bits mask to 00000101 for the NDF RO950124.
SETBB also allows you to combine an existing NDF bad-bits mask with
another mask using the operators AND and OR.  OR lets you switch on
additional bits without affecting those already on; AND lets you
turn off selected bits leaving the rest unchanged.
      % setbb RO950124 b00010001 or
     % setbb RO950124 b11101110 and
 The first example sets bits 1 and 5 but leaves the other bits of
the mask unaltered, whereas the second switches off the same bits.
 Now remembering which bit corresponds to which could be a strain on
the memory.  It would be better if some meaning was attached to each
bit through a name.  There are four general tasks in the IRAS90
package which address this. [We plan to integrate them into the
more-natural home of the NDFPACK sub-package of KAPPA.]  SETQUAL
sets quality values and names; SHOWQUAL lists the named qualities;
REMQUAL removes named qualities; and QUALTOBAD uses a logical
expression containing the named quality properties to create a
copy of your NDF in which pixels satisfying the quality expression
are set bad.  See Section 4.3 of SUN/163 for details.
 2 Removing_bad_pixels
 Sometimes having bad pixels present in your data is a nuisance, say
because some application outside of KAPPA does not recognise them, or
you want to integrate the flux of a source.  KAPPA offers a number of
options for removing bad values.  Which of these is appropriate
depends on the reason why you want to remove the bad pixels.
 First you could replace the bad values with some other reasonable value,
such as zero.
      % nomagic old new 0 comp=all
 Here dataset new is the same as dataset old except that any bad value
in the data or variance array has now become zero.
 If you wanted some representative value used based upon neighbouring
pixels, use the GLITCH command.
      % fillbad old new size=4
 The value of parameter SIZE should be about half the diameter of the
largest region of bad pixels.  Both the data array and variance arrays
are filled.
 You may replace individual pixels or rectangular sections using CHPIX.
      % chpix old new
     SECTION - Section to be set to a constant /'55,123'/ >
     NEWVAL - New value for the section /'60'/ >
     SECTION - Section to be set to a constant /'1:30,-10:24'/ >
     NEWVAL - New value for the section /'-1'/ >
     SECTION - Section to be set to a constant /'1:30,-10:24'/ > !
 This replaces pixel (55,123) with value 60, and the region from
(1,-10) to (30,24) with -1.  The final ! ends the loop of
replacements.  If you supply NEWVAL on the command line, only one
replacement occurs.
 It is also possible to paste other datasets where your bad values
lie with the PASTE and SEGMENT tasks.
      % paste old fudge"(10:20,29:30)" out=new
 The dataset old is a copy of dataset new, except in the 22-pixel
region (10,29) to (20,30), where the values originate from the fudge
dataset.
.endhelp
