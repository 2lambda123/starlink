      SUBROUTINE KPS1_MFLD<T>( DTAXIS, NCLIP, CLIP, DIMS, ARRAY,
     :                         STATUS )
*+
*  Name:
*     KPS1_MFLDx

*  Purpose:
*     Flags deviant pixels from a linear fit for all elements
*     along a given axis.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL KPS1_MFLD<T>( DTAXIS, NCLIP, CLIP, DIMS, ARRAY, STATUS )

*  Description:
*     This routine serves MFITTREND.  It fits a straight line to
*     to all lines of the supplied data that lie parallel to a given
*     axis, and iteratively rejects outliers within each line using the
*     dispersion within that line.

*  Arguments:
*     DTAXIS = INTEGER (Given)
*        The axis index of the dimension that is being detrended.
*     NCLIP = INTEGER (Given)
*        The number of clipping cycles for the rejection of outliers.
*     CLIP( NCLIP ) = REAL (Given)
*        The clipping levels in standard deviations for the rejection 
*        of outliers.
*     DIMS( NDF__MXDIM ) = INTEGER (Given)
*        The dimensions of the array to be analysed.
*     ARRAY( EL ) = ? (Given & Returned)
*        The lines of data being fitted.  On exit, deviant points will
*        replaced with the bad-pixel value.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Notes:
*     -  There is a routine for double-precision and real data types:
*     replace "x" in the routine name by D or R as appropriate.  The
*     ARRAY argument supplied to the routine must have the data type
*     specified.

*  Copyright:
*     Copyright (C) 2007, 2008 Science & Technology Facilities Council.
*     All Rights Reserved.

*  Licence:
*     This program is free software; you can redistribute it and/or
*     modify it under the terms of the GNU General Public License as
*     published by the Free Software Foundation; either version 2 of
*     the License, or (at your option) any later version.
*
*     This program is distributed in the hope that it will be
*     useful, but WITHOUT ANY WARRANTY; without even the implied
*     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
*     PURPOSE. See the GNU General Public License for more details.
*
*     You should have received a copy of the GNU General Public License
*     along with this program; if not, write to the Free Software
*     Foundation, Inc., 59, Temple Place, Suite 330, Boston, MA
*     02111-1307, USA.

*  Authors:
*     MJC: Malcolm J. Currie (STARLINK)
*     {enter_new_authors_here}

*  History:
*     2007 September 30 (MJC):
*        Original version adapted from KPS1_MFADx.
*     2008 May 15 (MJC):
*        Used revised API for KPS1_LFTx.
*     {enter_changes_here}

*-

*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants
      INCLUDE 'NDF_PAR'          ! NDF_ public constants
      INCLUDE 'PRM_PAR'          ! PRIMDAT public constants
      INCLUDE 'CNF_PAR'          ! For CNF_PVAL function
      
*  Arguments Given:
      INTEGER DTAXIS
      INTEGER NCLIP
      REAL CLIP( NCLIP )
      INTEGER DIMS( NDF__MXDIM )

*  Arguments Given and Returned:
      <TYPE> ARRAY( * )

*  Status:
      INTEGER STATUS             ! Global status

*  Local Constants:
      LOGICAL BAD                ! Process bad pixels
      PARAMETER ( BAD = .TRUE. )

      INTEGER LINDIM             ! Dimensionality of a line
      PARAMETER ( LINDIM = 1 )

      INTEGER MAXRNG             ! Maximum number of range limits
      PARAMETER( MAXRNG = 2 )

      INTEGER ORDER              ! Fit order
      PARAMETER ( ORDER = 1 )

*  Local Variables:
      INTEGER AREA               ! Number of lines to be fit at once
      INTEGER DIMPRM( NDF__MXDIM ) ! Permuted dimensions
      DOUBLE PRECISION DMAX      ! Max. value of pixels in array
      DOUBLE PRECISION DMAXC     ! Max. pixel value after clipping
      DOUBLE PRECISION DMIN      ! Min. value of pixels in array
      DOUBLE PRECISION DMINC     ! Min. pixel value after clipping
      INTEGER DTEL               ! Number of elements along detrend axis
      INTEGER EL                 ! Number of elements in supplied array
      <LTYPE> HIGH               ! Higher rejection threshold
      INTEGER I                  ! Loop counter
      INTEGER IDIMS( NDF__MXDIM ) ! Paste-array dimensions
      INTEGER IERR               ! Position of first error (dummy)
      INTEGER IMAX               ! Vector index of max. pixel
      INTEGER IMAXC              ! Vector index of max. clipped pixel
      INTEGER IMIN               ! Vector index of min. pixel
      INTEGER IMINC              ! Vector index of min. clipped pixel
      INTEGER IPAS               ! Pointer to workspace for A matrix
      INTEGER IPBS               ! Pointer to coefficients
      INTEGER IPLINE             ! Pointer to a single detrend line
      INTEGER IPMASK             ! Pointer to a single masked line
      INTEGER IPPERM             ! Pointer to permuted supplied array
      INTEGER IPPRES             ! Pointer to permuted residuals array
      INTEGER IPRES              ! Pointer to residuals
      INTEGER IPRLIN             ! Pointer to a single line of residuals
      INTEGER IPWORK             ! Pointer to work array 
      INTEGER IPWRK1             ! Pointer to workspace
      INTEGER IPWRK2             ! Pointer to workspace
      INTEGER J                  ! Loop counter
      INTEGER LBND( 1 )          ! Lower bound of the whole array
      INTEGER LBNDL( 1 )         ! Lower bound of a line section
      <LTYPE> LOW                ! Lower rejection threshold
      DOUBLE PRECISION MEAN      ! Mean of pixels in array
      DOUBLE PRECISION MEANC     ! Mean of pixels after clipping
      INTEGER NBAD               ! Number of bad values
      INTEGER NEL                ! Number of elements (not used)
      INTEGER NGOOD              ! Number of valid values
      INTEGER NGOODC             ! Number valid values after clipping
      INTEGER NERR               ! Number of errors
      INTEGER NREPHI             ! Number of high residuals rejected
      INTEGER NREPLO             ! Number of low residuals rejected
      INTEGER ODIMS( NDF__MXDIM ) ! Base-array dimensions
      INTEGER OFFSET( NDF__MXDIM ) ! Paste origin offsets
      INTEGER PERMBA( NDF__MXDIM ) ! Backward-permutation indices
      INTEGER PERMFO( NDF__MXDIM ) ! Forward-permutation indices
      INTEGER RANGES( MAXRNG )   ! Exclusion ranges
      DOUBLE PRECISION STDEV     ! Standard devn. of pixels in array
      DOUBLE PRECISION STDEVC    ! Std. devn. of pixels after clipping
      DOUBLE PRECISION SUM       ! Sum of pixels in array
      DOUBLE PRECISION SUMC      ! Sum of pixels after clipping
      INTEGER UBND( 1 )          ! Upper bound of the whole array
      INTEGER UBNDL( 1 )         ! Upper bound of a line section

*  Internal References:
      INCLUDE 'NUM_DEC_CVT'      ! NUM declarations for conversions
      INCLUDE 'NUM_DEF_CVT'      ! NUM definitions for conversions
            
*.

*  Check the inherited global status.
      IF ( STATUS .NE. SAI__OK ) RETURN

*  Find the number of elements in the array and the size of the
*  A- and B-matrix workspaces.  We need space for the cumulative 
*  coefficient sums and the coefficients themselves (Ax=B).
      EL = 1
      AREA = 1
      DO I = 1, NDF__MXDIM
         EL = EL * DIMS( I )
         IF ( I .NE. DTAXIS ) THEN
            AREA = AREA * DIMS( I )
         END IF
      END DO
      DTEL = DIMS( DTAXIS )

*  Form the permutation arrays needed to make the trend axis first and
*  then to restore the original order.
      PERMFO( 1 ) = DTAXIS
      DO I = 1, NDF__MXDIM
         IF ( I .GT. DTAXIS ) THEN
            PERMBA( I ) = I
            PERMFO( I ) = I
         ELSE IF ( I .LT. DTAXIS ) THEN
            PERMBA( I ) = I + 1
            PERMFO( I + 1 ) = I
         ELSE
            PERMBA( I ) = 1
         END IF
         DIMPRM( I ) = DIMS( PERMFO( I ) )
      END DO

*  Define some fixed bounds and dimensions needed by the paste
*  and permute routines.
      IDIMS( 1 ) = DTEL
      ODIMS( 1 ) = EL
      DO I = 2, NDF__MXDIM
        OFFSET( I ) = 0
        IDIMS( I ) = 1
        ODIMS( I ) = 1
      END DO
      LBND( 1 ) = 1
      UBND( 1 ) = EL

*  Initialise some variables for the fitting.
      RANGES( 1 ) = 1
      RANGES( 2 ) = DIMS( DTAXIS )

*  Obtain the workspace for the fits.
      CALL PSX_CALLOC( AREA * ( ORDER + 1 ) * ( ORDER + 1 ),
     :                 '_DOUBLE', IPAS, STATUS )
       
      CALL PSX_CALLOC( AREA * ( ORDER + 1 ), '_DOUBLE', IPBS, STATUS )
      CALL PSX_CALLOC( AREA * ( ORDER + 1 ), '_DOUBLE', IPWRK1, STATUS )
      CALL PSX_CALLOC( AREA * ( ORDER + 1 ), '_INTEGER', IPWRK2,
     :                 STATUS )
           
*  Get some workspace for the subtracted array and a permuted version of
*  it and the output array, a copy of the original data with rejected 
*  pixels flagged as bad, and a mask of rejected pixels.
      CALL PSX_CALLOC( EL, '<HTYPE>', IPRES, STATUS )
      CALL PSX_CALLOC( EL, '<HTYPE>', IPPERM, STATUS )
      CALL PSX_CALLOC( EL, '<HTYPE>', IPPRES, STATUS )
      CALL PSX_CALLOC( DTEL, '<HTYPE>', IPMASK, STATUS )
      CALL PSX_CALLOC( DTEL, '<HTYPE>', IPWORK, STATUS )
      CALL PSX_CALLOC( DTEL, '<HTYPE>', IPRLIN, STATUS )
      CALL PSX_CALLOC( DTEL, '<HTYPE>', IPLINE, STATUS )
      IF ( STATUS .NE. SAI__OK ) GO TO 999

      DO J = 1, NCLIP

*  Fit a linear slope to all the data. 
         CALL KPS1_LFT<T>( ORDER, DTAXIS, MAXRNG, RANGES, .FALSE., 
     :                     ARRAY, .FALSE., ARRAY, DIMS, ARRAY,
     :                     %VAL( CNF_PVAL( IPAS ) ),
     :                     %VAL( CNF_PVAL( IPBS ) ),
     :                     %VAL( CNF_PVAL( IPWRK1 ) ),
     :                     %VAL( CNF_PVAL( IPWRK2 ) ), STATUS )

*  Copy the flagged (or the initial unflagged array on the first pass)
*  array to what will become the subtracted-fit array.
         CALL VEC_<T>TO<T>( BAD, EL, ARRAY, %VAL( CNF_PVAL( IPRES ) ), 
     :                      IERR, NERR, STATUS )

*  Form the residuals from the fit.
         CALL KPS1_LFTS<T>( ORDER, DTAXIS, .TRUE., DIMS, 
     :                      %VAL( CNF_PVAL( IPBS ) ), 
     :                      %VAL( CNF_PVAL( IPRES ) ), STATUS )

*  For the rejection process each line to be fit is filtered separately.
*  To make this easier, permute the axes in the supplied array and
*  residuals so that the trend axis is first.  Then within the permuted
*  arrays, each line is offset from the next by the length of the trend 
*  axis in bytes.  There are AREA lines to test.
         CALL KPS1_PRMX<T>( NDF__MXDIM, DIMS, DIMPRM, PERMFO, 
     :                      %VAL( CNF_PVAL( IPRES ) ),
     :                      %VAL( CNF_PVAL( IPPRES ) ), STATUS )

         CALL KPS1_PRMX<T>( NDF__MXDIM, DIMS, DIMPRM, PERMFO, ARRAY,
     :                      %VAL( CNF_PVAL( IPPERM ) ), STATUS )

         DO I = 1, AREA

*  Extract a detrend line and its residuals.
            LBNDL( 1 ) = 1 + ( I - 1 ) * DTEL
            UBNDL( 1 ) = I * DTEL
            CALL KPG1_CPND<T>( LINDIM, LBND, UBND,  
     :                         %VAL( CNF_PVAL( IPPRES ) ),
     :                         LBNDL, UBNDL, 
     :                         %VAL( CNF_PVAL( IPRLIN ) ), NEL, STATUS )

            CALL KPG1_CPND<T>( LINDIM, LBND, UBND, 
     :                         %VAL( CNF_PVAL( IPPERM ) ),
     :                         LBNDL, UBNDL,
     :                         %VAL( CNF_PVAL( IPLINE ) ), NEL, STATUS )


*  Derive the statistics of the residuals to the fit.  No clipping is
*  applied here.
            CALL KPG1_STAT<T>( BAD, DTEL, %VAL( CNF_PVAL( IPRLIN ) ), 0, 
     :                         CLIP, NGOOD, IMIN, DMIN, IMAX, DMAX, SUM,
     :                         MEAN, STDEV, NGOODC, IMINC, DMINC, 
     :                         IMAXC, DMAXC, SUMC, MEANC, STDEVC,
     :                         STATUS )

*  Flag outliers beyond the clipping interval.
            IF ( STDEV .NE. VAL__BADD ) THEN
               LOW = NUM_DTO<T>( MEAN - DBLE( CLIP( J ) ) * STDEV )
               HIGH = NUM_DTO<T>( MEAN + DBLE( CLIP ( J ) ) * STDEV )

*  Replace the values in the output array outside the range with the
*  new values, otherwise copy from the input to the output NDF.
               CALL KPG1_THRS<T>( BAD, DTEL, %VAL( CNF_PVAL( IPRLIN ) ),
     :                            LOW, HIGH, VAL__BAD<T>, VAL__BAD<T>,
     :                            %VAL( CNF_PVAL( IPWORK ) ),
     :                            NREPLO, NREPHI, STATUS )

               IF ( NREPLO .GT. 0 .OR. NREPHI .GT. 0 ) THEN

*  Multiply the values by 0 to form a mask of the rejected elements.
                  CALL KPG1_CMUL<T>( BAD, DTEL,
     :                               %VAL( CNF_PVAL( IPWORK ) ), 
     :                               0.0D0, %VAL( CNF_PVAL( IPMASK ) ), 
     :                               NBAD, STATUS )

*  Add the mask to the array being fitted.
                  CALL VEC_ADD<T>( BAD, DTEL,
     :                             %VAL( CNF_PVAL( IPLINE ) ),
     :                             %VAL( CNF_PVAL( IPMASK ) ), 
     :                             %VAL( CNF_PVAL( IPWORK ) ), 
     :                             IERR, NERR, STATUS )

*  Copy the flagged array to the returned, but permuted, array.
                  CALL VEC_<T>TO<T>( BAD, DTEL,
     :                               %VAL( CNF_PVAL( IPWORK ) ), 
     :                               %VAL( CNF_PVAL( IPLINE ) ), 
     :                               IERR, NERR, STATUS )

*  Paste the line with flagged features back into the raw permuted data.
                  OFFSET( 1 ) = ( I - 1 ) * DTEL
                  CALL KPG1_PAST<T>( .FALSE., .TRUE., OFFSET, IDIMS, 
     :                               DTEL, %VAL( CNF_PVAL( IPLINE ) ),
     :                               ODIMS, EL, 
     :                               %VAL( CNF_PVAL( IPPERM ) ),
     :                               STATUS )
               END IF
            END IF
         END DO

*  Restore the original permutation of the supplied array, but now it
*  has pixels with the largest residuals masked.
         CALL KPS1_PRMX<T>( NDF__MXDIM, DIMPRM, DIMS, PERMBA,
     :                      %VAL( CNF_PVAL( IPPERM ) ), ARRAY, STATUS )

      END DO

  999 CONTINUE

*  Free workspaces arrays.
      CALL PSX_FREE( IPLINE, STATUS )
      CALL PSX_FREE( IPRLIN, STATUS )
      CALL PSX_FREE( IPPERM, STATUS )
      CALL PSX_FREE( IPPRES, STATUS )
      CALL PSX_FREE( IPMASK, STATUS )
      CALL PSX_FREE( IPWORK, STATUS )
      CALL PSX_FREE( IPRES, STATUS )
      CALL PSX_FREE( IPWRK2, STATUS )
      CALL PSX_FREE( IPWRK1, STATUS )
      CALL PSX_FREE( IPBS, STATUS )
      CALL PSX_FREE( IPAS, STATUS )

      END
