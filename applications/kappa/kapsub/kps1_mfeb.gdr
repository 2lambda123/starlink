      SUBROUTINE KPS1_MFEB<T>( COMPRS, DIMS, BARRAY, MASK, STATUS )
*+
*  Name:
*     KPS1_MFEBx

*  Purpose:
*     Transfers bad pixels from an array binned along one or more
*     axes to an unbinned mask.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL KPS1_MFEBx( COMPRS, DIMS, BARRAY, MASK, STATUS )

*  Description:
*     This transfers bad pixels from the supplied binned array
*     to sections within the the supplied unbinned array.  It is assumed
*     that the binned and unbinned arrays have the same origin.

*  Arguments:
*     COMPRS( NDF__MXDIM ) = INTEGER (Given)
*        The binning factors, i.e. the number of elements of the 
*        original unbinned array along each axis that were combined to
*        form one element of ARRAY.
*     CLIP( NCLIP ) = REAL (Given)
*        The clipping levels in standard deviations for the rejection 
*        of outliers.
*     DIMS( NDF__MXDIM ) = INTEGER (Given)
*        The dimensions of the unbinned array.
*     BARRAY( * ) = ? (Given)
*        The binned array.  Its ith dimension is given by 
*        DIMS(i) / COMPRS( I )
*     MASK( * ) = BYTE (Given & Returned)
*        The unbinned mask array.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Notes:
*     -  There is a routine for double-precision and real data types:
*     replace "x" in the routine name by D or R as appropriate.  The
*     BARRAY argument supplied to the routine must have the data type
*     specified.

*  Copyright:
*     Copyright (C) 2007 Science & Technology Facilities Council.
*     All Rights Reserved.

*  Licence:
*     This program is free software; you can redistribute it and/or
*     modify it under the terms of the GNU General Public License as
*     published by the Free Software Foundation; either Version 2 of
*     the License, or (at your option) any later version.
*
*     This program is distributed in the hope that it will be
*     useful, but WITHOUT ANY WARRANTY; without even the implied
*     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
*     PURPOSE. See the GNU General Public License for more details.
*
*     You should have received a copy of the GNU General Public License
*     along with this program; if not, write to the Free Software
*     Foundation, Inc., 59, Temple Place, Suite 330, Boston, MA
*     02111-1307, USA.

*  Authors:
*     MJC: Malcolm J. Currie (STARLINK)
*     {enter_new_authors_here}

*  History:
*     2007 August 16 (MJC):
*        Original version.
*     2007 September 6 (MJC):
*        No longer write to the array itself but log the feature mask
*        in the new BYTE MASK that replaces the ARRAY argument. 
*     {enter_further_changes_here}

*-

*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants
      INCLUDE 'NDF_PAR'          ! NDF constants
      INCLUDE 'PRM_PAR'          ! Bad values
      INCLUDE 'CNF_PAR'          ! For CNF_PVAL

*  Arguments Given:
      INTEGER COMPRS( NDF__MXDIM )
      INTEGER DIMS( NDF__MXDIM )
      <TYPE> BARRAY( * )

*  Arguments Given and Returned:
      BYTE MASK( * )
      
*  Status:
      INTEGER STATUS             ! Global status

*  Local Variables:
      INTEGER BDIMS( NDF__MXDIM ) ! Dimensions of binned array
      INTEGER BIND( NDF__MXDIM ) ! Indices from vectorised binned array
      INTEGER BEL                ! Number of elements in binned array
      INTEGER EL                 ! Number of elements in unbinned array
      INTEGER I                  ! Loop counter
      INTEGER IPSECT             ! Pointer to unbinned bad section
      INTEGER J                  ! Loop counter
      INTEGER LBND( NDF__MXDIM ) ! Section lower bounds
      INTEGER OFFSET( NDF__MXDIM ) ! Offset of section wrt unbinned
      INTEGER SEL                ! Number of elements in section

*.

*  Check the inherited global status.
      IF ( STATUS .NE. SAI__OK ) RETURN

*  Obtain the dimensions of the binned array and the total number of
*  elements
      EL = 1
      BEL = 1
      SEL = 1
      DO I = 1, NDF__MXDIM
         BDIMS( I ) = DIMS( I ) / COMPRS( I )
         LBND( I ) = 1
         EL = EL * DIMS( I )
         BEL = BEL * BDIMS( I )
         SEL = SEL * COMPRS( I )
      END DO

*  Initialise the MASK.
      DO I = 1, EL
         MASK( I ) = 0
      END DO

*  Allocate some work space for the section corresponding the the
*  single element in the binned array.  It is always going to have
*  this size.
      CALL PSX_CALLOC( SEL, '_BYTE', IPSECT, STATUS )
      IF ( STATUS .NE. SAI__OK ) GOTO 999

*  Fill it with the bad value.
      CALL KPG1_FILLB( VAL__BADB, SEL, %VAL( CNF_PVAL( IPSECT ) ),
     :                 STATUS )

*  Search for bad pixels.  Convert the vectorised index of each bad
*  pixel into n-dimensional pixel indices.
      I = 1
      DO WHILE ( I .LE. BEL )
         IF ( BARRAY( I ) .EQ. VAL__BAD<T> ) THEN
            CALL KPG1_VEC2N( 1, I, NDF__MXDIM, LBND, BDIMS, BIND, 
     :                       STATUS )

*  Determine the offset of the section of bad pixels with respect to the
*  origin of the unbinned array.
            DO J = 1, NDF__MXDIM
               OFFSET( J ) = ( BIND( J ) - 1 ) * COMPRS( J )
            END DO

*  Paste the bad-pixel section into the appropriate place within the
*  unbinned array.
            CALL KPG1_PASTB( .FALSE., .TRUE., OFFSET, COMPRS, SEL,
     :                        %VAL( CNF_PVAL( IPSECT ) ), DIMS, EL,
     :                        MASK, STATUS )
         END IF
         I = I + 1
      END DO

      CALL PSX_FREE( IPSECT, STATUS )

  999 CONTINUE
      END
