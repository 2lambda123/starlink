      SUBROUTINE KPS1_CLPS<T>( AXIS, LO, HI, VAR, METH, WLIM, NEL2, 
     :                       NDIM1, LBND1, UBND1, DIN, VIN, CIN, WIN,
     :                       NDIM2, LBND2, UBND2, DOUT, VOUT, WORK1, 
     *                       WORK2, WORK3, STATUS )
*+
*  Name:
*     KPS1_CLPS<T>

*  Purpose:
*     Collapse one axis of an N-dimensional array using one of a
*     selection of statistics.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL KPS1_CLPS<T>( AXIS, LO, HI, VAR, METH, WLIM, NEL2, NDIM1, 
*                      LBND1, UBND1, DIN, VIN, CIN, WIN, NDIM2, LBND2,
*                      UBND2, DOUT, VOUT, WORK1, WORK2, WORK3, STATUS )

*  Description:
*     This routine collapses the supplied data and variance arrays
*     along the specified axis.  See the COLLAPSE documentation.

*  Arguments:
*     AXIS = INTEGER (Given)
*        The index of the axis to be collapsed.
*     LO = INTEGER (Given)
*        The low pixel index bound of the range of axis AXIS to be
*        collapsed.
*     HI = INTEGER (Given)
*        The high pixel index bound of the range of axis AXIS to be
*        collapsed.
*     VAR = LOGICAL (Given)
*        Process variances?
*     METH = CHARACTER * ( * ) (Given)
*        Estimator: 'MEAN', 'WMEAN', 'MODE', 'MEDIAN', 'SUM', 'SIGMA', 
*        'INTEG', 'IWC', 'IWD', 'RMS', 'ABSDEV', 'MAX', 'MIN', 'COMAX',
*        or 'COMIN'.  See the COLLAPSE documentation for details.
*     WLIM = REAL (Given)
*        Fraction of pixels which must be good to create a good output
*        pixel.
*     NEL2 = INTEGER (Given)
*        Total number of elements in the output array (i.e. the product
*        of the output dimension sizes).
*     NDIM1 = INTEGER (Given)
*        The number of axes in the input array.
*     LBND1( NDIM1 ) = INTEGER (Given)
*        The lower pixel index bounds of the input array.
*     UBND1( NDIM1 ) = INTEGER (Given)
*        The upper pixel index bounds of the input array.
*     DIN( * ) = <TYPE> (Given)
*        The input data values.
*     VIN( * ) = <TYPE> (Given)
*        The input variance values.  It is only accessed if VAR is
*        .TRUE.
*     CIN( * ) = <TYPE> (Given)
*        The co-ordinates along the collapse axis, starting at index LO,
*        for each pixel.  It is only accessed if METH is one of 'INTEG',
*        'IWC', 'IWD', 'COMAX', or 'COMIN'.
*     WIN( * ) = <TYPE> (Given)
*        The pixel widths along the collapse axis, starting at index LO.
*        It is only accessed if METH is 'INTEG'
*     NDIM2 = INTEGER (Given)
*        The number of axes in the output array.
*     LBND2( NDIM2 ) = INTEGER (Given)
*        The lower pixel index bounds of the output array.
*     UBND2( NDIM2 ) = INTEGER (Given)
*        The upper pixel index bounds of the output array.
*     DOUT( * ) = <TYPE> (Returned)
*        The output data values.
*     VOUT( * ) = <TYPE> (Returned)
*        The output variance values.  It is only accessed if VAR is
*        .TRUE.
*     WORK1( NEL2, * ) = <TYPE> (Returned)
*        Work array.  The second axis should have at least (HI-LO+1) 
*        elements. It is nly accessed if AXIS is not equal to NDIM1.
*     WORK2( NEL2, * ) = <TYPE> (Returned)
*        Work array.  The second axis should have at least (HI-LO+1)
*        elements.  It is only accessed if VAR is .TRUE., and AXIS is
*        not equal to NDIM1.
*     WORK3( NEL2, * ) = <TYPE> (Returned)
*        Work array.  The second axis should have at least (HI-LO+1)
*        elements.  It is only accessed if METH is one of 'INTEG',
*        'IWC', 'IWD', 'COMAX', 'COMIN'; and AXIS is not equal to NDIM1.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Authors:
*     DSB: David Berry (STARLINK)
*     TIMJ: Tim Jenness (JAC, Hawaii)
*     MJC: Malcolm J. Currie (STARLINK)
*     {enter_new_authors_here}

*  History:
*     31-AUG-2000 (DSB):
*        Original version.
*     27-OCT-2000 (DSB):
*        Modified to avoid re-ordering the data if it is already in the
*        correct order (i.e. if the collapse axis is the last pixel
*        axis).
*     26-SEP-2001 (DSB):
*        Do not allocate memory for a covariance array (IPCOV) if
*        method=mean.
*     14-DEC-2001 (DSB):
*        Renamed weighted mean method as WMEAN, and add unweighted 
*        method MEAN.
*     27-AUG-2003 (DSB):
*        To avoid impractical memory requirements, estimate the output
*        median variances rather than calculating them properly for
*        sample sizes larger than 300.
*     2004 September 3 (TIMJ):
*        Use CNF_PVAL.
*     2005 December 22 (MJC):
*        Add MAX and MIN methods.
*     2005 December 24 (MJC):
*        Add ABSDEV method.
*     2005 December 27 (MJC):
*        Add SIGMA method.
*     2005 December 28 (MJC):
*        Add RMS method.
*     2005 December 29 (MJC):
*        Add SUM method.  Corrected prologue.
*     2005 December 30 (MJC):
*        Add INTEG, COMAX, COMIN, IWC, IWD methods.  Obtain workspace
*        for COMAX and COMIN.
*     2005 January 2 (MJC):
*        Added CIN argument, passed through to main subroutines.
*     2005 January 6 (MJC):
*        Added WIN argument, passed through to main subroutines.
*     2005 January 27 (MJC):
*        Added WORK3 argument, and use to permute width or co-ordinate
*        array.
*     2006 February 10 (MJC):
*        Obtain the pixel-index workspace for methods 31 and 32.
*     2006 February 13 (MJC):
*        Better initialisation of START to avoid valgrind warning.
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}

*-
      
*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants
      INCLUDE 'NDF_PAR'          ! NDF constants
      INCLUDE 'PRM_PAR'          ! VAL constants
      INCLUDE 'CNF_PAR'          ! For CNF_PVAL function

*  Arguments Given:
      INTEGER AXIS
      INTEGER LO
      INTEGER HI
      LOGICAL VAR
      CHARACTER METH*(*)
      REAL WLIM
      INTEGER NEL2
      INTEGER NDIM1
      INTEGER LBND1( NDIM1 )
      INTEGER UBND1( NDIM1 )
      <TYPE> DIN( * )
      <TYPE> VIN( * )
      <TYPE> CIN( * )
      <TYPE> WIN( * )
      INTEGER NDIM2
      INTEGER LBND2( NDIM2 )
      INTEGER UBND2( NDIM2 )

*  Arguments Returned:
      <TYPE> DOUT( * )
      <TYPE> VOUT( * )
      <TYPE> WORK1( NEL2, * )
      <TYPE> WORK2( NEL2, * )
      <TYPE> WORK3( NEL2, * )

*  Status:
      INTEGER STATUS             ! Global status

*  Local Variables:
      LOGICAL CARRY              ! Increment next axis?
      INTEGER DIM1( NDF__MXDIM ) ! Input dimension sizes
      INTEGER DIM2( NDF__MXDIM ) ! Output dimension sizes
      INTEGER IAX1               ! Input axis index
      INTEGER IAX2               ! Output axis index
      INTEGER IEL1               ! Index into input data vectors
      INTEGER IEL2               ! Index into output data vectors
      INTEGER IMETH              ! Combination method
      INTEGER IPCOIN             ! Pointer to workspace, co-ord indices
      INTEGER IPCOV              ! Pointer to workspace
      INTEGER IPNCON             ! Pointer to workspace
      INTEGER IPPNT              ! Pointer to workspace
      INTEGER IPPP               ! Pointer to workspace
      INTEGER IPUSED             ! Pointer to workspace
      INTEGER IPVAR              ! Pointer to dummy line variances
      INTEGER IPWRK1             ! Pointer to workspace
      INTEGER IPWRK2             ! Pointer to workspace
      INTEGER J                  ! Pixel index on collapsed axis
      INTEGER K                  ! Work array index
      INTEGER NLIN               ! No. of i/p pixels in each o/p pixel
      INTEGER NMAT               ! Size of workspace 
      INTEGER POS1( NDF__MXDIM ) ! Input pixel indices 
      INTEGER POS2( NDF__MXDIM ) ! Output pixel indices 
      INTEGER START              ! The first input element to use
      INTEGER STEP1              ! Vector step between collapsed pixels
      LOGICAL USECO              ! Method uses the co-ordinate array?
      LOGICAL USEIND             ! Method uses the pixel-index array?
      LOGICAL USEWID             ! Method uses the width array?
      LOGICAL USEWRK             ! Use the work arrays?

*.

*  Check the inherited global status.
      IF( STATUS .NE. SAI__OK ) RETURN

*  Check the supplied METH value.
      IF( METH .EQ. 'MEAN' ) THEN
         IMETH = 1

      ELSE IF( METH .EQ. 'WMEAN' ) THEN
         IMETH = 2

      ELSE IF( METH .EQ. 'MEDIAN' ) THEN
         IMETH = 3

      ELSE IF( METH .EQ. 'MODE' ) THEN
         IMETH = 5

      ELSE IF( METH .EQ. 'SUM' ) THEN
         IMETH = 12

      ELSE IF( METH .EQ. 'SIGMA' ) THEN
         IMETH = 13

      ELSE IF( METH .EQ. 'INTEG' ) THEN
         IMETH = 21

      ELSE IF( METH .EQ. 'IWC' ) THEN
         IMETH = 22

      ELSE IF( METH .EQ. 'IWD' ) THEN
         IMETH = 23

      ELSE IF( METH .EQ. 'RMS' ) THEN
         IMETH = 24

      ELSE IF( METH .EQ. 'ABSDEV' ) THEN
         IMETH = 25

      ELSE IF( METH .EQ. 'MAX' ) THEN
         IMETH = 31

      ELSE IF( METH .EQ. 'MIN' ) THEN
         IMETH = 32

      ELSE IF( METH .EQ. 'COMAX' ) THEN
         IMETH = 33

      ELSE IF( METH .EQ. 'COMIN' ) THEN
         IMETH = 34

      ELSE IF( STATUS .EQ. SAI__OK ) THEN
         STATUS = SAI__ERROR
         CALL MSG_SETC( 'M', METH )
         CALL ERR_REP( 'KPS1_CLPS<T>_ERR1', 'KPS1_CLPS<T>: '//
     :                 'Unsupported combination method ''^M'' '//
     :                 'requested (programming error).', STATUS )    
         GO TO 999
      END IF

*  Decide whether indices, co-ordinates, and widths array is used.
      USEIND = IMETH .GE. 31 .AND. IMETH .LE. 34
      USECO = IMETH .EQ. 22 .OR. IMETH .EQ. 23 .OR. IMETH .EQ. 33 .OR.
     :        IMETH .EQ. 34
      USEWID = IMETH .EQ. 21
     
*  Find the size of each dimension in the output array. Also initialize 
*  the pixel indices of the current output pixel to be the first pixel.
      DO IAX2 = 1, NDIM2
         DIM2( IAX2 ) = UBND2( IAX2 ) - LBND2( IAX2 ) + 1
         POS2( IAX2 ) = LBND2( IAX2 )
      END DO

*  Find the dimensions of the input array.
      DO IAX1 = 1, NDIM1
         DIM1( IAX1 ) = UBND1( IAX1 ) - LBND1( IAX1 ) + 1
      END DO

*  Note the step between adjacent pixels along the collapse axis.
      STEP1 = 1
      DO IAX1 = 1, AXIS - 1
         STEP1 = STEP1 * DIM1( IAX1 )
      END DO

*  If we are collapsing along the last axis, we do not need to
*  re-arrange the input data and variance values since the CCDPACK
*  combination routines used at the end of this routine can access them
*  in "natural" order.
      USEWRK = ( AXIS .NE. NDIM1 ) 
      START = 1
      IF( .NOT. USEWRK ) THEN

*  Note the index of the first element of the first plane to be included
*  in the output array.
         START = ( LO - LBND1( AXIS ) ) * STEP1 + 1

*  If we are not collapsing along the last axis, we need to re-arrange
*  the input data and variance values. 
      ELSE 

*  Step through every pixel in the output arrays.
         DO IEL2 = 1, NEL2      

*  Find the pixel indices of the first input pixel to contribute to
*  the current output pixel.
            DO IAX1 = 1, NDIM1
               IF( IAX1 .LT. AXIS ) THEN 
                  POS1( IAX1 ) = POS2( IAX1 )
               ELSE IF( IAX1 .EQ. AXIS ) THEN
                  POS1( IAX1 ) = LO
               ELSE
                  POS1( IAX1 ) = POS2( IAX1 - 1 )
               END IF
            END DO

*  Find the corresponding vector index into the input arrays at this
*  position.
            IEL1 = 0
            DO IAX1 = NDIM1 - 1, 1, -1
               IEL1 = ( POS1( IAX1 + 1 ) - LBND1( IAX1 + 1 ) + IEL1 ) *
     :                DIM1( IAX1 )
            END DO
            IEL1 = IEL1 + POS1( 1 ) - LBND1( 1 ) + 1

*  Loop through the pixels to be collapsed in this "column".
            K = 0
            DO J = LO, HI
               K = K + 1

*  Store this pixel value in a work array.  Likewise for variance and
*  co-ordinates or widths.
               WORK1( IEL2, K ) = DIN( IEL1 )
               IF ( VAR ) WORK2( IEL2, K ) = VIN( IEL1 )
               IF ( USECO ) WORK3( IEL2, K ) = CIN( IEL1 )
               IF ( USEWID ) WORK3( IEL2, K ) = WIN( IEL1 )

*  Move on to the next input pixel.
               IEL1 = IEL1 + STEP1

            END DO

*  Update the pixel indices of the current output pixel.
            CARRY = .TRUE.
            IAX2 = 1
            DO WHILE( CARRY )
               POS2( IAX2 ) = POS2( IAX2 ) + 1
               IF( POS2( IAX2 ) .LE. UBND2( IAX2 ) ) THEN
                  CARRY = .FALSE.
               ELSE
                  POS2( IAX2 ) = LBND2( IAX2 )
                  IAX2 = IAX2 + 1
                  IF( IAX2 .GT. NDIM2 ) CARRY = .FALSE.
               END IF
            END DO            
   
         END DO

      END IF

*  Now we have the input data in the order needed by the CCDPACK
*  combination routines. Combine the values together into the output 
*  data and variances. The CCDPACK combination routines used below 
*  expect the data to be supplied as a series of lines in a 2D array. 
*  Each line comprises one "image" and each column gives the pixels to 
*  be combined. The result is a single line of data. Allocate the
*  required work arrays...
      NLIN = HI - LO + 1
      NMAT = NLIN * ( NLIN + 1 ) / 2

      CALL PSX_CALLOC( NLIN, '<HTYPE>', IPWRK1, STATUS )
      CALL PSX_CALLOC( NLIN, '<HTYPE>', IPWRK2, STATUS )
      CALL PSX_CALLOC( NLIN, '_DOUBLE', IPNCON, STATUS )
      CALL PSX_CALLOC( NLIN, '_INTEGER', IPPNT, STATUS )
      CALL PSX_CALLOC( NLIN, '_LOGICAL', IPUSED, STATUS )

*  Get workspace if co-ordinates are to be derived, otherwise
*  use a valid pointer.
      IF ( USEIND ) THEN
         CALL PSX_CALLOC( NEL2, '_INTEGER', IPCOIN, STATUS )
      ELSE
         IPCOIN = IPPNT
      END IF

*  There's no need to allocate allocate memory for the pixel indices
*  of the maximum or minimum values, or the intensity-weight 
*  co-ordinate or dispersion, as we can use the IPPNT array.

*  First deal with cases where input variances are available.
*  Output variances are generated based on these input variances.
      IF ( VAR ) THEN

*  If we are using a median estimator, and we are producing output
*  variances, and the input image is big, we will estimate the variance
*  on the median rather than calculating it properly. This is because
*  the memory requirements for the covariance array becomes huge for 
*  large images.  "Median with estimated variances" is treated as a new
*  IMETH value, 300.
         IF ( IMETH .EQ. 3 .AND. NLIN .GT. 300 ) IMETH = 300

*  Allocate memory.
         CALL PSX_CALLOC( NLIN, '_DOUBLE', IPPP, STATUS )
         NMAT = NLIN * ( NLIN + 1 ) / 2 
         IF( IMETH .NE. 1 .AND. IMETH .NE. 2 .AND. IMETH .NE. 300 ) THEN
            CALL PSX_CALLOC( NLIN * NMAT, '_DOUBLE', IPCOV, STATUS )
         ELSE
            IPCOV = IPPP
         END IF

*  If the axis along which the input array was collapsed was not the
*  last axis, we need to use the re-ordered data in the work arrays.
         IF ( USEWRK ) THEN
            CALL CCG1_CM1<T><T>( WORK1, NEL2, NLIN, WORK2, CIN, WIN, 
     :                           IMETH, 
     :                           MAX( 1, NINT( WLIM * REAL( NLIN ) ) ),
     :                           7, 4.0, 0.0, 0.0, 0.0, DOUT, VOUT, 
     :                           %VAL( CNF_PVAL( IPCOIN ) ), 
     :                           %VAL( CNF_PVAL( IPWRK1 ) ), 
     :                           %VAL( CNF_PVAL( IPWRK2 ) ),
     :                           %VAL( CNF_PVAL( IPPP ) ), 
     :                           %VAL( CNF_PVAL( IPCOV ) ), NMAT,
     :                           %VAL( CNF_PVAL( IPNCON ) ), 
     :                           %VAL( CNF_PVAL( IPPNT ) ),
     :                           %VAL( CNF_PVAL( IPUSED ) ), STATUS )

*  If the collapse axis is the last axis, we can use the original input
         ELSE 
            CALL CCG1_CM1<T><T>( DIN( START ), NEL2, NLIN, VIN( START ),
     :                           CIN, WIN, IMETH, 
     :                           MAX( 1, NINT( WLIM * REAL( NLIN ) ) ),
     :                           7, 4.0, 0.0, 0.0, 0.0, DOUT, VOUT,
     :                           %VAL( CNF_PVAL( IPCOIN ) ), 
     :                           %VAL( CNF_PVAL( IPWRK1 ) ), 
     :                           %VAL( CNF_PVAL( IPWRK2 ) ),
     :                           %VAL( CNF_PVAL( IPPP ) ), 
     :                           %VAL( CNF_PVAL( IPCOV ) ), NMAT,
     :                           %VAL( CNF_PVAL( IPNCON ) ), 
     :                           %VAL( CNF_PVAL( IPPNT ) ),
     :                           %VAL( CNF_PVAL( IPUSED ) ), STATUS )
         END IF

         CALL PSX_FREE( IPPP, STATUS )
         IF ( IMETH .NE. 1 .AND. IMETH .NE. 2 .AND. IMETH .NE. 300 ) 
     :     CALL PSX_FREE( IPCOV, STATUS )

*  Now deal with cases where input variances are not available.  No
*  output variances will be created.
      ELSE
         CALL PSX_CALLOC( NLIN, '_DOUBLE', IPVAR, STATUS )
         CALL KPG1_FILLD( 1.0D0, NLIN, %VAL( CNF_PVAL( IPVAR ) ), 
     :                    STATUS )

*  If the axis along which the input array was collapsed was not the
*  last axis, we need to use the re-ordered data in the work arrays.
         IF ( USEWRK ) THEN   
            CALL CCG1_CM3<T><T>( WORK1, NEL2, NLIN, 
     :                           %VAL( CNF_PVAL( IPVAR ) ), CIN, WIN,
     :                           IMETH,
     :                           MAX( 1, NINT( WLIM * REAL( NLIN ) ) ),
     :                           7, 4.0, 0.0, 0.0, 0.0,
     :                           DOUT, %VAL( CNF_PVAL( IPCOIN ) ), 
     :                           %VAL( CNF_PVAL( IPWRK1 ) ),
     :                           %VAL( CNF_PVAL( IPWRK2 ) ),
     :                           %VAL( CNF_PVAL( IPNCON ) ), 
     :                           %VAL( CNF_PVAL( IPPNT ) ),
     :                           %VAL( CNF_PVAL( IPUSED ) ), STATUS )

*  If the collapse axis is the last axis, we can use the original input
*  data.
         ELSE 
            CALL CCG1_CM3<T><T>( DIN( START ), NEL2, NLIN, 
     :                           %VAL( CNF_PVAL( IPVAR ) ), CIN, WIN,
     :                           IMETH, 
     :                           MAX( 1, NINT( WLIM * REAL( NLIN ) ) ),
     :                           7, 4.0, 0.0, 0.0, 0.0,
     :                           DOUT, %VAL( CNF_PVAL( IPCOIN ) ), 
     :                           %VAL( CNF_PVAL( IPWRK1 ) ),
     :                           %VAL( CNF_PVAL( IPWRK2 ) ),
     :                           %VAL( CNF_PVAL( IPNCON ) ), 
     :                           %VAL( CNF_PVAL( IPPNT ) ),
     :                           %VAL( CNF_PVAL( IPUSED ) ), STATUS )
         END IF

         CALL PSX_FREE( IPVAR, STATUS )

      END IF

*  Free the remaining work space.
      CALL PSX_FREE( IPWRK1, STATUS )
      CALL PSX_FREE( IPWRK2, STATUS )
      CALL PSX_FREE( IPNCON, STATUS )
      CALL PSX_FREE( IPPNT, STATUS )
      CALL PSX_FREE( IPUSED, STATUS )

      IF ( USEIND ) THEN
         CALL PSX_FREE( IPCOIN, STATUS )
      END IF

 999  CONTINUE

      END
