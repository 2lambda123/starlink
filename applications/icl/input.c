/******************************************************************************
 *
 *	I N P U T . C
 *
 * This module implements both the input handling before the lexical analyser
 * (lex) see it AND all other input from files and stdin.
 *
 * LEX input
 * 	Since input may come from a number of sources (terminals, files,
 *	strings) we hide all this behind an input stack.
 *	We can also auto-sense VMS files and perform the appropriate conversion
 *
 *	History
 *	Created :	S.K.Robinson	21/11/91
 *	Edited :	I.R.Jenkins	03/06/92, prototyped, restructured
 *			B.K.McIlwrath	1993 and all subsequent edits
 *
 ******************************************************************************
 */
#include <stdio.h>
#include <signal.h>
#include <setjmp.h>
#include <termios.h>
#include <unistd.h>
#include "icl.h"
#include "input.h"
#include "output.h"
#include "uface_functions.h"
#include "icl_io.h"
#include "sae_par.h"
#include "messys_err.h"

int yyparse();

extern node *node_value(value v);				/* node.c   */
extern value sys_exception (char * mess);			/* procs.c  */
extern value sys_exception2
		(char *format, char *arg1, char *arg2);		/* procs.c  */
extern value store_symbol (char *name, int type, node *n);	/* symtab.c */

/******************************************************************************
 *
 * This file contains the code to processs input before the lexical analyser
 * generated by LEX and the parser generated by YACC see it.
 *
 * During a run of ICL it is possible we may wish to process an input file
 * and then return to processing the input from the terminal, or we may wish
 * to process a string during the processing of a file during the processing
 * of the input from the terminal.  To support this we provide a stack of
 * input sources, initially empty and pushed as the requirements for processing
 * alternate sources arises and popped as we complete the processing of an
 * input source.  To this end we stack, for each source, a status/control
 * flags integer set using the bits below
 *
 ******************************************************************************
 */
#define INPUT_FILE	0x1	/* input from a file    */
#define INPUT_STRING	0x2	/* input from a string  */
#define INPUT_VMS	0x100	/* VMS file, so read length terminated
				 * records */
#define INPUT_TTY	0x200	/* person - so prompt them */
#define INPUT_VIRGIN	0x400	/* we have not yet tested for VMS file type */

#define VMS_BUFSIZE	(256*256)

extern int always_vms;
/*
 * file descriptor of command pipe to iosubsystem
 */
extern int iocommand_fd;					/* main.c */

/******************************************************************************
 *
 * and we also stack the associated filename, C file descriptor (FILE *), a
 * pointer to the input sources associated buffer, a pointer to the current
 * position in that buffer and the length of that buffer.  The currently
 * "active" set of these is maintained in the set of variables below
 *
 ******************************************************************************
 */
static int in_flags;		/* contain the INPUT_ flag setting */
static char *in_name;		/* stream name USED?               */
static FILE *in_fp;		/* equivalent C filedescriptor     */
static char *in_buffer, *in_bufp;	/* input buffer pointers, in_buffer
					 * points to the start of an
					 * allocated buffer, in_bufp to the
					 * next available character in the
					 * buffer */
static int in_length;		/* maintained to hold the number of
				 * characters available in the buffer pointed
				 * to by in_buffer  */
static int in_maxlength;	/* the maximum current buffer length */

/******************************************************************************
 *
 * The stack used is defined below
 *
 ******************************************************************************
 */
static int in_stack_height = 0;
static struct {
    int flags;
    char *name;			/* file name - not used much yet */
    FILE *fp;
    char *buffer, *bufp;
    int length;
    int maxlength;
}   in_stack[ICL_BUFSIZE];

/******************************************************************************
 *
 *	S T A C K _ T H I S _ I N P U T (void)
 *
 * Saves the current input context.
 *
 * Returns 1 if OK, 0 if stack full
 *
 ******************************************************************************
 */
static int
stack_this_input(void)
{
    if (in_stack_height == ICL_BUFSIZE)
	return 0;
    in_stack[in_stack_height].flags = in_flags;
    in_stack[in_stack_height].name = in_name;
    in_stack[in_stack_height].fp = in_fp;
    in_stack[in_stack_height].buffer = in_buffer;
    in_stack[in_stack_height].bufp = in_bufp;
    in_stack[in_stack_height].length = in_length;
    in_stack[in_stack_height].maxlength = in_maxlength;
    in_stack_height++;
    return 1;
}

/******************************************************************************
 *
 *	S T A C K _ F I L E _ I N P U T (FILE *fp, char *name)
 *
 * Stack the current input stream and reset it to be a file pointed to
 * by the C filedescriptor 'fp' of name "name".
 *
 * Returns 1 if OK, zero if input stack full or malloc fails to allocate a
 * buffer
 *
 ******************************************************************************
 */
static int
stack_file_input(FILE *fp, char *name)
{
    if (!stack_this_input() ||
       (in_buffer = in_bufp = (char *) malloc(VMS_BUFSIZE)) == CHARNIL )
	return 0;
    in_flags = INPUT_FILE | INPUT_VIRGIN;
    if (sense_vms(fp))
	in_flags |= INPUT_VMS;
    in_name = name;
    in_maxlength = VMS_BUFSIZE;
    in_fp = fp;
    return 1;
}

/******************************************************************************
 *
 *	S T A C K _ S T R I N G _ I N P U T (char *s, int length)
 *
 * Stack the current input stream and set it to be input from the string s,
 * of length "length".
 *
 * Returns 1 of OK, zero if input stack overflow
 *
 ******************************************************************************
 */
int
stack_string_input(char *s, int length)
{
    if (!stack_this_input())
	return 0;
    in_flags = INPUT_STRING;
    in_name = "STRING";
    in_buffer = in_bufp = s;
    in_length = length;
    in_maxlength = length;
    in_fp = (FILE *) 0;
    return 1;
}

/******************************************************************************
 *
 *	U N S T A C K _ I N P U T (void)
 *
 * Return to earlier input source by popping input stack
 *
 ******************************************************************************
 */
void
unstack_input(void)
{
    if (in_stack_height == 0) {
	systemfail("Unstack_input: input stack empty!\n");
	return;	/* for lint */
    }
    --in_stack_height;
    if (in_flags & INPUT_FILE)
	free(in_buffer);
    in_flags = in_stack[in_stack_height].flags;
    in_name = in_stack[in_stack_height].name;
    in_fp = in_stack[in_stack_height].fp;
    in_buffer = in_stack[in_stack_height].buffer;
    in_length = in_stack[in_stack_height].length;
    in_maxlength = in_stack[in_stack_height].maxlength;
    return;
}

/******************************************************************************
 *
 * When input is from the interactive terminal, input is prompted.  This is
 * normally ICL> but during, for example, a loop it becomes LOOP> returning
 * to ICL> after endloop.  Because we can be in a loop in a procedure in
 * interactive mode etc. we need a stack of prompts so that we can keep
 * track of the correct prompt for the current input context.
 *
 * This is done using the following variables implementing the push-down
 * stack of prompts for use during procedure and control statement entry.
 * nprompt is the top-of-stack pointer into prompts[] and prompt is
 * maintained to be the current prompt.
 *
 ******************************************************************************
 */
static int nprompt = 0;			/* depth of prompt stack */
static char *prompts[ICL_BUFSIZE];	/* The stack itself      */
char *prompt;				/* The current prompt. This is NOT
					 * static as SET prompt (in procs.c)
					 *  needs to set it */

/******************************************************************************
 *
 *	S T A C K _ P R O M P T (char *newprompt)
 *
 * This pushes the current prompt onto the stack and sets the current prompt
 * to be 'newprompt'
 *
 ******************************************************************************
 */
int
stack_prompt(char *newprompt)
{
    if (nprompt >= ICL_BUFSIZE)
	return 0;
    prompts[nprompt++] = prompt;
    prompt = newprompt;
    return 1;
}

/******************************************************************************
 *
 *	U N S T A C K _ P R O M P T (void)
 *
 * Restore the top of prompt stack as the current prompt by popping 'prompts[]'
 *
 ******************************************************************************
 */
int
unstack_prompt(void)
{
    if (nprompt <= 0)
	return 0;
    prompt = prompts[--nprompt];
    return 1;
}

/******************************************************************************
 *
 *	C L E A R _ P R O M P T S T A C K (void)
 *
 * Clear the current prompt stack.  This is used on completion of a call to
 * yyparse() to ensure that any incomplete parsing (due to a parse error
 * in, say, a loop) does not leave us in the wrong context.
 *
 ******************************************************************************
 */
void
clear_promptstack(void)
{
    while (nprompt)
	unstack_prompt();
    return;
}

/******************************************************************************
 *
 *	I N I T _ I N P U T (void)
 *
 * Initialise the input system.
 *
 * We assume input from an input stream named stdin (Unix standard) and by
 * using isatty(fileno(stdin)) we check whether stdin is attached to a
 * interactive device or has been re-routed to a file.
 *
 ******************************************************************************
 */
value
init_input(void)
{
    if ((in_buffer = (char *) malloc(VMS_BUFSIZE)) == CHARNIL)
	return exception("SYSERR : Failure to initialise input");
    if (isatty(fileno(stdin)))
	in_flags = INPUT_TTY;
    else
	return exception("SYSERR - ICL requires stdin to be a tty");
    in_length = 0;
    in_maxlength = 0;
    in_name = "STDIN";
    prompt = ICLDEFAULTPROMPT;
    in_fp = stdin;
    return (store_symbol("STDIN", SYM_FILE,
			  node_value(value_file((PORTPTR) stdin))));
}

/******************************************************************************
 *
 *	I N T E R A C T I V E (void)
 *
 * By testing the INPUT_TTY bit in the current in_flags we discern if we are
 * interacting with a terminal.
 *
 ******************************************************************************
 */
int
interactive(void)
{
    return (in_flags & INPUT_TTY);
}

/******************************************************************************
 *
 *	T E R M I N A L _ O U T P U T (void)
 *
 * By testing the INPUT_TTY bit in the base level in_flags we discern if we are
 * interacting with a terminal.
 *
 ******************************************************************************
 */
int
terminal_output(void)
{
    int flags;

    if( in_stack_height != 0)
	flags = in_stack[0].flags;
    else
	flags = in_flags;

    return (flags & INPUT_TTY);
}

/******************************************************************************
 *
 *	S E N S E _ V M S (FILE *fp)
 *
 * VMS variable length records consist of a two-byte length count with the
 * lower byte first (of course - this is VAX after all), followed by length
 * bytes of line. If the length is odd, it is padded to an even boundary.
 *
 * For most files, the second byte of the length count will be very small,
 * probably zero and very likely less than 8, which is the lowest ASCII value
 * you should expect to find in a text file. This means that we can recognise
 * VMS files when the first line is less than 4096 characters long.
 * This is probably reasonable.
 *
 * fseek(FILE *fp, 0,0) positions input at the first byte within a file
 *
 ******************************************************************************
 */
int
sense_vms(FILE *fp)
{
    int res = 1, length, length2;

    length = getc(fp);
    if (length == EOF)
	return 0;
    length2 = getc(fp);
    if (length2 == EOF || length2 >= 7)
	res = always_vms;
    fseek(fp, 0L, 0);
    return res;
}

/******************************************************************************
 *
 *	G E T _ V M S _ L I N E (int size, FILE *fp)
 *
 * Read a line from a VMS file whose C filepointer is 'fp' into the current
 * system input buffer in_buffer length "size".
 *
 * Returns number of characters read if read successful, zero on EOF or
 * a failed read.
 * If the next line in the file is shorter than 'size', the line is newline
 * terminated and the whole line is always null terminated.
 *
 * fread(char *buff,int n,int length,FILE *fp) reads, into the buffer 'buff',
 * up to 'length' elements whose size is 'n' bytes, from the stream 'fp'.
 * The file position indicator for the stream (if defined) is advanced by the
 * number of characters read. If an error occurs, this indicator value on
 * return is undefined.
 * Returns the number of elements actually read which may be less than length
 * if an error or EOF was found.
 *
 * getc(FILE *fp) returns the next character in the input stream fp.  If EOF
 * found the EOF flag of fp is set and EOF is returned.  If an error occurs
 * the error indicator flag is set and getc() returns EOF.
 *
 ******************************************************************************
 */
static value
get_vms_line(FILE *fp)
{
    int length, length1;

    length = getc(fp);
    if (length == EOF)
	return exception("SYSERR : EOF during input from vms file");
    length1 = getc(fp);
    if (length1 == EOF)
	return exception("SYSERR : EOF during input from vms file");
    length += length1 << 8;
    if (length + 2 >= in_maxlength) {	/* allowing for newline and null
					 * terminators */
    /* physical record larger than allocated buffer in_buffer */
	if (in_buffer != CHARNIL)
	    free(in_buffer);
	if ((in_buffer = in_bufp = (char *) malloc(length + 2)) == CHARNIL)
	    return exception("SYSERR : ICL has exhausted its memory");
	in_maxlength = length + 2;
    }
    if (fread(in_buffer, 1, length, fp) != length)
	return exception("SYSERR : Error during read of VMS file");
    if (length & 0x1)		/* was physical record an 'odd' length */
	(void) fgetc(fp);	/* if so skip filler to even length    */
    in_buffer[length++] = '\n';
    in_buffer[length] = '\0';
    return trueval;
}

/******************************************************************************
 *
 * Although interrupt handling is usually done by polling, if we do this
 * during input, an interrupt has no effect until NEWLINE is pressed. We thus
 * trap interrupts using a longjmp in this situation.
 *
 * The header <setjmp.h> defines the macro setjmp and declares one function
 * and one type, for bypassing the normal function call and return discipline.
 * The type declared is jmp_buf which is an array type suitable for holding
 * the information required to restore a calling environment.
 *
 * int setjmp(jmp_buf env) saves its calling environment in "env" for later
 * use by longjmp().  Returns zero on a direct invocation, or if via
 * longjmp() a non zero value.
 *
 * void longjmp(jmp_buf env, int val) restores the environment to that saved in
 * the most recent invocation of setjmp() with "env" as its argument.
 * This in effect returns from that corresponding setjmp() with the value
 * "val".  All accessible (from the setjmp() position) retain their values
 * at the longjmp() call.  An exception to this is local autos (non volatile)
 * to the function containing the setjmp() that have changed value since
 * the call to setjmp().  These become indeterminate.
 * longjmp() WILL NOT accept a value "val" of zero!
 *
 ******************************************************************************
 */

/******************************************************************************
 *
 *	I C L _ I N P U T (void)
 *
 * This is the get_next_input_character input routine for lex.
 *
 * 'in_length' contains a count of the number of characters available in the
 * input buffer.  If non-zero at this point then we can decrement this count
 * and return the next buffered character by using in_bufp which is maintained
 * to point to the next input character in the input_buffer
 * If the buffer is empty then
 *  (1) input was from a string (in_flags has INPUT_STRING bit set)
 *      in which case the string is exhausted and we return 0 (ie null)
 *  (2) input is from an interactive terminal (ie in_flags has INPUT_TTY
 *      bit set).
 *      In the understanding that the iosubsystem will handle interupts we use
 *	outstring() to issue the prompt "prompt" (a global variable maintained
 *      to be the relevant prompt).  We then continue at (4)
 *  (3) input is from a virginal file (ie we havent read from it yet)
 *      In this case we test if it is a VMS file using sense_vms()
 *      and if it is we set the INPUT_VMS bit in the current input stream flags.
 *  (4) We clear the INPUT_VIRGIN flags bit.
 *      We now read input.  If from a VMS file we use GET_VMS_LINE()
 *      otherwise we use icl_fgets().  If fgets() fails we set the input
 *      buffer empty.
 *  (5) We then check if the last character in the input was a ~ in which
 *	case we shorten the line to ignore it and its newline.  This will
 *	cause another line to be read by the parser that is newline terminated.
 *      Finally  if the input buffer is still empty we return zero (ie null)
 *	otherwise we reduce the length count and using in_bufp return the
 *	first character in the buffer.
 *
 ******************************************************************************
 */
int
icl_input(void)
{
    value val;

    if (in_length == 0) {	/* Need some more input */
	in_bufp = in_buffer;
	if (in_flags & INPUT_STRING)
	    return 0;
	if (interactive()) {
	/* Input source is stdin */
	/*
	 * here we must wait for the reply from the io system to our request
	 * for an input line AND handle any adam task messages
	 *
	 */
	    do {
		val = icl_gets( 1, "ICL Command input", in_buffer,
				VMS_BUFSIZE - 1, prompt, CHARNIL);
	    } while (cntlcexp(val));	/* Ignore CNTLC exceptions */
            if (isexc(val)) {	/* real exception */
		in_length = 0;
		*in_buffer = '\0';
		bufstring(string_part(val));
		bufnewline();
		flshbuf();
	    } else
		in_length = strlen(in_buffer);
	} else {
	/* Input is from some file */
	    if (in_flags & INPUT_VIRGIN) {
		if (sense_vms(in_fp))
		    in_flags |= INPUT_VMS;
		in_flags &= ~INPUT_VIRGIN;
	    }
	    if (in_flags & INPUT_VMS)
		if (isexc(val = get_vms_line(in_fp))) {
		    in_length = 0;
		    *in_buffer = '\0';
		} else
		    in_length = strlen(in_buffer);
	    else if (isexc(val = icl_fgets(in_name, in_buffer, VMS_BUFSIZE - 1,
			   value_file((PORTPTR) in_fp)))) {
		in_length = 0;
		*in_buffer = '\0';
	    } else
		in_length = strlen(in_buffer);
	}

	if (in_length == 0)
	    return 0;
	else
/*
 * if last character was a ~, delete it and the newline from the
 * buffer so that another line gets read. Clearly this puts no limit
 * on the allowable number of ~'s.
 */
	    if (in_length >= 2 && in_buffer[in_length - 2] == '~')
		in_length -= 2;
    }
    in_length--;
    return *in_bufp++;
}

/******************************************************************************
 *
 *	I C L _ U N P U T (int c)
 *
 * Put a character back in the buffer.
 *
 * Lex is well-behaved about this except for EOF characters.
 *
 ******************************************************************************
 */
void
icl_unput(int c)
{
    if (c <= 0)
	return;
    *--in_bufp = c;
    ++in_length;
    return;
}

/******************************************************************************
 *
 *	I C L _ G E T S ( whofor, buffer, buffersize, prompt )
 *
 * Inputs a string from stdin (which has been testing in init_input and is
 * guaranteed to be the tty) for the ICL routine "whofor', into 'buffer'
 * (maximum size buffersize) using 'prompt' as the input prompt
 *
 ******************************************************************************
 */
static struct iocommand message;
static int inputcommandnumber = 1;

value
icl_gets
(
int interuptable,	/* Boolean controlling input interruption (input) */
char *whofor,		/* Calling routine/operation  (input) */
char *buffer,		/* buffer used to hold return value task (both) */
int buffersize,		/* size of buffen (input) */
char *prompt,		/* prompt to be used for input (input) */
char *dflt		/* default value for input (input) */
)
{
    int istat;

    if (interuptable)
	message.fcode = IO_COMMAND_GETINTINPUT;
    else
	message.fcode = IO_COMMAND_GETINPUT;

    message.iarg = inputcommandnumber++;	/* Input sequence number */

    if (prompt != CHARNIL)
	strcpy(message.buff, prompt);
    else
	strcpy(message.buff, "??");
    message.buflen = strlen(message.buff) + 1;
    if (dflt != CHARNIL) {
	message.dindex = message.buflen;
	message.buflen += strlen(dflt) +1;
	strcpy(&message.buff[message.dindex], dflt);
    } else
	message.dindex = 0;

 /* Send command to io subsystem */
    write(iocommand_fd, &message, iocommandlength(message));

    istat = SAI__OK;
    uface_getcom((char *) &message, &istat);

    if (istat == MESSYS__EXTINT)
	return exception("CNTLC - Interrupt");
    else if (istat != SAI__OK)
	return exception2("%s during %s", "READERR", whofor);
    else
	strcpy(buffer, message.buff);
   return trueval;
}

/******************************************************************************
 *
 *	C L E A R U P A F T E R I N P U T (char *whofor)
 *
 * This function clears up after INPUT commands
 *
 ******************************************************************************
 */
value
clearupafterinput(char *whofor)
{
/*
 * if (ferror (stdin) || feof(stdin)) clearerr (stdin);
 */
    return trueval;
}

/******************************************************************************
 *
 *	I C L _ F G E T S ( filename, buffer, buffersize, iclvalue vfp )
 *
 * Reads a string from the file 'filename' whose internal icl value is vfp.
 * Reads at most 'buffersize' chars into 'buffer'
 *
 * Used to implement the READ command from proc_read() in fileio.c
 *
 * fgets(char *buf, int length, FILE *fp)
 *   reads at most one less than the "length" characters from the stream fp
 *   into the buffer buf.  No additional charcters are read after a newline
 *   character (retained) or after EOF.  The input is null terminated by
 *   fgets().  returns buf is successful, nil if EOF encountered immediately
 *   OR if an error occurs with the associated setting of fp's corresponding
 *   flags bits.
 *
 ******************************************************************************
 */
value
icl_fgets(char *filename, char *buffer, int buffersize, value vfp)
{
    FILE *fp;
    extern int trace;

    fp = (FILE *) file_part(vfp);
    if ((fgets(buffer, buffersize, fp)) == CHARNIL)
	return exception2("%s during READ on file %s", (ferror(fp) ? "READERR"
			   : "EOF"), filename);
    else {
	if (trace) {
	    bufstring(buffer);
	    flshbuf();
	}
	return trueval;
    }
}

/******************************************************************************
 *
 *	C L E A R U P A F T E R R E A D (value file, char *whofor,
 *					 char *filename)
 *
 * Clear up after read operations.
 *
 ******************************************************************************
 */
value
clearupafterread(value file, char *whofor, char *filename)
{
    FILE *fp;
    static char buf[512];

    fp = (FILE *) file_part(file);
    if (ferror(fp) || feof(fp)) {
	sprintf(buf, "%s  during %s on file %s", (ferror(fp) ?
					"READERR" : "EOF"), whofor, filename);
	return exception(buf);
    } else
	return trueval;
}

/******************************************************************************
 *
 *	I C L O P E N F I L E (char *whofor, char *filename, char *mode)
 *
 * This routine is called in all cases of opening a file for the user with
 * create, open and append.
 *
 * We have translated the command to an open mode in mode, "w" for create,
 * 'r" for open, "a" for append" and 'whofor' represents the command directly.
 *
 * FILE * fopen(char * filename, char * mode)
 *      opens the file filename with the mode "mode" and returns the
 *	filedescriptor if successful, nil otherwise.
 *      Relevant modes are:
 *      "r", open text file for reading
 *      "w" create text file for writing (or zero an existing file)
 *      "a" open or create text file for writing
 *
 * returns with an icl file 'value' or an exception if the open fails
 *
 ******************************************************************************
 */
value
iclopenfile(char *whofor, char *filename, char *mode)
{
    char buf[ICL_BUFSIZE];
    FILE *fp;

    if (strcmp(mode, "w") == 0) {
	if ((fp = fopen(filename, "r")) != ((FILE *) 0)) {
	    (void) fclose(fp);
	    return exception2(
			"OPENERR  error %sing file \"%s\" already exists",
			whofor, filename);
	}
    }
    if (!(fp = fopen(filename, mode))) {
	sprintf(buf, "OPENERR  error %sing file \"%s\"", whofor, filename);
	return (sys_exception(buf));
    }
    return (value_file((PORTPTR) fp));
}

/******************************************************************************
 *
 *	D O _ L O A D (char *command_name, char *name)
 *
 * A helper function for the various commands which LOAD files.
 *
 * It opens the file "name" in read mode and then pushes the input source
 * stack with the resulting file pointer. It then uses yyparse() to process
 * the file line by line and if yyparse() delivers an executable entity
 * (todo is set) it interprets it It continues to do this until an exception
 * occurs (either in parsing or in interpreting) or the file exhuasts, when
 * it closes the file, pops the input stack and returns.
 *
 * Will return an exception if it fails.
 *
 ******************************************************************************
 */
value
do_load(char *command_name, char *name)
{
    extern value interpret(node *n);			        /* interp.c */
    extern node *todo;						/* interp.c */
    FILE *fp;
    extern int sigint_flag;	   /* flag - set by cntlc_handler in main.c */

    if ((fp = fopen(name, "r")) == ((FILE *) 0))
	return sys_exception2( "OPENERR  %s: cannot open file \"%s\"",
				command_name, name);
    if (stack_file_input(fp, name) == 0)
	return exception("SYSERR  memory exhausted in loading file");
    todo = NODENIL;
    while (yyparse() != 0) {
	value val;

	if (!todo)
	    continue;
	if (isexc(val = interpret(todo)) || sigint_flag) {
	    todo = NODENIL;
	    fclose(fp);
	    unstack_input();
	    return val;
	}
	todo = NODENIL;
    }
    unstack_input();
    if (fclose(fp))
	return sys_exception2("CLOSEERR  %s: cannot close file \"%s\"",
			       command_name, name);
    return trueval;
}

/******************************************************************************
 *
 *	C O M P O S E _ S Y N T A X E R R (char *mess)
 *
 * This is mostly used by the parser to handle syntax errors.
 *
 * Given an error message in 'mess', the routine constructs the string
 *              SYNTAXERR  message\n
 *              ICL>Current contents of input line\n  ( from in_buffer)
 *
 * It then returns an exception whose message is is this string augmented with
 * an indication of the error position in the input line. This means that when
 * the exception is printed a ^ is printed near the location of the error.
 *
 * We assume the error is caused by the current token which is held in
 * yytext. We print the error position indicator by printing spaces up to the
 * point of the error and then print a ^. We do this using in_bufp (current
 * position in buffer), in_buffer ( start of current input buffer) and yytext
 * (current token from LEX).
 *
 * The number of spaces to be printed is
 *
 * strlen(prompt) + current position in buffer - start position in buffer -
 * length of current token (if any)
 *
 ******************************************************************************
 */
node *
compose_syntaxerr(char *mess)
{
    char buf[ICL_BUFSIZE], *p;
    extern char yytext[];
    int i;
    int plen = strlen(prompt);

    sprintf(buf, "SYNTAXERR  %s\n%s%s", mess, prompt, in_buffer);
    p = &buf[strlen(buf)];
    for (i = plen + in_bufp - in_buffer - (yytext ? strlen(yytext) : 0);
	 	i; i--)
	*p++ = ' ';
    *p++ = '^';
    *p++ = '\0';
    return node_value(exception(buf));
}
