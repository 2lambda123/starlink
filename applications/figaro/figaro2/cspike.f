C+
      SUBROUTINE CSPIKE
C
C     C S P I K E
C
C     Generates a calibration 'spiketrum', given an observation of
C     a standard star and a spiketrum giving the tabulated flux
C     values for that star.  The calibration spiketrum has points
C     giving the instrumental response calculated at the points
C     given by the spikes in the flux spiketrum.  A calibration
C     spectrum can then be generated by interpolating between the
C     points of the calibration spectrum.
C
C     Command Parameters
C
C     SPIKETRUM     (Character) The tabulated flux spiketrum.  Note:
C                   this should include the BANDWIDTH data
C                   object - a spiketrum that does not is probably
C                   not appropriate for this function.  Also note that
C                   CSPIKE does not work with data in magnitude units.
C     SPECTRUM      (Character) The observation of the standard star.
C                   Note that this should include an exposure time data
C                   object.  If it does not, a time of 1 sec will be
C                   assumed, and the calibration will only be relative.
C                   Both SPECTRUM and SPIKETRUM should contain an
C                   AXIS(1) data array, giving the wavelength values.
C                   These should normally be exactly the same, although
C                   this is not essential.
C     OUTPUT        (Character) The resulting spiketrum of calibration
C                   points.
C
C     Command keywords - None
C
C     User variables used - None
C
C                                      KS / CIT 28th May 1984
C     Modified:
C
C     23rd Jan 1985  KS / AAO.  Code added to test for TIME<=0.
C     14th Apr 1987  KS / AAO.  Now works properly in the case where
C                    the Output file is the same as the input Spiketrum.
C     16th Jan 1989  JM / RAL. Modified to use DSA_ routines
C                    Dynamic memory handling changed to use
C                    DYN_ routines
C     25th Sep 1992  HME / UoE, Starlink.  INCLUDE changed.
C                    Lowercase file name spiketrum (.def).
C     13th Mar 1996  HME / UoE, Starlink.  Adapt to the FDA library.
C                    No error messages from DTA. Call PAR_WRUSER instead
C                    of FIG_DTAERR.
C      7th Aug 1996  MJCL / Starlink, UCL.  Changed reference to
C                    non-existent HELP text to point to SUN/86.
C     28th Jun 1999  TDCA / Starlink, RAL. Initialised DIMS to zero.
C     17th May 2001  ACD / UoE, Starlink.  Revised obtaining the
C                    exposure time with DSA_GET_EXPOSURE.
C     2005 June 10   MJC / Starlink  Use CNF_PVAL for pointers to
C                    mapped data.
C+
      IMPLICIT NONE

      INCLUDE 'CNF_PAR'          ! For CNF_PVAL function
C
C     Functions
C
      LOGICAL FIG_WCHECK
C
C     Local variables
C
      REAL      BANDW            ! Bandwidth
      CHARACTER CITEMS(2)*32     ! Axis character items retrieved
      INTEGER   DIMS(2)          ! Dimensions
      REAL      DLAMB            ! Doubling wavelength
      CHARACTER DNAME*72         ! DTA name
      INTEGER   DSTAT            ! Status for DTA routines
      REAL      ENDS(4)          ! End values
      LOGICAL   FAULT            ! True if non-DSA fault occurs
      INTEGER   I                ! Loop variable
      INTEGER   NCITEMS          ! Number of axis character items
                                 ! retrieved
      INTEGER   NDIM             ! Number of dimensions
      INTEGER   NELM             ! Number of elements in image - ignored
      DOUBLE PRECISION NITEMS(1) ! Axis numeric items retrieved
      INTEGER   NNITEMS          ! Number of axis numeric items
                                 ! retrieved
      INTEGER   NTAB             ! Dimensions of TABLE_DATA structure
      INTEGER   NX               ! First dimension of spiketrum
      INTEGER   OUTPTR           ! Dynaelement element for output data
      INTEGER   PSTAT            ! Status for PAR routines
      INTEGER   SLOT             ! Slot number for mapped data - ignored
      INTEGER   SPEPTR           ! Dynamic-memory pointer for spectrum
                                 ! data
      INTEGER   SPEXPR           ! Dynamic-memory pointer for spectrum
                                 ! axis centres
      INTEGER   SPIPTR           ! Dynamic-memory pointer for spiketrum
                                 ! data
      INTEGER   SPIXPR           ! Dynamic-memory pointer for spiketrum
                                 ! axis data
      INTEGER   STATUS           ! Running status for DSA routines
      LOGICAL   TABLED           ! True if table structure is found
      REAL      TIME             ! Exposure time
      INTEGER   TXPTR            ! Dynamic-memory pointer for workspace
      INTEGER   TZPTR            ! Dynamic-memory pointer for workspace

C
C     Parameters controlling the way DSA_OUTPUT opens the spectrum file
C
      INTEGER   NEW_FILE, NO_DATA
      PARAMETER (NEW_FILE=1, NO_DATA=1)
C
C     Initial values
C
      STATUS=0
      FAULT=.FALSE.
      NCITEMS=2
      NNITEMS=1
      DIMS(1)=0
      DIMS(2)=0
C
C     Open DSA routines
C
      CALL DSA_OPEN(STATUS)
C
C     Get name of SPIKETRUM and open it
C
      CALL DSA_INPUT ('SPIKE','SPIKETRUM',STATUS)
C
C     Check for magnitude data and reject it.
C
      CALL DSA_GET_DATA_INFO('SPIKE',NCITEMS,CITEMS,NNITEMS,NITEMS,
     :                        STATUS)
      IF(STATUS.NE.0)GOTO 500
      IF(NITEMS(1).NE.0.0)THEN
         CALL DSA_WRUSER(
     :      'Cannot use a spiketrum whose data is in magnitudes '//
     :      'You must calibrate in Janskys or suchlike and then '//
     :      'convert using ABCONV.\N')
         FAULT=.TRUE.
         GOTO 500
      END IF
C
C     Get name of SPECTRUM and open it
C
      CALL DSA_INPUT('SPECT','SPECTRUM',STATUS)
      IF(STATUS.NE.0)GOTO 500
C
C     Check the dimensions match
C
      CALL DSA_MATCH_SIZES('SPIKE','SPECT',STATUS)
      IF(STATUS.NE.0)GOTO 500
C
C     Map the data objects
C
      CALL DSA_DATA_SIZE('SPIKE',1,NDIM,DIMS,NELM,STATUS)
      NX=DIMS(1)

      CALL DSA_MAP_DATA('SPIKE','READ','FLOAT',SPIPTR,SLOT,STATUS)

      CALL DSA_MAP_DATA('SPECT','READ','FLOAT',SPEPTR,SLOT,STATUS)
C
C     Map the AXIS(1) data arrays (the wavelengths).  First the
C     spectrum.
C
      CALL DSA_MAP_AXIS_DATA('SPECT',1,'READ','FLOAT',SPEXPR,SLOT,
     :                       STATUS)
C
C     then the spiketrum
C
      CALL DSA_MAP_AXIS_DATA('SPIKE',1,'READ','FLOAT',SPIXPR,SLOT,
     :                        STATUS)
      IF(STATUS.NE.0)GOTO 500
C
C     Check that the wavelength arrays match.  Strictly speaking,
C     they don't have to - this calculation doesn't require it - but
C     if they don't something is probably amiss and later steps will
C     foul up.
C
      IF (.NOT.FIG_WCHECK(NX,%VAL(CNF_PVAL(SPIXPR)),
     :                    %VAL(CNF_PVAL(SPEXPR)))) THEN
         CALL DSA_WRUSER(
     :     'Warning: Wavelength calibrations are not identical.\N')
      END IF
C
C     What we want to do with the Spiketrum data is generate two
C     tables of wavelength and data values.  (In fact, we're reproducing
C     the original tables used by GSPIKE!)  So we need a little work
C     space for these.  There may be a table of exact wavelength
C     values for the spiketrum (TABLE_DATA) or there may not, in
C     which case we have to get the values from the wavelength array.
C     So - look for any 'end' values. These are located with the aid of
C     the structure definition file SPIKETRUM.DEF. Failure to find these
C     end values in the input spiketrum file simply results in
C     default values being used.
C
      CALL DSA_READ_STRUCT_DEF('spiketrum',STATUS)

      CALL DSA_ELEMENT_NAME('SPIKE','TABLE_DATA',DNAME,STATUS)
      IF(STATUS.NE.0)GOTO 500

      CALL DTA_SZVAR(DNAME,10,NDIM,DIMS,DSTAT)
      TABLED=DSTAT.EQ.0
      IF (TABLED) THEN
         NTAB=DIMS(1)
      ELSE
         DO I=1,4
            ENDS(I)=0.
         END DO
         CALL FIG_NPSPIK(NX,%VAL(CNF_PVAL(SPIPTR)),ENDS,NTAB)
      END IF
      CALL DSA_GET_WORK_ARRAY(NTAB,'FLOAT',TXPTR,SLOT,STATUS)
      CALL DSA_GET_WORK_ARRAY(NTAB,'FLOAT',TZPTR,SLOT,STATUS)
      IF (TABLED) THEN
         CALL DTA_RDVARF(DNAME,NTAB,%VAL(CNF_PVAL(TXPTR)),DSTAT)
         IF (DSTAT.NE.0) THEN
            CALL PAR_WRUSER('Error reading spiketrum table data',DSTAT)
            FAULT=.TRUE.
            GO TO 500
         END IF
      END IF
C
C     Fill the  table data values, given the spiketrum AXIS(1) array,
C     the spiketrum data array, and the AXIS(1) table values if they
C     were available (otherwise, fill the AXIS(1) table values as well).
C
      CALL FIG_FSPTAB(NTAB,%VAL(CNF_PVAL(TXPTR)),TABLED,NX,
     :                %VAL(CNF_PVAL(SPIXPR)),%VAL(CNF_PVAL(SPIPTR)),
     :                %VAL(CNF_PVAL(TZPTR)))
C
C     Create the new output file.
C
      CALL PAR_SDCHAR('OUTPUT','SPIKE',PSTAT)
      CALL DSA_OUTPUT('OUTPUT','OUTPUT','SPIKE',0,0,STATUS)
C
C     Map the data array in the new file
C
      CALL DSA_MAP_DATA('OUTPUT','UPDATE','FLOAT',OUTPTR,SLOT,STATUS)
      IF(STATUS.NE.0)GOTO 500
C
C     Now for the incidental values - the wavelength range (BANDWIDTH),
C     the doubling wavelength (LAMBDA_DOUBLE), and the exposure time
C     for the spectrum (TIME).
C
      CALL DSA_GET_EXPOSURE('SPECT',1.0E0,0.0E0,TIME,STATUS)
      IF ((STATUS.NE.0).OR.(TIME.LE.0.0E0)) THEN
         CALL DSA_WRUSER(
     :     'Warning: adopting an exposure time of 1 second.\N')
         TIME=1
         STATUS=0
      END IF

      CALL DSA_ELEMENT_NAME('SPIKE','BANDWIDTH',DNAME,STATUS)
      IF(STATUS.NE.0)GOTO 500

      CALL DTA_RDVARF(DNAME,1,BANDW,DSTAT)
      IF (DSTAT.NE.0) THEN
         CALL DSA_WRUSER(
     :    'Warning: No bandwidth specified for spiketrum.  This data '//
     :    'may be for a continuum calibration, which should be '//
     :    'processed using INTERP and then direct division.  See '//
     :    'SUN/86, Section 4.5 - "Flux Claibration".  '//
     :    'A bandwidth of 40 Angstroms will be used.\N')
         BANDW=40
      END IF

      CALL DSA_ELEMENT_NAME('SPIKE','LAMBDA_DOUBLE',DNAME,STATUS)
      IF(STATUS.NE.0)GOTO 500

      CALL DTA_RDVARF(DNAME,1,DLAMB,DSTAT)
      IF (DSTAT.NE.0) DLAMB=0.
C
C     And finally, create the result spiketrum, given the Z-table
C     values, the input spectrum, and the assorted other data.
C
      CALL FIG_CSPIKE(NTAB,%VAL(CNF_PVAL(TXPTR)),%VAL(CNF_PVAL(TZPTR)),
     :                NX,%VAL(CNF_PVAL(SPEXPR)),%VAL(CNF_PVAL(SPEPTR)),
     :                TIME,BANDW,DLAMB,%VAL(CNF_PVAL(OUTPTR)))
C
C     Any TABLE information in the original spiketrum is not relevant
C     to the output spiketrum, so delete it
C
      CALL DSA_ELEMENT_NAME('OUTPUT','TABLE_STRUCTURE',DNAME,STATUS)
      IF(STATUS.NE.0)GOTO 500

      CALL DTA_DLVAR(DNAME,DSTAT)

  500 CONTINUE
C
C     Close down everything
C
      CALL DSA_CLOSE(STATUS)
      IF(FAULT)CALL FIG_SETERR
      END
C+
      SUBROUTINE FIG_FSPTAB (NTAB,XTABLE,TABLED,NX,XDATA,ZDATA,ZTABLE)
C
C     F I G _ F S P T A B
C
C     CSPIKE utility.  Given a table of X values for a spiketrum,
C     the spiketrum X data array, and the spiketrum Z data array,
C     fills a table of Z values for the spiketrum.  Note that the main
C     reason for going through all this is that the precise X values
C     from the original table file are degraded (depending on the
C     values in the X data array) when the spiketrum is created.  This
C     routine essentially reproduces the original table values.
C     If the X table values are not available, they will be filled
C     from the X array.
C
C     Parameters -  (">" input, "<" output)
C
C     (>) NTAB     (Integer) Number of table entries
C     (>/<) XTABLE (Real array XTABLE(NTAB)) The table X values.  If
C                  TABLED is true, these are passed to this routine.
C                  Otherwise, they are set by this routine.
C     (>) TABLED   (Logical) True if the XTABLE values are known,
C                  false if they are to be determined from the ZDATA
C                  and XDATA values.
C     (>) NX       (Integer) The number of elements in the data arrays
C     (>) XDATA    (Real array XDATA(NX)) The X data array.
C     (>) ZDATA    (Real array ZDATA(NX)) The Z data array.
C     (<) ZTABLE   (Real array ZTABLE(NTAB)) The table Z values
C
C     Common variables used - None
C
C     Functions / subroutines used -
C
C     GEN_BSEARCH   (GEN_ package) Find nearest element to value in array
C     ICH_ENCODE    (ICH_   "    ) Encode real # into character string
C
C                                                  KS / CIT 28th May 1984
C     Modified:
C
C     16th Jan 1989.  JM / RAL. PAR-WRUSER replaced with DSA_ routine
C                     for output to user
C+
      IMPLICIT NONE
C
C     Parameters
C
      LOGICAL TABLED
      INTEGER NTAB, NX
      REAL    XTABLE(NX), XDATA(NX), ZDATA(NX), ZTABLE(NTAB)
C
C     Functions
C
      INTEGER GEN_BSEARCH, ICH_ENCODE
C
C     Local variables
C
      INTEGER INVOKE, IPTR, ITAB, IX, NEXT
      CHARACTER INTERR*36, STRING*64
C
      DATA INTERR/'Warning: Internal error in spiketrum'/
C
      IF (.NOT.TABLED) THEN
         ITAB=0
         DO IX=1,NX
            IF (ZDATA(IX).NE.0.) THEN
               ITAB=ITAB+1
               IF (ITAB.GT.NTAB) THEN
                  CALL DSA_WRUSER(INTERR//'\N')
                  CALL DSA_WRUSER(
     :                      'Too many values found in spiketrum.\N')
               ELSE
                  XTABLE(ITAB)=XDATA(IX)
                  ZTABLE(ITAB)=ZDATA(IX)
               END IF
            END IF
         END DO
      ELSE
         DO ITAB=1,NTAB
            IPTR=GEN_BSEARCH(XDATA,NX,XTABLE(ITAB))
            IF (IPTR.LE.0) THEN
               CALL DSA_WRUSER(INTERR//'\N')
               STRING='Table value '
               INVOKE=ICH_ENCODE(STRING,XTABLE(ITAB),13,3,NEXT)
               STRING(NEXT:)=' is outside wavelength range'
               CALL DSA_WRUSER(STRING//'\N')
               ZTABLE(ITAB)=0.
            ELSE
               ZTABLE(ITAB)=ZDATA(IPTR)
               IF (ZTABLE(ITAB).EQ.0.) THEN
                  CALL DSA_WRUSER(INTERR//'\N')
                  STRING='Spike value for '
                  INVOKE=ICH_ENCODE(STRING,XTABLE(ITAB),17,3,NEXT)
                  STRING(NEXT:)=' is zero.'
                  CALL DSA_WRUSER(STRING//'\N')
               END IF
            END IF
         END DO
      END IF
C
      END
C+
      SUBROUTINE FIG_CSPIKE(NTAB,XTABLE,ZTABLE,NX,XDATA,
     :                        ZDATA,TIME,BANDW,DLAMB,OUTPUT)
C
C     F I G _ C S P I K E
C
C     Calculates the instrumental response of a detector, given
C     an observed standard spectrum, and a table of values for
C     wavelength and flux at points in that spectrum.  The result
C     is returned as a 'spiketrum' - an array where all values are
C     zero except for those that correspond to the tabulated
C     wavelengths, where the elements contain the response in
C     'units per (count per second per angstrom)'.  'Units' being
C     the units used by the tabulated values - it doesn't matter
C     what they are, although they should not be magnitudes.
C
C     That is, this routine assumes that each of the tabulated values
C     is the average flux density over a given wavelength range.  For
C     each tabulated point it sums the counts in the observed spectrum
C     over the corresponding range, then divides by the range and
C     exposure time to get the counts per second per angstrom observed.
C     Dividing the tabulated flux density by this figure gives the
C     value placed in the resulting spiketrum.
C
C     Parameters -  (">" input, "<" output)
C
C     (>) NTAB    (Integer) Number of table values
C     (>) XTABLE  (Real array XTABLE(NTAB)) X table values (wavelengths)
C     (>) ZTABLE  (Real array ZTABLE(NTAB)) Z  "     "     (flux)
C     (>) NX      (Integer) Number of elements in the data arrays
C     (>) XDATA   (Real array XDATA(NX)) X data array - ie the wavelengths
C                 corresponding to the centers of each of the elements
C                 of ZDATA.
C     (>) ZDATA   (Real array ZDATA(NX)) Z data array - the observed
C                 standard spectrum.
C     (>) TIME    (Real) The observation time for the standard in seconds
C     (>) BANDW   (Real) The bandwidth for the tabulated values, in
C                 Angstroms.
C     (>) DLAMB   (Real) The bandwidth doubling value - a wavelength
C                 above which the bandwidth is 2*BANDW.  (Some published
C                 data does this).
C     (<) OUTPUT  (Real array OUTPUT(NX)) The output spiketrum.
C
C     Common variables used - None
C
C     Subroutines / functions used -
C
C     GEN_BSEARCH  (GEN_package) Find nearest array element to given value
C     FIG_WAVEST   (FIG_  "    ) Get wavelength of left edge of pixel
C
C                                           KS / CIT 2nd July 1984
C     Modified:
C
C     3rd Sept 1986.  KS / AAO.  Bug fix. Now works on negative data.
C+
      IMPLICIT NONE
C
C     Parameters
C
      INTEGER NTAB, NX
      REAL    XTABLE(NTAB), ZTABLE(NTAB), XDATA(NX), ZDATA(NX)
      REAL    TIME, BANDW, DLAMB, OUTPUT(NX)
C
C     Functions
C
      INTEGER GEN_BSEARCH
      REAL    FIG_WAVEST
C
C     Local variables
C
      LOGICAL MORE, REV
      INTEGER IFIRST, ILAST, IST, ITAB, IX
      REAL    COUNTS, CWAVE, RATIO, WAVEL, WAVER, WEND, WIST
      REAL    WSTART, XRANGE
C
C     First step.  Zero the result array.
C
      CALL GEN_FILL(NX*4,0,OUTPUT)
C
C     Second step.  Some data may have been scrunched in such a way that
C     there are zeros at the ends of the spectrum.  We don't want to
C     include these zeros as real data, so first we move the limits of the
C     spectrum in, if necessary.  If the data is all zero, quit now.
C
      DO IX=1,NX
         IF (ZDATA(IX).NE.0.) GO TO 300
      END DO
      GO TO 600
  300 CONTINUE
      IFIRST=IX
      DO IX=NX,IFIRST,-1
         IF (ZDATA(IX).NE.0.) GO TO 310
      END DO
  310 CONTINUE
      ILAST=IX
C
C     Third step.  For each table point, find the range of elements in
C     ZDATA that correspond to its wavelength range, and sum the counts
C     observed over that range, interpolating linearly at the ends, then
C     calculate the response ratio and stick it in the result spiketrum.
C
      REV=XDATA(1).GT.XDATA(NX)
      DO ITAB=1,NTAB
C
C        Wavelength range is from WAVEL to WAVER (the names imply Left
C        and Right, which is correct if X data is in ascending order)
C
         CWAVE=XTABLE(ITAB)
         IF ((DLAMB.GT.0.).AND.(CWAVE.GT.DLAMB)) THEN
            WAVEL=CWAVE-BANDW
            WAVER=CWAVE+BANDW
         ELSE
            WAVEL=CWAVE-BANDW*.5
            WAVER=WAVEL+BANDW
         END IF
         COUNTS=0.
C
C        The actual calculation of the total counts in the wavelength band
C        is essentially the same whether the X data is in ascending or
C        descending order, but the details are sufficiently different that
C        it codes better as two distinct alternative cases.
C
         IF (.NOT.REV) THEN
C
C           This is for the ascending case.  Find the element that contains
C           the start wavelength, and take that fraction of it that is
C           within the wavelength range.  If range starts before IFIRST,
C           adjust the wavelength start - adding in zeros from the zero
C           elements won't matter.
C
            IST=GEN_BSEARCH(XDATA,NX,WAVEL)
            IF (IST.LT.IFIRST) THEN
               WSTART=FIG_WAVEST(IST+1,NX,XDATA)
            ELSE
               XRANGE=FIG_WAVEST(IST+1,NX,XDATA)
     :                       -FIG_WAVEST(IST,NX,XDATA)
               WSTART=WAVEL
               COUNTS=ZDATA(IST)*(XDATA(IST)+XRANGE*.5-WAVEL)/XRANGE
            END IF
C
C           Now carry on through the successive elements until we pass the
C           end of the data, or are out of the wavelength range.  Add all
C           of the data in from each element.
C
            MORE=.TRUE.
            DO WHILE (MORE)
               IST=IST+1
               WIST=FIG_WAVEST(IST,NX,XDATA)
               IF (IST.GT.ILAST) THEN
                  MORE=.FALSE.
                  WEND=WIST
               ELSE
                  IF (WIST.GT.WAVER) THEN
                     MORE=.FALSE.
                     WEND=WAVER
                  ELSE
                     COUNTS=COUNTS+ZDATA(IST)
                  END IF
               END IF
            END DO
C
C           Now that we are out of the range, compensate for the fact that
C           we probably took more from the last element than we should,
C           if it straddled the end of the wavelength range.
C
            XRANGE=WIST-FIG_WAVEST(IST-1,NX,XDATA)
            COUNTS=COUNTS
     :              -ZDATA(IST-1)*(XDATA(IST-1)+XRANGE*.5-WEND)/XRANGE
         ELSE
C
C           The sequence when the X array is in descending order is the
C           same, but the functions of WSTART and WEND etc reverse, and
C           most of the tests are the other way round.
C
            IST=GEN_BSEARCH(XDATA,NX,WAVER)
            IF (IST.LT.IFIRST) THEN
               WEND=FIG_WAVEST(IST+1,NX,XDATA)
            ELSE
               XRANGE=FIG_WAVEST(IST,NX,XDATA)
     :                       -FIG_WAVEST(IST+1,NX,XDATA)
               WEND=WAVER
               COUNTS=ZDATA(IST)*(WAVER-XDATA(IST)+XRANGE*.5)/XRANGE
            END IF
            MORE=.TRUE.
            DO WHILE (MORE)
               IST=IST+1
               WIST=FIG_WAVEST(IST,NX,XDATA)
               IF (IST.GT.ILAST) THEN
                  MORE=.FALSE.
                  WSTART=WIST
               ELSE
                  IF (WIST.LT.WAVEL) THEN
                     MORE=.FALSE.
                     WSTART=WAVEL
                  ELSE
                     COUNTS=COUNTS+ZDATA(IST)
                  END IF
               END IF
            END DO
            XRANGE=FIG_WAVEST(IST-1,NX,XDATA)-WIST
            COUNTS=COUNTS
     :              -ZDATA(IST-1)*(WSTART-XDATA(IST-1)+XRANGE*.5)/XRANGE
         END IF
C
C        Finally, calculate the ratio value
C
         IF (COUNTS.NE.0.) THEN
            RATIO=ZTABLE(ITAB)*TIME*(WEND-WSTART)/COUNTS
            OUTPUT(GEN_BSEARCH(XDATA,NX,CWAVE))=RATIO
         END IF
      END DO
C
  600 CONTINUE
      END







