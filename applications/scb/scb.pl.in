#!/usr/bin/env starperl -w -I@bindir@

#+
#  Name:
#     scb.pl

#  Purpose:
#     Generate listing of a Starlink source code file.

#  Language:
#     Perl 5

#  Invocation:
#     scb.pl [-html] [-exact] \
#            [[name=]<name>] [[package=]<package>] [[type=]func|file|regex]
#
#     Arguments may be supplied on the command line or in the QUERY_STRING
#     environment variable as by CGI.

#  Description:
#     This script extracts the source code for a module in the USSC.
#     The input values $name, $package and $mode are interpreted as
#     documented in the Arguments section to identify a source code file,
#     and the source code file is extracted from its position in the
#     Starlink source code tree and printed to standard output.
#
#     It operates in one of two modes: CGI mode and command-line mode,
#     choosing which by how it appears to have been invoked (by examining
#     environment variables).
#
#     In CGI mode all output is in HTML, where possible including hyperlinks
#     where the output source file references other modules (called
#     routines and include files).  The location of the output file within
#     the Starlink source tree is given as the <head> tag of the HTML
#     (usually used as the title of the browser window).
#     In the absence of sufficient arguments to identify a source file
#     a query form is output instead, including further links which may
#     be useful (e.g. links to all files in the specified package).
#
#     In command-line mode the output file is by default printed to
#     standard output as raw text, although HTML may be generated instead
#     by using the '-html' flag.  The location of the file in the
#     Starlink source tree is printed to standard error.
#     In the absence of sufficient arguments to identify a source file
#     a usage message is printed.

#  Flags:
#     -html.
#        Force generation of HTML output (in command-line mode plain
#        text is generated by default).
#
#     -exact.
#        Match index keys exactly, do not attempt case folding or
#        adding an underscore.

#  Arguments:
#     $name = string.
#        Name of the module to retrieve.  This is interpreted as per
#        the $mode argument, but by default ($mode=NULL) is the name
#        of a key in any StarIndex object.
#
#     $package = string (optional).
#        This argument provides a hint for which package the module may
#        be found in.  It is only used when there are multiple entries
#        in the index file for the key $module, to decide which to choose.
#        If no $name argument is supplied in CGI mode then a list of modules
#        for the package $package is printed.
#
#     $mode = string (optional).
#        Query mode is one of the index names (currently "file" or "func"),
#        "regex" or NULL (either undef or "").
#           "file" queries the "file" StarIndex object for a key of
#              $name or possibly $name capitalised.
#           "func" queries the "func" StarIndex object for a key of
#              $name or possibly $name followed by an underscore or
#              $name in lower case.
#           NULL   combines the functions of "file" and "func".
#           "regex" performs a Perl regular expression search on the keys
#              of both StarIndex objects
#     $indexdir = string (optional).
#        If present, this argument specifies the directory in which to find
#        the index files.  It overrides the default and the environment
#        variable SCB_INDEX, which normally supply this value.  Setting
#        SCB_INDEX is the preferred way of influencing this value; hence
#        this will normally be used only in CGI mode (where environment
#        variables cannot be set to order), rather than from the command
#        line.
#
#     If invoked from the command line, then $name must be specified.
#     If invoked as a CGI script then if $module is specified an attempt
#     is made to retrieve that module.  If it is not, then a form is
#     presented in which a module may be specified.
#
#     Arguments may be presented in ADAM style, either as 'arg=val'
#     (which is what CGI makes them look like) or positionally determined.

#  Notes:
#     Operation of this script will be affected by the build-time and
#     run-time values of certain environment variables, as documented
#     in the module Scb.pm.

#  Copyright:
#     Copyright (C) 1998 Central Laboratory of the Research Councils

#  Authors:
#     MBT: Mark Taylor (IoA, Starlink)
#     {enter_new_authors_here}

#  History:
#     14-OCT-1998 (MBT):
#        Initial revision.
#     13-FEB-2003 (MBT):
#        Modified so that it can operate without writable scratch
#        directory if it doesn't need to untar any files.
#     {enter_further_changes_here}

#  Bugs:
#     {note_any_bugs_here}

#-

#  Temporary directory location.

$tmpdir = "$scb_tmpdir/$$";

#  Name of this program.

$self = $0;
$self =~ s%.*/%%;

#  Set root of source code extractor program.

$scb = $self . "?";

#  Set usage message.

$usage = "Usage: $self [-html] [-exact] \\\n"
       . "        " . ' ' x length ($self)
       . "[[name=]<name>] [[package=]<package>] [[type=]func|file|regex]\n"
       . "        " . ' ' x length ($self)
       . "[[indexdir=]<indexdir>]\n";

#  Required libraries.

use Scb;
use StarIndex;

#  Declarations.

sub parse_args;
sub get_module;
sub query_form;
sub extract_file;
sub search_keys;
sub package_list;
sub getdoctitles;
sub regex_validate;
sub output;
sub error;
sub mimetype;
sub header;
sub footer;
sub hprint;
sub quasialph;
sub demeta;
sub tidyup;

#  Determine whether we are being run as a CGI script, and take appropriate
#  action if so: output CGI header, make arguments look as if they were
#  received on the command line, and cut path down to a minimum for
#  security reasons.

if (exists $ENV{'SERVER_PROTOCOL'}) {
   $cgi = 1;
   @ARGV = split '&', $ENV{'QUERY_STRING'};
   $ENV{'PATH'} = '/bin:/usr/bin';
}

#  Parse command line arguments.

($rarg, $rflag, $rextra) = parse_args \@ARGV, qw/name package type indexdir/;

#  Exit if there are unassigned arguments.

die $usage if (@$rextra);

#  Process flags.

$html = defined (delete ($rflag->{'html'})) || $cgi;
$exact = defined (delete ($rflag->{'exact'}));

#  Exit if there are unknown flags (including '-h').

error $usage if (%$rflag);

#  Process arguments; assign empty string if unspecified to avoid
#  warning messages.

$name     = $rarg->{'name'}     || '';
$package  = $rarg->{'package'}  || '';
$type     = $rarg->{'type'}     || '';

#  $indexdir already has a default value; if one is specified on the
#  command line override it and note that this argument should be
#  retained for subsequent form invocations.

if ($rarg->{'indexdir'}) {
   $indexdir = $rarg->{'indexdir'};
   $retained{'indexdir'} = $indexdir;
}

#  Set the basic href used for constructing hyperlinks to source files
#  to include retained arguments, so that they are inherited by files
#  linked from this one.

my ($key, $value);
while (($key, $value) = each %retained) {
   $scb .= "$key=$value" . '&amp;';
}

#  Set up URL of top level of browser - same as current value of $scb but
#  may need an unused '?' removing.

$scb_top = $scb;
$scb_top =~ s/\?$//;

#  Initialise index objects containing locations of functions and files.

my $iname;
foreach $iname (@indexes) {
   $index{$iname} = StarIndex->new("$indexdir/$iname", "read");
}

#  Set up human-readable names for index contents.

%contents = (func => 'Routine', file => 'File');

#  Read list of packages and tasks if it will be required.

if (!$name || $type eq 'regex') {
   my ($pack, $time);
   my $taskfile = "$indexdir/tasks";
   open TASKS, $taskfile or error "Failed to open $taskfile\n";
   while (<TASKS>) {
      my($pre, @tasks) = split;
      ($pack, $time) = split ':', $pre;
      @{$tasks{$pack}} = @tasks;
   }
   close TASKS;
   @packages = sort keys %tasks;
}

#  Set up signal handler.  Note this is not entirely safe since tidyup
#  does non-trivial work and so (probably) calls some non-reentrant
#  routines.  If the handler is called at an unlucky time this may
#  result in an inelegant exit (core dump).

$SIG{'INT'} = sub {tidyup; exit;};

#  Main processing.

if ($name && $type ne 'regex') {

#  Name argument has been supplied, so try to retrieve the requested file.
#  If an type ('file' or 'func') has been given, then try to match it in the
#  appropriate index.  Otherwise try to match it in either index.
#  For each type of match, try it exact first, but (unless the -exact flag
#  has been given) look for variants if that fails - specifically,
#  try appending or lowercasing an underscore to function names, and try
#  lowercasing something which looks like a Fortran include.
#  By using the '||=' operator, once get_module has completed successfully,
#  no further calls are attempted.  If all attempts fail, exit with an
#  error.

   my $success = 0;
   my ($t, $n);
   my @types = $type ? ($type) : @indexes;
   foreach $t (@types) {
      my @names = ($name);
      unless ($exact) {
         if ($t eq 'file') {
            push @names, lc ($name) if ($name =~ /^[A-Z0-9_]*$/);
         }
         elsif ($t eq 'func') {
            push @names, $name . "_" if ($name !~ /_$/);
            push @names, lc ($name) . '_' if ($name =~ /^[A-Z0-9_]*[A-Z0-9]$/);
         }
      }
      foreach $n (@names) {
         $success ||= get_module ($t, $n, $package);
      }
   }
   unless ($success) {
      error "Failed to find item $name\n",
         "This may be a result of a deficiency in the source
          code indexing program, or because the module you
          requested doesn't exist, or because the index
          databases in <code>$indexdir</code> have become out of date.";
   }
}
elsif ($name && $type eq 'regex') {

#  Name has been supplied as a regular expression.

   regex_validate $name;
   if ($html) {
      header "$self: search for '" . demeta ($name) . "'";
      query_form $package;
      search_keys $name, $package;
      footer;
   }
   else {
      search_keys $name, $package;
   }

}
elsif (!$name) {

#  No name argument has been supplied.  Either present a form (HTML mode)
#  or exit with a usage message (command-line mode).

   if ($html) {
      header $self;
      query_form $package;
      package_list $package;
      footer;
   }
   else {
      error $usage;
   }
}
else {

#  This should not happen.

   error "Internal: program logic is wrong\n";
}

#  End

tidyup;

exit;



########################################################################
# Subroutines.
########################################################################


########################################################################
sub parse_args {

#+
#  Name:
#     parse_args

#  Purpose:
#     Parse arguments to Perl script.

#  Language:
#     Perl 5

#  Invocation:
#     parse_args (\@ARGV, @default);

#  Description:
#     Examine command line arguments of a Perl script and return them
#     in two hashes.  Three kinds of arguments are allowed:
#
#        Flags, beginning with a '-' character
#        Named arguments, of form "name=value"
#        Positionally determined arguments, of form "value"
#
#     First anything which looks like a flag or a named argument is
#     parsed.  Then anything left is presumed to be positionally
#     determined, and they are assigned in order to the names given
#     in the @defaults argument.  If there are more words on the
#     command line than can be assigned using the @defaults argument
#     they are returned in the @extra list.  Flags and named or
#     positionally-determined variables are returned in separate hashes.
#
#     Finally CGI-style encodings in the arguments are decoded into ASCII,
#     and HTML metacharacters in the arguments are encoded into SGML
#     entities.

#  Arguments:
#     \@ARGV = reference to list of strings.
#        List of words from the command line.
#     @default = list of strings.
#        List of names of arguments to be determined positionally.

#  Return value:
#     \%arg = reference to hash of strings.
#        Hash (key, value) pairs are argument (name, value) pairs.
#     \%flag = reference to hash of booleans.
#        Hash key 'flag' exists if '-flag' given on command line.
#     \@extra = reference to list of strings.
#        Each word in list is unnamed, non-positionally determined word
#        appearing on the command line.

#  Notes:

#  Copyright:
#     Copyright (C) 1998 Central Laboratory of the Research Councils

#  Authors:
#     MBT: Mark Taylor (IoA, Starlink)
#     {enter_new_authors_here}

#  History:
#     05-OCT-1998 (MBT):
#       Initial revision.
#     {enter_further_changes_here}

#  Bugs:
#     {note_any_bugs_here}

#-

#  Get arguments.

   my $rargv = shift;
   my @default = @_;

#  Initialise local variables.

   my (%arg, %flag);

#  Extract named arguments (format arg=value) into hash %arg
#  and flags (format -flag) into hash %flag.

   if (@$rargv) {
      for ($i = @$rargv - 1; $i>=0; $i--) {
         if ($rargv->[$i] =~ /(.*)=(.*)/) {
            $arg{$1} = $2;
            splice (@$rargv, $i, 1);
         }
         elsif ($rargv->[$i] =~ /^-(.*)/) {
            $flag{$1} = 1;
            splice (@$rargv, $i, 1);
         }
      }
   }

#  Deal with undefined positionally-determined arguments; anything
#  unassigned after this is left in @$rargv (and returned at the end).

   while ($default = shift @default) {
      $arg{$default} ||= shift (@$rargv) || '';
   }

#  Decode HTTP-style hex encoded characters and spaces, and encode SGML
#  metacharacters.

   foreach $key (keys %arg) {
      if ($cgi) {
         $arg{$key} =~ tr/+/ /;
         $arg{$key} =~ s/%(..)/pack("c",hex($1))/ge;
      }
      $arg{$key} =~ s/</&lt;/g;
      $arg{$key} =~ s/>/&gt;/g;
   }

#  Return.

   return (\%arg, \%flag, $rargv);
}


########################################################################
sub query_form {

#+
#  Name:
#     query_form

#  Purpose:
#     Output an HTML form to run source code browser.

#  Language:
#     Perl 5

#  Invocation:
#     query_form [$package];

#  Description:
#     Outputs an HTML form to allow the source code browser program to
#     be run as a CGI script.  The routine will output a form
#     containing enough functionality to allow the script to be called
#     with all its useful functions.

#  Arguments:
#     $package = string (optional).
#        Name of selected Starlink package.

#  Return value:

#  Notes:

#  Copyright:
#     Copyright (C) 1998 Central Laboratory of the Research Councils

#  Authors:
#     MBT: Mark Taylor (IoA, Starlink)
#     {enter_new_authors_here}

#  History:
#     05-OCT-1998 (MBT):
#       Initial revision.
#     {enter_further_changes_here}

#  Bugs:
#     {note_any_bugs_here}

#-

#  Get arguments.

   $package = shift;

#  Print form header.

   hprint "
      <h1>$self: Starlink Source Code Browser</h1>
      <form method=GET action='$self'>
   ";

#  Record retained arguments as hidden input fields in the form so they
#  are inherited by subsequent invocations.

   my ($key, $value);
   while (($key, $value) = each %retained) {
      print "<input type=hidden name='$key' value='$value'>\n";
   }

#  Print query box for module.

   print "Name of item: <input name=name size=40 value='",
                           ($type eq 'regex') ? $name : "",
                       "'>",
         "\n<br>\n";

#  Print radio buttons for type.

   my %radio;
   my $iname;
   foreach $iname (@indexes) {
      $radio{$iname} = "<input type=radio name=type value='$iname'>&nbsp;"
                     . $contents{$iname};
   }
   $radio{''}      = "<input type=radio name=type value=''>"
                   . "&nbsp;Either";
   $radio{'regex'} = "<input type=radio name=type value='regex'>"
                   . "&nbsp;Regular&nbsp;expression";
   $radio{$type} =~ s/>/ checked>/;

   print "Type of item:\n";
   print join "&nbsp;&nbsp;\n", @radio{(@indexes, '', 'regex')};
   print "\n<br>\n";

#  Print select list for package.

   my $selected = $package ? '' : ' selected';
   hprint "
      Name of package (optional):
      <font size=-1>
      <select name=package>
      <option value=''$selected>Any
   ";
   for $pack (@packages) {
      $selected = $pack eq $package ? ' selected' : '';
      print "<option value='$pack'$selected>$pack\n";
   }
   print "</select></font>\n";

#  Print submission button and form footer.

   hprint "
      <br>
      <input type=submit value='Retrieve'>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      <a href='http://www.star.bris.ac.uk/~mbt/docs/sun225.htx/node17.html#xref_BROWSER-HELP'>Help</a>
      </form>
      <hr>
   ";
}


########################################################################
sub package_list {

#+
#  Name:
#     package_list

#  Purpose:
#     Output HTML with links to useful elements of a Starlink package.

#  Language:
#     Perl 5

#  Invocation:
#     package_list [$package];

#  Description:
#     This routine will output HTML giving links to various elements of
#     the specified package.  If no package argument is given, it
#     will output HTML giving links to pages specific to each available
#     package.  All the links are links back to this CGI script with
#     appropriate arguments.
#
#     The exact output (list of files, functions, or both) depends on
#     the value of the global $type variable.

#  Arguments:
#     $package = string (optional).
#        Name of Starlink package of interest.

#  Return value:

#  Notes:

#  Copyright:
#     Copyright (C) 1998 Central Laboratory of the Research Councils

#  Authors:
#     MBT: Mark Taylor (IoA, Starlink)
#     {enter_new_authors_here}

#  History:
#     05-OCT-1998 (MBT):
#       Initial revision.
#     {enter_further_changes_here}

#  Bugs:
#     {note_any_bugs_here}

#-

#  Get arguments.

   my $package = shift;

#  Separator

   my $sep = "<b>-</b>&nbsp;";

   if ($package) {

#     Package has been specified.  Output links specific to that package.

      print "<h2>$package</h2>\n";

#     Assemble a list of files in the package for each file extension.
#     The code can be easily changed as commented to group them by
#     which tar file they are included in if that is preferred.

      my (%files, $file, $tarfile, $suffix);
      while (($file, $loc) = $index{'file'}->each($package)) {
         $suffix = $tarfile = '';
         $suffix = $1 if ($file =~ m%(\.[^/>#]+)$%);
         push @{$files{$suffix}}, $file;

         # Could do this to group them by tarfile instead if you wanted.
         # $tarfile = $1 if ($loc =~ m%([^/>#]+.tar)(?:\.[^/>#]*)?>[^/>#]+$%);
         # push @{$files{$tarfile}}, $file;
      }

#     Print links to package-specific lists which will not be given here.

      my %printlist;
      $printlist{$type} = 1;

      foreach $iname (@indexes) {
         print
            "<hr><h3><a href='${scb}package=$package&amp;type=$iname#$iname'>",
            $contents{$iname}, "s</a> in package <b>$package</b>.</h3>\n"
            unless ($printlist{$iname});
      }

#     Print list of Starlink documents from selected package.

      my (@docs);
      foreach $texfile (@{$files{'.tex'}}) {
         push @docs, "$1$2"
            if ($texfile =~ /^(sc|sg|sun|sgp|ssn)([0-9]+)\.tex$/);
      }

      if (@docs) {
         my $rdoctitles = getdoctitles;
         hprint "
            <hr>
            <h3>Starlink documents in package <b>$package</b>:</h3>
            <dl>
         ";
         foreach $doc (sort @docs) {
            print "<dt><a href='", docurl ($doc), "'>", uc ($doc), "</a>",
                  "<dd>", ($rdoctitles->{$doc} || ""), "\n";
         }
         print "</dl>\n";
      }

#     Print list of tasks in selected package.

      if (@tasks = @{$tasks{$package}}) {

         hprint "
            <hr>
            <h3>Tasks in package <b>$package</b>:</h3>
            The following appear to be tasks within package <b>$package</b>:
            <br>
            <dl> <dt> <br> <dd>
         ";
         my $module;
         foreach $module (sort @tasks) {
            $task = $module;
            $task =~ s/_$//;
            print
               "$sep<a href='${scb}$module&amp;$package#$module'>$task</a>\n";
         }
         print "</dl>\n\n";
      }

      if ($printlist{'func'}) {

         hprint "
            <hr>
            <a name='func'></a>
            <h3>" . $contents{'func'} . "s in package <b>$package</b>:</h3>
         ";

#        Assemble a list of functions in the package for each function
#        prefix.

         my $loc;
         my (%modules, $mod, $prefix);
         while (($mod, $loc) = $index{'func'}->each($package)) {
            $prefix = '';
            $prefix = $1 if ($mod =~ /^([^_]*_)./);
            push @{$modules{$prefix}}, $mod;
         }

         if (%modules) {

#           For each prefix, print group of functions in the package.

            hprint "
               The following routines (C and Fortran functions and subroutines)
               from the package $package are indexed:<br>
            ";
            print "<dl>\n";
            my ($prefix, $r_mods, $ignore);
            foreach $prefix (sort quasialph keys %modules) {
               print "<dt> $prefix <br>\n<dd>\n";
               foreach $mod (sort @{$modules{$prefix}}) {
                  if ($mod =~ /^(.*)&lt;t&gt;(.*)$/i) {
                     $ignore = "$1(" . join ('|', qw/i r d l c b ub w uw/)
                               . ")$2";
                  }
                  if ($ignore) {
                     next if ($mod =~ $ignore);
                  }
                  else {
                     $ignore = undef;
                  }
                  print "$sep<a href='${scb}$mod&amp;$package#$mod'>$mod</a>\n";
               }
            }
            print "\n</dl>\n<hr>\n";
         }
         else {
            hprint "
               No C or Fortran functions or subroutines are indexed for
               package $package.
            ";
          }
      }

      if ($printlist{'file'}) {

         hprint "
            <hr>
            <a name='file'></a>
            <h3>", $contents{'file'}, "s in package <b>$package</b>:</h3>
         ";

         if (%files) {

#           For each extension, print group of files in the package.

            hprint "
               The following files from the package are indexed:<br>
            ";
            print "<dl>\n";
            foreach $key (sort quasialph keys %files) {
               print "<dt> $key <br>\n<dd>\n";
               foreach $file (sort @{$files{$key}}) {
                  print
                     "$sep<a href='${scb}$file&amp;$package&type=file'>",
                     "$file</a>\n";
               }
            }
            print "\n</dl>\n<hr>\n";
         }
         else {
            hprint "
               No files are indexed for package $package.
            ";
         }
      }

   }
   else {

#     No package specified.  Print list of all packages.

      hprint "
         <h2>Packages</h2>
         <dir compact>
      ";
      foreach $pack (@packages) {
         print "<li> ";
         print "<a href='${scb}package=$pack&type=$type'>$pack</a>\n";
      }
      print "</dir>\n";
   }

}


########################################################################
sub search_keys {

#+
#  Name:
#     search_keys

#  Purpose:
#     Find keys in StarIndex objects matching a Perl regular expression.

#  Language:
#     Perl 5

#  Invocation:
#     search_keys $regex [, $package];

#  Description:
#     Searches through all keys in all StarIndex indexes and outputs a
#     list of those which match the regular expression $regex.  If the
#     $package argument is given, only that package is searched,
#     otherwise all packages are searched.

#  Arguments:
#     $regex = string.
#        Perl regular expression.
#     $package = string (optional).
#        Name of Starlink package to search.

#  Return value:

#  Notes:

#  Copyright:
#     Copyright (C) 1998 Central Laboratory of the Research Councils

#  Authors:
#     MBT: Mark Taylor (IoA, Starlink)
#     {enter_new_authors_here}

#  History:
#     05-OCT-1998 (MBT):
#       Initial revision.
#     {enter_further_changes_here}

#  Bugs:
#     {note_any_bugs_here}

#-

#  Get arguments.

   my ($regex, $package) = @_;

#  Initialise local variables.

   my (%match);
   my ($name, $loc, $pack, $iname);

#  Find matching index entries.

   foreach $iname (@indexes) {
      while (($name, $loc) = $index{$iname}->each($package)) {
         if ($name =~ m/$regex/io) {
            $pack = starpack $loc;
            $match{$iname}{$pack}{$name} = $loc;
         }
      }
   }

#  Prepare text of regular expression in HTML-printable form.

   my $htregex = demeta $regex;

#  Print heading.

   print "\n<h2>Search results: $htregex</h2>\n" if ($html);

   if (%match) {

#     Print list of matching index entries by index type and package.

      foreach $iname (sort keys %match) {
         if ($html) {
            print "\n<h3>", $contents{$iname}, "s</h3>\n<dl>\n";
         }
         else {
            print "\n", $contents{$iname}, ":\n";
         }
         foreach $pack (sort keys %{$match{$iname}}) {
            print "<dt>$pack:</dt>\n" if ($html && !$package);
            foreach $name (sort keys %{$match{$iname}{$pack}}) {
               $loc = $match{$iname}{$pack}{$name};
               if ($html) {
                  print
                     "<dd>",
                     "<a href='${scb}$name&package=$package&type=$iname",
                     ($iname eq "func" ? "#$name" : ""),
                     "'>",
                     "$name</a>",
                     "</dd>\n";
               }
               else {
                  printf "%-20s => %s\n", $name, $loc;
               }
            }
         }
         print "\n</dl>\n<hr>\n" if ($html);
      }
   }
   else {

#     No matching entries found.

      if ($html) {
         print "No matches were found for the regular expression '$htregex'";
         print " in package <b>$package</b>" if ($package);
         print ".<p>\n";
      }
      else {
         print STDERR "No matches found for the regular expression '$regex'\n";
         print STDERR "in package $package\n" if ($package);
      }
   }

}


########################################################################
sub regex_validate {

#+
#  Name:
#     regex_validate

#  Purpose:
#     Validate a regular expression.

#  Language:
#     Perl 5

#  Invocation:
#     regex_validate ($regex);

#  Description:
#     This routine checks that Perl thinks a regular expression is correct.
#     If so, no action is taken.
#     If not, the error() routine is called to give an informative error.

#  Arguments:
#     $regex = string.
#        Regular expression to be checked.

#  Return value:

#  Notes:

#  Copyright:
#     Copyright (C) 1998 Central Laboratory of the Research Councils

#  Authors:
#     MBT: Mark Taylor (IoA, Starlink)
#     {enter_new_authors_here}

#  History:
#     04-NOV-1998 (MBT):
#       Initial revision.
#     {enter_further_changes_here}

#  Bugs:
#     {note_any_bugs_here}

#-

#  Get arguments.

   my $regex = shift;

#  Evaluate the regular expression, and report if it generates an error.

   eval { "" =~ /$regex/ };

   if ($@) {

#     Prepare regular expression in a printable form.

      my $prregex = $html ? demeta ($regex) : $regex;

#     Call error reporting routine.

      error "Invalid regular expression '$prregex'",
         "The term you entered is not a valid Perl 5 regular expression.
          Perl generated the error <blockquote><code>$@</code></blockquote>\n";
   }

}


########################################################################
sub quasialph {

#+
#  Name:
#     quasialph

#  Purpose:
#     Collation order for subroutine prefixes.

#  Language:
#     Perl 5

#  Invocation:
#     @sorted_list = sort quasialph @list;

#  Description:
#     This is a routine which provides a collation order appropriate
#     for subroutine prefixes, suitable for use with the Perl 'sort'
#     builtin function.
#
#     The order is the same as ASCII but with '_' preceding '1'.
#     This is useful because it allows 'FAC_' modules to come before
#     'FAC1_' modules, where they logically belong.

#  Arguments:
#     $a = string.
#        First sort term.
#     $b = string.
#        Second sort term.

#  Return value:
#     $cmp = integer.
#        -1, 0 or 1 according to relative position of $a and $b in
#        collation sequence.  This is the normal mode of operation
#        for Perl sort sequences.

#  Notes:

#  Copyright:
#     Copyright (C) 1998 Central Laboratory of the Research Councils

#  Authors:
#     MBT: Mark Taylor (IoA, Starlink)
#     {enter_new_authors_here}

#  History:
#     05-OCT-1998 (MBT):
#       Initial revision.
#     {enter_further_changes_here}

#  Bugs:
#     {note_any_bugs_here}

#-

   my ($na, $nb) = ($a, $b);
   $na =~ tr/_/!/;
   $nb =~ tr/_/!/;
   $na cmp $nb;
}


########################################################################
sub get_module {

#+
#  Name:
#     get_module

#  Purpose:
#     Locate and output a file if it exists under a given key name.

#  Language:
#     Perl 5

#  Invocation:
#     $success = get_module ($type, $name, $package);

#  Description:
#     If the key $name exists in the StarIndex object specified by
#     the $type argument, then output the file at the location given
#     by the value of that key.

#  Arguments:
#     $type = string.
#        Indicates the index to search.
#     $name = string.
#        Key in index.
#     $package = string.
#        Starlink package name preferred if multiple entries for $name.

#  Return value:
#     $success = boolean.
#        True if file successfully located and output, else false.

#  Notes:

#  Copyright:
#     Copyright (C) 1998 Central Laboratory of the Research Councils

#  Authors:
#     MBT: Mark Taylor (IoA, Starlink)
#     {enter_new_authors_here}

#  History:
#     05-OCT-1998 (MBT):
#       Initial revision.
#     {enter_further_changes_here}

#  Bugs:
#     {note_any_bugs_here}

#-

#  Arguments.

   my ($type, $name, $package) = @_;

#  Get logical path name from database.  $locname is a global variable.

   $locname = $index{$type}->get($name, packpref => $package);

#  Return with fail status if no item of the requested name is indexed.

   return (0) unless ($locname);

#  Set up scratch directory, if we can (if creation of the directory
#  fails, note this fact - everything will work as long as we don't
#  need to unpack tar files).

   $hastmp = mkdirp $tmpdir, 0777;
   if ($hastmp) {
      $tmpfiles = 1;
      pushd $tmpdir;
   }

#  Interpret the first element (before the '#' sign) of the location as
#  a package or symbolic directory name.  If it is a symbolic directory,
#  there is a record in the 'file' index mapping it to a real directory,
#  otherwise the real location is taken from the $srcdir variable.
#  Either way, change it for a logical path name.

   $locname =~ /^(.+)#(.+)/i;
   ($head, $tail) = ($1, $2);

   my ($file, $tarfile, $dir, $loc);
   if ($loc = $index{'file'}->get("$head#")) {
      $file = ($loc =~ m%\.tar[^/>#]*$%) ? "$loc>$tail" : "$loc/$tail";
   }
   elsif (-d "$srcdir/$head") {
      $file = "$srcdir/$head/$tail";
   }
   elsif (defined ($tarfile = <$srcdir/$head.tar*>) && -f $tarfile) {
      $file = "$tarfile>$tail";
   }
   elsif ($head =~ /^INCLUDE$/i) {
      $file = "$incdir/$tail";
   }
   else {
      error "Failed to interpret location $locname\n",
         "Probably the indexes in $indexdir are outdated or corrupted.\n";
   }

#  Extract file from logical path.

   extract_file $file, $head;

#  Tidy up.

   if ($hastmp) {
      popd;
      rmrf $tmpdir;
      $tmpfiles = 0;
   }

#  Return successful exit code.

   return 1;

}

########################################################################
sub extract_file {

#+
#  Name:
#     extract_file

#  Purpose:
#     Locates or generates file given its logical pathname.

#  Language:
#     Perl 5

#  Invocation:
#     extract_file ($location, $package);

#  Description:
#     This routine, given a logical pathname, finds the file referred to
#     and outputs it.  It does this by calling itself recursively if
#     necessary to extract the named file from a tarfile (within a
#     tarfile (within a tarfile...)).  When extracting from a tarfile,
#     the routine will check to see if the file already exists outside
#     the tarfile (which will be the case if the tarfile has been untarred
#     in place), in which case it will pick it up directly, and not
#     bother to do the untarring itself.
#
#     On first entry, the logical pathname will start with a fully
#     qualified pathname (starting with a '/'), but on subsequent
#     recursions, if we have extracted from a tar file to the current
#     (temporary) directory, it will start with a relative pathname.

#  Arguments:
#     $location = string.
#        Logical pathname of the file.
#     $package = string.
#        Hint about which package contains module.

#  Return value:
#     None.

#  Notes:

#  Copyright:
#     Copyright (C) 1998 Central Laboratory of the Research Councils

#  Authors:
#     MBT: Mark Taylor (IoA, Starlink)
#     {enter_new_authors_here}

#  History:
#     05-OCT-1998 (MBT):
#       Initial revision.
#     {enter_further_changes_here}

#  Bugs:
#     {note_any_bugs_here}

#-

#  Get arguments.

   my ($location, $package) = @_;

#  Parse logical pathname:
#     $head is the directory containing the initial file
#     $tail is the name of the initial file in $head
#     $tarcontents is the file to extract from the initial file, if it
#        is a tar file
#     $rest is to $tarcontents as $tarcontents is to $location.

   $location =~ /^([^>]+)>?([^>]*)(>?.*)$/;
   my ($initial, $tarcontents, $rest) = ($1, $2, $3);
   $initial =~ m%^(.*/)?([^/]+)$%;
   my ($head, $tail) = ($1, $2);
   $head ||= '';

#  If $initial is not a tarfile, just output the file.

   if (!$tarcontents) {
      output $initial, $package;
   }

#  If required file exists outside named tarfile, use it directly.

   elsif (-r ($file = "$head$tarcontents")) {

#     If $file is a tarfile then recurse, else output file directly.

      if ($rest) {
         extract_file "$file$rest";
      }
      else {
         output $file, $package;
      }
   }

#  If required file doesn't exist, then extract it and recurse.

   else {
      if ($hastmp) {
         tarxf "$head$tail", $tarcontents unless (-r $tarcontents);
         extract_file "$tarcontents$rest", $package;
         unlink $tarcontents;
      }
      else {
         error "No write access to scratch space $scb_tmpdir";
      }
   }
}



########################################################################
sub output {

#+
#  Name:
#     output

#  Purpose:
#     Output an existing source file in an appropriate form.

#  Language:
#     Perl 5

#  Invocation:
#     output ($file, $package);

#  Description:
#     Given an existing file, this routine outputs it in an appropriate
#     form.  If the global variable $html is false, it simply prints
#     the raw file to standard output.  If $html is true, it attempts
#     to tag it using an appropriate tagging routine, and if it
#     succeeds, goes through the tagged text producing proper HTML,
#     in particular retaining as hyperlinks only those which look like
#     they will succeed in pointing to existing files.

#  Arguments:
#     $file = string.
#        Absolute or relative pathname of existing source file.
#     $package = string.
#        Name of Starlink package of which this file is a part.
#        This is used so that when the links are generated, they can
#        hint to the browser program the package in which the linked
#        files will be found, on the assumption that if there's a choice
#        it is more likely to be the current package than another one.

#  Return value:

#  Notes:

#  Copyright:
#     Copyright (C) 1998 Central Laboratory of the Research Councils

#  Authors:
#     MBT: Mark Taylor (IoA, Starlink)
#     {enter_new_authors_here}

#  History:
#     05-OCT-1998 (MBT):
#       Initial revision.
#     {enter_further_changes_here}

#  Bugs:
#     {note_any_bugs_here}

#-


#  Get arguments.

   my ($file, $package) = @_;
   $package ||= "";

#  Get file extension.

   my ($ftype) = ($file =~ m%\.([^/.]*)$%);
   $ftype ||= '';

#  Open module source file.

   open FILE, $file
      or error "Failed to open $file\n",
         "Probably the index files in $indexdir are outdated or corrupted.\n";

#  In command line mode, print location of file to standard error.

   print STDERR "$locname\n" unless ($cgi);

   my ($body, $name, @names, $include, $sub, $copyright);

   if ($html) {

#     HTML mode: attempt to tag file.  Produce pseudo-HTML by calling
#     a language-specific tagging routine if one is defined for this
#     file type.

      my $pre;
      $ext = '';
      $ext = $1 if ($file =~ /\.([^.]+)$/);
      if (taggable $file) {
         eval { $tagged = &{$tagger{$ext}} (*FILE, $ext) };
         error "Internal: tagging error: $@" if ($@);

#     Turn the pseudo-HTML produced by the tagging routine into real
#     HTML.  This principally involves checking the hyperlink hrefs
#     and either turning them into proper references to the CGI script
#     (if they look like they will successfully refer) or removing
#     them (if they look spurious).

         my $failedhref = 0;
         $tagged =~ s{(<[^>]+>)}{
            &{
               sub {
                  %tag = parsetag $1;

                  if ($tag{'Start'} eq 'a') {
                     $failedhref = 0;

                     if ($name = $tag{'href'}) {
                        my $href;
                        if ($name =~ /^INCLUDE-(.*)/) {

#                          Include file: generate a type=file reference.

                           my $file = $1;
                           if ($file =~ /^[A-Z0-9_.-]*$/ &&
                              !$index{'file'}->get($file)) {
                              $file =~ tr/A-Z/a-z/;
                           }
                           if ($index{'file'}->get($file)) {
                              $href = "${scb}$file&amp;$package&amp;type=file";
                           }
                        }
                        else {

#                          Function reference: generate a type=func reference.

                           $loc = $index{'func'}->get($name);
                           if ($loc) {
                              if (index ($loc, $locname) >= 0) {
                                 $href = "#$name";
                              }
                              else {
                                 $href = "${scb}$name&amp;$package&amp;"
                                       . "type=func#$name";
                              }
                           }
                        }

#                       Either output hyperlink start tag, or bold start tag
#                       to show failed hyperlink.

                        if ($href) {
                           $failedhref = 0;
                           return "<a href='$href'>";
                        }
                        else {
                           $failedhref = 1;
                           return "<b>";
                        }
                     }
                  }

#                 Either output hyperlink end tag, or bold end tag if it
#                 was a failed hyperlink.

                  elsif ($tag{'End'} eq 'a') {
                     my $retval = $failedhref ? '</b>' : '</a>';
                     $failedhref = 0;
                     return $retval;
                  }
                  return $1;
               }
            }
         }ges;

#        Output header and tagged source.

         header $locname;
         print "<pre>\n";
         $intag = 'pre';
         print $tagged;
      }
      else {

#        No tagging routine available; output without tagging.
#        On the whole, binary files are output as their proper MIME
#        type if it can be identified (otherwise an 'unknown' type),
#        and text files are output as preformatted HTML with appropriate
#        header and footer text.  Text files are not mostly output as
#        their proper MIME types, since as source files, it's probably
#        the source that we want to see rather than, say executing an
#        application/x-tcl type script.  There are exceptions to this
#        rule of thumb as defined in the variable $mimeuse.

         my $mimeuse = join '|', qw/postscript html x-xbitmap x-xpixmap/;

#        Get MIME type.

         $mime = mimetype $ext;

         if (-T $file && $mime !~ /$mimeuse/o) {

#           Text file to output as preformatted HTML.

            header $locname, 'text/html';
            print "<xmp>\n";
            $intag = 'xmp';
         }
         else {

#           Other - output as own, or unknown, MIME type.

            $mime ||= 'application/unknown';
            header $locname, $mime;
         }

#        Output text of file.

         while (<FILE>) {
            print;
         }

      }

#     Output appropriate footer text.
#     The date calculation is Y2K compliant, as long as the underlying
#     operating system is (see documentation for the Perl localtime()
#     function).

      if ($intag) {
         print "</$intag>\n";
         my $year = 1900 + (localtime)[5];
         hprint "
            <hr><i>
            Copyright &copy; $year Central Laboratory of the Research Councils
            </i>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <a href=${scb}package=$package>$package</a>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <a href=$scb_top>SCB</a>
         " unless ($copyright);
         footer;
      }

   }

   else {

#     Output raw text to standard output.

      while (<FILE>) {
         print;
      }
   }

   close FILE;

}


########################################################################
sub docurl {

#+
#  Name:
#     docurl

#  Purpose:
#     Generate a URL for a Starlink document.

#  Language:
#     Perl 5

#  Invocation:
#     $url = docurl ($doc);

#  Description:
#     Generates a URL for a Starlink document.

#  Arguments:
#     $doc = string.
#        Name of Starlink document, e.g. 'sun188'.

#  Return value:
#     $url = string.
#        Uniform Resource Locator pointing to the document in question.

#  Notes:

#  Copyright:
#     Copyright (C) 1998 Central Laboratory of the Research Councils

#  Authors:
#     MBT: Mark Taylor (IoA, Starlink)
#     {enter_new_authors_here}

#  History:
#     05-OCT-1998 (MBT):
#       Initial revision.
#     {enter_further_changes_here}

#  Bugs:
#     {note_any_bugs_here}

#-

#  Get argument.

   $doc = shift;

#  Return URL.

   return "$htxserver/$doc.htx/$doc.html";
}


########################################################################
sub tidyup {

#+
#  Name:
#     tidyup

#  Purpose:
#     Tidy up on exit from source code browser CGI script.

#  Language:
#     Perl 5

#  Invocation:
#     tidyup;

#  Description:
#     If any temporary files have been created, remove them.  Since the
#     routines which create the temporary files also remove them, this
#     routine should only do work in an abnormal exit situation.

#  Arguments:

#  Return value:

#  Notes:

#  Copyright:
#     Copyright (C) 1998 Central Laboratory of the Research Councils

#  Authors:
#     MBT: Mark Taylor (IoA, Starlink)
#     {enter_new_authors_here}

#  History:
#     05-OCT-1998 (MBT):
#       Initial revision.
#     {enter_further_changes_here}

#  Bugs:
#     {note_any_bugs_here}

#-

   if ($hastmp) {
      chdir "/";
      rmrf $tmpdir if ($tmpfiles);
   }
}


########################################################################
sub error {

#+
#  Name:
#     error

#  Purpose:
#     Present error text and exit.

#  Language:
#     Perl 5

#  Invocation:
#     error $message [, $more];

#  Description:
#     Prints an error message in an appropriate format.
#
#     In CGI mode only it will print a (possibly verbose) error message
#     in HTML to standard output, which will end up as an explanatory
#     page of HTML presented to the user.
#
#     In any case it will print a terse error message to standard error.
#     In command-line mode this will be presented to the user.
#     In CGI mode this will probably be written to an httpd log file.

#  Arguments:
#     $message = string.
#        Terse error message.
#     $more = string (optional).
#        Additional explanatory text expanding on $message.

#  Return value:

#  Notes:

#  Copyright:
#     Copyright (C) 1998 Central Laboratory of the Research Councils

#  Authors:
#     MBT: Mark Taylor (IoA, Starlink)
#     {enter_new_authors_here}

#  History:
#     05-OCT-1998 (MBT):
#       Initial revision.
#     {enter_further_changes_here}

#  Bugs:
#     {note_any_bugs_here}

#-

#  Get arguments.

   my ($message, $more) = @_;

#  Perform any necessary tidying operations.

   tidyup;

#  Remove carriage returns from strings if they exist;

   chomp $message if $message;
   chomp $more if $more;

#  Print verbose message in HTML in CGI mode only.

   if ($cgi) {
      header "Error";
      print "<h1>Error</h1>\n";
      hprint "<b>$message</b>\n";
      hprint "<p>\n$more\n" if $more;
      footer;
   }

#  Output terse message to standard error and exit with error status.

   die "$self: $message\n";

}



########################################################################
sub header {

#+
#  Name:
#     header

#  Purpose:
#     Print HTML header.

#  Language:
#     Perl 5

#  Invocation:
#     header $title [, $mimetype];

#  Description:
#     If in CGI mode, the HTTP header info is printed.
#     If in HTML mode, and $mimetype is 'text/html' (the default), the
#     HEAD part of the HTML document is printed.

#  Arguments:
#     $title = string.
#        Title element of document.
#     $mimetype = string (optional).
#        MIME type of document.

#  Return value:

#  Notes:

#  Copyright:
#     Copyright (C) 1998 Central Laboratory of the Research Councils

#  Authors:
#     MBT: Mark Taylor (IoA, Starlink)
#     {enter_new_authors_here}

#  History:
#     05-OCT-1998 (MBT):
#       Initial revision.
#     {enter_further_changes_here}

#  Bugs:
#     {note_any_bugs_here}

#-

#  Get argument.

   my ($title, $mimetype) = @_;
   $mimetype ||= 'text/html';

#  Print header.

   if ($cgi) {
      print "Content-Type: $mimetype\n";
      print "Title: $title\n";
      print "\n";
   }

   if ($html && $mimetype eq 'text/html') {
      print '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">', "\n";
      print "<html>\n";
      print "<head><title>", demeta ($title), "</title></head>\n";
      print "<body>\n";
   }
}


########################################################################
sub footer {

#+
#  Name:
#     footer

#  Purpose:
#     Print footer of HTML text.

#  Language:
#     Perl 5

#  Invocation:
#     footer;

#  Description:
#     Ends HTML file.

#  Arguments:

#  Return value:

#  Notes:

#  Copyright:
#     Copyright (C) 1998 Central Laboratory of the Research Councils

#  Authors:
#     MBT: Mark Taylor (IoA, Starlink)
#     {enter_new_authors_here}

#  History:
#     05-OCT-1998 (MBT):
#       Initial revision.
#     {enter_further_changes_here}

#  Bugs:
#     {note_any_bugs_here}

#-

#  Print HTML footer.

   print "</body>\n</html>\n" if $html;
}


########################################################################
sub getdoctitles {

#+
#  Name:
#     getdoctitles

#  Purpose:
#     Reads the docs_lis file to determine the titles of Starlink documents.

#  Language:
#     Perl 5

#  Invocation:
#     $rdoctitles = getdoctitles;

#  Description:
#     Reads the standard docs_lis file, whose filename is stored in the
#     global variable $docslisfile (usually /star/docs/docs_lis) to
#     generate a hash of all the titles of the Starlink documents
#     keyed by the document ids (e.g. sun221 => "KAPPA for IRAF").
#     If the file named in $docslisfile does not exist or cannot be
#     opened the routine simply returns a reference to an empty hash.

#  Arguments:
#     None.

#  Return value:
#     \%doctitles = reference to hash.
#        The hash contains title text keyed by document name (lower case
#        document type followed by the number without leading zeroes),
#        e.g. (sun221 => "KAPPA for IRAF").

#  Notes:
#     Clearly, this routine relies heavily on the docs_lis file having
#     the right format, and is best understood by examining the form
#     of that file.

#  Copyright:
#     Copyright (C) 1998 Central Laboratory of the Research Councils

#  Authors:
#     MBT: Mark Taylor (IoA, Starlink)
#     {enter_new_authors_here}

#  History:
#     03-NOV-1998 (MBT):
#       Initial revision.
#     {enter_further_changes_here}

#  Bugs:
#     {note_any_bugs_here}

#-

#  Declare local variables.

   my (%doctitles, $id, $title);

#  Attempt to open file containing information, otherwise return.

   open DOCSLIS, $docslisfile or return {};

#  Go through file looking for a line introducing information for documents
#  of a given type (SC, SG, SGP, SSN, SUN).

   while (<DOCSLIS>) {
      $doctype = (split)[0] || '';
      if ($doctype =~ /^(SC|SG|SGP|SSN|SUN)$/) {

#        Lines in this stanza each describe a single document.  Field
#        zero is of the form "document_number.revision_number", and
#        everything after field three is the text of the title.

         while (<DOCSLIS>) {

#           A blank line indicates the end of this stanza - exit the loop.

            last if (/^\s*$/);
            @words = split ' ', $_;
            $id = lc ($doctype) . int $words[0];
            $title = join (' ', splice (@words, 4));
            $doctitles{$id} = $title;
         }
      }
   }

#  Return reference to title hash.

   return \%doctitles;
}


########################################################################
sub mimetype {

#+
#  Name:
#     mimetype

#  Purpose:
#     Map file extension to MIME type.

#  Language:
#     Perl 5

#  Invocation:
#     $type = mimetype $extension;

#  Description:
#     Uses the file $mimetypes_file to get a MIME type for a file with
#     a given extension.  This is the way HTTP servers generate MIME
#     types for serving documents in absence of better information.

#  Arguments:
#     $extension = string.
#        Filename extension (the part after the last dot).

#  Return value:
#     $type = string.
#        MIME type if one can be located, otherwise ''.

#  Notes:
#     Subject of course to the completeness of the $mimetypes_file.

#  Copyright:
#     Copyright (C) 1998 Central Laboratory of the Research Councils

#  Authors:
#     MBT: Mark Taylor (IoA, Starlink)
#     {enter_new_authors_here}

#  History:
#     05-OCT-1998 (MBT):
#       Initial revision.
#     {enter_further_changes_here}

#  Bugs:
#     {note_any_bugs_here}

#-

#  Get argument.

   my $extension = shift;

#  Check through $mimetypes_file looking for the requested file extension.
#  If it is found, return with the corresponding MIME type.

   if (open MIMETYPES, $mimetypes_file) {
      my ($type, @ext, $ext);
      while (<MIMETYPES>) {
         ($type, @ext) = split (/\s+/, $_);
         foreach $ext (@ext) {
            return $type if ($ext eq $extension);
         }
      }
   }
   else {

#     If $mimetypes_file could not be found, log a non-fatal error.
#     We can still proceed without the MIME type.

      print STDERR "Failed to open mime.types file '$mimetypes_file'\n";
   }

#  Return empty string if no successful match was made.

   return '';
}


########################################################################
sub demeta {

#+
#  Name:
#     demeta

#  Purpose:
#     Encodes HTML metacharacters as HTML entities.

#  Language:
#     Perl 5

#  Invocation:
#     $htmlstring = demeta $textstring;

#  Description:
#     Turns a string of plain text, or of HTML, into a string of HTML.
#     There are certain characters ('<', '>' and '&') which have special
#     meaning in HTML and ought not to appear representing themselves.
#     This routine encodes them as entities ('&lt;', '&gt;' and '&amp;')
#     proper to HTML.
#     Additionally, if any of these entities exists in the original
#     string it is converted to the metacharacter prior to encoding,
#     so that you don't get doubly encoded strings (like '&amp;lt;').
#     There are pathological cases in which you don't want this
#     decoding prior to encoding, but the routine will practically
#     always do what you want it to.

#  Arguments:
#     $string = string.
#        Raw text.

#  Return value:
#     $string = string.
#        HTML encoded text.

#  Notes:

#  Copyright:
#     Copyright (C) 1998 Central Laboratory of the Research Councils

#  Authors:
#     MBT: Mark Taylor (IoA, Starlink)
#     {enter_new_authors_here}

#  History:
#     05-OCT-1998 (MBT):
#       Initial revision.
#     {enter_further_changes_here}

#  Bugs:
#     {note_any_bugs_here}

#-

#  Get argument.

   my $string = shift;

#  Decode any metacharacters in original string.

   $string =~ s/&lt;/</g;
   $string =~ s/&gt;/>/g;
   $string =~ s/&amp;/&/g;

#  Encode any metacharacters in string.

   $string =~ s/&/&amp;/g;
   $string =~ s/>/&gt;/g;
   $string =~ s/</&lt;/g;

#  Return encoded string.

   return $string;
}

########################################################################
sub hprint {

#+
#  Name:
#     hprint

#  Purpose:
#     Print text.

#  Language:
#     Perl 5

#  Invocation:
#     hprint $text

#  Description:
#     This simply prints a string after first stripping leading
#     whitespace from the start of each line.  The only purpose of
#     using this routine is so that text can easily be written in
#     a tidily indented fashion in the Perl source code, without
#     resulting in a lot of (syntactically insignificant) whitespace
#     in the output HTML.

#  Arguments:

#  Return value:

#  Notes:

#  Copyright:
#     Copyright (C) 1998 Central Laboratory of the Research Councils

#  Authors:
#     MBT: Mark Taylor (IoA, Starlink)
#     {enter_new_authors_here}

#  History:
#     05-OCT-1998 (MBT):
#       Initial revision.
#     {enter_further_changes_here}

#  Bugs:
#     {note_any_bugs_here}

#-

#  Get argument.

   local $_;

   while ($_ = shift) {

#     Strip leading whitespace from each line.

      s%^\s*%%mg;

#     Print stripped text.

      print;
   }
}

# $Id$
