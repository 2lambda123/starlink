\documentclass[twoside,11pt]{article}

% ? Specify used packages
% \usepackage{graphicx}        %  Use this one for final production.
% \usepackage[draft]{graphicx} %  Use this one for drafting.
% ? End of specify used packages

\pagestyle{myheadings}

% -----------------------------------------------------------------------------
% ? Document identification
% Fixed part
\newcommand{\stardoccategory}  {Starlink System Note}
\newcommand{\stardocinitials}  {SSN}
\newcommand{\stardocsource}    {ssn\stardocnumber}

% Variable part - replace [xxx] as appropriate.
\newcommand{\stardocnumber}    {[number].[version]}
\newcommand{\stardocauthors}   {M. B. Taylor}
\newcommand{\stardocdate}      {19 October 1998}
\newcommand{\stardoctitle}     {SCB - Starlink Source Code browser}
\newcommand{\stardocabstract}  {
This document describes the installation and use of SCB, 
the Starlink Source Code Browser.  
The package consists of two parts, an indexer program and an
extractor program.
The indexer need only be run infrequently (when the source code collection
changes), and the extractor can be run to extract a source file
by file- or function-name, either in plain text to the command line,
or in HTML including hyperlinks to called routines to be viewed
using a WWW browser.  In the latter case, the extractor program 
must be installed as a CGI script.
}
% ? End of document identification
% -----------------------------------------------------------------------------

% +
%  Name:
%     ssn.tex
%
%  Purpose:
%     Template for Starlink System Note (SSN) documents.
%     Refer to SUN/199
%
%  Authors:
%     AJC: A.J.Chipperfield (Starlink, RAL)
%     BLY: M.J.Bly (Starlink, RAL)
%     PWD: Peter W. Draper (Starlink, Durham University)
%     MBT: Mark Taylor (Starlink, IoA)
%
%  History:
%     17-JAN-1996 (AJC):
%        Original with hypertext macros, based on MDL plain originals.
%     16-JUN-1997 (BLY):
%        Adapted for LaTeX2e.
%     13-AUG-1998 (PWD):
%        Converted for use with LaTeX2HTML version 98.2 and
%        Star2HTML version 1.3.
%     19-OCT-1998 (MBT):
%        Text added for SCB.
%     {Add further history here}
%
% -

\newcommand{\stardocname}{\stardocinitials /\stardocnumber}
\markboth{\stardocname}{\stardocname}
\setlength{\textwidth}{160mm}
\setlength{\textheight}{230mm}
\setlength{\topmargin}{-2mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\setlength{\unitlength}{1mm}

% -----------------------------------------------------------------------------
%  Hypertext definitions.
%  ======================
%  These are used by the LaTeX2HTML translator in conjunction with star2html.

%  Comment.sty: version 2.0, 19 June 1992
%  Selectively in/exclude pieces of text.
%
%  Author
%    Victor Eijkhout                                      <eijkhout@cs.utk.edu>
%    Department of Computer Science
%    University Tennessee at Knoxville
%    104 Ayres Hall
%    Knoxville, TN 37996
%    USA

%  Do not remove the %begin{latexonly} and %end{latexonly} lines (used by 
%  LaTeX2HTML to signify text it shouldn't process).
%begin{latexonly}
\makeatletter
\def\makeinnocent#1{\catcode`#1=12 }
\def\csarg#1#2{\expandafter#1\csname#2\endcsname}

\def\ThrowAwayComment#1{\begingroup
    \def\CurrentComment{#1}%
    \let\do\makeinnocent \dospecials
    \makeinnocent\^^L% and whatever other special cases
    \endlinechar`\^^M \catcode`\^^M=12 \xComment}
{\catcode`\^^M=12 \endlinechar=-1 %
 \gdef\xComment#1^^M{\def\test{#1}
      \csarg\ifx{PlainEnd\CurrentComment Test}\test
          \let\html@next\endgroup
      \else \csarg\ifx{LaLaEnd\CurrentComment Test}\test
            \edef\html@next{\endgroup\noexpand\end{\CurrentComment}}
      \else \let\html@next\xComment
      \fi \fi \html@next}
}
\makeatother

\def\includecomment
 #1{\expandafter\def\csname#1\endcsname{}%
    \expandafter\def\csname end#1\endcsname{}}
\def\excludecomment
 #1{\expandafter\def\csname#1\endcsname{\ThrowAwayComment{#1}}%
    {\escapechar=-1\relax
     \csarg\xdef{PlainEnd#1Test}{\string\\end#1}%
     \csarg\xdef{LaLaEnd#1Test}{\string\\end\string\{#1\string\}}%
    }}

%  Define environments that ignore their contents.
\excludecomment{comment}
\excludecomment{rawhtml}
\excludecomment{htmlonly}

%  Hypertext commands etc. This is a condensed version of the html.sty
%  file supplied with LaTeX2HTML by: Nikos Drakos <nikos@cbl.leeds.ac.uk> &
%  Jelle van Zeijl <jvzeijl@isou17.estec.esa.nl>. The LaTeX2HTML documentation
%  should be consulted about all commands (and the environments defined above)
%  except \xref and \xlabel which are Starlink specific.

\newcommand{\htmladdnormallinkfoot}[2]{#1\footnote{#2}}
\newcommand{\htmladdnormallink}[2]{#1}
\newcommand{\htmladdimg}[1]{}
\newcommand{\hyperref}[4]{#2\ref{#4}#3}
\newcommand{\htmlref}[2]{#1}
\newcommand{\htmlimage}[1]{}
\newcommand{\htmladdtonavigation}[1]{}

\newenvironment{latexonly}{}{}
\newcommand{\latex}[1]{#1}
\newcommand{\html}[1]{}
\newcommand{\latexhtml}[2]{#1}
\newcommand{\HTMLcode}[2][]{}

%  Starlink cross-references and labels.
\newcommand{\xref}[3]{#1}
\newcommand{\xlabel}[1]{}

%  LaTeX2HTML symbol.
\newcommand{\latextohtml}{\LaTeX2\texttt{HTML}}

%  Define command to re-centre underscore for Latex and leave as normal
%  for HTML (severe problems with \_ in tabbing environments and \_\_
%  generally otherwise).
\renewcommand{\_}{\texttt{\symbol{95}}}

% -----------------------------------------------------------------------------
%  Debugging.
%  =========
%  Remove % on the following to debug links in the HTML version using Latex.

% \newcommand{\hotlink}[2]{\fbox{\begin{tabular}[t]{@{}c@{}}#1\\\hline{\footnotesize #2}\end{tabular}}}
% \renewcommand{\htmladdnormallinkfoot}[2]{\hotlink{#1}{#2}}
% \renewcommand{\htmladdnormallink}[2]{\hotlink{#1}{#2}}
% \renewcommand{\hyperref}[4]{\hotlink{#1}{\S\ref{#4}}}
% \renewcommand{\htmlref}[2]{\hotlink{#1}{\S\ref{#2}}}
% \renewcommand{\xref}[3]{\hotlink{#1}{#2 -- #3}}
%end{latexonly}
% -----------------------------------------------------------------------------
% ? Document specific \newcommand or \newenvironment commands.
% ? End of document specific commands
% -----------------------------------------------------------------------------
%  Title Page.
%  ===========
\renewcommand{\thepage}{\roman{page}}
\begin{document}
\thispagestyle{empty}

%  Latex document header.
%  ======================
\begin{latexonly}
   CCLRC / {\textsc Rutherford Appleton Laboratory} \hfill {\textbf \stardocname}\\
   {\large Particle Physics \& Astronomy Research Council}\\
   {\large Starlink Project\\}
   {\large \stardoccategory\ \stardocnumber}
   \begin{flushright}
   \stardocauthors\\
   \stardocdate
   \end{flushright}
   \vspace{-4mm}
   \rule{\textwidth}{0.5mm}
   \vspace{5mm}
   \begin{center}
   {\Large\textbf \stardoctitle}
   \end{center}
   \vspace{5mm}

% ? Heading for abstract if used.
   \vspace{10mm}
   \begin{center}
      {\Large\textbf Abstract}
   \end{center}
% ? End of heading for abstract.
\end{latexonly}

%  HTML documentation header.
%  ==========================
\begin{htmlonly}
   \xlabel{}
   \begin{rawhtml} <H1 ALIGN=CENTER> \end{rawhtml}
      \stardoctitle
   \begin{rawhtml} </H1> <HR> \end{rawhtml}

   \begin{rawhtml} <P> <I> \end{rawhtml}
   \stardoccategory\ \stardocnumber \\
   \stardocauthors \\
   \stardocdate
   \begin{rawhtml} </I> </P> <H3> \end{rawhtml}
      \htmladdnormallink{CCLRC}{http://www.cclrc.ac.uk} /
      \htmladdnormallink{Rutherford Appleton Laboratory}
                        {http://www.cclrc.ac.uk/ral} \\
      \htmladdnormallink{Particle Physics \& Astronomy Research Council}
                        {http://www.pparc.ac.uk} \\
   \begin{rawhtml} </H3> <H2> \end{rawhtml}
      \htmladdnormallink{Starlink Project}{http://star-www.rl.ac.uk/}
   \begin{rawhtml} </H2> \end{rawhtml}
   \htmladdnormallink{\htmladdimg{source.gif} Retrieve hardcopy}
      {http://star-www.rl.ac.uk/cgi-bin/hcserver?\stardocsource}\\

%  HTML document table of contents. 
%  ================================
%  Add table of contents header and a navigation button to return to this 
%  point in the document (this should always go before the abstract \section). 
  \label{stardoccontents}
  \begin{rawhtml} 
    <HR>
    <H2>Contents</H2>
  \end{rawhtml}
  \htmladdtonavigation{\htmlref{\htmladdimg{contents_motif.gif}}
        {stardoccontents}}

% ? New section for abstract if used.
  \section{\xlabel{abstract}Abstract}
% ? End of new section for abstract

\end{htmlonly}

% -----------------------------------------------------------------------------
% ? Document Abstract. (if used)
%  ==================
\stardocabstract
% ? End of document abstract
% -----------------------------------------------------------------------------
% ? Latex document Table of Contents (if used).
%  ===========================================
  \newpage
  \begin{latexonly}
    \setlength{\parskip}{0mm}
    \tableofcontents
    \setlength{\parskip}{\medskipamount}
    \markboth{\stardocname}{\stardocname}
  \end{latexonly}
% ? End of Latex document table of contents
% -----------------------------------------------------------------------------
\cleardoublepage
\renewcommand{\thepage}{\arabic{page}}
\setcounter{page}{1}

% ? Main text

\section{Introduction}

The USSC consists of a few million lines of source code, mainly in 
Fortran 77 and C. 
Finding the source code of interest given the name of a
user task, a function, or even a source file can be non-trivial;
the name of the file containing a routine definition,
the package/directory/tar archive in which the file resides,
and the position in the file at which the routine is defined
may all be difficult pieces of information to obtain if one is
unfamiliar with the package in question.

This package seeks to enable fast navigation around the USSC 
source code in two ways.  In the first place it can locate a routine
or file based on an explicit user query (giving the exact or
approximate name of the routine or file and optionally the Starlink 
package in which it resides).  In the second place, it can present
the source code as HTML, suitable for viewing with any WWW browser,
with references to external routines presented as hyperlinks so
that call chains can be followed conveniently.
This second mode of use is clearly much more powerful than the first.

There are two principle components of the system: an indexing program
which is run once to locate and store all the files and routine 
definitions, and subsequently only when the source code is changed,
and an extractor program which interrogates the index to locate 
and output a requested file.

Typically the index
will be generated by the system manager and stored centrally,
and the extractor installed
as a CGI script to serve HTML over the network (if security is 
a concern it is possible to restrict access to local users in the
usual ways).  Simultanously, local users will be able to locate
or extract source files from the command line without using the 
WWW interface.  
There are other possibilities however: the extractor need not be
installed as a CGI script at all so that only command-line use
is available, and users may have their own private indices 
which combine some or all of the main source code collection 
with their own development versions of packages.

The remainder of this document describes installation and use of
the package, and some details of its internal operation.




\section{Installation and setup}

\subsection{Installing the software}

The files comprising SCB should be obtained and installed into
the Starlink tree in more or less the usual way.
However, there are some environment variables which affect the
installation, determining for instance the location of the 
indices, the Perl binary and temporary directories.  
All default to sensible values, and the most important ones
are described below, but the comments in the
{\tt mk} script should be read and modifications made,
or environment variables set, accordingly.

Some of the environment variables can be used in two ways:
when set before building the package (the {\tt mk build} step)
they modify the default behaviour of the programs any time they are run.  
If the environment variables are set when the programs are being
run however, this value overrides the defaults set at build time.
These variables are:
\begin{description}
\item[SCB\_SOURCES]
The directory containing the Starlink source code.  
This directory must contain nothing but Starlink source packages,
each of which must be {\em either\/} in a directory named after the package
{\em or\/} in a tar file named {\tt package.tar}, optionally compressed
using {\tt compress} or {\tt gzip} (and named with a suffix .Z or .gz 
respectively).
The former of these is the usual format if the sources are in
their usual location, {\tt /star/sources}.
If undefined at build time and run time, SCB\_SOURCES 
defaults to {\tt /star/sources}.
\item[SCB\_INDEX]
The directory containing the index files (around 5\,Mbyte for the full
Starlink source collection).
If undefined at run time and build time, SCB\_INDEX defaults to
{\tt /star/etc/scb}.
\item[SCB\_BROWSER\_TMP]
The directory used by the browser program to store temporary files. 
If undefined at run time and build time, SCB\_BROWSER\_TMP defaults to
{\tt /usr/tmp/scb}.
\item[SCB\_INDEXER\_TMP]
The directory used by the indexer program to store temporary files. 
If undefined at run time and build time, SCB\_INDEXER\_TMP defaults to
{\tt /usr/tmp/scb}.
\end{description}

An example site installation might go as follows:
\begin{quote}
\begin{verbatim}
% zcat scb.tar.Z | tar xf -
% setenv PERL5 /usr/bin/perl
% setenv SCB_BROWSER_TMP /scratch/scb/browser
% setenv SCB_INDEXER_TMP /scratch/scb/indexer
% setenv INSTALL /star
% mk build
    ...
% mk install
    ...
% mk test
    ...
*** Installation test for the SCB package has been run
\end{verbatim}
\end{quote}


\subsection{\label{sec:install-cgi}Installing the CGI script}

In order to use this package to browse source code using a
World Wide Web browser, the browser script {\tt scb.pl}
must be installed as a CGI (Common Gateway Interface) program
on a computer running an HTTP server.  
For this purpose, the browser script is copied by the package
installation process (the {\tt mk install} step) 
into \$INSTALL{\tt /bin/cgi} as well as into \$INSTALL{\tt /bin}.

A full discussion of the setup of CGI programs is
beyond the scope of this document, but by way of example, 
if the HTTP server being used is 
\htmladdnormallink{Apache}{http://www.apache.org/}, 
it will typically 
be necessary to
add a stanza like the following to Apache's {\tt conf/access.conf} file:
\begin{quote}
\begin{verbatim}
<Directory /star/bin/cgi>
Options ExecCGI
</Directory>
\end{verbatim}
\end{quote}
and a line like the following to the {\tt conf/srm.conf} file:
\begin{quote}
\begin{verbatim}
ScriptAlias /star/cgi-bin/ /star/bin/cgi/
\end{verbatim}
\end{quote}
Setting up the CGI program can usually only 
be done by the system manager.

Every attempt has been made to make the CGI script secure against
abuse by users of the browsing facility, but anybody setting it 
up on their machines should be aware
that provision of any CGI program is risky for the server involved.
It should also be noted that the browser 
program can use significant system resources which might 
make it possible for users of the service intentionally or 
unintentionally to degrade performance of the server.
In particular, heavy use may be made of the following resources:
\begin{itemize}
\item {\bf CPU time}: 
Parsing source files to add the HTML tags is done on the fly by 
the browser program, and while for most of the source files this 
is quite fast, for some of the very large files it can 
take a matter of seconds or even minutes.
\item {\bf Memory}:
Again the parsing can take a significant amount of memory when the
file to be parsed is very large.
\item {\bf Temporary disk space}:
Temporary files will created in the SCB\_BROWSER\_TMP directory
if it is necessary to unpack tar archives.  The problem is most acute
when tar files are contained in other tar files (usually only the
case if the source archives are stored as tar files themselves,
rather than unpacked as is more usual).  
If all the tar files within the source archive are unpacked in place,
for instance using a sequence like 
\begin{quote}
\begin{verbatim}
setenv SCB_SOURCES /star/sources
foreach tarfile (`find $SCB_SOURCES -name \*.tar -print`)
   cd $tarfile:h
   tar xf $tarfile:t
end
\end{verbatim}
\end{quote}
then no temporary disk space will be used, and much reduced disk
activity will be required by the browser program.
The disadvantage of doing this is increased use of disk space
in the SCB\_SOURCES directory 
(by around 220MB for the full unbuilt USSC), 
and also slower running of the
indexer program (since it checks all files outside of the tar files
as well as all files inside them).
\end{itemize}





\subsection{\label{sec:indexing} Generating the index}

In order for the browser to work, indexes of the source files must be
generated.  This is done by the script {\tt scbindex.pl}, installed
by default in {\tt /star/bin}.
The following subsections explain how to use this command to
build an index.  In most cases, only an index of the whole Starlink
collection will be required, but people modifying or developing
their own copies of packages may wish to generate a personalised index.


\subsubsection{Indexing the whole Starlink collection}

To index the whole of the source collection, simply invoke the 
indexer program as follows:
\begin{quote}
\begin{verbatim}
% scbindex.pl
\end{verbatim}
\end{quote}
This will 
read the source files from the directory specified in SCB\_SOURCES, 
write the index files to the directory specified in SCB\_INDEX,
and print to the screen each index entry as it is encountered.
If the entire Starlink source code collection is installed, 
this will take a matter of hours.  Some indication of how far the indexing
has progressed can be seen by seeing which package is currently
being indexed (the name is given before the `\#' sign on the 
printed lines, e.g. lines which look like
\begin{quote}
\begin{verbatim}
cmp_activ.f          =>  hds#hds_source.tar>cmp_activ.f
cmp_blk.f            =>  hds#hds_source.tar>cmp_blk.f
cmp_cct              =>  hds#hds_source.tar>cmp_cct
\end{verbatim}
\end{quote}
indicate that the HDS package is being indexed).
The packages are dealt with in alphabetical order, so by seeing how 
far the package currently being examined is through the list of files
in the directory SCB\_SOURCES you can get a rough idea of how much remains
to be done.

If only one or a few packages have been changed
since the last indexing,
then the index can be updated rather than being regenerated from scratch.
In this case only the changed packages are named on the command line,
e.g.
\begin{quote}
\begin{verbatim}
% scbindex.pl ast polpack ndf
\end{verbatim}
\end{quote}
The packages so named will be taken from the SCB\_SOURCES directory in
the same way as if the whole source tree is being indexed.

Since the indexing can take a long time, it will probably be preferable to 
run it in the background, possibly {\tt renice}d, with the output
redirected elsewhere, e.g.:
\begin{quote}
\begin{verbatim}
% nice +4 scbindex.pl >& scbindex.log &
\end{verbatim}
\end{quote}
If the machine will be used by other people while the indexing 
is running, then you should seek advice from your system manager 
about the nice level that ought to be used.

While the indexing is taking place, the index files {\it may} 
(depending on the implementation of the database libraries on
your system)
be unreadable, so that the browser program ceases to work.
To maintain the browser service during an update of the index in this
case, it will be necessary to update a copy, and write it over the
original when it is complete, like this:
\begin{quote}
\begin{verbatim}
% setenv SCB_INDEX /usr/tmp/tmp_index
% mkdir $SCB_INDEX
% cp /star/etc/scb/* $SCB_INDEX
% scbindex.pl pack1 pack2
% cp $SCB_INDEX/* /star/etc/scb
\end{verbatim}
\end{quote}

Occasionally some non-fatal error messages will be generated in the 
course of the indexing, for instance:
\begin{quote}
\begin{verbatim}
Use of uninitialized value at FortranTag.pm line 456, <SOURCE> chunk 42.
\end{verbatim}
\end{quote}
These indicate that an error has occurred during the indexing process,
but unless they appear very many times can be safely ignored.
If the program stops with an error however, it should be investigated.
The error message in this case should give an indication of what has
gone wrong and how to fix it.


\subsubsection{Creating a personalised index}

As well as examining all the source files from their natural home
in the main Starlink source tree (the SCB\_SOURCES directory),
it is also possible to index source code from elsewhere, 
by giving the pathname of the directory
or tarfile containing the source.
In this way a personalised index can be created: 
suppose you have a personal source copy (under development say) of 
Figaro, you can execute the following sequence:
\begin{quote}
\begin{verbatim}
% setenv SCB_SOURCES /star/sources
% setenv SCB_INDEX ~/star/etc/scb
% scbindex.pl
% scbindex.pl ~/star/sources/figaro
\end{verbatim}
\end{quote}
--- the first invocation of {\tt scbindex.pl} 
creates an index of the main body
of Starlink source code, and the second one
replaces the entries relating to the Figaro package 
with those in your personal copy.
If the modified sources are instead in a compressed tar file in the current
directory, the last line above could be replaced by
\begin{quote}
\begin{verbatim}
% scbindex.pl ./figaro.tar.Z
\end{verbatim}
\end{quote}
Note that for this usage of {\tt scbindex.pl} at least one `/' character
must appear in the package name, otherwise it will be interpreted
as a reference to the copy of the package in the SCB\_SOURCES directory.
The personalised index files will be written in the SCB\_INDEX directory.


\section{Viewing the source code}

This section explains how to use the extractor program, {\tt scb.pl},
to view source code from the Starlink source tree,
assuming that an index has been built as explained in 
section \ref{sec:indexing}.
The browser system tries to come up with the requested section of
source code, but for one reason and another sometimes fails to 
do so.  
For more insight into why it behaves as it does, and 
how it might be coaxed into behaving otherwise, 
section \ref{sec:internals} gives some explanation of how the
indexing and extraction is done.


\subsection{Command line operation}

However the package has been installed, it should be 
possible to use the extractor program, {\tt scb.pl},
to view the source code from the Unix shell.

\subsubsection{Basic use}

At its simplest, this is simply done by giving the 
requested filename or routine as an argument to the extractor:
\begin{quote}
\begin{verbatim}
% scb.pl dsa_data_size
\end{verbatim}
\end{quote}
finds the file which contains the routine `{\tt dsa\_data\_size}'
and prints it to standard output.  It also
prints to standard error the location of this file.
The file can therefore be viewed using {\tt more}, or printed,
or saved to a local file, or searched with {\tt grep}, or
generally used in the usual Unix ways.
For instance to save it to a local file {\tt file.f}:
\begin{quote}
\begin{verbatim}
% scb.pl dsa_data_size >file.f
figaro#figaro_dsa.tar>dsa/dsa_dat_sz.f
\end{verbatim}
\end{quote}
the second line here is the line printed to standard error 
by the program indicating the file in which the routine was found;
it means that the file is part of the package FIGARO,
is contained in the tar archive {\tt figaro\_dsa.tar}, and
within that archive is called {\tt dsa/dsa\_dat\_sz.f}.
Files can be extracted by their filename instead,
so that
\begin{quote}
\begin{verbatim}
% scb.pl dsa_dat_sz.f >file.f
figaro#figaro_dsa.tar>dsa/dsa_dat_sz.f
\end{verbatim}
\end{quote}
has exactly the same effect as the former example.

Routine names are indexed by the names the Unix linker gives them.
For C functions, this means the name of the function as in the 
source code should be used.
For Fortran functions and subroutines however, the indexed name is 
formed by appending an underscore to the lower case name of the 
routine.  
If the underscore is omitted however, and no routine by that name
can be found the extractor program will look for a routine with
the underscore appended.


\subsubsection{`{\tt package}' argument}

If the extractor can find a Fortran subroutine or function, 
or a C function or macro definition with the name supplied on
the command line, it will extract the relevant source file.
However it is sometimes necessary to restrict the search
further, since there may be more than one source file answering
to that description.  So it is also possible to specify the
package in which you expect to find the file or routine. 
For instance, there is one file called `{\tt help.f}' in
package HLP and another in POLMAP.  
To ensure that you get the one in HLP, specify it on the 
command line using the `{\tt package=}' argument:
\begin{quote}
\begin{verbatim}
% scb.pl help.f package=hlp
\end{verbatim}
\end{quote}
Note that the package argument only serves as a hint to the
extractor program: if the requested file/routine occurs in the
specified package, then that one is retrieved.  If it does not,
but it does exist in another package, then that one is retrieved.
Thus
\begin{quote}
\begin{verbatim}
% scb.pl help.f package=ccdpack
\end{verbatim}
\end{quote}
and 
\begin{quote}
\begin{verbatim}
% scb.pl help.f
\end{verbatim}
\end{quote}
will give the same result, which is one or other of the {\tt help.f}
files from either POLMAP or HLP (picked more or less at random).

The `{\tt package=}' part may be omitted, so that 
\begin{quote}
\begin{verbatim}
`{\tt scb.pl help.f hlp}'
\end{verbatim}
\end{quote}
is equivalent to 
\begin{quote}
\begin{verbatim}
`{\tt scb.pl help.f package=hlp}'.
\end{verbatim}
\end{quote}


\subsubsection{`{\tt type}' argument, and pattern matching}

It is also possible to specify whether the requested search
term is a routine/function or a file, by specifying `{\tt type=func}'
or `{\tt type=file}' respectively on the command line.  This is not
normally necessary, since the names of functions rarely clash with
the names of routines.

A third possibility is `{\tt type=regex}', in which case the 
search term is interpreted as a case-insensitive 
Perl regular expression, and
all functions and all files are searched for matches.
All the matching terms, along with file locations, are then printed out
(first files, then routines).
In this case no source file is extracted.
The same format of regular expression as used by the Unix {\tt grep}
utility can be used 
(although the many additional pattern matching facilities
offered by Perl are also allowed).
Thus to find, for instance, the locations of 
all the files and routines whose names contain `fit' followed
by `gauss', the following command can be used:
\begin{quote}
\begin{verbatim}
% scb.pl 'fit.*gauss' type=regex

Files:
ech_fit_gaussian.f       => echomop#echomop_source.tar>ech_fit_gaussian.f
fitgauss.f               => figaro#figaro_appca.tar>appca/fitgauss.f
fitgauss.ifl             => figaro#figaro_source.tar>fitgauss.ifl
sculib_fit_2d_gaussian.f => surf#surf_sculib.tar>sculib_fit_2d_gaussian.f
fit_mgauss.f             => twodspec#twodspec_opt.tar>opt/fit_mgauss.f

Routines:
ech_fit_gaussian_        => echomop#echomop_source.tar>ech_fit_gaussian.f
fitgauss_                => figaro#figaro_appca.tar>appca/fitgauss.f
sculib_fit_2d_gaussian_  => surf#surf_sculib.tar>sculib_fit_2d_gaussian.f
fit_mgauss_              => twodspec#twodspec_opt.tar>opt/fit_mgauss.f
\end{verbatim}
\end{quote}


\subsubsection{Command line flags}

There are two command line flags which can be supplied to {\tt scb.pl}.
Neither is required very often, but they are documented here for completeness.
\begin{itemize}
\item {\bf -html}
If the `{\tt -html}' flag is included on the command line, 
then HTML is written, in the same way as if the extractor were
being invoked as a CGI script.  This is not particularly useful,
except for debugging purposes.
\item {\bf -exact}
Normally the extractor program, if it fails to find the file or
function exactly as specified, tries a few variations like appending
underscores or folding the case of the given argument.
If the {\tt -exact} flag is given then these variations are not attempted.
\end{itemize}




\subsection{Browsing using HTML}

If the extractor program {\tt scb.pl} has been installed
as a CGI program as described in section \ref{sec:install-cgi}
then the Starlink source code can be viewed as a set of 
hypertext pages hyperlinked together 
at function/subroutine calls or include files.
It should be fairly intuitive how to use the pages generated,
so the following discussion does not give exact instructions
but clears up a few points.
The best way to see how it works is to play around with it.

The URL of the source code browser will depend on exactly how
the installation has been performed, but it will look something
like {\tt http://host.domain/cgi-bin/star/scb.pl}.


\subsubsection{Locating a source file}

The top level page of the source code browser is a form
with the following parts:
\begin{itemize}
\item {\bf Name of item}:
The name of the file or function/subroutine to locate, or the search term.
\item {\bf Type of item}:
How to interpret the ``Name of item'' box.  Select one of:
\begin{itemize}
   \item {\bf Routine}:
   The item is a Fortran or C function or subroutine.
   This is case sensitive.
   For C use the name of the function exactly as it occurs in the source code.
   For Fortran, use the routine's name in lower case with an 
   underscore appended;
   however, if the case is wrong or the underscore is omitted the 
   browser will still probably 
   find the right routine.
   \item {\bf File}:
   The item is a filename.  This is case sensitive.
   \item {\bf Either}:
   The browser will try both of the above options (File and Routine).
   \item {\bf Search term}:
   The item name is a Perl 5 regular expression, interpreted case-insensitively;
   The browser will present a list of all the routines or filenames 
   which match it.
   For most practical purposes, Perl regular expressions are a superset
   of ordinary regular expressions, so they can be treated like the 
   argument of a `{\tt grep -i}' command.
   A case sensitive search can be achieved by prepending `(?-i)' to the
   regular expression; however this requires Perl 5.005.
\end{itemize}
\item {\bf Name of package (optional)}:
If one of the listed packages is selected, it serves
as a hint about where the file or routine being searched for might be.
It is used as follows: if a file or routine of the given name is found
in the package specified, then that one will be presented.
If it is not in that package, or if no package is specified, 
then any such item in the whole source tree will be presented.
In particular, this means that even when one package is specified here,
a routine from another package may be presented.
\end{itemize}

Instead of entering the name of the file or routine you wish to
see, you can browse the contents of a given package.
Below the form is a list of links to all the available packages.
Following one of these links (or equivalently selecting the package
name in the `Name of package' box without filling in the `Name of item'
field) will take you to a page giving more information about the 
package requested.
This will contain the same form at the top, 
but below it are links to files from the package grouped by category:
\begin{itemize}
\item {\bf Files}:
Links to every file in the package.
\item {\bf Routines}:
Links to every C and Fortran function and subroutine definition 
identified in the source files.
\item {\bf Starlink documents}:
Links to any SUNs and SSNs which form part of the package
(although not necessarily all those {\it relevant\/} to the package).
\item {\bf Tasks}:
Links to `tasks' in the package.
This is rather loosely defined, but it is intended to be
the names of commands which can be invoked from the Unix shell or ICL.
Because the way these are identified is rather ad hoc,
the list may be incomplete and/or contain spurious entries.
\end{itemize}
Sometimes the `Files' or `Routines' heading is a hyperlink to 
the actual lists of links, rather than having the list on the page.

Following any of the listed links 
will take you to one of the files in the package.

\subsubsection{Viewing a source file}

A file from a package is normally presented as text in the browser.
If it is C or Fortran source code, then each called function or
subroutine should be a hyperlink to the appropriate definition.
Similarly, included files (Fortran {\tt INCLUDE} or C {\tt \#include}) 
are hyperlinked to the right place.
If any part of the source text is in bold face,
this indicates that it ought to be a link,
but that the routine or file in question cannot be found. 
This can happen because the program has misinterpreted the source code,
or the index is out of date, or for other reasons.
The program tries to link to the correct place, 
but cannot guarantee to do so; for instance if there are two 
routines with the same name in different packages outside the
package containing the current file, the link might point to
the wrong one.
Most types of file other than C or Fortran source are 
simply presented as plain text, although some types
(e.g.\ postscript)
will be presented using a viewer appropriate to the type.

The title of the HTML document
(normally displayed in the title bar of your browser)
is the location of the file in 
the source tree.  The notation is quite easy to understand: 
it's like a Unix pathname except that
a `\#' sign denotes inclusion in a package, 
and a 
`\latex{$}>\latex{$}'
sign denotes inclusion in a tar file.
So for instance the location
\begin{quote}
\begin{verbatim}
figaro#figaro_dsa.tar>dsa/dsa_dat_sz.f
\end{verbatim}
\end{quote}
means that the file is part of the package FIGARO,
is contained in the tar archive {\tt figaro\_dsa.tar}, and
within that archive is called {\tt dsa/dsa\_dat\_sz.f}.

At the bottom of each file is a copyright notice.



% ? End of main text
\end{document}
