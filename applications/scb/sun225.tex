\documentclass[twoside,11pt]{article}

% ? Specify used packages
% \usepackage{graphicx}        %  Use this one for final production.
% \usepackage[draft]{graphicx} %  Use this one for drafting.
% ? End of specify used packages

\pagestyle{myheadings}

% -----------------------------------------------------------------------------
% ? Document identification
% Fixed part
\newcommand{\stardoccategory}  {Starlink User Note}
\newcommand{\stardocinitials}  {SUN}
\newcommand{\stardocsource}    {sun\stardocnumber}

% Variable part - replace [xxx] as appropriate.
\newcommand{\stardocnumber}    {225.1(Draft)}
\newcommand{\stardocauthors}   {M. B. Taylor}
\newcommand{\stardocdate}      {1 December 1998}
\newcommand{\stardoctitle}     {SCB --- Source Code Browser}
\newcommand{\stardocversion}   {1.0-0}
\newcommand{\stardocmanual}    {Use and installation guide}
\newcommand{\stardocabstract}  {
This document describes the installation and use of SCB, 
the Starlink Source Code Browser.  
The package consists of two parts, an indexer program and an
extractor program.
The indexer need only be run infrequently (when the source code collection
changes), and the extractor can be run to extract a source file
by file- or function-name, either in plain text to the command line,
or in HTML including hyperlinks to called routines, viewable
using a WWW browser.  In the latter case, the extractor program 
must be installed as a CGI script.
}
% ? End of document identification
% -----------------------------------------------------------------------------

% +
%  Name:
%     sun.tex
%
%  Purpose:
%     Template for Starlink User Note (SUN) documents.
%     Refer to SUN/199
%
%  Authors:
%     AJC: A.J.Chipperfield (Starlink, RAL)
%     BLY: M.J.Bly (Starlink, RAL)
%     PWD: Peter W. Draper (Starlink, Durham University)
%     MBT: Mark Taylor (Starlink, IoA)
%
%  History:
%     17-JAN-1996 (AJC):
%        Original with hypertext macros, based on MDL plain originals.
%     16-JUN-1997 (BLY):
%        Adapted for LaTeX2e.
%        Added picture commands.
%     13-AUG-1998 (PWD):
%        Converted for use with LaTeX2HTML version 98.2 and
%        Star2HTML version 1.3.
%     11-NOV-1998 (MBT):
%        Instantiated as SUN/225.
%     {Add further history here}
%
% -

\newcommand{\stardocname}{\stardocinitials /\stardocnumber}
\markboth{\stardocname}{\stardocname}
\setlength{\textwidth}{160mm}
\setlength{\textheight}{230mm}
\setlength{\topmargin}{-2mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\setlength{\unitlength}{1mm}

% -----------------------------------------------------------------------------
%  Hypertext definitions.
%  ======================
%  These are used by the LaTeX2HTML translator in conjunction with star2html.

%  Comment.sty: version 2.0, 19 June 1992
%  Selectively in/exclude pieces of text.
%
%  Author
%    Victor Eijkhout                                      <eijkhout@cs.utk.edu>
%    Department of Computer Science
%    University Tennessee at Knoxville
%    104 Ayres Hall
%    Knoxville, TN 37996
%    USA

%  Do not remove the %begin{latexonly} and %end{latexonly} lines (used by 
%  LaTeX2HTML to signify text it shouldn't process).
%begin{latexonly}
\makeatletter
\def\makeinnocent#1{\catcode`#1=12 }
\def\csarg#1#2{\expandafter#1\csname#2\endcsname}

\def\ThrowAwayComment#1{\begingroup
    \def\CurrentComment{#1}%
    \let\do\makeinnocent \dospecials
    \makeinnocent\^^L% and whatever other special cases
    \endlinechar`\^^M \catcode`\^^M=12 \xComment}
{\catcode`\^^M=12 \endlinechar=-1 %
 \gdef\xComment#1^^M{\def\test{#1}
      \csarg\ifx{PlainEnd\CurrentComment Test}\test
          \let\html@next\endgroup
      \else \csarg\ifx{LaLaEnd\CurrentComment Test}\test
            \edef\html@next{\endgroup\noexpand\end{\CurrentComment}}
      \else \let\html@next\xComment
      \fi \fi \html@next}
}
\makeatother

\def\includecomment
 #1{\expandafter\def\csname#1\endcsname{}%
    \expandafter\def\csname end#1\endcsname{}}
\def\excludecomment
 #1{\expandafter\def\csname#1\endcsname{\ThrowAwayComment{#1}}%
    {\escapechar=-1\relax
     \csarg\xdef{PlainEnd#1Test}{\string\\end#1}%
     \csarg\xdef{LaLaEnd#1Test}{\string\\end\string\{#1\string\}}%
    }}

%  Define environments that ignore their contents.
\excludecomment{comment}
\excludecomment{rawhtml}
\excludecomment{htmlonly}

%  Hypertext commands etc. This is a condensed version of the html.sty
%  file supplied with LaTeX2HTML by: Nikos Drakos <nikos@cbl.leeds.ac.uk> &
%  Jelle van Zeijl <jvzeijl@isou17.estec.esa.nl>. The LaTeX2HTML documentation
%  should be consulted about all commands (and the environments defined above)
%  except \xref and \xlabel which are Starlink specific.

\newcommand{\htmladdnormallinkfoot}[2]{#1\footnote{#2}}
\newcommand{\htmladdnormallink}[2]{#1}
\newcommand{\htmladdimg}[1]{}
\newcommand{\hyperref}[4]{#2\ref{#4}#3}
\newcommand{\htmlref}[2]{#1}
\newcommand{\htmlimage}[1]{}
\newcommand{\htmladdtonavigation}[1]{}

\newenvironment{latexonly}{}{}
\newcommand{\latex}[1]{#1}
\newcommand{\html}[1]{}
\newcommand{\latexhtml}[2]{#1}
\newcommand{\HTMLcode}[2][]{}

%  Starlink cross-references and labels.
\newcommand{\xref}[3]{#1}
\newcommand{\xlabel}[1]{}

%  LaTeX2HTML symbol.
\newcommand{\latextohtml}{\LaTeX2\texttt{HTML}}

%  Define command to re-centre underscore for Latex and leave as normal
%  for HTML (severe problems with \_ in tabbing environments and \_\_
%  generally otherwise).
\renewcommand{\_}{\texttt{\symbol{95}}}

% -----------------------------------------------------------------------------
%  Debugging.
%  =========
%  Remove % on the following to debug links in the HTML version using Latex.

% \newcommand{\hotlink}[2]{\fbox{\begin{tabular}[t]{@{}c@{}}#1\\\hline{\footnotesize #2}\end{tabular}}}
% \renewcommand{\htmladdnormallinkfoot}[2]{\hotlink{#1}{#2}}
% \renewcommand{\htmladdnormallink}[2]{\hotlink{#1}{#2}}
% \renewcommand{\hyperref}[4]{\hotlink{#1}{\S\ref{#4}}}
% \renewcommand{\htmlref}[2]{\hotlink{#1}{\S\ref{#2}}}
% \renewcommand{\xref}[3]{\hotlink{#1}{#2 -- #3}}
%end{latexonly}
% -----------------------------------------------------------------------------
% ? Document specific \newcommand or \newenvironment commands.
% ? End of document specific commands
% -----------------------------------------------------------------------------
%  Title Page.
%  ===========
\renewcommand{\thepage}{\roman{page}}
\begin{document}
\thispagestyle{empty}

%  Latex document header.
%  ======================
\begin{latexonly}
   CCLRC / {\textsc Rutherford Appleton Laboratory} \hfill {\textbf \stardocname}\\
   {\large Particle Physics \& Astronomy Research Council}\\
   {\large Starlink Project\\}
   {\large \stardoccategory\ \stardocnumber}
   \begin{flushright}
   \stardocauthors\\
   \stardocdate
   \end{flushright}
   \vspace{-4mm}
   \rule{\textwidth}{0.5mm}
   \vspace{5mm}
   \begin{center}
   {\Huge\textbf  \stardoctitle \\ [2.5ex]}
   {\LARGE\textbf \stardocversion \\ [4ex]}
   {\Huge\textbf  \stardocmanual}
   \end{center}
   \vspace{5mm}

% ? Add picture here if required for the LaTeX version.
%   e.g. \includegraphics[scale=0.3]{filename.ps}
% ? End of picture

% ? Heading for abstract if used.
   \vspace{10mm}
   \begin{center}
      {\Large\textbf Abstract}
   \end{center}
% ? End of heading for abstract.
\end{latexonly}

%  HTML documentation header.
%  ==========================
\begin{htmlonly}
   \xlabel{}
   \begin{rawhtml} <H1 ALIGN=CENTER> \end{rawhtml}
      \stardoctitle\\
      \stardocversion\\
      \stardocmanual
   \begin{rawhtml} </H1> <HR> \end{rawhtml}

% ? Add picture here if required for the hypertext version.
%   e.g. \includegraphics[scale=0.7]{filename.ps}
% ? End of picture

   \begin{rawhtml} <P> <I> \end{rawhtml}
   \stardoccategory\ \stardocnumber \\
   \stardocauthors \\
   \stardocdate
   \begin{rawhtml} </I> </P> <H3> \end{rawhtml}
      \htmladdnormallink{CCLRC}{http://www.cclrc.ac.uk} /
      \htmladdnormallink{Rutherford Appleton Laboratory}
                        {http://www.cclrc.ac.uk/ral} \\
      \htmladdnormallink{Particle Physics \& Astronomy Research Council}
                        {http://www.pparc.ac.uk} \\
   \begin{rawhtml} </H3> <H2> \end{rawhtml}
      \htmladdnormallink{Starlink Project}{http://star-www.rl.ac.uk/}
   \begin{rawhtml} </H2> \end{rawhtml}
   \htmladdnormallink{\htmladdimg{source.gif} Retrieve hardcopy}
      {http://star-www.rl.ac.uk/cgi-bin/hcserver?\stardocsource}\\

%  HTML document table of contents. 
%  ================================
%  Add table of contents header and a navigation button to return to this 
%  point in the document (this should always go before the abstract \section). 
  \label{stardoccontents}
  \begin{rawhtml} 
    <HR>
    <H2>Contents</H2>
  \end{rawhtml}
  \htmladdtonavigation{\htmlref{\htmladdimg{contents_motif.gif}}
        {stardoccontents}}

% ? New section for abstract if used.
  \section{\xlabel{abstract}Abstract}
% ? End of new section for abstract
\end{htmlonly}

% -----------------------------------------------------------------------------
% ? Document Abstract. (if used)
%  ==================
\stardocabstract
% ? End of document abstract
% -----------------------------------------------------------------------------
% ? Latex document Table of Contents (if used).
%  ===========================================
  \newpage
  \begin{latexonly}
    \setlength{\parskip}{0mm}
    \tableofcontents
    \setlength{\parskip}{\medskipamount}
    \markboth{\stardocname}{\stardocname}
  \end{latexonly}
% ? End of Latex document table of contents
% -----------------------------------------------------------------------------
\cleardoublepage
\renewcommand{\thepage}{\arabic{page}}
\setcounter{page}{1}

% ? Main text

\section{\xlabel{sec:introduction}\label{sec:introduction}Introduction}

The USSC consists of a few million lines of source code, mainly in 
Fortran 77 and C. 
Finding the source code of interest given the name of a
user task, a function, or even a source file can be non-trivial;
the name of the file containing a routine definition,
the package/directory/tar archive in which the file resides,
and the position in the file at which the routine is defined
may all be difficult pieces of information to obtain if one is
unfamiliar with the package in question.

This package seeks to enable fast navigation around the USSC 
source code in two ways.  In the first place it can locate a routine
or file based on an explicit user query (giving the exact or
approximate name of the routine or file and optionally the Starlink 
package in which it resides).  In the second place, it can present
the source code as HTML, suitable for viewing with any WWW browser,
with references to external routines presented as hyperlinks so
that call chains can be followed conveniently.
This second mode of use is clearly much more powerful than the first.

There are two principal components of the system: an indexing program
which is run once to locate and store all the files and routine 
definitions, and subsequently only when the source code is changed,
and an extractor program which interrogates the index to locate 
and output a requested file.

Typically the index
will be generated by the system manager and stored centrally,
and the extractor installed
as a CGI script to serve HTML over the network (if security is 
a concern it is possible to restrict access to local users in the
usual ways).  Simultanously, local users will be able to locate
or extract source files from the command line without using the 
WWW interface.  
There are other possibilities however: the extractor need not be
installed as a CGI script at all so that only command-line use
is available, and users may have their own private indexes 
which combine some or all of the main source code collection 
with their own development versions of packages.

The remainder of this document describes installation and use of
the package, and some details of its internal workings.
Its operation should be fairly intuitive however,
and it is perfectly possible to learn to use it just by playing around,
perhaps with reference to section \ref{BROWSER-HELP}.




\section{\xlabel{sec:install}\label{sec:install}Installation and setup}

\subsection{\xlabel{sec:install-pack}\label{sec:install-pack}Installing the package}

The files comprising SCB should be obtained and installed into
the Starlink tree in more or less the usual way.
There are some environment variables which affect the
installation, determining for instance the locations of the 
indexes and temporary directories.  
All default to sensible values, but if you are building the package
you can tailor them to your requirements.
If you have a pre-built version of the package for your system,
the default built values 
(recorded in the {\tt scb\_datestamp} file)
cannot be changed, but they can 
be overridden if the same environment variables are set at run time.
These variables are as follows:
\begin{description}
\item[SCB\_SOURCES]
The directory containing the Starlink source code.  
This directory should contain only Starlink source packages,
each of which must be {\em either\/} in a directory named after the package
{\em or\/} in a tar file named {\tt package.tar}, optionally compressed
using {\tt compress} or {\tt gzip} (and named with a suffix .Z or .gz 
respectively).
The former of these is the usual format if the sources are in
their usual location, {\tt /star/sources}.
If undefined at build time and run time, SCB\_SOURCES 
defaults to {\tt \$STARLINK/sources}.
\item[SCB\_INDEX]
The directory containing the index files (around 5--10 Mbyte for the full
Starlink source collection).
If undefined at build time and run time, SCB\_INDEX defaults to
{\tt \$INSTALL/etc/scb}.
\item[SCB\_BROWSER\_TMP]
The directory used by the browser program to store temporary files. 
If undefined at build time and run time, SCB\_BROWSER\_TMP defaults to
{\tt /usr/tmp/scb}.
\item[SCB\_INDEXER\_TMP]
The directory used by the indexer program to store temporary files. 
If undefined at build time and run time, SCB\_INDEXER\_TMP defaults to
{\tt /usr/tmp/scb}.
\end{description}
The following should also be set to locally sensible values,
although the program will still work if they are not set properly:
\begin{description}
\item[HTX\_SERVER]
The URL of an HTTP server which will provide HTX versions of the Starlink
documents (see \xref{SUN/188}{sun188}{remote_document_servers}).
In fact this does not have to be a proper HTX server; as long as it
can serve the documents it will not need to resolve {\tt xref\_}-type 
cross-references.
Thus if the {\tt /star/docs} directory is being served, the URL of
the top of that tree will do.
If undefined at build time, HTX\_SERVER defaults to 
{\tt http://star-www.rl.ac.uk/cgi-bin/htxserver/}.
\item[MIMETYPES\_FILE]
This should give the location of a MIME type mapping file,
which can probably be found named {\tt mime.types}
as part of the HTTP server installation.
It is used for the CGI script
to serve some non-text documents as their proper MIME types,
but not much functionality is lost if it does not point to a suitable file.
\end{description}
The build-time values of all these variables will be recorded
in the file 

An example site installation from source files might go as follows:
\begin{quote}
\begin{verbatim}
% zcat scb.tar.Z | tar xf -
% setenv SCB_BROWSER_TMP /scratch/scb/browser
% setenv SCB_INDEXER_TMP /scratch/scb/indexer
% setenv INSTALL /star
% setenv MIMETYPES_FILE /usr/local/etc/httpd/conf/mime.types
% mk build
    ...
% mk install
    ...
% mk test
    ...
*** Installation test for the SCB package has been run
\end{verbatim}
\end{quote}
or from a pre-built package:
\begin{quote}
\begin{verbatim}
% zcat scb_ix86_Linux_run.tar.Z | tar xf -
% setenv INSTALL /star
% mk install
    ...
% mk test
    ...
\end{verbatim}
\end{quote}

The program uses a DBM file to store the indexes on disk.
There will always be at least one library available on your system
which Perl can use to do this, and there may be 
several --- different implementations each have their own pros and cons.  
SCB will try to find 
the BSD DB library or the Gnu DBM library.
If these are not available then it will use one of the implementations
that is.  For most purposes this will work without any problems, but
these other implementations often impose limits which interfere slightly
with SCB's operation. 
In practice, the only effect of this is likely to be that the 
{\tt makefile} entry for a few of the packages cannot be written ---
if this is the case, then warning messages like 
\begin{quote}
\begin{verbatim}
!!! Failed to write makefile => package#makefile (block size limit?)
\end{verbatim}
\end{quote}
will be written by {\tt scbindex.pl}.
This is not a very serious handicap, but can be fixed by 
installing GDBM or BSD DB, which are available in the public domain.
Typically, BSD DB will be installed on a Linux or Digital Unix system,
but a Solaris system may lack all of the preferred implementations. 


SCB requires Perl 5
and has been tested using the version distributed with the 
Starlink software collection. 
Other versions of Perl may work, but have not been tested.


\subsection{\xlabel{sec:install-cgi}\label{sec:install-cgi}Installing the CGI script}

This part of the installation can normally only be done by 
the system manager.

In order to use this package to browse source code using a
World Wide Web browser, the browser script {\tt scb.pl}
must be installed as a CGI (Common Gateway Interface) program
on a computer running an HTTP server.  
For this purpose, the browser script is copied by the package
installation process (the {\tt mk install} step) 
into INSTALL{\tt /bin/cgi} as well as into INSTALL{\tt /bin}.

A full discussion of the setup of CGI programs is
beyond the scope of this document, but by way of example, 
if the HTTP server being used is 
\htmladdnormallink{Apache}{http://www.apache.org/}, 
it will typically 
be necessary to
add a stanza like the following to Apache's {\tt conf/access.conf} file:
\begin{quote}
\begin{verbatim}
<Directory /star/bin/cgi>
Options ExecCGI
</Directory>
\end{verbatim}
\end{quote}
and a line like the following to the {\tt conf/srm.conf} file:
\begin{quote}
\begin{verbatim}
ScriptAlias /cgi-bin/star/ /star/bin/cgi/
\end{verbatim}
\end{quote}
Alternatively, the script {\tt /star/bin/cgi/scb.pl} may be copied 
into an existing CGI directory;
if correctly installed it should still work if its name or location 
are changed.

Every attempt has been made to make the CGI script secure against
abuse by users of the browsing facility,
but provision of any CGI program is an inherently risky business.
It should also be noted that the browser 
program can use significant system resources which might 
make it possible for users of the service intentionally or 
unintentionally to degrade performance of the server.
In particular, heavy use may be made of the following resources:
\begin{description}
\item[CPU time] 
Parsing source files to add the HTML tags is done on the fly by 
the browser program, and while for most of the source files this 
is quite fast, for some of the very large files it can 
take a matter of seconds or even minutes.
\item[Memory]
Again the parsing can take a significant amount of memory when the
file to be parsed is very large.
\item[Temporary disk space]
Temporary files will created in the SCB\_BROWSER\_TMP directory
if it is necessary to unpack tar archives.  The problem is most acute
when tar files are contained in other tar files (usually only the
case if the whole source archive for each package is stored as a tar file,
rather than unpacked as is more usual).  
If all the tar files within the source archive are unpacked in place,
for instance using a C-shell sequence like 
\begin{quote}
\begin{verbatim}
setenv SCB_SOURCES /star/sources
foreach tarfile (`find $SCB_SOURCES -name \*.tar -print`)
   cd $tarfile:h
   tar xf $tarfile:t
end
\end{verbatim}
\end{quote}
then no temporary disk space will be used, and much reduced disk
activity will be required by the browser program.
The disadvantage of doing this is increased use of disk space
in the SCB\_SOURCES directory 
(by around 220MB for the full unbuilt USSC). 
\end{description}





\section{\xlabel{sec:indexing}\label{sec:indexing}Generating the index
         ({\tt scbindex.pl})}

In order for the browser to work, indexes of the source files must be
generated.  This is done by the script {\tt scbindex.pl}, installed
by default in {\tt /star/bin}.
The following subsections explain how to use this program to
build an index.  In most cases, only an index of the whole Starlink
collection will be required, but people modifying or developing
their own copies of packages may wish to generate a personalised index.


\subsection{\xlabel{sec:indexing-all}\label{sec:indexing-all}Indexing the whole Starlink collection}

To index the whole of the source collection, simply invoke the 
indexer program as follows:
\begin{quote}
\begin{verbatim}
% scbindex.pl
\end{verbatim}
\end{quote}
This will 
read the source files from the directory specified in SCB\_SOURCES, 
write the index files to the directory specified in SCB\_INDEX,
and print to the screen each index entry as it is encountered.
If the entire Starlink source code collection is installed, 
this will take a matter of hours.  Some indication of how far the indexing
has progressed can be seen by looking at which package is currently
being indexed (the package name is given before the `{\tt \#}' sign on the 
printed lines, e.g. lines which look like
\begin{quote}
\begin{verbatim}
cmp_activ.f          =>  hds#hds_source.tar>cmp_activ.f
cmp_blk.f            =>  hds#hds_source.tar>cmp_blk.f
cmp_cct              =>  hds#hds_source.tar>cmp_cct
\end{verbatim}
\end{quote}
indicate that the HDS package is being indexed).
The packages are dealt with in alphabetical order, so by seeing how 
far the package currently being examined is through the list of files
in the directory SCB\_SOURCES you can get a rough idea of how much remains
to be done.

If only one or a few packages have been changed
since the last indexing,
then the index can be updated rather than being regenerated from scratch.
In this case only the changed packages are named on the command line,
e.g.
\begin{quote}
\begin{verbatim}
% scbindex.pl ast polpack ndf
\end{verbatim}
\end{quote}
The packages so named will be taken from the SCB\_SOURCES directory in
the same way as if the whole source tree is being indexed.

Since the indexing can take a long time, it will probably be preferable to 
run it in the background, possibly {\tt renice}d, with the output
redirected elsewhere, e.g.:
\begin{quote}
\begin{verbatim}
% nice +4 scbindex.pl >& scbindex.log &
\end{verbatim}
\end{quote}
If the machine will be used by other people while the indexing 
is running, then you should seek advice from your system manager 
about the nice level that ought to be used.

While the indexing is taking place, the index files {\it may} 
(depending on the implementation of the database libraries on
your system)
be unreadable, so that the browser program ceases to work.
To maintain the browser service during an update of the index in this
case, it will be necessary to update a copy, and write it over the
original when it is complete, like this:
\begin{quote}
\begin{verbatim}
% setenv SCB_INDEX /usr/tmp/tmp_index
% mkdir $SCB_INDEX
% scbcp.pl /star/etc/scb $SCB_INDEX
% scbindex.pl pack1 pack2
% scbcp.pl $SCB_INDEX /star/etc/scb
\end{verbatim}
\end{quote}
Use of the {\tt scbcp.pl} utility is explained in 
section \ref{sec:scbcp}.

The index files created in the SCB\_INDEX directory should 
total around five Mb for the whole USSC.  
On some operating systems the index files may be 
sparse, and {\em appear} much bigger than they are,
so that {\tt ls~-l} makes them look very large, 
while {\tt du} or {\tt ls~-s} gives their true size.
Copying the indexes should be done using the supplied utility
{\tt scbcp.pl} (see section \ref{sec:scbcp}), 
not the Unix {\tt cp} command; the latter would
work, but may result in inefficient use of disk space.


\subsection{\xlabel{sec:personalise}\label{sec:personalise}Creating a personalised index}

As well as examining all the source files from their natural home
in the main Starlink source tree (the SCB\_SOURCES directory),
it is also possible to index source code from elsewhere, 
by giving the pathname of the directory
or tarfile containing the source.
In this way a personalised index can be created: 
suppose that {\tt scbindex.pl} has already been run 
on all the source code in {\tt /star/sources}, 
writing index files in {\tt /star/etc/scb}, as described in 
the previous section, 
and that you have a personal source copy (under development say) of 
Figaro in \verb|~/star/sources/figaro|.
To create your own index in \verb|~/star/etc/scb|, 
which will for the most part match the global index 
but contain your version of Figaro,
you can do the following:
\begin{quote}
\begin{verbatim}
% setenv SCB_INDEX ~/star/etc/scb
% scbcp.pl /star/etc/scb $SCB_INDEX
% scbindex.pl ~/star/sources/figaro
\end{verbatim}
\end{quote}
--- first a private copy is made of the global indexes using 
the supplied {\tt scbcp.pl} utility (see section \ref{sec:scbcp}),
and then the Figaro parts are overwritten using {\tt scbindex.pl}.
If the modified sources were 
in a compressed tar file in the current directory, 
rather than in \verb|~/star/sources|,
then the last line above could be replaced by
\begin{quote}
\begin{verbatim}
% scbindex.pl ./figaro.tar.Z
\end{verbatim}
\end{quote}
It would be possible to make personal index containing Figaro only,
in which case the copying step could be avoided, 
but then hyperlinks to routines in other Starlink packages 
would not work.

To make use of the personalised index, rather than the one set as
the default at install time, the following must be done:
\begin{description}
\item[Command line use]
For using the extractor program {\tt scb.pl} from the command line, 
set the environment variable SCB\_INDEX to the directory containing
the indexes, in the same way as during the index build as described
above.
\item[CGI browser use]
For using {\tt scb.pl} in HTML mode, then append 
`{\tt ?indexdir=directoryname}' to the script's URL.
Thus if your index is in {\tt /home/user/star/etc/scb}
and the browser is installed in {\tt /cgi-bin/star/} on server
host.domain, then to use the default index (as defined when the
package was installed) you should point
your browser at
\begin{quote}
\begin{verbatim}
http://host.domain/cgi-bin/star/scb.pl
\end{verbatim}
\end{quote}
and to use your personal index you should point it at
\begin{quote}
\begin{verbatim}
http://host.domain/cgi-bin/star/scb.pl?indexdir=/home/user/star/etc/scb
\end{verbatim}
\end{quote}
\end{description}


\section{\xlabel{sec:extract}\label{sec:extract}Viewing the source code
         ({\tt scb.pl})}

This section explains how to use the extractor program, {\tt scb.pl},
to view source code from the Starlink source tree,
assuming that an index has been built as explained in 
section \ref{sec:indexing}.
The browser system tries to come up with the requested section of
source code, but for one reason and another sometimes fails to 
do so.  
For more insight into why it behaves as it does, and 
how it might be coaxed into behaving otherwise, 
section \ref{sec:internals} gives some explanation of how the
indexing and extraction is done.


\subsection{\xlabel{sec:extract-commandline}\label{sec:extract-commandline}Command line operation}

Whether or not the package has been installed as a CGI script,
it should be 
possible to use the extractor program, {\tt scb.pl},
to view the source code from the Unix shell.

\subsubsection{\xlabel{sec:extract-name}\label{sec:extract-name}{\tt name} argument (basic use)}

At its simplest, a file is extracted by giving just the 
requested filename or routine as an argument to the extractor:
\begin{quote}
\begin{verbatim}
% scb.pl name=dsa_data_size
\end{verbatim}
\end{quote}
or equivalently:
\begin{quote}
\begin{verbatim}
% scb.pl dsa_data_size
\end{verbatim}
\end{quote}
finds the file which contains the routine `{\tt dsa\_data\_size}'
and prints it to standard output.  It also
prints to standard error the location of this file.
The file can therefore be viewed using {\tt more}, or printed,
or saved to a local file, or searched with {\tt grep}, or
generally used in the usual Unix ways.
For instance to save it to a local file {\tt file.f}:
\begin{quote}
\begin{verbatim}
% scb.pl dsa_data_size >file.f
figaro#figaro_dsa.tar>dsa/dsa_dat_sz.f
\end{verbatim}
\end{quote}
the second line here is the line printed to standard error 
by the program indicating the file in which the routine was found;
it means that the file is part of the package FIGARO,
is contained in the tar archive {\tt figaro\_dsa.tar}, and
within that archive is called {\tt dsa/dsa\_dat\_sz.f}.
Files can be extracted by their filename instead,
so that
\begin{quote}
\begin{verbatim}
% scb.pl dsa_dat_sz.f >file.f
figaro#figaro_dsa.tar>dsa/dsa_dat_sz.f
\end{verbatim}
\end{quote}
has exactly the same effect as the former example.

Routine names are indexed by the names the Unix linker gives them.
For C functions, this means the name of the function as in the 
source code should be used.
For Fortran functions and subroutines, the indexed name is 
formed by appending an underscore to the lower case name of the 
routine.  
If the underscore is omitted however, and no routine by that name
can be found, the extractor program will look for a routine with
the underscore appended.


\subsubsection{\xlabel{sec:extract-package}\label{sec:extract-package}{\tt package} argument}

If the extractor can find a Fortran subroutine or function, 
or a C function or macro definition, with the name supplied on
the command line, it will extract the relevant source file.
However it is sometimes necessary to restrict the search
further, since there may be more than one source file answering
to that description.  So it is also possible to specify the
package in which you expect to find the file or routine. 
For instance, there is one file called `{\tt help.f}' in
package HLP and another in POLMAP.  
To ensure that you get the one in HLP, specify it on the 
command line using the `{\tt package=}' argument:
\begin{quote}
\begin{verbatim}
% scb.pl help.f package=hlp
\end{verbatim}
\end{quote}
Note that the package argument only serves as a hint to the
extractor program: if the requested file/routine occurs in the
specified package, then that one is retrieved.  If it does not,
but it does exist in another package, then that one is retrieved.
Thus, given that there is no file {\tt help.f} in CCDPACK,
\begin{quote}
\begin{verbatim}
% scb.pl help.f package=ccdpack
\end{verbatim}
\end{quote}
and 
\begin{quote}
\begin{verbatim}
% scb.pl help.f
\end{verbatim}
\end{quote}
will give the same result, which is one or other of the {\tt help.f}
files from either POLMAP or HLP (picked more or less at random).

The `{\tt package=}' part may be omitted, so that 
\begin{quote}
\begin{verbatim}
scb.pl help.f hlp
\end{verbatim}
\end{quote}
is equivalent to 
\begin{quote}
\begin{verbatim}
scb.pl help.f package=hlp
\end{verbatim}
\end{quote}


\subsubsection{\xlabel{sec:extract-type}\label{sec:extract-type}{\tt type} argument, and pattern matching}

It is also possible to specify whether the requested search
term is a routine/function or a file, by specifying `{\tt type=func}'
or `{\tt type=file}' respectively on the command line.  This is not
normally necessary, since the names of functions rarely clash with
the names of routines.

A third possibility is `{\tt type=regex}', in which case the 
search term is interpreted as a case-insensitive 
Perl regular expression, and
all functions and all files are searched for matches.
All the matching terms, along with file locations, are then printed out
(first files, then routines).
In this case no source file is extracted.
The same format of regular expression as used by the Unix {\tt grep}
utility can be used 
(although the many additional pattern matching facilities
offered by Perl are also allowed).
Thus to find, for instance, the locations of 
all the files and routines whose names contain `fit' followed
by `gauss', the following command can be used:
\begin{quote}
\begin{verbatim}
% scb.pl 'fit.*gauss' type=regex

Files:
ech_fit_gaussian.f       => echomop#echomop_source.tar>ech_fit_gaussian.f
fitgauss.f               => figaro#figaro_appca.tar>appca/fitgauss.f
fitgauss.ifl             => figaro#figaro_source.tar>fitgauss.ifl
sculib_fit_2d_gaussian.f => surf#surf_sculib.tar>sculib_fit_2d_gaussian.f
fit_mgauss.f             => twodspec#twodspec_opt.tar>opt/fit_mgauss.f

Routines:
ech_fit_gaussian_        => echomop#echomop_source.tar>ech_fit_gaussian.f
fitgauss_                => figaro#figaro_appca.tar>appca/fitgauss.f
sculib_fit_2d_gaussian_  => surf#surf_sculib.tar>sculib_fit_2d_gaussian.f
fit_mgauss_              => twodspec#twodspec_opt.tar>opt/fit_mgauss.f
\end{verbatim}
\end{quote}
If the {\tt package} argument is given as well as the {\tt type=regex}
argument, then only the package specified will be searched.

More flexible pattern matching searches are possible 
with inventive use of the {\tt dbmcat.pl} command described
in section \ref{sec:dbmcat}.



\subsubsection{\xlabel{sec:extract-flags}\label{sec:extract-flags}Command line flags}

There are two command line flags which can be supplied to {\tt scb.pl}.
Neither is required very often, but they are documented here for completeness.
\begin{description}
\item[-html]
If the {\tt -html} flag is included on the command line, 
then HTML is written, in the same way as if the extractor were
being invoked as a CGI script.  This is not particularly useful,
except for debugging purposes.
\item[-exact]
Normally the extractor program, if it fails to find the file or
function exactly as specified, tries a few variations like appending
underscores or folding the case of the given argument.
If the {\tt -exact} flag is given then these variations are not attempted.
\end{description}




\subsection{\xlabel{sec:extract-cgi}\label{sec:extract-cgi}Browsing using HTML}

If the extractor program {\tt scb.pl} has been installed
as a CGI program as described in section \ref{sec:install-cgi}
then the Starlink source code can be browsed as a set of 
hypertext pages hyperlinked together 
at function/subroutine calls and file includes.
Using the pages generated should be quite intuitive,
so the following discussion does not give exact instructions
but clears up a few points.
The best way to see how it works is to play with it.

The URL of the source code browser will depend on exactly how
the installation has been performed, but it will look something
like {\tt http://host.domain/cgi-bin/star/scb.pl} 
(although see the note in section \ref{sec:personalise} 
if you have built your own index).


\subsubsection{\xlabel{BROWSER-HELP}\label{BROWSER-HELP}Locating a source file}



The top level page of the source code browser is a form
which can be filled in to request a particular source file.
It consists of the following parts:
\begin{description}
\item[Name of item]
The name of the file or function/subroutine to locate, 
or a regular expression matching a file or routine.
\item[Type of item]
Describes how to interpret the ``Name of item'' box.  Select one of:
\begin{description}
   \item[Routine]
   The item is a Fortran or C function or subroutine.
   This is case sensitive.
   For C use the name of the function exactly as it occurs in the source code.
   For Fortran, use the routine's name in lower case with an 
   underscore appended;
   however, if the case is wrong or the underscore is omitted the 
   browser will still probably 
   find the right routine.
   \item[File]
   The item is a filename.  This is case sensitive.
   \item[Either]
   The browser will try both of the above options (File and Routine).
   \item[Regular expression]
   The item name is a Perl 5 regular expression, 
   interpreted case-insensitively,
   to match the name of a file or function/subroutine
   (note it does {\em not\/} match the full text of source files).
   For most practical purposes, Perl regular expressions are a superset
   of ordinary regular expressions, so they can be treated like the 
   argument of a `{\tt grep -i}' command.
   % A case sensitive search can be achieved by prepending `{\tt (?-i)}' to the
   % regular expression; however this requires Perl 5.005.
\end{description}
\item[Name of package (optional)]
If one of the listed packages is selected, it serves
as a hint about where the file or routine being searched for might be.
It is used as follows: if a file or routine of the given name is found
in the package specified, then that one will be presented.
If it is not in that package, or if no package is specified, 
then any such item in the whole source tree will be presented.
In particular, this means that even when one package is specified here,
a routine from another package may be presented.\\
If the Type of item is ``Regular expression'' however, then filling in this
field will restrict the search to the named package.
\end{description}
If the type of item is ``Routine'' or ``File'', then submitting
the form will take you to the unit requested, or a message
that no such unit can be found
(note that these will take you to the top of the file,
not necessarily where the requested routine begins ---
if this makes it hard to find the right place, you can browse the
package and follow a link to the routine, as described below).
If the type of item is ``Regular expression'', 
it will present a list of links to
matching files.

Instead of entering the name of the file or routine you wish to
see, you can browse the contents of a given package.
Below the form is a list of links to all the available packages.
Following one of these links (or equivalently selecting the package
name in the `Name of package' box without filling in the `Name of item'
field) will take you to a page giving more information about the 
package requested.
This will contain the same form at the top, 
but below it are links to files from the package grouped by category:
\begin{description}
\item[Files]
Links to every file in the package.
\item[Routines]
Links to every C and Fortran function and subroutine definition 
identified in the source files.
\item[Starlink documents]
Links to any SUNs and SSNs which form part of the package
(although not necessarily all those {\it relevant\/} to the package).
\item[Tasks]
Links to `tasks' in the package.
This is rather loosely defined, but it is intended to be
the names of commands which can be invoked from the Unix shell or ICL.
Because the way these are identified is rather ad hoc,
the list may be incomplete and/or contain spurious entries.
\end{description}
Sometimes the ``Files'' or ``Routines'' heading is a hyperlink to 
the actual lists of links, rather than having the list on the page.

Following any of the listed links 
will take you to one of the files in the package.

\subsubsection{\xlabel{sec:view}\label{sec:view}Viewing a source file}

A file from a package is normally presented as text in the browser.
If it is C or Fortran source code, then each called function or
subroutine should be a hyperlink to the appropriate definition.
Similarly, included files (Fortran {\tt INCLUDE} or C {\tt \#include}) 
are hyperlinked to the right place.
If any part of the source text is in bold face,
this indicates that it ought to be a link,
but that the routine or file in question cannot be found. 
This can happen because the program has misinterpreted the source code,
or the index is out of date, or for other reasons.
The program tries to link to the correct place, 
but cannot guarantee to do so; for instance if there are two 
routines with the same name in different packages outside the
package containing the current file, the link might point to
the wrong one.
Most types of file other than C or Fortran source are 
simply presented as plain text, although some types
(e.g.\ postscript)
will be presented using a viewer appropriate to the type.

The title of the HTML document
(normally displayed in the title bar of your browser)
is the location of the file in 
the source tree.  The notation is specific to this package,
but quite easy to understand: 
it's like a Unix pathname except that
a `{\tt \#}' sign denotes inclusion in a package, 
and a 
`\verb|>|'
sign denotes inclusion in a tar file.
So for instance the location
\begin{quote}
\begin{verbatim}
figaro#figaro_dsa.tar>dsa/dsa_dat_sz.f
\end{verbatim}
\end{quote}
means that the file is part of the package FIGARO,
is contained in the tar archive {\tt figaro\_dsa.tar}, and
within that archive is called {\tt dsa/dsa\_dat\_sz.f}.

At the bottom of each file is a copyright notice.


\section{\xlabel{sec:internals}\label{sec:internals}Internal workings}

The code is mainly documented by in-line comments,
but an overview of its operation is given here so 
that the interested reader can gain more insight into
the capabilities and limitations of the package.
This overview will also prove useful as an introduction to
the code for anyone wishing to modify or extend it, 
for instance by adding or replacing modules for indexing 
given source code languages.

This section is not required reading for users of the package.

\subsection{\xlabel{sec:internals-indexes}\label{sec:internals-indexes}Index files}

The indexing program {\tt scbindex.pl} builds disk-based indexes, and the 
extractor program, which is the same as the browser program  {\tt scb.pl}
interrogates them.  There are three indexes:
\begin{description}
\item[Tasks]
For each package, a list of all the tasks which have been identified
is kept (the definition of what constitutes a task is rather 
loose, but it is intended to be programs which can be invoked by
typing their names from the Unix shell, ICL, or other external
environment).
Only the name of each task is stored here; 
for each task there will be a corresponding entry giving its location within
that package in the Routines index.
This index also serves as a list of all the
packages which have been indexed.
%
\item[Files]
An index of every file which makes up the indexed source code set,
indexed by bare filename (i.e.\ the tail of the filename, excluding
path information). 
This index also holds a special entry for each package 
recording where the source code is stored.
%
\item[Routines]
An index of every C and Fortran function and subroutine, 
indexed by the name used by the Unix linker on the supported systems;
thus C functions are indexed by their function names 
as written in the source code, and Fortran routines by the function 
or subroutine name in lower case, followed by a single underscore.
C preprocessor macro functions are also indexed,
but Fortran statement functions are not.
The location stored for each function gives only the file in
which it can be found, not the position within that file.
\end{description}

The Tasks index is stored in a plain text file called {\tt tasks};
being line formatted it has, in general, 
to be read in its entirety to find any
required piece of information.
Since it is plain text 
it can be examined using a normal text editor 
(although some of the lines may be rather long).

The File and Routine indexes
each resemble a table which
maps a key (name of the routine or file), and optionally a 
Starlink package name, to a location in the source tree. 
For each name which occurs at all,
the index contains a list of one or more locations, 
one for each package in which it occurs.
The index can be interrogated by requesting any location for a given name,
or by requesting a location which is preferentially within a given package
(using the `name' and `package' arguments of the CGI script respectively).
An important upshot of this is that if there are two instances of
the same file name or of the same function/routine name 
{\em in the same package\/}, only one will be indexed, so that the
browser program will never access the other.
The same routine name may crop up in different packages without causing
clashes however.

The File and Routine indexes are
handled by the program as StarIndex 
objects (named {\tt file} and {\tt func} respectively), 
i.e.\ are of a type 
defined in the supplied module {\tt StarIndex.pm}.
The corresponding files are much larger than the Tasks file 
(a couple of megabytes or more each),
but because of the way they are implemented 
(as a hash of flattened lists tied to a DBM file of some sort), 
any given entry can be accessed by key very quickly.
The design of these objects was dictated chiefly by the requirements
of the browser program, as explained in 
section \ref{sec:internals-extractor}).
More detailed documentation of the implementation of these indexes
can be found in the StarIndex.pm module itself.

It is possible to examine the File and Routines indexes 
directly from the command line by using the supplied {\tt dbmcat.pl}
utility (see section \ref{sec:dbmcat}).



\subsection{\xlabel{sec:internals-tagging}\label{sec:internals-tagging}Parsing and tagging source code}

Both the indexer and the extractor need to be able to parse the 
source code: the indexer needs to know which
functions/subroutines are indexed in each source file so that
it can write the Routines index, and the extractor needs to know
what is a reference to another file so that it can generate
hyperlinks, as well as the position of function/subroutine 
definitions so that references can point to the right place in
source files (via {\tt <a~name='...'>} tags).

Both programs therefore use the same parsing routines. 
A detailed description of how these interface with
the indexer and extractor programs are given in the 
module {\tt Scb.pm}, but the basic idea is that these routines
take as input the raw source code and output the same text
with added HTML-like tags indicating where functions are defined 
and where they are called.

One routine is supplied for tagging C source and one for 
Fortran.  
Each uses routines from the module {\tt Tag.pm}
which is designed to make it fairly painless to write a
reasonably successful tagging program in Perl.
The SCB package has been designed to make
replacing one of the language-specific tagging modules 
(for instance with a more efficient or more accurate one),
or adding a new one (for instance for a different language), 
fairly easy---aspects of this 
procedure are documented in the modules {\tt Scb.pm} and {\tt Tag.pm},
while the existing tagging modules {\tt CTag.pm} and {\tt FortranTag.pm}
serve as examples.

The existing tagging routines are good enough to generate 
accurate indexing information and hypertext 
for a large majority of the source files in the
Starlink software collection, but could be improved upon:
they can be quite inefficient on memory and slow
for the largest source files, and can be fooled into misinterpreting
the source code, e.g.\ the C module sometimes gets confused by conditional
compilation directives, and the Fortran one fails to identify
statement function definitions.



\subsection{\xlabel{sec:internals-indexer}\label{sec:internals-indexer}Operation of the indexer program}

The function of the indexer program {\tt scbindex.pl} 
is to go through
each of the Starlink packages in turn, writing the name and 
location of each task, file and function into the appropriate 
indexes.

For each package, the indexer program examines 
every file in the package directory or tar archive, 
and in any subdirectories or subarchives thereof.
Any file within a tar archive 
is written to the Files index
(files which only occur outside tar files are omitted
from that index since they are probably intermediate files 
generated as the result of building the package, although
a few explicit exceptions to this rule are made 
including makefiles and Starlink documents). 
Any file for which a
source code tagging routine exists
is passed through the tagging routine;
the output is examined for any function definitions 
(tags of the form {\tt <a~name='...'>}), 
and an entry is written to the Routines index for each of these.

Finally various heuristics are pursued to identify
keys from the Routine index which also appear to be tasks, 
and an entry is written to the Tasks index containing these.
Even if no tasks are found, an entry containing just the package
name is written to the Tasks index to serve as a record that 
the current package has been indexed.


\subsection{\xlabel{sec:internals-extractor}\label{sec:internals-extractor}Operation of the extractor program}

The extractor program {\tt scb.pl} functions in two main modes;
as a normal program which can be invoked from the Unix shell and
outputs plain text (described in section \ref{sec:extract-commandline}),
and as a CGI program which is run under the control of an HTTP server
to produce (predominantly) HTML output (described in \ref{sec:extract-cgi}).

In command line mode, the main function of the extractor
program is to locate and output
the file or routine requested using whatever arguments it
has been given (see section \ref{sec:extract-commandline}),
which may require pulling it out from within tar archives.
If no such file can be found, an error message is written.

In CGI mode, the program has two additional responsibilities.
Firstly, if invoked without sufficient arguments to identify 
a file for output, it must present some useful alternative in HTML.
Secondly, when presenting source code, it must mark up 
appropriate words as HTML anchors.

When supplied with insufficient arguments it may simply present
a formatted (and hopefully informative) error message. 
More commonly however, for instance if invoked with no arguments
at all, it will present a form and/or a series of links 
enabling the user to re-invoke the program 
in such a way as to present the source file required,
or get closer to being able to do that.

Marking the source code up with HTML anchor tags 
is done partly by the extractor program itself, 
and partly by separate language-specific tagging routines.
Having extracted the source code, the extractor 
checks whether a suitable tagging routine exists. 
If not, then some basic markup is done and the file written 
more or less raw.
If such a routine does exist however, it is called, 
which adds
HTML-like tags indicating the positions of routine definitions 
and code references.
The extractor program goes through this, and converts it to 
actual HTML before writing it out.
The following example should clarify this.  
If the original code is:
%
% This is rather ugly LaTeX, sorry - I think it's worthwhile if you're
% looking at the (latex2html'd) results in HTML though.
%
\begin{quote}
{\tt
\#include "header.h" \\
int code (int argc, char **argv) \{ \\
\mbox{}~~~do\_stuff(); \\
\}
}
\end{quote}
it will changed by the tagging routine to read:
\begin{quote}
{\tt
\#include "{\bf $<$a href='INCLUDE-header.h'$>$}header.h{\bf $<$/a$>$}" \\
int {\bf $<$a name='code'$>$}code{\bf $<$/a$>$} (int argc, char **argv) \{ \\
\mbox{}~~~{\bf $<$a href='do\_stuff'$>$}do\_stuff{\bf $<$/a$>$}(); \\
\}
}
\end{quote}
which, assuming the code appears within a package named ``pack'', 
will finally be modified for output by the extractor to look something like:
\begin{quote}
{\tt
\#include "{\bf $<$a href='scb.pl?header.h\&package=pack\&type=file'$>$}header.h{\bf $<$/a$>$}" \\
int {\bf $<$a name='code'$>$}code{\bf $<$/a$>$} (int argc, char **argv) \{ \\
\mbox{}~~~{\bf $<$a~href='scb.pl?do\_stuff\&package=pack\&type=func\#do\_stuff'$>$}do\_stuff{\bf $<$/a$>$}(); \\
\}
}
\end{quote}
The hyperlinks written by the browser program are thus such
(see section \ref{sec:extract-commandline})
that they effectively point to a routine or file of the given name from
the current package if one exists, but if it does not, will resolve to
one from another package.
This can sometimes resolve to the wrong routine---for instance
if there are multiple routines of the same name inside the
package, or none inside but one in each of several external packages.
However, it has a good chance of resolving to the right routine,
especially for routines named in the usual Starlink way of
{\tt pre\_name}, and importantly it has no need to attempt to 
understand the contents of include files, link scripts or makefiles, which 
would make the whole business a great deal more complicated.

Note that the link to the function (although not to the include file)
includes specification of a target within the document
(the part after the `{\tt \#}' symbol), 
which is important if the referenced function is just one of many within a
large source file (frequently true in C source, although less so in Fortran).
Links to locations within a file work because of the
{\tt $<$a~name='...'$>$} tags at function definitions.

A couple of other subtleties are observed in creating these hyperlinks.
Firstly, if no file or routine of the given name exists for any package,
the link is not created, but the word which would otherwise have
been a link is output in bold to indicate that it looks
like it ought to reference another file but does not.
Secondly, if the referenced item exists in the same source file,
a truncated URL giving only the relative position in the same
file is written.  This prevents the behaviour (which smart browsers
may in any case avoid) of having to reload the same file when all
that is required is to move around in it.


\section{\xlabel{sec:utilities}\label{sec:utilities}Additional utilities}

As well as the principal programs
{\tt scbindex.pl} (section \ref{sec:indexing})
and 
{\tt scb.pl} (section \ref{sec:extract}),
a couple of additional utilities are supplied with the package.
These are not necessary for normal operation 
of the package but may prove useful to those making more 
involved use of it.




\subsection{\xlabel{sec:dbmcat}\label{sec:dbmcat}{\tt dbmcat.pl}}

The {\tt dbmcat.pl} utility directly examines the DBM files 
in which the File and Routine indexes are kept 
(see section \ref{sec:internals-indexes}.

Source documentation is as follows:
\begin{verbatim}
#  Name:
#     dbmcat.pl

#  Purpose:
#     Examine StarIndex files.

#  Language:
#     Perl 5

#  Invocation:
#     dbmcat.pl filename
#     dbmcat.pl filename key ...

#  Description:
#     This utility is for examining the DBM files representing StarIndex
#     objects used to store the indexes used by the SCB package for
#     indexing files and routines.
#
#     It is not required for any part of the package operation, but is
#     provided for manual examination of these files.  It will mainly
#     be useful for debugging, but may also be useful (in combination
#     with, for instance, grep(1)) for making more flexible queries
#     of the index files than are permitted by the 'type=regex'
#     argument of the scb.pl extractor program.
#
#     It can be used in two modes: if the name of the index only is
#     specified, then every record in the index is printed (in an
#     unpredictable order); the format is
#
#        key    => value value value ...
#
#     where the values are file locations using the logical pathnames
#     as used in the rest of the SCB package.  There may be one or more
#     values, and they are separated by spaces.

#  Arguments:
#     filename
#        Name of the index file.  This is the name of the index as
#        submitted to the StarIndex::new() routine, i.e. without
#        whatever file extensions (.db, .dir, ...) may appear when
#        the file is actually written.  The full path must be given.
#     key
#        One or more keys of the index may be specified.  They must be
#        exact.
\end{verbatim}
Thus to examine the whole index (note that records are printed in
no particular order):
\begin{quote}
\begin{verbatim}
% dbmcat.pl $SCB_INDEX/file
ary1_gt1d.f          => ary#ary_source.tar>ary1_gt1d.f
test_abbrv.f         => chr#chr_source.tar>test_abbrv.f
ech_read_type.f      => echomop#echomop_source.tar>ech_read_type.f
optextract.hlp       => figaro#figaro_iraf.tar>doc/optextract.hlp
    . . .
\end{verbatim}
\end{quote}
and to examine named entries:
\begin{quote}
\begin{verbatim}
% dbmcat.pl /star/etc/scb/func add_ rec_unlock
add_                 => img#img_source.tar>add.f kappa#kappa_sub.tar>add.f
rec_unlock           => hds#hds_source.tar>rec_unlock.c
\end{verbatim}
\end{quote}



\subsection{\xlabel{sec:scbcp}\label{sec:scbcp}{\tt scbcp.pl}}

The {\tt scbcp.pl} utility copies all the indexes which have
been written by {\tt scbindex.pl} (see section \ref{sec:internals-indexes})
from one directory to another.

Source documentation is as follows:
\begin{verbatim}
#  Name:
#     scbcp.pl

#  Purpose:
#     Copy SCB indexes from one directory to another.

#  Language:
#     Perl 5

#  Invocation:
#     scbcp.pl $dir1 $dir2

#  Description:
#     This utility copies all the index files used by the SCB package
#     from one directory to another.  It is an improvement on copying
#     the files using cp in two ways:
#
#        1) It knows which files to copy.
#        2) It will copy sparse files in a sparse way.
#
#     The second may be important depending on the implementation of 
#     DBM being used.  Some DBMs can create sparse files, that is ones
#     with large 'holes' in them, which occupy few disk blocks but 
#     when copied in any of the usual ways (for instance with cp(1))
#     produce files which occupy many more blocks.  Whether a file is
#     sparse can be determined by comparing the output of 'ls -l' and 
#     'ls -s'.
#
#     During operation, the utility reports the copies being carried out.
#
#     This utility is not required for normal operation of the package,
#     it is provided for optional use.

#  Arguments:
#     dir1
#        Source directory containing SCB indexes.
#     dir2
#        Target directory into which SCB indexes are to be copied.
\end{verbatim}
Thus to create a private copy of the SCB indexes, for instance
in order to create a modified personal index, a command like the
following would be used:
\begin{quote}
\begin{verbatim}
% scbcp.pl /star/etc/scb ~/star/etc/scb
/star/etc/scb/tasks -> /home/user/star/etc/scb/tasks
/star/etc/scb/func -> /home/user/star/etc/scb/func
/star/etc/scb/file -> /home/user/star/etc/scb/file
\end{verbatim}
\end{quote}


% ? End of main text
\end{document}

% $Id$
