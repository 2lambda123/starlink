#!/usr/local/bin/perl -w

#+
#  Name:
#     scb.pl

#  Purpose:
#     Generate listing of a Starlink source code file.

#  Language:
#     Perl 5

#  Description:
#     This script extracts the source code for a routine in the USSC.  
#     The only input value it takes is the name of the routine, which
#     must be the key of an entry in the index dbm file generated by
#     scbindex.
#
#     It operates in two modes:
#        text:  prints the source file raw.
#        HTML:  prints the source code with HTML markup.
#
#     Normally, it will choose between the two modes according to whether 
#     it appears to have been called as a CGI program or not.  This can
#     be overridden to produce HTML output from the command line however.

#  Authors:
#     MBT: Mark Taylor (IoA, Starlink)
#     {enter_new_authors_here}

#  History:
#     25-AUG-1998 (MBT):
#       Initial revision.
#     {enter_further_changes_here}

#  Bugs:
#     {note_any_bugs_here}

#-

#  File locations.

$indexfile = "/local/devel/scb/index";
$taskfile  = "/local/devel/scb/tasks";

#  Directory locations.

$tmpdir = "/local/junk/scb/unpack";    # scratch directory

#  Name of this program relative to this program.

$self = $0;
$self =~ s%.*/%%;
$scb = $self;
$usage = "Usage: $self <module>\n";

#  Required libraries.

use Fcntl;
use SDBM_File;
use libscb;

#  Declarations.

sub get_module;
sub query_form;
sub extract_file;
sub output;
sub error;
sub header;
sub footer;
sub hprint;

#  Determine operating environment.

$cgi = defined $ENV{'SERVER_PROTOCOL'};
print "Content-Type: text/html\n\n" if ($cgi);
$html = $cgi;

#  Name of source module to locate.

if ($cgi) {
   $module = $ENV{'QUERY_STRING'};
}
else {
   $module = shift @ARGV;
}

if ($module) {
   $module =~ s/^module=//;
   get_module $module;
}
else {
   if ($cgi) {
      query_form;
   }
   else {
      $0 =~ s%.*/%%;
      die $usage;
   }
}

#  End

exit;

########################################################################
# Subroutines.
########################################################################


########################################################################
sub query_form {

#  CGI output of the program when no arguments have been specified.

   header $self;
   hprint <<"   END"
      <h1>$self: Starlink Source Code Browser</h1>
      <form method=GET action="$self">
          Name of source module:
          <input name=module size=24 value=''>
      </form>
      <hr>
   END
   ;
   open TASKS, $taskfile or error "Couldn't open $taskfile";
   while (<TASKS>) {
      ($package, @tasks) = split;
      # next unless @tasks;
      $package =~ s/:?$//;
      print "<h3>$package</h3>\n";
      foreach $task (@tasks) {
         print "<a href='$scb?$task#$task'>$task</a>\n";
      }
   }
   print "<hr>\n";
   hprint "
      This list of tasks is generated automatically and is probably
      not comprehensive.  Just because a task does not appear on this
      list does not mean it doesn't exist.
   ";
   footer;
}
   



########################################################################
sub get_module {

#  This routine takes the name of a module, locates it using the index
#  dbm, and outputs it in an appropriate form.

#  Arguments.

   $module = shift;

#  Open index file, tied to index hash %locate.

   tie %locate, SDBM_File, $indexfile, O_RDONLY, 0644;

#  Set locations of logical names appearing in logical paths.
#  It may be desirable to override these if the database has been moved.

   $basedir{'SOURCE'}  = $locate{'#SOURCE'};
   $basedir{'INCLUDE'} = $locate{'#INCLUDE'};

#  Set up scratch directory.

   system "mkdir -p $tmpdir" and error "Failed to mkdir $tmpdir: $?";
   chdir $tmpdir             or  error "Failed to enter $tmpdir";

#  Get logical path name from database.

   $location = $locate{$module};
   unless ($location) {
      error "Failed to find module $module",
         "Probably this is a result of a deficiency in the source
          code indexing program, but it may be because the index 
          database <code>$indexfile</code> has become out of date.";
   }

#  Substitute in base directory name.

   $location =~ s%(^[^/]*)(.*)$%$basedir{$1}/$2%;

#  Extract file from logical path.

   extract_file $location;

}

########################################################################
sub extract_file {

#  This routine takes as argument the logical path name of a file, 
#  and, by calling itself recursively to extract files from tar 
#  archives, finishes by calling routine 'output' with a filename
#  (possibly relative to the current directory) containing the 
#  requested module.

#  Arguments.

   my $location = shift;

   $location =~ /^([^>]+)>?([^>]*)(>?.*)$/;
   ($file, $tarcontents, $tail) = ($1, $2, $3);
   if ($tarcontents) {
      tarxf $file, $tarcontents;
      extract_file "$tarcontents$tail";
      unlink $tarcontents;
   }
   else {
      output $file;
   }
}


########################################################################
sub output {

#  Arguments.

   my $file = shift;              #  Filename of file to output.

#  Get file type.

   $file =~ m%\.([^/]*)$%;
   my $ftype = $1;
   $ftype = 'f'   if ($ftype eq 'gen');
   $ftype = 'c'   if ($ftype eq 'h');

#  Open module source file.

   open FILE, $file 
      or error "Failed to open $file - index may be outdated.";

#  Output appropriate header text.

   if ($html) {
      header $locate{$module};
      print "<pre>\n" if ($html);
   }
   else {
      print STDERR $location;
   }

   my ($body, $name, @names, $include, $sub);
   while (<FILE>) {
      if ($html) {

#        Identify active part of line.

         if ($ftype eq 'f') {

            $body = /^[cC*]/ ? '' : $_;     #  Ignore comments.
            if ($body) {
               $body =~ s/^......//;        #  Discard first six characters.
               $body =~ s/!.*//;            #  Discard inline comments.
               $body =~ s/\s//g;            #  Discard spaces.
               $body =~ y/a-z/A-Z/;         #  Fold to upper case.
            }
         }

         elsif ($ftype eq 'c') {

            $body = $_;
            $body =~ s%/\*.*\*/%%g;         #  Discard comments fully inline.
            $body =~ s%/\*.*%%;             #  Discard started comments.
         }

#        Substitute for HTML meta-characters.

         s%>%&gt;%g;
         s%<%&lt;%g;

         if ($body) {

#           Identify and deal with lines beginning modules.

            if ($name = module_name $ftype, $_) {

#              Embolden module name.

               s%($name)%<b>$1</b>%i;

#              Add anchors (multiple ones if generic function).

               @names = ($name);
               if ($name =~ /^(.*)&LT;T&GT;(.*)/) {
                  ($g1, $g2) = ($1, $2);
                  @names = map "$g1$_$g2", qw/I R D L C B UB W UW/; 
               }
               foreach $name (@names) {
                  s/^/<a name='$name'>/;
               }

            }

            if ($ftype eq 'f') {

#              Identify and deal with fortran includes.

               if ($body =~ /\bINCLUDE['"]([^'"]+)['"]/) {
                  $include = $1;
                  s%$include%<a href='$scb?$include'>$include</a>%;
               }

#              Identify and deal with fortran subroutine calls.

               if ($body =~ /\bCALL(\w+)[^=]*$/) {
                  $sub = $1;
                  s%$sub%<a href='$scb?$sub#$sub'>$sub</a>%;
               }
            }
            elsif ($ftype eq 'c') {

#              Identify and deal with C calls to fortran routines.

               if ($body =~ /F77_CALL\s*\(\s*(\w+)\s*\)/) {
                  $sub = $1;
                  $module = uc $sub;
                  s%$sub%<a href='$scb?$module#$module'>$sub</a>%;
               }

#              Identify and deal with C includes.

               if ($body =~ /#include\s*"\s*(\S+)\s*"/) {
                  $include = $1;
                  s%$include%<a href='$scb?$include'>$include</a>%;
               }
            }
         }
      }

#     Output (modified or unmodified) line of source.

      print;
   }
   close FILE;

#  Output appropriate footer text.

   footer;

}


########################################################################
sub error {

#  Arguments.

   my ($message, $more) = @_;

   if ($html) {
      header "Error";
      print "<h1>Error</h1>\n";
      hprint "<b>$message</b>\n";
      hprint "<p>\n$more\n" if $more;
      footer;
      exit 1;
   }
   else {
      die "$message\n";
   }
}



########################################################################
sub header {

#  Arguments.

   my $title = shift;

   if ($html) {
      print "<html>\n";
      print "<head><title>$title</title></head>\n";
      print "<body>\n";
   }
}


########################################################################
sub footer {
   print "</body>\n</html>\n" if $html;
}


########################################################################
sub hprint {

#  Utility routine - this just prints a string after first stripping 
#  leading whitespace from each line.  Its only purpose is to
#  allow here-documents which don't mess up the indenting of the 
#  perl source.

   local $_ = shift;
   s%^\s*%%mg;
   print;
}
