#!/usr/local/bin/perl -w

#+
#  Name:
#     scb.pl

#  Purpose:
#     Generate listing of a Starlink source code file.

#  Language:
#     Perl 5

#  Description:
#     This script extracts the source code for a routine in the USSC.  
#     The only input value it takes is the name of the routine, which
#     must be the key of an entry in the index dbm file generated by
#     scbindex.
#
#     It operates in two modes:
#        text:  prints the source file raw.
#        HTML:  prints the source code using CGI format with HTML markup.
#
#     It chooses between the two modes according to whether it appears to
#     have been called as a CGI program or not.

#  Authors:
#     MBT: Mark Taylor (IoA, Starlink)
#     {enter_new_authors_here}

#  History:
#     25-AUG-1998 (MBT):
#       Initial revision.
#     {enter_further_changes_here}

#  Bugs:
#     {note_any_bugs_here}

#-

#  Index file location.

$indexfile = "/local/devel/scb/index";

#  Directory locations.

$tmpdir = "/local/junk/scb/unpack";    # scratch directory

#  Name of this program relative to this program.

$self = $0;
$self =~ s%.*/%%;
$scb = $self;
$usage = "Usage: $self <module>\n";

#  Required libraries.

use Fcntl;
use SDBM_File;
use libscb;

#  Declarations.

sub get_module;
sub query_form;
sub extract_file;
sub output;
sub error;
sub header;
sub footer;
sub hprint;

#  Determine operating environment.

$cgi = defined $ENV{'SERVER_PROTOCOL'};
$html = $cgi;

#  Name of source module to locate.

if ($cgi) {
   $module = $ENV{'QUERY_STRING'};
}
else {
   $module = shift @ARGV;
}

if ($module) {
   $module =~ s/^module=//;
   get_module $module;
}
else {
   if ($cgi) {
      query_form;
   }
   else {
      $0 =~ s%.*/%%;
      die $usage;
   }
}

#  End

exit;

########################################################################
# Subroutines.
########################################################################


########################################################################
sub query_form {

#  CGI output of the program when no arguments have been specified.

   header $self;
   hprint <<"   END"
      <h1>$self: Starlink Source Code Browser</h1>
      <form method=GET action="$self">
          Name of source module:
          <input name=module size=24 value=''>
      </form>
   END
   ;

   footer;
}
   



########################################################################
sub get_module {

#  This routine takes the name of a module, locates it using the index
#  dbm, and outputs it in an appropriate form.

#  Arguments.

   $module = shift;

#  Open index file, tied to index hash %locate.

   tie %locate, SDBM_File, $indexfile, O_RDONLY, 0644;

#  Set locations of logical names appearing in logical paths.
#  It may be desirable to override these if the database has been moved.

   $basedir{'SOURCE'}  = $locate{'#SOURCE'};
   $basedir{'INCLUDE'} = $locate{'#INCLUDE'};

#  Set up scratch directory.

   system "mkdir -p $tmpdir" and error "Failed to mkdir $tmpdir: $?";
   chdir $tmpdir             or  error "Failed to enter $tmpdir";

#  Get logical path name from database.

   $location = $locate{$module};
   error "Failed to find $module; index may be outdated." unless $location;

#  Substitute in base directory name.

   $location =~ s%(^[^/]*)(.*)$%$basedir{$1}/$2%;

#  Extract file from logical path.

   extract_file $location;

}

########################################################################
sub extract_file {

#  This routine takes as argument the logical path name of a file, 
#  and, by calling itself recursively to extract files from tar 
#  archives, finishes by calling routine 'output' with a filename
#  (possibly relative to the current directory) containing the 
#  requested module.

#  Arguments.

   my $location = shift;

   $location =~ /^([^>]+)>?([^>]*)(>?.*)$/;
   ($file, $tarcontents, $tail) = ($1, $2, $3);
   if ($tarcontents) {
      tarxf $file, $tarcontents;
      extract_file "$tarcontents$tail";
      unlink $tarcontents;
   }
   else {
      output $file;
   }
}


########################################################################
sub output {

#  Arguments.

   my $file = shift;

#  Open module source file.

   open FILE, $file 
      or error "Failed to open $file - index may be outdated.";

#  Output appropriate header text.

   header $file;
   print "<pre>\n" if ($html);

   my ($body, $name, @names, $include, $sub);
   while (<FILE>) {
      if ($html) {

#        Identify active part of line.

         $body = /^[cC*]/ ? '' : $_;     #  Ignore comments.
         if ($body) {
            $body =~ s/^......//;        #  Discard first six characters.
            $body =~ s/!.*//;            #  Discard inline comments.
            $body =~ s/\s//g;             #  Discard spaces.
            $body =~ y/a-z/A-Z/;         #  Fold to upper case.
         }

#        Substitute for HTML meta-characters.

         s%>%&gt;%g;
         s%<%&lt;%g;

         if ($body) {

#           Identify and deal with lines beginning modules.

            if ($name = module_name) {

#              Embolden module name.

               s%($name)%<b>$1</b>%;

#              Add anchors (multiple ones if generic function).

               @names = ($name);
               if ($name =~ /^(.*)&LT;T&GT;(.*)/) {
                  ($g1, $g2) = ($1, $2);
                  @names = map "$g1$_$g2", qw/I R D L C B UB W UW/; 
               }
               foreach $name (@names) {
                  s/^/<a name='$name'>/;
               }

            }

#           Identify and deal with fortran includes.

            if ($body =~ /\bINCLUDE['"]([^'"]+)['"]/) {
               $include = $1;
               s%$include%<a href='$scb?$include'>$include</a>%;
            }

#           Identify and deal with fortran subroutine calls.

            if ($body =~ /\bCALL(\w+)[^=]*$/) {
               $sub = $1;
               s%$sub%<a href='$scb?$sub#$sub'>$sub</a>%;
            }

         }
      }

#     Output (modified or unmodified) line of source.

      print;
   }
   close FILE;

#  Output appropriate footer text.

   footer;

}


########################################################################
sub error {

#  Arguments.

   my $message = shift;

   if ($html) {
      header "Error";
      print "<h1>Error</h1>\n";
      print "$message\n";
      footer;
      exit 1;
   }
   else {
      die "$message\n";
   }
}



########################################################################
sub header {

#  Arguments.

   my $title = shift;

   if ($cgi) {
      print "Content-Type: text/html\n\n";
   }
   if ($html) {
      print "<html>\n";
      print "<head><title>$title</title></head>\n";
      print "<body>\n";
   }
}


########################################################################
sub footer {
   print "</body>\n</html>\n" if $html;
}


########################################################################
sub hprint {

#  Utility routine - this just prints a string of which each of the 
#  lines may have a load of leading spaces.  Its only purpose is to
#  allow here documents which don't mess up the indenting of the 
#  perl source.

   local $_ = shift;
   s%^\s*%%mg;
   print;
}
