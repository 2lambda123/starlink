\sstroutine{
   SCULIB\_1D2\_JIGGLE
}{
   routine to unpack a 1-d jiggle dataset into a 2-d
   image
}{
   \sstdescription{
      This routine unpacks the data for a specified bolometer from a
      dataset stored according to jiggle number into a 2-d dataset
      with data stored according to jiggle offset.
        The input dataset can contain data either from all or part of
      ONE run through the jiggle pattern or for several REPEATS of
      the entire pattern. In the first case, the routine copies the
      input data into the appropriate part of the 2-d image. In the
      second, the 2-d datum for a given pixel will be the average of the
      input values for it, and the variance will calculated from the
      spread of input points around the mean unless only one input point
      contributed, in which case the input variance will be used.
   }
   \sstinvocation{
       CALL SCULIB\_1D2\_JIGGLE (BOL, N\_BOLS, J\_START, N\_JIG,
         J\_REPEAT, J\_COUNT, J\_DATA, J\_VARIANCE, J\_QUALITY, IDIM,
         JDIM, I\_JIGGLE, J\_JIGGLE, DATA\_2D, VARIANCE\_2D, QUALITY\_2D,
         STATUS)
   }
   \sstarguments{
      \sstsubsection{
         BOL                          = INTEGER (Given)
      }{
         the number of the bolometer whose data is to be unpacked
      }
      \sstsubsection{
         N\_BOLS                       = INTEGER (Given)
      }{
         the number of bolometers measured
      }
      \sstsubsection{
         J\_START                      = INTEGER (Given)
      }{
         the index within the pattern of the first jiggle position
         measured
      }
      \sstsubsection{
         N\_JIG                        = INTEGER (Given)
      }{
         the total number of jiggle positions measured
      }
      \sstsubsection{
         J\_REPEAT                     = INTEGER (Given)
      }{
         the number of times the jiggle pattern was repeated in the
         dataset
      }
      \sstsubsection{
         J\_COUNT                      = INTEGER (Given)
      }{
         the number of jiggles in the pattern
      }
      \sstsubsection{
         J\_DATA (N\_BOLS, N\_JIG)
      }{
                                = REAL (Given)
         the measured data at each jiggle position
      }
      \sstsubsection{
         J\_VARIANCE (N\_BOLS, N\_JIG)
      }{
                                = REAL (Given)
         the measured variance
      }
      \sstsubsection{
         J\_QUALITY (N\_BOLS, N\_JIG)
      }{
                                = INTEGER (Given)
         the quality on the measured data
      }
      \sstsubsection{
         IDIM                         = INTEGER (Given)
      }{
         the x dimension of the 2-d map
      }
      \sstsubsection{
         JDIM                         = INTEGER (Given)
      }{
         the y dimension of the 2-d map
      }
      \sstsubsection{
         I\_JIGGLE (J\_COUNT)           = INTEGER (Given)
      }{
         the `i{\tt '} index on the 2-d map of each jiggle position
      }
      \sstsubsection{
         J\_JIGGLE (J\_COUNT)           = INTEGER (Given)
      }{
         the `j{\tt '} index on the 2-d map of each jiggle position
      }
      \sstsubsection{
         DATA\_2D (IDIM, JDIM)         = REAL (Returned)
      }{
         the data plane of the 2-d map
      }
      \sstsubsection{
         VARIANCE\_2D (IDIM, JDIM)     = REAL (Returned)
      }{
         the variance plane
      }
      \sstsubsection{
         QUALITY\_2D (IDIM, JDIM)      = INTEGER (Returned)
      }{
         the quality plane
      }
      \sstsubsection{
         STATUS                       = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_2POS\_CONFN
}{
   Generate a convolution function to remove the 2-position
   chop function from raster scans
}{
   \sstdescription{
       This routine will return the asymmetric convolution function
       required for deconvolving a dual beam map into a single beam map.
       It is the convolution function that is derived in Emerson Klein
       and Haslam (1979) Astron. Astrophys. 76 p92 paper.

      For the case where UNBAL = 1, the two beams are of equal strength:-

       The ideal convolution function would be the one whose FT was the
       inverse of the FT of the chop function. Unfortunately, the chop
       function FT has zeroes in it, at which the inverse FT will tend to
       infinity. The ideal convolution function, therefore, does not exist.
       This problem is avoided by generating a function whose FT is the
       same as the ideal function except at the problem points, where it is
       set to zero. This function consists of a series of delta functions
       separated by the chop spacing, the central 2 points being half the
       chop spacing on either side of the centre of the function.

       The function is normalised such that convolving this function with
       an original chop function of 2 delta functions of unit height will
       give a delta function of height 1.

      Don{\tt '}t understand what happens when UNBAL $<$$>$ 1, but the code has left
      doing the same as NOD2.

       The convolution must cover the map even when the centre of the function
       is at the left or right hand extremity of the map. Hence the convolution
       function must be twice the length of the raw map.

       Since the raw data is not sampled such that the chop spacing is an
       integer number of samples, the actual convolution function must be
       rebinned onto the sample mesh by sinc interpolation.

       This routine is essentially a rewritten version of CONF22 from the
       RESTOR program in the NOD2 package by Haslam (1974) Astron.
       Astrophys. Suppl. 15 p333
   }
   \sstinvocation{
       CALL SCULIB\_2POS\_CONFN (BSEP, PIXSEP, NPIX, UNBAL, NCFN, CONF,
         STATUS)
   }
   \sstarguments{
      \sstsubsection{
         BSEP = REAL (Given)
      }{
         The beam separation in arcseconds
      }
      \sstsubsection{
         PIXSEP = REAL (Given)
      }{
         The pixel separation in arcseconds
      }
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in the x direction
      }
      \sstsubsection{
         UNBAL = REAL (Given)
      }{
         The relative amplitudes of the right and left hand beams
         UNBAL=amp(lhb)/abs(amp(rhb))
      }
      \sstsubsection{
         NCFN = INTEGER (Returned)
      }{
         The length of the convolution array
      }
      \sstsubsection{
         CONF( $*$ ) = REAL (Returned)
      }{
         The convolution function
      }
      \sstsubsection{
         STATUS = INTEGER (Given and returned)
      }{
         Global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_2POS\_DECONV
}{
   deconvolve square chop from scan
}{
   \sstdescription{
      This routine deconvolves the chopped beam response from the
      individual scans of a SCUBA raster map.
         To achieve this it cycles through the scans making up the
      observation, calling SCULIB\_FIND\_SWITCH to locate the start and
      finish indices of each scan in the demodulated data array. If
      SCULIB\_FIND\_SWITCH indicates that there is no data for this scan,
      which might happen if the observation was aborted, then no further
      action is taken. If the scan is too long to be handled by the
      routine an error message will be output and the routine will return
      with bad status.
         Otherwise, SCULIB\_GENSYCONFN and SCULIB\_2POS\_CONFN will be
      called to generate the convolution functions needed to deconvolve
      the chop. The routine then cycles through the bolometers, calling
      SCULIB\_CONVOLVE to do the required convolutions with the scan data
      for each.
   }
   \sstinvocation{
       CALL SCULIB\_2POS\_DECONV (N\_EXPOSURES, N\_INTEGRATIONS,
         N\_MEASUREMENTS, DEMOD\_POINTER, N\_BOL, N\_POS, IN\_DATA,
         IN\_VARIANCE, IN\_QUALITY, SAMPLE\_DX, BEAM\_SEP,
         OUT\_DATA, OUT\_VARIANCE, OUT\_QUALITY, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         N\_EXPOSURES                 = INTEGER (Given)
      }{
         maximum number of exposures per integration
      }
      \sstsubsection{
         N\_INTEGRATIONS              = INTEGER (Given)
      }{
         number of integrations in the observation
      }
      \sstsubsection{
         N\_MEASUREMENTS              = INTEGER (Given)
      }{
         number of measurements in the observation
      }
      \sstsubsection{
         DEMOD\_POINTER (N\_EXPOSURES, N\_INTEGRATIONS, N\_MEASUREMENTS)
      }{
         array pointing to start and finish of scans in IN\_DATA
      }
      \sstsubsection{
         N\_BOL                       = INTEGER (Given)
      }{
         the number of bolometers for which data was taken
      }
      \sstsubsection{
         N\_POS                       = INTEGER (Given)
      }{
         the number of positions measured in the scan
      }
      \sstsubsection{
         IN\_DATA (N\_BOL, N\_POS)      = REAL (Given)
      }{
         the measured data
      }
      \sstsubsection{
         IN\_VARIANCE (N\_BOL, N\_POS)  = REAL (Given)
      }{
         the variance on IN\_DATA
      }
      \sstsubsection{
         IN\_QUALITY (N\_BOL, N\_POS)   = BYTE (Given)
      }{
         the quality on IN\_DATA
      }
      \sstsubsection{
         SAMPLE\_DX                   = REAL (Given)
      }{
         the measurement spacing along the scan (arcseconds)
      }
      \sstsubsection{
         BEAM\_SEP                    = REAL (Given)
      }{
         the beam separation (arcseconds)
      }
      \sstsubsection{
         OUT\_DATA (N\_BOL, N\_POS)     = REAL (Returned)
      }{
         the deconvolved data
      }
      \sstsubsection{
         OUT\_VARIANCE (N\_BOL, N\_POS) = REAL (Returned)
      }{
         the variance on OUT\_DATA
      }
      \sstsubsection{
         OUT\_QUALITY (N\_BOL, N\_POS)  = BYTE (Returned)
      }{
         the quality on OUT\_DATA
      }
      \sstsubsection{
         BADBIT                      = BYTE (Given)
      }{
         bad bit mask
      }
      \sstsubsection{
         STATUS                      = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_3POS\_CONFN
}{
   Generate a convolution function to remove the 3-position
   chop function from raster scans
}{
   \sstdescription{
      This routine will return the convolution function
      required for deconvolving the 3-position chop from a scan.

      This function consists of a series of delta functions at a spacing
      equal to that between a -ve spike and the central spike of the
      3-position chop. The height of the delta dunctions peaks at the
      centre of the convolution function and falls off by 1 at a time for
      the delta functions on either side, so that the envelope of the
      function is an isosceles triangle.

      The convolution function must cover the scan even when the centre of
      the function is at one end of it. Hence, the convolution function
      must be twice the length of the scan.

      Since the raw data are not sampled such that the chop spacing is an
      integer number of samples, the actual convolution function must be
      rebinned onto the sample mesh by sinc interpolation.
   }
   \sstinvocation{
       CALL SCULIB\_3POS\_CONFN (BSEP, PIXSEP, NPIX, NCFN, CONF,
         STATUS)
   }
   \sstarguments{
      \sstsubsection{
         BSEP = REAL (Given)
      }{
         The beam separation in arcseconds
      }
      \sstsubsection{
         PIXSEP = REAL (Given)
      }{
         The pixel separation in arcseconds
      }
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in the x direction
      }
      \sstsubsection{
         NCFN = INTEGER (Returned)
      }{
         The length of the convolution array
      }
      \sstsubsection{
         CONF( $*$ ) = REAL (Returned)
      }{
         The convolution function
      }
      \sstsubsection{
         STATUS = INTEGER (Given and returned)
      }{
         Global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_3POS\_DECONV
}{
   deconvolve 3-position chop from scan
}{
   \sstdescription{
      This routine deconvolves the 3 position chopped beam response from the
      individual scans of a SCUBA raster map.
         To achieve this it cycles through the scans making up the
      observation, calling SCULIB\_FIND\_SWITCH to locate the start and
      finish indices of each scan in the demodulated data array. If
      SCULIB\_FIND\_SWITCH indicates that there is no data for this scan,
      which may happen if the observation was aborted, then no further
      action is taken. If a scan is too long to be handled by the routine
      an error message will be output and the routine will return with
      bad status.
         Otherwise, SCULIB\_GENSYCONFN and SCULIB\_3POS\_CONFN will be
      called to generate the convolution functions needed to deconvolve
      the chop. The routine then cycles through the bolometers, calling
      SCULIB\_CONVOLVE to do the required convolutions with the scan data
      for each.
   }
   \sstinvocation{
       CALL SCULIB\_3POS\_DECONV (N\_EXPOSURES, N\_INTEGRATIONS,
         N\_MEASUREMENTS, DEMOD\_POINTER, N\_BOL, N\_POS, IN\_DATA,
         IN\_VARIANCE, IN\_QUALITY, SAMPLE\_DX, BEAM\_SEP,
         OUT\_DATA, OUT\_VARIANCE, OUT\_QUALITY, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         N\_EXPOSURES                 = INTEGER (Given)
      }{
         maximum number of exposures per integration
      }
      \sstsubsection{
         N\_INTEGRATIONS              = INTEGER (Given)
      }{
         number of integrations in the observation
      }
      \sstsubsection{
         N\_MEASUREMENTS              = INTEGER (Given)
      }{
         number of measurements in the observation
      }
      \sstsubsection{
         DEMOD\_POINTER (N\_EXPOSURES, N\_INTEGRATIONS, N\_MEASUREMENTS)
      }{
         array pointing to start and finish of scans in IN\_DATA
      }
      \sstsubsection{
         N\_BOL                       = INTEGER (Given)
      }{
         the number of bolometers for which data was taken
      }
      \sstsubsection{
         N\_POS                       = INTEGER (Given)
      }{
         the number of positions measured in the scan
      }
      \sstsubsection{
         IN\_DATA (N\_BOL, N\_POS)      = REAL (Given)
      }{
         the measured data
      }
      \sstsubsection{
         IN\_VARIANCE (N\_BOL, N\_POS)  = REAL (Given)
      }{
         the variance on IN\_DATA
      }
      \sstsubsection{
         IN\_QUALITY (N\_BOL, N\_POS)   = BYTE (Given)
      }{
         the quality on IN\_DATA
      }
      \sstsubsection{
         SAMPLE\_DX                   = REAL (Given)
      }{
         the measurement spacing along the scan (arcseconds)
      }
      \sstsubsection{
         BEAM\_SEP                    = REAL (Given)
      }{
         the beam separation (arcseconds)
      }
      \sstsubsection{
         OUT\_DATA (N\_BOL, N\_POS)     = REAL (Returned)
      }{
         the deconvolved data
      }
      \sstsubsection{
         OUT\_VARIANCE (N\_BOL, N\_POS) = REAL (Returned)
      }{
         the variance on OUT\_DATA
      }
      \sstsubsection{
         OUT\_QUALITY (N\_BOL, N\_POS)  = BYTE (Returned)
      }{
         the quality on OUT\_DATA
      }
      \sstsubsection{
         STATUS                      = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_ADD\_CHOP
}{
   Add chop throw to apparent RA/Dec
}{
   \sstdescription{
      This routine takes a chop throw and adds it on the
      supplied apparent RA/Dec centre position returning a new
      apparent RA/Dec. Works with scan map and jiggle map
      but does not actually know the difference itself (unless
      using SC chop). For EKH (SC) chopping we have to convert
      the scan ends to tangent plane offsets from the reference
      centre before calculating the angle.
   }
   \sstinvocation{
       CALL SCULIB\_ADD\_CHOP(BEAM, RA\_REF\_CENTRE, DEC\_REF\_CENTRE, RA\_CENTRE,
            DEC\_CENTRE, CHOP\_CRD, CHOP\_PA, CHOP\_FUN, CHOP\_THROW,
            LST, MJD, LAT\_OBS, RA\_START, RA\_END, DEC\_START,
            DEC\_END, OUT\_RA\_CEN, OUT\_DEC\_CEN,
            STATUS)
   }
   \sstarguments{
      \sstsubsection{
         BEAM        = CHARACTER $*$ ($*$) (Given)
      }{
         Beam name ({\tt '}M{\tt '},{\tt '}L{\tt '} or {\tt '}R{\tt '})
      }
      \sstsubsection{
         RA\_REF\_CENTRE = DOUBLE PRECISION (Given)
      }{
         Apparent RA of the map centre. This is the centre that
         scan map tangent plane offsets are calculated from.
      }
      \sstsubsection{
         DEC\_REF\_CENTRE = DOUBLE PRECISION (Given)
      }{
         Apparent dec of the map centre. This is the centre that
         scan map tangent plane offsets are calculated from.
      }
      \sstsubsection{
         RA\_CENTRE              = DOUBLE PRECISION (Given)
      }{
         the apparent RA of the `centre{\tt '} of the array (radians)
      }
      \sstsubsection{
         DEC\_CENTRE             = DOUBLE PRECISION (Given)
      }{
         the apparent dec of the `centre{\tt '} of the array (radians)
      }
      \sstsubsection{
         CHOP\_CRD               = CHARACTER $*$($*$) (Given)
      }{
         Coordinate system of CHOP throw (SC,AZ,RB,RJ,GA)
      }
      \sstsubsection{
         CHOP\_PA                = REAL (Given)
      }{
         Position angle of chop (in radians)
      }
      \sstsubsection{
         CHOP\_FUN               = CHARACTER $*$ ($*$) (Given)
      }{
         Chop function (CENTER, SQUARE, TRIPOS)
      }
      \sstsubsection{
         CHOP\_THROW             = REAL (Given)
      }{
         Chop throw in radians
      }
      \sstsubsection{
         LST                    = DOUBLE PRECISION (Given)
      }{
         the local sidereal time (radians)
      }
      \sstsubsection{
         MJD                    = DOUBLE PRECISION (Given)
      }{
         MJD of observation
      }
      \sstsubsection{
         LAT\_OBS                = DOUBLE PRECISION (Given)
      }{
         the latitude of the observatory (radians)
      }
      \sstsubsection{
         RA\_START               = REAL (Given)
      }{
         RA of start of scan (if SAMPLE\_MODE=RASTER)
      }
      \sstsubsection{
         RA\_END                 = REAL (Given)
      }{
         RA of end of scan (if SAMPLE\_MODE=RASTER)
      }
      \sstsubsection{
         DEC\_START              = REAL (Given)
      }{
         DEC of start of scan (if SAMPLE\_MODE=RASTER)
      }
      \sstsubsection{
         DEC\_END                = REAL (Given)
      }{
         DEC of end of scan (if SAMPLE\_MODE=RASTER)
      }
      \sstsubsection{
         OUT\_RA\_CEN             = DOUBLE (Returned)
      }{
         New position with CHOP
      }
      \sstsubsection{
         OUT\_DEC\_CEN            = DOUBLE (Returned)
      }{
         New DEC with CHOP
      }
      \sstsubsection{
         STATUS                 = INTEGER (Given and returned)
      }{
         The global status
      }
   }
   \sstnotes{
      It is assumed that the chop throw is divided by two
      prior to calling this routine for scan map mode since the
      chop is effectively half a chop either side of the middle.
      For jiggle modes the chop is effectively a full chop throw
      from the centre since the 3-beam chopping is done by a combination
      of chopping and nodding.
      \sstitemlist{

         \sstitem
         This routine does not yet support TRIPOS chopping (I think)

         \sstitem
         AZ, LO and SC chopping are supported

         \sstitem
         The negative beam is always the {\tt '}left{\tt '} beam, the $+$ve beam is the
           {\tt '}right{\tt '}.

         \sstitem
         The chop tracking {\tt '}droopy{\tt '} beam problem should be dealt with
           in an earlier subroutine such that the chop is converted from
           LO to AZ before calling this routine
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_ADD\_DEMOD\_EXPOSURE
}{
   add demodulated data for an exposure into the
   integration result
}{
   \sstdescription{
      This routine adds the reduced demodulated data for an exposure in a
      jiggle-sampled observation into the integration result.
        The exposure can contain data either for all or part of ONE run
      through the jiggle pattern or for several REPEATS of the entire jiggle
      pattern. In the first case, the routine copies the exposure data into
      the appropriate part of the integration arrays. In the second, the
      integration data will be the average of the input exposure values and the
      integration variance will be set equal to the exposure value if there
      was just one valid measurement, or calculated from the dispersion of
      the exposure data about the mean otherwise.
   }
   \sstinvocation{
       CALL SCULIB\_ADD\_DEMOD\_EXPOSURE (N\_BOLS, J\_START, N\_JIG,
         J\_REPEAT, J\_COUNT, EXP\_DATA, EXP\_VARIANCE, EXP\_QUALITY,
         INT\_DATA, INT\_VARIANCE, INT\_QUALITY, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         N\_BOLS                           = INTEGER (Given)
      }{
         the number of bolometers measured
      }
      \sstsubsection{
         J\_START                          = INTEGER (Given)
      }{
         the index within the pattern of the first jiggle position measured
      }
      \sstsubsection{
         N\_JIG                            = INTEGER (Given)
      }{
         the number of jiggle positions measured
      }
      \sstsubsection{
         J\_REPEAT                         = INTEGER (Given)
      }{
         the number of times the measured pattern was repeated
      }
      \sstsubsection{
         J\_COUNT                          = INTEGER (Given)
      }{
         the number of jiggle positions in the entire pattern
      }
      \sstsubsection{
         EXP\_DATA (N\_BOLS, N\_JIG)         = REAL (Given)
      }{
         the data for the exposure
      }
      \sstsubsection{
         EXP\_VARIANCE (N\_BOLS, N\_JIG)     = REAL (Given)
      }{
         the exposure variance
      }
      \sstsubsection{
         EXP\_QUALITY (N\_BOLS, N\_JIG)      = INTEGER (Given)
      }{
         the exposure quality
      }
      \sstsubsection{
         INT\_DATA (N\_BOLS, J\_COUNT)       = REAL (Returned)
      }{
         the integration data
      }
      \sstsubsection{
         INT\_VARIANCE (N\_BOLS, J\_COUNT)   = REAL (Returned)
      }{
         the integration variance
      }
      \sstsubsection{
         INT\_QUALITY (N\_BOLS, J\_COUNT)    = INTEGER (Returned)
      }{
         the integration quality
      }
      \sstsubsection{
         STATUS                           = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_ADDARE
}{
   add one real array to another into a third
}{
   \sstdescription{
      Adds two real arrays. Note that any of the arrays may be the same.
   }
   \sstinvocation{
       CALL SCULIB\_ADDARE (N, ARRAY1, ARRAY2, ARRAY3, Q1DATA,
          Q2DATA, Q3DATA, V1DATA, V2DATA, V3DATA, QUALITY, FLAGGED,
          VARIANCE)
   }
   \sstarguments{
      \sstsubsection{
         N            = INTEGER (Given)
      }{
         Number of elements in each array
      }
      \sstsubsection{
         ARRAY1 (N)   = REAL (Given)
      }{
         Input array
      }
      \sstsubsection{
         ARRAY2 (N)   = REAL (Given)
      }{
         Second input array
      }
      \sstsubsection{
         ARRAY3 (N)   = REAL (Returned)
      }{
         Result array.  ARRAY3 = ARRAY1 $+$ ARRAY2
      }
      \sstsubsection{
         Q1DATA (N)   = INTEGER (Given)
      }{
         Quality array for first input array
      }
      \sstsubsection{
         Q2DATA (N)   = INTEGER (Given)
      }{
         Quality array for second input array
      }
      \sstsubsection{
         Q3DATA (N)   = INTEGER (Returned)
      }{
         Quality array for output array
      }
      \sstsubsection{
         V1DATA (N)   = REAL (Given)
      }{
         Variance array for first input array
      }
      \sstsubsection{
         V2DATA (N)   = REAL (Given)
      }{
         Variance array for second input array
      }
      \sstsubsection{
         V3DATA (N)   = REAL (Returned)
      }{
         Variance array for output array
      }
      \sstsubsection{
         QUALITY      = LOGICAL (Given)
      }{
         True if input has quality information
      }
      \sstsubsection{
         FLAGGED      = LOGICAL (Given)
      }{
         True if input has flagged data values
      }
      \sstsubsection{
         VARIANCE     = LOGICAL (Given)
      }{
         True if both input arrays have variance arrays
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Does not use Quality correctly.
           Uses INTEGER quality rather than UBYTE
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         Propagates variance

         \sstitem
         Checks for bad values
      }
   }
}
\sstroutine{
   SCULIB\_ADDCAD
}{
   add a constant to a double array
}{
   \sstdescription{
      adds a real constant to a double array
   }
   \sstinvocation{
      CALL SCULIB\_ADDCAD (N, IN, RVAL, OUT)
   }
   \sstarguments{
      \sstsubsection{
         N              = INTEGER (Given)
      }{
         number of elements in arrays
      }
      \sstsubsection{
         IN (N)         = DOUBLE PRECISION (Given)
      }{
         input array
      }
      \sstsubsection{
         RVAL           = DOUBLE PRECISION (Given)
      }{
         real constant to be added to array
      }
      \sstsubsection{
         OUT (N)        = DOUBLE PRECISION (Returned)
      }{
         output array (may be same as input)
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         No range checks are performed

         \sstitem
         No status checking

         \sstitem
         No checks for bad values
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_ADDCAI
}{
   add a constant to an integer array
}{
   \sstdescription{
      adds an integer constant to an integer array
   }
   \sstinvocation{
      CALL SCULIB\_ADDCAI (N, IN, IVAL, OUT)
   }
   \sstarguments{
      \sstsubsection{
         N              = INTEGER (Given)
      }{
         number of elements in arrays
      }
      \sstsubsection{
         IN (N)         = INTEGER (Given)
      }{
         input array
      }
      \sstsubsection{
         IVAL           = INTEGER (Given)
      }{
         constant to be added to array
      }
      \sstsubsection{
         OUT (N)        = INTEGER (Returned)
      }{
         output array (may be same as input)
      }
   }
   \sstnotes{
      \sstitemlist{
         \sstitem
         No range checks are performed

         \sstitem
         No status checking

         \sstitem
         No checks for bad values
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_ADDCAR
}{
   add a constant to a real array
}{
   \sstdescription{
      adds a real constant to a real array
   }
   \sstinvocation{
      CALL SCULIB\_ADDCAR (N, IN, RVAL, OUT)
   }
   \sstarguments{
      \sstsubsection{
         N              = INTEGER (Given)
      }{
         number of elements in arrays
      }
      \sstsubsection{
         IN (N)         = REAL (Given)
      }{
         input array
      }
      \sstsubsection{
         RVAL           = REAL (Given)
      }{
         real constant to be added to array
      }
      \sstsubsection{
         OUT (N)        = REAL (Returned)
      }{
         output array (may be same as input)
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         No range checks are performed

         \sstitem
         No status checking

         \sstitem
         No checks for bad values
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_AIRMASS
}{
   calculate the airmass for a given zenith distance
}{
   \sstdescription{
      This routine calculates the airmass corresponding to the input
      zenith distance. The airmass is just sec(Z) until it reaches 2,
      after which a more complex algorithm developed by Ian Coulson
      is used (it is described by comments in the code). There may be
      a discontinuity in returned airmasses around the value 2, I
      haven{\tt '}t checked.
   }
   \sstinvocation{
      CALL SCULIB\_AIRMASS (Z, AIRMASS, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         Z               = REAL (Given)
      }{
         zenith distance (radians)
      }
      \sstsubsection{
         AIRMASS         = REAL (Returned)
      }{
         airmass
      }
      \sstsubsection{
         STATUS          = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1993-1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_ANALYSE\_PHOTOM\_JIGGLE
}{
   analyse the jiggle map made by a
   bolometer during a PHOTOM observation
}{
   \sstdescription{
      This routine analyses the jiggle map made by a bolometer during a
      PHOTOM observation.
         If status is good on entry the routine checks that the data array
      holds data for the specified bolometer. If it does not an error
      message will be output and the bad status returned.
         All being well the routine will analyse the data by the method
       specified in PHOTOM\_ANALYSIS:-

      AVERAGE -    the `result{\tt '} will be the mean of the jiggle points.
                   The variance is the sum of the variances of the averaged
                   data divided by the number of them squared. The result
                   will be flat-fielded and reported to the user. If no
                   valid data were available for the calculation of the
                   mean then a warning message will be output but good
                   status returned.

      PARABOLA -   the routine will call SCULIB\_FIT\_2D\_PARABOLA to fit a
                   2-d parabola to the data and the `result{\tt '} will be the
                   peak of the fitted curve. If the fit is good the results
                   will be flat-fielded and reported to the user. Otherwise
                   the result quality is set bad but good status will be
                   returned.
   }
   \sstinvocation{
       CALL SCULIB\_ANALYSE\_PHOTOM\_JIGGLE (PHOTOM\_ANALYSIS, BOL, N\_BOLS,
         J\_COUNT, JDATA, VARIANCE, QUALITY, RESULT\_D, RESULT\_V, RESULT\_Q,
         BADBIT, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         PHOTOM\_ANALYSIS              = CHARACTER$*$($*$) (Given)
      }{
         the method of analysis to be applied to the data
      }
      \sstsubsection{
         BOL                          = INTEGER (Given)
      }{
         the index of the bolometer whose data is to be analysed
      }
      \sstsubsection{
         N\_BOLS                       = INTEGER (Given)
      }{
         the number of bolometers being measured
      }
      \sstsubsection{
         J\_COUNT                      = INTEGER (Given)
      }{
         the number of jiggles in the pattern
      }
      \sstsubsection{
         JIGGLE\_X                     = REAL (Given)
      }{
         x jiggle offsets
      }
      \sstsubsection{
         JIGGLE\_Y                     = REAL (Given)
      }{
         y jiggle offsets
      }
      \sstsubsection{
         JDATA (N\_BOLS, J\_COUNT)       = REAL (Given)
      }{
         the measured data
      }
      \sstsubsection{
         VARIANCE (N\_BOLS, J\_COUNT)   = REAL (Given)
      }{
         the variance
      }
      \sstsubsection{
         QUALITY (N\_BOLS, J\_COUNT)    = BYTE (Given)
      }{
         the quality
      }
      \sstsubsection{
         RESULT\_D                     = REAL (Returned)
      }{
         the sum of the input data
      }
      \sstsubsection{
         RESULT\_V                     = REAL (Returned)
      }{
         the sum of the input variances
      }
      \sstsubsection{
         RESULT\_Q                     = BYTE (Returned)
      }{
         the quality on the sum
      }
      \sstsubsection{
         A0                           = REAL (Returned)
      }{
         fitted parabola parameter
      }
      \sstsubsection{
         A1                           = REAL (Returned)
      }{
         fitted parabola parameter
      }
      \sstsubsection{
         X0                           = REAL (Returned)
      }{
         x offset of peak of fitted parabola
      }
      \sstsubsection{
         Y0                           = REAL (Returned)
      }{
         y offset of peak of fitted parabola
      }
      \sstsubsection{
         BADBIT                       = BYTE (Given)
      }{
         bad bit mask
      }
      \sstsubsection{
         STATUS                       = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1993-1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_APPARENT\_2\_MP
}{
   Calculate mean place from a given apparent RA,Dec
}{
   \sstdescription{
      This routine takes the apparent RA,Dec as input and converts
      them to the position in a specified output coordinate system.
      Allowed OUTPUT\_COORDS are AZ, RJ, RB, GA, EQ.
      This is the reverse of SCULIB\_CALC\_APPARENT
   }
   \sstinvocation{
       CALL SCULIB\_APPARENT\_2\_MP(RA\_APP, DEC\_APP, OUT\_COORDS,
            LST, MJD, LAT\_OBS, LONG, LAT,
            STATUS )
   }
   \sstarguments{
      \sstsubsection{
         RA\_APP                 = DOUBLE PRECISION (Given)
      }{
         Apparent RA of point at date (radians)
      }
      \sstsubsection{
         DEC\_APP                = DOUBLE PRECISION (Given)
      }{
         Apparent Dec
      }
      \sstsubsection{
         OUT\_COORDS             = CHARACTER $*$ ($*$) (Given)
      }{
      }
      \sstsubsection{
         LST                    = DOUBLE PRECISION (Given)
      }{
         LST for requested coordinates (for AZ and HA)
      }
      \sstsubsection{
         MJD                    = DOUBLE PRECISION (Given)
      }{
         Modified Julian date of observation
      }
      \sstsubsection{
         LAT\_OBS                = DOUBLE PRECISION (Given)
      }{
         Latitude of observatory in radians.
         For JCMT this value is 3.46026051751D-1
      }
      \sstsubsection{
         LONG                   = DOUBLE PRECISION (Returned)
      }{
         longitude of centre in input coord system (radians)
      }
      \sstsubsection{
         LAT                    = DOUBLE PRECISION (Returned)
      }{
         latitude of centre in input coord system (radians)
      }
      \sstsubsection{
         STATUS                 = INTEGER (Given and returned)
      }{
         Global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_APPARENT\_2\_TP
}{
   calculate tangent plane coordinates from apparent
   RA, Decs
}{
   \sstdescription{
      This routine converts a list of apparent RA,Decs to tangent plane
      offsets from a tangent point whose position is also given in apparent
      RA,Dec. In addition, a rotation is applied to the tangent plane so that
      it can be aligned with a coordinate system other than apparent RA,Dec,
      and a shift is added to allow the map to be moved about in that output
      frame.
   }
   \sstinvocation{
       CALL SCULIB\_APPARENT\_2\_TP (N\_POS, BOL\_XPOS, BOL\_YPOS, RA\_CEN,
         DEC\_CEN, ROTATION, SHIFT\_DX, SHIFT\_DY, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         N\_POS                  = INTEGER (Given)
      }{
         the number of positions to be converted
      }
      \sstsubsection{
         BOL\_XPOS (N\_POS)       = DOUBLE PRECISION (Given and returned)
      }{
         apparent RA on input (radians), x tangent plane offset on
         output (radians)
      }
      \sstsubsection{
         BOL\_YPOS (N\_POS)       = DOUBLE PRECISION (Given and returned)
      }{
         apparent Dec on input (radians), y tangent plane offset on
         output (radians)
      }
      \sstsubsection{
         RA\_CEN                 = DOUBLE PRECISION (Given)
      }{
         apparent RA of tangent point (radians)
      }
      \sstsubsection{
         DEC\_CEN                = DOUBLE PRECISION (Given)
      }{
         apparent Dec of tangent point (radians)
      }
      \sstsubsection{
         ROTATION               = DOUBLE PRECISION (Given)
      }{
         angle between output North and apparent North (radians,
         measured anticlockwise from output North)
      }
      \sstsubsection{
         SHIFT\_DX               = DOUBLE PRECISION (Given)
      }{
         value to be added to x offsets (radians)
      }
      \sstsubsection{
         SHIFT\_DY               = DOUBLE PRECISION (Given)
      }{
         value to be added to y offsets (radians)
      }
      \sstsubsection{
         STATUS                 = INTEGER (Given and returned)
      }{
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_BESSEL\_WTINIT
}{
   Generate a weighting function for rebinning
}{
   \sstdescription{
      This is a FORTRAN version of the C code written for the transputer
      rebinning. Here is the C description:
      Initialise the BESSEL weighting function for Bessel interpolation.
      The 1-D function 2.0$*$J1(x)/x is initialised in the declaration, and the
      weighting function lookup table is calculated from this. The
      tabulation is at intervals of pi/RES for the range 0.0 to RADIUS$*$pi,
      resulting in (RES$*$RADIUS)$*$$*$2 values. The weight function is also
      multiplied by a cosine over the oute third to reduce edge effects.

      The look up table is initialised such that one can access the
      weight directly given the square of the distance between the input
      and output pixel. We use a fixed resolution out to 10PI.
   }
   \sstinvocation{
      CALL SCULIB\_BESSEL\_WTINIT( WTFN, RADIUES, RES, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         WTFN ( RADIUS $*$ RADIUS $*$ RES $*$ RES $+$ 1) = REAL (Returned)
      }{
         The weighting function generated by this routine.
         The index corresponds to the square of the distance from the
         centre in scale units.
      }
      \sstsubsection{
         RADIUS = INTEGER (Given)
      }{
         Size of the weighting function in scale units.
      }
      \sstsubsection{
         RES = INTEGER (Given)
      }{
         Number of points per scale lenghth.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_BESSJ1
}{
   calculates Bessel function J1(x)
}{
   \sstdescription{
      If status is good on entry this function returns the Bessel function
      J1(x) for any real x.
   }
   \sstinvocation{
      Y = SCULIB\_BESSJ1 (X, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         X                      = REAL (Given)
      }{
         the argument of the J1 Bessel function
      }
      \sstsubsection{
         STATUS                 = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         SCULIB\_BESSJ1 = REAL
      }{
         Bessel function J1(X)
      }
   }
   \sstnotes{
      Probably should be changed to use PDA\_DBESJ1 (SUN/194). That routine
      is DOUBLE PRECISION.
   }
   \sstdiytopic{
      Method
   }{
      Uses an algorithm from Numerical Recipes in Fortran.
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_BITON
}{
   turn on a bit
}{
   \sstdescription{
      Turns on a bit in a byte.
   }
   \sstinvocation{
      NEWBYTE = SCULIB\_BITON( VAL, BIT )
   }
   \sstarguments{
      \sstsubsection{
         VAL              = BYTE (Given)
      }{
         The byte to be changed
      }
      \sstsubsection{
         BIT              = INT (Given)
      }{
         The bit to be turned on
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         SCULIB\_BITON = BYTE
      }{
         Modified byte.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_BITOFF
}{
   Turn off a bit
}{
   \sstdescription{
      Turns off a bit in a byte
   }
   \sstinvocation{
      NEWBYTE = SCULIB\_BITOFF ( VAL, BIT )
   }
   \sstarguments{
      \sstsubsection{
         VAL              = BYTE (Given)
      }{
         The byte to be changed
      }
      \sstsubsection{
         BIT              = INT (Given)
      }{
         The bit to be turned off
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         SCULIB\_BITOFF = BYTE
      }{
         Modified byte.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_BITOR
}{
   Returns the bitwise OR of two bytes
}{
   \sstdescription{
      Returns the bitwise OR
   }
   \sstinvocation{
      LOGOR = SCULIB\_BITOR(VAL1, VAL2)
   }
   \sstarguments{
      \sstsubsection{
         VAL1              = BYTE (Given)
      }{
         First byte
      }
      \sstsubsection{
         VAL2              = BYTE (Given)
      }{
         Second byte
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         SCULIB\_BITOR = BYTE
      }{
         OR of bytes
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_BITAND
}{
   Calculate the bitwise AND of two bytes
}{
   \sstdescription{
      Returns the bitwise AND
   }
   \sstinvocation{
      LOGAND = SCULIB\_BITAND( VAL1, VAL2 )
   }
   \sstarguments{
      \sstsubsection{
         VAL1              = BYTE (Given)
      }{
         First byte
      }
      \sstsubsection{
         VAL2              = BYTE (Given)
      }{
         Second byte
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         SCULIB\_BITAND = BYTE
      }{
         AND of bytes.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_BITTEST
}{
   Test whether a bit is on
}{
   \sstdescription{
      Tests whether specified bit is turned on or not.
      Returns TRUE if it is on, false otherwise.
   }
   \sstinvocation{
      ISON = SCULIB\_BITTEST( VAL, BIT )
   }
   \sstarguments{
      \sstsubsection{
         VAL              = BYTE (Given)
      }{
         The byte to be tested
      }
      \sstsubsection{
         BIT              = INT (Given)
      }{
         The bit to be tested
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         SCULIB\_BITTEST = LOGICAL
      }{
         True if specified bit is turned on.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_BOLDECODE
}{
   decode a bolometer ID into ADC and channel number
}{
   \sstdescription{
      Given a character string containing a bolometer ID, put ADC and
      CHANNEL number into output variables. The syntax of the bolometer
      ID is a3, A3 or 3. Allowed ADCs run from a-i. Channels
      must be in range 1-16. Bolometer IDs outside these ranges will cause
      an error to be returned.
   }
   \sstinvocation{
      CALL SCULIB\_BOLDECODE (BOLCODE, ADC, CHANNEL, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         BOLCODE                     = CHARACTER$*$($*$) (given)
      }{
         bolometer ID
      }
      \sstsubsection{
         ADC                         = INTEGER (Returned)
      }{
         ADC number
      }
      \sstsubsection{
         CHANNEL                     = INTEGER (Returned)
      }{
         channel number
      }
      \sstsubsection{
         STATUS                      = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_BOLNAME
}{
   generate bolometer name from ADC and channel number
}{
   \sstdescription{
      Given bolometer ADC and channel, generate the bolometer name. E.g.
      ADC=2, CHAN=5 gives B5. If the ADC number is outside the range 1-9, or
      the channel number outside 1-16, and error will be reported and bad status
      returned.
   }
   \sstinvocation{
      CALL SCULIB\_BOLNAME (ADC, CHANNEL, BOLCODE, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         ADC                         = INTEGER (Given)
      }{
         ADC number
      }
      \sstsubsection{
         CHANNEL                     = INTEGER (Given)
      }{
         channel number
      }
      \sstsubsection{
         BOLCODE                     = CHARACTER$*$($*$) (Returned)
      }{
         bolometer ID
      }
      \sstsubsection{
         STATUS                      = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_BOLSELECT
}{
   interpret a list of selected bolometers
}{
   \sstdescription{
      Interpret a character string containing a list of bolometers,
      put number of bolometers to be used in N\_BOL\_SELECT, channel
      and ADC of selected bolometers in BOL\_SELECT\_CHAN and BOL\_SELECT\_ADC
      respectively. BOL\_ENABLED entries will also be set .TRUE. for bolometers
      that have been selected. The number of sub-instruments involved
      is returned in N\_SUB, and the names of the sub-instruments are given
      in SUB\_INSTRMNT. The Nasmyth coords of the point on the focal plane
      to be treated as the axis of the instrument will be returned in
      CENTRE\_DU3, CENTRE\_DU4.

      The given string can either be ALL, in which case all bolometer channels
      will be selected, or be a list of words specifying parts of the 144
      channel array. Each word in such a list must be separated from the others
      by {\tt '},{\tt '}, and the words can select bolometers by type - SHORT, LONG,
      P1100, P1300, P2000, SHORT\_DC, LONG\_DC, P1100\_DC, P1300\_DC, P2000\_DC,
      or by channel number, either individually or as a range, specified by
      ADC letter and channel number e.g. a3. Allowed ADCs are A-I and channels
      1-16.

      Repeated words in the list will be ignored, as will repeated selections
      of the same bolometer by different routes.

      The instrument sections returned in SUB\_INSTRMNT will be arranged in the
      order SHORT, LONG, P1100, P1300, P2000.

      CENTRE\_DU3, CENTRE\_DU4 will be set equal to ARRAY\_CENTRE\_DU3, ARRAY\_
      CENTRE\_DU4 if the first word in the selection is SHORT, LONG,
      SHORT\_DC or LONG\_DC. They will be set to the offsets of the bolometer
      concerned if the first word in the selection is P1100, P1300, P2000
      or a bolometer name like A7. If either of the coordinates ends up
      being set to the {\tt '}bad{\tt '} value, they will be reset to zero and a
      warning message output.

      Errors will be reported and bad status returned if -

      \sstitemlist{

         \sstitem
          there are too many words in BOLOMETERS

         \sstitem
          BOLOMETERS is empty

         \sstitem
          if when bolometers are selected by type
              no detectors of the desired type are found in the database

         \sstitem
          if the type selected refers to a single bolometer (P1100, P1300,
           P2000, SHORT\_DC, LONG\_DC, P1100\_DC, P1300\_DC, P2000\_DC)
              more than bolometer of the required type is found in the database

         \sstitem
          if bolometers are selected by ID, e.g. a15,
              the ID or range of IDs is bad

      }
      Warnings will be reported but good status returned if -

      \sstitemlist{

         \sstitem
          any selected bolometer has undefined attributes (type, calib, dU3, or
           dU4)

         \sstitem
          CENTRE\_DU3, CENTRE\_DU4 are set to {\tt '}bad{\tt '} values (they will be reset
           to 0 too)
      }
   }
   \sstinvocation{
       CALL SCULIB\_BOLSELECT (BOLOMETERS, BOL\_TYPE, BOL\_CALIB,
         BOL\_DU3, BOL\_DU4, BOL\_QUAL, BOL\_ENABLED, NUM\_CHAN, NUM\_ADC,
         ARRAY\_CENTRE\_DU3, ARRAY\_CENTRE\_DU4, BOL\_SELECT\_CHAN,
         BOL\_SELECT\_ADC, N\_BOL\_SELECT, MAX\_SUB, SUB\_INSTRMNT, N\_SUB,
         CENTRE\_DU3, CENTRE\_DU4, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         BOLOMETERS                  = CHARACTER$*$($*$) (Given)
      }{
         list of bolometer selections
      }
      \sstsubsection{
         BOL\_TYPE (NUM\_CHAN, NUM\_ADC)
      }{
                               = CHARACTER$*$($*$) (Given)
         type of bolometer
      }
      \sstsubsection{
         BOL\_CALIB (NUM\_CHAN, NUM\_ADC)
      }{
                               = REAL (Given)
         target calibrator values for bolometers
      }
      \sstsubsection{
         BOL\_DU3 (NUM\_CHAN, NUM\_ADC) = REAL (Given)
      }{
         Nasmyth dU3 offset of bolometer from field centre
      }
      \sstsubsection{
         BOL\_DU4 (NUM\_CHAN, NUM\_ADC) = REAL (Given)
      }{
         Nasmyth dU4 offset of bolometer from field centre
      }
      \sstsubsection{
         BOL\_QUAL (NUM\_CHAN, NUM\_ADC)
      }{
                               = INTEGER (Given)
         quality of bolometers
      }
      \sstsubsection{
         BOL\_ENABLED (NUM\_CHAN, NUM\_ADC)
      }{
                               = LOGICAL (Returned)
         .TRUE. if bolometer was selected
      }
      \sstsubsection{
         NUM\_CHAN                    = INTEGER (Given)
      }{
         number of channels per A/D
      }
      \sstsubsection{
         NUM\_ADC                     = INTEGER (Given)
      }{
         number of A/D cards
      }
      \sstsubsection{
         ARRAY\_CENTRE\_DU3            = REAL (Given)
      }{
         the DU3 offset of the centre to be used for either array
      }
      \sstsubsection{
         ARRAY\_CENTRE\_DU4            = REAL (Given)
      }{
         the DU4 offset of the centre to be used for either array
      }
      \sstsubsection{
         BOL\_SELECT\_CHAN (NUM\_CHAN $*$ NUM\_ADC)
      }{
                               = INTEGER (Returned)
         channel numbers of selected bolometers
      }
      \sstsubsection{
         BOL\_SELECT\_ADC (NUM\_CHAN $*$ NUM\_ADC)
      }{
                               = INTEGER (Returned)
         A/D card numbers of selected bolometers
      }
      \sstsubsection{
         N\_BOL\_SELECT                = INTEGER (Returned)
      }{
         total number of bolometers selected
      }
      \sstsubsection{
         MAX\_SUB                     = INTEGER (Given)
      }{
         maximum number of sub-instruments
      }
      \sstsubsection{
         SUB\_INSTRMNT (MAX\_SUB)      = CHARACTER$*$($*$) (Returned)
      }{
         names of instrument sections being used
      }
      \sstsubsection{
         N\_SUB                       = INTEGER (Returned)
      }{
         the number of sub-instruments being used
      }
      \sstsubsection{
         CENTRE\_DU3                  = REAL (Returned)
      }{
         the DU3 of the instrument {\tt '}centre{\tt '}
      }
      \sstsubsection{
         CENTRE\_DU4                  = REAL (Returned)
      }{
         the DU4 of the instrument {\tt '}centre{\tt '}
      }
      \sstsubsection{
         STATUS                      = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstnotes{
      The routine will not work properly if the input BOLOMETERS string
      is more than 400 characters long.
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_CALC\_APPARENT
}{
   calculate apparent RA, Dec of plate centre and angle
   of input coord system N relative to apparent N
}{
   \sstdescription{
      This routine takes the input coordinates and coordinate system of the
      map centre and converts them to the apparent coords at the time of the
      observation. In addition, the angle between the north direction in
      the input coordinate frame and that in the apparent frame is calculated
      (measured anti-clockwise from input north, in radians). See SCU/3.0/JFL/
      0393.

      \sstitemlist{

         \sstitem
         [AZ] coords:
            Calculate the apparent RA and DEC at the LST when the routine is
            called by:-

\begin{equation}
\sin(dec\_app) = \sin(lat\_obs) * \sin(el) + \cos(lat\_obs) * \cos(el) * \cos(az)
\end{equation}

\begin{equation}
\sin(H\_A) = - \frac{\sin(az) * \cos(el)}{\cos(dec\_app)}
\end{equation}

\begin{equation}
\cos(H\_A) = \frac{\sin(el) - \sin(dec\_app) * \sin(lat\_obs)}{\cos(dec\_app) * \cos(lat\_obs)}
\end{equation}

$\cos(dec\_app)$ is present in the denominator of both the
$\sin(H\_A)$ and $\cos(H\_A)$ terms and it could cause both to blow up -- so
it{\tt '}s left out as only the ratio is important

\begin{equation}
RA\_app = LST - H\_A
\end{equation}

\begin{equation}
\sin(rotation) =   \frac{\sin(az) * \cos(lat\_obs)}{\cos(dec\_app)}
\end{equation}

\begin{equation}
\cos(rotation) = \frac{\sin(lat\_obs) - \sin(dec\_app) * \sin(el)}{\cos(dec\_app) * \cos(el)}
\end{equation}

  Again, $\cos(dec\_app)$ appears in the denominator of both $\sin$ and $\cos$
         expressions and is left out of the calculation because on ly the ratio
         is important.

         \sstitem
         [RB] coords:
            Use SLA\_FK54Z to convert to RJ.
            Use SLA\_MAP to convert to apparent, giving ra\_app, dec\_app.
            Use same method to calculate apparent position of RB N pole, giving
            ra\_N\_app, dec\_N\_app.
            Then calculate rotation from:-

\begin{equation}
\mathrm{d}RA =  ra\_app - ra\_N\_app
\end{equation}

\begin{equation}
\sin (rotation) =   \frac{\sin(\mathrm{d}RA) * \cos(dec\_N\_app)}{\cos(lat)}
\end{equation}

\begin{equation}
\cos (rotation) = \frac{\sin(dec\_N\_app) - \sin(dec\_app) * \sin(lat)}{\cos(dec\_app) * \cos(lat)}
\end{equation}

     Since $\cos(lat)$ is in the denominator for both $\sin$ and $\cos$ terms,
         is always $+$ve except for $\pm \pi/2$ where it goes to zero and blows
         up the equations, leave it out in the calculations. The ratio
         of sin and cos will be unaffected.

         If dec\_app = $\pi/2$ (i.e. at N pole of apparent system) then

\begin{equation}
rotation = \pi - (ra\_N\_app - ra\_app)
\end{equation}

         \sstitem
         [RJ] coords:
            Use SLA\_MAP to convert to apparent.
            Use same method to calculate apparent position of RB N pole.
            Derive rotation angle in the same way as for RB.

         \sstitem
         [GA] coords:
            Use SLA\_GALEQ to convert to RJ.
            Use SLA\_MAP to convert to apparent, giving ra\_app, dec\_app.
            Use same method to calculate apparent position of GA N pole, giving
            ra\_N\_app, dec\_N\_app.
            Derive rotation angle in the same way as for RB.

         \sstitem
         [EQ] coords:
            Use SLA\_ECLEQ to convert to RJ.
            Use SLA\_MAP to convert to apparent, giving ra\_app, dec\_app.
            Use same method to calculate apparent position of EQ N pole, giving
            ra\_N\_app, dec\_N\_app.
            Derive rotation angle in the same way as for RB.

         \sstitem
         [HA] coords:
            Apparent RA = LST - LONG

            Apparent Dec = LAT

            Rotation = 0.0D0

         \sstitem
         [RD] coords:
            Apparent RA, Dec set to input values. Rotation = 0.0.

         \sstitem
         [PLANET] coords:
            If MJD1 = MJD2 then apparent RA, Dec set to input LONG, LAT.
               Rotation = 0.0.
            Otherwise apparent RA, Dec interpolated (or extrapolated) between
               LONG, LAT, MJD1 and LONG2, LAT2, MJD2 according to MJD.
               Rotation = 0.
      }
   }
   \sstinvocation{
       CALL SCULIB\_CALC\_APPARENT (LAT\_OBS, LONG, LAT, LONG2, LAT2, MAP\_X, MAP\_Y,
         COORD\_TYPE, LST, MJD, MJD1, MJD2, RA\_APP, DEC\_APP, ROTATION, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         LAT\_OBS                = DOUBLE PRECISION (Given)
      }{
         latitude of observatory (radians)
      }
      \sstsubsection{
         LONG                   = DOUBLE PRECISION (Given)
      }{
         longitude of centre in input coord system (radians)
      }
      \sstsubsection{
         LAT                    = DOUBLE PRECISION (Given)
      }{
         latitude of centre in input coord system (radians)
      }
      \sstsubsection{
         LONG2                  = DOUBLE PRECISION (Given)
      }{
         longitude of second centre in PLANET coord system (radians)
      }
      \sstsubsection{
         LAT2                   = DOUBLE PRECISION (Given)
      }{
         latitude of second centre in PLANET coord system (radians)
      }
      \sstsubsection{
         MAP\_X                  = DOUBLE PRECISION (Given)
      }{
         x tangent plane offset of point from centre (radians)
         The offset must be in the same coordinate as COORD\_TYPE
      }
      \sstsubsection{
         MAP\_Y                  = DOUBLE PRECISION (Given)
      }{
         y tangent plane offset of point from centre (radians)
         The offset must be in the same coordinate as COORD\_TYPE
      }
      \sstsubsection{
         COORD\_TYPE             = CHARACTER$*$($*$) (Given)
      }{
         Coord system of input centre, RD, RB, RJ, GA, EQ, PLANET
      }
      \sstsubsection{
         LST                    = DOUBLE PRECISION (Given)
      }{
         LST for requested coordinates (for AZ and HA)
      }
      \sstsubsection{
         MJD                    = DOUBLE PRECISION (Given)
      }{
         Modified Julian date of observation
      }
      \sstsubsection{
         MJD1                   = DOUBLE PRECISION (Given)
      }{
         Modified Julian date of first centre in PLANET coord system
      }
      \sstsubsection{
         MJD2                   = DOUBLE PRECISION (Given)
      }{
         Modified Julian date of second centre in PLANET coord system
      }
      \sstsubsection{
         RA\_APP                 = DOUBLE PRECISION (Returned)
      }{
         Apparent RA of point at date (radians)
      }
      \sstsubsection{
         DEC\_APP                = DOUBLE PRECISION (Returned)
      }{
         Apparent Dec
      }
      \sstsubsection{
         ROTATION               = DOUBLE PRECISION (Returned)
      }{
         Angle between apparent north and north of input coord system
         (radians, measured clockwise from input north)
      }
      \sstsubsection{
         STATUS                 = INTEGER (Given and returned)
      }{
         Global status
      }
   }
   \sstnotes{
      Does not handle LOCAL\_COORDS for MAP\_X and MAP\_Y
      (see SCULIB\_APARRENT\_2\_MP for information on how to do this)
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_CALC\_BOL\_COORDS
}{
   Calculate the bolometer offsets in (apparent RA,DEC), AzEl or NA
}{
   \sstdescription{
      This routine calculates the apparent RA and dec of a specified set
      of bolometers. It does this by:-

      \sstitemlist{

         \sstitem
            calculating the offsets that must be added to the bolometer
              positions to cater for the fact that the origin of the bolometer
              coordinate system may be offset from the `centre{\tt '} specified by
              RA\_CENTRE , DEC\_CENTRE.

         \sstitem
            Three types of offsets may be added; Nasmyth offsets which are
              simply subtracted from the bolometer coordinates, azimuth offsets
              which are subtracted from the bolometer positions in az and el,
              or offsets in a coordinate system fixed relative to the sky,
              rotated relative to apparent RA,Dec by the angle ROTATION. The
              latter are added to the bolometer coordinates when they are in
              the form of tangent plane coords in apparent RA,Dec.

         \sstitem
            working out the elevation and parallactic angle for the sidereal
              time and apparent RA, dec of the `centre{\tt '}.

         \sstitem
            calculating the Nasmyth offset of each bolometer, then rotating
              them into tangent plane offsets in azimuth and elevation.

         \sstitem
            adding pointing corrections in azimuth and elevation, then
              rotating the coords into the apparent RA,Dec tangent plane.

         \sstitem
            calling SLA\_DTP2S to work out the apparent RA, dec of the offset
              positions.
      }
   }
   \sstinvocation{
       CALL SCULIB\_CALC\_BOL\_COORS (OUT\_COORDS,RA\_CENTRE, DEC\_CENTRE, LST,
         LAT\_OBS, OFFSET\_COORDS, OFFSET\_X, OFFSET\_Y, ROTATION,
         N\_POINT, MAX\_POINT, POINT\_LST, POINT\_DAZ, POINT\_DEL,
         NUM\_CHAN, NUM\_ADC, N\_BOL, BOL\_CHAN, BOL\_ADC, U3, U4, U3\_CENTRE,
         U4\_CENTRE, X\_BOL, Y\_BOL, ELEVATION, PAR\_ANGLE, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         OUT\_COORDS = CHARACTER $*$ ($*$) (Given)
      }{
         Output coordinate system (NA, AZ, RA)
      }
      \sstsubsection{
         RA\_CENTRE              = DOUBLE PRECISION (Given)
      }{
         the apparent RA of the `centre{\tt '} (radians)
      }
      \sstsubsection{
         DEC\_CENTRE             = DOUBLE PRECISION (Given)
      }{
         the apparent dec of the `centre{\tt '} (radians)
      }
      \sstsubsection{
         LST                    = DOUBLE PRECISION (Given)
      }{
         the local sidereal time (radians)
      }
      \sstsubsection{
         LAT\_OBS                = DOUBLE PRECISION (Given)
      }{
         the latitude of the observatory (radians)
      }
      \sstsubsection{
         OFFSET\_COORDS          = CHARACTER$*$($*$) (Given)
      }{
         the coordinate system of the offset of the array origin from
         the `centre{\tt '}; NA or RD or AZ
      }
      \sstsubsection{
         OFFSET\_X               = REAL (Given)
      }{
         the x offset of the array origin from the `centre{\tt '}
         (arcseconds)
      }
      \sstsubsection{
         OFFSET\_Y               = REAL (Given)
      }{
         the y offset of the array origin from the `centre{\tt '}
         (arcseconds)
      }
      \sstsubsection{
         ROTATION               = DOUBLE PRECISION (Given)
      }{
          for OFFSET\_COORDS other than NA, this gives the angle
         from N in the offset coordinate system to N in apparent
         RA,Dec (radians, increasing clockwise)
      }
      \sstsubsection{
         N\_POINT                = INTEGER (Given)
      }{
         number of elements used in pointing correction arrays
      }
      \sstsubsection{
         MAX\_POINT              = INTEGER (Given)
      }{
         dimension of pointing correction arrays
      }
      \sstsubsection{
         POINT\_LST (MAX\_POINT)  = DOUBLE PRECISION (Given)
      }{
         LST of measured corrections (radians)
      }
      \sstsubsection{
         POINT\_DAZ (MAX\_POINT)  = REAL (Given)
      }{
         correction to be added in azimuth (arcsec)
      }
      \sstsubsection{
         POINT\_DEL (MAX\_POINT)  = REAL (Given)
      }{
         correction to be added in elevation (arcsec)
      }
      \sstsubsection{
         NUM\_CHAN               = INTEGER (Given)
      }{
         the number of channels per A/D card
      }
      \sstsubsection{
         NUM\_ADC                = INTEGER (Given)
      }{
         the number of A/D cards
      }
      \sstsubsection{
         N\_BOL                  = INTEGER (Given)
      }{
         the actual number of bolometers
      }
      \sstsubsection{
         BOL\_CHAN (N\_BOL)       = INTEGER (Given)
      }{
         channel numbers of bolometers
      }
      \sstsubsection{
         BOL\_ADC (N\_BOL)        = INTEGER (Given)
      }{
         ADC numbers of bolometers
      }
      \sstsubsection{
         U3 (NUM\_ADC,NUM\_CHAN)  = REAL (Given)
      }{
         the U3 offsets of the bolometers (arcsec)
      }
      \sstsubsection{
         U4 (NUM\_ADC,NUM\_CHAN)  = REAL (Given)
      }{
         the U4 offsets of the bolometers (arcsec)
      }
      \sstsubsection{
         U3\_CENTRE              = REAL (Given)
      }{
         the U3 offset of the tracking `centre{\tt '} on the array (arcsec)
      }
      \sstsubsection{
         U4\_CENTRE              = REAL (Given)
      }{
         the U4 offset of the tracking `centre{\tt '} on the array (arcsec)
      }
      \sstsubsection{
         X\_BOL (N\_BOL)         = DOUBLE PRECISION (Returned)
      }{
         the X offset (apparent RA or X) of the bolometer (radians)
      }
      \sstsubsection{
         Y\_BOL (N\_BOL)        = DOUBLE PRECISION (Returned)
      }{
         the Y offset (apparent dec or Y) of the bolometer (radians)
      }
      \sstsubsection{
         ELEVATION       = DOUBLE (Returned)
      }{
         elevation of each position
      }
      \sstsubsection{
         PAR\_ANGLE       = DOUBLE (Returned)
      }{
         parallactic angle of each position
      }
      \sstsubsection{
         STATUS                 = INTEGER (Given and returned)
      }{
         The global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_CALC\_CLOCKERR
}{
   Calculate start up time and error in system clock
}{
   \sstdescription{
      Checks the self-consistency of the FITS headers by calculating
      the expected LST from the Azimuth and Elevation values stored
      in the header and comparing this with the supplied reference
      LST. Returns the difference between the two values and the
      LST calculated from the headers.
   }
   \sstinvocation{
       CALL SCULIB\_CALC\_CLOCKERR( N\_FITS, FITS, RA\_CEN, LST\_REF,
          CLOCK\_ERR, LST\_AZEL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N\_FITS = INTEGER (Given)
      }{
         Number of items in the FITS array
      }
      \sstsubsection{
         FITS() = CHAR$*$80 (Given)
      }{
         FITS array
      }
      \sstsubsection{
         RA\_CEN = DOUBLE (Given)
      }{
         Apparent RA corresponding to the Az/El defined in the FITS header.
         In radians.
      }
      \sstsubsection{
         LST\_REF = DOUBLE (Given)
      }{
         Local sidereal time at the start of data acquisition. This
         usually comes from the LST\_STRT array. In radians.
      }
      \sstsubsection{
         CLOCK\_ERR = DOUBLE (Returned)
      }{
         The time difference (in radians) between the times stored
         in the data file (header items and LST\_STRT) and the actual
         time of the observation derived from the azimuth and elevation
         of the observed source. The value is the number that must be
         added to the supplied LST\_REF in order to correct it.
      }
      \sstsubsection{
         LST\_AZEL = DOUBLE (Returned)
      }{
         Local Sidereal time calculated from the azimuth, elevation
         and apparent RA/Dec (radians)
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status. An error will be returned if the observation
         was not done in a tracking frame (eg NA or AZ) since those
         frames can not be used to determine the time from the telescope
         az and el.
      }
   }
   \sstnotes{
      Requires the following FITS headers to be defined:
      \sstitemlist{

         \sstitem
         LAT-OBS

         \sstitem
         STRT\_ELD

         \sstitem
         STRT\_AZD

         \sstitem
         CENT\_CRD

      }
      The clock error returned must be added to all times read from
      the data file in order to make those times correct.

      The centre coordinates of the observation must corresponde to
      an astronomical frame. AZ can not be used (for obvious reasons).
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 2000 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_CALC\_FLATFIELD
}{
   calculate flat-field results for a bolometer
}{
   \sstdescription{
      This routine calculates the image parameters from data taken as a
      flat-field measurement of a SCUBA bolometer. It takes as input data a
      map made of a point source with pixels on a square grid.

         If status is good on entry, the routine will set default return values
      to VAL\_\_BADR except QUALITY set to 0. As progress is made through the
      routine the various image quantities will be set to their derived values,
      and QUALITY will be set to 1 if any problem is encountered.

         An attempt will then be made to estimate the 0 level of the image by
      averaging valid data points in the corners of the map area. If there are
      any such points then the 0 level will be subtracted from the map.

         Next the routine will calculate the 0th and 1st order moments of the
      image on the map. Map pixels with bad quality are ignored.

  The 0th order is calculated as
\begin{equation}
U_0 = \sum_{ij} f_{ij},
\end{equation}
where i,j are the pixel indices. The 1st order moment in X is calculated as
\begin{equation}
U_x = \sum_{ij} x f_{ij},
\end{equation}
where x is the x position of pixel i,j; and the 1st order moment in Y is
calculated as
\begin{equation}
U_y = \sum_{ij} y f_{ij},
\end{equation}
where y is the y position of pixel i,j.

      If the 0th order moment of the image was 0, i.e. there is no image on
      the map, then a warning message will be output and the routine will
      return with good status and QUALITY set to 1. Otherwise, the x,y centre
      of the image is calculated from:-

\begin{equation}
X_\mathrm{cen} = \frac{U_x}{U_0}
\end{equation}
\begin{equation}
Y_\mathrm{cen} = \frac{U_y}{U_0}
\end{equation}

      With this information the image can be analysed further by one of
      2 methods. The method used depends on the value of parameter
      FLAT\_ANALYSIS. If there is an error reading this parameter, or
      its value is not either MOMENTS or FIT, then a warning message will
      be issued and a value of MOMENTS will be assumed.

      For a MOMENTS analysis the 2nd order moments can be calculated about the
      centre of the image:-

\begin{equation}
          U_{xx} = \sum_{ij} (x - X_{cen})^2 f_{ij}
\end{equation}
\begin{equation}
          U_{xy} = \sum_{ij} (x - X_{cen})(y - Y\_{cen}) f_{ij}
\end{equation}
\begin{equation}
          U_{yy} = \sum_{ij} (y - Y_{cen})^2  f_{ij}
\end{equation}

      The parameters of the weighted ellipse describing the data are then
      (following `Analysis of Astronomical Images using Moments{\tt '}, R.Stobie,
      J.B.I.S., 33, 323):-

\begin{equation}
\tan(2\theta) = \frac{2 U_{xy}}{U_{xx} - U_{yy}}
\end{equation}
\begin{equation}
A^2 = 2 ( U_{xx} + U_{yy} ) + 2 \sqrt{(U_{xx} - U_{yy})^2 + 4U_{xy}^2}
\end{equation}
\begin{equation}
B^2 = 2 ( U_{xx} + U_{yy} ) - 2 \sqrt{(U_{xx} - U_{yy})^2 + 4U_{xy}^2}
\end{equation}

      For a FIT analysis, a 2-d Gaussian is fitted by a least-squares
      routine to the data. SCULIB\_FIT\_ROUTINE is the routine that performs
      the fit while SCULIB\_GAUSSIAN\_XISQ calculates the chi-squared of the
      fit to the data. An error will be reported and QUALITY set to 1
      if there are any problems with the fit process. The fitted function
      is :-

\begin{equation}
  P \exp( \frac{-(x-X_{cen})^2 - (y-Y_{cen})^2}{\sigma^2})
\end{equation}

      where SIGMA ($\sigma$) is an ellipse with semi-axis lengths A and B, with
THETA ($\theta$)
      the angle between the x axis and A (THETA in radians, measured
      anti-clockwise).

      If all is well still, the volume under the image and the variance on it
      are calculated. The volume will be the sum of all map pixels under a
      circle of 12 arcsec radius for short-wave array bolometers, or 25
      arcsec for other types. If this area laps over the edges of the map, or
      any pixels inside it have bad quality then a warning message will be
      output but QUALITY will stay good.
   }
   \sstinvocation{
       CALL SCULIB\_CALC\_FLATFIELD (BOLNAME, BOL\_TYPE, IDIM, JDIM, MAP\_DATA,
         MAP\_VARIANCE, MAP\_QUALITY, X, Y, VOLUME, VOLUME\_VAR, X\_CENTRE,
         Y\_CENTRE, THETA, A, B, QUALITY, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         BOLNAME                           = CHARACTER$*$($*$) (Given)
      }{
         the name of the bolometer being measured
      }
      \sstsubsection{
         BOL\_TYPE                          = CHARACTER$*$($*$) (Given)
      }{
         the type of the bolometer being measured
      }
      \sstsubsection{
         IDIM                              = INTEGER (Given)
      }{
         `I{\tt '} dimension of map
      }
      \sstsubsection{
         JDIM                              = INTEGER (Given)
      }{
         `J{\tt '} dimension of map
      }
      \sstsubsection{
         MAP\_DATA (IDIM, JDIM)             = REAL (Given)
      }{
         map data values
      }
      \sstsubsection{
         MAP\_VARIANCE (IDIM, JDIM)         = REAL (Given)
      }{
         map variance
      }
      \sstsubsection{
         MAP\_QUALITY (IDIM, JDIM)          = REAL (Given)
      }{
         map quality
      }
      \sstsubsection{
         X (IDIM)                          = REAL (Given)
      }{
         x axis of map
      }
      \sstsubsection{
         Y (JDIM)                          = REAL (Given)
      }{
         y axis of map
      }
      \sstsubsection{
         VOLUME                            = REAL (Returned)
      }{
         volume under image within MULT times the fitted ellipse
      }
      \sstsubsection{
         VOLUME\_VAR                        = REAL (Returned)
      }{
         variance on VOLUME\_DATA
      }
      \sstsubsection{
         X\_CENTRE                          = REAL (Returned)
      }{
         x of image centre
      }
      \sstsubsection{
         Y\_CENTRE                          = REAL (Returned)
      }{
         y of image centre
      }
      \sstsubsection{
         THETA                             = REAL (Returned)
      }{
         angle of tilt of ellipse (radians)
      }
      \sstsubsection{
         A                                 = REAL (Returned)
      }{
         semi-major axis of ellipse
      }
      \sstsubsection{
         B                                 = REAL (Returned)
      }{
         semi-minor axis of ellipse
      }
      \sstsubsection{
         STATUS                            = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_CALC\_GRID
}{
   calculate the minimum rectangular grid that would
   contain the input jiggle pattern
}{
   \sstdescription{
      This routine takes the x,y coords of the mapped points and attempts to
      fit them onto a rectangular grid. The grid contains the minimum number
      of points required to hold the measured positions.
   }
   \sstinvocation{
       CALL SCULIB\_CALC\_GRID (N, X, Y, XMIN, XMAX, XSPACE, NX,
         YMIN, YMAX, YSPACE, NY, IPOS, JPOS, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         N                                     = INTEGER (Given)
      }{
         the number of positions in the jiggle pattern
      }
      \sstsubsection{
         X (N)                                 = REAL (Given)
      }{
         the x offsets of the jiggle
      }
      \sstsubsection{
         Y (N)                                 = REAL (Given)
      }{
         the y offsets
      }
      \sstsubsection{
         XMIN                                  = REAL (Returned)
      }{
         the minimum of the output map{\tt '}s x-axis
      }
      \sstsubsection{
         XMAX                                  = REAL (Returned)
      }{
         the maximum of the x-axis
      }
      \sstsubsection{
         XSPACE                                = REAL (Returned)
      }{
         the pixel spacing in x
      }
      \sstsubsection{
         NX                                    = INTEGER (Returned)
      }{
         the map dimension in x
      }
      \sstsubsection{
         YMIN                                  = REAL (Returned)
      }{
         the minimum of the output map{\tt '}s y-axis
      }
      \sstsubsection{
         YMAX                                  = REAL (Returned)
      }{
         the maximum of the y-axis
      }
      \sstsubsection{
         YSPACE                                = REAL (Returned)
      }{
         the pixel spacing in y
      }
      \sstsubsection{
         NY                                    = INTEGER (Returned)
      }{
         the map dimension in y
      }
      \sstsubsection{
         IPOS (N)                              = INTEGER (Returned)
      }{
         the I index of each jiggle position in the map
      }
      \sstsubsection{
         JPOS (N)                              = INTEGER (Returned)
      }{
         the J index of each jiggle position in the map
      }
      \sstsubsection{
         STATUS                                = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_CALC\_OUTPUT\_COORDS
}{
   calculate output coords of map centre and angle
   of output coord system N relative to apparent N
}{
   \sstdescription{
      This routine takes the apparent centre coords at the time of the
      observation and converts them to the output coordinate system. In
      addition, the angle between the north direction in the output
      coordinate frame and that in the apparent frame is calculated
      (measured anticlockwise from output north, in radians).
   }
   \sstinvocation{
       CALL SCULIB\_CALC\_OUTPUT\_COORDS (RA\_APP, DEC\_APP, MJD,
         OUTPUT\_COORDS, LONG, LAT, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         RA\_APP                 = DOUBLE PRECISION (Given)
      }{
         apparent RA of map centre on MJD (radians)
      }
      \sstsubsection{
         DEC\_APP                = DOUBLE PRECISION (Given)
      }{
         apparent declination of map centre on MJD (radians)
      }
      \sstsubsection{
         MJD                    = DOUBLE PRECISION (Given)
      }{
         U1 of observation expressed as modified Julian day
      }
      \sstsubsection{
         OUTPUT\_COORDS          = CHARACTER$*$($*$) (Given)
      }{
         output coordinated system; RB, RJ, RD, GA or EQ
      }
      \sstsubsection{
         LONG                   = DOUBLE PRECISION (Returned)
      }{
         longitude of map centre in output coord system (radians)
      }
      \sstsubsection{
         LAT                    = DOUBLE PRECISION (Returned)
      }{
         latitude of map centre in output coord system (radians)
      }
      \sstsubsection{
         STATUS                 = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstnotes{
      SLA routines are used to perform the coordinate conversions.
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_CALC\_SKYDIP\_TEMPS
}{
   Calculate all the skydip temps from raw data
}{
   \sstdescription{
      This routine accepts the SKYDIP (3 dimensional) raw data and
      works out the temperature associated with each integration.
      The 2 dimensional array (bolometers, integrations) is then returned.
   }
   \sstinvocation{
       CALL SCULIB\_CALC\_SKYDIP\_TEMPS( N\_TEMPS, N\_FITS, FITS, PARAM,
            N\_INTEGRATIONS, N\_MEASUREMENTS, N\_POS, N\_BOLS, DEM\_PNTR,
            IN\_DATA, OUT\_DATA, OUT\_VAR, OUT\_QUAL, OUT\_DEM\_PNTR,
            OUT\_DATA\_AV, OUT\_VAR\_AV, OUT\_QUAL\_AV, SCRATCH,
            STATUS)
   }
   \sstarguments{
      \sstsubsection{
         N\_TEMPS = INTEGER (Given)
      }{
         Number of SKYDIP temperatures.
      }
      \sstsubsection{
         SUB\_REQUIRED = INTEGER (Given)
      }{
         The number of the sub-instrument that is requested.
         If this number is less than 1 or greater than N\_BOLS then
         all subinstrumentes are returned. This should be 0 when called
         from REDUCE\_SWITCH and the required number if called from
         SKYDIP. Exists purely to prevent multiple requests for T\_COLD
         if we are only interested in one wavelength
      }
      \sstsubsection{
         N\_FITS = INTEGER (Given)
      }{
         Number of FITS items
      }
      \sstsubsection{
         FITS = CHARACTER$*$80 (Given)
      }{
         The FITS items
      }
      \sstsubsection{
         PARAM = CHARACTER$*$(PAR\_\_SZNAM) (Given)
      }{
         Name of parameter from which T\_COLD can be read
      }
      \sstsubsection{
         N\_INTEGRATIONS = INTEGER (Given)
      }{
         Number of integrations
      }
      \sstsubsection{
         N\_MEASUREMENTS = INTEGER (Given)
      }{
         Number of measurements
      }
      \sstsubsection{
         N\_POS = INTEGER (Given)
      }{
         Number of data points
      }
      \sstsubsection{
         N\_BOLS = INTEGER (Given)
      }{
         Number of bolometers (sub instruments)
      }
      \sstsubsection{
         NUM\_CHAN                   = INTEGER (Given)
      }{
         number of A/D channels per A/D card
      }
      \sstsubsection{
         NUM\_ADC                    = INTEGER (Given)
      }{
         number of A/D cards
      }
      \sstsubsection{
         BOL\_TYPE (NUM\_CHAN, NUM\_ADC)
      }{
                              = CHARACTER$*$($*$) (Given)
         the types of the bolometers
      }
      \sstsubsection{
         BOL\_CHAN (N\_BOLS)          = INTEGER (Given)
      }{
         channel numbers of selected bolometers
      }
      \sstsubsection{
         BOL\_ADC (N\_BOLS)           = INTEGER (Given)
      }{
         ADC numbers of selected bolometers
      }
      \sstsubsection{
         DEM\_PNTR(1, 1, N\_INTEGRATIONS, N\_MEASUREMENTS) = INTEGER (Given)
      }{
         Pointer to positions in the input data
      }
      \sstsubsection{
         IN\_DATA(N\_TEMPS, N\_BOLS, N\_POS) = REAL (Given)
      }{
         Input data [NTEMPS, NBOLS, NPOS]
      }
      \sstsubsection{
         OUT\_DATA(N\_BOLS, N\_POS) = REAL (Returned)
      }{
         Processed sky brightness temperatures.
      }
      \sstsubsection{
         OUT\_VAR(N\_BOLS, N\_POS) = REAL (Returned)
      }{
         Variance on each point in OUT\_DATA
      }
      \sstsubsection{
         OUT\_QUAL(N\_BOLS, N\_POS) = BYTE (Returned)
      }{
         Quality of OUT\_DATA
      }
      \sstsubsection{
         OUT\_DEM\_PNTR(1, 1, N\_INTEGRATIONS, N\_MEASUREMENTS) = INTEGER (Returned)
      }{
         Modified DEM\_PNTR to reflect changes in data array
      }
      \sstsubsection{
         OUT\_DATA\_AV(N\_MEASUREMENTS, N\_BOLS) = REAL (Returned)
      }{
         Average sky temp for each measurement
      }
      \sstsubsection{
         OUT\_VAR\_AV(N\_MEASUREMENTS, N\_BOLS) = REAL (Returned)
      }{
         Variance of the Average sky temp for each measurement
      }
      \sstsubsection{
         OUT\_QUAL\_AV(N\_MEASUREMENTS, N\_BOLS) = BYTE (Returned)
      }{
         Quality of the Average sky temp for each measurement
      }
      \sstsubsection{
         SCRATCH(N\_TEMPS, N\_BOLS, N\_INTEGRATIONS) = REAL (Given)
      }{
         Work space to store the data for each measurement (since I
         cant simply pass a pointer in as the data is non-contiguous)
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global Status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_CALC\_SUB\_BOLS
}{
   find the positions of bolometers belonging to a
   specified sub-instrument in a demodulated data array
}{
   \sstdescription{
      This subroutine finds the location of data from bolometers belonging to
      a specified sub-instrument in a demodulated data array that may contain
      data for several sub-instruments. The number of bolometers found, their
      indices in the data array, and their ADC,channel numbers are returned
      by the routine.
   }
   \sstinvocation{
       CALL  SCULIB\_CALC\_SUB\_BOLS (N\_BOL\_IN, IN\_BOL\_ADC, IN\_BOL\_CHAN,
         NUM\_CHAN, NUM\_ADC, BOL\_TYPE, SUB\_INSTRUMENT, N\_BOL\_OUT,
         OUT\_BOL\_ADC, OUT\_BOL\_CHAN, IN\_POINTER, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         N\_BOL\_IN                     = INTEGER (Given)
      }{
         number of bolometers in data array
      }
      \sstsubsection{
         IN\_BOL\_ADC (N\_BOL\_IN)        = INTEGER (Given)
      }{
         ADC numbers of bolometers in data array
      }
      \sstsubsection{
         IN\_BOL\_CHAN (N\_BOL\_IN)       = INTEGER (Given)
      }{
         channel numbers of bolometers in data array
      }
      \sstsubsection{
         NUM\_CHAN                     = INTEGER (Given)
      }{
         number of channels per A/D card
      }
      \sstsubsection{
         NUM\_ADC                      = INTEGER (Given)
      }{
         number of A/D cards
      }
      \sstsubsection{
         BOL\_TYPE (NUM\_CHAN,NUM\_ADC)  = CHARACTER$*$($*$) (Given)
      }{
         types of bolometers
      }
      \sstsubsection{
         SUB\_INSTRUMENT               = CHARACTER$*$($*$) (Given)
      }{
         the name of the sub-instrument for which data are to be extracted
      }
      \sstsubsection{
         N\_BOL\_OUT                    = INTEGER (Returned)
      }{
         the number of bolometers in the data array that belong to the
         specified sub-instrument
      }
      \sstsubsection{
         OUT\_BOL\_ADC (N\_BOL\_IN)       = INTEGER (Returned)
      }{
         ADC numbers of bolometers in specified sub-instrument
      }
      \sstsubsection{
         OUT\_BOL\_CHAN (N\_BOL\_IN)      = INTEGER (Returned)
      }{
         channel numbers of bolometers in specified sub-instrument
      }
      \sstsubsection{
         IN\_POINTER (N\_BOL\_IN)        = INTEGER (Returned)
      }{
         array pointing to indices in data array that contain
         data for bolometers in the specified sub-instrument
      }
      \sstsubsection{
         STATUS                       = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_CFILLB
}{
   fill a byte array with a constant
}{
   \sstdescription{
      fills an byte array with a constant
   }
   \sstinvocation{
      CALL SCULIB\_CFILLB (N, IVAL, ARRAY)
   }
   \sstarguments{
      \sstsubsection{
         N                  = INTEGER (Given)
      }{
         number of array elements
      }
      \sstsubsection{
         IVAL               = BYTE (Given)
      }{
         constant to which array is to be set
      }
      \sstsubsection{
         ARRAY (N)          = BYTE (Returned)
      }{
         array to be set
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         No status checking
      }
   }
}
\sstroutine{
   SCULIB\_CFILLD
}{
   fill a double precision array with a constant
}{
   \sstdescription{
      fills a double precision array with a constant
   }
   \sstinvocation{
      CALL SCULIB\_CFILLD (N, DVAL, ARRAY)
   }
   \sstarguments{
      \sstsubsection{
         N                  = INTEGER (Given)
      }{
         number of array elements
      }
      \sstsubsection{
         DVAL               = DOUBLE PRECISION (Given)
      }{
         constant to which array is to be set
      }
      \sstsubsection{
         ARRAY (N)          = DOUBLE PRECISION (Returned)
      }{
         array to be set
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         No status checking
      }
   }
}
\sstroutine{
   SCULIB\_CFILLI
}{
   fill an integer array with a constant
}{
   \sstdescription{
      fills an integer array with a constant
   }
   \sstinvocation{
      CALL SCULIB\_CFILLI (N, IVAL, ARRAY)
   }
   \sstarguments{
      \sstsubsection{
         N                  = INTEGER (Given)
      }{
         number of array elements
      }
      \sstsubsection{
         IVAL               = INTEGER (Given)
      }{
         constant to which array is to be set
      }
      \sstsubsection{
         ARRAY (N)          = INTEGER (Returned)
      }{
         array to be set
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         No status checking
      }
   }
}
\sstroutine{
   SCULIB\_CFILLR
}{
   fill a real array with a constant
}{
   \sstdescription{
      fills a real array with a constant
   }
   \sstinvocation{
      CALL SCULIB\_CFILLR (N, RVAL, ARRAY)
   }
   \sstarguments{
      \sstsubsection{
         N                  = INTEGER (Given)
      }{
         number of array elements
      }
      \sstsubsection{
         RVAL               = REAL (Given)
      }{
         constant to which array is to be set
      }
      \sstsubsection{
         ARRAY (N)          = REAL (Returned)
      }{
         array to be set
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         No status checking
      }
   }
}
\sstroutine{
   SCULIB\_CLIP\_BOL
}{
   To clip a bolometer at $+$/- nsigma
}{
   \sstdescription{
      This routine despikes a single bolometer at the $+$/- n sigma
      level. A 1-dimensional data set is assumed.
   }
   \sstinvocation{
       CALL SCULIB\_CLIP\_BOL(N\_POS, SCUDATA, SCUQUAL,
            N\_SIGMA, BADBIT, NSPIKES, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         N\_POS = INTEGER (Given)
      }{
         Number of jiggle positions in data set
      }
      \sstsubsection{
         SCUDATA(N\_POS) = REAL (Given)
      }{
         The data
      }
      \sstsubsection{
         SCUQUAL(N\_POS) = BYTE (Given \& Returned)
      }{
         The data quality
      }
      \sstsubsection{
         N\_SIGMA = DOUBLE (Given)
      }{
         Number of sigma to clip at. If this number is positive
         then a clipped mean and standard deviation are calculated.
         If it is negative the statistics are calculated without
         iterative clipping.
      }
      \sstsubsection{
         BADBIT = BYTE (Given \& Returned)
      }{
         Bad bit mask
      }
      \sstsubsection{
         NSPIKES = INTEGER (Returned)
      }{
         Number of spikes that were detected.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         Global Status value
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_COADD
}{
   coadd exposure into coadded result
}{
   \sstdescription{
      This routine coadds the current exposure to the input coadd arrays
      and puts the result in the output coadd arrays. The input and output
      arrays can be the same. The coadd result is the average of exposures
      that have been input. The coadd variance is calculated from
      the spread of the input exposures about the mean if more than
      one exposure has been added in. If only one exposure is
      available then the coadd variance is set equal to variance on the
      input data if present, otherwise it is set equal to zero.
      Input pixels with bad quality are ignored.
   }
   \sstinvocation{
       CALL SCULIB\_COADD (N, IN\_DATA, IN\_VARIANCE, IN\_QUALITY,
          INCOADD\_DATA, INCOADD\_VAR, INCOADD\_QUAL, INCOADD\_NUMBER,
          OUTCOADD\_DATA, OUTCOADD\_VAR, OUTCOADD\_QUAL, OUTCOADD\_NUMBER,
          BADBIT, VARIANCE, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         N                       = INTEGER (Given)
      }{
         Number of elements in arrays.
      }
      \sstsubsection{
         IN\_DATA (N)             = REAL (Given)
      }{
         data to be added to coadd
      }
      \sstsubsection{
         IN\_VARIANCE (N)         = REAL (Given)
      }{
         variance on input data
      }
      \sstsubsection{
         IN\_QUALITY (N)          = BYTE (Given)
      }{
         quality on input data
      }
      \sstsubsection{
         INCOADD\_DATA (N)        = REAL (Given)
      }{
         Input coadd.
      }
      \sstsubsection{
         INCOADD\_VAR (N)         = REAL (Given)
      }{
         Input coadd variance.
      }
      \sstsubsection{
         INCOADD\_QUAL (N)       = BYTE (returned)
      }{
         Input coadd quality.
      }
      \sstsubsection{
         INCOADD\_NUMBER (N)      = INTEGER (Given)
      }{
         Number of exposures coadded in input coadd.
      }
      \sstsubsection{
         OUTCOADD\_DATA (N)       = REAL (Returned)
      }{
         Output coadd.
      }
      \sstsubsection{
         OUTCOADD\_VAR (N)        = REAL (Returned)
      }{
         Output coadd variance.
      }
      \sstsubsection{
         OUTCOADD\_QUAL (N)       = BYTE (returned)
      }{
         Output coadd quality.
      }
      \sstsubsection{
         OUTCOADD\_NUMBER (N)     = INTEGER (Returned)
      }{
         Number of exposures coadded in output coadd.
      }
      \sstsubsection{
         BADBIT                  = BYTE (Given)
      }{
         Bad bit mask
      }
      \sstsubsection{
         VARIANCE                = LOGICAL (Given)
      }{
         T if input data has variance associated with it
      }
      \sstsubsection{
         STATUS                  = INTEGER (Given \& Returned)
      }{
         Global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_COADD\_MAPS
}{
   Average together integration and output map
}{
   \sstdescription{
      This routine coadds the current integration image to the output image.
      The coadd variance is calculated from the spread of the integrations
      about the mean if more than one integration has been added in. The
      averaging is done over integrations, so that each point in an image
      is separate. An output point is good if either of the inputs is good.
      If only one dataset is coadded th variance is set zero.
      Input pixels with bad quality are ignored.
   }
   \sstinvocation{
       CALL SCULIB\_COADD\_MAPS(NPTS, DATA\_IN, QUALITY\_IN, WEIGHT,
            NCOADD, DATA\_OUT, VARIANCE\_OUT, QUALITY\_OUT, WEIGHT\_OUT,
            STATUS)
   }
   \sstarguments{
      \sstsubsection{
         NPTS = INTEGER (Given)
      }{
         Number of input data points
      }
      \sstsubsection{
         DATA\_IN( NPTS ) = REAL (Given)
      }{
         Input data
      }
      \sstsubsection{
         QUALITY\_IN( NPTS ) = BYTE (Given)
      }{
         Input data quality
      }
      \sstsubsection{
         WEIGHT = REAL (Given)
      }{
         Relative weight of input data
      }
      \sstsubsection{
         NCOADD( NPTS ) = INTEGER (Given \& Returned)
      }{
         Number of points coadded into each data point
      }
      \sstsubsection{
         DATA\_OUT( NPTS ) = REAL (Given \& Returned)
      }{
         Coadded output data
      }
      \sstsubsection{
         VARIANCE\_OUT( NPTS ) = REAL (Given \& Returned)
      }{
         Variance of coadded output data.
      }
      \sstsubsection{
         QUALITY\_OUT( NPTS ) = BYTE (Given \& Returned)
      }{
         Quality of coadded output data
      }
      \sstsubsection{
         WEIGHT\_OUT( NPTS ) = REAL (Given \& Returned)
      }{
         Total weight of output data
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_COADD\_REMOVE
}{
   remove exposure from coadded result
}{
   \sstdescription{
      This routine removes an exposure from the input coadd and puts the
      result in the output coadd arrays. The input and output
      arrays can be the same. The coadd result is the average of exposures
      remaining in the coadd. The coadd variance is calculated from
      the spread of the exposures about the mean if more than one exposure
      remains, 0 otherwise. Exposure pixels with bad quality are ignored.
   }
   \sstinvocation{
       CALL SCULIB\_COADD\_REMOVE (N, IN\_DATA, IN\_VARIANCE, IN\_QUALITY,
         INCOADD\_DATA, INCOADD\_VAR, INCOADD\_QUAL, INCOADD\_NUMBER,
         OUTCOADD\_DATA, OUTCOADD\_VAR, OUTCOADD\_QUAL, OUTCOADD\_NUMBER,
         VARIANCE)
   }
   \sstarguments{
      \sstsubsection{
         N                       = INTEGER (Given)
      }{
         Number of elements in arrays.
      }
      \sstsubsection{
         IN\_DATA (N)             = REAL (Given)
      }{
         data to be added to coadd
      }
      \sstsubsection{
         IN\_VARIANCE (N)         = REAL (Given)
      }{
         variance on input data
      }
      \sstsubsection{
         IN\_QUALITY (N)          = INTEGER (Given)
      }{
         quality on input data
      }
      \sstsubsection{
         INCOADD\_DATA (N)        = REAL (Given)
      }{
         Input coadd.
      }
      \sstsubsection{
         INCOADD\_VAR (N)         = REAL (Given)
      }{
         Input coadd variance.
      }
      \sstsubsection{
         INCOADD\_QUAL (N)        = INTEGER (Given)
      }{
         Input coadd quality
      }
      \sstsubsection{
         INCOADD\_NUMBER (N)      = INTEGER (Given)
      }{
         Number of exposures coadded in input coadd.
      }
      \sstsubsection{
         OUTCOADD\_DATA (N)       = REAL (Returned)
      }{
         Output coadd.
      }
      \sstsubsection{
         OUTCOADD\_VAR (N)        = REAL (Returned)
      }{
         Output coadd variance.
      }
      \sstsubsection{
         OUTCOADD\_QUAL (N)       = INTEGER (returned)
      }{
         Output coadd quality.
      }
      \sstsubsection{
         OUTCOADD\_NUMBER (N)     = INTEGER (Returned)
      }{
         Number of exposures coadded in output coadd.
      }
      \sstsubsection{
         VARIANCE                = LOGICAL (Given)
      }{
         T if input data has variance associated with it
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_COMPRESS\_DEMOD
}{
   get demodulated data for a bolometer and coadd
   jiggles in each integration
}{
   \sstdescription{
      This routine selects data for a specified bolometer from a demodulated
      data array, and coadds the results for each jiggle in each integration
      to give an average for that integration. Data with bad quality are
      ignored. The variance on the average will also be derived; set equal
      to the variance on the input data if only one jiggle contributes to the
      average, otherwise calculated from the spread of the input points about
      the mean.
   }
   \sstinvocation{
       CALL SCULIB\_COMPRESS\_DEMOD (N\_BOLS, N\_JIGS, N\_INTS,
         IN\_DATA, ADC\_INDEX, CHAN\_INDEX, INT\_INDEX, ADC, CHAN,
         OUT\_DATA, OUT\_VARIANCE, OUT\_QUALITY, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         N\_BOLS                 = INTEGER (Given)
      }{
         number of bolometers measured
      }
      \sstsubsection{
         N\_JIGS                 = INTEGER (Given)
      }{
         number of jiggles in pattern
      }
      \sstsubsection{
         N\_INTS                 = INTEGER (Given)
      }{
         number of integrations taken
      }
      \sstsubsection{
         IN\_DATA (4, N\_BOLS, N\_JIGS $*$ N\_INTS)
      }{
                          = REAL (Given)
         the demodulated data; 1=data, 2=variance, 3=calibrator, 4=quality
      }
      \sstsubsection{
         ADC\_INDEX (N\_BOLS)     = INTEGER (Given)
      }{
         the ADC numbers of the measured bolometers
      }
      \sstsubsection{
         CHAN\_INDEX (N\_BOLS)    = INTEGER (Given)
      }{
         the channel numbers of the measured bolometers
      }
      \sstsubsection{
         INT\_INDEX (N\_INTS)     = INTEGER (Given)
      }{
         the k index in IN\_DATA of the first jiggle of each integration
      }
      \sstsubsection{
         ADC                    = INTEGER (Given)
      }{
         the ADC number of the requested bolometer
      }
      \sstsubsection{
         CHAN                   = INTEGER (Given)
      }{
         the channel number of the requested bolometer
      }
      \sstsubsection{
         OUT\_DATA (N\_INTS)      = REAL (Returned)
      }{
         the values for each integration averaged over the jiggles
      }
      \sstsubsection{
         OUT\_VARIANCE (N\_INTS)  = REAL (Returned)
      }{
         the variance on OUT\_DATA
      }
      \sstsubsection{
         OUT\_QUALITY (N\_INTS)   = INTEGER (Returned)
      }{
         the quality on OUT\_DATA
      }
      \sstsubsection{
         STATUS                 = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstnotes{
      Only works for data where SWITCH\_PER\_EXP=1, EXP\_PER\_INT=1 and
      N\_MEASUREMENTS=1.
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_CONSTRUCT\_OUT
}{
   Append a identification string to a string
}{
   \sstdescription{
      Appends an ID string to an input string given the contents
      of the environment variable specified by ENV\_NAME
      Allowed values of ENV\_NAME are stored in OPTIONS and the
      corresponding string stored in OPTION\_STRINGS.
      Default is to go for the first entry in the IDSTRING array.
      if the value of ENV\_NAME is either not set or unrecognized.
   }
   \sstinvocation{
       CALL SCULIB\_CONSTRUCT\_OUT(IN\_STRING, ENV\_NAME,
         N\_OPTIONS, OPTIONS, OPTION\_STRINGS, OUT\_STRING, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         IN\_STRING = CHAR (Given)
      }{
         Input string
      }
      \sstsubsection{
         ENV\_NAME = CHAR (Given)
      }{
         Name of environment variable to examine for suffix preference
      }
      \sstsubsection{
         N\_OPTIONS = INTEGER (Given)
      }{
         Number of suffix options
      }
      \sstsubsection{
         OPTIONS(N\_OPTIONS) = CHAR (Given)
      }{
         Names of different options
      }
      \sstsubsection{
         OPTION\_STRINGS(N\_OPTIONS) = CHAR (Given)
      }{
         Suffixes for each option. If the string starts with a {\tt '}!{\tt '}
         the input string is chopped from the last {\tt '}\_{\tt '} before adding
         the new string.
      }
      \sstsubsection{
         OUT\_STRING = CHAR (Returned)
      }{
         Input string with suffix
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_CONVOLVE
}{
   convolve array A with array B to give result in R
}{
   \sstdescription{
      This routine convolves array A with array B using multiplication
      only (i.e. no FFTs are used). The routine assumes that the A arrays
      are N\_A long and that the convolution array B is N\_B long, centred
      at N\_MIDDLE. The final result is normalised by dividing by NORM.
      Elements of the A array that have bad quality are ignored. The input
      variances are propagated as:-

\begin{equation}
R_{Variance} = \frac{ \sum B^2A_{Variance}}{norm^2}
\end{equation}

      After this process the errors can no longer be considered independent.
   }
   \sstinvocation{
       CALL SCULIB\_CONVOLVE (A\_DATA, A\_VARIANCE, A\_QUALITY, B, N\_A, N\_B,
         N\_MIDDLE, NORM, R\_DATA, R\_VARIANCE, R\_QUALITY, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         A\_DATA (N\_A)                  = REAL (Given)
      }{
         input data array
      }
      \sstsubsection{
         A\_VARIANCE (N\_A)              = REAL (Given)
      }{
         variance on A\_DATA
      }
      \sstsubsection{
         A\_QUALITY (N\_A)               = BYTE (Given)
      }{
         quality on A\_DATA
      }
      \sstsubsection{
         B (N\_B)                       = REAL (Given)
      }{
         convolution function
      }
      \sstsubsection{
         N\_A                           = INTEGER (Given)
      }{
         the size of A\_DATA
      }
      \sstsubsection{
         N\_B                           = INTEGER (Given)
      }{
         length of convolution function
      }
      \sstsubsection{
         N\_MIDDLE                      = INTEGER (Given)
      }{
         index of zero point of convolution function
      }
      \sstsubsection{
         NORM                          = REAL (Given)
      }{
         normalisation factor for convolution function
      }
      \sstsubsection{
         R\_DATA (N\_A)                  = REAL (Returned)
      }{
         result of the convolution
      }
      \sstsubsection{
         R\_VARIANCE (N\_A)              = REAL (Returned)
      }{
         variance on R\_DATA
      }
      \sstsubsection{
         R\_QUALITY (N\_A)               = QUALITY (Returned)
      }{
         quality on R\_DATA
      }
      \sstsubsection{
         BADBIT                        = BYTE (Given)
      }{
         badbit mask
      }
      \sstsubsection{
         STATUS                        = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_COPY\_DEMOD\_SWITCH
}{
   copy a switch of demodulated data into
   arrays holding the switch chop data, chop
   variance, calibrator, cal variance and quality
   separately
}{
   \sstdescription{
      This routine copies the demodulated data for the jiggle positions
      measured in the last switch into separate arrays for the switch
      chop data, chop variance, calibrator, cal variance and quality.
      Quality is marked bad if BIT 1 is set and LEVEL is greater than requested
   }
   \sstinvocation{
       CALL SCULIB\_COPY\_DEMOD\_SWITCH (NBOLS, NDATA, NJIG,
         SWITCH, SWITCH\_DATA, SWITCH\_VARIANCE, SWITCH\_CALIBRATOR,
         SWITCH\_CAL\_VARIANCE, SWITCH\_QUALITY, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         NBOLS                           = INTEGER (Given)
      }{
         number of bolometers being measured
      }
      \sstsubsection{
         NDATA                           = INTEGER (Given)
      }{
         number of data per measured position; 5 for jiggle data, 4 for
         raster
      }
      \sstsubsection{
         NJIG                            = INTEGER (Given)
      }{
         number of jiggle positions measured
      }
      \sstsubsection{
         LEVEL                           = INTEGER (Given)
      }{
         level at which spikes are marked as bad quality
      }
      \sstsubsection{
         SWITCH (5, NBOLS, NJIG)         = REAL (Given)
      }{
         switch datablock
      }
      \sstsubsection{
         SWITCH\_DATA (NBOLS, NJIG)       = REAL (Returned)
      }{
         chop data for this switch of the exposure
      }
      \sstsubsection{
         SWITCH\_VARIANCE (NBOLS, NJIG)   = REAL (Returned)
      }{
         variance on the chop signal
      }
      \sstsubsection{
         SWITCH\_CALIBRATOR (NBOLS, NJIG) = REAL (Returned)
      }{
         calibrator for this switch of the exposure
      }
      \sstsubsection{
         SWITCH\_CAL\_VARIANCE (NBOLS, NJIG)= REAL (Returned)
      }{
         variance on the calibrator signal
      }
      \sstsubsection{
         SWITCH\_QUALITY (NBOLS, NJIG)    = BYTE (Returned)
      }{
         quality for this switch of the exposure
      }
      \sstsubsection{
         STATUS                          = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_COPY\_GOOD
}{
   Go through data set and throw away bad values
}{
   \sstdescription{
      This routine copies good data and variance from an input array to
      to an output array, leaving behind BAD values.
   }
   \sstinvocation{
       CALL SCULIB\_COPY\_GOOD(NPTS, INDATA, INVAR, INARR1, INARR2,
            NGOOD, OUTDATA, OUTVAR, OUTARR1, OUTARR2, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         NPTS = INTEGER (Given)
      }{
         The number of points in the input array
      }
      \sstsubsection{
         INDATA ( NPTS ) = REAL (Given)
      }{
         Input data
      }
      \sstsubsection{
         INVAR ( NPTS ) = REAL (Given)
      }{
         Input variance
      }
      \sstsubsection{
         INARR1 ( NPTS ) = DOUBLE (Given)
      }{
         Auxilliary double precision array
      }
      \sstsubsection{
         INARR2 ( NPTS ) = DOUBLE (Given)
      }{
         Auxilliary double precision array
      }
      \sstsubsection{
         NGOOD = INTEGER (Returned)
      }{
         Number of good points in input data
      }
      \sstsubsection{
         OUTDATA ( NPTS ) = REAL (Returned)
      }{
         Output data
      }
      \sstsubsection{
         OUTVAR ( NPTS ) = REAL (Returned)
      }{
         Output variance
      }
      \sstsubsection{
         OUTARR1 ( NPTS ) = REAL (Returned)
      }{
         Good auxiliary data converted to real
      }
      \sstsubsection{
         OUTARR2 ( NPTS ) = REAL (Returned)
      }{
         Good auxiliary data converted to real
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Data are still good even if VARIANCE or AUX are bad
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         Only a routine for REAL numbers exists
      }
   }
}
\sstroutine{
   SCULIB\_COPYB
}{
   copy one byte array to another
}{
   \sstdescription{
      copies one integer array into another
   }
   \sstinvocation{
      CALL SCULIB\_COPYB (N, FROM, TO)
   }
   \sstarguments{
      \sstsubsection{
         N          = INTEGER (Given)
      }{
         number of integers in arrays
      }
      \sstsubsection{
         FROM (N)   = BYTE (Given)
      }{
         array copied from
      }
      \sstsubsection{
         TO (N)     = BYTE (Returned)
      }{
         array copied to
      }
   }
   \sstnotes{
      This routine is deprecated. Use VEC\_BTOB (SUN/39) instead.
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_COPYD
}{
   copy one double precision array to another
}{
   \sstdescription{
      copies one double precision array into another
   }
   \sstinvocation{
      CALL SCULIB\_COPYD (N, FROM, TO)
   }
   \sstarguments{
      \sstsubsection{
         N          = INTEGER (Given)
      }{
         number of elements in arrays
      }
      \sstsubsection{
         FROM (N)   = DOUBLE PRECISION (Given)
      }{
         array copied from
      }
      \sstsubsection{
         TO (N)     = DOUBLE PRECISION (Returned)
      }{
         array copied to
      }
   }
   \sstnotes{
      This routine is deprecated. Use VEC\_DTOD (SUN/39) instead.
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_COPYI
}{
   copy one integer array to another
}{
   \sstdescription{
      copies one integer array into another
   }
   \sstinvocation{
      CALL SCULIB\_COPYI (N, FROM, TO)
   }
   \sstarguments{
      \sstsubsection{
         N          = INTEGER (Given)
      }{
         number of integers in arrays
      }
      \sstsubsection{
         FROM (N)   = INTEGER (Given)
      }{
         array copied from
      }
      \sstsubsection{
         TO (N)     = INTEGER (Returned)
      }{
         array copied to
      }
   }
   \sstnotes{
      This routine is deprecated. Use VEC\_ITOI (SUN/39) instead.
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_COPYR
}{
   copy one real array to another
}{
   \sstdescription{
      copies one real array into another
   }
   \sstinvocation{
      CALL SCULIB\_COPYR (N, FROM, TO)
   }
   \sstarguments{
      \sstsubsection{
         N          = INTEGER (Given)
      }{
         number of reals in arrays
      }
      \sstsubsection{
         FROM (N)   = REAL (Given)
      }{
         array copied from
      }
      \sstsubsection{
         TO (N)     = REAL (Returned)
      }{
         array copied to
      }
   }
   \sstnotes{
      This routine is deprecated. Use VEC\_RTOR (SUN/39) instead.
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_CORRECT\_EXTINCTION
}{
   correct bolometers for sky opacity
}{
   \sstdescription{
      This routine corrects bolometer data for the effect of sky opacity.
      It does this by calculating the airmass of the point that each
      bolometer was looking at, then multiplying the data by
      exp (airmass $*$ TAUZ). Bolometers with bad data quality will be
      ignored.
   }
   \sstinvocation{
       CALL SCULIB\_CORRECT\_EXTINCTION (SIZE\_BOL, N\_BOL, BOL\_DATA,
         BOL\_VARIANCE, BOL\_RA, BOL\_DEC, LST, LAT\_OBS,
         TAUZ, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         SIZE\_BOL                       = INTEGER (Given)
      }{
         dimension of arrays
      }
      \sstsubsection{
         N\_BOL                          = INTEGER (Given)
      }{
         used size of arrays
      }
      \sstsubsection{
         BOL\_DATA (SIZE\_BOL)            = REAL (Given and returned)
      }{
         bolometer data
      }
      \sstsubsection{
         BOL\_VARIANCE (SIZE\_BOL)        = REAL (Given and returned)
      }{
         variance on BOL\_DATA
      }
      \sstsubsection{
         BOL\_RA (SIZE\_BOL)              = DOUBLE PRECISION (Given)
      }{
         apparent RA of bolometer (radians)
      }
      \sstsubsection{
         BOL\_DEC (SIZE\_BOL)             = DOUBLE PRECISION (Given)
      }{
         apparent dec of bolometer (radians)
      }
      \sstsubsection{
         LST                            = DOUBLE PRECISION (Given)
      }{
         sidereal time (radians)
      }
      \sstsubsection{
         LAT\_OBS                        = DOUBLE PRECISION (Given)
      }{
         latitude of observatory (radians)
      }
      \sstsubsection{
         TAUZ                           = REAL (Given)
      }{
         the zenith sky opacity
      }
      \sstsubsection{
         STATUS                         = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_COVSRT
}{
   Numerical Recipes in Fortran routine called by SCULIB\_MRQMIN
}{
   \sstdescription{
      Expand in storage the covariance matrix COVAR, so as to take into account
      parameters that are being held fixed. (For the latter return zero
      covariances). Derived from COVSRT in Numerical Recipes in Fortran, p.669,
      with STATUS added.
   }
   \sstinvocation{
      CALL SCULIB\_COVSRT (COVAR, NPC, MA, IA, MFIT, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         COVAR (  NPC, NPC ) = REAL (Given \& Returned)
      }{
         Covariance matrix
      }
      \sstsubsection{
         INTEGER NPC = INTEGER (Given)
      }{
         Size of covariance matrix
      }
      \sstsubsection{
         INTEGER MA = INTEGER (Given)
      }{
         Size of IA array. Total number of parameters.
      }
      \sstsubsection{
         INTEGER IA ( MA ) = INTEGER (Given)
      }{
         Ordering of parameters. Not a free parameter if containes 0.
      }
      \sstsubsection{
         INTEGER MFIT = INTEGER (Given)
      }{
         Number of required parameters
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status
      }
   }
   \sstnotes{
      Derived from the {\tt '}Numerical Recipes in Fortran{\tt '} COVSRT routine.
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1993,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_CROSSTALK
}{
   crosstalk measurements
}{
   \sstdescription{
      Experimental routine for calculating crosstalk between
      A-to-D cards. Averages signal for each bolometer and writes
      to a file. The file name comes from the FILE ADAM parameter.
   }
   \sstinvocation{
       CALL SCULIB\_CROSSTALK (SWITCH\_PER\_EXP, EXP\_PER\_INT,
         N\_INTEGRATIONS, N\_MEASUREMENTS, DEMOD\_POINTER, N\_BOLS,
         NUMPOS, DATA, BOL\_CHAN, BOL\_ADC, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         SWITCH\_PER\_EXP         = INTEGER (Given)
      }{
         number of switches per exposure
      }
      \sstsubsection{
         EXP\_PER\_INT            = INTEGER (Given)
      }{
         number of exposures per integration
      }
      \sstsubsection{
         N\_INTEGRATIONS         = INTEGER (Given)
      }{
         number of integrations
      }
      \sstsubsection{
         N\_MEASUREMENTS         = INTEGER (Given)
      }{
         number of measurments
      }
      \sstsubsection{
         DEMOD\_POINTER (SWITCH\_PER\_EXP, EXP\_PER\_INT, N\_INTEGRATIONS,
      }{
         N\_MEASUREMENTS)      = INTEGER (Given)
             pointer to start of demodulated data for each switch in
             DATA array
      }
      \sstsubsection{
         N\_BOLS                 = INTEGER (Given)
      }{
         number of bolometers being measured
      }
      \sstsubsection{
         NUMPOS                 = INTEGER (Given)
      }{
         total number of positions measured
      }
      \sstsubsection{
         DATA (4, N\_BOLS, NUMPOS)
      }{
                          = REAL (Given)
         the demodulated data
      }
      \sstsubsection{
         BOL\_CHAN (N\_BOLS)      = INTEGER (Given)
      }{
         the channel number of the measured bolometers
      }
      \sstsubsection{
         BOL\_ADC (N\_BOLS)       = INTEGER (Given)
      }{
         the ADC numbers of the measured bolometers
      }
      \sstsubsection{
         STATUS                 = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_DAY
}{
   returns date and time as day number since 1st Jan
}{
   \sstdescription{
      Calculates the time since 1st January. The time is returned
      as a day number and fractional day.
   }
   \sstinvocation{
      DAY = SCULIB\_DAY ()
   }
   \sstarguments{
      \sstsubsection{
         None
      }{
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         SCULIB\_DAY = DOUBLE PRECISION
      }{
         date and time as a day number since 1st Jan
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1994,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_DECODE\_ANGLE
}{
   convert angle string to double precision angle
}{
   \sstdescription{
      This routine converts an angle in dd:mm:ss.dd format into a
      double precision number in radians. It assumes that the input
      string specifies the angle in degrees. The process involves
      removing the {\tt '}:{\tt '} delimiters, then calling SLA\_DAFIN to perform
      the conversion. An error will be returned if there are less than 2 {\tt '}:{\tt '}
      delimiters in the string, or if the SLA routine errors.
   }
   \sstinvocation{
      CALL SCULIB\_DECODE\_ANGLE (STRING, ANGLE, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         STRING         = CHARACTER$*$($*$) (Given)
      }{
         angle in xx:mm:ss.ddd format
      }
      \sstsubsection{
         ANGLE          = DOUBLE PRECISION (Returned)
      }{
         angle in radians
      }
      \sstsubsection{
         STATUS         = INTEGER (Given and returned)
      }{
         Global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_DECODE\_COMPONENT
}{
   This routine decodes the value of a single component in a SCUBA
   data-spec
}{
   \sstdescription{
      This routine decodes the value of a single component in a SCUBA
      data-spec. It is called by SCULIB\_DECODE\_SPEC. The component can be:-

      \sstitemlist{

         \sstitem
         [1]   {\tt "}$*${\tt "}                     select all data

         \sstitem
         [2]   {\tt "}$<$index$>${\tt "}               select data at position $<$index$>$

         \sstitem
         [3]   {\tt "}$<$index1$>$,$<$index2$>${\tt "}     select data at positions $<$index1$>$ and
                                   $<$index2$>$

         \sstitem
         [4]   {\tt "}$<$index1$>$:$<$index2$>${\tt "}     select all data in the range $<$index1$>$ to
                                   $<$index2$>$

      }
      or any combination of 2, 3 and 4 separated by commas. Example
      component values are:-

      \sstitemlist{

         \sstitem
          {\tt "}$*${\tt "}                     select all data

         \sstitem
          {\tt "}1,5{\tt "}                   select data at indices 1 and 5

         \sstitem
          {\tt "}5:10,16{\tt "}               select data at indices 5 through 10 and 16

      }
      Errors will occur if:-

      \sstitemlist{

         \sstitem
           You mix the $*$ format with selection by index.

         \sstitem
           Any index selected lies outside the range 1 to N.

         \sstitem
           In a selection range $<$index2$>$ is less than $<$index1$>$.

         \sstitem
           The component does not conform to the design syntax.

      }
      Output from the routine is in the form of a mask array SELECT.
      Data indices selected will be marked as 1 in SELECT, while indices
      not selected will be zeroes.
   }
   \sstinvocation{
      CALL SCULIB\_DECODE\_COMPONENT (COMPONENT, N, SELECT, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         COMPONENT                        = CHARACTER$*$($*$) (Given)
      }{
         the component  to be decoded
      }
      \sstsubsection{
         N                                = INTEGER (Given)
      }{
         the number of items that can be selected
      }
      \sstsubsection{
         SELECT (N)                       = INTEGER (Returned)
      }{
         the items selected; 1 for selected, 0 for not selected
      }
      \sstsubsection{
         STATUS                           = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_DECODE\_FILTER
}{
   decode filter name into names and wavelengths of
   filters in front of each instrument section in use
}{
   \sstdescription{
      This routine decodes the filter name to give the name and central
      wavelength of the filter in front of each sub-instrument being used.

         The filter name should be in format $<$short$>$:$<$long$>$ where these
      are the names of the filters in front of the short and long-wave
      focal planes.

\texttt{
\begin{tabular}{crrcrl}
\multicolumn{6}{l}{$<$short$>$ can be:-}\\
'350'  &    short wavelength &=&  350.0 & name =& '350'\\
'450'  &                     & &  450.0 &       & '450'\\
'600'  &                     & &  600.0 &       & '600'\\
'750'  &                     & &  750.0 &       & '750'\\
'850'  &                     & &  850.0 &       & '850'\\
'PHOT' &                     & &   -1.0 &       & 'BLANK'\\
&&&&&\\
\multicolumn{6}{l}{$<$long$>$ can be:-}\\
'350'  &         long array  &=&  350.0  &name =& '350'\\
       &P1100, P1300, P2000  & &  350.0  &      & '350'\\
'450'  &         long array  &=&  450.0  &      & '450'\\
       &P1100, P1300, P2000  & &  450.0  &      & '450'\\
'600'  &         long array  &=&  600.0  &      & '600'\\
       &P1100, P1300, P2000  & &  600.0  &      & '600'\\
'750'  &         long array  &=&  750.0  &      & '750'\\
       &P1100, P1300, P2000  & &  750.0  &      & '750'\\
'850'  &         long array  &=&  850.0  &      & '850'\\
       &P1100, P1300, P2000  & &  850.0  &      & '850'\\
'PHOT' &         long array  &=&   -1.0  &      &  'BLANK'\\
       &              P1100  &=& 1100.0  &      &'1100'\\
       &              P1300  &=& 1300.0  &      &'1300'\\
       &              P2000  &=& 2000.0  &      &'2000'\\
\end{tabular}
}

      If the filter name does not fit the `pattern' described an error message
      will be output and the routine return with bad status. The routine is
      insensitive to the case of `PHOT'.
   }
   \sstinvocation{
       CALL SCULIB\_DECODE\_FILTER (FILTER, N\_SUB, SUB\_INSTRUMENT,
         SUB\_FILTER, WAVELENGTH, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         FILTER                   = CHARACTER$*$($*$) (Given)
      }{
         name of filter
      }
      \sstsubsection{
         N\_SUB                    = INTEGER (Given)
      }{
         number of sub instruments being used
      }
      \sstsubsection{
         SUB\_INSTRUMENT (N\_SUB)   = CHARACTER$*$($*$) (Given)
      }{
         the names of the sub instruments being used
      }
      \sstsubsection{
         SUB\_FILTER (N\_SUB)       = CHARACTER$*$($*$) (Returned)
      }{
         the name of the filter in front of each sub-instrument
      }
      \sstsubsection{
         WAVELENGTH (N\_SUB)       = REAL (Returned)
      }{
         the wavelength in microns of the filters in front of the sub
         instruments being used. An inappropriate filter will have
         wavelength set to VAL\_\_BADR
      }
      \sstsubsection{
         STATUS                   = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstnotes{
      The wavelength values are probably out of step with those currently
      in use by the real-time system.
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_SPLIT\_DECODE\_REBIN\_LINE
}{
   Splits a string into a filename and parameters for REBIN
}{
   \sstdescription{
      This routine takes a string and splits it into bits.
      The format is assumed to be:

          FILESPEC WEIGHT SHIFT\_DX SHIFT\_DY

      The string is broken up from left to right.
      There must always be a weight if there is a shift
      There must always be a shift if there is a section. etc...
      Comment character is \#. A line contains a comment once a \#
      appears on the line. Only chars before the \# are valid.
   }
   \sstinvocation{
       CALL SCULIB\_DECODE\_REBIN\_LINE(LINE, N\_FOUND, NAME,
            WEIGHT, SHIFT\_DX, SHIFT\_DY, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         LINE = CHAR (Given)
      }{
         Line read from file
      }
      \sstsubsection{
         N\_FOUND = INTEGER (Returned)
      }{
         Number of parameters found in LINE
      }
      \sstsubsection{
         NAME = CHARACTER (Returned)
      }{
         File name $+$ (optional) SCUBA section
      }
      \sstsubsection{
         WEIGHT = REAL (Returned)
      }{
         Relative weight given to filename
      }
      \sstsubsection{
         SHIFT\_DX = REAL (Returned)
      }{
         Shift in X
      }
      \sstsubsection{
         SHIFT\_DY = REAL (Returned)
      }{
         Shift in Y
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         Global Status value
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_DECODE\_SPEC
}{
   Decode SCUBA-style data specifications
}{
   \sstdescription{
      This routine decodes a SCUBA-style data specification. The data-spec
      will be of the form \{$<$component$>$;$<$component$>$;...\}, where components
      are one of the following:-

      \sstitemlist{

         \sstitem
         B$<$index\_spec$>$   - specifying bolometer indices

         \sstitem
         P$<$index\_spec$>$   -            position indices

         \sstitem
         S$<$index\_spec$>$   -            switch indices

         \sstitem
         E$<$index\_spec$>$   -            exposure indices

         \sstitem
         I$<$index\_spec$>$   -            integration indices

         \sstitem
         M$<$index\_spec$>$   -            measurement indices

      }
      and the $<$index\_spec$>$ is a list like, for example, 2,5:7,17 to select
      indices 2, 5 through 7 and 17. Alternatively, $<$index\_spec$>$ can be $*$
      which will select all data in that component coordinate.
      The data spec can be passed in as an array of data specs. The
      number is specified by N\_SPEC.
      By default all components in a dataset are selected. Thus the
      empty data-spec \{\} will return all components selected. Example
      data-specs are:-

      \sstitemlist{

         \sstitem
          {\tt "}\{\}               -         select all data

         \sstitem
          {\tt "}\{B7,12;P57\}{\tt "}     -          select data for bolometers 7 and 12 at
                                     measurement position 57

         \sstitem
          {\tt "}\{S2;E1;I3:M2\}{\tt "}   -          select data for all bolometers in
                                     switch 2 of exposure 1 of integration 3
                                     in measurement 2 of the observation

         \sstitem
          {\tt "}\{B29\}{\tt "}           -          select all data for bolometer 29

         \sstitem
          {\tt "}\{B29;E1\}{\tt "}        -          select data for bolometer 29 in the
                                     first exposure of each integration

      }
      The data-spec is case-insensitive and blanks are ignored.

      Errors will occur:-

      \sstitemlist{

         \sstitem
          If you attempt to select indices outside the dimensions input to
           the routine.

         \sstitem
          If you attempt to select data both by position Pxxx and by switch
           Sxxx, exposure Exxx, integration Ixxx or measurement Mxxx.

         \sstitem
          If you attempt to select by switch Sxxx when the SWITCH\_EXPECTED
           flag is input .FALSE.

      }
      Output consists of a flag POS\_SELECTED, to say whether or not the
      data were selected by position, and mask arrays that are set
      to 1 at the coordinate of selected data and 0 otherwise. Even if the
      data were not selected by position the POS\_S array, which is the mask
      for the position coordinate, will be set correctly. Conversely,
      however, the MEAS\_S, INT\_S, EXP\_S and SWITCH\_S arrays, which are
      masks for the measurement, integration, exposure and switch will not
      be set to sensible values if the data are position selected.
   }
   \sstinvocation{
       CALL SCULIB\_DECODE\_SPEC (SPEC, DEMOD\_POINTER,
            N\_SWITCHES,N\_EXPOSURES, N\_INTEGRATIONS, N\_MEASUREMENTS,
            N\_POS, N\_BOLS, SWITCH\_EXPECTED, POS\_SELECTED, POS\_S,
            SWITCH\_S, EXP\_S, INT\_S, MEAS\_S, BOL\_S, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         N\_SPEC                           = INTEGER (Given)
      }{
         Number of specifications supplied in SPEC
      }
      \sstsubsection{
         SPEC( N\_SPEC )                   = CHARACTER$*$($*$) (Given)
      }{
         the specification to be decoded
      }
      \sstsubsection{
         DEMOD\_POINTER (N\_SWITCHES, N\_EXPOSURES, N\_INTEGRATIONS,  N\_MEASUREMENTS)
      }{
      }
      \sstsubsection{
         = INTEGER (Given)
      }{
         the pointer to the location in the main data array of the data
         for each switch of the observation
      }
      \sstsubsection{
         N\_SWITCHES                       = INTEGER (Given)
      }{
         the number of switches per exposure
      }
      \sstsubsection{
         N\_EXPOSURES                      = INTEGER (Given)
      }{
         the number of exposures per integration
      }
      \sstsubsection{
         N\_INTEGRATIONS                   = INTEGER (Given)
      }{
         the number of integrations per measurement
      }
      \sstsubsection{
         N\_MEASUREMENTS                   = INTEGER (Given)
      }{
         the number of measurements in the observation
      }
      \sstsubsection{
         N\_POS                            = INTEGER (Given)
      }{
         the number of positions measured in the observation
      }
      \sstsubsection{
         N\_BOLS                           = INTEGER (Given)
      }{
         the number of bolometers measured in the observation
      }
      \sstsubsection{
         SWITCH\_EXPECTED                  = LOGICAL (Given)
      }{
         .TRUE. if a switch component is allowed in the data-spec
      }
      \sstsubsection{
         POS\_SELECTED                     = LOGICAL (Returned)
      }{
         .TRUE. if the P component is used in the data-spec
      }
      \sstsubsection{
         POS\_S (N\_POS)                    = INTEGER (Returned)
      }{
         the position mask array; 1 for selected positions, 0 otherwise
      }
      \sstsubsection{
         SWITCH\_S (N\_SWITCHES)            = INTEGER (Returned)
      }{
         the switch mask array; 1 for selected switches, 0 otherwise
      }
      \sstsubsection{
         EXP\_S (N\_EXPOSURES)              = INTEGER (Returned)
      }{
         the exposure mask array; 1 for selected exposures, 0 otherwise
      }
      \sstsubsection{
         INT\_S (N\_INTEGRATIONS)           = INTEGER (Returned)
      }{
         the integration mask array; 1 for selected integrations, 0
         otherwise
      }
      \sstsubsection{
         MEAS\_S (N\_MEASUREMENTS)          = INTEGER (Returned)
      }{
         the measurement mask array; 1 for selected measurements, 0
         otherwise
      }
      \sstsubsection{
         BOL\_S (N\_BOLS)                   = INTEGER (Returned)
      }{
         the bolometer mask array; 1 for selected bolometers, 0 otherwise
      }
      \sstsubsection{
         STATUS                           = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_DIV\_CALIBRATOR
}{
   divides the calibrator signal into the chop signal
}{
   \sstdescription{
      This routine divides the calibrator signal into the chop signal and
      variance over an array of measurements. No division will occur if the
      measurement quality is bad or the square of the calibrator signal is zero.
   }
   \sstinvocation{
       CALL SCULIB\_DIV\_CALIBRATOR (NELM, DATA, VARIANCE, CALIBRATOR,
         QUALITY)
   }
   \sstarguments{
      \sstsubsection{
         NELM                = INTEGER (Given)
      }{
         Number of elements in each array
      }
      \sstsubsection{
         DATA (NELM)         = REAL (Given and returned)
      }{
         Demodulated data array
      }
      \sstsubsection{
         VARIANCE (NELM)     = REAL (Given and returned)
      }{
         Variance on DATA
      }
      \sstsubsection{
         CALIBRATOR (NELM)   = REAL (Given)
      }{
         Calibration array
      }
      \sstsubsection{
         QUALITY (NELM)      = BYTE (Given)
      }{
         Quality on DATA
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         inherited status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_DIV\_CALIBRATOR\_2
}{
   divides the mean of the calibrator signal into
   the chop signal
}{
   \sstdescription{
      This routine divides the calibrator signal into the chop signal and
      variance over an array of measurements. No division will occur if the
      measurement quality is bad or the square of the calibrator signal is zero.
   }
   \sstinvocation{
       CALL SCULIB\_DIV\_CALIBRATOR\_2 (N\_BOLS, N\_POS, DATA, VARIANCE,
         CALIBRATOR, QUALITY)
   }
   \sstarguments{
      \sstsubsection{
         N\_BOLS              = INTEGER (Given)
      }{
         Number of bolometers measured
      }
      \sstsubsection{
         N\_POS               = INTEGER (Given)
      }{
         Number of positions measured
      }
      \sstsubsection{
         DATA (N\_BOLS,N\_POS) = REAL (Given and returned)
      }{
         Demodulated data array
      }
      \sstsubsection{
         VARIANCE (N\_BOLS,N\_POS)
      }{
                    = REAL (Given and returned)
         Variance on DATA
      }
      \sstsubsection{
         CALIBRATOR (N\_BOLS,N\_POS)
      }{
                    = REAL (Given)
         Calibration array
      }
      \sstsubsection{
         QUALITY (N\_BOLS,N\_POS)
      }{
                    = BYTE (Given and returned)
         Quality on DATA
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         inherited status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_EXTRACT\_2DIM\_B
}{
   To extract the second dimension (at a given X) from a 2d array
}{
   \sstdescription{
      This routine extracts a second dimension from a 2D byte array.
   }
   \sstinvocation{
      CALL SCULIB\_EXTRACT\_2DIM\_B(X, NX, NY, TWOD, ONED, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         X = INTEGER (Given)
      }{
         The X index in the 2D array to be extracted
      }
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         Size of the array in x
      }
      \sstsubsection{
         NY = INTEGER (Given)
      }{
         Size of the array in y
      }
      \sstsubsection{
         TWOD = BYTE (Given)
      }{
         2D array input dataset
      }
      \sstsubsection{
         ONED = BYTE (Returned)
      }{
         1D strip extracted from 2D array
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status
      }
   }
   \sstnotes{
      This is the BYTE routine.
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_EXTRACT\_2DIM\_D
}{
   To extract the second dimension (at a given X) from a 2d array
}{
   \sstdescription{
      This routine extracts a second dimension from a 2D DOUBLE array.
   }
   \sstinvocation{
      CALL SCULIB\_EXTRACT\_2DIM\_D(X, NX, NY, TWOD, ONED, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         X = INTEGER (Given)
      }{
         The X index in the 2D array to be extracted
      }
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         Size of the array in x
      }
      \sstsubsection{
         NY = INTEGER (Given)
      }{
         Size of the array in y
      }
      \sstsubsection{
         TWOD = DOUBLE (Given)
      }{
         2D array input dataset
      }
      \sstsubsection{
         ONED = DOUBLE (Returned)
      }{
         1D strip extracted from 2D array
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status
      }
   }
   \sstnotes{
      This is the DOUBLE PRECISION routine.
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_EXTRACT\_2DIM\_R
}{
   To extract the second dimension (at a given X) from a 2d array
}{
   \sstdescription{
      This routine extracts a second dimension from a 2D REAL array.
   }
   \sstinvocation{
      CALLSCULIB\_EXTRACT\_2DIM\_R(X, NX, NY, TWOD, ONED, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         X = INTEGER (Given)
      }{
         The X index in the 2D array to be extracted
      }
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         Size of the array in x
      }
      \sstsubsection{
         NY = INTEGER (Given)
      }{
         Size of the array in y
      }
      \sstsubsection{
         TWOD = REAL (Given)
      }{
         2D array input dataset
      }
      \sstsubsection{
         ONED = REAL (Returned)
      }{
         1D strip extracted from 2D array
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status
      }
   }
   \sstnotes{
      This is the REAL routine.
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_EXTRACT\_BOL
}{
   To extract a single bolometer from a data array
}{
   \sstdescription{
      This routine extracts a single bolometer from a SCUBA data array.
   }
   \sstinvocation{
       CALL SCULIB\_EXTRACT\_BOL(NBOL, N\_BOLS, N\_POS, SCUDATA,
            SCUQUAL, BOLDATA, BOLQUAL, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         NBOL = INTEGER (Given)
      }{
         The bolometer number
      }
      \sstsubsection{
         N\_BOLS = \_INTEGER (Given)
      }{
         Total number of bolometers in data array
      }
      \sstsubsection{
         N\_POS = INTEGER (Given)
      }{
         Number of jiggle positions in data set
      }
      \sstsubsection{
         SCUDATA(N\_BOLS, N\_POS) = REAL (Given)
      }{
         The data
      }
      \sstsubsection{
         SCUQUAL(N\_BOLS, N\_POS) = BYTE (Given)
      }{
         The data quality
      }
      \sstsubsection{
         BOLDATA(N\_POS) = REAL (Returned)
      }{
         The specified bolometer data
      }
      \sstsubsection{
         BOLQUAL(N\_POS) = \_BYTE (Returned)
      }{
         The bolometer quality
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         Global Status value
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
   \sstimplementationstatus{
      Propogates quality
   }
}
\sstroutine{
   SCULIB\_FIND\_INT
}{
   Return the indices of the start and end of the specified integration
}{
   \sstdescription{
      This routine find that start and end indices of the specified
      integration. In general these can be found directly from
      the DEMOD\_POINTER array but with the warning that the last
      integration will not necessarily point to the end of the
      data array if multiple measurements are being taken. For this
      reason, put this knowledge in one place.
   }
   \sstinvocation{
       CALL SCULIB\_FIND\_INT(DEMOD\_POINTER, N\_SWITCHES,
            N\_EXPOSURES, N\_INTEGRATIONS, N\_MEASUREMENTS, N\_POS,
            INTEG, MEAS, I\_START, I\_END, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         DEMOD\_POINTER ( N\_SWITCHES, N\_EXPOSURES, N\_INTEGRATIONS, N\_MEASUREMENTS ) = INTEGER (Given)
      }{
         an array of pointers to the start of each switch
      }
      \sstsubsection{
         N\_SWITCHES            = INTEGER (Given)
      }{
         the number of switches per exposure
      }
      \sstsubsection{
         N\_EXPOSURES           = INTEGER (Given)
      }{
         the number of exposures per integration
      }
      \sstsubsection{
         N\_INTEGRATIONS        = INTEGER (Given)
      }{
         the number of integrations per measurement
      }
      \sstsubsection{
         N\_MEASUREMENTS        = INTEGER (Given)
      }{
         the number of measurements in the observation
      }
      \sstsubsection{
         N\_POS                 = INTEGER (Given)
      }{
         the total number of positions measured in the observation
      }
      \sstsubsection{
         INTEG                 = INTEGER (Given)
      }{
         the integration number of the switch
      }
      \sstsubsection{
         MEAS                  = INTEGER (Given)
      }{
         the measurement number of the switch
      }
      \sstsubsection{
         I\_START               = INTEGER (Returned)
      }{
         pointer to the start of the integration
      }
      \sstsubsection{
         I\_END                 = INTEGER (Returned)
      }{
         pointer to the end of the integration
      }
      \sstsubsection{
         STATUS                = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_FIND\_SWITCH
}{
   find the start and end indices of a switch in the
   demodulated data array
}{
   \sstdescription{
      This routine finds the start and end indices of the specified switch
      in a SCUBA observation. The array DEMOD\_POINTER contains the start
      indices, so this part is easy. However, the end index will be 1 less
      than the start index of the next, or the index of the last position
      measured if the specified switch is the last in the observation. This
      makes things a little complicated because consecutive switches within
      an exposure need not have been taken and stored consecutively,
      though exposures, integrations and measurements are ordered as one
      would expect.
   }
   \sstinvocation{
       CALL SCULIB\_FIND\_SWITCH (DEMOD\_POINTER, N\_SWITCHES, N\_EXPOSURES,
         N\_INTEGRATIONS, N\_MEASUREMENTS, N\_POS, SWITCH, EXP, INT, MEAS,
         S\_START, S\_END, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         DEMOD\_POINTER (N\_SWITCHES, N\_EXPOSURES, N\_INTEGRATIONS, N\_MEASUREMENTS) = INTEGER (Given)
      }{
         an array of pointers to the start of each switch
      }
      \sstsubsection{
         N\_SWITCHES            = INTEGER (Given)
      }{
         the number of switches per exposure
      }
      \sstsubsection{
         N\_EXPOSURES           = INTEGER (Given)
      }{
         the number of exposures per integration
      }
      \sstsubsection{
         N\_INTEGRATIONS        = INTEGER (Given)
      }{
         the number of integrations per measurement
      }
      \sstsubsection{
         N\_MEASUREMENTS        = INTEGER (Given)
      }{
         the number of measurements in the observation
      }
      \sstsubsection{
         N\_POS                 = INTEGER (Given)
      }{
         the total number of positions measured in the observation
      }
      \sstsubsection{
         SWITCH                = INTEGER (Given)
      }{
         the index of the switch
      }
      \sstsubsection{
         EXP                   = INTEGER (Given)
      }{
         the exposure number of the switch
      }
      \sstsubsection{
         INT                   = INTEGER (Given)
      }{
         the integration number of the switch
      }
      \sstsubsection{
         MEAS                  = INTEGER (Given)
      }{
         the measurement number of the switch
      }
      \sstsubsection{
         S\_START               = INTEGER (Returned)
      }{
         pointer to the start of the switch
      }
      \sstsubsection{
         S\_END                 = INTEGER (Returned)
      }{
         pointer to the end of the switch
      }
      \sstsubsection{
         STATUS                = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_FIT\_2D\_GAUSSIAN
}{
   fit a 2D Gaussian to an image
}{
   \sstdescription{

      This routine fits a 2D Gaussian to an image of a source. It takes as
      input data a map made of the source with pixels on a square grid.

 If status is good on entry, the routine will calculate the 0th ($U_0$) and
      1st order ($U_x$, $U_y$) moments of the image on the map. Map pixels
      with bad quality are ignored:

 The 0th order is calculated as
\begin{equation}
U_0 = \sum_{ij} f_{ij},
\end{equation}
where i,j are the pixel indices. The 1st order moment in X is calculated as
\begin{equation}
U_x = \sum_{ij} x f_{ij},
\end{equation}
where x is the x position of pixel i,j; and the 1st order moment in Y is
calculated as
\begin{equation}
U_y = \sum_{ij} y f_{ij},
\end{equation}
where y is the y position of pixel i,j.

      If the 0th order moment of the image was 0, i.e. there is no image on
      the map, then a warning message will be output and all image parameters
      set to 0 or bad quality. Otherwise, the x,y centre of the image is
      calculated from:-

\begin{equation}
X_\mathrm{cen} = \frac{U_x}{U_0}
\end{equation}
\begin{equation}
Y_\mathrm{cen} = \frac{U_y}{U_0}
\end{equation}

      With this information the 2nd order moments can be calculated about the
      centre of the image:-

\begin{equation}
          U_{xx} = \sum_{ij} (x - X_{cen})^2 f_{ij}
\end{equation}
\begin{equation}
          U_{yy} = \sum_{ij} (y - Y_{cen})^2  f_{ij}
\end{equation}

      If the image had a 2D Gaussian profile,
\begin{equation}
f = A \exp(-a_x^2 x^2) \exp(-a_y^2 y^2),
\end{equation}
      then it can be shown that for x:-

\begin{equation}
a_x^2 = \frac{U_0}{2 U_{xx}}
\end{equation}

      and the half-width at half-maximum is calculated from:-

\begin{equation}
X_\mathrm{HWHM} = \sqrt{\ln(2)}{a_x}
\end{equation}

         Lastly, the volume under the image and the variance on it are
      calculated. These will be the sum of all map pixels and their variances
      that lie within a radius of 2 $*$ max(HWHM\_x, HWHM\_y) from X\_CENTRE,
      Y\_CENTRE. If the HWHM in either axis is zero then a warning message will
      be output and PEAK\_QUAL set bad. Otherwise, PEAK will be set to
      volume / ($\pi$ $*$ HWHM\_x $*$ HWHM\_y).
   }
   \sstinvocation{
       CALL SCULIB\_FIT\_2D\_GAUSSIAN (IDIM, JDIM, MAP\_DATA,
         MAP\_VARIANCE, MAP\_QUALITY, X, Y, PEAK, PEAK\_VAR,
         PEAK\_QUAL, X\_CENTRE, Y\_CENTRE, X\_HWHM, Y\_HWHM, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         IDIM                              = INTEGER (Given)
      }{
         `I{\tt '} dimension of map
      }
      \sstsubsection{
         JDIM                              = INTEGER (Given)
      }{
         `J{\tt '} dimension of map
      }
      \sstsubsection{
         MAP\_DATA (IDIM, JDIM)             = REAL (Given)
      }{
         map data values
      }
      \sstsubsection{
         MAP\_VARIANCE (IDIM, JDIM)         = REAL (Given)
      }{
         map variance
      }
      \sstsubsection{
         MAP\_QUALITY (IDIM, JDIM)          = REAL (Given)
      }{
         map quality
      }
      \sstsubsection{
         X (IDIM)                          = REAL (Given)
      }{
         x axis of map
      }
      \sstsubsection{
         Y (JDIM)                          = REAL (Given)
      }{
         y axis of map
      }
      \sstsubsection{
         PEAK                              = REAL (Returned)
      }{
         peak height of Gaussian
      }
      \sstsubsection{
         PEAK\_VAR                          = REAL (Returned)
      }{
         variance on PEAK
      }
      \sstsubsection{
         PEAK\_QUAL                         = INTEGER (Returned)
      }{
         quality of PEAK
      }
      \sstsubsection{
         X\_CENTRE                          = REAL (Returned)
      }{
         x of image centre
      }
      \sstsubsection{
         Y\_CENTRE                          = REAL (Returned)
      }{
         y of image centre
      }
      \sstsubsection{
         X\_HWHM                            = REAL (Returned)
      }{
         half-width half-max of image in x-axis
      }
      \sstsubsection{
         Y\_HWHM                            = REAL (Returned)
      }{
         half-width half-max of image in y-axis
      }
      \sstsubsection{
         STATUS                            = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1994,1995,1996,1997 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_FIT\_2D\_PARABOLA
}{
   fit 2d parabola to data
}{
   \sstdescription{
      This routine performs a least-squares fit of a 2d parabola to a set
      of data. The form of the parabola is:-

\begin{equation}
      z = A0 + A1 * (x - X0)^2 + A1 * (y - Y0)^2
\end{equation}

      The apex of the parabola is at X0,Y0 and its value there is A0.

         If status is good on entry the routine will work through the data
      calculating the various sums required for the least-squares method.
      Data with bad quality or zero variance are ignored. If no `good{\tt '} data
      are found then an error will be reported and the routine will return
      with bad status.

         A matrix equation of the form $M * B = Z$ is constructed, where:-

\begin{equation}
M = \begin{pmatrix}
\sum \frac{1}{var}  & \sum \frac{x}{var}         & \sum \frac{y}{var}         &\sum \frac{x^2+y^2}{var}\\
\sum \frac{x}{var} & \sum \frac{x^2}{var}       & \sum \frac{xy}{var}        &\sum \frac{x^3+xy^2}{var}\\
\sum \frac{y}{var} & \sum \frac{xy}{var}        & \sum \frac{y^2}{var}       &\sum \frac{x^2y+y^3}{var}\\
\sum \frac{x^2+y^2}{var} & \sum \frac{x^3+xy^2}{var}& \sum \frac{x^2y+y^3}{var} &\sum \frac{(x^2+y^2)^2}{var}\\
\end{pmatrix}
\end{equation}

\begin{equation}
B = \begin{pmatrix}
A0 + A1 * X0^2 + A1 * Y0^2 \\
 -  2 * A1 * X0 \\
 -  2 * A1 * Y0 \\
    A1 \\
\end{pmatrix}
\end{equation}

\begin{equation}
Z = \begin{pmatrix}
 \sum \frac{z}{var} \\
 \sum \frac{xz}{var}\\
 \sum \frac{yz}{var}\\
 \sum \frac{(x^2 + y^2)z}{var}\\
\end{pmatrix}
\end{equation}

      where x, y, z and var are the x,y coords, value and variance of the
      measured points and the sums are over all
      valid points.

         SCULIB\_INVERT\_MATRIX is called to invert the matrix and
      SCULIB\_FIT\_MULT to multiply Z by the inverse. This yields the fitted
      value for B from which the other fit parameters are derived.
   }
   \sstinvocation{
       CALL SCULIB\_FIT\_2D\_PARABOLA (N, DATA, VARIANCE, QUALITY,
         X, Y, A0, A1, X0, Y0, Z\_PEAK, Z\_PEAK\_VAR, BADBIT, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         N                      = INTEGER (Given)
      }{
         number of data points
      }
      \sstsubsection{
         DATA (N)               = REAL (Given)
      }{
         the data
      }
      \sstsubsection{
         VARIANCE (N)           = REAL (Given)
      }{
         variance on the data
      }
      \sstsubsection{
         QUALITY (N)            = BYTE (Given)
      }{
         the quality on the data
      }
      \sstsubsection{
         X (N)                  = REAL (Given)
      }{
         the x offsets of the data
      }
      \sstsubsection{
         Y (N)                  = REAL (Given)
      }{
         the y offsets of the data
      }
      \sstsubsection{
         A0                     = REAL (Returned)
      }{
         fit result
      }
      \sstsubsection{
         A1                     = REAL (Returned)
      }{
         fit result
      }
      \sstsubsection{
         X0                     = REAL (Returned)
      }{
         x coord of parabola apex
      }
      \sstsubsection{
         Y0                     = REAL (Returned)
      }{
         y coord of parabola apex
      }
      \sstsubsection{
         Z\_PEAK                 = REAL (Returned)
      }{
         the value of the parabola apex
      }
      \sstsubsection{
         Z\_PEAK\_VAR             = REAL (Returned)
      }{
         the variance on Z\_PEAK
      }
      \sstsubsection{
         BADBIT                 = BYTE (Given)
      }{
         bad bit mask
      }
      \sstsubsection{
         STATUS                 = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstnotes{
      If the variances are not a true reflection of the errors
      on the data then very strange numbers can result.
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_FIT\_D2XISQ\_DAJ2
}{
   calculate second differential of chi-squared
   with respect to a fit parameter
}{
   \sstdescription{
      If status is good on entry this routine will calculate the 2nd order
      differential of chi-squared with respect to A(J). It does this
      numerically by calling the supplied routine XISQ\_ROUTINE to calculate
      chi-squared at the current parameter values, then again at A(J)$+$DELTA\_AJ
      and A(J)-DELTA\_AJ, then using the formula:-

\begin{equation}
\frac{\partial^2\chi^2}{\partial AJ^2} = \frac{\chi^2(AJ+\delta AJ) -
2\chi^2(AJ) + \chi^2(AJ - \delta AJ)}{\delta AJ^2}
\end{equation}

      DELTA\_AJ is equal to the absolute value of 0.001 $*$ A(J) or, if this is
      zero, 0.001.
   }
   \sstinvocation{
       CALL SCULIB\_FIT\_D2XISQ\_DAJ2 (XISQ\_ROUTINE, N, A, J,
         D2XISQ\_DAJ2, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         XISQ\_ROUTINE (XISQ, N, A, STATUS) = EXTERNAL ROUTINE (Given)
      }{
         name of routine that will calculate chi-squared
      }
      \sstsubsection{
         N                       = INTEGER (Given)
      }{
         the number of parameters in the fit
      }
      \sstsubsection{
         A(N)                    = DOUBLE PRECISION (Given and returned)
      }{
         the fit parameters
      }
      \sstsubsection{
         J                       = INTEGER (Given)
      }{
         the index of the parameter to be varied
      }
      \sstsubsection{
         D2XISQ\_DAJ2             = DOUBLE PRECISION (Returned)
      }{
         the second differential of chi-squared with respect to A(J)
      }
      \sstsubsection{
         STATUS                  = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_FIT\_D2XISQ\_DAJK
}{
   calculate differential of chi-squared with respect
   to fit parameters J and K
}{
   \sstdescription{
      If status is good on entry this routine will calculate the differential
      of chi-squared with respect to A(J) and A(K). It does this numerically
      by calling the supplied routine XISQ\_ROUTINE to calculate chi-squared at
      [A(J)$+$DELTA\_AJ,A(K)$+$DELTA\_AK], [A(J)-DELTA\_AJ,A(K)$+$DELTA\_AK],
      [A(J)$+$DELTA\_AJ,A(K)-DELTA\_AK] and [A(J)-DELTA\_AJ,A(K)-DELTA\_AK].
      The result is then calculated using the formula:-

\begin{equation}
\begin{split}
\frac{\partial^2\chi^2}{\partial AJ\partial AK}=& \chi^2 (AJ+\delta AJ,AK+\delta AK) \\
                    &- \chi^2 (AJ-\delta AJ,AK+\delta AK) \\
                    &- \frac{\chi^2 (AJ-\delta AJ,AK+\delta AK) + \chi^2
(AJ-\delta AJ,AK-\delta AK)}{4 \delta AJ \delta AK}\\
\end{split}
\end{equation}

      DELTA\_AJ is equal to the absolute value of 0.001 $*$ A(J) or, if this is
      zero, 0.001. DELTA\_AK is calculated in a similar way.
   }
   \sstinvocation{
       CALL SCULIB\_FIT\_D2XISQ\_DAJK (XISQ\_ROUTINE, N, A, J, K,
         D2XISQ\_DAJK, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         XISQ\_ROUTINE (XISQ, N, A, STATUS)  = EXTERNAL ROUTINE (Given)
      }{
         name of routine that will calculate xi-squared
      }
      \sstsubsection{
         N                       = INTEGER (Given)
      }{
         the number of parameters in the fit
      }
      \sstsubsection{
         A(N)                    = DOUBLE PRECISION (Given and returned)
      }{
         the fit parameters
      }
      \sstsubsection{
         J                       = INTEGER (Given)
      }{
         the index of the first parameter to be varied
      }
      \sstsubsection{
         K                       = INTEGER (Given)
      }{
         the index of the second parameter to be varied
      }
      \sstsubsection{
         D2XISQ\_DAJK             = DOUBLE PRECISION (Returned)
      }{
         the differential of chi-squared with respect to A(J) and A(K)
      }
      \sstsubsection{
         STATUS                  = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_FIT\_DXISQ\_DAJ
}{
   calculate gradient in chi-squared with `a{\tt '}
}{
   \sstdescription{
      If status is good on entry this routine will calculate the gradient in
      the chi-squared of the fit with variation in fit parameter J. It does
      this numerically by calling the supplied routine XISQ\_ROUTINE to
      calculate chi-squared for (A(J)$+$DELTA\_AJ) and (A(J)-DELTA\_AJ), then
      using the equation:-

\begin{equation}
\frac{\partial\chi^2}{\partial AJ} = \frac{\chi^2 (A(J)+\delta AJ) - \chi^2 (A(J)-\delta AJ)}{2.0 \delta AJ}
\end{equation}

      DELTA\_AJ is equal to the absolute value of 0.001 $*$ A(J) or, if this is
      zero, 0.001.
   }
   \sstinvocation{
       CALL SCULIB\_FIT\_DXISQ\_DAJ (XISQ\_ROUTINE, N, A, J, DXISQ\_DAJ,
         STATUS)
   }
   \sstarguments{
      \sstsubsection{
         XISQ\_ROUTINE (XISQ, N, A, STATUS) = EXTERNAL ROUTINE (Given)
      }{
         name of routine that will calculate xi-squared
      }
      \sstsubsection{
         N                       = INTEGER (Given)
      }{
         the number of parameters in the fit
      }
      \sstsubsection{
         A (N)                   = DOUBLE PRECISION (Given and returned)
      }{
         the fit parameters
      }
      \sstsubsection{
         J                       = INTEGER (Given)
      }{
         the index of the parameter to be varied
      }
      \sstsubsection{
         DXISQ\_DAJ               = DOUBLE PRECISION (Returned)
      }{
         the gradient of chi-squared with A(J)
      }
      \sstsubsection{
         STATUS                  = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_FIT\_FUNCTION
}{
   routine to fit a general function to data
}{
   \sstdescription{
      This routine fits a general function to a data-set by searching the
      chi-squared plane. Chi-squared at each test fit position will be
      evaluated by the external routine XISQ\_ROUTINE. The data to be fit
      are passed to the external routine through common; see
      SCULIB\_GAUSSIAN\_XISQ for an example. Each call to the routine will
      generate one iteration of the search. On exit the fit should have an
      improved chi-squared that should be checked for convergence (i.e. has
      chi-squared changed by less than CHICUT between 2 iterations) before
      the routine is called again to perform the next iteration. It is
      recommended that the routine be entered for the first iteration with
      LAMBDA set to 0.001. Thereafter, the routine will return the value
      of LAMBDA to be used in the next iteration.

        The search method used is that due to Marquardt as described in
      chapter 8 of `Data Reduction and Error Analysis{\tt '} by Bevington and
      Robinson. The code is an adaptation of the Pascal routine Marquardt
      listed in that book.

        If the routine is entered with LAMBDA = 0 then it will return the
      `error{\tt '} matrix for the given fit parameters.
   }
   \sstinvocation{
       CALL SCULIB\_FIT\_FUNCTION (XISQ\_ROUTINE, CHICUT, N, A,
         LAMBDA, ALPHA, BETA, IK, JK, DA, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         XISQ\_ROUTINE (XISQ, N, A, STATUS) = EXTERNAL ROUTINE (Given)
      }{
         routine to calculate chi-squared of fit
      }
      \sstsubsection{
         CHICUT                  = DOUBLE PRECISION (Given)
      }{
         increase in chi-squared that will make routine search with
         larger LAMBDA
      }
      \sstsubsection{
         N                       = INTEGER (Given)
      }{
         number of fitted parameters
      }
      \sstsubsection{
         A (N)                   = DOUBLE PRECISION (Given and returned)
      }{
         the fitted parameters
      }
      \sstsubsection{
         LAMBDA                  = DOUBLE PRECISION (Given and returned)
      }{
         curvature factor for alpha matrix
      }
      \sstsubsection{
         ALPHA (N,N)             = DOUBLE PRECISION (Scratch)
      }{
         storage for alpha array
      }
      \sstsubsection{
         BETA (N)                = DOUBLE PRECISION (Scratch)
      }{
         storage for beta array
      }
      \sstsubsection{
         IK (N)                  = INTEGER (Scratch)
      }{
         used for inverting matrix
      }
      \sstsubsection{
         JK (N)                  = INTEGER (Scratch)
      }{
         used for inverting matrix
      }
      \sstsubsection{
         DA (N)                  = DOUBLE PRECISION (Scratch)
      }{
         increment in A
      }
      \sstsubsection{
         STATUS                  = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
   \sstdiytopic{
      Method
   }{
      If status is good on entry the routine will enter a loop

      \sstitemlist{

         \sstitem
           SCULIB\_FIT\_MAKEBETA is called to calculate the `beta{\tt '} matrix

         \sstitem
           SCULIB\_FIT\_MAKEALPHA is called to calculate the `alpha{\tt '} matrix

         \sstitem
           The diagonal elements of the `alpha{\tt '} matrix are multiplied by
              1 $+$ LAMBDA following the method due to Marquardt

         \sstitem
           SCULIB\_INVERT\_MATRIX is called to invert the modified `alpha{\tt '}
              matrix

         \sstitem
           If LAMBDA = 0 this is all that{\tt '}s required because this input
              is given if the routine is required to calculate the `error{\tt '}
              matrix

         \sstitem
           Otherwise, SCULIB\_FIT\_MULT is called to multiply the inverted
              `alpha{\tt '} matrix by the `beta{\tt '} to give the next iteration of the
              fit for this LAMBDA

         \sstitem
           Chi-squared is calculated for the new fit and compared with
              that for the previous fit. If the chi-squared is greater than
              the previous value plus CHICUT then things have got worse.
              In this case the routine will increase LAMBDA by a factor of
              10, return the fit to the previous value and return to the
              start of the loop. If LAMBDA exceeds 1000 status is set bad,
              an error is reported and the loop is exited

         \sstitem
           However, if the chi-squared is an improvement then LAMBDA is
              decreased by a factor of 10 and the loop is exited

      }
      End of loop
   }
}
\sstroutine{
   SCULIB\_FIT\_MAKEALPHA
}{
   calculates alpha matrix for SCULIB\_FIT\_FUNCTION
}{
   \sstdescription{
      This routine calculates the elements of the alpha matrix for non-linear
      fitting as described in `Data Reduction and Error Analysis for the
      Physical Sciences{\tt '} by Bevington and Robinson, section 8.6 `the Marquardt
      Method{\tt '}.

         The routine does this by calling routines SCULIB\_FIT\_D2XISQ\_DAJ2
      and SCULIB\_FIT\_D2XISQ\_DAJK for each element required. The routine will
      only execute if entered with good status.
   }
   \sstinvocation{
      CALL SCULIB\_FIT\_MAKEALPHA (XISQ\_ROUTINE, N, A, ALPHA, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         XISQ\_ROUTINE (XISQ, N, A, STATUS) = EXTERNAL ROUTINE (Given)
      }{
         routine to calculate chi-squared of current fit
      }
      \sstsubsection{
         N                         = INTEGER (Given)
      }{
         the number of fit parameters
      }
      \sstsubsection{
         A (N)                     = DOUBLE PRECISION (Given)
      }{
         the values of the fit parameters
      }
      \sstsubsection{
         ALPHA (N,N)               = DOUBLE PRECISION (Returned)
      }{
         the alpha matrix
      }
      \sstsubsection{
         STATUS                    = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_FIT\_MAKEBETA
}{
   calculates beta matrix for SCULIB\_FIT\_FUNCTION
}{
   \sstdescription{
      This routine calculates the elements of the beta matrix for non-linear
      fitting as described in `Data Reduction and Error Analysis for the
      Physical Sciences{\tt '} by Bevington and Robinson, section 8.6 `the Marquardt
      Method{\tt '}.

         The routine does this by calling the routine SCULIB\_FIT\_DXISQ\_DAJ
      for each element required. The routine will only execute if entered
      with good status.
   }
   \sstinvocation{
      CALL SCULIB\_FIT\_MAKEBETA (XISQ\_ROUTINE, N, A, BETA, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         XISQ\_ROUTINE (XISQ, N, A, STATUS) = EXTERNAL ROUTINE (Given)
      }{
         routine to calculate chi-squared of current fit
      }
      \sstsubsection{
         N                         = INTEGER (Given)
      }{
         the number of fit parameters
      }
      \sstsubsection{
         A (N)                     = DOUBLE PRECISION (Given)
      }{
         the values of the fit parameters
      }
      \sstsubsection{
         BETA (N)                  = DOUBLE PRECISION (Returned)
      }{
         the beta vector
      }
      \sstsubsection{
         STATUS                    = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_FIT\_MULT
}{
   matrix vector multiplication routine
}{
   \sstdescription{
      If status is good on entry, this routine will multiply the N-vector
      BETA by the NxN matrix ALPHA to give the N-vector GAMMA. GAMMA should
      not be the same as BETA as this would mean BETA being overwritten
      during the multiplication process giving an incorrect answer.
   }
   \sstinvocation{
      CALL SCULIB\_FIT\_MULT (N, ALPHA, BETA, GAMMA, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         N                      = INTEGER (Given)
      }{
         dimensions of square matrix
      }
      \sstsubsection{
         ALPHA (N,N)            = DOUBLE PRECISION (Given)
      }{
         the multiplying matrix
      }
      \sstsubsection{
         BETA (N)               = DOUBLE PRECISION (Given)
      }{
         the multiplied vector
      }
      \sstsubsection{
         GAMMA (N)              = DOUBLE PRECISION (Returned)
      }{
         the result vector (GAMMA and BETA should not be the same array)
      }
      \sstsubsection{
         STATUS                 = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_FIT\_PLANE
}{
   fits a plane to some x, y, z data
}{
   \sstdescription{
      This routine does a least squares fit of data to a plane. The plane
      is described by an equation of form:-

\begin{equation}
           z = M_X * x  +  M_Y * y  +  C
\end{equation}
   }
   \sstinvocation{
      CALL SCULIB\_FIT\_PLANE (N, X, Y, Z, QUALITY, MX, MY, C, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         N                      = INTEGER (Given)
      }{
         the number of data points
      }
      \sstsubsection{
         X (N)                  = REAL (Given)
      }{
         the x coords of the measured points
      }
      \sstsubsection{
         Y (N)                  = REAL (Given)
      }{
         the y coords of the measured points
      }
      \sstsubsection{
         Z (N)                  = REAL (Given)
      }{
         the measured values
      }
      \sstsubsection{
         QUALITY (N)            = INTEGER (Given)
      }{
         the quality on the data
      }
      \sstsubsection{
         MX                     = REAL (Returned)
      }{
         the slope of the fitted plane in the x-axis
      }
      \sstsubsection{
         MY                     = REAL (Returned)
      }{
         the slope of the fitted plane in the y-axis
      }
      \sstsubsection{
         C                      = REAL (Returned)
      }{
         the constant of the fitted plane
      }
      \sstsubsection{
         STATUS                 = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Method
   }{
      If status is good on entry the routine will loop through the
      input data calculating the sums required and the number of valid
      data points (i.e. those with good quality flags).

      If there are less than 3 valid data then
         an error message will be output and bad status returned
      else
         the plane coefficients will be calculated from the following
         formulae:-

\begin{equation}
M_X = \frac{\sum y^2(n_v\sum xz - \sum x \sum z) -
                (\sum y)^2 \sum xz  - n_v\sum xy \sum yz +
                \sum y(\sum xy \sum z  + \sum x \sum yz)
}{2\sum xy\sum x\sum y - n_v(\sum xy)^2 - (\sum x)^2\sum y^2
+ \sum x^2(n_v\sum y^2 + (\sum y)^2)}
\end{equation}

\begin{equation}
M_Y = \frac{n_v\sum yz - \sum y \sum z + M_X(\sum x \sum y - n_v\sum xy)}{
                          n_v\sum y^2 - \left(\sum y\right)^2}
\end{equation}


\begin{equation}
C = \frac{\sum z - M_X\sum x - M_Y\sum y}{n_v}
\end{equation}

         where $n_v$ is the number of valid data points. If the denominator of
         the expression for MX is 0 then an error message will be output and
         bad status returned.

      end if
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_FIT\_SKYDIP
}{
   Fit the skydip data
}{
   \sstdescription{
      This routine fits a sub-instrument{\tt '}s measurements of the sky
      brightness at a range of airmasses to obtain the sky opacity, ETAtel
      and `b{\tt '} parameters. The fit is to the function:-

\begin{equation}
J_\mathrm{meas} = (1 - \eta_\mathrm{tel}) J_\mathrm{tel} +
                   \eta_\mathrm{tel} J_\mathrm{atm} -
                   b  \eta_\mathrm{tel} J_\mathrm{atm} e^{-A\tau},
\end{equation}

      Jtel is known and Jatm is related to Jamb by:-

 \begin{equation}
J_\mathrm{atm} = J_\mathrm{amb} \int_0^{40}\! A \left[k\exp\left(-\frac{h}{h_2}
\right)\exp\left[A k h_2 \left(\exp\left(-\frac{h}{h_2}\right)-1\right)\right]
\left(1-\frac{h}{h_1}\right)\right]\mathrm{d}h,
\end{equation}

      where h2 = scale height of absorption ( = 2km),
            h1 = coefficient to give 6.5K/km temperature drop in absorber,
             A = airmass,
             k = extinction.

      which relation has been fudged by Bill Duncan to:-

\begin{equation}
J_\mathrm{atm} = J_\mathrm{amb} X_\mathrm{g} \left[1-\exp\left(-A k h_2\right)\right],
\end{equation}
with $X_\mathrm{g}$ having the form
\begin{equation}
X_\mathrm{g} = 1 + \frac{h_2 T_\mathrm{lapse}}{T_\mathrm{amb}}\exp\left(-\frac{A \tau}{X_\mathrm{gconst}}\right)
\end{equation}

      with

            h1 = 2,
            h2 = -6.5 (note this h2 is defined differently to that in the
                       previous equation),
       $X_\mathrm{gconst}$ = 3.669383

      See `Calibration of mm and sub-mm Photometers by Skydipping{\tt '}, W.D.Duncan
      preprint and `Inversion of Sky Dips{\tt '}, SCU/WDD/31.1/1093 for further
      details.

         The fit can be made with ETAtel and/or b either fixed or
      varying. To allow one of these parameters to vary it should be
      input to the routine with a value below zero. If the input
      value is greater than zero then the routine will fix it at
      that for the fit.
   }
   \sstinvocation{
       CALL SCULIB\_FIT\_SKYDIP (CVAR, N\_MEASUREMENTS, AIRMASS, J\_MEASURED,
         J\_VARIANCE, SUB\_WAVELENGTH, SUB\_INSTRUMENT, SUB\_FILTER, T\_TEL,
         T\_AMB, ETA\_TEL\_IN, B\_IN, ETA\_TEL\_FIT, B\_FIT, TAUZ\_FIT,
         REXISQ, TAU\_ERROR, ETA\_ERROR, B\_ERROR, RESIDUAL, SIGMA, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         CVAR                      = LOGICAL (Given)
      }{
         flag to govern whether to use a fixed variance (true)
         or the actual variance. The fixed variance is the mean
         of the actual variances.
      }
      \sstsubsection{
         N\_MEASUREMENTS            = INTEGER (Given)
      }{
         the number of SKYDIP measurements
      }
      \sstsubsection{
         AIRMASS (N\_MEASUREMENTS)  = REAL (Given)
      }{
         the airmasses at which the measurements were made
      }
      \sstsubsection{
         DATA (N\_MEASUREMENTS)     = REAL (Given)
      }{
         the measured sky brightness temperatures
      }
      \sstsubsection{
         VARIANCE (N\_MEASUREMENTS) = REAL (Given)
      }{
         the variance on DATA
      }
      \sstsubsection{
         SUB\_WAVELENGTH            = REAL (Given)
      }{
         the wavelength of the measurements
      }
      \sstsubsection{
         SUB\_INSTRUMENT            = CHARACTER$*$($*$) (Given)
      }{
         the name of the sub-instrument used
      }
      \sstsubsection{
         SUB\_FILTER                = CHARACTER$*$($*$) (Given)
      }{
         the name of the filter used
      }
      \sstsubsection{
         T\_TEL                     = REAL (Given)
      }{
         the telescope temperature (K)
      }
      \sstsubsection{
         T\_AMB                     = REAL (Given)
      }{
         the ambient temperature (K)
      }
      \sstsubsection{
         ETA\_TEL\_IN                = REAL (Given)
      }{
         if $>$= 0 then this will the ETAtel assumed in the fit.
         if $<$ 0 then ETAtel will be allowed to vary in the fit.
      }
      \sstsubsection{
         B\_IN                      = REAL (Given)
      }{
         if $>$=0 then this value of b will be assumed in the fit.
         if $<$ 0 then b will be allowed to vary in the fit.
      }
      \sstsubsection{
         ETA\_TEL\_FIT               = REAL (Returned)
      }{
         the result for ETAtel
      }
      \sstsubsection{
         B\_FIT                     = REAL (Returned)
      }{
         the result for b
      }
      \sstsubsection{
         TAUZ\_FIT                  = REAL (Returned)
      }{
         the fitted result for tauz
      }
      \sstsubsection{
         REXISQ                    = REAL (Returned)
      }{
         the reduced chi square of the fit
      }
      \sstsubsection{
         TAU\_ERROR                 = REAL (Returned)
      }{
         error in the tau
      }
      \sstsubsection{
         ETA\_ERROR                 = REAL (Returned)
      }{
         error in eta\_tel
      }
      \sstsubsection{
         B\_ERROR                   = REAL (Returned)
      }{
         error in B
      }
      \sstsubsection{
         RESIDUAL                     = DOUBLE (Returned)
      }{
        Absolute difference between the model and the fit.
      }
      \sstsubsection{
         SIGMA                     = DOUBLE (Returned)
      }{
         standard deviation of the difference between the
         model and the fit.
      }
      \sstsubsection{
         STATUS                    = INTEGER (Given and returned)
      }{
         Global status
      }
   }
}
\sstroutine{
   SCULIB\_FIX\_SCAN\_V10
}{
   Correct scan positions for version 1.0 data from SCUCD
}{
   \sstdescription{
      For data taken with version 1.0 of SCUCD the positions of
      the scan ends were incorrect. This was because of a bug
      in the software that calculated the scan ends concerning
      the use of arcseconds instead of radians.
      This routine attempts to recreate the bug so that the
      correct scan offsets can be calculated.
   }
   \sstinvocation{
       CALL SCULIB\_FIX\_SCAN\_V10(CENTRE\_COORDS, LAT\_OBS, LONG, LAT,
            MJD, RA\_OFF\_START, DEC\_OFF\_START, RA\_OFF\_END,
            DEC\_OFF\_END, RA\_NEW\_START, DEC\_NEW\_START,
            RA\_NEW\_END, DEC\_NEW\_END, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         CENTRE\_COORDS = CHAR (Given)
      }{
         The coordinate system of the map centre
      }
      \sstsubsection{
         LAT\_OBS                = DOUBLE PRECISION (Given)
      }{
         Latitude of observatory (radians)
      }
      \sstsubsection{
         LONG = DOUBLE (Given)
      }{
         The longitude (ra) of the map centre (radians)
      }
      \sstsubsection{
         LAT = DOUBLE (Given)
      }{
         The latitude (dec) of the map centre (radians)
      }
      \sstsubsection{
         MJD = DOUBLE (Given)
      }{
         The modified Julian date at which the data was taken
      }
      \sstsubsection{
         RA\_OFF\_START = DOUBLE (Given)
      }{
         The RA start position of the scan as stored in the header (RD)
      }
      \sstsubsection{
         DEC\_OFF\_START = DOUBLE (Given)
      }{
         The Dec start position of the scan as stored in the header (RD)
      }
      \sstsubsection{
         RA\_OFF\_END = DOUBLE (Given)
      }{
         The RA end position of the scan as stored in the header (RD)
      }
      \sstsubsection{
         DEC\_OFF\_END = DOUBLE (Given)
      }{
         The DEC end position of the scan as stored in the header (RD)
      }
      \sstsubsection{
         RA\_NEW\_START = DOUBLE (Returned)
      }{
         The corrected RA start position of the scan  (RD)
      }
      \sstsubsection{
         DEC\_NEW\_START = DOUBLE (Returned)
      }{
         The corrected Dec start position of the scan  (RD)
      }
      \sstsubsection{
         RA\_NEW\_END = DOUBLE (Returned)
      }{
         The corrected RA end position of the scan  (RD)
      }
      \sstsubsection{
         RA\_NEW\_END = DOUBLE (Returned)
      }{
         The corrected Dec end position of the scan  (RD)
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
      }
   }
   \sstnotes{
      The scan ends are all stored as apparent RA/Decs.
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_FLATFIELD\_DATA
}{
   flatfield the data in an array
}{
   \sstdescription{
      This routine multiplies the data in the input array by the flatfield
      values of the bolometers that took it. Output quality will be set
      bad if input quality was bad or the quality of the flatfield for that
      bolometer was bad.
   }
   \sstinvocation{
       CALL SCULIB\_FLATFIELD\_DATA (N\_BOL, N\_POS, N\_BEAM, BDATA, VARIANCE,
         QUALITY, BOL\_CHAN, BOL\_ADC, NUM\_CHAN, NUM\_ADC, BOL\_FLAT,
         BOL\_QUALITY, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         N\_BOL                  = INTEGER (Given)
      }{
         number of bolometers measured
      }
      \sstsubsection{
         N\_POS                  = INTEGER (Given)
      }{
         number of positions at which the bolometers were measured
      }
      \sstsubsection{
         N\_BEAM                 = INTEGER (Given)
      }{
         number of beams data have been reduced into
      }
      \sstsubsection{
         BDATA (N\_BOL, N\_POS, N\_BEAM)
      }{
                          = REAL (Given and returned)
         measured data
      }
      \sstsubsection{
         VARIANCE (N\_BOL, N\_POS, N\_BEAM)
      }{
                          = REAL (Given and returned)
         variance on BDATA
      }
      \sstsubsection{
         QUALITY (N\_BOL, N\_POS, N\_BEAM)
      }{
                          = BYTE (Given and returned)
         quality on BDATA
      }
      \sstsubsection{
         BOL\_CHAN (N\_BOL)       = INTEGER (Given)
      }{
         the channel numbers of the measured bolometers
      }
      \sstsubsection{
         BOL\_ADC (N\_BOL)        = INTEGER (Given)
      }{
         the A/D numbers of the measured bolometers
      }
      \sstsubsection{
         NUM\_CHAN               = INTEGER (Given)
      }{
         number of channels per A/D
      }
      \sstsubsection{
         NUM\_ADC                = INTEGER (Given)
      }{
         number of A/D cards
      }
      \sstsubsection{
         BOL\_FLAT (NUM\_CHAN, NUM\_ADC)
      }{
                          = REAL (Given)
         the flatfield values
      }
      \sstsubsection{
         BOL\_QUALITY (NUM\_CHAN, NUM\_ADC)
      }{
                          = INTEGER (Given)
         quality on BOL\_FLAT
      }
      \sstsubsection{
         STATUS                 = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_FLATFIELD\_SEQUENCE
}{
   get bolometer measurement sequence for FLATFIELD
}{
   \sstdescription{
      This routine works out the bolometer measurement sequence for a FLATFIELD
      observation. Only one of SCUBA{\tt '}s sub-instruments can be flat-fielded at
      a time. If the sub-instrument is one of the arrays then the measurement
      sequence will be ref-bol-ref-bol-......-bol-ref, where the `bol{\tt '}s are the
      bolometers to be measured and `ref{\tt '} the reference bolometer on the array.
      If the sub-instrument is one of the photometry pixels then only that
      bolometer will be measured.

         Whatever bolometer is the target of the measurement, data will be
      taken from all A/D channels.

         If status is good on entry SCULIB\_BOLSELECT is called to decode
      the bolometers to be measured and the sub-instruments involved. If
      the bolometers belong to more than one sub-instrument an error will
      be reported and bad status returned.

         If the sub-instrument is one of the arrays then the name of the
      reference bolometer will be read from parameters LONGREF\_BOL or
      SHORTREF\_BOL as appropriate. The number of measurements and their
      sequence is set as described above in N\_MEASUREMENTS, FLAT\_CHAN and
      FLAT\_ADC. If the sub-instrument is not one of the arrays then the
      reference bolometer will not be used and the bolometers(s) will be
      measured in sequence.

         For each measurement of a target bolometer data will be taken from
      all data channels; BOLS\_MEASURED is set to `ALL{\tt '} and SCULIB\_BOLSELECT
      called to decode this to channel and ADC numbers. A check is made
      that the reference bolometer, if used, is among those being measured.
      If not, an error message will be output and bad status returned.

         Lastly, the FLAT\_INDEX array is set so that it points to the
      position in the datablock of data from the target bolometer at each
      measurement.
   }
   \sstinvocation{
       CALL SCULIB\_FLATFIELD\_SEQUENCE (BOLOMETERS, NUM\_CHAN,
         NUM\_ADC, NUM\_SUB, BOL\_TYPE, BOL\_CALB, BOL\_DU3, BOL\_DU4,
         BOL\_QUAL, BOL\_ENABLED, BOLS\_MEASURED, N\_BOLS, BOL\_SELECT\_CHAN,
         BOL\_SELECT\_ADC, N\_SUBS, SUB\_INSTRUMENT, FLATREF\_CHAN,
         FLATREF\_ADC, N\_MEASUREMENTS, FLAT\_CHAN, FLAT\_ADC, FLAT\_INDEX,
         STATUS)
   }
   \sstarguments{
      \sstsubsection{
         BOLOMETERS                  = CHARACTER$*$($*$)
      }{
         the bolometers to be measured in this FLATFIELD
      }
      \sstsubsection{
         NUM\_CHAN                    = INTEGER (Given)
      }{
         the number of channels per A/D
      }
      \sstsubsection{
         NUM\_ADC                     = INTEGER (Given)
      }{
         the number of A/Ds
      }
      \sstsubsection{
         NUM\_SUB                     = INTEGER (Given)
      }{
         the number of sub-instruments in SCUBA
      }
      \sstsubsection{
         BOL\_TYPE (NUM\_CHAN,NUM\_ADC) = CHARACTER$*$($*$) (Given)
      }{
         the type of each bolometer
      }
      \sstsubsection{
         BOL\_CALB (NUM\_CHAN,NUM\_ADC) = REAL (Given)
      }{
         the flat-field factor for each bolometer
      }
      \sstsubsection{
         BOL\_DU3 (NUM\_CHAN,NUM\_ADC)  = REAL (Given)
      }{
         the dU3 coord of each bolometer
      }
      \sstsubsection{
         BOL\_DU4 (NUM\_CHAN,NUM\_ADC)  = REAL (Given)
      }{
         the dU4 coord of each bolometer
      }
      \sstsubsection{
         BOL\_QUAL (NUM\_CHAN,NUM\_ADC) = INTEGER (Given)
      }{
         the quality of each bolometer
      }
      \sstsubsection{
         BOL\_ENABLED (NUM\_CHAN,NUM\_ADC) = LOGICAL (Returned)
      }{
         .TRUE. if a bolometer is to be measured
      }
      \sstsubsection{
         BOLS\_MEASURED               = CHARACTER$*$($*$) (Returned)
      }{
         the bolometers to be measured for each FLATFIELD measurement
      }
      \sstsubsection{
         N\_BOLS                      = INTEGER (Returned)
      }{
         the number of bolometers to be measured at each measurement
      }
      \sstsubsection{
         BOL\_SELECT\_CHAN (NUM\_CHAN $*$ NUM\_ADC) = INTEGER (Returned)
      }{
         the channel numbers of the bolometers to be measured at each
         measurement
      }
      \sstsubsection{
         BOL\_SELECT\_ADC (NUM\_CHAN $*$ NUM\_ADC) = INTEGER (Returned)
      }{
         the A/D numbers of the bolometers to be measured at each measurement
      }
      \sstsubsection{
         N\_SUBS                      = INTEGER (Returned)
      }{
         the number of sub-instruments being used
      }
      \sstsubsection{
         SUB\_INSTRUMENT (NUM\_SUB)    = CHARACTER$*$($*$) (Returned)
      }{
         name of sub-instrument being used
      }
      \sstsubsection{
         FLATREF\_CHAN                = INTEGER (Returned)
      }{
         channel number of reference bolometer
      }
      \sstsubsection{
         FLATREF\_ADC                 = INTEGER (Returned)
      }{
         A/D number of reference bolometer
      }
      \sstsubsection{
         N\_MEASUREMENTS              = INTEGER (Returned)
      }{
         the number of measurements in this FLATFIELD observation
      }
      \sstsubsection{
         FLAT\_CHAN (2 $*$ NUM\_CHAN $*$ NUM\_ADC) = INTEGER (Returned)
      }{
         the channel number of the target bolometer in each measurement
      }
      \sstsubsection{
         FLAT\_ADC (2 $*$ NUM\_CHAN $*$ NUM\_ADC) = INTEGER (Returned)
      }{
         the A/D number of the target bolometer in each measurement
      }
      \sstsubsection{
         FLAT\_INDEX (2 $*$ NUM\_CHAN $*$ NUM\_ADC) = INTEGER (Returned)
      }{
         the index in the datablock of the target bolometer in each
         measurement
      }
      \sstsubsection{
         STATUS                      = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_FREE
}{
   release virtual memory
}{
   \sstdescription{
      This routine frees virtual memory obtained by SCULIB\_MALLOC.

      If status is bad on entry the routine will return immediately.

      If START\_PTR is not equal to 0 then:

      \sstitemlist{

         \sstitem
          The sentinel integers above and below the used piece of memory
            will be checked against the values they were set to by
            SCULIB\_MALLOC.

         \sstitem
          PSX\_FREE will be called to free the virtual memory. If
            that{\tt '}s successful START\_PTR and END\_PTR will be set to
            the bad value.

         \sstitem
          If either of the sentinel integers was corrupted then an
            error will be reported and bad status returned.
      }
   }
   \sstinvocation{
      CALL SCULIB\_FREE (NAME, START\_PTR, END\_PTR, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         NAME                = CHARACTER$*$($*$) (Given)
      }{
         name associated with VM
      }
      \sstsubsection{
         START\_PTR           = INTEGER (Given and returned)
      }{
         pointer to beginning of virtual memory
      }
      \sstsubsection{
         END\_PTR             = INTEGER (Given and returned)
      }{
         pointer to end of virtual memory
      }
      \sstsubsection{
         STATUS              = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_GAUSS\_WTINIT
}{
   Generate a weighting function for rebinning
}{
   \sstdescription{
      A Gaussian weighting function
      The look up table is initialised such that one can access the
      weight directly given the square of the distance between the input
      and output pixel.
      The scale length is taken to be radius at half-width-half-max
      The gaussian should go out to a radius of at least 3 scale
      lengths ($<$0.2\% of peak). Governed by the RADIUS argument
      The function is simply taken as
        F(x) = exp(-X$*$$*$2)
      where the scale size (FWHM) is at X = SQRT(loge(2))
   }
   \sstinvocation{
      CALL SCULIB\_GAUSS\_WTINIT (WTFN, RADIUS, RES, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         WTFN ( RADIUS $*$ RADIUS $*$ RES $*$ RES $+$ 1) = REAL (Returned)
      }{
         The weighting function generated by this routine.
         The index corresponds to the square of the distance from the
         centre in scale units.
      }
      \sstsubsection{
         RADIUS = INTEGER (Given)
      }{
         Size of the weighting function in scale units.
      }
      \sstsubsection{
         RES = INTEGER (Given)
      }{
         Number of points per scale lenghth.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_GAUSSIAN\_XISQ
}{
   calculate chi-squared of Gaussian fit
}{
   \sstdescription{
      If entered with good status this routine calculates the chi-squared
      between a dataset and a Gaussian function. Data points with bad quality
      will be ignored, as will points with zero variance. A warning will be
      issued if any data points with zero variance are encountered. If no
      valid data points are found then an error will be reported and bad
      status returned. The data are passed in via common.
   }
   \sstinvocation{
      CALL SCULIB\_GAUSSIAN\_XISQ (XISQ, N, FIT, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         XISQ                   = DOUBLE PRECISION (Returned)
      }{
         the chi-squared of the current fit
      }
      \sstsubsection{
         N                      = INTEGER (Given)
      }{
         the number of parameters being fit, should be 6
      }
      \sstsubsection{
         FIT(N)                 = DOUBLE PRECISION (Given)
      }{
         the fit parameters:-
         \sstitemlist{

            \sstitem
               FIT(1) = peak height

            \sstitem
               FIT(2) = length of the `a{\tt '} axis of the sigma ellipse

            \sstitem
               FIT(3) = length of the `b{\tt '} axis of the sigma ellipse

            \sstitem
               FIT(4) = the angle between the `a{\tt '} axis and
                          the x axis ($+$ve anticlockwise, radians)

            \sstitem
               FIT(5) = the x coord of the centre

            \sstitem
               FIT(6) = the y coord of the centre
         }
      }
      \sstsubsection{
         STATUS                 = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_GAUSSJ
}{
   Numerical Recipes in Fortran routine for solution of
   linear equations by Gauss-Jordan elimination
}{
   \sstdescription{
      Linear equation solution by Gauss-Jordan elimination. A(1:N,1:N) is an
      input matrix stored in an array of physical dimensions NP by NP.
      B(1:N,1:M) is an input matrix containing the M right-hand side vectors,
      stored in an array of physical dimensions NP by MP. On output,
      A(1:N,1:N) is replaced by its matrix inverse and B(1:N,1:M) is replaced
      by the corresponding set of solution vectors. Parameter NMAX is the
      largest anticipated value of N.
      Copied from GAUSSJ on p.30 of Numerical Recipes in Fortran, with
      STATUS added.
   }
   \sstinvocation{
      CALL SCULIB\_GAUSSJ (A, N, NP, B, M, MP, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         A ( NP, NP ) = REAL (Given \& Returned)
      }{
         Input matrix. On exit, contains its inverse.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Required size of A ($<$ NP)
      }
      \sstsubsection{
         NP = INTEGER (Given)
      }{
         Dimensions of input matrix.
      }
      \sstsubsection{
         B ( NP, MP) = REAL (Given \& Returned)
      }{
         Input matrix containing M right-hand side vectors. On exit, contains
         the solution vectors.
      }
      \sstsubsection{
         M = INTEGER (Given)
      }{
         Required size of B. ($<$ MP)
      }
      \sstsubsection{
         MP = INTEGER (Given)
      }{
         Size of second dimension of B.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_GENSYCONFN
}{
   Generate a convolution function which will set to zero the
   spatial frequencies with no signal in Dual Beam maps
}{
   \sstdescription{
      This routine will return the symmetric convolution function
      required for setting to zero the spatial frequencies that have zero
      sensitivity in the raw chop-scan data. This function is not described
      in Emerson et al., 1979. A\&A 96, 92, which (I think) describes an
      early version of the NOD2 algorithm before all the wrinkles had been
      properly understood.

      This convolution function has to set to zero those points in the FT of
      the raw data at zero frequency and harmonics of 1/chop spacing. In
      the Fourier domain this means multiplying by a function which is 1
      at all points apart from those specified, where it is zero. This is
      the sum of 2 functions, the first being 1 everywhere, the second
      being -1 at the points to be zeroed. The convolution function required
      is the sum of the inverse FTs of these two functions. The inverse
      FT of the first function is simply a delta function at the origin,
      that of the second is a series of negative spikes with the first at the
      origin and the others separated by the chop spacing.

      The convolution function must cover the map even when the centre of
      the function is at the left or right hand end of the map. Hence the
      convolution function must be twice the length of the raw map.

      Since the raw data is not sampled such that the chop spacing is an
      integer number of samples, the actual convolution function must be
      rebinned onto the sample mesh by sinc interpolation.

      Otherwise the only tricky part of the algorithm is the need to normalise
      the two component functions such that in the Fourier domain the
      addition of the 2 functions does result in zeroes at the desired points.
      This is most easily achieved by concentrating on the zero spatial
      frequency which is just the sum of all the points in each of the 2
      functions. The first function is a delta function set to 1, so the
      sum of that function is 1. The sum of the second function is that of
      all the points in the convolution function from its centre to one end,
      a length that corresponds to the map size. This is the length to be
      used because, in the Fourier domain, the width of the sample to be
      set to zero is 1/map\_size.
   }
   \sstinvocation{
      CALL SCULIB\_GENSYCONFN( BSEP, PIXSEP, NPIX, NCFN, CONF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BSEP = REAL (Given)
      }{
         The beam separation in arcseconds
      }
      \sstsubsection{
         PIXSEP = REAL (Given)
      }{
         The pixel separation in arcseconds
      }
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         The number of pixels in the x direction
      }
      \sstsubsection{
         UNBAL = REAL (Given)
      }{
         The relative amplitudes of the right and left hand beams
         UNBAL=amp(lhb)/abs(amp(rhb))
      }
      \sstsubsection{
         NCFN = INTEGER (Returned)
      }{
         The length of the convolution array
      }
      \sstsubsection{
         CONF( $*$ ) = REAL (Returned)
      }{
         The convolution function
      }
      \sstsubsection{
         STATUS = INTEGER (Given and returned)
      }{
         Global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_GET\_BOL\_DESC
}{
   Get the bolometer description arrays and check their dimensions
}{
   \sstdescription{
      This routine obtains the bolometer description arrays. ie:
      BOL\_TYPE, BOL\_ADC, BOL\_CHAN, BOL\_DU3 and BOL\_DU4 arrays.
      The dimensions of these arrays are checked and an error returned
      if necessary.
   }
   \sstinvocation{
       CALL SCULIB\_GET\_BOL\_DESC(LOC, NUM\_CHAN, NUM\_ADC, BOL\_TYPE,
            BOL\_DU3, BOL\_DU4, BOL\_ADC, BOL\_CHAN, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         LOC = \_CHARACTER (Given)
      }{
         Locator to the SCUBA extension
      }
      \sstsubsection{
         NUM\_CHAN = \_INTEGER (Given)
      }{
         Number of SCUBA channels per ADC
      }
      \sstsubsection{
         NUM\_ADC = \_INTEGER (Given)
      }{
         Number of ADC cards
      }
      \sstsubsection{
         N\_BOL = \_INTEGER (Given)
      }{
         Number of bolometers
      }
      \sstsubsection{
         BOL\_TYPE = \_CHARACTER$*$20() (Returned)
      }{
         Bolometer types
      }
      \sstsubsection{
         BOL\_DU3  = \_REAL() (Returned)
      }{
         du3 Nasmyth coordinated of bolometers
      }
      \sstsubsection{
         BOL\_DU4  = \_REAL() (Returned)
      }{
         du4 Nasmyth coordinated of bolometers
      }
      \sstsubsection{
         BOL\_ADC  = \_INTEGER() (Returned)
      }{
         A/D numbers of bolometers measured
      }
      \sstsubsection{
         BOL\_CHAN  = \_INTEGER() (Returned)
      }{
         Channel numbers of bolometers measured
      }
      \sstsubsection{
         STATUS = \_INTEGER (Given \& Returned)
      }{
         Global status
      }
   }
   \sstnotes{
      This routine does not annul the locator.
   }
   \sstdiytopic{
      Prior Requirements
   }{
      The locator to the structure must already be available.
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_GET\_DEM\_PNTR
}{
   Get the DEM\_PNTR array and its dimensions
}{
   \sstdescription{
      This routine obtains the dem\_pntr array and returns the
      dimensions in terms of switches, exposures, inegrations and
      measurements.
   }
   \sstinvocation{
       CALL SCULIB\_GET\_DEM\_PNTR(ACTDIM, LOC, DEM\_PNTR\_PTR,
            N\_SWITCHES, N\_EXPOSURES, N\_INTEGRATIONS, N\_MEASUREMENTS,
            STATUS)
   }
   \sstarguments{
      \sstsubsection{
         ACTDIM = \_INTEGER (Given)
      }{
         Number of expected dimensions
      }
      \sstsubsection{
         LOC = \_CHARACTER (Given)
      }{
         Locator to the SCUBA extension
      }
      \sstsubsection{
         DEM\_PNTR\_PTR = \_INTEGER (Returned)
      }{
         Pointer to location of DEM\_PTR array in memory
      }
      \sstsubsection{
         N\_SWITCHES = \_INTEGER (Returned)
      }{
         Number of switches indicated by DEM\_PNTR
      }
      \sstsubsection{
         N\_EXPOSURES = \_INTEGER (Returned)
      }{
         Number of exposures indicated by DEM\_PNTR
      }
      \sstsubsection{
         N\_INTEGRATIONS = \_INTEGER (Returned)
      }{
         Number of integrations indicated by DEM\_PNTR
      }
      \sstsubsection{
         N\_MEASUREMENTS = \_INTEGER (Returned)
      }{
         Number of measurements indicated by DEM\_PNTR
      }
      \sstsubsection{
         STATUS = \_INTEGER (Given \& Returned)
      }{
         Global status
      }
   }
   \sstnotes{
      This routine does not annul the locator.
   }
   \sstdiytopic{
      Prior Requirements
   }{
      The locator to the structure must already be available.
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_GET\_FILENAME
}{
   Find the filename associated with a parameter
}{
   \sstdescription{
      This routine finds the name of the filename associated with
      a NDF parameter.
   }
   \sstinvocation{
      CALL SCULIB\_GET\_FILENAME(PARAM, FILENAME, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHAR (Given)
      }{
         Name of the parameter
      }
      \sstsubsection{
         FILENAME = CHAR (Returned)
      }{
         Name of the file associated with PARAM
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
   \sstimplementationstatus{
      Uses SUBPAR
   }
}
\sstroutine{
   SCULIB\_GET\_FITS\_C
}{
   get the value of specified FITS character keyword
}{
   \sstdescription{
      This routine will get the value of a specified FITS character keyword
      held in the FITS extension of an NDF file. The FITS extension must
      have been read into the input array FITS before this routine is called.

         The routine assumes that each line in the FITS array will contain
      a string with format:-

       {\tt "}KEYWORD= {\tt '}VALUE{\tt '}           / this is a comment{\tt "}

      The string is extracted from between the quotes and the {\tt '}/{\tt '} is not
      required.

      It will search the input array for a line containing the required
      keyword and return VALUE. If the keyword is not found and error will
      be reported and bad status returned. If the keyword is found but the
      line does not conform to the above format an error will be reported
      and bad status returned.
   }
   \sstinvocation{
      CALL SCULIB\_GET\_FITS\_C (MAX\_FITS, N\_FITS, FITS, NAME,
         VALUE, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         MAX\_FITS             = INTEGER (Given)
      }{
         the maximum number of items in the FITS array
      }
      \sstsubsection{
         N\_FITS               = INTEGER (Given)
      }{
         the actual number of items in the FITS array
      }
      \sstsubsection{
         FITS (MAX\_FITS)      = CHARACTER$*$($*$) (Given)
      }{
         array containing the FITS items
      }
      \sstsubsection{
         NAME                 = CHARACTER$*$($*$) (Given)
      }{
         the name of the FITS keyword whose value is required
      }
      \sstsubsection{
         VALUE                = CHARACTER$*$($*$) (Returned)
      }{
         the value of the FITS keyword
      }
      \sstsubsection{
         STATUS               = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_GET\_FITS\_D
}{
   get the value of specified FITS double keyword
}{
   \sstdescription{
      This routine will get the value of a specified FITS double precision
      keyword held in the FITS extension of an NDF file. The FITS extension must
      have been read into the input array FITS before this routine is called.

         The routine assumes that each line in the FITS array will contain
      a string with format:-

       {\tt "}KEYWORD=VALUE           / this is a comment{\tt "}

      It will search the input array for a line containing the required
      keyword and return VALUE. If the keyword is not found an error will
      be reported and bad status returned. If the keyword is found but the
      line does not conform to the above format an error will be reported
      and bad status returned.
   }
   \sstinvocation{
       CALL SCULIB\_GET\_FITS\_D (MAX\_FITS, N\_FITS, FITS, NAME, VALUE,
         STATUS)
   }
   \sstarguments{
      \sstsubsection{
         MAX\_FITS             = INTEGER (Given)
      }{
         the maximum number of items in the FITS array
      }
      \sstsubsection{
         N\_FITS               = INTEGER (Given)
      }{
         the actual number of items in the FITS array
      }
      \sstsubsection{
         FITS (MAX\_FITS)      = CHARACTER$*$($*$) (Given)
      }{
         array containing the FITS items
      }
      \sstsubsection{
         NAME                 = CHARACTER$*$($*$) (Given)
      }{
         the name of the FITS keyword whose value is required
      }
      \sstsubsection{
         VALUE                = DOUBLE PRECISION (Returned)
      }{
         the value of the FITS keyword
      }
      \sstsubsection{
         STATUS               = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_GET\_FITS\_I
}{
   get the value of specified FITS integer keyword
}{
   \sstdescription{
      This routine will get the value of a specified FITS integer keyword
      held in the FITS extension of an NDF file. The FITS extension must
      have been read into the input array FITS before this routine is called.

         The routine assumes that each line in the FITS array will contain
      a string with format:-

       {\tt "}KEYWORD=INTEGER\_VALUE           / this is a comment{\tt "}

      It will search the input array for a line containing the required
      keyword and return VALUE. If the keyword is not found an error will
      be reported and bad status returned. If the keyword is found but the
      line does not conform to the above format an error will be reported
      and bad status returned.
   }
   \sstinvocation{
       CALL SCULIB\_GET\_FITS\_I (MAX\_FITS, N\_FITS, FITS, NAME, VALUE,
         STATUS)
   }
   \sstarguments{
      \sstsubsection{
         MAX\_FITS             = INTEGER (Given)
      }{
         the maximum number of items in the FITS array
      }
      \sstsubsection{
         N\_FITS               = INTEGER (Given)
      }{
         the actual number of items in the FITS array
      }
      \sstsubsection{
         FITS (MAX\_FITS)      = CHARACTER$*$($*$) (Given)
      }{
         array containing the FITS items
      }
      \sstsubsection{
         NAME                 = CHARACTER$*$($*$) (Given)
      }{
         the name of the FITS keyword whose value is required
      }
      \sstsubsection{
         VALUE                = INTEGER (Returned)
      }{
         the value of the FITS keyword
      }
      \sstsubsection{
         STATUS               = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_GET\_FITS\_L
}{
   get the value of specified FITS logical keyword
}{
   \sstdescription{
      This routine will get the value of a specified FITS logical keyword
      held in the FITS extension of an NDF file. The FITS extension must
      have been read into the input array FITS before this routine is called.

         The routine assumes that each line in the FITS array will contain
      a string with format:-

       {\tt "}KEYWORD=LOGICAL           / this is a comment{\tt "}

      It will search the input array for a line containing the required
      keyword and return VALUE. If the keyword is not found an error will
      be reported and bad status returned. If the keyword is found but the
      line does not conform to the above format an error will be reported
      and bad status returned.
   }
   \sstinvocation{
       CALL SCULIB\_GET\_FITS\_L (MAX\_FITS, N\_FITS, FITS, NAME, VALUE,
         STATUS)
   }
   \sstarguments{
      \sstsubsection{
         MAX\_FITS             = INTEGER (Given)
      }{
         the maximum number of items in the FITS array
      }
      \sstsubsection{
         N\_FITS               = INTEGER (Given)
      }{
         the actual number of items in the FITS array
      }
      \sstsubsection{
         FITS (MAX\_FITS)      = CHARACTER$*$($*$) (Given)
      }{
         array containing the FITS items
      }
      \sstsubsection{
         NAME                 = CHARACTER$*$($*$) (Given)
      }{
         the name of the FITS keyword whose value is required
      }
      \sstsubsection{
         VALUE                = LOGICAL (Returned)
      }{
         the value of the FITS keyword
      }
      \sstsubsection{
         STATUS               = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_GET\_FITS\_R
}{
   get the value of specified FITS real keyword
}{
   \sstdescription{
      This routine will get the value of a specified FITS real keyword
      held in the FITS extension of an NDF file. The FITS extension must
      have been read into the input array FITS before this routine is called.

         The routine assumes that each line in the FITS array will contain
      a string with format:-

       {\tt "}KEYWORD=VALUE           / this is a comment{\tt "}

      It will search the input array for a line containing the required
      keyword and return VALUE. If the keyword is not found an error will
      be reported and bad status returned. If the keyword is found but the
      line does not conform to the above format an error will be reported
      and bad status returned.
   }
   \sstinvocation{
       CALL SCULIB\_GET\_FITS\_R (MAX\_FITS, N\_FITS, FITS, NAME, VALUE,
         STATUS)
   }
   \sstarguments{
      \sstsubsection{
         MAX\_FITS             = INTEGER (Given)
      }{
         the maximum number of items in the FITS array
      }
      \sstsubsection{
         N\_FITS               = INTEGER (Given)
      }{
         the actual number of items in the FITS array
      }
      \sstsubsection{
         FITS (MAX\_FITS)      = CHARACTER$*$($*$) (Given)
      }{
         array containing the FITS items
      }
      \sstsubsection{
         NAME                 = CHARACTER$*$($*$) (Given)
      }{
         the name of the FITS keyword whose value is required
      }
      \sstsubsection{
         VALUE                = REAL (Returned)
      }{
         the value of the FITS keyword
      }
      \sstsubsection{
         STATUS               = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_GET\_JIGGLE
}{
   Get the jiggle parameters
}{
   \sstdescription{
      This routine obtains the parameters of the JIGGLE pattern:
      JIGL\_X, JIGL\_Y and some FITS parameters.
      The dimensions of these arrays are checked and an error returned
      if necessary.
   }
   \sstinvocation{
       CALL SCULIB\_GET\_JIGGLE(LOC, MAX\_JIGGLE, N\_FITS,
            FITS, JIGGLE\_COUNT, JIGGLE\_REPEAT, JIGGLE\_P\_SWITCH,
            SAMPLE\_PA, SAMPLE\_COORDS, JIGGLE\_X, JIGGLE\_Y,
            STATUS)
   }
   \sstarguments{
      \sstsubsection{
         LOC = \_CHARACTER (Given)
      }{
         Locator to the SCUBA extension
      }
      \sstsubsection{
         MAX\_JIGGLE = \_INTEGER (Given)
      }{
         Maximum number of jiggle positions
      }
      \sstsubsection{
         N\_FITS = \_INTEGER (Given)
      }{
         Size of FITS array
      }
      \sstsubsection{
         FITS  = \_CHARACTER (Given)
      }{
         FITS values
      }
      \sstsubsection{
         JIGGLE\_COUNT = \_INTEGER (Returned)
      }{
         Actual size of jiggle pattern
      }
      \sstsubsection{
         JIGGLE\_REPEAT = \_INTEGER (Returned)
      }{
         Number of times jiggle pattern is repeated in a switch
      }
      \sstsubsection{
         JIGGLE\_P\_SWITCH = \_INTEGER (Returned)
      }{
         Number of jiggles per switch
      }
      \sstsubsection{
         SAMPLE\_PA = \_REAL
      }{
         position angle of sample x axis relative to x axis of SAMPLE\_COORDS
      }
      \sstsubsection{
         SAMPLE\_COORDS = \_CHARACTER
      }{
         coordinate system of sample offsets
      }
      \sstsubsection{
         JIGGLE\_X = \_REAL (Returned)
      }{
         X jiggle positions
      }
      \sstsubsection{
         JIGGLE\_Y = \_REAL (Returned)
      }{
         Y jiggle positions
      }
      \sstsubsection{
         STATUS = \_INTEGER (Given \& Returned)
      }{
         Global status
      }
   }
   \sstnotes{
      This routine does not annul the locator.
   }
   \sstdiytopic{
      Prior Requirements
   }{
      The locator to the structure must already be available.
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_GET\_LST\_STRT
}{
   Get the LST\_STRT array and check its dimensions
}{
   \sstdescription{
      This routine obtains the lst\_strt array and compares the
      dimensions with the number of exposures, inegrations and
      measurements. The number of switches is returned.
   }
   \sstinvocation{
       CALL SCULIB\_GET\_LST\_STRT(LOC, LST\_STRT\_PTR,
            N\_SWITCHES, N\_EXPOSURES, N\_INTEGRATIONS, N\_MEASUREMENTS,
            STATUS)
   }
   \sstarguments{
      \sstsubsection{
         LOC = \_CHARACTER (Given)
      }{
         Locator to the SCUBA extension
      }
      \sstsubsection{
         LST\_STRT\_PTR = \_INTEGER (Returned)
      }{
         Pointer to location of DEM\_PTR array in memory
      }
      \sstsubsection{
         N\_SWITCHES = \_INTEGER (Returned)
      }{
         Number of switches indicated by LST\_STRT
      }
      \sstsubsection{
         N\_EXPOSURES = \_INTEGER (Given)
      }{
         Actual number of exposures
      }
      \sstsubsection{
         N\_INTEGRATIONS = \_INTEGER (Given)
      }{
         Actual number of integrations
      }
      \sstsubsection{
         N\_MEASUREMENTS = \_INTEGER (Given)
      }{
         Actual number of measurements
      }
      \sstsubsection{
         STATUS = \_INTEGER (Given \& Returned)
      }{
         Global status
      }
   }
   \sstnotes{
      This routine does not annul the locator.
      The array must be unmapped before finishing the program.
   }
   \sstdiytopic{
      Prior Requirements
   }{
      The locator to the structure must already be available.
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_GET\_MJD
}{
   Obtain the Modified Julian date from the UT stored in FITS
}{
   \sstdescription{
      This routine retrieves the UTSTART and UTDATE values from the FITS
      array and calculates the MJD from these. It can corrects for the
      time taken before beginning the observation by comparing the
      LST stored in the header (written when the observation begins and
      before the telescope gets on source) and the reference LST supplied to
      the routine (which is assumed to be the LST when the data acquisition
      starts).

   }
   \sstinvocation{
      CALL SCULIB\_GET\_MJD(N\_FITS, FITS, MJD, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         N\_FITS = \_INTEGER (Given)
      }{
         Size of FITS array
      }
      \sstsubsection{
         FITS  = \_CHARACTER (Given)
      }{
         FITS values
      }
      \sstsubsection{
         LST\_REF = DOUBLE PRECISION (Given)
      }{
        Reference LST. This is the LST at which data acquisition
        begins. The MJD should be calculated for the start of
        data taking rather than the time the telescope begain its
        slew. This number is normally read from the LST\_STRT array
        and should be in radians. If a negative value or a zero
        value is given it is assumed that no correction should be applied.
        This does mean that LST\_REF can never be exactly zero but that
        is thought be a remarkably unlikely event.
      }
      \sstsubsection{
         MJD = DOUBLE PRECISION (Returned)
      }{
         Modified Julian date of observation
      }
      \sstsubsection{
         EPOCH = \_REAL (Returned)
      }{
         Epoch of observation
      }
      \sstsubsection{
        STARTUP\_TIME = REAL (Returned)
      }{
        The time taken, in seconds, for the observation to begin.
        If the time stored in the STSTART is larger than LST\_REF
        the assumption is that a day boundary has been crossed since
        the LST\_REF should always be more recent than STSTART (the
        data can not be taken before the observation starts). A startup
        time longer than 5 minutes or so should be treated with
        suspicion. If the startup time is longer than 10 minutes it is
        not used for the MJD calculation since this should never
        be the case. Set to zero if LST\_REF was negative.
      }
      \sstsubsection{
         STATUS = \_INTEGER (Given \& Returned)
      }{
         Global status
      }
   }
   \sstnotes{
     Uses the UTDATE and UTSTART and STSTART FITS headers.
     These must be present.
      \sstitemlist{

         \sstitem
           The date must be stored in UTDATE in format YYYY:M:D

         \sstitem
           The time must be stored in UTSTART in format HH:MM:SS.SS

        \sstitem
     The MJD is calculated for the start of data taking rather
     than simply using the values stored in UTSTART. This is because
     there is always a delay between writing the FITS headers and
     taking data.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995-2000 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_GET\_RASTER
}{
   Get the raster parameters
}{
   \sstdescription{
      This routine obtains the parameters of the SCAN/MAP raster:
      RA1, RA2, DEC1 and DEC2.
      The dimensions of these arrays are checked and an error returned
      if necessary.
   }
   \sstinvocation{
       CALL SCULIB\_GET\_RASTER(LOC, N\_SWITCHES, N\_EXPOSURES,
            N\_INTEGRATIONS, N\_MEASUREMENTS, RA1\_PTR, RA2\_PTR,
            DEC1\_PTR, DEC2\_PTR, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         LOC = \_CHARACTER (Given)
      }{
         Locator to the SCUBA extension
      }
      \sstsubsection{
         N\_SWITCHES = \_INTEGER (Given)
      }{
         Actual number of switches
      }
      \sstsubsection{
         N\_EXPOSURES = \_INTEGER (Given)
      }{
         Actual number of exposures
      }
      \sstsubsection{
         N\_INTEGRATIONS = \_INTEGER (Given)
      }{
         Actual number of integrations
      }
      \sstsubsection{
         N\_MEASUREMENTS = \_INTEGER (Given)
      }{
         Actual number of measurements
      }
      \sstsubsection{
         RA1\_PTR = \_INTEGER (Given)
      }{
         Pointer to mapped RA1 array
      }
      \sstsubsection{
         RA2\_PTR = \_INTEGER (Given)
      }{
         Pointer to mapped RA2 array
      }
      \sstsubsection{
         DEC1\_PTR = \_INTEGER (Given)
      }{
         Pointer to mapped DEC1 array
      }
      \sstsubsection{
         DEC2\_PTR = \_INTEGER (Given)
      }{
         Pointer to mapped DEC2 array
      }
      \sstsubsection{
         STATUS = \_INTEGER (Given \& Returned)
      }{
         Global status
      }
   }
   \sstnotes{
      This routine does not annul the locator.
   }
   \sstdiytopic{
      Prior Requirements
   }{
      The locator to the structure must already be available.
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_GET\_SUB\_BOLS
}{
   copy bolometers belonging to a particular sub-
   instrument from the input data array to the output
}{
   \sstdescription{
      This routine extracts data for bolometers belonging to a particular
      sub-instrument from an input data array which may contain data for
      several sub-instruments. The input array IN\_POINTER points to the
      indices in the first dimension of the input data array that contain
      the data of interest. IN\_POINTER should have been calculated by an
      earlier call to SCULIB\_CALC\_SUB\_BOLS.
   }
   \sstinvocation{
       CALL SCULIB\_GET\_SUB\_BOLS (N\_BOL\_IN, N\_POS, N\_BEAM, IN\_DATA,
         IN\_VARIANCE, IN\_QUALITY, N\_BOL\_OUT, IN\_POINTER, OUT\_DATA,
         OUT\_VARIANCE, OUT\_QUALITY, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         N\_BOL\_IN                     = INTEGER (Given)
      }{
         number of bolometers in input array
      }
      \sstsubsection{
         N\_POS                        = INTEGER (Given)
      }{
         number of positions measured in input array
      }
      \sstsubsection{
         N\_BEAM                       = INTEGER (Given)
      }{
         the number of beams in the input array
      }
      \sstsubsection{
         IN\_DATA (N\_BOL\_IN,N\_POS,N\_BEAM)
      }{
                                = REAL (Given)
         input data array
      }
      \sstsubsection{
         IN\_VARIANCE (N\_BOL\_IN,N\_POS,N\_BEAM)
      }{
                                = REAL (Given)
         variance on IN\_DATA
      }
      \sstsubsection{
         IN\_QUALITY (N\_BOL\_IN,N\_POS,N\_BEAM)
      }{
                                = BYTE (Given)
         quality on IN\_DATA
      }
      \sstsubsection{
         N\_BOL\_OUT                    = INTEGER (Given)
      }{
         number of bolometers in output array
      }
      \sstsubsection{
         IN\_POINTER (N\_BOL\_OUT)       = INTEGER (Given)
      }{
         pointers from bolometers in output array to their indices in input
      }
      \sstsubsection{
         OUT\_DATA (N\_BOL\_OUT,N\_POS,N\_BEAM)
      }{
                                = REAL (Returned)
         output data array
      }
      \sstsubsection{
         OUT\_VARIANCE (N\_BOL\_OUT,N\_POS,N\_BEAM)
      }{
                                = REAL (Returned)
         variance on OUT\_DATA
      }
      \sstsubsection{
         OUT\_QUALITY (N\_BOL\_OUT,N\_POS,N\_BEAM)
      }{
                                = BYTE (Returned)
         quality on OUT\_DATA
      }
      \sstsubsection{
         STATUS                       = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_GET\_SUB\_INST
}{
   Ask for the specific sub-instrument
}{
   \sstdescription{
      This routine finds which sub-instruments are present in the
      file. If there is only one this is returned, otherwise
      the user is given a choice.
   }
   \sstinvocation{
       CALL SCULIB\_GET\_SUB\_INST(PACKAGE, N\_FITS, FITS, PARAM,
            SUB\_POINTER, WAVE, INST, FILT, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         PACKAGE = \_CHAR (Given)
      }{
         Name of software package for informational message
      }
      \sstsubsection{
         N\_FITS = \_INTEGER (Given)
      }{
         Number of FITS items
      }
      \sstsubsection{
         FITS(N\_FITS) = \_CHAR$*$80 (Given \& Returned)
      }{
         The FITS array
      }
      \sstsubsection{
         PARAM = \_CHAR (Given)
      }{
         Name of the ADAM parameter used to ask for sub instrument
      }
      \sstsubsection{
         N\_SUB = \_INTEGER (Returned)
      }{
         Number of sub instruments in file
      }
      \sstsubsection{
         SUB\_POINTER = \_INTEGER (Returned)
      }{
         Index of selected sub instrument
      }
      \sstsubsection{
         WAVE = \_REAL (Returned)
      }{
         Wavelength (microns) of selected sub instrument
      }
      \sstsubsection{
         INST = \_CHAR (Returned)
      }{
         Name of selected sub instrument
      }
      \sstsubsection{
         FILT = \_CHAR (Returned)
      }{
         Name of selected filter
      }
      \sstsubsection{
         STATUS = \_INTEGER (Given \& Returned)
      }{
         Global status
      }
   }
   \sstnotes{
      I actually need to include REDS\_SYS (for SCUBA\_\_MAX\_SUB) but I am
      doing it by hand at the moment.
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_INSERT\_BOL
}{
   To insert a single bolometer into a data array
}{
   \sstdescription{
      This routine inserts a single bolometer into a SCUBA data array.
   }
   \sstinvocation{
       CALL SCULIB\_INSERT\_BOL(NBOL, N\_BOLS, N\_POS, BOLDATA,
            BOLQUAL, SCUDATA, SCUQUAL, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         NBOL = INTEGER (Given)
      }{
         The bolometer number
      }
      \sstsubsection{
         N\_BOLS = \_INTEGER (Given)
      }{
         Total number of bolometers in data array
      }
      \sstsubsection{
         N\_POS = INTEGER (Given)
      }{
         Number of jiggle positions in data set
      }
      \sstsubsection{
         BOLDATA(N\_POS) = REAL (Given)
      }{
         The specified bolometer data
      }
      \sstsubsection{
         BOLQUAL(N\_POS) = \_BYTE (Given)
      }{
         The bolometer quality
      }
      \sstsubsection{
         SCUDATA(N\_BOLS, N\_POS) = REAL (Given \& Returned)
      }{
         The data
      }
      \sstsubsection{
         SCUQUAL(N\_BOLS, N\_POS) = BYTE (Given \&  Returned)
      }{
         The data quality
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         Global Status value
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
   \sstimplementationstatus{
      Propogates quality
   }
}
\sstroutine{
   SCULIB\_INTEGRATE\_PHOTOM\_JIGGLE
}{
   integrate the jiggle map made by a
   bolometer during a PHOTOM observation
}{
   \sstdescription{
      This routine just sums the data for the specified bolometer over the
      jiggle pattern.

        After checking status on entry the routine checks that the bolometer
      to be integrated is among those that were measured. All being well it
      then loops through the jiggle pattern summing the valid data and variance
      measured at each position for that bolometer. If no valid data were
      obtained then the result quality will be set bad.
   }
   \sstinvocation{
       CALL SCULIB\_INTEGRATE\_PHOTOM\_JIGGLE (BOL, N\_BOLS, J\_COUNT,
         DATA, VARIANCE, QUALITY, RESULT\_D, RESULT\_V, RESULT\_Q, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         BOL                          = INTEGER (Given)
      }{
         the index of the bolometer whose data is to be integrated
      }
      \sstsubsection{
         N\_BOLS                       = INTEGER (Given)
      }{
         the number of bolometers being measured
      }
      \sstsubsection{
         J\_COUNT                      = INTEGER (Given)
      }{
         the number of jiggles in the pattern
      }
      \sstsubsection{
         DATA (N\_BOLS, J\_COUNT)       = REAL (Given)
      }{
         the measured data
      }
      \sstsubsection{
         VARIANCE (N\_BOLS, J\_COUNT)   = REAL (Given)
      }{
         the variance
      }
      \sstsubsection{
         QUALITY (N\_BOLS, J\_COUNT)    = INTEGER (Given)
      }{
         the quality
      }
      \sstsubsection{
         RESULT\_D                     = REAL (Returned)
      }{
         the sum of the input data
      }
      \sstsubsection{
         RESULT\_V                     = REAL (Returned)
      }{
         the sum of the input variances
      }
      \sstsubsection{
         RESULT\_Q                     = INTEGER (Returned)
      }{
         the quality on the sum
      }
      \sstsubsection{
         STATUS                       = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_INVERT\_MATRIX
}{
   invert a square matrix
}{
   \sstdescription{
      This routine inverts a matrix by a method opaque to casual inspection
      but which has the advantage that it doesn{\tt '}t require any more space
      than the input matrix itself provides. The method is described in
      `Data Reduction and Error Analysis for the Physical Sciences{\tt '} by
      Bevington and Robinson, and the code is adapted from the Pascal
      version listed there.
   }
   \sstinvocation{
      CALL SCULIB\_INVERT\_MATRIX (M, ARRAY, DET, IK, JK, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         M                      = INTEGER (Given)
      }{
         the dimensions of the matrix
      }
      \sstsubsection{
         ARRAY (M,M)            = DOUBLE PRECISION (Given and returned)
      }{
         the matrix to be inverted
      }
      \sstsubsection{
         DET                    = DOUBLE PRECISION (Returned)
      }{
         the determinant of the matrix
      }
      \sstsubsection{
         IK (M)                 = INTEGER (Scratch)
      }{
         i indices of largest array elements
      }
      \sstsubsection{
         JK (M)                 = INTEGER (Scratch)
      }{
         j indices of largest array elements
      }
      \sstsubsection{
         STATUS                 = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_J\_THEORETICAL
}{
   calculate the theoretical sky brightness temperature
}{
   \sstdescription{
      This routine calculates the theoretical sky brightness temperature
      according to Bill Duncan{\tt '}s model:-


\begin{equation}
J_\mathrm{meas} = (1 - \eta_\mathrm{tel}) J_\mathrm{tel} +
                   \eta_\mathrm{tel} J_\mathrm{atm} -
                   b  \eta_\mathrm{tel} J_\mathrm{atm} e^{-A\tau},
\end{equation}

      Jtel is known and Jatm is related to Jamb by:-

 \begin{equation}
J_\mathrm{atm} = J_\mathrm{amb} \int_0^{40}\! A \left[k\exp\left(-\frac{h}{h_2}
\right)\exp\left[A k h_2 \left(\exp\left(-\frac{h}{h_2}\right)-1\right)\right]
\left(1-\frac{h}{h_1}\right)\right]\mathrm{d}h,
\end{equation}

      where h2 = scale height of absorption ( = 2km),
            h1 = coefficient to give 6.5K/km temperature drop in absorber,
             A = airmass,
             k = extinction.

      which relation has been fudged by Bill Duncan to:-

\begin{equation}
J_\mathrm{atm} = J_\mathrm{amb} X_\mathrm{g} \left[1-\exp\left(-A k h_2\right)\right],
\end{equation}
with $X_\mathrm{g}$ having the form
\begin{equation}
X_\mathrm{g} = 1 + \frac{h_2 T_\mathrm{lapse}}{T_\mathrm{amb}}\exp\left(-\frac{A \tau}{X_\mathrm{gconst}}\right)
\end{equation}

      with

            h1 = 2,
            h2 = -6.5 (note this h2 is defined differently to that in the
                       previous equation),
       $X_\mathrm{gconst}$ = 3.669383

      where Jatm is the effective brightness temperature of the sky.

      The routine will return immediately if entered with bad status.
      Errors will be reported and bad status returned if:-
      \sstitemlist{

         \sstitem
           TAUZ is less than 0

         \sstitem
           AIRMASS is less than 0

         \sstitem
           WAVELENGTH is less than or equal to 0

         \sstitem
           T\_AMB is less than or equal to 0

         \sstitem
           ETA\_TEL is outside the range 0 to 1

         \sstitem
           B is outside the range 0 to 1
      }
   }
   \sstinvocation{
       CALL SCULIB\_J\_THEORETICAL (TAUZ, AIRMASS, T\_TEL, T\_AMB,
         WAVELENGTH, ETA\_TEL, B, J\_THEORETICAL, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         TAUZ                = REAL (Given)
      }{
         zenith sky optical depth
      }
      \sstsubsection{
         AIRMASS             = REAL (Given)
      }{
         airmass
      }
      \sstsubsection{
         T\_TEL               = REAL (Given)
      }{
         temperature of the telescope (K)
      }
      \sstsubsection{
         T\_AMB               = REAL (Given)
      }{
         temperature of ambient air (K)
      }
      \sstsubsection{
         WAVELENGTH          = REAL (Given)
      }{
         wavelength of interest (microns)
      }
      \sstsubsection{
         ETA\_TEL             = REAL (Given)
      }{
         telescope transmission
      }
      \sstsubsection{
         B                   = REAL (Given)
      }{
         bandwidth factor
      }
      \sstsubsection{
         J\_THEORETICAL       = REAL (Returned)
      }{
         the theoretical sky brightness temperature
      }
      \sstsubsection{
         STATUS              = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_JNU
}{
   Calculate the Rayleigh-Jeans corrected brightness temperature
}{
   \sstdescription{
      This function calculates the Rayleigh-Jeans corrected brightness
      temperature of radiation at frequency NU ($\nu$) and temperature T.

\begin{equation}
\jmath_\nu = \frac{X T}{\exp(X) - 1}
\end{equation}
where
\begin{equation}
X = \frac{h\nu}{kT}
\end{equation}

      If the absolute value of X is less than 1e-4 JNU = T, or if the absolute
      value of X is greater than 20 JNU = 0.
   }
   \sstinvocation{
      JNU = SCULIB\_JNU (NU, T, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         NU                = REAL (Given)
      }{
         frequency (Hz)
      }
      \sstsubsection{
         T                 = REAL (Given)
      }{
         temperature (K)
      }
      \sstsubsection{
         STATUS            = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         SCULIB\_JNU = REAL
      }{
         Rayleigh-Jeans corrected brightness temperature
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_LINEAR\_WTINIT
}{
   Set up weighting function for linear rebinning
}{
   \sstdescription{
      This is a FORTRAN version of the C transputer code.
      Here is the C description:
      Initialise the array containing the weighting function for
      linear interpolation.
      The weighting function is a cone, going from 1.0 at the centre to
      0.0 at the edge. The look-up table represents a radial slice through the
      cone, tabulated to enable a look-up in terms of the square of the
      radius.
   }
   \sstinvocation{
      CALL SCULIB\_LINEAR\_WTINIT(WTFN, RES, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         WTFN ( RES $*$ RES ) = REAL (Returned)
      }{
         The weighting function generated by this routine.
         The index corresponds to the square of the distance from the
         centre in scale units.
      }
      \sstsubsection{
         RES = INTEGER (Given)
      }{
         Number of points per scale lenghth.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_LST
}{
   returns LST in radians
}{
   \sstdescription{
      Calculates the current LST in radians.
   }
   \sstinvocation{
      LST = SCULIB\_LST
   }
   \sstarguments{
      \sstsubsection{
         None
      }{
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         LST = DOUBLE PRECISION
      }{
         LST in radians
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_MALLOC
}{
   get virtual memory
}{
   \sstdescription{
      This routine gets SIZE bytes of virtual memory.

      If status is bad on entry the routine will return immediately.

      If START\_PTR is not equal to 0 then
      \sstitemlist{

         \sstitem
           It{\tt '}s possible that VM may have already been allocated to
            START\_PTR so issue an error message and set status bad.

      }
      else

      \sstitemlist{

         \sstitem
          Call PSX\_MALLOC to allocate the required memory plus space for
            2 integers at either end.

         \sstitem
          If status is good then
               Set START\_PTR and END\_PTR to point to the first and last
               bytes in the section of memory to be used and
               call SCULIB\_CFILLI to set the sentinel integers at either
               end of the block to 37. SCULIB\_FREE will check these for
               corruption when the time comes to free the VM.

      }
      end if
   }
   \sstinvocation{
      CALL SCULIB\_MALLOC (SIZE, START\_PTR, END\_PTR, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         SIZE                = INTEGER (Given)
      }{
         number of bytes required
      }
      \sstsubsection{
         START\_PTR           = INTEGER (Given and returned)
      }{
         pointer to beginning of virtual memory
      }
      \sstsubsection{
         END\_PTR             = INTEGER (Returned)
      }{
         pointer to end of virtual memory
      }
      \sstsubsection{
         STATUS              = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_MAP\_ALLAN\_VARIANCE
}{
   incorporate latest set of MAP demodulated data
   into Allan variance
}{
   \sstdescription{
      This routine incorporates a data slice into a run of data and
      updates the Allan variance of the run.
         The Allan variance is calculated for a range of simulated integration
      times for which artificial samples are calculated from the input data.
      The Allan variance for a particular integration time is calculated from:-

\begin{equation}
variance = \sum_{i=1\rightarrow n-1}\frac{(sample(i) - sample(i+1))^2}{2n}
\end{equation}

      where n is the number of artificial samples available.
   }
   \sstinvocation{
       CALL SCULIB\_MAP\_ALLAN\_VARIANCE (DEMOD, N\_BOLS, N\_SAMPLES,
         N\_ALLAN\_BOL, ALLAN\_BOL, KMAX, SUM, N\_SUM, ARTIFICIAL,
         N\_ARTIFICIAL, ALLAN\_VARIANCE, ALLAN\_QUALITY, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         DEMOD (4, N\_BOLS, N\_SAMPLES)    = REAL (Given)
      }{
         the demodulated data (data,-,-,quality)
      }
      \sstsubsection{
         N\_BOLS                          = INTEGER (Given)
      }{
         the number of bolometers taking data
      }
      \sstsubsection{
         N\_SAMPLES                       = INTEGER (Given)
      }{
         the number of samples taken for each bolometer
      }
      \sstsubsection{
         N\_ALLAN\_BOL                     = INTEGER (Given)
      }{
         the number of bolometers whose data is to be averaged together
         at each sample position
      }
      \sstsubsection{
         ALLAN\_BOL (N\_ALLAN\_BOL)         = INTEGER (Given)
      }{
         the positions in the demodulated data array of the bolometers
         whose measurements are to be used for the calculation of Allan
         variance
      }
      \sstsubsection{
         KMAX                            = INTEGER (Given)
      }{
         the size of the Allan variance array
      }
      \sstsubsection{
         SUM (KMAX)                      = REAL (Given and returned)
      }{
         the accumulator for current artificial sample of length K real
         samples
      }
      \sstsubsection{
         N\_SUM (KMAX)                    = INTEGER (Given and returned)
      }{
         the number of samples currently in the artificial sample
         accumulator
      }
      \sstsubsection{
         ARTIFICIAL (KMAX)               = REAL (Given and returned)
      }{
         the last artificial sample of length K samples that was
         calculated
      }
      \sstsubsection{
         N\_ARTIFICIAL (KMAX)             = INTEGER (Given and returned)
      }{
         the number of artificial samples of length K samples that
         have been calculated
      }
      \sstsubsection{
         ALLAN\_VARIANCE (KMAX)           = REAL (Given and returned)
      }{
         the Allan variance
      }
      \sstsubsection{
         ALLAN\_QUALITY (KMAX)            = INTEGER (Returned)
      }{
         quality on the Allan variance
      }
      \sstsubsection{
         STATUS                          = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Method
   }{
      If status on entry is good the routine will:-

      loop through the data samples to be incorporated -

         loop through the bolometers whose data is to be averaged into
         this sample -

            if the bolometer was measured -
               if the measurement had good quality -

                  add the measurement to the average for this sample

               end if
            end if

         end of loop

         if any bolometers had good data for this sample -

            calculate the sample average

            loop through the Allan variances -

               add the sample to the buffer used to calculate the latest
               artificial sample at the simulated integration time of this
               variance

               if all the data has been obtained for the latest artificial
               sample -

                  calculate the artificial sample

                  if there is only one artificial sample for this simulated
                  integration time we can{\tt '}t calculate the Allan variance, so
                  set its quality to bad

                  if there are 2 artifical samples then the Allan variance
                  can be calculated from -

\begin{equation}
variance = \frac{(artificial\_2 - artificial\_1)^2}{2 \times 2}
\end{equation}

                  if there are more than 2 artificial samples

                     the sum of the squares of the differences between the
                     previous samples is recovered from the current value of the
                     Allan variance

                     the square of the difference between the current artificial
                     sample and the previous one is added to the sum

                     the Allan variance is re-calculated

                  end if

                  the current artifical sample is stored to be used as the
                  `previous{\tt '} sample next time round

                  the variables used to calculate the artificial samples at
                  this simulated integration time are reset

               end if

            end of loop through Allan variances

         end if

      end of loop through samples in this dataslice
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_MASK\_DATA
}{
   Set a data array from a SCUBA section
}{
   \sstdescription{
      From an array of SCUBA sections, this routine creates a mask
      which is then used to modify the given data array
   }
   \sstinvocation{
      CALL SCULIB\_MASK\_DATA( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         USE\_SECT   = LOGICAL (Given)
      }{
         Are we using the section (TRUE) or inverse (FALSE)
      }
      \sstsubsection{
         TYPE = CHAR (Given)
      }{
         Type of data. Allowed values are:
           REAL - data is real array
           BYTE - data is byte array
           BIT  - affect single bit of byte array
      }
      \sstsubsection{
         N\_SPEC                           = INTEGER (Given)
      }{
         Number of specifications supplied in SPEC
      }
      \sstsubsection{
         SPEC( N\_SPEC )                   = CHARACTER$*$($*$) (Given)
      }{
         the specification to be decoded
      }
      \sstsubsection{
         DEMOD\_POINTER (N\_SWITCHES, N\_EXPOSURES, N\_INTEGRATIONS,  N\_MEASUREMENTS)
      }{
      }
      \sstsubsection{
         = INTEGER (Given)
      }{
         the pointer to the location in the main data array of the data
         for each switch of the observation
      }
      \sstsubsection{
         N\_SWITCHES                       = INTEGER (Given)
      }{
         the number of switches per exposure
      }
      \sstsubsection{
         N\_EXPOSURES                      = INTEGER (Given)
      }{
         the number of exposures per integration
      }
      \sstsubsection{
         N\_INTEGRATIONS                   = INTEGER (Given)
      }{
         the number of integrations per measurement
      }
      \sstsubsection{
         N\_MEASUREMENTS                   = INTEGER (Given)
      }{
         the number of measurements in the observation
      }
      \sstsubsection{
         N\_POS                            = INTEGER (Given)
      }{
         the number of positions measured in the observation
      }
      \sstsubsection{
         N\_BOLS                           = INTEGER (Given)
      }{
         the number of bolometers measured in the observation
      }
      \sstsubsection{
         N\_BEAM = INTEGER (Given)
      }{
         Number of beams in DATA\_PTR
      }
      \sstsubsection{
         SWITCH\_EXPECTED                  = LOGICAL (Given)
      }{
         .TRUE. if a switch component is allowed in the data-spec
      }
      \sstsubsection{
         VALUE   = REAL (Given)
      }{
         If TYPE is {\tt '}REAL{\tt '} then use this value for masked data
      }
      \sstsubsection{
         BVALUE   = BYTE (Given)
      }{
         If TYPE is {\tt '}BYTE{\tt '} then use this value for masked data
      }
      \sstsubsection{
         BITNUM   = INTEGER (Given)
      }{
         If TYPE is {\tt '}BIT{\tt '} then affect this bit position
      }
      \sstsubsection{
         BIT\_STATE = LOGICAL (Given)
      }{
         If TYPE is {\tt '}BIT{\tt '} then clear the bit (FALSE) or set it (TRUE)
      }
      \sstsubsection{
         DATA\_PTR = INTEGER (Given \& Returned)
      }{
         Pointer to data array that is to be masked
      }
      \sstsubsection{
         STATUS                           = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_MJD\_TO\_DATEOBS
}{
   Convert a modified julian date to the correct FITS DATE-OBS format
}{
   \sstdescription{
      Given a modified Julian date  generate
      a correctly formatted FITS DATE-OBS string.
   }
   \sstinvocation{
      CALL SCULIB\_MJD\_TO\_DATEOBS ( MJD, DATE\_OBS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         MJD = DOUBLE PRECISION (Given)
      }{
         Modified Julian date (Defined as JD - 2400000.5)
      }
      \sstsubsection{
         DATE\_OBS = CHARACTER $*$ ($*$) (Returned)
      }{
         FITS DATE-OBS string. Should have at least 24
         characters for YYYY-MM-DDThh:mm:ss.sssZ format
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global Status
      }
   }
   \sstnotes{
      The format used for the DATE-OBS keyword depends on the value of the
      keyword. For DATE-OBS $<$ 1999.0, use the old {\tt "}dd/mm/yy{\tt "} format.
      Otherwise, use the new {\tt "}ccyy-mm-ddThh:mm:ss[.ssss]Z{\tt "} format.
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 2000 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}

\sstroutine{
   SCULIB\_MRQCOF
}{
   called by SCULIB\_MRQMIN
}{
   \sstdescription{
      Utility routine called by SCULIB\_MRQMIN, copied from Numerical
      Recipes in Fortran, p. 681. Used by SCULIB\_MRQMIN to evaluate the
      linearised fitting matrix ALPHA, and vector BETA, and calculate
      chi-squared.
         Copied from MRQCOF on p.681 of Numerical Recipes in Fortran, with
      STATUS added.
   }
   \sstinvocation{
       CALL SCULIB\_MRQCOF (X, Y, SIG, NDATA, A, IA, MA, ALPHA,
         BETA, NALP, CHISQ, FUNCS, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         X( NDATA ) = REAL (Given)
      }{
         X Data points
      }
      \sstsubsection{
         Y( NDATA ) = REAL (Given)
      }{
         Y data points
      }
      \sstsubsection{
         SIG ( NDATA ) = REAL (Given)
      }{
      }
      \sstsubsection{
         NDATA = INTEGER (Given)
      }{
         Number of data points in arrays
      }
      \sstsubsection{
         A( MA ) = REAL (Given \& Returned)
      }{
         The input parameter values. Contains the best-fit values on exit.
      }
      \sstsubsection{
         IA( MA ) = INTEGER (Given)
      }{
         Array specifying which components should be fitted. A zero
         indicates the parameter should not be fitted -- the parameters
         are kept at their input values. Non-zero indicates the parameter
         is free to be modified.
      }
      \sstsubsection{
         MA = INTEGER (Given)
      }{
         Number of coefficients/parameters for function.
      }
      \sstsubsection{
         ALPHA( NALP, NALP ) = REAL (Returned)
      }{
      }
      \sstsubsection{
         BETA( MA ) = REAL (Returned)
      }{
      }
      \sstsubsection{
         NALP = INTEGER  (Given)
      }{
         Size of ALPHA.
      }
      \sstsubsection{
         CHISQ = REAL (Returned)
      }{
         ChiSq of fit.
      }
      \sstsubsection{
         FUNCS = REAL FUNCTION (Given)
      }{
         The function to be fitted. Must take arguments of X, A, YFIT,
         DYDA and MA, where YFIT is the fitting function and DYDA the
         the derivatives with respect to parameters A at X.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global Status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_MRQMIN
}{
   Levenberg-Marquardt method non-linear least-squares
   fit from Numerical Recipes in FORTRAN
}{
   \sstdescription{
      Levenberg-Marquardt method, attempting to reduce the value of
      chi-squared of a fit between a set of data points X(1:NDATA),
      Y(1:NDATA), and a non-linear function dependent on MA coefficients
      A(1:MA). The input array IA(1:MA) indicates by non-zero components
      those components of A that should be fitted for, and by 0 entries
      those components that should be held fixed at their input values.
      The program returns current best-fit values for the parameters
      A(1:MA), and chi-squared = CHISQ. The arrays COVAR (1:NCA,1:NCA),
      ALPHA (1:NCA,1:NCA) with physical dimension NCA ($>$= the number of
      fitted parameters) are used as working space during most iterations.
      Supply a subroutine FUNCS (X, A, YFIT, DYDA, MA) that evaluates
      the fitting function YFIT, and its derivatives DYDA with respect to the
      the fitting paramters A at X. On the first call provide an initial
      guess for the parameters A, and set ALAMDA $<$ 0 for initialisation
      (which then sets ALAMDA = 0.001). If a step succeeds CHISQ becomes
      smaller and ALAMDA decreases by a factor of 10. If a step fails
      ALAMDA grows by a factor of 10. You must call this routine repeatedly
      until convergence is achieved. Then, make one final call with
      ALAMDA = 0, so that COVAR (1:MA,1:MA) returns the covariance matrix,
      and ALPHA the curvature matrix. Parameters held fixed will return
      zero covariance.
        Copied from MRQMIN on p.680 of Numerical Recipes in Fortran, with
      STATUS added.
   }
   \sstinvocation{
       CALL SCULIB\_MRQMIN (X, Y, SIG, NDATA, A, IA, MA, COVAR,
         ALPHA, NCA, CHISQ, FUNCS, ALAMDA, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         X( NDATA ) = REAL (Given)
      }{
         X Data points
      }
      \sstsubsection{
         Y( NDATA ) = REAL (Given)
      }{
         Y data points
      }
      \sstsubsection{
         SIG ( NDATA ) = REAL (Given)
      }{
      }
      \sstsubsection{
         NDATA = INTEGER (Given)
      }{
         Number of data points in arrays
      }
      \sstsubsection{
         A( MA ) = REAL (Given \& Returned)
      }{
         The input parameter values. Contains the best-fit values on exit.
      }
      \sstsubsection{
         IA( MA ) = INTEGER (Given)
      }{
         Array specifying which components should be fitted. A zero
         indicates the parameter should not be fitted -- the parameters
         are kept at their input values. Non-zero indicates the parameter
         is free to be modified.
      }
      \sstsubsection{
         MA = INTEGER (Given)
      }{
         Number of coefficients/parameters for function.
      }
      \sstsubsection{
         COVAR ( NCA, NCA ) = REAL (Returned)
      }{
         The covariance matrix. Fixed parameters will return zero covariance.
      }
      \sstsubsection{
         ALPHA ( NCA, NCA ) = REAL (Returned)
      }{
         The curvature matrix.
      }
      \sstsubsection{
         NCA = INTEGER (Given)
      }{
         Size of output arrays. Must be greater than the number of fitted
         parameters
      }
      \sstsubsection{
         CHISQ = REAL (Returned)
      }{
         ChiSq of fit.
      }
      \sstsubsection{
         FUNCS = REAL FUNCTION (Given)
      }{
         The function to be fitted. Must take arguments of X, A, YFIT,
         DYDA and MA, where YFIT is the fitting function and DYDA the
         the derivatives with respect to parameters A at X.
      }
      \sstsubsection{
         ALAMDA = REAL (Given \& Returned)
      }{
         The stepping factor for the iteration. Should be set to $<$0
         initially.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global Status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_MULCAD
}{
   multiply double precision array by a constant double
}{
   \sstdescription{
      multiplies a double precision array by a double constant
   }
   \sstinvocation{
      CALL SCULIB\_MULCAD (N, IN, DVAL, OUT, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         N              = INTEGER (Given)
      }{
         number of array elements
      }
      \sstsubsection{
         IN (N)         = DOUBLE (Given)
      }{
         array to be multiplied
      }
      \sstsubsection{
         DVAL           = DOUBLE (Given)
      }{
         multiplication factor
      }
      \sstsubsection{
         OUT (N)        = DOUBLE (Returned)
      }{
         output array (can be same as input)
      }
      \sstsubsection{
         STATUS         = INTEGER (Given \& Returned)
      }{
         Global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_MULCAR
}{
   multiply real array by a constant
}{
   \sstdescription{
      multiplies a real array by a real constant
   }
   \sstinvocation{
      CALL SCULIB\_MULCAR (N, IN, RVAL, OUT)
   }
   \sstarguments{
      \sstsubsection{
         N              = INTEGER (Given)
      }{
         number of array elements
      }
      \sstsubsection{
         IN (N)         = REAL (Given)
      }{
         array to be multiplied
      }
      \sstsubsection{
         RVAL           = REAL (Given)
      }{
         multiplication factor
      }
      \sstsubsection{
         OUT (N)        = REAL (Returned)
      }{
         output array (can be same as input)
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_MULTARE
}{
   multiplies 2 real arrays with optional error and quality
   handling
}{
   \sstdescription{
      Multiplies two floating point arrays.  The arrays
      may have any dimensions; they are treated here as
      linear in order to generate more efficient code.
   }
   \sstinvocation{
       CALL SCULIB\_MULTARE (NELM, ARRAY1, ARRAY2, ARRAY3, Q1DATA,
         Q2DATA, Q3DATA, E1DATA, E2DATA, E3DATA, QUAL, FLAGS, FBAD,
         VARIANCE)
   }
   \sstarguments{
      \sstsubsection{
         NELM                = INTEGER (Given)
      }{
         Number of elements in each array
      }
      \sstsubsection{
         ARRAY1 (NELM)       = REAL (Given)
      }{
         Input array
      }
      \sstsubsection{
         ARRAY2 (NELM)       = REAL (Given)
      }{
         Second input array.
      }
      \sstsubsection{
         ARRAY3 (NELM)       = REAL (Returned)
      }{
         Result array.  ARRAY3=ARRAY1$*$ARRAY2
      }
      \sstsubsection{
         Q1DATA (NELM)       = INTEGER (Given)
      }{
         Quality array for first input array
      }
      \sstsubsection{
         Q2DATA (NELM)       = INTEGER (Given)
      }{
         Quality array for second input array
      }
      \sstsubsection{
         Q3DATA (NELM)       = INTEGER (Returned)
      }{
         Quality array for output array
      }
      \sstsubsection{
         E1DATA (NELM)       = REAL (Given)
      }{
         Variance array for input array
      }
      \sstsubsection{
         E2DATA (NELM)       = REAL (Given)
      }{
         Variance array for second input array
      }
      \sstsubsection{
         E3DATA (NELM)       = REAL (Returned)
      }{
         Variance array for output array
      }
      \sstsubsection{
         QUAL                = LOGICAL (Given)
      }{
         True if input has quality information
      }
      \sstsubsection{
         FLAGS               = LOGICAL (Given)
      }{
         True if input has flagged data values
      }
      \sstsubsection{
         FBAD                = REAL (Given)
      }{
         Flag value
      }
      \sstsubsection{
         VARIANCE            = LOGICAL (Given)
      }{
         True if both input arrays have variance arrays
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Any of the arrays may be the same.

         \sstitem
         Consider using VEC\_MULR (SUN/39) instead.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_NFILLI
}{
   fill an integer array with its indices
}{
   \sstdescription{
      fills an integer array with its indices
   }
   \sstinvocation{
      CALL SCULIB\_NFILLI (N, ARRAY)
   }
   \sstarguments{
      \sstsubsection{
         N            = INTEGER (Given)
      }{
         number of array elements
      }
      \sstsubsection{
         ARRAY (N)    = INTEGER (Returned)
      }{
         array to be filled
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
   \sstimplementationstatus{
      No status checking
   }
}
\sstroutine{
   SCULIB\_NFILLR
}{
   fill a real array with its indices
}{
   \sstdescription{
      fills a real array with its indices
   }
   \sstinvocation{
      CALL SCULIB\_NFILLR (N, ARRAY)
   }
   \sstarguments{
      \sstsubsection{
         N            = INTEGER (Given)
      }{
         number of array elements
      }
      \sstsubsection{
         ARRAY (N)    = REAL (Returned)
      }{
         array to be filled
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
   \sstimplementationstatus{
      No status checking
   }
}
\sstroutine{
   SCULIB\_NOISE\_MEAN
}{
   Calculate statistics of NOISE data from raw demodulated data
}{
   \sstdescription{
      This routine calculates the mean and variance of a set of integrations
      in a NOISE measurement.
         If, only one integration was taken then the demodulated chop signal,
      chop variance, calibrator signal, calibrator variance and quality will
      be returned in CHOP\_DATA, CHOP\_VARIANCE, CAL\_DATA, CAL\_VARIANCE and
      QUALITY as they were obtained from the transputers.
         If more than 1 integration was obtained then:-

           If, for a given bolometer, no valid data was obtained for any of the
           integrations then the QUALITY for that bolometer will be returned
           as 1.

           If, for that bolometer, one valid integration was obtained then the
           demodulated chop signal and variance will be returned in CHOP\_DATA
           and CHOP\_VARIANCE, the calibrator signal and variance will be
           returned in CAL\_DATA and CAL\_VARIANCE, and QUALITY will be set
           to 0.

           If more than one valid integration was obtained then the means
           of the chop and calibrator signals will be returned in CHOP\_DATA
           and CAL\_DATA, and the variances of the individual samples in
           CHOP\_VARIANCE and  CAL\_VARIANCE, and QUALITY will be set to 0.
   }
   \sstinvocation{
       SCULIB\_NOISE\_MEAN ( N\_INTEGRATIONS, N\_BOLS, DEMOD,
            CHOP\_DATA, CHOP\_VARIANCE, CAL\_DATA, CAL\_VARIANCE,
            QUALITY, WORKSPACE, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         N\_INTEGRATIONS                    = INTEGER (Given)
      }{
         number of integrations taken in measurement
      }
      \sstsubsection{
         N\_BOLS                            = INTEGER (Given)
      }{
         number of bolometers measured
      }
      \sstsubsection{
         DEMOD (5, N\_BOLS, N\_INTEGRATIONS) = REAL (Given)
      }{
         the demodulated data; chop, chop variance, calibrator, cal
         variance, quality
      }
      \sstsubsection{
         CHOP\_DATA (N\_BOLS)                = REAL (Returned)
      }{
         the mean of the demodulated chop signal over the integrations
      }
      \sstsubsection{
         CHOP\_VARIANCE (N\_BOLS)            = REAL (Returned)
      }{
         the variance on CHOP\_DATA, calculated from the dispersion
         about the mean, or the demodulated variance if there was only
         one integration
      }
      \sstsubsection{
         CAL\_DATA (N\_BOLS)                 = REAL (Returned)
      }{
         the mean of the demodulated calibrator signal over the integrations
      }
      \sstsubsection{
         CAL\_VARIANCE (N\_BOLS)             = REAL (Returned)
      }{
         the variance on CAL\_DATA, calculated from the dispersion about the
         mean, or the demodulated variance if there was only one integration
      }
      \sstsubsection{
         QUALITY (N\_BOLS)                  = BYTE (Returned)
      }{
         the quality on the returned data
      }
      \sstsubsection{
         WORKSPACE (N\_BOLS)                = INTEGER (Scratch)
      }{
         some scratch space for keeping track of the number of
         valid observations to be included in the averaging
         for each bolometer
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         inherited status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_PAR\_GET0?
}{
   Wrapper for the standard PAR\_GET0 routines
}{
   \sstdescription{
      This routine provides a wrapper for PAR\_GET0? so that
      STATUS can be checked and an informative error message
      added without adding large numbers of lines to other routines.
   }
   \sstinvocation{
      CALL SCULIB\_PAR\_GET0?(PARAM, VALUE, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         PARAM  = CHARACTER (Given)
      }{
         Name of requested parameter
      }
      \sstsubsection{
         VALUE  = TYPE (Returned)
      }{
         Parameter value (bad if bad status from PAR\_GET)
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status value
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         All return types are present as different subroutines
      }
   }
}
\sstroutine{
   SCULIB\_PHOTOM\_BOLSELECT
}{
   select photometers for a PHOTOM observation
}{
   \sstdescription{
      This routine selects the bolometers to be used in a PHOTOM observation.
      If status is good on entry the routine will start by setting to zero
      the arrays describing which bolometers have been selected. Then it will
      call SCULIB\_BOLSELECT to get the chan/ADC numbers of the bolometers
      directly specified in BOLOMETERS.

        The observer can specify between 1 and 3 bolometers by name. Otherwise
      an error will be reported and the routine will return with bad status.
      Likewise, if any of these directly selected bolometers have bad quality
      or have identical Nasmyth offsets.

      Now the routine branches on the number of directly selected bolometers:-

      \sstitemlist{

         \sstitem
          3 bolometers specified. In this case the observer must want to chop
          between 3 bolometers on an array.
            All 3 bolometers should belong to a single array, if not the routine
          will error and return with bad status. The routine will arbitrarily
          assign the 3 bolometers to the `left{\tt '}, {\tt '}middle{\tt '} and `right{\tt '} projected
          positions in the order they were selected. The routine now checks that
          the 3 bolometers do lie in roughly a straight line on the sky (allowing
          for distortion) and that the left and right bolometers lie roughly the
          same distance on either side of the middle. Errors will occur and the
          routine return with bad status if these conditions are not met.
            If all is OK the routine will now store the channel/ADC numbers of
          the directly selected bolometers, set CHOP\_COORDS to Nasmyth, the
          bolometer spacing to half the distance between the left and right,
          the chopper position angle, and the instrument `centre{\tt '} to the coords of
          the middle bolometer.
            Next, the routine will search the bolometers belonging to the other
          array. If 3 can be found that match the positions of the 3 direct
          bolometers and have good quality then the routine will store the
          channel/ADC numbers of those bolometers as well.
            Lastly, the routine will set the bolometers to actually be measured
          to all those belonging to the array(s) containing the bolometers
          already selected.

         \sstitem
          2 bolometers specified. In this case the observer must want to observe
          a source by chopping between the 2 named bolometers.
            The routine will arbitrarily call the first of the 2 bolometers
          the `middle{\tt '} projected bolometer, the second `right{\tt '}. Then it will
          store the channel/ADC numbers of these directly selected bolometers and
          set the types of sub-instruments that they imply. If any of the
          sub-instruments are arrays the routine will search for bolometer(s)
          at the same Nasmyth offset in the other array and select them too.
            Lastly, the routine will set the bolometers to actually be measured
          to all those in the selected sub-instruments. CHOP\_COORDS is set to
          Nasmyth, the bolometer spacing to the distance between the
          directly selected bolometers, the chopper position angle is set, and
          the instrument `centre{\tt '} to the Nasmyth coords of the middle bolometer.

         \sstitem
          1 bolometer specified. In this case the observer must want to observe
          a source without chopping between different bolometers.
            The routine will arbitrarily call the primary selected bolometer
          the `middle{\tt '} projected bolometer. `Left{\tt '} and `right{\tt '} bolometers will
          not be assigned.
            The routine will now store the channel/ADC numbers of the directly
          selected bolometer and set the type of sub-instrument that is implied.
          If the sub-instrument is one of the arrays the routine will search
          for a bolometer at the same Nasmyth offset in the other array and
          select it too.
            Lastly, the routine will set the bolometers to actually be measured
          to all those in the selected sub-instruments. The instrument `centre{\tt '}
          is set to the Nasmyth offset of the primary selected bolometer.
          CHOP\_COORDS, the bolometer spacing and chopper position angle are
          all set to bad values so that the calling routine knows these have to
          be read explicitly from the observation definition file.

      }
      Finally, SCULIB\_BOLSELECT is called to select for measurement all the
      bolometers belonging to the sub-instruments involved in this PHOTOM
      observation. An array is then calculated holding the index in the array
      of ALL the photometers to be measured of each projected bolometer
      in each sub-instrument that was directly selected.
   }
   \sstinvocation{
       CALL  SCULIB\_PHOTOM\_BOLSELECT (BOLOMETERS, BOL\_TYPE,
          BOL\_CALIB, BOL\_DU3, BOL\_DU4, BOL\_QUAL, BOL\_ENABLED, NUM\_CHAN,
          NUM\_ADC, BOL\_SELECT\_CHAN, BOL\_SELECT\_ADC, N\_BOLS, MAX\_SUB,
          SUB\_INSTRMNT, N\_SUB, CENTRE\_DU3, CENTRE\_DU4, CHOP\_COORDS,
          BOL\_SPACING, CHOP\_PA, N\_BOL\_SUB, BOLS\_MEASURED,
          PHOT\_BEAM\_CHAN, PHOT\_BEAM\_ADC, PHOT\_BEAM\_BOL, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         BOLOMETERS                  = CHARACTER$*$($*$) (Given)
      }{
         list of bolometer selections
      }
      \sstsubsection{
         BOL\_TYPE (NUM\_CHAN, NUM\_ADC)
      }{
                               = CHARACTER$*$($*$) (Given)
         type of bolometer
      }
      \sstsubsection{
         BOL\_CALIB (NUM\_CHAN, NUM\_ADC)
      }{
                               = REAL (Given)
         target calibrator values for bolometers
      }
      \sstsubsection{
         BOL\_DU3 (NUM\_CHAN, NUM\_ADC) = REAL (Given)
      }{
         Nasmyth DU3 offset of bolometer from field centre
      }
      \sstsubsection{
         BOL\_DU4 (NUM\_CHAN, NUM\_ADC) = REAL (Given)
      }{
         Nasmyth DU4 offset of bolometer from field centre
      }
      \sstsubsection{
         BOL\_QUAL (NUM\_CHAN, NUM\_ADC)
      }{
                               = INTEGER (Given)
         quality of bolometers
      }
      \sstsubsection{
         BOL\_ENABLED (NUM\_CHAN, NUM\_ADC)
      }{
                               = LOGICAL (Returned)
         .TRUE. if bolometer was selected
      }
      \sstsubsection{
         NUM\_CHAN                    = INTEGER (Given)
      }{
         number of channels per A/D
      }
      \sstsubsection{
         NUM\_ADC                     = INTEGER (Given)
      }{
         number of A/D cards
      }
      \sstsubsection{
         BOL\_SELECT\_CHAN (NUM\_CHAN $*$ NUM\_ADC)
      }{
                               = INTEGER (Returned)
         channel numbers of selected bolometers
      }
      \sstsubsection{
         BOL\_SELECT\_ADC (NUM\_CHAN $*$ NUM\_ADC)
      }{
                               = INTEGER (Returned)
         A/D card numbers of selected bolometers
      }
      \sstsubsection{
         N\_BOLS                      = INTEGER (Returned)
      }{
         total number of bolometers selected
      }
      \sstsubsection{
         MAX\_SUB                     = INTEGER (Given)
      }{
         maximum number of sub instruments
      }
      \sstsubsection{
         SUB\_INSTRMNT (MAX\_SUB)      = CHARACTER$*$($*$) (Returned)
      }{
         names of sub instrument sections to be used
      }
      \sstsubsection{
         N\_SUB                       = INTEGER (Returned)
      }{
         the number of sub instruments to be used
      }
      \sstsubsection{
         CENTRE\_DU3                  = REAL (Returned)
      }{
         Nasmyth DU3 offset from instrument centre to which telescope
         is to pointed
      }
      \sstsubsection{
         CENTRE\_DU4                  = REAL (Returned)
      }{
         Nasmyth DU4 offset from instrument centre to which telescope
         is to pointed
      }
      \sstsubsection{
         CHOP\_COORDS                 = CHARACTER$*$($*$) (Returned)
      }{
         Chopper coordinate system required
      }
      \sstsubsection{
         BOL\_SPACING                 = REAL (Returned)
      }{
         Spacing between bolometers (arcsec)
      }
      \sstsubsection{
         CHOP\_PA                     = REAL (Returned)
      }{
         Chop position angle required (degrees)
      }
      \sstsubsection{
         N\_BOL\_SUB (MAX\_SUB)         = INTEGER (Returned)
      }{
         Number of bolometers selected in each sub instrument
      }
      \sstsubsection{
         BOLS\_MEASURED               = CHARACTER$*$($*$) (Returned)
      }{
         Bolometers to be measured by transputer system
      }
      \sstsubsection{
         PHOT\_BEAM\_CHAN (3, MAX\_SUB) = INTEGER (Returned)
      }{
         Channel numbers of selected bolometers projected left, middle,
         right on sky for each sub-instrument (I index = 1 for left, 2
         for middle and 3 for right)
      }
      \sstsubsection{
         PHOT\_BEAM\_ADC (3, MAX\_SUB)  = INTEGER (Returned)
      }{
         ADC numbers of selected bolometers projected left, middle,
         right on sky for each sub-instrument
      }
      \sstsubsection{
         PHOT\_BEAM\_BOL (3, MAX\_SUB)  = INTEGER (Returned)
      }{
         The index in the array of selected bolometers of those projected
         left, middle, right on sky for each sub-instrument.
      }
      \sstsubsection{
         STATUS                      = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_POWER2
}{
   Calculate next highest power of 2
}{
   \sstdescription{
      Given a number, returns that number or the next highest
      number that is a power of 2, and returns the power itself.
      If N$<$1, GEN\_POWER2 is returned as -1, and NP2 is returned as 0.
   }
   \sstinvocation{
      I = SCULIB\_POWER2 (N, NP2)
   }
   \sstarguments{
      \sstsubsection{
         N              = INTEGER (Given)
      }{
         The number in question.
      }
      \sstsubsection{
         NP2            = INTEGER (Returned)
      }{
         The next number that is a power of 2. Returns 0 if N is less
         than 1.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         SCULIB\_POWER2  = INTEGER (Returned)
      }{
         The power of 2.  ie NP2=2$*$$*$SCULIB\_POWER2.
         Returns -1 if N is less than 1.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1992,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_PUT\_FITS\_C
}{
   write a string to a FITS item specified
}{
   \sstdescription{
      This routine  writes a FITS character item into a character array
      ready to be written out to the .MORE.FITS structure in an NDF file.
      An error will be reported and bad status returned if the name of the
      FITS item is blank or more than 8 characters long. An error will also
      occur if the FITS character array is full.
      The FITS array must contain a final entry of simply `END' unless
      N\_FITS is 0. The END entry is automatically moved to the last field
      as entries are added to the FITS array.
  }
   \sstinvocation{
       CALL SCULIB\_PUT\_FITS\_C (MAX\_FITS, N\_FITS, FITS, NAME, VALUE,
         COMMENT, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         MAX\_FITS                       = INTEGER (Given)
      }{
         the size of the FITS array
      }
      \sstsubsection{
         N\_FITS                         = INTEGER (Given and returned)
      }{
         the number of FITS items currently in the FITS array.
           This should include an `END' entry. If N\_FITS is 1 it will
           be assumed to be an array with just an `END'. If N\_FITS=0
           on entry the array will be empty and N\_FITS will be changed to 2
           on exit (the entry and the END card).
      }
      \sstsubsection{
         FITS (MAX\_FITS)                = CHARACTER$*$80 (Given and returned)
      }{
         array containing the FITS items
      }
      \sstsubsection{
         NAME                           = CHARACTER$*$($*$) (Given)
      }{
         the name of the FITS item to be written
      }
      \sstsubsection{
         VALUE                          = CHARACTER$*$($*$) (Given)
      }{
         the value to be assigned to the item
      }
      \sstsubsection{
         COMMENT                        = CHARACTER$*$($*$) (Given)
      }{
         a comment applying to the FITS item
      }
      \sstsubsection{
         STATUS                         = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995-2000 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_PUT\_FITS\_D
}{
   write a DOUBLE to a FITS item specified
}{
   \sstdescription{
      This routine  writes a FITS double precision item into a character array
      ready to be written out to the .MORE.FITS structure in an NDF file.
      An error will be reported and bad status returned if the name of the
      FITS item is blank or more than 8 characters long. An error will also
      occur if the FITS character array is full.
      The FITS array must contain a final entry of simply `END' unless
      N\_FITS is 0. The END entry is automatically moved to the last field
      as entries are added to the FITS array.
   }
   \sstinvocation{
       CALL SCULIB\_PUT\_FITS\_D (MAX\_FITS, N\_FITS, FITS, NAME, VALUE,
         COMMENT, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         MAX\_FITS                       = INTEGER (Given)
      }{
         the size of the FITS array
      }
      \sstsubsection{
         N\_FITS                         = INTEGER (Given and returned)
      }{
         The number of FITS items currently in the FITS array.
           This should include an `END' entry. If N\_FITS is 1 it will
           be assumed to be an array with just an `END'. If N\_FITS=0
           on entry the array will be empty and N\_FITS will be changed to 2
           on exit (the entry and the END card).
      }
      \sstsubsection{
         FITS (MAX\_FITS)                = CHARACTER$*$80 (Given and returned)
      }{
         array containing the FITS items
      }
      \sstsubsection{
         NAME                           = CHARACTER$*$($*$) (Given)
      }{
         the name of the FITS item to be written
      }
      \sstsubsection{
         VALUE                          = DOUBLE PRECISION (Given)
      }{
         the value to be assigned to the item
      }
      \sstsubsection{
         COMMENT                        = CHARACTER$*$($*$) (Given)
      }{
         a comment applying to the FITS item
      }
      \sstsubsection{
         STATUS                         = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_PUT\_FITS\_I
}{
   write an integer to a FITS item specified
}{
   \sstdescription{
      This routine writes a FITS integer item into a character array
      ready to be written out to the .MORE.FITS structure in an NDF file.
      An error will be reported and bad status returned if the name of the
      FITS item is blank or more than 8 characters long. An error will also
      occur if the FITS character array is full.
      The FITS array must contain a final entry of simply `END' unless
      N\_FITS is 0. The END entry is automatically moved to the last field
      as entries are added to the FITS array.
   }
   \sstinvocation{
       CALL SCULIB\_PUT\_FITS\_I (MAX\_FITS, N\_FITS, FITS, NAME, VALUE,
         COMMENT, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         MAX\_FITS                       = INTEGER (Given)
      }{
         the size of the FITS array
      }
      \sstsubsection{
         N\_FITS                         = INTEGER (Given and returned)
      }{
         The number of FITS items currently in the FITS array.
           This should include an `END' entry. If N\_FITS is 1 it will
           be assumed to be an array with just an `END'. If N\_FITS=0
           on entry the array will be empty and N\_FITS will be changed to 2
           on exit (the entry and the END card).
      }
      \sstsubsection{
         FITS (MAX\_FITS)                = CHARACTER$*$80 (Given and returned)
      }{
         array containing the FITS items
      }
      \sstsubsection{
         NAME                           = CHARACTER$*$($*$) (Given)
      }{
         the name of the FITS item to be written
      }
      \sstsubsection{
         VALUE                          = INTEGER (Given)
      }{
         the value to be assigned to the item
      }
      \sstsubsection{
         COMMENT                        = CHARACTER$*$($*$) (Given)
      }{
         a comment applying to the FITS item
      }
      \sstsubsection{
         STATUS                         = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_RAD2STRING
}{
   Translate an angle or time in radians to a nicely formatted string
}{
   \sstdescription{
      Converts an angle or time in radians to a string that can be
      used for display. The sexagesimal format is colon separated.
      For time output, the output is format SHH:MM:SS.NDP.
      For angle output, the format used is SDD:MM:SS.NDP. Note
      that the sign is used for the first character but this can
      be either blank or a {\tt '}-{\tt '}.
   }
   \sstinvocation{
      CALL SCULIB\_RAD2STRING( ANGLE, NDP, ISTIME, RESLT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         ANGLE = DOUBLE PRECISION (Given)
      }{
         Angle to be translated (radians)
      }
      \sstsubsection{
         NDP = INTEGER (Given)
      }{
         Number of decimal places to use for the seconds
         Can not be greater than 6.
      }
      \sstsubsection{
         ISTIME = LOGICAL (Given)
      }{
         If true the angle will be assumed to be a time and will
         be converted to HH:MM:SS.NDP format. If false it will be
         assumed to be an angle and converted to SDDD:MM:SS.NDP.
      }
      \sstsubsection{
         RESLT = CHARACTER (Returned)
      }{
         String containing the translated angle. Colon separated.
         Should be at least 11$+$NDP characters long.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global Status
      }
   }
   \sstnotes{
      Essentially a wrapper around SLA\_DR2AF and SLA\_DR2TF
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 2000 Particle Physics and Astronomy Research Council.
      All Rights Reserved.
   }
}


\sstroutine{
   SCULIB\_RANGED
}{
   Finds the maximum and minimum values in a double precision array
}{
   \sstdescription{
      Find the maximum and minimum values in a double precision array.
   }
   \sstinvocation{
      CALL SCULIB\_RANGED( ARRAY, IST, IEN, VMAX, VMIN, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         ARRAY( IEN ) = DOUBLE PRECISION (Given)
      }{
         Array containing the values to be checked.
      }
      \sstsubsection{
         IST = INTEGER (Given)
      }{
         The first element of ARRAY to be examined.
      }
      \sstsubsection{
         IEN = INTEGER (Given)
      }{
         The last element of ARRAY to be examined.
      }
      \sstsubsection{
         VMAX = DOUBLE PRECISION (Returned)
      }{
         The maximum value of those examined
      }
      \sstsubsection{
         VMIN = DOUBLE PRECISION (Returned)
      }{
         The minumum value of those examined
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_READ\_JIGGLE
}{
   read a jiggle pattern
}{
   \sstdescription{
      This routine reads in a jiggle pattern and sets some variables associated
      with it; the number of jiggles in the pattern, the number of jiggles to
      be measured in each exposure, the number of times the pattern will be
      repeated in each exposure, the maximum offsets in the pattern.

         After checking status on entry, SCULIB\_READ\_NUMBERS is called to read
      in the jiggle offsets from the file named in JIGGLE\_NAME, an error will
      be reported and bad status returned if no offsets are read. The maximum
      and minimum x and y offsets in the pattern are calculated.

         Next, the variables governing the way the jiggle pattern will be
      divided among the exposures making up each integration is worked out.
      An error will be reported and bad status returned if JIGGLE\_P\_SWITCH
      is less than or equal to zero. Otherwise, the number of exposures
      required to execute the whole jiggle pattern, each exposure containing
      JIGGLE\_P\_SWITCH jiggles (except perhaps the last which will hold less),
      is calculated. If JIGGLE\_P\_SWITCH is larger than the number of jiggles
      in the pattern then the jiggle pattern will be repeated an integer
      number of times during each switch of the exposure and JIGGLE\_P\_SWITCH
      will be reset accordingly.
   }
   \sstinvocation{
       CALL SCULIB\_READ\_JIGGLE (JIGGLE\_NAME, MAX\_JIGGLE,
         JIGGLE\_P\_SWITCH, JIGGLE\_REPEAT, EXP\_PER\_INT, JIGGLE\_X, JIGGLE\_Y,
         JIGGLE\_COUNT, JIGGLE\_X\_MAX, JIGGLE\_X\_MIN, JIGGLE\_Y\_MAX,
         JIGGLE\_Y\_MIN, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         JIGGLE\_NAME            = CHARACTER$*$($*$) (Given)
      }{
         the name of the file containing the jiggle pattern
      }
      \sstsubsection{
         MAX\_JIGGLE             = INTEGER (Given)
      }{
         the maximum number of jiggles that can be read
      }
      \sstsubsection{
         JIGGLE\_P\_SWITCH        = INTEGER (Given and returned)
      }{
         the requested (given) and actual (returned) number of jiggles
         that will be performed in each exposure of the integration
      }
      \sstsubsection{
         JIGGLE\_REPEAT          = INTEGER (Returned)
      }{
         the number of times the jiggle pattern wil be repeated in each
         exposure
      }
      \sstsubsection{
         EXP\_PER\_INT            = INTEGER (Returned)
      }{
         the number of exposures required per integration
      }
      \sstsubsection{
         JIGGLE\_X (MAX\_JIGGLE)  = REAL (Returned)
      }{
         the x jiggle offsets
      }
      \sstsubsection{
         JIGGLE\_Y (MAX\_JIGGLE)  = REAL (Returned)
      }{
         the y jiggle offsets
      }
      \sstsubsection{
         JIGGLE\_COUNT           = INTEGER (Returned)
      }{
         the number of jiggles in the pattern
      }
      \sstsubsection{
         JIGGLE\_X\_MAX           = REAL (Returned)
      }{
         the maximum jiggle offset in the x axis
      }
      \sstsubsection{
         JIGGLE\_X\_MIN
      }{
         the minimum jiggle offset in the x axis
      }
      \sstsubsection{
         JIGGLE\_Y\_MAX           = REAL (Returned)
      }{
         the maximum jiggle offset in the y axis
      }
      \sstsubsection{
         JIGGLE\_Y\_MIN
      }{
         the minimum jiggle offset in the y axis
      }
      \sstsubsection{
         STATUS =       INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_READ\_NUMBERS
}{
   routine to read numbers from an ASCII file
}{
   \sstdescription{
      This routine reads a file of ASCII numbers. The name of the file
      is specified by FILENAME, and the routine assumes that the numbers
      are in NARRAY columns each containing SIZE numbers. The maximum
      value for NARRAY is 3. The read operation itself is free format.
      An error will be returned if there is trouble reading from the
      file. A warning will be given if there are more numbers in the
      file than can be read into the arrays.
   }
   \sstinvocation{
       CALL SCULIB\_READ\_NUMBERS (FILENAME, NARRAY, SIZE,
          ARRAY1, ARRAY2, ARRAY3, LENGTH, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         FILENAME         = CHARACTER$*$($*$) (Given)
      }{
         Name of file containing numbers
      }
      \sstsubsection{
         NARRAY           = INTEGER (Given)
      }{
         Number of columns in file ($<$=3)
      }
      \sstsubsection{
         SIZE             = INTEGER (Given)
      }{
         Dimension of arrays
      }
      \sstsubsection{
         ARRAY1 (SIZE)    = REAL (Returned)
      }{
         Output array to contain first column of numbers
      }
      \sstsubsection{
         ARRAY2 (SIZE)    = REAL (Returned)
      }{
         Output array to contain second column of numbers (if present)
      }
      \sstsubsection{
         ARRAY3 (SIZE)    = REAL (Returned)
      }{
         Output array to contain third column of numbers (if present)
      }
      \sstsubsection{
         LENGTH           = INTEGER (Returned)
      }{
         Number of items read into output arrays
      }
      \sstsubsection{
         STATUS = INTEGER (Given and returned)
      }{
         Global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_READ\_SKY
}{
   read sky parameters from a named file
}{
   \sstdescription{
      This routine reads sky and telescope parameters for each SCUBA
      sub-instrument/filter combination from an ASCII file named in FILE.
      The format of each line in the file that contains sky information is
      assumed to be:-

         FIT1 $<$qual$>$ $<$sub$>$ $<$filter$>$ $<$eta\_tel$>$ $<$b$>$ $<$tauz$>$ $<$date$>$ $<$day$>$ $<$run$>$

      The values returned for a given filter/sub-instrument will be from the
      good quality entry ($<$qual$>$ = 0) with the highest associated $<$day$>$ number
      in the file.

      Errors will be reported and bad status returned if;

      \sstitemlist{

         \sstitem
           there is an error opening or reading from the file

         \sstitem
           $<$qual$>$ does not convert to an integer

         \sstitem
           $<$sub$>$ is not one of SHORT, LONG, P1100, P1300, P2000

         \sstitem
           $<$eta\_tel$>$ does not convert to a real

         \sstitem
           $<$b$>$ does not convert to a real

         \sstitem
           $<$tauz$>$ does not convert to a real

         \sstitem
           $<$run$>$ does not convert to an integer

         \sstitem
           More than MAX\_SKY combinations are read.

      }
      Blank lines are ignored as are those parts of lines following
      a ! character (comments) and lines not beginning with the word FIT1.

      This routine reads a file written by SCUDR\_END\_SKYDIP, so these 2
      routines should be changed together when necessary.

      If the file name is {\tt '}NULL{\tt '} (case insensitive) then the sky parameters
      will be reset to null values.
   }
   \sstinvocation{
       CALL SCULIB\_READ\_SKY (FILE, MAX\_SKY, N\_SKY, SUB,
         FILTER, ETA\_TEL, B, TAUZ, DATEM, DAY, RUN, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         FILE                              = CHARACTER$*$($*$) (Given)
      }{
         the name of the file
      }
      \sstsubsection{
         MAX\_SKY                           = INTEGER (Given)
      }{
         the maximum number of sub-instrument/filter combinations
      }
      \sstsubsection{
         N\_SKY                             = INTEGER (Returned)
      }{
         the number of sub-instrument/filter combinations read
      }
      \sstsubsection{
         SUB (MAX\_SKY)                     = CHARACTER$*$($*$) (Returned)
      }{
         the name of the sub-instrument
      }
      \sstsubsection{
         FILTER (MAX\_SKY)                  = CHARACTER$*$($*$) (Returned)
      }{
         the name of the filter
      }
      \sstsubsection{
         ETA\_TEL (MAX\_SKY)                 = REAL (Returned)
      }{
         telescope transmission
      }
      \sstsubsection{
         B (MAX\_SKY)                       = REAL (Returned)
      }{
         atmospheric bandwidth b factor
      }
      \sstsubsection{
         TAUZ (MAX\_SKY)                    = REAL (Returned)
      }{
         zenith atmospheric optical depth
      }
      \sstsubsection{
         DATEM (MAX\_SKY)                   = CHARACTER$*$($*$) (Returned)
      }{
         the date on which a measurement was made
      }
      \sstsubsection{
         DAY (MAX\_SKY)                     = DOUBLE PRECISION (Returned)
      }{
         the date and time at which the measurement was made, measured
         as a day number from 1st Jan
      }
      \sstsubsection{
         RUN (MAX\_SKY)                     = INTEGER (Returned)
      }{
         the run number of a measurement
      }
      \sstsubsection{
         STATUS                            = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_READ\_TAUZ
}{
   read sky zenith optical depths from a named file
}{
   \sstdescription{
      This routine reads filter names and associated sky zenith opacities
      from an ASCII file named in FILE. The format of each line in the file
      that contains sky information is assumed to be:-

       FIT1 $<$qual$>$ $<$sub\_inst$>$ $<$filter$>$ $<$eta\_tel$>$ $<$b$>$ $<$tauz$>$ $<$date$>$ $<$day$>$ $<$run$>$

      Errors will be reported and bad status returned if;

      \sstitemlist{

         \sstitem
           there is an error opening or reading the file

         \sstitem
           $<$qual$>$ is not an integer

         \sstitem
           $<$sub-inst$>$ is not one of SHORT, LONG, P1100, P1300, P2000

         \sstitem
           $<$eta\_tel$>$ does not convert to a real

         \sstitem
           $<$b$>$ does not convert to a real

         \sstitem
           $<$tauz$>$ does not convert to a real

         \sstitem
           $<$day$>$ does not convert to a double

         \sstitem
           $<$run$>$ does not convert to an integer

      }
      The value of tauz returned for a given filter will be the good
      quality entry ($<$qual$>$ = 0) with the highest associated $<$day$>$ number
      in the file.

      Blank lines are ignored as are those parts of lines following
      a ! character (comments) and any line whose first line is not
      FIT1.

      This routine reads a file written by SCUDR\_END\_SKYDIP, so these 2
      routines should be changed together when necessary.
   }
   \sstinvocation{
       CALL SCULIB\_READ\_TAUZ (FILE, MAX\_FILT, N\_FILT, FILTER,
         TAUZ, DATEM, DAY, RUN, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         FILE                              = CHARACTER$*$($*$) (Given)
      }{
         the name of the file
      }
      \sstsubsection{
         MAX\_FILT                          = INTEGER (Given)
      }{
         the maximum number of filters
      }
      \sstsubsection{
         N\_FILT                            = INTEGER (Returned)
      }{
         the number of filters read
      }
      \sstsubsection{
         FILTER (MAX\_FILT)                 = CHARACTER$*$($*$) (Returned)
      }{
         the names of the filters
      }
      \sstsubsection{
         TAUZ (MAX\_FILT)                   = REAL (Returned)
      }{
         zenith atmospheric optical depth for that filter
      }
      \sstsubsection{
         DATEM (MAX\_FILT)                  = CHARACTER$*$($*$) (Returned)
      }{
         the date on which the measurement was made
      }
      \sstsubsection{
         DAY (MAX\_FILT)                    = DOUBLE PRECISION (Returned)
      }{
         the date and time at which the measurement was made, measured
         as a day number from 1st Jan
      }
      \sstsubsection{
         RUN (MAX\_FILT)                    = INTEGER (Returned)
      }{
         the run number of the measurement
      }
      \sstsubsection{
         STATUS                            = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_READBOLS
}{
   read bolometer data from a name file
}{
   \sstdescription{
      This routine reads bolometer data from an ASCII file named in
      FILE. The format of the file is assumed to be:-

\texttt{
       proc SET\_BOLS \\
       \{ flat field data file written by SCUDR \\
       \{ Tues Apr 20 18:09:20 1993\\
       \{ observation run number 6\\
       \{ long-wave array\\
         SETBOL name type du3 du4 calib theta a b qual day run ref\\
            "     ditto for other long-wave array bolometers    "\\
       \{ short-wave array
         SETBOL name type du3 du4 calib theta a b qual day run ref\\
            "     ditto for other short-wave array bolometers   "\\
       \{ P1100\\
         SETBOL name type du3 du4 calib theta a b qual day run ref\\
       \{ P1300\\
         SETBOL name type du3 du4 calib theta a b qual day run ref\\
       \{ P2000\\
         SETBOL name type du3 du4 calib theta a b qual day run ref\\
       end proc\\
}

      where:-

$<$name$>$ is the name of a bolometer (e.g. a16), case insensitive\\
$<$type$>$ is the type of the bolometer, e.g. SHORT, LONG, P1100, P1300,
          P2000\\
$<$du3$>$ is the Nasmyth DU3 coordinate of the bolometer\\
$<$du4$>$ is the Nasmyth DU4 coordinate of the bolometer\\
$<$calib$>$ is the flat-field value of the bolometer\\
$<$theta$>$ is the angle between x axis an `a{\tt '} axis of fitted ellipse\\
$<$a$>$ is the semi-length of the `a{\tt '} axis\\
$<$b$>$ is the semi-length of the `b{\tt '} axis\\
$<$qual$>$ is the quality of the bolometer; 0=good, 1=bad\\
$<$day$>$ is the date when the information was measured, in days from 1 Jan\\
$<$run$>$ is the number of the run when the information was measured\\
$<$ref$>$ is the name of the reference bolometer\\

      Values for bolometers that are not specified in the file will be set
      to default values; {\tt '}BAD{\tt '} for strings, 0 for all other values except
      BOL\_QUAL which will be 1.

      Errors will be reported and bad status returned if:-

      \sstitemlist{

         \sstitem
          $<$name$>$ is not a valid bolometer name

         \sstitem
          $<$du3$>$, $<$du4$>$, $<$calib$>$, $<$theta$>$, $<$a$>$, $<$b$>$ do not convert to reals

         \sstitem
          $<$qual$>$, $<$run$>$ do not convert to integers

         \sstitem
          $<$day$>$ does not convert to double

         \sstitem
          An attempt is made to set values for a bolometer twice

      }
      Each line in the file will be converted to upper case. Characters to the
      right of a \{ character in a line will be treated as comments and ignored.
   }
   \sstinvocation{
       CALL SCULIB\_READBOLS (FILE, NUM\_CHAN, NUM\_ADC, BOL\_TYPE,
         BOL\_DU3, BOL\_DU4, BOL\_CALIB, BOL\_THETA, BOL\_A, BOL\_B,
         BOL\_QUAL, BOL\_DAY, BOL\_RUN, BOL\_REF, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         FILE                              = CHARACTER$*$($*$) (Given)
      }{
         the name of the file
      }
      \sstsubsection{
         NUM\_CHAN                          = INTEGER (Given)
      }{
         number of channels per ADC
      }
      \sstsubsection{
         NUM\_ADC                           = INTEGER (Given)
      }{
         number of ADC cards
      }
      \sstsubsection{
         BOL\_TYPE (NUM\_CHAN, NUM\_ADC)      = CHARACTER$*$($*$) (Returned)
      }{
         the type of bolometer; SHORT, LONG, P1100, etc.
      }
      \sstsubsection{
         BOL\_DU3 (NUM\_CHAN, NUM\_ADC)       = REAL (Returned)
      }{
         the DU3 Nasmyth coordinate of the bolometer
      }
      \sstsubsection{
         BOL\_DU4 (NUM\_CHAN, NUM\_ADC)       = REAL (Returned)
      }{
         the DU4 Nasmyth coordinate of the bolometer
      }
      \sstsubsection{
         BOL\_CALIB (NUM\_CHAN, NUM\_ADC)     = REAL (Returned)
      }{
         the target calibration of the bolometer
      }
      \sstsubsection{
         BOL\_THETA (NUM\_CHAN, NUM\_ADC)     = REAL (Returned)
      }{
         angle between x axis and `a{\tt '} axis of fitted ellipse (radians)
      }
      \sstsubsection{
         BOL\_A (NUM\_CHAN, NUM\_ADC)         = REAL (Returned)
      }{
         half length of `a{\tt '} axis of fitted ellipse
      }
      \sstsubsection{
         BOL\_B (NUM\_CHAN, NUM\_ADC)         = REAL (Returned)
      }{
         half length of `b{\tt '} axis of fitted ellipse
      }
      \sstsubsection{
         BOL\_QUAL (NUM\_CHAN, NUM\_ADC)      = INTEGER (Returned)
      }{
         the bolometer quality
      }
      \sstsubsection{
         BOL\_DAY (NUM\_CHAN, NUM\_ADC)       = DOUBLE PRECISION (Returned)
      }{
         the date when the bolometer was measured
      }
      \sstsubsection{
         BOL\_RUN (NUM\_CHAN, NUM\_ADC)       = INTEGER (Returned)
      }{
         the run when the bolometer was measured
      }
      \sstsubsection{
         BOL\_REF (NUM\_CHAN, NUM\_ADC)       = CHARACTER$*$($*$) (Returned)
      }{
         the name of the reference bolometer used
      }
      \sstsubsection{
         STATUS                            = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_REDUCE\_SWITCH
}{
   reduce the demodulated data from the switches of
   an exposure into the exposure result
}{
   \sstdescription{
      This routine reduces the switches in an exposure to give the
      exposure result, and returns the weight to be given to the
      specified projected bolometer position when combining different
      projected bolometers into the result for a sub-instrument.
        Exposure results are calculated assuming that:-

      For a SQUARE chop-function -\\
       switch 1 has the object in the R beam of the `middle{\tt '} projected
       bolometer and in the L beam of the `right{\tt '} bolometer.\\
       switch 2 has the object in the L beam of the `middle{\tt '} bolometer
       and in R beam of the `left{\tt '} bolometer.

      For a TRIPOS (3-position) chop-function -\\
       switch 1 has the object in the M beam of the `middle{\tt '} bolometer,
       in the L beam of the right and the R beam of the `left{\tt '}.\\
       switch 2 has the object in the R beam of the `middle{\tt '} bolometer
       and in the M beam of the `right{\tt '}.\\
       switch 3 has the object in the L beam of the `middle{\tt '} bolometer
       and in the M beam of the `left{\tt '}.

      The reduction method depends on the number of switches taken per
      exposure, the chop function used and the projected beam that the
      bolometers are assumed to be in.

      SWITCH\_PER\_EXP = 1\\
         CHOP\_FUN = SQUARE (SCUBAWAVE or RAMPWAVE)\\
            left bolometer = BAD (was never looking at source), weight =  0.0\\
          middle bolometer = switch 1, weight = 1.0\\
           right bolometer = - switch 1, weight = 1.0\\
         CHOP\_FUN = TRIPOS\\
            left bolometer = - 2 $*$ switch 1, weight = 0.5\\
          middle bolometer = switch 1, weight = 1.0\\
           right bolometer = - 2 $*$ switch 1, weight = 0.5\\

      SWITCH\_PER\_EXP = 2\\
         CHOP\_FUN = SQUARE\\
            left bolometer = switch 2 - switch 1, weight = 0.5\\
          middle bolometer = (switch 1 - switch 2) / 2, weight = 1.0\\
           right bolometer = switch 2 - switch 1, weight = 0.5\\
         CHOP\_FUN = TRIPOS\\
            left bolometer = - 2 $*$ (switch 1 - switch 2), weight = 0.5\\
          middle bolometer = 2/3 $*$ (switch 1 - switch 2), weight = 1.5\\
           right bolometer = -2/3 $*$ (switch 1 - switch 2), weight = 1.5\\

      SWITCH\_PER\_EXP = 3\\
         CHOP\_FUN = SQUARE\\
            error\\
         CHOP\_FUN = TRIPOS\\
            left bolometer = -1/2 $*$ (2 $*$ switch 1 - (switch 2 $+$ switch 3)),
                             weight = 2/3\\
          middle bolometer = 1/3 $*$ (2 $*$ switch 1 - (switch 2 $+$ switch 3)),
                             weight = 1.0\\
           right bolometer = -1/2 $*$ (2 $*$ switch 1 - (switch 2 $+$ switch 3)),
                             weight = 2/3

      Any other combinations of parameters will give rise to an error report
      and the routine will return with bad status.
   }
   \sstinvocation{
       CALL SCULIB\_REDUCE\_SWITCH (CHOP\_FUN, SWITCH\_PER\_EXP,
         N\_DATA,
         SWITCH\_1\_DATA, SWITCH\_1\_VARIANCE, SWITCH\_1\_QUALITY,
         SWITCH\_2\_DATA, SWITCH\_2\_VARIANCE, SWITCH\_2\_QUALITY,
         SWITCH\_3\_DATA, SWITCH\_3\_VARIANCE, SWITCH\_3\_QUALITY,
         BEAM,
         EXP\_DATA, EXP\_VARIANCE, EXP\_QUALITY, WEIGHT, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         CHOP\_FUN                              = CHARACTER$*$($*$) (Given)
      }{
         the chop function used
      }
      \sstsubsection{
         SWITCH\_PER\_EXP                        = INTEGER (Given)
      }{
         the number of switches per exposure
      }
      \sstsubsection{
         N\_DATA                                = INTEGER (Given)
      }{
         the number of measurements
      }
      \sstsubsection{
         SWITCH\_1\_DATA (N\_DATA)                = REAL (Given)
      }{
         data for switch 1
      }
      \sstsubsection{
         SWITCH\_1\_VARIANCE (N\_DATA)            = REAL (Given)
      }{
         variance for switch 1
      }
      \sstsubsection{
         SWITCH\_1\_QUALITY (N\_DATA)             = BYTE (Given)
      }{
         quality for switch 1
      }
      \sstsubsection{
         SWITCH\_2\_DATA (N\_DATA)                = REAL (Given)
      }{
         likewise for switch 2
      }
      \sstsubsection{
         SWITCH\_2\_VARIANCE (N\_DATA)            = REAL (Given)
      }{
      }
      \sstsubsection{
         SWITCH\_2\_QUALITY (N\_DATA)             = BYTE (Given)
      }{
      }
      \sstsubsection{
         SWITCH\_3\_DATA (N\_DATA)                = REAL (Given)
      }{
         and switch 3
      }
      \sstsubsection{
         SWITCH\_3\_VARIANCE (N\_DATA)            = REAL (Given)
      }{
      }
      \sstsubsection{
         SWITCH\_3\_QUALITY (N\_DATA)             = BYTE (Given)
      }{
      }
      \sstsubsection{
         BEAM                                  = INTEGER (Given)
      }{
         the projected beam assumed for the bolometers; 1 = LEFT
         2 = MIDDLE, 3 = RIGHT
      }
      \sstsubsection{
         EXP\_DATA (N\_DATA)                     = REAL (Returned)
      }{
         the exposure result
      }
      \sstsubsection{
         EXP\_VARIANCE (N\_DATA)                 = REAL (Returned)
      }{
         the variance on the result
      }
      \sstsubsection{
         EXP\_QUALITY (N\_DATA)                  = BYTE (Returned)
      }{
         the quality on the result
      }
      \sstsubsection{
         WEIGHT                                = REAL (Returned)
      }{
         the relative weight to assign to this projected-beam compared
         to the others when adding them together to give a final result
      }
      \sstsubsection{
         STATUS                                = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_REMOVE\_DEMOD\_INT
}{
   remove demodulated data for one sub-instrument
   in an integration from a coadded result
}{
   \sstdescription{
      This routine removes the demodulated data for a specified sub-instrument
      and integration from the coadded measurement.

        After checking status on entry the routine cycles through the
      bolometers for which data has been taken. If the bolometer belongs
      to the sub-instrument whose data is to be removed, the routine will
      then cycle through the jiggle pattern removing the integration data
      from the coadd. If this reduces the number of coadded integrations
      to 0 then all the coadd numbers are set to 0 apart from quality,
      which is set to 1. If the number of coadded integrations is reduced
      to 1 then the coadd variance can no longer be estimated from the
      spread of data about the mean and will be set to 0.
   }
   \sstinvocation{
       CALL SCULIB\_REMOVE\_DEMOD\_INT (REMOVE\_TYPE, NUM\_CHAN,
         NUM\_ADC, BOL\_TYPE, N\_BOLS, BOL\_CHAN, BOL\_ADC, J\_COUNT,
         INT\_DATA, INT\_QUALITY, COADD\_DATA, COADD\_VARIANCE,
         COADD\_QUALITY, COADD\_NUMBER, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         REMOVE\_TYPE                   = CHARACTER$*$($*$) (Given)
      }{
         the type of the sub-instrument whose data is to be removed
      }
      \sstsubsection{
         NUM\_CHAN                      = INTEGER (Given)
      }{
         the number of channels per ADC in SCUBA
      }
      \sstsubsection{
         NUM\_ADC                       = INTEGER (Given)
      }{
         the number of ADCs in SCUBA
      }
      \sstsubsection{
         BOL\_TYPE (NUM\_CHAN, NUM\_ADC)  = CHARACTER$*$($*$) (Given)
      }{
         the types of the bolometers in SCUBA
      }
      \sstsubsection{
         N\_BOLS                        = INTEGER (Given)
      }{
         the number of bolometers being measured
      }
      \sstsubsection{
         BOL\_CHAN (N\_BOLS)             = INTEGER (Given)
      }{
         the channel numbers of the bolometers being measured
      }
      \sstsubsection{
         BOL\_ADC (N\_BOLS)              = INTEGER (Given)
      }{
         the ADC numbers of the bolometers being measured
      }
      \sstsubsection{
         J\_COUNT                       = INTEGER (Given)
      }{
         the number of jiggle positions in the pattern
      }
      \sstsubsection{
         INT\_DATA (N\_BOLS, J\_COUNT)    = REAL (Given)
      }{
         the integration data
      }
      \sstsubsection{
         INT\_QUALITY (N\_BOLS, J\_COUNT) = INTEGER (Given)
      }{
         quality on the integration data
      }
      \sstsubsection{
         COADD\_DATA (N\_BOLS, J\_COUNT)  = REAL (Given and returned)
      }{
         the mean of the coadded data
      }
      \sstsubsection{
         COADD\_VARIANCE (N\_BOLS, J\_COUNT)
      }{
                                 = REAL (Given and returned)
         the variance on the mean of the coadded data
      }
      \sstsubsection{
         COADD\_QUALITY (N\_BOLS, J\_COUNT)
      }{
                                 = INTEGER (Given and returned)
         the quality on the mean of the coadded data
      }
      \sstsubsection{
         COADD\_NUMBER (N\_BOLS, J\_COUNT)= INTEGER (Given and returned)
      }{
         the number of data coadded
      }
      \sstsubsection{
         STATUS                        = INTEGER (Given and returned)
      }{
         the global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_REMOVE\_LINEAR\_BASELINE
}{
   Remove linear baseline from each exposure
}{
   \sstdescription{
      This routine takes a data array. It then removes a linear baseline
      from each scan. The ends of the scan are the size of the chop throw
      (should be no source at the ends of a scan)
   }
   \sstinvocation{
       CALL SCULIB\_REMOVE\_LINEAR\_BASELINE(DORLB, N\_EXPOSURES,
            N\_INTEGRATIONS, N\_MEASUREMENTS, DEM\_PNTR, N\_BOL, N\_POS,
            IN\_DATA, IN\_QUALITY, SAMPLE\_DX, CHOP\_THROW, OUT\_DATA,
            OUT\_QUALITY, BADBIT, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         DORLB                       = LOGICAL (Given)
      }{
         control whether we are subtracting the baseline (TRUE)
         or storing the basline (FALSE)
      }
      \sstsubsection{
         N\_EXPOSURES                 = INTEGER (Given)
      }{
         maximum number of exposures per integration
      }
      \sstsubsection{
         N\_INTEGRATIONS              = INTEGER (Given)
      }{
         number of integrations in the observation
      }
      \sstsubsection{
         N\_MEASUREMENTS              = INTEGER (Given)
      }{
         number of measurements in the observation
      }
      \sstsubsection{
         DEMOD\_POINTER (N\_EXPOSURES, N\_INTEGRATIONS, N\_MEASUREMENTS) = INTEGER (Given)
      }{
         array pointing to start and finish of scans in IN\_DATA
      }
      \sstsubsection{
         N\_BOL                       = INTEGER (Given)
      }{
         the number of bolometers for which data was taken
      }
      \sstsubsection{
         N\_POS                       = INTEGER (Given)
      }{
         the number of positions measured in the scan
      }
      \sstsubsection{
         IN\_DATA (N\_BOL, N\_POS)      = REAL (Given)
      }{
         the measured data
      }
      \sstsubsection{
         IN\_VARIANCE (N\_BOL, N\_POS)      = REAL (Given)
      }{
         the measured variance
      }
      \sstsubsection{
         IN\_QUALITY (N\_BOL, N\_POS)   = BYTE (Given)
      }{
         the quality on IN\_DATA
      }
      \sstsubsection{
         NSTART                      = INTEGER (Given)
      }{
         Number of points used for fit at start of scan
      }
      \sstsubsection{
         NEND                        = INTEGER (Given)
      }{
         Number of points from end of scan
      }
      \sstsubsection{
         OUT\_DATA (N\_BOL, N\_POS)     = REAL (Returned)
      }{
         the data with baseline removed
      }
      \sstsubsection{
         OUT\_VARIANCE (N\_BOL, N\_POS)      = REAL (Given)
      }{
         the output variance
      }
      \sstsubsection{
         OUT\_QUALITY (N\_BOL, N\_POS)  = BYTE (Returned)
      }{
         the quality on OUT\_DATA
      }
      \sstsubsection{
         BADBIT                      = BYTE (Given)
      }{
         bad bit mask
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         Global Status value
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_REMOVE\_OPACITY
}{
   remove sky opacity from demodulated data
}{
   \sstdescription{
      This routine corrects demodulated data for the effect of sky opacity.
      All data is corrected assuming the same airmass of observation, but
      the zenith sky opacity used will depend which SCUBA sub-instrument each
      bolometer belongs to.

        After checking status on entry, the routine will loop through the
      bolometers measured. For each bolometer it will then ascertain the
      appropriate zenith sky opacity from the parent sub-instrument and
      wavelength of observation. The total sky optical depth will then
      be calculated and, if this is in the range 0 to 20, the flux correction
      factor derived. The routine will then loop through the positions
      measured by this bolometer, correcting the fluxes and variances.
      If the bolometer data quality was bad, or if sky optical depth lay
      outside the above range, the data quality will be set bad and no
      correction applied.
   }
   \sstinvocation{
       CALL SCULIB\_REMOVE\_OPACITY (N\_BOLS, N\_POS,
         BOL\_SELECT\_CHAN, BOL\_SELECT\_ADC, NUM\_CHAN, NUM\_ADC, BOL\_TYPE,
         N\_SUB, SUB\_INSTRUMENT, TAUZ, AIRMASS, EXP\_DATA, EXP\_VARIANCE,
         EXP\_QUALITY, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         N\_BOLS                        = INTEGER (Given)
      }{
         the number of bolometers measured
      }
      \sstsubsection{
         N\_POS                         = INTEGER (Given)
      }{
         the number of positions they were measured at
      }
      \sstsubsection{
         BOL\_SELECT\_CHAN (N\_BOLS)      = INTEGER (Given)
      }{
         the channel numbers of the measured bolometers
      }
      \sstsubsection{
         BOL\_SELECT\_ADC (N\_BOLS)       = INTEGER (Given)
      }{
         the ADC numbers of the measured bolometers
      }
      \sstsubsection{
         NUM\_CHAN                      = INTEGER (Given)
      }{
         the number of channels per ADC
      }
      \sstsubsection{
         NUM\_ADC                       = INTEGER (Given)
      }{
         the number of ADCs
      }
      \sstsubsection{
         BOL\_TYPE (NUM\_CHAN, NUM\_ADC)  = CHARACTER$*$($*$) (Given)
      }{
         the type of the bolometer on each channel
      }
      \sstsubsection{
         N\_SUB                         = INTEGER (Given)
      }{
         the number of SCUBA sub-instruments being measured
      }
      \sstsubsection{
         SUB\_INSTRUMENT (N\_SUB)        = CHARACTER$*$($*$)
      }{
         the names of the sub-instruments being measured
      }
      \sstsubsection{
         TAUZ (NSUB)                   = REAL (Given)
      }{
         the zenith sky opacity for each sub-instrument
      }
      \sstsubsection{
         AIRMASS                       = REAL (Given)
      }{
         the airmass at which the observations were made
      }
      \sstsubsection{
         EXP\_DATA (N\_BOLS, N\_POS)      = REAL (Given and returned)
      }{
         the bolometer data
      }
      \sstsubsection{
         EXP\_VARIANCE (N\_BOLS, N\_POS)  = REAL (Given and returned)
      }{
         the variance on the data
      }
      \sstsubsection{
         EXP\_QUALITY (N\_BOLS, N\_POS)   = REAL (Given and returned)
      }{
         the quality on the data
      }
      \sstsubsection{
         STATUS                        = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_REM\_SKY
}{
   To remove sky background from SCUBA data
}{
   \sstdescription{
      This routine goes through each jiggle position in turn, finding
      the sky background level by using the selected SKY bolometers.
      This level is removed from each bolometer.
      The background level is determined by the median of the SKY data
      for each jiggle.
      If requested, via ADD\_BACK, the mean of the level that was
      removed is added back onto the data so that flux is conserved
      in the image.
   }
   \sstinvocation{
       CALL SCULIB\_REM\_SKY(MODE, ADD\_BACK, N\_BOLS, N\_POS, SCUDATA,
            SCUVAR, SCUQUAL, CLIP, N\_SKYBOLS, SKYBOLS, BADBIT, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         MODE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Clip mode
      }
      \sstsubsection{
         ADD\_BACK = LOGICAL (Given)
      }{
         Add the mean removed level back onto the final data set. (if TRUE)
      }
      \sstsubsection{
         N\_BOLS = INTEGER (Given)
      }{
         Number of bolometers in data set
      }
      \sstsubsection{
         N\_POS = INTEGER (Given)
      }{
         Number of jiggle positions in data set
      }
      \sstsubsection{
         SCUDATA(N\_BOLS, N\_POS) = REAL (Given \& Returned)
      }{
         The data
      }
      \sstsubsection{
         SCUVAR(N\_BOLS, N\_POS) = REAL (Given \& Returned)
      }{
         The variance on the data
      }
      \sstsubsection{
         SCUQUAL(N\_BOLS, N\_POS) = BYTE (Given \& Returned)
      }{
         The data quality
      }
      \sstsubsection{
         CLIP = \_REAL (Given)
      }{
         Iterative sigma clipping level
      }
      \sstsubsection{
         N\_SKYBOLS = INTEGER (Given)
      }{
         Number of sky bolometers
      }
      \sstsubsection{
         SKYBOLS (N\_SKYBOLS) = INTEGER (Given)
      }{
         List of sky bolometers
      }
      \sstsubsection{
         BADBIT = BYTE (Given)
      }{
         Bad bit mask
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         Global Status value
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_REWRITE\_FITS\_C
}{
   rewrite the value of specified FITS character keyword
}{
   \sstdescription{
      This routine will overwrite the value of a specified FITS character
      keyword held in the FITS extension of an NDF file. The FITS extension
      must have been read into the input array FITS before this routine is
      called and be written out again afterwards for the change to take effect.

         The routine assumes that each line in the FITS array will contain
      a string with format:-

       {\tt "}KEYWORD={\tt '}VALUE{\tt '}           / this is a comment{\tt "}

      It will search the input array for a line containing the required
      keyword and replace VALUE. If the keyword is not found an error will
      be reported and bad status returned. If the keyword is found but the
      line does not conform to the above format an error will be reported
      and bad status returned.
   }
   \sstinvocation{
       CALL SCULIB\_REWRITE\_FITS\_C (MAX\_FITS, N\_FITS, FITS, NAME,
         VALUE, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         MAX\_FITS             = INTEGER (Given)
      }{
         the maximum number of items in the FITS array
      }
      \sstsubsection{
         N\_FITS               = INTEGER (Given)
      }{
         the actual number of items in the FITS array
      }
      \sstsubsection{
         FITS (MAX\_FITS)      = CHARACTER$*$($*$) (Given and returned)
      }{
         array containing the FITS items
      }
      \sstsubsection{
         NAME                 = CHARACTER$*$($*$) (Given)
      }{
         the name of the FITS keyword whose value is to be changed
      }
      \sstsubsection{
         VALUE                = CHARACTER$*$($*$) (Given)
      }{
         the value that the FITS keyword is to have
      }
      \sstsubsection{
         STATUS               = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_REWRITE\_FITS\_I
}{
   rewrite the value of specified FITS integer keyword
}{
   \sstdescription{
      This routine will overwrite the value of a specified FITS integer
      keyword held in the FITS extension of an NDF file. The FITS extension
      must have been read into the input array FITS before this routine is
      called and be written out again afterwards for the change to take effect.

         The routine assumes that each line in the FITS array will contain
      a string with format:-

       {\tt "}KEYWORD=VALUE           / this is a comment{\tt "}

      It will search the input array for a line containing the required
      keyword and replace VALUE. If the keyword is not found an error will
      be reported and bad status returned. If the keyword is found but the
      line does not conform to the above format an error will be reported
      and bad status returned.
   }
   \sstinvocation{
       CALL SCULIB\_REWRITE\_FITS\_I (MAX\_FITS, N\_FITS, FITS, NAME,
         VALUE, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         MAX\_FITS             = INTEGER (Given)
      }{
         the maximum number of items in the FITS array
      }
      \sstsubsection{
         N\_FITS               = INTEGER (Given)
      }{
         the actual number of items in the FITS array
      }
      \sstsubsection{
         FITS (MAX\_FITS)      = CHARACTER$*$($*$) (Given and returned)
      }{
         array containing the FITS items
      }
      \sstsubsection{
         NAME                 = CHARACTER$*$($*$) (Given)
      }{
         the name of the FITS keyword whose value is to be rewritten
      }
      \sstsubsection{
         VALUE                = INTEGER (Given)
      }{
         the value that the FITS keyword is to have
      }
      \sstsubsection{
         STATUS               = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_REWRITE\_FITS\_R
}{
   rewrite the value of specified FITS real keyword
}{
   \sstdescription{
      This routine will overwrite the value of a specified FITS real
      keyword held in the FITS extension of an NDF file. The FITS extension
      must have been read into the input array FITS before this routine is
      called and be written out again afterwards for the change to take effect.

         The routine assumes that each line in the FITS array will contain
      a string with format:-

       {\tt "}KEYWORD=VALUE           / this is a comment{\tt "}

      It will search the input array for a line containing the required
      keyword and replace VALUE. If the keyword is not found an error will
      be reported and bad status returned. If the keyword is found but the
      line does not conform to the above format an error will be reported
      and bad status returned.
   }
   \sstinvocation{
       CALL SCULIB\_REWRITE\_FITS\_R (MAX\_FITS, N\_FITS, FITS, NAME,
         VALUE, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         MAX\_FITS             = INTEGER (Given)
      }{
         the maximum number of items in the FITS array
      }
      \sstsubsection{
         N\_FITS               = INTEGER (Given)
      }{
         the actual number of items in the FITS array
      }
      \sstsubsection{
         FITS (MAX\_FITS)      = CHARACTER$*$($*$) (Given and returned)
      }{
         array containing the FITS items
      }
      \sstsubsection{
         NAME                 = CHARACTER$*$($*$) (Given)
      }{
         the name of the FITS keyword whose value is to be rewritten
      }
      \sstsubsection{
         VALUE                = REAL (Given)
      }{
         the value that the FITS keyword is to have
      }
      \sstsubsection{
         STATUS               = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_SCAN\_2\_RD
}{
   Calculate the apparent RA/Dec of a scan
}{
   \sstdescription{
      The start and end of each scan is calculated in different
      coordinate systems dependent on the coordinate system of the
      tracking centre.
      This routine calculates the apparent RA/DEC centre for
      the supplied long and Lat using knowledge of the transputer system.
   }
   \sstinvocation{
       CALL SCULIB\_SCAN\_2\_RD(VERSION, CENTRE\_COORDS, RA\_CEN, DEC\_CEN,
            LONG, LAT, LST, MJD, LAT\_OBS, RA\_APP, DEC\_APP,
            STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VERSION = REAL (Given)
      }{
         Version number of the file. This governs whether we need to
         even run this subroutine.
      }
      \sstsubsection{
         CENTRE\_COORDS = CHAR (Given)
      }{
         Centre coordinates of tracking centre
      }
      \sstsubsection{
         RA\_CEN = DOUBLE (Given)
      }{
         Apparent RA of map centre
      }
      \sstsubsection{
         DEC\_CEN = DOUBLE (Given)
      }{
         Apparent dec of map centre
      }
      \sstsubsection{
         LONG = DOUBLE (Given)
      }{
         Longitude of array at LST
      }
      \sstsubsection{
         LAT = DOUBLE (Given)
      }{
         Latitude of array at LST
      }
      \sstsubsection{
         LST = DOUBLE (Given)
      }{
         Local sidereal time (radians)
      }
      \sstsubsection{
         MJD = DOUBLE (Given)
      }{
         Modified Julian data of observation (should be the MJD of the
         time for which lst = LST).
      }
      \sstsubsection{
         LAT\_OBS                = DOUBLE PRECISION (Given)
      }{
         Latitude of observatory in radians.
      }
      \sstsubsection{
         RA\_APP                 = DOUBLE PRECISION (Returned)
      }{
         Apparent RA of point at date (radians)
      }
      \sstsubsection{
         DEC\_APP                = DOUBLE PRECISION (Returned)
      }{
         Apparent Dec
      }
      \sstsubsection{
         STATUS                 = INTEGER (Given and returned)
      }{
         Global status
      }
   }
   \sstnotes{
      Before November 1997 the situation is a bit tricky:
      \sstitemlist{

         \sstitem
           [1] Scan ends were assumed to be RD by the transputers

         \sstitem
           [2] The telescope assumed RJ offsets

      }
      Therefore I need to do the following to recreate what actually
      happened:
      \sstitemlist{

         \sstitem
           [1] Calculate tangent plane offsets from the RD centre

         \sstitem
           [2] Add these offsets onto the actual RJ tracking centre

         \sstitem
           [3] Convert back into RD

      }
      Post November 1997 the offsets really are RD even when the telescope
      goes to RJ so this routine should not be called. Version 1.0 data
      will not be modified.
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_SCAN\_APPARENT\_TP\_2\_AZNA
}{
   Calculate NAsmyth and AZel coordinates for SCAN/MAP
}{
   \sstdescription{
      This routine calculates the NA/AZ offsets from tangent plane
      offsets for SCAN map data.
   }
   \sstinvocation{
       CALL SCULIB\_SCAN\_APPARENT\_TP\_2\_AZNA(OUT\_COORDS, N\_POS,
            N\_BOL, ELEVATION, PAR\_ANGLE,
            BOL\_DEC, BOL\_RA, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         OUT\_COORDS = \_CHAR (Given)
      }{
         Output coordinate system
      }
      \sstsubsection{
         N\_POS = \_INTEGER (Given)
      }{
         Number of `samples{\tt '} taken
      }
      \sstsubsection{
         N\_BOL = \_INTEGER (Given)
      }{
         Number of bolometers in the input data
      }
      \sstsubsection{
         ELEVATION ( N\_POS ) = \_DOUBLE (Given)
      }{
         Elevation of each exposure
      }
      \sstsubsection{
         PAR\_ANGLE ( N\_POS ) = \_DOUBLE (Given)
      }{
         Parallactic angle of each exposure
      }
      \sstsubsection{
         RA\_CEN = \_DOUBLE (Given)
      }{
         apparent RA of output map centre (radians) Only used for JIGGLE data.
      }
      \sstsubsection{
         DEC\_CEN = \_DOUBLE (Given)
      }{
         apparent Dec of output map centre (radians) Only used for JIGGLE data.
      }
      \sstsubsection{
         BOL\_DEC(N\_BOL, N\_POS) = \_DOUBLE (Returned)
      }{
         Apparent DEC of bolometers for each measurement for MJD\_STANDARD
      }
      \sstsubsection{
         BOL\_RA(N\_BOL, N\_POS) = \_DOUBLE (Returned)
      }{
         Apparent RA of bolometers for each measurement for MJD\_STANDARD
      }
      \sstsubsection{
         STATUS = \_INTEGER (Given \& Returned)
      }{
         Global status
      }
   }
   \sstnotes{
      This routine does not annul the locator.
   }
   \sstdiytopic{
      Prior Requirements
   }{
      The locator to the structure must already be available.
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_SEARCH\_DATADIR
}{
   Open an NDF using the parameter system whilst searching DATADIR
}{
   \sstdescription{
      This routine reads a parameter and attempt to open an NDF.
      If it fails it searches the directory DATADIR and then opens
      an NDF there. If that fails it asks again.
      This routine also recognises the SCUBA\_PREFIX environment variable.
      When a number is given it is expanded to 4 digites (leading zeroes)
      and prepended with SCUBA\_PREFIX and {\tt '}\_dem\_{\tt '} before opening the file.
      The priority is:
      \sstitemlist{

         \sstitem
              File specified in current directory

         \sstitem
              Check if filename was a number and look in current directory
            then either

         \sstitem
              Look for full filename in DATADIR
            or

         \sstitem
              Look for numbered name in DATADIR
         Only one of the last two will happen since I will know from the status
         return of CHR\_CTOI whether a number was given.
      }
   }
   \sstinvocation{
      CALL SCULIB\_SEARCH\_DATADIR(PACKAGE, PARAM, INDF, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         PACKAGE = CHAR (Given)
      }{
         String to identify the software system when the information
         messages appear.
      }
      \sstsubsection{
         PARAM = CHAR (Given)
      }{
         Name of parameter associated with NDF
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier of successfully opened file
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         Global Status value
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         Uses some non PSX calls for accessing Current working directory
           These are GETCWD and CHDIR. This may be a portability issue.

         \sstitem
         Checks for PAR\_\_ABORT or PAR\_\_NULL status from parameter.
      }
   }
}
\sstroutine{
   SCULIB\_SET\_DATA
}{
   set data to a real value given a byte mask
}{
   \sstdescription{
      This routine uses a byte mask (N\_BOLS $*$ N\_POS) to set a data
      value in the output. A mask value of 1 indicates that a value
      should be changed. This routine does not distinguish {\tt '}beams{\tt '}
   }
   \sstinvocation{
       CALL SCULIB\_SET\_DATA (USE\_THIS, N\_BOLS, N\_POS,
            N\_BEAM, MASK, VALUE, IN\_DATA, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         USE\_THIS   = LOGICAL (Given)
      }{
         Describes whether the mask should be set to the value (TRUE)
         or whether the rest of the data should be set (FALSE)
      }
      \sstsubsection{
         N\_BOLS                  = INTEGER (Given)
      }{
         number of bolometers measured
      }
      \sstsubsection{
         N\_POS                   = INTEGER (Given)
      }{
         number of positions measured
      }
      \sstsubsection{
         N\_BEAM                  = INTEGER (Given)
      }{
         number of beams used
      }
      \sstsubsection{
         MASK( N\_BOLS, N\_POS)    = BYTE (Given)
      }{
         input mask
      }
      \sstsubsection{
         VALUE               = REAL (Given)
      }{
         The value of the masked/unmasked data
      }
      \sstsubsection{
         IN\_DATA (N\_BOLS, N\_POS, N\_BEAM) = REAL (Given and returned)
      }{
         the data to be masked
      }
      \sstsubsection{
         STATUS                  = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_SET\_DATA\_BIT
}{
   set a bit in data given a byte mask
}{
   \sstdescription{
      This routine uses a byte mask (N\_BOLS $*$ N\_POS) to set a data
      bit in the output. A mask value of 1 indicates that a value
      should be changed. This routine does not distinguish {\tt '}beams{\tt '}
      A bit can be set or unset.
   }
   \sstinvocation{
       CALL SCULIB\_SET\_DATA\_BIT(USE\_THIS, N\_BOLS, N\_POS, N\_BEAM,
           MASK, BITNUM, STATE, IN\_DATA, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         USE\_THIS   = LOGICAL (Given)
      }{
         Describes whether the mask should be set to the value (TRUE)
         or whether the rest of the data should be set (FALSE)
      }
      \sstsubsection{
         N\_BOLS                  = INTEGER (Given)
      }{
         number of bolometers measured
      }
      \sstsubsection{
         N\_POS                   = INTEGER (Given)
      }{
         number of positions measured
      }
      \sstsubsection{
         N\_BEAM                  = INTEGER (Given)
      }{
         number of beams used
      }
      \sstsubsection{
         MASK( N\_BOLS, N\_POS)    = BYTE (Given)
      }{
         input mask
      }
      \sstsubsection{
         BITNUM                  = INTEGER (Given)
      }{
         Bit number to affect
      }
      \sstsubsection{
         STATE                   = LOGICAL (Given)
      }{
         Set the bits if true. Otherwise clear them
      }
      \sstsubsection{
         IN\_DATA (N\_BOLS, N\_POS, N\_BEAM) = BYTE (Given and returned)
      }{
         the data to be masked
      }
      \sstsubsection{
         STATUS                  = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_SET\_DATA\_UB
}{
   set data to a byte value given a byte mask
}{
   \sstdescription{
      This routine uses a byte mask (N\_BOLS $*$ N\_POS) to set a data
      value in the output. A mask value of 1 indicates that a value
      should be changed. This routine does not distinguish {\tt '}beams{\tt '}
   }
   \sstinvocation{
       CALL SCULIB\_SET\_DATA\_UB(USE\_THIS, N\_BOLS, N\_POS, N\_BEAM,
         MASK, BVALUE, IN\_DATA, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         USE\_THIS   = LOGICAL (Given)
      }{
         Describes whether the mask should be set to the value (TRUE)
         or whether the rest of the data should be set (FALSE)
      }
      \sstsubsection{
         N\_BOLS                  = INTEGER (Given)
      }{
         number of bolometers measured
      }
      \sstsubsection{
         N\_POS                   = INTEGER (Given)
      }{
         number of positions measured
      }
      \sstsubsection{
         N\_BEAM                  = INTEGER (Given)
      }{
         number of beams used
      }
      \sstsubsection{
         MASK( N\_BOLS, N\_POS)    = BYTE (Given)
      }{
         input mask
      }
      \sstsubsection{
         BVALUE                  = BYTE (Given)
      }{
         The value to be given to the masked/unmasked data
      }
      \sstsubsection{
         IN\_DATA (N\_BOLS, N\_POS, N\_BEAM) = BYTE (Given and returned)
      }{
         the data to be masked
      }
      \sstsubsection{
         STATUS                  = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_SET\_QUAL
}{
   set quality bits in a subset of a quality array
}{
   \sstdescription{
      Set the bits in the quality array as specified by a mask.
      Can be used to set or unset bits as well as using the mask
      or the inverse of the mask. This is used to mask scuba sections.
   }
   \sstinvocation{
       CALL SCULIB\_SET\_QUAL (USE\_SECT, QUALITY, N\_BOLS, N\_POS, N\_BEAM,
         BOL\_S, POS\_S, BIT\_POS, BIT\_SWITCH, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         USE\_SECT                = LOGICAL (Given)
      }{
         am I changing SECTION or .NOT. SECTION
      }
      \sstsubsection{
         QUALITY (N\_BOLS, N\_POS, N\_BEAM) = BYTE (Given and returned)
      }{
         the quality array
      }
      \sstsubsection{
         N\_BOLS                  = INTEGER (Given)
      }{
         number of bolometers measured
      }
      \sstsubsection{
         N\_POS                   = INTEGER (Given)
      }{
         number of positions measured
      }
      \sstsubsection{
         N\_BEAM                  = INTEGER (Given)
      }{
         number of beams used
      }
      \sstsubsection{
         BOL\_S (N\_BOLS)          = INTEGER (Given)
      }{
         array containing 1s for bolometers whose quality is to be
         changed
      }
      \sstsubsection{
         POS\_S (N\_POS)           = INTEGER (Given)
      }{
         array containing 1s for positions whose quality is to be
         changed
      }
      \sstsubsection{
         BIT\_POS                 = INTEGER (Given)
      }{
         position of bit ot be set (0 - 7)
      }
      \sstsubsection{
         BIT\_SWITCH               = LOGICAL (Given)
      }{
         If .TRUE. we set the bit using SCULIB\_BITON. If .FALSE.
         we unset the bit with SCULIB\_BITOFF
      }
      \sstsubsection{
         STATUS                  = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_SET\_QUALITY
}{
   set quality bits in a subset of a quality array
}{
   \sstdescription{
      set quality bits in a subset of a quality array
   }
   \sstinvocation{
        CALL  SCULIB\_SET\_QUALITY (N\_BOLS, N\_POS, N\_BEAM, QUALITY,
         START\_BOL, END\_BOL, START\_POS, END\_POS, START\_BEAM, END\_BEAM,
         BIT\_POS, BIT\_VALUE, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         N\_BOLS                  = INTEGER (Given)
      }{
         number of bolometers measured
      }
      \sstsubsection{
         N\_POS                   = INTEGER (Given)
      }{
         number of positions measured
      }
      \sstsubsection{
         N\_BEAM                  = INTEGER (Given)
      }{
         number of beams used
      }
      \sstsubsection{
         QUALITY (N\_BOLS, N\_POS, N\_BEAM) = BYTE (Given and returned)
      }{
         the quality array
      }
      \sstsubsection{
         START\_BOL               = INTEGER (Given)
      }{
         index of first bolometer to be set bad
      }
      \sstsubsection{
         END\_BOL                 = INTEGER (Given)
      }{
         index of last bolometer to be set bad
      }
      \sstsubsection{
         START\_POS               = INTEGER (Given)
      }{
         index of first position to be set bad
      }
      \sstsubsection{
         END\_POS                 = INTEGER (Given)
      }{
         index of last position to be set bad
      }
      \sstsubsection{
         START\_BEAM              = INTEGER (Given)
      }{
         index of first beam  to be set bad
      }
      \sstsubsection{
         END\_BEAM                = INTEGER (Given)
      }{
         index of last beam  to be set bad
      }
      \sstsubsection{
         BIT\_POS                 = INTEGER (Given)
      }{
         position of bit ot be set (0 - 7)
      }
      \sstsubsection{
         BIT\_VALUE               = INTEGER (Given)
      }{
         value to which bit is to be set (0 if zero, 1 otherwise)
      }
      \sstsubsection{
         STATUS                  = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_SET\_USER
}{
   set the USER array used by SCULIB\_SKYFUNC\_1
}{
   \sstdescription{
      E04UPF is a NAG routine that is used to fit a theoretical
      sky-dip curve to the measured data by varying ETA\_TEL, B and TAU.
      SCULIB\_SKYFUNC\_1 is called by E04UPF to calculate the M sub-functions
      fi(x) at the current solution vector X, and/or their Jacobian
      matrix (see NAG manual for further info). That routine obtains the
      data needed for its calculations via the USER array passed into it,
      and this routine fills USER with the necessary numbers:-
      \sstitemlist{

         \sstitem
          USER (1) = J\_TEL

         \sstitem
          USER (2) = J\_ATM

         \sstitem
          USER (3) = not used

         \sstitem
          USER (4:M$+$3)      = the measured airmasses

         \sstitem
          USER (M$+$4:2M$+$3)   = the measured sky temperatures

         \sstitem
          USER (2M$+$4:3M$+$3)  = the errors on the measured sky temperatures
      }
   }
   \sstinvocation{
       CALL SCULIB\_SET\_USER (J\_TEL, J\_ATM, N\_MEASUREMENTS,
         AIRMASS, J\_MEAS\_D, J\_MEAS\_V, USER)
   }
   \sstarguments{
      \sstsubsection{
         J\_TEL                     = REAL (Given)
      }{
         the temperature of the telescope
      }
      \sstsubsection{
         J\_ATM                     = REAL (Given)
      }{
         the temperature of the atmosphere
      }
      \sstsubsection{
         N\_MEASUREMENTS            = INTEGER (Given)
      }{
         the number of measurements taken in the sky-dip
      }
      \sstsubsection{
         AIRMASS (N\_MEASUREMENTS)  = REAL (Given)
      }{
         the airmass at each measurement
      }
      \sstsubsection{
         J\_MEAS\_D (N\_MEASUREMENTS) = REAL (Given)
      }{
         the brightness temperature of the atmosphere at each airmass
      }
      \sstsubsection{
         J\_MEAS\_V (N\_MEASUREMENTS) = REAL (Given)
      }{
         the variance on J\_MEAS\_D
      }
      \sstsubsection{
         USER (3 $*$ N\_MEASUREMENTS $+$ 3) = DOUBLE PRECISION (Returned)
      }{
         the USER array required
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_SINC
}{
   Calculate SIN(PI$*$X)/(PI$*$X)
}{
   \sstdescription{
      Calculate sinc function.
   }
   \sstinvocation{
      RESULT = SCULIB\_SINC( X )
   }
   \sstarguments{
      \sstsubsection{
         X = REAL (Given)
      }{
         The argument to the sinc function - In turns
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         SCULIB\_SINC = REAL
      }{
         SINC(PI$*$X)
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         No status checking

         \sstitem
         No bad value checking
      }
   }
}
\sstroutine{
   SCULIB\_SKYCON\_1
}{
   routine to calculate non-linear constraints for
   NAG non-linear fitting routine E04UPF when fitting
   ETA\_TEL, B and TAU in sky-dip analysis
}{
   \sstdescription{
      E04UPF is a NAG routine used to fit a theoretical SKYDIP
      curve to the measured data by varying ETA\_TEL, B and TAU. This
      routine is called by E04UPF to calculate the 1 non-linear constraint
      in the problem and/or it{\tt '}s Jacobian at the current solution vector
      X. See the NAG manual if you need to know more about E04UPF.

      The solution vector is composed as follows:-
      \sstitemlist{

         \sstitem
              x(1) = ETA\_TEL

         \sstitem
              x(2) = B

         \sstitem
              x(3) = TAU

      }
      The non-linear constraint limits ETA\_TEL $*$ B. So, evaluation
      of the constraint gives:-

           C(1) = ETA\_TEL $*$ B

      and its Jacobian has components :-

\begin{equation}
\frac{\partial C}{\partial x(1)} = B
\end{equation}
\begin{equation}
\frac{\partial C}{\partial x(2)} = \eta_\mathrm{tel}
\end{equation}
\begin{equation}
\frac{\partial C}{\partial x(2)} = 0.0
\end{equation}

   }
   \sstinvocation{
       CALL SCULIB\_SKYCON\_1 (MODE, NCNLN, N, LDCJ, NEEDC, X, C,
         CJAC, NSTATE, IUSER, USER)
   }
   \sstarguments{
      \sstsubsection{
         See NAG manual description of CONFUN parameter in E04UPF.
      }{
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1993-1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_SKYDIP\_ALLAN\_VARIANCE
}{
   incorporate latest set of SKYDIP data
   samples into Allan variance
}{
   \sstdescription{
      This routine incorporates a data slice into a run of data and updates
      the Allan variance of the run.

         The Allan variance is calculated for a range of simulated integration
      times for which artificial samples are calculated from the input data.
      The Allan variance for a particular integration time is calculated from:-


\begin{equation}
variance = \sum_{i=1\rightarrow n-1}\frac{(sample(i) - sample(i+1))^2}{2n}
\end{equation}
      where n is the number of artificial samples available.
   }
   \sstinvocation{
       CALL SCULIB\_SKYDIP\_ALLAN\_VARIANCE (SUB\_INSTRUMENT, NUM\_CHAN,
         NUM\_ADC, BOL\_TYPE, N\_BOLS, BOL\_CHAN, BOL\_ADC, N\_SAMPLES,
         SAMPLE, SAMPLE\_QUALITY, KMAX, SUM, N\_SUM, ARTIFICIAL,
         N\_ARTIFICIAL, ALLAN\_VARIANCE, ALLAN\_QUALITY, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         SUB\_INSTRUMENT                  = CHARACTER$*$($*$) (Given)
      }{
         the name of the sub-instrument for which the Allan variance
         is to be calculated
      }
      \sstsubsection{
         NUM\_CHAN                        = INTEGER (Given)
      }{
         number of channels per A/D card
      }
      \sstsubsection{
         NUM\_ADC                         = INTEGER (Given)
      }{
         number of A/D cards
      }
      \sstsubsection{
         BOL\_TYPE (NUM\_CHAN, NUM\_ADC)    = CHARACTER$*$($*$) (Given)
      }{
         the types of the bolometers
      }
      \sstsubsection{
         N\_BOLS                          = INTEGER (Given)
      }{
         the number of bolometers making measurements
      }
      \sstsubsection{
         BOL\_CHAN (N\_BOLS)               = INTEGER (Given)
      }{
         channel numbers of selected bolometers
      }
      \sstsubsection{
         BOL\_ADC (N\_BOLS)                = INTEGER (Given)
      }{
         ADC numbers of selected bolometers
      }
      \sstsubsection{
         N\_SAMPLES                       = INTEGER (Given)
      }{
         the number of samples
      }
      \sstsubsection{
         SAMPLE (N\_BOLS, N\_SAMPLES)      = REAL (Given)
      }{
         the samples
      }
      \sstsubsection{
         SAMPLE\_QUALITY (N\_BOLS, N\_SAMPLES) = INTEGER (Given)
      }{
         quality on the samples
      }
      \sstsubsection{
         KMAX                            = INTEGER (Given)
      }{
         the size of the Allan variance array
      }
      \sstsubsection{
         SUM (KMAX)                      = REAL (Given and returned)
      }{
         the accumulator for current artificial sample of length K real
         samples
      }
      \sstsubsection{
         N\_SUM (KMAX)                    = INTEGER (Given and returned)
      }{
         the number of samples currently in the artificial sample
         accumulator
      }
      \sstsubsection{
         ARTIFICIAL (KMAX)               = REAL (Given and returned)
      }{
         the last artificial sample of length K samples that was
         calculated
      }
      \sstsubsection{
         N\_ARTIFICIAL (KMAX)             = INTEGER (Given and returned)
      }{
         the number of artificial samples of length K samples that
         have been calculated
      }
      \sstsubsection{
         ALLAN\_VARIANCE (KMAX)           = REAL (Given and returned)
      }{
         the Allan variance
      }
      \sstsubsection{
         ALLAN\_QUALITY (KMAX)            = INTEGER (Returned)
      }{
         quality on the Allan variance
      }
      \sstsubsection{
         STATUS                          = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
   \sstdiytopic{
      Method
   }{
      If status on entry is good the routine will:-

      loop through the data samples to be incorporated -

         loop through the bolometers for which data is available and calculate
         an average value for the sample from those bolometers belonging to
         the specified sub-instrument

         if the quality of the average sample is good -

            loop through the Allan variances -

               add the sample to the buffer used to calculate the latest
               artificial sample at the simulated integration time of this
               variance

               if all the data has been obtained for the latest artificial
               sample -

                  calculate the artificial sample

                  if there is only one artificial sample for this simulated
                  integration time we can{\tt '}t calculate the Allan variance, so
                  set its quality to bad

                  if there are 2 artifical samples then the Allan variance
                  can be calculated from -
\begin{equation}
variance = \frac{(artificial\_2 - artificial\_1)^2}{2 \times 2}
\end{equation}

                  if there are more than 2 artificial samples

      \sstitemlist{

         \sstitem
                        the sum of the squares of the differences between the
                        previous samples is recovered from the current value of the
                        Allan variance

         \sstitem
                        the square of the difference between the current artificial
                        sample and the previous one is added to the sum

         \sstitem
                        the Allan variance is re-calculated

      }
                  end if

                  the current artifical sample is stored to be used as the
                  `previous{\tt '} sample next time round

                  the variables used to calculate the artificial samples at
                  this simulated integration time are reset

               end if

            end of loop through Allan variances

         end if

      end of loop through samples in this dataslice
   }
}
\sstroutine{
   SCULIB\_SKYDIP\_BOLS
}{
   returns bolometers to be measured in a SKYDIP
}{
   \sstdescription{
      This routine returns a string containing the names of the bolometers
      to be measured in a SKYDIP observation.

         Only those sub-instruments that are looking out through a suitable
      filter will be measured. Thus, if the filter in front of the SHORT
      array is {\tt '}350{\tt '} or {\tt '}450{\tt '} the returned string will contain the word
      SHORT\_DC. Other filter/sub/bolometer combinations are as follows:-
      \sstitemlist{

         \sstitem
           600 or 750 or 850 in front of the LONG array gives LONG\_DC

         \sstitem
           1100 in front of the P1100 photometer gives        P1100\_DC

         \sstitem
           1300 in front of the P1300 photometer gives        P1300\_DC

         \sstitem
           2000 in front of the P2000 photometer gives        P2000\_DC

      }
      The returned BOLOMETERS string will contain the words for each
      sub-instrument to be measured separated by commas.
   }
   \sstinvocation{
      CALL SCULIB\_SKYDIP\_BOLS (FILTER, BOLOMETERS, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         FILTER                    = CHARACTER$*$($*$) (Given)
      }{
         the name of the filter combination in use
      }
      \sstsubsection{
         BOLOMETERS                = CHARACTER$*$($*$) (Returned)
      }{
         the names of the bolometers to be measured
      }
      \sstsubsection{
         STATUS                    = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_SKYDIP\_TEMPERATURES
}{
   derive sky temperatures from chopper-wheel data
}{
   \sstdescription{
      This routine derives sky brightness temperatures from data containing
      the measured signals from cold and ambient loads and sky. The sky
      temperature is calculated for each sample by linear interpolation between
      the signals from the cold and ambient loads.

         In addition, mean values of the sky temperature for each bolometer
      are derived from the samples taken. If more than one sample contributes
      to the mean then the variance is calculated from the spread of samples
      about the mean.
   }
   \sstinvocation{
       CALL SCULIB\_SKYDIP\_TEMPERATURES (T\_COLD, T\_HOT, N\_SUB,
      :  SUB\_INSTRUMENT, WAVELENGTH, NUM\_CHAN, NUM\_ADC, BOL\_TYPE,
      :  N\_BOLS, BOL\_CHAN, BOL\_ADC, N\_SAMPLES\_IN, RAW\_DATA,
      :  N\_SAMPLES\_OUT, J\_SKY, J\_SKY\_VARIANCE, J\_SKY\_QUALITY, J\_SKY\_AV,
      :  J\_SKY\_AV\_VARIANCE, J\_SKY\_AV\_QUALITY, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         T\_COLD (N\_SUB)             = REAL (Given)
      }{
         the temperature of the cold load for each sub-instrument
      }
      \sstsubsection{
         T\_HOT (N\_SUB)              = REAL (Given)
      }{
         the temperature of the hot load for each sub-instrument
      }
      \sstsubsection{
         N\_SUB                      = INTEGER (Given)
      }{
         the number of sub-instruments being used
      }
      \sstsubsection{
         SUB\_INSTRUMENT (N\_SUB)     = CHARACTER$*$($*$) (Given)
      }{
         the names of the sub-instruments being used
      }
      \sstsubsection{
         WAVELENGTH (N\_SUB)         = REAL (Given)
      }{
         the wavelengths of the filters in front of the sub-instruments
         (microns)
      }
      \sstsubsection{
         NUM\_CHAN                   = INTEGER (Given)
      }{
         number of A/D channels per A/D card
      }
      \sstsubsection{
         NUM\_ADC                    = INTEGER (Given)
      }{
         number of A/D cards
      }
      \sstsubsection{
         BOL\_TYPE (NUM\_CHAN, NUM\_ADC) = CHARACTER$*$($*$) (Given)
      }{
         the types of the bolometers
      }
      \sstsubsection{
         N\_BOLS                     = INTEGER (Given)
      }{
         the number of bolometers making measurements
      }
      \sstsubsection{
         BOL\_CHAN (N\_BOLS)          = INTEGER (Given)
      }{
         channel numbers of selected bolometers
      }
      \sstsubsection{
         BOL\_ADC (N\_BOLS)           = INTEGER (Given)
      }{
         ADC numbers of selected bolometers
      }
      \sstsubsection{
         N\_SAMPLES\_IN               = INTEGER (Given)
      }{
         the number of samples taken by each bolometer
      }
      \sstsubsection{
         RAW\_DATA (3, N\_BOLS, N\_SAMPLES\_IN) = REAL (Given)
      }{
         the measured signals from the cold and ambient loads and sky
         \sstitemlist{

            \sstitem
              RAW\_DATA (1,i,j) = ambient load signal

            \sstitem
              RAW\_DATA (2,i,j) = sky signal

            \sstitem
              RAW\_DATA (3,i,j) = cold load signal
         }
      }
      \sstsubsection{
         N\_SAMPLES\_OUT              = INTEGER (Given)
      }{
         the number of samples requested for each bolometer
      }
      \sstsubsection{
         J\_SKY (N\_BOLS, N\_SAMPLES\_OUT) = REAL (Returned)
      }{
         the brightness temperature of the sky
      }
      \sstsubsection{
         J\_SKY\_VARIANCE (N\_BOLS, N\_SAMPLES\_OUT) = REAL (Returned)
      }{
         the variance on J\_SKY
      }
      \sstsubsection{
         J\_SKY\_QUALITY (N\_BOLS, N\_SAMPLES\_OUT) = BYTE (Returned)
      }{
         the quality on J\_SKY
      }
      \sstsubsection{
         J\_SKY\_AV (N\_BOLS)          = REAL (Returned)
      }{
         the average of J\_SKY for each bolometer
      }
      \sstsubsection{
         J\_SKY\_AV\_VARIANCE (N\_BOLS) = REAL (Returned)
      }{
         the variance on the average of J\_SKY
      }
      \sstsubsection{
         J\_SKY\_AV\_QUALITY (N\_BOLS)  = BYTE (Returned)
      }{
         the quality of the average of J\_SKY
      }
      \sstsubsection{
         STATUS                     = INTEGER (Given and returned)
      }{
         Global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         Should be converted to use double precision internally since sometimes
           can return a negative temperature.
      }
   }
}

\sstroutine{
   SCULIB\_SKYDIP\_VAR
}{
   calculate variance of skydip data points
}{
   \sstdescription{
      If entered with good status this routine calculates the variance
      between a SKYDIP dataset and the theoretical curve generated by
      the the sky and telescope parameters in FIT.  Additionally, the residual
      of the fit is also returned (absolute value of measured data mins
      fitted values). Data points with bad
      quality will be ignored. If no valid data points are found then an
      error will be reported and bad status returned. The data are passed
      in via common.

      The FIT vector is composed as follows:-
      \sstitemlist{

         \sstitem
               x(1) = ETA\_TEL

         \sstitem
               x(2) = B

         \sstitem
               x(3) = TAU

      }
      For a given airmass:-

\begin{equation}
J_\mathrm{theory} = (1-\eta_\mathrm{tel}) J_\mathrm{tel} +
\eta_\mathrm{tel}J_\mathrm{atm} (1-B \exp(-\tau Airmass))
\end{equation}

\begin{equation}
            J_\mathrm{atm} = J_\mathrm{amb} X_G
\end{equation}

\begin{equation}
              X_G = 1 + \frac{h1\times h2}{J_\mathrm{amb}} \exp (-\tau \times
Airmass(i) / X\_Gconst)
\end{equation}

   }
   \sstinvocation{
      CALL SCULIB\_SKYDIP\_VAR (RESIDUAL, VAR, N, FIT, NDEG, STATUS)
   }
   \sstarguments{
      \sstsubsection{
        RESIDUAL = DOUBLE PRECISION (Returned)
      }{
        residual of the fit (absolute difference between the
            model and the data)
      }
      \sstsubsection{
         VAR                     = DOUBLE PRECISION (Returned)
      }{
         the chi-squared value of the current fit
      }
      \sstsubsection{
         N                        = INTEGER (Given)
      }{
         the number of parameters being fit, should be 3
      }
      \sstsubsection{
         FIT (N)                  = DOUBLE PRECISION (Given)
      }{
         the fit parameters:-
         \sstitemlist{

            \sstitem
                                FIT (1) = ETA\_TEL

            \sstitem
                                FIT (2) = B

            \sstitem
                                FIT (3) = TAUZ
         }
      }
      \sstsubsection{
         NDEG                     = INTEGER (Given)
      }{
         the number of degrees of freedom
      }
      \sstsubsection{
         STATUS                   = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995-2000 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_SKYDIP\_XISQ
}{
   calculate chi-square of sky fit
}{
   \sstdescription{
      If entered with good status this routine calculates the chi-squared
      between a SKYDIP dataset and the theoretical curve generated by
      the the sky and telescope parameters in FIT. Data points with bad
      quality will be ignored. If no valid data points are found then an
      error will be reported and bad status returned. The data are passed
      in via common.

      The FIT vector is composed as follows:-
      \sstitemlist{

         \sstitem
               x(1) = ETA\_TEL

         \sstitem
               x(2) = B

         \sstitem
               x(3) = TAU

      }
      For a given airmass:-
\begin{equation}
J_\mathrm{theory} = (1-\eta_\mathrm{tel}) J_\mathrm{tel} +
\eta_\mathrm{tel}J_\mathrm{atm} (1-B \exp(-\tau Airmass))
\end{equation}

\begin{equation}
            J_\mathrm{atm} = J_\mathrm{amb} X_G
\end{equation}

\begin{equation}
              X_G = 1 + \frac{h1\times h2}{J_\mathrm{amb}} \exp (-\tau \times
Airmass(i) / X\_Gconst)
\end{equation}

   }
   \sstinvocation{
      CALL SCULIB\_SKYDIP\_XISQ (XISQ, N, FIT, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         XISQ                     = DOUBLE PRECISION (Returned)
      }{
         the chi-squared value of the current fit
      }
      \sstsubsection{
         N                        = INTEGER (Given)
      }{
         the number of parameters being fit, should be 3
      }
      \sstsubsection{
         FIT (N)                  = DOUBLE PRECISION (Given)
      }{
         the fit parameters:-
         \sstitemlist{

            \sstitem
                               FIT (1) = ETA\_TEL

            \sstitem
                               FIT (2) = B

            \sstitem
                               FIT (3) = TAUZ
         }
      }
      \sstsubsection{
         STATUS                   = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_SKYFUNC
}{
   Return the value of the skydip function
}{
   \sstdescription{
      This routine returns the value of the skydip function.
      The parameters are passed as follows:
      \sstitemlist{

         \sstitem
             P(1) = ETA\_TEL

         \sstitem
             P(2) = B

         \sstitem
             P(3) = TAU

         \sstitem
             P(4) = J\_AMB

         \sstitem
             P(5) = J\_TEL

      }
      This subroutine returns the theoretical value of the skydip
      for the given input parameters.

\begin{equation}
J_\mathrm{theory} = (1-\eta_\mathrm{tel}) J_\mathrm{tel} +
\eta_\mathrm{tel}J_\mathrm{atm} (1-B \exp(-\tau Airmass))
\end{equation}

\begin{equation}
            J_\mathrm{atm} = J_\mathrm{amb} X_G
\end{equation}

\begin{equation}
              X_G = 1 + \frac{h1\times h2}{J_\mathrm{amb}} \exp (-\tau \times
Airmass(i) / X\_Gconst)
\end{equation}

   }
   \sstinvocation{
      CALL SCULIB\_SKYFUNC(F, X, P, M)
   }
   \sstarguments{
      \sstsubsection{
         F = REAL (Returned)
      }{
         The value of the skydip function
      }
      \sstsubsection{
         X = REAL (Given)
      }{
         The airmass used to calculate the function
      }
      \sstsubsection{
         P = REAL (Given)
      }{
         The parameter values
      }
      \sstsubsection{
         M = INTEGER (Given)
      }{
         The number of parameters
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_SKYFUNC\_1
}{
   calculate f(x) and its Jacobian for NAG non-linear
   fitting routine E04UPF when fitting ETA\_TEL, B
   and TAU in SKYDIP analysis
}{
   \sstdescription{
      E04UPF is a NAG routine that is used to fit a theoretical
      sky-dip curve to the measured data by varying ETA\_TEL, B and TAU.
      This routine is called by E04UPF to calculate the M sub-functions
      fi(x) at the current solution vector X, and/or their Jacobian
      matrix. See the NAG manual if you need to know more about E04UPF.

      The solution vector is composed as follows:-
      \sstitemlist{

         \sstitem
               x(1) = ETA\_TEL

         \sstitem
               x(2) = B

         \sstitem
               x(3) = TAU

      }
      For each of the M measured airmasses the subfunction f(x) is:-

\begin{equation}
             f(x) = \frac{J_\mathrm{theory} (Airmass(i)) - J_\mathrm{meas} (Airmass(i))}{J_\mathrm{noise} (Airmass(i))}
\end{equation}

      where:-

\begin{equation}
J_\mathrm{theory} = (1-\eta_\mathrm{tel}) J_\mathrm{tel} +
\eta_\mathrm{tel}J_\mathrm{atm} (1-B \exp(-\tau Airmass))
\end{equation}

\begin{equation}
            J_\mathrm{atm} = J_\mathrm{amb} X_G
\end{equation}

\begin{equation}
              X_G = 1 + \frac{h1\times h2}{J_\mathrm{amb}} \exp (-\tau \times
Airmass(i) / X\_Gconst)
\end{equation}


      The corresponding Jacobian has component (i,j):-


\begin{equation}
\frac{\partial f(x)}{\partial x(j)} = \frac{\partial}{\partial x(j)}J_\mathrm{theory}(Airmass(i)) \times\frac{1}{J_\mathrm{noise}(i)}
\end{equation}

leading to:

\begin{equation}
\frac{\partial f(i)}{\partial x(1)} = -\frac{J_\mathrm{tel}+J_\mathrm{atm} - B
J_\mathrm{tel} \exp(-\tau A(i))}{J_\mathrm{noise}(i)}
\end{equation}

\begin{equation}
\frac{\partial f(i)}{\partial x(2)} = - \frac{\eta_\mathrm{tel} J_\mathrm{atm}
\exp(-\tau A(i))}{J_\mathrm{noise}(i)}
\end{equation}

\begin{equation}
\frac{\partial f(i)}{\partial x(3)} = \frac{\eta_\mathrm{tel} \frac{\partial
J_\mathrm{atm}}{\partial\tau} - \eta_\mathrm{tel} B \exp(-\tau A(i)) \left(\frac{\partial
J_\mathrm{atm}}{\partial\tau} - J_\mathrm{atm} A(i)\right)}{J_\mathrm{noise}(i)}
\end{equation}

where

\begin{equation}
\frac{\partial J_\mathrm{atm}}{\partial\tau} = J_\mathrm{amb} \frac{\partial
X_G}{\partial\tau}
\end{equation}

and

\begin{equation}
\frac{\partial X_G}{\partial\tau} = - \frac{H_1 H_2 A(i)}{J_\mathrm{amb}
X_\mathrm{Gconst}} \exp(-\tau A(i) / X_\mathrm{Gconst})
\end{equation}

      The array USER is used to get the necessary ancillary information into
      the routine:-
      \sstitemlist{

         \sstitem
          USER (1) = J\_TEL

         \sstitem
          USER (2) = J\_AMB

         \sstitem
          USER (3) = not used

         \sstitem
          USER (4:M$+$3)      = the measured airmasses

         \sstitem
          USER (M$+$4:2M$+$3)   = the measured sky temperatures

         \sstitem
          USER (2M$+$4:3M$+$3)  = the errors on the measured sky temperatures
      }
   }
   \sstinvocation{
       CALL SCULIB\_SKYFUNC\_1 (MODE, M, N, LDFJ, X, F, FJAC, NSTATE,
           IUSER, USER)
   }
   \sstarguments{
      \sstsubsection{
         See NAG manual description of OBJFUN parameter in E04UPF.
      }{
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_SKYFUNC\_2
}{
   calculate f(x) and its Jacobian for NAG non-linear
   fitting routine E04UPF when fitting B and TAU in
   sky-dip analysis
}{
   \sstdescription{
      E04UPF is a NAG routine that is used to fit a theoretical
      sky-dip curve to the measured data by varying B and TAU.
      This routine is called by E04UPF to calculate the M sub-functions
      f(x) at the current solution vector X, and/or the Jacobian
      matrix. Please see the NAG manual if you need to know more about
      E04UPF.

      The solution vector is composed as follows:-
      \sstitemlist{

         \sstitem
              x(1) = B

         \sstitem
              x(2) = TAU

      }
      For each of the M measured airmasses the subfunction f(x) is:-


\begin{equation}
             f(x) = \frac{J_\mathrm{theory} (Airmass(i)) - J_\mathrm{meas} (Airmass(i))}{J_\mathrm{noise} (Airmass(i))}
\end{equation}

      where:-

\begin{equation}
J_\mathrm{theory} = (1-\eta_\mathrm{tel}) J_\mathrm{tel} +
\eta_\mathrm{tel}J_\mathrm{atm} (1-B \exp(-\tau Airmass))
\end{equation}

      The corresponding Jacobian has component (i,j):-

\begin{equation}
\frac{\partial f(x)}{\partial x(j)} = \frac{\partial}{\partial x(j)}J_\mathrm{theory}(Airmass(i)) \times\frac{1}{J_\mathrm{noise}(i)}
\end{equation}

leading to:

\begin{equation}
\frac{\partial f(i)}{\partial x(1)} = - \eta_\mathrm{tel} J_\mathrm{atm}
\exp(-\tau A(i))
\end{equation}

\begin{equation}
\frac{\partial f(i)}{\partial x(2)} = A(i) B \eta_\mathrm{tel} J_\mathrm{atm}
\exp(-\tau A(i))
\end{equation}

      The array USER is used to get the necessary ancillary information into
      the routine:-
      \sstitemlist{

         \sstitem
          USER (1) = J\_TEL

         \sstitem
          USER (2) = J\_ATM

         \sstitem
          USER (3) = ETA\_TEL

         \sstitem
          USER (4:M$+$3)     = the measured airmasses

         \sstitem
          USER (M$+$4:2M$+$3)  = the measured sky temperatures

         \sstitem
          USER (2M$+$4:3M$+$3) = the errors on the measured sky temperatures
      }
   }
   \sstinvocation{
       CALL SCULIB\_SKYFUNC\_2 (MODE, M, N, LDFJ, X, F, FJAC, NSTATE,
         IUSER, USER)
   }
   \sstarguments{
      \sstsubsection{
         See NAG manual description of OBJFUN parameter in E04UPF.
      }{
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_SKYFUNCD
}{
   Return the value of the partial derivatives of the skydip function
}{
   \sstdescription{
      This routine returns the value of the skydip function.
      The parameters are passed as follows:
      \sstitemlist{

         \sstitem
              P(1) = ETA\_TEL

         \sstitem
              P(2) = B

         \sstitem
              P(3) = TAU

         \sstitem
              P(4) = J\_AMB

         \sstitem
              P(5) = J\_TEL

      }
      The  theoretical value of the skydip
      for the given input parameters is given by:

\begin{equation}
f(x) = \frac{J_\mathrm{theory} (Airmass) - J_\mathrm{meas} (Airmass)}{J_\mathrm{noise} (Airmass)}
\end{equation}

      where:-

\begin{equation}
J_\mathrm{theory} = (1-\eta_\mathrm{tel}) J_\mathrm{tel} +
\eta_\mathrm{tel}J_\mathrm{atm} (1-B \exp(-\tau Airmass))
\end{equation}

\begin{equation}
            J_\mathrm{atm} = J_\mathrm{amb} X_G
\end{equation}

\begin{equation}
X_G = 1 + \frac{h1\times h2}{J_\mathrm{amb}} \exp (-\tau \times
Airmass / X\_Gconst)
\end{equation}

      The partial derivatives are:

\begin{equation}
\frac{\partial f(i)}{\partial\eta_\mathrm{tel}} = DR(1) =
-J_\mathrm{tel}+J_\mathrm{atm} - B J_\mathrm{tel} \exp(-\tau A)
\end{equation}

\begin{equation}
\frac{\partial f(i)}{\partial B} = DR(2) = - \eta_\mathrm{tel} J_\mathrm{atm}
\exp(-\tau A)
\end{equation}

\begin{equation}
\frac{\partial X_G}{\partial\tau} = - \frac{H_1 H_2 A}{J_\mathrm{amb}
X_\mathrm{Gconst}} \exp(-\tau A / X_\mathrm{Gconst})
\end{equation}

\begin{equation}
\frac{\partial J_\mathrm{atm}}{\partial\tau} = J_\mathrm{amb} \frac{\partial
X_G}{\partial\tau}
\end{equation}

\begin{equation}
\frac{\partial f}{\partial \tau} = DR(3) = \eta_\mathrm{tel} \frac{\partial
J_\mathrm{atm}}{\partial\tau} - \eta_\mathrm{tel} B \exp(-\tau A) \left(\frac{\partial
J_\mathrm{atm}}{\partial\tau} - J_\mathrm{atm} A\right)
\end{equation}

\begin{equation}
\frac{\partial f}{\partial J_\mathrm{amb}} = \frac{\partial f}{\partial
J_\mathrm{tel}} = 0.0 \quad(\text{fixed parameters})
\end{equation}

   }
   \sstinvocation{
      CALL SCULIB\_SKYFUNCD(X, P, DR, M)
   }
   \sstarguments{
      \sstsubsection{
         X = REAL (Given)
      }{
         The airmass used to calculate the function
      }
      \sstsubsection{
         P = REAL (Given)
      }{
         The parameter values
      }
      \sstsubsection{
         M = INTEGER (Given)
      }{
         The number of parameters
      }
      \sstsubsection{
         DR = REAL (Returned)
      }{
         The values of the partial derivatives
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_SPLINE\_PDA\_IDBVIP
}{
   Fit a surface to an irregular grid using the PDA function PDA\_IDBVIP
}{
   \sstdescription{
      This routine provides a wrapper for the PDA\_IDBVIP spline interpolation
      routine. The quirks of the algorithm are dealt with here so that
      SCULIB\_SPLINE\_REGRID does not have to know anything about the
      interpolation routine.
   }
   \sstinvocation{
       CALL SCULIB\_SPLINE\_PDA\_IDBVIP (NDP, X\_IN, Y\_IN, DATA\_IN,
         N\_PTS, X\_OUT, Y\_OUT, DATA\_OUT, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         NDP = INTEGER (Given)
      }{
         Number of data points on irregular grid
      }
      \sstsubsection{
         X\_IN ( NDP ) = REAL (Given)
      }{
         X coordinates of input data
      }
      \sstsubsection{
         Y\_IN ( NDP ) = REAL (Given)
      }{
         Y coordinates of input data
      }
      \sstsubsection{
         DATA\_IN ( NDP ) = REAL (Given)
      }{
         Data values for each X,Y
      }
      \sstsubsection{
         N\_PTS = INTEGER (Given)
      }{
         Number of points in output grid
      }
      \sstsubsection{
         X\_OUT ( N\_PTS ) = REAL (Given)
      }{
         X coordinates of output points
      }
      \sstsubsection{
         Y\_OUT ( N\_PTS ) = REAL (Given)
      }{
         Y coordinates of output points
      }
      \sstsubsection{
         DATA\_OUT ( N\_PTS ) = REAL (Returned)
      }{
         Output data values
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_SPLINE\_PDA\_IDSFFT
}{
   Fit a surface to an irregular grid using the PDA function PDA\_IDSFFT
}{
   \sstdescription{
      This routine provides a wrapper for the PDA\_IDSFFT spline interpolation
      routine. The quirks of the algorithm are dealt with here so that
      SCULIB\_SPLINE\_REGRID does not have to know anything about the
      interpolation routine.
   }
   \sstinvocation{
       CALL SCULIB\_SPLINE\_PDA\_IDSFFT (NDP, X\_IN, Y\_IN, DATA\_IN,
         NX\_OUT, NY\_OUT, X\_OUT, Y\_OUT, DATA\_OUT, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         NDP = INTEGER (Given)
      }{
         Number of data points on irregular grid
      }
      \sstsubsection{
         X\_IN ( NDP ) = REAL (Given)
      }{
         X coordinates of input data
      }
      \sstsubsection{
         Y\_IN ( NDP ) = REAL (Given)
      }{
         Y coordinates of input data
      }
      \sstsubsection{
         DATA\_IN ( NDP ) = REAL (Given)
      }{
         Data values for each X,Y
      }
      \sstsubsection{
         NX\_OUT = INTEGER (Given)
      }{
         Number of pixels in X direction
      }
      \sstsubsection{
         NY\_OUT = INTEGER (Given)
      }{
         Number of pixels in Y direction
      }
      \sstsubsection{
         X\_OUT ( NX\_OUT ) = REAL (Given)
      }{
         X coordinates of output points
      }
      \sstsubsection{
         Y\_OUT ( NY\_OUT ) = REAL (Given)
      }{
         Y coordinates of output points
      }
      \sstsubsection{
         DATA\_OUT ( NX\_OUT, NY\_OUT ) = REAL (Returned)
      }{
         Output data values
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_SPLINE\_PDA\_SURFIT
}{
   Fit a surface to an irregular grid using the PDA function PDA\_SURFIT
}{
   \sstdescription{
      This routine provides a wrapper for the PDA\_SURFIT spline interpolation
      routine. The quirks of the algorithm are dealt with here so that
      SCULIB\_SPLINE\_REGRID does not have to know anything about the interpolation
      routine.
   }
   \sstinvocation{
       CALL SCULIB\_SPLINE\_PDA\_SURFIT (NDP, X\_IN, Y\_IN, DATA\_IN,
          VARIANCE\_IN, NX\_OUT, NY\_OUT, X\_OUT, Y\_OUT, DATA\_OUT, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         NDP = INTEGER (Given)
      }{
         Number of data points on irregular grid
      }
      \sstsubsection{
         S = REAL (Given)
      }{
         Smoothness factor
      }
      \sstsubsection{
         X\_IN ( NDP ) = REAL (Given)
      }{
         X coordinates of input data
      }
      \sstsubsection{
         Y\_IN ( NDP ) = REAL (Given)
      }{
         Y coordinates of input data
      }
      \sstsubsection{
         DATA\_IN ( NDP ) = REAL (Given)
      }{
         Data values for each X,Y
      }
      \sstsubsection{
         VARIANCE\_IN ( NDP ) = REAL (Given)
      }{
         Variance for each data value
      }
      \sstsubsection{
         NX\_OUT = INTEGER (Given)
      }{
         Number of pixels in X direction
      }
      \sstsubsection{
         NY\_OUT = INTEGER (Given)
      }{
         Number of pixels in Y direction
      }
      \sstsubsection{
         X\_OUT ( NX\_OUT ) = REAL (Given)
      }{
         X coordinates of output points
      }
      \sstsubsection{
         Y\_OUT ( NY\_OUT ) = REAL (Given)
      }{
         Y coordinates of output points
      }
      \sstsubsection{
         DATA\_OUT ( NX\_OUT, NY\_OUT ) = REAL (Returned)
      }{
         Output data values
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_SPLINE\_REGRID
}{
   Regrid supplied data onto a rectangular grid using a spline
}{
   \sstdescription{
      This routine takes data with a variance array and x y positions
      and regrids it onto a rectangular grid using a spline interpolation
      algorithm (from PDA). Each integration is regridded separately and
      added into a mean output image.
   }
   \sstinvocation{
       CALL SCULIB\_SPLINE\_REGRID( METHOD, SFACTOR, MAX\_MAPS, N\_MAPS,
            N\_BOLS, N\_INTS, DIAMETER, WAVELENGTH, PXSIZE, NX\_OUT, NY\_OUT,
            I\_CENTRE, J\_CENTRE, WEIGHT, INT\_PTR, DATA\_PTR, VAR\_PTR,
            XPOS\_PTR,YPOS\_PTR, OUT\_DATA, OUT\_VARIANCE,
            OUT\_QUALITY, OUT\_WEIGHT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         METHOD = CHARACTER (Given)
      }{
         Spline method to use.
      }
      \sstsubsection{
         SFACTOR = REAL (Given)
      }{
         Smoothing factor to be used for PDA\_SURFIT
      }
      \sstsubsection{
         MAX\_MAPS = INTEGER (Given)
      }{
         Max allowed number of input maps (eg FILES in rebin)
      }
      \sstsubsection{
         N\_MAPS = INTEGER (Given)
      }{
         Number of input maps
      }
      \sstsubsection{
         N\_BOLS( N\_MAPS ) = INTEGER (Given)
      }{
         Number of bolometers in each map
      }
      \sstsubsection{
         MAX\_INTS = INTEGER (Given)
      }{
         Maximum number of separate integrations
      }
      \sstsubsection{
         N\_INTS( N\_MAPS ) = INTEGER (Given)
      }{
         Number of integrations in each input map
      }
      \sstsubsection{
         DIAMETER = REAL (Given)
      }{
         Diameter of dish in metres
      }
      \sstsubsection{
         WAVELENGTH = REAL (Given)
      }{
         Wavelength of observation
      }
      \sstsubsection{
         PXSIZE = REAL (Given)
      }{
         Pixel size of output map (radians)
      }
      \sstsubsection{
         NX\_OUT = INTEGER (Given)
      }{
         Number of X pixels in output map
      }
      \sstsubsection{
         NY\_OUT = INTEGER (Given)
      }{
         Number of Y pixels in output map
      }
      \sstsubsection{
         I\_CENTRE = INTEGER (Given)
      }{
         Reference pixel in X
      }
      \sstsubsection{
         J\_CENTRE = INTEGER (Given)
      }{
         Reference pixel in Y
      }
      \sstsubsection{
         WEIGHT( N\_MAPS ) = REAL (Given)
      }{
         Relative weight of each input map
      }
      \sstsubsection{
         INT\_LIST( MAX\_MAPS, MAX\_INTS $+$ 1 ) = INTEGER (Given)
      }{
         Position of each integration in data (cf DEM\_PNTR for integrations)
      }
      \sstsubsection{
         DATA\_PTR( N\_MAPS ) = INTEGER (Given)
      }{
         Array of pointers to input data
      }
      \sstsubsection{
         VAR\_PTR( N\_MAPS ) = INTEGER (Given)
      }{
         Array of pointers to input data variance
      }
      \sstsubsection{
         XPOS\_PTR( N\_MAPS ) = INTEGER (Given)
      }{
         Array of pointers to input data X positions
      }
      \sstsubsection{
         YPOS\_PTR( N\_MAPS ) = INTEGER (Given)
      }{
         Array of pointers to input data Y positions
      }
      \sstsubsection{
         OUT\_DATA( NX\_OUT, NY\_OUT ) = REAL (Returned)
      }{
         Regular gridded data
      }
      \sstsubsection{
         OUT\_VARIANCE( NX\_OUT, NY\_OUT ) = REAL (Returned)
      }{
         Variance of output data
      }
      \sstsubsection{
         OUT\_DATA( NX\_OUT, NY\_OUT ) = BYTE (Returned)
      }{
         Quality of output map
      }
      \sstsubsection{
         OUT\_WEIGHT( NX\_OUT, NY\_OUT) = REAL (Returned)
      }{
         Total weight of each pixel
      }
      \sstsubsection{
         STATUS = \_INTEGER (Given \& Returned)
      }{
         Global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_SPLINE\_REGRID\_1
}{
   Calculate the areas of the output map that contain good data points
}{
   \sstdescription{
      Calculate the areas of the output map that will be affected by
      points in the input data array. This is used to generate a mask
      so that the rebinned output map only contains data points close
      to input data. Similar to SCULIB\_WTFN\_REGRID\_1.
   }
   \sstinvocation{
       CALL SCULIB\_SPLINE\_REGRID\_1 (DIAMETER, WAVELENGTH,
            IN\_DATA, X, Y, NPIX,
            PIXSPACE, NI, NJ, ICEN, JCEN, QUALITY, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         DIAMETER   = REAL (Given)
      }{
         Diameter of telescope
      }
      \sstsubsection{
         WAVELENGTH = REAL (Given)
      }{
         Wavelength of the observation
      }
      \sstsubsection{
         IN\_DATA (NPIX)                   = REAL (Given)
      }{
         The input data values. (Used to define quality)
      }
      \sstsubsection{
         X( NPIX ) = REAL (Given)
      }{
         The x coordinates of the input pixels
      }
      \sstsubsection{
         Y( NPIX ) = REAL (Given)
      }{
         The y coordinates of the input pixels
      }
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         the number of input pixels
      }
      \sstsubsection{
         PIXSPACE = DOUBLE PRECISION (Given)
      }{
         the pixel spacing of the output pixels
      }
      \sstsubsection{
         NI = INTEGER (Given)
      }{
         The number of output pixels in the x direction
      }
      \sstsubsection{
         NJ = INTEGER (Given)
      }{
         The number of output pixels in the y direction
      }
      \sstsubsection{
         ICEN = INTEGER (Given)
      }{
         the x index of the centre of the output array
      }
      \sstsubsection{
         JCEN = INTEGER (Given)
      }{
         the y index of the centre of the output array
      }
      \sstsubsection{
         SCRATCH (NI, NJ) = UBYTE (Returned)
      }{
         Quality mask
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_SPLIT\_FILE\_SPEC
}{
   Splits a string into a filename and SCUBA section
}{
   \sstdescription{
      This routine takes a string and returns the filename (ie text
      before a \{) and the data specifications. Each specification
      is indicated by a \{\}. More than one spec can be returned.
      If the string contains a {\tt '}!{\tt '} then we will use the invers of the
      specified section.
   }
   \sstinvocation{
       CALL SCULIB\_SPLIT\_FILE\_SPEC( NAME, MAX\_SPEC, FILENAME, NSPEC,
            DATA\_SPEC, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         NAME = CHAR (Given)
      }{
         Input string
      }
      \sstsubsection{
         MAX\_SPEC = INTEGER (Given)
      }{
         Max number of specifications allowed
      }
      \sstsubsection{
         FILENAME = CHAR (Returned)
      }{
         The name of the file (text before first spec)
      }
      \sstsubsection{
         NSPEC = INTEGER (Returned)
      }{
         Number of specs found/returned (can be 0)
      }
      \sstsubsection{
         DATA\_SPEC(NSPEC) = CHAR (Returned)
      }{
         The actual specification for the SCUBA section
      }
      \sstsubsection{
         USE\_SECTION = LOGICAL (Returned)
      }{
         Set to true by default and false if a {\tt '}-{\tt '} is found
         at the end of the section (ie after last closing brace) --
         a {\tt '}-{\tt '} indicates that we are using the inverse of the section.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         Global Status value
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_SQROOTR
}{
   take the square root of a real array
}{
   \sstdescription{
      Puts square root of real input array into output array. If FLAGGED and
      QUALITY are both false then negative input numbers give a zero output.
      If FLAGGED is true then input bad values, or negative input numbers,
      give a bad output. If QUALITY is true then input values with bad
      quality, or negative input numbers, lead to zero output data and bad
      output quality.
   }
   \sstinvocation{
       CALL SCULIB\_SQROOTR (N, IN\_DATA, IN\_QUAL, ROOT, ROOT\_QUAL, QUALITY,
          FLAGGED)
   }
   \sstarguments{
      \sstsubsection{
         N                       = INTEGER (Given)
      }{
         the number of array elements
      }
      \sstsubsection{
         IN\_DATA (N)             = REAL (Given)
      }{
         the array whose root is to be taken
      }
      \sstsubsection{
         IN\_QUAL (N)             = INTEGER (Given)
      }{
         the quality on the input data
      }
      \sstsubsection{
         ROOT (N)                = REAL (Returned)
      }{
         the array to hold the square roots (may be the same as IN\_DATA)
      }
      \sstsubsection{
         ROOT\_QUAL (N)           = INTEGER (Returned)
      }{
         the quality on the output root
      }
      \sstsubsection{
         QUALITY                 = LOGICAL (Given)
      }{
         .TRUE. if input quality array exists
      }
      \sstsubsection{
         FLAGGED                 = LOGICAL (Given)
      }{
         .TRUE. if input data has flagged values
      }
   }
   \sstnotes{
      Consider using VEC\_SQRTR (SUN/39) instead.
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
   \sstimplementationstatus{
      Uses INTEGER rather than BYTE Quality.
   }
}
\sstroutine{
   SCULIB\_STANDARD\_APPARENT
}{
   convert apparent RA,Decs from one date to another
}{
   \sstdescription{
      This routine converts a list of apparent RA,Decs for one date into
      apparent coordinates at another. To do this it calls SLA\_MAPPA and
      SLA\_AMPQK to convert the input coordinates into mean coordinates for
      a J2000.0 equinox, then SLA\_MAPPA and SLA\_MAPQKZ to convert the mean
      coordinates into apparent on the output date.
   }
   \sstinvocation{
       CALL SCULIB\_STANDARD\_APPARENT (N, RA\_APP, DEC\_APP, IN\_MJD, OUT\_MJD,
         STATUS)
   }
   \sstarguments{
      \sstsubsection{
         N                      = INTEGER (Given)
      }{
         number of positions to be converted
      }
      \sstsubsection{
         RA\_APP (N)             = DOUBLE PRECISION (Given and returned)
      }{
         apparent RA (radians)
      }
      \sstsubsection{
         DEC\_APP (N)            = DOUBLE PRECISION (Given and returned)
      }{
         apparent Dec (radians)
      }
      \sstsubsection{
         IN\_MJD                 = DOUBLE PRECISION (Given)
      }{
         date of input coordinates (modified Julian day)
      }
      \sstsubsection{
         OUT\_MJD                = DOUBLE PRECISION (Given)
      }{
         date of output coordinates (modified Julian day)
      }
      \sstsubsection{
         STATUS                 = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_STATD
}{
   To calculate mean and standard deviation of a DOUBLE array
}{
   \sstdescription{
      This routine calculates the mean and standard deviation of
      a double array. If a positive value of CLIP is given, the data
      set will be clipped at CLIP sigma repeatedly until all
      points are within CLIP sigma. Mean and standard deviation are those
      values derived after iterative clipping.
   }
   \sstinvocation{
       CALL SCULIB\_STATD(N\_POS, SCUDATA, SCUQUAL, BADBIT,
            NGOOD, MEAN, MEDIAN, SUM, SUMSQ, STDEV, QSORT, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         N\_POS = \_INTEGER (Given)
      }{
         Number of jiggle positions in data set
      }
      \sstsubsection{
         CLIP = \_REAL (Given)
      }{
         Number of sigma to clip iteratively
      }
      \sstsubsection{
         SCUDATA(N\_POS) = \_DOUBLE (Given)
      }{
         The data
      }
      \sstsubsection{
         SCUQUAL(N\_POS) = \_BYTE (Given)
      }{
         The data quality
      }
      \sstsubsection{
         BADBIT = \_BYTE (Given)
      }{
         Bad bit mask
      }
      \sstsubsection{
         NGOOD = \_INTEGER (Returned)
      }{
         Number of good pixels in mean
      }
      \sstsubsection{
         MEAN = \_DOUBLE (Returned)
      }{
         Mean value
      }
      \sstsubsection{
         MEDIAN = \_DOUBLE (Returned)
      }{
         Median of good data
      }
      \sstsubsection{
         SUM = \_DOUBLE (Returned)
      }{
         Data sum
      }
      \sstsubsection{
         SUMSQ = \_DOUBLE (Returned)
      }{
         Sum of squares
      }
      \sstsubsection{
         STDEV = \_DOUBLE (Returned)
      }{
         Standard deviation
      }
      \sstsubsection{
         QSORT = \_DOUBLE (Returned)
      }{
         Sorted data set
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         Global Status value
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         Deals with bad pixels

         \sstitem
         Uses PDA sort routine
      }
   }
}
\sstroutine{
   SCULIB\_STATR
}{
   To calculate mean and standard deviation of a REAL array
}{
   \sstdescription{
      This routine calculates the mean and standard deviation of
      a real array. If a positive value of CLIP is given, the data
      set will be clipped at CLIP sigma repeatedly until all
      points are within CLIP sigma. Mean and standard deviation are those
      values derived after iterative clipping.
   }
   \sstinvocation{
       CALL SCULIB\_STATR(N\_POS, SCUDATA, SCUQUAL, BADBIT,
            NGOOD, MEAN, MEDIAN, SUM, SUMSQ, STDEV, QSORT, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         N\_POS = \_INTEGER (Given)
      }{
         Number of jiggle positions in data set
      }
      \sstsubsection{
         CLIP = \_REAL (Given)
      }{
         Number of sigma to clip iteratively
      }
      \sstsubsection{
         SCUDATA(N\_POS) = \_REAL (Given)
      }{
         The data
      }
      \sstsubsection{
         SCUQUAL(N\_POS) = \_BYTE (Given)
      }{
         The data quality
      }
      \sstsubsection{
         BADBIT = \_BYTE (Given)
      }{
         Bad bit mask
      }
      \sstsubsection{
         NGOOD = \_INTEGER (Returned)
      }{
         Number of good pixels in mean
      }
      \sstsubsection{
         MEAN = \_DOUBLE (Returned)
      }{
         Mean value
      }
      \sstsubsection{
         MEDIAN = \_DOUBLE (Returned)
      }{
         Median of good data
      }
      \sstsubsection{
         SUM = \_DOUBLE (Returned)
      }{
         Data sum
      }
      \sstsubsection{
         SUMSQ = \_DOUBLE (Returned)
      }{
         Sum of squares
      }
      \sstsubsection{
         STDEV = \_DOUBLE (Returned)
      }{
         Standard deviation
      }
      \sstsubsection{
         QSORT = \_REAL (Returned)
      }{
         Sorted data set
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         Global Status value
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         Deals with bad pixels

         \sstitem
         Uses PDA sort routine
      }
   }
}
\sstroutine{
   SCULIB\_SUB\_TAUZ
}{
   get tauz appropriate for each sub-instrument
}{
   \sstdescription{
      This routine finds the zenith sky optical depth appropriate for the
      filter in front of each sub-instrument being used. If it cannot find
      an optical depth for the required filter the routine will output a
      warning message and return an optical depth of 0.0.

      The times and dates at which the optical depths were measured are also
      returned. If the optical depth for the required filter cannot be found
      then the date will be that at which the routine is run.
   }
   \sstinvocation{
       CALL SCULIB\_GET\_TAUZ (N\_SUBS, SUB\_FILTER, N\_SKY, SKY\_FILTER,
         SKY\_TAUZ, SKY\_DAY, SUB\_TAUZ, SUB\_DAY, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         N\_SUBS                         = INTEGER (Given)
      }{
         number of sub-instruments
      }
      \sstsubsection{
         SUB\_FILTER (N\_SUBS)            = CHARACTER$*$($*$) (Given)
      }{
         names of filters in front of sub-instruments
      }
      \sstsubsection{
         N\_SKY                          = INTEGER (Given)
      }{
         number of filters for which data is available
      }
      \sstsubsection{
         SKY\_FILTER (N\_SKY)             = CHARACTER$*$($*$) (Given)
      }{
         filters for which data is available
      }
      \sstsubsection{
         SKY\_TAUZ (N\_SKY)               = REAL (Given)
      }{
         tauz for each possible filter
      }
      \sstsubsection{
         SKY\_DAY (N\_SKY)                = DOUBLE PRECISION (Given)
      }{
         the date and time of the tauz measurement specified as day
         number since 1st Jan.
      }
      \sstsubsection{
         SUB\_TAUZ (N\_SUBS)              = REAL (Returned)
      }{
         tauz appropriate to sub-instruments
      }
      \sstsubsection{
         SUB\_DAY (N\_SUBS)               = DOUBLE PRECISION (Returned)
      }{
         the date and time of the tauz measurement
      }
      \sstsubsection{
         STATUS                         = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_SUBARE
}{
   subtract one real array from another into a third
}{
   \sstdescription{
      Subtracts two real arrays. Note that any of the arrays may be the same.
   }
   \sstinvocation{
       CALL SCULIB\_SUBARE (N, ARRAY1, ARRAY2, ARRAY3, Q1DATA,
          Q2DATA, Q3DATA, V1DATA, V2DATA, V3DATA, QUALITY, FLAGGED,
          VARIANCE)
   }
   \sstarguments{
      \sstsubsection{
         N            = INTEGER (Given)
      }{
         Number of elements in each array
      }
      \sstsubsection{
         ARRAY1 (N)   = REAL (Given)
      }{
         Input array
      }
      \sstsubsection{
         ARRAY2 (N)   = REAL (Given)
      }{
         Second input array
      }
      \sstsubsection{
         ARRAY3 (N)   = REAL (Returned)
      }{
         Result array.  ARRAY3 = ARRAY1 - ARRAY2
      }
      \sstsubsection{
         Q1DATA (N)   = INTEGER (Given)
      }{
         Quality array for first input array
      }
      \sstsubsection{
         Q2DATA (N)   = INTEGER (Given)
      }{
         Quality array for second input array
      }
      \sstsubsection{
         Q3DATA (N)   = INTEGER (Returned)
      }{
         Quality array for output array
      }
      \sstsubsection{
         V1DATA (N)   = REAL (Given)
      }{
         Variance array for first input array
      }
      \sstsubsection{
         V2DATA (N)   = REAL (Given)
      }{
         Variance array for second input array
      }
      \sstsubsection{
         V3DATA (N)   = REAL (Returned)
      }{
         Variance array for output array
      }
      \sstsubsection{
         QUALITY      = LOGICAL (Given)
      }{
         True if input has quality information
      }
      \sstsubsection{
         FLAGGED      = LOGICAL (Given)
      }{
         True if input has flagged data values
      }
      \sstsubsection{
         VARIANCE     = LOGICAL (Given)
      }{
         True if both input arrays have variance arrays
      }
   }
   \sstnotes{
      Consider using VEC\_SUBR (SUN/39) instead
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_SUMAD
}{
   sum the elements of a double precision array
}{
   \sstdescription{
      This routine adds up the NELM elements of the double precision ARRAY
      and puts the result in SUM.
   }
   \sstinvocation{
      CALL SCULIB\_SUMAD (NELM, ARRAY, SUM)
   }
   \sstarguments{
      \sstsubsection{
         NELM               = INTEGER (Given)
      }{
         the number of elements in the array
      }
      \sstsubsection{
         ARRAY (NELM)       = DOUBLE PRECISION (Given)
      }{
         the array whose elements are to be summed
      }
      \sstsubsection{
         SUM                = DOUBLE PRECISION (Returned)
      }{
         the sum
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
   \sstimplementationstatus{
      No status checking
   }
}
\sstroutine{
   SCULIB\_TIDY\_LINE
}{
   remove tabs and comments from a line
}{
   \sstdescription{
      This routine tidies up a character string and returns its length
      ignoring trailing blanks. If the returned length is 0 the returned
      string will be {\tt '} {\tt '}, otherwise it will be equal to the input string
      truncated at the used length.

      The tidying involves:-
      \sstitemlist{

         \sstitem
          calling CHR\_CLEAN to remove non-printable characters.

         \sstitem
          replacing all HT (tab) characters by spaces.

         \sstitem
          truncating the string at the character before a COMCHAR character, if
            present (the characters after COMCHAR are assumed to be comments).
      }
   }
   \sstinvocation{
      CALL SCULIB\_TIDY\_LINE (COMCHAR, LINE, LENGTH)
   }
   \sstarguments{
      \sstsubsection{
         COMCHAR    = CHARACTER$*$1 (Given)
      }{
         the character at the beginning of a comment
      }
      \sstsubsection{
         LINE       = CHARACTER$*$($*$) (Given and returned)
      }{
         the line to be tidied
      }
      \sstsubsection{
         LENGTH     = INTEGER (Returned)
      }{
         the length of the string, ignoring trailing blanks
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_UNPACK
}{
   routine to unpack compressed resampled map
}{
   \sstdescription{
      This routine unpacks a compressed SCUBA resampled data array into
      a 2-d image. It does this by cycling up the j slices of the image
      and -

         if the packed data has pixels for that slice
      \sstitemlist{

         \sstitem
              fill the image slice data (data sum, variance sum and weight sum)
                 with zeroes and bad quality before the packed slice starts.

         \sstitem
              copy the data and quality of the packed slice into the appropriate
                 part of the image slice

         \sstitem
              fill the image slice with zeroes and bad quality after the packed
                 slice ends.

      }
         else
      \sstitemlist{

         \sstitem
              fill the image slice with zeroes and bad quality

      }
         endif
   }
   \sstinvocation{
       CALL SCULIB\_UNPACK (NBS\_DIM1, NBS\_DIM2, NBS\_DIM3,
          RESNBS, ISTART, NPIX, POINTER, SUB, RES\_DIM1, RES\_DIM2,
          RES\_DS, RES\_VS, RES\_WS, RES\_QS)
   }
   \sstarguments{
      \sstsubsection{
         NBS\_DIM1                            = INTEGER (Given)
      }{
         first dimension of the RESNBS array
      }
      \sstsubsection{
         NBS\_DIM2                            = INTEGER (Given)
      }{
         second dimension of the RESNBS array
      }
      \sstsubsection{
         NBS\_DIM3                            = INTEGER (Given)
      }{
         third dimension of the RESNBS array
      }
      \sstsubsection{
         RESNBS (NBS\_DIM1, NBS\_DIM2, NBS\_DIM3)) = REAL (Given)
      }{
         the noticeboard `resampled data{\tt '}
      }
      \sstsubsection{
         ISTART (RES\_DIM2)                   = INTEGER (Given)
      }{
         the I index of the start of each packed slice
      }
      \sstsubsection{
         NPIX (RES\_DIM2)                     = INTEGER (Given)
      }{
         the number of pixels in each packed slice
      }
      \sstsubsection{
         POINTER (RES\_DIM2)                  = INTEGER (Given)
      }{
         the pointer to the start of each packed slice
      }
      \sstsubsection{
         SUB                                 = INTEGER (Given)
      }{
         the number of the sub-instrument map to be unpacked
      }
      \sstsubsection{
         RES\_DIM1                            = INTEGER (Given)
      }{
         first dimension of resampled image array
      }
      \sstsubsection{
         RES\_DIM2                            = INTEGER (Given)
      }{
         second dimension of resampled image array
      }
      \sstsubsection{
         RES\_DS (RES\_DIM1, RES\_DIM2)         = REAL (Returned)
      }{
         the unpacked data sum
      }
      \sstsubsection{
         RES\_VS (RES\_DIM1, RES\_DIM2)         = REAL (Returned)
      }{
         the unpacked variance sum
      }
      \sstsubsection{
         RES\_WS (RES\_DIM1, RES\_DIM2)         = REAL (Returned)
      }{
         the unpacked weight sum
      }
      \sstsubsection{
         RES\_QS (RES\_DIM1, RES\_DIM2)         = INTEGER (Returned)
      }{
         the unpacked quality
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1993-1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_UNPACK\_CHOPSCAN
}{
   routine to unpack compressed chop-scan data
}{
   \sstdescription{
      Used by the on-line system to unpack notice-board entries
      and retrieve demodulated data.
   }
   \sstinvocation{
       CALL SCULIB\_UNPACK\_CHOPSCAN (RESNBS, N\_POINTS, ISTART,
          NPIX, POINTER, RESDATA\_450, RESWT\_450, RESDATA\_850, RESWT\_850,
          RESDIM1, RESDIM2, BAD)
   }
   \sstarguments{
      \sstsubsection{
         RESNBS (4, N\_POINTS)                = REAL (Given)
      }{
         the `resampled data{\tt '} noticeboard
      }
      \sstsubsection{
         N\_POINTS                            = INTEGER (Given)
      }{
         the 2nd dimension of the RESNBS array
      }
      \sstsubsection{
         ISTART (RESDIM2)                    = INTEGER (Given)
      }{
         the I index of the start of the packed slice at index J
      }
      \sstsubsection{
         NPIX (RESDIM2)                      = INTEGER (Given)
      }{
         the number of pixels in the packed slice for row J
      }
      \sstsubsection{
         POINTER (RESDIM2)                   = INTEGER (Given)
      }{
         the pointer to the start of the slice in the packed array
      }
      \sstsubsection{
         RESDATA\_450 (RESDIM1, RESDIM2)      = REAL (Returned)
      }{
         the unpacked 450 data
      }
      \sstsubsection{
         RESWT\_450 (RESDIM1, RESDIM2)        = REAL (Returned)
      }{
         450 weights
      }
      \sstsubsection{
         RESDATA\_850 (RESDIM1, RESDIM2)      = REAL (Returned)
      }{
         the unpacked 850 image
      }
      \sstsubsection{
         RESWT\_850 (RESDIM1, RESDIM2)        = REAL (Returned)
      }{
         850 weights
      }
      \sstsubsection{
         RESDIM1                             = INTEGER (Given)
      }{
         first dimension of resampled image array
      }
      \sstsubsection{
         RESDIM2                             = INTEGER (Given)
      }{
         second dimension
      }
      \sstsubsection{
         BAD                                 = REAL (Given)
      }{
         value signalling bad pixel
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_UNPACK\_JIGGLE
}{
   unpack demodulated data onto 2-d map
}{
   \sstdescription{
      This routine unpacks the demodulated data from a switch onto a
      rectangular 2-d map.

         If status is good on entry the data and variance of the output map
      will be initialised to `bad{\tt '} values, the quality to 1. If there are
      any data to unpack the routine will then attempt to do so. The method
      used depends on whether the switch covered part/all of the entire jiggle
      pattern or contains data for several repeats of the jiggle pattern.

         In the first case, the routine will check that the indices of the
      section of jiggle pattern covered by this switch lie within the bounds
      of the full jiggle pattern. If not, an error will be reported and bad
      status returned. Otherwise, the datablock will be unpacked into the
      map as specified by the I\_JIGGLE, J\_JIGGLE arrays. Each map point
      just has its data, variance and quality copied from the demodulated
      data.

         When the data covers several repeats of the jiggle pattern, the
      routine will check that the jiggle index of the first point in the
      datablock is 1 and that the number of data points is an integer multiple
      of the size of the jiggle. If not, an error will be reported and bad
      status returned. Otherwise, the datablock will be unpacked into the
      map as specified by I\_JIGGLE, J\_JIGGLE. The unpacking differs from
      the first case in that demodulated data with bad quality will be
      ignored. Points in the unpacked map will be set to the average of the
      values contributed by the separate jiggles, variances will be calculated
      from the dispersion of the values about the mean if there was more than
      1, or set to the demodulated variance otherwise.
   }
   \sstinvocation{
       CALL SCULIB\_UNPACK\_JIGGLE (N\_JIGGLES, N\_BOLS, DEMOD,
         J\_START, JIGGLE\_COUNT, I\_JIGGLE, J\_JIGGLE, IDIM, JDIM,
         MAP\_DATA, MAP\_VARIANCE, MAP\_QUALITY, J\_END, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         N\_JIGGLES                         = INTEGER (Given)
      }{
         number of jiggles in datablock
      }
      \sstsubsection{
         N\_BOLS                            = INTEGER (Given)
      }{
         number of bolometers measured
      }
      \sstsubsection{
         DEMOD (4, N\_BOLS, N\_JIGGLES)      = REAL (Given)
      }{
         demodulated data
      }
      \sstsubsection{
         J\_START                           = INTEGER (Given)
      }{
         index of first jiggle in datablock in the overall jiggle pattern
      }
      \sstsubsection{
         JIGGLE\_COUNT                      = INTEGER (Given)
      }{
         number of jiggles in jiggle pattern
      }
      \sstsubsection{
         I\_JIGGLE (JIGGLE\_COUNT)           = INTEGER (Given)
      }{
         i index in output map of each jiggle position in pattern
      }
      \sstsubsection{
         J\_JIGGLE (JIGGLE\_COUNT)           = INTEGER (Given)
      }{
         j index in output map of each jiggle position in pattern
      }
      \sstsubsection{
         IDIM                              = INTEGER (Given)
      }{
         i dimension of output map
      }
      \sstsubsection{
         JDIM                              = INTEGER (Given)
      }{
         j dimension of output map
      }
      \sstsubsection{
         MAP\_DATA (IDIM, JDIM, N\_BOLS)     = REAL (Returned)
      }{
         output map data
      }
      \sstsubsection{
         MAP\_VARIANCE (IDIM, JDIM, N\_BOLS) = REAL (Returned)
      }{
         output map variance
      }
      \sstsubsection{
         MAP\_QUALITY (IDIM, JDIM, N\_BOLS)  = INTEGER (Returned)
      }{
         output map quality
      }
      \sstsubsection{
         J\_END                             = INTEGER (Returned)
      }{
         index of last jiggle in datablock in the overall jiggle pattern
      }
      \sstsubsection{
         STATUS                            = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1993-1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_UNPACK\_JIGGLE\_SEPARATES
}{
   unpack jiggle data arrays onto 2-d map
}{
   \sstdescription{
      This routine unpacks data from a jiggle observation into a
      rectangular 2-d map.

         If status is good on entry the data and variance of the output map
      will be initialised to `bad{\tt '} values, the quality to 1. If there are
      any data to unpack the routine will then attempt to do so. The method
      used depends on whether the switch covered part/all of the entire jiggle
      pattern or contains data for several repeats of the jiggle pattern.

         In the first case, the routine will check that the indices of the
      section of jiggle pattern covered by this switch lie within the bounds
      of the full jiggle pattern. If not, an error will be reported and bad
      status returned. Otherwise, the data will be unpacked into the
      map as specified by the I\_JIGGLE, J\_JIGGLE arrays.

         When the data cover several repeats of the jiggle pattern, the
      routine will check that the jiggle index of the first point in the
      datablock is 1 and that the number of data points is an integer multiple
      of the size of the jiggle. If not, an error will be reported and bad
      status returned. Otherwise, the data will be unpacked into the
      map as specified by I\_JIGGLE, J\_JIGGLE. The unpacking differs from
      the first case in that points in the unpacked map will be set to the
      average of the good quality values contributed by the separate jiggles,
      variances will be calculated from the dispersion of the values about
      the mean if there was more than 1, or set to the input variance
      otherwise.
   }
   \sstinvocation{
       CALL SCULIB\_UNPACK\_JIGGLE\_SEPARATES (N\_JIGGLES, N\_BOLS, J\_DATA,
         J\_VARIANCE, J\_QUALITY, J\_START, JIGGLE\_COUNT, I\_JIGGLE,
         J\_JIGGLE, IDIM, JDIM, MAP\_DATA, MAP\_VARIANCE, MAP\_QUALITY, MAP\_NUMPTS,
         J\_END, BADBIT, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         N\_JIGGLES                         = INTEGER (Given)
      }{
         number of jiggles in datablock
      }
      \sstsubsection{
         N\_BOLS                            = INTEGER (Given)
      }{
         number of bolometers measured
      }
      \sstsubsection{
         J\_DATA (N\_BOLS, N\_JIGGLES)        = REAL (Given)
      }{
         data for each jiggle measured
      }
      \sstsubsection{
         J\_VARIANCE (N\_BOLS, N\_JIGGLES)    = REAL (Given)
      }{
         variance on J\_DATA
      }
      \sstsubsection{
         J\_QUALITY (N\_BOLS, N\_JIGGLES)     = BYTE (Given)
      }{
         quality on J\_DATA
      }
      \sstsubsection{
         J\_START                           = INTEGER (Given)
      }{
         index of first jiggle in datablock in the overall jiggle pattern
      }
      \sstsubsection{
         JIGGLE\_COUNT                      = INTEGER (Given)
      }{
         number of jiggles in jiggle pattern
      }
      \sstsubsection{
         I\_JIGGLE (JIGGLE\_COUNT)           = INTEGER (Given)
      }{
         i index in output map of each jiggle position in pattern
      }
      \sstsubsection{
         J\_JIGGLE (JIGGLE\_COUNT)           = INTEGER (Given)
      }{
         j index in output map of each jiggle position in pattern
      }
      \sstsubsection{
         IDIM                              = INTEGER (Given)
      }{
         i dimension of output map
      }
      \sstsubsection{
         JDIM                              = INTEGER (Given)
      }{
         j dimension of output map
      }
      \sstsubsection{
         MAP\_DATA (IDIM, JDIM, N\_BOLS)     = REAL (Returned)
      }{
         output map data
      }
      \sstsubsection{
         MAP\_VARIANCE (IDIM, JDIM, N\_BOLS) = REAL (Returned)
      }{
         output map variance
      }
      \sstsubsection{
         MAP\_NUMPTS (IDIM, JDIM, N\_BOLS)   = INTEGER (Returned)
      }{
         output map quality
      }
      \sstsubsection{
         MAP\_QUALITY (IDIM, JDIM, N\_BOLS)  = BYTE (Returned)
      }{
         output map quality
      }
      \sstsubsection{
         J\_END                             = INTEGER (Returned)
      }{
         index of last jiggle in datablock in the overall jiggle pattern
      }
      \sstsubsection{
         BADBIT                            = BYTE  (Given)
      }{
         bad bit mask
      }
      \sstsubsection{
         STATUS                            = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_UT1
}{
   returns UT1 as a modified Julian day
}{
   \sstdescription{
      Return the current modified Julian day calculated for Hawaiian
      local time.
   }
   \sstinvocation{
      UT1 = SCULIB\_UT1
   }
   \sstarguments{
      \sstsubsection{
         None
      }{
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         SCULIB\_UT1 = DOUBLE PRECISION
      }{
         UT1 expressed as a modified Julian day (JD - 2400000.5)
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Depends on system clock for local time and date

         \sstitem
         Uses the IDATE function to retrieve the current date. This
         only returns a 2-digit year (not Y2K compliant) but is not
         a problem since the output is immediately passed to the SLALIB
         routine SLA\_CALDJ which uses windowing to select the correct
         year.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
   \sstbugs{
      The time zone is hard-wired for Hawaii (10).
   }
}
\sstroutine{
   SCULIB\_WTFN\_REGRID
}{
   Regrid supplied data onto a rectangular grid
}{
   \sstdescription{
      This routine takes data with a variance array and x y positions
      and regrids it onto a rectangular grid using a weight function
      interpolation.

      This is an image space implementation of fourier techniques.
      In Fourier terms the technique could be described
      as follows:-
      \sstitemlist{

         \sstitem
         [1] Do a 2-d discrete Fourier transform of the data points. The result
         is a repeating pattern made up of copies of the transform of
         the map as a continuous function, each copied displaced from its
         neighbours by 1/dx, where dx is the sample spacing of the input points
         (assumed equal in x and y). Different copies of the {\tt '}continuous map{\tt '}
         transforms will overlap ({\tt '}alias{\tt '}) if there is any power in the
         map at frequencies greater than 1/(2dx). It is not possible to unravel
         aliased spectra and this constraint leads to the Nyquist sampling
         criterion.

         \sstitem
         [2] We want to derive the {\tt '}continuous map{\tt '} so that map values on the new
         grid mesh can be derived. Do this by multiplying the transform of the
         data by a function that has zero value beyond a radius of 0.5/dx from the
         origin. This will get rid of all the repeats in the pattern and leave
         just the transform of the {\tt '}continuous map{\tt '}.

         \sstitem
         [3] Do an inverse FT on the remaining transform for the points where you
         wish the resampled points to be (note: FFTs implicitly assume that the
         data being transformed DO repeat ad infinitum so we{\tt '}d have to be careful
         when using them to do this).

      }
      The analogue of these process steps in image space is as follows:
      \sstitemlist{

         \sstitem
         [1] Nothing.

         \sstitem
         [2] Convolve the input data with the FT of the function used to isolate
         the {\tt '}continuous map{\tt '} transform.

         \sstitem
         [3] Nothing.

      }
      If the method is done properly, the rebinned map is in fact the map on
      the new sample mesh that has the same FT as the continuous function
      going through the original sample points.

      Convolution Functions:-
      \sstitemlist{

         \sstitem
         [Bessel:]
         For good data and with no time constraint on reduction the best
         convolution function would be one whose FT is a flat-topped cylinder in
         frequency space, centred on the origin and of a radius such that
         frequencies to which the telescope is not sensitive are set to zero.
         Unfortunately, this function is a Bessel function, which extends to
         infinity along both axes and has significant power out to a large radius.
         To work correctly this would require an infinite map and infinite
         computing time. However, a truncated Bessel function should work well on
         a large map, except near the edges. Edge effects can be removed by
         pretending that the map extends further - of course, this only works if
         you know what data the pretend map area should contain, i.e. zeros.
         Another problem with a Bessel function arises from the fact that it does
         truncate the FT of the map sharply. If the data are good then there
         should be nothing but noise power at the truncation radius and the
         truncation of the FT should have no serious effect. However, if the data
         has spikes (power at all frequencies in the FT) or suffers from seeing
         effects such that the data as measured DO have power beyond the
         truncation radius, then this will cause ringing in the rebinned map.

         \sstitem
         [Gaussian:]
         In fact, any function that is finite in frequency space will have
         infinite extent in image space (I think). As such they will all
         drag in some power from the aliased versions of the map transform
         and all suffer from edge effects and large compute times. Some are
         worse than others, however. For example, a Gaussian can have most
         of its power concentrated over a much smaller footprint than a
         Bessel function, so the convolution calculation will be much
         faster. It is also more robust in the presence of spikes and
         seeing problems because it does not truncate the map FT as sharply
         as the Bessel function - such effects give rise to smoother
         defects in the rebinned map though the defects will still BE
         there.
      }
   }
   \sstinvocation{
       CALL SCULIB\_WTFN\_REGRID(USEGRD, N\_MAPS, N\_PTS, WTFNRAD, WTFNRES,
            WEIGHTSIZE, SCALE, DIAMETER, WAVELENGTH, PXSIZE, NX\_OUT, NY\_OUT,
            I\_CENTRE, J\_CENTRE, WTFN, WEIGHT, BOLWT, N\_BOL, MAX\_BOLS,
            DATA\_PTR, VAR\_PTR,
            XPOS\_PTR,YPOS\_PTR, OUT\_DATA, OUT\_VARIANCE,
            OUT\_QUALITY, CONV\_WEIGHT,
            STATUS)
   }
   \sstarguments{
      \sstsubsection{
         USEGRD = LOGICAL (Given)
      }{
         Use guard ring for final stage of rebin
      }
      \sstsubsection{
         N\_MAPS = INTEGER (Given)
      }{
         Number of data files read in
      }
      \sstsubsection{
         N\_PTS (N\_MAPS) = INTEGER (Given)
      }{
         Number of points in each input dataset
      }
      \sstsubsection{
         WTFNRAD = INTEGER (Given)
      }{
         Radius of largest weight function in scale lengths
      }
      \sstsubsection{
         WTFNRES = INTEGER (Given)
      }{
         Number of values per scale length in the supplied weight function
      }
      \sstsubsection{
         WEIGHTSIZE = INTEGER (Given)
      }{
         Radius of supplied weighting function
      }
      \sstsubsection{
         SCALE = REAL (Given)
      }{
         Size of a scale length in the same units as PXSIZE
      }
      \sstsubsection{
         DIAMETER = REAL (Given)
      }{
         Diameter of telescope in metres
      }
      \sstsubsection{
         WAVELENGTH = REAL (Given)
      }{
         Wavelength of map in microns
      }
      \sstsubsection{
         PXSIZE = REAL (Given)
      }{
         Pixel size in radians
      }
      \sstsubsection{
         NX\_OUT = INTEGER (Given)
      }{
         Number of pixels in X direction of output map
      }
      \sstsubsection{
         NY\_OUT = INTEGER (Given)
      }{
         Number of pixels in Y direction of output map
      }
      \sstsubsection{
         I\_CENTRE = INTEGER (Given)
      }{
         X reference pixel
      }
      \sstsubsection{
         J\_CENTRE = INTEGER (Given)
      }{
         Y reference pixel
      }
      \sstsubsection{
         WTFN() = REAL (Given)
      }{
         The weighting function
      }
      \sstsubsection{
         WEIGHT(N\_MAPS) = REAL (Given)
      }{
         The weight of each input dataset
      }
      \sstsubsection{
         BOLWT (MAX\_BOLS, N\_MAPS) = REAL (Given)
      }{
         Relative weight for each bolometer
      }
      \sstsubsection{
         N\_BOL (N\_MAPS) = INTEGER (Given)
      }{
         Number of bolometers from each map
      }
      \sstsubsection{
         MAX\_BOLS = INTEGER (Given)
      }{
         Max number of bolometers allowable in BOLWT
      }
      \sstsubsection{
         DATA\_PTR(N\_MAPS) = INTEGER (Given)
      }{
         Array of pointers to REAL input data
      }
      \sstsubsection{
         VAR\_PTR(N\_MAPS) = INTEGER (Given)
      }{
         Array of pointers to REAL input variance
      }
      \sstsubsection{
         XPOS\_PTR(N\_MAPS) = INTEGER (Given)
      }{
         Array of pointers to X bolometer positions (DOUBLE)
      }
      \sstsubsection{
         YPOS\_PTR(N\_MAPS) = INTEGER (Given)
      }{
         Array of pointers to Y bolometer positions (DOUBLE)
      }
      \sstsubsection{
         OUT\_DATA ( NX\_OUT, NY\_OUT ) = REAL (Returned)
      }{
         Output map
      }
      \sstsubsection{
         OUT\_VARIANCE ( NX\_OUT, NY\_OUT ) = REAL (Returned)
      }{
         Output variance
      }
      \sstsubsection{
         OUT\_QUALITY ( NX\_OUT, NY\_OUT ) = BYTE (Returned)
      }{
         Output quality
      }
      \sstsubsection{
         CONV\_WEIGHT ( NX\_OUT, NY\_OUT ) = REAL (Returned)
      }{
         Contribution to each pixel
      }
      \sstsubsection{
         STATUS = \_INTEGER (Given \& Returned)
      }{
         Global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_WTFN\_REGRID\_1
}{
   Calculate the coverage of the data and total weight per cell
}{
   \sstdescription{
      This routine performs two tasks:
    \sstitemlist{
      \sstitem
      [1] Determine which output pixels contain data (effectively
         detecting the edge of the useful area of the output image.

      \sstitem
      [2] For each output pixel containing data the weight of the
         map is added to the total weight. This TOTAL\_WEIGHT is then
         used to modify the behaviour when two images overlap (the
         TOTAL\_WEIGHT will be 2.0 (say) in the overlap region and
         1 elsewhere.
    }
   }
   \sstinvocation{
       CALL SCULIB\_WTFN\_REGRID\_1 (DIAMETER, WAVELENGTH, WEIGHT,
            IN\_DATA, X, Y, NPIX,
            PIXSPACE, NI, NJ, ICEN, JCEN, AV\_WEIGHT, SCRATCH, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         DIAMETER = REAL (Given)
      }{
         Diameter of telescope
      }
      \sstsubsection{
         WAVELENGTH = REAL (Given)
      }{
         Wavelength of the observation
      }
      \sstsubsection{
         WEIGHT = REAL (Given)
      }{
         The weight of the input dataset.
      }
      \sstsubsection{
         IN\_DATA (NPIX)                   = REAL (Given)
      }{
         The input data values. (Used to define quality)
      }
      \sstsubsection{
         X( NPIX ) = DOUBLE PRECISION (Given)
      }{
         The x coordinates of the input pixels
      }
      \sstsubsection{
         Y( NPIX ) = DOUBLE PRECISION (Given)
      }{
         The y coordinates of the input pixels
      }
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         the number of input pixels
      }
      \sstsubsection{
         PIXSPACE = DOUBLE PRECISION (Given)
      }{
         the pixel spacing of the output pixels
      }
      \sstsubsection{
         NI = INTEGER (Given)
      }{
         The number of output pixels in the x direction
      }
      \sstsubsection{
         NJ = INTEGER (Given)
      }{
         The number of output pixels in the y direction
      }
      \sstsubsection{
         ICEN = INTEGER (Given)
      }{
         the x index of the centre of the output array
      }
      \sstsubsection{
         JCEN = INTEGER (Given)
      }{
         the y index of the centre of the output array
      }
      \sstsubsection{
         AV\_WEIGHT (NI, NJ) = REAL (Given and Returned)
      }{
         Given as a workspace array
      }
      \sstsubsection{
         SCRATCH (NI, NJ) = INTEGER (Returned)
      }{
         Temporary workspace.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_WTFN\_REGRID\_2
}{
   Perform convolution
}{
   \sstdescription{
      This routine convolves the input data with a weighting function
      onto a regularly spaced output grid.
      The weighting function is stored in a lookup table indexed
      by the square of the distance and is parametrized by RES,
      WEIGHTSIZE, SCLSZ and WTFN.

      This is an image space implementation of fourier techniques.
      In Fourier terms the technique could be described
      as follows:-
      \sstitemlist{

         \sstitem
         [1] Do a 2-d discrete Fourier transform of the data points. The result
         is a repeating pattern made up of copies of the transform of
         the map as a continuous function, each copied displaced from its
         neighbours by 1/dx, where dx is the sample spacing of the input points
         (assumed equal in x and y). Different copies of the {\tt '}continuous map{\tt '}
         transforms will overlap ({\tt '}alias{\tt '}) if there is any power in the
         map at frequencies greater than 1/(2dx). It is not possible to unravel
         aliased spectra and this constraint leads to the Nyquist sampling
         criterion.

         \sstitem
         [2] We want to derive the {\tt '}continuous map{\tt '} so that map values on the new
         grid mesh can be derived. Do this by multiplying the transform of the
         data by a function that has zero value beyond a radius of 0.5/dx from the
         origin. This will get rid of all the repeats in the pattern and leave
         just the transform of the {\tt '}continuous map{\tt '}.

         \sstitem
         [3] Do an inverse FT on the remaining transform for the points where you
         wish the resampled points to be (note: FFTs implicitly assume that the
         data being transformed DO repeat ad infinitum so we{\tt '}d have to be careful
         when using them to do this).

      }
      The analogue of these process steps in image space is as follows:
      \sstitemlist{

         \sstitem
         [1] Nothing.

         \sstitem
         [2] Convolve the input data with the FT of the function used to isolate
         the `continuous map{\tt '} transform.

         \sstitem
         [3] Nothing.

      }
      If the method is done properly, the rebinned map is in fact the map on
      the new sample mesh that has the same FT as the continuous function
      going through the original sample points.

      Convolution Functions:-
      \sstitemlist{

         \sstitem
         [Bessel]
         For good data and with no time constraint on reduction the best
         convolution function would be one whose FT is a flat-topped cylinder in
         frequency space, centred on the origin and of a radius such that
         frequencies to which the telescope is not sensitive are set to zero.
         Unfortunately, this function is a Bessel function, which extends to
         infinity along both axes and has significant power out to a large radius.
         To work correctly this would require an infinite map and infinite
         computing time. However, a truncated Bessel function should work well on
         a large map, except near the edges. Edge effects can be removed by
         pretending that the map extends further - of course, this only works if
         you know what data the pretend map area should contain, i.e. zeros.
         Another problem with a Bessel function arises from the fact that it does
         truncate the FT of the map sharply. If the data are good then there
         should be nothing but noise power at the truncation radius and the
         truncation of the FT should have no serious effect. However, if the data
         has spikes (power at all frequencies in the FT) or suffers from seeing
         effects such that the data as measured DO have power beyond the
         truncation radius, then this will cause ringing in the rebinned map.

         \sstitem
         [Gaussian]
         In fact, any function that is finite in frequency space will have
         infinite extent in image space (I think). As such they will all
         drag in some power from the aliased versions of the map transform
         and all suffer from edge effects and large compute times. Some are
         worse than others, however. For example, a Gaussian can have most
         of its power concentrated over a much smaller footprint than a
         Bessel function, so the convolution calculation will be much
         faster. It is also more robust in the presence of spikes and
         seeing problems because it does not truncate the map FT as sharply
         as the Bessel function - such effects give rise to smoother
         defects in the rebinned map though the defects will still BE
         there.
      }
   }
   \sstinvocation{
       CALL SCULIB\_WTFN\_REGRID\_2 (RES, IN\_DATA, IN\_VARIANCE,
         WEIGHT, USEVARWT, VARWT, X, Y, NPIX, PIXSPACE, NI, NJ, ICEN, JCEN,
         TOTAL\_WEIGHT, WAVELENGTH, CONV\_DATA\_SUM, CONV\_VARIANCE\_SUM,
         CONV\_WEIGHT, WEIGHTSIZE, SCLSZ, WTFN, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         RES                            = INTEGER (Given)
      }{
         number of resolution elements per scale length
      }
      \sstsubsection{
         IN\_DATA (NPIX)                   = REAL (Given)
      }{
         The input data values.
      }
      \sstsubsection{
         IN\_VARIANCE (NPIX)               = REAL (Given)
      }{
         Variance on IN\_DATA.
      }
      \sstsubsection{
         WEIGHT                           = REAL (Given)
      }{
         The weight of this dataset.
      }
      \sstsubsection{
         USEVARWT                         = LOGICAL (Given)
      }{
         Are we using a different weight for each point
      }
      \sstsubsection{
         VARWT (NPIX)                     = REAL (Given)
      }{
         The different weight for each pixel
      }
      \sstsubsection{
         X (NPIX)                         = DOUBLE PRECISION (Given)
      }{
         The x coordinates of the input pixels.
      }
      \sstsubsection{
         Y (NPIX)                         = DOUBLE PRECISION (Given)
      }{
         The y coordinates of the input pixels.
      }
      \sstsubsection{
         NPIX                             = INTEGER (Given)
      }{
         the number of input pixels.
      }
      \sstsubsection{
         PIXSPACE                         = REAL (Given)
      }{
         the pixel spacing of the output map.
      }
      \sstsubsection{
         NI                               = INTEGER (Given)
      }{
         The number of output pixels in the x direction.
      }
      \sstsubsection{
         NJ                               = INTEGER (Given)
      }{
         The number of output pixels in the y direction.
      }
      \sstsubsection{
         ICEN                             = INTEGER (Given)
      }{
         the x index of the centre of the output array.
      }
      \sstsubsection{
         JCEN                             = INTEGER (Given)
      }{
         the y index of the centre of the output array.
      }
      \sstsubsection{
         TOTAL\_WEIGHT (NI,NJ)             = REAL (Given)
      }{
         the `total weight{\tt '} of each output pixel.
      }
      \sstsubsection{
         WAVELENGTH                       = REAL (Given)
      }{
         the wavelength at which the maps were made (microns).
      }
      \sstsubsection{
         CONV\_DATA\_SUM (NI,NJ)            = REAL (Given and returned)
      }{
         the convolution sum for each output pixel.
      }
      \sstsubsection{
         CONV\_VARIANCE\_SUM (NI,NJ)        = REAL (Given and returned)
      }{
         the variance convolution sum for each output pixel.
      }
      \sstsubsection{
         CONV\_WEIGHT (NI,NJ)              = REAL (Given and returned)
      }{
         the convolution weight for each output pixel.
      }
      \sstsubsection{
         WEIGHTSIZE                       = INTEGER (Given)
      }{
         radius of weight function in scale units (SCUIP\_\_FILTRAD for BESSEL, 1 for LINEAR)
      }
      \sstsubsection{
         SCLSZ                            = REAL
      }{
         1 scale length in the same units as PIXSPACE
      }
      \sstsubsection{
         WTFN (RES $*$ RES $*$ WEIGHTSIZE $*$ WEIGHTSIZE) = REAL (Given)
      }{
         convolution weighting function
      }
      \sstsubsection{
         STATUS                           = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SCULIB\_WTFN\_REGRID\_3
}{
   Sets up the {\tt '}guard ring{\tt '} of bolometers outside the data
}{
   \sstdescription{
      Takes the regridded image and adds in data of value {\tt '}zero{\tt '}
      for any points that are within range of the weighting function
      (ie if TOTAL\_WEIGHT is greater than 0) but that do not already
      contain any data (ie TOTAL\_WEIGHT is set to something becuase
      regrid\_1 determined that the pixel was close enough to be
      influenced by the convolution function, BUT no data was actually
      found to lie in that pixel). This has the effect of enforcing
      zero flux density at the edges of the map or where no data
      was present (eg surrounding a bad pixel).
      This is only really necessary for the bessel function regrid since
      that function is extremely sensitive to edge effects.
      Once the {\tt '}guard ring{\tt '} has been processed, the output image is
      normalised by dividing by the convolution weight (ie the actual
      weight used for each pixel). Any point that has zero convolution
      weight is set to bad.
   }
   \sstinvocation{
       CALL SCULIB\_WTFN\_REGRID\_3 (METHOD,RES,PIXSPACE, NI, NJ, ICEN, JCEN,
         TOT\_WEIGHT\_IN, WAVELENGTH, CONV\_DATA\_SUM, CONV\_VARIANCE\_SUM,
         CONV\_QUALITY\_SUM, CONV\_WEIGHT, WEIGHTSIZE, SCLSZ, WTFN, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         USEGUARD                       = LOGICAL (Given)
      }{
         Logical to determine whether the gueard ring should be used.
      }
      \sstsubsection{
         RES                            = INTEGER (Given)
      }{
         number of resolution elements per scale length
      }
      \sstsubsection{
         PIXSPACE                       = REAL (Given)
      }{
         the pixel spacing of the output pixels (radians).
      }
      \sstsubsection{
         NI                             = INTEGER (Given)
      }{
         The number of output pixels in the x direction.
      }
      \sstsubsection{
         NJ                             = INTEGER (Given)
      }{
         The number of output pixels in the y direction.
      }
      \sstsubsection{
         ICEN                           = INTEGER (Given)
      }{
         the x index of the centre of the output array.
      }
      \sstsubsection{
         JCEN                           = INTEGER (Given)
      }{
         the y index of the centre of the output array.
      }
      \sstsubsection{
         TOT\_WEIGHT\_IN (NI, NJ)         = REAL (Given)
      }{
         the `total weight{\tt '} of each output pixel.
      }
      \sstsubsection{
         WAVELENGTH                     = REAL (Given)
      }{
         the wavelength at which the maps was made (microns).
      }
      \sstsubsection{
         CONV\_DATA\_SUM (NI,NJ)          = REAL (Given and returned)
      }{
         the convolution sum for each output pixel.
      }
      \sstsubsection{
         CONV\_VARIANCE\_SUM (NI,NJ)      = REAL (Given and returned)
      }{
         the convolved variance sum for each output pixel.
      }
      \sstsubsection{
         CONV\_QUALITY\_SUM (NI,NJ)       = BYTE (Given)
      }{
         the quality on the convolution sum for each output pixel.
      }
      \sstsubsection{
         CONV\_WEIGHT (NI,NJ)            = REAL (Given and returned)
      }{
         the convolution weight for each output pixel.
      }
      \sstsubsection{
         WEIGHTSIZE                       = INTEGER (Given)
      }{
         radius of weight function in scale units (SCUIP\_\_FILTRAD for BESSEL, 1 for LINEAR)
      }
      \sstsubsection{
         SCLSZ                          = REAL (Given)
      }{
         1 scale length in the same units as pixspace
      }
      \sstsubsection{
         WTFN (RES $*$ RES $*$ WEIGHTSIZE $*$ WEIGHTSIZE) = REAL (Given)
      }{
         convolution weighting function
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
