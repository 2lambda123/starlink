\sstroutine{
   SURF\_GRID\_CALCSKY
}{
   Calculate sky contribution from median image
}{
   \sstdescription{
      This routine calculates the sky contribution by attempting
      to remove the source from the input data stream. The source
      signal can either be calculated by this routine or by reading
      in a model of the source from a file.

      When calculating the source structure internally a similar
      method to that used by DESPIKE is employed. The input data
      are placed into bins of size one quarter beamwidth. The median
      of each bin is calculated and this is treated as the source
      model (cf. REBIN\_METHOD=MEDIAN in REBIN).

      Once the source model is available, it is removed from
      all of the input data. The source-removed data are then analysed
      with the sky emission derived from the mean of the signal across
      the array for all the sample times.

      Since the sky signal is expected to vary on timesales of the
      order of one second, an option is included for smoothing the
      sky signal. This is especially useful for scan map data where
      samples are taken at 7.8~Hz.
   }
   \sstinvocation{
       CALL SURF\_GRID\_CALCSKY ( TSKNAME, N\_FILES, N\_PTS, N\_POS, N\_BOLS,
            N\_BOLS, WAVELENGTH, DIAMETER, IMNDF, N\_M\_FITS, MODEL\_FITS,
            CHOP\_THROW, CHOP\_PA, BOX\_SIZE, BOL\_RA\_PTR,  BOL\_DEC\_PTR,
            DATA\_PTR, QUALITY\_PTR, SKY\_PTR, SKY\_ERR, BADBIT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TSKNAME = CHARACTER (Given)
      }{
         Name of task to be used in output messages
      }
      \sstsubsection{
         N\_FILES = INTEGER (Given)
      }{
         Number of data sets (ie files)
      }
      \sstsubsection{
         N\_PTS ( N\_FILES ) = INTEGER (Given)
      }{
         Total number of points in each map
      }
      \sstsubsection{
         N\_POS( N\_FILES ) = INTEGER (Given)
      }{
         Number of positions per set (Y positions)
      }
      \sstsubsection{
         N\_BOLS( N\_FILES ) = INTEGER (Given)
      }{
         Number of bolometers per set (X positions)
      }
      \sstsubsection{
         WAVELENGTH = REAL (Given)
      }{
         Wavelength of observation in microns
      }
      \sstsubsection{
         DIAMETER = REAL (Given)
      }{
         Diameter of telescope in metres
      }
      \sstsubsection{
         IMNDF = INTEGER (Given)
      }{
         NDF identifier of the supplied model. If this is equal to
         NDF\_\_NOID then no external model is used.
      }
      \sstsubsection{
         N\_M\_FITS = INTEGER (Given)
      }{
         Number of FITS keywords in the model
      }
      \sstsubsection{
         MODEL\_FITS = CHAR$*$(80) (Given)
      }{
         FITS keywords from the model
      }
      \sstsubsection{
         CHOP\_THROW = REAL (Given)
      }{
         Size of chop throw for the first input image (arcsec)
      }
      \sstsubsection{
         CHOP\_PA = REAL (Given)
      }{
         Chop position angle of first input image (degrees)
      }
      \sstsubsection{
         BOX\_SIZE ( N\_FILES ) = INTEGER (Given)
      }{
         Size of smoothing box - pixels
      }
      \sstsubsection{
         BOL\_RA\_PTR( N\_FILES ) = INTEGER (Given)
      }{
         Array of pointers to position information (X coords)
         Note that each data set has positions for N\_POS $*$ N\_BOLS
      }
      \sstsubsection{
         BOL\_RA\_PTR( N\_FILES ) = INTEGER (Given)
      }{
         Array of pointers to position information (Y coords)
      }
      \sstsubsection{
         DATA\_PTR( N\_FILES ) = INTEGER (Given, modified data)
      }{
         Pointers to actual data arrays. The arrays are modified
         and contain the source removed data on exit.
      }
      \sstsubsection{
         QUALITY\_PTR( N\_FILES ) = INTEGER (Given)
      }{
         Pointer to quality arrays
      }
      \sstsubsection{
         SKY\_PTR ( N\_FILES ) = INTEGER (Pointer Given, data returned)
      }{
         Storage space for the sky signal
      }
      \sstsubsection{
         SKY\_ERR ( N\_FILES ) = INTEGER (Pointer Given, data returned)
      }{
         Storage space for the error on sky signal
      }
      \sstsubsection{
         BADBIT ( N\_FILES ) = BYTE (Given)
      }{
         Bad bit mask for identifying bad pixels from quality
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global Status
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         calcsky test\_rlb model=! $\backslash$$\backslash$
      }{
         Calculate sky for test\_rlb.sdf. Only read in one file and
         don{\tt '}t use an external source model.
      }
      \sstexamplesubsection{
         calcsky list.inp model=m82 noloop$\backslash$$\backslash$
      }{
         Read in the files specified in list.inp and use m82.sdf
         as a model of the source.
      }
      \sstexamplesubsection{
         calcsky file nosrc=nosrc boxsz=10.0 $\backslash$$\backslash$
      }{
         Calculate sky for file.sdf. Store the source subtracted image
         in nosrc.sdf. Use a smoothing size of 10 seconds.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The model itself is only an approximation
           to the data (since the data points can fall anywhere within
           a given cell) so some source signal will remain after source
           subtraction.

         \sstitem
         If a model is supplied externally (via MODEL parameter) the
           cell size and the map centre of the model
           is used for the source subtraction.

         \sstitem
         The sky signal is stored in an NDF extension (.MORE.REDS.SKY).
           The file must be processed by REMSKY to actually remove the
           sky contribution.
      }
   }
   \sstdiytopic{
      Related Applications
   }{
      SURF: REMSKY
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SURF\_GRID\_DESPIKE
}{
   Despike data by sorting into a given grid position
}{
   \sstdescription{
      For each data point this routine places it into a bin in the
      output grid depending on the position of the data point on the sky.
      The position in the input data array is stored.
      This is done in two stages:

      \sstitemlist{

         \sstitem
         Find the size of the output grid from the maximum extent of
            the input data.

         \sstitem
         Loop through data. Find I,J coordinate of each point in the
            output grid.

         \sstitem
         Find out maximum number of points for an I,J position.

         \sstitem
         Put data onto grid in array (I,J,N) [REALS].
            We also need to store positions of these data.
            We can either do it by storing the file number, bolometer and
            position (time) index OR we can just store some index in a merged
            data array that goes from 1..TOT\_PTS.
             First method is easy but memory hungry. Second method is
             more efficient but does need some reconstruction to work
             out where the point was in the original data.
           Use the second method.

      }
      Once the data is gridded, it is first displayed and then
      despiked. Currently despiking is done on a simple sigma clipping
      basis for each bin.
   }
   \sstinvocation{
       CALL SURF\_GRID\_DESPIKE ( N\_FILES, N\_PTS, N\_POS, N\_BOLS, WAVELENGTH,
            DIAMETER, BOL\_RA\_PTR, BOL\_DEC\_PTR, DATA\_PTR, QUALITY\_PTR,
            NX, NY, ICEN, JCEN, NSPIKES,
            BADBIT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N\_FILES = INTEGER (Given)
      }{
         Number of data sets (ie files)
      }
      \sstsubsection{
         N\_PTS ( N\_FILES ) = INTEGER (Given)
      }{
         Total number of points in each map
      }
      \sstsubsection{
         N\_POS( N\_FILES ) = INTEGER (Given)
      }{
         Number of positions per set (Y positions)
      }
      \sstsubsection{
         N\_BOLS( N\_FILES ) = INTEGER (Given)
      }{
         Number of bolometers per set (X positions)
      }
      \sstsubsection{
         BITNUM = INTEGER (Given)
      }{
         Bit number to be affected by this routine
      }
      \sstsubsection{
         WAVELENGTH = REAL (Given)
      }{
         Wavelength of data (microns)
      }
      \sstsubsection{
         DIAMETER = REAL (Given)
      }{
         Diameter of telescope (metres)
      }
      \sstsubsection{
         BOL\_RA\_PTR( N\_FILES ) = INTEGER (Given)
      }{
         Array of pointers to position information (X coords)
         Note that each data set has positions for N\_POS $*$ N\_BOLS
      }
      \sstsubsection{
         BOL\_RA\_PTR( N\_FILES ) = INTEGER (Given)
      }{
         Array of pointers to position information (Y coords)
      }
      \sstsubsection{
         DATA\_PTR( N\_FILES ) = INTEGER (Given)
      }{
         Pointers to actual data arrays
      }
      \sstsubsection{
         QUALITY\_PTR( N\_FILES ) = INTEGER (Given)
      }{
         Pointer to quality arrays
      }
      \sstsubsection{
         NX = INTEGER (Returned)
      }{
         Number of points in grid (X)
      }
      \sstsubsection{
         NY = INTEGER (Returned)
      }{
         Number of points in grid (Y)
      }
      \sstsubsection{
         ICEN = INTEGER (Returned)
      }{
         Reference pixel (X)
      }
      \sstsubsection{
         JCEN = INTEGER (Returned)
      }{
         Reference pixel (Y)
      }
      \sstsubsection{
         NSPIKES ( N\_FILES ) = INTEGER (Returned)
      }{
         Number of spikes detected (and removed) in each file
      }
      \sstsubsection{
         BADBIT ( N\_FILES ) = BYTE (Given)
      }{
         Bad bit mask for identifying bad pixels from quality
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global Status
      }
   }
   \sstnotes{
      For SMODE=NONE, DMODE is only requested if a plot is required.
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SURF\_MON
}{
   main routine for SCUBA offline data reduction package
}{
   \sstdescription{
      This is the main routine for the SCUBA reduction A-task.
   }
   \sstinvocation{
      CALL SURF\_MON( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status
      }
   }
   \sstnotes{
      This routine is not seen by the user
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SURF\_READ\_REBIN\_NDF
}{
   Read an NDF into memory prior to regridding
}{
   \sstdescription{
      This routines reads all necessary information from an NDF (via
      the given NDF identifier) for rebinning. Optionally, returns
      the quality array (needed for despiking).
   }
   \sstinvocation{
       CALL SURF\_READ\_REBIN\_NDF( IN\_NDF, MAX\_FILE, NSPEC,
            DATA\_SPEC, OUT\_COORDS, N\_FILE, USE\_SECTION,
            N\_BOL, N\_POS, N\_INTS, N\_BEAMS, MJD\_STANDARD, IN\_UT1,
            OUT\_RA\_CEN, OUT\_DEC\_CEN, FITS, N\_FITS, WAVELENGTH,
            SUB\_INSTRUMENT, SOBJECT, SUTDATE, SUTSTART,
            BOL\_ADC, BOL\_CHAN,
            BOL\_RA\_PTR, BOL\_RA\_END, BOL\_DEC\_PTR,
            BOL\_DEC\_END, DATA\_PTR, DATA\_END, VARIANCE\_PTR, VARIANCE\_END,
            QMF, QUALITY\_PTR, QUALITY\_END, BADBITS,
            USE\_LST, LST\_PTR, ANG\_INT, ANG\_MEAS, INT\_LIST, MEAS\_LIST, BOLWT,
            STATUS)
   }
   \sstarguments{
      \sstsubsection{
         IN\_NDF = INTEGER (Given)
      }{
         NDF identifier of input NDF
      }
      \sstsubsection{
         MAX\_FILE = INTEGER (Given)
      }{
         Max number of files allowed [used for INT\_LIST/MEAS only]
      }
      \sstsubsection{
         NSPEC = INTEGER (Given)
      }{
         Number of SCUBA sections in DATA\_SPEC
      }
      \sstsubsection{
         DATA\_SPEC( NSPEC ) = CHAR (Given)
      }{
         SCUBA sections
      }
      \sstsubsection{
         OUT\_COORDS = CHAR (Given)
      }{
         Output coordinates system. (Passed into SURF\_READ\_REBIN\_NDF)
      }
      \sstsubsection{
         N\_FILE = INTEGER (Given)
      }{
         Current file number (less than MAX\_FILE and greater than 0).
      }
      \sstsubsection{
         USE\_SECTION = LOGICAL (Given)
      }{
         Determines whether we are using the section or the invers
      }
      \sstsubsection{
         N\_BOL = INTEGER (Returned)
      }{
         Number of bolometers associated with this observation
      }
      \sstsubsection{
         N\_POS = INTEGER (Returned)
      }{
         Number of samples in observation
      }
      \sstsubsection{
         N\_INTS = INTEGER (Returned)
      }{
         Total Number of integrations in observation (INT$*$MEAS)
      }
      \sstsubsection{
         N\_MEAS = INTEGER (Returned)
      }{
         Number of measurements in observation
      }
      \sstsubsection{
         N\_BEAMS = INTEGER (Given \& Returned)
      }{
         Number of beams requested in the positions arrays.
         N\_BEAMS = 1  will return the middle-beam (standard position)
         N\_BEAMS = 2 will return L and R beams for RASTER and JIGGLE
         N\_BEAMS = 3 will return L, M and R beams (as M,L,R) for JIGGLE
                    data that has been reduce\_switched and for SCAN
                    data. N\_BEAM is set to 2 if a single switch of a
                    JIGGLE map is requested.
      }
      \sstsubsection{
         MJD\_STANDARD = DOUBLE (Given \& Returned)
      }{
         Modified Julian data of observation. Returned if N\_FILE=1.
      }
      \sstsubsection{
         IN\_UT1 = DOUBLE (Returned)
      }{
         Modified Julian data of observation UT1 at start of an input
         observation, expressed as modified Julian day
      }
      \sstsubsection{
         IN\_RA\_CEN = DOUBLE (Returned)
      }{
         RA of centre
      }
      \sstsubsection{
         IN\_DEC\_CEN = DOUBLE (Returned)
      }{
         Dec of centre
      }
      \sstsubsection{
         FITS ( SCUBA\_MAX\_FITS ) = CHARACTER $*$80 (Returned)
      }{
         FITS header entries
      }
      \sstsubsection{
         N\_FITS = INTEGER (Returned)
      }{
         Number of FITS entries
      }
      \sstsubsection{
         WAVELENGTH = REAL (Given \& Returned)
      }{
         Wavelength of map
      }
      \sstsubsection{
         SUB\_INSTRUMENT = CHAR (Given \& Returned)
      }{
         Sub instrument of map
      }
      \sstsubsection{
         SOBJECT = CHAR (Returned)
      }{
         Name of object
      }
      \sstsubsection{
         SUTDATE = CHAR (Returned)
      }{
         UT date of the observation
      }
      \sstsubsection{
         SUTSTART = CHAR (Returned)
      }{
         UT time of the observation
      }
      \sstsubsection{
         BOL\_ADC = INTEGER (Returned)
      }{
         ADC information for bolometers - only used by BOLREBIN
      }
      \sstsubsection{
         BOL\_CHAN = INTEGER (Returned)
      }{
         Channel information for bolometers - only used by BOLREBIN
      }
      \sstsubsection{
         BOL\_RA\_PTR = INTEGER (Returned)
      }{
         Pointer to RA bolometer positions [Pointer is given, data is
         returned]
      }
      \sstsubsection{
         BOL\_RA\_END = INTEGER (Returned)
      }{
         Pointer to end of RA bolometer positions
      }
      \sstsubsection{
         BOL\_DEC\_PTR = INTEGER (Returned)
      }{
         Pointer to DEC bolometer positions
      }
      \sstsubsection{
         BOL\_DEC\_END = INTEGER (Returned)
      }{
         Pointer to end of DEC bol positions
      }
      \sstsubsection{
         DATA\_PTR = INTEGER (Returned)
      }{
         Pointer to data values
      }
      \sstsubsection{
         DATA\_END = INTEGER (Returned)
      }{
         Pointer to end of data values
      }
      \sstsubsection{
         VARIANCE\_PTR = INTEGER (Returned)
      }{
         Pointer to variance values
      }
      \sstsubsection{
         VARIANCE\_END = INTEGER (Returned)
      }{
         Pointer to end of variance values
      }
      \sstsubsection{
         QMF = LOGICAL (Given)
      }{
         Flag to decide whether quality is being stored (.FALSE.) or
         being folded into the data array (.true.). See NDF\_SQMF
      }
      \sstsubsection{
         QUALITY\_PTR = INTEGER (Returned)
      }{
         Pointer to quality array
      }
      \sstsubsection{
         QUALITY\_END = INTEGER (Returned)
      }{
         Pointer to end of quality array
      }
      \sstsubsection{
         BADBITS = BYTE (Returned)
      }{
         Bad bits mask for quality array
      }
      \sstsubsection{
         USE\_LST = LOGICAL (Given)
      }{
         Governs whether we want an LST array returned
      }
      \sstsubsection{
         LST\_PTR( 2 ) = INTEGER (Returned)
      }{
         Array of pointers (begin and end)  to array of LSTs
      }
      \sstsubsection{
         ANG\_INT( MAX\_FILE, SCUBA\_\_MAX\_INT,2)  = REAL (Returned)
      }{
         Array containing the polarimetry angles for each integration
         The 2 dimensions are for WPLATE and ANGROT
      }
      \sstsubsection{
         ANG\_MEAS( MAX\_FILE, SCUBA\_\_MAX\_MEAS,2) = REAL (Returned)
      }{
         Array containing the pol angles for each measurement
         The 2 dimensions are for WPLATE and ANGROT
      }
      \sstsubsection{
         INT\_LIST( MAX\_FILE, SCUBA\_\_MAX\_INT$+$1) = INTEGER (Returned)
      }{
         Position of integrations in each data file
      }
      \sstsubsection{
         MEAS\_LIST(MAX\_FILE, SCUBA\_\_MAX\_MEAS$+$1) = INTEGER (Returned)
      }{
         Position of measurements in each data file
      }
      \sstsubsection{
         BOLWT ( N\_BOL ) = REAL (Returned)
      }{
         Relative weights of each bolometer
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SURF\_RECURSE\_READ
}{
   Allow the recursive read of REBIN text files and NDFs
}{
   \sstdescription{
      This routine takes an input name and reads in all NDFs resulting
      from this name. SCUBA sections are parsed. Text files are expanded
      into NDF$+$parameters. Nested text files are allowed.
   }
   \sstinvocation{
       CALL SURF\_RECURSE\_READ( RLEV, NAME, MAX\_FILE,
            OUT\_COORDS, N\_FILE, N\_BOL, N\_POS, N\_INTS,
            IN\_UT1, IN\_RA\_CEN, IN\_DEC\_CEN, FITS, N\_FITS, WAVELENGTH,
            SUB\_INSTRUMENT, OBJECT, UTDATE, UTSTART, FILENAME,
            BOL\_ADC, BOL\_CHAN,
            BOL\_RA\_PTR, BOL\_RA\_END, BOL\_DEC\_PTR,
            BOL\_DEC\_END, DATA\_PTR, DATA\_END, VARIANCE\_PTR, VARIANCE\_END,
            QMF, QUALITY\_PTR, QUALITY\_END, QBITS, ANG\_INT, ANG\_MEAS,
            INT\_LIST, MEAS\_LIST, BOLWT, WEIGHT, SHIFT\_DX, SHIFT\_DY,
            NPARS, PARS, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         RLEV = INTEGER (Given)
      }{
         Recursion level. This is the number of times that the routine
         has called itself. A value of 1 should be passed in by the
         external routine.
      }
      \sstsubsection{
         NAME = CHAR (Given)
      }{
         Name of input file. This may also contain scuba section
         specifications. The input file can be a NDF or a text file
         containing a list of NDFs.
      }
      \sstsubsection{
         MAX\_FILE = INTEGER (Given)
      }{
         Maximum number of NDFs that can be read by the system.
      }
      \sstsubsection{
         OUT\_COORDS = CHAR (Given)
      }{
         Output coordinates system. (Passed into SURF\_READ\_REBIN\_NDFS)
      }
      \sstsubsection{
         N\_FILE = INTEGER (Given \& Returned)
      }{
         Current file number (less than MAX\_FILE and greater than 0).
         This counter is incremented when an NDF has been read successfully.
      }
      \sstsubsection{
         N\_BOL( MAX\_FILE ) = INTEGER (Returned)
      }{
         Number of bolometers associated with each file
      }
      \sstsubsection{
         N\_POS( MAX\_FILE ) = INTEGER (Returned)
      }{
         Number of samples associated with each file
      }
      \sstsubsection{
         N\_INTS( MAX\_FILE ) = INTEGER (Returned)
      }{
         Total Number of integrations associated with each file (INT$*$MEAS)
      }
      \sstsubsection{
         N\_MEAS( MAX\_FILE ) = INTEGER (Returned)
      }{
         Number of measurements associated with each file
      }
      \sstsubsection{
         IN\_UT1( MAX\_FILE ) = DOUBLE (Returned)
      }{
         Modified Julian data of observation for each file
      }
      \sstsubsection{
         IN\_RA\_CEN( MAX\_FILE ) = DOUBLE (Returned)
      }{
         RA of centre for each file
      }
      \sstsubsection{
         IN\_DEC\_CEN( MAX\_FILE ) = DOUBLE (Returned)
      }{
         Dec of centre for each file
      }
      \sstsubsection{
         FITS ( N\_FITS, MAX\_FILE) = CHARACTER$*$(80) (Returned)
      }{
         FITS entries for each file
      }
      \sstsubsection{
         N\_FITS = INTEGER (Given)
      }{
         Size of FITS array for each file
      }
      \sstsubsection{
         WAVELENGTH = REAL (Given \& Returned)
      }{
         Wavelength of map
      }
      \sstsubsection{
         SUB\_INSTRUMENT = CHAR (Given \& Returned)
      }{
         Sub instrument of map
      }
      \sstsubsection{
         OBJECT( MAX\_FILE ) = CHAR (Returned)
      }{
         Name of object in each file
      }
      \sstsubsection{
         UTDATE( MAX\_FILE ) = CHAR (Returned)
      }{
         UT date of each observation
      }
      \sstsubsection{
         UTSTART( MAX\_FILE ) = CHAR (Returned)
      }{
         UT time of each observation
      }
      \sstsubsection{
         FILENAME( MAX\_FILE ) = CHAR (Returned)
      }{
         Actual filename of each file read.
      }
      \sstsubsection{
         BOL\_ADC ( ) = INTEGER (Returned)
      }{
         ADC information for bolometers - only used by BOLREBIN
      }
      \sstsubsection{
         BOL\_CHAN ( ) = INTEGER (Returned)
      }{
         Channel information for bolometers - only used by BOLREBIN
      }
      \sstsubsection{
         BOL\_RA\_PTR( MAX\_FILE ) = INTEGER (Returned)
      }{
         Array of pointers to RA bolometer positions read from each file
      }
      \sstsubsection{
         BOL\_RA\_END( MAX\_FILE ) = INTEGER (Returned)
      }{
         Array of pointers to end of RA bolometer positions read from each file
      }
      \sstsubsection{
         BOL\_DEC\_PTR( MAX\_FILE ) = INTEGER (Returned)
      }{
         Array of pointers to DEC bolometer positions read from each file
      }
      \sstsubsection{
         BOL\_DEC\_END( MAX\_FILE ) = INTEGER (Returned)
      }{
         Array of pointers to end of DEC bol positions read from each file
      }
      \sstsubsection{
         DATA\_PTR( MAX\_FILE ) = INTEGER (Returned)
      }{
         Array of pointers to data values read from each file
      }
      \sstsubsection{
         DATA\_END( MAX\_FILE ) = INTEGER (Returned)
      }{
         Array of pointers to end of data values
      }
      \sstsubsection{
         VARIANCE\_PTR( MAX\_FILE ) = INTEGER (Returned)
      }{
         Array of pointers to variance values read from each file
      }
      \sstsubsection{
         VARIANCE\_END( MAX\_FILE ) = INTEGER (Returned)
      }{
         Array of pointers to end of variance values
      }
      \sstsubsection{
         QMF = LOGICAL (Given)
      }{
         Flag to decide whether quality is being stored (.FALSE.) or
         being folded into the data array (.true.). See NDF\_SQMF
      }
      \sstsubsection{
         QUALITY\_PTR(MAX\_FILE) = INTEGER (Returned)
      }{
         Pointer to quality array
      }
      \sstsubsection{
         QUALITY\_END(MAX\_FILE) = INTEGER (Returned)
      }{
         Pointer to end of quality array
      }
      \sstsubsection{
         QBITS(MAX\_FILE) = BYTE (Returned)
      }{
         Bad bits mask for each file
      }
      \sstsubsection{
         ANG\_INT( MAX\_FILE, SCUBA\_\_MAX\_INT,2)  = REAL (Returned)
      }{
         Array containing the polarimetry angles for each integration
         The 2 dimensions are for WPLATE and ANGROT
      }
      \sstsubsection{
         ANG\_MEAS( MAX\_FILE, SCUBA\_\_MAX\_MEAS,2) = REAL (Returned)
      }{
         Array containing the pol angles for each measurement
         The 2 dimensions are for WPLATE and ANGROT
      }
      \sstsubsection{
         INT\_LIST( MAX\_FILE, SCUBA\_\_MAX\_INT$+$1) = INTEGER (Returned)
      }{
         Position of integrations in each data file
      }
      \sstsubsection{
         MEAS\_LIST(MAX\_FILE, SCUBA\_\_MAX\_MEAS$+$1) = INTEGER (Returned)
      }{
         Position of measurements in each data file
      }
      \sstsubsection{
         BOLWT (max num of bols, MAX\_FILE) = REAL (Returned)
      }{
         Relative Weights of each bolometer for each file
      }
      \sstsubsection{
         WEIGHT( MAX\_FILE ) = REAL (Returned)
      }{
         Weight of each input file
      }
      \sstsubsection{
         SHIFT\_DX( MAX\_FILE ) = REAL (Returned)
      }{
         X Shift of each input file
      }
      \sstsubsection{
         SHIFT\_DY( MAX\_FILE ) = REAL (Returned)
      }{
         Y Shift of each input file
      }
      \sstsubsection{
         NPARS = INTEGER (Given)
      }{
         Number of parameters in PARS array.
      }
      \sstsubsection{
         PARS( NPARS ) = REAL (Given)
      }{
         Values of input parameters. 1: WEIGHT, 2: SHIFT\_DX, 3: SHIFT\_DY
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This subroutine can be called recursively. A limit of 5 recursion
           levels is imposed. Note that recursion is not approved of in
           Fortran 77 (mainly because local variables remember their state
           on entry!).

         \sstitem
         Text files with extension .txt are converted to NDFs by the
           NDF\_OPEN command. This is bad - do not use .txt files as batch
           files.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SURF\_REQUEST\_OUTPUT\_COORDS
}{
   Request longitude and latitude of output map from user
}{
   \sstdescription{
      Prompts user for output coordinates of map in the specified
      coordinate frame. The default values are derived from the
      supplied apparent RA/Dec centre. The selected centre
      is returned (in apparent ra/dec).
   }
   \sstinvocation{
       CALL SURF\_REQUEST\_OUTPUT\_COORDS( TASK, PARLONG, PARLAT,
            OUT\_COORDS, LAT\_OBS, DEF\_RA\_CEN, DEF\_DEC\_CEN, MJD, HOURS,
            OUT\_RA\_CEN, OUT\_DEC\_CEN, OUT\_ROTATION, OUT\_LONG, OUT\_LAT,
            STATUS)
   }
   \sstarguments{
      \sstsubsection{
         TASK = CHARACTER (Given)
      }{
         Description of task to be used in error messages
      }
      \sstsubsection{
         PARLONG = CHARACTER (Given)
      }{
         Name of the parameter used to request the LONGITUDE
      }
      \sstsubsection{
         PARLAT = CHARACTER (Given)
      }{
         Name of the parameter used to request the LATITUDE
      }
      \sstsubsection{
         OUT\_COORDS = CHARACTER (Given)
      }{
         Coordinate frame of output coordinates.
      }
      \sstsubsection{
         LAT\_OBS = DOUBLE (Given)
      }{
         Latitude of observatory (Radians)
      }
      \sstsubsection{
         DEF\_RA\_CEN = DOUBLE (Given)
      }{
         Apparent RA of the default map centre (radians)
      }
      \sstsubsection{
         DEF\_DEC\_CEN = DOUBLE (Given)
      }{
         Apparent Dec of the default map centre (radians)
      }
      \sstsubsection{
         MJD = DOUBLE (Given)
      }{
         Modified Julian date to be used as reference for apparent
         RA/Dec coordinates
      }
      \sstsubsection{
         HOURS = LOGICAL (Given)
      }{
         Flag to decide whether longitude is expressed as hours or degrees
      }
      \sstsubsection{
         OUT\_RA\_CEN = DOUBLE (Returned)
      }{
         Apparent RA of output map centre (radians)
      }
      \sstsubsection{
         OUT\_DEC\_CEN = DOUBLE (Returned)
      }{
         Apparent Dec of output map centre (radians)
      }
      \sstsubsection{
         OUT\_ROTATION = DOUBLE (Returned)
      }{
         angle between apparent N and N of output coord system (radians)
      }
      \sstsubsection{
         OUT\_LONG = DOUBLE (Returned)
      }{
         longitude of output map centre in the selected coordinate frame (rad)
      }
      \sstsubsection{
         OUT\_LAT = DOUBLE (Returned)
      }{
         latitude of output map centre in the selected coordinate frame (rad)
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The output coordinates are always slightly different from the
           when defaults are accepted since there is a loss of precision
           converting the ra/dec to and from a string form.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SURF\_SET\_APP\_NAME
}{
   Set application name for NDF history
}{
   \sstdescription{
      This routine sets the application name to be of the form

          TASKNAME   ( PACKAGE VN.n-n )

      That is, the taskname (which would be the default history
      if we did not change it) with the package name and the
      version number. The version number is specified at compile time.
   }
   \sstinvocation{
      CALL SURF\_SET\_APP\_NAME( TSKNAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TASKNAME = \_CHAR (Given)
      }{
         Name of the task.
      }
      \sstsubsection{
         STATUS = \_INTEGERS (Given \& Returned)
      }{
         Global status
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine should be compiled using the C pre-processor
           with a define for the PKG\_VERS cpp variable. This variable
           should include the required quotes (since CPP will not change
           quoted strings). An example could be:
                     f77 -DPKG\_VERS={\tt "}{\tt '}5.2-4{\tt '}{\tt "} surf\_set\_app\_name.F
           The V is prepended automatically.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SURF\_WRITE\_DATA
}{
   Write bolometer positions and values to text file
}{
   \sstdescription{
      This routine writes the value, variance and position of each
      data point to a ASCII file. It is called as part of the EXTRACT\_DATA
      task.
      The interface is the same as that used in the REBIN task.
      The data and variance are in volts. The positions are in radians.
      The data are written out as columns (RA DEC DATA VAR) and subsets
      can be extracted by using SCUBA sections.
   }
   \sstinvocation{
       CALL SURF\_WRITE\_DATA( FD, NPTS, IN\_DATA, IN\_VARIANCE,
        BOL\_RA, BOL\_DEC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         Output file descriptor
      }
      \sstsubsection{
         NPTS = INTEGER (Given)
      }{
         Number of points in input data
      }
      \sstsubsection{
         IN\_DATA( NPTS ) = REAL (Given)
      }{
         Data value
      }
      \sstsubsection{
         IN\_VARIANCE( NPTS ) = REAL (Given)
      }{
         Variance on data
      }
      \sstsubsection{
         BOL\_RA( NPTS ) = DOUBLE (Given)
      }{
         Bolometer position (radians offset from map centre)
      }
      \sstsubsection{
         BOL\_DEC( NPTS ) = DOUBLE (Given)
      }{
         Bolometer position (radians offset from map centre)
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status
      }
   }
   \sstnotes{
      For each file name that is entered, values for the parameters
      SELECT\_INTS, WEIGHT, SHIFT\_DX and SHIFT\_DY are requested.
      \sstitemlist{

         \sstitem
         The application can read in up to 100 separate input datasets.

         \sstitem
         No data is returned if the DATA or positions are bad.
         Data is still returned if Variance is bad.
      }
   }
   \sstdiytopic{
      ASCII input files
   }{
      The REF and IN parameters accept ASCII text files as input. These
      text files may contain comments (signified by a \#), NDF names,
      values for the parameters WEIGHT, SHIFT\_DX and SHIFT\_DY,
      and names of other ASCII files. There is one data file per line.
      An example file is:

\texttt{
\begin{tabular}{lcccl}
        file1\{b5\}  & 1.0& 0.5&   0.0&  \# Read bolometer 5 from file1.sdf\\
        file2        &    &    &      &\# Read file 2 but you will still be\\
                     &    &    &      &  \# prompted for WEIGHT, and shifts.\\
        file3\{i3\}- & 1.0& 0.0&   0.0&  \# Use everything except int 3\\
        test.bat     &    &    &      &\# Read in another text file\\
\end{tabular}
}

      Note that the parameters are position dependent and are not necessary.
      Missing parameters are requested. This means it is not possible to
      specify SHIFT\_DX (position 3) without specifying the WEIGHT.
      Also note that SCUBA sections can be specified with any input NDF.
   }
   \sstdiytopic{
      Related Applications
   }{
      SURF: REBIN, BOLREBIN, INTREBIN, CHANGE\_QUALITY
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SURF\_WRITE\_MAP\_INFO
}{
   Calculate FITS and WCS information for rebinned image
}{
   \sstdescription{
      This routine writes Axis, FITS and WCS information to a rebinned
      map file. Note that this routine does not write WCS information
      to the FITS header - that is stored in the WCS information.
      Keywords CRVAL, CRPIX and CTYPE are used here to generate the
      WCS only.
   }
   \sstinvocation{
       CALL SURF\_WRITE\_MAP\_INFO( OUT\_NDF, OUT\_COORDS, OUT\_TITLE,
            MJD\_STANDARD, NFILE, FILENAME, OUT\_LONG, OUT\_LAT,
            OUT\_PIXEL, I\_CENTRE, J\_CENTRE, NX\_OUT, NY\_OUT, WAVELENGTH
            FILTER, WRITE\_CHOP, CHOP\_PA, CHOP\_THROW, WPLATE, ANGROT,
            STATUS )
   }
   \sstarguments{
      \sstsubsection{
         OUT\_NDF = INTEGER (Given)
      }{
         NDF identifier of output file
      }
      \sstsubsection{
         OUT\_COORDS = CHAR (Given)
      }{
         Output coordinate system
      }
      \sstsubsection{
         OUT\_TITLE = CHAR (Given)
      }{
         Title of map
      }
      \sstsubsection{
         OUT\_UNITS = CHAR (Given)
      }{
         Output units
      }
      \sstsubsection{
         MJD\_STANDARD = DOUBLE (Given)
      }{
         Modified Julian date of map
      }
      \sstsubsection{
         NFILE = INTEGER (Given)
      }{
         Number of files in input map
      }
      \sstsubsection{
         FILENAME = CHAR(NFILE) (Given)
      }{
         Names of input files
      }
      \sstsubsection{
         OUT\_PIXEL = REAL (Given)
      }{
         Size of pixel in output map (radians)
      }
      \sstsubsection{
         OUT\_LONG  = DOUBLE (Given)
      }{
         Longitude of output map (radians)
      }
      \sstsubsection{
         OUT\_LAT  = DOUBLE (Given)
      }{
         Latitude of output map (radians)
      }
      \sstsubsection{
         I\_CENTRE = INTEGER (Given)
      }{
         Position of X reference pixel in output map
      }
      \sstsubsection{
         J\_CENTRE = INTEGER (Given)
      }{
         Position of Y reference pixel in output map
      }
      \sstsubsection{
         NX\_OUT = INTEGER (Given)
      }{
         Size of output map in X direction
      }
      \sstsubsection{
         NY\_OUT = INTEGER (Given)
      }{
         Size of output map in Y direction
      }
      \sstsubsection{
         WAVELENGTH = REAL (Given)
      }{
         Wavelength of the map (microns)
      }
      \sstsubsection{
         FILTER = CHARACTER (Given)
      }{
         Name of filter
      }
      \sstsubsection{
         WRITE\_CHOP = LOGICAL (Given)
      }{
         Write the CHOP information to the header
      }
      \sstsubsection{
         CHOP\_CRD = CHARACTER (Given)
      }{
         Chop coordinate frame
      }
      \sstsubsection{
         CHOP\_PA = REAL (Given)
      }{
         Chop position angle in degrees east of north
      }
      \sstsubsection{
         CHOP\_THROW = REAL (Given)
      }{
         Chop throw in arcsec
      }
      \sstsubsection{
         WPLATE = REAL (Given)
      }{
         Wave plate angle (ignored if bad value).
      }
      \sstsubsection{
         ANGROT = REAL (Given)
      }{
         POLPACK rotation angle between waveplate and X pixel axis
         (ignored if bad value)
      }
      \sstsubsection{
         TELESCOPE = CHARACTER (Given)
      }{
         Name of telescope to write to FITS header
      }
      \sstsubsection{
         INSTRUMENT = CHARACTER (Given)
      }{
         Name of instrument to write to FITS header
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SURF\_WRITE\_PHOTOM
}{
   Routine to output ASCII results of PHOTOM reduction
}{
   \sstdescription{
      This routine writes out the results for 1 sub-instrument of a PHOTOM
      observation.
      For each bolometer that measured the source:-

\texttt{
\begin{tabular}{cccccc}
\multicolumn{2}{l}{Bolometer} &:&\multicolumn{3}{l}{$<$bolometer name$>$}\\
\multicolumn{2}{l}{Weight}    &:&\multicolumn{3}{l}{$<$weight to be given to its results$>$}\\
&&&&&\\
Integration &Peak  &   Peak\_sig&      Peak\_x &     Peak\_y  &    Quality\\
$<$integration$>$& $<$peak$>$&   $<$Error$>$ &  $<$x of peak$>$& $<$y of
peak$>$ &  $<$quality$>$\\
\multicolumn{6}{c}{for all the integrations taken in the observation}\\
&&&&&\\
\multicolumn{6}{l}{Measurement results   :}\\
\multicolumn{2}{c}{Fit to coadded jiggle:}&:&&\\
&$<$peak$>$ &  $<$variance$>$ &  $<$x of peak$>$&$<$y of peak$>$&$<$quality$>$\\
\multicolumn{2}{c}{Coadded fit results :}&:&&\\
&$<$peak$>$ &  $<$variance$>$&  &           &                  $<$quality$>$\\
\end{tabular}   
}
}
   \sstinvocation{
       CALL SURF\_WRITE\_PHOTOM (FD, MAX\_BEAM,
         N\_BOLS, BOL\_CHAN, BOL\_ADC, PHOT\_BB, MAX\_INT, N\_MEASUREMENTS,
         N\_INTEGRATIONS,PEAK\_D, PEAK\_V, PEAK\_X, PEAK\_Y, PEAK\_Q, BEAM\_WEIGHT,
         MEAS\_1\_D, MEAS\_1\_V, MEAS\_1\_X, MEAS\_1\_Y, MEAS\_1\_Q,
         MEAS\_2\_D, MEAS\_2\_V, MEAS\_2\_Q, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         FD                     = INTEGER (Given)
      }{
         ASCII file descriptor
      }
      \sstsubsection{
         MAX\_BEAM               = INTEGER (Given)
      }{
         the maximum number of bolometers that can observe the source
         in a single observation
      }
      \sstsubsection{
         PARABOLA               = LOGICAL (Given)
      }{
         True if we fitted the coaaded jiggle with a parabola
      }
      \sstsubsection{
         N\_BOLS                 = INTEGER (Given)
      }{
         the number of bolometers used in the sub-instrument
      }
      \sstsubsection{
         BOL\_CHAN (N\_BOLS)      = INTEGER (Given)
      }{
         the channel numbers of the bolometers observing the object
      }
      \sstsubsection{
         BOL\_ADC (N\_BOLS)       = INTEGER (Given)
      }{
         the A/D numbers of the bolometers observing the object
      }
      \sstsubsection{
         PHOT\_BB (MAX\_BEAM)     = INTEGER (Given)
      }{
         the indices of the bolometers used to observe the source in
         each beam in the BOL\_CHAN and BOL\_ADC arrays
      }
      \sstsubsection{
         MAX\_INT                = INTEGER (Given)
      }{
         the maximum number of integrations in an observation
      }
      \sstsubsection{
         N\_MEASUREMENTS         = INTEGER (Given)
      }{
         the number of measurements in the observation
      }
      \sstsubsection{
         N\_INTEGRATIONS         = INTEGER (Given)
      }{
         the number of integrations in the observation
      }
      \sstsubsection{
         PEAK\_D (MAX\_INT, MAX\_BEAM) = REAL (Given)
      }{
         the fitted peak value for each integration with each
         bolometer
      }
      \sstsubsection{
         PEAK\_V (MAX\_INT, MAX\_BEAM) = REAL (Given)
      }{
         the variance on PEAK
      }
      \sstsubsection{
         PEAK\_X (MAX\_INT, MAX\_BEAM) = REAL (Given)
      }{
         the x offset of the fitted peak for each integration with
         each bolometer
      }
      \sstsubsection{
         PEAK\_Y (MAX\_INT, MAX\_BEAM) = REAL (Given)
      }{
         the y offset of the fitted peak
      }
      \sstsubsection{
         PEAK\_Q (MAX\_INT, MAX\_BEAM) = BYTE (Given)
      }{
         the quality of each fitted peak (0 is good)
      }
      \sstsubsection{
         BEAM\_WEIGHT (MAX\_BEAM) = REAL (Given)
      }{
         the weights assigned to the measurements with each bolometer
      }
      \sstsubsection{
         MEAS\_1\_D (MAX\_BEAM)    = REAL (given)
      }{
         the fitted peak to the coadded integrations
      }
      \sstsubsection{
         MEAS\_1\_V (MAX\_BEAM)    = REAL (Given)
      }{
         the variance on MEAS\_1\_D
      }
      \sstsubsection{
         MEAS\_1\_X (MAX\_BEAM)    = REAL (Given)
      }{
         the x offset of the peak fitted to the coadd
      }
      \sstsubsection{
         MEAS\_1\_Y (MAX\_BEAM)    = REAL (Given)
      }{
         the y offset
      }
      \sstsubsection{
         MEAS\_1\_Q (MAX\_BEAM)    = BYTE (Given)
      }{
         the quality on MEAS\_1\_D
      }
      \sstsubsection{
         MEAS\_2\_D (MAX\_BEAM)    = REAL (Given)
      }{
         the coadd of the peaks fitted to the individual integrations
         for each bolometer
      }
      \sstsubsection{
         MEAS\_2\_V (MAX\_BEAM)    = REAL (Given)
      }{
         the variance on MEAS\_2\_D
      }
      \sstsubsection{
         MEAS\_2\_Q (MAX\_BEAM)    = BYTE (Given)
      }{
         the quality on MEAS\_2\_D
      }
      \sstsubsection{
         STATUS                 = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
\sstroutine{
   SURF\_WRITE\_PHOTOM\_HEADER
}{
   Write photom information to text file
}{
   \sstdescription{
      This routine writes out the header for 1 sub-instrument of a PHOTOM
      observation.
         If status is good on entry the routine will call FIO\_ASSOC to open
      the ASCII file to hold the results; the filename will be read from
      parameter {\tt '}FILE{\tt '}. FIO\_WRITE will then be called to write out the results
      in the following format:-

\texttt{
\begin{tabular}{lcl}
\multicolumn{3}{l}{Output from SURF reduction of a PHOTOM observation}\\
       Reduction date        &:& $<$date$>$\\
       Observation definition&:& $<$ODF name$>$\\
       Date of observation   &:& $<$date$>$\\
       Time of observation   &:& $<$time$>$\\
       Run number            &:& $<$number$>$\\
       Object                &:& $<$object$>$\\
       Sub-instrument        &:& $<$name$>$\\
       Filter                &:& $<$name$>$\\
       Centre coords         &:& $<$coord system of centre$>$\\
       Latitude              &:& $<$latitude$>$\\
       Longitude             &:& $<$longitude$>$\\
\end{tabular}
}

If the centre coordinate system is PLANET then:-

\texttt{
\begin{tabular}{lcl}
       2nd latitude          &:& $<$latitude on MJD2$>$\\
       2nd longitude         &:& $<$longitude on MJD2$>$\\
       date of 1st position  &:& $<$modified Julian day when source at lat,long$>$\\
       date of 2nd position  &:& $<$modified Julian day when source at lat2,long2$>$\\
\end{tabular}
}

      end if

\texttt{
\begin{tabular}{lcl}
       Offset coords         &:& $<$coord system of source offset$>$\\
       x offset              &:& $<$x offset of source$>$\\
       y offset              &:& $<$y offset of source$>$\\
       Sampe coords          &:& $<$coord system of jiggle offsets$>$\\
       Sample position angle &:& $<$angle that x axis of jiggle offsets is rotated\\
    &&                           anticlockwise from the x axis of the sample\\
    &&                           coord system$>$\\
       Sky error removal     &:& $<$TRUE if the SURF REMSKY application has \\
   &&                            been run on the data$>$\\
       Analysis mode         &:& AVERAGE or PARABOLA\\
\end{tabular}
}

   }
   \sstinvocation{
       CALL SURF\_WRITE\_PHOTOM\_HEADER (ODF, OBS\_DATE, OBS\_TIME,
            ANALYSIS, RUN\_NUMBER, OBJECT, SUB\_INSTRUMENT, FILTER,
            CENTRE\_COORDS, LAT, LONG, LAT2, LONG2, MJD1, MJD2,
            OFFSET\_COORDS, MAP\_X, MAP\_Y, SAMPLE\_COORDS, SAMPLE\_PA,
            SKY\_SUBTRACTION, FD, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         ODF                    = CHARACTER$*$($*$) (Given)
      }{
         the name of the observation definition file
      }
      \sstsubsection{
         OBS\_DATE               = CHARACTER$*$($*$) (Given)
      }{
         the date of the observation
      }
      \sstsubsection{
         OBS\_TIME               = CHARACTER$*$($*$) (Given)
      }{
         the UT of the observation
      }
      \sstsubsection{
         RUN\_NUMBER             = INTEGER (Given)
      }{
         the observation number
      }
      \sstsubsection{
         OBJECT                 = CHARACTER$*$($*$) (Given)
      }{
         the name of the object observed
      }
      \sstsubsection{
         SUB\_INSTRUMENT         = CHARACTER$*$($*$) (Given)
      }{
         the name of the sub-instrument used
      }
      \sstsubsection{
         FILTER                 = CHARACTER$*$($*$) (Given)
      }{
         the name of the filter used
      }
      \sstsubsection{
         CENTRE\_COORDS          = CHARACTER$*$($*$) (Given)
      }{
         the coordinate system of the telescope centre coords
      }
      \sstsubsection{
         LAT                    = CHARACTER$*$($*$) (Given)
      }{
         the latitude of the telescope centre
      }
      \sstsubsection{
         LONG                   = CHARACTER$*$($*$) (Given)
      }{
         the longitude of the telescope centre
      }
      \sstsubsection{
         LAT2                   = CHARACTER$*$($*$) (Given)
      }{
         the second source latitude if CENTRE\_COORDS is PLANET
      }
      \sstsubsection{
         LONG2                  = CHARACTER$*$($*$) (Given)
      }{
         the second source longitude if CENTRE\_COORDS is PLANET
      }
      \sstsubsection{
         MJD1                   = DOUBLE PRECISION (Given)
      }{
         the modified Julian date of LAT,LONG if CENTRE\_COORDS is PLANET
      }
      \sstsubsection{
         MJD2                   = DOUBLE PRECISION (Given)
      }{
         the modified Julian date of LAT2,LONG2 if CENTRE\_COORDS is PLANET
      }
      \sstsubsection{
         OFFSET\_COORDS          = CHARACTER$*$($*$) (Given)
      }{
         the coordinate system of the map centre offsets
      }
      \sstsubsection{
         MAP\_X                  = REAL (Given)
      }{
         the x offset of the map centre
      }
      \sstsubsection{
         MAP\_Y                  = REAL (Given)
      }{
         the y offset of the map centre
      }
      \sstsubsection{
         SAMPLE\_COORDS          = CHARACTER$*$($*$) (Given)
      }{
         the coordinate system of the jiggle offsets
      }
      \sstsubsection{
         SAMPLE\_PA              = REAL (Given)
      }{
         the position angle by which the x-axis of the jiggle offsets is
         rotated (anti-clockwise) from the x-axis of the SAMPLE\_COORDS
         system
      }
      \sstsubsection{
         SKY\_SUBTRACTION        = LOGICAL (Given)
      }{
         .TRUE. if the sky error has been removed
      }
      \sstsubsection{
         MAX\_BEAM               = INTEGER (Given)
      }{
         the maximum number of bolometers that can observe the source
         in a single observation
      }
      \sstsubsection{
         PHOT\_BB (MAX\_BEAM)     = INTEGER (Given)
      }{
         the indices of the bolometers used to observe the source in
         each beam in the BOL\_CHAN and BOL\_ADC arrays
      }
      \sstsubsection{
         FD                     = INTEGER (Returned)
      }{
         File descriptor of output file
      }
      \sstsubsection{
         STATUS                 = INTEGER (Given and returned)
      }{
         global status
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright \copyright 1995,1996,1997,1998,1999 Particle Physics and Astronomy
      Research Council. All Rights Reserved.
   }
}
