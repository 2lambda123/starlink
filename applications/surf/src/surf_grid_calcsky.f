      SUBROUTINE SURF_GRID_CALCSKY( TSKNAME, N_FILES, N_PTS, N_POS, 
     :     N_BOLS, WAVELENGTH, DIAMETER, BOX_SIZE, BOL_RA_PTR, 
     :     BOL_DEC_PTR, DATA_PTR, QUALITY_PTR,  SKY_PTR, SKY_ERR,
     :     BADBIT, STATUS )
*+
*  Name:
*     SURF_GRID_CALCSKY

*  Purpose:
*     Calculate sky contribution from median image

*  Language:
*     Starlink Fortran 77
 
*  Invocation:
*     CALL SURF_GRID_DESPIKE ( TSKNAME, N_FILES, N_PTS, N_POS, N_BOLS, 
*    :     WAVELENGTH, DIAMETER, BOX_SIZE, BOL_RA_PTR, BOL_DEC_PTR, DATA_PTR, 
*    :     QUALITY_PTR, NX, NY, ICEN, JCEN, NSPIKES,
*    :     BADBIT, STATUS ) 

*  Description:
*     For each data point this routine places it into a bin in the 
*     output grid depending on the position of the data point on the sky.
*     The position in the input data array is stored.
*     This is done in two stages:
*
*     1) Find the size of the output grid from the maximum extent of
*        the input data.
*     2) Loop through data. Find I,J coordinate of each point in the 
*        output grid.
*     3) Find out maximum number of points for an I,J position.
*     4) Put data onto grid in array (I,J,N) [REALS]. 
*        We also need to store positions of these data.
*        We can either do it by storing the file number, bolometer and
*        position (time) index OR we can just store some index in a merged
*        data array that goes from 1..TOT_PTS. 
*         First method is easy but memory hungry. Second method is 
*         more efficient but does need some reconstruction to work
*         out where the point was in the original data.
*       Use the second method.
*   
*     Once the data is gridded, it is first displayed and then
*     despiked. Currently despiking is done on a simple sigma clipping
*     basis for each bin.


*  Arguments:
*     N_FILES = INTEGER (Given)
*       Number of data sets (ie files)
*     N_PTS ( N_FILES ) = INTEGER (Given)
*       Total number of points in each map
*     N_POS( N_FILES ) = INTEGER (Given)
*       Number of positions per set (Y positions)
*     N_BOLS( N_FILES ) = INTEGER (Given)
*       Number of bolometers per set (X positions)
*     WAVELENGTH = REAL (Given)
*       Wavelength of observation in microns
*     DIAMETER = REAL (Given)
*       Diameter of telescope in metres
*     BOX_SIZE ( N_FILES ) = INTEGER (Given)
*       Size of smoothing box - pixels
*     BOL_RA_PTR( N_FILES ) = INTEGER (Given)
*       Array of pointers to position information (X coords)
*       Note that each data set has positions for N_POS * N_BOLS 
*     BOL_RA_PTR( N_FILES ) = INTEGER (Given)
*       Array of pointers to position information (Y coords)
*     DATA_PTR( N_FILES ) = INTEGER (Given)
*       Pointers to actual data arrays
*     QUALITY_PTR( N_FILES ) = INTEGER (Given)
*       Pointer to quality arrays
*     NX = INTEGER (Returned)
*       Number of points in grid (X)
*     NY = INTEGER (Returned)
*       Number of points in grid (Y)
*     ICEN = INTEGER (Returned)
*       Reference pixel (X)
*     JCEN = INTEGER (Returned)
*       Reference pixel (Y)
*     NSPIKES ( N_FILES ) = INTEGER (Returned)
*       Number of spikes detected (and removed) in each file
*     BADBIT ( N_FILES ) = BYTE (Given)
*       Bad bit mask for identifying bad pixels from quality
*     STATUS = INTEGER (Given & Returned)
*       Global Status

*  ADAM Parameters:
*     BOXSZ = INTEGER (Given)
*       Size of smoothing box in seconds. This is used to smooth
*       the time series. Default is 2.0 seconds.
*     DMODE = CHAR (Given)
*       Determines nearest neighbour. Only useful when SMODE is
*       set to HANN. Allowed values are:
*         SPIRAL  - A Spiral outwards from the reference pixel
*         XLINEAR - unfold each X strip in turn for each Y
*         YLINEAR - unfold each Y strip in turn for each X
*         DIAG1   - diagonal strips starting at position (1,1)
*         DIAG2   - diagonal strips starting at positions (nx,1)
*     MODEL = NDF (Read)
*       NDF containing the model of the source. The size of the
*       input image must (currently) match the default size of the
*       image that would be generated by REBIN with the current input
*       files.
*     NOSRC = NDF (Write)
*       File to store source removed data. This can be used to
*       check the source removal. Note that this output file can
*       not be used directly by SURF for further processing since 
*       the header is incomplete. No file is written by default.
*     NSIGMA = REAL (Given)
*       Number of sigma used in clipping
*     SMODE = CHAR (Given)
*       Mode used for smoothing the clipping envelope.
*       Available modes are:
*         NONE  - No smoothing (this is not dependent on the DMODE)
*         HANN  - Hanning smoothing
*       All modes except 'NONE' depend on the unwrapping mode (given
*       by parameter DMODE) since this determines which pixels are adjacent
*       to a given bin.
*     XRANGE = INTEGER (Given)
*       X Range of plot

*  Notes:
*     For SMODE=NONE, DMODE is only requested if a plot is required.

*  Authors:
*     Tim Jenness (timj@jach.hawaii.edu)

*  History:
*     Original version: Timj, 1997 Oct 20
*     $Log$
*     Revision 1.1  1998/06/10 04:01:36  timj
*     Initial revision
*
*     Revision 1.2  1998/05/12 20:56:48  timj
*     Free the memory allocated for STATS
*
*     Revision 1.1  1997/11/12 00:13:37  timj
*     Initial revision
*


*-

*  Type Definitions:
      IMPLICIT NONE                              ! No implicit typing
 
*  Global Constants:
      INCLUDE 'SAE_PAR'                          ! Standard SAE constants
      INCLUDE 'DAT_PAR'                          ! DAT__SZLOC
      INCLUDE 'PRM_PAR'                          ! Bad values
      INCLUDE 'PAR_ERR'                          ! PAR__NULL
      INCLUDE 'MSG_PAR'                          ! MSG__NORM
      INCLUDE 'SURF_PAR'                         ! SURF constants
 
*  Arguments Given:
      CHARACTER * (*) TSKNAME
      INTEGER N_FILES
      BYTE    BADBIT ( N_FILES )
      INTEGER N_POS ( N_FILES )
      INTEGER N_PTS ( N_FILES )
      INTEGER N_BOLS ( N_FILES )
      INTEGER BOL_DEC_PTR ( N_FILES )
      INTEGER BOL_RA_PTR ( N_FILES )
      INTEGER BOX_SIZE ( N_FILES )
      INTEGER DATA_PTR ( N_FILES )
      INTEGER QUALITY_PTR ( N_FILES )
      INTEGER SKY_PTR ( N_FILES )
      INTEGER SKY_ERR ( N_FILES )
      REAL    WAVELENGTH
      REAL    DIAMETER
      INTEGER NX
      INTEGER NY
      INTEGER ICEN
      INTEGER JCEN
      
*  Arguments Returned:

*  Status:
      INTEGER STATUS                        ! Global status

*  Local Constants:
 
*  Local Variables:
      INTEGER BIN_PTR                       ! Binned data
      INTEGER BIN_PTR_END                   ! End of BIN_PTR
      INTEGER BIN_POS_PTR                   ! Position of binned data
      INTEGER BIN_POS_END                   ! End of BIN_POS
      INTEGER BOX_DIV                       ! Box size div by 2
      BYTE    BTEMP                         ! Temporary byte
      INTEGER DIMS ( 2 )                    ! Dimensions of input image
      CHARACTER * (80) FITS (SCUBA__MAX_FITS) ! FITS info
      CHARACTER * (DAT__SZLOC) FITSX_LOC    ! Locator to FITS
      INTEGER GRID_END                      ! End of scratch array
      INTEGER GRID_PTR                      ! Scratch space
      LOGICAL HAVE_MODEL                    ! Have external image for source
      INTEGER I                             ! Loop counter
      INTEGER IERR                          ! For VEC_
      INTEGER IJPOS_PTR                     ! Ptr to array containing I,J's
      INTEGER IJPOS_END                     ! End of IJPOS_PTR
      INTEGER IMAX                          ! I pos of hist max
      INTEGER IMNDF                         ! NDF id for input image
      INTEGER IPOS_END                      ! End of ipos_ptr
      INTEGER IPOS_PTR                      ! I positions in lookup table
      INTEGER ISTART                        ! Start of count
      INTEGER ISTOP                         ! End of count
      INTEGER ITEMP                         ! Temp integer
      INTEGER J                             ! Loop variable
      INTEGER JPOS_END                      ! End of jpos_ptr
      INTEGER JPOS_PTR                      ! J positions in lookup table
      INTEGER JMAX                          ! J pos of hist max
      INTEGER K                             ! Loop counter
      DOUBLE PRECISION MEAN                 ! Mean of sky
      DOUBLE PRECISION MEDIAN               ! Median of sky
      INTEGER NGOOD                         ! Number of good sky points
      INTEGER NERR                          ! For VEC_
      INTEGER NMAX                          ! Max entries per cell
      REAL    NSIGMA                        ! Despiking level
      INTEGER N_FITS                        ! Number of FITS keywords
      INTEGER OFFSET                        ! Offset in data array
      REAL    OUT_PIXEL                     ! Pixel size in radians
      DOUBLE PRECISION PIXELSZ              ! Pixel size in image (ARCSEC)
      INTEGER PNT_END                       ! End of PNT_PTR
      INTEGER PNT_PTR                       ! Work space for gridded points
      REAL    RTEMP                         ! Scratch real
      INTEGER SCRATCH_END                   ! Scratch space
      INTEGER SCRATCH_PTR                   ! Scratch space
      INTEGER SCRATCH2_END                   ! Scratch space
      INTEGER SCRATCH2_PTR                   ! Scratch space
      INTEGER SCRATCHUB_END                   ! Scratch space
      INTEGER SCRATCHUB_PTR                   ! Scratch space
      CHARACTER * (10) SMODE                ! Smoothing mode
      INTEGER STATS_END                     ! End of STATS_PTR
      INTEGER STATS_PTR                     ! Bin statistics
      DOUBLE PRECISION STDEV       ! Standard deviation
      DOUBLE PRECISION SUM         ! Sum of data
      DOUBLE PRECISION SUMSQ       ! Sum of squares data
      INTEGER TOT_PTS                       ! Total number of points to despike
      CHARACTER * (10) UMODE                ! Pixel unwrapping mode

      INTEGER UBND(2)
      INTEGER LBND(2)
      INTEGER GRPNTR
      INTEGER GRNDF

*  Local data
*.
 
      IF (STATUS .NE. SAI__OK) RETURN

*     Initialise pointers
      BIN_PTR = 0
      BIN_PTR_END = 0
      BIN_POS_PTR = 0
      BIN_POS_END = 0
      GRID_PTR = 0
      GRID_END = 0
      PNT_END = 0
      PNT_PTR = 0
      SCRATCH_END = 0
      SCRATCH_PTR = 0
      IJPOS_PTR = 0
      IJPOS_END = 0

*     First need to find out how many data points we are dealing with

      TOT_PTS = 0

      DO I = 1, N_FILES

         TOT_PTS = TOT_PTS + N_PTS(I)

      END DO

*     Ask the user for an input image. This can be used as our
*     model from which we can derive the sky fluctuations.
*     Note that this model image must cover the full region covered
*     by the data (although pixel scale is not important since I can read
*     that from the header)

      HAVE_MODEL = .FALSE.
      IF (STATUS .EQ. SAI__OK) THEN
         CALL NDF_ASSOC('MODEL','READ',IMNDF, STATUS)

         IF (STATUS .EQ. SAI__OK) THEN

            HAVE_MODEL = .TRUE.

*     Read FITS header
            CALL NDF_XLOC (IMNDF, 'FITS', 'READ', FITSX_LOC,
     :           STATUS)
            CALL DAT_SIZE (FITSX_LOC, ITEMP, STATUS)
            IF (ITEMP .GT. SCUBA__MAX_FITS) THEN
               IF (STATUS .EQ. SAI__OK) THEN
                  STATUS = SAI__ERROR
                  CALL MSG_SETC('TASK', TSKNAME)
                  CALL ERR_REP (' ', '^TASK: input '//
     :                 'file contains too many FITS items', STATUS)
               END IF
            END IF
 
            CALL DAT_GET1C (FITSX_LOC, SCUBA__MAX_FITS, FITS, 
     :           N_FITS, STATUS)
            CALL DAT_ANNUL (FITSX_LOC, STATUS)

*     Read PIXELSZ (pixel scale in arcsec)
            CALL SCULIB_GET_FITS_D(SCUBA__MAX_FITS, N_FITS, FITS,
     :           'SCUPIXSZ', PIXELSZ, STATUS)

            OUT_PIXEL = PIXELSZ / R2AS

*     If a null is returned then assume that the user wants to
*     derive the source signal in this routine
*     Calculate ourselves
         ELSE IF (STATUS .EQ. PAR__NULL) THEN
            
            CALL ERR_ANNUL(STATUS)
            HAVE_MODEL = .FALSE.

*     Choose a pixel size based on wavelength
*     and dish diameter.
*     Try for quarter beam size first.
            
            OUT_PIXEL = (WAVELENGTH * 1.0E-6 / DIAMETER) / 4.0

         END IF

      END IF

*     Now find out how big an output grid is needed

      CALL SURFLIB_CALC_OUTPUT_GRID(N_FILES, N_PTS, OUT_PIXEL,
     :     BOL_RA_PTR, BOL_DEC_PTR, NX, NY, ICEN, JCEN, STATUS)

*     If we are reading in an image, compare grid size.
*     Raise an error if they are different. (ie somebody rebinned
*     a subset -- dont want to handle that possibility at the moment)
*     Also dont check that reference pixel is correct

      IF (HAVE_MODEL .AND. STATUS .EQ. SAI__OK) THEN
         
*     Get dims
         CALL NDF_DIM(IMNDF, 2, DIMS, ITEMP, STATUS)

         IF (ITEMP .NE. 2 .OR. DIMS(1) .NE. NX .OR. 
     :        DIMS(2) .NE. NY) THEN

            STATUS = SAI__ERROR
            CALL MSG_SETI('DX', DIMS(1))
            CALL MSG_SETI('DY', DIMS(2))
            CALL MSG_SETI('NX', NX)
            CALL MSG_SETI('NY', NY)
            CALL MSG_SETC('TASK', TSKNAME)
            CALL ERR_REP(' ','^TASK: Dims of input Image (^DX, ^DY) '//
     :           'do not match calculated extent of data (^NX, ^NY)',
     :           STATUS)

         END IF

      END IF


*     The first run through simply stores an I,J for each of the TOT_PTS
*     So need to allocate some memory. Just need two locations per point.
*     A 2 x TOT_PTS integer array

      CALL SCULIB_MALLOC (TOT_PTS * 2 * VAL__NBI,
     :     IJPOS_PTR, IJPOS_END, STATUS)

*     Allocate some memory for the histogram

      CALL SCULIB_MALLOC(NX * NY * VAL__NBI, GRID_PTR, GRID_END,
     :     STATUS)

*     Fill with zeroes
      IF (STATUS .EQ. SAI__OK) THEN
         CALL SCULIB_CFILLI(NX * NY, 0, %VAL(GRID_PTR))
      END IF



*     Now loop through each map in turn and fill this array
*     Note that we put all the data in this array (ie each
*     input file is in this array). The index is 1..TOT_PTS where
*     the division is every N_PTS(I)
*     Whilst we are at it, construct a histogram.
*     Need to do this via a subroutine since I only have access to
*     pointers here.

      OFFSET = 0

      DO I = 1, N_FILES

*     Fill the array with data. (1 file at a time)

         CALL SURFLIB_CALC_IJPOS(N_PTS(I), DBLE(OUT_PIXEL), ICEN, JCEN,
     :        %VAL(BOL_RA_PTR(I)), %VAL(BOL_DEC_PTR(I)), 
     :        %VAL(IJPOS_PTR + (2 * OFFSET * VAL__NBR)),
     :        STATUS)

*     At the same time we can be adding the returned data into
*     a histogram (since we have already calculated the offsets
*     in the returned data). NMAX tells us the maximum number of
*     entries for any cell.
*     Note that in order that the histogram
*     is correct for our given data set we must pass in the quality
*     and data array so that bad pixels are not included in the
*     calculation. We could do it without the data values (and probably
*     should) but I am just trying to do it properly...

         CALL SURFLIB_HISTOGRAM_GRID( N_PTS(I), NX, NY, .TRUE.,
     :        %VAL(DATA_PTR(I)), %VAL(QUALITY_PTR(I)), BADBIT(I),
     :        %VAL(IJPOS_PTR + (2 * OFFSET * VAL__NBI)),
     :        %VAL(GRID_PTR), IMAX, JMAX, NMAX, STATUS)


*     Calculate the offset in the position array based on file number
*     for the next time round the loop
         OFFSET = OFFSET + N_PTS(I)

      END DO

*     If we have an input image then the STATS for the image
*     are simply the mapped input data (dont care about variance)

      IF (HAVE_MODEL) THEN

         CALL NDF_MAP(IMNDF, 'DATA', '_REAL', 'READ', STATS_PTR,
     :        ITEMP, STATUS)

      ELSE

*     Now we know where each pixel is. We need to put this data onto
*     a grid. From the histogram we know how big the array needs to
*     be that contains each data point.

*     Get some memory for the output grid
*     Need two arrays
*      1) Real array containing the data values (NX, NY, NMAX)
*      2) Integer array containing the positions for each value (NX,NY,NMAX)

         CALL SCULIB_MALLOC(NX * NY * NMAX * VAL__NBR, BIN_PTR,
     :        BIN_PTR_END, STATUS)

         CALL SCULIB_MALLOC(NX * NY * NMAX * VAL__NBI, BIN_POS_PTR,
     :        BIN_POS_END, STATUS)

*     We are going to use the histogram scratch space to keep track
*     of the current highest member used in BIN_PTR (etc).
*     Two options for doing this:
*       1. Reset to zero and increment each time a data point is entered.
*       2. Leave as is and decrement each time a data point is entered.
*     Not much difference so I will go for the increment option.


*     Initialise the work arrays

         IF (STATUS .EQ. SAI__OK) THEN
            CALL SCULIB_CFILLI(NX * NY, 0, %VAL(GRID_PTR))
            CALL SCULIB_CFILLR(NX * NY * NMAX, VAL__BADR, %VAL(BIN_PTR))
            CALL SCULIB_CFILLI(NX * NY * NMAX, VAL__BADI, 
     :           %VAL(BIN_POS_PTR))
         END IF

*     Now we need to copy the data into BIN_PTR and the positions
*     into BIN_POS_PTR. 

         OFFSET = 0

         DO I = 1, N_FILES

            CALL SURFLIB_FILL_GRID(N_PTS(I), NX, NY, NMAX, OFFSET,
     :           %VAL(DATA_PTR(I)), %VAL(QUALITY_PTR(I)), BADBIT(I),
     :           %VAL(IJPOS_PTR + (2 * OFFSET * VAL__NBI)),
     :           %VAL(GRID_PTR), %VAL(BIN_PTR), %VAL(BIN_POS_PTR),
     :           STATUS)

*     Calculate the offset in the position array based on file number
*     for the next time round the loop
            OFFSET = OFFSET + N_PTS(I)

         END DO


*     Free the scratch memory used for the histogram and counting the
*     current position in the array.

         CALL SCULIB_FREE ('GRID_PTR', GRID_PTR, GRID_END, STATUS)

*     Some scratch space for storing the numbers (size nmax)
*     in each bin

         CALL SCULIB_MALLOC(NMAX * VAL__NBR, PNT_PTR, PNT_END, STATUS)
         CALL SCULIB_MALLOC(NMAX * VAL__NBR, SCRATCH_PTR, SCRATCH_END, 
     :        STATUS)


*     Calculate the grid positions related to a given pixel index
*     Need to do this since some people want complicated spiral unwrapping
*     and it takes too long to calculate all this on the fly.

*     Allocate some memory

         IPOS_PTR = 0
         JPOS_PTR = 0
         IPOS_END = 0
         JPOS_END = 0

         CALL SCULIB_MALLOC(NX * NY * VAL__NBI, IPOS_PTR, IPOS_END,
     :        STATUS)
         CALL SCULIB_MALLOC(NX * NY * VAL__NBI, JPOS_PTR, JPOS_END,
     :        STATUS)
      
*     ...and calculate the new grid look up table

         UMODE = 'XLINEAR'
         CALL SURFLIB_CALC_GRIDIJ(UMODE, NX, NY, ICEN, JCEN,
     :        %VAL(IPOS_PTR), %VAL(JPOS_PTR), STATUS)


*     Calculate the statistics of each bin and store in an array.
*     Since this is generally useful for the plotting and the
*     despiking itself.
*     Have three measurements: 
*         Median and The mean + nsigma and the mean - nsigma
*     Note that SURFLIB_PLOT_GRID still needs to work out the
*     positions itself since it can not deal with bad pixels.

*     Memory for the statistics
*     Since it is all related, just create one array to store
*     all the stats.

         STATS_PTR = 0
         STATS_END = 0
         CALL SCULIB_MALLOC(3 * NX * NY * VAL__NBR, STATS_PTR,STATS_END, 
     :        STATUS)

*     Calculate stats using the specified smoothing mode

         SMODE = 'NONE'
         NSIGMA = 0.0
         CALL SURFLIB_STATS_GRID(SMODE, NX, NY, NMAX, NSIGMA, 
     :        %VAL(IPOS_PTR),
     :        %VAL(JPOS_PTR), %VAL(BIN_PTR), %VAL(PNT_PTR),
     :        %VAL(STATS_PTR), STATUS)
         
*     Free memory
         CALL SCULIB_FREE('PNT_PTR', PNT_PTR, PNT_END, STATUS)
         CALL SCULIB_FREE('SCRATCH', SCRATCH_PTR, SCRATCH_END, STATUS)

*     Free positions
         CALL SCULIB_FREE('IPOS_PTR', IPOS_PTR, IPOS_END, STATUS)
         CALL SCULIB_FREE('JPOS_PTR', JPOS_PTR, JPOS_END, STATUS)


*     Free BIN_PTR 
         CALL SCULIB_FREE('BIN_PTR', BIN_PTR, BIN_PTR_END, STATUS)
         CALL SCULIB_FREE('BIN_POS', BIN_POS_PTR, BIN_POS_END, STATUS)


      END IF

*     Now we have statistics so can now subtract the median
*     from each pixel in the input data
*     Loop over files so that we can pass data in rather than pointers

      OFFSET = 0
      DO I = 1, N_FILES

*     Subtract median
         CALL SURFLIB_REM_GRID(N_PTS(I), NX, NY,
     :        %VAL(IJPOS_PTR + (2 * OFFSET * VAL__NBI)), 
     :        %VAL(STATS_PTR), %VAL(DATA_PTR(I)), STATUS)
      
*     Find new offset in lookup table
         OFFSET = OFFSET + N_PTS(I)

      END DO

*     Free Statistics and lookup table
      IF (HAVE_MODEL) THEN
         CALL NDF_UNMAP(IMNDF, '*', STATUS)
         CALL NDF_ANNUL(IMNDF, STATUS)
      ELSE
         CALL SCULIB_FREE('STATS_PTR', STATS_PTR, STATS_END, STATUS)
      END IF

      CALL SCULIB_FREE ('IJPOS_PTR', IJPOS_PTR, IJPOS_END, STATUS)

*     Write data to file
      LBND(1) = 1
      LBND(2) = 1
      UBND(1) = N_BOLS(1)
      UBND(2) = N_POS(1)
      IF (STATUS .EQ. SAI__OK) THEN
         CALL NDF_CREAT('NOSRC','_REAL', 2, LBND, UBND, GRNDF, STATUS)
 
         IF (STATUS .NE. PAR__NULL) THEN
 
            CALL NDF_MAP(GRNDF, 'DATA', '_REAL', 'WRITE', GRPNTR, 
     :           ITEMP, STATUS)
            CALL VEC_RTOR(.FALSE., N_BOLS(1) * N_POS(1), 
     :           %VAL(DATA_PTR(1)), 
     :           %VAL(GRPNTR), IERR, NERR, STATUS)
            CALL NDF_UNMAP(GRNDF, 'DATA', STATUS)
            CALL NDF_MAP(GRNDF, 'QUALITY', '_UBYTE', 'WRITE', GRPNTR, 
     :           ITEMP, STATUS)
            CALL VEC_UBTOUB(.FALSE., N_BOLS(1) * N_POS(1), 
     :           %VAL(QUALITY_PTR(1)), 
     :           %VAL(GRPNTR), IERR, NERR, STATUS)
            CALL NDF_UNMAP(GRNDF, 'QUALITY', STATUS)
            CALL NDF_SBB(BADBIT(1), GRNDF, STATUS)

            CALL NDF_ANNUL(GRNDF, STATUS)
         ELSE
            CALL ERR_ANNUL(STATUS)
         END IF
      END IF




*     The source has now been removed from the data.
*     We can now calculate the sky  by doing statistics
*     on each time slice and storing this in the sky array

*     Allocate some scratch data space for the sorting
*     Simply allocate MAX_SCUBA_BOLS of data so that I don't
*     have to reallocate for each file since in principal there
*     can be different numbers of bolometers per file

      SCRATCH_END = 0
      SCRATCH_PTR = 0
      CALL SCULIB_MALLOC(SCUBA__NUM_CHAN * SCUBA__NUM_ADC * VAL__NBR,
     :     SCRATCH_PTR, SCRATCH_END, STATUS)

      SCRATCH2_END = 0
      SCRATCH2_PTR = 0
      CALL SCULIB_MALLOC(SCUBA__NUM_CHAN * SCUBA__NUM_ADC * VAL__NBR,
     :     SCRATCH2_PTR, SCRATCH2_END, STATUS)
      SCRATCHUB_END = 0
      SCRATCHUB_PTR = 0
      CALL SCULIB_MALLOC(SCUBA__NUM_CHAN * SCUBA__NUM_ADC * VAL__NBUB,
     :     SCRATCHUB_PTR, SCRATCHUB_END, STATUS)

*     Loop over files
      DO I = 1, N_FILES

         DO J = 1, N_POS(I)

            OFFSET = (J-1) * N_BOLS(I)

*     Need to remove all the points that are exactly 0.0D0 since
*     these do not provide a measure of the sky

            NGOOD = 0
            DO K = 1, N_BOLS(I)
               
               CALL VEC_RTOR(.FALSE., 1,
     :              %VAL(DATA_PTR(I) + ((K-1) + OFFSET) * VAL__NBR),
     :              RTEMP, IERR, NERR, STATUS)

*       Skip if zero
               IF (RTEMP .NE. 0.0) THEN
                  CALL VEC_RTOR(.FALSE., 1, RTEMP,
     :                 %VAL(SCRATCH2_PTR + NGOOD*VAL__NBR),
     :                 IERR, NERR, STATUS)
                  CALL VEC_UBTOUB(.FALSE., 1,
     :                 %VAL(QUALITY_PTR(I) + ((K-1)+OFFSET)* VAL__NBUB),
     :                 %VAL(SCRATCHUB_PTR + NGOOD*VAL__NBUB),
     :                 IERR, NERR, STATUS)

                  NGOOD = NGOOD + 1
                  
               END IF

            END DO


*       Dont need to do anything special here. Just pass the data
*       to stats (bad pixel and all)
            
*            CALL SCULIB_STATR(N_BOLS(I), -1.0, 
*     :           %VAL(DATA_PTR(I) + OFFSET * VAL__NBR),
*     :           %VAL(QUALITY_PTR(I) + OFFSET * VAL__NBUB),
            CALL SCULIB_STATR(NGOOD, -1.0,
     :           %VAL(SCRATCH2_PTR), %VAL(SCRATCHUB_PTR),
     :           BADBIT(I), ITEMP, MEAN, MEDIAN, SUM, SUMSQ,
     :           STDEV, %VAL(SCRATCH_PTR), STATUS)

*     Copy this value to the SKY_PTR array
            CALL VEC_DTOR(.TRUE., 1, MEDIAN, 
     :           %VAL(SKY_PTR(I) + (J-1) * VAL__NBR),
     :           IERR, NERR, STATUS)
*     Copy in the error
            CALL VEC_DTOR(.TRUE., 1, STDEV, 
     :           %VAL(SKY_ERR(I) + (J-1) * VAL__NBR),
     :           IERR, NERR, STATUS)

         END DO

      END DO

*     Free sort area.
      CALL SCULIB_FREE('SCRATCH', SCRATCH_PTR, SCRATCH_END, STATUS)
      CALL SCULIB_FREE('SCRAT2', SCRATCH2_PTR, SCRATCH2_END, STATUS)
      CALL SCULIB_FREE('SCRATUB', SCRATCHUB_PTR, SCRATCHUB_END, STATUS)

*     In some cases (eg SCAN/MAP) we need to smooth the time series
*     with a box average
*     In general the sky varies on a 10-20 second time scale whereas
*     we take scan map data at 1/8 second.

*     Loop over files
      DO I = 1, N_FILES

*     The number of pixels to bin over for each file is specified
*     in BIN_SIZE(I) and is passed in from above.
*     Divide size of bin by 2
         BOX_DIV = BOX_SIZE(I) / 2

*     Get some memory for scratch space
         CALL SCULIB_MALLOC(N_POS(I) * VAL__NBR, SCRATCH_PTR,
     :        SCRATCH_END, STATUS)
         CALL SCULIB_MALLOC(N_POS(I) * VAL__NBR, SCRATCH2_PTR,
     :        SCRATCH2_END, STATUS)
         CALL SCULIB_MALLOC(N_POS(I) * VAL__NBUB,
     :        SCRATCHUB_PTR, SCRATCHUB_END, STATUS)

*     Copy unsmoothed data into scratch space (variance from spread)
         CALL VEC_RTOR(.FALSE., N_POS(I), %VAL(SKY_PTR(I)),
     :        %VAL(SCRATCH_PTR), IERR, NERR, STATUS)
         BTEMP = 0
         IF (STATUS .EQ. SAI__OK) THEN
            CALL SCULIB_CFILLB(N_POS(I), BTEMP, %VAL(SCRATCHUB_PTR))
         END IF

*     Loop over positions
         DO J = 1, N_POS(I)

*     Determine start and end of box
            ISTART = MAX(1, J - BOX_DIV)
            ISTOP  = MIN(N_POS(I), J + BOX_DIV)

*     Now find stats of this section
            NGOOD = ISTOP - ISTART + 1

            CALL SCULIB_STATR(NGOOD, -1.0,
     :           %VAL(SCRATCH_PTR + (ISTART - 1)*VAL__NBR), 
     :           %VAL(SCRATCHUB_PTR + (ISTART - 1)*VAL__NBUB),
     :           BTEMP, ITEMP, MEAN, MEDIAN, SUM, SUMSQ,
     :           STDEV, %VAL(SCRATCH2_PTR), STATUS)

*     Copy result to output file
*     Copy this value to the SKY_PTR array
            CALL VEC_DTOR(.TRUE., 1, MEAN, 
     :           %VAL(SKY_PTR(I) + (J-1) * VAL__NBR),
     :           IERR, NERR, STATUS)
*     Copy in the error if the status was good
*     if not (eg bin was 1 pixel wide). Just keep the variance
*     from the earlier calculation
            IF (STDEV .NE. VAL__BADD) THEN
               CALL VEC_DTOR(.TRUE., 1, STDEV, 
     :              %VAL(SKY_ERR(I) + (J-1) * VAL__NBR),
     :              IERR, NERR, STATUS)
            END IF

         END DO

*     Free the scratch space
         CALL SCULIB_FREE('SCRAT_SM', SCRATCH_PTR, SCRATCH_END, STATUS)
         CALL SCULIB_FREE('SCRAT2_SM', SCRATCH2_PTR, SCRATCH2_END, 
     :        STATUS)
         CALL SCULIB_FREE('SCRATUB_SM', SCRATCHUB_PTR, SCRATCHUB_END, 
     :        STATUS)

      END DO

      END
