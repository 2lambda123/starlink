      SUBROUTINE SURF_REDUCE_NOISE ( STATUS )
*+
*  Name:
*    REDUCE_NOISE

*  Purpose:
*    Process demodulated noise data

*  Language:
*     Starlink Fortran 77
 
*  Type of Module:
*     ADAM A-task
 
*  Invocation:
*     CALL SURF_REDUCE_NOISE ( STATUS )
 
*  Arguments:
*     STATUS = INTEGER (Given and Returned)
*        The global status
 
*  Description:
*     This routine takes raw demodulated noise data and processes it.
*     NDF and ASCII results files are generated.
*
*     The output NDF file is a 2-D dataset with a chop signal and
*     calibrator signal per bolometer. The text file is similar
*     to the file generated by the real-time system.

*  ADAM parameters:
*     IN = NDF (Read)
*        The name of the raw noise data file. A single number can be
*        supplied if SCUBA_PREFIX is set. DATADIR is recognised.
*     OUT = NDF (Write)
*        Output NDF. This file is 2-dimensional. The first 
*        dimension is bolometer number. The second dimension is 
*        chop signal and calibrator signal (along with variances
*        and quality). If no output NDF is required a null value
*        can be given.
*     FILE = FILENAME (Write)
*        Output text file. Format is almost identical to that
*        generated by the real-time system. A null value can be
*        supplied to prevent a text file from being written. The
*        default output name is the same name as generated by the
*        on-line system (noise_YYMMDD_nr.dat)
*     MSG_FILTER = CHAR (Read)
*        Message output level. Default is NORM. Allowed values are
*        QUIET, NORMAL and VERBOSE.

*  Examples:
*     reduce_noise 19981113_dem_0001 out_noise !
*        Read in observation 1 and write the output to an NDF
*        names out_noise.sdf. Do not write a text file.
*     reduce_noise '3' ! accept
*        Process observation 3 but do not write an NDF output file.
*        Use the default file name for the text file.

*  Notes:
*     Noise observations containing multiple measurements are condensed
*     into a single measurement.

*  Authors:
*     JFL: John Lightfoot (ROE)
*     TIMJ: Tim Jenness (JACH)
*       {enter_new_authors_here}


*  Copyright:
*     Copyright (C) 1995,1996,1997,1998,1999 Particle Physics and Astronomy
*     Research Council. All Rights Reserved.

*  History:
*     1995-1997
*       Original on-line version (JFL)
*     November 1998
*       Converted to SURF (TIMJ)
*     $Log$
*     Revision 1.7  2004/09/08 02:03:34  timj
*     Add CNF_PVAL where appropriate
*
*     Revision 1.6  2003/04/02 02:58:24  timj
*     Protect bad pixels when changing type with VEC
*
*     Revision 1.5  1999/08/03 20:01:37  timj
*     Add copyright message to header.
*     Minor fixes to header style.
*
*     Revision 1.4  1999/05/15 02:02:10  timj
*     Initialise pointers
*
*     Revision 1.3  1999/05/15 01:48:40  timj
*     Finalise support for POLMAP/POLPHOT observing modes.
*     Only check first few characters of history app name
*     now that we are writing version number to this string.
*     POLPHOT is synonym for PHOTOM.
*
*     Revision 1.2  1999/03/08 20:57:42  timj
*     Initalise SCRATCH_PTR
*
*     Revision 1.1  1998/12/07 02:22:19  timj
*     Initial revision
*
*     {enter_further_changes_here}
 
*  Bugs:
*     {note_any_bugs_here}

*-

*  Type Definitions:
      IMPLICIT NONE

*  Global constants:
      INCLUDE 'SAE_PAR'                ! SSE global definitions
      INCLUDE 'MSG_PAR'                ! Add MSG__ constants
      INCLUDE 'SURF_PAR'               ! SURF constants
      INCLUDE 'DAT_PAR'                ! DAT__ constants
      INCLUDE 'PRM_PAR'                ! VAL__ constants
      INCLUDE 'PAR_ERR'                ! PAR__NULL
      INCLUDE 'CNF_PAR'                ! For CNF_PVAL function

*  Status:
      INTEGER STATUS

*  External references:
      INTEGER CHR_LEN
      EXTERNAL CHR_LEN

*  Local Constants:
      INTEGER MAXDIM
      PARAMETER (MAXDIM = 4)
      CHARACTER * 15 TSKNAME           ! Name of task
      PARAMETER ( TSKNAME = 'REDUCE_NOISE' )
      REAL    AMP_GAIN                 ! Combined gain of head-amps and
      PARAMETER ( AMP_GAIN = 8000.0 )  ! pre-amps

*  Local variables:
      CHARACTER  * ( 30 )  BOLOMS      ! List of observed bolometers
      CHARACTER * 10 BOLNAME           ! Name of bolometer
      INTEGER BOL_ADC (SCUBA__NUM_CHAN * SCUBA__NUM_ADC)
                                       ! A/D numbers of bolometers measured in
                                       ! input file
      INTEGER BOL_CHAN (SCUBA__NUM_CHAN * SCUBA__NUM_ADC)
                                       ! channel numbers of bolometers
                                       ! measured in input file
      CHARACTER*20 BOL_TYPE (SCUBA__NUM_CHAN, SCUBA__NUM_ADC)
                                       ! bolometer types
      REAL             BOL_DU3 (SCUBA__NUM_CHAN, SCUBA__NUM_ADC)
                                       ! dU3 Nasmyth coord of bolometers
      REAL             BOL_DU4 (SCUBA__NUM_CHAN, SCUBA__NUM_ADC)
                                       ! dU4 Nasmyth coord of bolometers
      REAL    CAL_DATA                 ! Calibrator data
      REAL    CAL_LAG                  ! Calibrator lag in samples
      REAL    CAL_PERIOD               ! Calibrator period in samples
      REAL    CAL_VARIANCE             ! Calibrator variance
      CHARACTER * 20 CENTRE_COORDS     ! Coordinate system of tracking centre
      CHARACTER * 20 CHOP_COORDS       ! Coordinate frame of chopping
      REAL    CHOP_DATA                ! Chop data
      REAL    CHOP_LAG                 ! Chop lag in samples
      REAL    CHOP_PA                  ! Chop position angle
      REAL    CHOP_PERIOD              ! Chop period period in samples
      REAL    CHOP_THROW               ! Chop throw (arcsec)
      REAL    CHOP_VARIANCE            ! Variance of chop
      INTEGER DIM ( MAXDIM )           ! Dimensions of an array
      INTEGER DEMOD_QUALITY            ! Quality
      INTEGER FD                       ! File handle
      CHARACTER * (80) FITS(SCUBA__MAX_FITS) ! FITS array
      CHARACTER * (DAT__SZLOC) FITS_LOC! Locator to FITS extension
      INTEGER I                        ! Loop counter
      INTEGER IEND                     ! End position in string
      INTEGER IERR                     ! For VEC_
      INTEGER IN_DATA_PTR              ! Input data
      CHARACTER*(DAT__SZLOC) IN_SCUBAX_LOC ! Locator to EXTENSIONS
      INTEGER IN_NDF                   ! Input NDF identifier
      INTEGER IPOSN                    ! Position in string
      INTEGER ISTART                   ! Start postiion in string
      INTEGER ITEMP                    ! Temporary variable
      INTEGER JIGL_DISCARD             ! Samples discarded after jiggle
      CHARACTER * 20 LAT               ! Latitude
      INTEGER LBND ( 2 )               ! Lower bounds of section
      CHARACTER * 80 LINE              ! Text line for output ASCII file
      CHARACTER * 20 LOCAL_COORDS      ! Local coordinate frame
      CHARACTER * 20 LONG              ! Longitude
      INTEGER NDIM                     ! Number of dimensions
      INTEGER NERR                     ! For VEC_
      INTEGER NREC                     ! Number of history records
      INTEGER NTICKS                   ! current Time in seconds
      INTEGER N_BOLS                   ! Number of bolometers
      INTEGER N_INTEGRATIONS           ! Number of integrations
      INTEGER N_FITS                   ! Number of FITS items
      CHARACTER * 20 OBJ_TYPE          ! Object type
      CHARACTER * 10 OBSERVING_MODE    ! Observing mode
      CHARACTER  * ( 80 ) ODF_NAME     ! Name of ODF
      CHARACTER * 132 OUTFILE          ! Output filename suggestion
      INTEGER OUT_DATA_END             ! end of Output data
      INTEGER OUT_DATA_PTR             ! Output data
      INTEGER OUT_NDF                  ! Output NDF id
      INTEGER OUT_QUALITY_END          ! end of Output quality
      INTEGER OUT_QUALITY_PTR          ! Output quality
      INTEGER OUT_VARIANCE_END         ! end of Output variance
      INTEGER OUT_VARIANCE_PTR         ! Output variance
      INTEGER POST_DISCARD             ! Samples discarded after chop
      INTEGER PRE_DISCARD              ! Samples discarded before chop
      LOGICAL REDUCE_NOISE             ! History logical
      INTEGER RUN_NUMBER               ! Run number
      INTEGER SAM_TIME                 ! Sample period in ticks
      INTEGER SCRATCH_END              ! Pointer to end of scratch space
      INTEGER SCRATCH_PTR              ! Pointer to scratch space
      INTEGER SECNDF                   ! NDF id for section
      CHARACTER * 80 STEMP             ! Temporary string
      INTEGER UBND ( 2 )               ! Upper bounds of section
      LOGICAL USENDF                   ! Are we writing an output NDF?
      CHARACTER  * ( 15 )  UTDATE      ! UT date
      CHARACTER  * ( 15 )  UTSTART     ! UT start time


*.


      IF (STATUS .NE. SAI__OK) RETURN

*     Set the MSG output level (for use with MSG_OUTIF)
      CALL MSG_IFGET('MSG_FILTER', STATUS)

*     Start up NDF
      CALL NDF_BEGIN

*     Look for the raw input file in DATADIR
      CALL SCULIB_SEARCH_DATADIR(PACKAGE, 'IN', IN_NDF, STATUS)


*     Read in the FITS header

      CALL NDF_XLOC (IN_NDF, 'FITS', 'READ', FITS_LOC, STATUS)
      CALL DAT_SIZE (FITS_LOC, ITEMP, STATUS)
      IF (ITEMP .GT. SCUBA__MAX_FITS) THEN
         IF (STATUS .EQ. SAI__OK) THEN
            STATUS = SAI__ERROR
            CALL MSG_SETC('TASK',TSKNAME)
            CALL ERR_REP (' ', '^TASK: input file '//
     :        'contains too many FITS items', STATUS)
         END IF
      END IF

      CALL DAT_GET1C (FITS_LOC, SCUBA__MAX_FITS, FITS, N_FITS, STATUS)

*     Annul the locator
      CALL DAT_ANNUL(FITS_LOC, STATUS)

*     Retrieve some general info and write this to user

      CALL SCULIB_GET_FITS_I (SCUBA__MAX_FITS, N_FITS, FITS, 'RUN', 
     :  RUN_NUMBER, STATUS)
      CALL SCULIB_GET_FITS_C (SCUBA__MAX_FITS, N_FITS, FITS, 'MODE',
     :  OBSERVING_MODE, STATUS)
      CALL CHR_UCASE (OBSERVING_MODE)

      CALL MSG_SETC ('MODE', OBSERVING_MODE)
      CALL MSG_SETI ('RUN', RUN_NUMBER)
      CALL MSG_SETC ('PKG', PACKAGE)
      CALL MSG_OUTIF (MSG__NORM, ' ', 
     :     '^PKG: run ^RUN was a ^MODE observation ',
     :     STATUS)


*     Check that this is a NOISE observation

      IF (OBSERVING_MODE .NE. 'NOISE') THEN
         CALL MSG_SETC('TASK', TSKNAME)

         IF (STATUS .EQ. SAI__OK) THEN
            STATUS = SAI__ERROR
            CALL ERR_REP(' ', '^TASK: This is not a NOISE observation',
     :           STATUS)
         END IF
      END IF

*     Check that the history is okay (ie we havent already
*     processed this with this routine

*  check that the history of the input file is OK

      IF (STATUS .EQ. SAI__OK) THEN
         CALL NDF_HNREC (IN_NDF, NREC, STATUS)
         IF (STATUS .NE. SAI__OK) THEN
            CALL ERR_ANNUL (STATUS)
            NREC = 0
         END IF

         REDUCE_NOISE = .FALSE.

         IF (NREC .GT. 0) THEN
            DO I = 1, NREC
               CALL NDF_HINFO (IN_NDF, 'APPLICATION', I, STEMP, STATUS)
               CALL CHR_UCASE (STEMP)
               IF (STEMP(:12) .EQ. 'REDUCE_NOISE') THEN
                  REDUCE_NOISE = .TRUE.
               END IF
            END DO
         ENDIF

         IF (REDUCE_NOISE) THEN
            IF (STATUS .EQ. SAI__OK) THEN
               STATUS = SAI__ERROR
               CALL MSG_SETC('TASK',TSKNAME)
               CALL ERR_REP (' ', '^TASK: REDUCE_NOISE '//
     :           'has already been run on the input data', STATUS)
            END IF
         END IF
      END IF

*  get the number of bolometers measured

      CALL SCULIB_GET_FITS_I (SCUBA__MAX_FITS, N_FITS, FITS, 'N_BOLS',
     :     N_BOLS, STATUS)

* Find the SCUBA extension

      CALL NDF_XLOC (IN_NDF, 'SCUBA', 'READ', IN_SCUBAX_LOC, STATUS)

* Get the bolometer description arrays (NB BOL_DU3 and DU4 are not used)

      CALL SCULIB_GET_BOL_DESC(IN_SCUBAX_LOC, SCUBA__NUM_CHAN,
     :     SCUBA__NUM_ADC, N_BOLS, BOL_TYPE, BOL_DU3,
     :     BOL_DU4, BOL_ADC, BOL_CHAN, STATUS)

*     Annul the locator
      CALL DAT_ANNUL(IN_SCUBAX_LOC, STATUS)
 
*     Check the dimensions of the input data array

      CALL NDF_DIM (IN_NDF, MAXDIM, DIM, NDIM, STATUS)

      IF (STATUS .EQ. SAI__OK ) THEN
         IF ((NDIM .NE. 3)    .OR.
     :        (DIM(1) .NE. 5) .OR.
     :        (DIM(2) .NE. N_BOLS)) THEN
            STATUS = SAI__ERROR
            CALL MSG_SETI ('NDIM', NDIM)
            CALL MSG_SETI ('DIM1', DIM(1))
            CALL MSG_SETI ('DIM2', DIM(2))
            CALL MSG_SETI ('DIM3', DIM(3))
            CALL MSG_SETC ('TASK', TSKNAME)
            CALL ERR_REP (' ', '^TASK: main data '//
     :           'array has bad dimensions - (^NDIM) ^DIM1 ^DIM2 '//
     :           '^DIM3', STATUS)

         END IF

*     The 3rd dimension is the number of integrations
*     in the case of noise data
         N_INTEGRATIONS = DIM ( 3 )

      END IF

*     Now need to open the output file -- propagate from the
*     input file so that the extensions are automatically copied
*     across

*     Now create a section of the input data so that we can
*     copy only the necessary size

      NDIM = 2
      LBND(1) = 1
      LBND(2) = 1
      UBND(1) = N_BOLS
      UBND(2) = 2
      CALL NDF_SECT(IN_NDF, NDIM, LBND, UBND, SECNDF, STATUS)

*     Generate a default output filename
*     Takes the form of 'o'//RUN_NUMBER

      OUTFILE = 'o'
      CALL CHR_ITOC( RUN_NUMBER, STEMP, ITEMP)
      ITEMP = 1
      CALL CHR_APPND( STEMP, OUTFILE, ITEMP)

      CALL PAR_DEF0C('OUT', OUTFILE, STATUS)
      

*     Propogate the section to the output

      IF (STATUS .EQ. SAI__OK) THEN
         USENDF = .TRUE.
         CALL NDF_PROP (SECNDF, 'NOEXTENSION(SCUCD)', 'OUT', OUT_NDF, 
     :        STATUS)

*     Allow for the possibility that an output NDF is not required
*     Check for NULL status
         IF (STATUS .EQ. PAR__NULL) THEN
            USENDF = .FALSE.
            CALL ERR_ANNUL(STATUS)
         END IF
      END IF

*     Annull the section
      CALL NDF_ANNUL(SECNDF, STATUS)

*     create a history component in the output file

      IF (USENDF) CALL NDF_HCRE (OUT_NDF, STATUS)

*     Now we need to map the input and output data arrays

*     Map the input array
      CALL NDF_MAP (IN_NDF, 'DATA', '_REAL', 'READ', IN_DATA_PTR,
     :     ITEMP, STATUS)

*     Map the output array if we are using an NDF. Else we have
*     to malloc some memory

      IF (USENDF) THEN
         CALL NDF_MAP (OUT_NDF, 'QUALITY', '_UBYTE', 'WRITE',
     :        OUT_QUALITY_PTR, ITEMP, STATUS)
         CALL NDF_MAP (OUT_NDF, 'DATA', '_REAL', 'WRITE',
     :        OUT_DATA_PTR, ITEMP, STATUS)
         CALL NDF_MAP (OUT_NDF, 'VARIANCE', '_REAL', 'WRITE',
     :        OUT_VARIANCE_PTR, ITEMP, STATUS)
      ELSE
         OUT_DATA_PTR = 0
         OUT_DATA_END = 0
         OUT_VARIANCE_PTR = 0
         OUT_VARIANCE_END = 0
         OUT_QUALITY_PTR = 0
         OUT_QUALITY_END = 0
         CALL SCULIB_MALLOC(N_BOLS * 2 * VAL__NBR,
     :        OUT_DATA_PTR, OUT_DATA_END, STATUS)
         CALL SCULIB_MALLOC(N_BOLS * 2 * VAL__NBR,
     :        OUT_VARIANCE_PTR, OUT_VARIANCE_END, STATUS)
         CALL SCULIB_MALLOC(N_BOLS * 2 * VAL__NBUB,
     :        OUT_QUALITY_PTR, OUT_QUALITY_END, STATUS)
      END IF

*     Now we just have to average the data using the
*     SCULIB_NOISE_MEAN routine

*     Create some scratch space for the averaging routine
*     Easier to create here rather than inside SCULIB_NOISE_MEAN
      SCRATCH_PTR = 0
      SCRATCH_END = 0

      CALL SCULIB_MALLOC(N_BOLS * VAL__NBI, SCRATCH_PTR,
     :     SCRATCH_END, STATUS)

*     Note how we use %VAL to step forwards from the Chop
*     signal to the calibrator signal.

      CALL SCULIB_NOISE_MEAN( N_INTEGRATIONS, N_BOLS,
     :     %VAL(CNF_PVAL(IN_DATA_PTR)),
     :     %VAL(CNF_PVAL(OUT_DATA_PTR)), 
     :     %VAL(CNF_PVAL(OUT_VARIANCE_PTR)),
     :     %VAL(CNF_PVAL(OUT_DATA_PTR) + (N_BOLS * VAL__NBR)),
     :     %VAL(CNF_PVAL(OUT_VARIANCE_PTR) + (N_BOLS * VAL__NBR)),
     :     %VAL(CNF_PVAL(OUT_QUALITY_PTR)), %VAL(CNF_PVAL(SCRATCH_PTR)), 
     :     STATUS)

*     Free the scratch space
      CALL SCULIB_FREE('SCRATCH', SCRATCH_PTR, SCRATCH_END, STATUS)

*     Now need to divide by the preamp gain and multiply by 10^9
*     in order to give results in nV at  the input to the preamps

      IF (STATUS .EQ. SAI__OK) THEN

         CALL SCULIB_MULCAR(2*N_BOLS, %VAL(CNF_PVAL(OUT_DATA_PTR)),
     :        1.0E9 / AMP_GAIN, %VAL(CNF_PVAL(OUT_DATA_PTR)))
         CALL SCULIB_MULCAR(2*N_BOLS, %VAL(CNF_PVAL(OUT_VARIANCE_PTR)),
     :        1.0E18 / AMP_GAIN**2, %VAL(CNF_PVAL(OUT_VARIANCE_PTR)))

      END IF

*     We now have to copy the Quality values from the start
*     of the array (chop quality) to the end of the array
*     (calibrator quality)

      CALL VEC_UBTOUB(.FALSE., N_BOLS, %VAL(CNF_PVAL(OUT_QUALITY_PTR)),
     :     %VAL(CNF_PVAL(OUT_QUALITY_PTR) + (N_BOLS * VAL__NBUB)),
     :     IERR, NERR, STATUS)


      IF (STATUS .EQ. SAI__OK) THEN

*     Calculate the default file name
*     Should be noise_YYMMDD_nr.dat

*     Start constructing string
         STEMP = 'noise_'
         IPOSN = 6

*     First read and decode UTDATE using code copied from sculib_get_mjd
            CALL SCULIB_GET_FITS_C (SCUBA__MAX_FITS, N_FITS, FITS,
     :           'UTDATE', UTDATE, STATUS)

*     Year (2 digit)
         ISTART = 1
         IEND = INDEX (UTDATE,':')
         IEND = MAX (ISTART,IEND)

*     IY is then  IEND-2:IEND-1 - append to STEMP
         CALL CHR_APPND(UTDATE(IEND-2:IEND-1), STEMP, IPOSN)

*     Append month
         UTDATE (IEND:IEND) = ' '
         ISTART = IEND + 1
         IEND = INDEX (UTDATE,':')
         IEND = MAX (ISTART,IEND)

*     Must pad with a zero if ISTART to IEND-1 is 1
         IF (IEND-ISTART .EQ. 1) CALL CHR_APPND('0', STEMP, IPOSN)

         CALL CHR_APPND(UTDATE(ISTART:IEND-1), STEMP, IPOSN)

*     Append day
         UTDATE (IEND:IEND) = ' '
         ISTART = IEND + 1
         IEND = MAX (ISTART,CHR_LEN(UTDATE))

*     Pad day if too small
         IF (ISTART-IEND .EQ. 0) CALL CHR_APPND('0', STEMP, IPOSN)

         CALL CHR_APPND(UTDATE(ISTART:IEND), STEMP, IPOSN)

*     Append the '_'
         CALL CHR_APPND('_', STEMP, IPOSN)

*     Convert the run number to a string and append
         CALL CHR_ITOC(RUN_NUMBER, STEMP(IPOSN+1:), ITEMP)
         IPOSN = CHR_LEN(STEMP)

         CALL CHR_APPND('.dat', STEMP, IPOSN)

         CALL PAR_DEF0C('FILE',STEMP, STATUS)

*     Now we need to write the text file if required
         CALL FIO_ASSOC ('FILE', 'WRITE', 'LIST', 0, FD, STATUS)

*     If we have a NULL status then we assume this means they
*     dont want a file to be written

         IF (STATUS .EQ. PAR__NULL) THEN
            CALL ERR_ANNUL(STATUS)
         ELSE

*     Gather the necessary information from the FITS header
            CALL SCULIB_GET_FITS_C (SCUBA__MAX_FITS, N_FITS, FITS, 
     :           'UTSTART', UTSTART, STATUS)
            CALL SCULIB_GET_FITS_C (SCUBA__MAX_FITS, N_FITS, FITS, 
     :           'OBSDEF', ODF_NAME, STATUS)
            CALL SCULIB_GET_FITS_C (SCUBA__MAX_FITS, N_FITS, FITS, 
     :           'BOLOMS', BOLOMS, STATUS)
            CALL SCULIB_GET_FITS_C (SCUBA__MAX_FITS, N_FITS, FITS, 
     :           'OBJ_TYPE', OBJ_TYPE, STATUS)
            CALL SCULIB_GET_FITS_I (SCUBA__MAX_FITS, N_FITS, FITS,
     :           'SAM_TIME', SAM_TIME, STATUS)
            CALL SCULIB_GET_FITS_I (SCUBA__MAX_FITS, N_FITS, FITS,
     :           'PRE_DSCD', PRE_DISCARD, STATUS)
            CALL SCULIB_GET_FITS_I (SCUBA__MAX_FITS, N_FITS, FITS,
     :           'PST_DSCD', POST_DISCARD, STATUS)
            
*     Some early data does not have the JIG_DSCD keyword in the header
            IF (STATUS .EQ. SAI__OK) THEN
               CALL SCULIB_GET_FITS_I (SCUBA__MAX_FITS, N_FITS, FITS,
     :              'JIG_DSCD', JIGL_DISCARD, STATUS)
               IF (STATUS .NE. SAI__OK) THEN
                  JIGL_DISCARD = -1
                  CALL ERR_ANNUL(STATUS)
               END IF
            END IF

            CALL SCULIB_GET_FITS_R (SCUBA__MAX_FITS, N_FITS, FITS,
     :           'CHOP_LG', CHOP_LAG, STATUS)
            CALL SCULIB_GET_FITS_R (SCUBA__MAX_FITS, N_FITS, FITS,
     :           'CALIB_LG', CAL_LAG, STATUS)
            CALL SCULIB_GET_FITS_R (SCUBA__MAX_FITS, N_FITS, FITS,
     :           'CHOP_PD', CHOP_PERIOD, STATUS)
            CALL SCULIB_GET_FITS_R (SCUBA__MAX_FITS, N_FITS, FITS,
     :           'CALIB_PD', CAL_PERIOD, STATUS)
            CALL SCULIB_GET_FITS_C (SCUBA__MAX_FITS, N_FITS, FITS, 
     :           'CENT_CRD', CENTRE_COORDS, STATUS)
            CALL SCULIB_GET_FITS_C (SCUBA__MAX_FITS, N_FITS, FITS, 
     :           'CHOP_CRD', CHOP_COORDS, STATUS)
            CALL SCULIB_GET_FITS_C (SCUBA__MAX_FITS, N_FITS, FITS, 
     :           'LOCL_CRD', LOCAL_COORDS, STATUS)
            CALL SCULIB_GET_FITS_C (SCUBA__MAX_FITS, N_FITS, FITS, 
     :           'LAT', LAT, STATUS)
            CALL SCULIB_GET_FITS_C (SCUBA__MAX_FITS, N_FITS, FITS, 
     :           'LONG', LONG, STATUS)
            CALL SCULIB_GET_FITS_R (SCUBA__MAX_FITS, N_FITS, FITS,
     :           'CHOP_THR', CHOP_THROW, STATUS)
            CALL SCULIB_GET_FITS_R (SCUBA__MAX_FITS, N_FITS, FITS,
     :           'CHOP_PA', CHOP_PA, STATUS)


*     Write the file header

            LINE = '! Output from '//PACKAGE//
     :           ' reduction of a NOISE observation'
            CALL FIO_WRITE (FD, LINE, STATUS)

            LINE = '! Reduction date        : '
            CALL PSX_TIME (NTICKS, STATUS)
            CALL PSX_CTIME (NTICKS, LINE(25:), STATUS)
            CALL FIO_WRITE (FD, LINE, STATUS)

            LINE = 'Observation definition: '//ODF_NAME
            CALL FIO_WRITE (FD, LINE, STATUS)

            LINE = 'Date of observation   : '//UTDATE
            CALL FIO_WRITE (FD, LINE, STATUS)
            
            LINE = 'Time of observation   : '//UTSTART
            CALL FIO_WRITE (FD, LINE, STATUS)

            LINE = 'Run number            : '
            CALL CHR_ITOC (RUN_NUMBER, LINE(25:), ITEMP)
            CALL FIO_WRITE (FD, LINE, STATUS)

            LINE = 'Bolometers measured   : '//BOLOMS
            CALL FIO_WRITE (FD, LINE, STATUS)

            LINE = 'Source                : '//OBJ_TYPE
            CALL FIO_WRITE (FD, LINE, STATUS)

            LINE = 'Sample time           : '
            IPOSN = 25
            CALL CHR_ITOC(SAM_TIME, STEMP, ITEMP)
            CALL CHR_APPND(STEMP, LINE, IPOSN)
            CALL FIO_WRITE (FD, LINE, STATUS)

            LINE = 'Chop period           : '
            IPOSN = 25
            CALL CHR_RTOC(CHOP_PERIOD, STEMP, ITEMP)
            CALL CHR_APPND(STEMP, LINE, IPOSN)
            CALL FIO_WRITE (FD, LINE, STATUS)

            LINE = 'Calibrator period     : '
            IPOSN = 25
            CALL CHR_RTOC(CAL_PERIOD, STEMP, ITEMP)
            CALL CHR_APPND(STEMP, LINE, IPOSN)
            CALL FIO_WRITE (FD, LINE, STATUS)

            LINE = 'Jiggle discard        : '
            IPOSN = 25
            CALL CHR_ITOC(JIGL_DISCARD, STEMP, ITEMP)
            CALL CHR_APPND(STEMP, LINE, IPOSN)
            CALL FIO_WRITE (FD, LINE, STATUS)

            LINE = 'Pre-discard           : '
            IPOSN = 25
            CALL CHR_ITOC(PRE_DISCARD, STEMP, ITEMP)
            CALL CHR_APPND(STEMP, LINE, IPOSN)
            CALL FIO_WRITE (FD, LINE, STATUS)

            LINE = 'Post discard          : '
            IPOSN = 25
            CALL CHR_ITOC(POST_DISCARD, STEMP, ITEMP)
            CALL CHR_APPND(STEMP, LINE, IPOSN)
            CALL FIO_WRITE (FD, LINE, STATUS)

            LINE = 'Chop lag              : '
            IPOSN = 25
            CALL CHR_RTOC(CHOP_LAG, STEMP, ITEMP)
            CALL CHR_APPND(STEMP, LINE, IPOSN)
            CALL FIO_WRITE (FD, LINE, STATUS)

            LINE = 'Calibrator lag        : '
            IPOSN = 25
            CALL CHR_RTOC(CAL_LAG, STEMP, ITEMP)
            CALL CHR_APPND(STEMP, LINE, IPOSN)
            CALL FIO_WRITE (FD, LINE, STATUS)

            LINE = 'Centre coords         : '//CENTRE_COORDS
            CALL FIO_WRITE (FD, LINE, STATUS)
            LINE = 'Local coords          : '//LOCAL_COORDS
            CALL FIO_WRITE (FD, LINE, STATUS)
            LINE = 'Longitude             : '//LONG
            CALL FIO_WRITE (FD, LINE, STATUS)
            LINE = 'Latitude              : '//LAT
            CALL FIO_WRITE (FD, LINE, STATUS)

            LINE = 'Chop coords           : '//CHOP_COORDS
            CALL FIO_WRITE (FD, LINE, STATUS)

            LINE = 'Chop throw            : '
            IPOSN = 25
            CALL CHR_RTOC(CHOP_THROW, STEMP, ITEMP)
            CALL CHR_APPND(STEMP, LINE, IPOSN)
            CALL FIO_WRITE (FD, LINE, STATUS)

            LINE = 'Chop PA               : '
            IPOSN = 25
            CALL CHR_RTOC(CHOP_PA, STEMP, ITEMP)
            CALL CHR_APPND(STEMP, LINE, IPOSN)
            CALL FIO_WRITE (FD, LINE, STATUS)

            LINE = ' '
            CALL FIO_WRITE (FD, LINE, STATUS)
            LINE = 'Note that the quoted errors are errors on the '//
     :           'mean.'
            CALL FIO_WRITE (FD, LINE, STATUS)

            LINE = ' '
            CALL FIO_WRITE (FD, LINE, STATUS)

            LINE = 'Channel       Chop(nV)   Error(nV)     Cal(nV)'//
     :           '   Error(nV)  Quality'
            CALL FIO_WRITE (FD, LINE, STATUS)

*     Write some data

            DO I = 1, N_BOLS
               CALL SCULIB_BOLNAME (BOL_ADC(I), BOL_CHAN(I),
     :              BOLNAME, STATUS)
    
*     Copy the data out of the 'pointer'
               CALL VEC_RTOR(.FALSE., 1,
     :              %VAL(CNF_PVAL(OUT_DATA_PTR) + (I-1) * VAL__NBR ),
     :              CHOP_DATA, IERR, NERR, STATUS)
               CALL VEC_RTOR(.FALSE., 1,
     :   %VAL(CNF_PVAL(OUT_VARIANCE_PTR) + (I-1) * VAL__NBR ),
     :              CHOP_VARIANCE, IERR, NERR, STATUS)
               CALL VEC_RTOR(.FALSE., 1,
     :   %VAL(CNF_PVAL(OUT_DATA_PTR) + (N_BOLS + I-1) * VAL__NBR ),
     :              CAL_DATA, IERR, NERR, STATUS)
               CALL VEC_RTOR(.FALSE., 1,
     :   %VAL(CNF_PVAL(OUT_VARIANCE_PTR) + (N_BOLS + I-1) * VAL__NBR ),
     :              CAL_VARIANCE, IERR, NERR, STATUS)
               CALL VEC_UBTOI(.TRUE., 1,
     :   %VAL(CNF_PVAL(OUT_QUALITY_PTR) + (I-1) * VAL__NBUB ),
     :              DEMOD_QUALITY, IERR, NERR, STATUS)


               WRITE (LINE, 10) BOLNAME, CHOP_DATA, 
     :              SQRT(MAX(0.0,CHOP_VARIANCE)),
     :              CAL_DATA, SQRT(MAX(0.0,CAL_VARIANCE)),DEMOD_QUALITY
               CALL FIO_WRITE (FD, LINE, STATUS)

            END DO

 10         FORMAT (A6, 4F12.2, I12)

*     Close file
            CALL FIO_CLOSE ( FD, STATUS )

         END IF

      END IF

*     Unmap data files
      CALL NDF_UNMAP(IN_NDF, '*', STATUS)
      CALL NDF_ANNUL(IN_NDF, STATUS)

      IF (USENDF) THEN 

*     Add the units
         CALL NDF_CPUT('nV',OUT_NDF, 'UNITS', STATUS)
         CALL NDF_CPUT('Signal',OUT_NDF, 'LABEL', STATUS)
         CALL NDF_CPUT('Demodulated noise',OUT_NDF, 'TITLE', STATUS)
         CALL NDF_ACPUT('Bolometers', OUT_NDF, 'LABEL', 1, STATUS)

*     Unmap the data and close the file
         CALL NDF_UNMAP(OUT_NDF, '*', STATUS)
         CALL NDF_ANNUL(OUT_NDF, STATUS)
      ELSE
         CALL SCULIB_FREE('OUTDATA', OUT_DATA_PTR, OUT_DATA_END,
     :        STATUS)
         CALL SCULIB_FREE('OUTDATA', OUT_VARIANCE_PTR, OUT_VARIANCE_END,
     :        STATUS)
         CALL SCULIB_FREE('OUTDATA', OUT_QUALITY_PTR, OUT_QUALITY_END,
     :        STATUS)
      END IF

*     Shut down NDF
      CALL NDF_END( STATUS )

      END
