#!/bin/sh
#+
#  Name:
#     htxserver

#  Type of Module:
#     CGI compliant shell script.

#  Invocation:
#     By CGI compliant HTTP server.

#  Description:
#     This is a CGI script for serving hypertext documents that have index
#     files generated by the HTX "hlink" hypertext linker command. It is used
#     when accessing such documents from remote sites, as local access to
#     linked documents can be done directly and does not need to go via a
#     server.
#
#     The purpose of using this script is, roughly, to perform the resolution
#     of document cross-references in the same way as "hlink" does (i.e. by
#     looking up cross-reference labels in an index file to identify which
#     part of a multi-page document is required). In this case, the lookup is
#     performed in real time when the cross-reference is actually followed.
#
#     If this script succeeds in resolving the cross-reference, it returns a
#     URL which the client can then use to access the required part of the
#     document. If it fails, it returns an HTML document containing information
#     about why it failed. This may also contain links to other parts of the
#     document which could still be useful to the remote user.
#
#     Documents are searched for in a series of directories identifid by the
#     HTX_LOCATIONS variable (see the "Installation and Configuration"
#     section). Each set of ".html" files comprising a hypertext document
#     should reside in their own directory (within one of the directories
#     above) with a name of the form:
#
#        docname.htx
#
#     and should be accompanied by the "docname.index" file, as generated by
#     "hlink".
#
#     If the required hypertext ".htx" document cannot be found in any of the
#     locations specified, this script will then examine the contents of the
#     HTX catalogue file (if any) in each location to see if the document is
#     available in non-hypertext form (see SUN/188 for a description of HTX
#     catalogue files). If found, the URL of the document file (as listed in
#     the HTX catalogue file) is returned. This approach assumes that the
#     client has access to an appropriate document viewer for the file in
#     question.

#  Installation and Configuration:
#     This script should be installed with appropriate protections in the
#     directory that holds your HTTP server's CGI scripts. Note that it will
#     also execute scripts that form part of the standard HTX installation, so
#     these must be available with appropriate protections, and should also be
#     secure (see below).
#
#     This script may require editing to configure it for your system, as
#     follows:
#
STARLINK='/star'
#        Edit and un-comment the line above to define the directory under which
#        your HTX installation resides (normally this will be the directory
#        where you have installed the rest of your Starlink software). This
#        script will execute HTX scripts which it finds in the directory:
#
#           $STARLINK/bin/htx-scripts
#
#        In the interests of security, this directory and all directories
#        above it should only be writable by trusted individuals. The default
#        value used is:
#
#           "/star"
#
#        if you do not specify STARLINK explicitly above.
#
HTX_LOCATIONS='star/docs=/star/docs:star/help=/star/help'
#        Edit and un-comment the line above to define a colon-separated list
#        of locations to search for the documents to be served, of the form:
#     
#           "loc=dir:loc=dir:loc=dir"
#
#        where "loc" is the location of a directory containing documents, as
#        known to your HTTP server (i.e. given relative to the server's
#        document root directory or using a pre-defined server alias) and "dir"
#        is the true file system path of the directory. All the directories
#        used, and the documents they contain, must be readable by the server
#        and may have to reside in specific locations, depending on how your
#        server is configured. The default value used is:
#
#           "star/docs=/star/docs:star/help=/star/help"
#
#        if you do not specify HTX_LOCATIONS explicitly above.
#
#     HTX_SUPPORT=''
#        Edit and un-comment the line above to contain text (which may include
#        HTML constructs) which identifies the person to contact for help with
#        problems originating with this script or the documents it serves. This
#        will appear at the end of any error messages sent to the client. The
#        default behaviour is to omit this information if you do not specify
#        HTX_SUPPORT explicitly above (unless this script is running on the
#        Starlink WWW server at RAL, in which case a suitable default is
#        supplied).
#
#     echo 'Content-type: text/plain'
#     echo
#        Un-comment the previous two lines to receive debugging information
#        at the client side.
#
#     No edits apart from those above should normally be needed.

#  Input:
#     The script uses the standard CGI environment variables for input. The
#     following have particular significance:
#
#     PATH_INFO
#        Will contain the virtual document path as extracted from the URL
#        by the HTTP server. This script expects it to be of the form:
#
#           /xxx/docname.htx/yyy.html
#
#        where "/xxx" may be any directory path (including a null path) and
#        "yyy.html" may be any path to an ".html" file, which need not
#        necessarily exist (this may also be null).
#     QUERY_STRING
#        This should contain the optional label part of the cross-reference
#        and this script expects it to have the form:
#
#           xref_label
#
#        If the label is absent, then QUERY_STRING may either be blank or set
#        to "xref_".
#
#     Note that these requirements mean that the URL passed to the HTTP server
#     running this script should normally be of the form:
#
#        <script_url>/xxx/docname.htx/yyy.html?xref_label
#
#     where <script_url> locates this CGI script and "/xxx", "yyy.html" and
#     "label" (or "xref_label") are optional.

#  Examples:
#     A typical URL that could be used to follow a cross-reference to a
#     remote document using this script might look like:
#
#        http://www.stalink.ac.uk/cgi-bin
#                       /htxserver/sun109.htx/node33.html?xref_appendix
#
#     (this is broken across two lines for clarity and should all be one
#     string). If successful, the script would return a "Location: URL" string
#     that allows the client to access that part of document "sun109" that
#     is identified by the "appendix" cross-reference label.

#  Copyright:
#     Copyright (C) 1995, The Central Laboratory of the Research Councils.

#  Authors:
#     PDRAPER: Peter Draper (Starink, Durham University)
#     RFWS: R.F. Warren-Smith (Starlink, RAL)
#     {enter_new_authors_here}

#  History:
#     9-MAR-1995 (PDRAPER):
#        Original version.
#     27-APR-1995 (RFWS):
#        Greatly revised to include HTML diagnostics and to use the same style
#        as other HTX scripts. Also extended to use a search path for documents
#        and to look harder for substitute files if the cross-reference cannot
#        be properly resolved.
#     28-APR-1995 (RFWS):
#        Added the HTX_LOCATIONS method of identifying document locations and
#        HTX_DOCTYPES for specifying alternative document types.
#     11-MAY-1995 (RFWS):
#        Set configuration variables for use as the main HTX server at RAL.
#     11-JUL-1995 (RFWS):
#        Set new default configuration for use at RAL.
#     24-NOV-1995 (RFWS):
#        Changed to use new index files by depending on standard HTX scripts.
#        Also introduced the use of catalogue files and simplified the error
#        reporting. Added link to SUN/188 in error messages.
#     {enter_further_changes_here}

#  Bugs:
#     {note_any_bugs_here}

#-

#.

#  Initialisation.
#  --------------
#  Check that PATH_INFO is defined. If not, then exit.
      if test "${PATH_INFO}" = ""; then
         echo >&2 "This routine may only be run as a CGI script."
         exit 1
      fi

#  Set the positional parameters to the list of document locations to be
#  searched.
      if test -n "${HTX_LOCATIONS}"; then
         IFS=':'
         set ${HTX_LOCATIONS}
      else
         set 'star/docs=/star/docs' 'star/help=/star/help'
      fi
      IFS=' '

#  If no support person has been specified and this script is running on the
#  Starlink WWW server at RAL, then provide a suitable default.
      if test ! -n "${HTX_SUPPORT}"; then
         if test "${SERVER_NAME}${SCRIPT_NAME}" = \
                 "www.starlink.rl.ac.uk/cgi-bin/htxserver"; then
            HTX_SUPPORT='Starlink Software Support
(<A HREF="mailto:ussc@star.rl.ac.uk">ussc@star.rl.ac.uk</A>)'
         fi
      fi

#  Set up the URL prefix that identifies the current HTTP server.
      if test "${SERVER_PORT}" = "80"; then
         server_url="http://${SERVER_NAME}"
      else
         server_url="http://${SERVER_NAME}:${SERVER_PORT}"
      fi

#  Set up the default location to search for STARLINK software.
      STARLINK="${STARLINK:-/star}"

#  Define an environment variable to be used to locate HTX scripts.
      HTX_DIR="${STARLINK}/bin/htx-scripts"
      export HTX_DIR

#  Obtain the search criteria.
#  --------------------------
#  Extract the document name from $PATH_INFO by looking for a field like
#  "/docname.htx/". Check that a document name has been given.
      docname="`expr "X${PATH_INFO}" : 'X.*/\([^/]*\)\.htx/.*$'`"
      if test -n "${docname}"; then

#  Extract the label name (if any) from $QUERY_STRING, removing the "xref_"
#  prefix. Do not accept a label without this prefix.
         label="`expr "X${QUERY_STRING}" : 'Xxref_\(.*\)$'`"

#  Search for the document in hypertext form.
#  -----------------------------------------
#  Set an environment variable (used by "urlgen") to specify that only local
#  documents are to be found.
         HTX_WHERE='l'
         export HTX_WHERE

#  Loop to search each possible document location.
         for loc do

#  From each location extract the name of the directory as known to the HTTP
#  server and add the server URL as a prefix to generate the URL of the
#  directory.
            dir_url="${server_url}/`expr "X${loc}" : 'X\([^=]*\)=.*$'`"

#  Also extract the true file system directory name.
            dir="`expr "X${loc}" : 'X[^=]*=\(.*\)$'`"

#  Use "urlgen" to search for the document and label in this directory,
#  returning a local file reference. Set the file reference to "-" if "urlgen"
#  fails because the label is not found in the document.
            fileref="`${HTX_DIR}/urlgen "${dir}/${docname}" "${label}" \
                      2>/dev/null || echo '-'`"

#  Note if the label was bad and try to locate the "top" page of the document
#  instead (if different).
            if test "${fileref}" = '-'; then
               badlabel='1'
               fileref=''
               if test -n "${label}"; then
                  fileref="`${HTX_DIR}/urlgen "${dir}/${docname}" 2>/dev/null`"
               fi
            fi

#  If a file reference was obtained, then change its directory name into the
#  URL of the directory as known to the HTTP server.
            if test -n "${fileref}"; then
               url="`echo "${fileref}" | \
                     sed -n 's%^file://localhost/%/%
                             s%^'"${dir}"/'%'"${dir_url}"'/%p'`"
               break
            fi
         done
      fi

#  Search the contents of catalogue files.
#  --------------------------------------
#  If no hypertext version of the document could be found, and this was not
#  due to a bad label, then loop to search the contents of the catalogue file
#  (if any) in each possible document location.
      if test ! -n "${url}" -a ! "${badlabel}" = '1'; then
         for loc do

#  As before, generate the directory URL and the directory name for each
#  location.
            dir_url="${server_url}/`expr "X${loc}" : 'X\([^=]*\)=.*$'`"
            dir="`expr "X${loc}" : 'X[^=]*=\(.*\)$'`"

#  Generate the catalogue file name and check if the file exists and is
#  readable.
            catfile="${dir}/htx.catalogue"
            if test -f "${catfile}" -a -r "${catfile}"; then

#  If so, search the file for an entry with the required document name. If
#  found, extract the associated file name field (and quit after the first
#  entry that matches).
               filename="`sed -n '/^'"${docname}"' /{
                                     s%^[^ ][^ ]*  *\([^ ][^ ]*\) .*$%\1%p
                                     q
                                  }' "${catfile}"`"

#  If a file name was found, and the file exists and is readable, then
#  generate a URL that will allow the HTTP server to find it. Then quit
#  searching.
               if test -n "${filename}" -a -r "${dir}/${filename}"; then
                  url="${dir_url}/${filename}"
                  break
               fi
            fi
         done
      fi

#  Output the document location.
#  ----------------------------
#  If the document reference was resolved and no bad label was encountered,
#  then return its URL. 
      if test -n "${url}" -a ! "${badlabel}" = '1'; then
         echo "Location: ${url}"
         echo

#  Classify errors and output error messages.
#  -----------------------------------------
#  Reconstruct the original cross-reference URL that was sent to the server.
      else
         if test "${QUERY_STRING}" = ""; then
            xref="${PATH_INFO}"
         else
            xref="${PATH_INFO}?${QUERY_STRING}"
         fi

#  Output the preliminary part of an HTML document that will contain the full
#  error message.
         cat <<END
Content-Type: text/html

<HTML>
<HEAD>
<TITLE>Error in Document Reference</TITLE>
</HEAD>
<BODY>
<H1>Error in Document Reference</H1>
<HR>
END

#  Classify the error condition and output the appropriate HTML text. All
#  possible combinations should be covered here (the error messages should be
#  self explanatory).
         if test ! -n "${docname}"; then
            cat <<END
The reference you followed was:
<BLOCKQUOTE>
${xref}
</BLOCKQUOTE>
This does not contain a document name field of the form:
<BLOCKQUOTE>
/docname.htx/
</BLOCKQUOTE>
so the document you wanted could not be identified. This probably
means that the reference in your original document or software is
invalid.
<P>
Please alert the author of your document or the maintainer of your
software to this problem.
END
         elif test "${badlabel}" = '1'; then
            cat <<END
The reference you followed requested a label called "${label}" in
document "${docname}". This label could not be found. This means
that the part of the document you wanted could not be identified.
<P>
You can view the top page of the document instead by following
<A HREF="${url}">this link</A>.
<P>
Please alert the author of your document or the maintainer of your
software to this problem.
END
         else
            cat <<END
The reference you followed requested a document called "${docname}".
This document could not be found. This probably means that the name
used in your document or software is invalid, or that it is referring
to the wrong remote document server.
<P>
Please alert the author of your document or the maintainer of your
documentation system or software to this problem.
END
         fi

#  Output the final text of the HTML document describing the error.
         cat <<END
<P>
For more information on labels, remote document servers, and how to refer
to them, please see
<A HREF="http://www.starlink.ac.uk/cgi-bin/htxserver/sun188.htx/sun188.htx/sun188.html?xref_">SUN/188</A>.
<HR>
<I>
This message was generated by the HTX document server at
${SERVER_NAME}${SCRIPT_NAME}.
END

#  Inclusion of the name of a support person is optional.
         if test -n "${HTX_SUPPORT}"; then
            cat <<END
Please report any problems with this server or the documents it serves to
${HTX_SUPPORT}.
END
         fi
         cat <<END
</I>
<HR>
</BODY>
</HTML>
END
      fi

#  End of script.
