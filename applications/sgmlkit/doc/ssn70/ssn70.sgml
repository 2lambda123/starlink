<!doctype ssn public "-//Starlink//DTD Starlink SSN 0.2//EN" [
  <!entity sgp28
	public "-//Starlink//DOCUMENT Summary SGP/28//EN" subdoc>
  <!entity sun199 
	public "-//Starlink//DOCUMENT Summary SUN/199//EN" subdoc>
  <!entity sgmlsystem.eps system 'SGMLsystem.eps' ndata eps>
  <!entity sgmlsystem.gif system 'SGMLsystem.gif' ndata gif87a>
  <!entity starlinkdtddoc system '../dtd2sgml/starlink-0.2.sgmltext'>
  <!entity programcodedtddoc system '../dtd2sgml/programcode-0.2.sgmltext'>
  <!entity % Feature.Routinelist 'include'>
  <!entity rsqbrack ']'>
]>
<!-- $Id$ -->

<title>The Starlink SGML system
<author email='norman@astro.gla.ac.uk'
	webpage='http://www.astro.gla.ac.uk/users/norman'
	affiliation='University of Glasgow'
	id=ng
	>Norman Gray

<docnumber>70

<history>
<version number=0 date='21-APR-1999' author=ng>Initial version
</history>

<copyright>
Copyright 1999, Particle Physics and Astronomy Research Council
</copyright>

<abstract>
This document describes the Starlink SGML system.  Blah

<px>Audience: 
This document is addressed both at those who need to generate Starlink
documentation of any kind, and at anyone maintaining the SGML system.
</abstract>

<sect id=intro export>Introduction

<p>The Starlink SGML system supports people writing Starlink documents,
such as SUNs, SSNs, MUDs and the like.  It consists of a definition of
a markup language suitable for such documents, plus software to
convert these source documents to reader-friendly form.  At present,
these `output formats' include HTML and &latex (and hence include
postscript and PDF formats).

<p>The SGML system scores over previous solutions to Starlink's
documentation needs, such as <code/runoff/ or &latex, because it is a
well-defined system, so that there is excellent support for it in
tools, and it is designed to be converted into whichever presentation
format is most convenient (see also the Frequently Asked Questions
<ref id=faq.html> and <ref id=faq.latex>).

<p>Although this system can help with many of the tasks involved in
document creation, it cannot write the document for you (shame!).  For
advice on that, documents such as <docxref doc=sgp28> are still vital.

<p>This document is organised as follows.  In <ref id=sgml>, I
discuss SGML in general terms, describing its general structure and
aims, describing how to read a Document Type Definition (DTD), and
pointing to sources of information.  In <ref id=markup>, I describe
how you would go about actually writing a document, describing the
structure of Starlink documents which is crystallised in the
specification of this system.  In <ref id=future>, I describe
some possible further improvements in the system (suggestions and
comments are most welcome).  Finally, in <ref id=faq>, I
answer (I hope) some frequently asked questions about SGML in general
and this system in particular.

<sect id=sgml export>SGML Overview

<p>This section introduces you to SGML, and explains its advantages
over other approaches to document preparation.

<subsect id=why.sgml export>Why SGML?

<p>The problem SGML tries to solve is that humans are good at
intuiting structure from layout, but computers are exceedingly bad at
it.  This means that if we want computers to help us with documents --
displaying them, transforming them, storing them, searching them -- we
have to give the computer some help.  

<p>A common way of providing this
help is through markup systems such as <code/runoff/ (or its
variants), or &tex, or &latex;.  The last of these three has served
Starlink very well, and even survived the conversion of Starlink's
document set to hypertext, through the tool <code/Star2HTML/ (see <docxref
doc=sun199>), but the problems of the &latex system illustrate the
advantages of the SGML approach quite well.
<dl>
<dt>LaTeX templates are ill-defined
<!-- Have this as `LaTeX' rather than &latex: the `latex' back-end -->
<!-- messes up SDATA references within (data nd), which is bad, since -->
<!-- latex/slmisc.dsl turns <dt> into \item[blah] using (data ...). -->
<dd>What is a Starlink document?  Although Starlink distributes
templates for the principal document types (for example in
<code>/star/docs/sun.tex</code>), and distributes style guides such as
<docxref doc=sgp28>, there is no way either of mandating that certain
elements, such as a document number, actually appear, nor of ensuring
that other features, such as raw &tex, do not.  This means that
document authors can never quite be sure that they have produced a
`correct' document; that, since the effective definition of `correct' is
`processable by this tool', there is no guarantee that a document
which is correct at one time will continue to be so; and that tools
which search or process such 
documents have to have contingency strategies available, when the
elements they hope to use are missing.

<dt>The conversion is a hack!
<dd>Because the input documents are not well-defined, the tools which
process them cannot be designed against any standard, but instead have
to rely on heuristics and uncheckable conventions.  &latex documents
are defined to work with one particular tool -- the &tex tokeniser and
parser -- so that using
them with any other tool (which is necessary if you want to produce
anything other than DVI files<note>In fact, there is a version of &tex;
which produces PDF files directly, and a &tex;-to-HTML converter
called <webref url="http://www.tug.org/applications/tex4ht/mn.html"
>TeX4ht</webref> which writes special DVI files which work with a
postprocessor, and so uses the &tex parser to produce HTML
indirectly.  This really just pushes the hack elsewhere.</note>) is
asking for trouble.

<dt>Users have to know too much.
<dd>When you are writing a <code/Star2HTML/ document, you are
riding two horses at once; you must write in that subset of &latex
which <code/Star2HTML/ knows about.  Users must frequently be
sensitive to the treatment of their document by two separate systems.

<dt>Not future-proof
<dd>&latex is not precisely defined; on the contrary, it is
continually being developed, and a completely new version, <webref
url="http://www.oasis-open.org/cover/latex3-9804.html" >&latex;3</webref> is
eagerly anticipated (which will, incidentally, be heavily influenced
by SGML).  Similarly, the <code/LaTeX2HTML/ package is continually
being upgraded, causing a <code/Star2HTML/ (based on
<code/LaTeX2HTML/) maintenance headache.
</dl>

<p>None of these problems is fatal -- all of them have manifestly been
overcome by the authors and maintainers of the current document set --
but taken together they make the maintenance of the document set more
expensive in time than there is time to spare.

<p>SGML addresses these problems effectively.
<dl>
<dt>SGML documents are well-defined
<dd>The structure of an SGML document is formally specified in the
Document Type Definition (DTD) associated with it.  This specifies
what features must, which may, and which may not, be present in a
document.  This means that systems processing the document need work
only within a much smaller universe of possibilities.

<dt>Future-proof
<dd>SGML has had only two backward-compatible amendments since 1986;
it's not dependent on any particular tool; SGML is designed to be used
decades hence; a sufficient number of
hangarfuls of technical documentation have been produced using SGML
that if and when a replacement comes along, it will have good support.

</dl>

<subsect id=what.sgml export>What is SGML?

<p>SGML is a metalanguage: that is, a language for writing languages
in.

<p>This is not actually as arcane as it sounds.  It simply means that
you use SGML to define the abstract structure of a document type (the
Document Type Definition, or DTD), so
that any documents which claim to be of that type must have a certain
syntactic structure.

<p>HTML is a well known example of an SGML DTD, whose rules are well
known.  An HTML document consists of precisely one <code/head/ and one
<code/body/ element.  The <code/head/ must have precisely one
<code/title/ element, and may have zero or more <code/link/ elements.
The <code/title/ element has simple characters as content.  The
<code/link/ element has no content, but has four optional
attributes&ellip, and so on.

<p>Given a document marked up in some specific DTD it will be parsed
by some tool which reads first the DTD then the document, and then
creates some abstract representation of the document which it passes
to a formatter, which in turn produces output in some form which may,
of course, be further processed to a final document.  The SGML parser
and whichever editor you use are both quite generic, but the formatter
is tied to a particular DTD.  There is a diagram of this system in
<ref id=fig.sgml>.
<figure id=fig.sgml float>
<caption>An SGML system
<figurecontent
	image="sgmlsystem.eps sgmlsystem.gif"
	alt="An SGML system">
</figure>

<p>For further information on SGML, see <ref id=appx.sgml>.  For other
texts, see the well-known
<cite>Gentle Introduction to SGML</cite><citation/gentle/.
For more detailed information,
see the useful but compressed <citation/bradley/; and for an
authoritative account see 
<citation/goldfarb/, which is an exegesis of the standard,
<citation/iso8879/. 

<sect id=markup export>Marking up your document

<subsect id=markup.intro export>Sample document, and overview

<p>A sample SUN is illustrated in <ref id=fig.simplesun>.
<figure id=fig.simplesun export float>
<caption>A simple sample SUN
<figurecontent alt="Simple SUN document">
<verbatim><![ cdata [
<!doctype sun public "-//Starlink//DTD Starlink SUN//EN">
<title>The Starlink SGML system
<author email='norman@astro.gla.ac.uk'
	webpage='http://www.astro.gla.ac.uk/users/norman'
	affiliation='University of Glasgow'
	id=ng
	>Norman Gray
<docnumber>1234
<history>
  <version number=0 date='21-APR-1999'>Initial version
</history>
<abstract>
  This is a sample SUN
</abstract>

<sect id=intro export>Introduction
<p>Starlink SUNs are easy to write.
]]></verbatim>
</figurecontent>
</figure>
<p>Features to note:
<ul>
<li>The document starts off with a `document type declaration',
<code>&lt;!doctype sun public &quot;-//Starlink//DTD Starlink
SUN//EN&quot;></code>, which states which DTD this document claims to be
conformant to, in this case the Starlink SUN document type.

<li>The document is structured in terms of `elements' such as
<code/author/ or <code/sect/, and these in turn contain further data,
such as a sequence of characters (`Norman Gray') in the case of the
<code/author/ element, or further elements (the <code/version/ element)
in the case of the <code/history/ element.  Elements are delimited by
`opening tags' like <code>&lt;abstract&gt;</code> and `closing tags'
like <code>&lt;/abstract&gt;</code>.

<li>Elements have both <em/content/ and <em/attributes/.  For example,
the <code/author/ element has the characters `Norman Gray' as its
content and a list of strings such as an email address as its
attributes.

<li>Some of the elements (the <code/abstract/ element for example)
are closed (ie, have closing tags to match their opening tags), but
the majority are not.  This is because the DTD tells 
the parser that a <code/title/ element cannot contain an <code/author/
element, so the appearance of the latter implicitly finishes the
former.

<li>Some elements and attributes are required, others optional.  This
document is close to being a minimal SUN.  It is not quite minimal
because the <code/copyright/ element is optional, and it turns out
that the only <em/required/ content of a document 
body is the abstract!  Also, the only required attribute of the
<code/author/ element is the <code/id/ attribute.

<li>There are actually more elements present here than are apparent to
the eye.  As well as allowing some closing tags to be omitted, a DTD
can be allow certain <em/opening/ tags to be omitted, too.  In fact,
the full structure of this document is as seen in <ref
id=fig.simplesun2>.
</ul>
<figure float id="fig.simplesun2" export>
<caption>A SUN document with all tags in place, the normalised version
of the document in <ref id=fig.simplesun>.
<figurecontent alt="Normalised SUN document">
<verbatim><![ cdata [
<SUN>
<DOCINFO>
<TITLE>The Starlink SGML system</TITLE>
<AUTHORLIST>
<AUTHOR EMAIL="norman@astro.gla.ac.uk" 
WEBPAGE="http://www.astro.gla.ac.uk/users/norman" 
AFFILIATION="University of Glasgow" 
ID="NG">Norman Gray</AUTHOR>
</AUTHORLIST>
<DOCNUMBER>1234</DOCNUMBER>
<HISTORY>
<VERSION NUMBER="0" DATE="21-APR-1999">
<PX>Initial version</PX>
</VERSION>
</HISTORY>
<COPYRIGHT>
<P>Copyright 1999, Particle Physics and Astronomy Research Council</P>
</COPYRIGHT>
</DOCINFO>
<DOCBODY>
<ABSTRACT>
<PX>This is a sample SUN</PX>
</ABSTRACT>
<SECT ID="INTRO" EXPORT>
<SUBHEAD>
<TITLE>Introduction</TITLE>
</SUBHEAD>
<P>Starlink SUNs are easy to write.</P>
</SECT>
</DOCBODY>
</SUN>
]]></verbatim>
</figurecontent>
</figure>

<p>In <ref id=fig.simplesun2>, note that the actual content of
the <code/abstract/ element is one or more <code/px/ elements (a
slightly restricted variant of the standard <code/p/ paragraph
element), and that the <code/sect/ element contains a <code/subhead/
element, and <em/contains/ the paragraphs which constitute it (note
that this is a significant difference from HTML, where the heading
elements <code/hn/ contain only a section title).  You will rarely
have to be aware of these `hidden' tags when you are creating a
document, but it will occasionally be
useful to know that these tags are there somewhere, and that you're
glad you don't have to type all of them.
In fact, when I explain the document structure below, I will do it in terms
of the elements which are `really' there.

<p>`Markup minimisation', which is SGML's name for this, was
introduced to SGML to make typing less onerous.  Personally, I like
this, since it seems to make the document look less cluttered, and so
I have designed the DTD to support this quite extensively.  The
minimisation is completely optional, however, and you may insert all
the tags if you prefer.  SGML-aware editors (see <ref id=editors>)
typically insert all tags.  See also <ref id=markup.min>.

<p>You can see from <ref id=fig.simplesun2> that the `top-level'
element of this document is <code/sun/.  The top-level element of SSN
documents is <code/ssn/, and similarly for the other Starlink document
types (see <ref id=str.structure>).  These different document types
are broadly the same, but the 
SSN document type does not include elements for documenting
programming code, and the MUD document type has a <code/docdate/
element instead of a <code/docnumber/ and a <code/history/.  The SUN
document type is the most general.  The top-level <code/sun/ element
has only two `children', <code/docinfo/, which contains the document
information such as its author, number, and so on, and <code/docbody/,
which contains the actual content of the document.

<subsect id=markup.entities export>Entity references

<p>Entity references are a mechanism for referring to characters, or
longer pieces of text, which you cannot type on your keyboard, which
must be escaped from the parser, or which you simply want to
abbreviate.

<p>A reference to an entity <code/amp/ is of the form
<code/&amp;amp;/.  It is prefixed by the character <code/&amp/ and
suffixed by a semicolon.

<p>The list of entities predefined by the Starlink general DTD is
given in <ref id=table.entities>.

<table id="table.entities">
<caption>Entities predefined in the Starlink general DTD.</caption>
<tgroup cols="3">
<thead>
<row><entry>Entity reference<entry>Replacement<entry>Description
<tbody>
<row><entry><code>&amp;copy;</code><entry>&copy<entry>Copyright symbol
<row><entry><code>&amp;amp;</code><entry><code>&amp</code><entry>ampersand
<row><entry><code>&amp;gt;</code><entry><code>&gt</code><entry>greater-than symbol
<row><entry><code>&amp;lt;</code><entry><code>&lt</code><entry>less-than symbol
<row><entry><code>&amp;quot;</code><entry>&quot<entry>quotation mark
<row><entry><code>&amp;nbsp;</code><entry>&nbsp<entry>non-breaking space
<row><entry><code>&amp;hash;</code><entry>&hash<entry>hash sign
<row><entry><code>&amp;pounds;</code><entry>&pounds<entry>pounds sign
<row><entry><code>&amp;dollar;</code><entry>&dollar<entry>dollar sign
<row><entry><code>&amp;ellip;</code><entry>&ellip<entry>ellipses
<row><entry><code>&amp;emdash;</code><entry>&emdash<entry>em dash
<row><entry><code>&amp;endash;</code><entry>&endash<entry>en dash
<row><entry><code>&amp;percent;</code><entry>&percent<entry>percent sign
<row><entry><code>&amp;deg;</code><entry>&deg<entry>degrees symbol
<row><entry><code>&amp;latex;</code><entry>&latex<entry>&latex logo
<row><entry><code>&amp;tex;</code><entry>&tex<entry>&tex logo
</row>
</tbody>
</tgroup>
</table>

<p>For more details on entities, see <ref id=sgml.entities>.

<subsect id=markup.dtdsubset export>Defining entities

<p>As explained in section <ref id=markup.entities>, there are a
number of predefined entities which you can refer to in your
documents.  These are defined either for general convenience or
because, as in the case of <code>&lt</code> and <code>&amp</code>,
because the characters are significant to the SGML parser.

<p>You can, however, define entities yourself, perhaps to save typing,
or to parameterise a fragment of text which might change.  Also, you
would have to define an entity to refer to other files, or to other
SGML documents.

<p>You define entities in a section of the document which rejoices in
the name of the `document type declaration subset'.  This is a
fragment of SGML markup which is presented within the
<code>&lt;!doctype></code> declaration, which is formally read before
the reading of the actual DTD the declaration refers to.  There are
many things you can do within the DTD subset, up to and including a
partial rewrite of the DTD (this is generally felt to be A Bad Thing
-- do try to resist the temptation), but the main function of the DTD
subset in normal documents is to define a variety of types of
entities.  For more details about the DTD subset, see <ref
id=sgml.dtdsubset>.

<subsubsect>Referring to text

<p>You can make an entity a shorthand for a piece of text which might
either need to be parameterised, or which it is simply inconvenient to
repeatedly retype.

<p>For example:

<verbatim><![cdata[
<!doctype sun public "-//Starlink//DTD Starlink SUN//EN" [
  <!entity urlroot "http://www.astro.gla.ac.uk/users/norman">
]>
[...]
<p>Here is a <webref url="&urlroot;/star/" >web page</webref>
]]></verbatim>
When the document is parsed, the text for the entity
<code>urlroot</code> is substituted for the entity reference
<code>&amp;urlroot;</code>.

<subsubsect id=markup.files>Referring to files

<p>A feature of SGML's portability is that it abstracts the notion of
files: there are no `files' and `filenames' in the SGML world, only
<em/external entities/ which have <em/public identifiers/ or <em/system
identifiers/.  You can refer to these external entities as follows:
<verbatim><![cdata[
<!doctype sun public "-//Starlink//DTD Starlink SUN//EN" [
  <!entity chapter1 system 'chaptext/chapter1.text'>
  <!entity fig1.eps system 'figure1.eps' ndata eps>
  <!entity fig1.gif system 'figure1.gif' ndata gif87a>
  <!entity sun199 
	public "-//Starlink//DOCUMENT Summary SUN/199//EN" subdoc>
]>
]]></verbatim>

<p>There are four entities described here.

<p>`chapter1' is a reference to the object with system
identifier <code>chaptext/chapter1.text</code>.  A system identifier
can refer to an object in a wide variety of ways -- it could be a
database query, or system command -- but in the present system, a
system identifier is just a filename.  When you refer to this entity
by making the reference <code/&amp;chapter1;/ where you might
otherwise type text, the SGML system would insert the contents of the
specified file in the document at that point.  This is a way of
breaking your document up into a collection of smaller documents.

<p>The two entities `fig1.eps' and `fig1.gif' are also references to
the two
files `figure1.eps' and `figure1.gif' -- note the distinction between
the entity name and the file name.  These
entity declarations have extra information, however, indicating that
their <em/notation/ is <code/eps/ and <code/gif87a/ respectively.  The
system currently recognises these notations, plus `jpeg'.  You would
refer to these entities in an attribute of a <code/figurecontent/
element (see <ref id=el.sun.figurecontent>).  For more details on how
to refer to figure files, see <ref id=str.figures>.

<p>The last entity is different in two ways.  Firstly, it does not refer
to a system identifier, but to a <em/public identifier/.  The SGML
system maps this identifier into a file using some internal database.
Note that the reference to the DTD, <code>"-//Starlink//DTD Starlink
SUN//EN"</code> is also a public identifier.  Secondly, the keyword
<code/subdoc/ indicates that this entity is a <em/subdocument/ entity
-- a complete SGML document which the SGML system will have to parse
at some point.  In this case, the entity <code/sun199/ has been
declared so that it can be cross-referenced at some point.  See <ref
id=str.xrefs> for details.

<subsect id=markup.min export>Markup minimisation

<p>SGML was designed to be readable by computers, but it was also
designed to be written by humans<note>This is unlike XML, which is
likely to be written largely by authoring programs</note>.  It
therefore has several features -- collectively referred to as
<em/markup minimisation/ -- designed to cut down the amount of
markup you have to write.

<p>The first such minimisation feature is tag omission: in certain
circumstances you may omit tags which are formally redundant.  This
can happen only when the SGML parser can reliably infer the presence
of the omitted tags, and when the DTD author has permitted this.  For
example, the content of the <ref id=el.sun.sect text='sect'>
element is a subhead element, followed by zero or more paragraphs (or
figures or tables), followed by zero or more subsect elements.  That
is, the sect element <em/contains/ the section, rather than containing
just the title (as is the case for HTML's <code/H1/ element, for
example).  The <ref id=el.sun.subhead text='subhead'> element
contains a <ref id=el.sun.title text='title'> element, which
finally contains the text of the section heading.  In other words, the
structure of a section is
<verbatim><![cdata[
<sect>
  <subhead>
    <title>Section 1</title>
  </subhead>
  <p>Paragraph text</p>
</sect>
<sect>
  ... <!-- and so on -->
]]></verbatim>
<p>This would be tedious to type.  However, the parser can infer the
end of the section and paragraph elements (from the start of the next
section and the end of the current section respectively), so those
closing tags can be omitted; and since the section
<em/must/ start with a subhead, which <em/must/ start with a title,
those tags are redundant, too.  That means that this can be compressed
to just
<verbatim><![cdata[
<sect>Section 1
<p>Paragraph text
<sect>
...
]]></verbatim>

<p>Many closing tags can be omitted, and a few opening tags, too
(apart from subhead, about the only other one is <ref
id=el.sun.px text='px'> since it is the only permissable content
of elements like <ref id=el.sun.abstract text='abstract'>).  If
you include tags redundantly it doesn't matter (and may even make the
text clearer in some cases), and if you omit them erroneously, the
SGML parser will quickly tell you.

<p>In cases where tags cannot be omitted, you can still cut down the
amount you have to type.  Instead of typing <code>&lt;em>emphasised
text&lt;/em></code>, you can type just <code>&lt;em/emphasised
text/</code>.<note>This much is a convenient shortcut. SGML defines
other tag minimisation locutions, so that
<code>&lt;p&lt;em/emph/&lt;/></code> is legal.  This rarely improves
readability, can get you into terrible messes, and is part of the
`parser hell' which XML was designed to avoid.  I mention it purely
for completeness.</note>

<p>SGML also has single-character entity references.  The character
<code><![cdata[~]]></code> in normal text turns into the entity
<code/&amp;nbsp;/, and <code><![cdata[--]]></code> (two hyphens) turns
into <code/&amp;endash;/.  Such `short reference' characters are used
a little more in the programcode DTD (see <ref id=doccode>).

<subsect id=markup.try export>Try it yourself -- running the SGML parser

<p>Type the document given in <ref id=fig.simplesun> into a file, and
check it with the distributed SGML parser, as follows.  If the
document is in a file <code/sun1234.sgml/, then give the command
<kbd>nsgmls -s sun1234.sgml</kbd>.  This invokes the <code/nsgmls/
parser, and, with the <code/-s/ option, suppresses all output except
warnings and error messages.  This means that for a valid document,
you should see precisely no output from this command.  If you want to
see output, leave off the <code/-s/ option and the parser will produce
a version of your document in a form which is easy for a downstream
application to parse.  There are, for example, Perl libraries (for
example <code/SGMLSpm/, which should be on CPAN) which
will parse this output format and allow you to process SGML documents
using Perl.  The crucial thing in this case is the final line in
the output, which should be a single `C' command, indicating that the
document conforms to its DTD.

<p>If you want to try normalising your document, give the command
<kbd>sgmlnorm sun1234.sgml</kbd>.  This transforms your document into
an equivalent one with all omitted elements reinserted.

<p>Finally, try converting your document to HTML.  This uses the
program Jade, which is an implementation of the DSSSL formatting
language.  Give the command 
<kbd>jade -t sgml -d
$STARLINK_SGML_DIR/dsssl/sl/html/sl.dsl#html sun1234.sgml</kbd>.  This
will parse your document, and convert it to a collection of HTML
files, with the master file named <code/SUN-1234.html/ (this name is based
on the information in the document, and is independent of what your
source file is actually called).  The command actually spits out a
line of text to the standard output; this is because the system is
designed to be used from within a Makefile (see <ref id=proc.makefile>) rather
than directly from the command line.

<p>You can also convert your document to &latex;, with the command 
<kbd>jade -t latex -d $STARLINK_SGML_DIR/dsssl/sl/latex/sl.dsl#latex
sun1234.sgml</kbd>.

<p>Try making parts of your document invalid, and comparing the error
with the error message <code/nsgmls/ produces.

<!-- FIXME : check that this is consistent with whatever I do to set up
     the paths and environment variables -->


<sect id=structure export>The structure of the document

<p>In this section I will describe all of the elements of the DTD,
grouping them by type.  There is an alternative description of the
elements, listed alphabetically, in <ref id=appx.general.dtd>.

<p>The elements are thematically grouped in <ref id=table.elements>.

<table id=table.elements>
<caption>
DTD elements, grouped by type.  Note that a few elements appear in more
than one group.
</caption>
<tgroup cols="2">
<thead><row><entry>Group<entry>Elements
<tbody>
<row>
<entry>
<ref id=str.structure>
<entry>
<ref id='el.sun.abstract' text='abstract'>,
<ref id='el.sun.appendices' text='appendices'>,
<ref id='el.sun.author' text='author'>,
<ref id='el.sun.authorlist' text='authorlist'>,
<ref id='el.sun.copyright' text='copyright'>,
<ref id='el.sun.docbody' text='docbody'>,
<ref id='el.sun.docinfo' text='docinfo'>,
<ref id='el.sun.docnumber' text='docnumber'>,
<ref id='el.sun.editors' text='editors'>,
<ref id='el.sun.keyword' text='keyword'>,
<ref id='el.sun.otherauthors' text='otherauthors'>,
<ref id='el.sun.sun' text='sun'>,
<ref id='el.sun.title' text='title'>

<row>
<entry>
<ref id=str.sect>
<entry>
<ref id='el.sun.sect' text='sect'>,
<ref id='el.sun.subhead' text='subhead'>,
<ref id='el.sun.subsect' text='subsect'>,
<ref id='el.sun.subsubsect' text='subsubsect'>,
<ref id='el.sun.subsubsubsect' text='subsubsubsect'>
<ref id='el.sun.title' text='title'>

<row>
<entry>
<ref id=str.backmatter>
<entry>
<ref id='el.sun.backmatter' text='backmatter'>,
<ref id='el.sun.bibliography' text='bibliography'>,
<ref id='el.sun.citation' text='citation'>,
<ref id='el.sun.index' text='index'>,
<ref id='el.sun.indexcontents' text='indexcontents'>,
<ref id='el.sun.note' text='note'>,
<ref id='el.sun.notecontents' text='notecontents'>

<row>
<entry>
<ref id=str.code>
<entry>
<ref id='el.sun.codecollection' text='codecollection'>,
<ref id='el.sun.routinelist' text='routinelist'>

<row>
<entry>
<ref id=str.history>
<entry>
<ref id='el.sun.change' text='change'>,
<ref id='el.sun.distribution' text='distribution'>,
<ref id='el.sun.docdate' text='docdate'>,
<ref id='el.sun.history' text='history'>,
<ref id='el.sun.update' text='update'>,
<ref id='el.sun.version' text='version'>

<row>
<entry>
<ref id=str.xrefs>
<entry>
<ref id='el.sun.docxref' text='docxref'>,
<ref id='el.sun.ref' text='ref'>,
<ref id='el.sun.url' text='url'>,
<ref id='el.sun.webref' text='webref'>

<row>
<entry>
<ref id=str.figures>
<entry>
<ref id='el.sun.caption' text='caption'>,
<ref id='el.sun.figure' text='figure'>,
<ref id='el.sun.figurecontent' text='figurecontent'>

<row>
<entry>
<ref id=str.tables>
<entry>
<ref id='el.sun.caption' text='caption'>,
<ref id='el.sun.colspec' text='colspec'>,
<ref id='el.sun.entry' text='entry'>,
<ref id='el.sun.row' text='row'>,
<ref id='el.sun.table' text='table'>,
<ref id='el.sun.tbody' text='tbody'>,
<ref id='el.sun.tgroup' text='tgroup'>,
<ref id='el.sun.thead' text='thead'>

<row>
<entry>
<ref id=str.text>
<entry>
<ref id='el.sun.attribution' text='attribution'>,
<ref id='el.sun.blockquote' text='blockquote'>,
<ref id='el.sun.cite' text='cite'>,
<ref id='el.sun.code' text='code'>,
<ref id='el.sun.dd' text='dd'>,
<ref id='el.sun.dl' text='dl'>,
<ref id='el.sun.draftnote' text='draftnote'>,
<ref id='el.sun.dt' text='dt'>,
<ref id='el.sun.em' text='em'>,
<ref id='el.sun.kbd' text='kbd'>,
<ref id='el.sun.li' text='li'>,
<ref id='el.sun.ol' text='ol'>,
<ref id='el.sun.p' text='p'>,
<ref id='el.sun.px' text='px'>,
<ref id='el.sun.quote' text='quote'>,
<ref id='el.sun.strong' text='strong'>,
<ref id='el.sun.ul' text='ul'>,
<ref id='el.sun.verbatim' text='verbatim'>

<row>
<entry>
<ref id=str.maths>
<entry>
<ref id='el.sun.m' text='m'>,
<ref id='el.sun.meqnarray' text='meqnarray'>,
<ref id='el.sun.mequation' text='mequation'>

</tbody>
</tgroup>
</table>

<p>Discuss separately structure, tables, figures, cross-references,
maths, program code.  

<subsect id=str.structure export>Overall structure

<p>Includes
<ref id='el.sun.abstract' text='abstract'>,
<ref id='el.sun.appendices' text='appendices'>,
<ref id='el.sun.author' text='author'>,
<ref id='el.sun.authorlist' text='authorlist'>,
<ref id='el.sun.copyright' text='copyright'>,
<ref id='el.sun.docbody' text='docbody'>,
<ref id='el.sun.docinfo' text='docinfo'>,
<ref id='el.sun.docnumber' text='docnumber'>,
<ref id='el.sun.editors' text='editors'>,
<ref id='el.sun.keyword' text='keyword'>,
<ref id='el.sun.otherauthors' text='otherauthors'>,
<ref id='el.sun.sun' text='sun'>,
<ref id='el.sun.title' text='title'>

<p>An SGML document always starts with a doctype declaration.  There
are seven document types defined at present:
<verbatim><![cdata[
<!doctype sug PUBLIC "-//Starlink//DTD Starlink SUG//EN">
<!doctype sun PUBLIC "-//Starlink//DTD Starlink SUN//EN">
<!doctype ssn PUBLIC "-//Starlink//DTD Starlink SSN//EN">
<!doctype sgp PUBLIC "-//Starlink//DTD Starlink SGP//EN">
<!doctype sc  PUBLIC "-//Starlink//DTD Starlink SC//EN">
<!doctype sg  PUBLIC "-//Starlink//DTD Starlink SG//EN">
<!doctype mud PUBLIC "-//Starlink//DTD Starlink MUD//EN">
]]></verbatim>
These cover, respectively, the Starlink User Guide, Starlink user
notes, system notes, general papers, cookbooks, and guides, and
Miscellaneous User Documents.  These document types are broadly the
same (there is a single DTD underlying them all), but the different
types have different features, summarised in <ref
id=table.dtdfeatures>.

<table id=table.dtdfeatures>
<caption>
Starlink DTD feature summary
</caption>
<tgroup cols="6">
<thead>
<row>
<entry>DTD
<entry>Abstract<entry>Versioning<entry>Docnumber<entry>Routinelist<entry>EnforceLinkPolicy
<tbody>
<row>
<entry>sug
<entry>yes<entry>yes<entry>no<entry>no<entry>yes
<row>
<entry>sun
<entry>yes<entry>yes<entry>yes<entry>yes<entry>yes
<row>
<entry>ssn
<entry>yes<entry>yes<entry>yes<entry>no<entry>yes
<row>
<entry>sgp
<entry>yes<entry>yes<entry>yes<entry>no<entry>yes
<row>
<entry>sc
<entry>yes<entry>yes<entry>yes<entry>no<entry>yes
<row>
<entry>sg
<entry>yes<entry>yes<entry>yes<entry>no<entry>yes
<row>
<entry>mud
<entry>opt'l<entry>no<entry>yes<entry>no<entry>no
</tbody>
</tgroup>
</table>

<p>The table headings in <ref id=table.dtdfeatures> are as follows:
<dl>
<dt>Abstract
<dd>Is an abstract required or optional.
<dt>Versioning
<dd>Is the history mechanism, described in <ref id=str.history>
required?  If not, the <ref id=el.sun.docdate text='docdate'>
element is required.
<dt>Docnumber
<dd>Is a document number required?
<dt>Routinelist
<dd>Are the code-documentation elements, described in <ref
id=str.code> available?
<dt>EnforceLinkPolicy
<dd>Is the link policy enforced?  See <ref id=str.xrefs>.
</dl>

<p>These defaults are generally appropriate for the type of document.
If you need to change them for a particular document, however, you
can.  The only case where you might plausibly need to change the
default is in in the case of the routine-list feature, and you do this by
invoking the SSN DTD (for example) as follows
<verbatim><![cdata[
<!doctype ssn PUBLIC "-//Starlink//DTD Starlink SSN//EN" [
  <!entity % Feature.Routinelist 'include'>
]>
]]></verbatim>

<subsect id=str.sect export>Sectioning

<p>Includes
<ref id='el.sun.sect' text='sect'>,
<ref id='el.sun.subhead' text='subhead'>,
<ref id='el.sun.subsect' text='subsect'>,
<ref id='el.sun.subsubsect' text='subsubsect'>,
<ref id='el.sun.subsubsubsect' text='subsubsubsect'>
<ref id='el.sun.title' text='title'>

<subsect id=str.backmatter export>Backmatter - notes and bibliography

<p>Includes
<ref id='el.sun.backmatter' text='backmatter'>,
<ref id='el.sun.bibliography' text='bibliography'>,
<ref id='el.sun.citation' text='citation'>,
<ref id='el.sun.index' text='index'>,
<ref id='el.sun.indexcontents' text='indexcontents'>,
<ref id='el.sun.note' text='note'>,
<ref id='el.sun.notecontents' text='notecontents'>

<subsect id=str.code export>Documenting code

<p>Includes
<ref id='el.sun.codecollection' text='codecollection'>,
<ref id='el.sun.routinelist' text='routinelist'>

<subsect id=str.history export>History

<p>Includes
<ref id='el.sun.change' text='change'>,
<ref id='el.sun.distribution' text='distribution'>,
<ref id='el.sun.docdate' text='docdate'>,
<ref id='el.sun.history' text='history'>,
<ref id='el.sun.update' text='update'>,
<ref id='el.sun.version' text='version'>

<subsect id=str.xrefs export>Cross-references

<p>Includes
<ref id='el.sun.docxref' text='docxref'>,
<ref id='el.sun.ref' text='ref'>,
<ref id='el.sun.url' text='url'>,
<ref id='el.sun.webref' text='webref'>

<p>Explain `link-policy'

<p>Explain generating document-summary.

<subsect id=str.figures export>Figures

<p>Includes
<ref id='el.sun.caption' text='caption'>,
<ref id='el.sun.figure' text='figure'>,
<ref id='el.sun.figurecontent' text='figurecontent'>

<subsect id=str.tables export>Tables

<p>Includes
<ref id='el.sun.caption' text='caption'>,
<ref id='el.sun.colspec' text='colspec'>,
<ref id='el.sun.entry' text='entry'>,
<ref id='el.sun.row' text='row'>,
<ref id='el.sun.table' text='table'>,
<ref id='el.sun.tbody' text='tbody'>,
<ref id='el.sun.tgroup' text='tgroup'>,
<ref id='el.sun.thead' text='thead'>

<subsect id=str.text export>Text markup

<p>Includes
<ref id='el.sun.attribution' text='attribution'>,
<ref id='el.sun.blockquote' text='blockquote'>,
<ref id='el.sun.cite' text='cite'>,
<ref id='el.sun.code' text='code'>,
<ref id='el.sun.dd' text='dd'>,
<ref id='el.sun.dl' text='dl'>,
<ref id='el.sun.draftnote' text='draftnote'>,
<ref id='el.sun.dt' text='dt'>,
<ref id='el.sun.em' text='em'>,
<ref id='el.sun.kbd' text='kbd'>,
<ref id='el.sun.li' text='li'>,
<ref id='el.sun.ol' text='ol'>,
<ref id='el.sun.p' text='p'>,
<ref id='el.sun.px' text='px'>,
<ref id='el.sun.quote' text='quote'>,
<ref id='el.sun.strong' text='strong'>,
<ref id='el.sun.ul' text='ul'>,
<ref id='el.sun.verbatim' text='verbatim'>

<subsect id=str.maths export>Maths

<p>Includes
<ref id='el.sun.m' text='m'>,
<ref id='el.sun.meqnarray' text='meqnarray'>,
<ref id='el.sun.mequation' text='mequation'>

<sect id=doccode export>Documenting code

<p>In this section I will describe all the elements of the programcode
DTD, grouping them by type.  There is an alternative description of
the elements, listed alphabetically, in (ref id=appx.programcode.elementlist>.

<ref id='el.programcode.argumentlist' text='argumentlist'>,
<ref id='el.programcode.author' text='author'>,
<ref id='el.programcode.authorlist' text='authorlist'>,
<ref id='el.programcode.authornote' text='authornote'>,
<ref id='el.programcode.authorref' text='authorref'>,
<ref id='el.programcode.change' text='change'>,
<ref id='el.programcode.code' text='code'>,
<ref id='el.programcode.codebody' text='codebody'>,
<ref id='el.programcode.codegroup' text='codegroup'>,
<ref id='el.programcode.codeprologue' text='codeprologue'>,
<ref id='el.programcode.codereference' text='codereference'>,
<ref id='el.programcode.copyright' text='copyright'>,
<ref id='el.programcode.description' text='description'>,
<ref id='el.programcode.docblock' text='docblock'>,
<ref id='el.programcode.em' text='em'>,
<ref id='el.programcode.func' text='func'>,
<ref id='el.programcode.funcname' text='funcname'>,
<ref id='el.programcode.history' text='history'>,
<ref id='el.programcode.li' text='li'>,
<ref id='el.programcode.misccode' text='misccode'>,
<ref id='el.programcode.miscprologue' text='miscprologue'>,
<ref id='el.programcode.name' text='name'>,
<ref id='el.programcode.otherauthors' text='otherauthors'>,
<ref id='el.programcode.othernames' text='othernames'>,
<ref id='el.programcode.p' text='p'>,
<ref id='el.programcode.parameter' text='parameter'>,
<ref id='el.programcode.programcode' text='programcode'>,
<ref id='el.programcode.purpose' text='purpose'>,
<ref id='el.programcode.returnvalue' text='returnvalue'>,
<ref id='el.programcode.routinename' text='routinename'>,
<ref id='el.programcode.title' text='title'>,
<ref id='el.programcode.type' text='type'>,
<ref id='el.programcode.ul' text='ul'>,
<ref id='el.programcode.url' text='url'>,


<sect id=processing export>Processing your document

<subsect id=proc.setup export>Setting up

<p>Packaging document for distribution.  BOS?  Manifest?  Figures?  Makefile?

<subsect id=proc.makefile export>Makefile

<p>Makefile.common.  Only.web and Only.paper.  Targets such as
%.single.html.  Stamps.

<subsect id=editors export>Editors

<p>Is this the best place for this?

<sect id=future export>Further developments

<p>What next?  Weaknesses with the current implementation.

<p>HyTime?  XML?  Searching?

<sect id=faq export>Frequently Asked Questions

<subsect id=faq.html export>What's wrong with HTML?

<p>Well?

<subsect id=faq.latex export>What's wrong with &latex?

<p>Well?

<subsect id=faq.xml export>What about XML?

<p>Well?

<appendices>

<sect id=appx.sgml export>SGML -- some of the details

<p>This section covers some SGML topics in a little more detail than is
necessary if you simply want to write Starlink documents.  It should
give you enough understanding to allow you to read most DTDs.

<p>This section is for extra, or more detailed, information than it
was necessary to include in <ref id=markup>.  It will not, therefore,
repeat information presented there.

<subsect id=sgml.dtd export>Reading DTDs

<p>The discussion in <ref id=markup> should be enough to let
you produce your own documents but, now or in the future, you may find
it useful to be able to read the DTD directly.  Once you are familiar
with the underlying ideas, the expression of them in the DTD turns out
to be agreeably compact and reasonably readable.

<p>My account of the DTD syntax will be rather compressed -- see
<citation/gentle/, or the other references in <ref
id=what.sgml> for alternatives.

<p>A simple HTML-like DTD could be declared as follows:
<verbatim><![ cdata [
<!element html      o o (head, body, copyright?)>
<!element head      o o (title & link*)>
<!element title     - - (#pcdata)>
<!element link      - o empty>
<!element body      o o (p | dl)+>
<!element p         - o (#pcdata)>
<!element dl        - - (dt, dd)+>
<!element (dt|dd)   - o (#pcdata)>
<!element copyright - - (#pcdata)>

<!entity % URL "cdata"
        -- The term URL means a CDATA attribute
           whose value is a Uniform Resource Locator,
           See RFC1808 (June 95) and RFC1738 (Dec 94).
        -->
<!attlist link
    href  %URL          #required  -- URL for linked resource --
    rel   (next | prev) #implied   -- reverse link types --
    >
<!entity amp "&">
]]></verbatim>
And here is a simple document which uses this DTD:
<verbatim><![ cdata [
<link href="http://www.astro.gla.ac.uk/users/norman/" rel=next>
<title>This is a title</title>

<p>And here is a paragraph
<dl>
<dt>With a delimited list
<dd>Correctly formed &amp; OK
</dl>
]]></verbatim>
This displays most of the important syntactical features in an SGML
DTD, so if we explain it line-by-line, it should illustrate the
features you need to make some sense of most DTDs.

<p><verbatim><![ cdata [
<!element html    o o (head, body, copyright?)>
]]></verbatim>
This `element declaration'
declares the <code/html/ element.  The element type name is followed
by a statement of whether the start and end tags may be omitted if the
parser can infer their presence.  The minimisation specifications may
be either `-' (minus), indicating that the corresponding tag is
required, or `o' (letter~O), indicating that it may be omitted.
Following this is the `content model' which, in this case, states that
the <code/html/ element must consist of one <code/head/, one
<code/body/, and an optional <code/copyright/, in that order -- the
comma connecting the element 
names specifies that they must be in order, and the question mark
following the copyright element indicates that it may occur zero or
one times. 
The omission of the start element is possible in this case, since the
first element in the <code/html/ element must be a <code/head/
element, so whenever the parser finds a <code/head/ element, it can
know that the <code/html/ element has begun.

<p>So what is in the <code/head/ element?
<verbatim><![ cdata [
<!element head    o o (title & link*)>
]]></verbatim>
The <code/head/ element consists of precisely one title, and zero or
more <code/link/ elements, in either order.  The <code/head/ tags
can be inferred from the presence of
the <code/title/ and <code/link/ elements, and so it is feasible for
us to declare that they may be omitted.  The star following the
<code/link/ token in the content model indicates that this element may
appear zero or more times, and the ampersand declares that the
elements on either side of it must both appear, but can do so in
either order.  Note that this content model allows `<code/title/',
`<code/title link link.../' and `<code/link link...title/', but not
`<code/link/' or `<code/link title link/'.

<p>Finally we have some text:
<verbatim><![ cdata [
<!element title   - - (#pcdata)>
]]></verbatim>
The title element is very simple: neither the start not the end tag
may be omitted, and it may contain only characters (<code/#pcdata/
stands for `parseable character data') and entity references such as
<code/&amp;amp;/.

<p><verbatim><![ cdata [
<!element link    - o empty>
]]></verbatim>
The <code/link/ element has no actual content, so it is given a
content model consisting of the reserved word <code/empty/.  The tag
omission for empty elements is always `<code/- o/'.  The point of the
<code/link/ element is to hold its attributes, which we will come to
shortly.

<p><verbatim><![ cdata [
<!element body    o o (p | dl)+>
]]></verbatim>
The document body consists of paragraph elements, or `delimited
lists'.  The `or' connector, `<code/|/', indicates that either of the
<code/p/ or <code/dl/ elements may appear, and the `plus' occurrence
indicator asserts that the group <code/(p|dl)/ must appear one or more
times.  In other words, the body consists of a sequence of <code/p/
and <code/dl/ elements in arbitrary order.

<p>Finally, we start to specify the `interesting' content of the document.
<verbatim><![ cdata [
<!element dl      - - (dt, dd)+>
]]></verbatim>
Like the <code/body/ itself, the <code/dl/ element consists of a
sequence of one or more structures.  Unlike the <code/body/ element,
however, the structure is not a list of alternatives, but a sequence.
Where the <code/body/ element would allow `<code/p p dl p/' for example, the
<code/dl/ element requires that the <code/dt/ and <code/dd/ elements
alternate -- the repeatable element is the <em/ordered pair/ of
elements `<code/dt, dd/'.

<p><verbatim><![ cdata [
<!element (dt|dd) - o (#pcdata)>
<!element p       - o (#pcdata)>
<!element copyright - - (#pcdata)>
]]></verbatim>
The paragraph, list and copyright elements have simple content
models.  Note that we can specify the structure of more than one
element in the same declaration.

<p>Prior to specifying the attributes for the <code/link/ element, we
may declare an abbreviation.
<verbatim><![ cdata [
<!entity % URL "cdata"
        -- The term URL means a CDATA attribute
           whose value is a Uniform Resource Locator,
           See RFC1808 (June 95) and RFC1738 (Dec 94).
        -->
]]></verbatim>
This declares <code/URL/ to be a `parameter entity', usable only
within this DTD.  The entity reference `<code/%URL/' will be
substituted by the string `<code/cdata/' (unparsed character data)
when it is encountered.  A DTD may declare an entity more than once,
but any declarations after the first are silently ignored.

<p>Note the structure of the comment in this last declaration: in SGML,
comments may appear only within markup declarations (that is within
`<code/&lt;! ... >/'), they start and end with the string
`<code/&#45;&#45;/', and there may be more than one in a row.  Thus you
may legally find `<code/&lt;!>/' within an SGML file -- this is a
completely empty markup declaration.  Such a declaration may have a
single comment within it, as in `<code><![ cdata [<!-- this is a comment
-->]]></code>', or it may have several, as in
<code><![ cdata [<!-- here -- -- is a comment ------>]]></code>, which
has <em/three/ comments within it, the third of which is empty. 

<p>Now we declare the attributes for the <code/link/ element.
<verbatim><![ cdata [
<!attlist link
    href  %URL          #required  -- URL for linked resource --
]]></verbatim>
This declares an <code/href/ attribute.  After expansion of the
<code/%URL/ entity reference, this attribute is seen to have a
`declared value' of <code/cdata/ (unparsed character data), and this
attribute is required to be present, so that the SGML parser will
object if it finds a <code/link/ element in a document without an
<code/href/ attribute.

<p>The <code/rel/ attribute can take only two values:
<verbatim><![ cdata [
    rel   (next | prev) #implied   -- reverse link types --
    >
]]></verbatim>
The <code/link/ element may have the attribute `<code/rel=next/' or
`<code/rel=prev/', but no other strings.  Since this attribute is
`<code/#implied/', it is also permitted to omit it entirely.  A
document may even specify this as simply `<code/&lt;link
href=&quot;here.html&quot; next>/' and the parser will infer that the value
`<code/next/' is associated with the attribute name `<code/rel/'.

<p><verbatim><![ cdata [
<!entity amp "&">
]]></verbatim>
Entity references (other than parameter entities, which are internal
to a DTD) are made using a
construction such as `<code/&amp;entname;/.  This presents a problem
if you want to include the ampersand in your text, but this
declaration sets up an entity called `amp', which can be used to
include an ampersand in text by typing `<code/&amp;amp;/'.  You can
use this in your own documents to create shorthand forms for bits of
text you don't want to retype.

<subsect id=sgml.dtdsubset export>Document type declaration subset

<p>As explained above, the structure of your document type, plus a
variety of entities, is declared in the DTD, which, because it is
common to a large number of documents, is held separately
from the document you are writing.

<p>It is possible, however, for a specific document to adjust or add to the
declarations within the DTD, and this is done within the `document
type declaration subset'.

<p>The subset is a DTD fragment which 

get-out-of-jail-free card

<p>Can be used to include subfiles, create abbreviations, necessarily
declare subdocs or, in extremis, modify the DTD.  Use for HTML-only
sections, etc.  Recapitulate the warnings about careless use making
the document invalid.  Perhaps put this into a separate section on
marked sections, and mention the CDATA marked section.

%Feature....


<subsect id=sgml.entities export>SGML entities

<p>Entity references are a mechanism for referring to characters, or
longer pieces of text, which you cannot type on your keyboard, which
must be escaped from the parser, or which you simply want to
abbreviate.

<p>A reference to an entity <code/amp/ is of the form
<code/&amp;amp;/.  It is prefixed by the character <code/&amp/ and
suffixed by a semicolon<note>In fact, you can omit the trailing
semicolon if the character following the entity name is not a name
character -- not a letter, hyphen or dot.  This is probably a bad
habit to get into.</note>.

<p>The list of entities predefined by the Starlink general DTD is
given in <ref id=table.entities>.

<p>It is not an error to define an entity twice.  In this case, the
second definition is silently ignored.

<p>You can define entities, including parameter entities, in the
document's `declaration subset' (see <ref id=markup.dtdsubset>), since
these conceptually come before, and hence have priority over,
definitions in the DTD.  Also, SGML parsers usually allow such
on-the-fly definitions on the command line.  However, resist resist
resist the temptation to do clever things here, since it is easy to
make your document unreadable and, a much more heinous crime, invalid.

<subsect id=sgml.ms export>Marked sections

<p>Another feature you will commonly find in DTDs is the `marked
section'.  As an author, you will most likely only ever use the
<code/cdata/ marked section, but the <code/ignore/ and <code/include/
marked sections are very commonly used within DTDs.

<p>A marked section is a construction such as
<verbatim>
Here is some text &lt;![ cdata [ with &lt;odds&gt; &amp sods &rsqbrack;]>
</verbatim>
and
<verbatim>
Here is some text &lt;![ ignore [ and here is some ignored text &rsqbrack;]>
</verbatim>
Along with <code/ignore/ there is <code/include/.

<p>The marked section ends at the sequence of characters
<code/&rsqbrack;&rsqbrack;&gt;/, which is therefore the one sequence
which cannot appear within the marked section.

<subsubsect>CDATA marked sections

<p>Within the <code/cdata/ marked section, parsing is switched off, so
that angle brackets, <code/&lt/, and ampersands, <code/&amp/, are no
longer recognised as introducing markup and entity references.

<p>You will typically use a <code/cdata/ marked section to delimit
verbatim text.  The <code/code/ and <code/verbatim/ elements (see <ref
id=el.sun.code> and <ref id=el.sun.verbatim>) do not make any
provision to switch off parsing of the text within them.  If the text
would be significant to the parser -- that is, if it contains angle
brackets or ampersands -- you must either escape those characters by
giving them as entity references <code/&amp;lt;/ or <code/&amp;amp;/,
or else enclose the contents in a <code/cdata/ marked section as
follows.
<verbatim>
&lt;verbatim>&lt;![ cdata [
Here is some &lt;em>marked-up&lt/em> text
which will be skipped &amp; ignored
&rsqbrack;&rsqbrack>&lt;/verbatim>
</verbatim>

<subsubsect>IGNORE and INCLUDE marked sections

<p>Text within <code/include/ and <code/ignore/ marked sections is
parsed or skipped by the parser, as appropriate.  They are <em/not/
typically used outside of DTDs, but the <code/ignore/ marked section
is occasionally useful as a way of `commenting out' large sections of
text which might itself include SGML comments <code/&lt;!--
... --&gt;/. 

<p>Why on earth would you want to do this?  Because the ignore/include
keyword can be the expansion of an entity.  We could have defined our
HTML-like document type as follows:
<!-- can't use marked section when I'm illustrating one! -->
<verbatim>
&lt;!entity % allow.copyright &quot;ignore&quot;>
&lt;![ %allow.copyright; [
  &lt;!entity % html.model &quot;head, body, copyright?&quot;>
  &lt;!element copyright - - (#pcdata)>
&rsqbrack;]>
&lt;!entity % html.model &quot;head, body&quot;>
&lt;!element html    o o (%html.model;)>
</verbatim>
This looks very strange, but it is a common idiom in DTDs.  

<p>The entity reference <code/&percent;allow.copyright;/ is a
`parameter entity reference' (see section <ref id=sgml.entities>),
which is distinct from a general entity 
reference such as <code/&amp;amp;/, and can occur only within markup
(ie, within DTDs).

<p>The parameter entity <code/%allow.copyright/ is defined to be
<code/ignore/.  That means that when the parser finds the marked
section it ignores it, so that the first definition it finds of the parameter
entity <code/%html.model/ is the one which sets it to be
`<code/head,body/', so that is what is used as the content model
in the declaration of the <code/html/ element in the last line.

<p>Nothing appears to have been achieved here.  However, if the
<code/%allow.copyright/ entity had <em/earlier/ been set to
<code/include/, then the redefinition of it here would have been
ignored, the marked section would have been included, the
<code/%html.model/ entity would have been defined as
`<code/head,body,copyright?/' with the (now) second one ignored, and
the <code/html/ element would have been defined to allow all three
elements.  That is, marked sections used internally in this way can be
a useful way of parameterising DTDs.

<p>The entity could be declared earlier in the same DTD, in a
particular document's DTD-subset (see <ref id=markup.dtdsubset>), or
completely externally to the document in a command-line option to the
parser.

<subsubsect>Paper-only and web-only variants

<p>Sometimes, it is necessary to have parts of your document which
vary depending on whether the document is to be viewed on paper or
online.  The Starlink general DTD defines two parameter entities
<code/&percent;Only.paper/ and <code/&percent;Only.web/, which you can
use to include or ignore text in a marked section (see <ref
id=sgml.ms>).  By default, both of these are set to the string
`ignore', but the common Makefile (in
<code>$STARLINK_SGML_DIR/lib/Makefile.common</code>, see <ref
id=proc.makefile>) sets one or other of these to `include', as
appropriate for the type of file being generated.

<p>You would use this facility as follows:
<verbatim>
&lt;p>Here is some text.
&lt;![ %Only.web [ And here is some which would appear
only in webpages. &rsqbrack;&rsqbrack;>
</verbatim>

<p>It is, I hope, clear that you could get yourself in a terrible mess
here, and create a document which is only valid for some settings of
the entities.  Take care that your document remains valid for all
settings, including the case where both entities are set to `ignore'.

<sect id=appx.general.dtd export>The Starlink General DTD

<p>This section includes a list of all the elements in the Starlink
General DTD.  For a thematic treatment of the elements, see <ref
id=structure>, and the groups in <ref id=table.elements>.

<subsect id=appx.general.elementlist export>Element listing

<p>The following element listing includes all the elements and
attributes defined in the Starlink General DTD.  This includes a
number of attributes with a <em/fixed/ value (indicated by a default
keyword of <code/#fixed/).  These are for internal use by the DTD and
the applications which process it, and are not documented further.

&starlinkdtddoc;

<sect id=appx.programcode.dtd export>The Programcode DTD

<p>The programcode DTD.

<subsect id=appx.programcode.elementlist export>Element listing

&programcodedtddoc;

<sect id=appx.system export>The Starlink SGML system for maintainers

<p>This section is a reference for maintainers of the Starlink SGML
system

<p>Supporting software: in .../sgml/lib (inc BibTeX style).  What
about distributing perlSGML?

<subsect id=appx.dssslcode export>The DSSSL source code

<p>Hoover everything in to here.

<subsect id=install export>Installation

<p>How to install everything, including building Jade.

<sect id=appx.releasenotes export>Release Notes

<p>Insert the TODO list, and news.

<backmatter>
<notecontents>
<bibliography bib=ssn70>
