<!DOCTYPE ssn PUBLIC "-//Starlink//DTD Starlink SSN 0.6//EN" [
  <!-- Other Starlink documents referred to -->
  <!ENTITY sgp28	PUBLIC "-//Starlink//DOCUMENT Summary SGP/28//EN"
			SUBDOC
			-- How to write good documents for Starlink -->
  <!ENTITY sun188	PUBLIC "-//Starlink//DOCUMENT Summary SUN/188//EN"
			SUBDOC
			-- HTX -->
  <!ENTITY sun199 	PUBLIC "-//Starlink//DOCUMENT Summary SUN/199//EN"
			SUBDOC
			-- Star2HTML -->

  <!-- Figures -->
  <!ENTITY sgmlsystem.eps SYSTEM 'ssn70_SGMLsystem.eps' NDATA eps>
  <!ENTITY sgmlsystem.gif SYSTEM 'ssn70_SGMLsystem.gif' NDATA gif89a>

  <!-- Local text files included -->
  <!ENTITY starlinkdtddoc	
			SYSTEM '../dtd2sgml/starlink-0.6.sgmltext'>
  <!ENTITY programcodedtddoc
			SYSTEM '../dtd2sgml/programcode-0.6.sgmltext'>
  <!ENTITY dsssl.lib	SYSTEM "../../dsssl/sl/lib/sllib.dsl" SUBDOC
			-- DSSSL library code -->
  <!ENTITY dsssl.common	SYSTEM "../../dsssl/sl/common/slcommon.dsl" SUBDOC
			-- dsssl common code -->
  <!ENTITY dsssl.params	SYSTEM "../../dsssl/sl/common/slparams.sgml" SUBDOC
			-- Parameterisation -->
  <!ENTITY release.notes	
			SYSTEM "ReleaseNotes">
  <!ENTITY release.notes.old
			SYSTEM "ReleaseNotes.old">

  <!-- other miscellanea -->
  <!ENTITY % Feature.Routinelist 'INCLUDE'>
  <!ENTITY rsqbrack ']'	-- needed in order to describe marked sections -->
  <!ENTITY ddash CDATA '--'	-- so I can use this in CODE els without it
				   being recognised as a shortref -->
]>
<!-- $Id$ -->

<title>The Starlink SGML Set
<author email='norman@astro.gla.ac.uk'
	webpage='http://www.astro.gla.ac.uk/users/norman/'
	affiliation='University of Glasgow'
	id=ng
	>Norman Gray

<docnumber>70

<history>
<version number=0 date='21-APR-1999' author=ng>Initial version</version>

<distribution string="DR-0.2" date="03-JUN-1999" author=ng>
First real release to other programmers.  Distribution contains only
SGML lib stuff: Jade has to be built separately.

<change date="06-JUN-1999" author="ng" versionid="post-0.2">
Various edits, great and small.  I received comments from Mark Taylor,
arising from the DR-0.2 distribution.  I made considerable additions
to the appendices.  Generally tidying up for release.

<distribution string="DR-0.3" date="15-JUN-1999" author="ng">
More substantial release, CD candidate.

<change date="22-JUN-1999" versionid="post-0.3">
Assorted tweaks, introduced since the release.
</change>

<distribution string="DR-0.4" date="10-SEP-1999" author="ng" versionid=v0-4>
Smallish DTD and DC changes, arising from the programmers' meeting and
discussion with Mark Taylor.
</distribution>

<change date='13-SEP-1999' versionid="post-v0-4">
Assorted tidyups and clarifications from user comments
</change>

<distribution string="DR-0.5" date="19-SEP-1999" author="ng">
Rather rushed distribution, containing implementations of changes to
Programcode DTD and implementations of those in the down-converters.
Time for few documentation updates.
</distribution>

<change date="23-SEP-1999" versionid="post-v0-5">Misc. clarifications.</change>

<distribution string="DR-0.6-unreleased" date="30-SEP-1999" author="ng" versionid="v0.6">
Added sgml2docs command.  Significant changes to programcode.
</distribution>

</history>

<coverimage>
<px>An SGML Application Conforming to International Standard ISO 8879
-- Standard Generalized Markup Language
<px>A HyTime application conforming to International Standard ISO/IEC
10744 -- Hypermedia/Time-based Structuring Language
</coverimage>

<copyright>
Copyright 1999, Particle Physics and Astronomy Research Council
</copyright>

<abstract>
<px>This is a developers' release, not production code.

<px>This document describes the Starlink SGML set.

<px>Audience: 
This document is addressed both at those who need to generate Starlink
documentation of any kind, and at anyone maintaining the Starlink SGML set.
</abstract>

<sect id=intro export>Introduction

<p>The Starlink SGML set supports people writing Starlink documents,
such as SUNs, SSNs, MUDs and the like.<note>To avoid ambiguity, this
somewhat arcane note needs to be here.  The terms `SGML system' and
`SGML application' have precise meanings in the SGML world.  An SGML
system is a program such as Jade or SP which parses SGML.  An SGML
application is a collection of DTDs and other supporting documents
(see the standard <citation/iso8879/, clause~4.279).  This package is
therefore properly referred to as an SGML application, but since this
term could be confusing, I will refer to this package instead
as the (Starlink) SGML Set.</note> It consists of a definition of a
markup language suitable for such documents, plus software to convert
these source documents to reader-friendly form.  At present, these
`output formats' include HTML and &latex (and hence include postscript
and PDF formats).

<p>The SGML set scores over previous solutions to Starlink's
documentation needs, such as <code/runoff/ or &latex, because it is a
well-defined system, so that there is excellent support for it in
tools, and it is designed to be converted into whichever presentation
format is most convenient.
The DTD is designed to be flexible, rather than imposing a
particularly tight document structure.  At the same time it has
<em/enough/ structure that it can be indexed and stored effectively.

<p>Although this system can help with many of the tasks involved in
document creation, it cannot write the document for you (shame!).  For
advice on that, documents such as <docxref doc=sgp28> are still vital.

<p>This document is organised as follows.  In <ref id=sgml>, I
discuss SGML in general terms, describing its general structure and
aims, describing how to read a Document Type Definition (DTD), and
pointing to sources of information.  In <ref id=markup>, I describe
how you would go about actually writing a document, describing the
structure of Starlink documents which is crystallised in the
specification of this set.  In <ref id=structure>, I describe the
structure of the document DTD, and the categories of elements you will use.
In <ref id=doccode>, I describe the
support which exists to support documentation of source code, allowing
you to maintain detailed routine documentation along with the routine
source code.  In <ref id=processing>, I describe the details of how
you transform your document from SGML to an output format.  Finally,
the appendices give the detailed descriptions of the elements in the
two DTDs described here, a more detailed description of SGML than is
necessary for simple use of the set, and documentation for
maintainers of the set.

<!--
In <ref id=future>, I describe
some possible further improvements in the set (suggestions and
comments are most welcome).  Finally, in <ref id=faq>, I
answer (I hope) some frequently asked questions about SGML in general
and this set in particular.
-->

<sect id=sgml export>SGML Overview

<p>This section introduces you to SGML, and explains its advantages
over other approaches to document preparation.

<subsect id=why.sgml export>Why SGML?

<p>The problem SGML tries to solve is that humans are good at
intuiting structure from layout, but computers are exceedingly bad at
it.  This means that if we want computers to help us with documents --
displaying them, transforming them, storing them, searching them -- we
have to give the computer some help.  

<p>A common way of providing this
help is through markup systems such as <code/runoff/ (or its
variants), or &tex, or &latex;.  The last of these three has served
Starlink very well, and even survived the conversion of Starlink's
document set to hypertext, through the tool <code/Star2HTML/ (see <docxref
doc=sun199>), but the problems of the &latex system illustrate the
advantages of the SGML approach quite well.
<dl>
<dt>LaTeX templates are ill-defined
<!-- Have this as `LaTeX' rather than &latex: the `latex' back-end -->
<!-- messes up SDATA references within (data nd), which is bad, since -->
<!-- latex/slmisc.dsl turns <dt> into \item[blah] using (data ...). -->
<dd>What is a Starlink document?  Although Starlink distributes
templates for the principal document types (for example in
<code>/star/docs/sun.tex</code>), and distributes style guides such as
<docxref doc=sgp28>, there is no way either of mandating that certain
elements, such as a document number, actually appear, nor of ensuring
that other features, such as raw &tex, do not.  This means that
document authors can never quite be sure that they have produced a
`correct' document; that, since the effective definition of `correct' is
`processable by this tool', there is no guarantee that a document
which is correct at one time will continue to be so; and that tools
which search or process such 
documents have to have contingency strategies available, when the
elements they hope to use are missing.

<dt>The conversion is a hack!
<dd>Because the input documents are not well-defined, the tools which
process them cannot be designed against any standard, but instead have
to rely on heuristics and uncheckable conventions.  &latex documents
are defined to work with one particular tool -- the &tex tokeniser and
parser -- so that using
them with any other tool (which is necessary if you want to produce
anything other than DVI files<note>In fact, there is a version of &tex;
which produces PDF files directly, and a &tex;-to-HTML converter
called TeX4ht (see
<url>http://www.tug.org/applications/tex4ht/mn.html</url>) which
writes special DVI files which work with a 
postprocessor, and so uses the &tex parser to produce HTML
indirectly.  This really just pushes the hack elsewhere.</note>) is
asking for trouble.

<dt>Authors have to know too much.
<dd>When you are writing a <code/Star2HTML/ document, you are
riding two horses at once; you must write in that subset of &latex
which <code/Star2HTML/ knows about.  Authors must frequently be
sensitive to the treatment of their document by two separate systems.

<dt>Authors <em/can/ know too much!
<dd>Part of the strength of &tex and &latex is their flexibility, and
it is easy for authors, especially programmer authors, to exploit this
when writing documentation, and a burst of &tex macro
magic can be an effective antidote to demotivation during the longeurs
of preparing documentation.  However much this flexibility may assist
(or even amuse) authors, it inflicts parsing hell on anyone else who
wants to do something unforseen with the document.
If you restrict what an author <em/can/ do, then you limit what a
parser <em/has/ to do to repurpose the document.

<dt>Not future-proof
<dd>&latex is not precisely defined; on the contrary, it is
continually being developed, and a completely new version, <webref
url="http://www.oasis-open.org/cover/latex3-9804.html" >&latex;3</webref> is
eagerly anticipated (which will, incidentally, be heavily influenced
by SGML).  Similarly, the <code/LaTeX2HTML/ package is continually
being upgraded, causing a <code/Star2HTML/ (based on
<code/LaTeX2HTML/) maintenance headache.
</dl>

<p>None of these problems is fatal -- all of them have manifestly been
overcome by the authors and maintainers of the current document set --
but taken together they make the maintenance of the document set more
expensive in time than there is time to spare.

<p>SGML addresses these problems effectively.
<dl>
<dt>SGML documents are well-defined
<dd>The structure of an SGML document is formally specified in the
Document Type Definition (DTD) associated with it.  This specifies
what features must, which may, and which may not, be present in a
document.  This means that systems processing the document need work
only within a much smaller universe of possibilities.

<dt>Future-proof
<dd>SGML has had only two backward-compatible amendments since 1986;
it's not dependent on any particular tool; SGML is designed to be used
decades hence; a sufficient number of
hangarfuls of technical documentation have been produced using SGML
that if and when a replacement comes along, it will have good support.

</dl>

<subsect id=what.sgml export>What is SGML?

<p>SGML is a metalanguage: that is, a language for writing languages
in.

<p>This is not actually as arcane as it sounds.  It simply means that
you use SGML to define the abstract structure of a document type (the
Document Type Definition, or DTD), so
that any documents which claim to be of that type must have a certain
syntactic structure.

<p>HTML is a well known example of an SGML DTD, whose rules are well
known.  An HTML document consists of precisely one <code/head/ and one
<code/body/ element.  The <code/head/ must have precisely one
<code/title/ element, and may have zero or more <code/link/ elements.
The <code/title/ element has simple characters as content.  The
<code/link/ element has no content, but has four optional
attributes&ellip, and so on.

<p>Given a document marked up in some specific DTD it will be parsed
by some tool which reads first the DTD then the document, and then
creates some abstract representation of the document which it passes
to a formatter, which in turn produces output in some form which may,
of course, be further processed to a final document.  The SGML parser
and whichever editor you use are both quite generic, but the formatter
is tied to a particular DTD.  There is a diagram of this system in
<ref id=fig.sgml>.
<figure id=fig.sgml float alt="An SGML system">
<caption>An SGML system
<figurecontent image="sgmlsystem.eps">
<figurecontent image="sgmlsystem.gif">
</figure>

<p>For further information on SGML, see <ref id=appx.sgml>.  For other
texts, see the well-known
<cite>Gentle Introduction to SGML</cite><citation/gentle/.
For more detailed information,
see the useful but compressed <citation/bradley/; and for an
authoritative account see 
<citation/goldfarb/, which is an exegesis of the standard,
<citation/iso8879/. 

<subsect id=faq export>Frequently Asked Questions

<subsubsect id=faq.html>What's wrong with HTML?

<p>HTML was designed as a flexible and generic markup language.
Unfortunately, it is a little <em/too/ flexible and generic to be
really useful.  The power of SGML comes from its ability to represent
the structure of a document faithfully, and HTML cannot do this in
most cases - it has a <code/&lt;title>/ element, and some structural
markup <code/&lt;Hn>/, but apart from that, it's little better than
simple ASCII text.  As well, it suffers from some of the same diseases
as &latex;, as described above in <ref id=why.sgml>, in that the
effective definition of a `good' HTML document is `viewable by
netscape', and that means that you're even less well-assured of the
content and structure of a document than you are if you use &latex;
(if you are going to get involved in validating documents,
you might as well go the whole hog and do it properly).

<subsubsect id=faq.latex>What about &latex;?

<p>See the discussion in <ref id=why.sgml>, as
that describes SGML's advantages by comparing them to the problems
with the current &latex; system.  &latex; is marvellous -- this system
uses it as a back-end print formatter -- but it's not ideal for a
large and various document set.

<subsubsect id=faq.xml>What about XML?

<p>XML is a cut-down version of SGML, omitting rarely-used or
dispensable features, but preserving many of its strengths (<ref
id=final.xml>).  I have, however, used several of these omitted
features in this application.  Some of these features, such as markup
minimisation (<ref id=markup.min>) are not vital, and would simply be
inconvenient to lose, but others such as SGML's support for
subdocuments would radically change (for the worse) the nature of the
application's support for complicated documents.

<p>I would like to support XML in future, if there's development time
available.

<sect id=markup export>Marking up your document

<p>In this section I will introduce you to SGML from the point of view
of writing a document marked up using the particular set of SGML
element types this application defines.  There are many 
features of SGML which I will not describe, for simplicity and
brevity, but if you wish to find out more about the possibilities of
SGML, then see the more detailed documentation in <ref id=appx.sgml>
or, for the most authoritative (but admittedly largely
incomprehensible) documentation, the SGML standard
<citation/iso8879/.

<subsect id=markup.intro export>Sample document, and overview

<p>A sample SUN is illustrated in <ref id=fig.simplesun>.
<figure id=fig.simplesun export float alt="Simple SUN document">
<caption>A simple sample SUN</caption>
<px>
<verbatim><![ CDATA [
<!DOCTYPE sun PUBLIC "-//Starlink//DTD Starlink SUN//EN">
<title>The Starlink SGML set
<author email='norman@astro.gla.ac.uk'
        webpage='http://www.astro.gla.ac.uk/users/norman'
        affiliation='University of Glasgow'
        id=ng
        >Norman Gray
<docnumber>1234
<history>
  <version number=0 date='21-APR-1999' author=ng>Initial version
</history>
<abstract>
  This is a sample SUN
</abstract>

<sect id=intro export>Introduction
<p>Starlink SUNs are easy to write.
]]></verbatim>
</figure>
<p>Features to note:
<ul>
<li>The document starts off with a `document type declaration',
<code>&lt;!DOCTYPE sun PUBLIC &quot;-//Starlink//DTD Starlink
SUN//EN&quot;></code>, which states which DTD this document claims to be
conformant to, in this case the Starlink SUN document type.

<li>The document is structured in terms of `element types' such as
<code/author/ or <code/sect/, and these in turn contain further data,
such as a sequence of characters (`Norman Gray') in the case of the
<code/author/ element, or further elements (the <code/version/ element)
in the case of the <code/history/ element.  Elements are delimited by
`opening tags' like <code>&lt;abstract&gt;</code> and `closing tags'
like <code>&lt;/abstract&gt;</code>.<note>There is a difference
between `elements' and `element types': the former are things which
appear in documents, with data in them; the latter are the abstract
things defined by the DTD.  The distinction is not particularly
important outside of a DTD, however, so I will not continue to make it
in the description of the element types below.  It will always be
possible to make the distinction from the context anyway.</note>

<li>Elements have both <em/content/ and <em/attributes/.  For example,
the <code/author/ element has the characters `Norman Gray' as its
content and a list of strings such as an email address as its
attributes.

<li>Some of the elements (the <code/abstract/ element for example)
are closed (ie, have closing tags to match their opening tags), but
the majority are not.  This is because the DTD tells 
the parser that a <code/title/ element cannot contain an <code/author/
element, so the appearance of the latter implicitly finishes the
former.

<li>Some elements and attributes are required, others optional.  This
document is close to being a minimal SUN.  It is not quite minimal
because the <code/copyright/ element is optional, and it turns out
that the only <em/required/ content of a document 
body is the abstract!  Also, the only required attribute of the
<code/author/ element is the <code/id/ attribute.

<li>Starlink SGML documents are <em/case-sensitive/ (unlike most SGML
documents).  The element names must all be lowercase, and SGML
reserved words uppercase, as in this example.

<li>There are actually more elements present here than are apparent to
the eye.  As well as allowing some closing tags to be omitted, a DTD
can be allow certain <em/opening/ tags to be omitted, too.  In fact,
the full structure of this document is as seen in <ref
id=fig.simplesun2>.
</ul>
<figure float id="fig.simplesun2" export alt="Normalised SUN document">
<caption>A SUN document with all tags in place, the normalised version
of the document in <ref id=fig.simplesun>.</caption>
<px>
<verbatim><![ CDATA [
<sun>
<docinfo>
<title>The Starlink SGML set</title>
<authorlist>
<author email="norman@astro.gla.ac.uk" webpage="http://www.astro.gla.ac.uk/users/norman" affiliation="University of Glasgow" id="ng">Norman Gray</author>
</authorlist>
<docnumber>1234</docnumber>
<history>
<version number="0" date="21-APR-1999" author="ng">
<px>Initial version</px>
</version>
</history>
</docinfo>
<docbody>
<abstract>
<px>This is a sample SUN</px>
</abstract>
<sect id="intro" export>
<subhead>
<title>Introduction</title>
</subhead>
<p>Starlink SUNs are easy to write.</p>
</sect>
</docbody>
</sun>
]]></verbatim>
</figure>

<p>In <ref id=fig.simplesun2>, note that the actual content of
the <code/abstract/ element is one or more <code/px/ elements (a
slightly restricted variant of the standard <code/p/ paragraph
element), and that the <code/sect/ element contains a <code/subhead/
element, and <em/contains/ the paragraphs which constitute it (note
that this is a significant difference from HTML, where the heading
elements <code/hn/ contain only a section title).  You will rarely
have to be aware of these `hidden' tags when you are creating a
document, but it will occasionally be
useful to know that these tags are there somewhere, and that you're
glad you don't have to type all of them.
In fact, when I explain the document structure below, I will do it in terms
of the elements which are `really' there.

<p>`Markup minimisation', which is SGML's name for this, was
introduced to SGML to make typing less onerous.  Personally, I like
this, since it seems to make the document look less cluttered, and so
I have designed the DTD to support this quite extensively.  The
minimisation is completely optional, however, and you may insert all
the tags if you prefer.  SGML-aware editors (see <ref id=editors>)
typically insert all tags.  See also <ref id=markup.min>.

<p>You can see from <ref id=fig.simplesun2> that the `top-level'
element of this document is <code/sun/.  The top-level element of SSN
documents is <code/ssn/, and similarly for the other Starlink document
types (see <ref id=str.structure>).  These different document types
are broadly the same, but the 
SSN document type does not include elements for documenting
programming code, and the MUD document type has a <code/docdate/
element instead of a <code/docnumber/ and a <code/history/.  The SUN
document type is the most general.  The top-level <code/sun/ element
has only two `children', <code/docinfo/, which contains the document
information such as its author, number, and so on, and <code/docbody/,
which contains the actual content of the document.

<subsect id=markup.entities export>Entity references

<p>Entity references are a mechanism for referring to characters, or
longer pieces of text, which you cannot type on your keyboard, which
must be escaped from the parser, or which you simply want to
abbreviate.

<p>A reference to an entity <code/amp/ is of the form
<code/&amp;amp;/.  It is prefixed by the character <code/&amp/ and
suffixed by a semicolon.

<p>The list of entities predefined by the Starlink general DTD is
given in <ref id=table.entities>.

<table id="table.entities">
<caption>Entities predefined in the Starlink general DTD.</caption>
<tabular>
<tgroup cols="3">
<thead>
<row><entry>Entity reference<entry>Replacement<entry>Description
<tbody>
<row><entry><code>&amp;copy;</code><entry>&copy<entry>Copyright symbol
<row><entry><code>&amp;amp;</code><entry><code>&amp</code><entry>ampersand
<row><entry><code>&amp;gt;</code><entry><code>&gt</code><entry>greater-than symbol
<row><entry><code>&amp;lt;</code><entry><code>&lt</code><entry>less-than symbol
<row><entry><code>&amp;quot;</code><entry>&quot<entry>quotation mark
<row><entry><code>&amp;nbsp;</code><entry>&nbsp<entry>non-breaking space
<row><entry><code>&amp;hash;</code><entry>&hash<entry>hash sign
<row><entry><code>&amp;pounds;</code><entry>&pounds<entry>pounds sign
<row><entry><code>&amp;dollar;</code><entry>&dollar<entry>dollar sign
<row><entry><code>&amp;ellip;</code><entry>&ellip<entry>ellipses
<row><entry><code>&amp;emdash;</code><entry>&emdash<entry>em dash
<row><entry><code>&amp;endash;</code><entry>&endash<entry>en dash
<row><entry><code>&amp;percent;</code><entry>&percent<entry>percent sign
<row><entry><code>&amp;deg;</code><entry>&deg<entry>degrees symbol
<row><entry><code>&amp;tilde;</code><entry>&tilde<entry>tilde
<row><entry><code>&amp;underscore;</code><entry>&underscore<entry>underscore
<row><entry><code>&amp;latex;</code><entry>&latex<entry>&latex logo
<row><entry><code>&amp;tex;</code><entry>&tex<entry>&tex logo
</row>
</tbody>
</tgroup>
</tabular>
</table>

<p>Certain of these entities are used sufficiently often that there
are `short references' declared for them: you can type `<code/_/'
instead of <code/&amp;underscore;/ (unsurprisingly), `<code/&ddash/' for
a punctuation dash (this is currently set to <code/&amp;endash;/, but
could conceivably change to <code/&amp;emdash;/ if we make a
typographic decision on that score), and `<code/&tilde/' instead of
<code/&amp;nbsp;/.  These short references work within paragraphs, but
not within maths or verbatim elements within them.

<p>For more details on entities, see <ref id=sgml.entities>.

<subsect id=markup.dtdsubset export>Defining entities

<p>As explained in section <ref id=markup.entities>, there are a
number of predefined entities which you can refer to in your
documents.  These are defined either for general convenience or
because, as in the case of <code>&lt</code> and <code>&amp</code>,
the characters are significant to the SGML parser.

<p>You can, however, define entities yourself, perhaps to save typing,
or to parameterise a fragment of text which might change.  Also, you
would have to define an entity to refer to other files, or to other
SGML documents.

<p>You define entities in a section of the document which rejoices in
the name of the `document type declaration subset'.  This is a
fragment of SGML markup which is presented within the
<code>&lt;!DOCTYPE></code> declaration, which is formally read before
the reading of the actual DTD the declaration refers to.  There are
many things you can do within the DTD subset, up to and including a
partial rewrite of the DTD (this is generally felt to be A Bad Thing
-- do try to resist the temptation), but the main function of the DTD
subset in normal documents is to define a variety of types of
entities.  For more details about the DTD subset, see <ref
id=sgml.dtdsubset>.

<p>The DTD subset is the only place you can define entities -- the
<code>&lt;!ENTITY...></code> declaration is forbidden in the body of
the document.  While this is occasionally inconvenient, it helps keep
all the document's monkey-business in one place.

<subsubsect>Referring to text

<p>You can make an entity a shorthand for a piece of text which might
either need to be parameterised, or which it is simply inconvenient to
repeatedly retype.

<p>For example:

<verbatim><![CDATA[
<!DOCTYPE sun PUBLIC "-//Starlink//DTD Starlink SUN//EN" [
  <!ENTITY urlroot "http://www.astro.gla.ac.uk/users/norman">
]>
[...]
<p>Here is a <webref url="&urlroot;/star/" >web page</webref>
]]></verbatim>
When the document is parsed, the text for the entity
<code>urlroot</code> is substituted for the entity reference
<code>&amp;urlroot;</code>.

<subsubsect id=markup.files>Referring to files

<p>A feature of SGML's portability is that it abstracts the notion of
files: there are no `files' and `filenames' in the SGML world, only
<em/external entities/ which have <em/public identifiers/ or <em/system
identifiers/.  You can refer to these external entities as follows:
<verbatim><![CDATA[
<!DOCTYPE sun PUBLIC "-//Starlink//DTD Starlink SUN//EN" [
  <!ENTITY chapter1 SYSTEM 'chaptext/chapter1.text'>
  <!ENTITY fig1.eps SYSTEM 'figure1.eps' NDATA eps>
  <!ENTITY fig1.gif SYSTEM 'figure1.gif' NDATA gif89a>
  <!ENTITY sun199 
        PUBLIC "-//Starlink//DOCUMENT Summary SUN/199//EN" SUBDOC>
]>
]]></verbatim>

<p>There are four entities described here.

<p>`chapter1' is a reference to the object with system
identifier <code>chaptext/chapter1.text</code>.  A system identifier
can refer to an object in a wide variety of ways -- it could be a
database query, or system command -- but in the present system, a
system identifier is just a filename.  When you refer to this entity
by making the reference <code/&amp;chapter1;/ where you might
otherwise type text, the SGML system would insert the contents of the
specified file in the document at that point.  This is a way of
breaking your document up into a collection of smaller documents.

<p>The two entities `fig1.eps' and `fig1.gif' are also references to
the two files `figure1.eps' and `figure1.gif' -- note the distinction
between the entity name and the file name.  These entity declarations
have extra information, however, indicating that their <em/notation/
is <code/eps/ and <code/gif87a/ respectively.  The system currently
recognises these notations, plus `jpeg'.  You would refer to these
entities in an attribute of a <code/figurecontent/ element.  For more
details on how to refer to figure files, see <ref id=str.figures>, and
for the list of allowable notations, see the <code/figurecontent/
documetation in <ref id=el.sun.figurecontent>.

<p>The last entity is different in two ways.  Firstly, it does not refer
to a system identifier, but to a <em/public identifier/.  The SGML
system maps this identifier into a file using some internal database.
Note that the reference to the DTD, <code>"-//Starlink//DTD Starlink
SUN//EN"</code> is also a public identifier.  Secondly, the keyword
<code/subdoc/ indicates that this entity is a <em/subdocument/ entity
-- a complete SGML document which the SGML system will have to parse
at some point.  In this case, the entity <code/sun199/ has been
declared so that it can be cross-referenced at some point.  See <ref
id=str.xrefs> for details.

<subsect id=markup.min export>Markup minimisation

<p>SGML was designed to be readable by computers, but it was also
designed to be written by humans<note>This is unlike XML, which is
likely to be written largely by authoring programs</note>.  It
therefore has several features -- collectively referred to as
<em/markup minimisation/ -- designed to cut down the amount of
markup you have to write.

<p>The first such minimisation feature is tag omission: in certain
circumstances you may omit tags which are formally redundant.  This
can happen only when the SGML parser can reliably infer the presence
of the omitted tags, and when the DTD author has permitted this.  For
example, the content of the <ref id=el.sun.sect text='sect'>
element is a subhead element, followed by zero or more paragraphs (or
figures or tables), followed by zero or more subsect elements.  That
is, the sect element <em/contains/ the section, rather than containing
just the title (as is the case for HTML's <code/H1/ element, for
example).  The <ref id=el.sun.subhead text='subhead'> element
contains a <ref id=el.sun.title text='title'> element, which
finally contains the text of the section heading.  In other words, the
structure of a section is
<verbatim><![CDATA[
<sect>
  <subhead>
    <title>Section 1</title>
  </subhead>
  <p>Paragraph text</p>
</sect>
<sect>
  ... <!-- and so on -->
]]></verbatim>
<p>This would be tedious to type.  However, the parser can infer the
end of the section and paragraph elements (from the start of the next
section and the end of the current section respectively), so those
closing tags can be omitted; and since the section
<em/must/ start with a subhead, which <em/must/ start with a title,
those tags are redundant, too.  That means that this can be compressed
to just
<verbatim><![CDATA[
<sect>Section 1
<p>Paragraph text
<sect>
...
]]></verbatim>

<p>Many closing tags can be omitted, and a few opening tags, too
(apart from subhead, about the only other one is <ref
id=el.sun.px text='px'> since it is the only permissable content
of elements like <ref id=el.sun.abstract text='abstract'>).  If
you include tags redundantly it doesn't matter (and may even make the
text clearer in some cases), and if you omit them erroneously, the
SGML parser will quickly tell you.

<p>In cases where tags cannot be omitted, you can still cut down the
amount you have to type.  Instead of typing <code>&lt;em>emphasised
text&lt;/em></code>, you can type just <code>&lt;em/emphasised
text/</code>.<note>This much is a convenient shortcut. SGML defines
other tag minimisation locutions, so that
<code>&lt;p&lt;em/emph/&lt;/></code> is legal.  This rarely improves
readability, can get you into terrible messes, and is part of the
`parser hell' which XML was designed to avoid.  I mention it purely
for completeness.</note>

<p><update versionid="post-0.2">Added note to the effect that
attribute names can be minimised when the value is from a set</update>
In certain cases, attributes may have only one of a limited set of
values.  In this case, specifying one of these values is enough to
indicate which attribute you are referring to.  For example, the <ref
id=el.sun.figure text='figure'> element has a `float' attribute, which
can take either of the values `float' or `nofloat'.  You might
normally specify it as <code>&lt;figure float="nofloat"></code>, but
since the attribute values come from a limited set, this can be
abbreviated to <code>&lt;figure nofloat></code>.  The same is true of
the `export' attribute associated with exported IDs.

<p>SGML also has single-character entity references.  The character
<code><![CDATA[~]]></code> in normal text turns into the entity
<code/&amp;nbsp;/, and <code><![CDATA[--]]></code> (two hyphens) turns
into <code/&amp;endash;/.  Such `short reference' characters are used
a little more in the programcode DTD (see <ref id=doccode>).

<subsect id=markup.ms export>Marked sections

<update versionid="post-0.2">Section added, with text
relocated from appendix. 

<p>A feature you will occasionally use in documents is the `marked
section'.  As an author, you will most likely only ever use the
<code/CDATA/ marked section, but the <code/IGNORE/ and <code/INCLUDE/
marked sections might also be useful, as well as being common within DTDs.

<p>A marked section is a construction such as
<verbatim>
Here is some text &lt;![ CDATA [ with &lt;odds&gt; &amp sods &rsqbrack;]>
</verbatim>
and
<verbatim>
Here is some text &lt;![ IGNORE [ and here is some ignored text &rsqbrack;]>
</verbatim>
Along with <code/IGNORE/ there is <code/INCLUDE/.

<p>The marked section ends at the sequence of characters
<code/&rsqbrack;&rsqbrack;&gt;/, which is therefore the one sequence
which cannot appear within the marked section.

<p>There are some further technical details in <ref id=sgml.ms>.

<subsubsect id=markup.ms.cdata>CDATA marked sections

<p>Within the <code/cdata/ marked section, parsing is switched off, so
that angle brackets, <code/&lt/, and ampersands, <code/&amp/, are no
longer recognised as introducing markup and entity references.

<p>You will typically use a <code/CDATA/ marked section to delimit
verbatim text.  The <code/code/ and <code/verbatim/ elements (see <ref
id=el.sun.code> and <ref id=el.sun.verbatim>) do not make any
provision to switch off parsing of the text within them.  If the text
would be significant to the parser -- that is, if it contains angle
brackets or ampersands -- you must either escape those characters by
giving them as entity references <code/&amp;lt;/ or <code/&amp;amp;/,
or else enclose the contents in a <code/CDATA/ marked section as
follows.
<verbatim>
&lt;verbatim>&lt;![ CDATA [
Here is some &lt;em>marked-up&lt/em> text
which will be skipped &amp; ignored
&rsqbrack;&rsqbrack>&lt;/verbatim>
</verbatim>
Within a CDATA marked section, no markup is recognised except the
<code/&rsqbrack;]>/ which closes the marked section; thus element
start- and end-tags are not parsed, and entity references not expanded.

<subsubsect id=markup.ms.variants>Paper-only and web-only variants

<p>Text within <code/INCLUDE/ and <code/IGNORE/ marked sections is
parsed or skipped by the parser, as appropriate.  They are <em/not/
often used outside of DTDs, but the <code/IGNORE/ marked section
is occasionally useful as a way of `commenting out' large sections of
text which might itself include SGML comments <code><![CDATA[<!--
... -->]]></code>.

<p>Sometimes, it is necessary to have parts of your document which
vary depending on whether the document is to be viewed on paper or
online.  The Starlink general DTD defines two parameter entities
<code/&percent;Only.paper/ and <code/&percent;Only.web/, which you can
use to include or ignore text in a marked section.  By default, both
of these are set to the string 
`IGNORE', but when you use the <code/sgml2docs/ script (see <ref
id=proc.sgml2docs>), one or the other of these will be set to `include', as
appropriate for the type of file being generated.

<p>You would use this facility as follows:
<verbatim>
&lt;p>Here is some text.
&lt;![ %Only.web [ And here is some which would appear
only in webpages. &rsqbrack;&rsqbrack;>
</verbatim>

<p>It is, I hope, clear that you could get yourself in a terrible mess
here, and create a document which is only valid for some settings of
the entities.  Take care that your document remains valid for all
settings, <em/including/ the case where both entities are set to `IGNORE'.


<subsect id=markup.try export>Try it yourself -- running the SGML parser

<p>Type the document given in <ref id=fig.simplesun> into a file, and
check it with the distributed SGML parser, as follows.  If the
document is in a file <code/sun1234.sgml/, then give the command
<kbd>nsgmls -s sun1234.sgml</kbd>.  This invokes the <code/nsgmls/
parser, and, with the <code/-s/ option, suppresses all output except
warnings and error messages.  This means that for a valid document,
you should see precisely no output from this command.  If you want to
see output, leave off the <code/-s/ option and the parser will produce
a version of your document in a form which is easy for a downstream
application to parse.  There are, for example, Perl libraries (for
example <code/SGMLSpm/, which should be on CPAN) which
will parse this output format and allow you to process SGML documents
using Perl.  The crucial thing in this case is the final line in
the output, which should be a single `C' command, indicating that the
document conforms to its DTD.

<p>If you want to try normalising your document, give the command
<kbd>sgmlnorm sun1234.sgml</kbd>.  This transforms your document into
an equivalent one with all omitted elements reinserted.

<p>Finally, and most importantly, try converting your document to
HTML.  This uses the script <code/sgml2docs/.  Give the command
<kbd/sgml2docs sun1234.sgml/, which will transform your document into
a collection of HTML files, and package them up into a tar-file by the
name of <code/sun1234.tar-htx/.  Alternatively, give the command
<kbd/sgml2docs --latex sun1234.sgml/, which will transform your
document into a &latex; file, and place it, and any figures required
for processing into a file <code/sun1234.tar-latex/.
See <ref id=proc.sgml2docs> for further details.  

<!--
<p>Finally, try converting your document to HTML.  This uses the
program Jade, which is an implementation of the DSSSL formatting
language.  Give the command 
<kbd>jade -t sgml -d
$STARLINK_SGML_DIR/dsssl/sl/html/sl.dsl#html sun1234.sgml</kbd>.  This
will parse your document, and convert it to a collection of HTML
files, with the master file named <code/SUN-1234.html/ (this name is based
on the information in the document, and is independent of what your
source file is actually called).  The command actually spits out a
line of text to the standard output; this is because the SGML set is
designed to be used from within a Makefile (see <ref id=proc.makefile>) rather
than directly from the command line.

<p>You can also convert your document to &latex;, with the command 
<kbd>jade -t latex -d $STARLINK_SGML_DIR/dsssl/sl/latex/sl.dsl#latex
sun1234.sgml</kbd>.
-->

<p>Try making parts of your document invalid, and comparing the error
with the error message <code/nsgmls/ produces.


<sect id=structure export>The structure of the document

<p>In this section I will describe all of the elements of the General DTD,
grouping them by type.  There is an alternative description of the
elements, listed alphabetically, in <ref id=appx.general.dtd>.

<p>The elements are thematically grouped in <ref id=table.elements>,
and each of these groups is discussed in the indicated section.  Note
that the discussion there is intended to provide an overview of the
possibilities provided by the group, and it does not necessarily
describe all of the functionality available; see the individual
element listings for further details.

<p>Remember that the markup of your document is quite distinct from
its processing, so that not all elements and attributes will
necessarily have a detectable effect on the output (ie, formatted)
document you produce.  Nonetheless, you should future-proof your
document by including as much element and attribute detail as you can.

<table id=table.elements float>
<caption>
<px>DTD elements, grouped by type.
<px>Note that a few elements appear in more than one group.
</caption>
<tabular>
<tgroup cols="2">
<thead><row><entry>Group<entry>Elements
<tbody>
<row>
<entry>
<ref id=str.structure>
<entry>
<ref id='el.sun.abstract' text='abstract'>,
<ref id='el.sun.appendices' text='appendices'>,
<ref id='el.sun.author' text='author'>,
<ref id='el.sun.authorlist' text='authorlist'>,
<ref id='el.sun.copyright' text='copyright'>,
<ref id='el.sun.coverimage' text='coverimage'>,
<ref id='el.sun.docbody' text='docbody'>,
<ref id='el.sun.docinfo' text='docinfo'>,
<ref id='el.sun.docnumber' text='docnumber'>,
<ref id='el.sun.editors' text='editors'>,
<ref id='el.sun.keyword' text='keyword'>,
<ref id='el.sun.otherauthors' text='otherauthors'>,
<ref id='el.sun.sun' text='sun'>,
<ref id='el.sun.title' text='title'>

<row>
<entry>
<ref id=str.sect>
<entry>
<ref id='el.sun.sect' text='sect'>,
<ref id='el.sun.subhead' text='subhead'>,
<ref id='el.sun.subsect' text='subsect'>,
<ref id='el.sun.subsubsect' text='subsubsect'>,
<ref id='el.sun.subsubsubsect' text='subsubsubsect'>
<ref id='el.sun.title' text='title'>

<row>
<entry>
<ref id=str.backmatter>
<entry>
<ref id='el.sun.backmatter' text='backmatter'>,
<ref id='el.sun.citation' text='citation'>,
<ref id='el.sun.index' text='index'>,
<ref id='el.sun.note' text='note'>
<!--
<ref id='el.sun.bibliography' text='bibliography'>,
<ref id='el.sun.indexcontents' text='indexcontents'>,
<ref id='el.sun.notecontents' text='notecontents'>
-->

<row>
<entry>
<ref id=str.code>
<entry>
<ref id='el.sun.codecollection' text='codecollection'>,
<ref id='el.sun.routinelist' text='routinelist'>

<row>
<entry>
<ref id=str.history>
<entry>
<ref id='el.sun.change' text='change'>,
<ref id='el.sun.distribution' text='distribution'>,
<ref id='el.sun.docdate' text='docdate'>,
<ref id='el.sun.history' text='history'>,
<ref id='el.sun.update' text='update'>,
<ref id='el.sun.version' text='version'>

<row>
<entry>
<ref id=str.xrefs>
<entry>
<ref id='el.sun.docxref' text='docxref'>,
<ref id='el.sun.ref' text='ref'>,
<ref id='el.sun.url' text='url'>,
<ref id='el.sun.webref' text='webref'>

<row>
<entry>
<ref id=str.figures>
<entry>
<ref id='el.sun.caption' text='caption'>,
<ref id='el.sun.figure' text='figure'>,
<ref id='el.sun.figurecontent' text='figurecontent'>

<row>
<entry>
<ref id=str.tables>
<entry>
<ref id='el.sun.caption' text='caption'>,
<ref id='el.sun.colspec' text='colspec'>,
<ref id='el.sun.entry' text='entry'>,
<ref id='el.sun.row' text='row'>,
<ref id='el.sun.table' text='table'>,
<ref id='el.sun.tabular' text='tabular'>,
<ref id='el.sun.tbody' text='tbody'>,
<ref id='el.sun.tgroup' text='tgroup'>,
<ref id='el.sun.thead' text='thead'>

<row>
<entry>
<ref id=str.text>
<entry>
<ref id='el.sun.attribution' text='attribution'>,
<ref id='el.sun.blockquote' text='blockquote'>,
<ref id='el.sun.cite' text='cite'>,
<ref id='el.sun.code' text='code'>,
<ref id='el.sun.dd' text='dd'>,
<ref id='el.sun.dl' text='dl'>,
<ref id='el.sun.draftnote' text='draftnote'>,
<ref id='el.sun.dt' text='dt'>,
<ref id='el.sun.em' text='em'>,
<ref id='el.sun.kbd' text='kbd'>,
<ref id='el.sun.li' text='li'>,
<ref id='el.sun.line' text='line'>,
<ref id='el.sun.linespecific' text='linespecific'>,
<ref id='el.sun.ol' text='ol'>,
<ref id='el.sun.p' text='p'>,
<ref id='el.sun.px' text='px'>,
<ref id='el.sun.quote' text='quote'>,
<ref id='el.sun.strong' text='strong'>,
<ref id='el.sun.ul' text='ul'>,
<ref id='el.sun.verbatim' text='verbatim'>

<row>
<entry>
<ref id=str.maths>
<entry>
<ref id='el.sun.m' text='m'>,
<ref id='el.sun.meqnarray' text='meqnarray'>,
<ref id='el.sun.mequation' text='mequation'>,
<ref id='el.sun.mlabel' text='mlabel'>,
<ref id='el.sun.mline' text='mline'>

</tbody>
</tgroup>
</tabular>
</table>

<subsect id=str.structure export>Overall structure

<p>Includes
<ref id='el.sun.sun' text='sun'> (or whatever top-level element is
appropriate for the document type), which contains 
<ref id='el.sun.docinfo' text='docinfo'> and
<ref id='el.sun.docbody' text='docbody'>.  The former contains
<ref id='el.sun.abstract' text='abstract'>,
<ref id='el.sun.author' text='author'>,
<ref id='el.sun.authorlist' text='authorlist'>,
<ref id='el.sun.copyright' text='copyright'>,
<ref id='el.sun.coverimage' text='coverimage'>,
<ref id='el.sun.docnumber' text='docnumber'>,
<ref id='el.sun.editors' text='editors'>,
<ref id='el.sun.keyword' text='keyword'>,
<ref id='el.sun.manualtype' text='manualtype'>,
<ref id='el.sun.otherauthors' text='otherauthors'>,
<ref id='el.sun.softwareversion' text='softwareversion'>,
<ref id='el.sun.title' text='title'>; and the latter contains the body
text, the backmatter, and the
<ref id='el.sun.appendices' text='appendices'>.

<p>An SGML document always starts with a doctype declaration.  There
are seven document types defined at present:
<verbatim><![CDATA[
<!DOCTYPE sug PUBLIC "-//Starlink//DTD Starlink SUG//EN">
<!DOCTYPE sun PUBLIC "-//Starlink//DTD Starlink SUN//EN">
<!DOCTYPE ssn PUBLIC "-//Starlink//DTD Starlink SSN//EN">
<!DOCTYPE sgp PUBLIC "-//Starlink//DTD Starlink SGP//EN">
<!DOCTYPE sc  PUBLIC "-//Starlink//DTD Starlink SC//EN">
<!DOCTYPE sg  PUBLIC "-//Starlink//DTD Starlink SG//EN">
<!DOCTYPE mud PUBLIC "-//Starlink//DTD Starlink MUD//EN">
]]></verbatim>
These cover, respectively, the Starlink User Guide, Starlink user
notes, system notes, general papers, cookbooks, and guides, and
Miscellaneous User Documents.  These document types are broadly the
same (there is a single DTD underlying them all), but the different
types have different features, summarised in <ref
id=table.dtdfeatures>.

<table id=table.dtdfeatures>
<caption>
Starlink DTD feature summary
</caption>
<tabular>
<tgroup cols="6">
<thead>
<row>
<entry>DTD
<entry>Abstract<entry>Versioning<entry>Docnumber<entry>Routinelist<entry>EnforceLinkPolicy
<tbody>
<row>
<entry>sug
<entry>yes<entry>yes<entry>no<entry>no<entry>yes
<row>
<entry>sun
<entry>yes<entry>yes<entry>yes<entry>yes<entry>yes
<row>
<entry>ssn
<entry>yes<entry>yes<entry>yes<entry>no<entry>yes
<row>
<entry>sgp
<entry>yes<entry>yes<entry>yes<entry>no<entry>yes
<row>
<entry>sc
<entry>yes<entry>yes<entry>yes<entry>no<entry>yes
<row>
<entry>sg
<entry>yes<entry>yes<entry>yes<entry>no<entry>yes
<row>
<entry>mud
<entry>opt'l<entry>no<entry>yes<entry>no<entry>no
</tbody>
</tgroup>
</tabular>
</table>

<p>The table headings in <ref id=table.dtdfeatures> are as follows:
<dl>
<dt>Abstract
<dd>Is an abstract required or optional.
<dt>Versioning
<dd>Is the history mechanism, described in <ref id=str.history>
required?  If not, the <ref id=el.sun.docdate text='docdate'>
element is required.
<dt>Docnumber
<dd>Is a document number required?
<dt>Routinelist
<dd>Are the code-documentation elements, described in <ref
id=str.code> available?
<dt>EnforceLinkPolicy
<dd>Is the link policy enforced?  See <ref id=str.xrefs>.
</dl>

<p>These defaults are generally appropriate for the type of document.
If you need to change them for a particular document, however, you
can.  The only case where you are likely to need to change the
default is in in the case of the routine-list feature, if you wish to
add it to a document type which does not have it by default, and you do this by
invoking the SSN DTD (for example) as follows
<verbatim><![CDATA[
<!DOCTYPE ssn PUBLIC "-//Starlink//DTD Starlink SSN//EN" [
  <!ENTITY % Feature.Routinelist 'include'>
]>
]]></verbatim>
Note that the entity names are case-sensitive.

<p>The top-level element in the document contains two elements, <ref
id=el.sun.docinfo text='docinfo'> and <ref id=el.sun.docbody
text='docbody'>. The second contains all the text of the document, and
the first all the `meta-information' -- the author, title, keywords,
and so on, which are important for identifying and indexing the
document.  The docinfo elements should be self-explanatory, with the
exception of the history element, which is discussed in <ref
id=str.history>.

<p>The docbody element contains all the text of the document,
optionally preceded by paragraphs and tables.  Any document appendices
are gathered together in a single <ref id=el.sun.appendices
text='appendices'> element, with each appendix in a <ref
id=el.sun.sect text='sect'> element, optionally preceded by a <ref
id=el.sun.routinelist text='routinelist'> element (see <ref
id=str.code>), if the specific DTD allows that.

<p>Material such as a bibliography and endnotes do not go in an
appendix, but in a separate backmatter element (see <ref
id=str.backmatter>).

<subsect id=str.sect export>Sectioning

<p>Includes
<ref id='el.sun.sect' text='sect'>,
<ref id='el.sun.subsect' text='subsect'>,
<ref id='el.sun.subsubsect' text='subsubsect'>
and
<ref id='el.sun.subsubsubsect' text='subsubsubsect'>,
which contain the section contents, preceded by 
<ref id='el.sun.subhead' text='subhead'>, which contains the section
<ref id='el.sun.title' text='title'>.

<p>The sect element and friends contain the section content (note
that this is different to the behaviour of &latex and HTML, in both of
which the sectioning commands enclose only the section heading).

<p>The content of the sectioning elements start with a <ref
id=el.sun.subhead text='subhead'> element, which in
turn contains a <ref id=el.sun.title text='title'> element, and the
two are followed by the section 
content. Note, however, that since the subhead and title start and end
tags are both omissable (see <ref id=markup.min>), you may omit both,
and follow the sect start 
tag immediately with the section title.
That is, the structure is formally
<verbatim><![CDATA[
<sect><subhead><title>Section title</title><subhead>
<p>Section body</p>
</sect>
]]></verbatim>
but this may be abbreviated to just
<verbatim><![CDATA[
<sect>Section title
<p>Section body
]]></verbatim>

<p>The sectioning elements have an ID attribute, which allows you to
specify a unique label with which you can refer to the section.  For
both the sect and subsect elements, this ID attribute is required by
the DTD (when the <code>EnforceLinkPolicy</code> feature is enabled --
see <ref id=str.structure>).  See also <ref id=str.xrefs> for more
detail on cross-referencing.

<subsect id=str.backmatter export>Backmatter -- notes and bibliography
<update versionid="post-0.2">
Removed mention of the deleted backmatter content elements</update>
<update versionid="post-v0-5">Emphasised that notes will not appear
unless backmatter element is present</update>

<p>The
<ref id='el.sun.backmatter' text='backmatter'> element
<!--
includes the
<ref id='el.sun.bibliography' text='bibliography'>,
<ref id='el.sun.indexcontents' text='indexcontents'> and
<ref id='el.sun.notecontents' text='notecontents'>
elements, stocked by
-->
is stocked by the 
<ref id='el.sun.citation' text='citation'>,
<ref id='el.sun.index' text='index'> and
<ref id='el.sun.note' text='note'>
elements.

<p>Within your document you may refer to books and articles using the
citation element, and these are collected together in the backmatter
element.  The DTD is quite generic, but in this application, the
bibliography is implemented as a Bib&tex database, so that the
backmatter element's `bibliography' attribute names a Bib&tex
<code>.bib</code> file (without the <code/.bib/ extension), and the
citation element's content is a Bib&tex entry key.  Note that the
Bib&tex; processing of your document is done within the context of a
temporary work directory (see <ref id=proc.sgml2docs>), so you might have
to specify Bib&tex;'s <code/BIBINPUTS/ environment variable if
Bib&tex; is to find your bibliography database.  There is no way (at
present) to specify the bibliography formatting style -- the SGML set
uses a customised bibliography style which, incidentally, supports a
URL field in bibliography entries.  See the Bib&tex documentation in,
for example, <citation/lamport/ for further details.

<p>You can include notes in your document with the note element.
At present, the notes are presented as footnotes in
the paper version of your document and collected together as endnotes
in the online version.
<!--
Note that since the notes are collected within
the backmatter element, the notes <em/will not be printed/ unless
a backmatter element is present.
-->

<p>Although the indexing support is defined in the DTD, there is not
yet any application support for it.  It is likely to use the
<code/makeindex/ system associated with &latex;.

<subsect id=str.code export>Documenting code

<p>The 
<ref id='el.sun.routinelist' text='routinelist'>
element contains one or more
<ref id='el.sun.codecollection' text='codecollection'>
elements.

<p>The routinelist element must be the first child of the <ref
id=el.sun.appendices text='appendices'> element, and contains one or
more codecollection elements, each of which makes a link between the
general documentation and a specific file marked up using the
<code/programcode/ DTD.  See <ref id=doccode> for details.

<p>These elements are available only if the document type has the
`Routinelist' feature enabled.  See <ref id=str.structure>.

<subsect id=str.history export>History

<p>Includes
<ref id='el.sun.change' text='change'>,
<ref id='el.sun.distribution' text='distribution'>,
<ref id='el.sun.docdate' text='docdate'>,
<ref id='el.sun.history' text='history'>,
<ref id='el.sun.update' text='update'>,
<ref id='el.sun.version' text='version'>.

<p>In a large document which will be revised in future, it is
important to preserve some document history.  This means that readers
can check which version of a document, and find what features of it
have changed since the last version they are familiar with.

<p>The history element, within in the docinfo element (see <ref
id=str.structure>), records the history of the document.  It is
available in most of the Starlink DTDs, but not all, and when it is
omitted, the <ref id=el.sun.docdate text='docdate'> element is
required instead.

<p>The history of a document is composed of a sequence of versions,
changes, and distributions.  A document has a version number of the
form <code/docnumber.docversion-release/.  The document number is the
number declared in the <ref id=el.sun.docnumber text='docnumber'>
element, as assigned by the Starlink librarian.  The document version
indicates which edit of the document this is -- a significant update
to the document should be marked by incrementing the document version
number.  The release information marks a more minor update to a
document.

<p>Each of the three elements has paragraph content, to record brief notes
about the change or distribution.

<p>A version of a document (marked by a <ref id=el.sun.version
text='version'> element in the history) is a significant release of a
document, perhaps describing new functionality in a package.  The
number attribute gives the version number to be attached to the
document.

<p>A distribution of a document (marked by a <ref
id=el.sun.distribution text='distribution'> element in the history) is
a less significant update to a document, perhaps for distribution to
readers for comments.  The <code/string/ attribute is a label for the
distribution, and could be something like `draft1' or `comments-13'.

<p>Other changes to the document are labelled by a <ref
id=el.sun.change text='change'> element.  These record an edit of a
document without a corresponding change to an version number.

<p>The <ref id=el.sun.distribution text='distribution'> and <ref
id=el.sun.change text='change'> elements have an optional
<code/versionid/ attribute.  This allows you to specify a label for
this edit.  Any <ref id=el.sun.update text='update'> elements
elsewhere in the text must attach themselves to one of these elements,
using the <code/versionid/ attribute.

<p>For example:
<verbatim><![ CDATA [
<author id=ng>Norman
<editors>
<author id=mb>Martin
...
<history>
<version author=ng date='02-MAR-1999' number=0>Initial version
<distribution author=ng date='03-MAR-1999' string='comm-0.1'>Released
  to programmers for comment.
<change author=ng date='04-MAR-1999' versionid=post-0.1>Various tidyings
<version author=mb date='05-MAR-1999' number=1>First public release
...
<p><update versionid=post-0.1>Corrected typos and reexpressed
argument</update>In this section....
]]></verbatim>
Presumably, the `comm-0.1' release of the document elicited some
comments, and the resulting changes have been logged by the change
element immediately following it.  Any (optional) update elements
scattered throughout the document (they can be children of the list
structures, figures, tables, paragraphs, and the document body itself)
can link back to this element to inherit its authorship and date.
These updates could be collected together by an application, to
generate a change log, or a `new in this release' section.

<subsect id=str.xrefs export>Cross-references
<update versionid="v0.6">Noted that the stylesheets deal gracefully
with missing FPIs</update>

<p>Includes
<ref id='el.sun.docxref' text='docxref'>,
<ref id='el.sun.ref' text='ref'>,
<ref id='el.sun.url' text='url'>
and
<ref id='el.sun.webref' text='webref'>.

<p>Writing a document, you frequently wish to refer to other parts of
the same or other documents, or else to documents scattered around the
web.

<p>The cross-reference element you will use most often is the <ref
id=el.sun.ref text='ref'> element, which refers to another part of the
same document.  It takes a required `id' attribute, giving the ID of
the element you wish to refer to; any element with an ID attribute may
be referred to.  This will produce a named reference to the target
element, based on the type and name of that element, and will make a
link to it if the output format allows that.  If you wish, you can
override the link text by giving the `text' attribute.  For example,
the above link to the ref element's documentation was specified as
<code>&lt;ref id=el.sun.ref text='ref'></code>.

<p>The <ref id=el.sun.docxref text='docxref'> element refers to all or
part of another Starlink document.  To use this, you must declare an
entity which refers to the document as follows:
<verbatim>
&lt;!DOCTYPE sun PUBLIC "-//Starlink//DTD Starlink SUN//EN" [
  ...
  &lt;!ENTITY otherdoc 
    PUBLIC "-//Starlink//DOCUMENT Summary SUN/123//EN" subdoc>
  ...
]>
</verbatim>
Once you have done that, you can refer to that document with a docxref
element, <code>&lt;docxref doc=otherdoc></code>.  If you wish, you can
refer to a specific ID within that document using the `loc'
attribute.  

<p>In general, the SGML kit will be set up so that this `formal public
identifier' (FPI) will map to a summary document which will allow the
SGML system to effectively query the target document.  At present,
however (release DR-0.6), it has been decided to distribute the kit
with these document summaries missing, and so the down-converters have
been written so that they fail gracefully and silently in this case,
and generate a link to the Starlink documents available at RAL <em/if/
the FPI is declared in this correct format.  Jade will <em/warn/ you
about its inability to resolve the FPI, but this can be ignored. See
<ref id=appx.system.summaries> for maintainer-level discussion of
document summaries.

<p>When linking to other Starlink documents, you may only link to IDs
which have been `exported' from the document; by the same mechanism,
others may only link to IDs which you have exported from your
document.  You export an ID by giving the attribute `export' alongside
the `id' attribute.  To ensure that there is a rich field of targets
for other documents (see also <docxref doc=sun188
loc=establishing_cross_references>), most of the Starlink document
types enforce a `link policy' (see the `EnforceLinkPolicy' feature in
<ref id=str.structure>), requiring that <em/all/ sect and subsect
elements (at least) have both the `id' and `export' attributes
present.  Note that the export attribute must be explicitly present --
it is not automatically inserted or assumed -- even though it is
redundant when it is mandatory.  The `export' attribute is thus both
an indication to the processing system that it may link to this
element from outside, and an explicit warning to future
maintainers of the document that they should not delete or change this
ID.

<p>The <ref id=el.sun.webref text='webref'> and <ref id=el.sun.url
text='url'> elements are straightforward: they both refer to a
resource on the web.  The webref element is much like HTML's <code/a/
element, providing link text and a URL for the target; the url element
quotes the URL directly.

<p>As rather a special case, these cross-reference elements are
allowable in the <ref id=el.sun.verbatim text='verbatim'> element,
which is occasionally quite useful.  For example, the contents of <ref
id=figure.programcode> makes extensive use of this, to link from the
element names to their documentation in <ref
id=appx.programcode.dtd>.  This application uses the ref element's
text attribute, and the result is that the link disappears in the
paper version of the document.  I don't imagine that the docxref
element would often be useful here, but url and webref might be.

<subsect id=str.figures export>Figures
<update versionid=v0-4>Rewrote section to match new figures structure</update>

<p>Includes
<ref id='el.sun.figure' text='figure'>,
<ref id='el.sun.caption' text='caption'> and
<ref id='el.sun.figurecontent' text='figurecontent'>.

<p>You may include images and other figures within your document using
the figure element.  A figure consists of a caption, optionally
followed by a sequence of figurecontent elements, optionally followed
by a single block of PX elements.  You provide a figurecontent element
for each alternative figure format you provide.  The processing system
selects a usable format from; not all processors can use all formats,
so that it would be desirable to provide an image in both EPS and GIF
format, if you can.

<p>You can provide paragraphs of text (perhaps containing a <ref
id=el.sun.verbatim text='verbatim'> element) as figure content.

<p>For details, and an example, see <ref id=el.sun.figurecontent>.

<subsect id=str.tables export>Tables
<update versionid="v0-4">Include description of new tabular element</update>
<update versionid="post-v0-4">
Clarified description of tabular element, and linebreaks.</update>


<p>Includes
<ref id='el.sun.caption' text='caption'>,
<ref id='el.sun.colspec' text='colspec'>,
<ref id='el.sun.entry' text='entry'>,
<ref id='el.sun.row' text='row'>,
<ref id='el.sun.table' text='table'>,
<ref id='el.sun.tabular' text='tabular'>,
<ref id='el.sun.tbody' text='tbody'>,
<ref id='el.sun.tgroup' text='tgroup'>,
<ref id='el.sun.thead' text='thead'>.

<p>The table element contains a tabular element.  The distinction
between the two is that the tabular is the object which contains data
lined up in columns, whilst the table is an object which might float
from its declared position, which has a caption, and
which can be referred to from elsewhere.

<p>The tabular element will most commonly be used within a table
element, but it is also permissible within ordinary paragraphs.  Note,
however, that the tabular element does not necessarily have a
linebreak before and after it in this case.  If you want the tabular
to go on a line by itself (which will usually be the case, you should
include it within a <ref id='el.sun.blockquote' text='blockquote'>
element.

<p><update versionid="post-0.2">Corrected Oasis URL</update>
The Starlink DTDs use the <webref
url='http://www.oasis-open.org/html/a503.htm' >Oasis
Exchange Table Model</webref> as the basis for their tables.  Even
though it is only a portable subset of a more elaborate standard (the
industry-standard CALS table model), there is more in the table model
than has yet been implemented in the Starlink application.

<p>In the current release of the Starlink SGML set, all of the
elements and attributes in the Oasis model are permitted in the
documents you write, but most of the attributes are ignored.  Support
for these will likely be added in future releases, but the only real
inconvenience is that there is currently no control over column
alignment.  Please let me know which features you would like to be
given priority.

<p>You lay out a table as follows:
<verbatim><![CDATA[
<table id="table.entities">
<caption>Entities predefined in the Starlink general DTD.</caption>
<tabular>
<tgroup cols="3">
<thead>
<row><entry>Entity reference<entry>Replacement<entry>Description
<tbody>
<row><entry><code>&amp;copy;</code><entry>&copy<entry>Copyright symbol
<row><entry><code>&amp;amp;</code><entry><code>&amp</code><entry>ampersand
</tabular>
</table>
]]></verbatim>
You specify an ID for the table, and optionally also the `export'
attribute, in the table start tag.  A tabular can have a number of
groups of rows, specified by tgroup elements, and it is in the
start-tag of that element that you specify the number of columns in
rows in that group.  A group of rows consists of an optional group of
heading rows, followed by one or more groups of body rows.  Each row
consists of a sequence of entry elements.

<p>For more detailed documentation, including documentation of the
currently unsupported features, see the Oasis documentation referred
to above.

<subsect id=str.text export>Text markup

<p>Paragraphing
(<ref id='el.sun.p' text='p'> and
<ref id='el.sun.px' text='px'>): element p is the normal paragraph,
element px is a restricted paragraph used in the abstract, for
example.  The restricted paragraph is just like the normal one except
that there are a few elements (index, note and draftnote) which may
not appear.

<p>The paragraph elements have an `id' attribute, which allows you to
refer to them using a REF element (see <ref id=el.sun.ref>).  This
reference will, however, typically be a reference to the section which
contains the paragraph rather than to the paragraph specifically.
This is an instance of the more general warning that you should 
make few assumptions about how elements are rendered, when you are
authoring a document.

<p>Text style
(<ref id='el.sun.em' text='em'>,
<ref id='el.sun.strong' text='strong'>,
<ref id='el.sun.cite' text='cite'>,
<ref id='el.sun.draftnote' text='draftnote'>): em and strong indicate
degrees of emphasis; cite refers to the title of something such as a
book; and draftnote is a reminder usable whilst drafting a document,
which should be prominently displayed in some way.

<p>Verbatim text
(<ref id='el.sun.code' text='code'>,
<ref id='el.sun.verbatim' text='verbatim'>,
<ref id='el.sun.kbd' text='kbd'>,
<ref id='el.sun.linespecific' text='linespecific'>):
The `code' and `kbd' elements are verbatim text, displayed using a
fixed-width font in 
the line of a paragraph; the distinction is that kbd text might be
displayed in some way which indicated that it is text a user should
type.  Verbatim content is displayed in a fixed-width font, respecting
line-breaks.  Note that none of these elements perform any escaping of
their contents -- if there are any characters in the content which
would be of significance to the SGML parser (such as <code/&amp/ or
<code/&lt/), they should either be escaped with entity references
(<code/&amp;amp;/ or <code/&amp;lt;/) or else the content should be
enclosed in a CDATA marked section as follows (see also <ref
id=markup.ms.cdata>).
<verbatim>
&lt;verbatim>&lt;![ CDATA [
Here is some &lt;em>marked-up&lt/em> text
which will be skipped &amp; ignored
&rsqbrack;&rsqbrack>&lt;/verbatim>
</verbatim>

<p>The `linespecific' element is slightly different.  It is intended to
mark up a block of text where the linebreaks are significant, but the
text is not otherwise verbatim; the canonical example is that of
verse.  It consists of a sequence of `line' elements.

<p>Quotations
(<ref id='el.sun.quote' text='quote'>,
<ref id='el.sun.blockquote' text='blockquote'>,
<ref id='el.sun.attribution' text='attribution'>): a short quotation
may be enclosed in a quote element, and a longer one in a blockquote
element. In both cases, the content may start with an attribution
element, which notes the source of the quotation.

<p>Lists
(<ref id='el.sun.ol' text='ol'>,
<ref id='el.sun.ul' text='ul'>,
<ref id='el.sun.dl' text='dl'>,
<ref id='el.sun.dt' text='dt'>,
<ref id='el.sun.dd' text='dd'>,
<ref id='el.sun.li' text='li'>): These are the ordered, unordered and
description lists familiar from HTML.  Unlike HTML, however, the dt
and dd elements within the description list must be paired.

<subsect id=str.maths export>Maths
<update versionid="v0-4">Slight edit to discuss new mline and mlabel
elements</update>

<p>Includes
<ref id='el.sun.m' text='m'>,
<ref id='el.sun.mequation' text='mequation'>,
<ref id='el.sun.meqnarray' text='meqnarray'>,
<ref id='el.sun.mlabel' text='mlabel'>,
<ref id='el.sun.mline' text='mline'>.

<p>All the maths in Starlink documents uses &latex;
notation.<note>MathML was considered, but is neither well-supported in
browsers, nor designed to be easily written by hand</note>  The `m'
element is equivalent to <code/&dollar;...&dollar/, `mequation' is
equivalent to <code>\begin{equation} ... \end{equation}</code> and
`meqnarray' is equivalent
to <code>\begin{eqnarray} ... \end{eqnarray}</code>,
with the exception that the `meqnarray' elements contains a sequence
of `mline' elements, rather than having the equation lines separated
by <code>\\</code> commands.

<p>Within the `mequation' and `mline' elements, you may have a single
`mlabel' element.  If this is present, the equation is numbered, and
if you give it an ID, you can refer to that equation number from elsewhere.

<p>Note that, although the parser `knows'
that the content of these elements is in &latex notation there is no
suppression of markup-recognition within them -- entity references and
element start-tags are still recognised as such by the parser.  The
latter is rather a pest, but the former means that you can still use
entity references to parameterise or abbreviate mathematical
expressions.

<p>When you are typing an eqnarray, you might want to escape all
occurrences of <code/&amp/ and <code/&lt/ with the corresponding
entity references <code/&amp;amp;/ and <code/&amp;lt;/.  This is not
wrong, but it can become tedious and could obscure what you are
writing, so you may prefer to take advantage of the fact that SGML
recognises these bits of markup only in context: only if an ampersand
or less-than symbol is immediately followed by a name-start character
(an upper- or lowercase letter) is it recognised as an entity
reference or element start-tag.  Thus the following element is
correctly formed (with <code>&lt!entity dec "\delta"></code>):
<verbatim><![CDATA[
<meqnarray><mline>\alpha&<& x<mline>&dec&=&amp;4< x</meqnarray>
]]></verbatim>
I do, however, advise you against typing anything so wilfully obscure.
The best practice when typing meqnarray
elements is to reflexively put a space after all occurrences of
<code/&amp;/ and <code/&lt;/: this will keep the SGML parser from
interfering, and make no difference to &latex, which ignores all
spaces in maths mode anyway.

<sect id=doccode export>Documenting source code

<p>Many -- perhaps most -- Starlink documents exist to describe a body
of program code, and while the general behaviour and usage of that
program can be described in a document such as this one, the details
of the implementation might be most sensibly kept with the program
code itself.  The Starlink DTDs have facilities to do precisely this,
associating documentation directly with program code, and associating
that detailed documentation with user documents.

<p>As described in <ref id=str.code>, the Starlink General DTD has an
appendix element <ref id=el.sun.routinelist text='routinelist'>,
containing one or more <ref id=el.sun.codecollection
text='codecollection'> elements.  Each of these latter elements makes
a link between the documentation and a document marked up using the
programcode DTD, which I will now describe.

<p>The programcode document -- the document marked up using the
programcode DTD, pointed to by the main documentation -- may be
compilable source code, with the markup suitably commented out of
sight of the compiler; it may be a skeleton document which includes
separate source files into itself; or it may be a non-compilable
document maintained separately or generated from idiolectal source
markup by some sed or Perl magic.  It makes no difference to the SGML
parser, but gives the code author flexibility in deciding how much,
and what, markup to allow into their code comments.

<p>There are distinct document type declarations for the different
supported languages, although they use the same underlying markup.
This is so that the generic programcode DTD can be slightly customised
as appropriate for different languages.  See <ref id=doccode.languages>.

<p>The programcode DTD is more elaborate than it <em/could/ have
been.  Different people have different coding and documenting styles,
and are firmly wedded to them, so I felt that flexibility was more
important than simplicity.  As a result, there is sometimes more than
one place where information can reasonably be placed.  Also, the DTD
makes it possible to exploit tag-omission quite heavily (see <ref
id=markup.min>) -- the aim was to indicate an adequate level of
structure using as little markup as possible.

<p>The programcode DTD is designed to document code; there is no
reason why it could not also be used to prettyprint it, by taking a
marked-up document and putting it through a different processor.
That, however, is a project for another time.

<subsect id=doccode.general export>The structure of programcode documents

<subsubsect id=doccode.example>Example document

<p>Let us start in the traditional way, with a (sort of) `hello world'
program:
<verbatim><![CDATA[
<!DOCTYPE programcode PUBLIC '-//Starlink//DTD Fortran Source Code 0.2//EN'>
<PROGRAMCODE>
<DOCBLOCK>
<title>Test program
<authorlist>
<author id=ng affiliation='Starlink, Glasgow'><NAME>Norman

<codegroup><DOCBLOCK><TITLE>Test function

<routine>
<ROUTINEPROLOGUE>
<routinename><NAME>helloworld
<description><P>Greets the world with a sunny hello
<returnvalue type=string>Suitably formatted greeting
<argumentlist>
<parameter given><NAME>language
  <type>enumerated list<description><P>Selects the language to use.
  Allowed values are english and sanskrit.
</ARGUMENTLIST>
<authorlist><authorref id=ng>
</ROUTINEPROLOGUE>
<codebody empty>
]]></verbatim>

<p>This is, obviously, not a compilable Fortran program, but it is a
good example, firstly because it displays the structure (which will
be a little obscured when we come to consider Fortran programs in <ref
id=doccode.fortran>), and secondly because it could plausibly be the
output of some script which extracts documentation from compilable
source code files.

<p>As mentioned above, the programcode DTD allow you to make heavy use
of SGML tag omission features.  All the capitalised tags in this
example are omissable: removing them tips the balance back to the
healthy side of more text than markup.  The Fortran code DTD allows
further abbreviation, and we shall see that the content of the `func'
element could be represented as:
<verbatim><![CDATA[
*+
* <routinename>helloworld
* <description>Greets the world with a sunny hello
* <returnvalue type=string>Suitably formatted greeting
* <parameter given>
*   language = enumerated list
*     Selects the language to use.
*     Allowed values are english and sanskrit.
* <authorlist><authorref id=ng>
*-
      (function source code goes here)
]]></verbatim>

<p><update versionid="post-0.2">Added a note pointing out
that returnvalue and argumentlist have optional `none'
attributes.</update>
Note that the <ref id=el.programcode.returnvalue
text='returnvalue'> element is not omissable.  When there is <em/no/
return value, in the case of a subroutine, you can give the
returnvalue element the attribute `none'.  The same is true of the
<ref id=el.programcode.argumentlist text='argumentlist'> element.

<subsubsect id=doccode.elements>The programcode element structure
<update versionid="v0.6">
Substantially redone, to match significant changes to programcode DTD
</update>

<p>In the case of the Starlink General DTD, described in <ref
id=structure>, the important features were the meanings of the element
types.  In the case of the programcode DTD, however, the meanings of
the element types are fairly straightforward, and the detail is in the
<em/structure/ of the DTD.  It therefore seems best to focus on the
structure of the DTD here, leaving the detailed descriptions of the
elements to <ref id=appx.programcode.dtd>.

<p>The programcode DTD includes essentially all of the paragraph-level
elements in the Starlink General DTD, that is, everything that may be
included in a paragraph in that DTD may also be included in a
paragraph in the programcode DTD (except `docxref' and `ref', but with
the addition of the `funcname' element).

<p><ref id=figure.programcode> displays the element structure of the
programcode DTD.  The syntax is that of a DTD -- see <ref id=sgml.dtd>
for brief notes on this.

<figure id=figure.programcode alt="programcode DTD element structure">
<caption>Element structure of the programcode DTD</caption>
<px>
<!-- This was extracted from the dtd with the sed script
  sed -n '/^<!ELEMENT/{:again;/> *$/b nextel;p;n;b again;:nextel;p;}' \
	programcode-0.6.dtd 
  ...then reordered for documentation purposes, and the <ref> elements
  put in.
-->
<verbatim>
&lt;!ELEMENT <ref id=el.programcode.programcode text='programcode'>   O O (docblock, (codegroup | codereference)+)>
&lt;!ELEMENT <ref id=el.programcode.codegroup text='codegroup'>     - O (docblock, routine+)>
&lt;!ELEMENT <ref id=el.programcode.codereference text='codereference'> - O (docblock)>
&lt;!ELEMENT <ref id=el.programcode.docblock text='docblock'>      O O (title, description?, authorlist?,
                             copyright?, history?)>

&lt;!ELEMENT <ref id=el.programcode.routine text='routine'>       O O (codeopener?, routineprologue, codebody)>
&lt;!ELEMENT <ref id=el.programcode.codeopener text='codeopener'>    O O (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.codebody text='codebody'>      O O (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.routineprologue text='routineprologue'> O O (routinename? & purpose? & description & 
                                returnvalue? & argumentlist? &
                                parameterlist? & authorlist? & history? &
                                usage? & invocation? & examplelist? &
                                notelist? & implementationstatus? & bugs?)>

&lt;!ELEMENT <ref id=el.programcode.routinename text='routinename'>   O O (name, othernames?)>
&lt;!ELEMENT <ref id=el.programcode.name text='name'>          O O (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.othernames text='othernames'>    - O (name+)>

&lt;!ELEMENT <ref id=el.programcode.purpose text='purpose'>       - O (%p.model)>
&lt;!ELEMENT <ref id=el.programcode.title text='title'>         O O (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.description text='description'>   - O (%paralist;)>
&lt;!ELEMENT <ref id=el.programcode.returnvalue text='returnvalue'>   - O (%paralist;)>
&lt;!ELEMENT (<ref id=el.programcode.argumentlist text='argumentlist'> | <ref id=el.programcode.parameterlist text='parameterlist'>)
                        O O (parameter*)>
&lt;!ELEMENT <ref id=el.programcode.parameter text='parameter'>     - O (name, type, description)>
&lt;!ELEMENT <ref id=el.programcode.type text='type'>          - O (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.examplelist text='examplelist'>   O O ((example,description)+)>
&lt;!ELEMENT <ref id=el.programcode.example text='example'>       - O (#PCDATA)>
&lt;!ELEMENT (<ref id=el.programcode.usage text='usage'> | <ref id=el.programcode.invocation text='invocation'> | <ref id=el.programcode.implementationstatus text='implementationstatus'> | bugs)
                        - O (%paralist;)>
&lt;!ELEMENT <ref id=el.programcode.notelist text='notelist'>      O O (othernote+)>
&lt;!ELEMENT <ref id=el.programcode.othernote text='othernote'>     - O (title, %paralist;)>
&lt;!ELEMENT <ref id=el.programcode.copyright text='copyright'>     - O (%paralist;)>

&lt;!ELEMENT <ref id=el.programcode.authorlist text='authorlist'>    O O ((author+ | authorref+), otherauthors?)>
&lt;!ELEMENT <ref id=el.programcode.otherauthors text='otherauthors'>  - O (author+ | authorref+)>
&lt;!ELEMENT <ref id=el.programcode.author text='author'>        - O (name, authornote?)>
&lt;!ELEMENT <ref id=el.programcode.authornote text='authornote'>    - O (%paralist;)>
&lt;!ELEMENT <ref id=el.programcode.authorref text='authorref'>     - O EMPTY>

&lt;!ELEMENT <ref id=el.programcode.history text='history'>       O O (change+)>
&lt;!ELEMENT <ref id=el.programcode.change text='change'>        - O (%paralist;)>

&lt;!ELEMENT <ref id=el.programcode.funcname text='funcname'>      - - (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.webref text='webref'> - - (%simpletext)+>
&lt;!ELEMENT <ref id=el.programcode.url text='url'> - - (#PCDATA)>
</verbatim>
<![IGNORE[
<!-- This is the 0.2 dtd -->
<verbatim>
&lt;!ELEMENT <ref id=el.programcode.programcode text='programcode'>   O O (docblock, (codegroup | codereference)+)>
&lt;!ELEMENT <ref id=el.programcode.codegroup text='codegroup'>     - O (docblock, (func | misccode)+)>
&lt;!ELEMENT <ref id=el.programcode.codereference text='codereference'> - O (docblock)>
&lt;!ELEMENT <ref id=el.programcode.docblock text='docblock'>      O O (title, description?, authorlist?,
                             copyright?, history?)>

&lt;!ELEMENT <ref id=el.programcode.func text='func'>          O O (codeprologue, codebody)>
&lt;!ELEMENT <ref id=el.programcode.misccode text='misccode'>      O O (miscprologue, codebody)>
&lt;!ELEMENT <ref id=el.programcode.codeprologue text='codeprologue'>  O O (routinename , purpose? , description , 
                                returnvalue , argumentlist ,
                                authorlist? , history?)>
&lt;!ELEMENT <ref id=el.programcode.miscprologue text='miscprologue'>  O O (description, history?)>
&lt;!ELEMENT <ref id=el.programcode.codebody text='codebody'>      O O (#PCDATA)>

&lt;!ELEMENT <ref id=el.programcode.routinename text='routinename'>   O O (name, othernames?)>
&lt;!ELEMENT <ref id=el.programcode.name text='name'>          O O (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.othernames text='othernames'>    - O (name+)>

&lt;!ELEMENT <ref id=el.programcode.title text='title'>         O O (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.purpose text='purpose'>       - O (%para.content;)>
&lt;!ELEMENT <ref id=el.programcode.description text='description'>   - O (p+)>

&lt;!ELEMENT <ref id=el.programcode.returnvalue text='returnvalue'>   - O (%para.content | p+)>
&lt;!ELEMENT <ref id=el.programcode.argumentlist text='argumentlist'>  O O (parameter*)>
&lt;!ELEMENT <ref id=el.programcode.parameter text='parameter'>     - O (name, type, description)>
&lt;!ELEMENT <ref id=el.programcode.type text='type'>          - O (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.copyright text='copyright'>     - O (p+)>

&lt;!ELEMENT <ref id=el.programcode.authorlist text='authorlist'>    O O ((author+ | authorref+), otherauthors?)>
&lt;!ELEMENT <ref id=el.programcode.otherauthors text='otherauthors'>  - O (author+ | authorref+)>
&lt;!ELEMENT <ref id=el.programcode.author text='author'>        - O (name, authornote?)>
&lt;!ELEMENT <ref id=el.programcode.authorref text='authorref'>     - O EMPTY>
&lt;!ELEMENT <ref id=el.programcode.authornote text='authornote'>    - O (p+)>

&lt;!ELEMENT <ref id=el.programcode.history text='history'>       O O (change+)>
&lt;!ELEMENT <ref id=el.programcode.change text='change'>        - O (p+)>

&lt;!ENTITY % para.markup '<ref id=el.programcode.code text='code'> | <ref id=el.programcode.em text='em'> | <ref id=el.programcode.url text='url'> | <ref id=el.programcode.funcname text='funcname'>'>
&lt;!ENTITY % para.content '(#PCDATA | %para.markup | ul)*'>
&lt;!ELEMENT <ref id=el.programcode.p text='p'>             O O (%para.content;)>
&lt;!ELEMENT (%para.markup;) - - (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.ul text='ul'>            - - (li+)>
&lt;!ELEMENT <ref id=el.programcode.li text='li'>            - O (#PCDATA)>
</verbatim>
]]>
</figure>

<p>Below, I describe these elements group-by-group.  This description
concentrates on the structure of the DTD and the relationships between
the elements -- I have not described the details of the elements or
their attributes where these can be found in the detailed element
listing in <ref id=appx.programcode.dtd>.

<p><verbatim>
&lt;!ELEMENT <ref id=el.programcode.programcode text='programcode'>   O O (docblock, (codegroup | codereference)+)>
&lt;!ELEMENT <ref id=el.programcode.codegroup text='codegroup'>     - O (docblock, routine+)>
&lt;!ELEMENT <ref id=el.programcode.codereference text='codereference'> - O (docblock)>
&lt;!ELEMENT <ref id=el.programcode.docblock text='docblock'>      O O (title, description?, authorlist?,
                             copyright?, history?)>
</verbatim>
The <code/programcode/ top-level element, like the
<code/codegroup/ and <code/codereference/ elements which it contains,
starts off with a <code/docblock/ element.  This may provide
discussion, author, copyright, change history information, or it may
give as little as a title.  Where this information is provided is up
to the author of the documentation.  The elements in the
<code/docblock/ must be present in the order specified here.

<p>A <code/codegroup/ element simply
gathers together several related functions (this is deliberately
vague); it might therefore represent all the functions defined in one
source file, or in one directory of a source tree.  
A <code/codereference/ is even vaguer: it documents a relationship
between the current programcode document and another one.  In the case
of the DSSSL DTD, this is mapped to the structure in that language which
included one source file in 
another; in the case of the Fortran DTD, it could document the
dependence of a source file on an `include' file.

<p><verbatim>
&lt;!ELEMENT <ref id=el.programcode.routine text='routine'>       O O (codeopener?, routineprologue, codebody)>
&lt;!ELEMENT <ref id=el.programcode.codeopener text='codeopener'>    O O (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.codebody text='codebody'>      O O (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.routineprologue text='routineprologue'> O O (routinename? & purpose? & description & 
                                returnvalue? & argumentlist? &
                                parameterlist? & authorlist? & history? &
                                usage? & invocation? & examplelist? &
                                notelist? & implementationstatus? & bugs?)>
</verbatim>
A <code/routine/ element documents a function, with arguments, a return
value, and the like.

<p><update versionid="post-0.2">
Paragraph rewritten to suggest using a CDATA marked section, instead
of code edits.</update>
The <code/codebody/ element is ignored by the processing system,
but is still scanned by the parser.  This could cause you a problem if
there's anything in there which looks like something the parser would
be interested in, namely an element start-tag, an entity reference, or
something that looks like markup.
The ampersand and left angle-bracket are only recognised as markup if
they are immediately followed by a name-start character (upper- or
lowercase letter); markup is something starting with the string
<code>&lt;!...</code>.
If the parser trips up on something, there are two
things you can do.  You can make minor edits 
to your source code (adding a space character
will always be enough), to stop things looking like markup:
<code>&lt;a</code> is the beginning of an element start-tag, but
<code>&lt; a</code>, with an interpolated space, is not.
Alternatively, you can bracket the code in a CDATA marked section
(<ref id=markup.ms.cdata>) as follows
<verbatim>
* ... end of code prologue
*-&lt;![CDATA[
      ...fortran code including &lt;ignored &amp;markup...
*&rsqbrack;]>
</verbatim>
Which of these alternatives you prefer is largely a matter of taste, I
think, but remember that you'll only have to do this for those
source-code files which you include within your documentation.  It is
undeniable that these strategies are ugly, but something like this is
fairly inevitable as the downside of having your source processable by
more than one system at once.  If both of these are unacceptable to
you (on aesthetic grounds if nothing else), then you can always
preprocess your sources to strip the code out and leave a `pure' SGML
document.<note>Note for SGML initiates: it does
seem a little disappointing that none of SGML's various escaping
mechanisms could help here, but the fact that the code text has to
remain pretty much inviolate (apart from the possibility of a few
spaces here and there) is rather restrictive.  Another possibility I
considered was making the <code/codebody/ element have CDATA content,
even though that's generally deprecated in the most lurid terms.  Far from
solving the problem, this would make things worse, however: the
<code>&lt;/</code> which ends the element would still be magic, you'd
have to have an explicit <code>&lt;/codebody></code> closing the
element (no entities recognised), and you'd have to have an explicit
<code>&lt;codebody></code> starting the element, since the
<code>*-</code> short reference doesn't seem to permit the element to
be ended with the <code>&lt;/codebody></code> end-tag.</note>

<p>Note: If the <code/codebody/ element actually contains no code at all
(perhaps because the document has been generated by a preprocessor
stage), then you should include the attribute `empty' in the
start-tag; this has no effect at present, but could become significant
if the documents are repurposed in future versions of this set.

<p>
<verbatim>
&lt;!ELEMENT <ref id=el.programcode.routinename text='routinename'>   O O (name, othernames?)>
&lt;!ELEMENT <ref id=el.programcode.name text='name'>          O O (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.othernames text='othernames'>    - O (name+)>
</verbatim>
The <code/routinename/ element has structure, though in the usual case
(<code/&lt;routinename>helloworld/) you wouldn't notice this.  The
<code/othernames/ element is useful when a function has some generic
name, say <code/allocarray/, plus some specific names, say
<code/allocarray_int/ and <code/allocarray_float/.

<p>
<verbatim>
&lt;!ELEMENT <ref id=el.programcode.purpose text='purpose'>       - O (%p.model)>
&lt;!ELEMENT <ref id=el.programcode.title text='title'>         O O (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.description text='description'>   - O (%paralist;)>
&lt;!ELEMENT <ref id=el.programcode.returnvalue text='returnvalue'>   - O (%paralist;)>
&lt;!ELEMENT (<ref id=el.programcode.argumentlist text='argumentlist'> | <ref id=el.programcode.parameterlist text='parameterlist'>)
                        O O (parameter*)>
&lt;!ELEMENT <ref id=el.programcode.parameter text='parameter'>     - O (name, type, description)>
&lt;!ELEMENT <ref id=el.programcode.type text='type'>          - O (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.examplelist text='examplelist'>   O O ((example,description)+)>
&lt;!ELEMENT <ref id=el.programcode.example text='example'>       - O (#PCDATA)>
&lt;!ELEMENT (<ref id=el.programcode.usage text='usage'> | <ref id=el.programcode.invocation text='invocation'> | <ref id=el.programcode.implementationstatus text='implementationstatus'> | bugs)
                        - O (%paralist;)>
&lt;!ELEMENT <ref id=el.programcode.notelist text='notelist'>      O O (othernote+)>
&lt;!ELEMENT <ref id=el.programcode.othernote text='othernote'>     - O (title, %paralist;)>
&lt;!ELEMENT <ref id=el.programcode.copyright text='copyright'>     - O (%paralist;)>

</verbatim>
The distinction between <code/purpose/ and <code/description/ is that
<code/purpose/ is intended for a brief, perhaps one-line, summary
of the function, whereas <code/description/ is intended for a longer
discussion.

<p>The <code/description/ element is used in the <code/docblock/,
<code/codeprologue/, <code/miscprologue/ and <code/parameter/
elements, <code/authorlist/ is used in both <code/codeprologue/ and
<code/docblock/ elements, and <code/name/ is used in the <code/author/,
<code/othernames/, <code/parameter/ and <code/routinename/ elements.

<p>The <code/notelist/ element is for other notes which aren't
otherwise covered by the element types listed here.

<p>
<verbatim>
&lt;!ELEMENT <ref id=el.programcode.authorlist text='authorlist'>    O O ((author+ | authorref+), otherauthors?)>
&lt;!ELEMENT <ref id=el.programcode.otherauthors text='otherauthors'>  - O (author+ | authorref+)>
&lt;!ELEMENT <ref id=el.programcode.author text='author'>        - O (name, authornote?)>
&lt;!ELEMENT <ref id=el.programcode.authornote text='authornote'>    - O (%paralist;)>
&lt;!ELEMENT <ref id=el.programcode.authorref text='authorref'>     - O EMPTY>
</verbatim>

The distinction between the <code/author/ and <code/authorref/
elements is important.  The <code/author/ element has a required ID
attribute which can be used to refer to this author, and the
associated metadata of URL and email address.  Since IDs must be
unique in an SGML document, it follows that there can be only <em/one/
<code/author/ element per author per document: there cannot be an
author element in each function.  It is usual, however, to give
authorship information in each function, and this is done with the
<code/authorref/ element, which has a required ID attribute linking
back to the <code/author/ element presumably located in the document's
initial <code/docblock/ (see the example in <ref id=doccode.example>).

<p>
<verbatim>
&lt;!ELEMENT <ref id=el.programcode.history text='history'>       O O (change+)>
&lt;!ELEMENT <ref id=el.programcode.change text='change'>        - O (p+)>
</verbatim>
The history mechanism in programcode documents is intentionally
simple, as it merely emulates the list-of-changes style in the
majority of the Starlink code-base.  The <code/change/ element has a
required date, and a required `author' attribute, which links back to
a previous <code/author/ element.

<p>
<verbatim>
&lt;!ELEMENT <ref id=el.programcode.funcname text='funcname'>      - - (#PCDATA)>
&lt;!ELEMENT <ref id=el.programcode.webref text='webref'> - - (%simpletext)+>
&lt;!ELEMENT <ref id=el.programcode.url text='url'> - - (#PCDATA)>
</verbatim>
The only unusual element is <code/funcname/, which
is intended to indicate other functions within the same `world'
(vagueness again): these could be language primitives, or other
documented functions.  At present, this simply functions as a variant
of the <code/code/ element, but the system could be extended in future
to generate cross-references for these.

<p>The text <code/%p.model;/ indicates that at this point, any of the
paragraph-level elements from the Starlink General DTD may be used,
with the exception of the `docxref' and `ref' elements, and the
addition of the `funcname' element.

<p>The text <code/%paralist;/ is shorthand for <code/p, (p |
tabular)*/, or in other words, a sequence of paragraphs and tabular elements.

<subsect id=doccode.languages export>Specific language variants

<p>As I mentioned above, the programcode DTD is not invoked directly,
but instead <em/via/ a document type declaration specific to the
language of the program being documented, allowing for
language-specific customisation of the generic DTD.

<p>At present, the only languages supported by DTDs are
DSSSL (a language for formatting SGML documents, which has
been used for much of the processing work in this project) and
Fortran.  C and C++ will be added almost immediately, and other
languages as guided by demand.

<subsubsect id=doccode.fortran>Fortran

<p>The principal customisations for Fortran documents are to do with
the definition of `short references' for certain tags, to help you
`hide' SGML within Fortran comments.

<p>The string <code/*+/ coming at the beginning of the line, is
equivalent to the <code/func/ start-tag, and <code/*-/ at the
beginning of the line is recognised as the <code/codebody/ start-tag.
Within the <code/func/ element, a <code/*/ at the beginning of the
line is ignored.  Further, within the <code/parameter/ element, an
equals sign, <code/=/, is recognised as a <code/type/ start-tag, and
within that element, end-of-line and <code/:/ are recognised as a
<code/description/ start-tag.

<p>All together, this means that, as trailed in <ref
id=doccode.example>, the code fragment
<verbatim><![CDATA[
*+
* <routinename>helloworld
* <description>Greets the world with a sunny hello
* <returnvalue type=string>Suitably formatted greeting
* <parameter given>
*   language = enumerated list
*     Selects the language to use.
*     Allowed values are english and sanskrit.
* <authorlist><authorref id=ng>
*-
      (function source code goes here)
]]></verbatim>
is interpreted as 
<verbatim><![CDATA[
<func>
<routinename>helloworld
<description>Greets the world with a sunny hello
<returnvalue type=string>Suitably formatted greeting
<parameter given>language
  <type>enumerated list<description>Selects the language to use.
  Allowed values are english and sanskrit.
<authorlist><authorref id=ng>
<codebody>
      (function source code goes here)
]]></verbatim>

<subsubsect id=doccode.dsssl>DSSSL

<p>DSSSL is a language defined in ISO/IEC 10179:1996
<citation>iso10179</citation> as a means of specifying the formatting of SGML
documents.  It is the language, as implemented in the free DSSSL
system <webref url='http://www.jclark.com/jade/' >Jade</webref>, used
for almost all the processing of SGML documents in this Starlink SGML
application.  Since the language is likely to be of interest only to
those with some knowledge of SGML, the rest of this section uses
terminology not defined elsewhere in this document.

<p>DSSSL source documents are SGML instances.  When presented with a
source file, Jade does not process it immediately, but instead
extracts (rather nicely) an instance of the `DSSSL' architecture,
which must be declared in the DTD the document conforms to.  The DTD
referred to by <code>-//Starlink//DTD DSSSL Source Code 0.2//EN</code>
declares such an architecture.  It maps the programcode
<code/codegroup/ element to the DSSSL <code/style-specification/
architectural form, <code/codereference/ to
<code/external-specification/ (with attribute name remapping) and
<code/codebody/ to <code/style-specification-body/. This follows a
discussion of this technique in <code/comp.text.sgml/ by Eliot
Kimber~<citation>kimber97a</citation>.

<p>Also it defines the entity <code/%direction.attr/ to be simply
`given', since arguments to DSSSL functions are only passed in.

<p>See <ref id=appx.system> for further discussion of the DSSSL
code base.

<subsect id=doccode.org export>Organising files

<p>I described above how, for example, the Fortran-code DTD can allow
you to mix program source code and SGML markup.  A Fortran source file
cannot be a complete SGML document on its own, however, even though it
can be a fragment of a valid document, since there is no way to hide
the required <code/&lt;!DOCTYPE ...>/ declaration from the compiler.
The source file must therefore be part of a composite document.

<p>Although the object that is pointed to by the General DTD's
<code/codecollection/ element is a single SGML document marked up
using the programcode DTD, it need not be a single file.  A suitable
way to manage a collection of source code files, for documentation
purposes, might be as follows.

<p>We can return to the example in <ref id=doccode.example>, and split
our `hello world' example into two files, a skeleton file holding the
general structure, and including an entity which refers to the source
code:
<verbatim><![CDATA[
<!DOCTYPE programcode PUBLIC '-//Starlink//DTD Fortran Source Code 0.2//EN' [
 <!ENTITY ptest-source SYSTEM 'ptest.for'>
]>

<title>Test program
<authorlist>
<author id=ng affiliation='Starlink, Glasgow'>Norman

<codegroup>Test function

&ptest-source;
]]></verbatim>
and a separate file, <code/ptest.for/, containing just the source code:
<verbatim><![CDATA[
*+
* <routinename>helloworld
* <description>Greets the world with a sunny hello
* <returnvalue type=string>Suitably formatted greeting
* <parameter given>
*   language = enumerated list
*     Selects the language to use.
*     Allowed values are english and sanskrit
* <authorlist><authorref id=ng>
*-
      write (*,*) 'hello'
]]></verbatim>

<p>Note that in this case the source-code file refers to its author
only through the authorref element, pointing to the author
element and its associated author metadata in the main file.

<subsect id=doccode.devel export>Development of the programcode DTD

<p>As you can see from the programcode structure in <ref
id=figure.programcode>, the DTD recognised only two structures,
<code/func/ (which includes subroutines since the returnvalue element
can be given the `none' attribute) and miscellaneous-code.  Also, the
structure of the code prologue is quite strict, with routinename,
description, returnvalue and argument list all required, and these and
their optional companions having a fixed order.  It's not clear that
this element structure is ideal, and I would like to solicit feedback
on this at this stage of the project.

<p>On the one
hand, it seemed important to make as much as possible required here,
to encourage folk to include all the important bits of documentation.
On the other hand, I didn't want to fall into the trap of `all the
world is Fortran'.  On the third hand, quite a lot of the world <em/is/
Fortran (or C or IDL or something pretty like them in terms of code
structures), so that's obviously a class of documentable objects I
should map quite faithfully into documentation support.

<p>When I support C++, I'll have to add support in programcode for the
notion of a class which contains methods.  Probably this'll be
something at the same level as `codegroup' (perhaps it should simply
<em/be/ `codegroup', with the `func' element documenting individual methods).
I think that'll be just about all the major code structures --
anything else can be bundled in the guards van under `misccode'
without much loss.

<p>When I discussed that with Mark Taylor, however, he suggested a
much more flexible structure:
<verbatim><![CDATA[
I think that imposing a rigid structure could be counterproductive.
My feeling is that if people's (source) code fails to parse it's going 
to be an incentive to leave it unSGMLized or just bung everything in some
In any case there are a lot of differently prologuized
routines out there so imposing a rigid structure on it is going to
be an uphill job.  My inclination would be to have a single element
for putting code into (in which case ROUTINE might be a better GI
than FUNC) with many optional children and no compulsory ones except
perhaps NAME.  I also think that we need a generic element in the
content model.

  <!ELEMENT routine      O O   ( codeprologue, codebody )>
  <!ELEMENT codebody     O O   ( #PCDATA )>
  <!ELEMENT codeprologue O O   ( routinename & purpose? & description? &
                                 returnvalue? & argumentlist? & 
                                 algorithm? & pitfalls? & bugs? &
                                 examples? & usage? & notes? & other* &
                                 authorlist? & history? )>

  <!ELEMENT (description | returnvalue | algorithm |
             pitfalls | bugs | examples | usage | notes | 
             other)      - O   ( p* )>

  <!ELEMENT other        - O   ( othersect* )>
  <!ELEMENT othersect    O O   ( otherhead, p* )>
  <!ELEMENT otherhead    - O   ( #PCDATA )>
]]></verbatim>
I agree that my original may be more
strict than is comfortable to use, but Mark's might be too far
the other way.

<p>My picture of how the programcode DTD would be used was that people
probably wouldn't document so elaborately every routine they wrote,
but only those they intended to incorporate into user or maintainer
documentation; if this constituted a minority of routines, it wasn't
necessarily inappropriate to make the structuring quite strict.  If,
on the other hand, we envisage the majority of routines being marked
up like so, then it would be appropriate to cut folk a little more
slack.  The question then is, how much slack can you afford before the
result looks shapeless?  The structure we give up here, in the
interests of flexibility and authoring ease, is the structure that
makes it easy to write powerful downstream tools in the future.

<p>It is clear that a balance has to be struck here, and that my own
taste would not be universal.  I'm open to suggestion.

<sect id=processing export>Processing your document

<p>SGML documents are processed using a suite of free tools produced
by James Clark.

<p><webref url="http://www.jclark.com/jade/" >Jade</webref> is a
system which implements the DSSSL language for document formatting
and, in the present case, transformation.  The difference is that
`formatting' refers to the process of turning an SGML document into a
printed, or otherwise readable, form, and `transformation' refers to
the processing of an SGML document into another SGML document.  Thus
the conversion to HTML is really `transformation', but since HTML is
not much cop as a high-level markup language, the HTML transformation
is much more akin to a formatting step; likewise the `formatting' into
&latex;.  In fact, DSSSL has a transformation language as well as a
formatting language; Jade implements only the formatting language, but
with extensions which allow it to be used very easily for
transformation.

<p>Along with Jade is the <webref url="http://www.jclark.com/sp/"
>SP</webref> toolkit.  This consists of a standalone parser,
<code/nsgmls/, and various markup editing tools.

<subsect id=proc.setup export>Setting up

<p>To use the SGML set, give the command 
<verbatim>
% . /star/bin/sgml/sgml_set.sh
</verbatim>
or
<verbatim>
% source /star/bin/sgml/sgml_set.csh
</verbatim>
depending on whether you are using a Bourne-like shell (<code/sh/,
<code/bash/) or a C-shell (<code/csh/, <code/tcsh/ or
other variants).  This will set up a couple of environment variables,
and add a binaries directory to your path.


<subsect id=proc.sgml2docs export>sgml2docs
<update versionid="v0-4" >Added section on sgml2stuff commands, and
discussion of very simple processing.</update>
<update versionid="v0.6">Significant change to sgml2docs commands</update>

<p>You should use the command <code/sgml2docs/ to process your SGML
documents.

<p>Given a single argument, specifying an SGML source file, the script
uses the Starlink DSSSL stylesheets to process this into a
collection of HTML files and GIFs, or &latex; and EPS files
places them in a subdirectory named after the source file, and
then creates a tarball in the source directory holding the
generated files.

<p>It requires that the environment variable <code/STARLINK_SGML_DIR/ is
properly set, pointing to the root of the Starlink SGML kit.  It
also requires that dvi2bitmap is in the <code/PATH/.
The script creates a work directory and does its processing
there.  If it is necessary to run Bib&tex;, it will be done with
that temporary directory as the current directory, so that it
might be necessary to set <code/BIBINPUTS/ (for example) to let the
system find the bibliography database.

<p>The program takes a single argument, the SGML file to be processed.

There are several script options:
<dl compact>
<dt><code/--html/
<dd>Generate HTML (the default).
<dt><code/--htmlsingle/
<dd>Generate HTML, but in a single file rather than a collection.
<dt><code/--latex/
<dd>Generate &latex;.
<dt><code/--packagedir my-dir/
<dd>Package up the generated files into a directory called `my-dir'.
<dt><code/--tarball my.tar/
<dd>Bundle the package-dir into a tarball named `my.tar'.  If you do
not give an absolute pathname, it will be located relative to the
current directory.
<dt><code/--jadeflags flags/
<dd>Pass the given flags to Jade.
<dt><code/--help/
<dd>Show brief usage instructions.
<dt><code/--debug/
<dd>Don't delete the working directory at the end (allows you to explore).
</dl>

<p>The final option, <code/--jadeflags/, allows you to do some limited
customisation of the output.  See <ref id=appx.system.paramdsssl>.

<subsect id=proc.makefile export>Processing documents -- using the Makefile
<update versionid="v0.6">Makefile approach no longer supported</update>

<p>At one time, the processing of documents was driven by a Makefile.
This is still distributed with the rest of the package, but is no
longer supported, and is not guaranteed to work.

<p>Processing documents is potentially a bit of a headache.

<p>The Jade processor is typically invoked with quite elaborate
command lines, with some options vital and some optional.  Some
documents -- those including maths or bibliographies, for example --
require more or less elaborate preprocessing for some formats.  In
some circumstances the names of output files are significant to the
system.  It is for all these reasons that the system is designed to be
used primarily <em/via/ makefiles.  See however, the description of
the <code/sgml2html/ and <code/sgml2latex/ commands in <ref
id=proc.sgml2docs>.

<p>The distribution contains a Makefile,
<code>$STARLINK_SGML_DIR/lib/Makefile.common</code>, which contains
reasonably modular rules for the various stages of the formatting
process.  The aim is that you can process your documents by including
this common makefile in a per-directory makefile, and then simply
expressing the dependencies between your source documents and the
makefile's template targets.

<p>If your document is relatively simply, you may not actually need to
have a makefile in the documentation 
directory in order to use the setup.  Imagine that you want to process
file <code/mydoc.sgml/.  If it has no backmatter or maths, then you
can process this with the command
<kbd>make -f $(STARLINK_SGML_DIR)/lib/Makefile.common
mydoc.html.stamp</kbd>, which will read the set of rules from the
common makefile and apply the one necessary to build the HTML target.
If, in this 
simple case, you wished to have a makefile in the current directory for
the sake of clarity, it need contain nothing more than the line
<verbatim>
include $(STARLINK_SGML_DIR)/lib/Makefile.common
</verbatim>
(assuming that your version of <code/make/ supports the `include'
command), and you could build the documentation using the command
<kbd/make mydoc.html.stamp/.  If your document is simple enough to
need no more than this, then you will be able to use the
<code/sgml2html/ command described in <ref id=proc.sgml2docs>.

<p>If your document includes backmatter (bibliography or notes) or
maths, then they will need 
to be preprocessed.  This is done by specifying extra dependencies in
the makefile.  A document with backmatter would need a three-line
makefile like:
<verbatim>
include $(STARLINK_SGML_DIR)/lib/Makefile.common
mydoc.html.stamp:   mydoc.sgml   mydoc.htmlback.stamp
mydoc.latex.stamp:  mydoc.sgml   mydoc.latexback.stamp
</verbatim>
Then the command <kbd/make mydoc.html.stamp/ would first process the
backmatter, then generate the main HTML document.  The command
<kbd/make mydoc.latex.stamp/ is broadly the same.

<p>If your document contains some maths, then the generation of HTML
requires another preprocessing step, and you declare the need for this
with another target, so that our makefile would become:
<verbatim>
include $(STARLINK_SGML_DIR)/lib/Makefile.common
mydoc.html.stamp:   mydoc.sgml   mydoc.htmlback.stamp   mydoc.imgeq.list.stamp
mydoc.latex.stamp:  mydoc.sgml   mydoc.latexback.stamp
</verbatim>
(there is no need for a &latex; preprocessing stage for maths).

<p>The root of the generated files is itself generated based on data
within the file, and is not configurable.  Do not change filenames yourself,
since HTML cross-references are constructed using the assumption that
no-one has been monkeying with filenames.  

<p>The HTML `front page' includes links to printable versions of the
file.  The files which are linked to are controlled by the
parameterisation variable <code/%link-extension-list%/ (see <ref
id=appx.system.paramdsssl>).
The stylesheet and makefile neither generate these files nor check
that they are there -- that is left to you.  

<p>You can find out the root filename and the list of linked-to files
by examining the stamp file (which is written from the standard output
of the stylesheet).  This file contains the filename root, a colon,
the list of file extensions it has included links to, and another colon.
The root may therefore be extracted with a command like:
<verbatim>
awk -F: '{print $1}' mydoc.html.stamp
</verbatim>
You might, for example, wish to finish off your processing of a
document by giving a command like <kbd/ln -s SUN-123.html index.html/,
which could be automated as
<verbatim>
ln -s `awk -F: '{print $1}' mydoc.html.stamp` index.html
</verbatim>

<p>The makefile targets are as follows.  With makefiles, the code is
the documentation to a greater extent than with other languages, so
the makefile itself should be consulted if in doubt.  Note, however,
that targets in the makefile that are not mentioned here should not be
used, since they are internal (ie, could disappear without warning),
unstable, or otherwise deprecated.
<dl>
<dt><code/%.html.stamp: %.sgml/
<dd>The main target for generating collections of HTML files.

<dt><code/%.single.html: %.sgml/
<dd>A target for generating HTML using the same stylesheet as above,
but with the entire document in a single file.

<dt><code/%.summary: %.sgml/
<dd>Generate a document-summary for the source file.

<dt><code/%.htmlback.stamp: %.sgml/
<dd>Preprocess a document to generate backmatter in HTML format.  Use
this as a dependency of the <code/%.html.stamp/ target, when a document has
backmatter, as in the example above.

<dt><code/%.imgeq.list.stamp: %.sgml/
<dd>Preprocesses a document, producing GIF images of the equations within
it.  Use as with <code/%.htmlback.stamp/

<dt><code/%.latex.stamp: %.sgml/
<dd>Produce a &latex file suitable for subsequent processing.  The
generated &latex document is not particularly readable, but it does
not depend on any external classes or packages other than those which
should be in a standard &latex distribution; it should therefore be
generally portable.

<dt><code/%.latexback.stamp: %.sgml/
<dd>Proprocess a document, producing backmatter in &latex format.  Use
this as a dependency of the <code/%.latex.stamp/ target, when a
document has backmatter.

<dt><code/%.parse: %.sgml/ 
<dd>The <code/%.parse/ target is the SGML parser's view of the
document.  The format is <webref
url="http://www.jclark.com/sp/sgmlsout.htm" >standard</webref>, though
not formally defined, and
can be parsed by Perl libraries such as <webref
url="http://www.cpan.org/modules/by-module/SGMLS/" >SGMLSpm</webref>.

<dt><code/%.data: %.sgml/
<dd>The <code/%.data/ target contains all the character data content
of the document.  It's not obvious what use this is, but it's there if
you can think of one.

<dt>Miscellaneous
<dd>The Makefile also defines targets <code/%.ps/, <code/%.dvi/.
There's nothing clever involved in these -- they're present for
convenience.

</dl>

<p>To help you when packaging up your document, the stylesheets write
a manifest of the files which make a complete set.  The names of the
manifest files can be configured as parameters (see <ref
id=appx.system.paramdsssl>).

<subsect id=editors export>Editors

<p>SGML is a text format, so you can write SGML documents using
whichever editor you prefer.

<p>If you use emacs, you can benefit from an emacs SGML mode called
<webref url='http://www.lysator.liu.se/projects/about_psgml.html'
/psgml/.  This can help with simple things such as automatically
inserting appropriate closing tags, all the way up to validating your
document.

<p>There are no free SGML editors that I'm aware of, but there will
soon be free XML editors.  These aren't useful quite yet, as there is
not yet an XML version of the Starlink DTD, but their time will come.

<sect id=final export>Finally

<subsect id=final.development export>Further developments
<update versionid="post-0.3">
Added extended Oasis table support to the wish list.
</update>


<p>What's next?  This section contains rather miscellaneous ideas for
further work.  They're ordered from most to least work, but on the
basis of about two seconds' reflection, so nothing should be pinned on
this.  The work involved seems to correspond rather neatly with their
expected utility.

<dl>
<dt>XML
<dd>I'd like to support XML (see <ref id=final.xml>).  This requires
a little development of the DTD but, more substantially, also requires
investigating what level of support we can reasonably expect from
users' browsers.  There is a great deal of work being done on XML at
present (mid-1999) -- when the developments settle down we can start
to exploit them.  There's a big range of possibilities here, so this
could be a smallish task or a huge one, depending on what we wanted to do.

<dt>Searching
<dd>I'd like to support sophisticated searching.  The Starlink HTX
system allows some context-based searching (see <docxref
doc="sun188" loc='searching_for_information'>), and it should be easy
to support this and more in the SGML set.  This would involve
finding a suitable SGML-aware search engine.  The <webref
url="http://info.ox.ac.uk/bnc/sara/" >BNC's SARA server</webref> might
be a possibility: I think it's free, but I haven't yet investigated
the extent to which it's specific to the BNC, or to its windows
client.

<dt>Table support
<dd>I'd like to support more of the Oasis table subset (see <ref
id=str.tables>).  I can add support incrementally, as folk suggest
priorities.

<dt>CSS stylesheets
<dd>At present, the formatting is controlled by the parameters file.
I could remove this and instead distribute a CSS stylesheet, which
would also allow individual users to selectively override things they
didn't like.

<dt>Include elements for Examples, Notes, Warnings?
<dd>How important is this?  It might be nice to have explicit support
for these, but I don't want to bloat the DTD with too many features,
so it's a question of balance.  I'd thought of something like:
<code>&lt;callout type=warning>Switch the computer on before
attempting to read your mail&lt;/callout></code>.  Having `type' be
`example', `note' or `warning' gives the thing attractive symmetry,
but would this improperly bundle different things together.
<!--
I think that examples should go within %body.content, and
contain paragraphs.  Notes and warnings should be in p.content?  I'm
not sure how necessary it is to support these so explicitly.
-->

<dt>Link colouring
<dd>Output, for example, a little coloured dot (4x2 pixels) before all or some
links, indicating what type of link this is.  For example, unadorned
links are to other parts of the same document (ie, <code/&lt;ref>/), a
red dot indicates a reference to another Starlink document (ie,
<code/&lt;docxref>/), a blue one to a miscellaneous URL.  I've
implemented a similar thing on another system, and it's both
unobtrusive and rather helpful.

</dl>

<subsect id=final.xml export>XML

<p>The primary XML resources are
<ul>
<li><url>http://www.w3.org/XML</url> for the W3C's XML spec
<li><url>http://www.ucc.ie/xml/</url> for the XML FAQ
<li><url>http://www.xml.com/xml/pub/axml/axmlintro.html</url> for the
annotated spec
</ul>

<subsubsect>XML is SGML&ddash;
<p><ul>
<li>An SGML document consists of an `SGML declaration' which
sets various options, a `document type definition' (DTD) which
establishes the syntax of a document type, and a `document instance',
which is the actual document.

<li>XML has a single, fixed, SGML declaration, which sets most of the
SGML options to `off'.  For example, in XML all element names are case
sensitive, there is no tag omission, there are some restrictions on
the possible syntaxes expressible by the DTD, and more exotic features
such as SUBDOC are forbidden.  For a more detailed discussion of the
differences, see 
<webref url='http://www.w3.org/TR/WD-xml-lang.html#secA.'
>appendix A</webref> of the spec.

<li>This means that parsers are easy to write, and there are numerous
such parsers available for free.

<li>XML dispenses with the SGML declaration; it can dispense with a
DTD as well.  XML introduces the notion of `well-formed' versus
`valid' documents.
<p>If a document has all closing tags present,
and all elements properly nested, and starts with the declaration
<verbatim>
   &lt;?xml version="1.0" standalone="yes"?>
</verbatim>
and empty elements are
written <code>&lt;empty/></code>, then it is `<webref
url='http://www.ucc.ie/xml/#FAQ-WF' >well-formed</webref>', and may
be processed in the absence of a DTD.

<li>A file which has a DTD and which conforms to it (which will also
be well-formed), is `<webref url='http://www.ucc.ie/xml/#FAQ-VALID'
>valid</webref>'.  It may optionally also begin with the XML declaration
<verbatim>
&lt;?xml version="1.0"?>
</verbatim>

<li>That is, a valid XML document is also a conforming SGML document.
This has been made possible by recent subtle, technical, changes to
the SGML standard.

<li>The latter has come about because there has been close cooperation
between the developers of XML and the wider SGML community.  That is,
XML is fully legit as SGML.

</ul>

<subsubsect>XML is not HTML++

<p><ul>
<li>XML is a real standard (well, there <em/are/ HTML standards, but
noone pays any attention to them).
<li>HTML has a fixed element set, and associates fixed semantics with
those elements.  XML has neither restriction.
</ul>

<subsubsect>Associated standards

<p><ul>

<li><webref url='http://www.w3.org/TR/WD-xlink' >XLink</webref> is a draft
specification for links in XML. It's closely related to the hyperlinks
module of HyTime.

<li><webref url='http://www.w3.org/TR/WD-xptr' >XPointer</webref> is a
draft specification for location specifiers in XML, so that you
can refer, for example, to `the second section beneath the
element with id so-and-so'. As with XLink, it's closely related
to HyTime.

<li><webref url='http://www.w3.org/Style/XSL/' >XSL</webref> are style
sheets for XML.  These are vital if XML is to be readable when it is
served over the web (because it doesn't have the fixed semantics HTML
has, XML rendering can't be left entirely to a browser).

<li>The <webref url='http://www.w3.org/DOM/' >Document Object
Model</webref> (DOM) is `a platform- and language-neutral interface that
allows programs and scripts to dynamically access and update the
content, structure and style of documents' [from the spec].  It's a
simple set of O-O declarations for querying and manipulating XML
documents in simple ways (small subset of DSSSL).

<li><webref url='http://www.hytime.org/' >HyTime</webref> is a very
high-level standard for associating semantics with SGML DTDs.

<li><webref url='http://www.oasis-open.org/cover/dsssl.html'
>DSSSL</webref> is the Document Style and Semantics Specification
Language. It's a language for writing stylesheets in.  Both HyTime and
DSSSL are specific to SGML, but have informed the other standards
above.

</ul>

<subsubsect>Future developments

<p><ul>

<li>SGML technology will work with XML (as long as it conforms to the
minor technical corrigenda mentioned above)

<li>Because XML is <em/much/ easier to parse than fully general SGML,
it is <em/much/ easier to produce parsers for it.  It is therefore
very likely that we will soon see many XML editors and XML-aware
browsers in the months to come.

<li>We should also see XML-aware search engines, potentially finally
realising the possibilities offered by hightly structured information
storage and retrieval.

<li>The development of 
<webref url='http://www.w3.org/Math/' >MathML</webref> should help see
maths on the internet

</ul>

<subsect id=final.ack export>Acknowledgements

<p>I've benefited greatly from various contributers to the usenet
newsgroup <code/comp.text.sgml/, from the Oasis SGML pages at
<url>http://www.oasis-open.org/cover/</url> and references there, and
specifically from the various papers made available by Eliot Kimber
and co.~at <webref url='http://www.isogen.com' >Isogen International
Corp</webref>. 

<p>The DSSSL code started off heavily based on Norman Walsh's <webref
url="http://nwalsh.com/docbook/dsssl/" >DocBook
DSSSL stylesheets</webref>.

<p>Mark Taylor provided a great deal of elaborate criticism of the DTD
structure.  Though I haven't agreed with all his suggestions, future
users of this kit have a lot to thank him for in terms of the
flexibility and usability of the DTD.

<appendices>

<sect id=appx.sgml export>SGML -- some of the details

<p>This section covers some SGML topics in a little more detail than is
necessary if you simply want to write Starlink documents.  It should
give you enough understanding to allow you to read most DTDs.

<p>This section is for extra, or more detailed, information than it
was necessary to include in <ref id=markup>.  It will not, therefore,
repeat information presented there.

<subsect id=sgml.std export>Standard identification

<p>The SGML Standard Identification:
<blockquote>
An SGML Application Conforming to International Standard ISO 8879 --
Standard Generalized Markup Language
</blockquote>
SGML has many features not described in this document.
For further details, see the standard, <citation/iso8879/ or
<citation/goldfarb/ (better, since it contains all the standard text
plus commentary).

<p>The HyTime Standard Identification:
<blockquote>
A HyTime application conforming to International Standard ISO/IEC
10744 -- Hypermedia/Time-based Structuring Language
</blockquote>
For further details of the possibilities available via HyTime, see
<ref id=appx.system.hytime>, or the HyTime
standard,~<citation/iso10744/.

<subsect id=sgml.dtd export>Reading DTDs

<p>The discussion in <ref id=markup> should be enough to let you
produce your own documents but, now or in the future, you may find it
useful to be able to read the DTD directly.<note>Note for pedants:
there is a distinction between document type declaration and
definition.  The document type definition is the collection of rules
which specifies which elements can go where, what attributes they
have, and so on; the declaration is the <code>&lt;!DOCTYPE...></code>
invocation at the top of the document file -- the `document instance'
in SGML parlance -- which associates that instance with a particular
definition.  The abbreviation `DTD' usually refers to the definition,
and it is the definition that this section is about.</note> Once you
are familiar with the underlying ideas, the expression of them in the
DTD turns out to be agreeably compact and reasonably readable.

<p>My account of the DTD syntax will be rather compressed -- see
<citation/gentle/, or the other references in <ref
id=what.sgml> for alternatives.

<p>A simple HTML-like DTD could be declared as follows:
<verbatim><![ CDATA [
<!ELEMENT html      O O (head, body, copyright?)>
<!ELEMENT head      O O (title & link*)>
<!ELEMENT title     - - (#PCDATA)>
<!ELEMENT link      - O EMPTY>
<!ELEMENT body      O O (p | dl)+>
<!ELEMENT p         - O (#PCDATA)>
<!ELEMENT dl        - - (dt, dd)+>
<!ELEMENT (dt|dd)   - O (#PCDATA)>
<!ELEMENT copyright - - (#PCDATA)>

<!ENTITY % URL "CDATA"
        -- The term URL means a CDATA attribute
           whose value is a Uniform Resource Locator,
           See RFC1808 (June 95) and RFC1738 (Dec 94).
        -->
<!attlist link
    href  %URL          #REQUIRED  -- URL for linked resource --
    rel   (next | prev) #IMPLIED   -- reverse link types --
    >
<!ENTITY amp "&">
]]></verbatim>
And here is a simple document which uses this DTD:
<verbatim><![ CDATA [
<link href="http://www.astro.gla.ac.uk/users/norman/" rel=next>
<title>This is a title</title>

<p>And here is a paragraph
<dl>
<dt>With a delimited list
<dd>Correctly formed &amp; OK
</dl>
]]></verbatim>
This displays most of the important syntactical features in an SGML
DTD, so if we explain it line-by-line, it should illustrate the
features you need to make some sense of most DTDs.

<p><verbatim><![ CDATA [
<!ELEMENT html    O O (head, body, copyright?)>
]]></verbatim>
This `element declaration'
declares the <code/html/ element.  The element type name is followed
by a statement of whether the start and end tags may be omitted if the
parser can infer their presence.  The minimisation specifications may
be either `-' (minus), indicating that the corresponding tag is
required, or `O' (letter~O), indicating that it may be omitted.
Following this is the `content model' which, in this case, states that
the <code/html/ element must consist of one <code/head/, one
<code/body/, and an optional <code/copyright/, in that order -- the
comma connecting the element 
names specifies that they must be in order, and the question mark
following the copyright element indicates that it may occur zero or
one times. 
The omission of the start element is possible in this case, since the
first element in the <code/html/ element must be a <code/head/
element, so whenever the parser finds a <code/head/ element, it can
know that the <code/html/ element has begun.

<p>So what is in the <code/head/ element?
<verbatim><![ CDATA [
<!ELEMENT head    O O (title & link*)>
]]></verbatim>
The <code/head/ element consists of precisely one title, and zero or
more <code/link/ elements, in either order.  The <code/head/ tags
can be inferred from the presence of
the <code/title/ and <code/link/ elements, and so it is feasible for
us to declare that they may be omitted.  The star following the
<code/link/ token in the content model indicates that this element may
appear zero or more times, and the ampersand declares that the
elements on either side of it must both appear, but can do so in
either order.  Note that this content model allows `<code/title/',
`<code/title link link.../' and `<code/link link...title/', but not
`<code/link/' or `<code/link title link/'.

<p>Finally we have some text:
<verbatim><![ CDATA [
<!ELEMENT title   - - (#PCDATA)>
]]></verbatim>
The title element is very simple: neither the start not the end tag
may be omitted, and it may contain only characters (<code/#PCDATA/
stands for `parseable character data') and entity references such as
<code/&amp;amp;/.

<p><verbatim><![ CDATA [
<!ELEMENT link    - O EMPTY>
]]></verbatim>
The <code/link/ element has no actual content, so it is given a
content model consisting of the reserved word <code/EMPTY/.  The tag
omission for empty elements is always `<code/- O/'.  The point of the
<code/link/ element is to hold its attributes, which we will come to
shortly.

<p><verbatim><![ CDATA [
<!ELEMENT body    O O (p | dl)+>
]]></verbatim>
The document body consists of paragraph elements, or `delimited
lists'.  The `or' connector, `<code/|/', indicates that either of the
<code/p/ or <code/dl/ elements may appear, and the `plus' occurrence
indicator asserts that the group <code/(p|dl)/ must appear one or more
times.  In other words, the body consists of a sequence of <code/p/
and <code/dl/ elements in arbitrary order.

<p>Finally, we start to specify the `interesting' content of the document.
<verbatim><![ CDATA [
<!ELEMENT dl      - - (dt, dd)+>
]]></verbatim>
Like the <code/body/ itself, the <code/dl/ element consists of a
sequence of one or more structures.  Unlike the <code/body/ element,
however, the structure is not a list of alternatives, but a sequence.
Where the <code/body/ element would allow `<code/p p dl p/' for example, the
<code/dl/ element requires that the <code/dt/ and <code/dd/ elements
alternate -- the repeatable element is the <em/ordered pair/ of
elements `<code/dt, dd/'.

<p><verbatim><![ CDATA [
<!ELEMENT (dt|dd) - O (#PCDATA)>
<!ELEMENT p       - O (#PCDATA)>
<!ELEMENT copyright - - (#PCDATA)>
]]></verbatim>
The paragraph, list and copyright elements have simple content
models.  Note that we can specify the structure of more than one
element in the same declaration.

<p>Prior to specifying the attributes for the <code/link/ element, we
may declare an abbreviation.
<verbatim><![ CDATA [
<!ENTITY % URL "CDATA"
        -- The term URL means a CDATA attribute
           whose value is a Uniform Resource Locator,
           See RFC1808 (June 95) and RFC1738 (Dec 94).
        -->
]]></verbatim>
This declares <code/URL/ to be a `parameter entity', usable only
within this DTD.  The entity reference `<code/%URL/' will be
substituted by the string `<code/CDATA/' (unparsed character data)
when it is encountered.  A DTD may declare an entity more than once,
but any declarations after the first are silently ignored.

<p>Note the structure of the comment in this last declaration: in SGML,
comments may appear only within markup declarations (that is within
`<code/&lt;! ... >/'), they start and end with the string
`<code/&#45;&#45;/', and there may be more than one in a row.  Thus you
may legally find `<code/&lt;!>/' within an SGML file -- this is a
completely empty markup declaration.  Such a declaration may have a
single comment within it, as in `<code><![ CDATA [<!-- this is a comment
-->]]></code>', or it may have several, as in
<code><![ CDATA [<!-- here -- -- is a comment ------>]]></code>, which
has <em/three/ comments within it, the third of which is empty. 

<p>Now we declare the attributes for the <code/link/ element.
<verbatim><![ CDATA [
<!attlist link
    href  %URL          #REQUIRED  -- URL for linked resource --
]]></verbatim>
This declares an <code/href/ attribute.  After expansion of the
<code/%URL/ entity reference, this attribute is seen to have a
`declared value' of <code/CDATA/ (unparsed character data), and this
attribute is required to be present, so that the SGML parser will
object if it finds a <code/link/ element in a document without an
<code/href/ attribute.

<p>The <code/rel/ attribute can take only two values:
<verbatim><![ CDATA [
    rel   (next | prev) #IMPLIED   -- reverse link types --
    >
]]></verbatim>
The <code/link/ element may have the attribute `<code/rel=next/' or
`<code/rel=prev/', but no other strings.  Since this attribute is
`<code/#IMPLIED/', it is also permitted to omit it entirely.  A
document may even specify this as simply `<code/&lt;link
href=&quot;here.html&quot; next>/' and the parser will infer that the value
`<code/next/' is associated with the attribute name `<code/rel/'.

<p><verbatim><![ CDATA [
<!ENTITY amp "&">
]]></verbatim>
Entity references (other than parameter entities, which are internal
to a DTD) are made using a
construction such as `<code/&amp;entname;/.  This presents a problem
if you want to include the ampersand in your text, but this
declaration sets up an entity called `amp', which can be used to
include an ampersand in text by typing `<code/&amp;amp;/'.  You can
use this in your own documents to create shorthand forms for bits of
text you don't want to retype.

<subsect id=sgml.dtdsubset export>Document type declaration subset

<p>As explained above, the structure of your document type, plus a
variety of entities, is declared in the DTD, which, because it is
common to a large number of documents, is held separately
from the document you are writing.

<p>It is possible, however, for a specific document to adjust or add to the
declarations within the DTD, and this is done within the `document
type declaration subset'.

<p>The DTD subset is typically used to declare entities of one type or
another, as described in <ref id=markup.dtdsubset>.

<p>The subset is a DTD fragment which is processed <em/before/ the
declaration refers to.  Thus, any (parameter) entity declarations
there override corresponding ones in the DTD, so it is possible for a
document author to do some limited rewriting of the DTD on the fly.
This will be most common when a DTD is modular, as the Starlink DTD
is.  As described in <ref id=str.structure>, you can enable features
within your DTD by setting a suitable entity.

<p>This get-out-of-jail-free card is obviously eminently abusable, and
you should avoid doing anything clever here.

<subsect id=sgml.entities export>SGML entities

<p>As described in <ref id=markup.entities>, entity references are a
mechanism for referring to characters, or 
longer pieces of text, which you cannot type on your keyboard, which
must be escaped from the parser, or which you simply want to
abbreviate.

<p>As well as general entities, there are parameter entities.  These
can be referenced only within markup declarations, and hence are
effectively restricted to the DTD.  The only time you'd use them in a
document instance would be within a marked section (<ref
id=markup.ms.variants>).  The point of parameter entities is that a document
author can define any entities they want in the declaration subset,
without having to worry that they might conflict with declarations in
the DTD.

<p>A reference to an entity <code/amp/ is of the form
<code/&amp;amp;/.  It is prefixed by the character <code/&amp/ and
suffixed by a semicolon.  In fact, you can omit the trailing semicolon
if the character following the entity name is not a name character --
not a letter, number, hyphen or dot.  Similarly, an ampersand not
followed by a name-start character (upper- and lowercase letters) is
recognised as an ampersand, and not a malformed entity reference.  It
is possibly bad to get into the habit of abbreviating entity
references, but you might need to be aware that these features both
exist and are legal.

<p>The list of entities predefined by the Starlink general DTD is
given in <ref id=table.entities>.

<p>It is not an error to define an entity twice.  In this case, the
second definition is silently ignored.

<p>You can define entities, including parameter entities, in the
document's `declaration subset' (see <ref id=markup.dtdsubset>), since
these conceptually come before, and hence have priority over,
definitions in the DTD.  Also, SGML parsers usually allow 
on-the-fly definitions on the command line.  However, resist resist
resist the temptation to do clever things here, since it is easy to
make your document unreadable and, a much more heinous crime, invalid.

<subsect id=sgml.ms export>Marked sections

<update versionid="post-0.2">This section trimmed, and the
discussion of the `author-visible' uses of MSs moved to the `Marking
up...' section.

<p>As described in <ref id=markup.ms>, SGML includes the notion of a
`marked section'.  These are used only rather occasionally by authors,
but are very frequently used within DTDs, particularly the
<code/IGNORE/ and <code/INCLUDE/ marked sections.

<subsubsect>IGNORE and INCLUDE marked sections

<p>About the only use of the <code/IGNORE/ and <code/INCLUDE/ marked
sections in documents is to delimit variant sections of text (see <ref
id=markup.ms.variants>).  They are, however, very common within DTDs.

<p>Why on earth would you want to include or exclude text in DTDs?
Because the IGNORE/INCLUDE 
keyword can be the expansion of an entity.  We could have defined our
HTML-like document type as follows:
<!-- can't use marked section when I'm illustrating one! -->
<verbatim>
&lt;!ENTITY % allow.copyright &quot;IGNORE&quot;>
&lt;![ %allow.copyright; [
  &lt;!ENTITY % html.model &quot;head, body, copyright?&quot;>
  &lt;!ELEMENT copyright - - (#PCDATA)>
&rsqbrack;]>
&lt;!ENTITY % html.model &quot;head, body&quot;>
&lt;!ELEMENT html    O O (%html.model;)>
</verbatim>
This looks very strange, but it is a common idiom.  

<p>The entity reference <code/&percent;allow.copyright;/ is a
`parameter entity reference' (see section <ref id=sgml.entities>),
which is distinct from a general entity 
reference such as <code/&amp;amp;/, and can occur only within markup
(ie, within DTDs).

<p>The parameter entity <code/%allow.copyright/ is defined to be
<code/IGNORE/.  That means that when the parser finds the marked
section it ignores it, so that the first definition it finds of the parameter
entity <code/%html.model/ is the one which sets it to be
`<code/head,body/', so that is what is used as the content model
in the declaration of the <code/html/ element in the last line.

<p>Nothing appears to have been achieved here.  However, if the
<code/%allow.copyright/ entity had <em/earlier/ been set to
<code/INCLUDE/, then the redefinition of it here would have been
ignored, the marked section would have been included, the
<code/%html.model/ entity would have been defined as
`<code/head,body,copyright?/' with the (now) second one ignored, and
the <code/html/ element would have been defined to allow all three
elements.  That is, marked sections used internally in this way can be
a useful way of parameterising DTDs.

<p>The entity could be declared earlier in the same DTD, in a
particular document's DTD-subset (see <ref id=markup.dtdsubset>), or
completely externally to the document in a command-line option to the
parser.

<sect id=appx.system export>The Starlink SGML set for maintainers
<update versionid="post-0.2">Very substantial additions -- this
section was barely present before.</update>

<p>This section is a reference for maintainers of the Starlink SGML
set

<subsect id=appx.system.sgml export>SGML arcana

<subsubsect id=appx.system.sgmldoc export>The SGML status of this project

<p>The SGML application conforms to the SGML~<citation/iso8879/ and
HyTime~<citation/iso10744/ standards.  The processing system uses
DSSSL (see <ref id=appx.system.dsssl> and~<citation/iso10179/), which
is a standard, but generates HTML using DSSSL extensions specific to
Jade, and generates LaTeX using DSSSL extensions specific to a patched
version of Jade.

<p>A good deal of effort has been invested in making the SGML side of
this project both robust and correct.  `Correct' here means a lot more
than merely `it works': it means that it conforms with both the letter
and the spirit of the SGML standard, and with the occasionally
nebulous notions of `best practice' for SGML applications.

<subsubsect id=appx.system.hytime export>HyTime, architectures and groves

<p>As noted above, in <ref id=appx.system.sgmldoc>, this DTD is an
application of the HyTime standard.

<p>The HyTime standard <citation/iso10744/ specifies three things,
which are distinct, but easily confused (the standards document is not
an easy read -- not because it is unclear, but because it is so very
abstract; there are unfortunately few accessible alternatives).  It
defines a standard processing model for SGML documents in terms of the
`grove'; it extends the SGML standard by introducing the notion of
`architectures'; and it specifies a particular architecture -- the
HyTime architecture -- for abstracting the semantics of document
links.

<p>A `grove' is an acyclic directed labelled graph (I think!) --
alternatively defined, even in the HyTime standard, as `a bunch of
trees and other stuff' -- which is the data structure into which an
SGML document is nominally transformed, and with respect to which the
semantics of SGML standards (SGML itself, HyTime, DSSSL and others)
are now formally defined.  DSSSL is designed to be able to query the
grove straightforwardly and efficiently, but unless you are
maintaining the more recondite parts of the DSSSL sources, which query
a few grove properties directly, you will not need to be aware of
anything more than the grove's formal existence.  The grove is
formally defined in <webref
url="http://www.ornl.gov/sgml/wg8/document/n1920/html/clause-A.4.html"
>ISO/IEC 10179, clause~A.4</webref>: there are introductions and
tutorials on the relevant Oasis <webref
url='http://www.oasis-open.org/cover/topics.html#groves' >special
topic</webref> list, of which Paul Prescod's tutorial
<citation/prescod99/ is particularly good, and Kimber has written
variously on this <citation/kimber97c/.

<p>An `architecture' is a skeleton DTD (the HyTime first edition name
for it was `meta-DTD').  An individual DTD may declare itself to be a
`client' of the architecture by asserting the fact, and defining (or
allowing to be defaulted) a mapping between the element forms it
defines, and those defined in the architecture (the architectural
elements are referred to as `architectural forms' in that context).
For example, the Starlink General DTD declares itself to be a client
of the DocumentSummary DTD (which is easy, because the elements
defined in the latter are a subset of the elements defined in the
former), and the DSSSL programcode DTD declares itself to be a client
of the DSSSL architecture, with suitable remappings of element and
attribute names (see <ref id=doccode.dsssl> for discussion, and see
the reference cited there).  For formal details see the HyTime
standard, particularly clause~A.3, <cite/Architectural forms
declaration requirement/.  The relevant Oasis
<webref url='http://www.oasis-open.org/cover/topics.html#archForms'
>special topic</webref> has an overwhelming number of references on
this, of which Kimber's article <citation/kimber97b/ is very good.

<p>Finally, the HyTime standard defines a particular architecture --
the so-called HyTime Architecture.  This architecture defines forms
(ie, elements in a meta-DTD) suitable for expressing all kinds of
linking semantics, from a simple link from one part of a document to
another, all the way up to indirect many-to-many links between
fragments of non-SGML media (for example sections of an image or
passages in a piece of music).  Crucially, it defines the semantics of
these forms formally and precisely.

<p>As a consequence a DTD can declare itself
to be a client of (some subset of) the HyTime architecture, formally associate
elements it defines with the available architectural forms, and thus
inherit the precise semantics and associated documentation.
The point of this is twofold.  Firstly, it means that the DTD
inherits the documentation of the forms it has referred to.  A reader
of the DTD, who is familiar with HyTime, can therefore look at a
declaration and immediately know what its intended meaning is.
Secondly, that reader of the DTD need not be human: a `HyTime engine'
is a processor which can interpret the HyTime forms in a document and
process them correctly without further configuration.

<p>For example,
the Panorama SGML viewer is an application, which is also available as
a Netscape plug-in, which will display SGML.  When it displays SGML,
it formats it appropriately, guided by a style-sheet which expresses
things like what font to display headings in.  It also, however, has
built-in knowledge about the HyTime <code/clink/ element (`contextual
link'), and knows what to do with it.  If the viewer is given a
document and DTD which has properly declared itself as a HyTime
client, such as the Starlink General DTD, then Panorama can format and
follow <code>&lt;ref></code> elements (for example) immediately.

<p>The <ref id=el.sun.webref text='webref'> element in the Starlink
General DTD is declared much as follows (compare <citation/iso10744/,
clause~7.8)
<verbatim>
&lt;!ELEMENT WEBREF - - (#PCDATA)>
&lt;!ATTLIST WEBREF
    url      CDATA #REQUIRED
    &ddash HyTime attributes... &ddash;
    HyTime   NAME  #FIXED clink
    HyNames  CDATA #FIXED "linkend url"
    anchcstr NAMES #FIXED "self required"
    linktrav NAMES #FIXED "A D"
    loctype  CDATA #FIXED "url QUERYLOC URL"
    >
</verbatim>
Line-by-line, this says that the element is mapped to the HyTime
`clink' element, that that element's `linkend' attribute should be
mapped to the webref element's `url' attribute, that the direction of
the link is from the link itself to a to a required target, that
traversal of the link consists of arriving at it (putting a mouse over
it and clicking, for example) and then departing from it (ie, the link
is one-way -- the fact that a browser may add semantics to this by
providing a back button is not part of the definition of a webref
element, nor part of its meaning in the context of a particular
document), and finally that the content of the `url' attribute is a
query in a predefined notation referred to as `URL'.  A HyTime
processor therefore transforms the element <code>&lt;webref
url="http://www.hytime.org">Hello&lt;/webref></code> into
<code>&lt;clink linkend="http://www.hytime.org" linktrav="A D"
loctype="url QUERYLOC URL">&lt;/clink></code>.
<!-- FIXME: is this right, or should it be loctype="linkend queryloc url"?-->

<p>If you're curious, you can obtain the HyTime view of a document
with the command <kbd/sgmlnorm -A hytime ssn70.sgml/.<note>Note that
this currently doesn't work fully -- there's some defect in the HyTime
declaration of the docxref element type which I haven't been able to
identify.</note>

<p>The linking elements in the Starlink General DTD have been defined
in terms of HyTime.  This is partly for documentation purposes, partly
for completeness, but mostly so that the groundwork will have been
done when there is an opportunity to use a HyTime-aware application
such as Panorama.  I will claim this as a full implementation,
however: I have no access to a HyTime engine, and so I cannot test
that the HyTime declarations here are in fact correct.

<p>See <ref id=appx.system.online> for online resources.

<subsubsect id=appx.system.dsssl export>DSSSL

<p>The SGML processing part of this package is implemented in DSSSL,
which is a standard <citation/iso10179/ for device independent
formatting of SGML documents.  DSSSL includes both a style language
and a (DTD to DTD) transformation language.  

<p>I have used James Clark's Jade
implementation of DSSSL.  This implements the style language, but not
the transformation language.<note>Although I believe Clark was involved with
the specification of the DSSSL standard, he has said (on the <webref
url="http://www.mulberrytech.com/dsssl/dssslist/" >DSSSList
discussion list</webref>, May 1999) that the transformation
language has significant weaknesses.</note>  Jade has back-ends which
generate RTF, MIF and rather odd &tex; requiring a specialised
&tex; format.  Clark added an SGML-transformation back-end, as a Jade
extension of the standard, which uses non-standard flow-object
constructors to specify SGML elements, entities and the like.  In
addition, I added a back-end which generates &latex;.

<p>It follows that the stylesheets which implement this Starlink
package are not standards-conforming, and are specific to Jade.  This
needs a little justification.

<ul>
<li>There are not too many alternative ways of producing HTML.  Perl
is a contender, since the <code/SGMLSpm/ package (see <webref
url='http://www.cpan.org' >CPAN</webref>) can parse the output of
<code/nsgmls/.  This is perfectly legitimate, but I know from
experience that it can become rather messy.<note>It's a matter of
taste whether you prefer Perl or DSSSL.  DSSSL, based on Scheme Lisp,
is undeniably odd, but I've grown to rather like it.  A language with
no assignments, no loops, no real sequences of actions, and where
absolutely everything is a function, has a certain rather twisted
glamour to it, like a nature programme about fish-life four miles down
the Marianas Trench.</note>

<li>DSSSL has very good access to the SGML grove, and processes the
document in a generally `SGML-ish' way.  This feels like keeping
things in the family, as it were, even if the non-standard back-ends
have something of the wicked stepmother about them.

<li>One alternative is through XML and XSLT, but this would require
doing the work to transform the document from SGML to XML (which would
lose the subdocument processing features), and using XSLT which, from
what I've seen of it, looks like hell on earth.

</ul>

<p>This does not in any way affect the standards conformance of the
rest of the SGML set -- the various DTDs and the HyTime support --
since the processing of documents is by design completely independent
of the standards which define their markup.

<p>See <ref id=appx.system.online> for online resources.

<p><ref id=appx.system.dssslcode> includes documentation for some of
the important DSSSL stylesheets.

<p>Notes on the code:
<ul>
<li>In almost all cases, the code for the HTML stylesheet was
developed first, then adapted for the &latex stylesheet.  This makes
sense in general, as the HTML stylesheet has to do much more elaborate
formatting and rearrangement, whereas &latex can do much of the
simple information-shuffling itself.  It does, however, mean
that some fragments of code are duplicated in the two stylesheets,
even although the <code/slcommon.dsl/ stylesheet is supposed to cover
all of that -- when it happens, this is typically an error, rather
than some great subtlety.

<li>The code started off as adaptations to Norman Walsh's DocBook stylesheets.
In some modules -- primarily the <code/slnavig.dsl/ code which was the
section I began development with -- there are still relics of this
here and there.  There isn't a lint for Jade, so it's not trivial to
find and remove these.

<li>It's unattractive that the print-based stylesheet is so specific
to &latex;, and goes against the format-independent goals of DSSSL.
If it becomes necessary to produce another output format at the same
level of abstraction as &latex; -- 'roff would be an example, though
that seems unlikely -- the way to proceed would be to adapt the
&latex; stylesheet to produce output marked in some DTD which matches
the abstraction level of &latex; -- that is, describing sections and
paragraphs and so on, rather than the placement on the page which is
characteristic of the standard DSSSL FOs -- and then translate that to
&latex; and whatever.  The latter translation would be easy, since
there would likely be no information shuffling at all, but a
translation task little more demanding than search and replace.

</ul>

<subsubsubsect id=appx.system.jade>Jade and OpenJade
<update versionid="v0.6">Included description of, and pointer to,
OpenJade</update>

<p>James Clark's Jade distribution, at
<url>http://www.jclark.com/jade/</url>, has been frozen at Jade 1.2.1.
Jade development has now forked, with `OpenJade' being developed by
the community.  This is based at 
<url>http://jade-cvs.avionitek.com/</url>.  I hope to move to this
distribution when time is available.

<subsubsubsect id=appx.system.paramdsssl>Customising the DSSSL source
code.

<p>The DSSSL source code which produces the HTML and &latex; output
has been parameterised to a limited extent.  As described in <ref
id=appx.system.dssslcode>, it can therefore be customised either on the
Jade command line, or by providing Jade with an alternative DSSSL
parameters file.

<p>Jade has a <code/-V/ option which takes a DSSSL variable name as
argument; this variable is then given the value <code/#t/ (true),
overriding any other definition in a stylesheet.  Several of the
stylesheets' parameters are designed to be settable this way.  You can
either give this option explicitly on a Jade command line, or pass it
to Jade via the <code/sgml2docs/ command line (see <ref id=proc.sgml2docs>):
<verbatim>
sgml2docs --jadeflags '-V show-element-ids' ...
</verbatim>

<p>If this type of customising is insufficient, then you may take a
copy of the appropriate parameters file in <code
fspath>$STARLINK_SGML_DIR/dsssl/sl/html/slparams.dsl</code> (or the
corresponding <code>.../latex</code> file), call it, say
<code/my-params.dsl/, and change what parameters 
you like.  The stylesheets refer to the parameters files by the public
identifiers <code>PUBLIC "-//Starlink//TEXT DSSSL Common Parameterisation//EN"</code>,
<code>PUBLIC "-//Starlink//TEXT DSSSL HTML Parameterisation//EN"</code>
and <code>PUBLIC "-//Starlink//TEXT DSSSL LaTeX Parameterisation//EN"</code>,
and these are mapped to the real files by the catalogue file in <code
fspath>$STARLINK_SGML_DIR/dtd/CATALOG.starlink</code>.  To direct the system to
your own parameter file instead, create a catalogue file of your own
(conventionally given the name <code/CATALOG/), and include the
appropriate line like
<verbatim>
PUBLIC "-//Starlink//TEXT DSSSL HTML Parameterisation//EN" my-params.dsl
</verbatim>
(you can give a path relative to the location of the catalogue, and
it's best if you quote the entry exactly as here).  To direct the SGML
system to this catalogue, you must include the file at the beginning
of the <code/SGML_CATALOG_FILES/ environment variable:
<verbatim>
SGML_CATALOG_FILES=./CATALOG:$SGML_CATALOG_FILES
</verbatim>
(or use the corresponding <code/setenv/ command).

<subsect id=appx.system.software export>Supporting software

<p>This distribution primarily consists of SGML materials --
that is, the DTDs and associated DSSSL stylesheets.  It also relies on
the Jade DSSSL engine, suitably patched, and the
<code/dvi2bitmap/ package (to help generate the GIFs used when
displaying maths on the web.   See <ref id=install> for further
details of obtaining and building these.

<p>As well as these supporting applications, which must be obtained
and installed separately, there is some auxiliary software distributed
with the package itself.  This is located in <code
fspath>$STARLINK_SGML_DIR/lib</code>.

<dl>
<dt><code/abstract-star2html.pl/
<dd>A Perl script which does a simple but robust parse of &latex;
files suitable for the Star2HTML system, generating DocumentSummary
documents.  See <ref id=appx.system.summaries>.

<dt><code/img-eqlist.pl/
<dd>This post-processes the file produced by the <code/img.maths/ mode
of <code fspath>$STARLINK_SGML_DIR/dsssl/sl/html/slmaths.dsl</code>.
It produces two files, based on the filename root of the argument.
The SGML one conforms to a very simple DTD (with system id
<code/img-eqlist/) which maps equation labels to filenames, the the &latex;
one consists of a &latex; document with one equation per page.  The
latter should be processed by &latex; plus whatever dvi to gif magic
you need, making sure that the resulting GIF filenames match those
in the img-eqlist document.  See the file header for further
documentation.

<dt><code/plainhtml.bst/ and <code/plainlatex.bst/
<dd>These are Bib&tex; style files used by the Bib&tex; step in the
common makefile.

<dt><code/postprocess-bbl.sed/
<dd>This postprocesses the bibliography file produced by
<code/plainhtml.bst/, rejoining the long lines which Bib&tex;
erroneously splits.

</dl>

<p><ref id=appx.system.dssslcode> includes a selection of the more important
DSSSL code modules.

<subsect id=appx.system.summaries export>Document summaries

<p>When referring to an external Starlink document via a <ref
id=el.sun.docxref text='docxref'> element, the processing system must
generate both the link text and, in the case of the HTML stylesheet,
the URL which is the link target.  It does this by processing the
document referred to by the element's `doc' attribute.  This document
must be marked up using the `document summary' DTD,
<code>"-//Starlink//DTD Document Summary 0.1//EN"</code>.

<p>The Document Summary DTD has the same general structure as the
Starlink General one, but the only text in it is the abstract
(possibly) and the content of the various section headings.  The
SGML set uses the structure expressed in here, to work out the section
number which will be given to the link text.
The DTD has attributes to control a `link policy' (whether we may link
to all elements, or only those with the export attribute present), and
exercise some control over the URLs which will be used in HTML
targets, if these are not to be generated using the same algorithm
used for the main document.  There is more flexibility in the Document
Summary DTD than is used at present.  The DTD is well-commented, and
you should refer to it for further details.

<![ IGNORE [
<p>The installation procedure generates document summaries for all the
Starlink documents it can find, using the script
<code fspath>$STARLINK_SGML_DIR/lib/abstract-star2html.pl</code> to scan
documents marked up ready for processing by Star2HTML.  This script
does not currently do a very neat job -- it's primarily designed to be
robust enough to be used in an unattended installation procedure, so its
&latex; parsing is somewhat simpleminded.  As noted in <ref
id=appx.system.htx>, the installation makefile invokes this script in
a precise way, to make generated HTML output conform to the
requirements of HTX.
]]>

<p>Since the Starlink General DTD declares itself as a client of the
Document Summary DTD (see <ref id=appx.system.hytime> for a discussion
of architectures), the processing of cross-referenced documents could
be done by having the `doc' attribute point to the main SGML source of
the target document and extracting the DocumentSummary architectural
instance.  DSSSL's <code/(sgml-parse)/ function does not, however,
support the extraction of architectural instances.  There is a Jade
patch at <webref url='http://www.isogen.com' >Isogen</webref> which
adds this as a Jade extension; this has been incorporated into the
OpenJade distribution (see <ref id=appx.system.jade>), but not (yet)
into the Starlink version of Jade which accompanies this
set.  Note, however, that this is almost entirely an implementation
issue: if this feature were to be added to Jade, as it might be if it
conforms to any updated DSSSL standard which includes this feature,
the only changes necessary would be a possible adjustment of that
element's HyTime declaration, some adjustment of the call of the
relevant <code/(sgml-parse)/ function, and corresponding changes in
the package's installation script so that the document summary
catalogue points to the original documents rather than a
freshly-generated set of summaries.  There would be no need for
documentation updates, since there would be no user-visible changes.
It is possible to extract the DocumentSummary architectural instance
by hand, using the command <kbd>sgmlnorm -A documentsummary
ssn70.sgml</kbd> for example.

<subsect id=appx.system.htx export>Cross-references, installing
documents, and the interaction with HTX

<p>The system generates cross-references to other Starlink documents
without further editing.  It does not test that the HTML target
exists, but assumes that if the document summary files exist, then the
HTML targets exist, or will exist by the time the output documentation
is installed.  An alternative system would have the link targets refer
to a live document server, so that the targets would be resolved when
they are referenced, rather than when the document is processed.  This
would, however, be unnecessarily complicated for a first version of
the system, as well as going beyond the current, and adequate, HTX
model.

<p>The current SGML set uses Star2html and HTX.  Star2html (see <docxref
doc=sun199>) generates a distributable document set with correct
internal cross-references, and `best guess', but possibly broken,
external ones.  These references are then patched up in a separate
installation phase, being edited by a copy of HTX primed with
appropriate local knowledge (see <docxref doc=sun188
loc=how_linking_works>).

<p>The aim of the current set is to produce documents which are in
their final form, and can be moved to their final location without
further editing -- this assumes that documents are distributed in
(SGML) source form and processed at installation time, and that the
SGML set is the only system producing documentation.  This aim has
been achieved in the current version, but could benefit from more
convenient parameterisation.

<p>Since HTX is likely to remain in use for the forseeable future, 
the current set is intended to be used with HTX, and is claimed
to be compatible with it.  It produces links in the format recognised
by HTX, as described (or defined?) in <docxref doc=sun188
loc=referring_to_targets>.  Note two points, however.  

<ul>
<li>The generated
document set is compatible as <em/input/ to HTX, and does not attempt
to emulate it to the extent of generating HTX index, catalogue and log
files.  This would not, however, be terribly difficult, and might
appear in a future version of this set.  There is therefore at
least a potential interaction between the development of the two
systems, and if you are involved in the development of either, some
liason would be useful.

<li>The compatibility is assured by cooperation between several
disjoint processing steps.  The DSSSL style sheets generate
appropriate internal labels, and the HTML parameters style sheet
contains a variable which sets the `document server' which is used
when generating URLs.  The document-summary DTD (see <ref
id=appx.system.summaries>) includes a <code/urlpath/ attribute in its
section and label elements which specifies the tail of the URL where a
particular section lives, relative to an (unspecified) document
server.  The <code/abstract-star2html.pl/ script includes a
<code/&ddash;prefix/ option to control the start of this attribute,
and this option is used when this script is invoked during the
installation stage of the package makefile, so that the <code/urlpath/
attribute starts with the string <code>sunNNN.htx/</code> (as
appropriate), ready to be recognised by HTX.  This separation may seem
complicated, but it separates, as much as possible, features which are
internal to the system (internal labels and generated HTML filenames)
from features which are properly external (URL paths and locations in
a filesystem), using the document-summary files and the script used to
generate them as the interface.

</ul>

<subsect id=appx.system.dssslcode export>The DSSSL source code

<routinelist>
<p>The following sections document some of the more important DSSSL
style sheets

<codecollection doc="dsssl.params">
<codecollection doc="dsssl.common">
<codecollection doc="dsssl.lib">

<subsect id=appx.system.online export>Online resources

<subsubsect>HyTime and architectures

<p><dl>

<dt><url>http://www.ornl.gov/sgml/wg4/docs/n1920/</url>
<dd>Online materials for the HyTime standard

<dt><url>http://www.hytime.org/</url>
<dd>The HyTime users' group, including
<url>http://www.hytime.org/papers/htguide.html</url>,
The HyTime reader's guide

<dt><url>http://www.oasis-open.org/cover/hytime.html</url>
<dd>The HyTime pages at Oasis.

<dt><url>http://www.isogen.com/papers/archintro.html</url>
<dd>A very good tutorial introduction to SGML architectures

<dt><url>http://www.cogsci.ed.ac.uk/%7eht/grove.html</url>
<dd>A picture of a grove.

<dt><url>http://www.hytime.org/materials/sgmlpropset/index.html</url>
<dd>An online, hyperlinked, version of the SGML Property Set.  This
requires some understanding of the grove concept and the SGML property
set, but once you have that, it's invaluable.

</dl>

<subsubsect>DSSSL

<p><dl>

<dt><url>ftp://ftp.ornl.gov/pub/sgml/WG4/DSSSL/</url>
<dd>The DSSSL standard

<dt><url>http://www.oasis-open.org/cover/dsssl.html</url>
<dd>The DSSSL pages at the Oasis SGML site

<dt><url>http://itrc.uwaterloo.ca/%7epapresco/dsssl/tutorial.html</url>
<dd>Paul Prescod's excellent DSSSL tutorial

<dt><url>http://www.mulberrytech.com/dsssl/</url>
<dd>Mulberry Technologies' DSSSL pages

<dt><url>http://www.mulberrytech.com/dsssl/dssslist/</url>
<dd>The DSSSList archive

<dt><url>http://www-swiss.ai.mit.edu/scheme-home.html</url>
<dd>The home page for the programming language Scheme, which is the
basis for the DSSSL language.  The language reference manual here is
excellently concise.

</dl>

<subsect id=install export>Installation

<p>The installation procedure should be standard.  When you have
unpacked the distribution, define the <code/SYSTEM/ and <code/INSTALL/
environment variables as usual, and type
<verbatim>
% ./mk build
% ./mk install
</verbatim>
This will install the DTD, DSSSL scripts and documentation in the
correct places.
<!--
, and generate document summaries for all the Starlink
documents it can find in <code fspath>/star/docs</code> (these
summaries are not necessarily perfect, as they do not attempt to do
anything clever with &latex; markup in the documents they are
abstracting; however the script which generates them should not
collapse during the installation).
-->
As noted in <ref id=proc.setup>, you prepare the set for use by
sourcing one of two scripts.

<p>This will also install a patched version of <code/Jade/, and an
appropriate copy of the <code/dvi2bitmap/ package.

<!-- Keep old Jade build instructions for the moment -->
<![ IGNORE [
<p>The SGML set does not have Jade packaged up within it, largely
because it's rather difficult to build.  I hope to work on this, but
at present, you will need to obtain, patch, and build Jade yourself.

<p>Unfortunately, Jade turns out
to be a real hassle to build with a compiler other than gcc.  The
author, James Clark, is a fine programmer, but apparently a bit of a
standards purist (he was involved with writing the DSSSL standard, and
with the development of XML/XSL): he seems to take the position that a
standards document is an adequate C++ user manual, and doesn't appear
to believe that porting software to non-conforming compilers should be
high on his priority list.  Now, I greatly approve of this attitude,
<em/but/ I'd rather I had the attitude alone, rather than sharing it
with Clark.  Jade builds
perfectly happily on gcc, but I've been struggling away for ages
trying to get it to build using Sun's and Digital's C++ compilers.  I
will distribute a runnable version of Jade eventually, but for the
moment, you'll have to build Jade yourself.  If <em/you/ manage to
build it using one of those, could you tell me what you had to do&ellip;.

<p>Get Jade from Clark's <webref
url='http://www.jclark.com/jade/' >Jade pages</webref>.  Before you
build it, you need to patch it to a Starlink-specific version, using
the patch at
<url>http://www.astro.gla.ac.uk/users/norman/distrib/jade.html</url>.
The configuration you'll need is:
<verbatim>
% mkdir -p /my/star/bin/sgml/bin /my/star/bin/sgml/lib
% ./configure &ddash;enable-latex &ddash;prefix=/my/star/bin/sgml
% make
% make install
</verbatim>
The stylesheets need Jade patched to version
<code/1.2.1-starlink-1.0b2/ (you can check Jade's version with
<kbd>jade -v &lt;/dev/null</kbd>).  Don't install Jade in the same
place as this package installs its binaries -- the installation script
for the SGML set assumes it has complete control over that
subdirectory, and will squash anything else it finds there.
]]>

<![ IGNORE [
<p>The application <code/dvi2bitmap/ is also required.  This is
distributed separately.  Until it finds its way onto the Starlink CD,
however, you can obtain a copy on <webref
url="http://www.astro.gla.ac.uk/users/norman/star/dvi2bitmap/" >my
dvi2bitmap page</webref>.
]]>

<sect id=appx.general.dtd export>The Starlink General DTD

<p>This section includes a list of all the elements in the Starlink
General DTD.  For a thematic treatment of the elements, see <ref
id=structure>, and the groups in <ref id=table.elements>.

<p>The elements listed here are shown as children of the top-level
element <code>&lt;sun></code>, because this is the most general of the
document types described in <ref id=str.structure>.  However, the
listing here does not <em/quite/ document the SUN DTD, since it
includes the <ref id=el.sun.docdate text='docdate'> element which is
only available in those document types which do <em/not/ have the
`Versioning' feature (see <ref id=str.structure> and <ref
id=str.history>).

<subsect id=appx.general.elementlist export>Element listing

<p>The following element listing includes all the elements and
attributes defined in the Starlink General DTD.  This includes a
number of attributes with a <em/fixed/ value (indicated by a default
keyword of <code/#FIXED/).  These are for internal use by the DTD and
the applications which process it, and are not documented further.

&starlinkdtddoc;

<sect id=appx.programcode.dtd export>The Programcode DTD

<p>See <ref id=doccode> for an overview of documenting code.

<p>The programcode DTD described here is the same for all languages.
When you invoke it, however, you do so using a document type
declaration specific to the language of the program being documented.
See <ref id=doccode.languages> for details.

<p>As noted above, in <ref id=doccode.elements>, the programcode
includes the same paragraph model as the Starlink General DTD.  In the
element listing below, therefore, these are not duplicated separately,
but instead consist of a reference to the appropriate part of the
General DTD's documentation.

<subsect id=appx.programcode.elementlist export>Element listing

&programcodedtddoc;

<sect id=appx.releasenotes export>Release Notes

&release.notes;
&release.notes.old;

<backmatter bibliography=ssn70>
