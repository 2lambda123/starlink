<!doctype ssn public "-//Starlink//DTD Starlink SSN 0.2//EN" [
  <!entity sgp28
	public "-//Starlink//DOCUMENT Summary SGP/28//EN" subdoc
	-- How to write good documents for Starlink -->
  <!entity sun188
	public "-//Starlink//DOCUMENT Summary SUN/188//EN" subdoc
	-- HTX -->
  <!entity sun199 
	public "-//Starlink//DOCUMENT Summary SUN/199//EN" subdoc
	-- Star2HTML -->
  <!entity sgmlsystem.eps system 'SGMLsystem.eps' ndata eps>
  <!entity sgmlsystem.gif system 'SGMLsystem.gif' ndata gif87a>
  <!entity starlinkdtddoc system '../dtd2sgml/starlink-0.2.sgmltext'>
  <!entity programcodedtddoc system '../dtd2sgml/programcode-0.2.sgmltext'>
  <!entity % Feature.Routinelist 'include'>
  <!entity rsqbrack ']'>
  <!-- DSSSL source code -->
  <!entity dsssl.lib
	system "../../dsssl/sl/lib/sllib.dsl" subdoc>
  <!entity dsssl.common
	system "../../dsssl/sl/common/slcommon.dsl" subdoc>
  <!entity dsssl.html.params
	system "../../dsssl/sl/html/slparams.dsl" subdoc>
  <!entity dsssl.latex.params
	system "../../dsssl/sl/latex/slparams.dsl" subdoc>
  <!entity release.notes 
	system "../../ReleaseNotes">
]>
<!-- $Id$ -->

<title>The Starlink SGML system
<author email='norman@astro.gla.ac.uk'
	webpage='http://www.astro.gla.ac.uk/users/norman'
	affiliation='University of Glasgow'
	id=ng
	>Norman Gray

<docnumber>70

<history>
<version number=0 date='21-APR-1999' author=ng>Initial version
</history>

<copyright>
Copyright 1999, Particle Physics and Astronomy Research Council
</copyright>

<abstract>
This document describes the Starlink SGML system.  Blah

<px>Audience: 
This document is addressed both at those who need to generate Starlink
documentation of any kind, and at anyone maintaining the SGML system.
</abstract>

<sect id=intro export>Introduction

<p>The Starlink SGML system supports people writing Starlink documents,
such as SUNs, SSNs, MUDs and the like.  It consists of a definition of
a markup language suitable for such documents, plus software to
convert these source documents to reader-friendly form.  At present,
these `output formats' include HTML and &latex (and hence include
postscript and PDF formats).

<p>The SGML system scores over previous solutions to Starlink's
documentation needs, such as <code/runoff/ or &latex, because it is a
well-defined system, so that there is excellent support for it in
tools, and it is designed to be converted into whichever presentation
format is most convenient.
The DTD is designed to be flexible, rather than imposing a
particularly tight document structure.  At the same time it has
<em/enough/ structure that it can be indexed and stored effectively.

<p>Although this system can help with many of the tasks involved in
document creation, it cannot write the document for you (shame!).  For
advice on that, documents such as <docxref doc=sgp28> are still vital.

<p>This document is organised as follows.  In <ref id=sgml>, I
discuss SGML in general terms, describing its general structure and
aims, describing how to read a Document Type Definition (DTD), and
pointing to sources of information.  In <ref id=markup>, I describe
how you would go about actually writing a document, describing the
structure of Starlink documents which is crystallised in the
specification of this system.  In <ref id=structure>, I describe the
structure of the document DTD, and the categories of elements you will use.
In <ref id=doccode>, I describe the
support which exists to support documentation of source code, allowing
you to maintain detailed routine documentation along with the routine
source code.  In <ref id=processing>, I describe the details of how
you transform your document from SGML to an output format.  Finally,
the appendices give the detailed descriptions of the elements in the
two DTDs described here, a more detailed description of SGML than is
necessary for simple use of the system, and documentation for
maintainers of the system.

<!--
In <ref id=future>, I describe
some possible further improvements in the system (suggestions and
comments are most welcome).  Finally, in <ref id=faq>, I
answer (I hope) some frequently asked questions about SGML in general
and this system in particular.
-->

<sect id=sgml export>SGML Overview

<p>This section introduces you to SGML, and explains its advantages
over other approaches to document preparation.

<subsect id=why.sgml export>Why SGML?

<p>The problem SGML tries to solve is that humans are good at
intuiting structure from layout, but computers are exceedingly bad at
it.  This means that if we want computers to help us with documents --
displaying them, transforming them, storing them, searching them -- we
have to give the computer some help.  

<p>A common way of providing this
help is through markup systems such as <code/runoff/ (or its
variants), or &tex, or &latex;.  The last of these three has served
Starlink very well, and even survived the conversion of Starlink's
document set to hypertext, through the tool <code/Star2HTML/ (see <docxref
doc=sun199>), but the problems of the &latex system illustrate the
advantages of the SGML approach quite well.
<dl>
<dt>LaTeX templates are ill-defined
<!-- Have this as `LaTeX' rather than &latex: the `latex' back-end -->
<!-- messes up SDATA references within (data nd), which is bad, since -->
<!-- latex/slmisc.dsl turns <dt> into \item[blah] using (data ...). -->
<dd>What is a Starlink document?  Although Starlink distributes
templates for the principal document types (for example in
<code>/star/docs/sun.tex</code>), and distributes style guides such as
<docxref doc=sgp28>, there is no way either of mandating that certain
elements, such as a document number, actually appear, nor of ensuring
that other features, such as raw &tex, do not.  This means that
document authors can never quite be sure that they have produced a
`correct' document; that, since the effective definition of `correct' is
`processable by this tool', there is no guarantee that a document
which is correct at one time will continue to be so; and that tools
which search or process such 
documents have to have contingency strategies available, when the
elements they hope to use are missing.

<dt>The conversion is a hack!
<dd>Because the input documents are not well-defined, the tools which
process them cannot be designed against any standard, but instead have
to rely on heuristics and uncheckable conventions.  &latex documents
are defined to work with one particular tool -- the &tex tokeniser and
parser -- so that using
them with any other tool (which is necessary if you want to produce
anything other than DVI files<note>In fact, there is a version of &tex;
which produces PDF files directly, and a &tex;-to-HTML converter
called <webref url="http://www.tug.org/applications/tex4ht/mn.html"
>TeX4ht</webref> which writes special DVI files which work with a
postprocessor, and so uses the &tex parser to produce HTML
indirectly.  This really just pushes the hack elsewhere.</note>) is
asking for trouble.

<dt>Authors have to know too much.
<dd>When you are writing a <code/Star2HTML/ document, you are
riding two horses at once; you must write in that subset of &latex
which <code/Star2HTML/ knows about.  Authors must frequently be
sensitive to the treatment of their document by two separate systems.

<dt>Authors <em/can/ know too much!
<dd>Part of the strength of &tex and &latex is their flexibility, and
it is easy for authors, especially programmer authors, to exploit this
when writing documentation, and a burst of &tex macro
magic can be an effective antidote to demotivation during the longeurs
of preparing documentation.  However much this flexibility may assist
(or even amuse) authors, it inflicts parsing hell on anyone else who
wants to do something unforseen with the document.
If you restrict what an author <em/can/ do, then you limit what a
parser <em/has/ to do to repurpose the document.

<dt>Not future-proof
<dd>&latex is not precisely defined; on the contrary, it is
continually being developed, and a completely new version, <webref
url="http://www.oasis-open.org/cover/latex3-9804.html" >&latex;3</webref> is
eagerly anticipated (which will, incidentally, be heavily influenced
by SGML).  Similarly, the <code/LaTeX2HTML/ package is continually
being upgraded, causing a <code/Star2HTML/ (based on
<code/LaTeX2HTML/) maintenance headache.
</dl>

<p>None of these problems is fatal -- all of them have manifestly been
overcome by the authors and maintainers of the current document set --
but taken together they make the maintenance of the document set more
expensive in time than there is time to spare.

<p>SGML addresses these problems effectively.
<dl>
<dt>SGML documents are well-defined
<dd>The structure of an SGML document is formally specified in the
Document Type Definition (DTD) associated with it.  This specifies
what features must, which may, and which may not, be present in a
document.  This means that systems processing the document need work
only within a much smaller universe of possibilities.

<dt>Future-proof
<dd>SGML has had only two backward-compatible amendments since 1986;
it's not dependent on any particular tool; SGML is designed to be used
decades hence; a sufficient number of
hangarfuls of technical documentation have been produced using SGML
that if and when a replacement comes along, it will have good support.

</dl>

<subsect id=what.sgml export>What is SGML?

<p>SGML is a metalanguage: that is, a language for writing languages
in.

<p>This is not actually as arcane as it sounds.  It simply means that
you use SGML to define the abstract structure of a document type (the
Document Type Definition, or DTD), so
that any documents which claim to be of that type must have a certain
syntactic structure.

<p>HTML is a well known example of an SGML DTD, whose rules are well
known.  An HTML document consists of precisely one <code/head/ and one
<code/body/ element.  The <code/head/ must have precisely one
<code/title/ element, and may have zero or more <code/link/ elements.
The <code/title/ element has simple characters as content.  The
<code/link/ element has no content, but has four optional
attributes&ellip, and so on.

<p>Given a document marked up in some specific DTD it will be parsed
by some tool which reads first the DTD then the document, and then
creates some abstract representation of the document which it passes
to a formatter, which in turn produces output in some form which may,
of course, be further processed to a final document.  The SGML parser
and whichever editor you use are both quite generic, but the formatter
is tied to a particular DTD.  There is a diagram of this system in
<ref id=fig.sgml>.
<figure id=fig.sgml float>
<caption>An SGML system
<figurecontent
	image="sgmlsystem.eps sgmlsystem.gif"
	alt="An SGML system">
</figure>

<p>For further information on SGML, see <ref id=appx.sgml>.  For other
texts, see the well-known
<cite>Gentle Introduction to SGML</cite><citation/gentle/.
For more detailed information,
see the useful but compressed <citation/bradley/; and for an
authoritative account see 
<citation/goldfarb/, which is an exegesis of the standard,
<citation/iso8879/. 

<subsect id=faq export>Frequently Asked Questions

<subsubsect id=faq.html>What's wrong with HTML?

<p>HTML was designed as a flexible and generic markup language.
Unfortunately, it is a little <em/too/ flexible and generic to be
really useful.  The power of SGML comes from its ability to represent
the structure of a document faithfully, and HTML cannot do this in
most cases - it has a <code/&lt;title>/ element, and some structural
markup <code/&lt;Hn>/, but apart from that, it's little better than
simple ASCII text.  As well, it suffers from some of the same diseases
as &latex;, as described above in <ref id=why.sgml>, in that the
effective definition of a `good' HTML document is `viewable by
netscape', and that means that you're even less well-assured of the
content and structure of a document than you are if you use &latex;
(if you are going to get involved in validating documents,
you might as well go the whole hog and do it properly).

<subsubsect id=faq.latex>What about &latex;?

<p>See the discussion in <ref id=why.sgml>, as
that describes SGML's advantages by comparing them to the problems
with the current &latex; system.  &latex; is marvellous -- this system
uses it as a back-end print formatter -- but it's not ideal for a
large and various document set.

<subsubsect id=faq.xml>What about XML?

<p>XML is a cut-down version of SGML, omitting rarely-used or
dispensable features, but preserving many of its strengths (<ref
id=further.xml>).  I have, however, used several of these omitted
features in this application.  Some of these features, such as markup
minimisation (<ref id=markup.min>) are not vital, and would simply be
inconvenient to lose, but others such as SGML's support for
subdocuments would radically change (for the worse) the nature of the
application's support for complicated documents.

<p>I would like to support XML in future, if there's development time
available.

<sect id=markup export>Marking up your document

<subsect id=markup.intro export>Sample document, and overview

<p>A sample SUN is illustrated in <ref id=fig.simplesun>.
<figure id=fig.simplesun export float>
<caption>A simple sample SUN
<figurecontent alt="Simple SUN document">
<verbatim><![ cdata [
<!doctype sun public "-//Starlink//DTD Starlink SUN//EN">
<title>The Starlink SGML system
<author email='norman@astro.gla.ac.uk'
        webpage='http://www.astro.gla.ac.uk/users/norman'
        affiliation='University of Glasgow'
        id=ng
        >Norman Gray
<docnumber>1234
<history>
  <version number=0 date='21-APR-1999'>Initial version
</history>
<abstract>
  This is a sample SUN
</abstract>

<sect id=intro export>Introduction
<p>Starlink SUNs are easy to write.
]]></verbatim>
</figurecontent>
</figure>
<p>Features to note:
<ul>
<li>The document starts off with a `document type declaration',
<code>&lt;!doctype sun public &quot;-//Starlink//DTD Starlink
SUN//EN&quot;></code>, which states which DTD this document claims to be
conformant to, in this case the Starlink SUN document type.

<li>The document is structured in terms of `elements' such as
<code/author/ or <code/sect/, and these in turn contain further data,
such as a sequence of characters (`Norman Gray') in the case of the
<code/author/ element, or further elements (the <code/version/ element)
in the case of the <code/history/ element.  Elements are delimited by
`opening tags' like <code>&lt;abstract&gt;</code> and `closing tags'
like <code>&lt;/abstract&gt;</code>.

<li>Elements have both <em/content/ and <em/attributes/.  For example,
the <code/author/ element has the characters `Norman Gray' as its
content and a list of strings such as an email address as its
attributes.

<li>Some of the elements (the <code/abstract/ element for example)
are closed (ie, have closing tags to match their opening tags), but
the majority are not.  This is because the DTD tells 
the parser that a <code/title/ element cannot contain an <code/author/
element, so the appearance of the latter implicitly finishes the
former.

<li>Some elements and attributes are required, others optional.  This
document is close to being a minimal SUN.  It is not quite minimal
because the <code/copyright/ element is optional, and it turns out
that the only <em/required/ content of a document 
body is the abstract!  Also, the only required attribute of the
<code/author/ element is the <code/id/ attribute.

<li>There are actually more elements present here than are apparent to
the eye.  As well as allowing some closing tags to be omitted, a DTD
can be allow certain <em/opening/ tags to be omitted, too.  In fact,
the full structure of this document is as seen in <ref
id=fig.simplesun2>.
</ul>
<figure float id="fig.simplesun2" export>
<caption>A SUN document with all tags in place, the normalised version
of the document in <ref id=fig.simplesun>.
<figurecontent alt="Normalised SUN document">
<verbatim><![ cdata [
<SUN>
<DOCINFO>
<TITLE>The Starlink SGML system</TITLE>
<AUTHORLIST>
<AUTHOR EMAIL="norman@astro.gla.ac.uk" 
WEBPAGE="http://www.astro.gla.ac.uk/users/norman" 
AFFILIATION="University of Glasgow" 
ID="NG">Norman Gray</AUTHOR>
</AUTHORLIST>
<DOCNUMBER>1234</DOCNUMBER>
<HISTORY>
<VERSION NUMBER="0" DATE="21-APR-1999">
<PX>Initial version</PX>
</VERSION>
</HISTORY>
<COPYRIGHT>
<P>Copyright 1999, Particle Physics and Astronomy Research Council</P>
</COPYRIGHT>
</DOCINFO>
<DOCBODY>
<ABSTRACT>
<PX>This is a sample SUN</PX>
</ABSTRACT>
<SECT ID="INTRO" EXPORT>
<SUBHEAD>
<TITLE>Introduction</TITLE>
</SUBHEAD>
<P>Starlink SUNs are easy to write.</P>
</SECT>
</DOCBODY>
</SUN>
]]></verbatim>
</figurecontent>
</figure>

<p>In <ref id=fig.simplesun2>, note that the actual content of
the <code/abstract/ element is one or more <code/px/ elements (a
slightly restricted variant of the standard <code/p/ paragraph
element), and that the <code/sect/ element contains a <code/subhead/
element, and <em/contains/ the paragraphs which constitute it (note
that this is a significant difference from HTML, where the heading
elements <code/hn/ contain only a section title).  You will rarely
have to be aware of these `hidden' tags when you are creating a
document, but it will occasionally be
useful to know that these tags are there somewhere, and that you're
glad you don't have to type all of them.
In fact, when I explain the document structure below, I will do it in terms
of the elements which are `really' there.

<p>`Markup minimisation', which is SGML's name for this, was
introduced to SGML to make typing less onerous.  Personally, I like
this, since it seems to make the document look less cluttered, and so
I have designed the DTD to support this quite extensively.  The
minimisation is completely optional, however, and you may insert all
the tags if you prefer.  SGML-aware editors (see <ref id=editors>)
typically insert all tags.  See also <ref id=markup.min>.

<p>You can see from <ref id=fig.simplesun2> that the `top-level'
element of this document is <code/sun/.  The top-level element of SSN
documents is <code/ssn/, and similarly for the other Starlink document
types (see <ref id=str.structure>).  These different document types
are broadly the same, but the 
SSN document type does not include elements for documenting
programming code, and the MUD document type has a <code/docdate/
element instead of a <code/docnumber/ and a <code/history/.  The SUN
document type is the most general.  The top-level <code/sun/ element
has only two `children', <code/docinfo/, which contains the document
information such as its author, number, and so on, and <code/docbody/,
which contains the actual content of the document.

<subsect id=markup.entities export>Entity references

<p>Entity references are a mechanism for referring to characters, or
longer pieces of text, which you cannot type on your keyboard, which
must be escaped from the parser, or which you simply want to
abbreviate.

<p>A reference to an entity <code/amp/ is of the form
<code/&amp;amp;/.  It is prefixed by the character <code/&amp/ and
suffixed by a semicolon.

<p>The list of entities predefined by the Starlink general DTD is
given in <ref id=table.entities>.

<table id="table.entities">
<caption>Entities predefined in the Starlink general DTD.</caption>
<tgroup cols="3">
<thead>
<row><entry>Entity reference<entry>Replacement<entry>Description
<tbody>
<row><entry><code>&amp;copy;</code><entry>&copy<entry>Copyright symbol
<row><entry><code>&amp;amp;</code><entry><code>&amp</code><entry>ampersand
<row><entry><code>&amp;gt;</code><entry><code>&gt</code><entry>greater-than symbol
<row><entry><code>&amp;lt;</code><entry><code>&lt</code><entry>less-than symbol
<row><entry><code>&amp;quot;</code><entry>&quot<entry>quotation mark
<row><entry><code>&amp;nbsp;</code><entry>&nbsp<entry>non-breaking space
<row><entry><code>&amp;hash;</code><entry>&hash<entry>hash sign
<row><entry><code>&amp;pounds;</code><entry>&pounds<entry>pounds sign
<row><entry><code>&amp;dollar;</code><entry>&dollar<entry>dollar sign
<row><entry><code>&amp;ellip;</code><entry>&ellip<entry>ellipses
<row><entry><code>&amp;emdash;</code><entry>&emdash<entry>em dash
<row><entry><code>&amp;endash;</code><entry>&endash<entry>en dash
<row><entry><code>&amp;percent;</code><entry>&percent<entry>percent sign
<row><entry><code>&amp;deg;</code><entry>&deg<entry>degrees symbol
<row><entry><code>&amp;latex;</code><entry>&latex<entry>&latex logo
<row><entry><code>&amp;tex;</code><entry>&tex<entry>&tex logo
</row>
</tbody>
</tgroup>
</table>

<p>For more details on entities, see <ref id=sgml.entities>.

<subsect id=markup.dtdsubset export>Defining entities

<p>As explained in section <ref id=markup.entities>, there are a
number of predefined entities which you can refer to in your
documents.  These are defined either for general convenience or
because, as in the case of <code>&lt</code> and <code>&amp</code>,
the characters are significant to the SGML parser.

<p>You can, however, define entities yourself, perhaps to save typing,
or to parameterise a fragment of text which might change.  Also, you
would have to define an entity to refer to other files, or to other
SGML documents.

<p>You define entities in a section of the document which rejoices in
the name of the `document type declaration subset'.  This is a
fragment of SGML markup which is presented within the
<code>&lt;!doctype></code> declaration, which is formally read before
the reading of the actual DTD the declaration refers to.  There are
many things you can do within the DTD subset, up to and including a
partial rewrite of the DTD (this is generally felt to be A Bad Thing
-- do try to resist the temptation), but the main function of the DTD
subset in normal documents is to define a variety of types of
entities.  For more details about the DTD subset, see <ref
id=sgml.dtdsubset>.

<p>The DTD subset is the only place you can define entities -- the
<code>&lt;entity...></code> declaration is forbidden in the body of
the document.  While this is occasionally inconvenient, it helps keep
all the document's monkey-business in one place.

<subsubsect>Referring to text

<p>You can make an entity a shorthand for a piece of text which might
either need to be parameterised, or which it is simply inconvenient to
repeatedly retype.

<p>For example:

<verbatim><![cdata[
<!doctype sun public "-//Starlink//DTD Starlink SUN//EN" [
  <!entity urlroot "http://www.astro.gla.ac.uk/users/norman">
]>
[...]
<p>Here is a <webref url="&urlroot;/star/" >web page</webref>
]]></verbatim>
When the document is parsed, the text for the entity
<code>urlroot</code> is substituted for the entity reference
<code>&amp;urlroot;</code>.

<subsubsect id=markup.files>Referring to files

<p>A feature of SGML's portability is that it abstracts the notion of
files: there are no `files' and `filenames' in the SGML world, only
<em/external entities/ which have <em/public identifiers/ or <em/system
identifiers/.  You can refer to these external entities as follows:
<verbatim><![cdata[
<!doctype sun public "-//Starlink//DTD Starlink SUN//EN" [
  <!entity chapter1 system 'chaptext/chapter1.text'>
  <!entity fig1.eps system 'figure1.eps' ndata eps>
  <!entity fig1.gif system 'figure1.gif' ndata gif87a>
  <!entity sun199 
        public "-//Starlink//DOCUMENT Summary SUN/199//EN" subdoc>
]>
]]></verbatim>

<p>There are four entities described here.

<p>`chapter1' is a reference to the object with system
identifier <code>chaptext/chapter1.text</code>.  A system identifier
can refer to an object in a wide variety of ways -- it could be a
database query, or system command -- but in the present system, a
system identifier is just a filename.  When you refer to this entity
by making the reference <code/&amp;chapter1;/ where you might
otherwise type text, the SGML system would insert the contents of the
specified file in the document at that point.  This is a way of
breaking your document up into a collection of smaller documents.

<p>The two entities `fig1.eps' and `fig1.gif' are also references to
the two
files `figure1.eps' and `figure1.gif' -- note the distinction between
the entity name and the file name.  These
entity declarations have extra information, however, indicating that
their <em/notation/ is <code/eps/ and <code/gif87a/ respectively.  The
system currently recognises these notations, plus `jpeg'.  You would
refer to these entities in an attribute of a <code/figurecontent/
element (see <ref id=el.sun.figurecontent>).  For more details on how
to refer to figure files, see <ref id=str.figures>.

<p>The last entity is different in two ways.  Firstly, it does not refer
to a system identifier, but to a <em/public identifier/.  The SGML
system maps this identifier into a file using some internal database.
Note that the reference to the DTD, <code>"-//Starlink//DTD Starlink
SUN//EN"</code> is also a public identifier.  Secondly, the keyword
<code/subdoc/ indicates that this entity is a <em/subdocument/ entity
-- a complete SGML document which the SGML system will have to parse
at some point.  In this case, the entity <code/sun199/ has been
declared so that it can be cross-referenced at some point.  See <ref
id=str.xrefs> for details.

<subsect id=markup.min export>Markup minimisation

<p>SGML was designed to be readable by computers, but it was also
designed to be written by humans<note>This is unlike XML, which is
likely to be written largely by authoring programs</note>.  It
therefore has several features -- collectively referred to as
<em/markup minimisation/ -- designed to cut down the amount of
markup you have to write.

<p>The first such minimisation feature is tag omission: in certain
circumstances you may omit tags which are formally redundant.  This
can happen only when the SGML parser can reliably infer the presence
of the omitted tags, and when the DTD author has permitted this.  For
example, the content of the <ref id=el.sun.sect text='sect'>
element is a subhead element, followed by zero or more paragraphs (or
figures or tables), followed by zero or more subsect elements.  That
is, the sect element <em/contains/ the section, rather than containing
just the title (as is the case for HTML's <code/H1/ element, for
example).  The <ref id=el.sun.subhead text='subhead'> element
contains a <ref id=el.sun.title text='title'> element, which
finally contains the text of the section heading.  In other words, the
structure of a section is
<verbatim><![cdata[
<sect>
  <subhead>
    <title>Section 1</title>
  </subhead>
  <p>Paragraph text</p>
</sect>
<sect>
  ... <!-- and so on -->
]]></verbatim>
<p>This would be tedious to type.  However, the parser can infer the
end of the section and paragraph elements (from the start of the next
section and the end of the current section respectively), so those
closing tags can be omitted; and since the section
<em/must/ start with a subhead, which <em/must/ start with a title,
those tags are redundant, too.  That means that this can be compressed
to just
<verbatim><![cdata[
<sect>Section 1
<p>Paragraph text
<sect>
...
]]></verbatim>

<p>Many closing tags can be omitted, and a few opening tags, too
(apart from subhead, about the only other one is <ref
id=el.sun.px text='px'> since it is the only permissable content
of elements like <ref id=el.sun.abstract text='abstract'>).  If
you include tags redundantly it doesn't matter (and may even make the
text clearer in some cases), and if you omit them erroneously, the
SGML parser will quickly tell you.

<p>In cases where tags cannot be omitted, you can still cut down the
amount you have to type.  Instead of typing <code>&lt;em>emphasised
text&lt;/em></code>, you can type just <code>&lt;em/emphasised
text/</code>.<note>This much is a convenient shortcut. SGML defines
other tag minimisation locutions, so that
<code>&lt;p&lt;em/emph/&lt;/></code> is legal.  This rarely improves
readability, can get you into terrible messes, and is part of the
`parser hell' which XML was designed to avoid.  I mention it purely
for completeness.</note>

<p>SGML also has single-character entity references.  The character
<code><![cdata[~]]></code> in normal text turns into the entity
<code/&amp;nbsp;/, and <code><![cdata[--]]></code> (two hyphens) turns
into <code/&amp;endash;/.  Such `short reference' characters are used
a little more in the programcode DTD (see <ref id=doccode>).

<subsect id=markup.try export>Try it yourself -- running the SGML parser

<p>Type the document given in <ref id=fig.simplesun> into a file, and
check it with the distributed SGML parser, as follows.  If the
document is in a file <code/sun1234.sgml/, then give the command
<kbd>nsgmls -s sun1234.sgml</kbd>.  This invokes the <code/nsgmls/
parser, and, with the <code/-s/ option, suppresses all output except
warnings and error messages.  This means that for a valid document,
you should see precisely no output from this command.  If you want to
see output, leave off the <code/-s/ option and the parser will produce
a version of your document in a form which is easy for a downstream
application to parse.  There are, for example, Perl libraries (for
example <code/SGMLSpm/, which should be on CPAN) which
will parse this output format and allow you to process SGML documents
using Perl.  The crucial thing in this case is the final line in
the output, which should be a single `C' command, indicating that the
document conforms to its DTD.

<p>If you want to try normalising your document, give the command
<kbd>sgmlnorm sun1234.sgml</kbd>.  This transforms your document into
an equivalent one with all omitted elements reinserted.

<p>Finally, try converting your document to HTML.  This uses the
program Jade, which is an implementation of the DSSSL formatting
language.  Give the command 
<kbd>jade -t sgml -d
$STARLINK_SGML_DIR/dsssl/sl/html/sl.dsl#html sun1234.sgml</kbd>.  This
will parse your document, and convert it to a collection of HTML
files, with the master file named <code/SUN-1234.html/ (this name is based
on the information in the document, and is independent of what your
source file is actually called).  The command actually spits out a
line of text to the standard output; this is because the system is
designed to be used from within a Makefile (see <ref id=proc.makefile>) rather
than directly from the command line.

<p>You can also convert your document to &latex;, with the command 
<kbd>jade -t latex -d $STARLINK_SGML_DIR/dsssl/sl/latex/sl.dsl#latex
sun1234.sgml</kbd>.

<p>Try making parts of your document invalid, and comparing the error
with the error message <code/nsgmls/ produces.

<!-- FIXME : check that this is consistent with whatever I do to set up
     the paths and environment variables.  Refer to id=proc.setup as
     appropriate. -->


<sect id=structure export>The structure of the document

<p>In this section I will describe all of the elements of the General DTD,
grouping them by type.  There is an alternative description of the
elements, listed alphabetically, in <ref id=appx.general.dtd>.

<p>The elements are thematically grouped in <ref id=table.elements>,
and each of these groups is discussed in the indicated section.  Note
that the discussion there is intended to provide an overview of the
possibilities provided by the group, and it does not necessarily
describe all of the functionality available; see the individual
element listings for further details.

<table id=table.elements float>
<caption>
<px>DTD elements, grouped by type.
<px>Note that a few elements appear in more than one group.
</caption>
<tgroup cols="2">
<thead><row><entry>Group<entry>Elements
<tbody>
<row>
<entry>
<ref id=str.structure>
<entry>
<ref id='el.sun.abstract' text='abstract'>,
<ref id='el.sun.appendices' text='appendices'>,
<ref id='el.sun.author' text='author'>,
<ref id='el.sun.authorlist' text='authorlist'>,
<ref id='el.sun.copyright' text='copyright'>,
<ref id='el.sun.docbody' text='docbody'>,
<ref id='el.sun.docinfo' text='docinfo'>,
<ref id='el.sun.docnumber' text='docnumber'>,
<ref id='el.sun.editors' text='editors'>,
<ref id='el.sun.keyword' text='keyword'>,
<ref id='el.sun.otherauthors' text='otherauthors'>,
<ref id='el.sun.sun' text='sun'>,
<ref id='el.sun.title' text='title'>

<row>
<entry>
<ref id=str.sect>
<entry>
<ref id='el.sun.sect' text='sect'>,
<ref id='el.sun.subhead' text='subhead'>,
<ref id='el.sun.subsect' text='subsect'>,
<ref id='el.sun.subsubsect' text='subsubsect'>,
<ref id='el.sun.subsubsubsect' text='subsubsubsect'>
<ref id='el.sun.title' text='title'>

<row>
<entry>
<ref id=str.backmatter>
<entry>
<ref id='el.sun.backmatter' text='backmatter'>,
<ref id='el.sun.bibliography' text='bibliography'>,
<ref id='el.sun.citation' text='citation'>,
<ref id='el.sun.index' text='index'>,
<ref id='el.sun.indexcontents' text='indexcontents'>,
<ref id='el.sun.note' text='note'>,
<ref id='el.sun.notecontents' text='notecontents'>

<row>
<entry>
<ref id=str.code>
<entry>
<ref id='el.sun.codecollection' text='codecollection'>,
<ref id='el.sun.routinelist' text='routinelist'>

<row>
<entry>
<ref id=str.history>
<entry>
<ref id='el.sun.change' text='change'>,
<ref id='el.sun.distribution' text='distribution'>,
<ref id='el.sun.docdate' text='docdate'>,
<ref id='el.sun.history' text='history'>,
<ref id='el.sun.update' text='update'>,
<ref id='el.sun.version' text='version'>

<row>
<entry>
<ref id=str.xrefs>
<entry>
<ref id='el.sun.docxref' text='docxref'>,
<ref id='el.sun.ref' text='ref'>,
<ref id='el.sun.url' text='url'>,
<ref id='el.sun.webref' text='webref'>

<row>
<entry>
<ref id=str.figures>
<entry>
<ref id='el.sun.caption' text='caption'>,
<ref id='el.sun.figure' text='figure'>,
<ref id='el.sun.figurecontent' text='figurecontent'>

<row>
<entry>
<ref id=str.tables>
<entry>
<ref id='el.sun.caption' text='caption'>,
<ref id='el.sun.colspec' text='colspec'>,
<ref id='el.sun.entry' text='entry'>,
<ref id='el.sun.row' text='row'>,
<ref id='el.sun.table' text='table'>,
<ref id='el.sun.tbody' text='tbody'>,
<ref id='el.sun.tgroup' text='tgroup'>,
<ref id='el.sun.thead' text='thead'>

<row>
<entry>
<ref id=str.text>
<entry>
<ref id='el.sun.attribution' text='attribution'>,
<ref id='el.sun.blockquote' text='blockquote'>,
<ref id='el.sun.cite' text='cite'>,
<ref id='el.sun.code' text='code'>,
<ref id='el.sun.dd' text='dd'>,
<ref id='el.sun.dl' text='dl'>,
<ref id='el.sun.draftnote' text='draftnote'>,
<ref id='el.sun.dt' text='dt'>,
<ref id='el.sun.em' text='em'>,
<ref id='el.sun.kbd' text='kbd'>,
<ref id='el.sun.li' text='li'>,
<ref id='el.sun.ol' text='ol'>,
<ref id='el.sun.p' text='p'>,
<ref id='el.sun.px' text='px'>,
<ref id='el.sun.quote' text='quote'>,
<ref id='el.sun.strong' text='strong'>,
<ref id='el.sun.ul' text='ul'>,
<ref id='el.sun.verbatim' text='verbatim'>

<row>
<entry>
<ref id=str.maths>
<entry>
<ref id='el.sun.m' text='m'>,
<ref id='el.sun.meqnarray' text='meqnarray'>,
<ref id='el.sun.mequation' text='mequation'>

</tbody>
</tgroup>
</table>

<subsect id=str.structure export>Overall structure

<p>Includes
<ref id='el.sun.sun' text='sun'> (or whatever top-level element is
appropriate for the document type), which contains 
<ref id='el.sun.docinfo' text='docinfo'> and
<ref id='el.sun.docbody' text='docbody'>.  The former contains
<ref id='el.sun.abstract' text='abstract'>,
<ref id='el.sun.author' text='author'>,
<ref id='el.sun.authorlist' text='authorlist'>,
<ref id='el.sun.copyright' text='copyright'>,
<ref id='el.sun.docnumber' text='docnumber'>,
<ref id='el.sun.editors' text='editors'>,
<ref id='el.sun.keyword' text='keyword'>,
<ref id='el.sun.otherauthors' text='otherauthors'>,
<ref id='el.sun.title' text='title'>; and the latter contains the body
text, the backmatter, and the
<ref id='el.sun.appendices' text='appendices'>.

<p>An SGML document always starts with a doctype declaration.  There
are seven document types defined at present:
<verbatim><![cdata[
<!doctype sug PUBLIC "-//Starlink//DTD Starlink SUG//EN">
<!doctype sun PUBLIC "-//Starlink//DTD Starlink SUN//EN">
<!doctype ssn PUBLIC "-//Starlink//DTD Starlink SSN//EN">
<!doctype sgp PUBLIC "-//Starlink//DTD Starlink SGP//EN">
<!doctype sc  PUBLIC "-//Starlink//DTD Starlink SC//EN">
<!doctype sg  PUBLIC "-//Starlink//DTD Starlink SG//EN">
<!doctype mud PUBLIC "-//Starlink//DTD Starlink MUD//EN">
]]></verbatim>
These cover, respectively, the Starlink User Guide, Starlink user
notes, system notes, general papers, cookbooks, and guides, and
Miscellaneous User Documents.  These document types are broadly the
same (there is a single DTD underlying them all), but the different
types have different features, summarised in <ref
id=table.dtdfeatures>.

<table id=table.dtdfeatures>
<caption>
Starlink DTD feature summary
</caption>
<tgroup cols="6">
<thead>
<row>
<entry>DTD
<entry>Abstract<entry>Versioning<entry>Docnumber<entry>Routinelist<entry>EnforceLinkPolicy
<tbody>
<row>
<entry>sug
<entry>yes<entry>yes<entry>no<entry>no<entry>yes
<row>
<entry>sun
<entry>yes<entry>yes<entry>yes<entry>yes<entry>yes
<row>
<entry>ssn
<entry>yes<entry>yes<entry>yes<entry>no<entry>yes
<row>
<entry>sgp
<entry>yes<entry>yes<entry>yes<entry>no<entry>yes
<row>
<entry>sc
<entry>yes<entry>yes<entry>yes<entry>no<entry>yes
<row>
<entry>sg
<entry>yes<entry>yes<entry>yes<entry>no<entry>yes
<row>
<entry>mud
<entry>opt'l<entry>no<entry>yes<entry>no<entry>no
</tbody>
</tgroup>
</table>

<p>The table headings in <ref id=table.dtdfeatures> are as follows:
<dl>
<dt>Abstract
<dd>Is an abstract required or optional.
<dt>Versioning
<dd>Is the history mechanism, described in <ref id=str.history>
required?  If not, the <ref id=el.sun.docdate text='docdate'>
element is required.
<dt>Docnumber
<dd>Is a document number required?
<dt>Routinelist
<dd>Are the code-documentation elements, described in <ref
id=str.code> available?
<dt>EnforceLinkPolicy
<dd>Is the link policy enforced?  See <ref id=str.xrefs>.
</dl>

<p>These defaults are generally appropriate for the type of document.
If you need to change them for a particular document, however, you
can.  The only case where you might plausibly need to change the
default is in in the case of the routine-list feature, and you do this by
invoking the SSN DTD (for example) as follows
<verbatim><![cdata[
<!doctype ssn PUBLIC "-//Starlink//DTD Starlink SSN//EN" [
  <!entity % Feature.Routinelist 'include'>
]>
]]></verbatim>

<p>The top-level element in the document contains two elements, <ref
id=el.sun.docinfo text='docinfo'> and <ref id=el.sun.docbody
text='docbody'>. The second contains all the text of the document, and
the first all the `meta-information' -- the author, title, keywords,
and so on, which are important for identifying and indexing the
document.  The docinfo elements should be self-explanatory, with the
exception of the history element, which is discussed in <ref
id=str.history>.

<p>The docbody element contains all the text of the document,
optionally preceded by paragraphs and tables.  Any document appendices
are gathered together in a single <ref id=el.sun.appendices
text='appendices'> element, with each appendix in a <ref
id=el.sun.sect text='sect'> element, optionally preceded by a <ref
id=el.sun.routinelist text='routinelist'> element (see <ref
id=str.code>), if the specific DTD allows that.

<p>Material such as a bibliography and endnotes do not go in an
appendix, but in a separate backmatter element (see <ref
id=str.backmatter>).

<subsect id=str.sect export>Sectioning

<p>Includes
<ref id='el.sun.sect' text='sect'>,
<ref id='el.sun.subsect' text='subsect'>,
<ref id='el.sun.subsubsect' text='subsubsect'>
and
<ref id='el.sun.subsubsubsect' text='subsubsubsect'>,
which contain the section contents, preceded by 
<ref id='el.sun.subhead' text='subhead'>, which contains the section
<ref id='el.sun.title' text='title'>.

<p>The sect element and friends contain the section content (note
that this is different to the behaviour of &latex and HTML, in both of
which the sectioning commands enclose only the section heading).

<p>The content of the sectioning elements start with a <ref
id=el.sun.subhead text='subhead'> element, which in
turn contains a <ref id=el.sun.title text='title'> element, and the
two are followed by the section 
content. Note, however, that since the subhead and title start and end
tags are both omissable (see <ref id=markup.min>), you may omit both,
and follow the sect start 
tag immediately with the section title.
That is, the structure is formally
<verbatim><![cdata[
<sect><subhead><title>Section title</title><subhead>
<p>Section body</p>
</sect>
]]></verbatim>
but this may be abbreviated to just
<verbatim><![cdata[
<sect>Section title
<p>Section body
]]></verbatim>

<p>The sectioning elements have an ID attribute, which allows you to
specify a unique label with which you can refer to the section.  For
both the sect and subsect elements, this ID attribute is required by
the DTD (when the <code>EnforceLinkPolicy</code> feature is enabled --
see <ref id=str.structure>).  See also <ref id=str.xrefs> for more
detail on cross-referencing.

<subsect id=str.backmatter export>Backmatter -- notes and bibliography

<p>The
<ref id='el.sun.backmatter' text='backmatter'> element
includes the
<ref id='el.sun.bibliography' text='bibliography'>,
<ref id='el.sun.indexcontents' text='indexcontents'> and
<ref id='el.sun.notecontents' text='notecontents'>
elements, stocked by
<ref id='el.sun.citation' text='citation'>,
<ref id='el.sun.index' text='index'> and
<ref id='el.sun.note' text='note'>
respectively.

<p>Within your document you may refer to books and articles using the
citation element, and these are collected together by the (empty)
bibliography element.  The DTD is quite generic, but in this
application, the bibliography is implemented as a Bib&tex database, so
that the bibliography element's `bib' attribute names a Bib&tex
<code>.bib</code> file (without the <code/.bib/ extension), and the
citation element's content is a Bib&tex entry key.  If you use the
template Makefile (see <ref id=proc.makefile>), the name of the
Bib&tex database is passed directly to Bib&tex, so you might need to
have Bib&tex;'s <code/BIB_INPUTS/ environment variable suitably
defined.  There is no way (at present) to specify the bibliography
formatting style -- the system uses a customised bibliography style
which, incidentally, supports a URL field in bibliography entries.
See the Bib&tex documentation
in, for example, <citation/lamport/ for further details.

<p>You can include notes in your document with the note element, and
if you do that, you should include the notecontents element at the end
of your document.  At present, the notes are presented as footnotes in
the paper version of your document and collected together as endnotes
in the online version.

<p>Although the indexing support is defined in the DTD, there is not
yet any application support for it.  It is likely to use the
<code/makeindex/ system associated with &latex;.

<subsect id=str.code export>Documenting code

<p>The 
<ref id='el.sun.routinelist' text='routinelist'>
element contains one or more
<ref id='el.sun.codecollection' text='codecollection'>
elements.

<p>The routinelist element must be the first child of the <ref
id=el.sun.appendices text='appendices'> element, and contains one or
more codecollection elements, each of which makes a link between the
general documentation and a specific file marked up using the
<code/programcode/ DTD.  See <ref id=doccode> for details.

<p>These elements are available only if the document type has the
`Routinelist' feature enabled.  See <ref id=str.structure>.

<subsect id=str.history export>History

<p>Includes
<ref id='el.sun.change' text='change'>,
<ref id='el.sun.distribution' text='distribution'>,
<ref id='el.sun.docdate' text='docdate'>,
<ref id='el.sun.history' text='history'>,
<ref id='el.sun.update' text='update'>,
<ref id='el.sun.version' text='version'>.

<p>In a large document which will be revised in future, it is
important to preserve some document history.  This means that readers
can check which version of a document, and find what features of it
have changed since the last version they are familiar with.

<p>The history element, within in the docinfo element (see <ref
id=str.structure>), records the history of the document.  It is
available in most of the Starlink DTDs, but not all, and when it is
omitted, the <ref id=el.sun.docdate text='docdate'> element is
required instead.

<p>The history of a document is composed of a sequence of versions,
changes, and distributions.  A document has a version number of the
form <code/docnumber.docversion-release/.  The document number is the
number declared in the <ref id=el.sun.docnumber text='docnumber'>
element, as assigned by the Starlink librarian.  The document version
indicates which edit of the document this is -- a significant update
to the document should be marked by incrementing the document version
number.  The release information marks a more minor update to a
document.

<p>Each of the three elements has paragraph content, to record brief notes
about the change or distribution.

<p>A version of a document (marked by a <ref id=el.sun.version
text='version'> element in the history) is a significant release of a
document, perhaps describing new functionality in a package.  The
number attribute gives the version number to be attached to the
document.

<p>A distribution of a document (marked by a <ref
id=el.sun.distribution text='distribution'> element in the history) is
a less significant update to a document, perhaps for distribution to
readers for comments.  The <code/string/ attribute is a label for the
distribution, and could be something like `draft1' or `comments-13'.

<p>Other changes to the document are labelled by a <ref
id=el.sun.change text='change'> element.  These record an edit of a
document without a corresponding change to an version number.

<p>The <ref id=el.sun.distribution text='distribution'> and <ref
id=el.sun.change text='change'> elements have an optional
<code/versionid/ attribute.  This allows you to specify a label for
this edit.  Any <ref id=el.sun.update text='update'> elements
elsewhere in the text must attach themselves to one of these elements,
using the <code/versionid/ attribute.

<p>For example:
<verbatim><![ cdata [
<author id=ng>Norman
<editors>
<author id=mb>Martin
...
<history>
<version author=ng date='02-MAR-1999' number=0>Initial version
<distribution author=ng date='03-MAR-1999' string='comments1'>Released
  to programmers for comment.
<change author=ng date='04-MAR-1999' versionid=alt99>Various tidyings
<version author=mb date='05-MAR-1999' number=1>First public release
...
<p><update author=ng versionid=alt99>Corrected typos and reexpressed
argument</update>In this section....
]]></verbatim>
Presumably, the `comments1' release of the document elicited some
comments, and the resulting changes have been logged by the change
element immediately following it.  Any (optional) update elements
scattered throughout the document (they can be children of the list
structures, figures, tables, paragraphs, and the document body itself)
can link back to this element to inherit its authorship and date.
These updates could be collected together by an application, to
generate a change log, or a `new in this release' section.

<subsect id=str.xrefs export>Cross-references

<p>Includes
<ref id='el.sun.docxref' text='docxref'>,
<ref id='el.sun.ref' text='ref'>,
<ref id='el.sun.url' text='url'>
and
<ref id='el.sun.webref' text='webref'>.

<p>Writing a document, you frequently wish to refer to other parts of
the same or other documents, or else to documents scattered around the
web.

<p>The cross-reference element you will use most often is the <ref
id=el.sun.ref text='ref'> element, which refers to another part of the
same document.  It takes a required `id' attribute, giving the ID of
the element you wish to refer to; any element with an ID attribute may
be referred to.  This will produce a named reference to the target
element, based on the type and name of that element, and will make a
link to it if the output format allows that.  If you wish, you can
override the link text by giving the `text' attribute.  For example,
the above link to the ref element's documentation was specified as
<code>&lt;ref id=el.sun.ref text='ref'></code>.

<p>The <ref id=el.sun.docxref text='docxref'> element refers to all or
part of another Starlink document.  To use this, you must declare an
entity which refers to the document as follows:
<verbatim>
&lt;!doctype sun public "-//Starlink//DTD Starlink SUN//EN" [
  &lt;!entity otherdoc 
    public "-//Starlink//DOCUMENT Summary SUN/123//EN" subdoc>
]>
</verbatim>
Once you have done that, you can refer to that document with a docxref
element, <code>&lt;docxref doc=otherdoc></code>.  If you wish, you can
refer to a specific ID within that document using the `loc'
attribute.  See <ref id=appx.system> for maintainer-level discussion
of document summaries.

<p>When linking to other Starlink documents, you may only link to IDs
which have been `exported' from the document; by the same mechanism,
others may only link to IDs which you have exported from your
document.  You export an ID by giving the attribute `export' alongside
the `id' attribute.  To ensure that there is a rich field of targets
for other documents (see also <docxref doc=sun188
loc=establishing_cross_references>), most of the Starlink document
types enforce a `link policy' (see the `EnforceLinkPolicy' feature in
<ref id=str.structure>), requiring that <em/all/ sect and subsect
elements have both the `id' and `export' attributes present.  The
`export' attribute is both an indication to the processing system
that it may link to this element, and a warning to future maintainers
of this document that they should not delete or change this ID.

<p>The <ref id=el.sun.webref text='webref'> and <ref id=el.sun.url
text='url'> elements are straightforward: they both refer to a
resource on the web.  The webref element is much like HTML's <code/a/
element, providing link text and a URL for the target; the url element
quotes the URL directly.

<p>As rather a special case, these cross-reference elements are
allowable in the <ref id=el.sun.verbatim text='verbatim'> element,
which is occasionally quite useful.  For example, the contents of <ref
id=figure.programcode> makes extensive use of this, to link from the
element names to their documentation in <ref
id=appx.programcode.dtd>.  This application uses the ref element's
text attribute, and the result is that the link disappears in the
paper version of the document.  I don't imagine that the docxref
element would often be useful here, but url and webref might be.

<subsect id=str.figures export>Figures

<p>Includes
<ref id='el.sun.figure' text='figure'>,
<ref id='el.sun.caption' text='caption'> and
<ref id='el.sun.figurecontent' text='figurecontent'>.

<p>You may include images and other figures within your document using
the figure element.  A figure consists of a caption and a
figurecontent element.  The figurecontent may contain paragraphs of
text containing the material to be displayed, but if (as will be true
in the majority of cases) you wish to display an image of some type,
then you can list candidate entities in the `image' attribute.  These
entities are distinguished by their declaration as being in a
particular `notation' -- the current possibilities are `eps', `gif87a'
and `jpeg' -- and the processing system selects the most suitable one
to use.  See <ref id=el.sun.figure> for more details.

<subsect id=str.tables export>Tables

<p>Includes
<ref id='el.sun.caption' text='caption'>,
<ref id='el.sun.colspec' text='colspec'>,
<ref id='el.sun.entry' text='entry'>,
<ref id='el.sun.row' text='row'>,
<ref id='el.sun.table' text='table'>,
<ref id='el.sun.tbody' text='tbody'>,
<ref id='el.sun.tgroup' text='tgroup'>,
<ref id='el.sun.thead' text='thead'>.

<p>The Starlink DTDs use the <webref
url='http://www.oasis-open.org/html/techpubs.htm/a503.htm' >Oasis
Exchange Table Model</webref> as the basis for their tables.  Even
though it is only a portable subset of a more elaborate standard (the
industry-standard CALS table model), there is more in the table model
than has yet been implemented in the Starlink system.

<p>In the current release of the Starlink SGML system, all of the
elements and attributes in the Oasis model are permitted in the
documents you write, but most of the attributes are ignored.  Support
for these will likely be added in future releases, but the only real
inconvenience is that there is currently no control over column
alignment.  Please let me know which features you would like to be
given priority.

<p>You lay out a table as follows:
<verbatim><![cdata[
<table id="table.entities">
<caption>Entities predefined in the Starlink general DTD.</caption>
<tgroup cols="3">
<thead>
<row><entry>Entity reference<entry>Replacement<entry>Description
<tbody>
<row><entry><code>&amp;copy;</code><entry>&copy<entry>Copyright symbol
<row><entry><code>&amp;amp;</code><entry><code>&amp</code><entry>ampersand
</table>
]]></verbatim>
You specify an ID for the table, and optionally also the `export'
attribute, in the table start tag.  A table can have a number of
groups of rows, specified by tgroup elements, and it is in the
start-tag of that element that you specify the number of columns in
rows in that group.  A group of rows consists of an optional group of
heading rows, followed by one or more groups of body rows.  Each row
consists of a sequence of entry elements.

<p>For more detailed documentation, including documentation of the
currently unsupported features, see the Oasis documentation referred
to above.

<subsect id=str.text export>Text markup

<p>Paragraphing
(<ref id='el.sun.p' text='p'> and
<ref id='el.sun.px' text='px'>): element p is the normal paragraph,
element px is a restricted paragraph used in the abstract, for
example.  The restricted paragraph is just like the normal one except
that there are a few elements (index, note and draftnote) which may
not appear.

<p>Text style
(<ref id='el.sun.em' text='em'>,
<ref id='el.sun.strong' text='strong'>,
<ref id='el.sun.cite' text='cite'>,
<ref id='el.sun.draftnote' text='draftnote'>): em and strong indicate
degrees of emphasis; cite refers to the title of something such as a
book; and draftnote is a reminder usable whilst drafting a document,
which should be prominently displayed in some way.

<p>Verbatim text
(<ref id='el.sun.code' text='code'>,
<ref id='el.sun.verbatim' text='verbatim'>,
<ref id='el.sun.kbd' text='kbd'>):
code and kbd are verbatim text, displayed using a fixed-width font in
the line of a paragraph; the distinction is that kbd text might be
displayed in some way which indicated that it is text a user should
type.  Verbatim content is displayed in a fixed-width font, respecting
line-breaks.  Note that none of these elements perform any escaping of
their contents -- if there are any characters in the content which
would be of significance to the SGML parser (such as <code/&amp/ or
<code/&lt/), they should either be escaped with entity references
(<code/&amp;amp;/ or <code/&amp;lt;/) or else the content should be
enclosed in a CDATA marked section as follows (see also <ref
id=sgml.ms.cdata>).
<verbatim>
&lt;verbatim>&lt;![ cdata [
Here is some &lt;em>marked-up&lt/em> text
which will be skipped &amp; ignored
&rsqbrack;&rsqbrack>&lt;/verbatim>
</verbatim>

<p>Quotations
(<ref id='el.sun.quote' text='quote'>,
<ref id='el.sun.blockquote' text='blockquote'>,
<ref id='el.sun.attribution' text='attribution'>): a short quotation
may be enclosed in a quote element, and a longer one in a blockquote
element. In both cases, the content may start with an attribution
element, which notes the source of the quotation.

<p>Lists
(<ref id='el.sun.ol' text='ol'>,
<ref id='el.sun.ul' text='ul'>,
<ref id='el.sun.dl' text='dl'>,
<ref id='el.sun.dt' text='dt'>,
<ref id='el.sun.dd' text='dd'>,
<ref id='el.sun.li' text='li'>): These are the ordered, unordered and
description lists familiar from HTML.  Unlike HTML, however, the dt
and dd elements within the description list must be paired.

<subsect id=str.maths export>Maths

<p>Includes
<ref id='el.sun.m' text='m'>,
<ref id='el.sun.mequation' text='mequation'>,
<ref id='el.sun.meqnarray' text='meqnarray'>.

<p>All the maths in Starlink documents uses &latex;
notation.<note>MathML was considered, but is neither well-supported in
browsers, nor designed to be easily written by hand</note>  The m
element is equivalent to <code/&dollar;...&dollar/, mequation is
equivalent to <code>\\begin{equation} ... \\end{equation}</code> and
meqnarray is equivalent to <code>\\begin{eqnarray}
... \\end{eqnarray}</code>.

<p>Note that, although the parser `knows'
that the content of these elements is in &latex notation there is no
suppression of markup-recognition within them -- entity references and
element start-tags are still recognised as such by the parser.  The
latter is rather a pest, but the former means that you can still use
entity references to parameterise or abbreviate mathematical
expressions.

<p>When you are typing an eqnarray, you might want to escape all
occurrences of <code/&amp/ and <code/&lt/ with the corresponding
entity references <code/&amp;amp;/ and <code/&amp;lt;/.  This is not
wrong, but it can become tedious and could obscure what you are
writing, so you may prefer to take advantage of the fact that SGML
recognises these bits of markup only in context: only if an ampersand
or less-than symbol is immediately followed by a name-start character
(an upper- or lowercase letter) is it recognised as an entity
reference or element start-tag.  Thus the following element is
correctly formed (with <code>&lt!entity dec "\delta"></code>):
<verbatim><![cdata[
<meqnarray>\alpha&<& x\\&dec&=&amp;4< x\\</meqnarray>
]]></verbatim>
I do, however, advise you against typing anything so wilfully obscure.
The best practice when typing meqnarray
elements is to reflexively put a space after all occurrences of
<code/&amp;/ and <code/&lt;/: this will keep the SGML parser from
interfering, and make no difference to &latex, which ignores all
spaces in maths mode anyway.

<sect id=doccode export>Documenting source code

<p>Many -- perhaps most -- Starlink documents exist to describe a body
of program code, and while the general behaviour and usage of that
program can be described in a document such as this one, the details
of the implementation might be most sensibly kept with the program
code itself.  The Starlink DTDs have facilities to do precisely this,
associating documentation directly with program code, and associating
that detailed documentation with user documents.

<p>As described in <ref id=str.code>, the Starlink General DTD has an
appendix element <ref id=el.sun.routinelist text='routinelist'>,
containing one or more <ref id=el.sun.codecollection
text='codecollection'> elements.  Each of these latter elements makes
a link between the documentation and a document marked up using the
programcode DTD, which I will now describe.

<p>The programcode document -- the document marked up using the
programcode DTD, pointed to by the main documentation -- may be
compilable source code, with the markup suitably commented out of
sight of the compiler; it may be a skeleton document which includes
separate source files into itself; or it may be a non-compilable
document maintained separately or generated from idiolectal source
markup by some sed or Perl magic.  It makes no difference to the SGML
parser, but gives the code author flexibility in deciding how much,
and what, markup to allow into their code comments.

<p>There are distinct document type declarations for the different
supported languages, although they use the same underlying markup.
This is so that the generic programcode DTD can be slightly customised
as appropriate for different languages.  See <ref id=doccode.languages>.

<p>The programcode DTD is more elaborate than it <em/could/ have
been.  Different people have different coding and documenting styles,
and are firmly wedded to them, so I felt that flexibility was more
important than simplicity.  As a result, there is sometimes more than
one place where information can reasonably be placed.  Also, the DTD
makes it possible to exploit tag-omission quite heavily (see <ref
id=markup.min>) -- the aim was to indicate an adequate level of
structure using as little markup as possible.

<p>The programcode DTD is designed to document code; there is no
reason why it could not also be used to prettyprint it, by taking a
marked-up document and putting it through a different processor.
That, however, is a project for another time.

<subsect id=doccode.general export>The structure of programcode documents

<subsubsect id=doccode.example>Example document

<p>Let us start in the traditional way, with a (sort of) `hello world'
program:
<verbatim><![cdata[
<!doctype programcode public '-//Starlink//DTD Fortran Source Code 0.2//EN'>
<PROGRAMCODE>
<DOCBLOCK>
<title>Test program
<authorlist>
<author id=ng affiliation='Starlink, Glasgow'><NAME>Norman

<codegroup><DOCBLOCK><TITLE>Test function

<func>
<CODEPROLOGUE>
<routinename><NAME>helloworld
<description><P>Greets the world with a sunny hello
<returnvalue type=string>Suitably formatted greeting
<ARGUMENTLIST>
<parameter given><NAME>language
  <type>enumerated list<description><P>Selects the language to use.
  Allowed values are english and sanskrit.
</ARGUMENTLIST>
<authorlist><authorref id=ng>
</CODEPROLOGUE>
<codebody empty>
]]></verbatim>

<p>This is, obviously, not a compilable Fortran program, but it is a
good example, firstly because it displays the structure (which will
be a little obscured when we come to consider Fortran programs in <ref
id=doccode.fortran>), and secondly because it could plausibly be the
output of some script which extracts documentation from compilable
source code files.

<p>As mentioned above, the programcode DTD allow you to make heavy use
of SGML tag omission features.  All the capitalised tags in this
example are omissable: removing them tips the balance back to the
healthy side of more text than markup.  The Fortran code DTD allows
further abbreviation, and we shall see that the content of the `func'
element could be represented as:
<verbatim><![cdata[
*+
* <routinename>helloworld
* <description>Greets the world with a sunny hello
* <returnvalue type=string>Suitably formatted greeting
* <parameter given>
*   language = enumerated list
*     Selects the language to use.
*     Allowed values are english and sanskrit.
* <authorlist><authorref id=ng>
*-
      (function source code goes here)
]]></verbatim>

<subsubsect id=doccode.elements>The programcode element structure

<p>In the case of the Starlink General DTD, described in <ref
id=structure>, the important features were the meanings of the element
types.  In the case of the programcode DTD, however, the meanings of
the element types are fairly straightforward, and the detail is in the
<em/structure/ of the DTD.  It therefore seems best to focus on the
structure of the DTD here, leaving the detailed descriptions of the
elements to <ref id=appx.programcode.dtd>.

<p><ref id=figure.programcode> displays the element structure of the
programcode DTD.  The syntax is that of a DTD -- see <ref id=sgml.dtd>
for brief notes on this.

<figure id=figure.programcode>
<caption>Element structure of the programcode DTD</caption>
<figurecontent alt="programcode DTD element structure">
<!-- This was extracted from the dtd with the sed script
  /^<!element/{\n :again\n /> *$/b nextel\n p\n n\n b again\n :nextel\n p\n }
  ...then reordered for documentation purposes, and the <ref> elements
  put in.
-->
<verbatim>
&lt;!element <ref id=el.programcode.programcode text='programcode'>   o o (docblock, (codegroup | codereference)+)>
&lt;!element <ref id=el.programcode.codegroup text='codegroup'>     - o (docblock, (func | misccode)+)>
&lt;!element <ref id=el.programcode.codereference text='codereference'> - o (docblock)>
&lt;!element <ref id=el.programcode.docblock text='docblock'>      o o (title, description?, authorlist?,
                             copyright?, history?)>

&lt;!element <ref id=el.programcode.func text='func'>          o o (codeprologue, codebody)>
&lt;!element <ref id=el.programcode.misccode text='misccode'>      o o (miscprologue, codebody)>
&lt;!element <ref id=el.programcode.codeprologue text='codeprologue'>  o o (routinename , purpose? , description , 
                                returnvalue , argumentlist ,
                                authorlist? , history?)>
&lt;!element <ref id=el.programcode.miscprologue text='miscprologue'>  o o (description, history?)>
&lt;!element <ref id=el.programcode.codebody text='codebody'>      o o (#pcdata)>

&lt;!element <ref id=el.programcode.routinename text='routinename'>   o o (name, othernames?)>
&lt;!element <ref id=el.programcode.name text='name'>          o o (#pcdata)>
&lt;!element <ref id=el.programcode.othernames text='othernames'>    - o (name+)>

&lt;!element <ref id=el.programcode.title text='title'>         o o (#pcdata)>
&lt;!element <ref id=el.programcode.purpose text='purpose'>       - o (%para.content;)>
&lt;!element <ref id=el.programcode.description text='description'>   - o (p+)>

&lt;!element <ref id=el.programcode.returnvalue text='returnvalue'>   - o (%para.content | p+)>
&lt;!element <ref id=el.programcode.argumentlist text='argumentlist'>  o o (parameter*)>
&lt;!element <ref id=el.programcode.parameter text='parameter'>     - o (name, type, description)>
&lt;!element <ref id=el.programcode.type text='type'>          - o (#pcdata)>
&lt;!element <ref id=el.programcode.copyright text='copyright'>     - o (p+)>

&lt;!element <ref id=el.programcode.authorlist text='authorlist'>    o o ((author+ | authorref+), otherauthors?)>
&lt;!element <ref id=el.programcode.otherauthors text='otherauthors'>  - o (author+ | authorref+)>
&lt;!element <ref id=el.programcode.author text='author'>        - o (name, authornote?)>
&lt;!element <ref id=el.programcode.authorref text='authorref'>     - o EMPTY>
&lt;!element <ref id=el.programcode.authornote text='authornote'>    - o (p+)>

&lt;!element <ref id=el.programcode.history text='history'>       o o (change+)>
&lt;!element <ref id=el.programcode.change text='change'>        - o (p+)>

&lt;!entity % para.markup '<ref id=el.programcode.code text='code'> | <ref id=el.programcode.em text='em'> | <ref id=el.programcode.url text='url'> | <ref id=el.programcode.funcname text='funcname'>'>
&lt;!entity % para.content '(#pcdata | %para.markup | ul)*'>
&lt;!element <ref id=el.programcode.p text='p'>             o o (%para.content;)>
&lt;!element (%para.markup;) - - (#pcdata)>
&lt;!element <ref id=el.programcode.ul text='ul'>            - - (li+)>
&lt;!element <ref id=el.programcode.li text='li'>            - o (#pcdata)>
</verbatim>
</figurecontent>
</figure>

<p>Below, I describe these elements group-by-group.  This description
concentrates on the structure of the DTD and the relationships between
the elements -- I have not described the details of the elements or
their attributes where these can be found in the detailed element
listing in <ref id=appx.programcode.dtd>.

<p><verbatim>
&lt;!element <ref id=el.programcode.programcode text='programcode'>   o o (docblock, (codegroup | codereference)+)>
&lt;!element <ref id=el.programcode.codegroup text='codegroup'>     - o (docblock, (func | misccode)+)>
&lt;!element <ref id=el.programcode.codereference text='codereference'> - o (docblock)>
&lt;!element <ref id=el.programcode.docblock text='docblock'>      o o (title, description?, authorlist?,
                             copyright?, history?)>
</verbatim>
The <code/programcode/ top-level element, like the
<code/codegroup/ and <code/codereference/ elements which it contains,
starts off with a <code/docblock/ element.  This may provide
discussion, author, copyright, change history information, or it may
give as little as a title.  Where this information is provided is up
to the author of the documentation.  The elements in the
<code/docblock/ must be present in the order specified here.

<p>A <code/codegroup/ element simply
gathers together several related functions (this is deliberately
vague); it might therefore represent all the functions defined in one
source file, or in one directory of a source tree.  
A <code/codereference/ is even vaguer: it documents a relationship
between the current programcode document and another one.  In the case
of the DSSSL DTD, this is mapped to the structure in that language which
included one source file in 
another; in the case of the Fortran DTD, it could document the
dependence of a source file on an `include' file.

<p><verbatim>
&lt;!element <ref id=el.programcode.func text='func'>          o o (codeprologue, codebody)>
&lt;!element <ref id=el.programcode.misccode text='misccode'>      o o (miscprologue, codebody)>
&lt;!element <ref id=el.programcode.codeprologue text='codeprologue'>  o o (routinename , purpose? , description , 
                                returnvalue , argumentlist ,
                                authorlist? , history?)>
&lt;!element <ref id=el.programcode.miscprologue text='miscprologue'>  o o (description, history?)>
&lt;!element <ref id=el.programcode.codebody text='codebody'>      o o (#pcdata)>
</verbatim>
A <code/func/ element documents a function, with arguments, a return
value, and the like, whereas the <code/misccode/ element documents
`other' code (again, deliberately vague).

<p>The <code/codebody/ element is ignored by the processing system,
but is still scanned by the parser.  This could cause you a problem if
there's anything in there which looks like something the parser would
be interested in, namely an element start-tag or an entity reference.
The ampersand and left angle-bracket are only recognised as markup if
they are immediately followed by a name-start character (upper- or
lowercase letter).  If the parser trips up on something, you should
either make minor edits to your source code, or do some preprocessing.

<p>Note: If the <code/codebody/ element actually contains no code at all
(perhaps because the document has been generated by a preprocessor
stage), then you should include the attribute `empty' in the
start-tag; this has no effect at present, but could become significant
if the documents are repurposed in future versions of this system.

<p>
<verbatim>
&lt;!element <ref id=el.programcode.routinename text='routinename'>   o o (name, othernames?)>
&lt;!element <ref id=el.programcode.name text='name'>          o o (#pcdata)>
&lt;!element <ref id=el.programcode.othernames text='othernames'>    - o (name+)>
</verbatim>
The <code/routinename/ element has structure, though in the usual case
(<code/&lt;routinename>helloworld/) you wouldn't notice this.  The
<code/othernames/ element is useful when a function has some generic
name, say <code/allocarray/, plus some specific names, say
<code/allocarray_int/ and <code/allocarray_float/.

<p>
<verbatim>
&lt;!element <ref id=el.programcode.title text='title'>         o o (#pcdata)>
&lt;!element <ref id=el.programcode.purpose text='purpose'>       - o (%para.content;)>
&lt;!element <ref id=el.programcode.description text='description'>   - o (p+)>

&lt;!element <ref id=el.programcode.returnvalue text='returnvalue'>   - o (%para.content | p+)>
&lt;!element <ref id=el.programcode.argumentlist text='argumentlist'>  o o (parameter*)>
&lt;!element <ref id=el.programcode.parameter text='parameter'>     - o (name, type, description)>
&lt;!element <ref id=el.programcode.type text='type'>          - o (#pcdata)>
&lt;!element <ref id=el.programcode.copyright text='copyright'>     - o (p+)>
</verbatim>
The distinction between <code/purpose/ and <code/description/ is that
<code/purpose/ is intended for a brief, perhaps one-line, summary
of the function, whereas <code/description/ is intended for a longer
discussion.

<p>The <code/description/ element is used in the <code/docblock/,
<code/codeprologue/, <code/miscprologue/ and <code/parameter/
elements, <code/authorlist/ is used in both <code/codeprologue/ and
<code/docblock/ elements, and <code/name/ is used in the <code/author/,
<code/othernames/, <code/parameter/ and <code/routinename/ elements.

<p>
<verbatim>
&lt;!element <ref id=el.programcode.authorlist text='authorlist'>    o o ((author+ | authorref+), otherauthors?)>
&lt;!element <ref id=el.programcode.otherauthors text='otherauthors'>  - o (author+ | authorref+)>
&lt;!element <ref id=el.programcode.author text='author'>        - o (name, authornote?)>
&lt;!element <ref id=el.programcode.authorref text='authorref'>     - o EMPTY>
&lt;!element <ref id=el.programcode.authornote text='authornote'>    - o (p+)>
</verbatim>

The distinction between the <code/author/ and <code/authorref/
elements is important.  The <code/author/ element has a required ID
attribute which can be used to refer to this author, and the
associated metadata of URL and email address.  Since IDs must be
unique in an SGML document, it follows that there can be only <em/one/
<code/author/ element per author per document: there cannot be an
author element in each function.  It is usual, however, to give
authorship information in each function, and this is done with the
<code/authorref/ element, which has a required ID attribute linking
back to the <code/author/ element presumably located in the document's
initial <code/docblock/ (see the example in <ref id=doccode.example>).

<p>
<verbatim>
&lt;!element <ref id=el.programcode.history text='history'>       o o (change+)>
&lt;!element <ref id=el.programcode.change text='change'>        - o (p+)>
</verbatim>
The history mechanism in programcode documents is intentionally
simple, as it merely emulates the list-of-changes style in the
majority of the Starlink code-base.  The <code/change/ element has a
required date, and a required `author' attribute, which links back to
a previous <code/author/ element.

<p>
<verbatim>
&lt;!entity % para.markup '<ref id=el.programcode.code text='code'> | <ref id=el.programcode.em text='em'> | <ref id=el.programcode.url text='url'> | <ref id=el.programcode.funcname text='funcname'>'>
&lt;!entity % para.content '(#pcdata | %para.markup | ul)*'>
&lt;!element <ref id=el.programcode.p text='p'>             o o (%para.content;)>
&lt;!element (%para.markup;) - - (#pcdata)>
&lt;!element <ref id=el.programcode.ul text='ul'>            - - (li+)>
&lt;!element <ref id=el.programcode.li text='li'>            - o (#pcdata)>
</verbatim>
The last group of elements consists of miscellaneous markup for use in
function descriptions.  The only unusual one is <code/funcname/, which
is intended to indicate other functions within the same `world'
(vagueness again): these could be language primitives, or other
documented functions.  At present, this simply functions as a variant
of the <code/code/ element, but the system could be extended in future
to generate cross-references for these.


<subsect id=doccode.languages export>Specific language variants

<p>As I mentioned above, the programcode DTD is not invoked directly,
but instead <em/via/ a document type declaration specific to the
language of the program being documented, allowing for
language-specific customisation of the generic DTD.

<p>At present, the only languages supported by DTDs are
DSSSL (a language for formatting SGML documents, which has
been used for much of the processing work in this project) and
Fortran.  C and C++ will be added almost immediately, and other
languages as guided by demand.

<subsubsect id=doccode.fortran>Fortran

<p>The principal customisations for Fortran documents are to do with
the definition of `short references' for certain tags, to help you
`hide' SGML within Fortran comments.

<p>The string <code/*+/ coming at the beginning of the line, is
equivalent to the <code/func/ start-tag, and <code/*-/ at the
beginning of the line is recognised as the <code/codebody/ start-tag.
Within the <code/func/ element, a <code/*/ at the beginning of the
line is ignored.  Further, within the <code/parameter/ element, an
equals sign, <code/=/, is recognised as a <code/type/ start-tag, and
within that element, end-of-line and <code/:/ are recognised as a
<code/description/ start-tag.

<p>All together, this means that, as trailed in <ref
id=doccode.example>, the code fragment
<verbatim><![cdata[
*+
* <routinename>helloworld
* <description>Greets the world with a sunny hello
* <returnvalue type=string>Suitably formatted greeting
* <parameter given>
*   language = enumerated list
*     Selects the language to use.
*     Allowed values are english and sanskrit.
* <authorlist><authorref id=ng>
*-
      (function source code goes here)
]]></verbatim>
is interpreted as 
<verbatim><![cdata[
<func>
<routinename>helloworld
<description>Greets the world with a sunny hello
<returnvalue type=string>Suitably formatted greeting
<parameter given>language
  <type>enumerated list<description>Selects the language to use.
  Allowed values are english and sanskrit.
<authorlist><authorref id=ng>
<codebody>
      (function source code goes here)
]]></verbatim>

<subsubsect id=doccode.dsssl>DSSSL

<p>DSSSL is a language defined in ISO/IEC 10179:1996
<citation>iso10179</citation> as a means of specifying the formatting of SGML
documents.  It is the language, as implemented in the free DSSSL
system <webref url='http://www.jclark.com/jade/' >Jade</webref>, used
for almost all the processing of SGML documents in this Starlink SGML
application.  Since the language is likely to be of interest only to
those with some knowledge of SGML, the rest of this section uses
terminology not defined elsewhere in this document.

<p>DSSSL source documents are SGML instances.  When presented with a
source file, Jade does not process it immediately, but instead
extracts (rather nicely) an instance of the `DSSSL' architecture,
which must be declared in the DTD the document conforms to.  The DTD
referred to by <code>-//Starlink//DTD DSSSL Source Code 0.2//EN</code>
declares such an architecture.  It maps the programcode
<code/codegroup/ element to the DSSSL <code/style-specification/
architectural form, <code/codereference/ to
<code/external-specification/ (with attribute name remapping) and
<code/codebody/ to <code/style-specification-body/. This follows a
discussion of this technique in <code/comp.text.sgml/ by Eliot
Kimber~<citation>kimber97</citation>.

<p>Also it defines the entity <code/%direction.attr/ to be simply
`given', since arguments to DSSSL functions are only passed in.

<p>See <ref id=appx.system> for further discussion of the DSSSL
code base.

<subsect id=doccode.org export>Organising files

<p>I described above how, for example, the Fortran-code DTD can allow
you to mix program source code and SGML markup.  A Fortran source file
cannot be a complete SGML document on its own, however, even though it
can be a fragment of a valid document, since there is no way to hide
the required <code/&lt;!doctype ...>/ declaration from the compiler.
The source file must therefore be part of a composite document.

<p>Although the object that is pointed to by the General DTD's
<code/codecollection/ element is a single SGML document marked up
using the programcode DTD, it need not be a single file.  A suitable
way to manage a collection of source code files, for documentation
purposes, might be as follows.

<p>We can return to the example in <ref id=doccode.example>, and split
our `hello world' example into two files, a skeleton file holding the
general structure, and including an entity which refers to the source
code:
<verbatim><![cdata[
<!doctype programcode public '-//Starlink//DTD Fortran Source Code 0.2//EN' [
 <!entity ptest-source system 'ptest.for'>
]>

<title>Test program
<authorlist>
<author id=ng affiliation='Starlink, Glasgow'>Norman

<codegroup>Test function

&ptest-source;
]]></verbatim>
and a separate file, <code/ptest.for/, containing just the source code:
<verbatim><![cdata[
*+
* <routinename>helloworld
* <description>Greets the world with a sunny hello
* <returnvalue type=string>Suitably formatted greeting
* <parameter given>
*   language = enumerated list
*     Selects the language to use.
*     Allowed values are english and sanskrit
* <authorlist><authorref id=ng>
*-
      write (*,*) 'hello'
]]></verbatim>

<p>Note that in this case the source-code file refers to its author
only through the authorref element, pointing to the author
element and its associated author metadata in the main file.

<sect id=processing export>Processing your document

<p>SGML documents are processed using a suite of free tools produced
by James Clark.

<p><webref url="http://www.jclark.com/jade/" >Jade</webref> is a
system which implements the DSSSL language for document formatting
and, in the present case, transformation.  The difference is that
`formatting' refers to the process of turning an SGML document into a
printed, or otherwise readable, form, and `transformation' refers to
the processing of an SGML document into another SGML document.  Thus
the conversion to HTML is really `transformation', but since HTML is
not much kop as a high-level markup language, the HTML transformation
is much more akin to a formatting step; likewise the `formatting' into
&latex;.  In fact, DSSSL has a transformation language as well as a
formatting language; Jade implements only the formatting language, but
with extensions which allow it to be used very easily for
transformation.

<p>Along with Jade is the <webref url="http://www.jclark.com/sp/"
>SP</webref> toolkit.  This consists of a standalone parser,
<code/nsgmls/, and various markup editing tools.

<subsect id=proc.setup export>Setting up

<p>To use the SGML system.  Blah.

<p>Note for developers: there will be a setup script, once I've sorted
out where the various bits of the system will be placed, and whether
or not I'm going to distribute a built version of Jade.  At present,
you need to have jade and co. (nsgmls, sgmlnorm,...) in your path; the
environment variable <code/STARLINK_SGML_SYSTEM/ pointing to the root
of the SGML distribution (ie, the directory which has doc, dsssl, dtd
and lib subdirectories; and <code/SGML_CATALOG_FILES/ including 
<code>/home/norman/s/src/sgml/documents/CATALOG</code> (the location
of the document summary files) and
<code>/home/norman/s/src/sgml/w/sgml/dtd/CATALOG</code> (the main
distributed SGML catalogue).

<p>To test the setup, go to <code>$STARLINK_SGML_DIR/doc/ssn70</code>
and type <kbd/make ssn70.html.stamp/ -- this should build the HTML
version of the documentation.  If you type <kbd/make
ssn70.latex.stamp/ you should get the &latex version.


<!-- FIXME: BOS?  Manifest? -->

<subsect id=editors export>Editors

<p>SGML is a text format, so you can write SGML documents using
whichever editor you prefer.

<p>If you use emacs, you can benefit from an emacs SGML mode called
<webref url='http://www.lysator.liu.se/projects/about_psgml.html'
/psgml/.  This can help with simple things such as automatically
inserting appropriate closing tags, all the way up to validating your
document.

<p>There are no free SGML editors that I'm aware of, but there will
soon be free XML editors.  These aren't useful quite yet, as there is
not yet an XML version of the Starlink DTD, but their time will come.

<subsect id=proc.makefile export>Processing documents -- using the Makefile

<p>Processing documents is potentially a bit of a headache.

<p>The Jade processor is typically invoked with quite elaborate
command lines, with some options vital and some optional.  Some
documents -- those including maths or bibliographies, for example --
require more or less elaborate preprocessing for some formats.  In
some circumstances the names of output files are significant to the
system.  It is for all these reasons that the system is designed to be
used primarily <em/via/ Makefiles.

<p>The distribution contains a Makefile,
<code>$STARLINK_SGML_SYSTEM/lib/Makefile.common</code>, which contains
reasonably modular rules for the various stages of the formatting
process.  The aim is that you can process your documents by including
this common Makefile in a per-directory Makefile, and then simply
expressing the dependencies between your source documents and the
Makefile's template targets.

<p>For example, a Makefile to generate HTML documentation could be as
simple as:
<verbatim>
include $(STARLINK_SGML_DIR)/lib/Makefile.common
ssn70.html.stamp: ssn70.sgml ssn70.htmlback.stamp
</verbatim>
Given this, the command <code>make ssn70.html.stamp</code> would
generate an HTML version of the document's backmatter (bibliography
and notes), generate the HTML version of the document, then create the
stamp file <code/ssn70.html.stamp/.

<p>The name of the generated files is itself generated based on data
within the file, and is not configurable.  Do not change it yourself,
since HTML cross-references are constructed using the assumption that
no-one has been monkeying with filenames.  The root of the generated
filenames is stored within the stamp file, followed by a colon, and so
may be extracted with a command like:
<verbatim>
awk -F: '{print $1}' ssn70.html.stamp
</verbatim>

<p>The Makefile targets are as follows.  With Makefiles, the code is
the documentation to a greater extent than with other languages, so
the Makefile itself should be consulted if in doubt.  Note, however,
that targets in the Makefile that are not mentioned here should not be
used, since they are internal (ie, could disappear without warning),
unstable, or otherwise deprecated.
<dl>
<dt><code/%.html.stamp: %.sgml/
<dd>The main target for generating collections of HTML files.

<dt><code/%.single.html: %.sgml/
<dd>A target for generating HTML using the same stylesheet as above,
but with the entire document in a single file.

<dt><code/%.summary: %.sgml/
<dd>Generate a document-summary for the source file.

<dt><code/%.htmlback.stamp: %.sgml/
<dd>Preprocess a document to generate backmatter in HTML format.  Use
this as a dependency of the <code/%.html.stamp/ target, when a document has
backmatter, as in the example above.

<dt><code/%.imgeq.list.stamp: %.sgml/
<dd>Preprocesses a document, producing GIF images of the equations within
it.  Use as with <code/%.htmlback.stamp/

<dt><code/%.latex.stamp: %.sgml/
<dd>Produce a &latex file suitable for subsequent processing.  The
generated &latex document is not particularly readable, but it does
not depend on any external classes or packages other than those which
should be in a standard &latex distribution; it should therefore be
generally portable.

<dt><code/%.latexback.stamp: %.sgml/
<dd>Proprocess a document, producing backmatter in &latex format.  Use
this as a dependency of the <code/%.latex.stamp/ target, when a
document has backmatter.

<dt><code/%.parse: %.sgml/ 
<dd>The <code/%.parse/ target is the SGML parser's view of the
document.  The format is <webref
url="http://www.jclark.com/sp/sgmlsout.htm" >standard</webref>, though
not formally defined, and
can be parsed by Perl libraries such as <webref
url="http://www.cpan.org/modules/by-module/SGMLS/" >SGMLSpm</webref>.

<dt><code/%.data: %.sgml/
<dd>The <code/%.data/ target contains all the character data content
of the document.  It's not obvious what use this is, but it's there if
you can think of one.

<dt>Miscellaneous
<dd>The Makefile also defines targets <code/%.ps/, <code/%.dvi/.
There's nothing clever involved in these -- they're present for
convenience.

</dl>

<sect id=further export>Further information

<subsect id=further.development export>Further developments

<p>What's next?
<ul>
<li>I'd like to support XML (see <ref id=further.xml>).  This requires
a little development of the DTD but, more substantially, also requires
investigating what level of support we can reasonably expect from
users' browsers.  There is a great deal of work being done on XML at
present (mid-1999) -- when the developments settle down we can start
to exploit them.

<li>I'd like to support sophisticated searching.  The Starlink HTX
system allows some context-based searching (see <docxref
doc="sun188" loc='searching_for_information'>), and it should be easy
to support this and more in the SGML system.

</ul>

<subsect id=further.xml export>XML

<p>The primary XML resources are
<ul>
<li><url>http://www.w3.org/XML</url> for the W3C's XML spec
<li><url>http://www.ucc.ie/xml/</url> for the XML FAQ
<li><url>http://www.xml.com/xml/pub/axml/axmlintro.html</url> for the
annotated spec
</ul>

<subsubsect>XML is SGML--
<p><ul>
<li>An SGML document consists of an `SGML declaration' which
sets various options, a `document type definition' (DTD) which
establishes the syntax of a document type, and a `document instance',
which is the actual document.

<li>XML has a single, fixed, SGML declaration, which sets most of the
SGML options to `off'.  For example, in XML all element names are case
sensitive, there is no tag omission, there are some restrictions on
the possible syntaxes expressible by the DTD, and more exotic features
such as SUBDOC are forbidden.  For a more detailed discussion of the
differences, see 
<webref url='http://www.w3.org/TR/WD-xml-lang.html#secA.'
>appendix A</webref> of the spec.

<li>This means that parsers are easy to write, and there are numerous
such parsers available for free.

<li>XML dispenses with the SGML declaration; it can dispense with a
DTD as well.  XML introduces the notion of `well-formed' versus
`valid' documents.
<p>If a document has all closing tags present,
and all elements properly nested, and starts with the declaration
<verbatim>
   &lt;?xml version="1.0" standalone="yes"?>
</verbatim>
and empty elements are
written <code>&lt;empty/></code>, then it is `<webref
url='http://www.ucc.ie/xml/#FAQ-WF' >well-formed</webref>', and may
be processed in the absence of a DTD.

<li>A file which has a DTD and which conforms to it (which will also
be well-formed), is `<webref url='http://www.ucc.ie/xml/#FAQ-VALID'
>valid</webref>'.  It may optionally also begin with the XML declaration
<verbatim>
&lt;?xml version="1.0"?>
</verbatim>

<li>That is, a valid XML document is also a conforming SGML document.
This has been made possible by recent subtle, technical, changes to
the SGML standard.

<li>The latter has come about because there has been close cooperation
between the developers of XML and the wider SGML community.  That is,
XML is fully legit as SGML.

</ul>

<subsubsect>XML is not HTML++

<p><ul>
<li>XML is a real standard (well, there <em/are/ HTML standards, but
noone pays any attention to them).
<li>HTML has a fixed element set, and associates fixed semantics with
those elements.  XML has neither restriction.
</ul>

<subsubsect>Associated standards

<p><ul>

<li><webref url='http://www.w3.org/TR/WD-xlink' >XLink</webref> is a draft
specification for links in XML. It's closely related to the hyperlinks
module of HyTime.

<li><webref url='http://www.w3.org/TR/WD-xptr' >XPointer</webref> is a
draft specification for location specifiers in XML, so that you
can refer, for example, to `the second section beneath the
element with id so-and-so'. As with XLink, it's closely related
to HyTime.

<li><webref url='http://www.w3.org/Style/XSL/' >XSL</webref> are style
sheets for XML.  These are vital if XML is to be readable when it is
served over the web (because it doesn't have the fixed semantics HTML
has, XML rendering can't be left entirely to a browser).

<li>The <webref url='http://www.w3.org/DOM/' >Document Object
Model</webref> (DOM) is `a platform- and language-neutral interface that
allows programs and scripts to dynamically access and update the
content, structure and style of documents' [from the spec].  It's a
simple set of O-O declarations for querying and manipulating XML
documents in simple ways (small subset of DSSSL).

<li><webref url='http://www.hytime.org/' >HyTime</webref> is a very
high-level standard for associating semantics with SGML DTDs.

<li><webref url='http://www.oasis-open.org/cover/dsssl.html'
>DSSSL</webref> is the Document Style and Semantics Specification
Language. It's a language for writing stylesheets in.  Both HyTime and
DSSSL are specific to SGML, but have informed the other standards
above.

</ul>

<subsubsect>Future developments

<p><ul>

<li>SGML technology will work with XML (as long as it conforms to the
minor technical corrigenda mentioned above)

<li>Because XML is <em/much/ easier to parse than fully general SGML,
it is <em/much/ easier to produce parsers for it.  It is therefore
very likely that we will soon see many XML editors and XML-aware
browsers in the months to come.

<li>We should also see XML-aware search engines, potentially finally
realising the possibilities offered by hightly structured information
storage and retrieval.

<li>The development of 
<webref url='http://www.w3.org/Math/' >MathML</webref> should help see
maths on the internet

</ul>


<appendices>

<sect id=appx.sgml export>SGML -- some of the details

<p>This section covers some SGML topics in a little more detail than is
necessary if you simply want to write Starlink documents.  It should
give you enough understanding to allow you to read most DTDs.

<p>This section is for extra, or more detailed, information than it
was necessary to include in <ref id=markup>.  It will not, therefore,
repeat information presented there.

<subsect id=sgml.dtd export>Reading DTDs

<p>The discussion in <ref id=markup> should be enough to let you
produce your own documents but, now or in the future, you may find it
useful to be able to read the DTD directly.<note>Note for pedants:
there is a distinction between document type declaration and
definition.  The document type definition is the collection of rules
which specifies which elements can go where, what attributes they
have, and so on; the declaration is the <code>&lt;!doctype...></code>
invocation at the top of the document file -- the `document instance'
in SGML parlance -- which associates that instance with a particular
definition.  The abbreviation `DTD' usually refers to the definition,
and it is the definition that this section is about.</note> Once you
are familiar with the underlying ideas, the expression of them in the
DTD turns out to be agreeably compact and reasonably readable.

<p>My account of the DTD syntax will be rather compressed -- see
<citation/gentle/, or the other references in <ref
id=what.sgml> for alternatives.

<p>A simple HTML-like DTD could be declared as follows:
<verbatim><![ cdata [
<!element html      o o (head, body, copyright?)>
<!element head      o o (title & link*)>
<!element title     - - (#pcdata)>
<!element link      - o empty>
<!element body      o o (p | dl)+>
<!element p         - o (#pcdata)>
<!element dl        - - (dt, dd)+>
<!element (dt|dd)   - o (#pcdata)>
<!element copyright - - (#pcdata)>

<!entity % URL "cdata"
        -- The term URL means a CDATA attribute
           whose value is a Uniform Resource Locator,
           See RFC1808 (June 95) and RFC1738 (Dec 94).
        -->
<!attlist link
    href  %URL          #required  -- URL for linked resource --
    rel   (next | prev) #implied   -- reverse link types --
    >
<!entity amp "&">
]]></verbatim>
And here is a simple document which uses this DTD:
<verbatim><![ cdata [
<link href="http://www.astro.gla.ac.uk/users/norman/" rel=next>
<title>This is a title</title>

<p>And here is a paragraph
<dl>
<dt>With a delimited list
<dd>Correctly formed &amp; OK
</dl>
]]></verbatim>
This displays most of the important syntactical features in an SGML
DTD, so if we explain it line-by-line, it should illustrate the
features you need to make some sense of most DTDs.

<p><verbatim><![ cdata [
<!element html    o o (head, body, copyright?)>
]]></verbatim>
This `element declaration'
declares the <code/html/ element.  The element type name is followed
by a statement of whether the start and end tags may be omitted if the
parser can infer their presence.  The minimisation specifications may
be either `-' (minus), indicating that the corresponding tag is
required, or `o' (letter~O), indicating that it may be omitted.
Following this is the `content model' which, in this case, states that
the <code/html/ element must consist of one <code/head/, one
<code/body/, and an optional <code/copyright/, in that order -- the
comma connecting the element 
names specifies that they must be in order, and the question mark
following the copyright element indicates that it may occur zero or
one times. 
The omission of the start element is possible in this case, since the
first element in the <code/html/ element must be a <code/head/
element, so whenever the parser finds a <code/head/ element, it can
know that the <code/html/ element has begun.

<p>So what is in the <code/head/ element?
<verbatim><![ cdata [
<!element head    o o (title & link*)>
]]></verbatim>
The <code/head/ element consists of precisely one title, and zero or
more <code/link/ elements, in either order.  The <code/head/ tags
can be inferred from the presence of
the <code/title/ and <code/link/ elements, and so it is feasible for
us to declare that they may be omitted.  The star following the
<code/link/ token in the content model indicates that this element may
appear zero or more times, and the ampersand declares that the
elements on either side of it must both appear, but can do so in
either order.  Note that this content model allows `<code/title/',
`<code/title link link.../' and `<code/link link...title/', but not
`<code/link/' or `<code/link title link/'.

<p>Finally we have some text:
<verbatim><![ cdata [
<!element title   - - (#pcdata)>
]]></verbatim>
The title element is very simple: neither the start not the end tag
may be omitted, and it may contain only characters (<code/#pcdata/
stands for `parseable character data') and entity references such as
<code/&amp;amp;/.

<p><verbatim><![ cdata [
<!element link    - o empty>
]]></verbatim>
The <code/link/ element has no actual content, so it is given a
content model consisting of the reserved word <code/empty/.  The tag
omission for empty elements is always `<code/- o/'.  The point of the
<code/link/ element is to hold its attributes, which we will come to
shortly.

<p><verbatim><![ cdata [
<!element body    o o (p | dl)+>
]]></verbatim>
The document body consists of paragraph elements, or `delimited
lists'.  The `or' connector, `<code/|/', indicates that either of the
<code/p/ or <code/dl/ elements may appear, and the `plus' occurrence
indicator asserts that the group <code/(p|dl)/ must appear one or more
times.  In other words, the body consists of a sequence of <code/p/
and <code/dl/ elements in arbitrary order.

<p>Finally, we start to specify the `interesting' content of the document.
<verbatim><![ cdata [
<!element dl      - - (dt, dd)+>
]]></verbatim>
Like the <code/body/ itself, the <code/dl/ element consists of a
sequence of one or more structures.  Unlike the <code/body/ element,
however, the structure is not a list of alternatives, but a sequence.
Where the <code/body/ element would allow `<code/p p dl p/' for example, the
<code/dl/ element requires that the <code/dt/ and <code/dd/ elements
alternate -- the repeatable element is the <em/ordered pair/ of
elements `<code/dt, dd/'.

<p><verbatim><![ cdata [
<!element (dt|dd) - o (#pcdata)>
<!element p       - o (#pcdata)>
<!element copyright - - (#pcdata)>
]]></verbatim>
The paragraph, list and copyright elements have simple content
models.  Note that we can specify the structure of more than one
element in the same declaration.

<p>Prior to specifying the attributes for the <code/link/ element, we
may declare an abbreviation.
<verbatim><![ cdata [
<!entity % URL "cdata"
        -- The term URL means a CDATA attribute
           whose value is a Uniform Resource Locator,
           See RFC1808 (June 95) and RFC1738 (Dec 94).
        -->
]]></verbatim>
This declares <code/URL/ to be a `parameter entity', usable only
within this DTD.  The entity reference `<code/%URL/' will be
substituted by the string `<code/cdata/' (unparsed character data)
when it is encountered.  A DTD may declare an entity more than once,
but any declarations after the first are silently ignored.

<p>Note the structure of the comment in this last declaration: in SGML,
comments may appear only within markup declarations (that is within
`<code/&lt;! ... >/'), they start and end with the string
`<code/&#45;&#45;/', and there may be more than one in a row.  Thus you
may legally find `<code/&lt;!>/' within an SGML file -- this is a
completely empty markup declaration.  Such a declaration may have a
single comment within it, as in `<code><![ cdata [<!-- this is a comment
-->]]></code>', or it may have several, as in
<code><![ cdata [<!-- here -- -- is a comment ------>]]></code>, which
has <em/three/ comments within it, the third of which is empty. 

<p>Now we declare the attributes for the <code/link/ element.
<verbatim><![ cdata [
<!attlist link
    href  %URL          #required  -- URL for linked resource --
]]></verbatim>
This declares an <code/href/ attribute.  After expansion of the
<code/%URL/ entity reference, this attribute is seen to have a
`declared value' of <code/cdata/ (unparsed character data), and this
attribute is required to be present, so that the SGML parser will
object if it finds a <code/link/ element in a document without an
<code/href/ attribute.

<p>The <code/rel/ attribute can take only two values:
<verbatim><![ cdata [
    rel   (next | prev) #implied   -- reverse link types --
    >
]]></verbatim>
The <code/link/ element may have the attribute `<code/rel=next/' or
`<code/rel=prev/', but no other strings.  Since this attribute is
`<code/#implied/', it is also permitted to omit it entirely.  A
document may even specify this as simply `<code/&lt;link
href=&quot;here.html&quot; next>/' and the parser will infer that the value
`<code/next/' is associated with the attribute name `<code/rel/'.

<p><verbatim><![ cdata [
<!entity amp "&">
]]></verbatim>
Entity references (other than parameter entities, which are internal
to a DTD) are made using a
construction such as `<code/&amp;entname;/.  This presents a problem
if you want to include the ampersand in your text, but this
declaration sets up an entity called `amp', which can be used to
include an ampersand in text by typing `<code/&amp;amp;/'.  You can
use this in your own documents to create shorthand forms for bits of
text you don't want to retype.

<subsect id=sgml.dtdsubset export>Document type declaration subset

<p>As explained above, the structure of your document type, plus a
variety of entities, is declared in the DTD, which, because it is
common to a large number of documents, is held separately
from the document you are writing.

<p>It is possible, however, for a specific document to adjust or add to the
declarations within the DTD, and this is done within the `document
type declaration subset'.

<p>The DTD subset is typically used to declare entities of one type or
another, as described in <ref id=markup.dtdsubset>.

<p>The subset is a DTD fragment which is processed <em/before/ the
declaration refers to.  Thus, any (parameter) entity declarations
there override corresponding ones in the DTD, so it is possible for a
document author to do some limited rewriting of the DTD on the fly.
This will be most common when a DTD is modular, as the Starlink DTD
is.  As described in <ref id=str.structure>, you can enable features
within your DTD by setting a suitable entity.

<p>This get-out-of-jail-free card is obviously eminently abusable, and
you should avoid doing anything clever here.

<subsect id=sgml.entities export>SGML entities

<p>As described in <ref id=markup.entities>, entity references are a
mechanism for referring to characters, or 
longer pieces of text, which you cannot type on your keyboard, which
must be escaped from the parser, or which you simply want to
abbreviate.

<p>As well as general entities, there are parameter entities.  These
can be referenced only within markup declarations, and hence are
effectively restricted to the DTD.  The only time you'd use them in a
document instance would be within a marked section (<ref
id=sgml.ms>).  The point of parameter entities is that a document
author can define any entities they want in the declaration subset,
without having to worry that they might conflict with declarations in
the DTD.

<p>A reference to an entity <code/amp/ is of the form
<code/&amp;amp;/.  It is prefixed by the character <code/&amp/ and
suffixed by a semicolon.  In fact, you can omit the trailing semicolon
if the character following the entity name is not a name character --
not a letter, number, hyphen or dot.  Similarly, an ampersand not
followed by a name-start character (upper- and lowercase letters) is
recognised as an ampersand, and not a malformed entity reference.  It
is possibly bad to get into the habit of abbreviating entity
references, but you might need to be aware that these features both
exist and are legal.

<p>The list of entities predefined by the Starlink general DTD is
given in <ref id=table.entities>.

<p>It is not an error to define an entity twice.  In this case, the
second definition is silently ignored.

<p>You can define entities, including parameter entities, in the
document's `declaration subset' (see <ref id=markup.dtdsubset>), since
these conceptually come before, and hence have priority over,
definitions in the DTD.  Also, SGML parsers usually allow 
on-the-fly definitions on the command line.  However, resist resist
resist the temptation to do clever things here, since it is easy to
make your document unreadable and, a much more heinous crime, invalid.

<subsect id=sgml.ms export>Marked sections

<p>Another feature you will commonly find in DTDs is the `marked
section'.  As an author, you will most likely only ever use the
<code/cdata/ marked section, but the <code/ignore/ and <code/include/
marked sections are very commonly used within DTDs.

<p>A marked section is a construction such as
<verbatim>
Here is some text &lt;![ cdata [ with &lt;odds&gt; &amp sods &rsqbrack;]>
</verbatim>
and
<verbatim>
Here is some text &lt;![ ignore [ and here is some ignored text &rsqbrack;]>
</verbatim>
Along with <code/ignore/ there is <code/include/.

<p>The marked section ends at the sequence of characters
<code/&rsqbrack;&rsqbrack;&gt;/, which is therefore the one sequence
which cannot appear within the marked section.

<subsubsect id=sgml.ms.cdata>CDATA marked sections

<p>Within the <code/cdata/ marked section, parsing is switched off, so
that angle brackets, <code/&lt/, and ampersands, <code/&amp/, are no
longer recognised as introducing markup and entity references.

<p>You will typically use a <code/cdata/ marked section to delimit
verbatim text.  The <code/code/ and <code/verbatim/ elements (see <ref
id=el.sun.code> and <ref id=el.sun.verbatim>) do not make any
provision to switch off parsing of the text within them.  If the text
would be significant to the parser -- that is, if it contains angle
brackets or ampersands -- you must either escape those characters by
giving them as entity references <code/&amp;lt;/ or <code/&amp;amp;/,
or else enclose the contents in a <code/cdata/ marked section as
follows.
<verbatim>
&lt;verbatim>&lt;![ cdata [
Here is some &lt;em>marked-up&lt/em> text
which will be skipped &amp; ignored
&rsqbrack;&rsqbrack>&lt;/verbatim>
</verbatim>
Within a CDATA marked section, no markup is recognised except the
<code/&rsqbrack;]>/ which closes the marked section; thus element
start- and end-tags are not parsed, and entity references not expanded.

<subsubsect>IGNORE and INCLUDE marked sections

<p>Text within <code/include/ and <code/ignore/ marked sections is
parsed or skipped by the parser, as appropriate.  They are <em/not/
typically used outside of DTDs, but the <code/ignore/ marked section
is occasionally useful as a way of `commenting out' large sections of
text which might itself include SGML comments <code/&lt;!--
... --&gt;/. 

<p>Why on earth would you want to do this?  Because the ignore/include
keyword can be the expansion of an entity.  We could have defined our
HTML-like document type as follows:
<!-- can't use marked section when I'm illustrating one! -->
<verbatim>
&lt;!entity % allow.copyright &quot;ignore&quot;>
&lt;![ %allow.copyright; [
  &lt;!entity % html.model &quot;head, body, copyright?&quot;>
  &lt;!element copyright - - (#pcdata)>
&rsqbrack;]>
&lt;!entity % html.model &quot;head, body&quot;>
&lt;!element html    o o (%html.model;)>
</verbatim>
This looks very strange, but it is a common idiom in DTDs.  

<p>The entity reference <code/&percent;allow.copyright;/ is a
`parameter entity reference' (see section <ref id=sgml.entities>),
which is distinct from a general entity 
reference such as <code/&amp;amp;/, and can occur only within markup
(ie, within DTDs).

<p>The parameter entity <code/%allow.copyright/ is defined to be
<code/ignore/.  That means that when the parser finds the marked
section it ignores it, so that the first definition it finds of the parameter
entity <code/%html.model/ is the one which sets it to be
`<code/head,body/', so that is what is used as the content model
in the declaration of the <code/html/ element in the last line.

<p>Nothing appears to have been achieved here.  However, if the
<code/%allow.copyright/ entity had <em/earlier/ been set to
<code/include/, then the redefinition of it here would have been
ignored, the marked section would have been included, the
<code/%html.model/ entity would have been defined as
`<code/head,body,copyright?/' with the (now) second one ignored, and
the <code/html/ element would have been defined to allow all three
elements.  That is, marked sections used internally in this way can be
a useful way of parameterising DTDs.

<p>The entity could be declared earlier in the same DTD, in a
particular document's DTD-subset (see <ref id=markup.dtdsubset>), or
completely externally to the document in a command-line option to the
parser.

<subsubsect>Paper-only and web-only variants

<p>Sometimes, it is necessary to have parts of your document which
vary depending on whether the document is to be viewed on paper or
online.  The Starlink general DTD defines two parameter entities
<code/&percent;Only.paper/ and <code/&percent;Only.web/, which you can
use to include or ignore text in a marked section (see <ref
id=sgml.ms>).  By default, both of these are set to the string
`ignore', but the common Makefile (in
<code>$STARLINK_SGML_DIR/lib/Makefile.common</code>, see <ref
id=proc.makefile>) sets one or other of these to `include', as
appropriate for the type of file being generated.

<p>You would use this facility as follows:
<verbatim>
&lt;p>Here is some text.
&lt;![ %Only.web [ And here is some which would appear
only in webpages. &rsqbrack;&rsqbrack;>
</verbatim>

<p>It is, I hope, clear that you could get yourself in a terrible mess
here, and create a document which is only valid for some settings of
the entities.  Take care that your document remains valid for all
settings, including the case where both entities are set to `ignore'.

<sect id=appx.general.dtd export>The Starlink General DTD

<p>This section includes a list of all the elements in the Starlink
General DTD.  For a thematic treatment of the elements, see <ref
id=structure>, and the groups in <ref id=table.elements>.

<p>The elements listed here are shown as children of the top-level
element <code>&lt;sun></code>, because this is the most general of the
document types described in <ref id=str.structure>.  However, the
listing here does not <em/quite/ document the SUN DTD, since it
includes the <ref id=el.sun.docdate text='docdate'> element which is
only available in those document types which do <em/not/ have the
`Versioning' feature (see <ref id=str.structure> and <ref
id=str.history>).

<subsect id=appx.general.elementlist export>Element listing

<p>The following element listing includes all the elements and
attributes defined in the Starlink General DTD.  This includes a
number of attributes with a <em/fixed/ value (indicated by a default
keyword of <code/#fixed/).  These are for internal use by the DTD and
the applications which process it, and are not documented further.

&starlinkdtddoc;

<sect id=appx.programcode.dtd export>The Programcode DTD

<p>See <ref id=doccode> for an overview of documenting code.

<p>The programcode DTD described here is the same for all languages.
When you invoke it, however, you do so using a document type
declaration specific to the language of the program being documented.
See <ref id=doccode.languages> for details.

<subsect id=appx.programcode.elementlist export>Element listing

&programcodedtddoc;

<sect id=appx.system export>The Starlink SGML system for maintainers

<p>This section is a reference for maintainers of the Starlink SGML
system

<p>Supporting software: in .../sgml/lib (inc BibTeX style).

<p>Document summaries, including makefile target

<p>Documentation system is standard in SGML and HyTime terms (apart
from the `SQL query...' bit in the definition of docxref).  The
processing system uses <webref
url="http://www.oasis-open.org/cover/dsssl.html" >DSSSL</webref>,
which is a standard, but generates HTML using DSSSL extensions
specific to Jade, and generates LaTeX using DSSSL extensions specific
to a version of Jade using my patch.  Include the `This is an
SGML/HyTime application...' declaration somewhere -- here?

<p><ref id=appx.dssslcode> include a selection of the more important
DSSSL code modules.

<subsect id=appx.dssslcode export>The DSSSL source code

<routinelist>
<codecollection doc="dsssl.common">
<codecollection doc="dsssl.html.params">
<codecollection doc="dsssl.latex.params">
<codecollection doc=dsssl.lib>

<subsect id=install export>Installation

<p>More here presently.  For the present, see the notes on setting up,
in <ref id=proc.setup>.

<p>How to install everything, including building Jade.

<sect id=appx.releasenotes export>Release Notes

&release.notes;

<backmatter>
<notecontents>
<bibliography bib=ssn70>
