<!DOCTYPE style-sheet PUBLIC "-//James Clark//DTD DSSSL Style Sheet//EN">
(define RCSID "$Id$")

;;; Redesigned.  Rather than having _two_ documents, and leaping
;;; athletically between them, we now have just one document, conforming
;;; to the dtddescription DTD, which now includes the structures of the
;;; old dtdelementlist DTD.  Thus, rather than the dtd2sgml.pl script
;;; producing a standalone document, it generates a document fragment,
;;; which is included in the description document.


(declare-flow-object-class element
  "UNREGISTERED::James Clark//Flow Object Class::element")
(declare-flow-object-class empty-element
  "UNREGISTERED::James Clark//Flow Object Class::empty-element")
(declare-flow-object-class formatting-instruction
  "UNREGISTERED::James Clark//Flow Object Class::formatting-instruction")
;(define debug
;  (external-procedure "UNREGISTERED::James Clark//Procedure::debug"))

(define %sect-gi% "subsubsect")
(define %subsect-gi% "subsubsubsect")



(root
    (process-children))

;; top-level element
(element dtddescription
  (let* ((summ (node-list-first (children (current-node)))) ;dtdsummary element
	 (summtop (attribute-string (normalize "top") summ)))
    (if (string=? (gi summ) (normalize "dtdsummary"))
	(if (string=? (attribute-string (normalize "docelem")
					(current-node))
		      summtop)
	    (make sequence
	      (make formatting-instruction data:
		    (string-append "<" "!-- Generated by dtd2sgml: 
     "
				   RCSID "
     -->
"))
	      (process-node-list summ))
	    (error (string-append
		    "Description and summary don't match: "
		    (attribute-string (normalize "docelem")
				      (document-element))
		    " not equal to " summtop)))
	(error "dtdsummary element should be first!"))))

;; The next batch of elements document the structure of the DTD,
;; rather than its semantics.
(element dtdsummary
  (process-children))

(element dtdelement
  (let* ((gi (attribute-string (normalize "gi") (current-node)))
	 (descrip (element-with-id gi (current-node))))
    (make element gi: %sect-gi%
	  attributes: (list (list "id" (xref-id gi)))
	  (make element gi: "title"
		(literal "Element " gi))
	  (if (node-list-empty? descrip)
	      (empty-sosofo)
	      (make element gi: %subsect-gi%
		    (make element gi: "title"
			  (literal "Description"))
		    (with-mode discard-attribute
		      (process-node-list descrip))))
	  (process-children))))

(element dtdattribute
  (let* ((name (attribute-string (normalize "name")    (current-node)))
	 (def  (attribute-string (normalize "default") (current-node)))
	 (type (attribute-string (normalize "type")    (current-node)))
	 (cont (data (current-node)))
	 (gi (attribute-string (normalize "gi") (parent (current-node))))
	 (el-descrip (element-with-id gi (current-node)))
	 (att-descrip (select-elements (children el-descrip)
				       (list (normalize "attribute")
					     (list (normalize "name") name)))))
    (make element gi: %subsect-gi%
 	  (make element gi: "title"
 		(literal "Attribute " gi "/" name))
	  (if (node-list-empty? att-descrip)
	      (empty-sosofo)
	      (process-node-list att-descrip))
 	  (make element gi: "p"
 		(make element gi: "ul"
 		      (make element gi: "li"
 			    (literal "Default: " def))
 		      (if type
 			  (make element gi: "li"
 				(literal "Type: " type))
 			  (empty-sosofo))
 		      (if (> (string-length cont) 0)
 			  (make element gi: "li"
 				(literal "Allowed values: " cont))
 			  (empty-sosofo)))))))

(element dtdparents
    (make element gi: %subsect-gi%
	  (make element gi: "title"
		(literal "Parents"))
	  (make element gi: "p"
		(with-mode dtdelemref-list
		  (process-children)))))

(element dtdcontent
  (make element gi: %subsect-gi%
	(make element gi: "title"
	      (literal "Content"))
	(process-children)))

(element dtdcontentmodel
  (make element gi: "p"
	(make element gi: "code"
	      (process-children))))

(element dtdcontenttree
  (make element gi: "p"
	(make element gi: "verbatim"
	      (process-children))))

(define (node-list-or-false nl)
  (if (node-list-empty? nl)
      #f
      nl))

(element dtdelemref
  (let* ((id (attribute-string (normalize "id") (current-node)))
	 (target (and id
		      (node-list-or-false
		       (element-with-id id (current-node)))))
	 (gi (and target
		  (attribute-string (normalize "gi") target))))
    (if gi
	(make empty-element gi: "ref"
	      attributes: (list (list "id" (xref-id gi))
				(list "text" gi)))
	(error
	 (string-append "dtdelemref: "
			(cond
			 (target "target does not have gi")
			 (id (string-append "no element with id " id))
			 ("missing required ID")))))))

(mode dtdelemref-list
  (element dtdelemref
    (let* ((id (attribute-string (normalize "id") (current-node)))
	   (target (and id
			(node-list-or-false
			 (element-with-id id (current-node)))))
	   (gi (and target
		    (attribute-string (normalize "gi") target))))
      (if gi
	  (make sequence
	    (make empty-element gi: "ref"
		  attributes: (list (list "id" (xref-id gi))
				    (list "text" gi)))
	    (if (last-sibling? (current-node))
		(empty-sosofo)
		(literal ", ")))
	  (error
	   (string-append "dtdelemref: "
			  (cond
			   (target "target does not have gi")
			   (id (string-append "no element with id " id))
			   ("missing required ID"))))))))


;; Following are the elements in the dtddescription DTD which actually
;; document the semantics of the DTD, as opposed to its structure.
(element element
  (process-children))
(element attribute
  (process-children))
(mode discard-attribute
  (element attribute
    (empty-sosofo)))
(element elemref
  (let* ((gi (attribute-string (normalize "gi") (current-node)))
	 (self (attribute-string (normalize "self") (current-node)))
	 (xrefdtd-ent (attribute-string (normalize "dtd") (current-node)))
	 (xrefdtd-gi (and xrefdtd-ent	; false if not present
			  (entity-text xrefdtd-ent))))
    (if gi
	(if self
	    (literal gi)
	    (make empty-element gi: "ref"
		  attributes: (list (list "id" (xref-id gi xrefdtd-gi))
				    (list "text" gi))))
	(error "elemref: required gi attribute missing"))))
(element example
  (make sequence
    (literal "Example:")
    (make element gi: "verbatim"
	  (process-children))))
(element p
  (make element gi: "p"
    (process-children)))
(element em
  (make element gi: "em"
    (process-children)))
(element code
  (make element gi: "code"
    (process-children)))

;; webref and url: just copy to output
(element webref
  (let ((url (attribute-string (normalize "url"))))
    (make element gi: "webref"
	  attributes: `(("url" ,url))
	  (process-children))))
(element url
  (make element gi: "url"
	(process-children)))

;; Utility functions

;; Get document element
(define (document-element #!optional (node (current-node)))
  (node-property 'document-element
		 (node-property 'grove-root node)
		 default: #f ;(empty-node-list)
		 ))

;; (normalize) string function from DocBook library.  See there for docs.
(define (normalize str)
  (if (string? str)
      (general-name-normalize str
                              (current-node))
      str))

;; Generate an id for an element with a given GI
(define (xref-id giname #!optional (use-docelem #f))
  (let ((docelem (or use-docelem
		     (attribute-string (normalize "docelem")
				       (document-element)))))
    (if docelem
	(string-append "el." docelem "." giname)
	(error "Can't find DOCELEM"))))

