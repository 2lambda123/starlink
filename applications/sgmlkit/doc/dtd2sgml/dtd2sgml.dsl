<!DOCTYPE style-sheet PUBLIC "-//James Clark//DTD DSSSL Style Sheet//EN">
(define RCSID "$Id$")

;;; Redesigned.  Rather than having _two_ documents, and leaping
;;; athletically between them, we now have just one document, conforming
;;; to the dtddescription DTD, which now includes the structures of the
;;; old dtdelementlist DTD.  Thus, rather than the dtd2sgml.pl script
;;; producing a standalone document, it generates a document fragment,
;;; which is included in the description document.


(declare-flow-object-class element
  "UNREGISTERED::James Clark//Flow Object Class::element")
(declare-flow-object-class empty-element
  "UNREGISTERED::James Clark//Flow Object Class::empty-element")
(declare-flow-object-class formatting-instruction
  "UNREGISTERED::James Clark//Flow Object Class::formatting-instruction")
(define debug
  (external-procedure "UNREGISTERED::James Clark//Procedure::debug"))

(define %sect-gi% "subsubsect")
(define %subsect-gi% "subsubsubsect")



(root
    (process-children))

;; Most of the elements which are not specific to this DTD are
;; equivalent to the corresponding element in the target DTD, so make
;; the default action echo that.
(default
  (make element
    (process-children)))

;; top-level element
(element dtddescription
  (let* ((summ (node-list-first (children (current-node)))) ;dtdsummary element
	 (summtop (attribute-string (normalize "top") summ)))
    (if (string=? (gi summ) (normalize "dtdsummary"))
	(if (string=? (attribute-string (normalize "docelem")
					(current-node))
		      summtop)
	    (make sequence
	      (make formatting-instruction data:
		    (string-append "<" "!-- Generated by dtd2sgml: 
     "
				   RCSID "
     -->
"))
	      (process-node-list summ))
	    (error (string-append
		    "Description and summary don't match: "
		    (attribute-string (normalize "docelem")
				      (document-element))
		    " not equal to " summtop)))
	(error "dtdsummary element should be first!"))))

;; The next batch of elements document the structure of the DTD,
;; rather than its semantics.
(element dtdsummary
  (process-children))

(element dtdelement
  (let* ((gi (attribute-string (normalize "gi") (current-node)))
	 (descrip (element-with-id gi (current-node))))
    (make element gi: %sect-gi%
	  attributes: (list (list "id" (xref-id gi)))
	  (make element gi: "title"
		(literal "Element " gi))
	  (if (node-list-empty? descrip)
	      (empty-sosofo)
	      (make element gi: %subsect-gi%
		    (make element gi: "title"
			  (literal "Description"))
		    (with-mode discard-attribute
		      (process-node-list descrip))))
	  (process-children))))

(element dtdattribute
  (let* ((name (attribute-string (normalize "name")    (current-node)))
	 (def  (attribute-string (normalize "default") (current-node)))
	 (type (attribute-string (normalize "type")    (current-node)))
	 (cont (data (current-node)))
	 (gi (attribute-string (normalize "gi") (parent (current-node))))
	 (el-descrip (element-with-id gi (current-node)))
	 (att-descrip (select-elements (children el-descrip)
				       (list (normalize "attribute")
					     (list (normalize "name") name)))))
    (make element gi: %subsect-gi%
 	  (make element gi: "title"
 		(literal "Attribute " gi "/" name))
	  (if (node-list-empty? att-descrip)
	      (empty-sosofo)
	      (process-node-list att-descrip))
 	  (make element gi: "p"
 		(make element gi: "ul"
 		      (make element gi: "li"
 			    (literal "Default: " def))
 		      (if type
 			  (make element gi: "li"
 				(literal "Type: " type))
 			  (empty-sosofo))
 		      (if (> (string-length cont) 0)
 			  (make element gi: "li"
 				(literal "Allowed values: " cont))
 			  (empty-sosofo)))))))

(element dtdparents
    (make element gi: %subsect-gi%
	  (make element gi: "title"
		(literal "Parents"))
	  (make element gi: "p"
		(with-mode dtdelemref-list
		  (process-children)))))

(element dtdcontent
  (make element gi: %subsect-gi%
	(make element gi: "title"
	      (literal "Content"))
	(process-children)))

(element dtdcontentmodel
  (make element gi: "p"
	(make element gi: "code"
	      (process-children))))

(element dtdcontenttree
  (make element gi: "p"
	(make element gi: "verbatim"
	      (process-children))))

(define (node-list-or-false nl)
  (if (node-list-empty? nl)
      #f
      nl))

(element dtdelemref
  (let* ((id (attribute-string (normalize "id") (current-node)))
	 (target (and id
		      (node-list-or-false
		       (element-with-id id (current-node)))))
	 (gi (and target
		  (attribute-string (normalize "gi") target))))
    (if gi
	(make element gi: "ref"
	      attributes: `(("id" ,(xref-id gi)))
	      (literal gi))
	(error
	 (string-append "dtdelemref: "
			(cond
			 (target "target does not have gi")
			 (id (string-append "no element with id " id))
			 ("missing required ID")))))))

(mode dtdelemref-list
  (element dtdelemref
    (let* ((id (attribute-string (normalize "id") (current-node)))
	   (target (and id
			(node-list-or-false
			 (element-with-id id (current-node)))))
	   (gi (and target
		    (attribute-string (normalize "gi") target))))
      (if gi
	  (make sequence
	    (make element gi: "ref"
		  attributes: `(("id" ,(xref-id gi)))
		  (literal gi))
	    (if (last-sibling? (current-node))
		(empty-sosofo)
		(literal ", ")))
	  (error
	   (string-append "dtdelemref: "
			  (cond
			   (target "target does not have gi")
			   (id (string-append "no element with id " id))
			   ("missing required ID"))))))))


;; Following are the elements in the dtddescription DTD which actually
;; document the semantics of the DTD, as opposed to its structure.
(element element
  (process-children))
(element attribute
  (process-children))
(mode discard-attribute
  (element attribute
    (empty-sosofo)))
(element elemref
  (let* ((gi (attribute-string (normalize "gi") (current-node)))
	 (self (attribute-string (normalize "self") (current-node))))
    (if gi
	(if self
	    (literal gi)
	    (make element gi: "ref"
		  attributes: `(("id" ,(xref-id gi)))
		  (literal gi)))
	(error "elemref: required gi attribute missing"))))
(element elemxref
  (let* ((gi (attribute-string (normalize "gi") (current-node)))
	 (xrefdtd-ent (attribute-string (normalize "dtd") (current-node)))
	 ;; Get document-element of the target document, if it exists
	 (xrefdtd-de (and xrefdtd-ent
			  (document-element-from-entity xrefdtd-ent))))
    (if gi
	(make element gi: "ref"
	      attributes: `(("id" ,(xref-id gi xrefdtd-de)))
	      (literal gi))
	(error "elemref: required gi attribute missing"))))
(element example
  (make sequence
    (literal "Example:")
    (make element gi: "verbatim"
	  (process-children))))

;; Elements p, em, code, verbatim, dl, dt, dd, ul, ol, li, url map
;; directly to the same-named element in the target DTD, so let the
;; default action cope with them.


;; webref: just copy to output, copying the attribute
(element webref
  (let ((url (attribute-string (normalize "url"))))
    (make element gi: "webref"
	  attributes: `(("url" ,url))
	  (process-children))))

;; commentary element -- discard
(element commentary
  (empty-sosofo))

;; Utility functions

;; Get document element
(define (document-element #!optional (node (current-node)))
  (node-property 'document-element
		 (node-property 'grove-root node)
		 default: #f ;(empty-node-list)
		 ))
(define %xml-decl-entity% "xml.decl")
(define (document-element-from-entity str #!key (prepend-decl #t))
  (let ((fsi (if prepend-decl
		 (string-append (entity-generated-system-id %xml-decl-entity%)
				(entity-generated-system-id str))
		 (entity-generated-system-id str))))
    (if fsi
        (document-element (sgml-parse fsi))
        (error (string-append "Can't generate file from entity " str)))))

;; (normalize) string function from DocBook library.  See there for docs.
(define (normalize str)
  (if (string? str)
      (general-name-normalize str
                              (current-node))
      str))

;; Generate an id for an element with a given GI
(define (xref-id giname #!optional (use-docelem #f))
  (let ((docelem (attribute-string (normalize "docelem")
				   (or use-docelem (document-element)))))
    (if docelem
	(string-append "el." docelem "." giname)
	(error "Can't find DOCELEM"))))

