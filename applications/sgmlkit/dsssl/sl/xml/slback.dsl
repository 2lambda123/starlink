<!doctype programcode public "-//Starlink//DTD DSSSL Source Code 0.2//EN" [
  <!entity common.dsl		system "../common/slcommon.dsl" subdoc>
  <!entity lib.dsl		system "../lib/sllib.dsl" subdoc>
  <!entity params.dsl		system "sl-html-parameters">
]>
<!-- $Id$ -->

<docblock>
<title>Backmatter in XML
<description>Support the backmatter elements.  Reasonably simple in
XML, because there's little cross-referencing to do.

<authorlist>
<author id=ng affiliation='Glasgow'>Norman Gray

<copyright>Copyright 1999, Particle Physics and Astronomy Research Council

<codegroup id=code.back>
<title>Support backmatter

<misccode>
<description>Declare Jade extension
<codebody>
(define read-entity
  (external-procedure "UNREGISTERED::James Clark//Procedure::read-entity"))
(declare-flow-object-class fi
  "UNREGISTERED::James Clark//Flow Object Class::formatting-instruction")

<misccode>
<description>
Support backmatter elements.
<codebody>

(element backmatter
  (make sequence
    ;(make-bibliography)
    (make-updatelist)))

(mode section-reference
  (element backmatter
    (make-section-reference title: (literal "Notes, etc..."))))

<misccode>
<description>
Support notes very simply as footnotes.  Don't put them in the backmatter
in fact
<codebody>
(element note
  (make element gi: "footnote"
	(process-children)))

<misccode>
<description>
Bibliography support.  The citation can be handled very simply -- just
emit the citation key, bracketed.  For the bibliography itself, simply
read in the <code/.bbl/ file we hope has been generated by a previous
Jade pass.
<codebody>
(element citation
  (make sequence
    (literal "[")
    (process-children)
    (literal "]")))

(define (make-bibliography)
  (let* ((hasbib? (attribute-string (normalize "bibliography")
				    (getdocbody 'backmatter)))
	 (bibcontents (and hasbib?
			   (read-entity (string-append (root-file-name)
						       ".latexbib.bbl")))))
    (if bibcontents
	;(make sequence
	;  (make empty-command name: "section"
	;	parameters: '("Bibliography"))
	;  (make fi data: bibcontents))
	(empty-sosofo)
	(empty-sosofo))))

<misccode>
<description>
Process the history element in the docbody.  Present it in reverse order
(ie, newest first), including in the distribution and change elements any
update elements which refer to them.
<codebody>
(define (make-updatelist)
  (make sequence
    (make element gi: "div"
	  attributes: '(("level" "1"))
	  (make element gi: "divtitle"
		(literal "Change history"))
	  (make element gi: "divbody"
		(with-mode extract-updatelist
		  (process-node-list (getdocinfo 'history)))))))


(mode extract-updatelist
  (element history
      (node-list-reduce (children (current-node))
			(lambda (last el)
			  (sosofo-append (process-node-list el)
					 last))
			(empty-sosofo)))
  (element version
    (make sequence
      (make element gi: "div"
	    attributes: '(("level" "2"))
	    (make element gi: "divtitle"
		  (literal (string-append "Version "
					  (attribute-string (normalize "number")))))
	    (make element gi: "divbody"
		  (process-node-list (element-with-id
				      (attribute-string (normalize "author"))))
		  (literal ", "
			   (format-date (attribute-string (normalize "date"))))))))
  (element distribution
    (collect-updates (literal "Distribution "
			      (attribute-string (normalize "string")))))
  (element change
    (collect-updates (literal
		      "Change "
		      (format-date (attribute-string (normalize "date"))))))
  (element update
    (make sequence
      (make element gi: "listlabel"
	    (let ((linktarget (ancestor-member (current-node)
					       (target-element-list))))
	      (with-mode section-reference
		(process-node-list linktarget))))
      (make element gi: "listitem"
	    (process-children))))
  )

(define (collect-updates title)
  (let* ((allupdates (get-updates))
	 (myvid (attribute-string (normalize "versionid")))
	 (selupdates (and myvid
			  (node-list-or-false
			   (select-elements
			    allupdates
			    (list (normalize "update")
				  (list (normalize "versionid")
					myvid)))))))
    (make sequence
      (make element gi: "div"
	    attributes: '(("level" "2"))
	    (make element gi: "divtitle"
		  (literal title))
	    (make element gi: "divbody"
		  (process-node-list (element-with-id
				      (attribute-string (normalize "author"))))
		  (literal ", "
			   (format-date (attribute-string (normalize "date"))))
		  (process-children)))
      (if selupdates
	  (make element gi: "list"
		attributes: '(("class" "description"))
		(process-node-list selupdates))
	  (empty-sosofo)))))

(element update				; ignore in default mode
  (empty-sosofo))


<codereference doc="lib.dsl" id="code.lib">
<title>Library code
<description>
<p>Some of this library code is from the standard, some from Norm
Walsh's stylesheet, other parts from me

<codereference doc="common.dsl" id="code.common">
<title>Common code
<description>
<p>Code which is common to both the HTML and print stylesheets.

<codegroup id=back.main use="code.common code.lib">
<title>Preprocess backmatter
<description>This part of the stylesheet is standalone, and may be used
to process a document and extract those parts of the document (such as 
bibliography references) which require preprocessing.

<misccode>
<description>
Extract the bibliography to a LaTeX .aux file, ready for processing
by BibTeX.
<codebody>
(declare-flow-object-class entity
  "UNREGISTERED::James Clark//Flow Object Class::entity")
(declare-flow-object-class fi
  "UNREGISTERED::James Clark//Flow Object Class::formatting-instruction")
;;(define debug
;;  (external-procedure "UNREGISTERED::James Clark//Procedure::debug"))


;; Read in the parameter file
&params.dsl;

(root
    (make sequence
      (make fi data: (string-append (root-file-name) ":"))
      (get-bibliography)))

(define (get-bibliography)
  (let* ((kids (select-by-class (descendants (document-element)) 'element))
	 (citations (select-elements kids (normalize "citation")))
	 ;;(bibelement (select-elements kids (normalize "bibliography")))
	 (bibname (attribute-string (normalize "bibliography")
				    (getdocbody 'backmatter)))
	 )
    (if (node-list-empty? citations)
	(empty-sosofo)
	(make entity system-id: (string-append (root-file-name)
					       ".latexbib.aux")
	      (make fi data: "\\relax
")
	      (process-node-list citations)
	      (if bibname
		  (make fi data: (string-append "\\bibdata{" bibname "}
\\bibstyle{plainlatex}
"))
		  (error "Citations but no BIBLIOGRAPHY in document"))
	      ;;(if (node-list-empty? bibelement)
	      ;;  (error "Citations but no BIBLIOGRAPHY in document")
	      ;;  (process-node-list bibelement))
	      ))))

(element citation
  (make fi data: (string-append "\\citation{" (trim-data (current-node)) "}
")))

