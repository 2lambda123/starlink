#! /star/Perl/bin/perl -w
#
# Autoastrometry tool
#
# Uses the facilities in StarPerl, so might not work with a vanilla
# Perl installation.  See SUN/228 for details.
#
# Environment variables used:
#
#    STARLINK (default /star):
#        Root of the starlink tree.
#    AUTOASTROM_DIR (default from $0):
#        Location of the autoastrom scripts, binaries, and configuration files
#    AUTOASTROM_TEMPDIR (default /tmp):
#        Location for temporary autoastrom files
#    EXTRACTOR_DIR (default $STARLINK/bin/extractor):
#        Location of the SExtractor binary and config files
#    KAPPA_DIR (default $STARLINK/bin/kappa):
#        Location of the kappa binary and config files
#
# $Id$

use strict;

my $VERSION = '0.4';		# %%VERSION%%
my $RCSInfo = '$Revision$ $Date$ ';

my $Usage = "$0 [OPTIONS] <NDF> or $0 --help";
my $progpath;			# Path to program.
($progpath = $0) =~ s+/[^/]*$++;
my $progname;			# Name of program
($progname = $0) =~ s+^.*/++;

my $NDF = undef;		# Name of the NDF to be processed
                                # (with or without the .sdf
                                # extension) 

my $keeptemps = 1;		# Keep temporary files for later debugging.

my $tempDir = undef;		# Allow this to be forced on the
                                # commandline.  This is presently for
                                # speed during debugging, but could
                                # conceivably be used in some
                                # production modes to redo some
                                # processing.  If this is given a
                                # value, then we call reuse_files(),
                                # which makes the library functions
                                # avoid regenerating files.

my $insertwcs = 1;		# Insert the final WCS information
                                # into the target NDF.

my $retainwcs = undef;		# If this is defined, it gives the
                                # name of a file in which we should
                                # retain the final WCS information
                                # (rather than letting it be amongst
                                # the temporary files to be deleted).

my $CCDcat = undef;		# If defined, a catalogue of objects
                                # on the CCD, as obtained from
                                # SExtractor.  Set only by the
                                # debugging/testing option xxxccdcat

my $NDFoverrides = undef;	# Overrides for NDFinfo.  Set only by
                                # the debugging/testing option xxxndfinfo.

my $monolithTimeout = 180;	# Timeout for monoliths.  Needs to be
                                # larger than default 60s.

my $monolithMessages = 1;	# Display monolith messages.

my $maxobj = 500;		# Maximum number of objects to
                                # manipulate.  This number is
                                # fairly arbitrary, but generous.

my $esocatname = 'usno@eso';	# Name of the catalogue to use by
                                # default, as known by SkyCat.

my $skycatconfig = undef;	# SkyCat configuration file.

my $verbose = 0;		# Chatter to STDERR.

my $dumpstatefile = undef;	# If defined, then after all
                                # command-line parsing is completed,
                                # and before starting any actual work,
                                # dump state to this file.

my $cmdlineobsdata = undef;	# Source for WCS information.  Can be
                                # undef (meaning default), 'AST'
                                # (meaning NDF AST information),
                                # 'FITS' (indicating that it should be
                                # taken from any FITS extension in the
                                # NDF), or ... explicit coordinates.

# Global variables
#XXX delete TEMPFILES
#my @TEMPFILES = ( );		# List of the temporary files which
                                # are created.


# Check that all the required environment variables have values.
$ENV{STARLINK} = '/star'
  unless defined ($ENV{STARLINK});
$ENV{AUTOASTROM_DIR} = "$progpath"
  unless defined ($ENV{AUTOASTROM_DIR});
$ENV{AUTOASTROM_TEMPDIR} = "/tmp"
  unless defined $ENV{AUTOASTROM_TEMPDIR};
$ENV{EXTRACTOR_DIR} = "$ENV{STARLINK}/bin/extractor"
  unless defined ($ENV{EXTRACTOR_DIR});
$ENV{KAPPA_DIR} = "$ENV{STARLINK}/bin/kappa"
  unless defined ($ENV{KAPPA_DIR});
$ENV{CCDPACK_DIR} = "$ENV{STARLINK}/bin/ccdpack"
  unless defined $ENV{CCDPACK_DIR};
$ENV{ATOOLS_DIR} = "$ENV{STARLINK}/bin/atools"
  unless defined $ENV{ATOOLS_DIR};
$ENV{ASTROM_DIR} = "$ENV{AUTOASTROM_DIR}"
  unless defined $ENV{ASTROM_DIR};
$ENV{CONVERT_DIR} = "$ENV{STARLINK}/bin/convert"
  unless defined $ENV{CONVERT_DIR};


# Library inclusions
# Perl standard libraries
use File::Copy;			# For copy() function

# Include the ADAM interface modules, and version-checking module
use Starlink::AMS::Init;
use Starlink::AMS::Task;
use Starlink::Versions;
# Include the NDF modules, for the fits_read_header function
use NDF;

# Use the getopt library
use Getopt::Long;



# The following requires that the variable AUTOASTROM_DIR be defined
# at _compile_ time (so that the setting of it above will never
# actually happen).
use lib "$ENV{AUTOASTROM_DIR}";
use Moggy;

# Include the subroutines
use autoastrom;


# Check that we have all the applications we need.
foreach my $app ("$ENV{KAPPA_DIR}/kappa_mon",
		    "$ENV{KAPPA_DIR}/ndfpack_mon",
		    "$ENV{CCDPACK_DIR}/ccdpack_reg",
		    "$ENV{EXTRACTOR_DIR}/extractor",
		    "$ENV{ATOOLS_DIR}/atools_mon") {
    -x $app || wmessage ('fatal', "Can't find monolith $app");
}

# Check we have the appropriate versions of applications.  We need
# CCDPACK version 4.0.1 or better, to get the propagation of extra
# columns.
if (Starlink::Versions::starversion_lt('ccdpack', '4.0-1')) {
    wmessage 'fatal', "We have CCDPack version "
      .Starlink::Versions::starversion_string('ccdpack')
      .", but we need 4.0-1 or better\n";
}
# And we need ATOOLS 1.3 or better, to get asttrann
if (Starlink::Versions::starversion_lt('atools', '1.3')) {
    wmessage 'fatal', "We have ATOOLS version "
      .Starlink::Versions::starversion_string('atools')
      .", but we need 1.3 or better\n";
}

# Useful values
my $d2r = 57.295779513082320876798155; # degrees to radians (quite accurately)


# Log who we are.
wmessage ('info', "$progname, v$VERSION");

# Copy the argument list XXX permanent?
my @arglist2 = ($0);
foreach (@ARGV) { push (@arglist2, $_); }


# Examine the argument list and options (man Getopt::Long).  Option(s)
# xxx* are for testing and debugging only.
my %optionset = ();
GetOptions (\%optionset,
	    "catalogue=s",	# SkyCat name of online catalogue to use
	    "dump=s",		# Dump state after parsing cmdline, and stop
	    "help!",		# Print usage information
	    "insert!",		# insert WCS info into NDF at end?
	    "keepfits=s",	# retain FITS-WCS in this file
	    "keeptemps!",	# keep temporary files?
	    "maxobj=i",		# maximum number of objects to process
	    "messages!",	# show messages from monoliths?
	    "obsdata=s",	# source of WCS info (AST/FITS)
	    "skycatconfig=s",	# SkyCat configuration file
	    "temp=s",		# name of temporary directory
	    "timeout=i",	# monolith timeout
	    "verbose!",		# verbosity
	    "version!",		# display version number
	    "xxxccdcat=s",	# catalogue of objects on CCD
	    'xxxndfinfo=s',	# overrides for NDFinfo
	    )
  || wmessage 'fatal', "Can't parse options\n";

if (defined($optionset{help}) && $optionset{help}) {
    print "Usage: $0 [options] NDF-file\n";
    print "Options: [and defaults; if no default, value is generated]\n";
    print "\tcatalogue     SkyCat name of online catalogue to use [$esocatname]\n";
    print "\thelp          Print this help\n";
    print "\tinsert        Insert WCS info into NDF at end? [", ($insertwcs ? "true" : "false"), "]\n";
    print "\tkeepfits      Retain WCS in specified file (default if empty) ['']\n";
    print "\tkeeptemps     Keep temporary files? [", ($keeptemps ? "true" : "false"), "]\n";
    print "\tmaxobj        Maximum number of objects to process [$maxobj]\n";
    print "\tmessages      Show messages from monoliths? [", ($monolithMessages ? "true" : "false"), "]\n";
    print "\tobsdata       WCS info=AST/FITS/[kwd-list] ['']\n";
    print "\tskycatconfig  SkyCat configuration file [$skycatconfig]\n" if defined($skycatconfig);
    print "\ttemp          Name of temporary directory\n";
    print "\ttimeout       Monolith timeout [$monolithTimeout]\n";
    print "\tverbose       Verbosity [", ($verbose ? "true" : "false"), "]\n";
    exit 0;
}

if (defined($optionset{version}) && $optionset{version}) {
    print "$progname v$VERSION ($RCSInfo)\n";
    exit 0;
}

($#ARGV == 0) || wmessage 'fatal', "Must have exactly one NDF argument";
$NDF = $ARGV[0];
defined($NDF) || wmessage 'fatal', "Usage: $Usage";
$NDF =~ s/\.sdf$//;		# remove any .sdf extension

$esocatname = $optionset{catalogue}	if defined ($optionset{catalogue});
$insertwcs = $optionset{insert}		if defined ($optionset{insert});
$retainwcs = $optionset{keepfits}	if defined ($optionset{keepfits});
$keeptemps = $optionset{keeptemps}	if defined ($optionset{keeptemps});
$maxobj = $optionset{maxobj}		if defined ($optionset{maxobj});
$monolithMessages = $optionset{messages} if defined ($optionset{messages});
$cmdlineobsdata = $optionset{obsdata}	if defined ($optionset{obsdata});
$skycatconfig = $optionset{skycatconfig} if defined ($optionset{skycatconfig});
$tempDir = $optionset{temp}		if defined ($optionset{temp});
$monolithTimeout = $optionset{timeout}	if defined ($optionset{timeout});
$verbose = $optionset{verbose}		if defined ($optionset{verbose});
$dumpstatefile = $optionset{dump}	if defined ($optionset{dump});#-=stdout
$CCDcat = $optionset{xxxccdcat}		if defined ($optionset{xxxccdcat});
$NDFoverrides = $optionset{xxxndfinfo}	if defined ($optionset{xxxndfinfo});

# Do some processing, defaulting, and checking of options.

(defined($retainwcs) || $insertwcs)
  || wmessage 'fatal', "You must have either --fits or --insert specified (otherwise you won't get any results at all)";

# Pass the setting of $verbose to the autoastrom library functions.
verbosity ($verbose);

# --temp implicitly causes reuse of files.
reuse_files() if $tempDir;

# Generate a temporary file name, if it wasn't set
defined($tempDir) || ($tempDir = "$ENV{AUTOASTROM_TEMPDIR}/autoastrom-$$");
(-d $tempDir)
  || mkdir ($tempDir, 0755) 
  || wmessage 'fatal', "Can't create directory $tempDir, for some reason. Giving up!";



# Log the argument list
open (AL, ">$tempDir/argument-list")
  || wmessage 'fatal', "Can't open file $tempDir/argument-list to write";
print AL "@arglist2\n";
close (AL);




# Examine the value of the --obsdata option.
#
# The content of $cmdlineobsdata is a sequence of keyword=value pairs,
# separated by commas.
defined ($cmdlineobsdata) || ($cmdlineobsdata = ''); # make sure it's defined
my %obsdata;
foreach my $p (split (/ *, */, $cmdlineobsdata)) {
    if (my ($k,$v) = ($p =~ /^ *([A-Za-z]+) *= *(\S+) *$/)) {
	print STDERR "obsdata{$k}=$v\n";
	$obsdata{$k} = $v;
    } else {
	print STDERR "obsdata keyword <$p> malformed (ignored)\n";
    }
}
my $badkwd = check_obsdata_kwd (%obsdata);
if (defined($badkwd)) {
    wmessage ('fatal', "obsdata value <$badkwd> unrecognised or malformed");
}



# Start things up, set the timeout to be 30 seconds, and turn off all
# but error messages if $monolithMessages is 0.
wmessage ('info', "Starting monoliths...");
my $ams = new Starlink::AMS::Init(1);
$ams->timeout($monolithTimeout);
$ams->messages($monolithMessages);


# Define the CONVERT environment variables.
#
# We don't actually have to start anything up here.  CONVERT setup
# (for our present purposes) consists of specifying a number of
# environment variables to control how the NDF library recognises
# foreign formats and how it invokes the converters.  See
# $CONVERT_DIR/convert.csh
#
# We don't need the full panoply of FITS file extensions, since the
# only FITS files we'll be wanting to read will be FITS-WCS files
# created by this application.  The following is more than enough.
$ENV{NDF_FORMATS_IN} = 'FITS(.fits),FITS(.fit),FITS(.fts),FITS(.FITS),FITS(.FIT),FITS(.FTS)';
$ENV{NDF_FROM_FITS} = "$ENV{CONVERT_DIR}/convertndf from '^fmt' '^dir' '^name' '^type' '^fxs' '^ndf'";
$ENV{NDF_TEMP_FITS} = 'temp_fits_^name^fxscl';

# temp NDF debugging switch
#$ENV{NDF_SHCVT} = 1;


my %helpers = ();
# I don't understand why, but all of these monoliths need to be
# started up here rather than in the individual subroutines.  If we
# don't do this, we get crashes.
#
# Start up KAPPA
my $Kappa = new Starlink::AMS::Task
  ("kappa_mon_$$", "$ENV{KAPPA_DIR}/kappa_mon");
$Kappa->contactw || wmessage 'fatal', "Error launching Kappa - timeout";
$helpers{kappa} = $Kappa;

# ... and KAPPA's NDFPACK
my $NDFPack = new Starlink::AMS::Task
  ("ndfpack_mon_$$", "$ENV{KAPPA_DIR}/ndfpack_mon");
$NDFPack->contactw || wmessage 'fatal', "Error launching NDFPack - timeout";
$helpers{ndfpack} = $NDFPack;

# ... and CCDPack
my $CCDPack = new Starlink::AMS::Task
  ("ccd_mon_$$", "$ENV{CCDPACK_DIR}/ccdpack_reg");
$CCDPack->contactw || wmessage 'fatal', "Error launching CCDPack - timeout";
$helpers{ccdpack} = $CCDPack;

# ... and SExtractor
#
# SExtractor is called with a custom config file which is set up to
# put output in the place pointed to by the AUTOASTROMTEMPCATALOGUE
# environment variable.
$ENV{AUTOASTROMTEMPCATALOGUE} = "$tempDir/extractor-temp";
#push (@TEMPFILES, $ENV{AUTOASTROMTEMPCATALOGUE});
my $extractor = new Starlink::AMS::Task
  ("extractor_mon_$$", "$ENV{EXTRACTOR_DIR}/extractor");
$extractor->contactw  || wmessage 'fatal', "Error launching extractor -- timeout";
$helpers{extractor} = $extractor;

# ... and ATOOLS
my $atools = new Starlink::AMS::Task
  ("atools_mon_$$", "$ENV{ATOOLS_DIR}/atools_mon");
$atools->contactw || wmessage 'fatal', "Error launching atools -- timeout";
$helpers{atools} = $atools;

wmessage ('info', "Monoliths OK");





# Now, finally start processing.

# Begin with confirmation of who we are, and what we plan to do
wmessage ('info', "Processing NDF <$NDF>");
if ($ENV{http_proxy}) {
    wmessage ('info', "HTTP proxy: ".$ENV{http_proxy});
} else {
    wmessage ('info', "No HTTP proxy");
}



# Obtain the PIXEL coordinates of the corners of the NDF image, and
# the WCS information from the WCS component of the NDF.  Returns a
# hash with {date}, {dim1}, {dim2}, {ast}, {fits}, {hassky})
my $NDFinfo = ndf_info ($NDF, \%helpers, \%obsdata, $tempDir);
wmessage ('info', "NDF <$NDF> examined OK");


# Allow the NDFinfo fields to be overridden.  This is only for
# debugging and testing.
if (defined($NDFoverrides)) {
    foreach my $ndfkw (split(',',$NDFoverrides)) {
	my ($k,$v) = $ndfkw =~ /(.*)=(.*)/;
	$NDFinfo->{$k} = $v;
	printf STDERR ("OVERRIDING NDFinfo{%s}=%s\n", $k, $NDFinfo->{$k});
    }
}


# Now select a source for the WCS information, and add this to the
# NDFinfo hash, with the keyword {wcs}.
#
# The default source of wcs data is first user-keywords, then AST,
# then FITS.
defined($obsdata{source}) || ($obsdata{source} = 'USER:AST:FITS');

foreach my $wcssource (split(/\s*:\s*/, $obsdata{source})) {

    if ($wcssource eq 'AST') {
	if (defined($NDFinfo->{ast})) {
	    $NDFinfo->{wcs} = $NDFinfo->{ast};
	    wmessage ('info', "WCS information from AST");
	    print STDERR "WCS info from AST\n" if $verbose;
	    last;
	}
    } elsif ($wcssource eq 'FITS') {
	if (defined($NDFinfo->{fits})) {
	    $NDFinfo->{wcs} = $NDFinfo->{fits};
	    wmessage ('info', "WCS information from FITS");
	    print STDERR "WCS info from FITS\n" if $verbose;
	    last;
	}
    } elsif ($wcssource eq 'USER') {
	# %obsdata is a hash of keyword/value pairs.  Use values to
	# construct a FITS file giving the rough astrometry.  The keywords
	# are (ra, dec, pa, scale, invert): see documentation for
	# make_pseudo_fits for details.
	#
	# If there are no appropriate keywords present in %obsdata,
	# then this routine will return undef.
	my $pseudofits = make_pseudo_fits (%obsdata, %{$NDFinfo});
	if (defined($pseudofits)) {
	    wmessage ('info', "WCS information from command line");
	    $NDFinfo->{wcs} = $pseudofits;
	    if ($verbose) {
		open (PF,">$tempDir/pseudo.fits")
		  || wmessage ('fatal', "Can't open $tempDir/pseudo.fits to write");
		foreach my $c (@{$NDFinfo->{wcs}}) {
		    print PF "$c\n";
		}
		close (PF);
		print STDERR "WCS information from --wcs commandline\n";
	    }
	    last;
	}
    } else {
	# Eh?
	wmessage ('warning', "Unrecognised WCS source <$wcssource>");
    }
}


    


defined($NDFinfo->{wcs})
    || wmessage ('fatal', "No WCS information available in NDF <$NDF>");


# The following test would be irrelvant or wrong if the calibration is
# being taken from a FITS file.  Is it necessary?  Omit it for the moment.
#if (! $NDFinfo->{hassky}) {
#    print STDERR "The NDF $NDF does not appear to have a SKY domain.\nYou need to do at least an approximate calibration first\n";
#    exit 1;
#}


# Find the moggy program.  Searching for it like this gives us a
# little more flexibility in installation locations (and means that
# the system will work for testing in its build directory).
my $moggylocation = undef;
foreach my $loc ("$ENV{AUTOASTROM_DIR}/moggy", 
	      "$ENV{AUTOASTROM_DIR}/moggy/moggy") {
    if (-f $loc && -x $loc) {
	$moggylocation = $loc;
	last;
    }
}
defined ($moggylocation) || wmessage ('fatal', "Can't locate moggy program");


# Debugging/testing: if --dump=filename has been specified, then dump the
# current state to the specified file, and exit.
if ($dumpstatefile) {
    wmessage ('info', "Dumping state, and exiting...");
    open (D, ">$dumpstatefile")
      || wmessage ('fatal', "Can't open file $dumpstatefile to write");

    # Print state variables (can't use array plus symbolic refs, since
    # these are lexical variables (my...) which aren't visible to
    # symbolic references).
    printf D ("NDF=%s\n",
	      (defined($NDF) ? $NDF : "<UNDEF>"));
    printf D ("keeptemps=%s\n",
	      (defined($keeptemps) ? $keeptemps : "<UNDEF>"));
    printf D ("tempDir=%s\n",
	      (defined($tempDir) ? $tempDir : "<UNDEF>"));
    printf D ("insertwcs=%s\n",
	      (defined($insertwcs) ? $insertwcs : "<UNDEF>"));
    printf D ("retainwcs=%s\n",
	      (defined($retainwcs) ? $retainwcs : "<UNDEF>"));
    printf D ("CCDcat=%s\n",
	      (defined($CCDcat) ? $CCDcat : "<UNDEF>"));
    printf D ("monolithTimeout=%s\n",
	      (defined($monolithTimeout) ? $monolithTimeout : "<UNDEF>"));
    printf D ("monolithMessages=%s\n",
	      (defined($monolithMessages) ? $monolithMessages : "<UNDEF>"));
    printf D ("maxobj=%s\n",
	      (defined($maxobj) ? $maxobj : "<UNDEF>"));
    printf D ("esocatname=%s\n",
	      (defined($esocatname) ? $esocatname : "<UNDEF>"));
    printf D ("skycatconfig=%s\n",
	      (defined($skycatconfig) ? $skycatconfig : "<UNDEF>"));
    printf D ("verbose=%s\n",
	      (defined($verbose) ? $verbose : "<UNDEF>"));
    printf D ("dumpstatefile=%s\n",
	      (defined($dumpstatefile) ? $dumpstatefile : "<UNDEF>"));
    printf D ("obsdata:\n");
    foreach my $k (sort(keys(%obsdata))) {
	printf D ("    %s=%s\n", $k, $obsdata{$k});
    }
    #printf D ("moggylocation=%s\n", $moggylocation);
    print D "NDFinfo hash:\n";
    foreach my $k (sort(keys(%$NDFinfo))) {
	my $reftype = ref($NDFinfo->{$k});
	if ($reftype eq '') {
	    print D "\$NDFinfo->{$k}=$NDFinfo->{$k}\n";
	} else {
	    print D "\$NDFinfo->{$k}: ref to $reftype:\n";
	    if ($reftype eq 'ARRAY') {
		foreach my $kv (@{$NDFinfo->{$k}}) {
		    printf D ("    %s\n", $kv);
		}
	    }
	}
    }
    exit 0;
}





# Start up the moggy slave.
my $moggy = Moggy->new($esocatname, $skycatconfig, $moggylocation);
$helpers{moggy} = $moggy;
#$moggy = Moggy->new ('dummy@home',
#		     'file:///home/norman/s/src/autoastrom/w/autoastrom/moggy/t/local.config');
#$moggy->debug('asthandler cataloguehandler');


# Obtain a catalogue covering the same part of the sky as the NDF.  We
# don't have to assume here that the projection pole is in the centre
# of the image, since ASTROM isn't fazed if it it's elsewhere.
wmessage ('info', "Obtaining catalogue from $esocatname...");
my $CAT = get_catalogue ($moggy, %$NDFinfo, $maxobj, $tempDir);

# ...and write an NDF which has the columns (number, ra/rad, dec/rad, ra,
# dec).  That is, copy the $PIXcat file, duplicating columns (3,4)
# into columns (1,2) and converting them to radians (required for asttrann).
my @catdata = txt2arr ($CAT);
($#catdata >= 0)
  || wmessage ('fatal',
	       "Catalogue search: I can't find any objects corresponding to that image!");
my $r;
foreach $r (@catdata) {
    $r->[1] = $r->[3]/$d2r;
    $r->[2] = $r->[4]/$d2r;
}
my $CATNDF = twodarray2ndf (@catdata, $CAT)
  || wmessage ('fatal', "Can't create NDF $CAT");
#push (@TEMPFILES, "$CATNDF.sdf");
print STDERR "CAT=$CAT  CATNDF=$CATNDF\n" if $verbose;

wmessage ('info', sprintf ("Obtained catalogue, %d entries, from %s",
			   $#catdata+1, $esocatname));


my $CCDcathash = undef;
# Extract a catalogue of objects from the NDF (unless this was
# previously set by a command-line argument).
if (defined($CCDcat)) {
    # This is primarily a testing/debugging feature.
    wmessage ('info', "Using pre-existing CCD catalogue $CCDcat");

    print STDERR "Reusing $CCDcat...\n" if $verbose;
    # The specified file is a re-used output of this subroutine.
    # It starts with a log of the keywords which are to be
    # returned in the hash.  Extract these, fill the hash, and
    # return. 
    my $openok = open (OLDCAT, "$CCDcat");
    my $line;
    my %anonhash = ();
    if ($openok) {
	while (defined($line = <OLDCAT>)) {
	    last if ($line !~ /^\#/);
	    if ($line =~ /^\#\#\s*(\S*)\s*(\S*)/) {
		$anonhash{$1} = $2;
	    }
	}
	close (OLDCAT);
	# Override the filename, in case it's different (usually true)
	$anonhash{filename} = $CCDcat;
	$CCDcathash = \%anonhash;
    } else {
	print STDERR "Ooops, can't open $CCDcat.  Regenerating...\n";
    }
}
unless (defined($CCDcathash)) {
    $CCDcathash = extract_objects (\%helpers,
				   $NDF,
				   {maxobj => $maxobj,
				    filtersmall => 20},
				   $tempDir);
    defined ($CCDcathash)
      || wmessage ('fatal', "Failed to extract objects from NDF <$NDF>");
    if ($verbose) {
	print STDERR "EXTRACTOR returned:\n";
	foreach my $k (keys (%$CCDcathash)) {
	    print STDERR "\t$k = ", $CCDcathash->{$k}, "\n";
	}
    }
    $CCDcat = $CCDcathash->{filename};
    wmessage ('info', "Object extraction successful");
}


# We run ASTROM $iterationsleft times.  We may stop the loop from
# within by setting $iterationsleft to zero.
#
# How do we decide how many iterations is enough?  If we do the
# iteration one more time after we get a 9-parameter fit, we do get an
# improvement in both rrms and nstars, as well as a couple of arcmin
# shift in the plate centre.
my $iterationsleft = 7;

# The following hold the state between iterations.
#
# $refstarndf and $astromfits have dummy initial values, but though
# $matchinfile is obtained by converting $refstarndf, it does have a
# valid initial value, $CAT, obtained from get_catalogue() above.
my $refstarndf =      'X';	# Ref. star pixel coordinates...
my $matchinfile =   $CAT;	# ...as a text file, input to match_positions.
my $astromfits =     'X';	# WCS information obtained by ASTROM.



# We have rather heuristic decisions to make, regarding the fit we
# want ASTROM to attempt.  The ASTROM documentation recommends
# attempting the fit for tilt and distortion only when there are at
# least 10 reference stars, and we have the observation data `Obs',
# `Met' and `Col'.  If we do not have this, we should stick with a
# 6-parameter fit.  If we do have this, we should always ask for the
# full 9-parameter fit _unless_ this full fit failed last time, in
# which case we should use the 7-parameter fit, and have another try
# at the 9-parameter fit next time round.  Experience with CCDs which
# are mounted significantly eccentrically (the projection pole off the
# plate) suggests that the 8-parameter fit is less robust than the
# 7-parameter one; the 9-parameter fit might not work without a
# reasonable estimate of the distortion parameter; the 9-parameter fit
# does seem to work if we _do_ have a decent distortion.
#
# The decision about which fit to attempt is done in generate_astrom,
# controlled by its parameter maxnterms (set equal to one of the
# entries in @astromnterms here), which contains the _maximum_
# number of terms to use.  This will only ever have the values 7 or 9
# (and we switch between these at the end of the loop) -- if the
# actual number of parameters is to be lowered to 6, that'll be done
# within generate_astrom.
my @astromnterms = (9);
#my @astromnterms = (7, 9);
my $ntermidx = 0;	# Index into @astromnterms
#my $ntermidx = $#astromnterms;	# Index into @astromnterms

my %lastastrom;			# Hash holding the results of the last
                                # (successful) ASTROM run.

my $iterno = 0;
while ($iterno < $iterationsleft) {
    wmessage ('info', "Iteration $iterno...");
    print STDERR "-------------------------\nStarting iteration $iterno...\n"
      if $verbose;

    my $tfile = sprintf ("%s/%02d", $tempDir, $iterno);

    # Get matches, returning the names of the two output files.
    wmessage ('info', "Matching position lists...");
    my ($ccdlist, $catlist, $matchworked)
      = match_positions ($CCDPack,
			 $CCDcat,
			 $matchinfile,
			 { poserr => $CCDcathash->{poserr},
			   objsize => $CCDcathash->{objsize},
			   area => ($NDFinfo->{dim1} * $NDFinfo->{dim2})
			 },
			 $tfile);

     if (! $matchworked) {
 	# The match didn't work.  That's most commonly because the
 	# value of error that we estimated was too low.  Try it again,
 	# using the last value which worked, if any.
 	wmessage ('info',
 		 "That match didn't work.  Trying again, with a larger error");
 	print STDERR
	  "--- That match didn't work.  Trying again, with a larger error\n"
	    if $verbose;
 	($ccdlist, $catlist, $matchworked)
 	  = match_positions ($CCDPack,
 			     $CCDcat,
			     $matchinfile,
			     { poserr => 2.0 * $CCDcathash->{poserr},
			       objsize => $CCDcathash->{objsize},
			       area => ($NDFinfo->{dim1} * $NDFinfo->{dim2})
			     },
 			     $tfile);
     }

    if (! $matchworked) {
	# Nahhh, something more substantial is wrong.  Give up.
	wmessage ('warning', "I can't match position lists.  Giving up.");
	print STDERR "I can't match position lists.  Giving up.\n" if $verbose;
	$iterationsleft = 0;	# Redundant (given `last' below), but neat.
	last;			# JUMP OUT of the loop
    }

    print STDERR "match_positions returned...\n\t$ccdlist\n\t$catlist\n"
      if $verbose;


    # Generate the ASTROM input file.  Returns hash with keys
    # {filename}, {nmatches} and {samplesd}.
    my %astromkws = ( CCDin => $ccdlist,
		      catalogue => $catlist,
		      helpers => \%helpers,
		      NDFinfo => $NDFinfo,
		      astrom => \%lastastrom,
		      maxnterms => $astromnterms[$ntermidx],
		      tempfn => $tfile);
    my $astromparams = generate_astrom (\%astromkws);
    defined($astromparams) || wmessage ('fatal', "generate_astrom failed");

    # Display the return from generate_astrom.
    if ($verbose) {
	printf STDERR ("generate_astrom (\n");
	foreach my $k (sort keys %astromkws) {
	    printf STDERR "\t%s => %s\n", $k, $astromkws{$k};
	}
	print STDERR "    )\n    returned:\n";
	foreach my $k (sort keys %$astromparams) {
	    printf STDERR "\t%s => %s\n", $k, $astromparams->{$k};
	}
	print STDERR "run_astrom (",$astromparams->{filename},", $tfile)...\n";
    }

    wmessage ('info', "Fitting astrometry");
    my @fitdetails = run_astrom ($astromparams->{filename}, $tfile);
    @fitdetails || wmessage ('fatal', "run_astrom failed");

    # Summarise the fits we obtained.
    if ($verbose) {
	print STDERR
	  "        n nterms          centre               q FITS-WCS\n";
	foreach my $k (0..$#fitdetails) {
	    if ($fitdetails[$k]->{STATUS}) {
		printf STDERR ("%9d %3d %12.12s %13.13s %7.7s %s\n",
			       $k,
			       $fitdetails[$k]->{nterms},
			       $fitdetails[$k]->{rasex},
			       $fitdetails[$k]->{decsex},
			       (defined($fitdetails[$k]->{q})
				? $fitdetails[$k]->{q}
				: "--"),
			       (length($fitdetails[$k]->{wcs}) > 32)
			       ? "...".substr($fitdetails[$k]->{wcs},-29)
			       : $fitdetails[$k]);
	    } else {
		printf STDERR "\t%d    NO FIT\n", $k;
	    }
	}
    }

    # Now find the FITS files generated by ASTROM.  The
    # highest-numbered one is the best fit.  The WCS information in
    # FITS files represents a transformation from pixel to sky
    # coordinates or, in AST terms, the PIXEL domain is the BASE
    # domain and the SKY is the CURRENT domain, so to map sky
    # coordinates to pixel ones, the AST transformation has to be done
    # in the reverse direction.

    my $bestfitfailed = 0;	# Check whether the highest-order fit failed.
    for (my $k=$#fitdetails; $k>=0; $k--) {
	%lastastrom = %{$fitdetails[$k]}; # provisionally
	if ($lastastrom{STATUS}) {
	    # This fit was OK
	    if ($verbose) {
		printf STDERR ("ASTROM: best fit: %d of %d\n",
			       $k+1, $#fitdetails+1);
		foreach my $kw (sort keys %lastastrom) {
		    printf STDERR "\t%s => %s\n", $kw, $lastastrom{$kw};
		}
	    }
	    last;
	} else {
	    if ($verbose) {
		printf STDERR ("ASTROM: Fit %d of %d rejected",
			       $k+1, $#fitdetails+1);
		print STDERR " (",$lastastrom{nterms}, " terms)"
		  if (defined($lastastrom{nterms}));
		print STDERR "\n";
	    }
	    $bestfitfailed = 1;
	}
    }

    # At least one of the fits worked, didn't it?
    $lastastrom{STATUS} || wmessage ('fatal',
				     "ASTROM failed to make any fits at all!");

    #$astromnmatches = $astromparams->{nmatches};

    # Store the (best of the) WCS information obtained by ASTROM.
    $astromfits = $lastastrom{wcs};
    wmessage ('info', "ASTROM found a ".$lastastrom{nterms}."-parameter fit");

    # Generate the name of an NDF to receive the output from the
    # coordinate transformation.  This is to be the coordinates of the
    # catalogue objects, in the pixel domain specified by the WCS
    # information obtained by ASTROM (ie, $lastastrom{wcs}).
    $refstarndf = "$tfile-tran";

    # Produce the ASTTRANN argument list.  First, the astrometry...
    my $asttrannarg = "this=$astromfits";
    # then the input and output NDFs...
    $asttrannarg .= " in=$CATNDF out=$refstarndf";
    # reverse transformation (ie, SKY to PIXEL domain) of columns 2 and 3...
    $asttrannarg .= " forward=false incols=[2,3]";

    # Call ASTTRANN
    if ($verbose) {
	print STDERR "Calling asttrann\n";
	foreach my $e (split(' ',$asttrannarg)) {
	    print STDERR "\t$e\n";
	}
    }
    my $status = $atools->obeyw ("asttrann", $asttrannarg);
    ($status == &Starlink::ADAM::DTASK__ACTCOMPLETE)
      || wmessage ('fatal', "Error getting atools/asttrann");

    #push (@TEMPFILES, "$refstarndf.sdf");

    # Now turn $refstarndf (the best-so-far pixel coordinates
    # of the reference stars) into a text input file for match_positions.
    $matchinfile = ndf2txt ($refstarndf);

    # What sort of ASTROM fit do we want to try next time?
    if ($bestfitfailed) {
	# be less adventurous next time
	$ntermidx-- if ($ntermidx > 0);
    } else {
	# be more adventurous next time
	$ntermidx++ if ($ntermidx < $#astromnterms);
    }

} continue {
    $iterno++;
}


# We're finished!  All that remains to do is to insert the FITS
# information into the NDF (if requested to), and/or leave a copy of
# that same FITS information to hand (again, if requested).
#
# The final FITS information is in $lastastrom{wcs}, which is also in
# $astromfits.
if ($insertwcs) {
    my $astcopyarg = sprintf ('this=%s result=%s', $lastastrom{wcs}, $NDF);
    wmessaage ('info',
	       "Inserting derived WCS information into WCS component of $NDF");
    printf STDERR ("Inserting WCS information from %s into %s\n\tastcopyarg=%s\n",
		   $lastastrom{wcs}, $NDF, $astcopyarg)
      if ($verbose);
    my $status = $atools->obeyw("astcopy", $astcopyarg);
    ($status == &Starlink::ADAM::DTASK__ACTCOMPLETE)
      || wmessage ('fatal', "insertwcs: error calling ATOOLS");
} else {
    wmessage ('warning', "Not inserting WCS information into NDF <$NDF>");
}

if (defined($retainwcs)) {
    ($retainwcs ne '') || wmessage ('fatal',
				    "Assertion failed: retainwcs is blank");
    if (defined($lastastrom{wcs}) && $lastastrom{wcs} ne '') {
	copy ($lastastrom{wcs}, $retainwcs);
	wmessage ('info', "Retaining WCS information in $retainwcs");
	print STDERR "Retained WCS information in $retainwcs\n" if ($verbose);
    } else {
	wmessage ('warning',
		  "I can't find any WCS information to save in file $retainwcs");
	print STDERR "Ooo-err, I can't find any WCS information to save in $retainwcs\n";
    }
}


# Get rid of all the temporary files we've accumulated.
if ($keeptemps) {
    wmessage ('info', "Retaining temporary files in directory $tempDir");
    print STDERR "Retaining temporary files in directory $tempDir\n"
      if $verbose;
} else {
    #push (@TEMPFILES, get_temp_files());
    #print STDERR "Deleting temporary files... @TEMPFILES\n" if ($verbose);
    #unlink (@TEMPFILES);
    print STDERR "Deleting temporary directory $tempDir\n" if $verbose;
    system "rm -Rf $tempDir";
}


exit 0;


