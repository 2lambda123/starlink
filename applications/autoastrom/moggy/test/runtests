#! /bin/sh -
#
# $Id$
#
# Run a series of tests on moggy.  The directory contains a collection
# of scripts named `t<number>', and these are executed in turn and their
# output diffed against `t<number>.correct'.  Exit status is the
# number of failures.
#
# Run without an argument, this runs all the tests in the directory;
# run with an argument, it runs only the specified tests.
#
# If the option --keep is present, then it doesn't delete temporary files.

UsageString="$0 [--keep] [filename...]"
deletetemp=true
LS=/bin/ls


filelist=""

while [ $# -gt 0 ]; do
    case $1 in
    --keep) deletetemp=false ;;
    --*) echo "Usage: $UsageString"
	 exit 1
	 ;;
    *) filelist="$filelist $1"
	 ;;
    esac
    shift
done

# If filelist is null, and a file runtests.filelist exists, use that
# file's contents as the value of filelist.  This is somewhat hacky,
# but means that we can make it easy to do a subset of the tests
# repeatedly while testing.
if [ -z "$filelist" -a -f runtests.filelist ]; then
    echo "Reading filelist from runtests.filelist"
    filelist=`cat runtests.filelist`
fi

# Check filelist is non-null, and make it t* if it is.
if [ -z "$filelist" ]; then
    filelist=`$LS | grep '^t[0-9]*$'`
fi



nfailures=0

for name in $filelist
do
	echo -n "$name... "
	sh $name >$name.stdout 2>$name.stderr
	testval=$?

	if [ $testval != 0 ]; then
	    echo "failed (exited with error status $testval)"
	    nfailures=`expr $nfailures + 1`
	    $deletetemp && rm $name.stdout $name.stderr
	elif [ -r "$name.correct" ]; then
	    diff $name.correct $name.stdout >$name.diff
	    rval=$?
	    if [ $rval != 0 ]; then
		echo "failed (results in $name.diff)"
		nfailures=`expr $nfailures + 1`
	    else
		echo "ok"
		$deletetemp && rm $name.diff $name.stdout $name.stderr
	    fi
	else
		echo "apparently OK, but no correct results to compare"
		mv $name.stdout $name.correct
		echo "    (now in $name.correct)"
		$deletetemp && rm $name.stderr
	fi
done

echo "$nfailures failed tests"

exit $nfailures
