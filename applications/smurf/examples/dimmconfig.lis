# Number of iterations
#  postive number  = fixed number of iterations
#  negative number = maximum iterations if using chi^2 stopping criteria
numiter = -5

# chi^2 tolerance in negative-numiter case (requires noi model component)
chitol = 1e-3

# method of estimating variance map
#  0 = propagate from the time-domain noise (requires noi model component)
#  1 = sample variance of data that land in each pixel
varmapmethod = 1

# Perform iterations in memory?
memiter = 1

# Delete temporary .DIMM files if memiter=0?
deldimm = 1

# If performing iterations in memory, maximum length (seconds) for concatenated
# data. If 0 attempt to concatenate entire continuous chunks.
maxlen = 0

# Model components/order (comma separated list in brackets)
# Note: components specified AFTER 'ast' will not be calculated for the
# first time until the second iteration.
#  dks = fit and remove dark squid for the column
#  com = remove common-mode signal
#  gai = if com specified, fit gain/offset of common mode
#  ext = apply extinction correction
#  ast = estimate the map and astronomical signal
#  flt = apply filter to time streams
#  noi = estimate time-domain variance

modelorder = (com,gai,ext,flt,ast,noi)

# Export model files as NDF?

# Specify a value of 1 or 0 to export all or none of the components
# You can also specify an array of components to export using the same
# format as modelorder. Note that you can specify additional
# components 'res' and 'qua' to what may be provided to modelorder if
# you wish to export the residual model or quality arrays
# respectively. Exportation of 'res' is implied if 'noi' is specified
# as it becomes the variance components of the resulting NDF for
# 'res'. 'qua' will become the quality component of any full 3-dimensional
# model (e.g. 'res', 'ast', 'flt', 'ext'), but no quality will be
# written to model components with different dimensions.

exportndf = 0
#exportndf = (com,gai,ast,flt,res,noi,qua)

# Normally all data points in exported model components are set to BAD values
# wherever there is a bad bolometer established during map-making. Set
# this flag to prevent this behaviour.

#noexportsetbad = 1

# Create .MORE.SMURF.ITERMAPS extensions after each iteration?
#itermap = 1

# Create .MORE.SMURF.BOLOMAPS single-beam map extensions?
#bolomap = 1

# Create .MORE.SMURF.SHORTMAPS extensions containing maps of every "shortmap"
# time slices?
#shortmap=1000

# Apply the flatfield if loading raw data? Default is 1 (true) -- you must
# explicitly set this to 0 if you want to produce a map in raw DAC units (and
# also supply raw data).

# ensureflat=0

# The gap (in time slices) between full calculations of the output map
# bolometer positions. Setting a larger value for this will speed up
# the map maker but will introduce larger spatial errors. The default
# value of 100 seems to produce spatial errors of under 0.1 arc-sec. This
# level of errors seems to cause about 1% of bolometers samples to be
# pushed into a neighouring map pixel. For tstep=100, the calculation of
# bolometer positions speeds up by about a factor of 60. Setting tstep to
# 1 (or zero) causes all bolometer positions to be calculated in full,
# without any approximation.
#tstep = 100

# ----------------------------------------------------------------------------
# The following parameters control data-cleaning before iterations start
# ----------------------------------------------------------------------------

# --- Padding, apodization and mean subtraction are all fairly useful ---

# Number of samples of padding to add to start and end before filtering
padstart = 100
padend = 100

# Apodize signals with a sin function roll-off across apod samples
apod = 100

# subtract a baseline polynomial of this order
order = 0


# --- badfrac ensures that bad data from DA system are ignored ---

# fraction of samples to be bad to flag entire bolo as dead
badfrac = 0.05


# --- flag data when we're stationary because insensitive to sky signal ---

# Flag data taken while telescope was stationary (value is a threshold
# slew velocity (arcsec/sec) measured in tracking coordinates
flagstat = 2


# --- Many of the following may not be useful ---

# S/N threshold to detect DC steps
dcthresh = 5

# box size over which to fit data with a straight line on either side of
# a potential DC jump.
dcfitbox = 400

# The maximum number of steps that can be corrected in each minute of
# good data (i.e. per 12000 samples) from a bolometer before the entire
# bolometer is flagged as bad. A value of zero will cause a bolometer to
# be rejected if any steps are found in the bolometer data stream.
dcmaxsteps = 10

# The width of the median filter used to smooth a bolometer data stream
# prior to finding DC jumps
dcmedianwidth = 40

# S/N ratio to flag spikes with sigma-clipper
# spikethresh = 5

# Number of iterations for sigma-clipper (0=until convergence)
# spikeiter = 0

# Fill vicinity of spikes / DC steps with constrained realization of
# noise
fillgaps = 1

# The following filters are applied *before* the iterative loop. It is
# probably a better idea in general to do filtering with the 'flt'
# model component as described in the next section.

# Hard-edge high-pass frequency-domain filter
#   e.g. keep only frequencies >= 0.1 Hz
# filt_edgehigh = 0.1

# Hard-edge low-pass frequency-domain filter
#   e.g. keep only frequencies <= 90 Hz
# filt_edgelow = 90

# Hard-edge band-cut frequency-domain notch filters.
# filt_notchlow gives lower edges of frequencies to cut in Hz
# filt_notchhigh gives upper edges of frequencies to cut in Hz
#   e.g. remove 25--35 Hz  and 55--65 Hz
#filt_notchlow  = (25,55)
#filt_notchhigh = (35,65)


# ----------------------------------------------------------------------------
# These parameters control the iterative model components
# ----------------------------------------------------------------------------

# delay calculation of COM until after the first iteration? (good if
# the astronomical signal is expected to dominate the sky signal)

#com.notfirst = 1

# low-pass boxcar filter on COM (samples) to assist with convergence
# if boxfact set reduce width of boxcar by this factor each iteration
# boxmin specifies a minimum width below which it can't be reduced

com.boxcar = 10
#com.boxcar  = 400
#com.boxfact = 0.5
#com.boxmin  = 10

# the following COM parameters control the rejection of bad detectors
# based on the gain and correlation coefficients for the fit of the
# common-mode signal to each detector (good at identifying bolo signals
# with bizarre gains, or shapes if they have for example steps in them). These
# are basically sigma-clippers; outliers are removed at the given threshold
# and then new means and sample standard deviations are measured until
# convergence. The time axis is divided up into one or more equal sized boxes,
# and a separate fit is performed for each box.
#
# com.gain_box: the number of time slices in a box
# com.corr_tol: n-sigma away from mean correlation coefficient tolerance
# com.corr_abstol: the absolute lower limit of acceptable correlation
# com.gain_tol: n-sigma away from mean gain coefficient tolerance
# com.gain_abstol: absolute factor away from mean gain coefficient tolerance
# com.gain_fgood: minimum fraction of good boxes for a usable bolometer
# com.gain_rat: ratio of largest usable gain to mean gain for a bolometer

com.corr_tol = 5
com.gain_tol = 5
com.gain_abstol = 3

# Set gain box to 30 seconds. This is about the timescale for
# fridge oscillations.
com.gain_box = 6000
#com.corr_abstol = 0.2
#com.gain_fgood = 0.25
#com.gain_rat = 4.0

# low-pass filter dark squid signals using boxcar of this width (if dks
# model is specified)
dks.boxcar = 100

# additional despiking / DC step finding after each iteration within noi
# calculation. Setting noi.spikeiter to 10050 will check for excursions
# from a rolling median filter in a box length (10050-10000 = 50) samples
# long. If we instead set noi.spikeiter to something < 10000 it will
# look for excursions from the mean, where the value is the number of
# iterations to use when identifying spikes (0 means repeat until
# convergence...).
noi.spikethresh = 10
noi.spikeiter = 10050
noi.fillgaps = 1

# explicitly turn off iterative DC step finding for now
noi.dcfitbox = 0


# iterative filter.

450.flt.filt_edgehigh = 0.1
850.flt.filt_edgehigh = 0.3

#flt.filt_edgelow = 90
#flt.filt_notchlow  = (25,55)
#flt.filt_notchhigh = (35,65)

# delay calculation of FLT until after the first iteration? May help
# with negative structure around bright sources

#flt.notfirst = 1

# extinction correction (see EXTINCTION task for further information)
# Best is to use WVM, uses continuously varying measurements as a
# function of time stored with each observation. This is the default if
# nothing is specified.
#
# tausrc   : auto, wvmraw, csotau, filtertau
# taumethod: adaptive, full, quick

# filtertau "tausrc" requires a filtertau entry
# csotau is optional for "auto" and "csotau" tausrc. If not provided
# the value will be calculated from the header.

# csotau   : use value only if tausrc=csotau
# filtertau: use only if tausrc=filtertau

ext.tausrc    =auto
ext.taumethod =adaptive
#ext.csotau    = 0.2
#ext.filtertau = 0.2

# Use the GAIn/COMmon mode to re-calculate the flatfield? Probably a
# good idea in most cases, but dangerous for short scans of very bright
# sources because the astronomical signal may completely dominate
# sky signal.

#gai.flatfield = 1

# Constrain boundary regions with low hit count to 0. The threshold is where
# the hits are this fraction lower than the mean

# ast.zero_lowhits = 0.5
