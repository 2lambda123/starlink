#+
#  Name:
#     smurf_makemap.def

#  Purpose:
#     Default parameters for SMURF application MAKEMAP.

#  Description:
#     This file specifies the default parameters for the MAKEMAP
#     iterative map-maker.  The main purpose of this file is to
#     guarantee an initial state for all parameters and to define all
#     the allowed parameters so that a user will be notified in case
#     of spelling mistakes. In practice the default dimmconfig.lis (in
#     $STARLINK_DIR/share/smurf) contains the effective defaults since
#     all other config files source it and it contains the default
#     documentation.

#  Notes:
#     This file does not attempt to document what each value
#     means. See the dimmconfig.lis file for documentation.

#  Authors:
#     TIMJ: Tim Jenness (JAC, Hawaii)
#     DSB: David Berry (JAC, Hawaii)

#  History:
#     2010-05-05 (TIMJ):
#        Original version.
#     2010-05-12 (DSB):
#        Added com.gain_is_one
#     2010-06-08 (EC):
#        Added two.amap, two.bmap
#     2010-06-13 (DSB):
#        Added com.offset_is_zero
#     2010-12-13 (DSB):
#        Added dump_lonlat
#     2012-02-24 (DSB):
#        Added COM zero masking options.

#-

# These come from smf_iteratemap

numiter = -5
tstep = -0.5       # negative, so interpreted as seconds
chitol = <undef>
maptol = <undef>

bolomap = 0
itermap = 0
shortmap = 0
flagmap = <undef>
sampcube = 0

ensureflat = 1
noexportsetbad = 0
varmapmethod = 1
maxlen = 0
pad = <undef>

# these are here instead of in smurf_sc2clean.def since they are used
# during concatenation, and not during calls to the cleaning function
downsampscale = 0
downsampfreq = 0

modelorder = (com,gai,ext,flt,ast,noi)
exportndf = 0

# Load the cleaning defaults
^$SMURF_DIR/smurf_sc2clean.def

# can turn off initial cleaning by setting this to 0
doclean = 1

# export lon/lat values for every sample?
exportlonlat = 0

# export raw data immediately after cleaning?
exportclean = 0

# add fake astronomical signal to the time series?
fakemap = <undef>
fakescale = 1
fakemce = 0

#  A delay, in seconds, to apply to each time stream when cleaning the data.
delay = 0.0

#  A delay, in seconds, to apply to each fake time stream sampled from
#  the supplied fake map, prior to adding it to the real data.
fakedelay = 0.0

# Subtract supplied initial guess at sky before iterating?
importsky = 0

# smf_model_create

# TSTEP is read in two locations.
# tstep = 100

# Also read in smf_calcmodel_com
# com.gain_box = -30.0

com.zero_lowhits = 0
com.zero_notlast = 1
com.zero_circle = <undef>
com.zero_snr = <undef>
com.zero_snrlo = <undef>
com.zero_mask = <undef>
com.zero_niter = 0
com.zero_freeze = 0

flt.zero_lowhits = 0
flt.zero_notlast = 1
flt.zero_circle = <undef>
flt.zero_snr = <undef>
flt.zero_snrlo = <undef>
flt.zero_mask = <undef>
flt.zero_niter = 2
flt.zero_freeze = 0

# If non-zero, add the old FLT model back into the residuals at the start
# of the iteration (and so before COM) rather than just before estimating
# a new FLT Model. This seems to help with convergence.
flt.undofirst = 1

# Load the tau relations from a separate config file
# Also load this before any other "ext" defaults in case
# they have local overrides for things other than
# tau relations.
^$SMURF_DIR/smurf_extinction.def

# We default these to be derived from the FITS headers
ext.csotau = <undef>
ext.filtertau = <undef>

# smf_get_extpar

ext.tausrc = auto
ext.taumethod = adaptive
ext.import = 0

# smf_calcmodel_ast

ast.gaussbg = 0
ast.zero_lowhits = 0
ast.zero_notlast = 1
ast.zero_circle = <undef>
ast.zero_snr = <undef>
ast.zero_snrlo = <undef>
ast.zero_snr_fwhm = 0
ast.zero_snr_low = -1.1
ast.zero_mask = <undef>
ast.zero_niter = 0
ast.zero_freeze = 0
ast.mapspike = 0

# smf_calcmodel_com -- these are defined in smurf_sc2clean.def

# smf_calcmodel_dks

dks.boxcar = 0
dks.replacebad = 0

# smf_calcmodel_gai -- see smf_calcmodel_com parameter defaults in
# smurf_sc2clean.def

# smf_calcmodel_flt

flt.notfirst = 0

# which calls smf_filter_fromkeymap which calls smf_get_cleanpar

flt.apod = <undef>
flt.zeropad = 0
flt.filt_edgelow = 0
flt.filt_edgehigh = 0
flt.filt_edge_smallscale = 0
flt.filt_edge_largescale = 0
flt.filt_notchlow = <undef>
flt.filt_notchhigh = <undef>
flt.whiten = 0

# Specifies the minimum fraction of good values that must contribute to a
# filtered value. For instance, if wlim is 0.9 then a filtered data value
# is flagged as bad unless at least 0.9 of the input values that
# contribute to it are good (i.e. have not been flagged as unusable for
# any reason). Thus a high filt_wlim value (i.e. close to 1.0) will cause
# more data to be rejected, and a low value (i.e. close to 0.0) will cause
# less data to be rejected. A value of <undef> causes the old filtering
# algorithm to be used that is based on filling gaps with artificial data.
# If the new algorithm is used the following additional settings can be
# made: "apod=0, fillgaps=0, noi.fillgaps=0".
flt.filt_wlim = <undef>

# smf_calcmodel_noi
noi.calcfirst = 0

#  Determines the number of time slices in a box used to determine the
#  noise level in a section of a bolometer time stream. If zero, then
#  the whole bolometer time stream is used, and each bolometer has only
#  one variance value. If non-zero, the time stream is divided up into
#  boxes, and a separate variance found for each box. Each bolometer then
#  has a variance value for every time slice. Negative values are
#  interpreted as number of seconds, and positive values as a number of
#  down-sampled time slices.
noi.box_size = 0

# these are a subset of smf_get_cleanpar options

noi.dcfitbox = 0
noi.dcmaxsteps = 10
noi.dcthresh = 25.0
noi.dcsmooth = 50
noi.dclimcorr = 10
noi.fillgaps = 1
noi.zeropad = 0
noi.spikethresh = 0
noi.spikebox = 50

# Plane fitting

pln.notfirst = 0

# Time Series Smoothing

smo.notfirst = 1
450.smo.boxcar = -10
850.smo.boxcar = -3
smo.type = median

# Two component common-mode

two.amap = <undef>
two.bmap = <undef>

# External template fitting

tmp.source = <undef>
tmp.dosin = 0
tmp.docos = 0
tmp.trigoffset = 0



# DIAGNOSTICS: ------------------------------------------------------

# diag.out - The full path/name for the HDS container file in which to
# store the diagnostic info. This will contain components for each
# requested model, with names like "COM", "FLT", etc. Each of these
# components will contain multiple NDFs with names in the following
# format: "<where>_<chunk>_<what>", where <what> is "power" or "time",
# <chunk> is the integer chunk index, and <where> is one of:
#
# - "before": the NDF contains the residuals as they were before
#   the model was subtracted.
# - "model": the NDF contains the model values themselves.
# - "after": the NDF contains the residuals as they were after
#   the model was subtracted.
#
# Each NDF will be 2-dimensional, with the first pixel axis
# representing time or frequency, and the second pixel axis
# representing iteration number.
diag.out = <undef>

# diag.append - If non-zero, it indicates that diagnostic info should be
# appended to the container file specified by diag.out, which should
# already exist. The non-zero value of diag.append indicates the
# one-based index of the row within each NDF at which to store the
# first row of diagnostic info created by the current run of makemap.
diag.append = 0

# diag.models - Indicates the models that are to be written out. It
# should be a comma separated list of model names (e.g. COM, FLT,
# AST, RES, etc) contained within parentheses, or a single model
# name. A model name of RES here refers to the residuals after
# subtraction of all models in use (typically COM, FLT and AST).
# The residuals can also be written out at other times - see
# diag.res_before and diag.res_after.
diag.models = (com,flt,ast,res)

# diag.power - If non-zero, write out the power spectrum for each
# selected model.
diag.power = 0

# diag.time - If non-zero, write out the time-series for each
# selected model.
diag.time = 1

# diag.bolo - Indicates the bolometer for which diagnostic information
# is required (the sub-array is indicated by ARRAY). It can be:
#
#    - A pair of integers, separated by a comma, contained in
#    parentheses, giving the column and row of the bolometer. The
#    first integer should be in the range 0 to 31, and the second
#    should be in the range 0 to 39.
#
#    - A single integer in the range 0 to 1279.
#
#    - The string "MEAN" (case insensitive), in which case all
#    unflagged data from all good bolometers is averaged to form
#    the time-stream to dump.
#
#    - The string "WMEAN" (case insensitive), in which case all
#    unflagged data from all good bolometers is averaged using
#    weights derived from the bolometer noise estimates to form
#    the time-stream to dump.
#
#    - The string "TYPICAL" (case insensitive), in which case a
#    bolometer with typical noise charactersitics is chosen and
#    used. The index of the chosen bolometer is reported, and
#    stored in the dumped NDFs.
diag.bolo = WMEAN

# diag.array - The name of the array (S8A, S*b, etc) containing the
# data to be written out. If not supplied, the first available
# array is used.
diag.array = <undef>

# diag.res_before - If non-zero, then in addition to writing out the
# requested models, the residuals are also written out immediately
# before each requested model is subtracted.
diag.res_before = 0

# diag.res_after - If non-zero, then in addition to writing out the
# requested models, the residuals are also written out immediately
# after each requested model is subtracted.
diag.res_after = 0

# diag.mask - If non-zero, then the AST model will be masked using the
# current AST mask before being dumped. Otherwise, the AST model
# will not be masked before being dumped.
diag.mask = 0

# diag.mingood - The minimum fraction of good values in a time stream
# for which data should be dumped. An error is reported if the
# required minimum value is not met.
diag.mingood = 0.2


