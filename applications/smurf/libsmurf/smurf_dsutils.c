/*
*+
*  Name:
*     DSUTILS

*  Purpose:
*     A colection ot utilities for estimating focal plane distortion.

*  Language:
*     Starlink ANSI C

*  Type of Module:
*     ADAM A-task

*  Invocation:
*     smurf_makecube( int *status );

*  Arguments:
*     status = int* (Given and Returned)
*        Pointer to global status.

*  Description:
*     This routine provides various functions needed by the scripts that
*     determine a 2D polynomial describing the focal plane disortion
*     produced by SCUBA-2 optics.

*  ADAM Parameters:
*     BMAP = FILENAME (Read)
*          Only accessed if a time series cube is specified via parameter
*          "IN". It gives the name of a text file in which to place an 
*          AST dump of a Mapping from a modified PIXEL Frame to the SKY 
*          offset frame for a time slice close to the middle of the data set
*          The PIXEL frame is modified in the sense that its origin (i.e. 
*          pixel coords (0,0,0.0) ) is shifted so that it co-incides with 
*          the sky reference point. No file is created if a null (!)
*          value is supplied. [!]
*     BORDER = _INTEGER (Read)
*          Only accessed if a time series cube is specified via parameter
*          "IN", and a null(!) value sispecified for parameter BMAP. It 
*          gives the border width in pixels. Time slices with peak positions 
*          closer to any edge than this amount will not be included in the 
*          output catalogue. [4]
*     FEATURE = LITERAL (Read)
*          Only accessed if an input catalogue is specified via parameter
*          "INCAT". It specifies whether the output offsets should be
*          generated by comparing the telescope base positions against the 
*          peak, centroid, beamfit or base positions. It can take any of 
*          the values "PEAK", "CENTROID", "BEAMFIT" or "BC". ["BEAMFIT"]
*     FORWARD = _LOGICAL (Read)
*          Only accessed if input NDFs are specified for parameter INFITX
*          and INFITY, and if a non-null (!) value is supplied for parameter
*          OUTCODE. It indices whether the code written to the OUTCODE
*          file should describe the forward or inverse PolyMap transformation.
*     IN = NDF (Read)
*          Only accessed if null (!) values are supplied for parameter INFITX, 
*          INFITY, and INCAT. It should be a flatfielded time series
*          cube. If a non-null value is supplied, then the BMAP parameter
*          can be used to get the WCS Mapping for a typical time slice, or 
*          the OUTCAT parameter can be used to create a catalogue holding
*          details of the source position and amplitude in every time slice.
*     INFITX = NDF (Read)
*          A 2D NDF holding fitted focal plane X offsets (in mm) at every
*          bolometer, or null (!). This NDF shoudl have been created by
*          KAPPA:FITSURFACE, and should hold the coefficients of the fit
*          in the SURFACEFIT extension. If NDFs are supplied for both INFITX 
*          and INFITY, then the OUTCODE parameter can be used to create C
*          source code describing the coefficients in a form usable by
*          the AST PolyMap constructor. In addition, the OUTDX and OUTDY
*          parameters can be used to create output NDFs containing the
*          values for the inverse quantities.
*     INFITY = NDF (Read)
*          A 2D NDF holding fitted focal plane Y offsets (in mm) at every
*          bolometer, or null (!). See INFITX.
*     INCAT = FILENAME (Read)
*          Only access if a null (!) value is supplied for INFITX or INFITY.
*          It is a text file holding a catalogue of corrected and uncorrected
*          pixel positions for every bolometer in the subarray specified by 
*          SUBARRAY. These are used to create output NDFs holding the X and 
*          Y focal plane offset (in mm) at every bolometer in the subarray 
*          (see OUTDX and OUTDY). An output catalogue can also be
*          produced holding extra columns, and from which abberant rows
*          have been rejected (see parameter OUTCAT).
*     LOWFACTOR = _REAL (Read)
*          Only accessed if a value is supplied for parameter IN. It gives 
*          the lowest time slice data sum (as a fraction of the largest 
*          time slice data sum in the supplied timne series cube) for
*          usable time slices. Any time slices that have total data sums
*          less than this value are skipped.
*     MAXERR = _REAL (Read)
*          Only accessed if a value is supplied for parameter IN. It gives 
*          the largest allowed distance from the base telescope position 
*          to the measured features position (see parameter FEATURE), in
*          pixels. Time slices are ignored if the distance from base telescope 
*          position to the feature position is more than this value.
*     NITER = _INTEGER (Read)
*          Only accessed if a value is supplied for parameter INCAT. It gives 
*          the number of sigma-clipping iterations to be performed whilst
*          creating the output NDFs. [3]
*     OUTCAT = FILENAME (Write)
*          If a value was supplied for INCAT, then OUTCAT is the name of
*          an output catalogue to create, containing a copy of the input 
*          catalogue form which abberant rows have been removed, and
*          contaiing some extra informative columns (e.g. offsets in
*          focal plane and pixel coordinates). No catalogue is created if
*          a null (!) value is supplied.
*     OUTCODE = FILENAME (Write)
*          If a value was supplied for INFITX and INFITY, then OUTCODE is 
*          the name of an output text file in which to store the C code
*          describing the coefficients of the forward or inverse distortion 
*          polynomial.
*     OUTDX = NDF (Write)
*          If a value was supplied for INFITX and INFITY, then OUTDX
*          gives the name of the NDF in which to store the inverse X axis 
*          corrections at each bolometer in the subarray (in mm). If a 
*          value was supplied for INCAT, then OUTDX is the name of an NDF
*          to recieve the forward X axis correctiosn at every bolometer
*          in the subarray (in mm).
*     OUTDY = NDF (Write)
*          If a value was supplied for INFITX and INFITY, then OUTDX
*          gives the name of the NDF in which to store the inverse Y axis 
*          corrections at each bolometer in the subarray (in mm). If a 
*          value was supplied for INCAT, then OUTDX is the name of an NDF
*          to recieve the forward Y axis correctiosn at every bolometer
*          in the subarray (in mm).
*     SUBARRAY = LITERAL (Write)
*          The name of the subarray being processed: one of "s8a", "s8b", 
*          "s8b", "s8d", "s4a", "s4b", "s4b", "s4d".

*  Authors:
*     David Berry (JAC, UCLan)
*     {enter_new_authors_here}

*  History:
*     2-DEC-2009 (DSB):
*        Initial version.

*  Copyright:
*     Copyright (C) 2009 Science and Technology Facilities Council.
*     All Rights Reserved.

*  Licence:
*     This program is free software; you can redistribute it and/or
*     modify it under the terms of the GNU General Public License as
*     published by the Free Software Foundation; either version 3 of
*     the License, or (at your option) any later version.
*
*     This program is distributed in the hope that it will be
*     useful,but WITHOUT ANY WARRANTY; without even the implied
*     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
*     PURPOSE. See the GNU General Public License for more details.
*
*     You should have received a copy of the GNU General Public
*     License along with this program; if not, write to the Free
*     Software Foundation, Inc., 59 Temple Place,Suite 330, Boston,
*     MA 02111-1307, USA

*  Bugs:
*     {note_any_bugs_here}
*-
*/

#if HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <ctype.h>

/* STARLINK includes */
#include "par.h"
#include "ast.h"
#include "mers.h"
#include "ndf.h"
#include "sae_par.h"
#include "star/grp.h"
#include "star/hds.h"
#include "star/atl.h"
#include "star/kaplibs.h"
#include "prm_par.h"

/* SMURF includes */
#include "smurf_typ.h"
#include "smurflib.h"
#include "libsmf/smf.h"


/* Local constants */
#define FUNC_NAME "smurf_dsutils"
#define EXPAND 50
#define MARGIN 500
#define SEARCH 11
#define MXSHFT 6.0
#define WORK1_SIZE 51*SEARCH*SEARCH*2
#define MAXPATH 255
#define BUFSIZE 255
#define HEADER "# SCUBA-2 focal plane distortion data"
#define BC1 0
#define BC2 1
#define DBF1 2
#define DBF2 3
#define F1 4
#define F2 5
#define AMP 6
#define DAMP 7
#define RMS 8

#define PIX2MM 1.135                   /* Focal plane pixel interval in mm */
#define PIBY2 1.57079632679
#define NSIGMA 3.0
#define NITER 3

/* True if the data array is configured (COL, ROW) [the new way]
   Undefined or false if (ROW,COL) order.
   Should match the definition of ROW and COL index from sc2store.c
   Remove COLROW once we have finished testing.
 */
#define COLROW 1

/* Type definitions */
typedef struct SliceInfo {
   double sum;    /* Total data sum in time slice */
   dim_t ipx;     /* Pixel X index at peak data value */
   dim_t ipy;     /* Pixel Y index at peak data value */
   float cx;      /* Pixel X coord at centroid */
   float cy;      /* Pixel Y coord at centroid */
   double bcx;    /* Pixel X coord at telescope base position */
   double bcy;    /* Pixel Y coord at telescope base position */
} SliceInfo;

static AstFrameSet *GetFPFrameSet( const char *name, int *status );
static void PasteNDF( const char *subarray, int *lb, int *ub, int nvals, 
                      double *xvals, 
                      double *yvals, double *datvals, double *varvals, 
                      AstMapping *map, AstFrameSet *wcs, int niter, 
                      int genvar, double wlim, const char *param, int *status );
static void Filter( int n, double *flags, double *vals, double nsigma,
                    const char *title, int * status );
static int SaveBoloMapping( const char *param, smfData *data, int *status );
static AstKeyMap *GetHeader( FILE *fp, int *status );
static int GetColIndex( AstKeyMap *header, const char *colname, int *status );
static void AddColName( AstKeyMap *header, const char *colname, const char *desc, 
                        int *status );
static void PutHeader( FILE *fp, AstKeyMap *header, int *status );


#define __USE_GNU 1
#include <fenv.h>
#include <math.h>

void smurf_dsutils( int *status ) {

/* Local Variables */
   AstFrameSet *fp_fset;     /* GRID->focal plane FrameSet */
   AstFrameSet *swcsin;      /* WCS FrameSet for current time slice */
   AstMapping *fp_map;       /* GRID->focal plane (in millimetres - no PolyMap) */
   AstMapping *map = NULL;   /* Mapping that moves the centroid to the origin */
   AstMapping *map2 = NULL;  /* Mapping that moves the centroid to the origin */
   AstPolyMap *polymap;      /* Polynomial distortion correction mapping */
   AstWinMap *winmap;        /* Expanded GRID to full size GRID mapping */
   FILE *fp1 = NULL;         /* File pointer for input catalogue */
   FILE *fp2 = NULL;         /* File pointer for output catalogue */
   Grp *igrp = NULL;         /* Group of input files */
   SliceInfo *slice = NULL;  /* Point to structure describing current time slice */
   SliceInfo *slices = NULL; /* Array of structures describing each time slice */
   char **words;             /* Pointer to array of word pointers */
   char buf[ BUFSIZE ];      /* Line read from input catalogue */
   char feature[11];         /* Feature to use for distortion calculations */
   char incat[ MAXPATH ];    /* Name of input catalogue */
   char outcat[ MAXPATH ];   /* Name of output catalogue */
   char outcode[ MAXPATH ];  /* Name of output file to hold C source code */
   char subarray[ 9 ];       /* Name of subarray */
   const char *skyrefis;     /* Original value of SkyRefIs in sky frame */
   const char *start;        /* Pointer to next character to read */
   dim_t border;             /* Width of excluded border, in pixels */
   dim_t itime;              /* Grid index on the third pixel axis */
   dim_t ntime;              /* Length of the third pixel axis */
   dim_t nx;                 /* Length of the first pixel axis */
   dim_t ny;                 /* Length of the second pixel axis */
   dim_t peakx;              /* Index on the first pixel axis at peak */
   dim_t peaky;              /* Index on the second pixel axis at peak */
   double *amp_vals = NULL;  
   double *damp_vals = NULL; 
   double *rms_vals = NULL;  
   double *bc1_vals = NULL;  /* Pointer to BC1 column values */
   double *bc2_vals = NULL;  /* Pointer to BC2 column values */
   double *dbf1_vals = NULL; /* Pointer to DBF1 column values */
   double *dbf2_vals = NULL; /* Pointer to DBF2 column values */
   double *dfx_vals = NULL;  /* Pointer to focal plane X offset values */
   double *dfy_vals = NULL;  /* Pointer to focal plane Y offset values */
   double *dpx_vals = NULL;  /* Pointer to pixel X offset values */
   double *dpy_vals = NULL;  /* Pointer to pixel Y offset values */
   double *f1_vals = NULL;   /* Pointer to F1 column values */
   double *f2_vals = NULL;   /* Pointer to F2 column values */
   double *p;                /* Pointer to array in which to put column value */
   double *pd0;              /* Ptr to 1st data value in current i/p time slice */
   double *pd;               /* Ptr to data array */
   double *pv0;              /* Ptr to 1st var value in current i/p time slice */
   double *work = NULL;      /* Pointer to astRebinSeq work array */
   double bcx;               /* Pixel X coord at base position */
   double bcy;               /* Pixel Y coord at base position */
   double f1_hi;             /* High bound on feature pixel X coord */
   double f1_lo;             /* Low bound on feature pixel X coord */
   double f2_hi;             /* High bound on feature pixel Y coord */
   double f2_lo;             /* Low bound on feature pixel Y coord */
   double gx;                /* Value for 1st axis in GRID frame */
   double gy;                /* Value for 2ns axis in GRID frame */
   double lowsum;            /* Lwest data sum in any usable time slice */
   double maxerr;            /* Max allowed base->cent distance */
   double maxsum;            /* Largest data sum in any time slice */
   double ox;                /* Value for 1st axis in offset sky frame */
   double oy;                /* Value for 2nd axis in offset sky frame */
   double peakv;             /* Largest pixel value found so far */
   double shift[ 2 ];        /* Axis shifts */
   double sum;               /* Sum of all good data values in time slice */
   double wlim;              /* Min weight for a valid output pixel */
   double *worka;            /* Work array */
   double *workb;            /* Work array */
   double xin[ 2 ];          /* Pixel coord X positions */
   double xout[ 2 ];         /* Focal plane X positions (mm) */
   double yin[ 2 ];          /* Pixel coord Y positions */
   double yout[ 2 ];         /* Focal plane Y positions (mm) */
   float cent[ 2 ];          /* Accurate centroid in pixel cords */
   float init[ 2 ];          /* Initial guess at centroid in pixel cords */
   float lowfactor;          /* Factor giving lowest usable total data sum */
   AstKeyMap *header;        /* Holds header info from input catalogue */
   float mxshft[ 2 ];        /* Max shift from initial guess to final centroid */
   float val;                /* Column value */
   float work1[ WORK1_SIZE ];/* Work array for kpg1Loctd */
   int col[ 20 ];            /* Indices of required input catalogue columns */
   int forward;
   int genvar;
   int i;                    /* Loop count */
   int indf1;                /* Identifier for NDF */
   int indf2;                /* Identifier for NDF */
   int irow;                 /* Row index */
   int ival;                 /* Temporary integer value storage */
   int ix;                   /* Grid index on the first pixel axis */
   int iy;                   /* Grid index on the second pixel axis */
   int l;                    /* Input line number */
   int lbnd[ 2 ];            /* Pixel index lower bounds in input array */
   int lbnd_out[ 2 ];        /* Pixel index lower bounds in output NDF */
   int ngood;                /* Number of usable time slices */
   int niter;                /* Number of sigma-clips to perform */
   int nrow;                 /* Number of usable rows */
   int nword;                /* Number of words in line of text */
   int nxy;                  /* Number of elements in a time slice */
   int nxyz;                 /* Number of elements in whole cube */
   int ok;                   /* Was the row good */
   int search[ 2 ];          /* Size of centroiding search box in pixels */
   int ubnd[ 2 ];            /* Pixel index upper bounds in input NDF */
   int ubnd_out[ 2 ];        /* Pixel index upper bounds in output NDF */
   int used;                 /* Was the time slice usable? */
   size_t size;              /* Number of files in input group */
   smfData *data = NULL;     /* Pointer to data struct for input file */
   smfFile *file = NULL;     /* Pointer to file struct for input file */
   smfHead *hdr = NULL;      /* Pointer to data header for time slice */
   double ina[ 2 ];
   double inb[ 2 ];
   double outa[ 2 ];
   double outb[ 2 ];
   HDSLoc *xloc1 = NULL;
   HDSLoc *xloc2 = NULL;
   HDSLoc *floc[ 2 ] = { NULL, NULL };
   int ncoeff_f, nin;
   double *cofs;


/* Uncomment to stop the program on any of the following exceptions. */
/*   feenableexcept(FE_DIVBYZERO | FE_INVALID | FE_OVERFLOW ); */

/* Check inherited status */
   if (*status != SAI__OK) return;

/* Start AST and NDF contexts. */
   astBegin;
   ndfBegin();








/* If input NDFs are supplied for parameter INFITX and INFITY, we can do
   one of two things: 1) create C source code defining the coefficients 
   needed for a single transformation (forward or inverse) of a 2D PolyMap 
   corresponding to the Starlink POLYNOMIAL structure in the SURFACEFIT 
   extension in both NDFs, or 2) actually create the PolyMap and then use
   it to create two output NDFs holding the sampled PolyMap outputs.
   ---------------------------------------------------------------- */
   ndfAssoc( "INFITX", "Read", &indf1, status );
   ndfAssoc( "INFITY", "Read", &indf2, status );

   if( *status == PAR__NULL ) {
      errAnnul( status );

/* If both NDFs were obtained, get locators to the NDF extensions
   holding the chebyshev polynomial coefficients. */
   } else {
      ndfXloc( indf1, "SURFACEFIT", "Read", &xloc1, status ); 
      datFind( xloc1, "FIT", floc, status );

      ndfXloc( indf2, "SURFACEFIT", "Read", &xloc2, status ); 
      datFind( xloc2, "FIT", floc + 1, status );

/* Convert them to coefficients of a standard polynomial. */
      cofs = kpg1Chcof( 2, floc, &ncoeff_f, &nin, status );

/* Get the name of the output file to hold the generated C code and attempt to open it. */
      if( *status == SAI__OK ) {
         parGet0c( "OUTCODE", outcode, MAXPATH, status );
   
/* If a name was supplied, attempt to open the file for writing. */
         if( *status == SAI__OK ) {
            fp2 = fopen( outcode, "w" );
            if( !fp2 && *status == SAI__OK ) {
               *status = SAI__ERROR;
               msgSetc ( "C", outcode );
               errRep( FUNC_NAME, "Output code file '^C' could not be opened "
                       "for writing.", status );

/* If an output file was specified, see if it is to receive the coefficients 
   of the forward or inverse transformation. */
            } else {
               parGet0l( "FORWARD", &forward, status );
            }
         }
      }

/* Write out the code if required. */
      if( fp2 ) {
         fprintf( fp2, "\n" );
         if( forward ) {
            fprintf( fp2, "/* SCUBA-2 PolyMap cooefficients. Forward coefficients are from \n");
            fprintf( fp2, "   FRAME850 to Nasmyth */ \n\n");
            fprintf( fp2, "/* Forward transformation coefficients... */\n");
            fprintf( fp2, "   int ncoeff_f = %d;\n", ncoeff_f );
            fprintf( fp2, "   const double coeff_f[] = {\n\n");
         } else {
            fprintf( fp2, "/* Inverse transformation coefficients... */\n");
            fprintf( fp2, "   int ncoeff_i = %d;\n", ncoeff_f );
            fprintf( fp2, "   const double coeff_i[] = {\n\n");
         }

/* The supplied polynomial gives a correction to add on to (x,y), as a function
   of (x,y). We want a PolyMap that converts (x,y) into corrected (x,y)
   in one step. Therefore add 1.0 to the linear X and Y terms. */
         fprintf( fp2, "/* X-coordinate */ \n");
         p = cofs;
         for( i = 0; i < ncoeff_f; i++ ) {
            if( p[ 1 ] == 1.0 ) {
               if( p[ 2 ] == 1 && p[ 3 ] == 0  ) *p += 1.0; 
               fprintf( fp2, "               %-12.5g,     %3.1f, %3.1f, %3.1f,\n", 
                       p[ 0 ], p[ 1 ], p[ 2 ], p[ 3 ] );
            }
            p += 4;
         }
   
         fprintf( fp2, "\n/* Y-coordinate */ \n");
         p = cofs;
         for( i = 0; i < ncoeff_f; i++ ) {
            if( p[ 1 ] == 2.0 ) {
               if( p[ 2 ] == 0.0 && p[ 3 ] == 1.0  ) *p += 1.0; 
               fprintf( fp2, "               %-12.5g,     %3.1f, %3.1f, %3.1f,\n", 
                       p[ 0 ], p[ 1 ], p[ 2 ], p[ 3 ] );
            }
            p += 4;
         }
         fprintf( fp2, "            };\n" );
         fprintf( fp2, "\n\n\n" );

         fclose( fp2 );
      }

/* If we are producing the forward transformation, create the PolyMap. It maps 
   real (Fx,Fy) in mm, to corrected (Fx,Fy). */
      if( forward ) {
         polymap = astPolyMap( 2, 2, ncoeff_f, cofs, 0, NULL, " " );

/* Create a WinMap that transforms a sub-dividied GRID coordinate system
   (in which each bolometer is dividied into 10 along each axis) into the
   full-sized bolometer GRID coordinate system. */
         if( EXPAND > 1 ) {
            ina[ 0 ] = 0.5;
            ina[ 1 ] = 0.5;
            outa[ 0 ] = 0.5;
            outa[ 1 ] = 0.5;
            inb[ 0 ] = 0.5 + EXPAND/2;
            inb[ 1 ] = 0.5 + EXPAND/2;
            outb[ 0 ] = 1.0;
            outb[ 1 ] = 1.0;
            winmap = astWinMap( 2, ina, inb, outa, outb, " " );
         } else {
            winmap = (AstWinMap *) astUnitMap( 2, " " );
         }
   
/* Get the (full-sized) GRID->real (Fx,Fy) Mapping. */
         parGet0c( "SUBARRAY", subarray, 8, status );
         fp_fset = GetFPFrameSet( subarray, status );
         fp_map = astGetMapping( fp_fset, AST__BASE, AST__CURRENT );
   
/* Combine them to get the (expanded) GRID->real (Fx,Fy) Mapping. */
         map2 = (AstMapping *) astCmpMap( winmap, fp_map, 1, " " );
   
/* Remap the base (GRID) Frame in the FrameSet to represent expanded
   grid coords. */
         astInvert( winmap );
         astRemapFrame( fp_fset, AST__BASE, winmap );
         astInvert( winmap );
   
/* Create arrays holding the real focal plane coords for every tenth of a
   bolometer. */
         lbnd_out[ 0 ] = 1 - MARGIN;
         lbnd_out[ 1 ] = 1 - MARGIN;
         ubnd_out[ 0 ] = 32*EXPAND + MARGIN;
         ubnd_out[ 1 ] = 40*EXPAND + MARGIN;
         nxy = ( ubnd_out[ 0 ] - lbnd_out[ 0 ] + 1 );
         nxy *= ( ubnd_out[ 1 ] - lbnd_out[ 1 ] + 1 );
         worka = astMalloc( 2*nxy*sizeof( double ) ) ;
         astTranGrid( map2, 2, lbnd_out, ubnd_out, 0.0, 0, 1, 2, nxy, worka );  
   
/* Combine the two Mappings to get the expanded GRID->corrected (Fx,Fy) Mapping. */
         map = (AstMapping *) astCmpMap( map2, polymap, 1, " " );
   
/* Create arrays holding the corrected focal plane coords for every tenth
   of a bolometer. */
         workb = astMalloc( 2*nxy*sizeof( double ) ) ;
         astTranGrid( map, 2, lbnd_out, ubnd_out, 0.0, 0, 1, 2, nxy, workb );  
   
/* Subtract the corrected focal plane X coords from the real focal plane
   X coords. Correct the Y coords in the same way. This gives us the
   deltas needed to to convert corrected focal plane coords to real focal
   plane coords. */
         for( i = 0; i < nxy; i++ ) {
            worka[ i ] -= workb[ i ];
            worka[ i + nxy ] -= workb[ i + nxy ];
         }
   
/* Create an NDF by pasting the X deltas into an image with axes which are 
   a linear function of corrected focal plane axes. To get a linear axis 
   mapping, we use "fp_map" rather than "map". */
         lbnd_out[ 0 ] = -EXPAND + 1;
         ubnd_out[ 0 ] = lbnd_out[ 0 ] + 32*EXPAND - 1;
         lbnd_out[ 1 ] = -EXPAND + 1;
         ubnd_out[ 1 ] = lbnd_out[ 1 ] + 40*EXPAND - 1;
         astInvert( map2 );
         PasteNDF( subarray, lbnd_out, ubnd_out, nxy, workb, workb + nxy, worka, NULL, 
                   map2, fp_fset, 0, 0, 0.0, "OUTDX", status );
   
/* Create another NDF by pasting the Y deltas into an image with axes which 
   are a linear function of corrected focal plane axes. */
         PasteNDF( subarray, lbnd_out, ubnd_out, nxy, workb, workb + nxy, worka + nxy, 
                   NULL, map2, fp_fset, 0, 0, 0.0, "OUTDY", status );
         astInvert( map2 );

/* Free resources. */
         worka = astFree( worka );
         workb = astFree( workb );
      }

      cofs = astFree( cofs );
      datAnnul( floc, status );
      datAnnul( floc + 1, status );
      datAnnul( &xloc1, status );
      datAnnul( &xloc2, status );

/* Nothing else to do, so jump to the end. */
      goto L999;
   }











/* If an input catalogue is supplied, we create output NDFs holding the
   binned focal plane X and Y corrections for each bolometer. We can also
   produce an output catalogue holding a copy of the input catalogue, but
   with aberant rows removed, and extra columns added.
   -------------------------------------------------------------------- */
   if( *status == SAI__OK ) {
      parGet0c( "INCAT", incat, MAXPATH, status );

/* If no name was supplied, annul the error and store a null file pointer. */
      if( *status == PAR__NULL ) {
         errAnnul( status );
         fp1 = NULL;

/* If a name was supplied, attempt to open the file for reading. */
      } else if( *status == SAI__OK ) {
         fp1 = fopen( incat, "r" );
         if( !fp1 && *status == SAI__OK ) {
            *status = SAI__ERROR;
            msgSetc ( "CAT", incat );
            errRep( FUNC_NAME, "Input catalogue '^CAT' could not be opened "
                    "for reading.", status );
         } 
      }
   }

/* If we got an input catalogue... */
   if( fp1 ) {

/* Get the name of any output catalogue and attempt to open it. */
      if( *status == SAI__OK ) {
         parGet0c( "OUTCAT", outcat, MAXPATH, status );
   
/* If no name was supplied, annul the error and store a null file pointer. */
         if( *status == PAR__NULL ) {
            errAnnul( status );
            fp2 = NULL;
   
/* If a name was supplied, attempt to open the file for writing. */
         } else if( *status == SAI__OK ) {
            fp2 = fopen( outcat, "w" );
            if( !fp2 && *status == SAI__OK ) {
               *status = SAI__ERROR;
               msgSetc ( "CAT", outcat );
               errRep( FUNC_NAME, "Output catalogue '^CAT' could not be opened "
                       "for writing.", status );
            } 
         }
      }

/* The lower pixel index bounds on the spatial axes of a raw time series 
   cube is always (0,0). */
      lbnd[ 0 ] = 0;
      lbnd[ 1 ] = 0;

/* Get the name of the scuba-2 subarray, and get the GRID - > focal 
   plane (in millimeters) Mapping. This does not include any polynomial
   corrections, but assumes the original focal plane reference point for
   each subarray. . */
      parGet0c( "SUBARRAY", subarray, 8, status );
      fp_fset = GetFPFrameSet( subarray, status );
      fp_map = astGetMapping( fp_fset, AST__BASE, AST__CURRENT );

/* Decide whether to compare telescope base positions against peak,
   centroid, beamfit or base positions. */ 
      parChoic( "FEATURE", "CENTROID", "PEAK,CENTROID,BEAMFIT,BC",
                1, feature, 10, status );

/* Get a KeyMap in which each entry has a key equal to a column name, and
   a value equal to the corresponding zero-based column index. */
      header = GetHeader( fp1, status );

/* Store the zero-based column indices of the required columns. */
      col[ BC1 ] = GetColIndex( header, "BC1", status );
      col[ BC2 ] = GetColIndex( header, "BC2", status );
      col[ DBF1 ] = GetColIndex( header, "DBF1", status );
      col[ DBF2 ] = GetColIndex( header, "DBF2", status );
      col[ AMP ] = GetColIndex( header, "AMP", status );
      col[ DAMP ] = GetColIndex( header, "DAMP", status );
      col[ RMS ] = GetColIndex( header, "RMS", status );

      if( !strcmp( feature, "PEAK" ) ) {
         col[ F1 ] = GetColIndex( header, "PEAK1", status );
         col[ F2 ] = GetColIndex( header, "PEAK2", status );

      } else if( !strcmp( feature, "CENTROID" ) ) {
         col[ F1 ] = GetColIndex( header, "CENT1", status );
         col[ F2 ] = GetColIndex( header, "CENT2", status );

      } else if( !strcmp( feature, "BEAMFIT" ) ) {
         col[ F1 ] = GetColIndex( header, "BF1", status );
         col[ F2 ] = GetColIndex( header, "BF2", status );

      } else {
         col[ F1 ] = GetColIndex( header, "BC1", status );
         col[ F2 ] = GetColIndex( header, "BC2", status );
      }

/* Initialiuse the number of rows read so far, and the upper and lower
   bounds on each axis of the selected feature position. */
      nrow = 0;
      f1_lo = VAL__MAXD;
      f2_lo = VAL__MAXD;
      f1_hi = VAL__MIND;
      f2_hi = VAL__MIND;

/* Read over all comment lines at the start of the file. */
      l = 0;
      while( fgets( buf, BUFSIZE, fp1 ) && buf[ 0 ] == '#' ) l++;

/* Initialise the number of rows read so far, and loop round all
   remaining lines in the input file. */
      genvar = 0;
      do {
         ok = 1;

/* Split the line into space separated words. */
         words = astChrSplit( buf, &nword );

/* Loop round all the words (i.e. columns) in this line. */
         start = buf;
         for( i = 0; i < nword; i++ ) {
            p = NULL;

/* Attempt to read a float from the column. If the conversion fails report an error. */
            if( sscanf( words[ i ], "%g", &val ) == 0 ) {
               *status = SAI__ERROR;
               msgSetc( "B", buf );
               msgSeti( "I", i + 1 );
               msgSeti( "L", l );
               errRep( " ", "Failed to read column ^I of line ^L:", status );
               errRep( " ", buf, status );
               break; 

/* If we read a floating point value succesfully, select the array in
   which to store it and expand the array to make room for the new value. */
            } else if( i == col[ BC1 ] ) {
               p = bc1_vals = astGrow( bc1_vals, nrow + 1, sizeof( *bc1_vals ) );

            } else if( i == col[ BC2 ] ) {
               p = bc2_vals = astGrow( bc2_vals, nrow + 1, sizeof( *bc2_vals ) );

            } else if( i == col[ DBF1 ] ) {
               p = dbf1_vals = astGrow( dbf1_vals, nrow + 1, sizeof( *dbf1_vals ) );

            } else if( i == col[ DBF2 ] ) {
               p = dbf2_vals = astGrow( dbf2_vals, nrow + 1, sizeof( *dbf2_vals ) );

            } else if( i == col[ AMP ] ) {
               p = amp_vals = astGrow( amp_vals, nrow + 1, sizeof( *amp_vals ) );

            } else if( i == col[ DAMP ] ) {
               p = damp_vals = astGrow( damp_vals, nrow + 1, sizeof( *damp_vals ) );

            } else if( i == col[ RMS ] ) {
               p = rms_vals = astGrow( rms_vals, nrow + 1, sizeof( *rms_vals ) );

            }

/* If the word has a silly value, indicate the line cannot be used. */
            if( !isfinite( val ) || fabs( val ) > 1.0E10 ) {
               ok = 0;
               val = 0.0;
            }

/* Ensure the error on the source position is no less than 0.001 pixels.
   Also, indicate the row is unusable if the error on the source position is
   more than 0.1 pixels. */
            if( i == col[ DBF1 ] || i == col[ DBF2 ] ) {
               if( val != VAL__BADD && val < 0.001 ) {
                  val = 0.001;
               } else if( val != VAL__BADD && val > 0.1 ) {
                  val = 0;
                  ok = 0;
               }
            }

/* If we read a required value, store it in the expanded array. */
            if( p ) p[ nrow ] = val;
            p = NULL;

/* Now look for feature positions... */
            if( i == col[ F1 ] ) {
               p = f1_vals = astGrow( f1_vals, nrow + 1, sizeof( *f1_vals ) );

/* If the data was created from bolomaps (as shown by all true positions
   being a multiple of half a pixel), we cannot use AST__GENVAR flag with
   astRebinSeq. */
               if( val != VAL__BADD && !genvar && ( fabs( fmod( val, 0.5 ) ) > 0.001 ) ) genvar = 1;

            } else if( i == col[ F2 ] ) {
               p = f2_vals = astGrow( f2_vals, nrow + 1, sizeof( *f2_vals ) );
            }

/* If we read a feature position, store it in the expanded array. */
            if( p ) p[ nrow ] = val;
         }            

/* Free resources. */
         for( i = 0; i < nword; i++ ) words[ i ] = astFree( words[ i ] );
         words = astFree( words );

/* Convert the base telescope position and feature position from PIXEL to 
   GRID, and then use astTran2 to convert GRID to focal plane (in mm). */
         if( *status == SAI__OK && ok ) {
            ok = 0;

            xin[ 0 ] = bc1_vals[ nrow ] - lbnd[ 0 ] + 1.5;
            yin[ 0 ] = bc2_vals[ nrow ] - lbnd[ 1 ] + 1.5;
            xin[ 1 ] = f1_vals[ nrow ] - lbnd[ 0 ] + 1.5;
            yin[ 1 ] = f2_vals[ nrow ] - lbnd[ 1 ] + 1.5;
            astTran2( fp_map, 2, xin, yin, 1, xout, yout ) ;

/* Store the offsets in focal plane coords at the current focal plane
   feature position. */
            bc1_vals[ nrow ] = xout[ 0 ] - xout[ 1 ];
            bc2_vals[ nrow ] = yout[ 0 ] - yout[ 1 ];

/* Expand memory to hold new columns in output catalogue. */
            dpx_vals = astGrow( dpx_vals, nrow + 1, sizeof( *dpx_vals ) );
            dpy_vals = astGrow( dpy_vals, nrow + 1, sizeof( *dpy_vals ) );
            dfx_vals = astGrow( dfx_vals, nrow + 1, sizeof( *dfx_vals ) );
            dfy_vals = astGrow( dfy_vals, nrow + 1, sizeof( *dfy_vals ) );
            if( *status == SAI__OK ) {

/* Store pixel offsets */
               dpx_vals[ nrow ] = xin[ 0 ] - xin[ 1 ];
               dpy_vals[ nrow ] = yin[ 0 ] - yin[ 1 ];

/* Store focal plane offsets */
               dfx_vals[ nrow ] = xout[ 0 ] - xout[ 1 ];
               dfy_vals[ nrow ] = yout[ 0 ] - yout[ 1 ];

            }

/* Skip lines for which the offset on either axis is more than 6 mm, or for 
   which the error on the beamfit position is more than 0.1 pixel */
            if( fabs( bc1_vals[ nrow ] ) < 6.0 && 
                fabs( bc2_vals[ nrow ] ) < 6.0 ) {

               if( col[F1] == 2 || ( dbf1_vals[ nrow ] < 0.1 && 
                                     dbf2_vals[ nrow ] < 0.1 ) ) {

/* Calculate the mean error on the feature position, in pixel coords, and 
   convert to mm. This is used as a weight for the focal plane offsets
   calculated above. */
                  dbf1_vals[ nrow ] += dbf2_vals[ nrow ];
                  dbf1_vals[ nrow ] *= 0.5*PIX2MM;

/* Convert the beamfit errors into variances. */
                  dbf1_vals[ nrow ] *= dbf1_vals[ nrow ];
                  dbf2_vals[ nrow ] = dbf1_vals[ nrow ];

/* Update the bounds of the usable feature positions (in pixel coords). */
                  if( f1_vals[ nrow ] < f1_lo ) f1_lo = f1_vals[ nrow ];
                  if( f1_vals[ nrow ] > f1_hi ) f1_hi = f1_vals[ nrow ];
                  if( f2_vals[ nrow ] < f2_lo ) f2_lo = f2_vals[ nrow ];
                  if( f2_vals[ nrow ] > f2_hi ) f2_hi = f2_vals[ nrow ];

                  ok = 1;
               } 
            }
         }

/* Flag bad rows by storing a bad bc1 value if the row was not usable. */
         if( !ok ) bc1_vals[ nrow ] = VAL__BADD;

/* Increment the number of usable rows. */
         nrow++;

/* Read the next line from the input catalogue. Leave the loop if we have
   reached the end. */
         l++;
      } while( *status == SAI__OK && fgets( buf, BUFSIZE, fp1 ) );

      if( *status != SAI__OK ) goto L999;

      printf( "%d bad rows\n", l - nrow );

/* Flag unusual rows by storing a bad value for each in "bc1_vals". */
      Filter( nrow, bc1_vals, amp_vals, 3.0, "AMP", status );
      Filter( nrow, bc1_vals, damp_vals, 3.0, "DAMP", status );
      Filter( nrow, bc1_vals, rms_vals, 3.0, "RMS", status );

/* Transfer flags into bc2_vals */
      for( irow = 0; irow < nrow; irow++ ) {
         if( bc1_vals[ irow ] == VAL__BADD ) bc2_vals[ irow ] = VAL__BADD;
      }

/* Create any required output catalogue */
      if( fp2 ) {

/* Add the new column nmaes to the header. */
         AddColName( header, "DPX", "Focal plane X offsets in pixels", status );
         AddColName( header, "DPY", "Focal plane Y offsets in pixels", status );
         AddColName( header, "DFX", "Focal plane X offsets in mm", status );
         AddColName( header, "DFY", "Focal plane Y offsets in mm", status );

/* Write out the catalogue header */
         PutHeader( fp2, header, status );

/* Re-read the input catalogue, skipping over comment lines. */
         rewind( fp1 );
         while( fgets( buf, BUFSIZE, fp1 ) && buf[ 0 ] == '#' );

/* Write each line out to the output catalogue, appending values for the new columns. */
         irow = 0;
         do {
            if( buf[ strlen( buf ) - 1 ] == '\n' ) buf[ strlen( buf ) - 1 ] = 0;
            if( bc1_vals[ irow ] != VAL__BADD ) fprintf( fp2, "%s %g %g %g %g\n", buf, 
                                                         dpx_vals[irow], dpy_vals[irow], 
                                                         dfx_vals[irow], dfy_vals[irow] );
            irow++;

/* Read the next line from the input catalogue. Leave the loop if we have
   reached the end. */
         } while( *status == SAI__OK && fgets( buf, BUFSIZE, fp1 ) );
         fclose( fp2 );
      }

/* Close the input catalogue. */
      fclose( fp1 );

/* See how many sigma-clipping iterations should be performed whilst
   creating the output NDFs. */
      parGet0i( "NITER", &niter, status );

/* Create a Mapping from pixel coords in a bolometer slice (i.e. pixel
   origin (0,0) ) to GRID coords. */
      shift[ 0 ] = 1.5;
      shift[ 1 ] = 1.5;
      map = (AstMapping *) astShiftMap( 2, shift, " " );

/* Paste the X offset values into an output NDF. */
      PasteNDF( subarray, NULL, NULL, nrow, f1_vals, f2_vals, bc1_vals, dbf1_vals, map,
                fp_fset, niter, genvar, 2.0, "OUTDX", status );

/* Create the Y offset NDF in the same way. */
      PasteNDF( subarray, NULL, NULL, nrow, f1_vals, f2_vals, bc2_vals, dbf2_vals, map,
                fp_fset, niter, genvar, 2.0, "OUTDY", status );

/* Free resources. */
      bc1_vals = astFree( bc1_vals );
      bc2_vals = astFree( bc2_vals );
      dbf1_vals = astFree( dbf1_vals );
      dbf2_vals = astFree( dbf2_vals );
      f1_vals = astFree( f1_vals );
      f2_vals = astFree( f2_vals );
      amp_vals = astFree( amp_vals );
      damp_vals = astFree( damp_vals );
      rms_vals = astFree( rms_vals );
      dpx_vals = astFree( dpx_vals );
      dpy_vals = astFree( dpy_vals );
      dfx_vals = astFree( dfx_vals );
      dfy_vals = astFree( dfy_vals );

/* Nothing else to do, so jump to the end. */
      goto L999;
   }












/* If a input time series NDF is supplied, we can either create a Mapping
   describing a typical time slice in it, or create an output catalogue
   holding the telescope base positions, peak positions, centroid
   positions and data sums at each time slice. 
   -------------------------------------------------------------------- */

/* Attempt to get the name of the input NDF. */
   igrp = NULL;
   if( *status == SAI__OK ) {
      kpg1Rgndf( "IN", 1, 1, "", &igrp, &size, status );
      if( *status == PAR__NULL ) errAnnul( status );
   }

/* If an input NDF name was obtained... */
   if( igrp && * status == SAI__OK ) {

/* Obtain information about the input NDF. */
      smf_open_file( igrp, 1, "READ", 0, &data, status );
 
/* Write the Mapping from a modified PIXEL Frame to the SKY offset frame.
   The PIXEL frame is modified in the sense that its origin (i.e. pixel
   coords (0,0,0.0) ) is shifted so that it co-incides with the sky
   reference point ). If succesful, do nothing more. */
      if( SaveBoloMapping( "BMAP", data, status ) ) goto L998;

/* Convenience pointers */
      file = data->file;
      hdr = data->hdr;

/* Check the data type is _DOUBLE. */
      if( data->dtype != SMF__DOUBLE && *status == SAI__OK ){
         msgSetc( "FILE", file->name );
         *status = SAI__ERROR;
         errRep( FUNC_NAME, "^FILE has an unspected data type, should be _DOUBLE.", status );
      } 

/* Check that there are 3 pixel axes. */
      if( data->ndims != 3 ) {
         msgSetc( "FILE", file->name );
         msgSeti( "NDIMS", data->ndims );
         *status = SAI__ERROR;
         errRep( FUNC_NAME, "^FILE has ^NDIMS pixel axes, should be 3.", status );
      }

/* Check it holds SCUBA-2 data. */
      if( data->ndims != 3 && *status == SAI__OK ) {
         msgSetc( "FILE", file->name );
         msgSeti( "NDIMS", data->ndims );
         *status = SAI__ERROR;
         errRep( FUNC_NAME, "^FILE has ^NDIMS pixel axes, should be 3.", status );
      }

/* Note the array dimensions, and the number of elements in a single slice. */
      nx = data->dims[ 0 ];
      ny = data->dims[ 1 ];
      ntime = data->dims[ 2 ];
      nxy = nx*ny;
      nxyz = nxy*ntime;
   
/* Store the upper pixel index bounds of each time slice. */
      ubnd[ 0 ] = data->lbnd[ 0 ] + nx - 1;
      ubnd[ 1 ] = data->lbnd[ 1 ] + ny - 1;
   
/* Get the border width in pixels. Time slices with peak positions closer
   to any edge than this amount will not be included in the output catalogue. */
      parGet0i( "BORDER", &ival, status );
      border = ival;
   
/* Get the maximum allowed distance from the base position to the
   centroid position. Slices with distances greater than this value will
   not be included in the output catalogue. */
      parGet0d( "MAXERR", &maxerr, status );
   
/* Get the name of the output catalogue and attempt to open it. */
      parGet0c( "OUTCAT", outcat, MAXPATH, status );
   
/* If a name was supplied, attempt to open the file for writing. */
      if( *status == SAI__OK ) {
         fp2 = fopen( outcat, "w" );
         if( !fp2 && *status == SAI__OK ) {
            *status = SAI__ERROR;
            msgSetc ( "CAT", outcat );
            errRep( FUNC_NAME, "Output catalogue '^CAT' could not be opened "
                    "for writing.", status );
         } 
      }
   
/* Initialise a pointer to the next element in the data array */
      pd = data->pntr[ 0 ];
   
/* Initialise the largest total data sum in any one time slice. */
      maxsum = VAL__MIND;
   
/* Store other constant values (values may need to change for 450/850 data). */
      search[ 0 ] = SEARCH;
      search[ 1 ] = SEARCH;
      mxshft[ 0 ] = MXSHFT;
      mxshft[ 1 ] = MXSHFT;
   
/* Allocate memory to hold info about all time slices. */
      slices = astMalloc( sizeof( *slices )*ntime );
   
/* Loop round each time slice. */
      for( itime = 0; itime < ntime && *status == SAI__OK; itime++ ) {
   
/* Initialise bad values. */
         bcx = AST__BAD;
         bcy = AST__BAD;
         sum = VAL__MIND;
         peakv = VAL__MIND;
         cent[ 0 ] = VAL__BADR;
         cent[ 1 ] = VAL__BADR;
         peakx = VAL__BADI;
         peaky = VAL__BADI;
   
/* Get a FrameSet describing the spatial coordinate systems associated with 
   the current time slice. The base frame in the FrameSet will be a 2D GRID
   Frame, the current Frame will be a SkyFrame (absolute or offset). NOTE,
   THE SMURF_NOPOLY environment variable should have been assigned a
   non-zero value before running this command in order to supress the
   usage of a polynomial distortion within sc2ast. */
         smf_tslice_ast( data, itime, 1, status );
         swcsin = hdr->wcs;
   
/* If the current Frame (the SkyFrame) currrently represents absolute
   coords, temporarily set it to represent offset coords. */
         skyrefis = astGetC( swcsin, "SkyRefIs" );
         if( skyrefis && strcmp( skyrefis, "Origin" ) ) {
            astSet( swcsin, "SkyRefIs=Origin" );
         }
   
/* Map the reference point (i.e. (0,0) in the offset coords system) into 
   GRID coords. */
         ox = 0.0;
         oy = 0.0;
         astTran2( swcsin, 1, &ox, &oy, 0, &gx, &gy );
   
/* Convert from GRID to PIXEL coords. */
         bcx = gx + data->lbnd[ 0 ] - 1.5;
         bcy = gy + data->lbnd[ 1 ] - 1.5;
   
/* If required, reset the SkyRefIs attribute back to its original value. */
         if( skyrefis && strcmp( skyrefis, "Origin" ) ) {
            astSetC( swcsin, "SkyRefIs", skyrefis );
         }
      
/* Save a pointer to the first data value in this time slice. */
         pd0 = pd;
   
/* Find the total data sum, and the grid coords of the peak pixel value,
   in the time slice data array. */
         sum = 0.0;
         for( iy = 1; iy <= (int) ny; iy++ ) {
            for( ix = 1; ix <= (int) nx; ix++, pd++ ) {
               if( *pd != VAL__BADD ) {
                  sum += *pd;
                  if( *pd > peakv ) {
                     peakv = *pd;
                     peakx = ix;
                     peaky = iy;
                  }
               }
            }
         }
   
/* If the peak is in the excluded border area, set its sum to zero. */
         if( peakx <= border || peakx > nx - border || 
             peaky <= border || peaky > ny - border ) {
            sum = 0.0;

/* Otherwise check there were some good values in the time slice. */
         } else if( peakv != VAL__MIND ) {

/* Update the maximum total data sum found in any time slice. */
            if( sum > maxsum ) maxsum = sum;
   
/* Convert GRID indices at the peak pixel to PIXEL indices. */
            peakx += data->lbnd[ 0 ] - 1;
            peaky += data->lbnd[ 1 ] - 1;
   
/* Convert peak position to floating point pixel coords, and store as the 
   initial guess at the centroid position. */
            init[ 0 ] = (float) peakx - 0.5;
            init[ 1 ] = (float) peaky - 0.5;
   
/* Find the centroid of the emission in a 9x9 box centred on the peak
   pixel. Check error beforehand, so that we know that any subsequent
   error is due to a failure to find the centroid. */
            if( *status == SAI__OK ) {
               kpg1Loctd( 2, data->lbnd, ubnd, pd0, init, search, 1, mxshft,
                          9, 0.1, SEARCH*SEARCH, cent, work1, status );

/* If the centroid could not be found, annul the error and treat the time 
   slice as if it contained no good data. */
               if( *status != SAI__OK ) {            
                  errAnnul( status );
                  sum = VAL__MIND;

               } else if( cent[ 0 ] == VAL__BADR || cent[ 1 ] == VAL__BADR ) {
                  sum = VAL__MIND;

/* If the centroid is too far from the base position, treat the time 
   slice as if it contained no good data. */
               } else if( sqrt( pow( cent[0]-bcx,2.0) + 
                                pow( cent[1]-bcy,2.0) ) > maxerr ) {
                  sum = VAL__MIND;
               }
            }
         }
   
/* Store values for this time slice. */
         slices[ itime ].sum = sum;
         slices[ itime ].ipx = peakx;
         slices[ itime ].ipy = peaky;
         slices[ itime ].cx = cent[ 0 ];
         slices[ itime ].cy = cent[ 1 ];
         slices[ itime ].bcx = bcx;
         slices[ itime ].bcy = bcy;
      }
   
/* Determine the lower total data sum limit for usable time slices. */
      parGet0r( "LOWFACTOR", &lowfactor, status );
      lowsum = maxsum*lowfactor;
   
/* Save pointers to the first data and variance value in the first input 
   time slice. */
      pd0 = data->pntr[ 0 ];
      pv0 = data->pntr[ 1 ];
   
/* Print out the header to any output file. */
      if( fp2 ) {
         fprintf( fp2, "%s\n", HEADER );
         fprintf( fp2, "#\n" );
         fprintf( fp2, "# IZ Sum" );
         fprintf( fp2, " BC1 BC2" );
         fprintf( fp2, " CENT1 CENT2" );
         fprintf( fp2, " PEAK1 PEAK2" );
         fprintf( fp2, "\n" );
      }
   
/* Loop round each time slice. */
      ngood = 0;
      wlim = 0.0;
      slice = slices;
      for( itime = 0; itime < ntime && *status == SAI__OK; itime++,slice++ ) {
         used = 0;
   
/* Skip this time slice if its total data sum is less than "lowsum". */ 
         if( slice->sum >= lowsum ) {
   
/* Write out the required information about this time slice to the output 
   catalogue. Remember to convert the time slice index from a zero-based 
   value to a one-based value. */
            if( fp2 ) {
               fprintf( fp2, "%d %g", (int) itime + 1, slices[ itime ].sum );
               fprintf( fp2, " %g %g", slices[ itime ].bcx,
                                       slices[ itime ].bcy );
               fprintf( fp2, " %g %g", slices[ itime ].cx,
                                       slices[ itime ].cy );
               fprintf( fp2, " %g %g", slices[ itime ].ipx - 0.5,
                                       slices[ itime ].ipy - 0.5 );
               fprintf( fp2, "\n" );
            }
         }
   
/* Get a pointer to the start of the next input time slice. */
         pd0 += nxy;
         pv0 += nxy;
   
      }
   
L998:

/* Free resources. */
      if( work ) work = astFree( work );

/* Close the input data file. */
      smf_close_file( &data, status);
   
/* Free resources. */
      if( igrp != NULL ) grpDelet( &igrp, status);
      if( slices ) slices = astFree( slices );
   }

L999:

/* End the AST and NDF contexts. */
   astEnd;
   ndfEnd( status );

/* If anything went wrong issue a context message. */
   if( *status != SAI__OK ) msgOutif( MSG__VERB, " ", "DSUTILS failed.", 
                                      status );
}












/* Returns the Mapping from GRID to focal plane coords in millimetres,
   for a given scuba-2 sub-array without any polynomial correction. 
   Copied from sc2ast_createwcs. Uses the original reference points for
   each subarray. 
--------------------------------------------------------------------- */

static AstFrameSet *GetFPFrameSet( const char *name, int *status ){

/* Local Variables: */
   AstFrameSet *result;
   AstMapping *totmap = NULL;
   AstMatrixMap *rotmap;
   AstShiftMap *shiftmap;
   AstShiftMap *zshiftmap;
   AstZoomMap *zoommap;
   double r;       
   double rot[ 4 ];
   double shift[ 2 ];
   double zshift[ 2 ];
   int subnum;

   const double rotangle[ 8 ] =
     { 0.0, PIBY2, 2*PIBY2, 3*PIBY2, 3*PIBY2, 2*PIBY2, PIBY2, 0.0 };

/* xoff and yoff are the distance in pixel units from the tracking centre
   to the [0][0] pixel in a subarray */

   const double xoff[8] =
/*       s8a    s8b     s8c   s8d    s4a    s4b    s4c    s4d */
      { -41.5,   33.5, 41.5, -33.5, -41.5,  33.5,  41.5, -33.5 };
   const double yoff[8] =
      { -33.5,  -41.5, 33.5,  41.5,  33.5,  41.5, -33.5, -41.5 };

#if COLROW
   AstPermMap *permmap;   
   int perm[ 2 ];
#endif

/* Check inherited status */
   if( *status != SAI__OK ) return NULL;

/* Start AST context. */
   astBegin;

/* Get the sub-array number. */
   sc2ast_name2num( name, &subnum, status );

/* Start off with a PermMap that swaps the grid axes from the new
   axes ordering to the old axis ordering (AST uses 1-based axis
   numbering). This covers the recent (ROW,COL) -> (COL,ROW) change. */
#if COLROW
   perm[ 0 ] = 2;
   perm[ 1 ] = 1;
   permmap = astPermMap( 2, perm, 2, perm, NULL, " " );
   totmap = (AstMapping *) permmap;
#endif

/* The GRID domain locates the [0][0] pixel at coordinates (1,1). Shift
   these so that the [0][0] pixel is at the origin of a coordinate system */
   zshift[0] = -1.0;
   zshift[1] = -1.0;
   zshiftmap = astShiftMap ( 2, zshift, " " );
#if COLROW
   totmap = (AstMapping *) astCmpMap( totmap, zshiftmap, 1, " " );
#else
   totmap = (AstMapping *) zshiftmap;
#endif

/* The mm coords now have to be rotated through an angle approximating
   a multiple of 90 degrees */
   r = rotangle[ subnum ];

/* 850 arrays */
   if( subnum < 4 ) {
     rot[ 0 ] =  cos( r );
     rot[ 1 ] = -sin( r );
     rot[ 2 ] =  sin( r );
     rot[ 3 ] =  cos( r );

/* 450 arrays */
   } else {
     rot[ 0 ] = -sin( r );
     rot[ 1 ] =  cos( r );
     rot[ 2 ] =  cos( r );
     rot[ 3 ] =  sin( r );
   }
   rotmap = astMatrixMap ( 2, 2, 0, rot, " " );
   totmap = (AstMapping *) astCmpMap( totmap, rotmap, 1, " " );

/* For each 450/850 subarray, the next Mapping creates FRAME450/FRAME850
   coordinates, which are coordinates in millimetres with origin at the
   center of the focal plane. */
   shift[ 0 ] = xoff[ subnum ];
   shift[ 1 ] = yoff[ subnum ];
   shiftmap = astShiftMap( 2, shift, " " );
   totmap = (AstMapping *) astCmpMap( totmap, shiftmap, 1, " " );

/* The mapping from pixel numbers to millimetres is a simple scaling,
   because the pixel separation is the same in both coordinates and is
   accurately constant. A ZoomMap can be used for this. */
   zoommap = astZoomMap ( 2, PIX2MM, " " );
   totmap = (AstMapping *) astCmpMap( totmap, zoommap, 1, " " );

/* Construct the returned FrameSet. */
   result = astFrameSet( astFrame( 2, "Domain=GRID" ), " " );
   astAddFrame( result, AST__BASE, astSimplify( totmap ),
                astFrame( 2, "Domain=FPLANE,label(1)=FplaneX,"
                             "label(2)=FplaneY,Unit(1)=mm,Unit(2)=mm" ) );

/* Clear up. */
   astExport( result );
   astEnd;   

/* Return the FrameSet. */
   return result; 
}
   






/* Create an output NDF and paste a list of data values into its data array.
--------------------------------------------------------------------- */

static void PasteNDF( const char *subarray, int *lb, int *ub, int nvals, 
                      double *xvals, double *yvals, double *datvals, 
                      double *varvals, AstMapping *map, AstFrameSet *wcs, 
                      int niter, int genvar, double wlim, const char *param, 
                      int *status ){

/* Local Variables: */
   AstLutMap *lut1;
   AstLutMap *lut2;
   AstMapping *tmap;
   AstPermMap *pmap;
   HDSLoc *xloc = NULL;
   double *data;
   double *var;
   double *work;
   double *work2v;
   double *work2d;
   double dx;
   int flags;
   int indf;
   int inperm[ 1 ];
   int irow;
   int iter;
   int lbnd[ 2 ];
   int nel;
   int nrej;
   int nused;
   int outperm[ 2 ];
   int rlbnd[ 1 ];
   int rubnd[ 1 ];
   int ubnd[ 2 ];

/* Check inherited status */
   if( *status != SAI__OK ) return;

/* Create the NDF with the required bounds (the default bounds match a 
   complete s8d time slice). */
   if( !lb ) {
      lbnd[ 0 ] = 0;
      lbnd[ 1 ] = 0;
   } else {
      lbnd[ 0 ] = lb[ 0 ];
      lbnd[ 1 ] = lb[ 1 ];
   }
   if( !ub ) {
      ubnd[ 0 ] = 31;
      ubnd[ 1 ] = 39;
   } else {
      ubnd[ 0 ] = ub[ 0 ];
      ubnd[ 1 ] = ub[ 1 ];
   }

   ndfCreat( param, "_DOUBLE", 2, lbnd, ubnd, &indf, status ); 
   if( *status == PAR__NULL ) {
      errAnnul( status );

   } else {

/* Store the subarray. */
      if( subarray ) {
         ndfXnew( indf, "DSUTILS", "DSUTILS", 0, NULL, &xloc, status );
         ndfXpt0c( subarray, indf, "DSUTILS", "SUBARRAY", status );
         datAnnul( &xloc, status );
      }

/* Put the supplied WCS FrameSet into the NDF. */
      ndfPtwcs( wcs, indf, status );

/* Map the NDF DATA array, filling it with bad values. */
      ndfMap( indf, "Data", "_DOUBLE", "Write/Bad", (void *) &data,
              &nel, status ); 

/* If required, map the NDF VARIANCE array, filling it with bad values. */
      if( genvar ) {
         ndfMap( indf, "Variance", "_DOUBLE", "Write/Bad", (void *) &var,
                 &nel, status ); 
      } else {
         var = NULL;
      }

/* Set up the bounds of the NDF in GRID coords. */
      ubnd[ 0 ] = ubnd[ 0 ] - lbnd[ 0 ] + 1;
      ubnd[ 1 ] = ubnd[ 1 ] - lbnd[ 1 ] + 1;
      lbnd[ 0 ] = 1;
      lbnd[ 1 ] = 1;

/* Create a Mapping that maps the index within the supplied vals arrays into
   GRID coords. */
      lut1 = astLutMap( nvals, xvals, 0.0, 1.0, "LutInterp=1" );
      lut2 = astLutMap( nvals, yvals, 0.0, 1.0, "LutInterp=1" );
      inperm[ 0 ] = 1;
      outperm[ 0 ] = 1;
      outperm[ 1 ] = 1;
      pmap = astPermMap( 1, inperm, 2, outperm, NULL, " " );
      tmap = (AstMapping *) astCmpMap( astCmpMap( pmap, astCmpMap( lut1, lut2, 
                                                                   0, " " ), 
                                                  1, " " ),
                                       map, 1, " " );

/* Allocate work arrays. */
      work = astMalloc( 2*nel*sizeof( double ) );
      work2d = astMalloc( sizeof( double )*nvals );
      work2v = astMalloc( sizeof( double )*nvals );

/* Store the bounds of row number. */
      rlbnd[ 0 ] = 0;
      rubnd[ 0 ] = nvals - 1;

/* Get basic flags for astRebinSeq. */
      flags = AST__USEBAD;      
      if( varvals ) flags = flags | AST__VARWGT;
      if( genvar ) flags = flags | AST__GENVAR | AST__DISVAR;

/* We do some sigma-clipping */
      for( iter = 0; iter <= niter && *status == SAI__OK; iter++ ) {

/* Bin the values array into the output pixel grid, forming variances from
   the spread of values if required. We use astRebinSeq because astRebin does 
   not have a GENVAR facility. */
         astRebinSeqD( tmap, wlim, 1, rlbnd, rubnd, datvals, varvals, AST__LINEAR,
                       NULL, (AST__REBININIT | flags ), 0.0, 0, VAL__BADD, 2, 
                       lbnd, ubnd, rlbnd, rubnd, data, var, work, &nused ); 
         astRebinSeqD( tmap, wlim, 1, rlbnd, rubnd, NULL, NULL, AST__LINEAR,
                       NULL, (AST__REBINEND | flags), 0.0, 0, VAL__BADD, 2, 
                       lbnd, ubnd, rlbnd, rubnd, data, var, work, &nused ); 

/* Quit if we have reached the end or if we have no variances. */
         if( iter == niter || !genvar ) break;

/* Resample the binned offset image back into the supplied array format. */
         astInvert( tmap );
         astResampleD( tmap, 2, lbnd, ubnd, data, var, AST__LINEAR, NULL, NULL,
                       AST__USEBAD, 0.0, 0, VAL__BADD, 1, rlbnd, rubnd,
                       rlbnd, rubnd, work2d, work2v ); 
         astInvert( tmap );

/* Reject any rows where the resampled row value is more than 3*sigma
   from the original row value. */
         nrej = 0;
         for( irow = 0; irow < nvals; irow++ ) {
            if( datvals[ irow ] != VAL__BADD && 
                 work2d[ irow ] != VAL__BADD && work2v[ irow ] != VAL__BADD ) {
               dx = fabs( datvals[ irow ] - work2d[ irow ] );
               if( dx > NSIGMA*sqrt( work2v[ irow ] ) ){ 
                  datvals[ irow ] = VAL__BADD;
                  varvals[ irow ] = VAL__BADD;
                  nrej++;
               }
            }
         }
         printf("%s: iteration %d: %d values removed\n", param, iter, nrej );
      }

/* Free resources */
      work = astFree( work );
      work2d = astFree( work2d );
      work2v = astFree( work2v );
      ndfAnnul( &indf, status );
   }

}







/* Perform sigma-clipping to identify outlying values in a list of values.
--------------------------------------------------------------------- */

static void Filter( int n, double *flags, double *vals, double nsigma,
                    const char *title, int * status ) {

/* Local Variables: */
   int done;
   int nrej;
   int ninc;
   int i;
   double sum1;
   double sum2;
   double mean;
   double var;
   double sigma;

/* Check inherited status */
   if( *status != SAI__OK ) return;

   nrej = 0;
   while( 1 ) {

      sum1 = 0.0;
      sum2 = 0.0;
      ninc = 0;

      for( i = 0; i < n; i++ ) {
         if ( !isfinite( vals[ i ] ) ) {
            msgOut( " ", "Warning - Non-finite value encountered within function "
                    "Filter.", status );

         } else if( vals[ i ] != VAL__BADD ) {
            sum1 += vals[ i ];
            sum2 += vals[ i ]*vals[ i ];
            ninc++;
         } 
      }

      if( ninc > 0 ) {
         mean = sum1/ninc;
         var = sum2/ninc - mean*mean;
         sigma = ( var > 0.0 ) ? sqrt( var ) : 0.0;
      } else {
         mean = 0.0;
         sigma = -1.0;
      }


      done = 1;
      for( i = 0; i < n; i++ ) {
         if( vals[ i ] != VAL__BADD ) {
            if( fabs( mean - vals[ i ] ) > nsigma*sigma ) {
               vals[ i ] = VAL__BADD;
               flags[ i ] = VAL__BADD;
               nrej++;
               done = 0;
            }
         } else {
            flags[ i ] = VAL__BADD;
         }
      }
      if( done ) break;

   }

   printf("Filtering %s removed %d rows\n", title, nrej );

}







/* Write a timeslice Mapping from a modified PIXEL Frame to the SKY offset 
   frame. The PIXEL frame is modified in the sense that its origin (i.e. 
   pixel coords (0,0,0.0) ) is shifted so that it co-incides with the sky
   reference point ). 
--------------------------------------------------------------------- */

static int SaveBoloMapping( const char *param, smfData *data, int *status ){

/* Local Variables: */
   AstFrameSet *swcsin;
   AstCmpMap *map;
   const char *skyrefis;
   double ox;
   double oy;
   double gx;
   double gy;
   double shifts[ 2 ];
   int result;
   dim_t itime;

   result = 0;

/* Check inherited status */
   if( *status != SAI__OK ) return result;

   astBegin;

/* Loop until we have found a usable time slice. Start looking at he
   middle time slice, and check all subsequent time slices until a good
   slice is found. */
   for( itime = data->dims[ 2 ]/2; itime <  data->dims[ 2 ]; itime++ ) {

/* Get the WCS FrameSet describing the time slice */
      smf_tslice_ast( data, itime, 1, status );
      swcsin = data->hdr->wcs;

/* If the skyref position is good, leave the loop early. */
      if( astGetD( swcsin, "SkyRef(1)" ) != AST__BAD &&
          astGetD( swcsin, "SkyRef(2)" ) != AST__BAD ) break;
   }

/* Report an error if no good skyref position was found. */
   if( astGetD( swcsin, "SkyRef(1)" ) == AST__BAD ||
       astGetD( swcsin, "SkyRef(2)" ) == AST__BAD ) {
      if( *status == SAI__OK ) {
         *status = SAI__ERROR;
         errRep( " " , "Could not find a time slice with a good reference "
                 "point", status );
      }
   }
   
/* If the current Frame (the SkyFrame) currrently represents absolute
   coords, temporarily set it to represent offset coords. */
   skyrefis = astGetC( swcsin, "SkyRefIs" );
   if( skyrefis && strcmp( skyrefis, "Origin" ) ) {
      astSet( swcsin, "SkyRefIs=Origin" );
   }
   
/* Map the sky reference point (i.e. (0,0) in the offset coords system) into 
   GRID coords. */
   ox = 0.0;
   oy = 0.0;
   astTran2( swcsin, 1, &ox, &oy, 0, &gx, &gy );

/* We want to define a translated version of GRID coords (a form of PIXEL
   coords) in which the pixel origin corresponds to the sky reference
   point. Create the ShiftMap that maps these tranlated grid coords into
   original GRID coords. And combine this with the Mapping from GRID to
   SKY, to get the Mapping from translated grid coords to SKY. */
   shifts[ 0 ] = gx;
   shifts[ 1 ] = gy;
   map = astCmpMap( astShiftMap( 2, shifts, " " ), 
                    astGetMapping( swcsin, AST__BASE, AST__CURRENT ), 1, " " );

/* If required, reset the SkyRefIs attribute back to its original value. */
   if( skyrefis && strcmp( skyrefis, "Origin" ) ) {
      astSetC( swcsin, "SkyRefIs", skyrefis );
   }

/* Write the Mapping to an output text file, if required. */
   atlCreat( param, (AstObject *) map, status );
   if( *status == PAR__NULL ) {
      errAnnul( status );
   } else if( *status == SAI__OK ) {
      result = 1;
   }

/* Export the swcsin pointer, since it is annulled explicitly when the
   input data file is closed. */
   astExport( swcsin );
   astEnd;

   return result;
}







/* Return a KeyMap holding information about the columns in the catalogue
   read from the supplied open file pointer. 
--------------------------------------------------------------------- */

static AstKeyMap *GetHeader( FILE *fp, int *status ) {

/* Local Variables: */
   AstKeyMap *result;
   AstKeyMap *coldes;
   char buf[ BUFSIZE ];
   char tbuf[ BUFSIZE ];
   char **fields;
   char *p;
   int i;
   int nfield;

/* Check inherited status */
   if( *status != SAI__OK ) return NULL;

/* Create the returned KeyMap. */
   result = astKeyMap( " " );

/* Create a secondary KeyMap to hold column descriptions, and store it in
   the returned KeyMap. */
   coldes = astKeyMap( " " );
   astMapPut0A( result, "XXCOLDES", coldes, NULL );

/* Ensure the file is re-wound. */
   rewind( fp );

/* Read lines from the file, until one is found that does not start with
   a comment character. */
   while( fgets( buf, BUFSIZE, fp ) && buf[ 0 ] == '#' ) {

/* If this line is a column description, extract the column name (and
   convert to upper case) and its description and store them in the 
   coldes keyMap. */
      fields = astChrSplitRE( buf, "^# +(\\w+) +- +(.+?)\\s*$", &nfield, NULL );
      if( fields && nfield == 2 ) {

         p = fields[ 0 ] - 1;
         while( *(++p) ) *p = toupper( *p );

         astMapPut0C( coldes, fields[0], fields[1], NULL );
         for( i = 0; i < nfield; i++ ) fields[ i ] = astFree( fields[ i ] );
         fields = astFree( fields );

/* Otherwise take a copy of the line, minus the leading #. */
      } else {
         strcpy( tbuf, buf + 1 );
      }
   }

/* Get the column names from the last comment line read, convert to upper
   case, and store the corresponding zero-based index in the returned KeyMap. 
   Also store the name for each column index. */
   fields = astChrSplit( tbuf, &nfield );
   for( i = 0; i < nfield; i++ ) {

      p = fields[ i ] - 1;
      while( *(++p) ) *p = toupper( *p );

      astMapPut0I( result, fields[ i ], i, NULL );

      sprintf( tbuf, "XXCOL%d", i );
      astMapPut0C( result, tbuf, fields[ i ], NULL );

      fields[ i ] = astFree( fields[ i ] );
   }
   fields = astFree( fields );

/* Store the number of columns. */
   astMapPut0I( result, "XXNCOL", nfield, NULL );

/* Annul objects. */
   coldes = astAnnul( coldes );

/* Rewind the file. */
   rewind( fp );

/* Return the KeyMap. */
   return result;
}





/* Return the index of a column in the supplied catalogue
--------------------------------------------------------- */

static int GetColIndex( AstKeyMap *header, const char *colname, int *status ){

/* Local Variables; */
   int result;
   int there;

/* Check inherited status */
   if( *status != SAI__OK ) return 0;

/* Attempt to get the column index from the keymap. */
   there = astMapGet0I( header, colname, &result );

/* If not there try some standard translations. */
   if( !there ) {
      if( !strcmp( colname, "DBF1" ) ) {
         there = astMapGet0I( header, "DBC1", &result );
      } else if( !strcmp( colname, "DBF2" ) ) {
         there = astMapGet0I( header, "DBC2", &result );
      }
   }

/* Report an error if not found. */
   if( !there ) {
      msgSetc( "C", colname );
      *status = SAI__ERROR;
      errRep( " ", "Supplied catalogue does not contain column ^C.",
              status );
      result = 0;
   }

/* Return the column index. */
   return result;
}








/* Add a new column name and description to a catalogue header
---------------------------------------------------------------- */

static void AddColName( AstKeyMap *header, const char *colname, const char *desc, 
                        int *status ){

/* Local Variables; */
   int ncol;
   AstKeyMap *coldes;
   char tbuf[ 20 ];

/* Check inherited status */
   if( *status != SAI__OK ) return;

/* Get the current number of columns in the catalogue. */
   astMapGet0I( header, "XXNCOL", &ncol );

/* Store the new column name and index. */
   astMapPut0I( header, colname, ncol, NULL );
   sprintf( tbuf, "XXCOL%d", ncol );
   astMapPut0C( header, tbuf, colname, NULL );

/* Store the new column count. */
   astMapPut0I( header, "XXNCOL", ncol + 1, NULL);

/* Get the KeyMap holding the column descriptions. */
   astMapGet0A( header, "XXCOLDES", &coldes );

/* Store the new column description. */
   astMapPut0C( coldes, colname, desc, NULL);

/* Free objects */
   coldes = astAnnul( coldes );

}




/* Write a catalogue header to an open file pointer 
--------------------------------------------------------------------- */

static void PutHeader( FILE *fp, AstKeyMap *header, int *status ) {

/* Local Variables; */
   AstKeyMap *coldes;
   const char *coldesc;
   const char *colname;
   char *line;
   char tbuf[ 20 ];
   int icol;
   int nc;       
   int ncol;

/* Check inherited status */
   if( *status != SAI__OK ) return;

/* Write out the standard header line. */
   fprintf( fp, "%s\n", HEADER );
   fprintf( fp, "#\n" );

/* Get the KeyMap holding the column descriptions. */
   astMapGet0A( header, "XXCOLDES", &coldes );

/* Get the current number of columns in the catalogue. */
   astMapGet0I( header, "XXNCOL", &ncol );

/* Initialise buffer for final line of header. */
   nc = 0;
   line = astAppendString( NULL, &nc, "#" );

/* Loop round them all */
   for( icol = 0; icol < ncol; icol++ ) {

/* Get the name of the current column. */
      sprintf( tbuf, "XXCOL%d", icol );
      astMapGet0C( header, tbuf, &colname );

/* Append the column name to the buffer for final line of header. */
      line = astAppendString( line, &nc, " " );
      line = astAppendString( line, &nc, colname );

/* Get the column description, and print it out. */
      if( astMapGet0C( coldes, colname, &coldesc ) ) {
         fprintf( fp, "# %s - %s\n", colname, coldesc );
      }
   }

/* Print out the final lines. */
   fprintf( fp, "#\n" );
   fprintf( fp, "%s\n", line );
   
/* Free resources */
   line = astFree( line );
   coldes = astAnnul( coldes );

}




