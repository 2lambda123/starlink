#!/usr/bin/env starperl   # -*- cperl -*-

=head1 NAME

print_index - Provide a listing of SCUBA-2 or ACSIS data files in a directory

=head1 SYNOPSIS

  scuba2_index  [-v | -h | -d | -o] [-a] [-e] [-f] [datadir] [scuba2_array]
  acsis_index   [-v | -h | -d | -o] [-a] [-c] [-e] [-f] [-t/T -r/R -s/S]
                  [datadir]

=head1 DESCRIPTION

Script to read JCMT observation files in a directory and create an
index, a table with the basic information on the files. Can be
invoked as C<acsis_index> (default) or C<scuba2_index> depending on the
desired instrument listing.

=head1 OPTIONS

The following options are supported:

=over 4

=item B<all>

Print information on all files even if the headers are identical. For example,
include multiple subbands (subsystems) and sub-scans.

=item B<-debug>

Print debugging information.

=item B<-extended>

Print extended lines. Can add AZ, EL, pointing offsets and bandwidth.

=item B<-force>

Force a subdirectory search. If no files are found in the directory itself, as
would be the case for a raw data tree, the program will automatically search subdirecties.
This option forces the subdirectory search.

=item B<-help>

Print help information.

=item B<-man>

Print the full documentation to STDOUT.

=item B<-ocscfg>

Print the OCS configuration XML file.

=item B<-version>

Print version information.

=back

ACSIS-specific options:

=over 4

=item B<-cal>

Only print calibration observations.

=item B<-skip>

Skip observation information when printing Tsys or Trx

=item B<-stdev>

Include the standard deviation when print Tsys or Trx.

=item B<-trx>

Print media receiver temperature.

=item B<-tsys>

Print median system temperature.

=back

=head1 ARGUMENTS

The primary argument is the data directory to index. If a yyyymmdd string is
given it will default to the SCUBA-2/ACSIS data for the specified data unless
there is a local subdirectory named yyyymmdd. Will default to the value of the
$DATADIR environment variable if set.

C<scuba2_index> can take a specific sub-array directory to index. Defaults to s8d.

=cut

use strict;

use File::Basename;
use File::Spec;

# Load in the SDF module
use Astro::FITS::Header::NDF;
use NDF;

# Astrometry
use Starlink::AST;

# Load in the GSD module
use GSD;

# Option handling
use Getopt::Long;
use Pod::Usage;

# Smurf command GETTSYS is used for some options
my $tsyscmd;
if (exists $ENV{SMURF_DIR} && defined $ENV{SMURF_DIR}) {
    $tsyscmd = $^X. " ". File::Spec->catfile( $ENV{SMURF_DIR},
                                              "gettsys" )
}

# ----------------------------------------------------------------------
# Parse the command line options

our $VERSION = "2.0";

my $acsis_root = "/jcmtdata/raw/acsis/spectra";

my $default_array = "s8d";
my $scuba2_root  = File::Spec->catdir("/jcmtdata/raw/scuba2",${default_array});

# Store the arguments for debugging purposes
my @args = @ARGV;

my ($help, $man, $doversion, $debug, $extended, $ocscfg, $force, $prtall);
my ($cal_only, $skip, $tsys, $trx, $stdev);
my $use_scuba2;
my $result = GetOptions(
                        "help" => \$help,         # Help text
                        "man"   => \$man,         # Manual page
                        "version" => \$doversion, # Version information
                        "debug" => \$debug,       # Debugging (debug = 2 prints header items)
                        "extended" => \$extended, # Print extended lines?
                        "ocscfg" => \$ocscfg,     # Print ocs config file
                        "force" => \$force,       # Force subdirectory search
                        "all" => \$prtall,        # Print info on all files even if headers identical
                        # ACSIS
                        "cal" => \$cal_only,      # Only print calibration observations
                        "skip" => \$skip,         # Skip obs-info (for Tsys/Rrx-only listing)
                        "tsys" => \$tsys,       # Print median Tsys
                        "trx"  => \$trx,        # Print median Trx
                        "stdev" => \$stdev,       # Include standard deviation for Tsys and Trx
                        # Explicit mode switching
                        "scuba2" => \$use_scuba2,     # Choose scuba-2 mode
                       );

my $prog = basename($0);
$prog = "scuba2_index" if $use_scuba2;

pod2usage(1) if $help;
pod2usage(-exitstatus => 0, -verbose =>2) if $man;
if ($doversion) {
  print "\n\t$prog --- version $VERSION\n";
  print "\tCreate an index of the files in \$DATADIR\n";
  print "\tContact Remo Tilanus (rpt\@jach.hawaii.edu) for more information\n\n";
  exit;
}

# Provide output from SCUBA or HETERODYNE data (default):
my $data_root = ( $prog =~ /scuba/ ? $scuba2_root : $acsis_root );

# Print extended lines?
my $pformat = ( $extended ? "LONG" : "SHORT");

my $tsysrms = 0;
my $trxrms = 0;

if ( $prog !~ /scuba/ ) {
  # Print Tsys?
  if ($tsys && $stdev) {
    $tsysrms = 1;
  }

  # Print Trx?
  if ($trx && $stdev) {
    $trxrms = 1;
  }

}

# Create string of arguments
my $sw = join( " ", grep { $_ !~ /^\-scu/i } @args);
print "Running: ${prog} $sw\n" if ($debug);

if ($skip && (!$tsys || $trx) ) {
  print "\n*ERROR*: -skip is only valid with -tsys and/or -trx";
  pod2usage(1);
  exit;
}

# ----------------------------------------------------------------------
# Command-line arguments

my $datadir = $ENV{'DATADIR'};            # The default data directory

# Get observation directory and (optional) scuba array from arguments
my $scuba2_array = $default_array;
my $i = $#ARGV;
for my $arg (reverse @ARGV) {
  chomp($arg);
  print "ARGV ${i}: $arg\n" if ($debug);
  if ( $arg =~ /^s\d\w/i ) {
    $scuba2_array = $arg;
  } else {
    $datadir = $arg;
  }
  $i--;
}

$datadir = File::Spec->catdir( $data_root, $datadir )
     if ( defined $datadir && $datadir =~ /^\d{8}$/ && not -e $datadir);

unless (defined $datadir || $datadir != '') {
    chomp($datadir = `pwd`);
}

# Replace any array string with the requested one:
$datadir =~ s/$default_array/$scuba2_array/
            if ($default_array ne $scuba2_array);

$datadir =~ s/\/$//;

print "Path: $datadir   Files: all\n" if ($debug);
my @obsfiles;

opendir( my $DIR,$datadir ) or die "Can't open directory '${datadir}'! :\n\t $!\n";
my @ofiles;
unless ($prog =~ /scuba/) {
   @ofiles = sort
          grep( /dem_|obs_|cbe_|das_|ac\d{8}_\d{5}|a\d{8}_\d{5}|\@/,
          grep( /sdf|dat|gsd/, readdir($DIR)) );
 }else {
   @ofiles = sort
          grep( /s\d\w\d{8}_\d{5}_\d{4}|\@/,
          grep( /sdf|dat|gsd/, readdir($DIR)) );
}
closedir($DIR);

# If: Found valid files in the flat directory
if ($#ofiles > 0 && $force == 0) {
  print "Found $#ofiles files in ${datadir}\n" if ($debug);
  foreach my $of (@ofiles) {
    push(@obsfiles, File::Spec->catfile($datadir,$of));
  }

# Else: Try to find spectra-like files in subdirs
} else {
  if ($debug) {
    print "Forced subdir search: " if ($force);
    print "No files found: " unless ($force);
    print " try scanning subdirs of ${datadir}\n";
  }
  open(my $FIND, "find $datadir -name \\\*_0001.sdf -print | sort |");
  while(<$FIND>) {
    chomp;
    if ( $prog !~ /scuba/ && $_ =~ /a\d{8}_\d{5}/  ) {
      push(@obsfiles,$_);
    } elsif ( $prog =~ /scuba/ && $_ =~ /s\d\w\d{8}_\d{5}_\d{4}/ ) {
      push(@obsfiles,$_);
    }
  }
  close($FIND);
}

my $origin = "";
$origin = $1 if $datadir =~ /[1,2][9,0,1](\d{6})/;

#-----------------------------------------------------------------------
# Handle each file

# in case obs_... gsd files sort by scan number
if ($obsfiles[0] !~ /sdf$/) {
  print "Sorting files...\n" if $debug;
  my @unsorted = @obsfiles;
  @obsfiles = sort sort_by_scan @unsorted;
}

my $prev_obs = "";

my @suffixlist = ( "sdf", "dat", "gsd" );

foreach my $obsfile ( @obsfiles )
{

  (my $basename,my $path,my $suffix) = fileparse($obsfile,@suffixlist);
  $basename =~ s/\.$//;
  $path =~ s/\/$//;
  print "File $basename, Suffix: $suffix, Path: $path\n" if ($debug);

  my $cur_obs = "";
  # ..and recover the PROJECT_ID and update INDEX.
  if ( "$suffix" eq "sdf" || "$suffix" eq "" ) {
      $cur_obs = sdf_header ( $path, $basename, $suffix,
                 $prev_obs, $pformat, $debug);
  } else {
      $cur_obs = gsd_header ( $path, $basename, $suffix,
                 $prev_obs, $pformat, $debug);
  }

  $prev_obs = $cur_obs;
}

exit;

# ---------------------- SUBROUTINES -----------------------------------

# Sort routine for GSD data
sub sort_by_scan {
  if ($a =~ /gsd$/) {
    (split(/\_/,$a,4))[3] <=> (split(/\_/,$b,4))[3];
  } else {
    (split(/\_/,$a,3))[2] <=> (split(/\_/,$b,3))[2];
  }
};


# Read a FITS header and return a hash reference
sub read_fits_header {
  my $file = shift;
  # Read the FITS header and tie it
  my $fitshdr = Astro::FITS::Header::NDF->new( File => $file );
  if (!$fitshdr) {
    print "Error reading FITS in $file\n";
    return;
  }
  my %tiedhdr;
  tie %tiedhdr, "Astro::FITS::Header", $fitshdr, tiereturnsref => 1;
  return \%tiedhdr;
}

# ----------------------------------------------------------------------
# Handle a SDF file, find out if SCUBA or ACSIS

sub sdf_header {

    my ($path, $basename, $suffix, $prev_obs, $pformat, $debug) = @_;
    my $sdffile = $path . '/' . $basename;
    my $fitsitem = read_fits_header( $sdffile );
    return "" unless defined $fitsitem;

# Branch between SCUBA, SCUBA2 and ACSIS

    my $cur_obs = "";
    if ("${$fitsitem}{'INSTRUME'}" =~ /^scuba$/i) {
      print "SCUBA observation\n" if ($debug);
      $cur_obs =
         scuba_header($path, $basename, $suffix,
                      $fitsitem, $prev_obs, $pformat, $debug);
    } elsif ("${$fitsitem}{'INSTRUME'}" =~ /^scuba-2$/i) {

      print "SCUBA-2 observation\n" if ($debug);

      # Find sub-files of observation
      opendir( my $ODIR,"${path}" ) or die "Can't open observation '${path}'! : $!\n";
      my @subfiles = sort
          grep( /s\d\w\d{8}_\d{5}_\d{4}/,grep(/sdf/, readdir($ODIR)) );
      closedir($ODIR);

      # Skip the initial DARK
      if ($#subfiles > 0) {
        my $basename = $subfiles[1];
        $basename =~ s/\.sdf$//;
        $sdffile = $path . '/' . $basename;
        print "Read non-dark file: $sdffile\n" if ($debug);
        $fitsitem = read_fits_header($sdffile);
        return "" unless defined $fitsitem;
      }

      # Try reading the last non-DARK file as well
      my $fitsitem2 = $fitsitem;
      my $listlast = $#subfiles;
      my $found = 0;
      while ($found == 0 && $listlast > 0 &&
             "${$fitsitem}{'OBS_TYPE'}" ne "flatfield" ) {
        my $basename2 = $subfiles[$listlast];
        $basename2 =~ s/\.sdf$//;
        my $sdffile2 = $path . '/' . $basename2;
        print "Read last non-dark file: $sdffile2\n" if ($debug);
        $fitsitem2 = read_fits_header( $sdffile2 );
        if (defined $fitsitem2) {
          if ( "${$fitsitem2}{'AZEND'}" ne "" &&
               "${$fitsitem2}{'ELEND'}" ne "" ) {
            $found = 1;
	  }
	}
        $listlast--;
      }

      $cur_obs =
         scuba2_header($path, $basename, $suffix, $fitsitem,
                       $fitsitem2, $prev_obs, $pformat, $debug);

    } else {

      print "ACSIS observation\n" if ($debug);
      $cur_obs =
         acsis_header($path, $basename, $suffix, $fitsitem,
                      $prev_obs, $pformat, $debug);
    }

    return($cur_obs);
}

# ----------------------------------------------------------------------
# Get project info from an ACSIS file

sub acsis_header {

    my ($path, $basename, $suffix, $fitsitem, $prev_obs, $pformat, $debug) = @_;
    my $sdffile = $path . '/' . $basename;

    # Get the rest frequency
    my $status = &NDF::SAI__OK;
    ndf_begin();
    ndf_find( NDF::DAT__ROOT, $sdffile, my $indf, $status);

    my $wcs = ndfGtwcs( $indf, $status );
    $fitsitem->{RESTFREQ} = 0;
    eval {
      $fitsitem->{RESTFREQ} = $wcs->Get( "restfreq" );
    };
    # Use "stdofrest" to get the velocity standard of rest
    # source velocity in the DOPPLER system
    my $sourcesys = "VRAD";
    if ($fitsitem->{DOPPLER}) {
      if ($fitsitem->{DOPPLER} =~ /rad/i) {
        $sourcesys = "VRAD";
      } elsif ($fitsitem->{DOPPLER} =~ /opt/) {
        $sourcesys = "VOPT";
      } elsif ($fitsitem->{DOPPLER} =~ /red/) {
        $sourcesys = "REDSHIFT";
      }
    }
    if ( $fitsitem->{RESTFREQ} > 0 ) {
      $wcs->Set( sourcesys => $sourcesys );
      $fitsitem->{VELOCITY} = $wcs->Get("sourcevel" );
    } else {
      $fitsitem->{VELOCITY} = 0;
    }

    ndf_annul( $indf, $status );
    ndf_end( $status );

    do {foreach (keys %$fitsitem) { print "$_\n";}} if ($debug > 1);

    my $projid = "\L${$fitsitem}{'PROJECT'}";
    my $run    = "\L${$fitsitem}{'OBSNUM'}";
    my $cfgfile = ${$fitsitem}{'OCSCFG'};
    my ($date, $ut) = split(/T/, ${$fitsitem}{'DATE-OBS'});
    $date =~ s/\-/\//g;
    my $datetime = "$date $ut";
    my $obstype  = "\U${$fitsitem}{'OBS_TYPE'}";
    my $mode   = "\U${$fitsitem}{'RECIPE'}";
    if ($mode =~ /science/i) {
      $mode = "\U${$fitsitem}{'SAM_MODE'}" . "_" . "\U${$fitsitem}{'SW_MODE'}";
      $mode =~ s/JIGGLE/JIG/;
      $mode =~ s/RASTER/RAS/;
      $mode =~ s/GRID/GRD/;
    } else {
      $mode =~ s/REDUCE_//i;
    }
    my $object = "\L${$fitsitem}{'OBJECT'}";

    my $rx     = "\L${$fitsitem}{'INSTRUME'}";
    $rx     =~ s/harpb/harp/;
    $rx     =~ s/^fe_//;
    $rx     =~ s/^rx//i;
    $rx     =~ s/^scuba-2/scu/i;
    my $freq   = sprintf("%.1f", $fitsitem->{RESTFREQ});
    my $cfreq  = "${rx}/${freq}";
    my $vel    = sprintf("%.2f", $fitsitem->{VELOCITY});
    my $cvref  = "$vel" . "/" . substr("\L${$fitsitem}{'DOPPLER'}",0,3) .
              substr("\L${$fitsitem}{'SPECSYS'}",0,3);
    my $bwmode = ${$fitsitem}{'BWMODE'};

    my $step = "${$fitsitem}{'STEPTIME'}";
    my $josmult = ( ${$fitsitem}{'JOS_MULT'} > ${$fitsitem}{'JOS_MIN'} ?
                    $fitsitem->{JOS_MULT} : $fitsitem->{JOS_MIN});
    my $numnods = ( $fitsitem->{NUM_NODS} ne '' ? 4*$fitsitem->{NUM_NODS} : 1 );
    my $intt = 0.1*int(10.0*${$fitsitem}{'NUM_CYC'}*$numnods*$josmult*$step+0.5);

    my $az     = 0.5*(${$fitsitem}{'AZSTART'}+${$fitsitem}{'AZEND'});
    my $el     = 0.5*(${$fitsitem}{'ELSTART'}+${$fitsitem}{'ELEND'});
    my $uaz    = ${$fitsitem}{'UAZ'};
    my $uel    = ${$fitsitem}{'UEL'};

    my $seeing = 0.01 * int(100.0*
                            0.5*(${$fitsitem}{'SEEINGST'}+${$fitsitem}{'SEEINGEN'})+0.5)
        if ("${$fitsitem}{'SEEINGST'}" ne "");
    my $csotau = 0.01 * int(100.0*
                            0.5*(${$fitsitem}{'TAU225ST'}+${$fitsitem}{'TAU225EN'})+0.5)
        if ("${$fitsitem}{'TAU225ST'}" ne "");
    my $wvmtau = 0.01 * int(100.0*
                            0.5*(${$fitsitem}{'WVMTAUST'}+${$fitsitem}{'WVMTAUEN'})+0.5)
        if ("${$fitsitem}{'WVMTAUST'}" ne "");
    my $lseeing = 0.001 * int(1000.0*
                              0.5*(${$fitsitem}{'SEEINGST'}+${$fitsitem}{'SEEINGEN'})+0.5)
        if ("${$fitsitem}{'SEEINGST'}" ne "");
    my $lcsotau = 0.001 * int(1000.0*
                              0.5*(${$fitsitem}{'TAU225ST'}+${$fitsitem}{'TAU225EN'})+0.5)
        if ("${$fitsitem}{'TAU225ST'}" ne "");
    my $lwvmtau = 0.001 * int(1000.0*
                              0.5*(${$fitsitem}{'WVMTAUST'}+${$fitsitem}{'WVMTAUEN'})+0.5)
        if ("${$fitsitem}{'WVMTAUST'}" ne "");

#    print "$run $mode $ut \'$object\' $projid $rx $boloms $filter $csotau $seeing\n";

    # Declare formats here since it has to be in scope of the lexical variables
format NOFITS =
--------- No FITS entry for @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
$basename
.

format STDOUT_SHORT_ACS =
@<<<<< UT  Projid     Mode     Source  Intt/Stp Tau  WVM  Rx/Freq   Vel/Velsys
$origin
.

format STDOUT_LONG_ACS =
@<<<<< UT  Projid     Mode     Source  Intt/Stp Tau   WVM   Rx/Freq   Vel/Velsys   Az    El    Uaz   Uel   Bwmode
$origin
.

format SHORT_ACS =
@<< @<<<<< @<<<<<<<<< @<<<<<<< @<<<<<< @>>>/@<< @<<< @<<< @<<<<<<<< @<<<<<<<<<<<<<<<<<<<<<
$run, substr($ut,0,5), $projid, $mode, $object, $intt, $step, $csotau, $wvmtau, $cfreq, $cvref
.

format LONG_ACS =
@<< @<<<<< @<<<<<<<<< @<<<<<<< @<<<<<< @>>>/@<< @<<<< @<<<< @<<<<<<<< @<<<<<<<<<<< @<<<< @<<<< @<<<< @<<<< @<<<<<<<<<<<
$run, substr($ut,0,5), $projid, $mode, $object, $intt, $step, $lcsotau, $lwvmtau, $cfreq, $cvref, $az, $el, $uaz, $uel, $bwmode
.

    # Set format

    $= = 999;
    $^ = "STDOUT_${pformat}_ACS";
    $~ = ($mode =~ /^$/ ? "NOFITS" : $mode);

    $~ = "${pformat}_ACS" if ($~ !~ /NOFITS/);

    unless ($skip == 1) {

      if ((not $cal_only) or ($cal_only and  $projid =~ /cal/i)) {
        write if ("${run}_${ut}" ne "${prev_obs}" || ($prtall));
        print "    OCSCFG: $cfgfile  ($obstype)\n" if ($ocscfg);
      }

    }

    &acsis_tsys( $sdffile, $projid, $mode, $run, $freq ) if ($tsys or $trx);

    if ($skip == 0) {

      if ((not $cal_only) or ($cal_only and  $projid =~ /cal/i)) {

        print "---------------------------------------------------\n"
              if (($ocscfg) or ($tsys or $trx));
      }
    }

    return("${run}_${ut}");
}


# ----------------------------------------------------------------------
# Get project info from an SCUBA-2 file

sub scuba2_header {

    my ($path, $basename, $suffix, $fitsitem, $fitsitem2, $prev_obs, $pformat, $debug) = @_;
    my $sdffile = $path . '/' . $basename;
    do {foreach (keys %$fitsitem) { print "$_\n";}} if ($debug > 1);

    my $projid = "\L${$fitsitem}{'PROJECT'}";
    my $cfgfile = ${$fitsitem}{'OCSCFG'};
    my $run    = "\L${$fitsitem}{'OBSNUM'}";
    my ($date, $ut) = split(/T/, ${$fitsitem}{'DATE-OBS'});
    $date =~ s/\-/\//g;
    my $datetime = "$date $ut";

    my $obstype  = "\U${$fitsitem}{'OBS_TYPE'}";
    my $mode   = "\U${$fitsitem}{'RECIPE'}";
    $mode =~ s/REDUCE_//i;
    $mode =~ s/FIELD/FLD/i;
    $mode = "\U${$fitsitem}{'SCAN_PAT'}" if ($mode eq "SCAN");
    $mode =~ s/CURVY_PONG/CRVYPONG/i;

    my $object = "\L${$fitsitem}{'OBJECT'}";
    $object =~ s/_science//;
    my $filter  = "$fitsitem->{FILTER}";
    my $step = int(1000*${$fitsitem}{'STEPTIME'}) . "ms";

    my ($mapx, $mapy);
    my $mpx = ${$fitsitem}{'MAP_WDTH'};
    if ($mpx > 3600.0) {
      $mapx = sprintf "%4.1fd", $mpx/3600.0;
    } elsif ($mpx > 60.0) {
      $mapx = sprintf "%4.1f'", $mpx/60.0;
    } else {
      $mapx = sprintf "%2d\"", $mpx;
    }
    my $mpy = int(${$fitsitem}{'MAP_HGHT'});
    if ($mpy > 3600.0) {
      $mapy = sprintf "%4.1fd", $mpy/3600.0;
    } elsif ($mpy > 60.0) {
      $mapy = sprintf "%4.1f'", $mpy/60.0;
    } else {
      $mapy = sprintf "%2d\"", $mpy;
    }
    $mapx =~ s/^\s+//;
    $mapy =~ s/^\s+//;

    my $map = "";
    $map = sprintf "%5sx%-5s", $mapx, $mapy unless ($mpx == 0 || $mpy == 0);

    my $az     = 0.5*(${$fitsitem}{'AZSTART'}+${$fitsitem2}{'AZEND'});
    my $el     = 0.5*(${$fitsitem}{'ELSTART'}+${$fitsitem2}{'ELEND'});
    if ($az == 0 && $el == 0) {
      $az = ""; $el = "";
    }
    my $uaz    = ${$fitsitem}{'UAZ'};
    my $uel    = ${$fitsitem}{'UEL'};

    my $seeing = " n/a";
    my $csotau = " n/a";
    my $wvmtau = " n/a";
    my $lseeing = " n/a";
    my $lcsotau = " n/a";
    my $lwvmtau = " n/a";

    $seeing = 0.01 * int(100.0*
              0.5*(${$fitsitem}{'SEEINGST'}+${$fitsitem2}{'SEEINGEN'})+0.5)
              if ("${$fitsitem}{'SEEINGST'}" ne "");
    $csotau = 0.01 * int(100.0*
              0.5*(${$fitsitem}{'TAU225ST'}+${$fitsitem2}{'TAU225EN'})+0.5)
              if ("${$fitsitem}{'TAU225ST'}" ne "");
    $wvmtau = 0.01 * int(100.0*
              0.5*(${$fitsitem}{'WVMTAUST'}+${$fitsitem2}{'WVMTAUEN'})+0.5)
              if ("${$fitsitem}{'WVMTAUST'}" ne "");
    $lseeing = 0.001 * int(1000.0*
              0.5*(${$fitsitem}{'SEEINGST'}+${$fitsitem2}{'SEEINGEN'})+0.5)
              if ("${$fitsitem}{'SEEINGST'}" ne "");
    $lcsotau = 0.001 * int(1000.0*
              0.5*(${$fitsitem}{'TAU225ST'}+${$fitsitem2}{'TAU225EN'})+0.5)
              if ("${$fitsitem}{'TAU225ST'}" ne "");
    $lwvmtau = 0.001 * int(1000.0*
              0.5*(${$fitsitem}{'WVMTAUST'}+${$fitsitem2}{'WVMTAUEN'})+0.5)
              if ("${$fitsitem}{'WVMTAUST'}" ne "");

#    print "$run $mode $ut \'$object\' $projid $rx $boloms $filter $csotau $seeing\n";

    # Declare formats here since it has to be in scope of the lexical variables
format NOFITS =
--------- No FITS entry for @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
$basename
.

format SHORT_SCU2 =
@<< @<<<<< @<<<<<<<<< @<<<<<<< @<<<<<< @<<<<<<<<<<< @<<<< @<<< @<<< @<<<  @<<<<
$run, substr($ut,0,5), $projid, $mode, $object, $map, $step, $csotau, $wvmtau,$seeing, $filter
.

format LONG_SCU2 =
@<< @<<<<< @<<<<<<<<< @<<<<<<< @<<<<<< @<<<<<<<<<< @<<<< @<<<< @<<<< @<<<<  @<<<<< @<<<< @<<<< @<<<< @<<<<
$run, substr($ut,0,5), $projid, $mode, $object, $map, $step, $lcsotau, $lwvmtau, $lseeing, $filter, $az, $el, $uaz, $uel
.

format STDOUT_SHORT_SCU2 =
@<<<<< UT  Projid     Mode     Source      Map      Step  Tau  WVM  See  Fltr
$origin
.

format STDOUT_LONG_SCU2 =
@<<<<< UT  Projid     Mode     Source      Map     Step  Tau   WVM   See   Fltr    Az    El    Uaz   Uel
$origin
.

    # Set format

    $= = 999;
    $^ = "STDOUT_${pformat}_SCU2";
    $~ = ($mode =~ /^$/ ? "NOFITS" : $mode);

    $~ = "${pformat}_SCU2" if ($~ !~ /NOFITS/);

    unless ($skip == 1) {

      if ((not $cal_only) or ($cal_only and  $projid =~ /cal/i)) {
        write if ("${run}_${ut}" ne "${prev_obs}" || ($prtall));
        print "    OCSCFG: $cfgfile  ($obstype)\n" if ($ocscfg);
      }

    }

    if ($skip == 0) {

      if ((not $cal_only) or ($cal_only and  $projid =~ /cal/i)) {

        print "---------------------------------------------------\n"
              if (($ocscfg) or ($tsys or $trx));
      }
    }

    return("${run}_${ut}");
}


# ----------------------------------------------------------------------
# Get project info from a SCUBA file

sub scuba_header {

    my ($path, $basename, $suffix, $fitsitem, $prev_obs, $pformat, $debug) = @_;
    my $sdffile = $path . '/' . $basename;

    do {foreach (keys %$fitsitem) { print "$_\n";}} if ($debug >1);

    my $projid = "\L${$fitsitem}{'PROJ_ID'}";
    my $run    = "\L${$fitsitem}{'RUN'}";
    my ($yy,$mm,$dd,$rest) = split(/\:/, ${$fitsitem}{'UTDATE'}, 4);
    if ($mm < 10) {$mm = "0$mm"};
    if ($dd < 10) {$dd = "0$dd"};
    (my $h,my $m,my $s,$rest) = split(/\:/, ${$fitsitem}{'UTSTART'}, 4);
    if ($h < 10) {$h = "0$h"};
    $s = substr($s,0,5);
    my $datetime = "${yy}/${mm}/${dd} ${h}:${m}:${s}";
    $s = int($s+0.5);
    if ($s < 10) {$s = "0$s"};
    my $ut = "${h}:${m}:${s}";
    my $mode   = "\U${$fitsitem}{'MODE'}";
    my $object = "\L${$fitsitem}{'OBJECT'}";
    my $rx     = "SCUBA";
    my $n_meas = "\L${$fitsitem}{'N_MEASUR'}";
    my $n_int  = "\L${$fitsitem}{'N_INT'}";
    my $boloms = substr(${$fitsitem}{'BOLOMS'},0,10);
    my $filter = "\L${$fitsitem}{'FILTER'}";
    my $az     = 0.5*(${$fitsitem}{'STRT_AZD'}+${$fitsitem}{'END_AZD'});
    my $el     = 0.5*(${$fitsitem}{'STRT_ELD'}+${$fitsitem}{'END_ELD'});
    my $uaz    = ${$fitsitem}{'UAZ'};
    my $uel    = ${$fitsitem}{'UEL'};
    my $seeing = 0.01 * int(100.0*${$fitsitem}{'SEEING'}+0.5);
    my $csotau = 0.01 * int(100.0*${$fitsitem}{'TAU_225'}+0.5);

#    print "$run $mode $ut \'$object\' $projid $rx/$boloms/$filter/ $csotau $seeing\n";

    # Set format
format NOFITS =
--------- No FITS entry for @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
$basename
.
format STDOUT_LONG_SCU =
@<<<<< UT Mode     Projid   Source    Me/Int Tau  See  Filter    Bolometers      Az    El    Uaz   Uel
$origin
.
format STDOUT_SHORT_SCU =
@<<<<< UT Mode     Projid   Source    Me/Int Tau  See  Filter    Bolometers
$origin
.
format SHORT_SCU =
@<< @<<<< @<<<<<<< @<<<<<<< @<<<<<<<< @>/@<< @<<< @<<< @<<<<<<<< @<<<<<<<<<<<<<<<<<<<<<
$run, $ut, $mode, $projid, $object, $n_meas, $n_int, $csotau, $seeing, $filter, $boloms
.
format SHORT_NOISE =
@<< @<<<< @<<<<<<< @<<<<<<< @<<<<<<<< @>/@<< @<<< @<<< @<<<<<<<< @<<<<<<<<<<<<<<<<<<<<<
$run, $ut, $mode, $projid, $fitsitem->{'OBJ_TYPE'}, $n_meas, $n_int, $csotau, $seeing, $filter, $boloms
.

format SHORT_SKYDIP =
@<< @<<<< @<<<<<<< @<<<<<<< SKY       @>/@<< @<<< @<<< @<<<<<<<< PHOT. PIXELS
$run, $ut, $mode, $projid, $n_meas, $n_int, $csotau, $seeing, $filter
.
format LONG_SCU =
@<< @<<<< @<<<<<<< @<<<<<<< @<<<<<<<< @>/@<< @<<< @<<< @<<<<<<<< @<<<<<<<<<<<<<< @<<<< @<<<< @<<<< @<<<<
$run, $ut, $mode, $projid, $object, $n_meas, $n_int, $csotau, $seeing, $filter, $boloms, $az, $el, $uaz, $uel
.

format LONG_NOISE =
@<< @<<<< @<<<<<<< @<<<<<<< @<<<<<<<< @>/@<< @<<< @<<< @<<<<<<<< @<<<<<<<<<<<<<< @<<<< @<<<< @<<<< @<<<<
$run, $ut, $mode, $projid, $fitsitem->{'OBJ_TYPE'}, $n_meas, $n_int, $csotau, $seeing, $filter, $boloms, $az, $el, $uaz, $uel
.

format LONG_SKYDIP =
@<< @<<<< @<<<<<<< @<<<<<<< SKY       @>/@<< @<<< @<<< @<<<<<<<< PHOT. PIXELS    @<<<< @<<<< @<<<< @<<<<
$run, $ut, $mode, $projid, $n_meas, $n_int, $csotau, $seeing, $filter, $az, $el, $uaz, $uel
.


    $= = 999;
    $^ = "STDOUT_${pformat}_SCU";
    $~ = ($mode =~ /^$/ ? "NOFITS" : $mode);

    if ($~ !~ /NOFITS/) {
	if (${$fitsitem}{'MODE'} eq 'NOISE') {
	    $~ = "${pformat}_NOISE";
	} elsif (${$fitsitem}{'MODE'} eq 'SKYDIP') {
	    $~ = "${pformat}_SKYDIP";
	} else {
	    $~ = "${pformat}_SCU";
	}
    }

    unless ($skip == 1) {
      if ((not $cal_only) or ($cal_only and  $projid =~ /cal/i)) {
        write if ("${run}_${ut}" ne "${prev_obs}" || ($prtall));
      }
    }

#-----------------------------------------------------------------------
# Now try to decide whether this is a 'calibration' observation or not.
# If so, change the name to 'scuba' to make sure directory structure
# will be set up correctly.

# ----------------------------------------------------------------------
# Define non-calibration modes (rather than the other way around since
# there are only a few) and objects:

    my @obsmodes = ("PHOTOM", "MAP");
    my @calobjects = ("mars", "uranus", "neptune", "crl618", "hltau",
		   "crl2688", "irc10216", "irc+10216", "oh231.8",
		   "twhya", "vycma", "mercury", "venus",
                   "jupiter", "saturn", "pluto");

    my $calibration = ( $projid eq 'scuba' ? 1 : 0 );
    if ($calibration == 0) {
	$calibration = 1;
	foreach my $obsmode ( @obsmodes ) {
	    if ($mode eq $obsmode) {
		$calibration = 0;
		last;
	    }
	}
	if ($calibration == 0) {
	    foreach my $calobject ( @calobjects ) {
		if ($object eq $calobject) {
		    $calibration = 1;
		    last;
		}
	    }
	}
    }

    $projid = "scuba" if ($calibration == 1);

    return("${run}_${ut}");
}


# ----------------------------------------------------------------------
# Get project info from a GSD file

sub gsd_header {

    my ($path, $basename, $suffix, $prev_obs, $pformat, $debug) = @_;

    my $obsfile = $path . '/' . $basename . '.' . $suffix;

# Read the file header

    my $het_format = "";
    $het_format = "since_03a" if ($datadir =~ /\d{8}$/);

    my %gsditem;
    tie %gsditem, 'GSD', "${obsfile}";
    do {foreach (keys %gsditem) { print "$_\n";}} if ($debug > 1);

    my $projid = "\L$gsditem{'C1PID'}";
    my $run    = "\L$gsditem{'C1SNO'}";
    my $mode   = "\U$gsditem{'C6ST'}";
    my $object = "\L$gsditem{'C1SNA1'}";
    my $rx     = "\U$gsditem{'C1RCV'}";
    my $utdate = $gsditem{'C3DAT'};
    $utdate =~ s/\.//g;
    # fix silly GSD error that causes ending 0's to be stripped
    $utdate = substr("${utdate}0000",0,8);
    my $uttime = $gsditem{'C3UT'};
    my $uth    = int ($uttime);
    my $utm    = int (60.0 * ($uttime-$uth));
    my $uts    = int (3600.0 * ($uttime-($uth+$utm/60.0)));
    my $ut     = sprintf "%8s %2.2d:%2.2d",${utdate},${uth},${utm};
    my $freq;
    if ($gsditem{'C3NRS'} == 1) {     # TimJ is too clever for his own good :)
      $freq   = 0.01 * int(100.0*$gsditem{'C12RF'}+0.5);
    } else {
      $freq   = 0.01 * int(100.0*${$gsditem{'C12RF'}}[0]+0.5);
    }
    my $cfreq  = "${rx}/$freq";
    my $vel    = 0.01 * int(100.0*$gsditem{'C7VR'}+0.5);
    my $cvref = "$vel" . "/" . substr("\L$gsditem{'C12VDEF'}",0,3) .
	"\L$gsditem{'C12VREF'}";
    my $n_meas = "\L$gsditem{'C3CL'}";
    my $n_int  = "\L$gsditem{'C3NCYCLE'}";
    my $az     = $gsditem{'C4AZ'};
    my $el     = $gsditem{'C4EL'};
    my $uaz    = $gsditem{'UAZ'};
    my $uel    = $gsditem{'UEL'};
    my $seeing = 0.01 * int(100.0*$gsditem{'C7SEEING'}+0.5);
    my $csotau = 0.01 * int(100.0*$gsditem{'C7TAU225'}+0.5);

    # Set format
format NOFITS =
--------- No FITS entry for @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
$basename
.

format STDOUT_SHORT_HET =
@<<<<<<<< UT       Mode     Source   Sec/Cyc Tau  See  Rx/Freq   Vel/Velsys
$origin
.

format STDOUT_SHORT_HET2 =
@<<<<< UT  Projid     Mode     Source   Sec/Cyc Tau  See  Rx/Freq   Vel/Velsys
$origin
.

format STDOUT_LONG_HET =
@<<<<<<<< UT       Mode     Source   Sec/Cyc Tau  See  Rx/Freq   Vel/Velsys   Az    El    Uaz   Uel
$origin
.

format STDOUT_LONG_HET2 =
@<<<<< UT  Projid     Mode     Source   Sec/Cyc Tau  See  Rx/Freq   Vel/Velsys   Az    El    Uaz   Uel
$origin
.

format SHORT_HET =
@<< @<<<<<<<<<<<<< @<<<<<<< @<<<<<<<< @>/@<< @<<< @<<< @<<<<<<<< @<<<<<<<<<<<<<<<<<<<<<
$run, $ut, $mode, $object, $n_meas, $n_int, $csotau, $seeing, $cfreq, $cvref
.

format SHORT_HET2 =
@<< @<<<<< @<<<<<<<<< @<<<<<<< @<<<<<<<< @>/@<< @<<< @<<< @<<<<<<<< @<<<<<<<<<<<<<<<<<<<<<
$run, substr($ut,9,5), $projid, $mode, $object, $n_meas, $n_int, $csotau, $seeing, $cfreq, $cvref
.

format LONG_HET =
@<< @<<<<<<<<<<<<< @<<<<<<< @<<<<<<<< @>/@<< @<<< @<<< @<<<<<<<< @<<<<<<<<<<< @<<<< @<<<< @<<<< @<<<<
$run, $ut, $mode, $object, $n_meas, $n_int, $csotau, $seeing, $cfreq, $cvref, $az, $el, $uaz, $uel
.

format LONG_HET2 =
@<< @<<<<< @<<<<<<<<< @<<<<<<< @<<<<<<<< @>/@<< @<<< @<<< @<<<<<<<< @<<<<<<<<<<< @<<<< @<<<< @<<<< @<<<<
$run, substr($ut,9,5), $projid, $mode, $object, $n_meas, $n_int, $csotau, $seeing, $cfreq, $cvref, $az, $el, $uaz, $uel
.

    $= = 999;
    if ($het_format eq 'since_03a') {
      $^ = "STDOUT_${pformat}_HET2";
    } else {
      $^ = "STDOUT_${pformat}_HET";
    }
    $~ = ($mode =~ /^$/ ? "NOFITS" : $mode);

    if ($~ !~ /NOFITS/) {
      if ($het_format eq 'since_03a') {
        $~ = "${pformat}_HET2";
      } else {
        $~ = "${pformat}_HET";
      }
    }

    unless ($skip == 1) {
      if ((not $cal_only) or ($cal_only and  $projid =~ /cal/i)) {
        write if ("${run}_${ut}" ne "${prev_obs}" || ($prtall));
      }
    }

    return("${run}_${ut}");
}


# ----------------------------------------------------------------------
# Get ACSIS tsys and trx

sub acsis_tsys {

  my $REC_HEADER_DONE;
  my ($sdffile, $projid, $mode, $run, $freq ) = @_;

  if ((not $cal_only) or ($cal_only and  $projid =~ /cal/i)) {

    unless ($mode eq "POINTING" or $mode eq "FOCUS") {

      my $obsnr     = "";
      my $obslab    = "";
      my $datestamp = "";
      my $rfreq = "";
      my $rflab = "";

      if ($skip) {
        $obsnr     = "$run";
        $obslab    = "Nr";
        $datestamp = "${origin}";
        $rfreq     = sprintf("%5.1f",$freq);
        $rflab     = sprintf("%5.5s","RFreq");
      }

      if ($tsys) {
        my @tsys_all = split(/\n/,
           `${tsyscmd} -statistics ${sdffile} | grep '[A-z]'`);
        $tsys_all[1] =~ s/\[median\]/\[Tsys\]/;
        $tsys_all[3] =~  s/\[stdev\]/\[ \+\/\-\]/;

        unless (defined $REC_HEADER_DONE) {
          printf "%-3s %s %s %6s\n", $obslab,$rflab, $tsys_all[0], $datestamp;
          $REC_HEADER_DONE = 1;
        }
        printf "%-3s %s %s\n", $obsnr, $rfreq, $tsys_all[1];
        printf "%-3s %s %s\n", $obsnr, $rfreq, $tsys_all[3] if ($tsysrms);

      }

      if ($trx) {
        my @trx_all =  split(/\n/,
           `${tsyscmd} -trx -statistics ${sdffile} | grep '[A-z]'`);
        $trx_all[1] =~ s/\[median\]/\[Trx\]/;
        $trx_all[3] =~  s/\[stdev\]/\[ \+\/\-\]/;

        unless (defined $REC_HEADER_DONE) {
          printf "%-3s %s %s %6s\n", $obslab,$rflab, $trx_all[0], $datestamp;
          $REC_HEADER_DONE = 1;
        }
        printf "%-3s %s %s\n", $obsnr, $rfreq, $trx_all[1];
        printf "%-3s %s %s\n", $obsnr, $rfreq, $trx_all[3] if ($trxrms);
      }

      $REC_HEADER_DONE = undef unless ($skip);

    }

  }

}

=head1 AUTHOR

Remo Tilanus E<lt>r.tilanus@jach.hawaii.eduE<gt>,
Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>

=head1 COPYRIGHT

Copyright (C) 2006-2007 Particle Physics and Astronomy Research Council.
Copyright (C) 2007-2010 Science and Technology Facilities Council.
All Rights Reserved.

=head1 LICENCE

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful,but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place,Suite 330, Boston, MA  02111-1307, USA

=cut
