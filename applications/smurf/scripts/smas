#!/bin/tcsh

#  Check a list of observations has been supplied on the command line.
if( $# < 1 ) then
   echo
   echo "Short Map Analysis Script"
   echo
   echo "Usage: smas <in-list> <out-table> <out-image>"
   echo
   echo "   <in-list> is a text file in which each line contains the path"
   echo "   to an NDF holding a SCUBA-2 map of a point source. If an NDF"
   echo "   contains a MORE.SMURF.SHORTMAPS or MORE.SMURF.BOLOMAPS extension"
   echo "   item, then the NDFs in the SHORTMAPS or BOLOMAPS array are used"
   echo "   in place of the supplied NDF (SHORTMAPS is used in preference to"
   echo "   BOLOMAPS if both are present)."
   echo
   echo "   <out-table> is the name of a text file in which to store a"
   echo "   catalogue containing details of the source in each supplied map,"
   echo "   as described below. This catalogue can be displayed and analysed"
   echo "   using 'topcat -f ascii <out-table>'."
   echo
   echo "   If <out-image> is supplied, and if the input data contains bolomaps, a 2D"
   echo "   NDF containing the fsum values for each bolometer is created, with the "
   echo "   name given by <out-image>."
   echo
   echo "   With the exception of moon maps, each NDF is processed in the same way."
   echo "   The KAPPA:PSF command is used to locate the accurate source centre and "
   echo "   fit it using an elliptical Gaussian-like model. The details of the model"
   echo "   are then appended to an output text file as a new row."
   echo
   echo "   The resulting output catalogue has a row for every input NDF, and contains"
   echo "   the following columns:"
   echo "   - TAI: The MJD (in the TAI timescale) associated with the NDF"
   echo "   - UTC: The UTC date and time string associated with the NDF"
   echo "   - SEQSTART - RTS index number of first frame"
   echo "   - SEQEND - RTS index number of last frame"
   echo "   - XCEN: The X pixel co-ordinate at the centre of the source"
   echo "   - YCEN: The Y pixel co-ordinate at the centre of the source"
   echo "   - AMP: The peak value in the source"
   echo "   - SUM: The total data sum in the source. This is the integral"
   echo "   of the Gaussian-like model calculated by KAPPA:PSF"
   echo "   - FWHM: The seeing-disc size: the full width at half maximum "
   echo "   across the minor axis of the source (arc-seconds)"
   echo "   - AXISR: The axis ratio of the source: the ratio of the major"
   echo "   axis length to that of the minor axis."
   echo "   - GAMMA: The radial fall-off parameter of the source. A gamma "
   echo "   of two would be a Gaussian."
   echo "   - ORIENT: The position angle (measured from north through east)"
   echo "   of the major axis of the source, in degrees."
   echo "   - NDF: The path to the NDF"
   echo "   - ROW: The row number for the bolometer (if known)
   echo "   - COL: The column number for the bolometer (if known)
   echo
   echo "   For comparison, a set of extra columns is appended to these "
   echo "   that give the source properties as calculated by KAPPA:BEAMFIT"
   echo "   rather than KAPPA:PSF. These columns have the same names, but "
   echo "   are prefixed by the letter B. Note, BEAMFIT assumes a gamma "
   echo "   value of 2.0  (i.e. a pure Gaussian) and so there is no BGAMMA"
   echo "   column in the output catalogue."
   echo
   echo "   The SEQSTART and SEQEND columns will be set to 'null' if the "
   echo "   supplied map does not contain these FITS headers."
   echo
   echo "   If the supplied data is for the moon, then all the above is ignored and the
   echo "   output contains the following columns:"
   echo "   - SUM: The integrated value within a 35 arc-minute aperture centred on (0,0)
   echo "   - ROW: The row number for the bolometer (if known)
   echo "   - COL: The column number for the bolometer (if known)
   echo
   exit
endif

# Ensure we can redirect output safely
unset noclobber

#  Ensure ADAM tasks fail rather than prompt for parameter values
setenv ADAM_NOPROMPT 1

#  Check we have enough command line arguments.
if( $# < 2 ) then
   echo "Usage: smas <in-list> <out-table>"
   exit
endif

# Check the input file exists
if( ! -e "$1" ) then
   echo "Input file not found: $1"
   exit
endif

#  See if an output image is required.
if( $# > 2 ) then
   set outimg = $3
else
   set outimg = " "
endif

# Check the remaining options (NOTE THE -p OPTION IS CURRENTLY IGNORED
# BECAUSE OF A BUG IN ARD - KAPPA:PSF IS ALWAYS USED)
set sum_method = APERADD
if( $# == 4 ) then
   if( "$4" == "-p" ) then
      set sum_method = PSF
   else
      echo "Unknown command line option - $4"
      exit
   endif
else if( $# > 4 ) then
   echo "Too many command line arguments"
endif

# Delete any existing output catalogue.
if( -e "$2" ) then
   rm -f $2
   if( -e "$2" ) then
      exit
   endif
endif

# Check no files are left over from previous runs
rm -f files.smas >& /dev/null

# First task is get a complete list of all the NDFs to be processed,
# substituting shortmap/bolomap names for their parent NDF name. Loop round
# each NDF in the input text file
set moon = 0
set sar = -1
set negative = -1
set bolomaps = 0
foreach n (`cat $1`)

# Ensure there is no ".sdf" on the end of the NDF name.
   set dir = `dirname $n`
   set base = `basename $n .sdf`
   set in = "$dir/$base"
   if( ! -e "$in.sdf" ) then
      echo "Cannot find $in.sdf"
      exit
   endif

#  See this is a map of the moon.
   set object = `$KAPPA_DIR/fitsmod $in edit=print keyword=OBJECT`
   if( $object == MOON ) then
      set moon = 1
   endif

#  Get the subarray name, and its corresponding integer index.
   set subarray = `$KAPPA_DIR/fitsmod $in edit=print keyword=SUBARRAY`
   if( $subarray == "s8a" ) then
      set array = 0
   else if( $subarray == "s8b" ) then
      set array = 1
   else if( $subarray == "s8c" ) then
      set array = 2
   else if( $subarray == "s8d" ) then
      set array = 3
   else if( $subarray == "s4a" ) then
      set array = 4
   else if( $subarray == "s4b" ) then
      set array = 5
   else if( $subarray == "s4c" ) then
      set array = 6
   else if( $subarray == "s4d" ) then
      set array = 7
   else
      echo "Unknown subarray - $subarray"
      exit
   endif

#  Check all the data is for the same wavelength.
   if( $sar == -1 ) then
      set sar = $array
   else
      if( $subarray != $sar ) then
         echo "$n is for subarray $subarrray, which is not the same as the first NDF"
         exit
      endif
   endif

#  See if the data has been flat-fielded (as implied by the map units being "pW"). If not,
#  the source features will be negative in the bolomaps.
   $KAPPA_DIR/ndftrace $in quiet
   set units = `$KAPPA_DIR/parget UNITS ndftrace`
   if( $negative == -1 ) then
      set units_old = $units
      if( "$units" == "pW" ) then
         set negative = 0;
      else
         set negative = 1;
      endif

   else if( "$units" != "$units_old" ) then
      echo "$n has units $units, which is not the same as the first NDF ($units_old)"
      exit

   endif

# See if the current NDF contains a list of shortmaps, and if so, how many.
   $HDSTRACE_DIR/hdstrace $in.more.smurf.shortmaps | grep "<NDF>" >& log.smas
   set text = `wc log.smas`
   set nmap = $text[1]

# First deal with NDFs containing shortmaps....
   if( $nmap > 0 ) then

# Write the full paths of the shortmaps (contained in column 1 of log.smas)
# out to a temp file
      foreach name (`cat log.smas | awk '{print $1}'`)
         echo "$in.more.smurf.shortmaps.$name" >> files.smas
      end

#  No output image can be created.
      set outimg = " "

# Now deal with NDF that do not contain shortmaps....
   else

# See if the current NDF contains a list of bolomaps, and if so, how many.
      $HDSTRACE_DIR/hdstrace $in.more.smurf.bolomaps | grep "<NDF>" >& log.smas
      set text = `wc log.smas`
      set nmap = $text[1]

# Now deal with NDFs containing bolomaps....
      if( $nmap > 0 ) then
         set bolomaps = 1

# Write the full paths of the bolomaps (contained in column 1 of log.smas)
# out to a temp file
         foreach name (`cat log.smas | awk '{print $1}'`)
            echo "$in.more.smurf.bolomaps.$name" >> files.smas
         end

# Now deal with NDF that do not contain shortmaps....
      else

# Just append the NDF path to the temp file.
         echo "$in" >> files.smas

#  No output image can be created.
         set outimg = " "
      endif
   endif
end

#  Create the line holding the column names in the output catalogue.
if( $moon == 0 ) then
   echo "# TAI UTC SEQSTART SEQEND XCEN YCEN AMP SUM FWHM AXISR GAMMA ORIENT NDF BXCEN BYCEN BAMP BSUM BFWHM BAXISR BORIENT ROW COL" > $2
   set xcol = 21
   set ycol = 22
   set valcol = 8
else
   echo "# SUM ROW COL" > $2
   set xcol = 2
   set ycol = 3
   set valcol = 1
endif

# Next loop round all the NDFs to be processed.
foreach n (`cat files.smas`)
   echo "Doing $n"

#  For bolomaps, get the row and column name from the NDF name. Record the max and min row and
#  column index.
   if( $bolomaps == 1 ) then
      set rc = `echo $n | sed -e 's/.*C\([0-9]\{2\}\)R\([0-9]\{2\}\)/\1 \2/'`
      set row = `echo $rc[1] | sed -e 's/0\([0-9]\)/\1/'`
      set col = `echo $rc[2] | sed -e 's/0\([0-9]\)/\1/'`
   else
      set row = null
      set col = null
   endif

# First handle all maps except those of hte Moon.
   if( $moon == 0 ) then

# Create a temp copy of the NDF so we can change it.
      $KAPPA_DIR/ndfcopy $n'(0~30,0~30)'  temp-smas
      set ndf = temp-smas

#  From here on, use offset sky coords to refer to positions within the map.
      $KAPPA_DIR/wcsattrib $ndf set skyrefis origin

#  Ensure formatted axis values are decimal arc-seconds.
      $KAPPA_DIR/wcsattrib $ndf set 'format(1)' s.2
      $KAPPA_DIR/wcsattrib $ndf set 'format(2)' s.2

#  If source features are negative in the shortmap/bolomap, negate the map
#  so that they become positive.
      if( $negative == 1 ) then
         $KAPPA_DIR/cmult $ndf -1 pos-smas
         set ndf = "pos-smas"
      endif

#  Find the offset sky coords at the centre of the feature. The feature is
#  nominally at the reference point and so should, in the absence of errors,
#  have coords (0.0,0.0). PSF fails unless a good central position is
#  supplied, so first find the peak value in a box centred on (0,0)
      $KAPPA_DIR/stats $ndf quiet
      set maxco = `$KAPPA_DIR/parget maxwcs stats`
      rm -f coin.smas > /dev/null
      echo $maxco > coin.smas

#  Check there are some good pixels
      set numgood = `$KAPPA_DIR/parget numgood stats`
      if( $numgood == 0 ) then
         echo "  no good data found"
         continue
      endif

#  Determine the source parameters using kappa:beamfit
      $KAPPA_DIR/beamfit $ndf mode=file coin=coin.smas  | grep \!\! >& /dev/null
      if( $status == 1 ) then
         set centre = `$KAPPA_DIR/parget centre beamfit`
         set bxcen = $centre[1]
         set bycen = $centre[2]
         set bamp = `$KAPPA_DIR/parget amp beamfit`
         set bamp = $bamp[1]
         set bsum = `$KAPPA_DIR/parget sum beamfit`
         set bfwhm = `$KAPPA_DIR/parget minfwhm beamfit`
         set bfwhm = $bfwhm[1]
         set majfwhm = `$KAPPA_DIR/parget majfwhm beamfit`
         set majfwhm = $majfwhm[1]
         set baxisr = `$KAPPA_DIR/calc exp="pa/pb" pa=$majfwhm pb=$bfwhm`
         set borient = `$KAPPA_DIR/parget orient beamfit`
         set borient = $borient[1]

#  Scale beamfit FWHM from radians to arc-seconds (we can't just change the
#  Format attribue since beamfit writes the fwhm out as a double rather than
#  as a string)
         set bfwhm = `$KAPPA_DIR/calc exp="3600*180*pa/3.1415926536" pa=$bfwhm`

      else
         echo "  beamfit failure"
         set bxcen = null
         set bycen = null
         set bamp = null
         set bsum = null
         set bfwhm = null
         set baxisr = null
         set borient = null
      endif

# PSF is also sensitive to low-level background structure, so threshold
# the data at 5% of the peak value to exclude background regions.
      set maxv = `$KAPPA_DIR/parget maximum stats`
      set cut = `$KAPPA_DIR/calc exp="pa*0.05" pa=$maxv`
      $KAPPA_DIR/thresh in=$ndf out=cut-smas thrlo=$cut newlo=bad thrhi=1.0E10 \
                        newhi=bad quiet
      set ndf = cut-smas

#  Find the size of the region containing the remaining good values.
      $KAPPA_DIR/ndfcopy $ndf temp-smas trimbad
      $KAPPA_DIR/ndftrace temp-smas quiet
      set dim1 = `$KAPPA_DIR/parget dims\(1\) ndftrace`
      set dim2 = `$KAPPA_DIR/parget dims\(2\) ndftrace`
      if( $dim1 > $dim2 ) then
         set isize = $dim1
      else
         set isize = $dim2
      endif

#  Ensure the size is odd since PSF reports an error is supplied an even
#  ISIZE value.
      set isize = `$KAPPA_DIR/calc exp="1+2*nint(pa/2-0.1)" pa=$isize`

#  Determine the source parameters using kappa:psf
      $KAPPA_DIR/psf $ndf incat=! cofile=coin.smas isize=$isize norm=f device=! | grep \!\! >& /dev/null

#  Check a psf was found succesfully.
      if( $status == 1 ) then

#  Get the parameters of the psf.
         set amp = `$KAPPA_DIR/parget amp1 psf`
         set posxy = `$KAPPA_DIR/parget centre psf`
         set axisr = `$KAPPA_DIR/parget axisr psf`
         set fwhm = `$KAPPA_DIR/parget fwhm psf`
         set orient = `$KAPPA_DIR/parget orient psf`
         set gamma = `$KAPPA_DIR/parget gamma psf`

#  Get the total data sum. Two methods - 1) aperture photometry...
#  NOTE - there is a bug in the ARD library that causes APERADD to fail
#  if the current Frame is an offset SKY Frame. Until this bug is fixed,
#  always use KAPPA:PSF to determine the SUM value.
         if( $sum_method == THIS_SHOULD_BE_SIMPLY_APERADD ) then

#  Choose the aperture size in pixels (60 arc-secs assuming default makemap pixel sizes of 2
#  and 4 arc-seconds)..
            if( $sar > 3 ) then
               set diam = 30
            else
               set diam = 15
            endif

#  Replace any bad pixels within a box centred on the max pixel with sides twice
#  the above diameter.
            @ size = $diam + $diam
            $KAPPA_DIR/fillbad in=$ndf\($maxco[1]~$size,$maxco[2]~$size\) size=2 out=filled-smas | grep \!\! >& /dev/null

#  Do the aperture photometry within the filled image. Check some bad pixels
#  were filled. If not, use $ndf instead of "filled-smas".
            if( $status == 1 ) then
               $KAPPA_DIR/aperadd filled-smas centre="'$posxy'" diam=$diam quiet
            else
               $KAPPA_DIR/aperadd $ndf centre="'$posxy'" diam=$diam quiet
            endif
            set fsum = `$KAPPA_DIR/parget total aperadd`

#  Alternatively - 2) use the integral of the model PSF as the souce total data sum.
         else
            set fsum = `$KAPPA_DIR/parget total psf`
         endif

#  Get the sequence number at start and end, if possible
         set seqstart = `$KAPPA_DIR/fitsmod $ndf edit=print keyword=SEQSTART`
         echo $seqstart | grep "does not exist" >& /dev/null
         if( $status != 1 ) then
            set seqstart = null
         endif

         set seqend = `$KAPPA_DIR/fitsmod $ndf edit=print keyword=SEQEND`
         echo $seqend | grep "does not exist" >& /dev/null
         if( $status != 1 ) then
            set seqend = null
         endif

#  If possible get the MJD-AVG and TIMESYS FITS headers (shortmaps should have both of these).
         set mjdavg = `$KAPPA_DIR/fitsmod $ndf edit=print keyword=MJD-AVG`
         echo $mjdavg | grep "does not exist" >& /dev/null
         if( $status != 1 ) then
            set mjdavg = null
            set timesys = null
         else
            set timesys = `$KAPPA_DIR/fitsmod $ndf edit=print keyword=TIMESYS`
            echo $timesys | grep "does not exist" >& /dev/null
            if( $status != 1 ) then
               set mjdavg = null
               set timesys = null
            endif
         endif

#  If we have an MJD-AVG, store it as the TimeOrigin value in a TimeFrame.
         $ATOOLS_DIR/asttimeframe options='system=mjd' result=tf
         if( $mjdavg != null ) then
            $ATOOLS_DIR/astset tf timescale $timesys result=tf
            $ATOOLS_DIR/astset tf timeorigin $mjdavg result=tf

# If we do not have an MJD-AVG value, get the epoch from the WCS FrameSet, and
# store it as the TimeOrigin value in a TimeFrame.
         else
            $ATOOLS_DIR/astset tf system JEPOCH result=tf
            $ATOOLS_DIR/astset tf timescale TDB result=tf
            set tdb = `$ATOOLS_DIR/astget $ndf epoch`
            $ATOOLS_DIR/astset tf timeorigin $tdb result=tf
            $ATOOLS_DIR/astset tf system MJD result=tf
         endif

#  Convert the TimeFrame to TAI timescale and get the converted TimeOrigin value.
         $ATOOLS_DIR/astset tf timescale TAI result=tf
         set tai = `$ATOOLS_DIR/astget tf timeorigin`

#  Covert the TimeFrame to UTC timescale and get the converted TimeOrigin value.
         $ATOOLS_DIR/astset tf timescale UTC result=tf
         set utc = `$ATOOLS_DIR/astget tf timeorigin`

#  Set the TimeFrame Format to ISO and get the UTC date-time string.
         $ATOOLS_DIR/astset tf format iso.2T result=tf
         set date = `$ATOOLS_DIR/astformat tf axis=1 value=0.0`

#  Write a row to the output catalogue.
         echo "$tai $date $seqstart $seqend $posxy[1] $posxy[2] $amp $fsum $fwhm $axisr $gamma $orient $n $bxcen $bycen $bamp $bsum $bfwhm $baxisr $borient $row $col" >> $2

#  Report any PSF failure.
      else
         echo "  psf failure"
      endif

#  Now handle maps of the Moon.
   else

# Create a temp copy of the whole NDF so we can change it.
      $KAPPA_DIR/ndfcopy $n  temp-smas
      set ndf = temp-smas

#  From here on, use offset sky coords to refer to positions within the map.
      $KAPPA_DIR/wcsattrib $ndf set skyrefis origin

#  Ensure formatted axis values are decimal arc-seconds.
      $KAPPA_DIR/wcsattrib $ndf set 'format(1)' s.2
      $KAPPA_DIR/wcsattrib $ndf set 'format(2)' s.2

#  If source features are negative in the shortmap/bolomap, negate the map
#  so that they become positive.
      if( $negative == 1 ) then
         $KAPPA_DIR/cmult $ndf -1 pos-smas
         set ndf = "pos-smas"
      endif

# Find the integrated value in a circular aperture centred on the nominal
# target position (0,0). Make the aperture (35 arcmins) a little bigger than
# needed in order to allow for small variations in the size of the moon.
      $KAPPA_DIR/aperadd $ndf centre="'0,0'" diam="0:35:00" quiet
      set fsum = `$KAPPA_DIR/parget total aperadd`

#  Write a row to the output catalogue.
      echo "$fsum $row $col" >> $2

   endif

end

# If an output image is required, create it from the output catalogue.
if( "$outimg" != " " ) then
   $KAPPA_DIR/trandat freename=$2 poscols="[$xcol,$ycol]" valcol=$valcol auto=no ndf=$outimg
endif

# Clean up.
rm -f back.sdf files.smas log.smas cut-smas.sdf coin.smas temp-smas.sdf pos-smas.sdf filled-smas.sdf >& /dev/null


