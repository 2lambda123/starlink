#!/star/Perl/bin/perl

=head1 NAME

jcmtstate2cat - convert JCMT state structure into TST format

=head1 SYNOPSIS

  jcmtstate2cat *.sdf
  jcmtstate2cat *.sdf > state.tst

=head1 DESCRIPTION

Reads a set of SCUBA-2 or ACSIS files and writes a catalogue of the state information
to standard out. The output file is in TST format and can be read into the
TOPCAT application (but may require that TOPCAT is told explicitly that
the catalogue is in TST format, e.g. with the "-f tst" command line option).

This information includes the telescope pointing position (Actual, Demand and Base)
in both the tracking system and AZEL coordinate frames, jiggle patterns, telescope
row/offset index amongst others.

=head1 OPTIONS

The following options are supported:

=over 4

=item B<-help>

Print help information.

=item B<-version>

Print version information.

=item B<-man>

Print the full documentation to STDOUT.

=back

=head1 NOTES

Four columns are generated in addition to writing the simple contents
of the JCMT state structure. "ra" and "dec" contain the tracking
coordinates taking into account jiggle and chop (noting that if the
tracking system is GALACTIC the columns will still be called "ra" and
"dec"). "az" and "el" contain the (moving) azimuth and elevation
taking into account telescope and secondary movement. "daz" and "del"
contain the azimuth and elevation of the observation taking account of
jiggling and chopping but referenced back to the base position for the
beginning of the observation. Note that jiggle and chop offsets are
added onto the actual AZEL coordinates (TCS_AZ_AC1 and TCS_AZ_AC2)
without attempting to convert them to RA/Dec first. This means that
the values may not correspond to a simple rotation relative to the
"ra" and "dec" values if the jiggle coordinate system is AZEL. If the
jiggle coordinate system is TRACKING then the coordinates will be
related by a simple rotation.

Note that information from the ACSIS extension is not included at this
time. This is partly because this extension can change in shape
between observations.

=cut

use strict;
use warnings;
use NDF;
use Astro::Coords::Angle::Hour;
use Astro::SLA;

use Getopt::Long;
use Pod::Usage;
use JSA::Headers ();

my ($help, $man, $version);
my $ostatus = GetOptions( "help" => \$help,
                          "man" => \$man,
                          "version" => \$version
                        );
pod2usage(1) if $help;
pod2usage(-exitstatus => 0, -verbose =>2) if $man;
if ($version) {
  my $id = '$Id$';
  print "jcmtstate2cat - convert JCMT State information to catalog\n";
  exit;
}


my @files = @ARGV;

my %DATA;
my $status = &NDF::SAI__OK;
my $isfirst = 1;
my $isfirst_file = 1;
my @columns;
my %cols;

my $base_az; # First AZEL Base position for use as reference for az and el columns
my $base_el;

err_begin($status );
for my $f (@files) {

  # Read JCMTSTATE information
  my %local = JSA::Headers::read_jcmtstate( $f );

  if ($isfirst) {
    # Lose ordering associated with the file but since
    # all sections share subsystem prefix then we will
    # not be grossly out of order
    @columns = sort keys %local;
    %cols = map { $_, undef } @columns;
    $isfirst = 1;
  }

  # now dump the contents
  if ($isfirst_file) {
    print "# This is a TST formatted file\n";
    print join("\t", "Id", "RA", "DEC", "DAZ","DEL", "AZ", "EL", @columns) ,"\n";
    print join("\t", map { "--" } (0..($#columns+3))),"\n";
    $isfirst_file = 0;
  }

  for my $i ( 0 .. $#{$local{RTS_NUM}} ) {
    my @slice;

    # Use the RTS sequence number as the ID
    push(@slice, $local{RTS_NUM}->[$i]);

    # Check for bad values
    my $isokay = 1;
    for my $key (qw/ TCS_TR_AC1 TCS_TR_AC2 SMU_TR_JIG_X SMU_TR_JIG_Y
                     SMU_TR_CHOP_X SMU_TR_CHOP_Y / ) {
      if ($local{$key}->[$i] == &NDF::VAL__BADD()) {
        $isokay = 0;
        last;
      }
    }

    # Now calculate the RA,Dec of the field centre in tracking coordinates
    # taking the chop and jiggle into account
    my ($ra, $dec) = (&NDF::VAL__BADD(), &NDF::VAL__BADD() );
    if ($isokay) {
      my $rabase = $local{TCS_TR_AC1}->[$i];
      my $decbase = $local{TCS_TR_AC2}->[$i];
      my $xoffset = $local{SMU_TR_JIG_X}->[$i] + $local{SMU_TR_CHOP_X}->[$i];
      my $yoffset = $local{SMU_TR_JIG_Y}->[$i] + $local{SMU_TR_CHOP_Y}->[$i];
      $xoffset *= Astro::SLA::DAS2R;
      $yoffset *= Astro::SLA::DAS2R;

      Astro::SLA::slaDtp2s( $xoffset, $yoffset, $rabase, $decbase, $ra, $dec );
      $ra = Astro::Coords::Angle::Hour->new( $ra )->degrees;
      $dec = Astro::Coords::Angle->new($dec)->degrees;
    }
    push(@slice, $ra, $dec );

    # Check for bad values
    $isokay = 1;
    for my $key (qw/ TCS_AZ_AC1 TCS_AZ_AC2 SMU_AZ_JIG_X SMU_AZ_JIG_Y
                     TCS_AZ_BC1 TCS_AZ_BC2 SMU_AZ_CHOP_X SMU_AZ_CHOP_Y / ) {
      if ($local{$key}->[$i] == &NDF::VAL__BADD()) {
        $isokay = 0;
        last;
      }
    }

    # Now calculate "az" and "el" and "daz" and "del". Complication
    # here for daz/del is that we calculate the position after taking
    # out the motion due to the telescope base position changing. Note
    # that there is no rotation because we do not first convert each
    # position to RA/Dec and then back to AZEL.
    my ($az, $el) = (&NDF::VAL__BADD(), &NDF::VAL__BADD() );
    my ($daz,$del) = ($az, $el);
    if ($isokay) {

      # Store the BASE AZEL position for later - first few could be bad but we
      # know they are good in here
      $base_az = $local{TCS_AZ_BC1}->[$i] unless defined $base_az;
      $base_el = $local{TCS_AZ_BC2}->[$i] unless defined $base_el;

      my $actual_az_diff = $local{TCS_AZ_AC1}->[$i] - $local{TCS_AZ_BC1}->[$i];
      my $actual_el_diff = $local{TCS_AZ_AC2}->[$i] - $local{TCS_AZ_BC2}->[$i];
      my $this_az_base = $base_az + $actual_az_diff;
      my $this_el_base = $base_el + $actual_el_diff;

      my $xoffset = $local{SMU_AZ_JIG_X}->[$i] + $local{SMU_AZ_CHOP_X}->[$i];
      my $yoffset = $local{SMU_AZ_JIG_Y}->[$i] + $local{SMU_AZ_CHOP_Y}->[$i];
      $xoffset *= Astro::SLA::DAS2R;
      $yoffset *= Astro::SLA::DAS2R;

      # az and el are not corrected for base position
      Astro::SLA::slaDtp2s( $xoffset, $yoffset,
                            $local{TCS_AZ_AC1}->[$i], $local{TCS_AZ_AC2}->[$i], $az, $el );
      $az = Astro::Coords::Angle->new( $az )->degrees;
      $el = Astro::Coords::Angle->new( $el )->degrees;

      # daz and del are corrected for base position
      Astro::SLA::slaDtp2s( $xoffset, $yoffset, $this_az_base, $this_el_base, $daz, $del );
      $daz = Astro::Coords::Angle->new( $daz )->degrees;
      $del = Astro::Coords::Angle->new( $del )->degrees;

    }

    push(@slice, $daz, $del, $az, $el );


    # And append the remaining columns
    for my $col (@columns) {
      push(@slice, $local{$col}->[$i]);
    }
    print join("\t",@slice)."\n";
  }
}
err_end( $status );



=head1 AUTHOR

Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>

Copyright (C) 2007 Particle Physics and Astronomy Research Council.
Copyright (C) 2007-2009 Science and Technology Facilities Council.
All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful,but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place,Suite 330, Boston, MA  02111-1307, USA

=cut
