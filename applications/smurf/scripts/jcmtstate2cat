#!/star/Perl/bin/perl

=head1 NAME

jcmtstate2cat - convert JCMT state structure into NDF format

=head1 SYNOPSIS

  jmctstate2cat *.sdf

=head1 DESCRIPTION

Just reads a set of files and writes a cataologue of the state information
to standard out. The output file is in TST format and can be read into the
TOPCAT application (but may require that TOPCAT is told explicitly that
the catalogue is in TST format).

=head1 OPTIONS

The following options are supported:

=over 4

=item B<-help>

Print help information.

=item B<-version>

Print version information.

=item B<-man>

Print the full documentation to STDOUT.

=back

=cut

use strict;
use warnings;
use NDF;
use Astro::Coords::Angle::Hour;
use Astro::SLA;

use Getopt::Long;
use Pod::Usage;

my ($help, $man, $version);
my $ostatus = GetOptions( "help" => \$help,
			 "man" => \$man,
			 "version" => \$version
			 );
pod2usage(1) if $help;
pod2usage(-exitstatus => 0, -verbose =>2) if $man;
if ($version) {
    my $id = '$Id$';
    print "jcmtstate2cat - convert JCMT State information to catalog\n";
    print " CVS revision: $id\n";
    exit;
}


my @files = @ARGV;

my %DATA;
my $status = &NDF::SAI__OK;
my $isfirst = 1;
my $isfirst_file = 1;
my @columns;
my %cols;
err_begin($status );
for my $f (@files) {
    # just open with HDS
    my $status = &NDF::SAI__OK;
    hds_open( $f, "READ", my $loc, $status);
    dat_find( $loc, "MORE", my $mloc, $status);
    dat_find( $mloc, "JCMTSTATE", my $jloc, $status);
    dat_annul( $mloc, $status);

    # find out how many extensions we have
    dat_ncomp( $jloc, my $ncomp, $status );

    # if first time round, get the names for columns
    if ($isfirst) {
	for my $i (1..$ncomp) {
	    dat_index( $jloc, $i, my $iloc, $status );
	    dat_name( $iloc, my $name, $status);
	    next if $name eq 'RTS_TASKS';
	    dat_annul( $iloc, $status );
	    push(@columns, $name);
	}
	$isfirst = 0;
	%cols = map { $_, undef } @columns;
    }

    my %local;
    for my $i (1..$ncomp) {
	dat_index( $jloc, $i, my $iloc, $status );
	dat_name( $iloc, my $name, $status );
	next if $name eq 'RTS_TASKS';
	dat_type( $iloc, my $type, $status );
	dat_size( $iloc, my $size, $status );
	my @data;
	if ($type eq '_DOUBLE' || $type eq '_REAL') {
	    dat_get1d( $iloc, $size, @data, my $el, $status );
	} elsif ($type eq '_INTEGER') {
	    dat_get1i( $iloc, $size, @data, my $el, $status );
	} elsif ($type =~ /_CHAR/) {
	    dat_get1c( $iloc, $size, @data, my $el, $status );
	} else {
	    if ($status == &NDF::SAI__OK) {
		$status = &NDF::SAI__ERRROR;
		err_rep( " ", "Unsupported type $type", $status );
	    }
	}
	dat_annul( $iloc, $status );
	$local{$name} = \@data if exists $cols{$name};
    } 

    # tidy
    dat_annul( $jloc, $status);
    dat_annul( $loc, $status);

    last if $status != &NDF::SAI__OK;

    # now dump the contents
    if ($isfirst_file) {
	print "# This is a TST formatted file\n";
	print join("\t", "Id", "RA", "DEC", @columns) ,"\n";
	print join("\t", map { "--" } (0..($#columns+3))),"\n";
	$isfirst_file = 0;
    }

    for my $i ( 0 .. $#{$local{RTS_NUM}} ) {
	my @slice;

	# Use the RTS sequence number as the ID
	push(@slice, $local{RTS_NUM}->[$i]);

	# Now calculate the RA,Dec of the field centre in tracking coordinates
	# taking the chop and jiggle into account
	my $rabase = $local{TCS_TR_AC1}->[$i];
	my $decbase = $local{TCS_TR_AC2}->[$i];
	my $xoffset = $local{SMU_TR_JIG_X}->[$i] + $local{SMU_TR_CHOP_X}->[$i];
	my $yoffset = $local{SMU_TR_JIG_Y}->[$i] + $local{SMU_TR_CHOP_Y}->[$i];
	$xoffset *= Astro::SLA::DAS2R;
	$yoffset *= Astro::SLA::DAS2R;

	Astro::SLA::slaDtp2s( $xoffset, $yoffset, $rabase, $decbase, my $ra, my $dec );

	push(@slice, Astro::Coords::Angle::Hour->new( $ra )->degrees,
	    Astro::Coords::Angle->new($dec)->degrees);

	for my $col (@columns) {
	    push(@slice, $local{$col}->[$i]);
	}
	print join("\t",@slice)."\n";
    }
}
err_end( $status );



=head1 AUTHOR

Tim Jenness E<lt>t.jenness@jach.hawaii.eduE<gt>

Copyright (C) 2007 Particle Physics and Astronomy Research Council.
Copyright (C) 2007 Science and Technology Facilities Council.
All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful,but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place,Suite 330, Boston, MA  02111-1307, USA

=cut

