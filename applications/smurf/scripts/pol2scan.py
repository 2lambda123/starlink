#!/usr/bin/env python

'''
*+
*  Name:
*     POL2SCAN

*  Purpose:
*     Create Q and U maps from a set of POL-2 "spin&scan" data
*     files.

*  Language:
*     python (2.7 or 3.*)

*  Description:
*     This script runs SMURF:CALCQU on the POL-2 data files specified by
*     parameter IN, to create a set of down-sampled time series files
*     holding Q and U values in each bolometer. These time series are
*     then converted into separate Q and U maps using SMURF:MAKEMAP.
*
*     Correction for instrumental polarisation is made only if a value
*     is supplied for parameter IPREF.

*  Usage:
*     pol2scan in q u [cat] [ipref] [config] [pixsize] [qudir] [retain] [msg_filter] [ilevel] [glevel] [logfile]

*  Parameters:
*     ALIGN = LOGICAL (Read)
*        If TRUE, and if a non-null value is supplied for parameter REF,
*        then corrections to the telescope pointing are determined and
*        applied when creating the Q and U maps. To determine this pointing
*        correction, a total intensity map is created from the supplied
*        POL2 time-stream data using the supplied reference map (see
*        parameter REF) to specify the pixel grid. Due to pointing errors,
*        this total intensity map may not be aligned accurately with the
*        reference map (errors of up to 8 arc-seconds have been seen). The
*        positional shift required to minimise the residuals between the
*        shifted total intensity map and the reference map is found, and
*        used to correct the pointing when creating the Q and U map.
*        Note, this option slows down the operation of pol2scan as it
*        requires an extra invocation of smurf:makemap to create the
*        total intensity map (which is not required if ALIGN is FALSE).
*        [TRUE]
*     CAT = LITERAL (Read)
*        The output FITS vector catalogue. No catalogue is created if
*        null (!) is supplied. [!]
*     CONFIG = LITERAL (Read)
*        The MAKEMAP configuration parameter values to use. If a null
*        value (!) or "def" is supplied, the following defaults will be
*        used:
*
*        ast.zero_snr=3
*        ast.zero_snrlo=2
*        maptol=0.05
*        modelorder=(pca,ext,ast,noi)
*        noisecliphigh=3
*        numiter=-20
*        pca.pcathresh=4
*        spikebox=10
*        spikethresh=5
*
*        If a configuration is supplied, it is used in place of the above
*        default configurations. In either case, the following values are
*        always appended to the end of the used config (whether external
*        or defaulted):
*
*        flagslow = 0.01
*        downsampscale = 0
*        noi.usevar=1
*     DEBIAS = LOGICAL (Given)
*        TRUE if a correction for statistical bias is to be made to
*        percentage polarization and polarized intensity. [FALSE]
*     GLEVEL = LITERAL (Read)
*        Controls the level of information to write to a text log file.
*        Allowed values are as for "ILEVEL". The log file to create is
*        specified via parameter "LOGFILE. In adition, the glevel value
*        can be changed by assigning a new integer value (one of
*        starutil.NONE, starutil.CRITICAL, starutil.PROGRESS,
*        starutil.ATASK or starutil.DEBUG) to the module variable
*        starutil.glevel. ["ATASK"]
*     ILEVEL = LITERAL (Read)
*        Controls the level of information displayed on the screen by the
*        script. It can take any of the following values (note, these values
*        are purposefully different to the SUN/104 values to avoid confusion
*        in their effects):
*
*        - "NONE": No screen output is created
*
*        - "CRITICAL": Only critical messages are displayed such as warnings.
*
*        - "PROGRESS": Extra messages indicating script progress are also
*        displayed.
*
*        - "ATASK": Extra messages are also displayed describing each atask
*        invocation. Lines starting with ">>>" indicate the command name
*        and parameter values, and subsequent lines hold the screen output
*        generated by the command.
*
*        - "DEBUG": Extra messages are also displayed containing unspecified
*        debugging information. In addition scatter plots showing how each Q
*        and U image compares to the mean Q and U image are displayed at this
*        ILEVEL.
*
*        In adition, the glevel value can be changed by assigning a new
*        integer value (one of starutil.NONE, starutil.CRITICAL,
*        starutil.PROGRESS, starutil.ATASK or starutil.DEBUG) to the module
*        variable starutil.glevel. ["PROGRESS"]
*     IN = NDF (Read)
*        A group of POL-2 time series NDFs. Only used if a null (!) value is
*        supplied for INQU.
*     INQU = NDF (Read)
*        A group of NDFs containing Q, U and (optionally) I time-series calculated
*        by a previous run of SMURF:CALCQU (the LSQFIT parameter must be set
*        to TRUE when running CALCQU). If not supplied, the IN parameter
*        is used to get input NDFs holding POL-2 time series data. [!]
*     IPBEAMFIX = _LOGICAL (Read)
*        Should the supplied total intensity reference image (parameter
*        IPREF) be modified so that its beam shape matches the expected
*        IP beam shape at the elevation of the supplied POL2 data, before
*        doing IP correction? This is currently an experimental feature.
*        [FALSE]
*     IPREF = NDF (Read)
*        A 2D NDF holding a map of total intensity within the sky area
*        covered by the input POL2 data, in units of pW. If supplied,
*        the returned Q and U maps will be corrected for instrumental
*        polarisation, based on the total intensity values in IPREF.
*        The supplied IPREF map need not be pre-aligned with the output
*        Q and U maps - it will be resampled as necessary using a
*        transformation derived form its WCS information. [!]
*     LOGFILE = LITERAL (Read)
*        The name of the log file to create if GLEVEL is not NONE. The
*        default is "<command>.log", where <command> is the name of the
*        executing script (minus any trailing ".py" suffix), and will be
*        created in the current directory. Any file with the same name is
*        over-written. The script can change the logfile if necessary by
*        assign the new log file path to the module variable
*        "starutil.logfile". Any old log file will be closed befopre the
*        new one is opened. []
*     MSG_FILTER = LITERAL (Read)
*        Controls the default level of information reported by Starlink
*        atasks invoked within the executing script. This default can be
*        over-ridden by including a value for the msg_filter parameter
*        within the command string passed to the "invoke" function. The
*        accepted values are the list defined in SUN/104 ("None", "Quiet",
*        "Normal", "Verbose", etc). ["Normal"]
*     NORTH = LITERAL (Read)
*        Specifies the celestial coordinate system to use as the reference
*        direction in the created Q and U maps. For instance if NORTH="AZEL",
*        then they use the elevation axis as the reference direction, and if
*        "ICRS" is supplied, they use the ICRS Declination axis. If "TRACKING"
*        is supplied, they use north in the tracking system - what ever
*        that may be. Note, this parameter is only used if null (!) is
*        supplied for parameter INQU. ["TRACKING"]
*     PIXSIZE = _REAL (Read)
*        Pixel dimensions in the output Q and U maps, in arcsec. The default
*        is 4 arc-sec for 850 um data and 2 arc-sec for 450 um data. []
*     Q = NDF (Read)
*        The output NDF in which to return the Q intensity map.
*     QUDIR = LITTERAL (Read)
*        The name of a directory in which to put the Q and U time series
*        generated by calcqu. If null is supplied, they are placed in the
*        same temporary direcory as all the other intermediate files. [!]
*     U = NDF (Read)
*        The output NDF in which to return the U intensity map.
*     REF = NDF (Read)
*        An optional map defining the pixel grid for the output maps. If
*        no value is specified for REF on the command line, it defaults
*        to the value supplied for parameter IPREF. See also parameter
*        ALIGN. []
*     PI = NDF (Read)
*        An output NDF in which to return the polarised intensity map.
*        No polarised intensity map will be created if null (!) is
*        supplied. [!]
*     RETAIN = _LOGICAL (Read)
*        Should the temporary directory containing the intermediate files
*        created by this script be retained? If not, it will be deleted
*        before the script exits. If retained, a message will be
*        displayed at the end specifying the path to the directory. [FALSE]

*  Copyright:
*     Copyright (C) 2015, 2016 East Asian Observatory.
*     All Rights Reserved.

*  Licence:
*     This program is free software; you can redistribute it and/or
*     modify it under the terms of the GNU General Public License as
*     published by the Free Software Foundation; either Version 2 of
*     the License, or (at your option) any later version.
*
*     This program is distributed in the hope that it will be
*     useful, but WITHOUT ANY WARRANTY; without even the implied
*     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
*     PURPOSE. See the GNU General Public License for more details.
*
*     You should have received a copy of the GNU General Public License
*     along with this program; if not, write to the Free Software
*     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
*     02110-1301, USA.

*  Authors:
*     DSB: David S. Berry (JAC, Hawaii)
*     {enter_new_authors_here}

*  History:
*     20-MAY-2015 (DSB):
*        Original version
*     21-SEP-2015 (DSB):
*        Update default config to use PCA instead of COM/GAI.
*     28-SEP-2015 (DSB):
*        - Add azel pointing correction for old data.
*        - Allow default config values to be used as the defaults even
*          if an external config is supplied.
*     29-SEP-2015 (DSB):
*        - Add parameter PIXSIZE.
*     8-OCT-2015 (DSB):
*        Only correct azel pointing error for data between 20150606 and
*        20150930.
*     26-NOV-2015 (DSB):
*        Add parameters CAT, PI and DEBIAS.
*     3-MAR-2016 (DSB):
*        - Rename parameter IREF as IPREF.
*        - Add parameters REF and ALIGN.
*        - Remove parameters QREF and UREF.
*     6-MAY-2016 (DSB):
*        Do not add default values for optional parameters to a supplied
*        config.
*     12-MAY-2016 (DSB):
*        - Improve pointing correction by using CORLIMIT option when
*        running kappa:align2d.
*        - Use the Epoch of the POL2 observation rather than the Epoch of
*        the IP reference map when determining the expected IP beam shape.
*     26-MAY-2016 (DSB):
*        Do not use the AST mask when determining the pointing correction if
*        the AST mask contains very few pixels.
*
'''

import os
import math
import starutil
from starutil import invoke
from starutil import NDG
from starutil import Parameter
from starutil import ParSys
from starutil import msg_out
from starutil import AtaskError

#  Assume for the moment that we will not be retaining temporary files.
retain = 0

#  A function to clean up before exiting. Delete all temporary NDFs etc,
#  unless the script's RETAIN parameter indicates that they are to be
#  retained. Also delete the script's temporary ADAM directory.
def cleanup():
   global retain
   ParSys.cleanup()
   if retain:
      msg_out( "Retaining temporary files in {0}".format(NDG.tempdir))
   else:
      NDG.cleanup()


#  Catch any exception so that we can always clean up, even if control-C
#  is pressed.
try:

#  Declare the script parameters. Their positions in this list define
#  their expected position on the script command line. They can also be
#  specified by keyword on the command line. No validation of default
#  values or values supplied on the command line is performed until the
#  parameter value is first accessed within the script, at which time the
#  user is prompted for a value if necessary. The parameters "MSG_FILTER",
#  "ILEVEL", "GLEVEL" and "LOGFILE" are added automatically by the ParSys
#  constructor.
   params = []

   params.append(starutil.ParNDG("IN", "The input POL2 time series NDFs",
                                 starutil.get_task_par("DATA_ARRAY","GLOBAL",
                                                       default=Parameter.UNSET)))

   params.append(starutil.ParNDG("Q", "The output Q intensity map",
                                 default=None, exists=False, minsize=1,
                                 maxsize=1 ))

   params.append(starutil.ParNDG("U", "The output Q intensity map",
                                 default=None, exists=False, minsize=1,
                                 maxsize=1 ))

   params.append(starutil.Par0S("CAT", "The output FITS vector catalogue",
                                 default=None, noprompt=True))

   params.append(starutil.ParNDG("IPREF", "Reference map defining IP correction",
                                 default=None, noprompt=True, minsize=0, maxsize=1 ))

   params.append(starutil.Par0S("CONFIG", "Map-maker tuning parameters",
                                "def", noprompt=True))

   params.append(starutil.Par0F("PIXSIZE", "Pixel size (arcsec)", None,
                                 maxval=1000, minval=0.01, noprompt=True))

   params.append(starutil.Par0S("QUDIR", "Directory in which to save the "
                                "Q/U time series", None, noprompt=True))

   params.append(starutil.ParNDG("INQU", "NDFs containing previously calculated Q and U values",
                                 None,noprompt=True))

   params.append(starutil.Par0L("IPBEAMFIX", "Convolve the IPREF map to "
                                "the expected IP beam shape?", False,
                                noprompt=True))

   params.append(starutil.Par0L("DEBIAS", "Remove statistical bias from P"
                                "and IP?", False, noprompt=True))

   params.append(starutil.ParNDG("PI", "The output polarised intensity map",
                                 default=None, noprompt=True, exists=False,
                                 minsize=0, maxsize=1 ))

   params.append(starutil.Par0L("ALIGN", "Determine pointing corrections?", True,
                                 noprompt=True))

   params.append(starutil.Par0L("RETAIN", "Retain temporary files?", False,
                                 noprompt=True))

   params.append(starutil.ParNDG("REF", "Reference map defining the pixel grid", default=None,
                                 noprompt=True, minsize=0, maxsize=1 ))

   params.append(starutil.ParChoice( "NORTH", ("TRACKING","FK5","ICRS","AZEL",
                                     "GALACTIC","GAPPT","FK4","FK4-NO-E",
                                     "ECLIPTIC"), "Celestial system to "
                                     "use as reference direction", "TRACKING",
                                     noprompt=True ))

#  Initialise the parameters to hold any values supplied on the command
#  line.
   parsys = ParSys( params )

#  It's a good idea to get parameter values early if possible, in case
#  the user goes off for a coffee whilst the script is running and does not
#  see a later parameter propmpt or error...

#  See if pre-calculated Q and U values have been supplied on the command
#  line. If so, we use these in preference to any raw time-series files
#  specified via parameter "IN".
   inqu = parsys["INQU"].value

#  Get the raw POL-2 data files. They should be supplied as the first item on
#  the command line, in the form of a Starlink "group expression" (i.e.
#  the same way they are supplied to other SMURF commands such as makemap).
   if inqu == None:
      indata = parsys["IN"].value
   else:
      indata = None

#  Now get the Q and U values to use.
   qmap = parsys["Q"].value
   umap = parsys["U"].value

#  Get the output catalogue.
   outcat = parsys["CAT"].value

#  See if statistical debiasing is to be performed.
   debias = parsys["DEBIAS"].value

#  See if the beam is to be corrected in the IPREF map.
   ipbeamfix = parsys["IPBEAMFIX"].value

#  See if we should determine pointing corrections.
   align = parsys["ALIGN"].value

#  Now get the PI value to use.
   pimap = parsys["PI"].value

#  The user-supplied makemap config, and pixel size.
   config = parsys["CONFIG"].value
   pixsize = parsys["PIXSIZE"].value
   if pixsize:
      pixsize = "pixsize={0}".format(pixsize)
   else:
      pixsize = ""

#  See if temp files are to be retained.
   retain = parsys["RETAIN"].value

#  Get the reference maps
   ipref = parsys["IPREF"].value
   if not ipref:
      ipref = "!"
      parsys["REF"].default = None
   else:
      parsys["REF"].default = ipref

   ref = parsys["REF"].value
   if not ref:
      ref = "!"

#  If no Q and U values were supplied, create a set of Q and U time
#  streams from the supplied analysed intensity time streams. Put them in
#  the QUDIR directory, or the temp directory if QUDIR is null.
   if inqu == None:
      north = parsys["NORTH"].value
      qudir =  parsys["QUDIR"].value
      if not qudir:
         qudir = NDG.tempdir
      elif not os.path.exists(qudir):
         os.makedirs(qudir)

      msg_out( "Calculating Q, U and I time streams for each bolometer...")
      invoke("$SMURF_DIR/calcqu in={0} lsqfit=yes config=def outq={1}/\*_QT "
             "outu={1}/\*_UT outi={1}/\*_IT fix=yes north={2}".
             format( indata, qudir, north ) )

#  Get groups listing the time series files created by calcqu.
      qts = NDG( "{0}/*_QT".format( qudir ) )
      uts = NDG( "{0}/*_UT".format( qudir ) )
      its = NDG( "{0}/*_IT".format( qudir ) )

#  If pre-calculated Q and U values were supplied, identifiy the Q, U and I
#  files.
   else:
      msg_out( "Using pre-calculating Q, U and I values...")

      qndfs = []
      undfs = []
      indfs = []
      for ndf in inqu:
         invoke("$KAPPA_DIR/ndftrace ndf={0} quiet".format(ndf) )
         label = starutil.get_task_par( "LABEL", "ndftrace" )
         if label == "Q":
            qndfs.append( ndf )
         elif label == "U":
            undfs.append( ndf )
         elif label == "I":
            indfs.append( ndf )
         else:
            raise starutil.InvalidParameterError("Q/U time-series {0} has "
                    "an unknown Label {1} - must be 'Q', 'U' or 'I'.".
                    format(ndf,label))

      qts = NDG( qndfs )
      uts = NDG( undfs )
      its = NDG( indfs )

#  Create a config file to use with makemap.
   conf = os.path.join(NDG.tempdir,"conf")
   fd = open(conf,"w")

#  If a non-default config was supplied, use it.
   if config and config != "def":
      fd.write("{0}\n".format(config))

#  Otherwise, use the default values.
   else:
      fd.write("ast.zero_snr=3\n")
      fd.write("ast.zero_snrlo=2\n")
      fd.write("maptol=0.05\n")
      fd.write("modelorder=(pca,ext,ast,noi)\n")
      fd.write("noisecliphigh=3\n")
      fd.write("numiter=-20\n")
      fd.write("pca.pcathresh=4\n")
      fd.write("spikebox=10\n")
      fd.write("spikethresh=5\n")

#  Now put in values that are absolutely required by this script. These
#  over-write any values in the user-supplied config.
   fd.write("noi.usevar=1\n")
   fd.write("flagslow=0.01\n")
   fd.write("downsampscale=0\n")
   fd.close()

#  AZ/EL pointing correction, for data between 20150606 and 20150930.
   ut = int(starutil.get_fits_header( qts[0], "UTDATE", True ))
   if ut >= 20150606 and ut <= 20150929:
      pntfile = os.path.join(NDG.tempdir,"pointing")
      fd = open(pntfile,"w")
      fd.write("# system=azel\n")
      fd.write("# tai dlon dlat\n")
      fd.write("54000 32.1 27.4\n")
      fd.write("56000 32.1 27.4\n")
      fd.close()
   else:
      pntfile = "!"

#  If a reference map has been supplied, and parameter ALIGN is TRUE,
#  we create an I map and determine any extra pointing corrections
#  that are needed to bring the I map into alignment with the reference map.
   if ref != "!" and align:

#  Issue a warning if we have no I time-stream files.
      if len(its) == 0:
         msg_out( "WARNING: No total intensity time series data has been "
                  "supplied. Therefore the final Q and U maps cannot "
                  "be corrected for pointing errors." )
      else:
         msg_out( "Making a map from the I time series...")

#  Create a config file to use when creating the I map. The I map needs an
#  FLT model because  it is derived from the background level in the time
#  stream data which can drift, rather then the modulation amplitude which
#  is insensitive to drift. Also mask out edge regions more aggresively since
#  we do not want spurious structures round the edges to upset the alignment
#  process in kappa:align2d.
         iconf = os.path.join(NDG.tempdir,"iconf")
         fd = open(iconf,"w")
         fd.write("^$STARLINK_DIR/share/smurf/dimmconfig_jsa_generic.lis\n")
         fd.write("hitslimit=1\n")
         fd.write("maptol=0.1\n")
         fd.write("flagslow=0.01\n")
         fd.write("downsampscale=0\n")
         fd.write("noi.usevar=1\n")
         fd.close()

#  Create the I map.
         imap = NDG( 1 )
         invoke("$SMURF_DIR/makemap in={0} config=^{1} out={2} ref={3} pointing={4}".
               format(its,iconf,imap,ref,pntfile))

#  See what translations (in pixels) are needed to align the imap with
#  the reference map. The determination of the shift is more accurate if
#  we first mask out background areas. Use the AST mask to define source
#  pixels, but only if the mask contains a reasonable number of pixels
#  (very faint sources will have very small or non-existant AST masks).
         invoke("$KAPPA_DIR/showqual ndf={0}".format(imap))
         if starutil.get_task_par( "QNAMES(1)", "showqual" ) == "AST":
            bb = 1
         elif starutil.get_task_par( "QNAMES(2)", "showqual" ) == "AST":
            bb = 2
         elif starutil.get_task_par( "QNAMES(3)", "showqual" ) == "AST":
            bb = 4
         else:
            bb = 0

         if bb > 0:
            invoke("$KAPPA_DIR/setbb ndf={0} bb={1}".format(imap,bb))

#  Clear badbits to use the whole map if the above masking results in too
#  few pixels.
            invoke("$KAPPA_DIR/stats ndf={0}".format(imap))
            nused = float( starutil.get_task_par( "numgood", "stats" ) )
            if nused < 400:
               invoke("$KAPPA_DIR/setbb ndf={0} bb=0".format(imap))

#  Find the pixel shift that aligns features in this masked, trimmed I map with
#  corresponding features in the reference map.
         invoke("$KAPPA_DIR/align2d ref={0} out=! in={1} form=3 corlimit=0.7".
                format(ref,imap))
         dx = float( starutil.get_task_par( "TR(1)", "align2d" ) )
         dy = float( starutil.get_task_par( "TR(4)", "align2d" ) )

#  If the shifts are suspiciously high, we do not believe them. In which
#  case we cannot do pointing ocorrection when creating the Q and U maps.
         if abs(dx) > 5 or abs(dy) > 5:
            msg_out( "WARNING: The I map created from the POL2 data cannot be aligned "
                     "with the supplied IP reference map. Therefore the final "
                     "Q and U maps cannot be corrected for pointing errors." )

#  Otherwise, convert the offset in pixels to (longitude,latitude) offsets
#  in the sky system of the reference map, in arc-seconds....
         else:

#  Strip the wavelength axis off the total intensity map created above.
            imap2d = NDG( 1 )
            invoke("$KAPPA_DIR/ndfcopy in={0} out={1} trim=yes".format(imap,imap2d))

#  Get the pixel coords at the centre of the total intensity map.
            invoke("$KAPPA_DIR/ndftrace ndf={0}".format(imap2d))
            lbndx = float( starutil.get_task_par( "LBOUND(1)", "ndftrace" ) )
            lbndy = float( starutil.get_task_par( "LBOUND(2)", "ndftrace" ) )
            ubndx = float( starutil.get_task_par( "UBOUND(1)", "ndftrace" ) )
            ubndy = float( starutil.get_task_par( "UBOUND(2)", "ndftrace" ) )
            cenx = 0.5*( lbndx + ubndx )
            ceny = 0.5*( lbndy + ubndy )

#  Convert to SKY coords, in radians. Use ATOOLS rather than pyast in
#  order to avoid the need for people to install pyast. Also, ATOOLS
#  integrates with NDFs more easily than pyast.
            (cena,cenb) = invoke("$ATOOLS_DIR/asttran2 this={0} forward=yes "
                                 "xin={1} yin={2}".format( imap2d,cenx,ceny)).split()
            cena = float( cena )
            cenb = float( cenb )

#  Add on the pixel offsets, and convert to SKY coords, in radians.
            offx = cenx + dx
            offy = ceny + dy
            (offa,offb) = invoke("$ATOOLS_DIR/asttran2 this={0} forward=yes "
                                 "xin={1} yin={2}".format( imap2d,offx,offy)).split()
            offa = float( offa )
            offb = float( offb )

#   Now find the arc-distance parallel to the longitude axis, between the central
#   and offset positions, and convert from radians to arc-seconds.
            dx = invoke("$ATOOLS_DIR/astdistance this={0}, point1=\[{1},{2}\] "
                        "point2=\[{3},{4}\]".format(imap2d,cena,cenb,offa,cenb))
            dx = 3600.0*math.degrees( float( dx ) )

#  The value returned by astDistance is always positive. Adjust the sign
#  of dx so that it goes the right way.
            da = offa - cena
            while da > math.pi:
               da -= math.pi
            while da < -math.pi:
               da += math.pi
            if da < 0.0:
               dx = -dx

#  Now find the arc-distance parallel to the latitude axis, between the central
#  and offset positions, and convert from radians to arc-seconds.
            dy = invoke("$ATOOLS_DIR/astdistance this={0}, point1=\[{1},{2}\] "
                        "point2=\[{3},{4}\]".format(imap2d,cena,cenb,cena,offb))
            dy = 3600.0*math.degrees( float( dy ) )

#  The value returned by astDistance is always positive. Adjust the sign
#  of dx so that it goes the right way.
            db = offb - cenb
            if db < 0.0:
               dy = -dy

#  Create the pointing correction file to use with subsequent makemap
#  calls. If a file is already in use (because of the data being old)
#  append the new pointing correction to the end of the file, preceeded
#  by an "end-of-table" Marker (two minus signs). Makemap will then apply
#  both correction.
            msg_out( "Using pointing corrections of ({0},{1}) arc-seconds".format(dx,dy) )
            if pntfile == "!":
               pntfile = os.path.join(NDG.tempdir,"pointing")
               fd = open(pntfile,"w")
            else:
               fd = open(pntfile,"a")
               fd.write("--\n")

            fd.write("# system=tracking\n")
            fd.write("# tai dlon dlat\n")
            fd.write("54000 {0} {1}\n".format(dx,dy))
            fd.write("56000 {0} {1}\n".format(dx,dy))
            fd.close()





#  Convolve the supplied ip reference map to give it a beam that matches
#  the expected IP beam at the elevation of the supplied data.
   if ipbeamfix and ipref != "!":
      msg_out( "Convolving the I reference map to match the expected IP beam shape...")

#  Get the azmimuth and elevation of the POL2 data.
      el1 = float( starutil.get_fits_header( qts[0], "ELSTART" ) )
      el2 = float( starutil.get_fits_header( qts[0], "ELEND" ) )
      el = 0.5*( el1 + el2 )
      az1 = float( starutil.get_fits_header( qts[0], "AZSTART" ) )
      az2 = float( starutil.get_fits_header( qts[0], "AZEND" ) )
      az = 0.5*( az1 + az2 )

#  Get the pixel size in the input total intensity map.
      invoke("$KAPPA_DIR/ndftrace ndf={0} quiet".format(ipref) )
      ipixsize = float( starutil.get_task_par( "fpixscale(1)", "ndftrace" ) )

#  Generate an NDF holding the canonical total-intensity beam (circular).
#  Parameters are: pg=shape exponent, pf=FWHM in arc-sec, pp=pixel size
#  in arc-sec.
      ibeam = NDG(1)
      invoke("$KAPPA_DIR/maths exp=\"'exp(-0.69315*((4*((xa+0.5)**2+(xb+0.5)**2)/(fa*fa))**(pg/2)))'\" "
             "fa=\"'pf/pp'\" lbound=\[-15,-15\] ubound=\[15,15\] type=_double "
             "pf=14 pg=1.984 pp={1} out={0}".format(ibeam,ipixsize) )

#  Get the parameters of the expected polarised-intensity beam, at the
#  elevation of the data. FWHM values are in arc-seconds. Area is in square
#  arc-seconds. Orientation is in degrees from the elevation axis towards
#  the azimuth axis.
      fwhm1 = 14.6914727284 + 0.0421973549002*el - 9.70079974113e-05*el*el
      fwhm2 = 15.245386229 - 0.115624437578*el + 0.000763994058326*el*el
      area = fwhm1*fwhm2
      gamma = 4.65996074835 - 0.0340987643291*area + 0.000115483045339*area*area
      orient = 118.639637086 - 0.472915017742*az +  0.00140620919736*az*az

#  Convert the array of TCS_TAI values within the JCMTSTATE extension of
#  the first Q time series into an NDF, and then get the average TCS_TAI
#  value (the epoch as an MJD).
      tcstai = NDG(1)
      invoke("$HDSTOOLS_DIR/hcreate type=image inp={0}".format(tcstai))
      invoke("$HDSTOOLS_DIR/hcopy in={0}.more.jcmtstate.tcs_tai out={1}.data_array".
             format(qts[0],tcstai))
      invoke("$KAPPA_DIR/stats ndf={0}".format(tcstai))
      epoch = float( starutil.get_task_par( "mean", "stats" ) )

#  Get the angle from the Y pixel axis to the elevation axis in the supplied
#  IP reference image. Positive rotation is from X pixel axis to Y pixel axis.
#  We need to set the WCS to AZEL offsets to do this, but we first need to
#  set the Epoch in the image to that of the POL2 observation, in order to
#  ensure that the AZEL axes are approriate to the time the POL2 dta was
#  taken rather than the time of the image. And we to do this without
#  adjusting the WCS Mappings. Take a copy to avoid changing the original.
      junk = NDG(1)
      invoke("$KAPPA_DIR/ndfcopy in={0} out={1} trim=yes".format(ipref,junk))
      invoke("$KAPPA_DIR/wcsattrib ndf={0} mode=set name=epoch newval=\"'MJD {1}'\" remap=no".format(junk,epoch))
      invoke("$KAPPA_DIR/wcsattrib ndf={0} mode=set name=skyrefis newval=origin".format(junk))
      invoke("$KAPPA_DIR/wcsattrib ndf={0} mode=set name=system newval=azel".format(junk))

      junk2 = NDG(1)
      invoke("$KAPPA_DIR/rotate in={0} out={1} angle=!".format(junk,junk2))
      angrot = float( starutil.get_task_par( "angleused", "rotate" ) )

#  Convert the major axis orientation from sky coords to pixel coords.
      orient = angrot - orient

#  Convert FWHM values to pixels.
      fwhm1 = fwhm1/ipixsize
      fwhm2 = fwhm2/ipixsize

#  Generate an NDF holding the expected polarised-intensity IP beam, at the
#  elevation of the data. This image has the same WCS axis orientation as the
#  supplied total intensity image.
      ipbeam = NDG(1)
      invoke("$KAPPA_DIR/maths exp=\"'exp(-0.69315*((4*((fx/px)**2+(fy/py)**2))**(pg/2)))'\" "
             "fx=\"'-(xa+0.5)*sind(po)+(xb+0.5)*cosd(po)'\" fy=\"'-(xa+0.5)*cosd(po)-(xb+0.5)*sind(po)'\" "
             "lbound=\[-15,-15\] ubound=\[15,15\] type=_double po={4} "
             "px={1} py={2} pg={3} out={0}".format(ipbeam,fwhm1,fwhm2,gamma,orient) )

#  Deconvolve the IP beam using the total intensity beam as the PSF. This
#  gives the required smoothing kernel.
      tmp1 = NDG(1)
      invoke("$KAPPA_DIR/wiener in={0} pmodel=1 pnoise=1E-5 psf={1} xcentre=0 ycentre=0 "
             "out={2}".format(ipbeam,ibeam,tmp1))

#  The results seem to have less ringing if the kernel is apodised. Use
#  a Gaussian of FWHM 30 arc-seconds as the apodising function.
      tmp2 = NDG(1)
      invoke("$KAPPA_DIR/maths exp=\"'ia*exp(-((xa+0.5)**2+(xb+0.5)**2)/fa)'\" "
             "fa=\"'30/pa'\" pa={1} ia={0} out={2}".format(tmp1,ipixsize,tmp2))

#  Ensure the kernal has a total data value of unity. This means the
#  input and output maps will have the same normalisation.
      invoke("$KAPPA_DIR/stats ndf={0}".format(tmp2))
      total = starutil.get_task_par( "total", "stats" )
      bkernel = NDG(1)
      invoke("$KAPPA_DIR/cdiv in={0} scalar={1} out={2}".format(tmp2,total,bkernel))

#  Convolve the supplied total intensity map using this kernel. The
#  output map should have a beam similar to the expected IP beam.
      iprefbeam = NDG(1)
      invoke("$KAPPA_DIR/convolve in={0} psf={1} xcentre=0 ycentre=0 "
             "out={2}".format(ipref,bkernel,iprefbeam))
      ipref = iprefbeam





#  Make a map from the Q time series.
   msg_out( "Making a map from the Q time series...")
   invoke("$SMURF_DIR/makemap in={0} config=^{1} out={2} ref={3} pointing={4} "
          "ipref={5} {6}".format(qts,conf,qmap,ref,pntfile,ipref,pixsize))

#  Make a map from the U time series.
   msg_out( "Making a map from the U time series..." )
   invoke("$SMURF_DIR/makemap in={0} config=^{1} out={2} ref={3} pointing={4} "
          "ipref={5} {6}".format(uts,conf,umap,ref,pntfile,ipref,pixsize))

#  Create the polarised intensity map if required.
   if pimap:
      msg_out( "Generating an polarised intensity image...")
      if debias:
         invoke( "$KAPPA_DIR/maths exp=\"'sign(sqrt(abs(fa)),fa)'\" "
                 "fa=\"'ia**2+ib**2-(va+vb)/2'\" ia={0} ib={1} out={2}".
                 format(qmap,umap,pimap))
      else:
         invoke( "$KAPPA_DIR/maths exp=\"'sqrt(ia**2+ib**2)'\" ia={0} "
                 "ib={1} out={2}".format(qmap,umap,pimap))

# The rest we only do if an output catalogue is reqired.
   if outcat:

#  If no total intensity map was supplied, generate an artificial I image that
#  is just equal to the polarised intensity image. This is needed because
#  polpack:polvec uses the I value to normalise the Q and U values prior to
#  calculating the polarised intensity and angle.
      if ipref == "!":
         if pimap:
            ipref = pimap
         else:
            ipref = NDG(1)
            msg_out( "Generating an artificial total intensity image...")
            if debias:
               invoke( "$KAPPA_DIR/maths exp=\"'sign(sqrt(abs(fa)),fa)'\" "
                       "fa=\"'ia**2+ib**2-(va+vb)/2'\" ia={0} ib={1} out={2}".
                       format(qmap,umap,ipref))
            else:
               invoke( "$KAPPA_DIR/maths exp=\"'sqrt(ia**2+ib**2)'\" ia={0} "
                       "ib={1} out={2}".format(qmap,umap,ipref))

#  Ensure the Q U and I images all have the same bounds, equal to the
#  overlap region between them. To get the overlap region, use MATHS to
#  add them together. Then use ndfcopy to produce the sections from each,
#  which match the overlap area.
      tmp = NDG( 1 )
      invoke( "$KAPPA_DIR/maths exp=\"'ia+ib+ic'\" ia={0} ib={1} ic={2} out={3}".
              format(qmap,umap,ipref,tmp) )
      qtrim = NDG( 1 )
      invoke( "$KAPPA_DIR/ndfcopy in={0} like={1} out={2}".format(qmap,tmp,qtrim) )
      utrim = NDG( 1 )
      invoke( "$KAPPA_DIR/ndfcopy in={0} like={1} out={2}".format(umap,tmp,utrim) )
      itrim = NDG( 1 )
      invoke( "$KAPPA_DIR/ndfcopy in={0} like={1} out={2}".format(ipref,tmp,itrim) )

#  The polarisation vectors are calculated by the polpack:polvec command,
#  which requires the input Stokes vectors in the form of a 3D cube. Paste
#  the 2-dimensional Q, U and I images into a 3D cube.
      planes = NDG( [qtrim,utrim,itrim] )
      cube = NDG( 1 )
      invoke( "$KAPPA_DIR/paste in={0} shift=\[0,0,1\] out={1}".format(planes,cube))

#  The cube will have a 3D "POLANAL-SPECTRUM" WCS Frame, but POLVEC
#  requires a 2D POLANAL Frame. So use wcsframe to create the 2D Frame
#  from the 3D Frame, then delete the 3D Frame.
      invoke( "$KAPPA_DIR/wcsframe ndf={0} frame=POLANAL".format(cube) )
      invoke( "$KAPPA_DIR/wcsremove ndf={0} frame=POLANAL-SPECTRUM".format(cube) )

#  Re-instate SKY as the current Frame
      invoke( "$KAPPA_DIR/wcsframe ndf={0} frame=SKY".format(cube) )

#  POLPACK needs to know the order of I, Q and U in the 3D cube. Store
#  this information in the POLPACK enstension within "cube.sdf".
      invoke( "$POLPACK_DIR/polext in={0} stokes=qui".format(cube) )

#  Create a FITS catalogue containing the polarisation vectors.
      msg_out( "Creating the output catalogue: '{0}'...".format(outcat) )
      msg = invoke( "$POLPACK_DIR/polvec {0} cat={1} debias={2}".format(cube,outcat,debias) )
      msg_out( "\n{0}\n".format(msg) )

#  Remove temporary files.
   cleanup()

#  If an StarUtilError of any kind occurred, display the message but hide the
#  python traceback. To see the trace back, uncomment "raise" instead.
except starutil.StarUtilError as err:
#  raise
   print( err )
   cleanup()

# This is to trap control-C etc, so that we can clean up temp files.
except:
   cleanup()
   raise

