#!/usr/bin/env python

'''
*+
*  Name:
*     POL2IP

*  Purpose:
*     Create an Instrumental Polarisation (IP) model from a set of POL2
*     observations.

*  Language:
*     python (2.7 or 3.*)

*  Description:
*     This script produces Q and U maps from a supplied list of POL2
*     planet observations (this list should include observations over a
*     wide range of elevations). It then estimates the parameters of an
*     IP model that gives good estimates of the resulting Q and U, based
*     on a supplied total intensity map of the planet.

*     It is assumed that the source is centred at the reference point of
*     the supplied observations.

*     An IP model gives the normalised Q and U values (Qn and Un) with
*     respect to focal plane Y axis, at any point on the sky, as functions
*     of elevation. The correction is applied as follows:
*
*        Q_corrected = Q_original - I*Qn
*        U_corrected = U_original - I*Un
*
*     where "I" is the total intensity at the same point on the sky as
*     Q_original and U_original. All (Q,U) values use the focal plane Y
*     axis as the reference direction.
*
*     The "PL1" IP model is as follows ("el" = elevation in radians):
*
*        p1 = A + B*el + C*el*el
*        Qn = I*p1*cos(-2*el)
*        Un = I*p1*sin(-2*el)
*
*     It is parameterised by three constants A, B and C, which are
*     calculated by this script.  It represents an instrumental
*     polarisation that varies in size with elevation but is always
*     parallel to elevation.

*  Usage:
*     pol2ip obslist iref [diam] [pixsize]

*  ADAM Parameters:
*     DIAM = _REAL (Read)
*        The diameter of the circle (in arc-seconds), centred on the source,
*        over which the mean Q, U and I values are found. If zero, or a
*        negative value, is supplied, the fit is based on the weighted
*        mean values within the source, where the spatial weiging function
*        is a fitted beam shape determined using kappa:beamfit. In this
*        case, a text file called "beamfit.asc" is created in the current
*        directory. This is a table containg columns of the geometric
*        properties of the polarised intensity beam in each observation.
*        The header for this file contains the parameters of quadratic fits
*        to these properties, which are used within pol2scan. [40]
*     ILEVEL = LITERAL (Read)
*        Controls the level of information displayed on the screen by the
*        script. It can take any of the following values (note, these values
*        are purposefully different to the SUN/104 values to avoid confusion
*        in their effects):
*
*        - "NONE": No screen output is created
*
*        - "CRITICAL": Only critical messages are displayed such as warnings.
*
*        - "PROGRESS": Extra messages indicating script progress are also
*        displayed.
*
*        - "ATASK": Extra messages are also displayed describing each atask
*        invocation. Lines starting with ">>>" indicate the command name
*        and parameter values, and subsequent lines hold the screen output
*        generated by the command.
*
*        - "DEBUG": Extra messages are also displayed containing unspecified
*        debugging information. In addition scatter plots showing how each Q
*        and U image compares to the mean Q and U image are displayed at this
*        ILEVEL.
*
*        In adition, the glevel value can be changed by assigning a new
*        integer value (one of starutil.NONE, starutil.CRITICAL,
*        starutil.PROGRESS, starutil.ATASK or starutil.DEBUG) to the module
*        variable starutil.glevel. ["PROGRESS"]
*     IREF = NDF (Read)
*        A 2D NDF holding a map of total intensity (in pW) for the object
*        covered by the observations in OBSLIST. It is assumed that the
*        object is centred at the reference point in the map. The
*        supplied map is resampled to to give it the pixel size specified
*        by parameter PIXSIZE.
*     LOGFILE = LITERAL (Read)
*        The name of the log file to create if GLEVEL is not NONE. The
*        default is "<command>.log", where <command> is the name of the
*        executing script (minus any trailing ".py" suffix), and will be
*        created in the current directory. Any file with the same name is
*        over-written. The script can change the logfile if necessary by
*        assign the new log file path to the module variable
*        "starutil.logfile". Any old log file will be closed befopre the
*        new one is opened. []
*     MSG_FILTER = LITERAL (Read)
*        Controls the default level of information reported by Starlink
*        atasks invoked within the executing script. This default can be
*        over-ridden by including a value for the msg_filter parameter
*        within the command string passed to the "invoke" function. The
*        accepted values are the list defined in SUN/104 ("None", "Quiet",
*        "Normal", "Verbose", etc). ["Normal"]
*     OBSLIST = LITERAL (Read)
*        The path to  a text file listing the POL2 observations to use.
*        Each line should contain a string of the form "<ut>/<obs>", where
*        <ut> is the 8 digit UT date (e.g. "20151009") and <obs> is the 5
*        digit observation number (e.g. "00034"). The raw data for all
*        observations is expected to reside in a directory given by
*        environment variable "SC2", within subdirectories with paths
*        of the form: $SC2/s8a/20150918/00056/ etc.
*     PIXSIZE = _REAL (Read)
*        Pixel dimensions in the Q and U maps, in arcsec. The default
*        is 4 arc-sec for 850 um data and 2 arc-sec for 450 um data. []
*     RESTART = LITERAL (Read)
*        If a value is assigned to this parameter, it should be the path
*        to a directory containing the intermediate files created by a
*        previous run of POL2IP (it is necessry to run POL2IP with
*        RETAIN=YES otherwise the directory is deleted after POL2IP
*        terminates). If supplied, any files which can be re-used from
*        the supplied directory are re-used, thus speeding things up.
*        The path to the intermediate files can be found by examining the
*        log file created by the previous run. [!]
*     RETAIN = _LOGICAL (Read)
*        Should the temporary directory containing the intermediate files
*        created by this script be retained? If not, it will be deleted
*        before the script exits. If retained, a message will be
*        displayed at the end specifying the path to the directory. [FALSE]
*     QUDIR = LITERAL (Read)
*        Path to a directory containing any pre-exiting Q/U time streams
*        or Q/U maps. Each UT date should have a separate subdirectory
*        within "qudir", and each observation should have a separate
*        subdirectory within its <UT> date subdirectory. If null (!) is
*        supplied, the root directory is placed within the temporary
*        directory used to store all other intermediate files. [!]
*     TABLE = LITERAL (Read)
*        The path to a new text file to create in which to place a table
*        holding columns of elevation, Q, U, Qfit and Ufit (and various
*        other useful things), in TOPCAT ASCII format. [!]
*     TABLEIN = LITERAL (Read)
*        The path to an existing text file containing a table created by
*        a previous run of this script, using the TABLE parameter. If
*        supplied, none of the other parameters are accessed, and a fit
*        is performed to the values in the supplied table. [!]

*  Copyright:
*     Copyright (C) 2015,2016 East Asian Observatory
*     All Rights Reserved.

*  Licence:
*     This program is free software; you can redistribute it and/or
*     modify it under the terms of the GNU General Public License as
*     published by the Free Software Foundation; either Version 2 of
*     the License, or (at your option) any later version.
*
*     This program is distributed in the hope that it will be
*     useful, but WITHOUT ANY WARRANTY; without even the implied
*     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
*     PURPOSE. See the GNU General Public License for more details.
*
*     You should have received a copy of the GNU General Public License
*     along with this program; if not, write to the Free Software
*     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
*     02110-1301, USA.

*  Authors:
*     DSB: David S. Berry (EAO)
*     {enter_new_authors_here}

*  History:
*     16-DEC-2015 (DSB):
*        Original version
*     26-APR-2016 (DSB):
*        - If DIAM is zero, use weighted mean Q and U values within the
*        fit, where the spatial weighting functions are given by a
*        gaussian fit to the polarised intensity peak, generated by
*        kappa:beamfit.
*        - Calculate the error on the mean Q and U values, and use these
*        errors to weight each data point in the fit.
*     9-MAY-2016 (DSB):
*        Generate quadratic fits to the beamfit geometric parameters.
*        These can be used later to calculate the expected IP beam shape
*        at any elevation. These are only generated if DIAM is zero or
*        negative, and are stored in a file called "beamfit.asc".
*     17-JUN-2016 (DSB):
*        - Scale errors on Q and U so that the weights are of order unity.
*        - Reduce maximize convergence criterion from 1E-4 to 1-E-5 as 
*        otherwise the fit to the Uranus data terminates too early, and 
*        produces a poor fit
*-
'''

import os
import re
import math
import starutil
from starutil import invoke
from starutil import get_fits_header
from starutil import get_task_par
from starutil import NDG
from starutil import Parameter
from starutil import ParSys
from starutil import msg_out
from starutil import UsageError

import numpy as np
try:
   from scipy.optimize import minimize
   dofit = True
except ImportError:
   msg_out( "Python scipy package no available - no fit will be done." )
   dofit = False

from math import cos as cos
from math import sin as sin
from math import radians as radians
from math import degrees as degrees
from math import exp as exp
from math import sqrt as sqrt
from math import fabs as fabs
from math import atan2 as atan2

#  Assume for the moment that we will not be retaining temporary files.
retain = 0

#  Assume for the moment that we will not be re-using old temporary files.
restart = None

#  Initialise empty lists to hold the elevation, Q and U for each observation.
elist = []
alist = []
qlist = []
ulist = []
dqlist = []
dulist = []
utlist = []
obsnumlist = []
wvmlist = []
hstlist = []
atlist = []
humlist = []
bplist = []
wndspdlist = []
wnddirlist = []
frleglist = []
bkleglist = []
fwhm1list = []
fwhm2list = []
orientlist = []
gammalist = []
arealist = []

# The mean total intensity within the aperture.
ival = 0

#  A function to clean up before exiting. Delete all temporary NDFs etc,
#  unless the script's RETAIN parameter indicates that they are to be
#  retained. Also delete the script's temporary ADAM directory.
def cleanup():
   global retain
   ParSys.cleanup()
   if retain:
      msg_out( "Retaining temporary files in {0}".format(NDG.tempdir))
   else:
      NDG.cleanup()







#  Functions related to fitting a single quadratic model to a set of
#  (x,y) positions (x values in qxlist and y values in qylist).
#  ------------------------------------------------------------------

#  Objective function used by minimisation routine. It returns the
#  sum of the squared residuals between the model and the data
#  for a given set of model parameters.
def objfunquad(x):
   global qxlist, qylist
   res = 0.0
   for i in range(len(qxlist)):
      ymod = modelquad( i, x )
      dy = ymod - qylist[i]
      res += dy*dy
   return res

#  Returns the quadratic model value corresponding to a given
#  set of model parameter values.
def modelquad( i, x ):
   global qxlist
   xval = qxlist[i]
   (a,b,c) = x
   return a + b*xval + c*xval*xval

#  Find RMS residual of quadratic model from data.
def residquad( x ):
   global qylist, qxlist
   swgt = 0.0
   res = 0.0
   nval = len(qxlist)
   for i in range(nval):
      yval = modelquad( i, x )
      dy = yval - qylist[i]
      res += dy*dy
   return sqrt( res/nval )

#  Form new lists excluding outliers.
def rejectquad( lim, x ):
   global qxlist, qylist
   newqxlist = []
   newqylist = []

   for i in range(len(qxlist)):
      yval = modelquad( i, x )
      dy = yval - qylist[i]

      if fabs( dy ) < lim:
         newqxlist.append( qxlist[i] )
         newqylist.append( qylist[i] )

   qxlist = newqxlist
   qylist = newqylist

def fitquad(text,a,b,c,xvals,yvals):
   global qxlist, qylist

   if len(xvals) != len(yvals):
      raise UsageError("fitquad: length of X and Y arrays differ in "
                       "fit: {0}.".format(text) )
   msg_out( "\n\n Doing quadratic fit: '{0}'...".format(text) )

#  Scale the Y values so that they cover the range -100 to +100.
   ymax = max( yvals )
   ymin = min( yvals )
   alpha = 200/(ymax-ymin)
   beta = 100 - alpha*ymax
   qylist = [alpha*y+beta for y in yvals]

#  Scale the X values so that they cover the range -1 to +1.
   xmax = max( xvals )
   xmin = min( xvals )
   gam = 2/(xmax-xmin)
   delta = 1 - gam*xmax
   qxlist = [gam*x+delta for x in xvals]

#  Find a quadratic fit to the scaled X and Y values, iterating to
#  reject outliers.
   for i in range(0,5):
      msg_out( "\nIteration {0}: Fitting to {1} data points...".format(i+1,len(qxlist)) )

#  Initial guess at model parameters.
      x0 = np.array([a,b,c])

#  Do a fit to find the optimum model parameters.
      res = minimize( objfunquad, x0, method='nelder-mead',
                      options={'xtol': 1e-5, 'disp': True})

#  Find RMS residual between data and fit.
      rms = residquad( res.x )
      msg_out( "   Fit: {0}    RMS: {1}".format(res.x, rms) )

#  Remove points more than 2 sigma from the fit.
      rejectquad( 2*rms, res.x )

#  Scale the best fit parameters so that they refer to the unscaled X
#  and Y values.
   a = ( res.x[0] + res.x[1]*delta + res.x[2]*delta*delta - beta )/alpha
   b = ( res.x[1]*gam + 2*res.x[2]*gam*delta )/alpha
   c = ( res.x[2]*gam*gam )/alpha

#  return results.
   return (a,b,c)

#--------------------------------------------------------------------------------









#  Functions related to fitting a single quadratic model to a joint set of
#  (Q,U) values as a functions of elevation (q values in qlist, u values
#  in ulist, elevation valuesin ellist).
#  ------------------------------------------------------------------

#  Returns the normalised Q and U representing the IP at a given
#  elevation, assuming given model parameter values.
def model( i, x ):
   global elist
   return model2( elist[i], x )

def model2( el, x ):
   (a,b,c) = x
   elval = radians( el )
   pi = a + b*elval + c*elval*elval
   qfp = ival*pi*cos( -2*elval )
   ufp = ival*pi*sin( -2*elval )
   return (qfp, ufp)

#  Objective function used by minimisation routine. It returns the
#  weighted mean of the squared Q/U residuals between the model and
#  the data for a given set of model parameters.
def objfun(x):
   global qlist, dqlist, ulist, dulist, elist
   res = 0.0
   swgt = 0.0
   for i in range(len(elist)):
      (qfp,ufp) = model( i, x )
      qwgt = 1/(dqlist[i]*dqlist[i])
      dq = qfp - qlist[i]
      uwgt = 1/(dulist[i]*dulist[i])
      du = ufp - ulist[i]
      res += qwgt*dq*dq + uwgt*du*du
      swgt += qwgt+uwgt
   return res/swgt

#  Find weighted RMS residual of Q or U from fit.
def resid( useq, x ):
   global qlist, dqlist, ulist, dulist, elist
   swgt = 0.0
   res = 0.0
   for i in range(len(elist)):
      (qfp,ufp) = model( i, x )
      if useq:
         wgt = 1/(dqlist[i]*dqlist[i])
         dqu = qfp - qlist[i]
      else:
         wgt = 1/(dulist[i]*dulist[i])
         dqu = ufp - ulist[i]
      swgt += wgt
      res += wgt*dqu*dqu
   return sqrt( res/swgt )

#  Form new lists excluding outliers.
def reject( useq, lim, x ):
   global qlist, dqlist, ulist, dulist, elist
   newqlist = []
   newulist = []
   newdqlist = []
   newdulist = []
   newelist = []

   for i in range(len(elist)):
      (qfp,ufp) = model( i, x )
      if useq:
         dqu = qfp - qlist[i]
      else:
         dqu = ufp - ulist[i]

      if fabs( dqu ) < lim:
         newqlist.append( qlist[i] )
         newulist.append( ulist[i] )
         newdqlist.append( dqlist[i] )
         newdulist.append( dulist[i] )
         newelist.append( elist[i] )

   qlist = newqlist
   ulist = newulist
   dqlist = newdqlist
   dulist = newdulist
   elist = newelist

#--------------------------------------------------------------------------------







#  Catch any exception so that we can always clean up, even if control-C
#  is pressed.
try:

#  Declare the script parameters. Their positions in this list define
#  their expected position on the script command line. They can also be
#  specified by keyword on the command line. No validation of default
#  values or values supplied on the command line is performed until the
#  parameter value is first accessed within the script, at which time the
#  user is prompted for a value if necessary. The parameters "MSG_FILTER",
#  "ILEVEL", "GLEVEL" and "LOGFILE" are added automatically by the ParSys
#  constructor.
   params = []

   params.append(starutil.Par0S("OBSLIST", "List of POL2 observations"))
   params.append(starutil.ParNDG("IREF", "The reference I map",
                                 minsize=0, maxsize=1 ))
   params.append(starutil.Par0F("DIAM", "Aperture diameter (arc-sec)",
                                 40.0, noprompt=True ))
   params.append(starutil.Par0F("PIXSIZE", "Pixel size (arcsec)", None,
                                 maxval=1000, minval=0.01, noprompt=True))
   params.append(starutil.Par0S("RESTART", "Restart using old files?", None,
                                 noprompt=True))
   params.append(starutil.Par0L("RETAIN", "Retain temporary files?", False,
                                 noprompt=True))
   params.append(starutil.Par0S("QUDIR", "Directory containing "
                                "pre-existing Q/U data", None, noprompt=True))
   params.append(starutil.Par0S("TABLE", "Output table holding raw and fitted "
                                "Q/U values", None, noprompt=True))
   params.append(starutil.Par0S("TABLEIN", "Input table holding raw "
                                "Q/U values", None, noprompt=True))

#  Initialise the parameters to hold any values supplied on the command
#  line.
   parsys = ParSys( params )

#  It's a good idea to get parameter values early if possible, in case
#  the user goes off for a coffee whilst the script is running and does not
#  see a later parameter propmpt or error...

#  Get the name of the output table.
   table = parsys["TABLE"].value

#  Get the name of the input table.
   tablein = parsys["TABLEIN"].value
   if not tablein:

#  Get the observation list. Verify it exists, and then read the contents
#  into a list.
      obslist_file = parsys["OBSLIST"].value
      if not os.path.isfile(obslist_file):
         raise UsageError("obslist file ({0}) does not exist.".
               format(obslist_file) )
      with open(obslist_file) as f:
         obslist = f.read().splitlines()

#  Get the I reference map.
      iref = parsys["IREF"].value

#  Get the aperture diameter, in arcsec.
      diam = parsys["DIAM"].value

#  Get the directory to store Q/U files.
      qudir = parsys["QUDIR"].value

#  The user-supplied pixel size.
      pixsize = parsys["PIXSIZE"].value
      if pixsize:
         pixsizepar = "pixsize={0}".format(pixsize)
      else:
         pixsizepar = ""

#  See if old temp files are to be re-used.
      restart = parsys["RESTART"].value
      if restart == None:
         retain = parsys["RETAIN"].value

      else:
         retain = True
         NDG.tempdir = restart
         if not os.path.isdir(restart):
            raise UsageError("\n\nThe directory specified by parameter RESTART ({0}) "
                             "does not exist".format(restart) )
         msg_out( "Re-using data in {0}".format(restart) )

#  Get the value of environment variable SC2.
      if "SC2" not in os.environ:
         raise UsageError( "Environment variable SC2 is undefined - cannot "
                           "find raw SCUBA-2 data.")
      sc2 = os.environ["SC2"]

#  Get the value of environment variable STARLINK_DIR
      if "STARLINK_DIR" not in os.environ:
         raise UsageError( "Environment variable STARLINK_DIR is undefined.")
      star = os.environ["STARLINK_DIR"]

#  Create a config file to use with makemap. We use the standard POL2
#  compact source condif, except we include "pol2fp=1". This is because
#  calcqu creates the Q and U values in focal plane coords. makemap
#  normally reports an error when supplied with Q/U values in focal plane
#  coords - including "pol2fp=1" prevents this.
      conf = os.path.join(NDG.tempdir,"conf")
      fd = open(conf,"w")
      fd.write("^{0}/share/smurf/dimmconfig_pol2_compact.lis\n".format(star))
      fd.write("pol2fp=1\n")
      fd.close()

#  If restarting, load the parameter values used by this script in the
#  previous run.
      newpixsize = False
      oldpars = {}
      if restart:
         parfile = os.path.join(NDG.tempdir,"PARAMS")
         if os.path.exists( parfile ):
            with open(parfile) as f:
               lines = f.read().splitlines()
            for line in lines:
               (par,val) = line.split("=")
               oldpars[par] = float(val)

#  Has the pixel size changed?
            if "pixsize" in oldpars:
               if not pixsize or oldpars["pixsize"] != pixsize:
                  newpixsize = True
            elif pixsize:
               newpixsize = True
         else:
            if pixsize:
               newpixsize = True

#  Loop round each observation.
      actpixsize0 = None
      for obs in obslist:
         msg_out( "Doing observation {0}...".format(obs) )

#  Create an NDG object describing all NDFs containsing raw data for the
#  current observations.
         try:
            raw = NDG( "{0}/s8\?/{1}/\*".format(sc2,obs) )
         except starutil.StarUtilError:
            raw = None

#  Create Q and U time streams from the raw analysed intensity time
#  streams. These Q and U values use the focal plane Y axis as the reference
#  direction. The Q and U files are placed into a subdirectory of the NDG
#  temp directory. If the directory already exists, then re-use the files
#  in it rather than calculating them again.
         if qudir:
            obsdir = "{0}/{1}".format( qudir, obs )
         else:
            obsdir = "{0}/{1}".format( NDG.tempdir, obs )

         if not os.path.isdir(obsdir):
            if not raw:
               raise UsageError( "Cannot find raw SCUBA-2 data.")
            os.makedirs(obsdir)
            invoke("$SMURF_DIR/calcqu in={0} lsqfit=yes config=def outq={1}/\*_QT "
                   "outu={1}/\*_UT fix=yes north=!".format( raw, obsdir ) )
         else:
            msg_out("Re-using pre-calculated Q and U time streams for {0}.".format(obs))

#  Make maps from the Q and U time streams. These Q and U values are with
#  respect to the focal plane Y axis, and use (az,el) as the WCS axes. Set
#  CROTA to zero to ensure that the Y axis corresponds to elevation.
         mapfile = "{0}/qmap.sdf".format(obsdir)
         if not os.path.exists( mapfile ) or newpixsize:
            qts = NDG( "{0}/*_QT".format( obsdir ) )
            qmap = NDG( mapfile, False )
            invoke("$SMURF_DIR/makemap in={0} config=^{1} out={2} {3} "
                   "system=azel crota=0".format(qts,conf,qmap,pixsizepar))
         else:
            qmap = NDG( mapfile, True )
            msg_out("Re-using pre-calculated Q map for {0}.".format(obs))

         invoke("$KAPPA_DIR/ndftrace ndf={0} quiet".format(qmap) )
         actpixsize = float( get_task_par( "fpixscale(1)", "ndftrace" ) )
         if actpixsize0 == None:
            actpixsize0 = actpixsize
         elif actpixsize != actpixsize0:
            raise UsageError( "{0} had pixel size {1} - was expecting {2}".
                              format(qmap,actpixsize,actpixsize0))


         mapfile = "{0}/umap.sdf".format(obsdir)
         if not os.path.exists( mapfile ) or newpixsize:
            uts = NDG( "{0}/*_UT".format( obsdir ) )
            umap = NDG( mapfile, False )
            invoke("$SMURF_DIR/makemap in={0} config=^{1} out={2} {3} "
                   "system=azel crota=0".format(uts,conf,umap,pixsizepar))
         else:
            umap = NDG( mapfile, True )
            msg_out("Re-using pre-calculated U map for {0}.".format(obs))

         invoke("$KAPPA_DIR/ndftrace ndf={0} quiet".format(umap) )
         actpixsize = float( get_task_par( "fpixscale(1)", "ndftrace" ) )
         if actpixsize != actpixsize0:
            raise UsageError( "{0} had pixel size {1} - was expecting {2}".
                              format(qmap,actpixsize,actpixsize0))

#  Ensure the maps use offset coordinates so that we can assume the
#  source is centred at (0,0). This should already be the case for
#  planets, but will not be the case for non-moving objects.
         invoke( "$KAPPA_DIR/wcsattrib ndf={0} mode=set name=skyrefis "
                 "newval=origin".format(qmap) )
         invoke( "$KAPPA_DIR/wcsattrib ndf={0} mode=set name=skyrefis "
                 "newval=origin".format(umap) )

#  Ensure sky offset values are formatted as decimal seconds.
         invoke("$KAPPA_DIR/wcsattrib ndf={0} mode=set name=Format'(1)' newval='s'".format(qmap) )
         invoke("$KAPPA_DIR/wcsattrib ndf={0} mode=set name=Format'(2)' newval='s'".format(qmap) )
         invoke("$KAPPA_DIR/wcsattrib ndf={0} mode=set name=Format'(1)' newval='s'".format(umap) )
         invoke("$KAPPA_DIR/wcsattrib ndf={0} mode=set name=Format'(2)' newval='s'".format(umap) )

#  Form the polarised intensity map (no de-biassing), and remove the
#  spectral axis.
         tmp1 = NDG( 1 )
         invoke( "$KAPPA_DIR/maths exp=\"'sqrt(ia**2+ib**2)'\" ia={0} ib={1} out={2}"
                 .format(qmap,umap,tmp1) )
         pimap = NDG( 1 )
         invoke( "$KAPPA_DIR/ndfcopy in={0} out={1} trim=yes".format(tmp1,pimap) )

#  Find the position of the source centre in sky coords within the polarised
#  intensity map.
         invoke("$KAPPA_DIR/centroid ndf={0} mode=int init=\"'0,0'\"".format(pimap) )
         xcen = get_task_par( "xcen", "centroid" )
         ycen = get_task_par( "ycen", "centroid" )

#  Get the elevation at the middle of the observation.
         el1 = float( get_fits_header( qmap, "ELSTART" ) )
         el2 = float( get_fits_header( qmap, "ELEND" ) )
         el = 0.5*( el1 + el2 )
         elist.append( el )

#  Get the azimuth at the middle of the observation.
         az1 = float( get_fits_header( qmap, "AZSTART" ) )
         az2 = float( get_fits_header( qmap, "AZEND" ) )
         az = 0.5*( az1 + az2 )
         alist.append( az )

#  Get the WVM tau at the middle of the observation.
         w1 = float( get_fits_header( qmap, "WVMTAUST" ) )
         w2 = float( get_fits_header( qmap, "WVMTAUEN" ) )
         w = 0.5*( w1 + w2 )
         wvmlist.append( w )

#  Get other environmental values.
         m = re.compile("T(\d\d):(\d\d):(\d\d)").search(get_fits_header( qmap, "HSTSTART" ))
         if m:
             w1 = float(m.group(1))+float(m.group(2))/60+float(m.group(3))/3600
         m = re.compile("T(\d\d):(\d\d):(\d\d)").search(get_fits_header( qmap, "HSTEND" ))
         if m:
             w2 = float(m.group(1))+float(m.group(2))/60+float(m.group(3))/3600
         w = 0.5*( w1 + w2 )
         hstlist.append( w )

         w1 = float( get_fits_header( qmap, "ATSTART" ) )
         w2 = float( get_fits_header( qmap, "ATEND" ) )
         w = 0.5*( w1 + w2 )
         atlist.append( w )

         w1 = float( get_fits_header( qmap, "HUMSTART" ) )
         w2 = float( get_fits_header( qmap, "HUMEND" ) )
         w = 0.5*( w1 + w2 )
         humlist.append( w )

         w1 = float( get_fits_header( qmap, "BPSTART" ) )
         w2 = float( get_fits_header( qmap, "BPEND" ) )
         w = 0.5*( w1 + w2 )
         bplist.append( w )

         w1 = float( get_fits_header( qmap, "WNDSPDST" ) )
         w2 = float( get_fits_header( qmap, "WNDSPDEN" ) )
         w = 0.5*( w1 + w2 )
         wndspdlist.append( w )

         w1 = float( get_fits_header( qmap, "WNDDIRST" ) )
         w2 = float( get_fits_header( qmap, "WNDDIREN" ) )
         w = 0.5*( w1 + w2 )
         wnddirlist.append( w )

         w1 = float( get_fits_header( qmap, "FRLEGTST" ) )
         w2 = float( get_fits_header( qmap, "FRLEGTEN" ) )
         w = 0.5*( w1 + w2 )
         frleglist.append( w )

         w1 = float( get_fits_header( qmap, "BKLEGTST" ) )
         w2 = float( get_fits_header( qmap, "BKLEGTEN" ) )
         w = 0.5*( w1 + w2 )
         bkleglist.append( w )

#  Append the UT and obs number to the corresponding lists.
         utlist.append( int( float( get_fits_header( qmap, "UTDATE" ) ) ) )
         obsnumlist.append( int( float( get_fits_header( qmap, "OBSNUM" ) ) ) )

#  If we are using the weighted mean, use beamfit to fit a beam to the polarised
#  intensity source and then get the weighted mean Q and U values value.
         if diam <= 0.0:
            try:
               bresid2 = NDG(1)
               invoke("$KAPPA_DIR/beamfit ndf={0}'(0~30,0~30)' pos=\"'{1},{2}'\" "
                      "gauss=no mode=int resid={3}".format(pimap,xcen,ycen,bresid2) )

#  Blank out residuals that are more than 3 sigma. The sidelobes should
#  be blanked out by this process.
               invoke("$KAPPA_DIR/stats ndf={0}".format(bresid2) )
               lim = 3*get_task_par( "sigma", "stats" )

               masked = NDG(1)
               invoke("$KAPPA_DIR/maths exp=\"'qif((abs(ib)<pa),ia,<bad>)'\" "
                      "ib={0} ia={1} out={2} pa={3}".
                      format(bresid2,pimap,masked,lim) )

#  Run beamfit again on the masked PI map to get a better fit on the
#  central component.
               bresid = NDG(1)
               invoke("$KAPPA_DIR/beamfit ndf={0}'(0~30,0~30)' pos=\"'{1},{2}'\" "
                      "gauss=no mode=int resid={3}".format(masked,xcen,ycen,bresid) )

#  Store the geometric parameters of the fit.
               fwhm1list.append( degrees( get_task_par( "majfwhm(1)", "beamfit" ))*3600 )
               fwhm2list.append( degrees( get_task_par( "minfwhm(1)", "beamfit" ))*3600 )
               orientlist.append( get_task_par( "orient(1)", "beamfit" ) )
               gammalist.append( get_task_par( "gamma(1)", "beamfit" ) )

#  Subtract the residuals from the data to get the beam model.
               tmodel = NDG(1)
               invoke("$KAPPA_DIR/sub in1={0} in2={1} out={2}".format(pimap,bresid,tmodel) )

#  Modify the model so that is has a minimum value of zero.
               invoke("$KAPPA_DIR/stats ndf={0}".format(tmodel) )
               vmin = get_task_par( "minimum", "stats" )
               bmodel = NDG(1)
               invoke("$KAPPA_DIR/csub in={0} scalar={1} out={2}".format(tmodel,vmin,bmodel) )

#  Multiply the model by the Q data, and get the total sum of the product.
               tmp = NDG(1)
               invoke("$KAPPA_DIR/mult in1={0} in2={1} out={2}".format(qmap,bmodel,tmp) )
               invoke("$KAPPA_DIR/stats ndf={0}".format(tmp) )
               wqsum = get_task_par( "total", "stats" )

#  Multiply the squared model by the Q variance values, and get the total sum of the product.
               qvw = NDG( 1 )
               invoke("$KAPPA_DIR/maths exp=\"'ib*ib*va'\" va={0} ib={1} out={2}".
                      format( qmap, bmodel, qvw ))
               invoke("$KAPPA_DIR/stats ndf={0}".format(qvw))
               wwqvsum = get_task_par( "total", "stats" )

#  Multiply the model by the U data, and get the total sum of the product.
               tmp = NDG(1)
               invoke("$KAPPA_DIR/mult in1={0} in2={1} out={2}".format(umap,bmodel,tmp) )
               invoke("$KAPPA_DIR/stats ndf={0}".format(tmp) )
               wusum = get_task_par( "total", "stats" )

#  Multiply the squared model by the U variance values, and get the total sum of the product.
               uvw = NDG( 1 )
               invoke("$KAPPA_DIR/maths exp=\"'ib*ib*va'\" va={0} ib={1} out={2}".
                      format( umap, bmodel, uvw ))
               invoke("$KAPPA_DIR/stats ndf={0}".format(uvw))
               wwuvsum = get_task_par( "total", "stats" )

#  Get the total sum of the model.
               invoke("$KAPPA_DIR/stats ndf={0}".format(bmodel) )
               wsum = get_task_par( "total", "stats" )

#  Get the weighted mean Q and U values and append them to the end of the list of Q
#  and U values.
               qlist.append( wqsum/wsum )
               ulist.append( wusum/wsum )

#  Get the error on the weighted means and append them to the end of the lists.
               dqlist.append( sqrt(wwqvsum)/wsum )
               dulist.append( sqrt(wwuvsum)/wsum )

#  If beamfit failed, we cannot store q and u values, so remove the
#  corresponding item from the other arrays (i.e the last element of each
#  array).
            except starutil.StarUtilError:
               del obsnumlist[-1]
               del wvmlist[-1]
               del alist[-1]
               del elist[-1]
               del utlist[-1]
               del hstlist[-1]
               del atlist[-1]
               del humlist[-1]
               del bplist[-1]
               del wndspdlist[-1]
               del wnddirlist[-1]
               del frleglist[-1]
               del bkleglist[-1]

#  Otherwise, get the mean Q value in a circle of diameter given by parameter
#  DIAM centred on the source.
         else:
            mask = NDG( 1 )
            invoke("$KAPPA_DIR/aperadd ndf={0} centre=\"'{2},{3}'\" diam={1} mask={4}".format(qmap,diam,xcen,ycen,mask))
            qlist.append( get_task_par( "mean", "aperadd" ) )

#  Mask out all Q values outside the circle.
            qmasked = NDG( 1 )
            invoke("$KAPPA_DIR/copybad in={0} out={1} ref={2}".
                    format(qmap,qmasked,mask))

#  Get the mean Q variance value inside the circle. Also get the number
#  of good variance values inside the cirle. Thus calculate and store the
#  error on the mean Q value.
            invoke("$KAPPA_DIR/stats ndf={0} comp=var".format(qmasked))
            vmean = get_task_par( "mean", "stats" )
            vnum = get_task_par( "numgood", "stats" )
            dqlist.append( sqrt(vmean)/vnum )

#  Likewise, store the mean U value in the same circle, and the
#  associated error on the mean.
            invoke("$KAPPA_DIR/aperadd ndf={0} centre=\"'{2},{3}'\" diam={1}".format(umap,diam,xcen,ycen))
            ulist.append( get_task_par( "mean", "aperadd" ) )

            umasked = NDG( 1 )
            invoke("$KAPPA_DIR/copybad in={0} out={1} ref={2}".
                    format(umap,umasked,mask))
            invoke("$KAPPA_DIR/stats ndf={0} comp=var".format(umasked))
            vmean = get_task_par( "mean", "stats" )
            vnum = get_task_par( "numgood", "stats" )
            dulist.append( sqrt(vmean)/vnum )

#  Now all observations are done, get the corresponding I value. First get rid
#  of any spectral axis and resample the supplied I map onto the same pixel
#  size as the Q an U maps.
      junk = NDG(1)
      invoke("$KAPPA_DIR/ndfcopy in={0} trim=yes out={1}".format(iref,junk) )
      invoke("$KAPPA_DIR/wcsattrib ndf={0} mode=set name=skyrefis "
             "newval=origin".format(junk) )
      invoke("$KAPPA_DIR/wcsattrib ndf={0} mode=set name=Format'(1)' newval='s'".format(junk) )
      invoke("$KAPPA_DIR/wcsattrib ndf={0} mode=set name=Format'(2)' newval='s'".format(junk) )
      if pixsize:
         imap = NDG(1)
         invoke("$KAPPA_DIR/sqorst in={0} mode=pix pixscale=\\\"{1},{1}\\\" out={2}".
                format(junk,pixsize,imap) )
      else:
         imap = junk
      invoke("$KAPPA_DIR/ndftrace ndf={0} quiet".format(imap) )
      actpixsize = float( get_task_par( "fpixscale(1)", "ndftrace" ) )
      if actpixsize != actpixsize0:
         raise UsageError( "IREF map had pixel size {0} - was expecting {1}".
                           format(actpixsize,actpixsize0))

#  Find the position of the source centre in sky offsets within the total intensity map.
      invoke("$KAPPA_DIR/centroid ndf={0} mode=int init=\"'0,0'\"".format(imap) )
      xcen = get_task_par( "xcen", "centroid" )
      ycen = get_task_par( "ycen", "centroid" )

#  If we are using weighted mean values, use beamfit to fit a beam to the total
#  intensity source.
      if diam <= 0.0:
         bresid = NDG(1)
         invoke("$KAPPA_DIR/beamfit ndf={0}'(0~30,0~30)' pos=\"'{1},{2}'\" "
                "gauss=no mode=int resid={3}".format( imap,xcen,ycen,bresid) )

#  Subtract the residuals from the data to get the beam model.
         tmodel = NDG(1)
         invoke("$KAPPA_DIR/sub in1={0} in2={1} out={2}".format(imap,bresid,tmodel) )

#  Modify the model so that is has a minimum value of zero.
         invoke("$KAPPA_DIR/stats ndf={0}".format(tmodel) )
         vmin = get_task_par( "minimum", "stats" )
         bmodel = NDG(1)
         invoke("$KAPPA_DIR/csub in={0} scalar={1} out={2}".format(tmodel,vmin,bmodel) )

#  Multiply the model by the I data, and get the total sum of the product.
         tmp = NDG(1)
         invoke("$KAPPA_DIR/mult in1={0} in2={1} out={2}".format(imap,bmodel,tmp) )
         invoke("$KAPPA_DIR/stats ndf={0}".format(tmp) )
         wisum = get_task_par( "total", "stats" )

#  Get the total sum of the model.
         invoke("$KAPPA_DIR/stats ndf={0}".format(bmodel) )
         wsum = get_task_par( "total", "stats" )

#  Get the weighted mean I value.
         ival = wisum/wsum

#  Otherwise, find the mean I value in the aperture centred on the
#  accurate source centre.
      else:
         invoke("$KAPPA_DIR/aperadd ndf={0} centre=\"'{2},{3}'\" diam={1}".format(imap,diam,xcen,ycen))
         ival = get_task_par( "mean", "aperadd" )

#  If an input table was supplied, read its contents.
   else:
      diam = -999.0
      ival = 0.0
      iref = 0.0
      actpixsize0 = 0.0
      lines  = []
      bad = False
      with open(tablein,"r") as f:
        for line in f:
           m = re.compile("# DIAM = (\S+)").match(line)
           if m:
              diam = float(m.group(1))

           m = re.compile("# Total intensity value = (\S+) pW").match(line)
           if m:
              ival = float(m.group(1))

           m = re.compile("# PIXSIZE = (\S+)").match(line)
           if m:
              actpixsize0 = float(m.group(1))

           m = re.compile("# IREF = '(\S+)'").match(line)
           if m:
              iref = m.group(1)

           if line.startswith("# ut obs az el q dq u du pi ang p qfit ufit "
               "pifit pfit tau tran rej hst at hum bp wndspd wnddir frleg bkleg"):
              bad = False
           elif not line.startswith("#"):
              lines.append(line)

      if diam == -999.0 or ival == 0.0 or bad:
         raise UsageError( "TABLEIN file ('{0}') has unexpected structure.".
                           format(tablein))
      else:
         for line in lines:
            words = line.split()
            utlist.append( float( words[0] ) )
            obsnumlist.append( float( words[1] ) )
            alist.append( float( words[2] ) )
            elist.append( float( words[3] ) )
            qlist.append( float( words[4] ) )
            dqlist.append( float( words[5] ) )
            ulist.append( float( words[6] ) )
            dulist.append( float( words[7] ) )
            wvmlist.append( float( words[15] ) )
            atlist.append( float( words[19] ) )
            humlist.append( float( words[20] ) )
            bplist.append( float( words[21] ) )
            wndspdlist.append( float( words[22] ) )
            wnddirlist.append( float( words[23] ) )
            frleglist.append( float( words[24] ) )
            bkleglist.append( float( words[25] ) )

            m = re.compile("T(\d\d):(\d\d):(\d\d)").search(words[18])
            if m:
               hst = float(m.group(1))+float(m.group(2))/60+float(m.group(3))/3600
               hstlist.append( hst )
            else:
               hstlist.append( float( words[18] ) )

#  Normalize dq and du values to a mean of unity. This is to ensure the
#  weights (1/dq**2 and 1/du**2) are scaled nicely.
   mean = np.array(dqlist).mean()
   dqlist = [x / mean for x in dqlist]
   dulist = [x / mean for x in dulist]

#  Record original lists before we reject any points.
   qlist0 = qlist
   ulist0 = ulist
   dqlist0 = dqlist
   dulist0 = dulist
   elist0 = elist

#  We now do the fit. Loop doing succesive fits, rejecting outliers on
#  each pass (i.e. sigma clipping).
   if dofit:
      msg_out( "Doing fit..." )
      for i in range(0,3):
         msg_out( "\nIteration {0}: Fitting to {1} data points...".format(i+1,len(elist)) )

#  Initial guess at model parameters (a constant 1% IP parallel to
#  elevation).
         x0 = np.array([0.01,0.0,0.0])

#  Do a fit to find the optimum model parameters.
         res = minimize( objfun, x0, method='nelder-mead',
                         options={'xtol': 1e-5, 'disp': True})

#  Find RMS Q residual between data and fit.
         qrms = resid( True, res.x )

#  Remove Q points more than 2 sigma from the fit.
         reject( True, 2*qrms, res.x )

#  Find RMS U residual between data and fit.
         urms = resid( False, res.x )

#  Remove U points more than 2 sigma from the fit.
         reject( False, 2*urms, res.x )

#  Display results.
      (a,b,c) = res.x
      msg_out("\n\nA={0} B={1} C={2}".format(a,b,c))
      msg_out("Q RMS = {0} pW  U RMS = {1} pW\n".format(qrms,urms))
      msg_out("Qn RMS = {0}   Un RMS = {1} \n".format(qrms/ival,urms/ival))


#  If we have models for all beams, produce fits of FWHM1 and FWHM2 (in
#  arc-seconds) against elevation (in degrees), shape parameter (gamma)
#  against beam area (in square arc-seconds), and orientation (in
#  degrees, from elevation axis to azimuth axis) against azimuth
#  (in degrees).
      if diam <= 0.0:

         (a1,b1,c1) = fitquad( "FWHM1 against elevation", 14.0, 0.0, 0.0, elist0, fwhm1list )
         (a2,b2,c2) = fitquad( "FWHM2 against elevation", 14.0, 0.0, 0.0, elist0, fwhm2list )

         for i in range(len(elist0)):
            arealist.append( fwhm1list[i]*fwhm2list[i] )

         (ag,bg,cg) = fitquad( "Gamma against area", 2.4, 0.0, 0.0, arealist, gammalist )
         (ao,bo,co) = fitquad( "Orientation against azimuth", 90.0, 0.0, 0.0, alist, orientlist )

         fd = open( "beamfit.asc", "w" )
         fd.write("#\n")
         fd.write("# FWHM1: {0} {1} {2}\n".format(a1,b1,c1) )
         fd.write("# FWHM2: {0} {1} {2}\n".format(a2,b2,c2) )
         fd.write("# Gamma: {0} {1} {2}\n".format(ag,bg,cg) )
         fd.write("# Orientation: {0} {1} {2}\n".format(ao,bo,co) )
         fd.write("# az el fwhm1 fwhm2 gamma orient fwhm1fit fwhm2fit gammafit orientfit\n" )

         for i in range(len(elist0)):
            fwhm1fit = a1 + b1*elist0[i] + c1*elist0[i]*elist0[i]
            fwhm2fit = a2 + b2*elist0[i] + c2*elist0[i]*elist0[i]
            area = fwhm1fit*fwhm2fit
            gammafit = ag + bg*area + cg*area*area
            orientfit = ao + bo*alist[i] + co*alist[i]*alist[i]
            fd.write("{0} {1} {2} {3} {4} {5} {6} {7} {8} {9}\n".format(alist[i], elist0[i],
                     fwhm1list[i], fwhm2list[i], gammalist[i], orientlist[i],
                     fwhm1fit, fwhm2fit, gammafit, orientfit ))
         fd.close()
         msg_out( "Beam fit values written to beamfit.asc." )

   else:
      msg_out( "Skipping fit because scipy is not available." )

#  Write a table showing the Q and U values and the fits.
   if table:
      fd = open( table, "w" )
      fd.write("#\n")
      fd.write("# DIAM = {0}\n".format(diam))
      fd.write("# IREF = {0}\n".format(iref))
      fd.write("# PIXSIZE = {0}\n".format(actpixsize0))
      fd.write("# Total intensity value = {0} pW\n".format(ival))
      fd.write("#\n")
      if dofit:
         fd.write("# A={0} B={1} C={2}\n".format(a,b,c))
         fd.write("# Q RMS = {0} pW  U RMS = {1} pW\n".format(qrms,urms))
         fd.write("# Qn RMS = {0}   Un RMS = {1} \n".format(qrms/ival,urms/ival))
         fd.write("#\n")

      fd.write("# ut obs az el q dq u du pi ang p qfit ufit pifit pfit tau tran rej "
               "hst at hum bp wndspd wnddir frleg bkleg" )
      if diam <= 0.0:
         fd.write(" fwhm1 fwhm2 orient gamma" )
      fd.write("\n")

      for i in range(len(elist0)):
         el = elist0[i]
         if dofit:
            if el in elist and qlist0[i] in qlist and ulist0[i] in ulist:
               rej = 0
            else:
               rej = 1
            (qfp,ufp) = model2( elist0[i], res.x )
            pifit = sqrt( qfp*qfp + ufp*ufp )
            pfit = pifit/ival
         else:
            rej = 0
            qfp = "null"
            ufp = "null"
            pifit = "null"
            pfit = "null"

         tau = wvmlist[i]
         tran = exp(-4.6*(tau-0.00435)/sin(radians(el)))
         q = qlist0[i]
         u = ulist0[i]
         dq = dqlist0[i]
         du = dulist0[i]
         pi = sqrt( q*q + u*u )
         ang = degrees( 0.5*atan2( u, q ) )
         p = pi/ival

         fd.write("{0} {1} {2} {3} {4} {5} {6} {7} {8} {9} {10} {11} {12} "
                  "{13} {14} {15} {16} {17} {18} {19} {20} {21} {22} {23} "
                  "{24} {25}"
                  .format(utlist[i], obsnumlist[i],
                  alist[i], el, q, dq, u, du, pi, ang, p, qfp, ufp, pifit, pfit,
                  tau, tran, rej, hstlist[i], atlist[i], humlist[i],
                  bplist[i], wndspdlist[i], wnddirlist[i], frleglist[i],
                  bkleglist[i] ))
         if diam <= 0.0:
            fd.write(" {0} {1} {2} {3}".format(fwhm1list[i],fwhm2list[i],orientlist[i],gammalist[i]))
         fd.write("\n")

      fd.close()
      msg_out("\nTable written to file '{0}'".format(table))

#  Save the parameter values used in this script in case we want to
#  re-use the intermediate files in a later run.
   if retain:
      parfile = os.path.join(NDG.tempdir,"PARAMS")
      fd = open( parfile, "w" )
      fd.write("diam={0}\n".format(diam))
      if pixsize:
         fd.write("pixsize={0}\n".format(pixsize))

#  Remove temporary files.
   cleanup()

#  If an StarUtilError of any kind occurred, display the message but hide the
#  python traceback. To see the trace back, uncomment "raise" instead.
except starutil.StarUtilError as err:
#  raise
   print( err )
   cleanup()

# This is to trap control-C etc, so that we can clean up temp files.
except:
   cleanup()
   raise








