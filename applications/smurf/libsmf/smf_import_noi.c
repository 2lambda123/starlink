/*
*+
*  Name:
*     smf_import_noi

*  Purpose:
*     Import noise values for the NOI model.

*  Language:
*     Starlink ANSI C

*  Type of Module:
*     C function

*  Invocation:
*     int smf_import_noi( const char *name, smfDIMMHead *head,
*                         AstKeyMap *keymap, double *dataptr, int *status )

*  Arguments:
*     name = const char * (Given)
*        The name of the container file without a suffix.
*     head = smfDIMMHead * (Given)
*        Defines the shape and size of the NOI model.
*     *keymap = AstKeyMap * (Given)
*        The config parameters for makemap.
*     dataptr = double * (Returned)
*        The array in which to return the noise values.
*     status = int* (Given and Returned)
*        Pointer to global status.

*   Returned Value:
*     Non-zero if values were imported successfully. Zero otherwise.

*  Description:
*     This function checks the NOI.IMPORT config parameter. If it set to
*     "Data" or "Variance", it imports the named component from an NDF
*      such as generated by a previous run of makemap with EXPORTNDF=NOI,
*      compresses it down to the size specified by heaed, and stores it
*      in the supplied dataptr array.

*  Authors:
*     David S Berry (JAC, Hawaii)
*     {enter_new_authors_here}

*  History:
*     24-SEP-2013 (DSB):
*        Original version.
*     {enter_further_changes_here}

*  Copyright:
*     Copyright (C) 2013 Science & Technology Facilities Council.
*     All Rights Reserved.

*  Licence:
*     This program is free software; you can redistribute it and/or
*     modify it under the terms of the GNU General Public License as
*     published by the Free Software Foundation; either version 3 of
*     the License, or (at your option) any later version.
*
*     This program is distributed in the hope that it will be
*     useful, but WITHOUT ANY WARRANTY; without even the implied
*     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
*     PURPOSE. See the GNU General Public License for more details.
*
*     You should have received a copy of the GNU General Public
*     License along with this program; if not, write to the Free
*     Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
*     MA 02110-1301, USA

*  Bugs:
*     {note_any_bugs_here}
*-
*/

/* Starlink includes */
#include "sae_par.h"
#include "mers.h"
#include "ndf.h"
#include "ast.h"

/* SMURF includes */
#include "libsmf/smf.h"

int smf_import_noi( const char *name, smfDIMMHead *head, AstKeyMap *keymap,
                    double *dataptr, int *status ){

/* Local Variables */
   AstKeyMap *kmap = NULL;   /* NOI config parameters */
   char *ename = NULL;       /* Name of file to import */
   const char *import = NULL;/* The value of the IMPORT parameter */
   double *dp;               /* Pointer to next element of NOI model */
   double *ip;               /* Pointer to NDF array */
   int dims[ 3 ];            /* NDF dimensions */
   int el;                   /* Number of mapped array elements */
   int ibolo;                /* Index of current bolometer */
   int indf;                 /* NDF identifier */
   int isTordered;           /* Is NOI model time ordered? */
   int itime;                /* Index of current time slice */
   int nbolo;                /* Number of bolometers */
   int nc;                   /* Current length of string */
   int ndim;                 /* Number of NDF dimensions */
   int nointslice;           /* Number of time slices in NOI model */
   int result ;              /* Value to return */

/* Initialise. */
   result = 0;

/* Check inherited status. */
   if( *status != SAI__OK ) return result;

/* Is the NOI model time-ordered? */
   isTordered = ( head->data.dims[ 0 ] == 32 && head->data.dims[ 1 ] == 40 );

/* Number of time slices in NOI model. */
   nointslice = isTordered ? head->data.dims[ 2 ] : head->data.dims[ 0 ];

/* Get a keymap holding the NOI model parameters. */
   astMapGet0A( keymap, "NOI", &kmap );

/* Do nothing more if the IMPORT param is undefined. */
   if( astMapDefined( kmap, "IMPORT" ) ){

/* Get the value of the IMPORT param. Report an error if it is not one of
   the allowed values (case insensitive). */
      astMapGet0C( kmap, "IMPORT", &import );
      if( !astChrMatch( import, "Data" ) &&
          !astChrMatch( import, "Variance" ) && *status == SAI__OK ) {
         *status = SAI__ERROR;
         errRepf( "", "Illegal value '%s' for parameter NOI.IMPORT - "
                  "should be 'Variance' or 'Data'.", status, import );

/* Append "_res" to the container file name (the noise values are
   exported as the Variance component associated with the residuals). */
      } else if( *status == SAI__OK ){
         nc = strstr( name, "_con" ) - name + 4;
         ename = astStore( NULL, name, nc + 1 );
         ename[ nc ] = 0;
         ename = astAppendString( ename, &nc, "_res" );

/* Attempt to open the NDF. */
         ndfFind( NULL, ename, &indf, status );

/* Get the dimensions of the NDF. Abort if they are incorrect. */
         ndfDim( indf, 3, dims, &ndim, status );
         if( ndim != 3 && *status == SAI__OK ) {
            *status = SAI__ERROR;
            errRepf( "", "Illegal number of dimensions (%d) in '%s' - "
                     "must be 3.", status, ndim, ename );
         }

         if( ( dims[ 0 ] != 32 || dims[ 1 ] != 40 ) && *status == SAI__OK ) {
            *status = SAI__ERROR;
            errRepf( "", "Illegal dimensions (%d,%d) for axes 1 and 2 in "
                     "'%s' - must be (32,40).", status, dims[0], dims[1],
                     ename );
         }

         if( nointslice > 1 ) {
            if( dims[ 2 ] != nointslice && dims[ 2 ] != 1 && *status == SAI__OK ) {
               *status = SAI__ERROR;
               errRepf( "", "Illegal dimension (%d) for axis 3 in '%s' - must "
                        "be 1 or %d.", status, dims[2], ename, nointslice );
            }
         }

/* Map the required component of the NDF. */
         ndfMap( indf, import, "_DOUBLE", "READ", (void **) &ip, &el,
                 status );

/* Check we can use the pointers safely. */
         if( *status == SAI__OK ) {

/* Number of bolometers. */
            nbolo = dims[ 0 ]*dims[ 1 ];

/* If the NOI model contains only a single value for each bolometer, we
   copy one slice from the NDF. Time or bolo ordering makes no difference
   in this case. */
            if( nointslice == 1 ) {
               memcpy( dataptr, ip, nbolo*sizeof( *dataptr ) );

/* If the NOI model contains bolometer values for every time slice, we
   may need to re-order the data. */
            } else if( isTordered ){
               memcpy( dataptr, ip, el*sizeof( *dataptr ) );

            } else {
               for( itime = 0; itime < dims[ 2 ]; itime++ ) {
                  dp = dataptr + itime;
                  for( ibolo = 0; ibolo < nbolo; ibolo++ ) {
                     *dp = *(ip++);
                     dp += nointslice;
                  }
               }
            }

/* Indicate we have succesfully imported some NOI values. */
            result = 1;
         }

/* Close the NDF. */
         ndfAnnul( &indf, status );

/* Add a context message if anything went wrong. */
         if( *status != SAI__OK ) {
            errRepf( "", "Failed to import NOI values from NDF specified "
                     "by parameter NOI.IMPORT (%s).", status, ename );
         }
      }
   }

/* Free resources. */
   ename = astFree( ename );
   kmap = astAnnul( kmap );

/* Return the result. */
   return result;
}

