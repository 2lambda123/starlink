/* -*- C -*-
*+
*  Name:
*     smf_stats1

*  Purpose:
*     Low-level routine for calculating mean and standard deviation of
*     a data array.

*  Language:
*     Starlink ANSI C

*  Type of Module:
*     Subroutine

*  Invocation:
*     void smf_stats1<X>( const CGEN_TYPE *data, size_t stride, size_t nsamp,
*                         const smf_qual_t *qual, size_t qstride,
*                         smf_qual_t mask, double *mean, double *sigma,
*                         double *median, size_t *ngood, int *status )

*  Arguments:
*     data = const CGEN_TYPE* (Given)
*        Pointer to input data array
*     stride = size_t (Given)
*        Index stride between elements
*     nsamp = size_t (Given)
*        Length of the interval to analyze
*     qual = const smf_qual_t* (Given)
*        If specified, use this QUALITY array to decide which samples
*        to use (provided mask). Otherwise data are only ignored if set
*        to CGEN_BAD.
*     qstride = size_t (Given)
*        Stride for qual. If 0 assumed to be stride.
*     mask = smf_qual_t (Given)
*        Use with qual to define which bits in quality are relevant to
*        ignore data in the calculation.
*     mean = double* (Given and Returned)
*        Pointer to variable that will contain the mean of the data.
*     sigma = double* (Given and Returned)
*        Pointer to variable that will contain the standard deviation of
*        the data. If NULL this routine will run faster and not calculate
*        the standard deviation.
*     median = double* (Given and Returned)
*        Pointer to variable that will contain median of the data. If
*        NULL this routine will not calculate the median and run faster.
*     ngood = size_t* (Given and Returned)
*        Pointer to variable that will indicate how many samples were used
*        to calculate the statistics.
*     status = int* (Given and Returned)
*        Pointer to global status.

*  Description:
*     Calculate mean and standard deviation provided there is at least
*     1 good sample. If requested, medians are calculated by sorting
*     the data with the system qsort routine and picking off the
*     central value. However, status is set to SMF__INSMP if there are
*     not at least SMF__MINSTATSAMP good samples.

*  Notes:
*     The algorithm is "naive" and may suffer roundoff problems. It may be
*     necessary to switch to a (slower) compensated method. See:
*     http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance

*  Authors:
*     Edward Chapin (UBC)
*     TIMJ: Tim Jenness (JAC, Hawaii)
*     {enter_new_authors_here}

*  History:
*     2008-03-06 (EC):
*        Initial version
*     2008-04-18 (EC):
*        Use SMF__MINSTATSAMP for sample length check
*     2008-08-29 (TIMJ):
*        Initialise return values even if status is bad on entry.
*     2008-12-15 (EC):
*        Remove initial time slice from interface, and add stride parameter.
*     2009-12-03 (EC):
*        Make this a generic function
*     2010-02-04 (EC):
*        Add qstride to interface, and switch to size_t from dim_t for
*        stride/nsamp
*     2011-06-16 (EC):
*        Add median
*     {enter_further_changes_here}

*  Copyright:
*     Copyright (C) 2008 Science and Technology Facilities Council.
*     Copyright (C) 2008-2011 University of British Columbia.
*     All Rights Reserved.

*  Licence:
*     This program is free software; you can redistribute it and/or
*     modify it under the terms of the GNU General Public License as
*     published by the Free Software Foundation; either version 3 of
*     the License, or (at your option) any later version.
*
*     This program is distributed in the hope that it will be
*     useful, but WITHOUT ANY WARRANTY; without even the implied
*     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
*     PURPOSE. See the GNU General Public License for more details.
*
*     You should have received a copy of the GNU General Public
*     License along with this program; if not, write to the Free
*     Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
*     MA 02111-1307, USA

*  Bugs:
*     {note_any_bugs_here}
*-
*/

/* Standard includes */
#include <math.h>
#include <stdlib.h>

/* Starlink includes */
#include "sae_par.h"
#include "ast.h"
#include "mers.h"
#include "msg_par.h"
#include "prm_par.h"

/* SMURF includes */
#include "smf.h"
#include "smurf_par.h"
#include "smurf_typ.h"
#include "libsmf/smf_err.h"

/* Local comparison function for sorting -------------------------------------*/

/* Since this is a generic function we need the #ifndef to avoid re-defining
   the function for each data type */

#ifndef SMFSTATS1COMPARE_DEFINED
#define SMFSTATS1COMPARE_DEFINED

int smfStats1Compare( const void *arg1, const void *arg2 );

int smfStats1Compare( const void *arg1, const void *arg2 ) {
  double diff;
  const double *d1 = arg1;
  const double *d2 = arg2;

  diff = *d1 - *d2;
  return (diff < 0) ? -1 : (diff == 0) ? 0 : 1;
}
#endif

/* Main function -------------------------------------------------------------*/

/* Simple default string for errRep */
#define FUNC_NAME "smf_stats1"

void CGEN_FUNCTION(smf_stats1)( const CGEN_TYPE *data, size_t stride,
                                size_t nsamp, const smf_qual_t *qual,
                                size_t qstride, smf_qual_t mask, double *mean,
                                double *sigma, double *median, size_t *ngood,
                                int *status ) {

  /* Local variables */
  size_t count=0;             /* Number of samples in estimate */
  size_t i;                   /* Loop counter */
  size_t j;                   /* Loop counter */
  double mu=0;                /* Estimate of the mean */
  double sum=0;               /* Sum of the data */
  double sumsq=0;             /* Sum of the square of the data */

  /* initialise return values */
  if (sigma) *sigma = VAL__BADD;
  if (ngood) *ngood = 0;
  if (mean) *mean = VAL__BADD;
  if (median) *median = VAL__BADD;

  /* Check status */
  if (*status != SAI__OK) return;

  if( !data ) {
    *status = SAI__ERROR;
    errRep( "", FUNC_NAME ": NULL data supplied", status );
    return;
  }

  if( !stride ) {
    *status = SAI__ERROR;
    errRep(" ", FUNC_NAME ": stride cannot be 0", status);
    return;
  }

  /* Assume qstride = stride if not specified */
  if( !qstride ) {
    qstride = stride;
  }

  /* Initialization */
  if( qual ) {
    /* Quality checking version */

    if( sigma ) {
      /* Standard deviation + mean calculating version */
      j = 0;
      for( i=0; i<nsamp*stride; i+=stride ) {
        if( !(qual[j] & mask) ) {
          sum += (double) data[i];
          sumsq += ((double) data[i]) * ((double) data[i]);
          count++;
        }
        j += qstride;
      }
    } else {
      /* Always calculate mean... even if we're only asking for the
         median we only have to count the number of good samples here,
         and the calculation is fast compared to sorting to get the
         median. */
      j = 0;
      for( i=0; i<nsamp*stride; i+=stride ) {
        if( !(qual[j] & mask) ) {
          sum += (double) data[i];
          count++;
        }
        j += qstride;
      }
    }

    /* Median calculation is independent of mean / standard deviation except
       that we know how many good values there are from the mean calculation */
    if( median && count) {
      double *sortbuf=NULL;

      /* Put all of the good values into a buffer that we can sort */
      sortbuf = astCalloc( count, sizeof(*sortbuf) );

      if( *status == SAI__OK ) {
        size_t index = 0;
        for( i=0; i<nsamp*stride; i+=stride ) {
          if( !(qual[j] & mask) ) {
            sortbuf[index] = (double) data[i];
            index++;
          }
        }

        /* Sort the buffer */
        qsort( sortbuf, count, sizeof(*sortbuf), smfStats1Compare );

        /* Set the median to the central value */
        *median = sortbuf[index/2];
      }

      /* Clean up */
      if( sortbuf ) sortbuf = astFree( sortbuf );
    }

  } else {
    /* CGEN_BAD checking version */
    if( sigma ) {
      /* Standard deviation calculating version */
      for( i=0; i<nsamp*stride; i+=stride ) if( data[i] != CGEN_BAD ) {
          sum += (double) data[i];
          sumsq += ((double) data[i]) * ((double) data[i]);
          count++;
        }
    } else {
      /* Mean only */
      for( i=0; i<nsamp*stride; i+=stride ) if( data[i] != CGEN_BAD ) {
          sum += (double) data[i];
          count++;
        }
    }

    /* Median calculation */
    if( median && count) {
      double *sortbuf=NULL;

      /* Put all of the good values into a buffer that we can sort */
      sortbuf = astCalloc( count, sizeof(*sortbuf) );

      if( *status == SAI__OK ) {
        size_t index = 0;
        for( i=0; i<nsamp*stride; i+=stride ) {
          if( data[i] != CGEN_BAD ) {
            sortbuf[index] = (double) data[i];
            index++;
          }
        }

        /* Sort the buffer */
        qsort( sortbuf, count, sizeof(*sortbuf), smfStats1Compare );

        /* Set the median to the central value */
        *median = sortbuf[index/2];
      }

      /* Clean up */
      if( sortbuf ) sortbuf = astFree( sortbuf );
    }

  }

  /* Calculate numbers as long as count > 0 */
  if( count > 0 ) {
    mu = sum / count;
    if( mean ) *mean = mu;
    if( sigma ) *sigma = sqrt( (sumsq - count*mu*mu)/(count) );
  }
  if( ngood ) *ngood = count;

  /* Enough samples? */
  if( count < SMF__MINSTATSAMP ) {
    *status = SMF__INSMP;
    msgSeti("MIN",SMF__MINSTATSAMP);
    msgSeti("N", count );
    msgSeti("MX", nsamp );
    errRep( "", FUNC_NAME
            ": Insufficient number of good samples (^N<^MIN out of ^MX) for "
            "statistics", status );
    return;
  }

}


