/* -*- C -*-
*+
*  Name:
*     smf_stats1

*  Purpose:
*     Low-level routine for calculating mean and standard deviation of
*     a data array.

*  Language:
*     Starlink ANSI C

*  Type of Module:
*     Subroutine

*  Invocation:
*     void smf_stats1<X>( CGEN_TYPE *data, size_t stride, size_t nsamp,
*                         unsigned char *qual, size_t qstride,
*                         unsigned char mask, double *mean,
*                         double *sigma, size_t *ngood, int *status )

*  Arguments:
*     data = CGEN_TYPE* (Given)
*        Pointer to input data array
*     stride = size_t (Given)
*        Index stride between elements
*     nsamp = size_t (Given)
*        Length of the interval to analyze
*     qual = usigned char* (Given)
*        If specified, use this QUALITY array to decide which samples
*        to use (provided mask). Otherwise data are only ignored if set
*        to CGEN_BAD.
*     qstride = size_t (Given)
*        Stride for qual. If 0 assumed to be stride.
*     mask = unsigned char (Given)
*        Use with qual to define which bits in quality are relevant to
*        ignore data in the calculation.
*     mean = double* (Given and Returned)
*        Pointer to variable that will contain the mean of the data.
*     sigma = double* (Given and Returned)
*        Pointer to variable that will contain the standard deviation of
*        the data. If NULL this routine will run faster and not calculate
*        the standard deviation.
*     ngood = size_t* (Given and Returned)
*        Pointer to variable that will indicate how many samples were used
*        to calculate the statistics.
*     status = int* (Given and Returned)
*        Pointer to global status.

*  Description:
*     Calculate mean and standard deviation provided there is at least 1
*     good sample. However, status is set to SMF__INSMP if there are not
*     at least SMF__MINSTATSAMP good samples.

*  Notes:
*     The algorithm is "naive" and may suffer roundoff problems. It may be
*     necessary to switch to a (slower) compensated method. See:
*     http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance

*  Authors:
*     Edward Chapin (UBC)
*     TIMJ: Tim Jenness (JAC, Hawaii)
*     {enter_new_authors_here}

*  History:
*     2008-03-06 (EC):
*        Initial version
*     2008-04-18 (EC):
*        Use SMF__MINSTATSAMP for sample length check
*     2008-08-29 (TIMJ):
*        Initialise return values even if status is bad on entry.
*     2008-12-15 (EC):
*        Remove initial time slice from interface, and add stride parameter.
*     2009-12-03 (EC):
*        Make this a generic function
*     2010-02-04 (EC):
*        Add qstride to interface, and switch to size_t from dim_t for
*        stride/nsamp
*     {enter_further_changes_here}

*  Copyright:
*     Copyright (C) 2008 Science and Technology Facilities Council.
*     Copyright (C) 2008-2010 University of British Columbia.
*     All Rights Reserved.

*  Licence:
*     This program is free software; you can redistribute it and/or
*     modify it under the terms of the GNU General Public License as
*     published by the Free Software Foundation; either version 3 of
*     the License, or (at your option) any later version.
*
*     This program is distributed in the hope that it will be
*     useful, but WITHOUT ANY WARRANTY; without even the implied
*     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
*     PURPOSE. See the GNU General Public License for more details.
*
*     You should have received a copy of the GNU General Public
*     License along with this program; if not, write to the Free
*     Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
*     MA 02111-1307, USA

*  Bugs:
*     {note_any_bugs_here}
*-
*/

/* Standard includes */
#include <math.h>

/* Starlink includes */
#include "sae_par.h"
#include "ast.h"
#include "mers.h"
#include "msg_par.h"
#include "prm_par.h"

/* SMURF includes */
#include "smf.h"
#include "smurf_par.h"
#include "smurf_typ.h"
#include "libsmf/smf_err.h"

/* Simple default string for errRep */
#define FUNC_NAME "smf_stats1"

void CGEN_FUNCTION(smf_stats1)( CGEN_TYPE *data, size_t stride, size_t nsamp,
                                unsigned char *qual, size_t qstride,
                                unsigned char mask, double *mean,
                                double *sigma, size_t *ngood,
                                int *status ) {

  /* Local variables */
  size_t count=0;             /* Number of samples in estimate */
  size_t i;                   /* Loop counter */
  size_t j;                   /* Loop counter */
  double mu=0;                /* Estimate of the mean */
  double sum=0;               /* Sum of the data */
  double sumsq=0;             /* Sum of the square of the data */

  /* initialise return values */
  if (sigma) *sigma = VAL__BADD;
  if (ngood) *ngood = 0;
  if (mean) *mean = VAL__BADD;

  /* Check status */
  if (*status != SAI__OK) return;

  if( !stride ) {
    *status = SAI__ERROR;
    errRep(" ", FUNC_NAME ": stride cannot be 0", status);
    return;
  }

  /* Assume qstride = stride if not specified */
  if( !qstride ) {
    qstride = stride;
  }

  /* Initialization */
  if( qual ) {
    /* Quality checking version */
    if( sigma ) {
      /* Standard deviation calculating version */
      j = 0;
      for( i=0; i<nsamp*stride; i+=stride ) {
        if( !(qual[j] & mask) ) {
          sum += (double) data[i];
          sumsq += ((double) data[i]) * ((double) data[i]);
          count++;
        }
        j += qstride;
      }
    } else {
      /* Mean only */
      j = 0;
      for( i=0; i<nsamp*stride; i+=stride ) {
        if( !(qual[j] & mask) ) {
          sum += (double) data[i];
          count++;
        }
        j += qstride;
      }
    }
  } else {
    /* CGEN_BAD checking version */
    if( sigma ) {
      /* Standard deviation calculating version */
      for( i=0; i<nsamp*stride; i+=stride ) if( data[i] != CGEN_BAD ) {
          sum += (double) data[i];
          sumsq += ((double) data[i]) * ((double) data[i]);
          count++;
        }
    } else {
      /* Mean only */
      for( i=0; i<nsamp*stride; i+=stride ) if( data[i] != CGEN_BAD ) {
          sum += (double) data[i];
          count++;
        }
    }
  }

  /* Calculate numbers as long as count > 0 */
  if( count > 0 ) {
    mu = sum / count;
    if( mean ) *mean = mu;
    if( sigma ) *sigma = sqrt( (sumsq - count*mu*mu)/(count) );
  }
  if( ngood ) *ngood = count;

  /* Enough samples? */
  if( count < SMF__MINSTATSAMP ) {
    *status = SMF__INSMP;
    msgSeti("MIN",SMF__MINSTATSAMP);
    msgSeti("N", count );
    msgSeti("MX", nsamp );
    errRep( "", FUNC_NAME
            ": Insufficient number of good samples (^N<^MIN out of ^MX) for "
            "statistics", status );
    return;
  }

}
