*EXTOPT
*
* EXTOPT -- Standard optimal extraction based upon the paper
*           Horne, K, 1986, PASP, 98, 609.
*
* EXTOPT fits polynomials to the fraction of flux falling into each column.
* These are then used to compute the optimal weights and reject cosmic rays.
* The background should have been estimated with 'skyfit'.
*
* Parameters:
*
*  IMAGE   -- The data file for extraction.
*
*  FLAT    -- Contains balance factors which when multiplied into
*             the data correct for short scale sensitivity variations.
*
*  DLOAD   -- TRUE if dark frame is required.
*
*  DARK    -- Dark frame representing counts unaffected by slit
*             profile. This will be subtracted off data before applying
*             the balance factors.
*
*  REGION  -- Contains the object region limits. This file should
*             have been generated by 'regpic' or 'skymov'.
*
*  SKY     -- Contains fits to the background sky in the region of
*             the object. Produced by 'skyfit'.
*
*  SPECT   -- The output file for both the spectrum and the uncertainty
*             estimates.
*
*  YSTART,YEND -- The Y pixel limit of the extraction.
*
*  READOUT -- The readout noise of the detector in RMS data units/pixel
*
*  PHOTON  -- The number of detected photons = electrons per data number.
*
*  OLD     -- True if you want to use an old profile fit. This is an option
*             generally used when extracting arc spectra at the same position
*             as an object.
*
*  If .NOT.OLD
*
*     NPOLY   -- number of terms for profile polynomial fits.
*
*     THRESH  -- threshold for poly fits.
*
*     NBLOCK  -- number of rows to add to give one block
*                for profile fitting stage.
*
*     NMED    -- median filter width. This is used to filter the profile
*                sums before they are divided into the profile to obtain
*                fractions. Use it to reject cosmic rays, but be careful with
*                sources with many narrow lines.
*
*  PROFIT -- If OLD = .TRUE., name of old profile fit file.
*            If OLD = .FALSE., name of new profile fit file.
*
*
*     PNEW    --
*  ZAPRATS -- .TRUE. then outlying points are ignored. Should not be used
*             if profile does not represent frame to be extracted (e.g.
*             arc or sky frame)
*
*  If ZAPRATS
*
*     RATLO  -- Lower outlier zap threshold
*
*     RATHI  -- Upper outlier zap threshold
*
*  EPS    -- Fudge factor to avoid silly rejections. On high signal-to-noise
*            data you can get very close fits but still be several sigma out.
*            EPS imposes a lower limit to the fractional deviation required
*            for a point to be rejected.
*
*  VMAX   -- Maximum value acceptable (to partially cope with saturated data)
*
*  PLOT   -- .TRUE. if you want plots
*
*  DEVICE -- Plot device
*
*  If
*
*  PNEW   --  File name of profile fit if STORE = .TRUE.
*
*
*EXTOPT
      SUBROUTINE EXTOPT(STATUS)
C
      IMPLICIT NONE
      INCLUDE 'SAE_PAR'
      INCLUDE 'DAT_PAR'
      INCLUDE 'CNF_PAR'
      INTEGER IMAGE, FLAT, SKY, REGION, SPECT, N
     :XS, NYS
      INTEGER STATUS, JLEFT, JRIGHT, SLO, SHI, NDIM, DARK
      INTEGER LBND(2), UBND(2), NS, NPOLY, XLO, XHI, NMED
      INTEGER YLO, YHI, TRIM(4), TEMP, PROFIT, NPOLYT
      INTEGER PPTR, EL, ODPTR, OVPTR, PLACE, WORK, WPTR
      INTEGER IPTR, FPTR, SPTR, RPTR, NBLOCK, SMALL, DPTR
      REAL LEFT, RIGHT, READOUT, PHOTON, RATLO, RATHI, EPS, CPOS
      REAL THRESH
      LOGICAL IBASE, FBASE, SBASE, BASE, OLD, ZAPRATS, PLOT, THERE
      LOGICAL DBASE, DLOAD
      DOUBLE PRECISION ZERO, SCALE
      CHARACTER*128 DEVICE
      CHARACTER*(DAT__SZLOC) LOC, LOCS, LOCS1, LOCR, LOCR1
C
C     Start
C
      IF(STATUS.NE.SAI__OK) RETURN
      CALL NDF_BEGIN
C
C     Open data file
C
      CALL NDF_ASSOC('IMAGE', 'READ',IMAGE, STATUS)
C
C     Open balance frame, identifier FLAT
C
      CALL NDF_ASSOC('FLAT','READ',FLAT,STATUS)
C
C     Open dark frame
C
      CALL PAR_GET0L('DLOAD', DLOAD, STATUS)
      IF(DLOAD) THEN
         CALL NDF_ASSOC('DARK','READ',DARK,STATUS)
      ELSE
         CALL NDF_BOUND(FLAT, 2, LBND, UBND, NDIM, STATUS)
         CALL NDF_TEMP(PLACE, STATUS)
         CALL NDF_NEW('_REAL', NDIM, LBND, UBND, PLACE, DARK, STATUS)
      END IF
C
C     Get sky region input file, check its OK
C
      CALL NDF_ASSOC('REGION','READ',REGION,STATUS)
      CALL NDF_ISBAS(REGION, BASE, STATUS)
      IF(STATUS.EQ.SAI__OK .AND. .NOT.BASE) THEN
         STATUS = SAI__ERROR
         CALL ERR_REP(' ','Sky region file must be a base NDF'
     &        //' to allow computation of uncertainties.',STATUS)
      END IF
C
      CALL NDF_XGT0R(REGION,'PAMELA','REGPIC.LEFT',LEFT,STATUS)
      CALL NDF_XGT0R(REGION,'PAMELA','REGPIC.RIGHT',RIGHT,STATUS)
      IF(STATUS.EQ.SAI__OK .AND. (LEFT.GT.RIGHT .OR.
     &     LEFT.LE.0.)) THEN
         STATUS = SAI__ERROR
         CALL ERR_REP(' ','Bad object limits', STATUS)
      END IF
      JLEFT  = NINT(LEFT)
      JRIGHT = NINT(RIGHT)
      CALL NDF_BOUND(REGION, 1, SLO, SHI, NDIM, STATUS)
      NS  = SHI - SLO + 1
C
C     Open sky file. Number of poly coefficients is used in
C     uncertainty estimation.
C
      CALL NDF_ASSOC('SKY','READ',SKY,STATUS)
      CALL NDF_XSTAT(SKY, 'PAMELA', THERE, STATUS)
      NPOLY = 0
      IF(THERE) THEN
         CALL NDF_XLOC(SKY,'PAMELA', 'READ', LOCS, STATUS)
         CALL DAT_THERE(LOCS, 'SKYFIT', THERE, STATUS)
         CALL DAT_ANNUL(LOCS, STATUS)
         IF(THERE)
     &        CALL NDF_XGT0I(SKY,'PAMELA','SKYFIT.NPOLY',NPOLY,STATUS)
      END IF
C
C     Get spectrum output name
C
      CALL NDF_SECT(IMAGE,1,1,1,SMALL,STATUS)
      CALL NDF_PROP(SMALL,' ','SPECT',SPECT,STATUS)
      CALL NDF_RESET(SPECT,'Title',STATUS)
      CALL NDF_CPUT('EXTOPT output',SPECT,'Title',STATUS)
C
C     What region of frame
C
      CALL NDF_ISBAS(IMAGE, IBASE, STATUS)
      CALL NDF_ISBAS(FLAT,  FBASE, STATUS)
      CALL NDF_ISBAS(DARK,  DBASE, STATUS)
      CALL NDF_ISBAS(SKY,   SBASE, STATUS)
      BASE = IBASE .AND. FBASE .AND. SBASE .AND. DBASE
      TRIM(1) = IMAGE
      TRIM(2) = FLAT
      TRIM(3) = DARK
      TRIM(4) = SKY
      CALL NDF_MBNDN('TRIM',4,TRIM,STATUS)
      IMAGE = TRIM(1)
      FLAT  = TRIM(2)
      DARK  = TRIM(3)
      SKY   = TRIM(4)

      CALL NDF_BOUND(IMAGE, 2, LBND, UBND, NDIM, STATUS)
      IF(BASE .AND. NDIM.EQ.2) THEN
         CALL PAR_GDR0I('YSTART',LBND(2),LBND(2),UBND(2),
     &        .FALSE.,YLO,STATUS)
         CALL PAR_GDR0I('YEND',UBND(2),YLO,UBND(2),
     &        .FALSE.,YHI,STATUS)
      ELSE
         YLO = LBND(2)
         YHI = UBND(2)
      END IF
C
C     compute minimal range in X to use
C
      XLO = MAX(LBND(1), JLEFT)
      XHI = MIN(UBND(1), JRIGHT)
C
C     Generate appropriate section NDFs
C
      IF(XLO.NE.LBND(1) .OR. XHI.NE.UBND(1) .OR.
     &     YLO.NE.LBND(2) .OR. YHI.NE.UBND(2)) THEN
         LBND(1) = XLO
         UBND(1) = XHI
         LBND(2) = YLO
         UBND(2) = YHI
         CALL NDF_SECT(IMAGE, 2, LBND, UBND, TEMP, STATUS)
         CALL NDF_ANNUL(IMAGE, STATUS)
         CALL NDF_CLONE(TEMP, IMAGE, STATUS)
         CALL NDF_ANNUL(TEMP, STATUS)

         CALL NDF_SECT(FLAT, 2, LBND, UBND, TEMP, STATUS)
         CALL NDF_ANNUL(FLAT, STATUS)
         CALL NDF_CLONE(TEMP, FLAT, STATUS)
         CALL NDF_ANNUL(TEMP, STATUS)

         IF(DLOAD) THEN
            CALL NDF_SECT(DARK, 2, LBND, UBND, TEMP, STATUS)
            CALL NDF_ANNUL(DARK, STATUS)
            CALL NDF_CLONE(TEMP, DARK, STATUS)
            CALL NDF_ANNUL(TEMP, STATUS)
         END IF

         CALL NDF_SECT(SKY, 2, LBND, UBND, TEMP, STATUS)
         CALL NDF_ANNUL(SKY, STATUS)
         CALL NDF_CLONE(TEMP, SKY, STATUS)
         CALL NDF_ANNUL(TEMP, STATUS)
      END IF
C
C     Section dimensions
C
      NXS = UBND(1)-LBND(1)+1
      NYS = UBND(2)-LBND(2)+1
C
C     Noise characteristics
C
      CALL PAR_GDR0R('READOUT',1.E-2,0.,1.E10,.FALSE.,READOUT,STATUS)
      CALL PAR_GDR0R('PHOTON',1.,1.E-10,1.E10,.FALSE.,PHOTON,STATUS)
C
C     Use an old fit ?
C
      CALL PAR_GET0L('OLD', OLD, STATUS)
      IF(OLD) THEN
         CALL NDF_ASSOC('PROFIT','READ',PROFIT,STATUS)
         CALL NDF_BOUND(PROFIT,2,LBND,UBND,NDIM,STATUS)
         NPOLYT = UBND(1)-LBND(1)+1
         IF(STATUS.EQ.SAI__OK .AND. (LBND(2).NE.XLO
     &        .OR. UBND(2).NE.XHI)) THEN
            STATUS = SAI__ERROR
            CALL ERR_REP(' ','Old profile fit and current'//
     &           ' object region do not match.',STATUS)
            CALL MSG_SETI('OLDL',LBND(2))
            CALL MSG_SETI('OLDR',UBND(2))
            CALL ERR_REP(' ','Old fit limits: ^OLDL to ^OLDR',STATUS)
            CALL MSG_SETI('OL',LBND(2))
            CALL MSG_SETI('OR',UBND(2))
            CALL ERR_REP(' ','Object limits: ^OL to ^OR',STATUS)
         END IF
         CALL NDF_MAP(PROFIT,'Data', '_DOUBLE','READ',PPTR,EL,STATUS)
         CALL NDF_XGT0D(PROFIT,'PAMELA','EXTOPT.ZERO',ZERO,STATUS)
         CALL NDF_XGT0D(PROFIT,'PAMELA','EXTOPT.SCALE',SCALE,STATUS)
      ELSE
C
C     Get number of poly coefficients then create file
C
         CALL PAR_GDR0I('NPOLY',3,1,10,.FALSE.,NPOLYT,STATUS)
         CALL NDF_PROP(SMALL,' ','PROFIT',PROFIT,STATUS)
         CALL NDF_RESET(PROFIT,'Title',STATUS)
         CALL NDF_CPUT('EXTNOR profile fit',PROFIT,'Title',STATUS)
         LBND(1) = 1
         UBND(1) = NPOLYT
         LBND(2) = XLO
         UBND(2) = XHI
         CALL NDF_RESET(PROFIT,'Data',STATUS)
         CALL NDF_STYPE('_DOUBLE',PROFIT,'Data',STATUS)
         CALL NDF_SBND(2,LBND,UBND,PROFIT,STATUS)
         CALL NDF_MAP(PROFIT,'Data', '_DOUBLE','WRITE',PPTR,EL,STATUS)
         CALL PAR_GDR0R('THRESH',3.,0.,1.E5,.FALSE.,THRESH,STATUS)
         CALL PAR_GDR0I('NBLOCK',1,1,NYS,.FALSE.,NBLOCK,STATUS)
         CALL PAR_GODD( 'NMED',  5,1,   101,.FALSE.,NMED,STATUS)
      END IF
C
C     Identify cosmic rays ?
C
      CALL PAR_GET0L('ZAPRATS',ZAPRATS,STATUS)
      IF(ZAPRATS) THEN
        CALL PAR_GDR0R('RATLO',-4.,-1.E5,0.,.FALSE.,RATLO,STATUS)
        CALL PAR_GDR0R('RATHI',+4.,0.,+1.E5,.FALSE.,RATHI,STATUS)
        CALL PAR_GDR0R('EPS',0.01,0.,1.E4,.FALSE.,EPS,STATUS)
      END IF
      CALL PAR_GET0L('PLOT',PLOT,STATUS)
      IF(PLOT) CALL PAR_GET0C('DEVICE',DEVICE,STATUS)
C
C     Create and map output spectrum file
C
      CALL NDF_RESET(SPECT,'Data,Variance',STATUS)
      CALL NDF_SBND(1,YLO,YHI,SPECT,STATUS)
      CALL NDF_STYPE('_REAL',SPECT,'Data,Variance',STATUS)
      CALL NDF_MAP(SPECT,'Data', '_REAL','WRITE',ODPTR,EL,STATUS)
      CALL NDF_MAP(SPECT,'Variance','_REAL','WRITE',OVPTR,EL,STATUS)
      CALL NDF_CPUT('Counts',SPECT,'Units',STATUS)
C
C     Grab space for skyfit covariance matrix
C
      IF(NPOLY.GT.0) THEN
         CALL NDF_TEMP(PLACE, STATUS)
         CALL NDF_NEW('_REAL',1,1,NXS*NXS,PLACE,WORK,STATUS)
         CALL NDF_MAP(WORK,'Data','_REAL','WRITE',WPTR,EL,STATUS)
      END IF
C
C     Map files
C
      CALL NDF_MAP(IMAGE,'Data','_REAL','READ',IPTR,EL,STATUS)
      CALL NDF_MAP(FLAT,'Data','_REAL','READ',FPTR,EL,STATUS)
      CALL NDF_MAP(DARK,'Data','_REAL','READ/ZERO',DPTR,EL,STATUS)
      CALL NDF_MAP(SKY,'Data','_REAL','READ',SPTR,EL,STATUS)
      CALL NDF_MAP(REGION,'Data','_INTEGER','READ',RPTR,EL,STATUS)
C
C     Extract
C
      CALL EXT_OPT(%VAL(CNF_PVAL(IPTR)), %VAL(CNF_PVAL(FPTR)),
     :             %VAL(CNF_PVAL(DPTR)), %VAL(CNF_PVAL(SPTR)),
     &     NXS, NYS, XLO, YLO, READOUT, PHOTON, ZAPRATS,
     &     %VAL(CNF_PVAL(ODPTR)), %VAL(CNF_PVAL(OVPTR)),
     :     NPOLYT, THRESH, RATLO,
     &     RATHI, NBLOCK, PLOT, OLD, ZERO, SCALE, %VAL(CNF_PVAL(PPTR)),
     &     SLO, NS, %VAL(CNF_PVAL(RPTR)), NPOLY, EPS,
     :     %VAL(CNF_PVAL(WPTR)),
     &     DEVICE, CPOS, NMED, STATUS)
C
C     Create 'pamela' extension if not already one. Write useful
C     info to it.
C
      CALL NDF_XSTAT(SPECT, 'PAMELA', THERE, STATUS)
      IF(.NOT.THERE) THEN
         CALL NDF_XNEW(SPECT,'PAMELA', 'Ext', 0, 0, LOC, STATUS)
      ELSE
         CALL NDF_XLOC(SPECT,'PAMELA', 'UPDATE', LOC, STATUS)
      END IF
C
C     Store position of centre of spectrum and extraction type
C
      CALL NDF_XPT0R(CPOS,SPECT,'PAMELA','CPOS',STATUS)
      CALL NDF_XPT0C('Optimal',SPECT,'PAMELA','EXTRACTION',
     &     STATUS)
C
C     Copy components from sky and region files into output file
C
      CALL NDF_XSTAT(SKY, 'PAMELA', THERE, STATUS)
      IF(THERE) THEN
         CALL NDF_XLOC(SKY,'PAMELA', 'READ', LOCS, STATUS)
         CALL DAT_THERE(LOCS, 'SKYFIT', THERE, STATUS)
         IF(THERE) THEN
            CALL DAT_FIND(LOCS, 'SKYFIT', LOCS1, STATUS)
            CALL DAT_COPY(LOCS1, LOC, 'SKYFIT',STATUS)
            CALL DAT_ANNUL(LOCS1, STATUS)
         END IF
         CALL DAT_ANNUL(LOCS, STATUS)
      END IF
      CALL NDF_XLOC(REGION,'PAMELA', 'READ', LOCR, STATUS)
      CALL DAT_FIND(LOCR, 'REGPIC', LOCR1, STATUS)
      CALL DAT_COPY(LOCR1, LOC,'REGPIC',STATUS)
      CALL DAT_ANNUL(LOCR1, STATUS)
      CALL DAT_ANNUL(LOCR, STATUS)
      CALL DAT_ANNUL(LOC, STATUS)
C
C     Store offset and scaling in profile fit file
C
      IF(.NOT.OLD) THEN
         CALL NDF_XSTAT(PROFIT, 'PAMELA', THERE, STATUS)
         IF(.NOT.THERE) THEN
            CALL NDF_XNEW(PROFIT,'PAMELA', 'Ext', 0, 0, LOC, STATUS)
            CALL DAT_NEW(LOC, 'EXTOPT', 'Struct', 0, 0, STATUS)
         ELSE
            CALL NDF_XLOC(PROFIT,'PAMELA','UPDATE',LOC,STATUS)
            CALL DAT_THERE(LOC, 'EXTOPT', THERE, STATUS)
            IF(.NOT.THERE)
     &           CALL DAT_NEW(LOC, 'EXTOPT', 'Struct', 0, 0, STATUS)
         END IF
         CALL DAT_ANNUL(LOC, STATUS)
         CALL NDF_XPT0D(ZERO,PROFIT,'PAMELA','EXTOPT.ZERO',STATUS)
         CALL NDF_XPT0D(SCALE,PROFIT,'PAMELA','EXTOPT.SCALE',STATUS)
      END IF
      CALL NDF_END(STATUS)
      RETURN
      END

      SUBROUTINE EXT_OPT (DATA, FLAT, DARK, SKY, NXS, NYS, XLO,
     &YLO, READOUT, PHOTON, ZAPRATS, SPEC, SPECVAR, NPOLY,
     &THRESH, RATLO, RATHI, NBLOCK, PLOT, OLD, ZERO, SCALE,
     &PSTORE, SLO, NS, MASK, NPSKY, EPS, VARMAT, DEVICE,
     &CPOS, NMED, STATUS)
*
*
* Written by T.R. Marsh, June 1988
* This routine has been modified for FIGARO from Keith Horne's
* original EXTOPT in the program PAMELA.
*
* Extracts a 1-D stellar spectrum from a 2-D data frame.
* Different weights are chosen for each pixel in order to
* optimize the S/N ratio in the 1-D spectrum.
*
* Input:
*
*  DATA(NXS,NYS)  (R*4) picture data (2-d spectrum, dispersion along y)
*  FLAT(NXS,NYS)  (R*4) picture containing balance factors
*  DARK(NXS,NYS)  (R*4) dark frame (NOT balanced)
*  SKY(NXS,NYS)   (R*4) picture containing sky background (already balanced)
*  NXS, NYS       (I*4) Section size
*  XLO,YLO        (I*4) Lower left corner
*  READOUT        (R*4) RMS readout noise (in data numbers)
*  PHOTON         (R*4) Equivalent number of photons per data number
*  ZAPRATS        (L*4) Program will attempt to remove cosmic rats if ZAPRATS
*                       is true.
*  NPOLY          (I*4) Number of polynomial terms for profile fit
*  THRESH         (R*4) Reject threshold
*  RATLO, RATHI   (R*4) Cosmic rat upper and lower rejection thresholds.
*  NBLOCK         (I*4) Wavelength blocking factor.
*  PLOT           (L*4) TRUE then plots can be made.
*  OLD            (L*4) Old profile fit will be used.
*  MASK(NX)       (I*4) Sky mask 1 for sky pixels, 0 otherwise.
*  NPSKY          (I*4) Number of polynomial terms used for sky fit.
*  EPS            (R*4) Fudge factor to place a minimum bound on the
*                       estimated variance during rejection. Use this
*                       to avoid pixels being rejected incorrectly in
*                       high s/n data. Should not be needed except when
*                       there are short term wiggles caused by detector
*                       imperfection. Typical value 1./50.
*
*  VARMAT(NXS,NXS) (R*4) Workspace array.
*  DEVICE        C*(*) Plot device

***
* ARGUMENT REMOVED:  SKYFIT       (L*4) True then weights will be optimsed
*                                 accounting for uncertainty in skyfit.
*
* Output:
*
*  SPEC(NY)     (R*4) The extracted 1-D spectrum
*  SPECVAR(NY)  (R*4) variances extimates
*  PSTORE(NPOLY,NXS) (R*8) Profile fits.
*
* The optimal extraction algorithm for CCD data is described
* in Horne(1986) PASP 98, 609.  This version of EXTOPT includes
* many changes for low count data with Poisson statistics. This
* is designed to improve the rejection for low signal data.
*
* The "seeing" profile is assumed to vary smoothly with wavelength.
* This program should therefore not be used to extract spectra
* of extended objects, or to extract ccd spectra in which
* charge transfer problems in the direction along the slit distort
* the seeing profile.
*
* The program constructs a smooth representation of the seeing profile,
* normalized to unit integral over spatial dimensions, by fitting
* a polynomial in wavelength to each column of normalized data.
* This procedure takes into account the smooth wavelength dependence
* of the seeing profile (due e.g. to focus, seeing, differential refraction,
* etc.), as well as moderate distortions (tilt, curvature, s-distortion)
* of the object spectrum relative to a row of pixels.
*
* The noise is modelled by Poisson statistics plus an independent
* background noise, assumed to be uniform over the picture.
*
* ***** CODE DESCRIBED NEXT HAS BEEN COMMENTED OUT IN THIS VERSION
* ***** AND THE ARGUMENT "SKYFIT" REMOVED FROM THE CALL
*
* The optimal 1-D spectrum estimate is obtained by a weighted
* least squares fit of the seeing profile model to picture data
* at each wavelength. As of July 1988 it is also possible to account
* for uncertainty in the sky, assuming that this has been computed
* from polynomial fits. This produces a small improvement when there
* are few sky pixels compared to object pixels, and/or a high order
* poly had to be used. Using this option (SKYFIT=.TRUE.) requires
* a matrix inversion at every column, and can therefore be very slow.
* Should only be used when desperate.
*
*******
*******
*
* Balance corrections are applied to the data on a pixel-by-pixel basis.
* Data should not be balanced before running this routine as then the
* estimates of variance may be incorrect.
*
* Cosmic ray hits and other detector defects near the spectrum
* are eliminated by a sigma-clipping algorithm,
* or by approximate poisson probability in case of low count rate.
*
      IMPLICIT NONE
      INCLUDE 'SAE_PAR'
      INCLUDE 'PRM_PAR'
      INTEGER XLO, YLO, YPOS, NXS, NYS, STATUS, IY, NBLOCK
      INTEGER NNEG, IY1, NUMBL, N, IY2, NNOW, IX,  NDF, IREJ
      INTEGER NRATS, IP, I, IBL, ICYCLE, NFIT, II, IB1, IB2
      INTEGER IB, NBBIN, J, K, SLO, NS, IREJH, IREJL, MAXREJ, IXK
      INTEGER ID, NNORM, NOK, NCOUNTER, IFAIL
      REAL CPOS, PMAX, READOUT, PHOTON, VAR0, CMIN, ALPHA, BETA
      REAL SUM1, SUM2, SUM3, SKYS, BALANCE, ETA, VAR, PRED
      REAL PROB, SMIN, PROF, RMS, OBS, SIGMA, RATIO, CHANCE
      REAL PLOG, FAC, RMAX, RESCALE, XXX, STAR, THRHI, THRLO, PTEST
      REAL P, YMX, YMN, XMN, XMX, VOLD, RMAXL
      REAL RMAXH, DIFF, VNORM, YMIN, YMAX, PFL, SKAVE, RSCALE
      REAL PSUM, SPEC(NYS), SPECVAR(NYS)
      REAL DATA(NXS,NYS), SKY(NXS,NYS), FLAT(NXS,NYS), DARK(NXS,NYS)
      INTEGER MASK(NS), NPSKY, NMED
      REAL VARMAT(NXS,NXS), RANGE
      DOUBLE PRECISION SUMD, SUMD2, SUM, WSUM, WVSUM, ZERO, SCALE
      DOUBLE PRECISION SUMF
C
C Work space. Quite a bit of it.
C
      INTEGER MXPOLY, MAXPSN, MAXLAM
      PARAMETER (MXPOLY=10, MAXPSN=200, MAXLAM=5000)
      REAL STARSUM(MAXLAM), SKYMEAN(MAXLAM), VSUM(MAXLAM)
      REAL PROFILE(MAXPSN), WEIGHT(MAXPSN), XPLOT(MAXLAM)
      REAL YPLOT(MAXLAM), FPLOT(MAXLAM), EPLOT(MAXLAM)
      REAL BPLOT(MAXLAM), THRESH, RATLO, RATHI, EPS
      REAL GOOD(MAXLAM), MFGOOD(MAXLAM)
      INTEGER NPOLY, NREJ
      LOGICAL PLOT, PLOTR, OLD, PREVIOUS, OK
      CHARACTER*8 WHAT, NEXT
      CHARACTER*(*) DEVICE
      INTEGER PGOPEN
      CHARACTER*40 TITLE
C
C Polynomial fitting arrays used by LSQUAR
C
      DOUBLE PRECISION WORK(3,MAXLAM), APOLY(3*MXPOLY*(MXPOLY+3)), CHISQ
      DOUBLE PRECISION PSTORE(NPOLY,NXS), YNORM, POLY
      CHARACTER*80 OUTPUT
      LOGICAL ZAPRATS, MORE
      PARAMETER (ALPHA=3.,BETA=2.)
C
      IF(STATUS.NE.SAI__OK) RETURN
C
C     Check input arguments
C
      IF(NYS .GT. MAXLAM) THEN
         STATUS = SAI__ERROR
         CALL MSG_SETI('MAX',MAXLAM)
         CALL ERR_REP(' ',
     &        'Maximum lambda-dimension = ^MAX',STATUS)
         RETURN
      ELSE IF( NXS .GT. MAXPSN ) THEN
         CALL MSG_SETI('MAX',MAXPSN)
         CALL ERR_REP(' ',
     &        'Maximum x-dimension = ^MAX',STATUS)
         RETURN
      ELSE IF(NPOLY.GT.MXPOLY) THEN
         CALL MSG_SETI('MAX',MXPOLY)
         CALL ERR_REP(' ',
     &        'Maximum number of poly terms = ^MAX',STATUS)
         RETURN
      END IF
C
      DO IY=1, NYS
        SPEC(IY)    = 0.
        SPECVAR(IY) = 0.
      END DO
C
C     Factor for weighting low count cases. This is
C     derived by requiring that pixels cannot be
C     incorrectly weighted by more than a factor BETA
C     for an ALPHA sigma fluctuation. For CCDs this should
C     be unimportant (likely to be zero) whereas for
C     photon counting detectors, it is important.
C
      VAR0 = READOUT*READOUT
      CMIN = (ALPHA*BETA/(BETA-1.))**2./PHOTON - VAR0*PHOTON
      CMIN = MAX(0., CMIN)
C
      IF(.NOT.OLD) THEN
C
C     Sum data between X-limits to obtain profile normalization factors.
C
         NNEG  = 0
         NREJ  = 0
         NUMBL = NYS/NBLOCK
         DO N = 1, NUMBL
            IY1 = NBLOCK*(N-1)+1
            IF(N.EQ.NUMBL) THEN
               IY2 = NYS
            ELSE
               IY2 = IY1 + NBLOCK - 1
            END IF
            NNOW = IY2 - IY1 + 1
            SUM1 = 0.
            SUM2 = 0.
            SUM3 = 0.
            OK   = .TRUE.
            DO IY = IY1, IY2
               DO IX = 1, NXS
                  IF(OK .AND. DATA(IX,IY).NE.VAL__BADR .AND.
     &                 FLAT(IX,IY).NE.VAL__BADR .AND.
     &                 DARK(IX,IY).NE.VAL__BADR .AND.
     &                 SKY(IX,IY).NE.VAL__BADR) THEN
                     BALANCE = FLAT(IX,IY)
                     SKYS    = SKY(IX,IY)+BALANCE*DARK(IX,IY)
                     SUM1    = SUM1+SKYS
                     SUM2    = SUM2+BALANCE*DATA(IX,IY)-SKYS
                     SUM3    = SUM3+BALANCE*BALANCE*
     &                    (VAR0+DATA(IX,IY)/PHOTON)
                  ELSE
                     OK = .FALSE.
                  END IF
               END DO
            END DO
            IF(OK) THEN
               SKYMEAN(N) = SUM1/REAL(NXS)
               STARSUM(N) = SUM2
               VSUM(N)    = SUM3
               IF(STARSUM(N).LE.0.) NNEG = NNEG + 1
            ELSE
               NREJ = NREJ + 1
               STARSUM(N) = -ABS(STARSUM(N))
            END IF
         END DO
         WRITE(OUTPUT,'(1X,I4,A,I4,A,I4,A)')
     &        NNEG,' non-positive blocks of length ',NBLOCK,
     &        ' out of ',NUMBL,' total.'
         CALL MSG_OUT(' ',OUTPUT, STATUS)
         WRITE(OUTPUT,'(1X,I4,A,I4,A)')
     &        NREJ,' blocks rejected out of ',NUMBL,' total.'
         CALL MSG_OUT(' ',OUTPUT, STATUS)

         IF(NREJ+NNEG+NPOLY.GE.NUMBL) THEN
            STATUS = SAI__ERROR
            CALL ERR_REP(' ',
     &           'Insufficient OK blocks to fit polys',STATUS)
            RETURN
         END IF
C
C     Median filter the sums. the idea is to kick out cosmic rays
C     which can otherwise dominate the profile. Ignore bad points.
C
      IF(NMED.GT.1) THEN
         NCOUNTER = 0
         DO IY = 1, NUMBL
            IF(STARSUM(IY).GT.0) THEN
               NCOUNTER = NCOUNTER + 1
               GOOD(NCOUNTER) = STARSUM(IY)
            END IF
         END DO
         CALL MEDFILT(GOOD,MFGOOD,NCOUNTER,NMED,IFAIL)
         NCOUNTER = 0
         DO IY = 1, NUMBL
            IF(STARSUM(IY).GT.0) THEN
               NCOUNTER = NCOUNTER + 1
               STARSUM(IY) = MFGOOD(NCOUNTER)
            END IF
         END DO
      END IF
C
C     Option to plot a series of seeing profiles
C
         PMAX = 1.
         IF(PLOT) THEN
            WRITE(*,'(A,$)') 'Plot cuts across spectra? [Y] '
            READ(*,'(A)') WHAT
            CALL UPPER_CASE(WHAT)
            IF(WHAT.NE.'N') THEN
               XMN = XLO-1
               XMX = XLO+NXS
               YMN = 0.
               YMX = 1.
               ID  = PGOPEN(DEVICE)
               IF(ID.LT.1) THEN
                  STATUS = SAI__ERROR
                  CALL MSG_SETC('DEVICE',DEVICE)
                  CALL ERR_REP(' ',
     &                 'Failed to open plot device ^DEVICE',
     &                 STATUS)
                  RETURN
               END IF
               CALL PGSCI(5)
               CALL PGENV(XMN,XMX,YMN,YMX,0,0)
               CALL PGMOVE( XMN, 0. )
               CALL PGDRAW( XMX, 0. )
               CALL PGSCI(7)
               CALL PGSCF(2)
               CALL PGLAB('X-column','Fraction','Profiles')
C
               NBBIN = MAX(1,NUMBL/10)
               PMAX = 0.
               DO IB = 1, 10
                  IB1 = NBBIN*(IB-1) + 1
                  IB2 = NBBIN*IB
                  IF(IB.EQ.10) IB2 = NUMBL
                  DO IX=1,NXS
                     XPLOT(IX) = REAL(IX+XLO-1)
                     YPLOT(IX) = 0.
                  END DO
                  DO II = IB1, IB2
                     IY1 = NBLOCK*(II-1) + 1
                     IY2 = NBLOCK*II
                     IF(II.EQ.NUMBL) IY2 = NYS
                     P = STARSUM(II)
                     IF(P.GT.0.) THEN
                        DO IY = IY1, IY2
                           DO IX = 1, NXS
                              PTEST = (FLAT(IX,IY)*
     &                            (DATA(IX,IY)-DARK(IX,IY))
     &                             -SKY(IX,IY))/P
                              YPLOT(IX) = YPLOT(IX) + PTEST
                           END DO
                        END DO
                     END IF
                  END DO
                  NNORM = IB2-IB1+1
                  DO IX = 1, NXS
                     YPLOT(IX) = YPLOT(IX)/REAL(NNORM)
                     PMAX = MAX(PMAX, YPLOT(IX))
                  END DO
                  CALL PGSCI(1)
                  CALL PGBIN(NXS, XPLOT, YPLOT, .TRUE.)
                  CALL PGSCI(4)
                  CALL PGLINE(NXS, XPLOT, YPLOT)
               END DO
               CALL PGCLOS
            END IF
C
C     column fits
C
            WRITE(*,'(A,$)') 'Plot profile fits ? [Y] '
            READ(*,'(A)') WHAT
            CALL UPPER_CASE(WHAT)
         ELSE
            WHAT = 'N'
         END IF
C
C     Open plot file for column poly-fits
C
         IF(WHAT.NE.'N') THEN
            ID = PGOPEN(DEVICE)
            IF(ID.LT.1) THEN
               STATUS = SAI__ERROR
               CALL MSG_SETC('DEVICE',DEVICE)
               CALL ERR_REP(' ',
     &              'Failed to open plot device ^DEVICE',
     &              STATUS)
               RETURN
            END IF
            CALL PGSCI(5)
            CALL PGENV( REAL(YLO-1), REAL(YLO+NYS),
     &           -0.1*PMAX, PMAX*1.1, 0,0)
            CALL PGMOVE( REAL(YLO-1), 0. )
            CALL PGDRAW( REAL(YLO+NYS), 0. )
            CALL PGSCI(7)
            CALL PGSCF(2)
            CALL PGLAB('Y-row','Fraction','Column fit')
         END IF
C
C     Main loop to fit a poly to each column
C
         THRLO =  -ABS(THRESH)
         THRHI =   ABS(THRESH)
         NEXT = ' '
         ZERO  = DBLE(YLO+YLO+NYS-1)/2.
         SCALE = SQRT(DBLE(NYS)/2.)
         DO IX=1,NXS
            CALL MSG_BLANK(STATUS)
            CALL MSG_SETI('IX',IX+XLO-1)
            CALL MSG_OUT(' ',
     &           'Fitting lambda polynomial to profile'//
     &           ' data at pixel ^IX',STATUS)
C
C     Load arrays for poly-fitting in wavelength to normalized profile data
C     Weights from first fit modified by CMIN factor for low counts.
C
            NFIT = 0
            DO IBL = 1, NUMBL
               IF(STARSUM(IBL).GT.0.) THEN
                  NFIT = NFIT + 1
                  IY1  = NBLOCK*(IBL-1) + 1
                  IF(IBL.EQ.NUMBL) THEN
                     IY2 = NYS
                  ELSE
                     IY2 = IY1 + NBLOCK - 1
                  END IF
                  STAR = 0.
C
C     Initial weights are unity.
C
                  DO IY = IY1, IY2
                     STAR = STAR+FLAT(IX,IY)*
     &                    (DATA(IX,IY)-DARK(IX,IY))-SKY(IX,IY)
                  END DO
                  XXX = REAL(YLO-1)+REAL(IY1+IY2)/2.
                  WORK(1,NFIT) = (DBLE(XXX)-ZERO)/SCALE
                  WORK(2,NFIT) = DBLE(STAR / STARSUM(IBL))
                  WORK(3,NFIT) = 1.D0
                  XPLOT(NFIT)  = XXX
                  YPLOT(NFIT)  = REAL(WORK(2,NFIT))
               END IF
            END DO
C
C     Data plotted in white
C
            PREVIOUS = .FALSE.
            IF(NEXT.EQ.' ' .AND. WHAT.NE.'N') THEN
               CALL PGSCI(1)
               CALL PGPOINT(NFIT,XPLOT,YPLOT,1)
               PREVIOUS = .TRUE.
            END IF
C
C     Cosmic rat reject loop and for estimating variances correctly
C     and then refitting polynomial. Force at least 3 loops
C     to use improved variances in fit.
C
            ICYCLE = 0
            NRATS = 0
            DO WHILE(ICYCLE.LE.2 .OR. IREJ.GT.0 )
               ICYCLE = ICYCLE + 1
C
C     Fit polynomial to normalized profile data
C
               CHISQ = 0.D0
               CALL LSQUAR(WORK,NFIT,NPOLY,APOLY,CHISQ,
     &              APOLY(NPOLY+1),1)
C
C     Revise the variance estimates using the fitted model.
C     Also compute the rms residual relative to the revised
C     variance estimates ignoring the rejected points
C
               RMS = 0.
               NFIT = 0
               NDF = 0
               DO IBL = 1, NUMBL
                  IF(STARSUM(IBL).GT.0.) THEN
                     NFIT = NFIT + 1
                     PROF = REAL(POLY(APOLY,NPOLY,WORK(1,NFIT)))
                     FPLOT(NFIT)  = PROF
                     BPLOT(NFIT)  = STARSUM(IBL)
                     IY1 = NBLOCK*(IBL-1) + 1
                     IF(IBL.EQ.NUMBL) THEN
                        IY2 = NYS
                     ELSE
                        IY2 = IY1 + NBLOCK - 1
                     END IF
                     NNOW = IY2 - IY1 + 1
                     PRED = (SKYMEAN(IBL)+PROF*STARSUM(IBL))/REAL(NNOW)
                     SMIN = SKYMEAN(IBL)/REAL(NNOW)
                     VAR  = 0.
                     DO IY = IY1, IY2
                        BALANCE = FLAT(IX,IY)
                        VAR = VAR + BALANCE*(BALANCE*VAR0
     &                       + MAX(ABS(PRED),ABS(SMIN))/PHOTON)
                     END DO
C
C     Correct variances for correlation and variance of
C     STARSUM (01/07/88) TRM
C     KDH found that this correction can let the value go negative
C     but rather than eliminate it, TRM (02/03/90) added a floor
C     Found an error in the part now occupied by VSUM 12/11/96
C     Probably overcorrecting
C

                     PROF = MAX(0., MIN(1., PROF))
                     VAR  = MAX(0.1*VAR, VAR*(1-2.*PROF)+
     &                    PROF*PROF*VSUM(IBL))
C
                     IF(WORK(3,NFIT).LE.0.D0) THEN
                        WORK(3,NFIT) = - SQRT(VAR)/STARSUM(IBL)
                     ELSE
                        WORK(3,NFIT) = SQRT(VAR)/STARSUM(IBL)
                        ETA = REAL((YPLOT(NFIT)-FPLOT(NFIT))/
     &                       WORK(3,NFIT))
                        RMS = RMS + ETA*ETA
                        NDF = NDF + 1
                     END IF
                  END IF
               END DO
               NDF = NDF-NPOLY
               IF(RMS.LE.0. .OR. NDF.LE.1) THEN
                  RMS = 1.
               ELSE
C
C     Minimum variance estimate of RMS
C
                  RMS = SQRT(RMS/NDF)
                  PROB = EXP(-MIN(80.,REAL(NDF)*(RMS-1.)**2./4.))
                  RMS = PROB + (1.-PROB)*RMS
               END IF
C
C     Zap outlaw pixels. Use a poisson rejection scheme
C
               RESCALE = MAX(0.01, RMS)
               RMAX = -1.
               IREJ = 0
               DO I = 1, NFIT
                  IF( WORK(3,I).GT.0.D0) THEN
C
C     Everything rescaled by BPLOT(I) in order to
C     apply Poisson rejection scheme correctly
C
                     FAC   = BPLOT(I)
                     OBS   = FAC*YPLOT(I)
                     PRED  = FAC*FPLOT(I)
                     SIGMA = REAL(FAC*RESCALE*ABS(WORK(3,I)))
                     RATIO = CHANCE(OBS,PRED,SIGMA,THRLO,THRHI)
                     IF(RATIO.GT.-0.5) THEN
                        IF(RATIO.GT.RMAX) THEN
                           IREJ = I
                           RMAX = RATIO
                        END IF
                     END IF
                  END IF
               END DO
C
C     Eliminate worst point by putting weight negative
C
               IF(IREJ.GT.0) THEN
                  NRATS = NRATS + 1
                  WORK(3,IREJ) = - ABS(WORK(3,IREJ))
                  PLOG = -RMAX/LOG(10.)
                  WRITE(OUTPUT,'(A,I4,A,I4,A,F10.3)')
     &                 ' Zap X,Y: ',IX+XLO-1,',',NINT(XPLOT(IREJ)),
     &                 ', LOG10(RATIO) = ',PLOG
                  CALL MSG_OUT(' ',OUTPUT, STATUS)
               END IF
            END DO
            WRITE(OUTPUT,'(A,I3,A,F8.3)') 'Poly-terms =', NPOLY,
     *           ' (True noise)/(predicted noise) =', RMS
            CALL MSG_OUT(' ',OUTPUT, STATUS)
            WRITE(OUTPUT,'(A,I3,A,I4)')
     &           'Number of cycles performed = ',
     &       ICYCLE,', total number of blocks rejected:', NRATS
            CALL MSG_OUT(' ',OUTPUT, STATUS)
C
C     Fit plotted in green
C     Plot rejected points in red.
C
            IF(NEXT.EQ.' ' .AND. WHAT.NE.'N') THEN
               DO I = 1, NFIT
                  IF(WORK(3,I).LT.0.) THEN
                     CALL PGSCI(0)
                     CALL PGPOINT(1,XPLOT(I),YPLOT(I),1)
                     CALL PGSCI(2)
                     CALL PGPOINT(1,XPLOT(I),YPLOT(I),17)
                  END IF
               END DO
               CALL PGSCI(3)
               CALL PGLINE(NFIT,XPLOT,FPLOT)
            END IF
C
            IF(NEXT.NE.'E' .AND. WHAT.NE.'N') THEN
               WRITE(*,'(A,$)')
     &     '<CR> for next plot, S(kip a plot), E(nd plots): '
               READ(*,'(A)') NEXT
               CALL UPPER_CASE(NEXT)
C
               IF(PREVIOUS) THEN
                  CALL PGSCI(0)
                  CALL PGLINE(NFIT,XPLOT,FPLOT)
                  CALL PGSCI(0)
                  CALL PGPOINT(NFIT,XPLOT,YPLOT,1)
                  DO I = 1, NFIT
                     IF(WORK(3,I).LT.0.) THEN
                        CALL PGSCI(0)
                        CALL PGPOINT(1,XPLOT(I),YPLOT(I),17)
                     END IF
                  END DO
                  CALL PGSCI(2)
                  CALL PGLINE(NFIT,XPLOT,FPLOT)
               END IF
            END IF
C
C     Store final poly-fit coefficients for later use
C
            DO IP = 1, NPOLY
               PSTORE(IP,IX) = APOLY(IP)
            END DO
         END DO
C
         IF(WHAT.NE.'N')    CALL PGEND
         IF(PLOT) THEN
            CALL MSG_OUT(' ','Profile fit complete', STATUS)
            CALL MSG_OUT(' ','Extracting the 1-D spectrum',
     &           STATUS)
         END IF
      END IF
C
C     Extraction stage, same whether old or new fit.
C
      IF(ZAPRATS .AND. PLOT) THEN
         WRITE(*,'(A,$)') 'Plot rejected profiles ? [N] '
         READ(*,'(A)') WHAT
         CALL UPPER_CASE(WHAT)
      ELSE
        WHAT = 'N'
      END IF
C
      IF(WHAT.EQ.'Y') THEN
        PLOTR = .TRUE.
      ELSE
        PLOTR = .FALSE.
      END IF
C
C     Compute sky fit covariance matrix
C
      IF(NPSKY.GT.0) THEN
         CALL VARSKY(MASK,SLO,NS,NPSKY,XLO,NXS,VARMAT,STATUS)
         IF(STATUS.NE.SAI__OK) RETURN
      END IF
C
      NRATS = 0
      YPOS  = (1+NYS)/2
      DO IY = 1, NYS
         YNORM = (DBLE(IY+YLO-1)-ZERO)/SCALE
C
C     evaluate polynomials and force profile to be positive
C
         PSUM  = 0.
         SKAVE = 0.
         NOK   = 0
         DO IX = 1, NXS
            PFL  = REAL(POLY( PSTORE(1, IX), NPOLY, YNORM))
            PFL  = MAX(0.,PFL)
            PSUM = PSUM + PFL
            PROFILE(IX) = PFL
C
C     stow a spatial slice of the spectrum data
C     for plotting if a point is rejected
C
            XPLOT(IX) = IX+XLO-1
            IF(DATA(IX,IY).NE.VAL__BADR .AND.
     &           FLAT(IX,IY).NE.VAL__BADR .AND.
     &           DARK(IX,IY).NE.VAL__BADR .AND.
     &           SKY(IX,IY).NE.VAL__BADR) THEN
               NOK     = NOK + 1
               BALANCE = FLAT(IX,IY)
               SKYS    = SKY(IX,IY) + BALANCE*DARK(IX,IY)
               SKAVE   = SKAVE + SKYS
               STAR    = BALANCE*DATA(IX,IY)-SKYS
               VAR     = BALANCE*(BALANCE*VAR0
     &              + MAX(CMIN,ABS(BALANCE*DATA(IX,IY)),
     &              ABS(SKYS))/PHOTON)
               YPLOT(IX) = STAR
               EPLOT(IX) = SQRT(VAR)
               BPLOT(IX) = BALANCE
            ELSE
C
C     Set value of YPLOT to bad pixel value as flag for later
C
               YPLOT(IX) = VAL__BADR
            END IF
         END DO
         IF(NOK.GT.0) THEN
            SKAVE = SKAVE/REAL(NOK)
            VNORM = VAR0+MAX(0.,SKAVE)/PHOTON
C
C     renormalize profile to unit sum
C
            SUM  = 0.D0
            SUMF = 0.D0
            DO I = 1, NXS
               PROFILE(I) = PROFILE(I)/PSUM
               FPLOT(I)   = PROFILE(I)
               IF(YPLOT(I).NE.VAL__BADR) THEN
                  SUM  = SUM + YPLOT(I)
                  SUMF = SUMF + PROFILE(I)
               END IF
            END DO
C
C     Compute weighted mean position to return
C     as extraction position
C
            IF(IY.EQ.YPOS) THEN
               SUMD = 0.D0
               SUMD2= 0.D0
               DO I = 1, NXS
                  SUMD  = SUMD  + DBLE(I+XLO-1)*PROFILE(I)
                  SUMD2 = SUMD2 + PROFILE(I)
               END DO
               CPOS = REAL(SUMD/SUMD2)
            END IF
C
C     initial estimate of the spectrum is a normal
C     sum across the profile, corrected for any pixels
C     rejected by bad pixel value
C
            SPEC(IY) = REAL(SUM/SUMF)
C
C     loop to reject cosmic rays
C     Up to MAXREJ pixels can be rejected, one at a time.
C
            IF(ZAPRATS) THEN
               MAXREJ = 20
               NREJ   = 0
               ICYCLE = 0
C
C     Initialise variables which will be used to correct
C     for the correlation between the spectrum point and the
C     particular data point (01/07/88)
C
               WVSUM = 0.D0
               WSUM  = 0.D0
               SUMD2 = 0.D0
               DO I = 1, NXS
                  IF(YPLOT(I).NE.VAL__BADR) THEN
                     WEIGHT(I) = 1.
                     BALANCE    = BPLOT(I)
                     SKYS       = SKY(I,IY)+BALANCE*DARK(IX,IY)
                     STAR       = SPEC(IY)*PROFILE(I)
                     WSUM       = WSUM + PROFILE(I)
                     WVSUM      = WVSUM +
     &                    BALANCE*(BALANCE*VAR0+
     &                    ABS(STAR+SKYS)/PHOTON)
                     IF(NPSKY.GT.0) THEN
                        DO J = 1, NXS
                           IF(YPLOT(J).NE.VAL__BADR) THEN
                              SUMD2 = SUMD2 + VARMAT(J,I)
                           END IF
                        END DO
                     END IF
                  END IF
               END DO
C
               MORE = .TRUE.
               DO WHILE(ICYCLE.LE.2 .OR.
     &              (NREJ.LT.MAXREJ.AND.MORE) )
                  ICYCLE = ICYCLE + 1
                  IREJL = 0
                  IREJH = 0
                  RMAXL = -1.
                  RMAXH = -1.
                  DO IX = 1, NXS
C
C     Compute revised variance estimate using profile model
C     Skip rejected pixels, find worst pixel. At least one
C     extra run is forced to take advantage of the improved
C     estimate of the spectrum, even if no pixel is rejected.
C
                     IF(YPLOT(IX).NE.VAL__BADR .AND.
     &                    EPLOT(IX).GT.0.) THEN
                        BALANCE = BPLOT(IX)
                        SKYS = SKY(IX,IY)+BALANCE*DARK(IX,IY)
                        STAR = SPEC(IY)*PROFILE(IX)
                        FPLOT(IX) = STAR
C
C     Avoid crashes in zero photon case by pretending that
C     there is one photon. This will be a bad approximation
C     if there are very many such instances since then the
C     chance of only one photon is small. However, this
C     should be rare.
C
                        STAR = MAX(PROFILE(IX)/PHOTON, STAR)
C
C     Old estimate preserved to avoid the correlation correction
C     going negative in next section, which it otherwise can do
C     in rare circumstances. Change made by TRM @STSCI 05/03/90
C
                        VOLD = EPLOT(IX)**2
                        VAR = BALANCE*(BALANCE*VAR0
     &                       +MAX(ABS(SKYS),
     &                       ABS(STAR+SKYS))/PHOTON)
                        EPLOT(IX) = SQRT(VAR)
C
C     A correction is made before calling CHANCE to account for
C     correlation between the estimated spectrum and the
C     data value. This increases the chance of rejection on
C     data points with high weights which was too low before.
C     Approximate decrease in VAR by (1-f*f/Sum of f*f) where f
C     is the profile factor. (01/07/88 TRM)
C
C     A floor to var is added for the test on the assumption that
C     the fractional flux is at best accurate to EPS
C     This reduces the chances of silly rejections when the smooth
C     model is imperfect as can happen due to imperfection of CCD
C     Purely empirical
C
                        VAR = REAL(VOLD*(1.-2.*WEIGHT(IX)*
     &                       PROFILE(IX)/WSUM)+(WVSUM+
     &                       SUMD2*VNORM)*(PROFILE(IX)/WSUM)**2)
                        VAR = SQRT(MAX(1.,VAR))
                        VAR = MAX(VAR, EPS*FPLOT(IX))
                        RATIO = CHANCE(YPLOT(IX),FPLOT(IX),
     &                       VAR, RATLO, RATHI)
C
C     find worst positive and negative outliers. Negative outliers
C     rejected only when all positive outliers have been rejected.
C
                        IF(RATIO.GT.-0.5) THEN
                           DIFF = YPLOT(IX)-FPLOT(IX)
                           IF(DIFF.GT.0.) THEN
                              IF(RATIO.GT.RMAXH) THEN
                                 RMAXH = RATIO
                                 IREJH = IX
                              END IF
                           ELSE
                              IF(RATIO.GT.RMAXL) THEN
                                 RMAXL = RATIO
                                 IREJL = IX
                              END IF
                           END IF
                        END IF
                     ELSE
                        FPLOT(IX) = SPEC(IY)*PROFILE(IX)
                     END IF
                  END DO
C
C     Reject worst outlier
C
                  IF(IREJH.GT.0 .OR. IREJL.GT.0) THEN
                     NREJ = NREJ + 1
                     IF(IREJH.GT.0) THEN
                        EPLOT(IREJH) = - ABS(EPLOT(IREJH))
                        PLOG = -RMAXH/LOG(10.)
                        IXK = IREJH
                     ELSE
                        EPLOT(IREJL) = - ABS(EPLOT(IREJL))
                        PLOG = -RMAXL/LOG(10.)
                        IXK = IREJL
                     END IF
                     WRITE(OUTPUT,'(A,I4,A,I4,A,F10.3)')
     &                    ' Zap X,Y: ',IXK+XLO-1,',',IY+YLO-1,
     &                    ', LOG10(RATIO) = ',PLOG
                     CALL MSG_OUT(' ',OUTPUT, STATUS)
                     MORE = .TRUE.
                  ELSE
                     MORE = .FALSE.
                  END IF
C
C     Load optimal weights
C
                  DO I = 1, NXS
                     IF(YPLOT(I).NE.VAL__BADR .AND.
     &                    EPLOT(I).GT.0.) THEN
                        WEIGHT(I) = PROFILE(I)/EPLOT(I)**2
                     END IF
                  END DO
C
                  SUM   = 0.D0
                  WSUM  = 0.D0
                  SUMD2 = 0.D0
                  WVSUM = 0.D0
                  DO I = 1, NXS
                     IF(YPLOT(I).NE.VAL__BADR .AND.
     &                    EPLOT(I).GT.0.) THEN
                        SUM   = SUM   + WEIGHT(I)*YPLOT(I)
                        WSUM  = WSUM  + WEIGHT(I)*PROFILE(I)
                        WVSUM = WVSUM + (WEIGHT(I)*EPLOT(I))**2
                        SUMD  = 0.
                        IF(NPSKY.GT.0) THEN
                           DO J = 1, NXS
                              IF(YPLOT(J).NE.VAL__BADR .AND.
     &                             EPLOT(J).GT.0.) THEN
                                 SUMD = SUMD + WEIGHT(J)*VARMAT(J,I)
                              END IF
                           END DO
                           SUMD2 = SUMD2 + WEIGHT(I)*SUMD
                        END IF
                     END IF
                  END DO
C
C     stow optimal spectrum and its standard deviation
C
                  IF(WSUM.GT.0.) THEN
                     SPEC(IY)    = REAL(SUM/WSUM)
                     SPECVAR(IY) = REAL((WVSUM+SUMD2*VNORM)/WSUM**2)
                  ELSE
                     SPEC(IY)    =  VAL__BADR
                     SPECVAR(IY) =  VAL__BADR
                  END IF
               END DO
               NRATS = NRATS + NREJ
            ELSE
C
C     If not cosmic ray zapping, just give
C     normal weighted estimate, with an
C     extra loop to refine the variances.
C
               DO J = 1, 2
C
C     Load optimal weights
C
                  DO I = 1, NXS
                     IF(YPLOT(I).NE.VAL__BADR) THEN
                        WEIGHT(I) = PROFILE(I)/EPLOT(I)**2
                     END IF
                  END DO
                  VNORM = VAR0+MAX(0.,SKAVE)/PHOTON
                  SUM   = 0.D0
                  WSUM  = 0.D0
                  SUMD2 = 0.D0
                  WVSUM = 0.D0
                  DO I = 1, NXS
                     IF(YPLOT(I).NE.VAL__BADR) THEN
                        SUM   = SUM+WEIGHT(I)*YPLOT(I)
                        WSUM  = WSUM+WEIGHT(I)*PROFILE(I)
                        WVSUM = WVSUM+(WEIGHT(I)*EPLOT(I))**2
                        IF(NPSKY.GT.0) THEN
                           SUMD  = 0.
                           DO K = 1, NXS
                              IF(YPLOT(K).NE.VAL__BADR) THEN
                                 SUMD = SUMD + WEIGHT(K)*VARMAT(K,I)
                              END IF
                           END DO
                           SUMD2 = SUMD2 + WEIGHT(I)*SUMD
                        END IF
                     END IF
                  END DO
C
C     stow optimal spectrum and its standard deviation
C
                  IF(WSUM.GT.0.) THEN
                     SPEC(IY)    = REAL(SUM/WSUM)
                     SPECVAR(IY) = REAL((WVSUM+SUMD2*VNORM)/WSUM**2)
                  ELSE
                     SPEC(IY)    =  VAL__BADR
                     SPECVAR(IY) =  VAL__BADR
                  END IF
C
                  IF(J.LT.2) THEN
                     DO IX = 1, NXS
                        IF(YPLOT(IX).NE.VAL__BADR) THEN
                           BALANCE = BPLOT(IX)
                           SKYS = SKY(IX,IY)+BALANCE*DARK(IX,IY)
                           STAR = MAX(1.,SPEC(IY))*PROFILE(IX)
                           VAR = BALANCE*(BALANCE*VAR0
     &                          +MAX(ABS(SKYS),
     &                          ABS(STAR+SKYS))/PHOTON)
                           EPLOT(IX) = SQRT(VAR)
                        END IF
                     END DO
                  END IF
               END DO
            END IF
C
C     Code to plot seeing profile with cosmic rat
C
            IF(SPEC(IY).NE.VAL__BADR .AND. PLOTR
     &           .AND. NREJ.GT.0 ) THEN
               WRITE(*,'(A,$)') 'Plot rejected profile ? [N] '
               READ(*,'(A)') WHAT
               CALL UPPER_CASE(WHAT)
               IF(WHAT.EQ.'Y') THEN
                  ID = PGOPEN(DEVICE)
                  IF(ID.GE.1) THEN
                     YMIN =  1.E20
                     YMAX = -1.E20
                     DO I = 1, NXS
                        IF(YPLOT(I).NE.VAL__BADR) THEN
                           YMIN = MIN(YMIN, YPLOT(I))
                           YMAX = MAX(YMAX, YPLOT(I))
                        END IF
                     END DO
                     RANGE = MAX(10.,YMAX-YMIN)
                     YMIN  = MIN(YMIN - RANGE/10., 0.)
                     YMAX  = YMAX + RANGE/10.
                     WRITE(TITLE,'(''ROW'',I4,3X)') IY
                     XMN=XLO-1
                     XMX=XLO+NXS
                     CALL PGSCI(5)
                     CALL PGENV(XMN, XMX, YMIN, YMAX, 0, 0)
                     CALL PGMOVE( XMN, 0. )
                     CALL PGDRAW( XMX, 0. )
                     CALL PGSCI(7)
                     CALL PGLAB('X-column', 'Profile', TITLE)
                     DO I=1,NXS
                        IF(EPLOT(I).GT.0. .AND.
     &                       YPLOT(I).NE.VAL__BADR) THEN
                           CALL PGSCI(3)
                           CALL PGMOVE(XPLOT(I),YPLOT(I)-EPLOT(I))
                           CALL PGDRAW(XPLOT(I),YPLOT(I)+EPLOT(I))
                           CALL PGSCI(1)
                           CALL PGPT(1,XPLOT(I),YPLOT(I),4)
                        ELSE IF(YPLOT(I).EQ.VAL__BADR) THEN
                           CALL PGSCI(2)
                           CALL PGPT( 1, XPLOT(I),0.,5)
                        ELSE
                           CALL PGSCI(2)
                           CALL PGMOVE(XPLOT(I), YPLOT(I)-EPLOT(I))
                           CALL PGDRAW(XPLOT(I), YPLOT(I)+EPLOT(I))
                           CALL PGPT(1,XPLOT(I),YPLOT(I),5)
                        END IF
                     END DO
                     RSCALE = (SPEC(IY)+SQRT(SPECVAR(IY)))/SPEC(IY)
                     DO I=1,NXS
                        FPLOT(I) = RSCALE*FPLOT(I)
                     END DO
                     CALL PGSCI(7)
                     CALL PGLINE(NXS, XPLOT, FPLOT)
                     RSCALE = RSCALE*RSCALE
                     DO I=1,NXS
                        FPLOT(I) = FPLOT(I)/RSCALE
                     END DO
                     CALL PGLINE(NXS, XPLOT, FPLOT)
                     CALL PGCLOS
                  END IF
               END IF
            END IF
         ELSE
            SPEC(IY)    = VAL__BADR
            SPECVAR(IY) = VAL__BADR
            CALL MSG_SETI('IY',IY+YLO-1)
            CALL MSG_OUT(' ','Whole profile rejected at Y = ^IY',
     &           STATUS)
         END IF
      END DO
      WRITE(OUTPUT,'(A,I4)') 'Total pixels rejected:', NRATS
      CALL MSG_OUT(' ',OUTPUT, STATUS)
      RETURN
      END

