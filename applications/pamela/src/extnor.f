*EXTNOR
*
* EXTNOR -- normal extraction routine by summation across object region.
*
* 'extnor' requires an estimated sky region from 'skyfit' and will
* estimate uncertainties according to parameters of a noise model.
*
* Bad pixels: Any bad pixel in the data, balance or sky fit frames
* will casue the respective row to be lost.
*
*  IMAGE   -- The data file for extraction.
*
*  FLAT    -- Contains balance factors which when multiplied into
*             the data correct for short scale sensitivity
*             variations.
*
*  DLOAD   -- TRUE if dark frame is required.
*
*  DARK    -- Dark frame representing counts unaffected by slit
*             profile. This will be subtracted off data before applying
*             the balance factors.
*
*  REGION  -- Contains the object region limits. This file should
*             have been generated by 'regpic' or 'skymov'.
*
*  SKY     -- Contains fits to the background sky in the region of
*             the object. Produced by 'skyfit'.
*
*  TRACE   -- True if you want to include a poly fit to the X position of
*             the spectrum (made with 'track').
*
*  If TRACE
*
*     TRACK   -- Name of poly fit distortion map file
*
*  SPECT   -- The output file for both the spectrum and the uncertainty
*             estimates.
*
*  YSTART,YEND -- The Y pixel limit of the extraction.
*
*  READOUT -- The readout noise of the detector in RMS data units/pixel
*
*  PHOTON  -- The number of photons per data number.
*
*EXTNOR
      SUBROUTINE EXTNOR(STATUS)
C
      IMPLICIT NONE
      INCLUDE 'SAE_PAR'
      INCLUDE 'DAT_PAR'
      INCLUDE 'CNF_PAR'
      INTEGER STATUS, NPOLY, NDIM, EL, DARK
      INTEGER LBND(2), UBND(2), XLO, XHI, YLO, YHI
      INTEGER IMAGE, FLAT, REGION, SKY, SPECT
      INTEGER IPTR, FPTR, RPTR, SPTR, OPTR, VPTR
      INTEGER TRIM(4), WPTR, PLACE, TEMP, SMALL, DPTR
      INTEGER WORK, NO, SLO, SHI, NS, NXS, NYS
      REAL LEFT, RIGHT, READOUT, PHOTON, CPOS
      LOGICAL TRACE, BASE, THERE, IBASE, FBASE, SBASE, DBASE
      LOGICAL DLOAD
      DOUBLE PRECISION YREF, YPOS, TOFF
      CHARACTER*(DAT__SZLOC) LOC, LOCR, LOCS, LOCR1, LOCS1
C
C     Start
C
      IF(STATUS.NE.SAI__OK) RETURN
      CALL NDF_BEGIN
C
C     Open data file
C
      CALL NDF_ASSOC('IMAGE', 'READ',IMAGE, STATUS)
C
C     Open balance frame, identifier FLAT
C
      CALL NDF_ASSOC('FLAT','READ',FLAT,STATUS)
C
C     Open dark frame
C
      CALL PAR_GET0L('DLOAD', DLOAD, STATUS)
      IF(DLOAD) THEN
         CALL NDF_ASSOC('DARK','READ',DARK,STATUS)
      ELSE
         CALL NDF_BOUND(FLAT, 2, LBND, UBND, NDIM, STATUS)
         CALL NDF_TEMP(PLACE, STATUS)
         CALL NDF_NEW('_REAL', NDIM, LBND, UBND, PLACE, DARK, STATUS)
      END IF
C
C
C     Get sky region input file, check its OK
C     It must be a bse ndf to allow correct computation
C     of uncertainties.
C
      CALL NDF_ASSOC('REGION','READ',REGION,STATUS)
      CALL NDF_ISBAS(REGION, BASE, STATUS)
      IF(STATUS.EQ.SAI__OK .AND. .NOT.BASE) THEN
         STATUS = SAI__ERROR
         CALL ERR_REP(' ','Sky region file must be a base NDF'
     &        //' to allow computation of uncertainties.',STATUS)
      END IF
C
      CALL NDF_XGT0R(REGION,'PAMELA','REGPIC.LEFT',LEFT,STATUS)
      CALL NDF_XGT0R(REGION,'PAMELA','REGPIC.RIGHT',RIGHT,STATUS)
      IF(STATUS.EQ.SAI__OK .AND. (LEFT.GT.RIGHT
     &     .OR. LEFT.LE.0.)) THEN
         STATUS = SAI__ERROR
         CALL ERR_REP(' ','Bad object limits', STATUS)
      END IF
      CALL NDF_BOUND(REGION, 1, SLO, SHI, NDIM, STATUS)
      NS  = SHI - SLO + 1
C
C     Open sky file. Number of poly coefficients is used in
C     uncertainty estimation.
C
      CALL NDF_ASSOC('SKY','READ',SKY,STATUS)
      CALL NDF_XSTAT(SKY, 'PAMELA', THERE, STATUS)
      NPOLY = 0
      IF(THERE) THEN
         CALL NDF_XLOC(SKY,'PAMELA', 'READ', LOCS, STATUS)
         CALL DAT_THERE(LOCS, 'SKYFIT', THERE, STATUS)
         CALL DAT_ANNUL(LOCS, STATUS)
         IF(THERE)
     &        CALL NDF_XGT0I(SKY,'PAMELA','SKYFIT.NPOLY',NPOLY,STATUS)
      END IF
C
C     See if distortion file is wanted
C
      CALL PAR_GET0L('TRACE', TRACE, STATUS)
      IF(TRACE) THEN
         CALL GET_TRACK(YPOS, TOFF, STATUS)
C
C     If a track is used, there must be a reference Y position in the
C     sky region file
C
         CALL NDF_XGT0D(REGION,'PAMELA','REGPIC.YREF',YREF,STATUS)
      END IF
C
C     Get spectrum output name
C
      CALL NDF_SECT(IMAGE,1,1,1,SMALL,STATUS)
      CALL NDF_PROP(SMALL,' ','SPECT',SPECT,STATUS)
      CALL NDF_RESET(SPECT,'Title',STATUS)
      CALL NDF_CPUT('EXTNOR output',SPECT,'Title',STATUS)
C
C     What region of frame
C
      CALL NDF_ISBAS(IMAGE, IBASE, STATUS)
      CALL NDF_ISBAS(FLAT,  FBASE, STATUS)
      CALL NDF_ISBAS(SKY,   SBASE, STATUS)
      CALL NDF_ISBAS(DARK,  DBASE, STATUS)
      BASE = IBASE .AND. FBASE .AND. SBASE .AND. DBASE
      TRIM(1) = IMAGE
      TRIM(2) = FLAT
      TRIM(3) = DARK
      TRIM(4) = SKY
      CALL NDF_MBNDN('TRIM',4,TRIM,STATUS)
      IMAGE = TRIM(1)
      FLAT  = TRIM(2)
      DARK  = TRIM(3)
      SKY   = TRIM(4)

      CALL NDF_BOUND(IMAGE, 2, LBND, UBND, NDIM, STATUS)
      IF(BASE .AND. NDIM.EQ.2) THEN
         CALL PAR_GDR0I('YSTART',LBND(2),LBND(2),UBND(2),
     &        .FALSE.,YLO,STATUS)
         CALL PAR_GDR0I('YEND',UBND(2),YLO,UBND(2),
     &        .FALSE.,YHI,STATUS)
      ELSE
         YLO = LBND(2)
         YHI = UBND(2)
      END IF
C
C     compute minimal range in X to use
C
      CALL XLIMS(TRACE,YREF,LEFT,RIGHT,YLO,YHI,XLO,XHI,STATUS)
      XLO = MAX(LBND(1), XLO)
      XHI = MIN(UBND(1), XHI)
C
C     Generate appropriate section NDFs
C
      IF(XLO.NE.LBND(1) .OR. XHI.NE.UBND(1) .OR.
     &     YLO.NE.LBND(2) .OR. YHI.NE.UBND(2)) THEN
         LBND(1) = XLO
         UBND(1) = XHI
         LBND(2) = YLO
         UBND(2) = YHI
         CALL NDF_SECT(IMAGE, 2, LBND, UBND, TEMP, STATUS)
         CALL NDF_ANNUL(IMAGE, STATUS)
         CALL NDF_CLONE(TEMP, IMAGE, STATUS)
         CALL NDF_ANNUL(TEMP, STATUS)

         CALL NDF_SECT(FLAT, 2, LBND, UBND, TEMP, STATUS)
         CALL NDF_ANNUL(FLAT, STATUS)
         CALL NDF_CLONE(TEMP, FLAT, STATUS)
         CALL NDF_ANNUL(TEMP, STATUS)

         CALL NDF_SECT(DARK, 2, LBND, UBND, TEMP, STATUS)
         CALL NDF_ANNUL(DARK, STATUS)
         CALL NDF_CLONE(TEMP, DARK, STATUS)
         CALL NDF_ANNUL(TEMP, STATUS)

         CALL NDF_SECT(SKY, 2, LBND, UBND, TEMP, STATUS)
         CALL NDF_ANNUL(SKY, STATUS)
         CALL NDF_CLONE(TEMP, SKY, STATUS)
         CALL NDF_ANNUL(TEMP, STATUS)
      END IF
C
C     Section dimensions
C
      NXS = UBND(1)-LBND(1)+1
      NYS = UBND(2)-LBND(2)+1
C
C     Noise characteristics
C
      CALL PAR_GDR0R('READOUT',1.E-2,0.,1.E10,.FALSE.,READOUT,STATUS)
      CALL PAR_GDR0R('PHOTON',1.,1.E-10,1.E10,.FALSE.,PHOTON,STATUS)
C
C     Create and map DATA and VARIANCE
C
      CALL NDF_RESET(SPECT,'Data,Variance',STATUS)
      CALL NDF_SBND(1,LBND(2),UBND(2),SPECT,STATUS)
      CALL NDF_STYPE('_REAL',SPECT,'Data,Variance',STATUS)
      CALL NDF_MAP(SPECT,'Data', '_REAL','WRITE',OPTR,EL,STATUS)
      CALL NDF_MAP(SPECT,'Variance','_REAL','WRITE',VPTR,EL,STATUS)
      CALL NDF_CPUT('Counts',SPECT,'Units',STATUS)
C
C     Grab space for skyfit covariance matrix
C
      IF(NPOLY.GT.0) THEN
         CALL NDF_TEMP(PLACE, STATUS)
         NO = NINT(RIGHT)-NINT(LEFT)+1
         CALL NDF_NEW('_REAL',1,1,NO*NO,PLACE,WORK,STATUS)
         CALL NDF_MAP(WORK,'Data','_REAL','WRITE',WPTR,EL,STATUS)
      END IF
C
C     Map files
C
      CALL NDF_MAP(IMAGE,'Data','_REAL','READ',IPTR,EL,STATUS)
      CALL NDF_MAP(FLAT,'Data','_REAL','READ', FPTR,EL,STATUS)
      CALL NDF_MAP(DARK,'Data','_REAL','READ/ZERO', DPTR,EL,STATUS)
      CALL NDF_MAP(SKY,'Data','_REAL','READ',  SPTR,EL,STATUS)
      CALL NDF_MAP(REGION,'Data','_INTEGER','READ',RPTR,EL,STATUS)
C
C     Extract
C
      CALL EXT_NORM(%VAL(CNF_PVAL(IPTR)), %VAL(CNF_PVAL(FPTR)),
     :              %VAL(CNF_PVAL(DPTR)), %VAL(CNF_PVAL(SPTR)),
     &     NXS,  NYS, LEFT, RIGHT, XLO, YLO, READOUT, PHOTON, SLO,
     &     NS, %VAL(CNF_PVAL(RPTR)), NO, %VAL(CNF_PVAL(WPTR)),
     :     NPOLY, YREF, %VAL(CNF_PVAL(OPTR)),
     &     %VAL(CNF_PVAL(VPTR)), CPOS, TRACE, STATUS)
C
C     Create 'pamela' extension if not already one. Write useful
C     info to it.
C
      CALL NDF_XSTAT(SPECT, 'PAMELA', THERE, STATUS)
      IF(.NOT.THERE) THEN
         CALL NDF_XNEW(SPECT,'PAMELA', 'Ext', 0, 0, LOC, STATUS)
      ELSE
         CALL NDF_XLOC(SPECT,'PAMELA', 'UPDATE', LOC, STATUS)
      END IF
C
C     Store position of centre of spectrum and extraction type
C
      CALL NDF_XPT0R(CPOS,SPECT,'PAMELA','CPOS',STATUS)
      CALL NDF_XPT0C('Normal',SPECT,'PAMELA','EXTRACTION',
     &     STATUS)
C
C     Copy components from sky and region files into output file
C
      CALL NDF_XSTAT(SKY, 'PAMELA', THERE, STATUS)
      IF(THERE) THEN
         CALL NDF_XLOC(SKY,'PAMELA', 'READ', LOCS, STATUS)
         CALL DAT_THERE(LOCS, 'SKYFIT', THERE, STATUS)
         IF(THERE) THEN
            CALL DAT_FIND(LOCS, 'SKYFIT', LOCS1, STATUS)
            CALL DAT_COPY(LOCS1, LOC, 'SKYFIT',STATUS)
            CALL DAT_ANNUL(LOCS1, STATUS)
         END IF
         CALL DAT_ANNUL(LOCS, STATUS)
      END IF
      CALL NDF_XLOC(REGION,'PAMELA', 'READ', LOCR, STATUS)
      CALL DAT_FIND(LOCR, 'REGPIC', LOCR1, STATUS)
      CALL DAT_COPY(LOCR1,LOC,'REGPIC',STATUS)
      CALL DAT_ANNUL(LOCR1, STATUS)
      CALL DAT_ANNUL(LOCR, STATUS)
      CALL DAT_ANNUL(LOC, STATUS)
      CALL NDF_END(STATUS)
      RETURN
      END
*
      SUBROUTINE EXT_NORM(DATA, FLAT, DARK, SKY, NXS, NYS, LEFT,
     &     RIGHT, XLO, YLO, READOUT, PHOTON, SLO, NS, MASK, NO,
     &     VARMAT, NPOLY, YREF, SPEC, VARNC, CPOS, TRACE, STATUS)
C
C
C Written by TRM @ RGO June 1988
C
C 30/06/88 TRM @ RGO modified to include uncertainty in sky fit
C Jan 1998 TRM include changes for NDF
C
C Normal extraction of frame DATA by collapse in X. FLAT is the
C balance frame and SKY is a flat fielded estimate of the sky in
C the region to be collapsed. If TRACE, DISTORT maps
C the distortion in the spatial direction of the spectrum.
C
C A correction for the uncertainty in the background sky estimate
C is also included through some matrix computations.
C
C Modified August 1988 by TRM @RGO to include distortion of spectrum
C in spatial direction, measured by routine TRACE
C
C Output:
C  SPEC(NYS) = The spectrum
C ERROR(NYS) = 1-sigma errors on spectrum
C
      IMPLICIT NONE
      INCLUDE 'SAE_PAR'
      INCLUDE 'PRM_PAR'
      INTEGER I, J, NXS, NYS, XLO, YLO, IX1, IX2
      INTEGER IX, IY, STATUS, NO
      REAL SUMTOT, VAR0, QFAC, SKAVE, XSHIFT
      REAL PSUM, SK, DAT, VADD, BALANCE, PARTIAL
      REAL DATA(NXS,NYS), FLAT(NXS,NYS), SKY(NXS,NYS), DARK(NXS,NYS)
      REAL SPEC(NYS), VARNC(NYS), STAR, VAR, READOUT, PHOTON
      REAL LEFT, RIGHT, CPOS, VARMAT(NO,NO)
      INTEGER SLO, NS, MASK(NS), NPOLY
      DOUBLE PRECISION POLY, XREF, XD, YREF, YD
      LOGICAL OK, TRACE
C
      IF(STATUS.NE.SAI__OK) RETURN
      IF(NPOLY.GT.0) THEN
C
C     Compute covariance matrix on fitted sky values
C     These are simply summed for normal extraction since
C     all enter with the same weight
C
         CALL VARSKY(MASK,SLO,NS,NPOLY,NINT(LEFT),NO,
     &        VARMAT,STATUS)
         IF(STATUS.NE.SAI__OK) RETURN
         SUMTOT = 0.
         DO J = 1, NO
            DO I = 1, NO
               SUMTOT = SUMTOT + VARMAT(I,J)
            END DO
         END DO
         CALL MSG_SETR('INC',1.+SUMTOT/REAL(NO))
         CALL MSG_OUT(' ','Uncertainty in sky fit'//
     &        ' increases sky variance contribution by ^INC',
     &        STATUS)
      END IF
C
C     SUMTOT contains the sum over I and J of
C     V(I,J)
C
      VAR0 = READOUT*READOUT
      QFAC = 1./PHOTON
      IF(TRACE) THEN
         CALL GET_TRACK(DBLE(YREF), XREF, STATUS)
         IF(STATUS.NE.SAI__OK) RETURN
         CPOS = REAL(XREF)
      ELSE
         CPOS = REAL(NINT(LEFT)+NINT(RIGHT))/2.
      END IF
      DO IY = 1, NYS
         STAR   = 0.
         VAR    = 0.
         SKAVE  = 0.
         XSHIFT = 0.
         PSUM   = 0.
         OK     = .TRUE.
         IF(TRACE) THEN
            CALL GET_TRACK(DBLE(IY+YLO-1), XD, STATUS)
            IF(STATUS.NE.SAI__OK) RETURN
            XSHIFT = REAL(XD - XREF)
            IX1    = NINT(LEFT+XSHIFT+1.)-(XLO-1)
            IX1    = MAX(1, MIN(IX1, NXS))
C
C     Add up contributions from partial end pixels
C
            IX = IX1 - 1
            IF(IX.GT.0) THEN
               IF(FLAT(IX,IY).NE.VAL__BADR .AND.
     &              DATA(IX,IY).NE.VAL__BADR .AND.
     &              DARK(IX,IY).NE.VAL__BADR .AND.
     &              SKY(IX,IY).NE.VAL__BADR) THEN
                  BALANCE = FLAT(IX,IY)
                  DAT     = BALANCE*DATA(IX,IY)
                  SK      = SKY(IX,IY)+BALANCE*DARK(IX,IY)
                  SKAVE   = SKAVE + SK
                  PARTIAL = (REAL(IX1+XLO)-1.5-LEFT-XSHIFT)
                  STAR    = STAR + PARTIAL*(DAT-SK)
                  VAR     = VAR + PARTIAL*PARTIAL*(BALANCE*
     &                 (BALANCE*VAR0
     &                 + QFAC*MAX(ABS(DAT), ABS(SK))))
                  PSUM    = PSUM + 1.
               ELSE
                  OK = .FALSE.
               END IF
            END IF
            IF(OK) THEN
               IX2 = NINT(RIGHT+XSHIFT-1.)-(XLO-1)
               IX2 = MAX(1, MIN(IX2, NXS))
               IF(IX2.LT.NXS) THEN
                  IX = IX2 + 1
                  IF(FLAT(IX,IY).NE.VAL__BADR .AND.
     &                 DATA(IX,IY).NE.VAL__BADR .AND.
     &                 DARK(IX,IY).NE.VAL__BADR .AND.
     &                 SKY(IX,IY).NE.VAL__BADR) THEN
                     BALANCE = FLAT(IX,IY)
                     DAT     = BALANCE*DATA(IX,IY)
                     SK      = SKY(IX,IY)+BALANCE*DARK(IX,IY)
                     SKAVE   = SKAVE + SK
                     PARTIAL = (RIGHT+XSHIFT-REAL(IX2+XLO)+0.5)
                     STAR    = STAR + PARTIAL*(DAT-SK)
                     VAR     = VAR + PARTIAL*PARTIAL*(BALANCE*
     &                    (BALANCE*VAR0
     &                    + QFAC*MAX(ABS(DAT), ABS(SK))))
                     PSUM    = PSUM + 1.
                  ELSE
                     OK = .FALSE.
                  END IF
               END IF
            END IF
         ELSE
            IX1 = NINT(LEFT)-(XLO-1)
            IX2 = NINT(RIGHT)-(XLO-1)
         END IF
C
C     Add in whole pixels
C
         DO IX = IX1, IX2
            IF(OK .AND. FLAT(IX,IY).NE.VAL__BADR .AND.
     &           DATA(IX,IY).NE.VAL__BADR .AND.
     &           DARK(IX,IY).NE.VAL__BADR .AND.
     &           SKY(IX,IY).NE.VAL__BADR) THEN
               BALANCE = FLAT(IX,IY)
               DAT     = BALANCE*DATA(IX,IY)
               SK      = SKY(IX,IY)+BALANCE*DARK(IX,IY)
               SKAVE   = SKAVE + SK
               STAR    = STAR  + DAT-SK
               VAR     = VAR + BALANCE*(BALANCE*VAR0 + QFAC*
     &              MAX(ABS(DAT), ABS(SK)))
            ELSE
               OK = .FALSE.
            END IF
         END DO
         IF(OK) THEN
            SKAVE = SKAVE/(PSUM+REAL(IX2-IX1+1))
            IF(NPOLY.GT.0) THEN
               VADD = SUMTOT*(VAR0+QFAC*MAX(0.,SKAVE))
            ELSE
               VADD = 0.
            END IF
            SPEC(IY)  = STAR
            VARNC(IY) = MAX(QFAC,VAR+VADD)
         ELSE
            SPEC(IY)  = VAL__BADR
            VARNC(IY) = VAL__BADR
         END IF
      END DO
      RETURN
      END



