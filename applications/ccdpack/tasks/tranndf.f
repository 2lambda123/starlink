      SUBROUTINE TRANNDF( STATUS )
*+
*  Name:
*     TRANNDF

*  Purpose:
*     Transforms a list of NDFs by resampling.

*  Language:
*     Starlink Fortran 77

*  Type of Module:
*     ADAM A-task

*  Invocation:
*     CALL TRANNDF( STATUS )

*  Arguments:
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Description:
*     This application performs the arbitrary transformation of a list
*     of NDFs using transform structures created by routines such as
*     REGISTER and CCDEDIT. The output NDFs are calculated by resampling
*     the data of the input NDFs. Output array elements are set to the
*     bad value if their inverse-transformed coordinates lie outside the
*     corresponding input NDF's coordinate limits.
*
*     NDFs processed within CCDPACK may be resampled using the
*     appropriate transformation structures located within the NDF's
*     extensions. Using these facilities allows many NDFs to be aligned
*     with one invocation.

*  Usage:
*     tranndf in out [method]

*  ADAM Parameters:
*     CONSERVE = _LOGICAL (Read)
*        If CONSERVE is TRUE, the output values are normalised by the
*        ratio of the output-to-input pixel areas.  In other words this
*        conserves flux.  If CONSERVE is FALSE, there is no normalisation.
*        If the NDFs WCS component (see USEWCS parameter) is used to define the
*        transformation then the program will be unable to determine whether 
*        the transformation is of a linear nature. If CONSERVE is set to TRUE,
*        the program will warn the user that although it is atempting to
*        conserve flux it may do so corretly if the transform is non-linear.
*        [TRUE]
*     IN = NDF (Read)
*        A list of NDF names whose data are to be transformed. The NDF
*        names should be separated by commas and may include wildcards.
*     INEXT = _LOGICAL (Read)
*        If TRUE then the transformation which is to be applied to the
*        NDF is stored in the NDF's CCDPACK extension
*        (.MORE.CCDPACK.TRANSFORM). If FALSE then a transformation
*        structure must be supplied via the parameter TRANSFORM. This
*        transformation is then applied to the list of NDFs.  [TRUE]
*     LBOUND() = _INTEGER (Read)
*        If SHAPE is "SPECIFY" then this parameter specifies the lower
*        pixel-index bounds of all the output NDFs. The number of
*        values should equal the maximum number of dimensions of the
*        input NDFs. The suggested defaults are the lower bounds
*        generated by the SHAPE="AUTO" option for the first NDF. These
*        bounds are probably small enough to ensure that all the
*        transformed data (of the first NDF) will appear in the output
*        NDF.
*        [Dynamic default]
*     LOGFILE = FILENAME (Read)
*        Name of the CCDPACK logfile.  If a null (!) value is given for
*        this parameter then no logfile will be written, regardless of
*        the value of the LOGTO parameter.
*
*        If the logging system has been initialised using CCDSETUP
*        then the value specified there will be used. Otherwise, the
*        default is "CCDPACK.LOG".
*        [CCDPACK.LOG]
*     LOGTO = LITERAL (Read)
*        Every CCDPACK application has the ability to log its output
*        for future reference as well as for display on the terminal.
*        This parameter controls this process, and may be set to any
*        unique abbreviation of the following:
*           -  TERMINAL  -- Send output to the terminal only
*           -  LOGFILE   -- Send output to the logfile only (see the
*                           LOGFILE parameter)
*           -  BOTH      -- Send output to both the terminal and the
*                           logfile
*           -  NEITHER   -- Produce no output at all
*
*        If the logging system has been initialised using CCDSETUP
*        then the value specified there will be used. Otherwise, the
*        default is "BOTH".
*        [BOTH]
*     METHOD = LITERAL (Read)
*        The interpolation method used to resample the input NDF data
*        arrays. Permitted values are "NEAREST" for nearest-neighbour,
*        and "LININT" for linear interpolation.
*        [NEAREST]
*     OUT = LITERAL (Write)
*        Names of the output -- transformed -- NDFs. These may be
*        specified as list of comma separated names, using indirection
*        if required, or, as a single modification element (of the
*        input names). The simplest modification element is the
*        asterisk "*" which means call each of the output NDFs the same
*        name as the corresponding input NDFs. So,
*           IN > *
*           OUT > *
*        signifies that all the NDFs in the current directory should be
*        used and the output NDFs should have the same names. Other
*        types of modification can also be used, such as,
*           OUT > *-TRN
*        which means call the output NDFs the same as the input NDFs
*        but add -TRN to the end of the names. Replacement of a
*        specified string with another in the output file names can
*        also be used,
*           OUT > *|RAW|RES|
*        this replaces the string RAW with RES in any of the output
*        names.
*     SHAPE = LITERAL (Read)
*        The method to be used to determine the SHAPE of the output
*        NDFs. Can take one of the values "AUTO", "SAME", "SPECIFY".
*        With the meanings.
*
*           - AUTO    -- automatically determine the bounds of the
*                        output NDFs such that all of the input data
*                        appears. This is achieved by transforming test
*                        points along the current bounds so assumes
*                        that the transformation will behave reasonably.
*           - SAME    -- set the output NDF bounds to those of the
*                        corresponding input NDFs.
*           - SPECIFY -- you will specify a single set of bounds for
*                        all the output NDFs. (See the LBOUND and UBOUND
*                        parameters.)
*        [AUTO]
*     TITLE = LITERAL (Read)
*        Title for the output images.
*        [Output from TRANNDF]
*     TRANSFORM = TRN (Read)
*        If INEXT is FALSE then this parameter specifies the
*        transformation structure.  This includes the file name and the
*        HDS object.  For example, DISTORT.MAPPING would use the
*        TRANSFORM structure called MAPPING in the HDS file DISTORT.
*        Normally the object name is TRANSFORM.  The structure must
*        contain both the forward and inverse mappings. This transform
*        if supplied acts on all the input NDFs.
*     UBOUND() = _INTEGER (Read)
*        If SHAPE is "SPECIFY" then this parameter specifies the upper
*        pixel-index bounds of all the output NDFs. The number of
*        values should equal the maximum number of dimensions of the
*        input NDFs. The suggested defaults are the upper bounds
*        generated by the SHAPE="AUTO" option for the first NDF. These
*        bounds are probably large enough to ensure that all the
*        transformed data (of the first NDF) will appear in the output
*        NDF.
*        [Dynamic default]
*     USEWCS = _LOGICAL (Read)
*        If TRUE then the transformation which is to be applied to the
*        NDF is stored in the NDF's WCS extension. If FALSE then the
*        transformation is either stored as a TRN structure in the
*        NDF's CCDPACK extension (.MORE.CCDPACK.TRANSFORM), or is
*        supplied by the user (see the INEXT parameter). [TRUE]

*  Examples:
*     tranndf '*' '*-resamp' reset
*        This transforms all the NDFs in the current directory from
*        the coordinates represented by the PIXEL-domain frame
*        to the coordinates represented by the Current frame in their
*        WCS components.  It uses nearest-neighbour resampling and
*        conserves the flux levels. The output NDFs are of a size such
*        that all the input pixels have contributed.
*     tranndf curved straight linint shape=same
*        As above, except linear interpolation is used, and the straight
*        array uses the bounds of curved.
*     tranndf 'a119*' '*s' inext=false transform=proj.merc shape=bounds
*             lbound='[1,-20]' ubound='[256,172]'
*        This transforms the images called a119*, using the transformation
*        structure merc in the HDS file called proj, into images called 
*        a119*s.  It uses nearest-neighbour resampling.  All the output
*        images have size 256 x 192 pixels and origin (1,-20).

*  Implementation Status:
*     - Flux conservation can only be applied to constant-determinant
*       or linear transformations. Since we currently can't tell 
*       whether AST Mappings are linear, flux conservation should be
*       turned off when using the NDFs WCS component to perform the
*       mapping. If left on the program will warn the user that it
*       may not be performing flux conservation correctly (N.B. if
*       the WCS transform is linear however, flux conservation will
*       be calculated correctly).
*     - The NDF components are processed by this application as
*       follows:
*        -  AXES, LABEL, UNITS, HISTORY, and extensions are merely
*           propagated.
*        -  QUALITY is not derived from the input NDF for a linearly
*           interpolated NDF. The DATA and VARIANCE arrays are
*           resampled.
*        -  If USEWCS is .TRUE. then the NDF WCS extension is updated
*           and propagated.
*     -  Bad pixels, including automatic quality masking, are supported.
*     -  All non-complex numeric data types are supported.
*     -  There can be an arbitrary number of NDF dimensions.

*  Implementation Deficiencies:
*     -  AXIS information is not used.

*  Behaviour of parameters:
*     Most parameters retain their current value as default. The
*     "current" value is the value assigned on the last run of the
*     application. If the application has not been run then the
*     "intrinsic" defaults, as shown in the parameter help, apply.
*     The exceptions to this rule are:
*        - LBOUND  -- always uses a dynamic default
*        - UBOUND  -- always uses a dynamic default
*        - TITLE   -- always "Output from TRANNDF"
*
*     Retaining parameter values has the advantage of allowing you to
*     define the default behaviour of the application but does mean
*     that additional care needs to be taken when using the application
*     after a break of sometime. The intrinsic default behaviour of
*     the application may be restored by using the RESET keyword on
*     the command line.
*
*     Certain parameters (LOGTO and LOGFILE) have global values. These
*     global values will always take precedence, except when an
*     assignment is made on the command line.  Global values may be set
*     and reset using the CCDSETUP and CCDCLEAR commands.

*  Authors:
*     MJC: Malcolm J. Currie (STARLINK)
*     PDRAPER: Peter Draper (STARLINK)
*     AALLAN: Alasdair Allan (STARLINK)
*     MBT: Mark Taylor (STARLINK)
*     {enter_new_authors_here}

*  History:
*     1993 March 16 (MJC):
*        Original version.
*     18-JUN-1993 (PDRAPER):
*        Changed for use in CCDPACK pipe-line - Lists of NDFs,
*        information logging etc. Restricted functionality to that which
*        is used by CCDPACK (no axes information).
*     19-JUL-1995 (PDRAPER):
*        Removed AIF_ calls.
*     6-SEP-1995 (PDRAPER):
*        Updated for CCDPACK version 2.0.
*     25-JUN-1998 (PDRAPER):
*        Stopped quality bad flag from being set (isn't possible).
*     11-MAR-1999 (AALLAN):
*        Added USEWCS parameter (.TRUE. for AST, .FALSE. for TRN).
*        Converted TRANNDF to use AST FrameSets rather than TRN structures.
*     14-APR-1999 (AALLAN):
*        Ongoing tweaks to conversion.
*     03-MAY-1999 (AALLAN):
*        Turned off flux conservation (NORM = .FALSE.) for AST FrameSets.
*        Now deals only in the current frame, warns in AST__CURRENT != CCD_REG.
*        Other minor changes.
*     17-MAY-1999 (AALLAN):
*        Final tweaks for shipping.
*     20-MAY-1999 (MBT):
*        Mucked about a bit.
*     07-SEP-1999 (AALLAN):
*        Renamed some KPG1_* routines and propogated changes
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}

*-

*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants
      INCLUDE 'DAT_PAR'          ! HDS constants
      INCLUDE 'MSG_PAR'          ! MSG constants
      INCLUDE 'NDF_PAR'          ! NDF constants
      INCLUDE 'PRM_PAR'          ! PRIMDAT public constants
      INCLUDE 'TRN_PAR'          ! TRANSFORM constants
      INCLUDE 'CCD1_PAR'         ! CCDPACK parameters
      INCLUDE 'AST_PAR'          ! AST parameters

*  Status:
      INTEGER STATUS             ! Global status

*  Local Constants:
      INTEGER NACOMP             ! Number NDF array components
      PARAMETER ( NACOMP = 3 )

*  External references:
      EXTERNAL VAL_DTOI
      INTEGER VAL_DTOI           ! DBLE to nearest INTEGER with
                                 ! exception checking

*  Local Variables:
      BYTE VARB                  ! Dummy input variance
      BYTE VARBO                 ! Dummy output variance
      CHARACTER * ( 8 ) COMP( NACOMP ) ! NDF array component names
      CHARACTER * ( 7 ) METHOD   ! Resampling method
      CHARACTER * ( 7 ) SHAPE    ! How output NDF shape is determined
      CHARACTER * ( DAT__SZLOC ) LOCEXT ! Locator to NDF extension
      CHARACTER * ( DAT__SZLOC ) LOCTR ! Locator to the transformation
      CHARACTER * ( DAT__SZTYP ) DTYPE ! NDF output array type
      CHARACTER * ( DAT__SZTYP ) ITYPE ! NDF array implementation type
      CHARACTER * ( 50 ) TEXT       ! Temporary string for message output
      DOUBLE PRECISION AEND( NDF__MXDIM ) ! End co-ord of each axis
      DOUBLE PRECISION ASTART( NDF__MXDIM ) ! Start co-ord of each axis
      DOUBLE PRECISION COIN( 0:NDF__MXDIM, NDF__MXDIM ) ! Input coord for determinant finding
      DOUBLE PRECISION COOUT( 0:NDF__MXDIM, NDF__MXDIM ) ! Output coord for determinant finding
      DOUBLE PRECISION DDLBND( NDF__MXDIM ) ! Data coord lower bnds of out NDF
      DOUBLE PRECISION DDUBND( NDF__MXDIM ) ! Data coord upper bnds of out NDF
      DOUBLE PRECISION DDXL( NDF__MXDIM ) ! Co-ord of input pnt gives lower bnd
      DOUBLE PRECISION DDXU( NDF__MXDIM ) ! Co-ord of input pnt gives upper bnd
      DOUBLE PRECISION FLUX      ! Flux conservation factor
      DOUBLE PRECISION JACOB( NDF__MXDIM, NDF__MXDIM ) ! Jacobian matrix
      DOUBLE PRECISION VARD      ! Dummy input variance
      DOUBLE PRECISION WORK2( NDF__MXDIM ) ! Workspace for determinant
      INTEGER * 2 VARW           ! Dummy input variance
      INTEGER ADIMS( NDF__MXDIM ) ! Number of elements in axis to be pasted
      INTEGER AEL( NDF__MXDIM )  ! Axis-array dimensions
      INTEGER AXOFFS( NDF__MXDIM ) ! Offset in concatenated axis vector
      INTEGER AXPNTR( NDF__MXDIM ) ! Pointers to the axis centre arrays
      INTEGER BMAX( NDF__MXDIM ) ! Maximum upper bounds of output NDF
      INTEGER CADIMS( NDF__MXDIM ) ! Number of elements in concatenated- axis vector
      INTEGER CAXPTR             ! Pointer to the concatenated axes
      INTEGER CFRAME            ! Index value of the current AST Frame
      INTEGER DLBND( NDF__MXDIM ) ! Default bounds of the output NDF
      INTEGER DUBND( NDF__MXDIM ) ! Default bounds of the output NDF
      INTEGER EL                 ! Number of elements in higher dims
      INTEGER ELIN               ! Number of elements in input array
      INTEGER ELOUT              ! Number of elements in output array
      INTEGER FRCUR              ! Pointer to the Current AST Frame
      INTEGER FRNEW             ! Pointer to the New AST Frame
      INTEGER FRM                ! AST pointer to frame under consideration
      INTEGER GIDIN              ! Input NDF group identifier
      INTEGER GIDOUT             ! Output NDF group identifier
      INTEGER I, J, K            ! Loop counters
      INTEGER IAXIS              ! Loop counter through the axes
      INTEGER ICOMP              ! Loop counter through array components
      INTEGER IDIMS( NDF__MXDIM ) ! Dimensions of the input NDF
      INTEGER IDIN               ! NDF identifier of input NDF
      INTEGER IDOUT              ! NDF identifier of output NDF
      INTEGER ILBND( NDF__MXDIM ) ! Lower bounds of the input NDF
      INTEGER INDEX              ! Main loop counter
      INTEGER INDID              ! Workspace identifier
      INTEGER INPNTR             ! Pointer to nearest-neighbour list
      INTEGER IPNTR( 2 )         ! Pointers to the input arrays
      INTEGER IUBND( NDF__MXDIM ) ! Upper bounds of the input NDF
      INTEGER IWCS               ! Pointer to the WCS extension of the input NDF
      INTEGER JREG              ! Index of the CCD_REG frame in the input NDF
      INTEGER JPIX              ! Index of the PIXEL frame in the output NDF
      INTEGER MAP                ! Mapping to use
      INTEGER NBAD               ! Number of bad elements in output array
      INTEGER NDIMI              ! Number of dimensions in input NDF
      INTEGER NFRM               ! Number of frames in frameset
      INTEGER NNDF               ! Number of NDFs to process
      INTEGER NVIN               ! Number of input variables in the transformation
      INTEGER NVOUT              ! Number of output variables in the transformation
      INTEGER OWCS              ! Pointer to the WCS extension of the output NDF
      INTEGER ODIMS( NDF__MXDIM ) ! Dimensions of the output NDF
      INTEGER OLBND( NDF__MXDIM ) ! Lower bounds of the output NDF
      INTEGER OPNTR( 2 )         ! Pointers to the output arrays
      INTEGER OPNTRW             ! Pointer to the output array or workspace for flux conservation
      INTEGER OUBND( NDF__MXDIM ) ! Upper bounds of the output NDF
      INTEGER PFRAME               ! Index of the PIXEL frame
      INTEGER SHADEF( NDF__MXDIM ) ! Suggested default output NDF shape upper bound
      INTEGER TRIDF              ! Identifier to the forward input transformation
      INTEGER TRIDI              ! Identifier to the inverse input transformation
      INTEGER UMAP               ! Identifier for AST unit map
      INTEGER VARI               ! Dummy input variance
      INTEGER WDIMS( 2 )         ! Workspace dimensions
      INTEGER WKID4              ! Workspace identifier
      INTEGER WORK1( NDF__MXDIM ) ! Workspace for determinant finding
      INTEGER WPNTR1             ! Pointer to coordinate workspace
      INTEGER WPNTR2             ! Pointer to indices workspace
      INTEGER WPNTR3             ! Pointer to coordinate workspace
      LOGICAL BAD                ! If true, test for bad values
      LOGICAL CLASS( TRN__MXCLS ) ! Transformation classifications
      LOGICAL CONSRV             ! If true, the flux will be altered
      LOGICAL INEXT              ! Locate transform structure in NDF extensions
      LOGICAL NORM               ! Conserve flux if true
      LOGICAL SWCS               ! If true, then a WCS component is present in the NDF
      LOGICAL THERE              ! If true, the array component is present in the NDF
      LOGICAL USEWCS               ! If true then we use AST FrameSet rather than TRN structure
      LOGICAL VAR                ! Variance array is present in NDF
      REAL VARR                  ! Dummy input variance

      CHARACTER * ( 20 ) TEMP    

*  Delcare Functions
      
*  Local Data:
      DATA COMP / 'Data', 'Variance', 'Quality' /


*  Check the inherited global status.
      IF ( STATUS .NE. SAI__OK ) RETURN

*  Startup up the CCDPACK logging system.
      CALL CCD1_START( 'TRANNDF', STATUS )

*  Get the qualifications to the transformation.
*  =============================================

*  Get the method for calculating the output array value from the
*  input values.
      CALL PAR_CHOIC( 'METHOD', 'NEAREST', 'NEAREST,LININT', .FALSE.,
     :                METHOD, STATUS )

*  Are the output values to be normalised by the output-to-input pixel
*  areas, i.e. flux conservation; or just take the values from the
*  input NDF?
      CALL PAR_GET0L( 'CONSERVE', NORM, STATUS )

*  Obtain NDFs.
*  ============
*
*  Start a new NDF context.
      CALL NDF_BEGIN
      
*  Start a new AST context
      CALL AST_BEGIN( STATUS )

*  Get the IRG group identifier for the NDFs.
      CALL CCD1_NDFGR( 'IN', 'READ', GIDIN, NNDF, STATUS )

*  And get the names of the corresponding output NDFs.
      CALL CCD1_NDFPG( 'OUT', GIDIN, NNDF, GIDOUT, STATUS )
      IF ( STATUS .NE. SAI__OK ) GO TO 960

*  Get control parameters.
*  =======================

*  Are we using AST FrameSets or TRN structures?
      CALL PAR_GET0L( 'USEWCS', USEWCS, STATUS )
      
*  If using AST FrameSets then we can't tell whether we have linear
*  or non-linear mappings, turn flux conservation OFF
      IF ( USEWCS .AND. NORM) THEN
         CALL CCD1_MSG( ' ', ' ', STATUS)
         CALL CCD1_MSG( ' ',
     : '  WARNING - Flux conservation is turned on but'/
     :/' we are using AST FrameSets ', STATUS )
         CALL CCD1_MSG( ' ',
     : '            to transform the co-ordinates. If the'/
     :/' transform is non-linear', STATUS )
         CALL CCD1_MSG( ' ',
     : '            then the flux levels will be incorrect.',STATUS)    
         CALL CCD1_MSG( ' ', ' ', STATUS )
      ENDIF      

      IF( .NOT. USEWCS ) THEN
        
*  The user wants to read data with the old TRN structures.

*  Does the user want transformation structures to be located in the NDF
*  extensions or do they want to supply a single structure to transform
*  all the NDFs.
         CALL PAR_GET0L( 'INEXT', INEXT, STATUS )

*  If we're not using the extension we need a transformation structure.
         IF ( .NOT. INEXT ) THEN

*  User supplies a single locator to a transformation structure.
            CALL DAT_ASSOC( 'TRANSFORM', 'READ', LOCTR, STATUS )
            
         END IF

      ENDIF

*  See if the user is happy with auto-sizing of the output bounds or
*  whether they want to specify some (just one chance at this --
*  delayed until more knowledge of the NDFs is available), or are the
*  NDF bounds to remain the same?
      CALL PAR_CHOIC( 'SHAPE', 'AUTO', 'AUTO,SAME,SPECIFY', .FALSE.,
     :                SHAPE, STATUS )

*  Report progress so far.
      CALL CCD1_MSG( ' ', '    Input parameters:', STATUS )
      CALL CCD1_MSG( ' ', '    -----------------', STATUS )

*  Resampling method.
      IF ( METHOD .EQ. 'LININT' ) THEN
         CALL CCD1_MSG( ' ',
     : '  Data resampling method: Linear interpolation', STATUS )
      ELSE
         CALL CCD1_MSG( ' ',
     : '  Data resampling method: Nearest neighbour', STATUS )
      END IF

*  If flux levels are conserved.
      IF ( NORM ) THEN
         IF ( USEWCS ) THEN
            CALL CCD1_MSG( ' ', '  Attempting to conserve flux levels', 
     :                     STATUS )
         ELSE
            CALL CCD1_MSG( ' ', '  Total flux levels conserved', 
     :                     STATUS )
         ENDIF
      ELSE
         CALL CCD1_MSG( ' ', '  Total flux levels not conserved',
     :                  STATUS )
      END IF

*  Are we using AST FrameSets or TRN structures?
      IF( USEWCS ) THEN
         CALL CCD1_MSG( ' ',
     :'  Using AST FrameSet in NDF extensions', STATUS )
     
      ELSE
     
*  Are we using a TRN structure from the NDFs or user?
         IF ( INEXT ) THEN
            CALL CCD1_MSG( ' ',
     :'  Using transform structures in NDF CCDPACK extensions', STATUS )
         ELSE
            CALL CCD1_MSG( ' ',
     :'  Using transform structure $STRUCT', STATUS )
         END IF
        
      ENDIF

*  Are we using auto-sizing or will the user get to specify a single
*  extent for all NDFs?
      IF ( SHAPE .EQ. 'AUTO' ) THEN
         CALL CCD1_MSG( ' ', '  Auto-sizing output NDF bounds', STATUS )
      ELSE IF ( SHAPE .EQ. 'SAME' ) THEN
         CALL CCD1_MSG( ' ',
     :'  Output NDFs will have same bounds as related input NDFs',
     :                  STATUS )
      ELSE
         CALL CCD1_MSG( ' ',
     :'  Output NDFs will have user specified bounds ', STATUS )
      END IF
      IF ( STATUS .NE. SAI__OK ) GO TO 960

*=======================================================================
*  Main loop. Access each NDF in turn and process.
*=======================================================================
      DO 99999 INDEX = 1, NNDF

*  Get the identifier of the input NDF.
         CALL IRG_NDFEX( GIDIN, INDEX, IDIN, STATUS )

*  Write out name of this NDF. And which loop this is.
         CALL CCD1_MSG( ' ',  ' ', STATUS )
         CALL NDF_MSG( 'CURRENT_NDF', IDIN )
         CALL CCD1_MSG( ' ', '  +++ Processing NDF: ^CURRENT_NDF',
     :                  STATUS )
         CALL MSG_SETI( 'CURRENT_NUM', INDEX )
         CALL MSG_SETI( 'MAX_NUM', NNDF )
         CALL CCD1_MSG( ' ', '  (Number ^CURRENT_NUM of ^MAX_NUM)',
     :                  STATUS )
         CALL CCD1_MSG( ' ',  ' ', STATUS )

*  Decide whether we're using AST or TRN structres
         IF ( USEWCS ) THEN
                              
*  Get the transformation associated with this NDF. This should be
*  stored in the WCS extention of the NDF.

*  First check that there is an existing WCS FrameSet
            CALL NDF_STATE( IDIN, 'WCS', SWCS, STATUS )
            IF( .NOT. SWCS ) THEN
               STATUS = SAI__ERROR
               CALL NDF_MSG( 'NDFNAME', IDIN )
               CALL ERR_REP( 'TRANNDF_NOAST', '  NDF ^NDFNAME '//
     :'does not have a WCS extension (try setting USEWCS to .FALSE.).',
     :                       STATUS ) 
               GO TO 940
            ENDIF  
            
*  It appears we have a WCS component, get a pointer to the current FrameSet
            CALL CCD1_GTWCS( IDIN, IWCS, STATUS )
            MAP = AST_GETMAPPING( IWCS, 2, AST__CURRENT, STATUS )
            MAP = AST_SIMPLIFY( MAP, STATUS )
            FRCUR = AST_GETFRAME( IWCS, AST__CURRENT, STATUS )

*  Get the index of the current frame for future use 
            CFRAME = AST_GETI( IWCS, 'Current', STATUS )
                                     
         ELSE

*  The user wishes to use TRANSFORM structures.
            IF ( INEXT ) THEN
            
*  Get the transformation associated with this NDF. This should be
*  stored in the CCDPACK extension item TRANSFORM.

*  First get a CCDPACK extension.
               CALL CCD1_CEXT( IDIN, .FALSE., 'READ', LOCEXT, STATUS )

*  Now Look for a transformation structure.
               IF ( STATUS .EQ. SAI__OK ) THEN
                 CALL DAT_THERE( LOCEXT, 'TRANSFORM', THERE, STATUS )

*  If have one get a locator to it.
                 IF ( THERE ) THEN
                    CALL DAT_FIND( LOCEXT, 'TRANSFORM', LOCTR, STATUS )
                 
                 ELSE

*  Failed to find component TRANSFORM.
                    STATUS = SAI__ERROR
                    CALL NDF_MSG( 'NDFNAME', IDIN )
                    CALL ERR_REP( 'TRANNDF_NOEXT', '  NDF ^NDFNAME '//
     :'does not have a TRANSFORM component in its CCDPACK extension',
     :                          STATUS )
                     GO TO 940
                 END IF
               ELSE

*  No extension structure. Set status and abort.
                   STATUS = SAI__ERROR
                 CALL NDF_MSG( 'NDFNAME', IDIN )
                 CALL ERR_REP( 'TRANNDF_NOEXT',
     : '  NDF ^NDFNAME does not have a CCDPACK extension', STATUS )
                 GO TO 940
               END IF
            END IF
            
         END IF
         
                  
*  We need to validate the transformations
         IF( USEWCS ) THEN
         
*  We are using AST FrameSets
*  ==========================

*  Most AST transformations are linear, if flux conservation is turned
*  on the the user will have been warned that we're using WCS transforms
*  and the code may not be able to conserve flux correctly. 

*  Validate the transformation
           IF ( IWCS .EQ. AST__NULL ) THEN
               STATUS = SAI__ERROR
               CALL NDF_MSG( 'NDFNAME', IDIN )
               CALL ERR_REP( 'TRANNDF_NOAST', '  NDF ^NDFNAME '//
     :'does not have a valid WCS extension.',STATUS ) 
               GO TO 940 
           ELSE IF (AST_GETC( IWCS,'Class',STATUS) .NE. 'FrameSet') THEN
               STATUS = SAI__ERROR
               CALL NDF_MSG( 'NDFNAME', IDIN )
               CALL ERR_REP( 'TRANNDF_FRAME', '  NDF ^NDFNAME '//
     :'does not have a WCS extention with class FrameSet.',STATUS)
               GO TO 940             
           ELSE 
                              
*  Make sure the user has actually run REGISTER, if not warn them
               CALL CCD1_FRDM( IWCS, 'CCD_REG', JREG, STATUS )
              
               IF( JREG .EQ. 0 ) THEN
               
*  There is no CCD_REG Frame, warn the user (bad things may happen!)
                    CALL CCD1_MSG( ' ',
     :'  WARNING - NDF does not have an AST CCD_REG Frame, '//
     :'attempting alignment',STATUS)
                    CALL CCD1_MSG( ' ',
     :'            This image has not been processed by the '//
     :'CCDPACK REGISTER program',STATUS)
                    CALL CCD1_MSG( ' ',' ',STATUS)
               ENDIF

*  Tell the user which co-ordinate domain we'll be transforming too
               CALL MSG_SETC('CURRENT', 
     :                       AST_GETC( FRCUR, 'Domain', STATUS ) )
               CALL CCD1_MSG(' ','  The current AST Frame has '//
     :'domain ^CURRENT', STATUS )               
           ENDIF

*  Obtain the number of input and output co-ordinates for a Mapping
           NVIN = AST_GETI( MAP, 'Nin', STATUS )
           NVOUT = AST_GETI( MAP, 'Nout', STATUS )    
                               
         ELSE
         
*  We are using TRN structres
*  ==========================
           
*  Now validate the transformation.  Need forward and backward
*  transformations.
            IF ( INEXT .OR. INDEX .EQ. 1 ) THEN
                CALL TRN_COMP( LOCTR, .TRUE., TRIDF, STATUS )
                CALL TRN_COMP( LOCTR, .FALSE., TRIDI, STATUS )

*  Obtain the number of variables in the transformation.
                CALL TRN_GTNV( LOCTR, NVIN, NVOUT, STATUS )
                IF ( STATUS .NE. SAI__OK ) GO TO 940

*  Inquire the classification of the transformation.
*  =================================================
*
*  Certain efficiencies gains can be made for certain types of
*  transformation, mostly notably a linear transformation, where the
*  flux conservation factor is a constant.
                CALL TRN_GTCL( LOCTR, .TRUE., CLASS, STATUS )

*  Test if the transformation can be processed.
                IF ( .NOT. CLASS( TRN__LIN   ) .AND.
     :               .NOT. CLASS( TRN__CONDT ) .AND. NORM ) THEN
                    STATUS = SAI__ERROR
                    CALL ERR_REP( 'TRANNDF_ERR',
     :     'TRANNDF: The transformation is non-linear, '/
     :     /'or does not have a constant determinant, and cannot be '/
     :     /'handled with flux conservation by this routine', STATUS )
                    GO TO 940
                END IF
            END IF
            
          ENDIF   
         
*  Get the properties of the NDF.
*  ==============================
*  Dimensions.
         CALL NDF_DIM( IDIN, NDF__MXDIM, IDIMS, NDIMI, STATUS )

*  Bounds.
         CALL NDF_BOUND( IDIN, NDF__MXDIM, ILBND, IUBND, NDIMI, STATUS )
                     
         IF ( STATUS .NE. SAI__OK ) GO TO 940

*  Validate dimensions and number of input coordinates.
*  =====================================================
*
*  Check that processing is possible.  The number of dimensions in the
*  NDF must be at least the number of input variables for the
*  transformation to be applied.
         IF ( NVIN .GT. NDIMI .AND. STATUS .EQ. SAI__OK ) THEN
            STATUS = SAI__ERROR
            CALL NDF_MSG( 'NDF', IDIN )
            CALL MSG_SETI( 'NVIN', NVIN )
            CALL MSG_SETI( 'NDIMI', NDIMI )
            CALL ERR_REP( 'TRANNDF_MISMATCH',
     :     'TRANNDF: There is a mismatch between the transformation '/
     :     /'which expects ^NVIN variables, and the '/
     :     /'NDF ^NDF, which has only ^NDIMI dimensions.', STATUS )
            GO TO 940
         END IF

*  Define the input coordinate system.
*  ====================================

*  Generate a pseudo axis array to satisfy later calls (which will keep
*  this application as simiar as possible to the KAPPA version).
         DO IAXIS = 1, NVIN

*  Get workspace for the axes.
            AEL( IAXIS ) = IUBND( IAXIS ) - ILBND( IAXIS ) + 1
            CALL CCD1_MALL( AEL( IAXIS ), '_DOUBLE', AXPNTR( IAXIS ),
     :                      STATUS )
            CALL CCG1_AXIND( ILBND( IAXIS ), IUBND( IAXIS ),
     :                       %VAL( AXPNTR( IAXIS ) ), STATUS )
         END DO

*  Find the coordinate bounds of the output NDF.
*  ==============================================

*  The transformed coordinates will not, in general, be in pixel
*  coordinates, so we shall need to derive and then join a
*  transformation that converts between the output coordinates and
*  pixel coordinates.  The first stage is to estimate the bounds.
*  Axis end-points are pixel coordinates.
         DO IAXIS = 1, NVIN
            ASTART( IAXIS ) = DBLE( ILBND( IAXIS ) )
            AEND( IAXIS ) = DBLE( IUBND( IAXIS ) )
         END DO
         IF ( USEWCS ) THEN

*  We're using AST framesets.
            DO IAXIS = 1, NVIN
               CALL AST_MAPBOX( MAP, ASTART, AEND, .TRUE., IAXIS,
     :                          DDLBND(IAXIS), DDUBND(IAXIS), DDXL, 
     :                          DDXU, STATUS )
            END DO                   
         ELSE
         
*  We're using old fashioned TRN structures
            CALL KPG1_TRBOD( NVIN, ASTART, AEND, TRIDF, NVOUT, DDLBND,
     :                       DDUBND, STATUS )
            IF ( STATUS .NE. SAI__OK ) GO TO 940
         ENDIF

*  Set the bounds of the output NDF.
*  =================================

*  Find the dimensions and bounds of the output array. There are three
*  options for these values. If autosize has been chosen then dynamic
*  bounds will be created which ensure that all the output data is
*  present. If same is specified then the output NDFs will have the
*  same bounds as the input NDFs, otherwise the user will be prompted
*  once for bounds which will apply to all output NDFs.
         IF ( SHAPE .EQ. 'SPECIFY' ) THEN
           IF ( INDEX .EQ. 1 ) THEN

*  User specified bounds - just this once. Report the current extents
*  of the pixel coordinates as an aid to the user.
               DO IAXIS = 1, NVOUT
                  CALL MSG_SETI( 'AXIS', IAXIS )
                  CALL MSG_SETD( 'LOW', DDLBND( IAXIS ) )
                  CALL MSG_SETD( 'HIGH', DDUBND( IAXIS ) )
                  IF ( IAXIS .EQ. 1 ) THEN
                        CALL CCD1_MSG( 'OUTBOUNDS',
     :           '  coordinates limits for axis ^AXIS: ^LOW to ^HIGH',
     :                                 STATUS )
                  ELSE
                     CALL CCD1_MSG( 'OUTBOUNDS',
     :           '                               ^AXIS: ^LOW to ^HIGH',
     :                                          STATUS )
                  END IF

*  Set the defaults for the output NDF extent.
                  DLBND( IAXIS ) = VAL_DTOI( .FALSE.,
     :                             DDLBND( IAXIS ) - 0.5D0, STATUS )
                  DUBND( IAXIS ) = VAL_DTOI( .FALSE., DDUBND( IAXIS ),
     :                             STATUS )
               END DO

*  Now get the values.
               CALL PAR_DEF1I( 'LBOUND', NVOUT, DLBND, STATUS )
               CALL PAR_GDR1I( 'LBOUND', NVOUT, DLBND, -VAL__MAXI,
     :                         VAL__MAXI, .FALSE., OLBND, STATUS )
               DO I = 1, NVOUT
                  SHADEF( I ) = MAX( OLBND( I ), DUBND( I ) )
                  BMAX( I ) = VAL__MAXI
               END DO
               CALL PAR_DEF1I( 'UBOUND', NVOUT, DUBND, STATUS )
               CALL PAR_GRM1I( 'UBOUND', NVOUT, SHADEF, OLBND, BMAX,
     :                         .FALSE., OUBND, STATUS )
            END IF
         ELSE IF ( SHAPE .EQ. 'SAME') THEN

*  Output NDF bounds those of the input NDFs.
            DO IAXIS = 1, NVOUT
               OLBND( IAXIS ) = ILBND( IAXIS )
               OUBND( IAXIS ) = IUBND( IAXIS )
            END DO
         ELSE

*  Autosize the output NDF.
            DO IAXIS = 1, NVOUT
               OLBND( IAXIS ) = VAL_DTOI( .FALSE.,
     :                          DDLBND( IAXIS ) - 0.5D0, STATUS )
               OUBND( IAXIS ) = VAL_DTOI( .FALSE., DDUBND( IAXIS ),
     :                          STATUS )
            END DO
         END IF

*  Derive the output NDF's dimensions.
         DO IAXIS = 1, NVOUT
            ODIMS( IAXIS ) = OUBND( IAXIS ) - OLBND( IAXIS ) + 1
         END DO
         IF ( STATUS .NE. SAI__OK ) GO TO 940

*  Create a concatenated input axis array.
*  =======================================
*
*  The subroutines that perform the resampling need the axis arrays
*  to convert coordinates into pixel indices in the input array.
*  For convenience the axis centres are passed in a single vector
*  and required values are found using offsets equal to the sum of
*  the lower axis dimensions.
*
*  Find the length of the concatenated axes.
         CADIMS( 1 ) = 0
         DO IAXIS = 1, NVIN
           CADIMS( 1 ) = CADIMS( 1 ) + AEL( IAXIS )
         END DO

*  Create some workspace for the concatenated array.
         CALL CCD1_MALL( CADIMS( 1 ), '_DOUBLE', CAXPTR, STATUS )

*  Pasting routine needs filled dimension arrays of NDF__MXDIM values.
         DO IAXIS = 2, NDF__MXDIM
            ADIMS( IAXIS ) = 1
            CADIMS( IAXIS ) = 1
            AXOFFS( IAXIS ) = 0
         END DO

         AXOFFS( 1 ) = 0
         DO IAXIS = 1, NVIN

*  Assign the axis dimension.
            ADIMS( 1 ) = AEL( IAXIS )

*  Paste each axis into the work array.
            CALL KPG1_PASTD( .FALSE., .TRUE., AXOFFS, ADIMS, ADIMS( 1 ),
     :                       %VAL( AXPNTR( IAXIS ) ), CADIMS,
     :                       CADIMS( 1 ), %VAL( CAXPTR ), STATUS )

*  Increment the offsets for the next axis.
            AXOFFS( 1 ) = AXOFFS( 1 ) + AEL( IAXIS )
         END DO

         IF ( STATUS .NE. SAI__OK ) GO TO 940

*  Tidy the axis centres.
*  ======================
         DO IAXIS = 1, NVIN
            CALL CCD1_MFREE( AXPNTR( IAXIS ), STATUS )
         END DO

*  Create the output NDF.
*  ======================
         CALL IRG_NDFPR( GIDOUT, INDEX, IDIN, 'Axis,Units', IDOUT,
     :                   STATUS )

*  Tell user the name of the output NDF.
         CALL NDF_MSG( 'OUTNDF', IDOUT )
         CALL CCD1_MSG( ' ', '  Output NDF: ^OUTNDF', STATUS )

*  Report the extent of the input NDF, useful if using shape=auto to compare
*  with the ouptut NDF shape and see if something stupid is happening. 
         DO IAXIS = 1, NVIN
            CALL MSG_SETI( 'LOW', ILBND( IAXIS ) )
            CALL MSG_SETI( 'HIGH', IUBND( IAXIS ) )
            IF ( IAXIS .EQ. 1 ) THEN
               CALL CCD1_MSG( 'INBOUNDS',
     :'  Input NDF bounds : ^LOW to ^HIGH', STATUS )
            ELSE 
               CALL CCD1_MSG( 'INBOUNDS',
     :'                   : ^LOW to ^HIGH', STATUS )      
            END IF
         END DO

*  And report the actual extent of the output NDF (before creating
*  an NDF of this actual extent - useful if shape=auto and funny
*  transformation is being used).
         DO IAXIS = 1, NVOUT
            CALL MSG_SETI( 'AXIS', IAXIS )
            CALL MSG_SETI( 'LOW', OLBND( IAXIS ) )
            CALL MSG_SETI( 'HIGH', OUBND( IAXIS ) )
            IF ( IAXIS .EQ. 1 ) THEN
                  CALL CCD1_MSG( 'OUTBOUNDS',
     :'  Output NDF bounds : ^LOW to ^HIGH', STATUS )
            ELSE
               CALL CCD1_MSG( 'OUTBOUNDS',
     :'                    : ^LOW to ^HIGH', STATUS )
            END IF
         END DO

*  Change its shape to the required output shape.
         CALL NDF_SBND( NDIMI, OLBND, OUBND, IDOUT, STATUS )
         IF ( STATUS .NE. SAI__OK ) GO TO 940


*  Find the flux-conservation factor.
*  ==================================

*  Find a constant determinant by transforming unit vectors along each
*  dimension.
         IF ( NORM .AND. NVIN .EQ. NVOUT .AND.
     :      ( CLASS(TRN__LIN) .OR. CLASS(TRN__CONDT) .OR. USEWCS)) THEN

*  First set the input coordinates to all zero.
            DO IAXIS = 1, NVIN
               DO I = 0, NVIN
                  COIN( I, IAXIS ) = 0.0D0
               END DO
            END DO

*  Revise the diagonal terms to one.
            DO I = 1, NVIN
               COIN( I, I ) = 1.0D0
            END DO
            EL = NVIN * NVIN + 1

*  Apply the transformation.
            IF( USEWCS ) THEN
              CALL AST_TRANN( MAP, EL, NVIN, NDF__MXDIM + 1, COIN,
     :                        .TRUE., NVOUT, NDF__MXDIM + 1, COOUT, 
     :                        STATUS )
            ELSE
              CALL TRN_TRND( .FALSE., NDF__MXDIM + 1, NVIN, EL, COIN,
     :                  TRIDF, NDF__MXDIM + 1, NVOUT, COOUT, STATUS )
            ENDIF

*  Assign the Jacobian matrix.
            DO IAXIS = 1, NVIN
               DO I = 1, NVIN
                  JACOB( I, IAXIS ) = COOUT( I, IAXIS ) -
     :                                COOUT( 0, IAXIS )
               END DO
            END DO

*  The flux term is the inverse of the absolute determinant of the
*  Jacobian.
            CALL KPG1_MDETD( NVIN, NDF__MXDIM, JACOB, WORK1, WORK2,
     :                       FLUX, STATUS )
            IF ( FLUX .GT. VAL__SMLD ) THEN
               FLUX = ABS( 1.0D0 / FLUX )
            ELSE
               FLUX = 1.0D0
            END IF
         ELSE

*  No flux conservation.
            FLUX = 1.0D0
            CALL CCD1_MSG( ' ', '  Flux is not conserved', STATUS )
         END IF

*  See if there is any conservation of flux required.
         CONSRV = ABS( FLUX - 1.0D0 ) .GT. VAL__EPSD
         IF ( STATUS .NE. SAI__OK ) GO TO 940
         

*  Resample using the nearest-neighbour technique.
*  ===============================================
         IF ( METHOD .EQ. 'NEAREST' ) THEN

*  This method is applicable to the data, variance and quality arrays.
*  First determine the vector indices of the nearest neighbours applying
*  the transformation.  To do this we need some work space for the
*  input and output coordinates, and input fractional indices.
            WDIMS( 1 ) = ODIMS( 1 )
            WDIMS( 2 ) = NDIMI
            CALL CCD1_MALL( WDIMS( 1 ) * WDIMS( 2 ), '_DOUBLE', WPNTR1,
     :                      STATUS )
            CALL CCD1_MALL( WDIMS( 1 ) * WDIMS( 2 ), '_DOUBLE', WPNTR2,
     :                      STATUS )
            WDIMS( 2 ) = NDIMI
            CALL CCD1_MALL( WDIMS( 1 ) * WDIMS( 2 ), '_DOUBLE', WPNTR3,
     :                      STATUS )

*  Get workspace to hold the indices of the nearest neighbours. There
*  is one for each output array element.
            EL = 1
            DO I = 1, NVOUT
               EL = EL * ODIMS( I )
            END DO
            CALL CCD1_MKTMP( EL, '_INTEGER', INDID, STATUS )
            CALL CCD1_MPTMP( INDID, 'WRITE', INPNTR, STATUS )

*  Generate the list of vector indices for the resampling.
            IF( USEWCS ) THEN
                CALL CCG1_ASPID( NDIMI, IDIMS, MAP, %VAL( CAXPTR ),
     :                           WDIMS( 1 ), NVOUT, OLBND, ODIMS,
     :                           %VAL( WPNTR1 ), %VAL( WPNTR3 ),
     :                           %VAL( WPNTR2 ), %VAL( INPNTR ), 
     :                           STATUS )            
            ELSE
                CALL KPG1_TRPID( NDIMI, IDIMS, TRIDI, %VAL( CAXPTR ),
     :                        WDIMS( 1 ), NVOUT, OLBND, ODIMS,
     :                        %VAL( WPNTR1 ), %VAL( WPNTR3 ),
     :                        %VAL( WPNTR2 ), %VAL( INPNTR ), STATUS )
            ENDIF
*  Free the workspace that is no longer needed.
            CALL CCD1_MFREE( WPNTR1, STATUS )
            CALL CCD1_MFREE( WPNTR2, STATUS )
            CALL CCD1_MFREE( WPNTR3, STATUS )

*  Apply the transformation with n-n resampling.
*  =============================================
*  Loop through all the components.
            DO ICOMP = 1, NACOMP

*  See if the component is present.
               IF ( COMP( ICOMP ) .NE. 'Data' ) THEN
                  CALL NDF_STATE( IDIN, COMP( ICOMP ), THERE, STATUS )
               ELSE
                  THERE = .TRUE.
               END IF

*  Can only process when the array component is present.
               IF ( THERE ) THEN

*  Get the type of the array.
                  CALL NDF_TYPE( IDIN, COMP( ICOMP ), ITYPE, STATUS )

*  Map the input and output arrays.
                  CALL NDF_MAP( IDIN, COMP( ICOMP ), ITYPE, 'READ',
     :                          IPNTR, ELIN, STATUS )
                  CALL NDF_MAP( IDOUT, COMP( ICOMP ), ITYPE,
     :                          'WRITE/BAD', OPNTR, ELOUT, STATUS )

*  When there is flux conservation there is a two-stage process, so
*  workspace is needed to hold the uncorrected values.  Use the same
*  pointer for both cases to save code.  Flux conservation is not
*  required for the QUALITY array.
                  IF ( CONSRV .AND. COMP( ICOMP ) .NE. 'Quality' ) THEN
                     CALL CCD1_MKTMP( ELOUT, ITYPE, WKID4, STATUS )
                     CALL CCD1_MPTMP( WKID4, 'WRITE', OPNTRW, STATUS )
                  ELSE
                     OPNTRW = OPNTR( 1 )
                  END IF

*  Perform the transformation on the data array for the numeric data
*  type.  First for a byte array
                  IF ( ITYPE .EQ. '_BYTE' ) THEN
                     CALL KPG1_VASVB( ELOUT, %VAL( INPNTR ), ELIN,
     :                                %VAL( IPNTR( 1 ) ),
     :                                %VAL( OPNTRW ), NBAD, STATUS )

*  Transform a double-precision array.
                  ELSE IF ( ITYPE .EQ. '_DOUBLE' ) THEN
                     CALL KPG1_VASVD( ELOUT, %VAL( INPNTR ), ELIN,
     :                                %VAL( IPNTR( 1 ) ),
     :                                %VAL( OPNTRW ), NBAD, STATUS )

*  Transform an integer array.
                  ELSE IF ( ITYPE .EQ. '_INTEGER' ) THEN
                     CALL KPG1_VASVI( ELOUT, %VAL( INPNTR ), ELIN,
     :                                %VAL( IPNTR( 1 ) ),
     :                                %VAL( OPNTRW ), NBAD, STATUS )

*  Transform a single-precision array.
                  ELSE IF ( ITYPE .EQ. '_REAL' ) THEN
                     CALL KPG1_VASVR( ELOUT, %VAL( INPNTR ), ELIN,
     :                                %VAL( IPNTR( 1 ) ),
     :                                %VAL( OPNTRW ), NBAD, STATUS )

*  Transform an unsigned-byte array.
                  ELSE IF ( ITYPE .EQ. '_UBYTE' ) THEN
                     CALL KPG1_VASVUB( ELOUT, %VAL( INPNTR ), ELIN,
     :                                 %VAL( IPNTR( 1 ) ),
     :                                 %VAL( OPNTRW ), NBAD, STATUS )

*  Transform an unsigned-word array.
                  ELSE IF ( ITYPE .EQ. '_UWORD' ) THEN
                     CALL KPG1_VASVUW( ELOUT, %VAL( INPNTR ), ELIN,
     :                                 %VAL( IPNTR( 1 ) ),
     :                                 %VAL( OPNTRW ), NBAD, STATUS )

*  Transform a word array.
                  ELSE IF ( ITYPE .EQ. '_WORD' ) THEN
                     CALL KPG1_VASVW( ELOUT, %VAL( INPNTR ), ELIN,
     :                                %VAL( IPNTR( 1 ) ),
     :                                %VAL( OPNTRW ), NBAD, STATUS )
                  END IF

*  If there is no flux conservation we only need to unmap the output
*  array.
                  IF ( CONSRV .AND. COMP( ICOMP ) .NE. 'Quality' ) THEN

*  Decide whether or not we need to test for bad pixels.
                     BAD = NBAD .NE. 0

*  Select the appropriate routine for the data type being processed and
*  multiply the data array by the constant.
                     CALL CCD1_CMUL( BAD, ITYPE, OPNTRW, EL, FLUX,
     :                               OPNTR( 1 ), STATUS )

*  Tidy the workspace.
                     CALL CCD1_FRTMP( WKID4, STATUS )
                  END IF

*  Set the bad pixel flag when bad pixels have been found.
                  IF ( BAD .AND. COMP( ICOMP ) .NE. 'Quality' ) THEN
                     CALL NDF_SBAD( .TRUE., IDOUT, COMP( ICOMP ),
     :                              STATUS )
                  END IF

*  Unmap the output array.
                  CALL NDF_UNMAP( IDOUT, COMP( ICOMP ), STATUS )

*  Unmap the input NDF array.
                  CALL NDF_UNMAP( IDIN, COMP( ICOMP ), STATUS )
               END IF
            END DO

*  Free the workspace holding the resampled vector indices.
            CALL CCD1_FRTMP( INDID, STATUS )

*  Apply linear-interpolation resampling.
*  ======================================
         ELSE IF ( METHOD .EQ. 'LININT' ) THEN

*  Get work arrays for the transformation. Needed is space for the input
*  and output coordinates, and input fractional indices.
            WDIMS( 1 ) = ODIMS( 1 )
            WDIMS( 2 ) = NDIMI
            CALL CCD1_MALL( WDIMS( 1 ) * WDIMS( 2 ), '_DOUBLE', WPNTR1,
     :                      STATUS )
            CALL CCD1_MALL( WDIMS( 1 ) * WDIMS( 2 ), '_DOUBLE', WPNTR2,
     :                      STATUS )
            WDIMS( 2 ) = NDIMI
            CALL CCD1_MALL( WDIMS( 1 ) * WDIMS( 2 ), '_DOUBLE', WPNTR3,
     :                      STATUS )

*  See if the variance component is present.  Note that a quality array
*  cannot be linearly interpolated.
            CALL NDF_STATE( IDIN, 'Variance', VAR, STATUS )
            IF ( VAR ) THEN

*  Get the implementation type of the arrays.
               CALL NDF_MTYPE( '_BYTE,_UBYTE,_WORD,_UWORD,_INTEGER,'/
     :                         /'_REAL,_DOUBLE', IDIN, IDIN,
     :                         'Data,Variance', ITYPE, DTYPE, STATUS )

*  Map the input and output arrays.
               CALL NDF_MAP( IDIN, 'Data,Variance', ITYPE, 'READ',
     :                       IPNTR, ELIN, STATUS )
               CALL NDF_MAP( IDOUT, 'Data,Variance', ITYPE, 'WRITE/BAD',
     :                       OPNTR, ELOUT, STATUS )

*  Perform the transformation on the data array for the numeric data
*  type.  First apply to a byte array.
               IF ( ITYPE .EQ. '_BYTE' ) THEN
                  IF( USEWCS ) THEN 
                    CALL CCG1_ASLIB( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                             VAR, %VAL( IPNTR( 2 ) ), MAP,
     :                             FLUX, %VAL( CAXPTR ), ODIMS( 1 ),
     :                             NDIMI, OLBND, ODIMS,
     :                             %VAL( OPNTR( 1 ) ),
     :                             %VAL( OPNTR( 2 ) ),
     :                             %VAL( WPNTR1 ), %VAL( WPNTR3 ),
     :                             %VAL( WPNTR2 ), STATUS )
                  ELSE
                    CALL KPG1_TDLIB( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                             VAR, %VAL( IPNTR( 2 ) ), TRIDI,
     :                             FLUX, %VAL( CAXPTR ), ODIMS( 1 ),
     :                             NDIMI, OLBND, ODIMS,
     :                             %VAL( OPNTR( 1 ) ),
     :                             %VAL( OPNTR( 2 ) ),
     :                             %VAL( WPNTR1 ), %VAL( WPNTR3 ),
     :                             %VAL( WPNTR2 ), STATUS )
                  ENDIF
*  Transform a double-precision array.
               ELSE IF ( ITYPE .EQ. '_DOUBLE' ) THEN
                  IF( USEWCS ) THEN 
                    CALL CCG1_ASLID( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                             VAR, %VAL( IPNTR( 2 ) ), MAP,
     :                             FLUX, %VAL( CAXPTR ), ODIMS( 1 ),
     :                             NDIMI, OLBND, ODIMS,
     :                             %VAL( OPNTR( 1 ) ),
     :                             %VAL( OPNTR( 2 ) ),
     :                             %VAL( WPNTR1 ), %VAL( WPNTR3 ),
     :                             %VAL( WPNTR2 ), STATUS )
                  ELSE
                    CALL KPG1_TDLID( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                             VAR, %VAL( IPNTR( 2 ) ), TRIDI,
     :                             FLUX, %VAL( CAXPTR ), ODIMS( 1 ),
     :                             NDIMI, OLBND, ODIMS,
     :                             %VAL( OPNTR( 1 ) ),
     :                             %VAL( OPNTR( 2 ) ),
     :                             %VAL( WPNTR1 ), %VAL( WPNTR3 ),
     :                             %VAL( WPNTR2 ), STATUS )
                  ENDIF
*  Transform an integer array.
               ELSE IF ( ITYPE .EQ. '_INTEGER' ) THEN
                  IF ( USEWCS ) THEN
                    CALL CCG1_ASLII( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                             VAR, %VAL( IPNTR( 2 ) ), MAP,
     :                             FLUX, %VAL( CAXPTR ), ODIMS( 1 ),
     :                             NDIMI, OLBND, ODIMS,
     :                             %VAL( OPNTR( 1 ) ),
     :                             %VAL( OPNTR( 2 ) ),
     :                             %VAL( WPNTR1 ), %VAL( WPNTR3 ),
     :                             %VAL( WPNTR2 ), STATUS )
                 ELSE
                    CALL KPG1_TDLII( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                             VAR, %VAL( IPNTR( 2 ) ), TRIDI,
     :                             FLUX, %VAL( CAXPTR ), ODIMS( 1 ),
     :                             NDIMI, OLBND, ODIMS,
     :                             %VAL( OPNTR( 1 ) ),
     :                             %VAL( OPNTR( 2 ) ),
     :                             %VAL( WPNTR1 ), %VAL( WPNTR3 ),
     :                             %VAL( WPNTR2 ), STATUS )
                 ENDIF
*  Transform a single-precision array.
               ELSE IF ( ITYPE .EQ. '_REAL' ) THEN
                  IF (USEWCS) THEN
                    CALL CCG1_ASLIR( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                             VAR, %VAL( IPNTR( 2 ) ), MAP,
     :                             FLUX, %VAL( CAXPTR ), ODIMS( 1 ),
     :                             NDIMI, OLBND, ODIMS,
     :                             %VAL( OPNTR( 1 ) ),
     :                             %VAL( OPNTR( 2 ) ),
     :                             %VAL( WPNTR1 ), %VAL( WPNTR3 ),
     :                             %VAL( WPNTR2 ), STATUS )
                  ELSE
                    CALL KPG1_TDLIR( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                             VAR, %VAL( IPNTR( 2 ) ), TRIDI,
     :                             FLUX, %VAL( CAXPTR ), ODIMS( 1 ),
     :                             NDIMI, OLBND, ODIMS,
     :                             %VAL( OPNTR( 1 ) ),
     :                             %VAL( OPNTR( 2 ) ),
     :                             %VAL( WPNTR1 ), %VAL( WPNTR3 ),
     :                             %VAL( WPNTR2 ), STATUS )
                  ENDIF
*  Transform an unsigned-byte array.
               ELSE IF ( ITYPE .EQ. '_UBYTE' ) THEN
                  IF (USEWCS ) THEN
                    CALL CCG1_ASLIUB( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                              VAR, %VAL( IPNTR( 2 ) ), MAP,
     :                              FLUX, %VAL( CAXPTR ), ODIMS( 1 ),
     :                              NDIMI, OLBND, ODIMS,
     :                              %VAL( OPNTR( 1 ) ),
     :                              %VAL( OPNTR( 2 ) ),
     :                              %VAL( WPNTR1 ), %VAL( WPNTR3 ),
     :                              %VAL( WPNTR2 ), STATUS )
                  ELSE
                    CALL KPG1_TDLIUB( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                              VAR, %VAL( IPNTR( 2 ) ), TRIDI,
     :                              FLUX, %VAL( CAXPTR ), ODIMS( 1 ),
     :                              NDIMI, OLBND, ODIMS,
     :                              %VAL( OPNTR( 1 ) ),
     :                              %VAL( OPNTR( 2 ) ),
     :                              %VAL( WPNTR1 ), %VAL( WPNTR3 ),
     :                              %VAL( WPNTR2 ), STATUS )
                  ENDIF
*  Transform an unsigned-word array.
               ELSE IF ( ITYPE .EQ. '_UWORD' ) THEN
                  IF (USEWCS) THEN
                    CALL CCG1_ASLIUW( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                              VAR, %VAL( IPNTR( 2 ) ), MAP,
     :                              FLUX, %VAL( CAXPTR ), ODIMS( 1 ),
     :                              NDIMI, OLBND, ODIMS,
     :                              %VAL( OPNTR( 1 ) ),
     :                              %VAL( OPNTR( 2 ) ),
     :                              %VAL( WPNTR1 ), %VAL( WPNTR3 ),
     :                              %VAL( WPNTR2 ), STATUS )
                  ELSE
                    CALL KPG1_TDLIUW( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                              VAR, %VAL( IPNTR( 2 ) ), TRIDI,
     :                              FLUX, %VAL( CAXPTR ), ODIMS( 1 ),
     :                              NDIMI, OLBND, ODIMS,
     :                              %VAL( OPNTR( 1 ) ),
     :                              %VAL( OPNTR( 2 ) ),
     :                              %VAL( WPNTR1 ), %VAL( WPNTR3 ),
     :                              %VAL( WPNTR2 ), STATUS )
                  ENDIF
*  Transform a word array.
               ELSE IF ( ITYPE .EQ. '_WORD' ) THEN
                  IF(USEWCS) THEN
                    CALL CCG1_ASLIW( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                             VAR, %VAL( IPNTR( 2 ) ), MAP,
     :                             FLUX, %VAL( CAXPTR ), ODIMS( 1 ),
     :                             NDIMI, OLBND, ODIMS,
     :                             %VAL( OPNTR( 1 ) ),
     :                             %VAL( OPNTR( 2 ) ),
     :                             %VAL( WPNTR1 ), %VAL( WPNTR3 ),
     :                             %VAL( WPNTR2 ), STATUS )
                  ELSE
                    CALL KPG1_TDLIW( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                             VAR, %VAL( IPNTR( 2 ) ), TRIDI,
     :                             FLUX, %VAL( CAXPTR ), ODIMS( 1 ),
     :                             NDIMI, OLBND, ODIMS,
     :                             %VAL( OPNTR( 1 ) ),
     :                             %VAL( OPNTR( 2 ) ),
     :                             %VAL( WPNTR1 ), %VAL( WPNTR3 ),
     :                             %VAL( WPNTR2 ), STATUS )
                  ENDIF
               END IF
            ELSE

*  Get the type of the data array.
               CALL NDF_TYPE( IDIN, 'Data', ITYPE, STATUS )

*  Map the input and output arrays.  Use a dummy variance value.  It is
*  not assigned as it will not be used.
               CALL NDF_MAP( IDIN, 'Data', ITYPE, 'READ', IPNTR, ELIN,
     :                       STATUS )
               CALL NDF_MAP( IDOUT, 'Data', ITYPE, 'WRITE/BAD', OPNTR,
     :                       ELOUT, STATUS )

*  Perform the transformation on the data array for the numeric data
*  type.  First apply to a byte array.
               IF ( ITYPE .EQ. '_BYTE' ) THEN
                  IF (USEWCS) THEN
                    CALL CCG1_ASLIB( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                             VAR, VARB, MAP, FLUX,
     :                             %VAL( CAXPTR ), ODIMS( 1 ), NDIMI,
     :                             OLBND, ODIMS, %VAL( OPNTR( 1 ) ),
     :                             VARBO, %VAL( WPNTR1 ),
     :                             %VAL( WPNTR3 ), %VAL( WPNTR2 ),
     :                             STATUS )    
                  ELSE           
                    CALL KPG1_TDLIB( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                             VAR, VARB, TRIDI, FLUX,
     :                             %VAL( CAXPTR ), ODIMS( 1 ), NDIMI,
     :                             OLBND, ODIMS, %VAL( OPNTR( 1 ) ),
     :                             VARBO, %VAL( WPNTR1 ),
     :                             %VAL( WPNTR3 ), %VAL( WPNTR2 ),
     :                             STATUS )
                  ENDIF

*  Transform a double-precision array.
               ELSE IF ( ITYPE .EQ. '_DOUBLE' ) THEN
                  IF (USEWCS) THEN
                    CALL CCG1_ASLID( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                             VAR, VARD, MAP, FLUX,
     :                             %VAL( CAXPTR ), ODIMS( 1 ), NDIMI,
     :                             OLBND, ODIMS, %VAL( OPNTR( 1 ) ),
     :                             VARBO, %VAL( WPNTR1 ),
     :                             %VAL( WPNTR3 ), %VAL( WPNTR2 ),
     :                             STATUS )
                  ELSE           
                    CALL KPG1_TDLID( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                             VAR, VARD, TRIDI, FLUX,
     :                             %VAL( CAXPTR ), ODIMS( 1 ), NDIMI,
     :                             OLBND, ODIMS, %VAL( OPNTR( 1 ) ),
     :                             VARBO, %VAL( WPNTR1 ),
     :                             %VAL( WPNTR3 ), %VAL( WPNTR2 ),
     :                             STATUS )
                  ENDIF
     
*  Transform an integer array.
               ELSE IF ( ITYPE .EQ. '_INTEGER' ) THEN
                  IF (USEWCS) THEN
                    CALL CCG1_ASLII( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                             VAR, VARI, MAP, FLUX,
     :                             %VAL( CAXPTR ), ODIMS( 1 ), NDIMI,
     :                             OLBND, ODIMS, %VAL( OPNTR( 1 ) ),
     :                             VARBO, %VAL( WPNTR1 ),
     :                             %VAL( WPNTR3 ), %VAL( WPNTR2 ),
     :                             STATUS )
                  ELSE           
                    CALL KPG1_TDLII( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                             VAR, VARI, TRIDI, FLUX,
     :                             %VAL( CAXPTR ), ODIMS( 1 ), NDIMI,
     :                             OLBND, ODIMS, %VAL( OPNTR( 1 ) ),
     :                             VARBO, %VAL( WPNTR1 ),
     :                             %VAL( WPNTR3 ), %VAL( WPNTR2 ),
     :                             STATUS )
                  ENDIF

*  Transform a single-precision array.
               ELSE IF ( ITYPE .EQ. '_REAL' ) THEN
                  IF (USEWCS) THEN
                    CALL CCG1_ASLIR( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                             VAR, VARR, MAP, FLUX,
     :                             %VAL( CAXPTR ), ODIMS( 1 ), NDIMI,
     :                             OLBND, ODIMS, %VAL( OPNTR( 1 ) ),
     :                             VARBO, %VAL( WPNTR1 ),
     :                             %VAL( WPNTR3 ), %VAL( WPNTR2 ),
     :                             STATUS )
                  ELSE           
                    CALL KPG1_TDLIR( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                             VAR, VARR, TRIDI, FLUX,
     :                             %VAL( CAXPTR ), ODIMS( 1 ), NDIMI,
     :                             OLBND, ODIMS, %VAL( OPNTR( 1 ) ),
     :                             VARBO, %VAL( WPNTR1 ),
     :                             %VAL( WPNTR3 ), %VAL( WPNTR2 ),
     :                             STATUS )
                  ENDIF

*  Transform an unsigned-byte array.
               ELSE IF ( ITYPE .EQ. '_UBYTE' ) THEN
                  IF (USEWCS) THEN
                    CALL CCG1_ASLIUB( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                              VAR, VARB, MAP, FLUX,
     :                              %VAL( CAXPTR ), ODIMS( 1 ),
     :                              NDIMI, OLBND, ODIMS,
     :                              %VAL( OPNTR( 1 ) ), VARBO,
     :                              %VAL( WPNTR1 ), %VAL( WPNTR3 ),
     :                              %VAL( WPNTR2 ), STATUS )
                  ELSE           
                    CALL KPG1_TDLIUB( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                              VAR, VARB, TRIDI, FLUX,
     :                              %VAL( CAXPTR ), ODIMS( 1 ),
     :                              NDIMI, OLBND, ODIMS,
     :                              %VAL( OPNTR( 1 ) ), VARBO,
     :                              %VAL( WPNTR1 ), %VAL( WPNTR3 ),
     :                              %VAL( WPNTR2 ), STATUS )
                  ENDIF
                  
*  Transform an unsigned-word array.
               ELSE IF ( ITYPE .EQ. '_UWORD' ) THEN
                  IF (USEWCS) THEN
                    CALL CCG1_ASLIUW( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                              VAR, VARW, MAP, FLUX,
     :                              %VAL( CAXPTR ), ODIMS( 1 ),
     :                              NDIMI, OLBND, ODIMS,
     :                              %VAL( OPNTR( 1 ) ), VARBO,
     :                              %VAL( WPNTR1 ), %VAL( WPNTR3 ),
     :                              %VAL( WPNTR2 ), STATUS )
                  ELSE           
                    CALL KPG1_TDLIUW( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                              VAR, VARW, TRIDI, FLUX,
     :                              %VAL( CAXPTR ), ODIMS( 1 ),
     :                              NDIMI, OLBND, ODIMS,
     :                              %VAL( OPNTR( 1 ) ), VARBO,
     :                              %VAL( WPNTR1 ), %VAL( WPNTR3 ),
     :                              %VAL( WPNTR2 ), STATUS )
                  ENDIF
                  
*  Transform a word array.
               ELSE IF ( ITYPE .EQ. '_WORD' ) THEN
                  IF (USEWCS) THEN
                    CALL CCG1_ASLIW( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                             VAR, VARW, MAP, FLUX,
     :                             %VAL( CAXPTR ), ODIMS( 1 ), NDIMI,
     :                             OLBND, ODIMS, %VAL( OPNTR( 1 ) ),
     :                             VARBO, %VAL( WPNTR1 ),
     :                             %VAL( WPNTR3 ), %VAL( WPNTR2 ),
     :                             STATUS )
                  ELSE           
                    CALL KPG1_TDLIW( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                             VAR, VARW, TRIDI, FLUX,
     :                             %VAL( CAXPTR ), ODIMS( 1 ), NDIMI,
     :                             OLBND, ODIMS, %VAL( OPNTR( 1 ) ),
     :                             VARBO, %VAL( WPNTR1 ),
     :                             %VAL( WPNTR3 ), %VAL( WPNTR2 ),
     :                             STATUS )
                  ENDIF
               END IF

*  Free the workspace that is no longer needed.
               CALL CCD1_MFREE( WPNTR1, STATUS )
               CALL CCD1_MFREE( WPNTR2, STATUS )
               CALL CCD1_MFREE( WPNTR3, STATUS )
            END IF
         END IF

*  Add a title to the new NDF.
         CALL NDF_CINP( 'TITLE', IDOUT, 'TITLE', STATUS )

*  Propogate the WCS component
         IF (USEWCS) THEN

*  A reminder of the various pointers and indices we have to play with
*       CFRAME  Index of the alignment frame
*       JREG    Index of CCD_REG frame
*       JPIX    Index of PIXEL frame
*       FRCUR   Pointer to alignment frame
*       IWCS    Pointer to input AST FrameSet
*       OWCS    Pointer to output AST FrameSet

*  Get default WCS component (just GRID, PIXEL, AXIS) for the output NDF.
            CALL CCD1_GTWCS( IDOUT, OWCS, STATUS )
            CALL AST_SETI( IWCS, 'Current', CFRAME, STATUS )
    
*  Remove GRID, PIXEL, AXIS frames from original frameset since they're
*  out of date now.  This just leaves the non-automatic frames of the 
*  input WCS component.
            CALL CCD1_DMPRG( IWCS, 'PIXEL', .FALSE., 0, STATUS )
            CALL CCD1_DMPRG( IWCS, 'AXIS', .FALSE., 0, STATUS )
            CALL CCD1_DMPRG( IWCS, 'GRID', .FALSE., 0, STATUS )
    
*  Lets find out which frame contains the PIXEL domain (its going to be
*  frame 2, but we may as well do it properly) in the output WCS frameset.
            NFRM = AST_GETI( OWCS, 'Nframe', STATUS )
            DO K = 1, NFRM
               FRM = AST_GETFRAME( OWCS, K, STATUS )
               IF( AST_GETC( FRM, 'Domain', STATUS ) 
     :             .EQ. 'PIXEL' ) PFRAME = K
            END DO
                
*  And add the remaining bits of IWCS to OWCS
            CALL AST_ADDFRAME( OWCS, PFRAME, 
     :                         AST_UNITMAP( NDIMI, ' ', STATUS ),
     :                         IWCS, STATUS )
    
*  Write it out.
            CALL NDF_PTWCS( OWCS, IDOUT, STATUS )
            
         END IF

*  Release NDFs and close container files. Retain locator to transform
*  structure if INEXT is false.
         IF( USEWCS ) THEN
            CALL AST_ANNUL( IWCS, STATUS )
            CALL AST_ANNUL( FRCUR, STATUS )
            CALL AST_ANNUL( OWCS, STATUS )
            CALL AST_ANNUL( FRM, STATUS )
         ELSE IF( INEXT ) THEN
            CALL DAT_ANNUL( LOCEXT, STATUS )
            CALL DAT_ANNUL( LOCTR, STATUS )
            CALL TRN_ANNUL( TRIDF, STATUS )
            CALL TRN_ANNUL( TRIDI, STATUS )
         END IF
         CALL NDF_ANNUL( IDIN, STATUS )
         CALL NDF_ANNUL( IDOUT, STATUS )

*  Free concatenated axes workspace.
         CALL CCD1_MFREE( CAXPTR, STATUS )

*  Write terminator for Processing NDF: message.
         CALL CCD1_MSG( ' ', '  ---',STATUS )

*  End of main processing loop.

99999 CONTINUE

*  Tidy resources.
*  ===============

*  Free any workspace.
  940 CONTINUE
      CALL CCD1_MFREE( -1, STATUS )
      CALL CCD1_FRTMP( -1, STATUS )

  960 CONTINUE
      IF( USEWCS ) THEN 
*  Tidy up any remaining AST FrameSets
        CALL AST_END( STATUS )
      ELSE
*  Free any remaining transformation resources.
        CALL TRN_CLOSE( STATUS ) 
      ENDIF     
 
*  Tidy the NDF context.
      CALL NDF_END( STATUS )

*  Close down IRH/IRG.
      CALL IRH_CLOSE( STATUS )

  999 CONTINUE
*  If an error occurred, then report a contextual message.
      IF ( STATUS .NE. SAI__OK ) THEN
         IF( USEWCS ) THEN
            CALL ERR_REP( 'TRANNDF_ERR',
     :        'TRANNDF: Unable to transform the NDF '/
     :       /'using WCS extensions.', STATUS ) 
         ELSE        
            CALL ERR_REP( 'TRANNDF_ERR',
     :        'TRANNDF: Unable to transform the NDF '/
     :       /'using TRN structures.', STATUS )
         ENDIF
      END IF

*  Close the log file.
      CALL CCD1_END( STATUS )
      
      END
