      SUBROUTINE TRANNDF( STATUS )
*+
*  Name:
*     TRANNDF

*  Purpose:
*     Transforms a list of NDFs by resampling.

*  Language:
*     Starlink Fortran 77

*  Type of Module:
*     ADAM A-task

*  Invocation:
*     CALL TRANNDF( STATUS )

*  Arguments:
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Description:
*     This application performs the arbitrary transformation of a list
*     of NDFs using transform structures created by routines such as
*     REGISTER and CCDEDIT. The output NDFs are calculated by resampling
*     the data of the input NDFs. Output array elements are set to the
*     bad value if their inverse-transformed coordinates lie outside the
*     corresponding input NDF's coordinate limits.
*
*     NDFs processed within CCDPACK may be resampled using the
*     appropriate transformation structures located within the NDF's
*     extensions. Using these facilities allows many NDFs to be aligned
*     with one invocation.

*  Usage:
*     tranndf in out [method] 

*  ADAM Parameters:
*     CONSERVE = _LOGICAL (Read)
*        If CONSERVE is TRUE, the output values are normalised by the
*        ratio of the output-to-input pixel areas.  In other words this
*        conserves flux.  If CONSERVE is FALSE, there is no
*        normalisation.  [TRUE]
*     IN = NDF (Read)
*        A list of NDF names whose data are to be transformed. The NDF
*        names should be separated by commas and may include wildcards.
*     INEXT = _LOGICAL (Read)
*        If TRUE then the transformation which is to be applied to the
*        NDF is stored in the NDF's CCDPACK extension
*        (.MORE.CCDPACK.TRANSFORM). If FALSE then a transformation
*        structure must be supplied via the parameter TRANSFORM. This
*        transformation is then applied to the list of NDFs.  [TRUE]
*     LBOUND() = _INTEGER (Read)
*        If SHAPE is "SPECIFY" then this parameter specifies the lower
*        pixel-index bounds of all the output NDFs. The number of
*        values should equal the maximum number of dimensions of the
*        input NDFs. The suggested defaults are the lower bounds
*        generated by the SHAPE="AUTO" option for the first NDF. These
*        bounds are probably small enough to ensure that all the
*        transformed data (of the first NDF) will appear in the output
*        NDF.
*        [Dynamic default]
*     LOGFILE = FILENAME (Read)
*        Name of the CCDPACK logfile.  If a null (!) value is given for
*        this parameter then no logfile will be written, regardless of
*        the value of the LOGTO parameter.
*
*        If the logging system has been initialised using CCDSETUP
*        then the value specified there will be used. Otherwise, the
*        default is "CCDPACK.LOG".
*        [CCDPACK.LOG]
*     LOGTO = LITERAL (Read)
*        Every CCDPACK application has the ability to log its output
*        for future reference as well as for display on the terminal.
*        This parameter controls this process, and may be set to any
*        unique abbreviation of the following:
*           -  TERMINAL  -- Send output to the terminal only
*           -  LOGFILE   -- Send output to the logfile only (see the
*                           LOGFILE parameter)
*           -  BOTH      -- Send output to both the terminal and the
*                           logfile
*           -  NEITHER   -- Produce no output at all
*
*        If the logging system has been initialised using CCDSETUP
*        then the value specified there will be used. Otherwise, the
*        default is "BOTH".
*        [BOTH]
*     METHOD = LITERAL (Read)
*        The interpolation method used to resample the input NDF data
*        arrays. Permitted values are "NEAREST" for nearest-neighbour,
*        and "LININT" for linear interpolation.
*        [NEAREST]
*     OUT = LITERAL (Write)
*        Names of the output -- transformed -- NDFs. These may be 
*        specified as list of comma separated names, using indirection
*        if required, or, as a single modification element (of the 
*        input names). The simplest modification element is the
*        asterisk "*" which means call each of the output NDFs the same
*        name as the corresponding input NDFs. So,
*           IN > *
*           OUT > *
*        signifies that all the NDFs in the current directory should be
*        used and the output NDFs should have the same names. Other
*        types of modification can also be used, such as,
*           OUT > *-TRN
*        which means call the output NDFs the same as the input NDFs
*        but add -TRN to the end of the names. Replacement of a
*        specified string with another in the output file names can
*        also be used,
*           OUT > *|RAW|RES|
*        this replaces the string RAW with RES in any of the output
*        names.
*     SHAPE = LITERAL (Read)
*        The method to be used to determine the SHAPE of the output
*        NDFs. Can take one of the values "AUTO", "SAME", "SPECIFY".
*        With the meanings.
*
*           - AUTO    -- automatically determine the bounds of the 
*                        output NDFs such that all of the input data 
*                        appears. This is achieved by transforming test
*                        points along the current bounds so assumes 
*                        that the transformation will behave reasonably.
*           - SAME    -- set the output NDF bounds to those of the
*                        corresponding input NDFs.
*           - SPECIFY -- you will specify a single set of bounds for 
*                        all the output NDFs. (See the LBOUND and UBOUND
*                        parameters.)
*        [AUTO]  
*     TRANSFORM = TRN (Read)
*        If INEXT is FALSE then this parameter specifies the
*        transformation structure.  This includes the file name and the
*        HDS object.  For example, DISTORT.MAPPING would use the
*        TRANSFORM structure called MAPPING in the HDS file DISTORT.
*        Normally the object name is TRANSFORM.  The structure must
*        contain both the forward and inverse mappings. This transform
*        if supplied acts on all the input NDFs.
*     UBOUND() = _INTEGER (Read)
*        If SHAPE is "SPECIFY" then this parameter specifies the upper
*        pixel-index bounds of all the output NDFs. The number of
*        values should equal the maximum number of dimensions of the
*        input NDFs. The suggested defaults are the upper bounds
*        generated by the SHAPE="AUTO" option for the first NDF. These
*        bounds are probably large enough to ensure that all the
*        transformed data (of the first NDF) will appear in the output
*        NDF.
*        [Dynamic default]

*  Examples:
*     tranndf '*' '*-trn' reset
*        This transforms all the NDFs in the current directory if
*        they contain suitable transformation structures in their
*        extensions. It uses nearest-neighbour resampling and conserves
*        the flux levels. The output NDFs are of a size such that all
*        the input pixels have contributed.
*     tranndf curved straight linint shape=same
*        As above, except linear interpolation is used, and the straight
*        array uses the bounds of curved.
*     tranndf 'a119*' '*s' inext=false transform=proj.merc shape=bounds
*             lbound='[1,-20]' ubound='[256,172]'
*        This transforms the NDFs called a119*, using the transformation
*        merc in the HDS file called proj, into NDFs called a119*s.
*        It uses nearest-neighbour resampling.  All the output NDFs
*        have size 256 x 192 pixels and origin (1,-20).

*  Notes:
*     - This application is a restricted form of the KAPPA routine
*       TRANSFORMER. If additional functionality is required then
*       look at TRANSFORMER.

*  Implementation Status:
*     - Flux conservation can only be applied to constant-determinant
*       or linear transformations.
*     - The NDF components are processed by this application as
*       follows:
*        -  AXES, LABEL, UNITS, HISTORY, and extensions are merely
*           propagated.
*        -  QUALITY is not derived from the input NDF for a linearly
*           interpolated NDF. The DATA and VARIANCE arrays are 
*           resampled.
*     -  Bad pixels, including automatic quality masking, are supported.
*     -  All non-complex numeric data types are supported.
*     -  There can be an arbitrary number of NDF dimensions.

*  Implementation Deficiencies:
*     -  AXIS information is not used.

*  Behaviour of parameters:
*     Most parameters retain their current value as default. The
*     "current" value is the value assigned on the last run of the
*     application. If the application has not been run then the
*     "intrinsic" defaults, as shown in the parameter help, apply.
*     The exceptions to this rule are:
*        - LBOUND  -- always uses a dynamic default
*        - UBOUND  -- always uses a dynamic default
*        - TITLE   -- always "Output from TRANNDF"
*
*     Retaining parameter values has the advantage of allowing you to
*     define the default behaviour of the application but does mean
*     that additional care needs to be taken when using the application
*     after a break of sometime. The intrinsic default behaviour of 
*     the application may be restored by using the RESET keyword on 
*     the command line.
*
*     Certain parameters (LOGTO and LOGFILE) have global values. These
*     global values will always take precedence, except when an
*     assignment is made on the command line.  Global values may be set
*     and reset using the CCDSETUP and CCDCLEAR commands.

*  Authors:
*     MJC: Malcolm J. Currie (STARLINK)
*     PDRAPER: Peter Draper (STARLINK)
*     {enter_new_authors_here}

*  History:
*     1993 March 16 (MJC):
*        Original version.
*     18-JUN-1993 (PDRAPER):
*        Changed for use in CCDPACK pipe-line - Lists of NDFs,
*        information logging etc. Restricted functionality to that which
*        is used by CCDPACK (no axes information).
*     19-JUL-1995 (PDRAPER):
*        Removed AIF_ calls.
*     6-SEP-1995 (PDRAPER):
*        Updated for CCDPACK version 2.0.
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}

*-
      
*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants
      INCLUDE 'DAT_PAR'          ! HDS constants
      INCLUDE 'MSG_PAR'          ! MSG constants
      INCLUDE 'NDF_PAR'          ! NDF constants
      INCLUDE 'PRM_PAR'          ! PRIMDAT public constants
      INCLUDE 'TRN_PAR'          ! TRANSFORM constants
      INCLUDE 'CCD1_PAR'         ! CCDPACK parameters

*  Status:
      INTEGER STATUS             ! Global status

*  Local Constants:
      INTEGER NACOMP             ! Number NDF array components
      PARAMETER ( NACOMP = 3 )

*  External references:
      EXTERNAL VAL_DTOI
      INTEGER VAL_DTOI           ! DBLE to nearest INTEGER with
                                 ! exception checking

*  Local Variables:
      BYTE VARB                  ! Dummy input variance
      BYTE VARBO                 ! Dummy output variance
      CHARACTER * ( 5 ) COMP( NACOMP ) ! NDF array component names
      CHARACTER * ( 7 ) METHOD   ! Resampling method
      CHARACTER * ( 7 ) SHAPE    ! How output NDF shape is determined
      CHARACTER * ( DAT__SZLOC ) LOCEXT ! Locator to NDF extension
      CHARACTER * ( DAT__SZLOC ) LOCTR ! Locator to the transformation
      CHARACTER * ( DAT__SZTYP ) DTYPE ! NDF output array type
      CHARACTER * ( DAT__SZTYP ) ITYPE ! NDF array implementation type
      DOUBLE PRECISION AEND( NDF__MXDIM ) ! End co-ord of each axis
      DOUBLE PRECISION ASTART( NDF__MXDIM ) ! Start co-ord of each axis
      DOUBLE PRECISION COIN( 0:NDF__MXDIM, NDF__MXDIM ) ! Input coordinates for determinant finding
      DOUBLE PRECISION COOUT( 0:NDF__MXDIM, NDF__MXDIM ) ! Output coordinates for determinant finding
      DOUBLE PRECISION DDLBND( NDF__MXDIM ) ! Data coordinate lower bounds of output NDF
      DOUBLE PRECISION DDUBND( NDF__MXDIM ) ! Data coordinate upper bounds of output NDF
      DOUBLE PRECISION FLUX      ! Flux conservation factor
      DOUBLE PRECISION JACOB( NDF__MXDIM, NDF__MXDIM ) ! Jacobian matrix
      DOUBLE PRECISION VARD      ! Dummy input variance
      DOUBLE PRECISION WORK2( NDF__MXDIM ) ! Workspace for determinant
      INTEGER * 2 VARW           ! Dummy input variance
      INTEGER ADIMS( NDF__MXDIM ) ! Number of elements in axis to be pasted
      INTEGER AEL( NDF__MXDIM )  ! Axis-array dimensions
      INTEGER AXOFFS( NDF__MXDIM ) ! Offset in concatenated axis vector
      INTEGER AXPNTR( NDF__MXDIM ) ! Pointers to the axis centre arrays
      INTEGER BMAX( NDF__MXDIM ) ! Maximum upper bounds of output NDF
      INTEGER CADIMS( NDF__MXDIM ) ! Number of elements in concatenated- axis vector
      INTEGER CAXPTR             ! Pointer to the concatenated axes
      INTEGER DLBND( NDF__MXDIM ) ! Default bounds of the output NDF
      INTEGER DUBND( NDF__MXDIM ) ! Default bounds of the output NDF
      INTEGER EL                 ! Number of elements in higher dims
      INTEGER ELIN               ! Number of elements in input array
      INTEGER ELOUT              ! Number of elements in output array
      INTEGER GIDIN              ! Input NDF group identifier
      INTEGER GIDOUT             ! Output NDF group identifier
      INTEGER I                  ! Loop counter
      INTEGER IAXIS              ! Loop counter through the axes
      INTEGER ICOMP              ! Loop counter through array components
      INTEGER IDIMS( NDF__MXDIM ) ! Dimensions of the input NDF
      INTEGER IDIN               ! NDF identifier of input NDF
      INTEGER IDOUT              ! NDF identifier of output NDF
      INTEGER ILBND( NDF__MXDIM ) ! Lower bounds of the input NDF
      INTEGER INDEX              ! Main loop counter
      INTEGER INDID              ! Workspace identifier
      INTEGER INPNTR             ! Pointer to nearest-neighbour list
      INTEGER IPNTR( 2 )         ! Pointers to the input arrays
      INTEGER IUBND( NDF__MXDIM ) ! Upper bounds of the input NDF
      INTEGER NBAD               ! Number of bad elements in output array
      INTEGER NDIMI              ! Number of dimensions in input NDF
      INTEGER NNDF               ! Number of NDFs to process
      INTEGER NVIN               ! Number of input variables in the transformation
      INTEGER NVOUT              ! Number of output variables in the transformation
      INTEGER ODIMS( NDF__MXDIM ) ! Dimensions of the output NDF
      INTEGER OLBND( NDF__MXDIM ) ! Lower bounds of the output NDF
      INTEGER OPNTR( 2 )         ! Pointers to the output arrays
      INTEGER OPNTRW             ! Pointer to the output array or workspace for flux conservation
      INTEGER OUBND( NDF__MXDIM ) ! Upper bounds of the output NDF
      INTEGER SHADEF( NDF__MXDIM ) ! Suggested default output NDF shape upper bound
      INTEGER TRIDF              ! Identifier to the forward input transformation
      INTEGER TRIDI              ! Identifier to the inverse input transformation
      INTEGER VARI               ! Dummy input variance
      INTEGER WDIMS( 2 )         ! Workspace dimensions
      INTEGER WKID4              ! Workspace identifier
      INTEGER WORK1( NDF__MXDIM ) ! Workspace for determinant finding
      INTEGER WPNTR1             ! Pointer to coordinate workspace
      INTEGER WPNTR2             ! Pointer to indices workspace
      INTEGER WPNTR3             ! Pointer to coordinate workspace
      LOGICAL BAD                ! If true, test for bad values
      LOGICAL CLASS( TRN__MXCLS ) ! Transformation classifications
      LOGICAL CONSRV             ! If true, the flux will be altered
      LOGICAL INEXT              ! Locate transform structure in NDF extensions
      LOGICAL NORM               ! Conserve flux if true
      LOGICAL THERE              ! If true, the array component is present in the NDF
      LOGICAL VAR                ! Variance array is present in NDF
      REAL VARR                  ! Dummy input variance

*  Local Data:
      DATA COMP / 'Data', 'Variance', 'Quality' /


*  Check the inherited global status.
      IF ( STATUS .NE. SAI__OK ) RETURN

*  Startup up the CCDPACK logging system.
      CALL CCD1_START( 'TRANNDF', STATUS )

*  Get the qualifications to the transformation.
*  =============================================

*  Get the method for calculating the output array value from the
*  input values.
      CALL PAR_CHOIC( 'METHOD', 'NEAREST', 'NEAREST,LININT', .FALSE.,
     :                METHOD, STATUS )

*  Are the output values to be normalised by the output-to-input pixel
*  areas, i.e. flux conservation; or just take the values from the
*  input NDF?
      CALL PAR_GET0L( 'CONSERVE', NORM, STATUS )

*  Obtain NDFs.
*  ============
*
*  Start a new NDF context.
      CALL NDF_BEGIN

*  Get the IRG group identifier for the NDFs.
      CALL CCD1_NDFGR( 'IN', 'READ', GIDIN, NNDF, STATUS )

*  And get the names of the corresponding output NDFs.
      CALL CCD1_NDFPG( 'OUT', GIDIN, NNDF, GIDOUT, STATUS )
      IF ( STATUS .NE. SAI__OK ) GO TO 960

*  Get control parameters.
*  =======================

*  Does the user want transformation structures to be located in the NDF
*  extensions or do they want to supply a single structure to transform
*  all the NDFs.
      CALL PAR_GET0L( 'INEXT', INEXT, STATUS )

*  If we're not using the extension we need a transformation structure.
      IF ( .NOT. INEXT ) THEN

*  User supplies a single locator to a transformation structure.
         CALL DAT_ASSOC( 'TRANSFORM', 'READ', LOCTR, STATUS )
      END IF

*  See if the user is happy with auto-sizing of the output bounds or
*  whether they want to specify some (just one chance at this --
*  delayed until more knowledge of the NDFs is available), or are the
*  NDF bounds to remain the same?
      CALL PAR_CHOIC( 'SHAPE', 'AUTO', 'AUTO,SAME,SPECIFY', .FALSE.,
     :                SHAPE, STATUS )

*  Report progress so far.
      CALL CCD1_MSG( ' ', '    Input parameters:', STATUS )
      CALL CCD1_MSG( ' ', '    -----------------', STATUS )

*  Resampling method.
      IF ( METHOD .EQ. 'LININT' ) THEN 
         CALL CCD1_MSG( ' ',
     : '  Data resampling method: Linear interpolation', STATUS )
      ELSE
         CALL CCD1_MSG( ' ',
     : '  Data resampling method: Nearest neighbour', STATUS )
      END IF

*  If flux levels are conserved.
      IF ( NORM ) THEN 
         CALL CCD1_MSG( ' ', '  Total flux levels conserved', STATUS )
      ELSE
         CALL CCD1_MSG( ' ', '  Total flux levels not conserved',
     :                  STATUS )
      END IF

*  Are we using a structure from the NDFs or user?
      IF ( INEXT ) THEN 
         CALL CCD1_MSG( ' ',
     :'  Using transform structures in NDF CCDPACK extensions', STATUS )
      ELSE
         CALL CCD1_MSG( ' ',
     :'  Using transform structure $STRUCT', STATUS )
      END IF

*  Are we using auto-sizing or will the user get to specify a single
*  extent for all NDFs?
      IF ( SHAPE .EQ. 'AUTO' ) THEN
         CALL CCD1_MSG( ' ', '  Auto-sizing output NDF bounds', STATUS )
      ELSE IF ( SHAPE .EQ. 'SAME' ) THEN
         CALL CCD1_MSG( ' ',
     :'  Output NDFs will have same bounds as related input NDFs',
     :                  STATUS )
      ELSE
         CALL CCD1_MSG( ' ',
     :'  Output NDFs will have user specified bounds ', STATUS )
      END IF
      IF ( STATUS .NE. SAI__OK ) GO TO 960

*=======================================================================
*  Main loop. Access each NDF in turn and process.
*=======================================================================
      DO 99999 INDEX = 1, NNDF

*  Get the identifier of the input NDF.
         CALL IRG_NDFEX( GIDIN, INDEX, IDIN, STATUS )

*  Write out name of this NDF. And which loop this is.
         CALL CCD1_MSG( ' ',  ' ', STATUS )
         CALL NDF_MSG( 'CURRENT_NDF', IDIN )
         CALL CCD1_MSG( ' ', '  +++ Processing NDF: ^CURRENT_NDF',
     :                  STATUS )
         CALL MSG_SETI( 'CURRENT_NUM', INDEX )
         CALL MSG_SETI( 'MAX_NUM', NNDF )
         CALL CCD1_MSG( ' ', '  (Number ^CURRENT_NUM of ^MAX_NUM)',
     :                  STATUS )
         CALL CCD1_MSG( ' ',  ' ', STATUS )

         IF ( INEXT ) THEN 
*  Get the transformation associated with this NDF. This should be
*  stored in the CCDPACK extension item TRANSFORM.
*  First get a CCDPACK extension.
            CALL CCD1_CEXT( IDIN, .FALSE., 'READ', LOCEXT, STATUS )

*  Now Look for a transformation structure.
            IF ( STATUS .EQ. SAI__OK ) THEN 
               CALL DAT_THERE( LOCEXT, 'TRANSFORM', THERE, STATUS )

*  If have one get a locator to it.
               IF ( THERE ) THEN
                  CALL DAT_FIND( LOCEXT, 'TRANSFORM', LOCTR, STATUS )
               ELSE

*  Failed to find component TRANSFORM. 
                  STATUS = SAI__ERROR
                  CALL NDF_MSG( 'NDFNAME', IDIN )
                  CALL ERR_REP( 'TRANNDF_NOEXT', '  NDF ^NDFNAME '//
     :'does not have a TRANSFORM component in its CCDPACK extension',
     :                          STATUS )
                  GO TO 940
               END IF
            ELSE

*  No extension structure. Set status and abort.
               STATUS = SAI__ERROR
               CALL NDF_MSG( 'NDFNAME', IDIN )
               CALL ERR_REP( 'TRANNDF_NOEXT',
     : '  NDF ^NDFNAME does not have a CCDPACK extension', STATUS )
               GO TO 940
            END IF            
         END IF

*  Now validate the transformation.  Need forward and backward
*  transformations.
         IF ( INEXT .OR. INDEX .EQ. 1 ) THEN 
            CALL TRN_COMP( LOCTR, .TRUE., TRIDF, STATUS )
            CALL TRN_COMP( LOCTR, .FALSE., TRIDI, STATUS )

*  Obtain the number of variables in the transformation.
            CALL TRN_GTNV( LOCTR, NVIN, NVOUT, STATUS )
            IF ( STATUS .NE. SAI__OK ) GO TO 940

*  Inquire the classification of the transformation.
*  =================================================
*
*  Certain efficiencies gains can be made for certain types of
*  transformation, mostly notably a linear transformation, where the
*  flux conservation factor is a constant.
            CALL TRN_GTCL( LOCTR, .TRUE., CLASS, STATUS )

*  Test if the transformation can be processed.
            IF ( .NOT. CLASS( TRN__LIN   ) .AND.
     :           .NOT. CLASS( TRN__CONDT ) .AND. NORM ) THEN
               STATUS = SAI__ERROR
               CALL ERR_REP( 'TRANNDF_ERR',
     :     'TRANNDF: The transformation is non-linear, '/
     :     /'or does not have a constant determinant, and cannot be '/
     :     /'handled with flux conservation by this routine', STATUS )
               GO TO 940
            END IF
         END IF

*  Get the properties of the NDF.
*  ==============================
*  Dimensions.
         CALL NDF_DIM( IDIN, NDF__MXDIM, IDIMS, NDIMI, STATUS )

*  Bounds.
         CALL NDF_BOUND( IDIN, NDF__MXDIM, ILBND, IUBND, NDIMI, STATUS )
         IF ( STATUS .NE. SAI__OK ) GO TO 940

*  Validate dimensions and number of input coordinates.
*  =====================================================
*  
*  Check that processing is possible.  The number of dimensions in the
*  NDF must be at least the number of input variables for the
*  transformation to be applied.
         IF ( NVIN .GT. NDIMI .AND. STATUS .EQ. SAI__OK ) THEN
            STATUS = SAI__ERROR
            CALL NDF_MSG( 'NDF', IDIN )
            CALL MSG_SETI( 'NVIN', NVIN )
            CALL MSG_SETI( 'NDIMI', NDIMI )
            CALL ERR_REP( 'TRANNDF_MISMATCH',
     :     'TRANNDF: There is a mismatch between the transformation '/
     :     /'which expects ^NVIN variables, and the '/
     :     /'NDF ^NDF, which has only ^NDIMI dimensions.', STATUS )
            GO TO 940
         END IF

*  Define the input coordinate system.
*  ====================================

*  Generate a pseudo axis array to satisfy later calls (which will keep
*  this application as simiar as possible to the KAPPA version).
         DO IAXIS = 1, NVIN

*  Get workspace for the axes.
            AEL( IAXIS ) = IUBND( IAXIS ) - ILBND( IAXIS ) + 1
            CALL CCD1_MALL( AEL( IAXIS ), '_DOUBLE', AXPNTR( IAXIS ),
     :                      STATUS )
            CALL CCG1_AXIND( ILBND( IAXIS ), IUBND( IAXIS ),
     :                       %VAL( AXPNTR( IAXIS ) ), STATUS )
         END DO

*  Find the coordinate bounds of the output NDF.
*  ==============================================

*  The transformed coordinates will not, in general, be in pixel
*  coordinates, so we shall need to derive and then join a
*  transformation that converts between the output coordinates and
*  pixel coordinates.  The first stage is to estimate the bounds.
*  Axis end-points are pixel coordinates.
         DO IAXIS = 1, NVIN
            ASTART( IAXIS ) = DBLE( ILBND( IAXIS ) )
            AEND( IAXIS ) = DBLE( IUBND( IAXIS ) )
         END DO

*  Use test points at the extremes and midpoints of each axis to obtain
*  an estimate of the extent of the output NDF's coordinates.  This
*  assumes that the transformation does not move the innards of the
*  input array to the outside of the output array.
         CALL KPG1_TRBOD( NVIN, ASTART, AEND, TRIDF, NVOUT, DDLBND,
     :                    DDUBND, STATUS )
         IF ( STATUS .NE. SAI__OK ) GO TO 940
      
*  Set the bounds of the output NDF.
*  =================================
      
*  Find the dimensions and bounds of the output array. There are three
*  options for these values. If autosize has been chosen then dynamic
*  bounds will be created which ensure that all the output data is
*  present. If same is specified then the output NDFs will have the
*  same bounds as the input NDFs, otherwise the user will be prompted
*  once for bounds which will apply to all output NDFs.
         IF ( SHAPE .EQ. 'SPECIFY' ) THEN
           IF ( INDEX .EQ. 1 ) THEN 

*  User specified bounds - just this once. Report the current extents
*  of the pixel coordinates as an aid to the user.
               DO IAXIS = 1, NVOUT
                  CALL MSG_SETI( 'AXIS', IAXIS )                       
                  CALL MSG_SETD( 'LOW', DDLBND( IAXIS ) )
                  CALL MSG_SETD( 'HIGH', DDUBND( IAXIS ) )
                  IF ( IAXIS .EQ. 1 ) THEN
                        CALL CCD1_MSG( 'OUTBOUNDS',
     :           '  coordinates limits for axis ^AXIS: ^LOW to ^HIGH',
     :                                 STATUS )
                  ELSE              
                     CALL CCD1_MSG( 'OUTBOUNDS',
     :           '                               ^AXIS: ^LOW to ^HIGH',
     :                                          STATUS )
                  END IF
      
*  Set the defaults for the output NDF extent.
                  DLBND( IAXIS ) = VAL_DTOI( .FALSE.,
     :                             DDLBND( IAXIS ) - 0.5D0, STATUS )
                  DUBND( IAXIS ) = VAL_DTOI( .FALSE., DDUBND( IAXIS ),
     :                             STATUS )
               END DO

*  Now get the values.
               CALL PAR_DEF1I( 'LBOUND', NVOUT, DLBND, STATUS )
               CALL PAR_GDR1I( 'LBOUND', NVOUT, DLBND, -VAL__MAXI,
     :                         VAL__MAXI, .FALSE., OLBND, STATUS )
               DO I = 1, NVOUT
                  SHADEF( I ) = MAX( OLBND( I ), DUBND( I ) )
                  BMAX( I ) = VAL__MAXI
               END DO
               CALL PAR_DEF1I( 'UBOUND', NVOUT, DUBND, STATUS )
               CALL PAR_GRM1I( 'UBOUND', NVOUT, SHADEF, OLBND, BMAX,
     :                         .FALSE., OUBND, STATUS )
            END IF
         ELSE IF ( SHAPE .EQ. 'SAME') THEN

*  Output NDF bounds those of the input NDFs.
            DO IAXIS = 1, NVOUT
               OLBND( IAXIS ) = ILBND( IAXIS )
               OUBND( IAXIS ) = IUBND( IAXIS )
            END DO
         ELSE

*  Autosize the output NDF.
            DO IAXIS = 1, NVOUT
               OLBND( IAXIS ) = VAL_DTOI( .FALSE.,
     :                          DDLBND( IAXIS ) - 0.5D0, STATUS )
               OUBND( IAXIS ) = VAL_DTOI( .FALSE., DDUBND( IAXIS ),
     :                          STATUS )
            END DO
         END IF

*  Derive the output NDF's dimensions.
         DO IAXIS = 1, NVOUT
            ODIMS( IAXIS ) = OUBND( IAXIS ) - OLBND( IAXIS ) + 1
         END DO
         IF ( STATUS .NE. SAI__OK ) GO TO 940

*  Create a concatenated input axis array.
*  =======================================
*
*  The subroutines that perform the resampling need the axis arrays
*  to convert coordinates into pixel indices in the input array.
*  For convenience the axis centres are passed in a single vector
*  and required values are found using offsets equal to the sum of
*  the lower axis dimensions.
*
*  Find the length of the concatenated axes.
         CADIMS( 1 ) = 0
         DO IAXIS = 1, NVIN
            CADIMS( 1 ) = CADIMS( 1 ) + AEL( IAXIS )
         END DO

*  Create some workspace for the concatenated array.
         CALL CCD1_MALL( CADIMS( 1 ), '_DOUBLE', CAXPTR, STATUS )

*  Pasting routine needs filled dimension arrays of NDF__MXDIM values.
         DO IAXIS = 2, NDF__MXDIM
            ADIMS( IAXIS ) = 1
            CADIMS( IAXIS ) = 1
            AXOFFS( IAXIS ) = 0
         END DO

         AXOFFS( 1 ) = 0
         DO IAXIS = 1, NVIN

*  Assign the axis dimension.
            ADIMS( 1 ) = AEL( IAXIS )

*  Paste each axis into the work array.
            CALL KPG1_PASTD( .FALSE., .TRUE., AXOFFS, ADIMS, ADIMS( 1 ),
     :                       %VAL( AXPNTR( IAXIS ) ), CADIMS,
     :                       CADIMS( 1 ), %VAL( CAXPTR ), STATUS )

*  Increment the offsets for the next axis.
            AXOFFS( 1 ) = AXOFFS( 1 ) + AEL( IAXIS )
         END DO

         IF ( STATUS .NE. SAI__OK ) GO TO 940

*  Tidy the axis centres.
*  ======================
         DO IAXIS = 1, NVIN
            CALL CCD1_MFREE( AXPNTR( IAXIS ), STATUS )
         END DO

*  Create the output NDF.
*  ======================
         CALL IRG_NDFPR( GIDOUT, INDEX, IDIN, 'Axis,Units', IDOUT,
     :                   STATUS )        

*  Tell user the name of the output NDF.
         CALL NDF_MSG( 'OUTNDF', IDOUT )
         CALL CCD1_MSG( ' ', '  Output NDF: ^OUTNDF', STATUS )

*  And report the actual extent of the output NDF (before creating
*  an NDF of this actual extent - useful if shape=auto and funny
*  transformation is being used).
         DO IAXIS = 1, NVOUT
            CALL MSG_SETI( 'AXIS', IAXIS )
            CALL MSG_SETI( 'LOW', OLBND( IAXIS ) )
            CALL MSG_SETI( 'HIGH', OUBND( IAXIS ) )
            IF ( IAXIS .EQ. 1 ) THEN
                  CALL CCD1_MSG( 'OUTBOUNDS',
     :'  Output NDF bounds : ^LOW to ^HIGH', STATUS )
            ELSE
               CALL CCD1_MSG( 'OUTBOUNDS',
     :'                    : ^LOW to ^HIGH', STATUS )
            END IF
         END DO
                                                 
*  Change its shape to the required output shape.
         CALL NDF_SBND( NDIMI, OLBND, OUBND, IDOUT, STATUS )
         IF ( STATUS .NE. SAI__OK ) GO TO 940

*  Find the flux-conservation factor.
*  ==================================

*  Find a constant determinant by transforming unit vectors along each
*  dimension.
         IF ( NORM .AND. NVIN .EQ. NVOUT .AND.
     :        ( CLASS( TRN__LIN ) .OR. CLASS( TRN__CONDT ) ) ) THEN

*  First set the input coordinates to all zero.
            DO IAXIS = 1, NVIN
               DO I = 0, NVIN
                  COIN( I, IAXIS ) = 0.0D0
               END DO
            END DO

*  Revise the diagonal terms to one.
            DO I = 1, NVIN
               COIN( I, I ) = 1.0D0
            END DO
            EL = NVIN * NVIN + 1

*  Apply the transformation.
            CALL TRN_TRND( .FALSE., NDF__MXDIM + 1, NVIN, EL, COIN,
     :                     TRIDF, NDF__MXDIM + 1, NVOUT, COOUT, STATUS )

*  Assign the Jacobian matrix.
            DO IAXIS = 1, NVIN
               DO I = 1, NVIN
                  JACOB( I, IAXIS ) = COOUT( I, IAXIS ) -
     :                                COOUT( 0, IAXIS )
               END DO
            END DO

*  The flux term is the inverse of the absolute determinant of the
*  Jacobian.
            CALL KPG1_MDETD( NVIN, NDF__MXDIM, JACOB, WORK1, WORK2,
     :                       FLUX, STATUS )
            IF ( FLUX .GT. VAL__SMLD ) THEN
               FLUX = ABS( 1.0D0 / FLUX )
            ELSE
               FLUX = 1.0D0
            END IF
         ELSE

*  No flux conservation.
            FLUX = 1.0D0
         END IF

*  See if there is any conservation of flux required.
         CONSRV = ABS( FLUX - 1.0D0 ) .GT. VAL__EPSD
         IF ( STATUS .NE. SAI__OK ) GO TO 940
         
*  Resample using the nearest-neighbour technique.
*  ===============================================
         IF ( METHOD .EQ. 'NEAREST' ) THEN
         
*  This method is applicable to the data, variance and quality arrays.
*  First determine the vector indices of the nearest neighbours applying
*  the transformation.  To do this we need some work space for the
*  input and output coordinates, and input fractional indices.
            WDIMS( 1 ) = ODIMS( 1 )
            WDIMS( 2 ) = NDIMI
            CALL CCD1_MALL( WDIMS( 1 ) * WDIMS( 2 ), '_DOUBLE', WPNTR1,
     :                      STATUS )
            CALL CCD1_MALL( WDIMS( 1 ) * WDIMS( 2 ), '_DOUBLE', WPNTR2,
     :                      STATUS )
            WDIMS( 2 ) = NDIMI
            CALL CCD1_MALL( WDIMS( 1 ) * WDIMS( 2 ), '_DOUBLE', WPNTR3,
     :                      STATUS )
         
*  Get workspace to hold the indices of the nearest neighbours. There
*  is one for each output array element.
            EL = 1
            DO I = 1, NVOUT
               EL = EL * ODIMS( I )
            END DO
            CALL CCD1_MKTMP( EL, '_INTEGER', INDID, STATUS )
            CALL CCD1_MPTMP( INDID, 'WRITE', INPNTR, STATUS )
         
*  Generate the list of vector indices for the resampling.
            CALL KPG1_TRPID( NDIMI, IDIMS, TRIDI, %VAL( CAXPTR ),
     :                       WDIMS( 1 ), NVOUT, OLBND, ODIMS,
     :                       %VAL( WPNTR1 ), %VAL( WPNTR3 ),
     :                       %VAL( WPNTR2 ), %VAL( INPNTR ), STATUS )
         
*  Free the workspace that is no longer needed.
            CALL CCD1_MFREE( WPNTR1, STATUS )
            CALL CCD1_MFREE( WPNTR2, STATUS )
            CALL CCD1_MFREE( WPNTR3, STATUS )
         
*  Apply the transformation with n-n resampling.
*  =============================================
*  Loop through all the components.
            DO ICOMP = 1, NACOMP
         
*  See if the component is present.
               IF ( COMP( ICOMP ) .NE. 'Data' ) THEN
                  CALL NDF_STATE( IDIN, COMP( ICOMP ), THERE, STATUS )
               ELSE
                  THERE = .TRUE.
               END IF
         
*  Can only process when the array component is present.
               IF ( THERE ) THEN
         
*  Get the type of the array.
                  CALL NDF_TYPE( IDIN, COMP( ICOMP ), ITYPE, STATUS )
         
*  Map the input and output arrays.
                  CALL NDF_MAP( IDIN, COMP( ICOMP ), ITYPE, 'READ',
     :                          IPNTR, ELIN, STATUS )
                  CALL NDF_MAP( IDOUT, COMP( ICOMP ), ITYPE,
     :                          'WRITE/BAD', OPNTR, ELOUT, STATUS )
                                     
*  When there is flux conservation there is a two-stage process, so
*  workspace is needed to hold the uncorrected values.  Use the same
*  pointer for both cases to save code.  Flux conservation is not
*  required for the QUALITY array.   
                  IF ( CONSRV .AND. COMP( ICOMP ) .NE. 'Quality' ) THEN
                     CALL CCD1_MKTMP( ELOUT, ITYPE, WKID4, STATUS )
                     CALL CCD1_MPTMP( WKID4, 'WRITE', OPNTRW, STATUS )
                  ELSE          
                     OPNTRW = OPNTR( 1 )
                  END IF        
                                
*  Perform the transformation on the data array for the numeric data
*  type.  First for a byte array
                  IF ( ITYPE .EQ. '_BYTE' ) THEN
                     CALL KPG1_VASVB( ELOUT, %VAL( INPNTR ), ELIN,
     :                                %VAL( IPNTR( 1 ) ),
     :                                %VAL( OPNTRW ), NBAD, STATUS )
                                
*  Transform a double-precision array.
                  ELSE IF ( ITYPE .EQ. '_DOUBLE' ) THEN
                     CALL KPG1_VASVD( ELOUT, %VAL( INPNTR ), ELIN,
     :                                %VAL( IPNTR( 1 ) ),
     :                                %VAL( OPNTRW ), NBAD, STATUS )
                                
*  Transform an integer array.  
                  ELSE IF ( ITYPE .EQ. '_INTEGER' ) THEN
                     CALL KPG1_VASVI( ELOUT, %VAL( INPNTR ), ELIN,
     :                                %VAL( IPNTR( 1 ) ),
     :                                %VAL( OPNTRW ), NBAD, STATUS )
                                
*  Transform a single-precision array.
                  ELSE IF ( ITYPE .EQ. '_REAL' ) THEN
                     CALL KPG1_VASVR( ELOUT, %VAL( INPNTR ), ELIN,
     :                                %VAL( IPNTR( 1 ) ),
     :                                %VAL( OPNTRW ), NBAD, STATUS )
                                
*  Transform an unsigned-byte array.
                  ELSE IF ( ITYPE .EQ. '_UBYTE' ) THEN
                     CALL KPG1_VASVUB( ELOUT, %VAL( INPNTR ), ELIN,
     :                                 %VAL( IPNTR( 1 ) ),
     :                                 %VAL( OPNTRW ), NBAD, STATUS )
                                
*  Transform an unsigned-word array.
                  ELSE IF ( ITYPE .EQ. '_UWORD' ) THEN
                     CALL KPG1_VASVUW( ELOUT, %VAL( INPNTR ), ELIN,
     :                                 %VAL( IPNTR( 1 ) ),
     :                                 %VAL( OPNTRW ), NBAD, STATUS )
                                
*  Transform a word array.      
                  ELSE IF ( ITYPE .EQ. '_WORD' ) THEN
                     CALL KPG1_VASVW( ELOUT, %VAL( INPNTR ), ELIN,
     :                                %VAL( IPNTR( 1 ) ),
     :                                %VAL( OPNTRW ), NBAD, STATUS )
                  END IF        
                                
*  If there is no flux conservation we only need to unmap the output
*  array.                       
                  IF ( CONSRV .AND. COMP( ICOMP ) .NE. 'Quality' ) THEN
                                
*  Decide whether or not we need to test for bad pixels.
                     BAD = NBAD .NE. 0
                                
*  Select the appropriate routine for the data type being processed and
*  multiply the data array by the constant.
                     CALL CCD1_CMUL( BAD, ITYPE, OPNTRW, EL, FLUX, 
     :                               OPNTR( 1 ), STATUS )

*  Tidy the workspace.
                     CALL CCD1_FRTMP( WKID4, STATUS )
                  END IF
                  
*  Set the bad pixel flag when bad pixels have been found.
                  IF ( BAD ) THEN
                     CALL NDF_SBAD( .TRUE., IDOUT, COMP( ICOMP ),
     :                              STATUS )
                  END IF
                  
*  Unmap the output array.
                  CALL NDF_UNMAP( IDOUT, COMP( ICOMP ), STATUS )

*  Unmap the input NDF array.
                  CALL NDF_UNMAP( IDIN, COMP( ICOMP ), STATUS )
               END IF                  
            END DO                     
         
*  Free the workspace holding the resampled vector indices.
            CALL CCD1_FRTMP( INDID, STATUS )
         
*  Apply linear-interpolation resampling.
*  ======================================
         ELSE IF ( METHOD .EQ. 'LININT' ) THEN
         
*  Get work arrays for the transformation. Needed is space for the input
*  and output coordinates, and input fractional indices.
            WDIMS( 1 ) = ODIMS( 1 )
            WDIMS( 2 ) = NDIMI
            CALL CCD1_MALL( WDIMS( 1 ) * WDIMS( 2 ), '_DOUBLE', WPNTR1,
     :                      STATUS )
            CALL CCD1_MALL( WDIMS( 1 ) * WDIMS( 2 ), '_DOUBLE', WPNTR2,
     :                      STATUS )
            WDIMS( 2 ) = NDIMI
            CALL CCD1_MALL( WDIMS( 1 ) * WDIMS( 2 ), '_DOUBLE', WPNTR3,
     :                      STATUS )
                             
*  See if the variance component is present.  Note that a quality array
*  cannot be linearly interpolated.
            CALL NDF_STATE( IDIN, 'Variance', VAR, STATUS )
            IF ( VAR ) THEN  
                             
*  Get the implementation type of the arrays.
               CALL NDF_MTYPE( '_BYTE,_UBYTE,_WORD,_UWORD,_INTEGER,'/
     :                         /'_REAL,_DOUBLE', IDIN, IDIN,
     :                         'Data,Variance', ITYPE, DTYPE, STATUS )
                             
*  Map the input and output arrays.
               CALL NDF_MAP( IDIN, 'Data,Variance', ITYPE, 'READ',
     :                       IPNTR, ELIN, STATUS )
               CALL NDF_MAP( IDOUT, 'Data,Variance', ITYPE, 'WRITE/BAD',
     :                       OPNTR, ELOUT, STATUS )
                             
*  Perform the transformation on the data array for the numeric data
*  type.  First apply to a byte array.
               IF ( ITYPE .EQ. '_BYTE' ) THEN
                  CALL KPG1_TDLIB( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                             VAR, %VAL( IPNTR( 2 ) ), TRIDI,
     :                             FLUX, %VAL( CAXPTR ), ODIMS( 1 ),
     :                             NDIMI, OLBND, ODIMS,
     :                             %VAL( OPNTR( 1 ) ),
     :                             %VAL( OPNTR( 2 ) ),
     :                             %VAL( WPNTR1 ), %VAL( WPNTR3 ),
     :                             %VAL( WPNTR2 ), STATUS )
                       
*  Transform a double-precision array.
               ELSE IF ( ITYPE .EQ. '_DOUBLE' ) THEN
                  CALL KPG1_TDLID( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                             VAR, %VAL( IPNTR( 2 ) ), TRIDI,
     :                             FLUX, %VAL( CAXPTR ), ODIMS( 1 ),
     :                             NDIMI, OLBND, ODIMS,
     :                             %VAL( OPNTR( 1 ) ),
     :                             %VAL( OPNTR( 2 ) ),
     :                             %VAL( WPNTR1 ), %VAL( WPNTR3 ),
     :                             %VAL( WPNTR2 ), STATUS )
                       
*  Transform an integer array.
               ELSE IF ( ITYPE .EQ. '_INTEGER' ) THEN
                  CALL KPG1_TDLII( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                             VAR, %VAL( IPNTR( 2 ) ), TRIDI,
     :                             FLUX, %VAL( CAXPTR ), ODIMS( 1 ),
     :                             NDIMI, OLBND, ODIMS,
     :                             %VAL( OPNTR( 1 ) ),
     :                             %VAL( OPNTR( 2 ) ),
     :                             %VAL( WPNTR1 ), %VAL( WPNTR3 ),
     :                             %VAL( WPNTR2 ), STATUS )
                       
*  Transform a single-precision array.
               ELSE IF ( ITYPE .EQ. '_REAL' ) THEN
                  CALL KPG1_TDLIR( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                             VAR, %VAL( IPNTR( 2 ) ), TRIDI,
     :                             FLUX, %VAL( CAXPTR ), ODIMS( 1 ),
     :                             NDIMI, OLBND, ODIMS,
     :                             %VAL( OPNTR( 1 ) ),
     :                             %VAL( OPNTR( 2 ) ),
     :                             %VAL( WPNTR1 ), %VAL( WPNTR3 ),
     :                             %VAL( WPNTR2 ), STATUS )
                       
*  Transform an unsigned-byte array.
               ELSE IF ( ITYPE .EQ. '_UBYTE' ) THEN
                  CALL KPG1_TDLIUB( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                              VAR, %VAL( IPNTR( 2 ) ), TRIDI,
     :                              FLUX, %VAL( CAXPTR ), ODIMS( 1 ),
     :                              NDIMI, OLBND, ODIMS,
     :                              %VAL( OPNTR( 1 ) ),
     :                              %VAL( OPNTR( 2 ) ),
     :                              %VAL( WPNTR1 ), %VAL( WPNTR3 ),
     :                              %VAL( WPNTR2 ), STATUS )
                       
*  Transform an unsigned-word array.
               ELSE IF ( ITYPE .EQ. '_UWORD' ) THEN
                  CALL KPG1_TDLIUW( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                              VAR, %VAL( IPNTR( 2 ) ), TRIDI,
     :                              FLUX, %VAL( CAXPTR ), ODIMS( 1 ),
     :                              NDIMI, OLBND, ODIMS,
     :                              %VAL( OPNTR( 1 ) ),
     :                              %VAL( OPNTR( 2 ) ),
     :                              %VAL( WPNTR1 ), %VAL( WPNTR3 ),
     :                              %VAL( WPNTR2 ), STATUS )
                       
*  Transform a word array.
               ELSE IF ( ITYPE .EQ. '_WORD' ) THEN
                  CALL KPG1_TDLIW( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                             VAR, %VAL( IPNTR( 2 ) ), TRIDI,
     :                             FLUX, %VAL( CAXPTR ), ODIMS( 1 ),
     :                             NDIMI, OLBND, ODIMS,
     :                             %VAL( OPNTR( 1 ) ),
     :                             %VAL( OPNTR( 2 ) ),
     :                             %VAL( WPNTR1 ), %VAL( WPNTR3 ),
     :                             %VAL( WPNTR2 ), STATUS )
               END IF
            ELSE
            
*  Get the type of the data array.
               CALL NDF_TYPE( IDIN, 'Data', ITYPE, STATUS )
            
*  Map the input and output arrays.  Use a dummy variance value.  It is
*  not assigned as it will not be used.
               CALL NDF_MAP( IDIN, 'Data', ITYPE, 'READ', IPNTR, ELIN,
     :                       STATUS )
               CALL NDF_MAP( IDOUT, 'Data', ITYPE, 'WRITE/BAD', OPNTR,
     :                       ELOUT, STATUS )
               
*  Perform the transformation on the data array for the numeric data
*  type.  First apply to a byte array.
               IF ( ITYPE .EQ. '_BYTE' ) THEN
                  CALL KPG1_TDLIB( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                             VAR, VARB, TRIDI, FLUX, 
     :                             %VAL( CAXPTR ), ODIMS( 1 ), NDIMI,
     :                             OLBND, ODIMS, %VAL( OPNTR( 1 ) ),
     :                             VARBO, %VAL( WPNTR1 ),
     :                             %VAL( WPNTR3 ), %VAL( WPNTR2 ),
     :                             STATUS )
                  
*  Transform a double-precision array.
               ELSE IF ( ITYPE .EQ. '_DOUBLE' ) THEN
                  CALL KPG1_TDLID( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                             VAR, VARD, TRIDI, FLUX, 
     :                             %VAL( CAXPTR ), ODIMS( 1 ), NDIMI,
     :                             OLBND, ODIMS, %VAL( OPNTR( 1 ) ),
     :                             VARBO, %VAL( WPNTR1 ),
     :                             %VAL( WPNTR3 ), %VAL( WPNTR2 ),
     :                             STATUS )
                  
*  Transform an integer array.
               ELSE IF ( ITYPE .EQ. '_INTEGER' ) THEN
                  CALL KPG1_TDLII( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                             VAR, VARI, TRIDI, FLUX, 
     :                             %VAL( CAXPTR ), ODIMS( 1 ), NDIMI,
     :                             OLBND, ODIMS, %VAL( OPNTR( 1 ) ),
     :                             VARBO, %VAL( WPNTR1 ),
     :                             %VAL( WPNTR3 ), %VAL( WPNTR2 ),
     :                             STATUS )
                  
*  Transform a single-precision array.
               ELSE IF ( ITYPE .EQ. '_REAL' ) THEN
                  CALL KPG1_TDLIR( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                             VAR, VARR, TRIDI, FLUX, 
     :                             %VAL( CAXPTR ), ODIMS( 1 ), NDIMI,
     :                             OLBND, ODIMS, %VAL( OPNTR( 1 ) ),
     :                             VARBO, %VAL( WPNTR1 ),
     :                             %VAL( WPNTR3 ), %VAL( WPNTR2 ),
     :                             STATUS )
                  
*  Transform an unsigned-byte array.
               ELSE IF ( ITYPE .EQ. '_UBYTE' ) THEN
                  CALL KPG1_TDLIUB( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                              VAR, VARB, TRIDI, FLUX, 
     :                              %VAL( CAXPTR ), ODIMS( 1 ),
     :                              NDIMI, OLBND, ODIMS,
     :                              %VAL( OPNTR( 1 ) ), VARBO,
     :                              %VAL( WPNTR1 ), %VAL( WPNTR3 ),
     :                              %VAL( WPNTR2 ), STATUS )
                  
*  Transform an unsigned-word array.
               ELSE IF ( ITYPE .EQ. '_UWORD' ) THEN
                  CALL KPG1_TDLIUW( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                              VAR, VARW, TRIDI, FLUX, 
     :                              %VAL( CAXPTR ), ODIMS( 1 ),
     :                              NDIMI, OLBND, ODIMS,
     :                              %VAL( OPNTR( 1 ) ), VARBO,
     :                              %VAL( WPNTR1 ), %VAL( WPNTR3 ),
     :                              %VAL( WPNTR2 ), STATUS )
                  
*  Transform a word array.
               ELSE IF ( ITYPE .EQ. '_WORD' ) THEN
                  CALL KPG1_TDLIW( NDIMI, IDIMS, %VAL( IPNTR( 1 ) ),
     :                             VAR, VARW, TRIDI, FLUX, 
     :                             %VAL( CAXPTR ), ODIMS( 1 ), NDIMI,
     :                             OLBND, ODIMS, %VAL( OPNTR( 1 ) ),
     :                             VARBO, %VAL( WPNTR1 ),
     :                             %VAL( WPNTR3 ), %VAL( WPNTR2 ),
     :                             STATUS )
               END IF
            
*  Free the workspace that is no longer needed.
               CALL CCD1_MFREE( WPNTR1, STATUS )
               CALL CCD1_MFREE( WPNTR2, STATUS )
               CALL CCD1_MFREE( WPNTR3, STATUS )
            END IF
         END IF

*  Add a title to the new NDF.
         CALL NDF_CINP( 'TITLE', IDOUT, 'TITLE', STATUS )

*  Release NDFs and close container files. Retain locator to transform
*  structure if INEXT is false.
         IF ( INEXT ) THEN 
            CALL DAT_ANNUL( LOCEXT, STATUS )
            CALL DAT_ANNUL( LOCTR, STATUS )
            CALL TRN_ANNUL( TRIDF, STATUS )
            CALL TRN_ANNUL( TRIDI, STATUS )
         END IF
         CALL NDF_ANNUL( IDIN, STATUS )
         CALL NDF_ANNUL( IDOUT, STATUS )

*  Free concatenated axes workspace.
         CALL CCD1_MFREE( CAXPTR, STATUS )

*  Write terminator for Processing NDF: message.
         CALL CCD1_MSG( ' ', '  ---',STATUS )

*  End of main processing loop.

99999 CONTINUE
         
*  Tidy resources.
*  ===============
         
*  Free any workspace.
  940 CONTINUE  
      CALL CCD1_MFREE( -1, STATUS )
      CALL CCD1_FRTMP( -1, STATUS )
         
*  Tidy the NDF context.
  960 CONTINUE  
      CALL NDF_END( STATUS )
         
*  Free any remaining transformation resources.
      CALL TRN_CLOSE( STATUS )
         
  999 CONTINUE
         
*  If an error occurred, then report a contextual message.
      IF ( STATUS .NE. SAI__OK ) THEN
         CALL ERR_REP( 'TRANNDF_ERR',
     :     'TRANNDF: Unable to transform the NDF.',
     :     STATUS )
      END IF
         
*  Close the log file.
      CALL CCD1_END( STATUS )
         
      END
* $Id$
