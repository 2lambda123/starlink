      SUBROUTINE MAKESET( STATUS )
*+
*  Name:
*     MAKESET

*  Purpose:
*     Group NDFs together into a Set.

*  Language:
*     Starlink Fortran 77

*  Type of Module:
*     ADAM A-task

*  Invocation:
*     CALL MAKESET( STATUS )

*  Arguments:
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Description:
*     This routine is used to group NDFs into a Set so that they can be
*     processed together.  It is usually used when you have CCD data from
*     a single exposure in multiple files because they were generated
*     from multiple CCDs in a mosaic camera, or from multiple amplifiers
*     in the same CCD, or both.  When this program is run on a group
*     of files, header information is written to each one so that
*     other CCDPACK routines will know about the relationship between
*     them.
*
*     MAKESET writes the following items of data to the .MORE.CCDPACK.SET
*     extension of each NDF:
*        1. The Set NAME (a string identifying all NDFs in the same Set)
*        2. The Set INDEX (an integer identifying the NDF's position 
*           within the Set)
*
*     and it will also optionally (if ADDWCS is set true) write:
*        3. The Set coordinate system (a coordinate frame in the NDF's 
*           WCS component with the Domain 'CCD_SET').
*
*     Normally by just presenting a list of NDF names to the program the
*     values of these attributes will be taken care of automatically,
*     but various options exist to tune how it is done.

*  Usage:
*     makeset in

*  ADAM Parameters:
*     ADDWCS = _LOGICAL (Read)
*        If ADDWCS is true, then MAKESET will attach a new coordinate
*        system to the WCS component of the image.  The new coordinate
*        frame will be a copy of the Current coordinate frame of
*        the image, and will have the Domain name of 'CCD_SET';
*        CCDPACK tasks concerned with registration know about this
*        name and will use those coordinates on the assumption that
*        they constitute a correct registration of images if they 
*        are present.  Therefore this parameter should be set true 
*        if the images which will form a Set are known to be aligned
*        in their common Current coordinate system.
*        [TRUE]
*     ASTFILE = LITERAL (Read)
*        If this parameter is supplied, it gives the name of a file
*        containing Set coordinate information.  A new coordinate 
*        frame will accordingly be written into the WCS component
*        of each image, with the Domain name 'CCD_SET'; CCDPACK
*        tasks concerned with registration know about this name 
*        and will use those coordinates on the assumption that they
*        constitute a correct registration of images if they are
*        present.
*
*        The file named by this parameter will normally have been
*        written by the ASTEXP program, saving a known correct 
*        alignment of images within a Set that corresponds to 
*        the one being created by this program.
*        [!]
*     FITSINDEX = LITERAL (Read)
*        The name of the FITS header card whose value will determine
*        the Set Index attribute of each file.  The Set Index
*        header value itself is determined from the value of the
*        chosen FITS header card and the value of the INDEXVALS
*        parameter.  Only used if MODE=FITS.
*     FITSNAME = LITERAL (Read)
*        The name of the FITS header card whose value will determine
*        the Set Name attribute of each file.  The Set Name header
*        value is taken directly from the chosen FITS header card.
*        Only used if MODE=FITS.
*     IN = LITERAL (Read)
*        A group expression giving a list of NDFs to group into one 
*        or more Sets.  The order in which they are listed will 
*        normally determine their INDEX values (but see the INDICES 
*        parameter), so that the Sets should be generated by 
*        presenting NDFs in a consistent order; the one from CCD1 
*        first, the one from CCD2 second...
*     INDEXVALS( * ) = LITERAL (Read)
*        A list of strings to map the value of the
*        FITS header card indicated by the FITSINDEX parameter to
*        the Set Index value; if the header value matches the Nth
*        element of this list the file will be given a Set Index
*        value of N.  This parameter will dynamically default to
*        a sorted list of all the values of the chosen parameter
*        which exist in all the input files presented.  This will
*        usually be a suitable value if at least one complete Set
*        is being considered.  Note that each value must in general
*        be surrounded by double quotes.  Only used if MODE=FITS.
*     INDICES( * ) = _INTEGER  (Read)
*        This parameter is a list of positive integers with SETSIZE
*        elements (SETSIZE will normally be the same as the number of
*        NDFs accessed by the IN parameter).  It indicates, for each
*        NDF in the list, what value the Set INDEX attribute should
*        take.  If set to the null value (!) then INDEX attributes
*        will be assigned in order (1, 2, 3, ...) for the members of 
*        each Set.  Only used if MODE=LIST.
*        [!]
*     LOGFILE = FILENAME (Read)
*        Name of the CCDPACK logfile.  If a null (!) value is given for
*        this parameter then no logfile will be written, regardless of
*        the value of the LOGTO parameter.
*
*        If the logging system has been initialised using CCDSETUP
*        then the value specified there will be used. Otherwise, the
*        default is "CCDPACK.LOG".
*        [CCDPACK.LOG]
*     LOGTO = LITERAL (Read)
*        Every CCDPACK application has the ability to log its output
*        for future reference as well as for display on the terminal.
*        This parameter controls this process, and may be set to any
*        unique abbreviation of the following:
*           -  TERMINAL  -- Send output to the terminal only
*           -  LOGFILE   -- Send output to the logfile only (see the
*                           LOGFILE parameter)
*           -  BOTH      -- Send output to both the terminal and the
*                           logfile
*           -  NEITHER   -- Produce no output at all
*
*        If the logging system has been initialised using CCDSETUP
*        then the value specified there will be used. Otherwise, the
*        default is "BOTH".
*        [BOTH]
*     MODE = LITERAL (Read)
*        Determines exactly how Set header information should be written
*        to the IN files.  It may take one of the following values:
*           - LIST
*           - CONTAINER
*           - FITS
*
*        When MODE=LIST, new Sets will be formed according to the
*        order in which NDFs are named in the IN list.
*        In the most straightforward case, all the named files will 
*        become part of the same new Set, with a Set Name derived 
*        from the name of the first file in the list and consecutive 
*        Set Index values 1, 2, 3, ....  The SETSIZE and INDICES 
*        parameters can be used to create multiple sets in one 
*        invocation and to modify the ordering.
*
*        When MODE=CONTAINER, one new Set will be formed for each HDS
*        container file; thus each NDF will be grouped with the 
*        other NDFs in the same container file, being given a Set 
*        Name based on the name of the container file and a Set Index
*        based on its position within it.  HDS container files 
*        suitable for feeding to MAKESET with MODE=CONTAINER are often
*        the result of converting multi-extension FITS files to NDF
*        format.
*
*        When MODE=FITS the Set attributes of each NDF are determined
*        by the value of FITS header cards with keywords given by
*        the FITSINDEX and FITSNAME parameters.  The Set Name
*        attribute is given directly by the value of the FITSNAME-
*        chosen header.  The Set Index attribute is given by the
*        position of the value of the FITSINDEX-chosen header in
*        the list determined by the INDEXVALS parameter.
*        Note this can only be used if both a Name-like and an 
*        Index-like header card is available in the FITS header of
*        each file.
*        [LIST]
*     NAME = LITERAL (Read)
*        The NAME parameter is used to determine the Set NAME attribute
*        which the grouped NDFs will have; all NDFs in the same Set
*        have the same NAME.  The value of this parameter should be
*        a group expression containing the same number of elements
*        as the number of Sets being created; if it contains
*        modification elements such as "*" they are applied to the
*        name of the first NDF in each Set.
*
*        The default value is "*", which means the Set NAME is the
*        same as the name of the NDF first entered into each Set
*        (if MODE=LIST) or the name of the HDS container file
*        (if MODE=CONTAINER).  If MODE=FITS it is ignored.  There 
*        is normally no need to use a value other than the default.
*        [*]
*     SETSIZE = _INTEGER (Read)
*        The number of NDFs in each set.  This will default initially 
*        to the number of NDFs in the IN list, but if set to a 
*        number less than that, then more than one set will be 
*        generated (the first SETSIZE from IN will become the first 
*        set, and so on).  If INDICES is specified it must have SETSIZE
*        elements, and Set INDEX assignment will wrap round when 
*        SETSIZE elements have been processed.  SETSIZE must be 
*        positive, and must be a divisor of the number of NDFs in 
*        the IN list, so that each distinct Set created by one 
*        invocation of MAKESET is forced to be the same size.
*        Only used if MODE=LIST.
*        [dynamic]

*  Examples:
*     makeset "data1,data2,data3,data4" addwcs mode=list
*        This will write Set information into the named NDFs; they will
*        all be given the same Set Name attribute ("data1") and will
*        be given the Set Index attributes 1, 2, 3 and 4 respectively.
*        Additionally, a new attached coordinate system with the Domain
*        "CCD_SET" will be added to the World Coordinate System (WCS)
*        component of each; this will be a copy of each one's Current
*        attached coordinate system.  If not all of them have the
*        same Current coordinate system when the program is run
*        (i.e. they do not all have the same Domain), then a warning
*        will be issued.
*
*     makeset * mode=container
*        In this case, all the NDFs in the current directory are
*        assigned Set header information based on how they are 
*        contained within HDS container files.
*
*     makeset * mode=list setsize=4
*        This will add Set information to all the NDFs in the current
*        directory, grouping them into Sets of 4 NDFs each.  If MAKESET
*        is to be used in this way however it must be done with care,
*        since it will group the files in the order in which they
*        are presented.  This depends on what order the "*" character
*        is expanded in, which depends on the details of the shell
*        that you are using.  Typically shells expand alphabetically,
*        so that if the directory contains files with the names 
*        d08.sdf, d09.sdf, d10.sdf, d11.sdf they will be presented
*        in that order, but files with the names d8.sdf, d9.sdf, 
*        d10.sdf, d11.sdf would be presented in the order d10.sdf, 
*        d11.sdf, d8.sdf, d9.sdf.  Unless you are confident of how
*        your shell behaves in this respect, then when using wildcards 
*        you should pay careful attention to the log output of 
*        MAKESET to check that the order is correct.  It is safest
*        to list Set members explicitly as in the previous example.
*
*     makeset "d1,d2,d3,e1,e2,e3" name=night1-* setsize=3 addwcs=no
*        This will construct two Sets, which will be given Set Name
*        attributes of "night1-d1" and "night1-e1" respectively.
*        You might want to do this if you are going to use these
*        files along with other Sets generated from files with the
*        names the same as these.  No additions are made to the
*        WCS componnent of the images.
*
*     makeset "d1,d3" indices=[1,3]
*        This will construct a Set of the two named NDFs, giving them
*        the Set Index attributes of 1 and 3 respectively.  This
*        might be necessary for comparison with 3-member sets if the
*        Index=2 one is absent in this case due to a loss of the data
*        file for some reason.

*  Behaviour of Parameters:
*     All parameters retain their current value as default. The
*     "current" value is the value assigned on the last run of the
*     application. If the application has not been run then the
*     "intrinsic" defaults, as shown in the parameter help, apply.
*
*     Retaining parameter values has the advantage of allowing you to
*     define the default behaviour of the application. The intrinsic
*     default behaviour of the application may be restored by using the
*     RESET keyword on the command line.
*
*     Certain parameters (LOGTO and LOGFILE) have global
*     values. These global values will always take precedence, except
*     when an assignment is made on the command line. Global values may
*     be set and reset using the CCDSETUP and CCDCLEAR commands.

*  Notes:
*     - When MODE=CONTAINER, membership of a Set is not strictly 
*     determined by the identity of the HDS container file in which 
*     it resides, but by the pathname supplied to the IN parameter
*     which identifies that HDS container file.  Thus it is possible
*     to create members of two Sets within a single container file
*     in one invocation of MAKESET, but it's most unlikely that this
*     will result unless you are deliberately invoking it in a 
*     bizarre way.
*
*     - When a non-null ASTFILE parameter is supplied, this program
*     duplicates much of the functionality of ASTIMP.

*  Copyright:
*     Copyright (C) 2001 Central Laboratory of the Research Councils

*  Authors:
*     MBT: Mark Taylor (STARLINK)
*     {enter_new_authors_here}

*  History:
*     5-FEB-2001 (MBT):
*        Original version.
*     {enter_changes_here}

*  Bugs:
*     {note_any_bugs_here}

*-

*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants
      INCLUDE 'AST_PAR'          ! Standard AST constants
      INCLUDE 'GRP_PAR'          ! Standard GRP constants
      INCLUDE 'PRM_PAR'          ! PRIMDAT system constants
      INCLUDE 'DAT_PAR'          ! Standard HDS constants
      INCLUDE 'PAR_ERR'          ! PAR system error values
      INCLUDE 'CCD1_PAR'         ! Private CCDPACK constants

*  External References:
      INTEGER CHR_LEN
      EXTERNAL CHR_LEN           ! Used length of string

*  Status:
      INTEGER STATUS             ! Global status

*  Local Constants:
      INTEGER MXFSET             ! Maximum framesets in one file
      PARAMETER( MXFSET = 100 )

*  Local Variables:
      INTEGER FSET( MXFSET )     ! AST pointers to import framesets
      INTEGER FSMAT              ! AST pointer to matching frameset
      INTEGER I                  ! Loop variable
      INTEGER ICARD              ! Index of FITS header card
      INTEGER IF                 ! Loop index for framesets
      INTEGER IGOT               ! Found index in GRP group
      INTEGER INDEX              ! Set INDEX attribute
      INTEGER INDDFL( CCD1__MXNDF ) ! Default values for INDXS
      INTEGER INDXS( CCD1__MXNDF ) ! Index values for successive NDFs in Set
      INTEGER INDF               ! NDF identifier
      INTEGER INGRP              ! GRP identifier for input NDFs
      INTEGER IPFITS             ! Pointer to mapped FITS headers
      INTEGER ISET( CCD1__MXNDF ) ! Which Set NDF belongs to
      INTEGER IVGRP              ! GRP identifier for index values
      INTEGER IVSGRP             ! GRP identifier for sorted index values
      INTEGER IWCS               ! AST identifier for WCS frameset
      INTEGER J                  ! Loop variable
      INTEGER JSET               ! Symbolic frame index for new WCS frame
      INTEGER K                  ! Offset into input NDF list
      INTEGER LDRGRP             ! GRP identifier for NDF base names
      INTEGER NAMGRP             ! GRP identifier for Set NAME attributes
      INTEGER NC( CCD1__MXNDF )  ! Number of NDFs so far in each Set
      INTEGER NCARD              ! Number of mapped FITS header cards
      INTEGER NCHAR              ! Number of characters in conversion
      INTEGER NFSET              ! Number of framesets in group
      INTEGER NIV                ! Number of index values
      INTEGER NNDF               ! Number of input NDFs
      INTEGER NRET               ! Number of names returned (dummy)
      INTEGER NSET               ! Number of Sets to be generated
      INTEGER NTRY               ! Number of tries for parameter entry
      INTEGER SETSIZ             ! Number of NDFs in each Set
      INTEGER SINDEX( CCD1__MXNDF ) ! What Set Index the NDF has
      LOGICAL ADDWCS             ! Add a CCD_SET frame?
      LOGICAL ASTFL              ! Use an AST file?
      LOGICAL DIFER              ! Do some NDFs have different Current domain?
      LOGICAL DIFSIZ             ! Are some groups different sizes?
      LOGICAL FITSEX             ! Does FITS extension exist?
      LOGICAL MATCH              ! Does frameset match?
      CHARACTER * ( 16 ) MODE    ! Mode for Set information construction
      CHARACTER * ( 80 ) FITIND  ! FITS header keyword for Set Index info
      CHARACTER * ( 80 ) FITNAM  ! FITS header keyword for Set Name info
      CHARACTER * ( 80 ) FITRTS( MXFSET ) ! FITS rot keyword frameset modifiers
      CHARACTER * ( 80 ) FNAME( CCD1__MXNDF ) ! FITNAM header card values
      CHARACTER * ( 80 ) FINDEX( CCD1__MXNDF ) ! FITIND header card values
      CHARACTER * ( 80 ) IVS( CCD1__MXNDF ) ! Index value strings
      CHARACTER * ( AST__SZCHR ) DMN1 ! Domain of Set leader Current frame
      CHARACTER * ( AST__SZCHR ) DOMAIN ! Domain to use for CCD_SET frame
      CHARACTER * ( AST__SZCHR ) FSID( MXFSET ) ! Id values for each frameset
      CHARACTER * ( DAT__SZLOC ) LOC ! HDS locator
      CHARACTER * ( GRP__SZNAM ) FIELDS( 6 ) ! NDG supplementary information
      CHARACTER * ( GRP__SZNAM ) NAME ! Set NAME attribute
      CHARACTER * ( GRP__SZNAM ) NDFNAM ! Name of NDF
      CHARACTER * ( CCD1__BLEN ) LINE ! Buffer for character output

*.

*  Check inherited global status.
      IF ( STATUS .NE. SAI__OK ) RETURN

*  Start up log file system, write introduction.
      CALL CCD1_START( 'MAKESET', STATUS )

*  Begin a new NDF context.
      CALL NDF_BEGIN

*  Initialise GRP identifiers, so that a later call of CCD1_GRDEL on
*  an uninitialised group cannot cause trouble.
      INGRP = GRP__NOID
      LDRGRP = GRP__NOID
      NAMGRP = GRP__NOID

*  ====================================================================
*  Preparation section.  Work out what Set header information will be
*  written to each NDF.
*  ====================================================================
*  Access an NDG group containing a list of NDF names.
      CALL CCD1_NDFGL( 'IN', 1, CCD1__MXNDF, INGRP, NNDF, STATUS )

*  What shall we do with all these NDFs?
      CALL PAR_CHOIC( 'MODE', 'LIST', 'LIST,CONTAINER,FITS', .TRUE.,
     :                MODE, STATUS )

*  Initialise number of Sets and Set base name group.
      NSET = 0
      CALL GRP_NEW( 'CCD:BASENAMES', LDRGRP, STATUS )

*  Getting Set information by position in container files.
      IF ( MODE .EQ. 'CONTAINER' ) THEN

*  Go through all the input NDFs recording which container file each
*  is in.
         DO I = 1, NNDF

*  Get the name of the container file.
            CALL NDG_GTSUP( INGRP, I, FIELDS, STATUS )
            NCHAR = 0
            IF ( FIELDS( 5 ) .NE. ' ' ) THEN
               CALL CHR_APPND( FIELDS( 5 ), NAME, NCHAR )
               CALL CHR_APPND( '/', NAME, NCHAR )
            END IF
            CALL CHR_APPND( FIELDS( 4 ), NAME, NCHAR )

*  Work out which Set of the ones we are creating this will belong to.
*  If it's the first one of a new Set, initialise the records for
*  that Set and add the name of the container file to the base names
*  group.
            CALL GRP_INDEX( NAME, LDRGRP, 1, IGOT, STATUS )
            IF ( IGOT .EQ. 0 ) THEN
               NSET = NSET + 1
               NC( NSET ) = 0
               CALL GRP_PUT( LDRGRP, 1, NAME, NSET, STATUS )
               IGOT = NSET
            END IF

*  Store the Set Name information and which Set it belongs to.
            NC( IGOT ) = NC( IGOT ) + 1
            SINDEX( I ) = NC( IGOT )
            ISET( I ) = IGOT
         END DO

*  Check that all the Sets we are about to create are the same size.
*  If not, warn the user.
         DIFSIZ = .FALSE.
         IF ( NSET .GT. 1 ) THEN
            DO I = 2, NSET
               DIFSIZ = DIFSIZ .OR. ( NC( I ) .NE. NC( I - 1 ) )
            END DO
         END IF
         IF ( DIFSIZ ) THEN
            CALL CCD1_MSG( ' ', ' ', STATUS )
            CALL CCD1_MSG( ' ',
     :      '  ** Warning: not all Sets are the same size.', STATUS )
         END IF

*  Getting Set information by position in input list.
      ELSE IF ( MODE .EQ. 'LIST' ) THEN

*  Get the number of NDFs per Set.  It dynamically defaults to the 
*  number of NDFs in the IN group.  It must divide into the number of
*  NDFs in the input group.
         NTRY = 0
 1       CONTINUE
         CALL PAR_DEF0I( 'SETSIZE', NNDF, STATUS )
         CALL PAR_GET0I( 'SETSIZE', SETSIZ, STATUS )
         IF ( MOD( NNDF, SETSIZ ) .NE. 0 .OR. SETSIZ .LT. 0 ) THEN
            IF ( NTRY .LT. 5 ) THEN
               CALL MSG_SETI( 'NNDF', NNDF )
               CALL MSG_SETI( 'SETSIZ', SETSIZ )
               CALL MSG_OUT( ' ', '  Number of input NDFs ^NNDF not '
     :         // 'divisible by SETSIZE ^SETSIZ - try again.',
     :         STATUS )
               CALL PAR_CANCL( 'SETSIZ', STATUS )
               NTRY = NTRY + 1
               GO TO 1
            ELSE
               STATUS = SAI__ERROR
               CALL ERR_REP( 'MAKESET_BADSIZE',
     :                       'MAKESET: Bad SETSIZE parameter.', STATUS )
               GO TO 99
            END IF
         END IF

*  Calculate the number of Sets we will be generating.
         NSET = NNDF / SETSIZ

*  Get a list of integers to use for the Set INDEX attributes.  If null,
*  use an array 1,2,3..SETSIZ.
         IF ( STATUS .NE. SAI__OK ) GO TO 99
         CALL CCD1_GISEQ( 1, 1, SETSIZ, INDDFL, STATUS )
         CALL PAR_GDR1I( 'INDICES', SETSIZ, INDDFL, 1, VAL__MAXI,
     :                   .TRUE., INDXS, STATUS )

*  Store the Set Index and number of the Set for each input NDF.
         K = 1
         DO I = 1, NSET
            CALL GRP_GET( INGRP, K, 1, NAME, STATUS )
            CALL GRP_PUT( LDRGRP, 1, NAME, I, STATUS )
            DO J = 1, SETSIZ
               ISET( K ) = I
               SINDEX( K ) = INDXS( J )
               K = K + 1
            END DO
         END DO

*  Getting Set information from FITS headers.
      ELSE IF ( MODE .EQ. 'FITS' ) THEN

*  Find out what FITS headers we have to use.
         CALL PAR_GET0C( 'FITSNAME', FITNAM, STATUS )
         CALL PAR_GET0C( 'FITSINDEX', FITIND, STATUS )

*  Convert them to upper case.
         CALL CHR_UCASE( FITNAM )
         CALL CHR_UCASE( FITIND )

*  Get the values of these headers for each of the input files.
         DO I = 1, NNDF

*  Locate and map the FITS extension.
            CALL GRP_GET( INGRP, I, 1, NDFNAM, STATUS )
            CALL NDG_NDFAS( INGRP, I, 'READ', INDF, STATUS )
            CALL NDF_XSTAT( INDF, 'FITS', FITSEX, STATUS )
            IF ( .NOT. FITSEX .AND. STATUS .EQ. SAI__OK ) THEN
               STATUS = SAI__ERROR
               CALL MSG_SETC( 'NDF', NDFNAM )
               CALL ERR_REP( 'MAKESET_NOFTS', 
     :         'MAKESET: No FITS extension in NDF ^NDF.', STATUS )
            END IF
            CALL NDF_XLOC( INDF, 'FITS', 'READ', LOC, STATUS )
            CALL DAT_MAPV( LOC, '_CHAR*80', 'READ', IPFITS, NCARD,
     :                     STATUS )

*  Get the requested header card values.
            CALL CCD1_FTGET( NCARD, IPFITS, 1, FITNAM, FNAME( I ),
     :                       ICARD, STATUS )
            CALL CCD1_FTGET( NCARD, IPFITS, 1, FITIND, FINDEX( I ),
     :                       ICARD, STATUS )

*  Remove quote characters; these are unlikely to remove any 
*  ambiguity and quoting them in the parameter values is a pain.
            CALL CHR_RMCHR( '''', FNAME( I ) )
            CALL CHR_RMCHR( '''', FINDEX( I ) )

*  Unmap and release the FITS header.
            CALL DAT_UNMAP( LOC, STATUS )
            CALL DAT_ANNUL( LOC, STATUS )

*  Make sure that the header card values are not blank.
            IF ( FNAME( I ) .EQ. ' ' .AND. STATUS .EQ. SAI__OK ) THEN
               STATUS = SAI__ERROR
               CALL MSG_SETC( 'FITNAM', FITNAM )
               CALL ERR_REP( 'MAKESET_BADFTS', 'MAKESET: Blank value '//
     :' of FITSNAME header ^FITNAM not allowed.', STATUS )
            END IF
            IF ( FINDEX( I ) .EQ. ' ' .AND. STATUS .EQ. SAI__OK ) THEN
               STATUS = SAI__ERROR
               CALL MSG_SETC( 'FITIND', FITIND )
               CALL ERR_REP( 'MAKESET_BADFTS', 'MAKESET: Blank value '//
     :' of FITSINDEX header %FITIND not allowed.', STATUS )
            END IF
            IF ( STATUS .NE. SAI__OK ) GO TO 99
         END DO

*  Create groups containing each of the FINDEX values once and each
*  of the FNAME values once.
         CALL GRP_NEW( 'CCD:INDEXVALS', IVGRP, STATUS )
         CALL GRP_NEW( 'CCD:NAMES', NAMGRP, STATUS )
         NIV = 0
         NSET = 0
         DO I = 1, NNDF
            CALL GRP_INDEX( FINDEX( I ), IVGRP, 1, IGOT, STATUS )
            IF ( IGOT .EQ. 0 ) THEN
               NIV = NIV + 1
               CALL GRP_PUT( IVGRP, 1, FINDEX( I ), NIV, STATUS )
            END IF
            CALL GRP_INDEX( FNAME( I ), NAMGRP, 1, ISET( I ), STATUS )
            IF ( ISET( I ) .EQ. 0 ) THEN
               NSET = NSET + 1
               CALL GRP_PUT( NAMGRP, 1, FNAME( I ), NSET, STATUS )
               ISET( I ) = NSET
            END IF
         END DO

*  Sort the group of FINDEX values alphabetically.
         CALL CCD1_GSRT( IVGRP, IVSGRP, STATUS )

*  Write them into an array, and use this as the dynamic default for
*  the parameter.  We use a vector of strings here rather than the
*  more easy-to-use group because each element might have delimiters
*  (commas) in it, and the dynamic default might just be too long
*  for the ADAM parameter length.  Hopefully most of the time it
*  will be possible just to use the default in any case.
         CALL GRP_GET( IVSGRP, 1, NIV, IVS, STATUS )
         CALL PAR_DEF1C( 'INDEXVALS', NIV, IVS, STATUS )

*  Release sets.
         CALL CCD1_GRDEL( IVGRP, STATUS )
         CALL CCD1_GRDEL( IVSGRP, STATUS )

*  Get the actual list from the user and write it into a group.
         CALL PAR_GET1C( 'INDEXVALS', VAL__MAXI, IVS, NIV, STATUS )
         CALL GRP_NEW( 'CCD:NAMES', IVSGRP, STATUS )
         CALL GRP_PUT( IVSGRP, NIV, IVS, 1, STATUS )

*  Work out the Set Index value of each presented NDF on the basis 
*  of this.
         DO I = 1, NNDF
            CALL GRP_INDEX( FINDEX( I ), IVSGRP, 1, SINDEX( I ),
     :                      STATUS )
            IF ( SINDEX( I ) .LE. 0 ) THEN
               STATUS = SAI__ERROR
               CALL MSG_SETC( 'KEY', FITIND )
               CALL MSG_SETC( 'VAL', FINDEX( I ) )
               CALL ERR_REP( 'MAKESET_NOTGOT', 'MAKESET: FITS ^KEY'//
     :' value ^VAL not in INDEXVALS', STATUS )
               GO TO 99
            END IF
         END DO

*  Unrecognised Set creation mode.
      ELSE
         STATUS = SAI__ERROR
         CALL ERR_REP( 'MAKESET_BADMODE', 
     :                 'MAKESET: Bad Set creation mode', STATUS )
         GO TO 99
      END IF
      IF ( STATUS .NE. SAI__OK ) GO TO 99

*  Construct a group of names using the NAME parameter as a basis,
*  possibly modifying the leader group.
      IF ( MODE .NE. 'FITS' ) THEN
         CALL CCD1_STRGR( 'NAME', LDRGRP, NSET, NSET, NAMGRP, NRET,
     :                    STATUS )
      END IF

*  ======================================================================
*  WCS section: Decide what new coordinate frame to add if any.
*  ======================================================================

*  Read framesets from an AST file if required; if this is done, they
*  will be used as the CCD_SET alignment frames.
      CALL CCD1_AFRD( 'ASTFILE', MXFSET, FSET, FSID, FITRTS, NFSET,
     :                STATUS )
      IF ( STATUS .EQ. PAR__NULL ) THEN
         ASTFL = .FALSE.
         CALL ERR_ANNUL( STATUS )
      ELSE
         ASTFL = .TRUE.
      END IF

*  Determine whether we are to mark the Current frame as the CCD_SET
*  alignment frame.
      JSET = AST__NOFRAME
      IF ( .NOT. ASTFL ) THEN
         CALL PAR_GET0L( 'ADDWCS', ADDWCS, STATUS )
         IF ( ADDWCS ) THEN
            JSET = AST__CURRENT
         END IF
      END IF

*  ======================================================================
*  Set construction section: go through input NDFs and write Set headers.
*  ======================================================================

*  Write output message header to user.
      CALL CCD1_MSG( ' ', ' ', STATUS )
      LINE = ' '
      LINE( 2: ) = 'Set name'
      LINE( 12: ) = 'Set index'
      LINE( 24: ) = 'NDF name'
      IF ( ADDWCS ) THEN
         LINE( 60: ) = 'CCD_SET domain'
      END IF
      CALL CCD1_MSG( ' ', LINE, STATUS )
      LINE( 2: ) = '--------'
      LINE( 12: ) = '---------'
      LINE( 24: ) = '--------'
      IF ( ADDWCS ) THEN
         LINE( 60: ) = '--------------'
      END IF
      CALL CCD1_MSG( ' ', LINE, STATUS )

*  Loop over Sets to be generated.
      K = 0
      DO I = 1, NSET

*  Get the NAME attribute for this Set, and write it to the user.
         CALL GRP_GET( NAMGRP, I, 1, NAME, STATUS )
         LINE = ' '
         LINE( 2: ) = NAME
         LINE( CHR_LEN( LINE ) + 1: ) = ':'
         CALL CCD1_MSG( ' ', ' ', STATUS )
         CALL CCD1_MSG( ' ', LINE, STATUS )

*  Search out NDFs to be placed in this Set.
         DIFER = .FALSE.
         K = 0
         DO J = 1, NNDF
            IF ( ISET( J ) .EQ. I ) THEN
               K = K + 1
               INDEX = SINDEX( J )

*  Get the NDF identifier and name.
               CALL NDG_NDFAS( INGRP, J, 'UPDATE', INDF, STATUS )
               CALL GRP_GET( INGRP, J, 1, NDFNAM, STATUS )

*  Initialise WCS data.
               JSET = AST__NOFRAME
               DOMAIN = ' '

*  Get WCS data from an AST file.
               IF ( ASTFL ) THEN

*  Get the WCS frameset.
                  CALL CCD1_GTWCS( INDF, IWCS, STATUS )

*  Map the FITS extension if it can be found.
                  NCARD = 0
                  CALL NDF_XSTAT( INDF, 'FITS', FITSEX, STATUS )
                  IF ( FITSEX ) THEN
                     CALL NDF_XLOC( INDF, 'FITS', 'READ', LOC, STATUS )
                     CALL DAT_MAPV( LOC, '_CHAR*80', 'READ', IPFITS,
     :                              NCARD, STATUS )
                  END IF

*  Go through the list of IDs to see if any match this NDF.
                  DO IF = 1, NFSET
                     CALL CCD1_NMID( FSID( IF ), INDEX, NCARD, IPFITS,
     :                               INDEX, MATCH, STATUS )
                     IF ( MATCH ) THEN
                        FSMAT = FSET( IF )
                        GO TO 2
                     END IF
                  END DO
 2                CONTINUE

*  No matching frameset was found from the AST file - inform user.
                  IF ( .NOT. MATCH ) THEN
                     CALL CCD1_MSG( ' ', '  No matching frameset in '//
     :               'AST file - Set coordinates not added', STATUS )
                  ELSE

*  Now we need to add the new frame to the WCS frameset.
*  Set the Current frame of the WCS frameset to the one which has the
*  same Domain as the Base frame of the read-in frameset.
                     DOMAIN = AST_GETC( FSMAT, 'Domain', STATUS )
                     CALL CCD1_ADFRM( IWCS, FSMAT, 'CCD_SET', 0D0,
     :                                FITRTS( I ), NCARD, IPFITS,
     :                                STATUS )
                  END IF

*  Release resources.
                  CALL AST_ANNUL( IWCS, STATUS )
                  CALL DAT_UNMAP( LOC, STATUS )
                  CALL DAT_ANNUL( LOC, STATUS )

*  Arrange to write a new CCD_SET frame as a copy of the Current 
*  frame of the WCS frameset.
               ELSE IF ( ADDWCS ) THEN
                  CALL CCD1_GTWCS( INDF, IWCS, STATUS )
                  DOMAIN = AST_GETC( IWCS, 'Domain', STATUS )
                  JSET = AST_GETI( IWCS, 'Current', STATUS )
                  CALL AST_ANNUL( IWCS, STATUS )
               END IF

*  Check that the domains are consistent for all NDFs.
               IF ( ADDWCS .OR. ASTFL ) THEN
                  IF ( K .EQ. 1 ) THEN
                     DMN1 = DOMAIN
                  ELSE
                     IF ( DOMAIN .NE. DMN1 ) DIFER = .TRUE.
                  END IF 
               END IF

*  Output a message to the user.
               LINE = ' '
               CALL CHR_ITOC( INDEX, LINE( 16: ), NCHAR )
               LINE( 24:58 ) = NDFNAM
               LINE( 60: ) = DOMAIN
               CALL CCD1_MSG( ' ', LINE, STATUS )

*  Write the Set information.
               CALL CCD1_SETWR( INDF, NAME, INDEX, JSET, STATUS )

*  Annul the NDF.
               CALL NDF_ANNUL( INDF, STATUS )
            END IF
         END DO

*  Warn if not all Current frame domains were the same.
         IF ( DIFER ) THEN
            CALL CCD1_MSG( ' ', ' ', STATUS )
            CALL CCD1_MSG( ' ', '  Warning: Not all CCD_SET'
     :      // ' frames have the same Domain', STATUS )
         END IF
      END DO
  
*  Error exit label.
 99   CONTINUE

*  Exit NDF context
      CALL NDF_END( STATUS )

*  Release groups.
      CALL CCD1_GRDEL( INGRP, STATUS )
      CALL CCD1_GRDEL( LDRGRP, STATUS )
      CALL CCD1_GRDEL( NAMGRP, STATUS )

*  If an error occurred, then report a contextual message.
      IF ( STATUS .NE. SAI__OK ) THEN
          CALL ERR_REP( 'MAKESET_ERR',
     ;                  'MAKESET: Failed to write Set header.', STATUS )
      END IF
      
      END
* $Id$
