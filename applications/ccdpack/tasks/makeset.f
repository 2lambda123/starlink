      SUBROUTINE MAKESET( STATUS )
*+
*  Name:
*     MAKESET

*  Purpose:
*     Group NDFs together into a Set.

*  Language:
*     Starlink Fortran 77

*  Type of Module:
*     ADAM A-task

*  Invocation:
*     CALL MAKESET( STATUS )

*  Arguments:
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Description:
*     This routine is used to group NDFs into a Set so that they can be
*     processed together.  It is usually used when you have CCD data from
*     a single exposure in multiple files because they were generated
*     from multiple CCDs in a mosaic camera, or from multiple amplifiers
*     in the same CCD, or both.  When this program is run on a group
*     of files, header information is written to each one so that
*     other CCDPACK routines will know about the relationship between
*     them.
*
*     MAKESET writes three items of data to each NDF:
*        1. The Set NAME (a string identifying all NDFs in the same Set)
*        2. The Set INDEX (an integer identifying the NDF's position 
*           within the Set)
*        3. The Set coordinate system (a coordinate frame in the NDF's 
*           WCS component with the Domain 'CCD_SET').
*
*     Normally by just presenting a list of NDF names to the program the
*     values of these attributes will be taken care of automatically,
*     but various options exist to tune how it is done.
*
*     By setting the ERASE parameter, MAKESET can be made to remove
*     all Set header information from a group of NDFs instead.

*  Usage:
*     makeset in

*  ADAM Parameters:
*     IN = LITERAL (Read)
*        A list of NDFs to group.  Normally, this should be a list of
*        the NDFs which will be grouped into a single Set.  The order
*        in which they are listed will normally determine their INDEX 
*        values (but see the INDICES parameter), so that the Sets 
*        should be generated by presenting NDFs in a consistent order; 
*        the one from CCD1 first, the one from CCD2 second...
*     INDICES( * ) = _INTEGER 
*        This parameter is a list of positive integers with SETSIZE
*        elements (SETSIZE will normally be the same as the number of
*        NDFs accessed by the IN parameter).  It indicates, for each
*        NDF in the list, what value the Set INDEX attribute should
*        take.  If set to the null value (!) then INDEX attributes
*        will be assigned in order (1, 2, 3, ...) for the members of 
*        each Set.
*        [!]
*     ERASE = _LOGICAL (Read)
*        If set TRUE, then instead of writing Set information to the 
*        specified NDFs, any existing Set information will be removed.
*        In this case most of the other parameters will be ignored.
*        No error is generated if an attempt to remove Set information
*        from an NDF which has none.
*        [FALSE]
*     LOGFILE = FILENAME (Read)
*        Name of the CCDPACK logfile.  If a null (!) value is given for
*        this parameter then no logfile will be written, regardless of
*        the value of the LOGTO parameter.
*
*        If the logging system has been initialised using CCDSETUP
*        then the value specified there will be used. Otherwise, the
*        default is "CCDPACK.LOG".
*        [CCDPACK.LOG]
*     LOGTO = LITERAL (Read)
*        Every CCDPACK application has the ability to log its output
*        for future reference as well as for display on the terminal.
*        This parameter controls this process, and may be set to any
*        unique abbreviation of the following:
*           -  TERMINAL  -- Send output to the terminal only
*           -  LOGFILE   -- Send output to the logfile only (see the
*                           LOGFILE parameter)
*           -  BOTH      -- Send output to both the terminal and the
*                           logfile
*           -  NEITHER   -- Produce no output at all
*
*        If the logging system has been initialised using CCDSETUP
*        then the value specified there will be used. Otherwise, the
*        default is "BOTH".
*        [BOTH]
*     NAME = LITERAL (Read)
*        The NAME parameter is used to determine the Set NAME attribute
*        which the grouped NDFs will have; all NDFs in the same Set
*        have the same NAME.  The value of this parameter should be
*        a group expression containing the same number of elements
*        as the number of Sets being created; if it contains
*        modification elements such as "*" they are applied to the
*        name of the first NDF in each Set.
*
*        The default value is "*", which means the Set NAME is the
*        same as the name of the NDF first entered into each Set.
*        There is rarely any reason to use any other value.
*        [*]
*     SETSIZE = _INTEGER (Read)
*        The number of NDFs in each set.  This will default initially 
*        to the number of NDFs in the IN list, but if set to a 
*        number less than that, then more than one set will be 
*        generated (the first SETSIZE from IN will become the first 
*        set, and so on).  If INDICES is specified it must have SETSIZE
*        elements, and Set INDEX assignment will wrap round when 
*        SETSIZE elements have been processed.  SETSIZE must be 
*        positive, and must be a divisor of the number of NDFs in 
*        the IN list, so that each distinct Set created by one 
*        invocation of MAKESET has to be the same size.

*  Examples:
*     makeset "data1,data2,data3,data4"
*        This will write Set information into the named NDFs; they will
*        all be given the same Set Name attribute ("data1") and will
*        be given the Set Index attributes 1, 2, 3 and 4 respectively.
*        Additionally, a new attached coordinate system with the Domain
*        "CCD_SET" will be added to the World Coordinate System (WCS)
*        component of each; this will be a copy of each one's Current
*        attached coordinate system.  If not all of them have the
*        same Current coordinate system when the program is run
*        (i.e. they do not all have the same Domain), then a warning
*        will be issued.
*     makeset * setsize=4
*        This will add Set information to all the NDFs in the current
*        directory, grouping them into Sets of 4 NDFs each.  If MAKESET
*        is to be used in this way however it must be done with care,
*        since it will group the files in the order in which they
*        are presented.  This depends on what order the "*" character
*        is expanded in, which depends on the details of the shell
*        that you are using.  Typically shells expand alphabetically,
*        so that if the directory contains files with the names 
*        d08.sdf, d09.sdf, d10.sdf, d11.sdf they will be presented
*        in that order, but files with the names d8.sdf, d9.sdf, 
*        d10.sdf, d11.sdf would be presented in the order d10.sdf, 
*        d11.sdf, d8.sdf, d9.sdf.  Unless you are confident of how
*        your shell behaves in this respect, then when using wildcards 
*        you should pay careful attention to the log output of 
*        MAKESET to check that the order is correct.  It is safest
*        to list Set members explicitly as in the previous example.
*     makeset "d1,d2,d3,e1,e2,e3" name=night1-* setsize=3
*        This will construct two Sets, which will be given Set Name
*        attributes of "night1-d1" and "night1-e1" respectively.
*        You might want to do this if you are going to use these
*        files along with other Sets generated from files with the
*        names the same as these.
*        Set Name attribute
*     makeset "d1,d3" indices=[1,3]
*        This will construct a Set of the two named NDFs, giving them
*        the Set Index attributes of 1 and 3 respectively.  This
*        might be necessary for comparison with 3-member sets if the
*        Index=2 one is absent in this case due to a loss of the data
*        file for some reason.
*     makeset * erase
*        All Set information (the .MORE.CCDPACK.SET headers and any
*        CCD_SET frames from the WCS component) are removed from all
*        of the NDFs in the current directory.

*  Behaviour of Parameters:
*     All parameters retain their current value as default. The
*     "current" value is the value assigned on the last run of the
*     application. If the application has not been run then the
*     "intrinsic" defaults, as shown in the parameter help, apply.
*
*     Retaining parameter values has the advantage of allowing you to
*     define the default behaviour of the application. The intrinsic
*     default behaviour of the application may be restored by using the
*     RESET keyword on the command line.
*
*     Certain parameters (LOGTO and LOGFILE) have global
*     values. These global values will always take precedence, except
*     when an assignment is made on the command line. Global values may
*     be set and reset using the CCDSETUP and CCDCLEAR commands.

*  Copyright:
*     Copyright (C) 2001 Central Laboratory of the Research Councils

*  Authors:
*     MBT: Mark Taylor (STARLINK)
*     {enter_new_authors_here}

*  History:
*     5-FEB-2001 (MBT):
*        Original version.
*     {enter_changes_here}

*  Bugs:
*     {note_any_bugs_here}

*-

*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants
      INCLUDE 'AST_PAR'          ! Standard AST constants
      INCLUDE 'GRP_PAR'          ! Standard GRP constants
      INCLUDE 'PRM_PAR'          ! PRIMDAT system constants
      INCLUDE 'CCD1_PAR'         ! Private CCDPACK constants

*  External References:
      INTEGER CHR_LEN
      EXTERNAL CHR_LEN           ! Used length of string

*  Status:
      INTEGER STATUS             ! Global status

*  Local Variables:
      INTEGER I                  ! Loop variable
      INTEGER INDEX              ! Set INDEX attribute
      INTEGER INDDFL( CCD1__MXNDF ) ! Default values for INDXS
      INTEGER INDXS( CCD1__MXNDF ) ! Index values for successive NDFs in Set
      INTEGER INDF               ! NDF identifier
      INTEGER INGRP              ! GRP identifier for input NDFs
      INTEGER IWCS               ! AST identifier for WCS frameset
      INTEGER J                  ! Loop variable
      INTEGER K                  ! Offset into input NDF list
      INTEGER LDRGRP             ! GRP identifier for NDF Set leader names
      INTEGER NAMGRP             ! GRP identifier for Set NAME attributes
      INTEGER NCHAR              ! Number of characters in conversion
      INTEGER NNDF               ! Number of input NDFs
      INTEGER NRET               ! Number of names returned (dummy)
      INTEGER NSET               ! Number of Sets to generate
      INTEGER NTRY               ! Number of tries for parameter entry
      INTEGER SETSIZ             ! Number of NDFs in each Set
      LOGICAL DIFER              ! Do some NDFs have different Current domain?
      LOGICAL ERASE              ! Are we erasing Set information?
      CHARACTER * ( AST__SZCHR ) DMN1 ! Domain of Set leader Current frame
      CHARACTER * ( AST__SZCHR ) DMN ! Domain of NDF Current frame
      CHARACTER * ( GRP__SZNAM ) NAME ! Set NAME attribute
      CHARACTER * ( GRP__SZNAM ) NDFNAM ! Name of NDF
      CHARACTER * ( CCD1__BLEN ) LINE ! Buffer for character output

*.

*  Check inherited global status.
      IF ( STATUS .NE. SAI__OK ) RETURN

*  Start up log file system, write introduction.
      CALL CCD1_START( 'MAKESET', STATUS )

*  Begin a new NDF context.
      CALL NDF_BEGIN

*  Access an NDG group containing a list of NDF names.
      CALL CCD1_NDFGL( 'IN', 1, CCD1__MXNDF, INGRP, NNDF, STATUS )

*  Do we want to erase Set information instead of add it?
      ERASE = .FALSE.
      CALL PAR_GET0L( 'ERASE', ERASE, STATUS )

*  If we are erasing Set information, we can do so directly.
      IF ( ERASE ) THEN
         CALL CCD1_MSG( ' ', ' ', STATUS )
         CALL CCD1_MSG( ' ', '  Erasing Set information from NDFs:',
     :                  STATUS )
         DO I = 1, NNDF

*  Write message to the user.
            CALL GRP_GET( INGRP, I, 1, NDFNAM, STATUS )
            CALL MSG_SETC( 'NDF', NDFNAM )
            CALL CCD1_MSG( ' ', '     ^NDF', STATUS )

*  Get the NDF identifier.
            CALL NDG_NDFAS( INGRP, I, 'UPDATE', INDF, STATUS )

*  Remove the Set information.
            CALL CCD1_SETRM( INDF, STATUS )
         END DO

*  No more work is required - skip to the end.
         GO TO 99
      END IF

*  Get the number of NDFs per Set.  It dynamically defaults to the 
*  number of NDFs in the IN group.  It must divide into the number of
*  NDFs in the input group.
      NTRY = 0
 1    CONTINUE
      CALL PAR_DEF0I( 'SETSIZE', NNDF, STATUS )
      CALL PAR_GET0I( 'SETSIZE', SETSIZ, STATUS )
      IF ( MOD( NNDF, SETSIZ ) .NE. 0 .OR. SETSIZ .LT. 0 ) THEN
         IF ( NTRY .LT. 5 ) THEN
            CALL MSG_SETI( 'NNDF', NNDF )
            CALL MSG_SETI( 'SETSIZ', SETSIZ )
            CALL MSG_OUT( ' ', '  Number of input NDFs ^NNDF not '
     :                 // 'divisible by SETSIZE ^SETSIZ - try again.',
     :                    STATUS )
            CALL PAR_CANCL( 'SETSIZ', STATUS )
            NTRY = NTRY + 1
            GO TO 1
         ELSE
            STATUS = SAI__ERROR
            CALL ERR_REP( 'MAKESET_BADSIZE',
     :                    'MAKESET: Bad SETSIZE parameter.', STATUS )
            GO TO 99
         END IF
      END IF

*  Calculate the number of Sets we will be generating.
      NSET = NNDF / SETSIZ

*  Get a list of integers to use for the Set INDEX attributes.  If null,
*  use an array 1,2,3..SETSIZ.
      IF ( STATUS .NE. SAI__OK ) GO TO 99
      CALL PAR_EXACI( 'INDICES', SETSIZ, INDXS, STATUS )
      CALL CCD1_GISEQ( 1, 1, SETSIZ, INDDFL, STATUS )
      CALL PAR_GDR1I( 'INDICES', SETSIZ, INDDFL, 1, VAL__MAXI, .TRUE.,
     :                INDXS, STATUS )

*  Construct a group containing the names of "leader" NDFs, i.e. the
*  first one from each Set which will be generated.
      CALL GRP_NEW( 'CCD:LEADERS', LDRGRP, STATUS )
      DO I = 1, NNDF, SETSIZ
         CALL GRP_GET( INGRP, I, 1, NAME, STATUS )
         CALL GRP_PUT( LDRGRP, 1, NAME, 0, STATUS )
      END DO

*  Construct a group of names using the NAME parameter as a basis,
*  possibly modifying the leader group.
      CALL CCD1_STRGR( 'NAME', LDRGRP, NSET, NSET, NAMGRP, NRET,
     :                 STATUS )

*  Write output message header to user.
      CALL CCD1_MSG( ' ', ' ', STATUS )
      LINE = ' '
      LINE( 2: ) = 'Set name'
      LINE( 12: ) = 'Set index'
      LINE( 24: ) = 'NDF name'
      LINE( 60: ) = 'CCD_SET domain'
      CALL CCD1_MSG( ' ', LINE, STATUS )
      LINE( 2: ) = '--------'
      LINE( 12: ) = '---------'
      LINE( 24: ) = '--------'
      LINE( 60: ) = '--------------'
      CALL CCD1_MSG( ' ', LINE, STATUS )

*  Loop over Sets to be generated.
      K = 0
      DO I = 1, NSET

*  Get the NAME attribute for this Set, and write it to the user.
         CALL GRP_GET( NAMGRP, I, 1, NAME, STATUS )
         LINE = ' '
         LINE( 2: ) = NAME
         LINE( CHR_LEN( LINE ) + 1: ) = ':'
         CALL CCD1_MSG( ' ', ' ', STATUS )
         CALL CCD1_MSG( ' ', LINE, STATUS )

*  Loop over NDFs to be placed in this Set.
         DIFER = .FALSE.
         DO J = 1, SETSIZ
            K = K + 1
            INDEX = INDXS( J )

*  Get the NDF identifier and name.
            CALL NDG_NDFAS( INGRP, K, 'UPDATE', INDF, STATUS )
            CALL GRP_GET( INGRP, K, 1, NDFNAM, STATUS )

*  Get the name of the Current domain.
            CALL CCD1_GTWCS( INDF, IWCS, STATUS )
            DMN = AST_GETC( IWCS, 'Domain', STATUS )
            IF ( J .EQ. 1 ) THEN
               DMN1 = DMN
            ELSE
               IF ( DMN .NE. DMN1 ) DIFER = .TRUE.
            END IF 
            CALL AST_ANNUL( IWCS, STATUS )

*  Output a message to the user.
            LINE = ' '
            CALL CHR_ITOC( INDEX, LINE( 16: ), NCHAR )
            LINE( 24:58 ) = NDFNAM
            LINE( 60: ) = DMN
            CALL CCD1_MSG( ' ', LINE, STATUS )

*  Write the Set information.
            CALL CCD1_SETWR( INDF, NAME, INDEX, AST__CURRENT, STATUS )

*  Annul the NDF.
            CALL NDF_ANNUL( INDF, STATUS )
         END DO

*  Warn if not all Current frame domains were the same.
         IF ( DIFER ) THEN
            CALL CCD1_MSG( ' ', ' ', STATUS )
            CALL CCD1_MSG( ' ', '  Warning: Not all CCD_SET frames have'
     :                  // ' the same Domain', STATUS )
         END IF
      END DO
  
*  Error exit label.
 99   CONTINUE

*  Exit NDF context
      CALL NDF_END( STATUS )

*  Release groups.
      CALL CCD1_GRDEL( INGRP, STATUS )
      CALL CCD1_GRDEL( LDRGRP, STATUS )
      CALL CCD1_GRDEL( NAMGRP, STATUS )

*  If an error occurred, then report a contextual message.
      IF ( STATUS .NE. SAI__OK ) THEN
          CALL ERR_REP( 'MAKESET_ERR',
     ;                  'MAKESET: Failed to write Set header.', STATUS )
      END IF
      
      END
* $Id$
