#!/bin/csh
#+
#  Name:
#     SETEXERCISE

#  Purpose:
#     Tests Set-specific aspects of CCDPACK functionality.

#  Language:
#     C shell

#  Description:
#     The script creates a series of test frames using CCDGENERATE. It
#     then executes various of the CCDPACK Atasks simulating a
#     reduction sequence. Intermediary results are displayed (if requested)

#  Authors:
#     MBT: Mark Taylor (STARLINK)
#     {enter_new_authors_here}

#  History:
#     21-FEB-2001 (MBT):
#        Original version (based on ccdexercise and wcsexercise).
#-
#
      onintr EXIT
      set null = "\!"
      set abort = "\!\!"

#  Initialise CCDPACK within this shell.
      if ( $?CCDPACK_DIR ) then 
         if ( -e $CCDPACK_DIR/ccdpack.csh ) then 
            source $CCDPACK_DIR/ccdpack.csh
         else 
            exit 1
         endif
      endif

#  Initialise KAPPA within this shell.
      if ( $?KAPPA_DIR ) then
         if ( -e $KAPPA_DIR/kappa.csh ) then
            source $KAPPA_DIR/kappa.csh
         else
            exit 1
         endif
      endif

#  Establish the current directory as ADAM_USER and clear 
#  any global values already existing 
      setenv ADAM_USER $cwd
      if ( -e ${ADAM_USER}/GLOBAL.sdf ) then
	 ccdclear accept 
      endif

#  Does the user want to see image display activity?
      echo -n "DISPLAY - Display device (xw for xwindows; ! for none) > "
      set device = $<
      if ( "$device" == "$abort" || "$device" == "" ) then
         goto EXIT
      else
         if ( "$device" == "$null" ) then
            set device = "NONE"
         endif
      endif

#  Set a file extension for generating data.
      if ( $?CCDPACK_EXT ) then 
         set exten =  $CCDPACK_EXT
      else 
         set exten = ".sdf"
      endif

#  Do graphics device initialisation if necessary.
      if ( "$device" != "NONE" ) then
         idset $device \\
         gdset $device \\
         gdclear \\
         paldef \\
      endif

#  Do the "device" setup without an ARD file.
      ccdsetup \
         bounds='[1,2,56,64]' \
         extent='[3,55,1,128]' \
	 adc=2 \
	 rnoise=10.0 \
         logto=both \
	 logfile=ccdtest.log \
	 preserve=true \
	 direction=x \
         reset accept

#  Try to locate the object specification file. If this does not exist
#  then exit.
      set objfile = ccdtest2_obj.dat
      set astfile = ccdtest.ast
      foreach file ( $objfile $astfile )
         if ( -e $file ) then
            'rm' $file
         endif
         if ( -e $CCDPACK_DIR/$file ) then
            cp $CCDPACK_DIR/$file ./
         else
            echo "Cannot locate file $CCDPACK_DIR/$file"
            echo "- test terminated."
            exit
         endif
      end

#  Create the test data: three Sets of three NDFs each.
      ccdgenerate \
         nseq=3 \
         file=$objfile \
         type=$exten \
         pixels='[64,128]' \
         origins='[19,-101,-49,-101,297,19]' \
         angles='[0,0,270]' \
         reduced=false \
         container=true \
         dataname=data-a \
         biasname=bias-a \
         ffname=ff-a \
         seed=32767 \
         reset accept
      ccdgenerate \
         nseq=3 \
         file=$objfile \
         type=$exten \
         pixels='[64,128]' \
         origins='[163,210,95,210,-15,163]' \
         angles='[180,180,90]' \
         reduced=false \
         container=true \
         dataname=data-b \
         biasname=bias-b \
         ffname=ff-b \
         seed=90909 \
         reset accept
      ccdgenerate \
         nseq=3 \
         file=$objfile \
         type=$exten \
         pixels='[64,128]' \
         origins='[20,-51,-49,-51,247,20]' \
         angles='[0,0,270]' \
         reduced=false \
         container=true \
         dataname=data-c \
         biasname=bias-c \
         ffname=ff-c \
         seed=2112123 \
         reset accept

#  Give the various NDFs different data types.  This is just to try to
#  confuse subsequent tasks.
         settype \
            ndf='"data-{a,b,c}"' \
            type=_double \
            reset accept
         settype \
            ndf='"ff-{a,b,c}"' \
            type=_uword \
            reset accept
         settype \
            ndf='"bias-{a,b,c}"' \
            type=_integer \
            reset accept

#  Construct Sets.
      makeset \
         in='"data-?,ff-?,bias-?"' \
         mode=container \
         addwcs=true \
         reset accept

#  Show the Set groupings.
      showset \
         in='"data-?,ff-?,bias-?"' \
         setless=false \
         sortby=name \
         reset \
         accept

#  If display capability is enabled then display the data frames.
      if ( "$device" != "NONE" ) then
         echo " "
         echo "  Displaying raw target frames."
         echo " "
         picdef mode=array xpic=3 ypic=3 prefix=a accept
         lutheat accept
         picsel label=a1 accept
         display data-a.i1 percentiles='[2,98]' accept
         picsel label=a2 accept; display data-a.i2 accept
         picsel label=a3 accept; display data-a.i3 accept
         picsel label=a4 accept; display data-b.i1 accept
         picsel label=a5 accept; display data-b.i2 accept
         picsel label=a6 accept; display data-b.i3 accept
         picsel label=a7 accept; display data-c.i1 accept
         picsel label=a8 accept; display data-c.i2 accept
         picsel label=a9 accept; display data-c.i3 accept
      endif
	 
#  Make a bias frame.
      makebias \
         in='bias-?' \
	 out=master_bias \
         useset \
         reset \
	 accept

#  Debias all frames (including flatfields)
      debias \
         in='"data-?,ff-?"' \
	 out='debias_*' \
         useset \
         reset accept

#  Display all the debiassed frames.
      if ( "$device" != "NONE" ) then
         gdclear accept
         picdef mode=array xpic=3 ypic=3 prefix=a accept
         lutheat accept
         picsel label=a1 accept; display debias_data-a.i1 accept
         picsel label=a2 accept; display debias_data-a.i2 accept
         picsel label=a3 accept; display debias_data-a.i3 accept
         picsel label=a4 accept; display debias_data-b.i1 accept
         picsel label=a5 accept; display debias_data-b.i2 accept
         picsel label=a6 accept; display debias_data-b.i3 accept
         picsel label=a7 accept; display debias_data-c.i1 accept
         picsel label=a8 accept; display debias_data-c.i2 accept
         picsel label=a9 accept; display debias_data-c.i3 accept
      endif

#  Create a flat field master
      makeflat \
         in='debias_ff-?' \
	 out=master_flat \
         useset \
         reset \
	 accept

#  Display the master flatfield.
      if ( "$device" != "NONE" ) then 
         gdclear accept
         picdef mode=array xpic=3 ypic=1 prefix=a accept
         lutheat accept
         picsel label=a1 accept; display master_flat.i1 accept
         picsel label=a2 accept; display master_flat.i2 accept
         picsel label=a3 accept; display master_flat.i3 accept
      endif

#  Flatfield all the data frames
      flatcor \
         in='debias_data-?' \
	 out='*|debias|reduced|' \
         useset \
         reset accept

      if ( "$device" != "NONE" ) then
         gdclear accept
         picdef mode=array xpic=3 ypic=3 prefix=a accept
         lutheat accept
         picsel label=a1 accept; display reduced_data-a.i1 accept
         picsel label=a2 accept; display reduced_data-a.i2 accept
         picsel label=a3 accept; display reduced_data-a.i3 accept
         picsel label=a4 accept; display reduced_data-b.i1 accept
         picsel label=a5 accept; display reduced_data-b.i2 accept
         picsel label=a6 accept; display reduced_data-b.i3 accept
         picsel label=a7 accept; display reduced_data-c.i1 accept
         picsel label=a8 accept; display reduced_data-c.i2 accept
         picsel label=a9 accept; display reduced_data-c.i3 accept
      endif

#  Now proceed to test out some alignment functionality.

#  First we will resample the reduced frames into different coordinate
#  systems - the a-set is left alone, the b-set is shifted so that
#  its pixel coordinates are entirely outside the range of its grid
#  coordinates and the c-set is magnified.  The purpose of this is
#  solely to provide the subsequent tasks with more opportunities to fail.
      ndfcopy \
         in='reduced_data-a' \
         out='*|reduced_data|xdata|' \
         reset accept
      wcsedit \
         in='"reduced_data-b.i1,reduced_data-b.i2"' \
         mode=add \
         frame=pixel \
         maptype=linear \
         coeffs='[500,1,0,1000,0,1]' \
         domain=shifted \
         reset accept
      wcsedit \
         in='"reduced_data-b.i3"' \
         mode=add \
         frame=pixel \
         maptype=linear \
         coeffs='[500,1,0,-1000,0,1]' \
         domain=shifted \
         reset accept
      tranndf \
         in='reduced_data-b' \
         out='*|reduced_data|xdata|' \
         conserve=false \
         method=nearest \
         reset accept
      wcsedit \
         in=xdata-b \
         mode=current \
         frame=ccd_gen \
         reset accept
      pixdupe \
         in='reduced_data-c' \
         out='*|reduced_data|xdata|' \
         expand=2 \
         reset accept

#  Give them different data types as well for the same reason.
      settype \
         ndf=xdata-a \
         type=_uword \
         reset accept
      settype \
         ndf=xdata-b \
         type=_integer \
         reset accept
      settype \
         ndf=xdata-c \
         type=_double \
         reset accept

#  Locate all the objects on the frames
      echo " " 
      echo "  The first stage of the automated registration process is"
      echo "  to detect the positions of objects (stars and galaxies)."
      echo "  "
      findobj \
        in='"xdata-[abc]"' \
	outlist='*.find' \
        percentile=95 \
	accept
      if ( "$device" != "NONE" ) then

#  Display the objects located.
         picsel label=a1 accept
         plotlist inlist='xdata-a.i1' palnum=4 mtype=23 accept
         picsel label=a2 accept; plotlist inlist='xdata-a.i2' accept
         picsel label=a3 accept; plotlist inlist='xdata-a.i3' accept
         picsel label=a4 accept; plotlist inlist='xdata-b.i1' accept
         picsel label=a5 accept; plotlist inlist='xdata-b.i2' accept
         picsel label=a6 accept; plotlist inlist='xdata-b.i3' accept
         picsel label=a7 accept; plotlist inlist='xdata-c.i1' accept
         picsel label=a8 accept; plotlist inlist='xdata-c.i2' accept
         picsel label=a9 accept; plotlist inlist='xdata-c.i3' accept
      endif

#  Determine matches between the positions.
      findoff \
         inlist='"xdata-[abc]"' \
	 ndfnames=true \
         usewcs=true \
         restrict=true \
         useset=true \
	 outlist='*.off' \
	 accept

#  Display the objects located.
      if ( "$device" != "NONE" ) then
         picsel label=a1 accept
         plotlist inlist='xdata-a.i1' \
                  palnum=3 mtype=-1 thick=2 msize=1.5 accept
         picsel label=a2 accept; plotlist inlist='xdata-a.i2' accept
         picsel label=a3 accept; plotlist inlist='xdata-a.i3' accept
         picsel label=a4 accept; plotlist inlist='xdata-b.i1' accept
         picsel label=a5 accept; plotlist inlist='xdata-b.i2' accept
         picsel label=a6 accept; plotlist inlist='xdata-b.i3' accept
         picsel label=a7 accept; plotlist inlist='xdata-c.i1' accept
         picsel label=a8 accept; plotlist inlist='xdata-c.i2' accept
         picsel label=a9 accept; plotlist inlist='xdata-c.i3' accept
      endif

#  Create registration frames.
      register \
         inlist='"xdata-[abc]"' \
         fittype=2 \
         useset=true \
         accept reset

#  Take a look at the alignment.
      if ( "$device" != "NONE" ) then
         gdclear
         bounds \
            in='"xdata-[abc]"' \
            labmode='"index,dot"' \
            penrot=true \
            useset=true \
            clear \
            reset accept
         plotlist \
            inlist='"xdata-[abc]"' \
            reset accept
      endif

#  Resample the data.
      echo " "
      echo "  The reduced NDFs will now be resampled to the same coordinate"
      echo "  system. After this is performed they can then be combined"
      echo "  (after determining normalising scale and zero points which "
      echo "  take into account any variations in sky transparency and "
      echo "  exposure time) into a single frame which shows the complete"
      echo "  data coverage for the target area."
      echo " "
      tranndf \
         in='"xdata-[abc]"' \
         out='*|xdata|rxdata|' \
         conserve=false \
         accept

#  Normalise it.
      echo " "
      echo "  Normalising and combining the aligned datasets."
      echo " "
      makemos \
         in='"rxdata-[abc]"' \
	 scale=false \
	 zero=false \
	 out=mosaic \
	 accept

#  Display the final mosaic.
      if ( "$device" != "NONE" ) then 
         echo " "
         echo "  Displaying the final mosaic."
         echo " "
         gdclear \\
         display \
           in=mosaic \
           mode=percentiles \
           percentiles='[2,98]' \
           accept
      endif

#  Exercise is completed.
      ccdnote \
         '"Exercise completed"' \
	 accept

#  Exit label
EXIT:
      exit
# $Id$
