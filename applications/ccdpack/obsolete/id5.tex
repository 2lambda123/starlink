\documentstyle{article} 
\pagestyle{myheadings}

%------------------------------------------------------------------------------
\newcommand{\irasdoccategory}  {IRAS90 Document}
\newcommand{\irasdocinitials}  {ID}
\newcommand{\irasdocnumber}    {5.7}
\newcommand{\irasdocauthors}   {D.S. Berry}
\newcommand{\irasdocdate}      {3rd February, 1991.}
\newcommand{\irasdoctitle}     {IRG: NDF Groups access subroutine package}
%------------------------------------------------------------------------------

\newcommand{\irasdocname}{\irasdocinitials /\irasdocnumber}
\renewcommand{\_}{{\tt\char'137}}     % re-centres the underscore
\markright{\irasdocname}
\setlength{\textwidth}{160mm}
\setlength{\textheight}{240mm}
\setlength{\topmargin}{-5mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\setlength{\unitlength}{1mm}

%------------------------------------------------------------------------------
% Add any \newcommand or \newenvironment commands here
%------------------------------------------------------------------------------

\begin{document}
\thispagestyle{empty}
SCIENCE \& ENGINEERING RESEARCH COUNCIL \hfill \irasdocname\\
RUTHERFORD APPLETON LABORATORY\\
{\large\bf IRAS90\\}
{\large\bf \irasdoccategory\ \irasdocnumber}
\begin{flushright}
\irasdocauthors\\
\irasdocdate
\end{flushright}
\vspace{-4mm}
\rule{\textwidth}{0.5mm}
\vspace{5mm}
\begin{center}
{\Large\bf \irasdoctitle}
\end{center}
\vspace{5mm}

\setlength{\parskip}{0mm}
\tableofcontents
\setlength{\parskip}{\medskipamount}
\markright{\irasdocname}

\section {Introduction}

If an application prompts the user for an NDF using the facilities of the NDF\_ 
system (see SUN/33), the user may only reply with the name of a single NDF. Some
applications allow many input NDFs to be specified and the need to
type in every NDF name explicitly each time the program is run can become time
consuming. The IRG package provides a means of giving the user the
ability to specify a list (or ``Group'') of NDFs as a reply to a single prompt
for an ADAM parameter. 

A major limitation of the current implementation of IRG is that each NDF
accessed by IRG must be the top level object in a .SDF container file. NDFs
which form components of a higher level structure cannot be handled by IRG.

\section {Interaction Between IRG and IRH}
IRG uses the facilities of the IRH package (see ID/9), and users of IRG should
be familiar with the format of group expressions and names described in ID/9.
Applications using the IRG system will normally also make calls to various IRH
routines. The {\em group identifiers} created by the IRG system to distinguish
between different groups can be passed to any IRH routine, as well as any IRG
routine. However, the reverse is not true. Group identifiers created by IRH 
cannot be directly used in any IRG routine except IRG\_GIN. This routine 
modifies a group created by IRH so that it {\em can} be used by all IRG 
routines.

\section {General overview of the IRG\_ system}
As a broad outline, applications use the IRG\_ package as follows:

\begin{enumerate}

\item A call is made to IRG\_GROUP which causes the user to be prompted for a
single ADAM parameter. This parameter is of type ``LITERAL'', {\em not} NDF. The
user replies with an NDF ``group expression'' (see ID/9), which contains
information identifying a group of {\em existing} NDFs to be used as inputs by
the application. For instance, the group expression may be 
\begin{verbatim}
     M51_B3S1_DS,M51_B3S2_DS,M51_B3S2%_DS,^FILES.LIS
\end{verbatim}
This is a complicated example, probably more complicated than would be used in
practice, but it highlights the facilities of the IRH and IRG packages, e.g. wild
cards (``\%'' or ``$*$''), lists of files, or indirection through a text file
(``\verb+^+'').

The IRG\_GROUP routine produces a list of explicit NDF names, which are stored
internally within the IRH system. 

\item What happens next depends on the application, but a common example may be
the initiation of a DO loop to loop through the input NDFs (IRG\_GROUP returns
the total number of NDF names in the group). 

\item To accessing a particular NDF, the application calls routine IRG\_NDFEX
supplying an index, $n$, within the group (i.e $n$ is an integer in the range 1
to the group size returned by IRG\_GROUP). IRG\_NDFEX returns an NDF identifier to
the $n$th NDF in the group. This identifier can then be used to access the NDF
in the normal manner using the NDF\_ routines (SUN 33). The identifier should be
annulled when it is no longer needed using NDF\_ANNUL.

\item Once the application has finished processing the NDF group, it calls 
IRH\_ANNUL which releases all resources reserved by the group.

\item Routine IRG\_GROUP can also be used to append a list of NDF names 
obtained from the environment, to a previously defined group.

\item Each group of NDFs is classified as being either an {\em input} group or 
an {\em output} group. IRG\_GROUP produces {\em input} groups 
which can only contain {\em previously existing} NDFs. NDF identifiers for 
members of such groups are obtained using IRG\_NDFEX.

The routine IRG\_CREAT produces an {\em output} group, containing the names of 
NDFs which are to be created by the application. The routine IRG\_NDFCR will 
create a new NDF with a name given by a group member, and returns an NDF 
identifier to it. Routine IRG\_NDFPR creates a new NDF by propagation from a 
previously existing NDF, in a similar manner to the NDF routine NDF\_PROP (see 
SUN/33).

The names of output NDFs given by users usually relate to the input NDF names.
When IRG\_CREAT is called, it creates a group of NDF names either by modifying
all the names in a specified input group using a ``modification element'' (see
ID/9), or by getting a list of new names from the user. 

\item Applications which produce a group of output NDFs could also produce a
text file holding the names of the output NDFs. Such a file can be used as input
to the next application, using the indirection facility. A text file listing of
all the NDFs in a group can be produced by routine IRH\_LIST. 

\item If an application needs to remove a name (or a contiguous set of names) 
from a group, it can call IRH\_SECT. This routine creates a new group by copying
all the names from an input group, excluding a set of names specified by the 
calling routine.

\end{enumerate}

\section {Processing of Existing NDF Names}
When IRG\_GROUP is called, a check is made that each supplied name corresponds
to an existing .SDF file containing an HDS structure of type ``NDF''. If any of
the specified NDFs cannot be accessed, an error is reported but the returned
group will contain any specified NDFs which {\em could} be accessed. 

Group expressions may contain elements which include the wild card tokens
``$*$'' or ``\%''. These are interpreted in the usual DCL manner, thus an
element ``M51\_B\%S4'' will add to the group the names of all .SDF files which
match the template, allowing any single character to replace the ``\%''
character. An element ``M51\_B1S$*$'' will add to the group the names of all
.SDF files which match the template, allowing any string of characters to
replace the ``$*$'' character. 

Each name actually stored in the group is expanded into an SDF file
specification including disk, directory, and file name, but no file type or 
version number. The stored names always correspond to file with type ``.SDF'', 
and the most recent version is always used.


\section {Processing of NDF Names Created by Modification Elements}
IRG\_CREAT can create an output group by modifying each name within a specified 
input group, according to the rules described for modification elements in ID/9.
IRG adds some further rules to the use of modification elements. Specifically,
\begin{itemize}
\item The ``$*$'' token represents just the file {\em name} field out of the 
total file specification.
\item The user may include further fields for the output file specifications 
within the prefix and suffix strings which lie on each side of the ``$*$'' 
token. These fields will override the corresponding fields values from the input 
file specification. If any field of the file specification is left unspecified 
by the suffix and prefix, then it defaults to the value from the input file 
specification.
\item File types and version numbers are removed from all output file specification.
\end{itemize}

Thus, if the input group consisted of the single file 
DISK\$FRED:[BLOGGS]DATA, the following modification elements would 
produce the described output group:

\begin{itemize}
\item The element ``$*$'' would generate the name DISK\$FRED:[BLOGGS]DATA.
\item The element ``[BLOGGS.DATA\_DIR]$*$'' would generate the name 
DISK\$FRED:[BLOGGS.DATA\_DIR]DATA.
\item The element ``DISK\$BERT:$*$/D/ZZ/'' would generate the name 
DISK\$BERT:[BLOGGS]ZZATA.
\end{itemize}

\section {User-specified NDF Sections}
Users can append ``section specifiers'' to supplied NDF names in the manner
described in SUN/33. These section specifiers are stored in the group in the
same format in which they are supplied. Thus if an NDF name is retrieved using
routine IRH\_GET it {\em may} be terminated with such a section specifier. The
IRG equivalent to this routine (IRG\_GET) parses the NDF name stored at a given
index within a group into its separate fields (device, directory, container file
and section specification).

If a supplied name containing wild-cards is terminated by a section specifier, 
than all the NDF names which match the wild-card template are stored in the 
group, and each such name has the supplied section specifier appended to it.
Thus the element ``CENA\_B\%(,10)'' could give rise to the names 
``CENA\_B1(,10)'', ``CENA\_B2(,10)'', ``CENA\_B3(,10)'' and ``CENA\_B4(,10)''.

Names within output groups (those created by IRG\_CREAT for instance) never
contain section specifiers. If a group {\em which does} contain section
specifiers is given as the basis for modification elements within IRG\_CREAT,
then the section specifiers are ignored. Similarly, any section specifiers
supplied by the user are ignored (no error is reported). 

An NDF identifier returned by IRG\_NDFEX will refer to an NDF section if the
corresponding NDF name contains a section specifier, otherwise it will refer to
the base NDF. NDF identifiers returned by IRG\_NDFPR and IRG\_NDFCR always refer
to a base NDF. 

\section {Linking with IRG}
To link an application with IRG, the linker options file IRG\_LINK should be
included in the linker command line. This logical name can be made available by
executing the START.COM procedure within IRG\_DIR. For example, to link an ADAM
application called PROG with the IRG library, the commands 

\begin{verbatim}
$ @IRG_DIR:START
$ ALINK PROG, IRG_LINK/OPT 
\end{verbatim}

should be used. This also links PROG with IRH, IRM, AIF, and RIO/FIO.
This linking procedure may change when development of IRAS90 is complete. The
procedure IRG\_DIR:START.COM also defines logical names defining the include
files IRG\_PAR, IRG\_ERR, IRH\_PAR and IRH\_ERR, and so should be executed
before compiling any routines which include them. 

\appendix
% Command for displaying routines in routine lists:
% =================================================

\newcommand{\noteroutine}[2]{{\small \bf #1} \\
                              \hspace*{3em} {\em #2} \\[1.5ex]}

\section {Routine descriptions}

\subsection {Routine list}

\noteroutine{IRG\_CREAT(PARAM,GID0,TERMC,GID,SIZE,ADDED,TERM,STATUS)}
   {Create a group containing names of output NDFs to be created.}
\noteroutine{IRG\_GET(GID,INDEX,DEVICE,DIRN,NAME,SLICE,AMODE,OUT,STATUS)}
   {Get information describing an NDF name stored at a given index.}
\noteroutine{IRG\_GIN(GID,OUT,AMODE,STATUS)}
   {Imports an IRH group into the IRG system.}
\noteroutine{IRG\_GROUP(PARAM,TERMC,AMODE,GID,SIZE,ADDED,TERM,STATUS)}
   {Create a group containing names of existing NDFs.}
\noteroutine{IRG\_NDFCR(GID,INDEX,FTYPE,NDIM,LBND,UBND,INDF,LOC,STATUS)}
   {Create an NDF and return an NDF identifier for it.}
\noteroutine{IRG\_NDFEX(GID,INDEX,INDF,LOC,STATUS)}
   {Return an NDF identifier for an existing NDF.}
\noteroutine{IRG\_NDFPR(GID,INDEX,INDF1,CLIST,INDF2,LOC,STATUS)}
   {Create an NDF by propagation from an existing NDF and return an NDF 
identifier for it.}

\subsection {Full Routine Specifications}
\label {SEC:FULLSPEC}
\newlength{\sstbannerlength}
\newlength{\sstcaptionlength}
\font\ssttt=CMTT10 scaled 1095
\newcommand{\sstroutine}[3]{
   \goodbreak
   \rule{\textwidth}{0.5mm}
   \vspace{-7ex}
   \newline
   \settowidth{\sstbannerlength}{{\Large {\bf #1}}}
   \setlength{\sstcaptionlength}{\textwidth}
   \addtolength{\sstbannerlength}{0.5em} 
   \addtolength{\sstcaptionlength}{-2.0\sstbannerlength}
   \addtolength{\sstcaptionlength}{-4.45pt}
   \parbox[t]{\sstbannerlength}{\flushleft{\Large {\bf #1}}}
   \parbox[t]{\sstcaptionlength}{\center{\Large #2}}
   \parbox[t]{\sstbannerlength}{\flushright{\Large {\bf #1}}}
   \begin{description}
      #3
   \end{description}
}

\newcommand{\sstdescription}[1]{\item[Description:] #1}

\newcommand{\sstusage}[1]{\item[Usage:] \mbox{} \\[1.3ex] {\ssttt #1}}

\newcommand{\sstinvocation}[1]{\item[Invocation:]\hspace{0.4em}{\tt #1}}

\newcommand{\sstarguments}[1]{
   \item[Arguments:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

\newcommand{\sstreturnedvalue}[1]{
   \item[Returned Value:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

\newcommand{\sstparameters}[1]{
   \item[Parameters:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

\newcommand{\sstexamples}[1]{
   \item[Examples:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

\newcommand{\sstsubsection}[1]{\item[{#1}] \mbox{} \\}

\newcommand{\sstexamplesubsection}[1]{\item[{\ssttt #1}] \mbox{} \\}

\newcommand{\sstnotes}[1]{\item[Notes:] \mbox{} \\[1.3ex] #1}

\newcommand{\sstdiytopic}[2]{\item[{\hspace{-0.35em}#1\hspace{-0.35em}:}] \mbox{} \\[1.3ex] #2}

\newcommand{\sstimplementationstatus}[1]{
   \item[{Implementation Status:}] \mbox{} \\[1.3ex] #1}

\newcommand{\sstbugs}[1]{\item[Bugs:] #1}

\newcommand{\sstitemlist}[1]{
  \mbox{} \\
  \vspace{-3.5ex}
  \begin{itemize}
     #1
  \end{itemize}
}

\newcommand{\sstitem}{\item}


\sstroutine{
   IRG\_CREAT
}{
   Obtain a group of NDF names to be created
}{
   \sstdescription{
      A group expression is obtained from the ADAM environment using
      the supplied parameter. The expression is parsed (using the
      facilities of the IRH routine IRH\_GROUP, see ID/9) to produce a
      list of explicit .SDF file names. These file names are expanded
      into complete file specifications ( minus the file type and
      version number) and appended to the group identified by GID. If
      GID has the value IRH\_\_NOID on entry, then a new group is created
      and GID is returned holding the new group identifier.  If a new
      group is created, it is given a title consisting of the supplied
      parameter name prefixed with the value of the symbolic constant
      IRG\_\_PREFX.

      If, on entry, GID0 holds a valid group identifier, then the group
      identified by GID0 is used as the basis for any modification
      element contained in the group expression obtained from the
      environment. If GID0 does not hold a valid group identified on
      entry (for instance, if it is assigned the symbolic value
      IRH\_\_NOID by the calling application), then no check is made for
      modification elements in the group expression.
   }
   \sstinvocation{
      CALL IRG\_CREAT( PARAM, GID0, TERMC, GID, SIZE, ADDED, TERM,
                      STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER$*$($*$) (Given)
      }{
         The ADAM parameter with which to associate the group.
      }
      \sstsubsection{
         GID0 = INTEGER (Given)
      }{
         An identifier for the group to be used as the basis for any
         modification elements. If GID0 is invalid then any modification
         elements included in the user-supplied group expression are
         included literally in the output group.
      }
      \sstsubsection{
         TERMC = CHARACTER (Given)
      }{
         The termination character to be searched for (see argument
         TERM). Only the first character in TERMC is used. Characters
         which form part of the syntax of a file specification (\$:[.;)
         should not be used as these may be mis-interpreted.
      }
      \sstsubsection{
         GID = INTEGER (Given and Returned)
      }{
         An identifier for the group to which the supplied .SDF file
         specifications are to be appended. If this is supplied equal to
         the symbolic value IRH\_\_NOID, then a new group is created and
         its identifier returned in GID.
      }
      \sstsubsection{
         SIZE = INTEGER (Returned)
      }{
         The total number of .SDF file specifications in the returned
         group.
      }
      \sstsubsection{
         ADDED = INTEGER (Returned)
      }{
         The number of .SDF file specifications added to the group as a
         result of this call.
      }
      \sstsubsection{
         TERM = LOGICAL (Returned)
      }{
         If the group expression was terminated by the character
         specified by argument TERMC, then TERM is returned true.
         Otherwise it is returned false.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRG\_GET
}{
   Return information about an NDF named in a specified group
}{
   \sstdescription{
      This routine returns information about an NDF stored in a
      specified group at a specified index. It also returns the
      access mode of the specified group, and whether it is an input or
      output group.
   }
   \sstinvocation{
      CALL IRG\_GET( GID, INDEX, DEVICE, DIRN, NAME, SLICE, AMODE, OUT,
                    STATUS )
   }
   \sstarguments{
      \sstsubsection{
         GID = INTEGER (Given)
      }{
         An IRG group identifier.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         An index within the group. An error is reported if the index
         lies outside the bounds of the group. The exception to this is
         that no error is reported if a value of zero is supplied, but
         in this case only the arguments AMODE and OUT are returned.
      }
      \sstsubsection{
         DEVICE = CHARACTER (Returned)
      }{
         The name of the device on which the NDF container file resides.
         Returned blank if INDEX is zero.
      }
      \sstsubsection{
         DIRN = CHARACTER (Returned)
      }{
         The name of the directory in which the NDF container file
         resides.  Returned blank if INDEX is zero.
      }
      \sstsubsection{
         NAME = CHARACTER (Returned)
      }{
         The name of the NDF container file.  Returned blank if INDEX
         is zero.
      }
      \sstsubsection{
         SLICE = CHARACTER (Returned)
      }{
         Any user-supplied NDF slice specification included in the
         stored NAME. Returned blank if no slice was specified or if
         INDEX is zero.
      }
      \sstsubsection{
         AMODE = CHARACTER (Returned)
      }{
         The access mode of the group; READ, WRITE or UPDATE.
      }
      \sstsubsection{
         OUT = LOGICAL (Returned)
      }{
         Returned true if the group holds the names of NDF which are
         to be created by the application, and returned false if the
         group holds the names of NDFs which already exist.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRG\_GIN
}{
   Modify a group created by IRH  so that it can be used in IRG
}{
   \sstdescription{
      Groups created within IRG can be directly used by any IRH
      routine, but the converse is not true; groups created by IRH
      cannot be used directly within IRG routines. This routine
      modifies such groups so that they can be used within IRG. An
      error is reported if the group is already in IRG format, and the
      status IRG\_\_NOTHG is returned. The names in the group are
      converted into file specifications (minus file type and version
      number). An error is reported if any of the names contained in the
      group on entry do not correspond to accessible NDFs.
   }
   \sstinvocation{
      CALL IRG\_GIN( GID, OUT, AMODE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         GID = INTEGER (Given)
      }{
         The identifier for the group. An error is reported if the group
         is already suitable for use with IRG. An error is also reported
         if the group identifier is invalid.
      }
      \sstsubsection{
         OUT = LOGICAL (Given)
      }{
         If the group contains a list of existing NDF then OUT should be
         given as .FALSE., if it contains a list of NDFs to be created
         then OUT should be given as .TRUE.
      }
      \sstsubsection{
         AMODE = CHARACTER (Given)
      }{
         The access mode required for the NDFs in the group. This can be
         {\tt '}READ{\tt '}, {\tt '}WRITE{\tt '} or {\tt '}UPDATE{\tt '}, or any abbreviation. If OUT is
         true this argument is ignored.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRG\_GROUP
}{
   Obtain a set of existing NDFs from the ADAM environment and store
   them in a group
}{
   \sstdescription{
      A group expression is obtained from the ADAM environment using a
      single prompt for the supplied parameter. The expression is
      parsed (using the facilities of the IRH routine IRH\_GROUP, see
      ID/9) to produce a list of explicit .SDF files. If any of the
      specified files do not exist, an error is reported identifying
      the missing files and the status IRG\_\_NOFIL is returned (the
      returned group contains any files which were found successfully).
      If any other error is reported the group is returned unaltered
      (SIZE is returned equal to its original size and ADDED is
      returned equal to zero).  The full file specifications (minus
      file type and version number but including any NDF slice
      specifications) of the files which were found successfully are
      appended to the group identified by argument GID.  If GID has the
      value IRH\_\_NOID on entry, then a new group is created and GID is
      returned holding the new group identifier.  If a new group is
      created, it is given a title consisting of the supplied parameter
      name prefixed by the value of symbolic constant IRG\_\_PREFX.
   }
   \sstinvocation{
      CALL IRG\_GROUP( PARAM, TERMC, AMODE, GID, SIZE, ADDED, TERM,
                      STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER$*$($*$) (Given)
      }{
         The ADAM parameter with which to associate the group
         expression.
      }
      \sstsubsection{
         TERMC = CHARACTER (Given)
      }{
         The termination character to be searched for (see argument
         TERM). Only the first character in TERMC is used. Characters
         which form part of the syntax of a file specification (\$:[.;)
         should not be used as these may be mis-interpreted.
      }
      \sstsubsection{
         AMODE = CHARACTER (Given)
      }{
         The access mode required for the NDFs contained in the
         specified .SDF files. This should be {\tt '}READ{\tt '}, {\tt '}WRITE{\tt '} or
         {\tt '}UPDATE{\tt '} or any abbreviation.
      }
      \sstsubsection{
         GID = INTEGER (Given and Returned)
      }{
         An identifier for the group to which the supplied .SDF file
         specifications are to be appended. If this is supplied equal to
         the symbolic value IRH\_\_NOID, then a new group is created and
         its identifier returned in GID.
      }
      \sstsubsection{
         SIZE = INTEGER (Returned)
      }{
         The total number of .SDF file specifications in the returned
         group.
      }
      \sstsubsection{
         ADDED = INTEGER (Returned)
      }{
         The number of .SDF file specifications added to the group as a
         result of this call.
      }
      \sstsubsection{
         TERM = LOGICAL (Returned)
      }{
         If the group expression was terminated by the character
         specified by argument TERMC, then TERM is returned true.
         Otherwise it is returned false.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRG\_NDFCR
}{
   Create an NDF and obtain an NDF identifier for it
}{
   \sstdescription{
      The routine creates a {\tt "}simple{\tt "} NDF with the name stored in the
      given group with the given index. It is created with the shape
      and data type specified by arguments FTYPE, NDIM, LBND, UBND. An
      NDF identifier is returned for it which can be used by all the
      normal NDF\_ routines (see SUN/33).
   }
   \sstinvocation{
      CALL IRG\_NDFCR( GID, INDEX, FTYPE, NDIM, LBND, UBND, INDF,
                      LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         GID = INTEGER (Given)
      }{
         A group identifier.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index within the group of the NDF name.
      }
      \sstsubsection{
         FTYPE = CHARACTER (Given)
      }{
         The full data type required for the DATA component.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The required number of NDF dimensions.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Given)
      }{
         The lower bounds required for the NDF.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         The upper bounds required for the NDF.
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         LOC = CHARACTER (Returned)
      }{
         An HDS locator to the top level object in the .SDF file which
         contains the specified NDF. NDF\_ANNUL should be called as usual
         to annul the NDF identifier returned by argument INDF once
         access is no longer required, but this will not of itself close
         the .SDF file which contains the NDF. HDS\_CLOSE must be called
         (after NDF\_ANNUL) to do this, specifying LOC as the first
         argument. This is sometimes necessary in order to minimise the
         number of files open at any one time. Note, any further
         attempts to access the file (e.g. through identifiers to other
         NDFs contained in the file) will fail once the file has been
         closed. If the file is not explicitly closed using HDS\_CLOSE,
         it will be done automatically by HDS when the application
         terminates. The character string should have a declared length
         equal to the symbolic constant DAT\_\_SZLOC.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRG\_NDFEX
}{
   Obtain an NDF identifier for an existing NDF
}{
   \sstdescription{
      The routine obtains an NDF identifier for a member of a group
      created by IRG\_GROUP. The returned identifier can be used by all
      the normal NDF\_ routines (see SUN/33). NDF identifiers for groups
      created by IRG\_CREAT cannot be obtained using this routine
      (routine IRG\_NDFCR or IRG\_NDFPR should be used instead).
   }
   \sstinvocation{
      CALL IRG\_NDFEX( GID, INDEX, INDF, LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         GID = INTEGER (Given)
      }{
         A group identifier, created by IRG
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index within the group of the NDF name.
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier. This will be an identifier to an NDF section if
         the user specified a slice on the NDF name.
      }
      \sstsubsection{
         LOC = CHARACTER (Returned)
      }{
         An HDS locator to the top level object in the .SDF file which
         contains the specified NDF. NDF\_ANNUL should be called as usual
         to annul the NDF identifier returned by argument INDF once
         access is no longer required, but this will not of itself close
         the .SDF file which contains the NDF. HDS\_CLOSE must be called
         (after NDF\_ANNUL) to do this, specifying LOC as the first
         argument. This is sometimes necessary in order to minimise the
         number of files open at any one time. Note, any further
         attempts to access the file (e.g. through identifiers to other
         NDFs contained in the file) will fail once the file has been
         closed. If the file is not explicitly closed using HDS\_CLOSE,
         it will be done automatically by HDS when the application
         terminates. The character string should have a declared length
         equal to the symbolic constant DAT\_\_SZLOC.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRG\_NDFPR
}{
   Create an NDF by propagation and get an NDF identifier for it
}{
   \sstdescription{
      The routine creates an NDF with name specified by INDEX and GID
      by propagation from the NDF identified by INDF1. An NDF
      identifier for the created NDF is returned which can then be used
      by all the normal NDF\_ routines (see SUN/33).
   }
   \sstinvocation{
      CALL IRG\_NDFPR( GID, INDEX, INDF1, CLIST, INDF2, LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         GID = INTEGER (Given)
      }{
         An identifier for the group containing the name of the NDF to
         be created.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index (within the group identified by GID) of the name of
         the NDF to be created.
      }
      \sstsubsection{
         NDF1 = INTEGER (Given)
      }{
         An NDF identifier for the NDF on which the created NDF is to
         be based.
      }
      \sstsubsection{
         CLIST = CHARACTER (Given)
      }{
         A list of components to be propagated, in the same format as
         the CLIST argument for the NDF\_PROP routine (see SUN/33).
      }
      \sstsubsection{
         INDF2 = INTEGER (Returned)
      }{
         An NDF identifier for the created NDF.
      }
      \sstsubsection{
         LOC = CHARACTER (Returned)
      }{
         An HDS locator to the top level object in the .SDF file which
         contains the specified NDF. NDF\_ANNUL should be called as usual
         to annul the NDF identifier returned by argument INDF once
         access is no longer required, but this will not of itself close
         the .SDF file which contains the NDF. HDS\_CLOSE must be called
         (after NDF\_ANNUL) to do this, specifying LOC as the first
         argument. This is sometimes necessary in order to minimise the
         number of files open at any one time. Note, any further
         attempts to access the file (e.g. through identifiers to other
         NDFs contained in the file) will fail once the file has been
         closed. If the file is not explicitly closed using HDS\_CLOSE,
         it will be done automatically by HDS when the application
         terminates. The character string should have a declared length
         equal to the symbolic constant DAT\_\_SZLOC.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\section {IRG Error Codes}
\label {APP:ERRORS}
IRG routines can return any $STATUS$ value generated by the subroutine packages 
which it calls. In addition it can return the following IRG-specific values,
made available by the Fortran statements
\begin{verbatim}
      INCLUDE 'I90_PAR'
      INCLUDE 'IRG_ERR'
\end{verbatim}

\begin{description}

\item {\bf IRG\_\_AMODE}\\  
An illegal access mode has been given.

\item {\bf IRG\_\_BADFN}\\  
An illegal file specification field was named.

\item {\bf IRG\_\_IN}\\  
An input group was specified, when an output group was required.

\item {\bf IRG\_\_NOFIL}\\
At least one NDF could not be found on disk.

\item {\bf IRG\_\_NOIRG}\\  
The given group was not created by an IRG routine.

\item {\bf IRG\_\_NOSDF}\\  
A file with type other than .SDF has been specified.

\item {\bf IRG\_\_NOTHG}\\  
The group supplied to IRG\_GIN is already in IRG format.

\item {\bf IRG\_\_OUT}\\  
An output group was specified, when an input group was required.

\item {\bf IRG\_\_VMSER}\\  
An operating system error has occurred.

\end{description}
\end{document}
%% $Id$
