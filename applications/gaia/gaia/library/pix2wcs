#!/bin/sh

# Run the real pix2wcs script using the gaia_swish binary.

# The gaia_swish binary run the gaiaMain.tcl script as soon as it
# starts, so the only way we can stop GAIA from running up is by
# replacing the commands that gaiaMain invokes.

# Need a directory to put all the files we need. Use /tmp.
script_dir="${TMPDIR:-/tmp}/pix2wcs${USER}$$"
if test -f ${script_dir}; then
    \rm -r -f ${script_dir}
fi
mkdir -p ${script_dir}

# Local directory is GAIA_LIBRARY so that we can pick up Tcl code.
GAIA_LIBRARY=${script_dir}
export GAIA_LIBRARY

# Make sure we remove this all on exit.
trap 'rm -r -f ${script_dir};exit' 0 1 2 3 9 15

# Add the intermediary files we need.
# 

# - tclIndex
cat > ${script_dir}/tclIndex <<EOF
# Tcl autoload index file, version 2.0
# This file is generated by the "auto_mkindex" command
# and sourced to set up indexing information for one or
# more commands.  Typically each line is a command that
# sets an element in the auto_index array, where the
# element name is the name of a command and the value is
# a script that loads the command.

set auto_index(::gaia::Gaia) [list source [file join \$dir start_script.tcl]]
set auto_index(::gaia::Gaia::startGaia) [list source [file join \$dir start_script.tcl]]
set auto_index(::gaia::GaiaImageName) [list source [file join \$dir GaiaImageName.tcl]]
EOF

# - GaiaImageName.tcl
cat > ${script_dir}/GaiaImageName.tcl <<EOF
itcl::class gaia::GaiaImageName {
   constructor {args} {
      eval configure \$args
   }
   destructor  {
   }
   public method fullname { {fitsext 1} } {
      return \$imagename
   }
   public method diskfile {} {
      return \$imagename
   }
   public method slice {} {
      return \$slice_
   }
   public method fitsext {} {
      return \$fitsext_
   }
   public method fitshdunum {} {
      return 0
   }
   public method path {} {
      return \$path_
   }
   public method type {} {
      return \$type_
   }
   public method ndfname {} {
      return \$imagename
   }
   public method exists {} {
      return 1
   }
   public method absolute {} {
   }
   public method protect {} {
   }
   protected method parse_name_ {} {
   }
   protected method get_slice_ {} {
   }
   protected method get_fitsext_ {} {
   }
   protected method get_type_ {} {
   }
   protected method check_type_ {} {
      return 1
   }
   protected method get_diskfile_ {} {
   }
   protected method get_fullname_ {} {
   }
   protected method get_path_ {} {
   }
   protected method reset_ {} {
   }
   public variable imagename {} {
   }
   protected variable fullname_ {}
   protected variable diskfile_ {}
   protected variable slice_ {}
   protected variable fitsext_ {}
   protected variable fitshdu_ 0
   protected variable path_ {}
   protected variable type_ {.sdf}
}
EOF

# - pix2wcs.real
cat > ${script_dir}/pix2wcs.real <<EOF
#   Name:
#      pix2wcs
#
#   Purpose:
#      Convert a file of pixel coordinate to world coordinates.
#
#   Usage:
#      pix2wcs image pixel_coordinates_file world_coordinates file
#
#   Description:
#      This command transforms a list of pixel coordinate stored in a
#      file into world coordinates. The format of the pixel file
#      should be:
#
#        x y
#        x y
#
#      The output file is proper tab-table which can be displayed
#      in GAIA.
#
#   Authors:
#      Peter W. Draper (PDRAPER):
#
#   History:
#      28-APR-1999 (PDRAPER):
#         Original version.
#-
#.

global argc
global argv

#  There are two too many arguments always.
incr argc -2

#  Get the image, if not given.
if { \$argc == 0 } {
   puts -nonewline "Image: "
   flush stdout
   gets stdin image
} else {
   set image [lindex \$argv 0]
}

#  Get names of files.
if { \$argc <= 1  } {
   puts -nonewline "XY coordinate file: "
   flush stdout
   gets stdin infile
} else {
   set infile [lindex \$argv 1]
}
if { ! [file exists \$infile] } {
   puts stderr "Sorry file: \$infile, does not exist"
   exit 1
}

if { \$argc <= 2 } {
   puts -nonewline "Output file: "
   flush stdout
   gets stdin outfile
} else {
   set outfile [lindex \$argv 2]
}

#  Open the XY positions file and the output file.
if { [catch "open \$infile r" infile] } {
   puts stderr "Failed to open input file: \$infile (\$infile)"
   exit 1
}
if { [catch "open \$outfile w" outfile] } {
   puts stderr "Failed to open output file: \$infile (\$outfile)"
   exit 1
}

#  Open the image.
set rtdimage [image create rtdimage -file \$image]
if { ! [info exists rtdimage] } {
   puts stderr "Failed to open image: \$image"
   exit 1
}

#  Add the initialising commands.
puts \$outfile "QueryResult"
puts \$outfile "ra_col: 1"
puts \$outfile "dec_col: 2"
puts \$outfile "symbol: INDEX {circle {} {} {} {\\\$INDEX} {}} {4.0 {}}"

puts \$outfile "INDEX\t RA\t DEC\t XPOS\t YPOS"
puts \$outfile "-----\t --\t ---\t ----\t ----"

#  Loop over the input file reading all the elements and writing them
#  back out with RA/Dec and TAB separated fields.
set id 0
while { [gets \$infile line] > -1 } {
   set nitems [llength \$line]
   if { \$nitems > 0 } {
      foreach {x y} \$line {
         incr id
         \$rtdimage convert coords \$x \$y image ra dec wcs
         puts \$outfile "\$id\t \$ra\t \$dec\t \$x\t \$y"
      }
   }
}
close \$infile
close \$outfile
exit
EOF

#- start_script
echo >  ${script_dir}/start_script.tcl 'itcl::class gaia::Gaia {'
echo >> ${script_dir}/start_script.tcl '   public proc startGaia {} {'
echo >> ${script_dir}/start_script.tcl "      source ${script_dir}/pix2wcs.real"
echo >> ${script_dir}/start_script.tcl '   }'
echo >> ${script_dir}/start_script.tcl '}'

#  Now run up script.
$GAIA_DIR/gaia_swish $*

exit
