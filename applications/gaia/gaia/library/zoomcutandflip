#!/bin/sh
# The next line is executed by /bin/sh, but not Tcl \
exec $GAIA_DIR/gaia_stcl $0 ${1+"$@"}
#+
#   Name:
#      zoomandcut
#
#   Purpose:
#      Set the zoom, flip and autocut range of GAIA
#
#   Usage:
#      zoomcutandflip zoom_factor [percentage_cut] &| [flip]
#
#   Authors:
#      Peter W. Draper (PWD):
#
#   History:
#      11-SEP-2000 (PWD):
#         Original version.
#-
#.

#  Check the command-line arguments.
if { $argc == 1 } {
   set zoom [lindex $argv 0]
   set cut {}
   set flip {}
} elseif { $argc == 2 } {
   set zoom [lindex $argv 0]
   set cut [lindex $argv 1]
   set flip {}
   # Check if cut is flip...
   if { [string match "*x*" "$cut"] || [string match "*y*" "$cut"] } {
      set flip $cut
      set cut {}
   }
} elseif { $argc == 3 } {
   set zoom [lindex $argv 0]
   set cut [lindex $argv 1]
   set flip [lindex $argv 2]
} else {
   puts stderr {usage: zoomandcut zoom_factor [percentage_cut] &! [flip]}
   exit
}

#  Add GAIA_DIR to autopath for some GAIA classes.
lappend auto_path $env(GAIA_DIR)

#  Open a socket to a GAIA application and return the file descriptor
#  for remote commands. If a GAIA isn't found then start one up.
proc connect_to_gaia {} {
   global env

   #  Get the hostname and port info from the file .rtd-remote, which is
   #  created by rtdimage when the remote subcommand is used. Normally the
   #  .rtd-remote file lives in the $HOME directory, but this can be changed
   #  using the environment variable RTD_REMOTE_DIR. GAIA doesn't create the
   #  RTD_REMOTE_DIR directory so neither should we, which means if it doesn't
   #  exist we should give up now as no contact file will be written.
   if { [info exists env(RTD_REMOTE_DIR)] } {
      if { ! [file isdirectory $env(RTD_REMOTE_DIR)] } {
         puts stderr "Remote access to GAIA is currently disabled.\
The RTD_REMOTE_DIR directory: $env(RTD_REMOTE_DIR), does not exist."
         exit 1
      }
      set rtd-remote "$env(RTD_REMOTE_DIR)/.rtd-remote"
   } else {
      set rtd-remote "$env(HOME)/.rtd-remote"
   }

   set tries 0
   while { 1 } {
      set needed 0

      #  Open the file containing the GAIA process information and read it.
      if {[catch {set fd [open ${rtd-remote}]} msg]} {
         set needed 1
      } else {
         lassign [read $fd] pid host port
         close $fd
      }

      #  See if the process is listening to this socket.
      if { ! $needed } {
         if {[catch {socket $host $port} msg]} {
            set needed 1
         } else {
            fconfigure $msg -buffering line
            return $msg
         }
      }

      #  If the process doesn't exist and we've not been around the
      #  loop already, then start a new GAIA.
      if { $needed && $tries == 0 } {
         puts stderr "Failed to connect to GAIA, starting new instance..."
         exec $env(GAIA_DIR)/gaia.sh &
      }

      #  Now either wait and try again or give up if waited too long.
      if { $needed && $tries < 500 } {
         #  Wait for a while and then try again.
         incr tries
         after 1000
      } elseif { $needed } {
         puts stderr "Sorry timed out: failed to display image in GAIA"
         exit 1
      }
   }
}

#  Send the command to GAIA and return the results or generate an error.
proc send_to_gaia {args} {
   global gaia_fd
   puts $gaia_fd "$args"
   lassign [gets $gaia_fd] status length
   set result {}
   if {$length > 0} {
      set result [read $gaia_fd $length]
   }
   if {$status != 0} {
      error "$result"
   }
   return "$result"
}

#  Open up connection to GAIA.
set gaia_fd [connect_to_gaia]

#  Command needs to performed by Skycat or derived object. We just
#  talk to the first window on the list.
set cmd "skycat::SkyCat::get_skycat_images"
set images [send_to_gaia remotetcl $cmd]

#  Got list so select first and ask about the parent (should be
#  top-level GAIA).
set ctrlwidget [lindex $images 0]
set cmd "$ctrlwidget get_image"
set rtdwidget [send_to_gaia remotetcl $cmd]

#  Send the zoom command.
set cmd "$ctrlwidget scale $zoom $zoom"
set ret [send_to_gaia remotetcl $cmd]

#  The cut command.
if { "$cut" != {} } {
   set cmd "$rtdwidget autocut -percent $cut"
   set ret [send_to_gaia remotetcl $cmd]
}

#  And the flip command.
if { "$flip" != {} } {
   if { [string match "-*" "$flip"] } {
      set forward 0
   } else {
      set forward 1
   }
   if { [string match "*xy" "$flip"] } {
      set cmd "$ctrlwidget rotate $forward"
   } else {
      if { [string match "*x" "$flip"] } {
         set cmd "$ctrlwidget flip x $forward"
      } else {
         set cmd "$ctrlwidget flip y $forward"
      }
   }
   set ret [send_to_gaia remotetcl $cmd]
}

close $gaia_fd
exit
