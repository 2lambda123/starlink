// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef VOTABLE1_1_HXX
#define VOTABLE1_1_HXX

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/version.hxx>

#if (XSD_INT_VERSION != 3010000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< type, char, ncname > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info < char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap < char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream < char > list_stream;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_type_info< char > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< char > not_derived;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::serialization< char > serialization;
  typedef ::xsd::cxx::tree::no_namespace_mapping< char > no_namespace_mapping;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::xsi_already_in_use< char > xsi_already_in_use;
  typedef ::xsd::cxx::tree::bounds< char > bounds;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY_IN___XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY_IN___XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace votable_11
{
  class anyTEXT;
  class astroYear;
  class ucdType;
  class arrayDEF;
  class encodingType;
  class dataType;
  class precType;
  class yesno;
  class VOTABLE;
  class RESOURCE;
  class DEFINITIONS;
  class INFO;
  class PARAM;
  class TABLE;
  class FIELD;
  class GROUP;
  class FIELDref;
  class PARAMref;
  class VALUES;
  class MIN;
  class MAX;
  class OPTION;
  class LINK;
  class DATA;
  class TABLEDATA;
  class TD;
  class TR;
  class FITS;
  class BINARY;
  class STREAM;
  class COOSYS;
  class version;
  class type;
  class type1;
  class type2;
  class content_role;
  class type3;
  class actuate;
  class system;
}


#include <memory>    // std::auto_ptr
#include <algorithm> // std::binary_search

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include <xsd/cxx/tree/containers-wildcard.hxx>

namespace votable_11
{
  class anyTEXT: public ::xml_schema::type
  {
    public:
    // any
    // 
    typedef ::xsd::cxx::tree::element_sequence any_sequence;
    typedef any_sequence::iterator any_iterator;
    typedef any_sequence::const_iterator any_const_iterator;

    const any_sequence&
    any () const;

    any_sequence&
    any ();

    void
    any (const any_sequence& s);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    dom_document () const;

    ::xercesc::DOMDocument&
    dom_document ();

    // Constructors.
    //
    anyTEXT ();

    anyTEXT (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    anyTEXT (const anyTEXT& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual anyTEXT*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~anyTEXT ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > dom_document_;

    any_sequence any_;
  };

  class astroYear: public ::xml_schema::token
  {
    public:
    // Constructors.
    //
    astroYear ();

    astroYear (const char*);

    astroYear (const ::std::string&);

    astroYear (const ::xml_schema::token&);

    astroYear (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    astroYear (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    astroYear (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    astroYear (const astroYear& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual astroYear*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~astroYear ();
  };

  class ucdType: public ::xml_schema::token
  {
    public:
    // Constructors.
    //
    ucdType ();

    ucdType (const char*);

    ucdType (const ::std::string&);

    ucdType (const ::xml_schema::token&);

    ucdType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    ucdType (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    ucdType (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    ucdType (const ucdType& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual ucdType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~ucdType ();
  };

  class arrayDEF: public ::xml_schema::token
  {
    public:
    // Constructors.
    //
    arrayDEF ();

    arrayDEF (const char*);

    arrayDEF (const ::std::string&);

    arrayDEF (const ::xml_schema::token&);

    arrayDEF (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    arrayDEF (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    arrayDEF (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    arrayDEF (const arrayDEF& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual arrayDEF*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~arrayDEF ();
  };

  class encodingType: public ::xml_schema::nmtoken
  {
    public:
    enum value
    {
      gzip,
      base64,
      dynamic,
      none
    };

    encodingType (value v);

    encodingType (const char* v);

    encodingType (const ::std::string& v);

    encodingType (const ::xml_schema::nmtoken& v);

    encodingType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    encodingType (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    encodingType (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    encodingType (const encodingType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual encodingType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    encodingType&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_encodingType_convert ();
    }

    protected:
    value
    _xsd_encodingType_convert () const;

    public:
    static const char* const _xsd_encodingType_literals_[4];
    static const value _xsd_encodingType_indexes_[4];
  };

  class dataType: public ::xml_schema::nmtoken
  {
    public:
    enum value
    {
      boolean,
      bit,
      unsignedByte,
      short_,
      int_,
      long_,
      char_,
      unicodeChar,
      float_,
      double_,
      floatComplex,
      doubleComplex
    };

    dataType (value v);

    dataType (const char* v);

    dataType (const ::std::string& v);

    dataType (const ::xml_schema::nmtoken& v);

    dataType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    dataType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    dataType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    dataType (const dataType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual dataType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    dataType&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_dataType_convert ();
    }

    protected:
    value
    _xsd_dataType_convert () const;

    public:
    static const char* const _xsd_dataType_literals_[12];
    static const value _xsd_dataType_indexes_[12];
  };

  class precType: public ::xml_schema::token
  {
    public:
    // Constructors.
    //
    precType ();

    precType (const char*);

    precType (const ::std::string&);

    precType (const ::xml_schema::token&);

    precType (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    precType (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    precType (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    precType (const precType& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual precType*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~precType ();
  };

  class yesno: public ::xml_schema::nmtoken
  {
    public:
    enum value
    {
      yes,
      no
    };

    yesno (value v);

    yesno (const char* v);

    yesno (const ::std::string& v);

    yesno (const ::xml_schema::nmtoken& v);

    yesno (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    yesno (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    yesno (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    yesno (const yesno& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual yesno*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    yesno&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_yesno_convert ();
    }

    protected:
    value
    _xsd_yesno_convert () const;

    public:
    static const char* const _xsd_yesno_literals_[2];
    static const value _xsd_yesno_indexes_[2];
  };

  class VOTABLE: public ::xml_schema::type
  {
    public:
    // DESCRIPTION
    // 
    typedef ::votable_11::anyTEXT DESCRIPTION_type;
    typedef ::xsd::cxx::tree::optional< DESCRIPTION_type > DESCRIPTION_optional;
    typedef ::xsd::cxx::tree::traits< DESCRIPTION_type, char > DESCRIPTION_traits;

    const DESCRIPTION_optional&
    DESCRIPTION () const;

    DESCRIPTION_optional&
    DESCRIPTION ();

    void
    DESCRIPTION (const DESCRIPTION_type& x);

    void
    DESCRIPTION (const DESCRIPTION_optional& x);

    void
    DESCRIPTION (::std::auto_ptr< DESCRIPTION_type > p);

    // DEFINITIONS
    // 
    typedef ::votable_11::DEFINITIONS DEFINITIONS_type;
    typedef ::xsd::cxx::tree::optional< DEFINITIONS_type > DEFINITIONS_optional;
    typedef ::xsd::cxx::tree::traits< DEFINITIONS_type, char > DEFINITIONS_traits;

    const DEFINITIONS_optional&
    DEFINITIONS () const;

    DEFINITIONS_optional&
    DEFINITIONS ();

    void
    DEFINITIONS (const DEFINITIONS_type& x);

    void
    DEFINITIONS (const DEFINITIONS_optional& x);

    void
    DEFINITIONS (::std::auto_ptr< DEFINITIONS_type > p);

    // COOSYS
    // 
    typedef ::votable_11::COOSYS COOSYS_type;
    typedef ::xsd::cxx::tree::sequence< COOSYS_type > COOSYS_sequence;
    typedef COOSYS_sequence::iterator COOSYS_iterator;
    typedef COOSYS_sequence::const_iterator COOSYS_const_iterator;
    typedef ::xsd::cxx::tree::traits< COOSYS_type, char > COOSYS_traits;

    const COOSYS_sequence&
    COOSYS () const;

    COOSYS_sequence&
    COOSYS ();

    void
    COOSYS (const COOSYS_sequence& s);

    // PARAM
    // 
    typedef ::votable_11::PARAM PARAM_type;
    typedef ::xsd::cxx::tree::sequence< PARAM_type > PARAM_sequence;
    typedef PARAM_sequence::iterator PARAM_iterator;
    typedef PARAM_sequence::const_iterator PARAM_const_iterator;
    typedef ::xsd::cxx::tree::traits< PARAM_type, char > PARAM_traits;

    const PARAM_sequence&
    PARAM () const;

    PARAM_sequence&
    PARAM ();

    void
    PARAM (const PARAM_sequence& s);

    // INFO
    // 
    typedef ::votable_11::INFO INFO_type;
    typedef ::xsd::cxx::tree::sequence< INFO_type > INFO_sequence;
    typedef INFO_sequence::iterator INFO_iterator;
    typedef INFO_sequence::const_iterator INFO_const_iterator;
    typedef ::xsd::cxx::tree::traits< INFO_type, char > INFO_traits;

    const INFO_sequence&
    INFO () const;

    INFO_sequence&
    INFO ();

    void
    INFO (const INFO_sequence& s);

    // RESOURCE
    // 
    typedef ::votable_11::RESOURCE RESOURCE_type;
    typedef ::xsd::cxx::tree::sequence< RESOURCE_type > RESOURCE_sequence;
    typedef RESOURCE_sequence::iterator RESOURCE_iterator;
    typedef RESOURCE_sequence::const_iterator RESOURCE_const_iterator;
    typedef ::xsd::cxx::tree::traits< RESOURCE_type, char > RESOURCE_traits;

    const RESOURCE_sequence&
    RESOURCE () const;

    RESOURCE_sequence&
    RESOURCE ();

    void
    RESOURCE (const RESOURCE_sequence& s);

    // ID
    // 
    typedef ::xml_schema::id ID_type;
    typedef ::xsd::cxx::tree::optional< ID_type > ID_optional;
    typedef ::xsd::cxx::tree::traits< ID_type, char > ID_traits;

    const ID_optional&
    ID () const;

    ID_optional&
    ID ();

    void
    ID (const ID_type& x);

    void
    ID (const ID_optional& x);

    void
    ID (::std::auto_ptr< ID_type > p);

    // version
    // 
    typedef ::votable_11::version version_type;
    typedef ::xsd::cxx::tree::optional< version_type > version_optional;
    typedef ::xsd::cxx::tree::traits< version_type, char > version_traits;

    const version_optional&
    version () const;

    version_optional&
    version ();

    void
    version (const version_type& x);

    void
    version (const version_optional& x);

    void
    version (::std::auto_ptr< version_type > p);

    // Constructors.
    //
    VOTABLE ();

    VOTABLE (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    VOTABLE (const VOTABLE& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual VOTABLE*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~VOTABLE ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    DESCRIPTION_optional DESCRIPTION_;
    DEFINITIONS_optional DEFINITIONS_;
    COOSYS_sequence COOSYS_;
    PARAM_sequence PARAM_;
    INFO_sequence INFO_;
    RESOURCE_sequence RESOURCE_;
    ID_optional ID_;
    version_optional version_;
  };

  class RESOURCE: public ::xml_schema::type
  {
    public:
    // DESCRIPTION
    // 
    typedef ::votable_11::anyTEXT DESCRIPTION_type;
    typedef ::xsd::cxx::tree::optional< DESCRIPTION_type > DESCRIPTION_optional;
    typedef ::xsd::cxx::tree::traits< DESCRIPTION_type, char > DESCRIPTION_traits;

    const DESCRIPTION_optional&
    DESCRIPTION () const;

    DESCRIPTION_optional&
    DESCRIPTION ();

    void
    DESCRIPTION (const DESCRIPTION_type& x);

    void
    DESCRIPTION (const DESCRIPTION_optional& x);

    void
    DESCRIPTION (::std::auto_ptr< DESCRIPTION_type > p);

    // INFO
    // 
    typedef ::votable_11::INFO INFO_type;
    typedef ::xsd::cxx::tree::sequence< INFO_type > INFO_sequence;
    typedef INFO_sequence::iterator INFO_iterator;
    typedef INFO_sequence::const_iterator INFO_const_iterator;
    typedef ::xsd::cxx::tree::traits< INFO_type, char > INFO_traits;

    const INFO_sequence&
    INFO () const;

    INFO_sequence&
    INFO ();

    void
    INFO (const INFO_sequence& s);

    // COOSYS
    // 
    typedef ::votable_11::COOSYS COOSYS_type;
    typedef ::xsd::cxx::tree::sequence< COOSYS_type > COOSYS_sequence;
    typedef COOSYS_sequence::iterator COOSYS_iterator;
    typedef COOSYS_sequence::const_iterator COOSYS_const_iterator;
    typedef ::xsd::cxx::tree::traits< COOSYS_type, char > COOSYS_traits;

    const COOSYS_sequence&
    COOSYS () const;

    COOSYS_sequence&
    COOSYS ();

    void
    COOSYS (const COOSYS_sequence& s);

    // PARAM
    // 
    typedef ::votable_11::PARAM PARAM_type;
    typedef ::xsd::cxx::tree::sequence< PARAM_type > PARAM_sequence;
    typedef PARAM_sequence::iterator PARAM_iterator;
    typedef PARAM_sequence::const_iterator PARAM_const_iterator;
    typedef ::xsd::cxx::tree::traits< PARAM_type, char > PARAM_traits;

    const PARAM_sequence&
    PARAM () const;

    PARAM_sequence&
    PARAM ();

    void
    PARAM (const PARAM_sequence& s);

    // LINK
    // 
    typedef ::votable_11::LINK LINK_type;
    typedef ::xsd::cxx::tree::sequence< LINK_type > LINK_sequence;
    typedef LINK_sequence::iterator LINK_iterator;
    typedef LINK_sequence::const_iterator LINK_const_iterator;
    typedef ::xsd::cxx::tree::traits< LINK_type, char > LINK_traits;

    const LINK_sequence&
    LINK () const;

    LINK_sequence&
    LINK ();

    void
    LINK (const LINK_sequence& s);

    // TABLE
    // 
    typedef ::votable_11::TABLE TABLE_type;
    typedef ::xsd::cxx::tree::sequence< TABLE_type > TABLE_sequence;
    typedef TABLE_sequence::iterator TABLE_iterator;
    typedef TABLE_sequence::const_iterator TABLE_const_iterator;
    typedef ::xsd::cxx::tree::traits< TABLE_type, char > TABLE_traits;

    const TABLE_sequence&
    TABLE () const;

    TABLE_sequence&
    TABLE ();

    void
    TABLE (const TABLE_sequence& s);

    // RESOURCE
    // 
    typedef ::votable_11::RESOURCE RESOURCE1_type;
    typedef ::xsd::cxx::tree::sequence< RESOURCE1_type > RESOURCE1_sequence;
    typedef RESOURCE1_sequence::iterator RESOURCE1_iterator;
    typedef RESOURCE1_sequence::const_iterator RESOURCE1_const_iterator;
    typedef ::xsd::cxx::tree::traits< RESOURCE1_type, char > RESOURCE1_traits;

    const RESOURCE1_sequence&
    RESOURCE1 () const;

    RESOURCE1_sequence&
    RESOURCE1 ();

    void
    RESOURCE1 (const RESOURCE1_sequence& s);

    // any
    // 
    typedef ::xsd::cxx::tree::element_sequence any_sequence;
    typedef any_sequence::iterator any_iterator;
    typedef any_sequence::const_iterator any_const_iterator;

    const any_sequence&
    any () const;

    any_sequence&
    any ();

    void
    any (const any_sequence& s);

    // name
    // 
    typedef ::xml_schema::token name_type;
    typedef ::xsd::cxx::tree::optional< name_type > name_optional;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_optional&
    name () const;

    name_optional&
    name ();

    void
    name (const name_type& x);

    void
    name (const name_optional& x);

    void
    name (::std::auto_ptr< name_type > p);

    // ID
    // 
    typedef ::xml_schema::id ID_type;
    typedef ::xsd::cxx::tree::optional< ID_type > ID_optional;
    typedef ::xsd::cxx::tree::traits< ID_type, char > ID_traits;

    const ID_optional&
    ID () const;

    ID_optional&
    ID ();

    void
    ID (const ID_type& x);

    void
    ID (const ID_optional& x);

    void
    ID (::std::auto_ptr< ID_type > p);

    // utype
    // 
    typedef ::xml_schema::string utype_type;
    typedef ::xsd::cxx::tree::optional< utype_type > utype_optional;
    typedef ::xsd::cxx::tree::traits< utype_type, char > utype_traits;

    const utype_optional&
    utype () const;

    utype_optional&
    utype ();

    void
    utype (const utype_type& x);

    void
    utype (const utype_optional& x);

    void
    utype (::std::auto_ptr< utype_type > p);

    // type
    // 
    typedef ::votable_11::type type_type;
    typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

    const type_type&
    type () const;

    type_type&
    type ();

    void
    type (const type_type& x);

    void
    type (::std::auto_ptr< type_type > p);

    static const type_type&
    type_default_value ();

    // any_attribute
    // 
    typedef ::xsd::cxx::tree::attribute_set< char > any_attribute_set;
    typedef any_attribute_set::iterator any_attribute_iterator;
    typedef any_attribute_set::const_iterator any_attribute_const_iterator;

    const any_attribute_set&
    any_attribute () const;

    any_attribute_set&
    any_attribute ();

    void
    any_attribute (const any_attribute_set& s);

    // DOMDocument for wildcard content.
    //
    const ::xercesc::DOMDocument&
    dom_document () const;

    ::xercesc::DOMDocument&
    dom_document ();

    // Constructors.
    //
    RESOURCE ();

    RESOURCE (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    RESOURCE (const RESOURCE& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual RESOURCE*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~RESOURCE ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > dom_document_;

    DESCRIPTION_optional DESCRIPTION_;
    INFO_sequence INFO_;
    COOSYS_sequence COOSYS_;
    PARAM_sequence PARAM_;
    LINK_sequence LINK_;
    TABLE_sequence TABLE_;
    RESOURCE1_sequence RESOURCE1_;
    any_sequence any_;
    name_optional name_;
    ID_optional ID_;
    utype_optional utype_;
    ::xsd::cxx::tree::one< type_type > type_;
    static const type_type type_default_value_;
    any_attribute_set any_attribute_;
  };

  class DEFINITIONS: public ::xml_schema::type
  {
    public:
    // COOSYS
    // 
    typedef ::votable_11::COOSYS COOSYS_type;
    typedef ::xsd::cxx::tree::sequence< COOSYS_type > COOSYS_sequence;
    typedef COOSYS_sequence::iterator COOSYS_iterator;
    typedef COOSYS_sequence::const_iterator COOSYS_const_iterator;
    typedef ::xsd::cxx::tree::traits< COOSYS_type, char > COOSYS_traits;

    const COOSYS_sequence&
    COOSYS () const;

    COOSYS_sequence&
    COOSYS ();

    void
    COOSYS (const COOSYS_sequence& s);

    // PARAM
    // 
    typedef ::votable_11::PARAM PARAM_type;
    typedef ::xsd::cxx::tree::sequence< PARAM_type > PARAM_sequence;
    typedef PARAM_sequence::iterator PARAM_iterator;
    typedef PARAM_sequence::const_iterator PARAM_const_iterator;
    typedef ::xsd::cxx::tree::traits< PARAM_type, char > PARAM_traits;

    const PARAM_sequence&
    PARAM () const;

    PARAM_sequence&
    PARAM ();

    void
    PARAM (const PARAM_sequence& s);

    // Constructors.
    //
    DEFINITIONS ();

    DEFINITIONS (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    DEFINITIONS (const DEFINITIONS& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

    virtual DEFINITIONS*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~DEFINITIONS ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    COOSYS_sequence COOSYS_;
    PARAM_sequence PARAM_;
  };

  class INFO: public ::xml_schema::string
  {
    public:
    // ID
    // 
    typedef ::xml_schema::id ID_type;
    typedef ::xsd::cxx::tree::optional< ID_type > ID_optional;
    typedef ::xsd::cxx::tree::traits< ID_type, char > ID_traits;

    const ID_optional&
    ID () const;

    ID_optional&
    ID ();

    void
    ID (const ID_type& x);

    void
    ID (const ID_optional& x);

    void
    ID (::std::auto_ptr< ID_type > p);

    // name
    // 
    typedef ::xml_schema::token name_type;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_type&
    name () const;

    name_type&
    name ();

    void
    name (const name_type& x);

    void
    name (::std::auto_ptr< name_type > p);

    // value
    // 
    typedef ::xml_schema::string value_type;
    typedef ::xsd::cxx::tree::optional< value_type > value_optional;
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    const value_optional&
    value () const;

    value_optional&
    value ();

    void
    value (const value_type& x);

    void
    value (const value_optional& x);

    void
    value (::std::auto_ptr< value_type > p);

    // Constructors.
    //
    INFO (const name_type&);

    INFO (const char*,
          const name_type&);

    INFO (const ::std::string&,
          const name_type&);

    INFO (const ::xml_schema::string&,
          const name_type&);

    INFO (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    INFO (const INFO& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual INFO*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~INFO ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ID_optional ID_;
    ::xsd::cxx::tree::one< name_type > name_;
    value_optional value_;
  };

  class PARAM: public ::xml_schema::type
  {
    public:
    // DESCRIPTION
    // 
    typedef ::votable_11::anyTEXT DESCRIPTION_type;
    typedef ::xsd::cxx::tree::optional< DESCRIPTION_type > DESCRIPTION_optional;
    typedef ::xsd::cxx::tree::traits< DESCRIPTION_type, char > DESCRIPTION_traits;

    const DESCRIPTION_optional&
    DESCRIPTION () const;

    DESCRIPTION_optional&
    DESCRIPTION ();

    void
    DESCRIPTION (const DESCRIPTION_type& x);

    void
    DESCRIPTION (const DESCRIPTION_optional& x);

    void
    DESCRIPTION (::std::auto_ptr< DESCRIPTION_type > p);

    // VALUES
    // 
    typedef ::votable_11::VALUES VALUES_type;
    typedef ::xsd::cxx::tree::optional< VALUES_type > VALUES_optional;
    typedef ::xsd::cxx::tree::traits< VALUES_type, char > VALUES_traits;

    const VALUES_optional&
    VALUES () const;

    VALUES_optional&
    VALUES ();

    void
    VALUES (const VALUES_type& x);

    void
    VALUES (const VALUES_optional& x);

    void
    VALUES (::std::auto_ptr< VALUES_type > p);

    // LINK
    // 
    typedef ::votable_11::LINK LINK_type;
    typedef ::xsd::cxx::tree::sequence< LINK_type > LINK_sequence;
    typedef LINK_sequence::iterator LINK_iterator;
    typedef LINK_sequence::const_iterator LINK_const_iterator;
    typedef ::xsd::cxx::tree::traits< LINK_type, char > LINK_traits;

    const LINK_sequence&
    LINK () const;

    LINK_sequence&
    LINK ();

    void
    LINK (const LINK_sequence& s);

    // ID
    // 
    typedef ::xml_schema::id ID_type;
    typedef ::xsd::cxx::tree::optional< ID_type > ID_optional;
    typedef ::xsd::cxx::tree::traits< ID_type, char > ID_traits;

    const ID_optional&
    ID () const;

    ID_optional&
    ID ();

    void
    ID (const ID_type& x);

    void
    ID (const ID_optional& x);

    void
    ID (::std::auto_ptr< ID_type > p);

    // unit
    // 
    typedef ::xml_schema::token unit_type;
    typedef ::xsd::cxx::tree::optional< unit_type > unit_optional;
    typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

    const unit_optional&
    unit () const;

    unit_optional&
    unit ();

    void
    unit (const unit_type& x);

    void
    unit (const unit_optional& x);

    void
    unit (::std::auto_ptr< unit_type > p);

    // datatype
    // 
    typedef ::votable_11::dataType datatype_type;
    typedef ::xsd::cxx::tree::optional< datatype_type > datatype_optional;
    typedef ::xsd::cxx::tree::traits< datatype_type, char > datatype_traits;

    const datatype_optional&
    datatype () const;

    datatype_optional&
    datatype ();

    void
    datatype (const datatype_type& x);

    void
    datatype (const datatype_optional& x);

    void
    datatype (::std::auto_ptr< datatype_type > p);

    // precision
    // 
    typedef ::votable_11::precType precision_type;
    typedef ::xsd::cxx::tree::optional< precision_type > precision_optional;
    typedef ::xsd::cxx::tree::traits< precision_type, char > precision_traits;

    const precision_optional&
    precision () const;

    precision_optional&
    precision ();

    void
    precision (const precision_type& x);

    void
    precision (const precision_optional& x);

    void
    precision (::std::auto_ptr< precision_type > p);

    // width
    // 
    typedef ::xml_schema::positive_integer width_type;
    typedef ::xsd::cxx::tree::optional< width_type > width_optional;
    typedef ::xsd::cxx::tree::traits< width_type, char > width_traits;

    const width_optional&
    width () const;

    width_optional&
    width ();

    void
    width (const width_type& x);

    void
    width (const width_optional& x);

    // ref
    // 
    typedef ::xml_schema::idref ref_type;
    typedef ::xsd::cxx::tree::optional< ref_type > ref_optional;
    typedef ::xsd::cxx::tree::traits< ref_type, char > ref_traits;

    const ref_optional&
    ref () const;

    ref_optional&
    ref ();

    void
    ref (const ref_type& x);

    void
    ref (const ref_optional& x);

    void
    ref (::std::auto_ptr< ref_type > p);

    // name
    // 
    typedef ::xml_schema::token name_type;
    typedef ::xsd::cxx::tree::optional< name_type > name_optional;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_optional&
    name () const;

    name_optional&
    name ();

    void
    name (const name_type& x);

    void
    name (const name_optional& x);

    void
    name (::std::auto_ptr< name_type > p);

    // ucd
    // 
    typedef ::votable_11::ucdType ucd_type;
    typedef ::xsd::cxx::tree::optional< ucd_type > ucd_optional;
    typedef ::xsd::cxx::tree::traits< ucd_type, char > ucd_traits;

    const ucd_optional&
    ucd () const;

    ucd_optional&
    ucd ();

    void
    ucd (const ucd_type& x);

    void
    ucd (const ucd_optional& x);

    void
    ucd (::std::auto_ptr< ucd_type > p);

    // utype
    // 
    typedef ::xml_schema::string utype_type;
    typedef ::xsd::cxx::tree::optional< utype_type > utype_optional;
    typedef ::xsd::cxx::tree::traits< utype_type, char > utype_traits;

    const utype_optional&
    utype () const;

    utype_optional&
    utype ();

    void
    utype (const utype_type& x);

    void
    utype (const utype_optional& x);

    void
    utype (::std::auto_ptr< utype_type > p);

    // value
    // 
    typedef ::xml_schema::string value_type;
    typedef ::xsd::cxx::tree::optional< value_type > value_optional;
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    const value_optional&
    value () const;

    value_optional&
    value ();

    void
    value (const value_type& x);

    void
    value (const value_optional& x);

    void
    value (::std::auto_ptr< value_type > p);

    // arraysize
    // 
    typedef ::votable_11::arrayDEF arraysize_type;
    typedef ::xsd::cxx::tree::optional< arraysize_type > arraysize_optional;
    typedef ::xsd::cxx::tree::traits< arraysize_type, char > arraysize_traits;

    const arraysize_optional&
    arraysize () const;

    arraysize_optional&
    arraysize ();

    void
    arraysize (const arraysize_type& x);

    void
    arraysize (const arraysize_optional& x);

    void
    arraysize (::std::auto_ptr< arraysize_type > p);

    // Constructors.
    //
    PARAM ();

    PARAM (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    PARAM (const PARAM& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual PARAM*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~PARAM ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    DESCRIPTION_optional DESCRIPTION_;
    VALUES_optional VALUES_;
    LINK_sequence LINK_;
    ID_optional ID_;
    unit_optional unit_;
    datatype_optional datatype_;
    precision_optional precision_;
    width_optional width_;
    ref_optional ref_;
    name_optional name_;
    ucd_optional ucd_;
    utype_optional utype_;
    value_optional value_;
    arraysize_optional arraysize_;
  };

  class TABLE: public ::xml_schema::type
  {
    public:
    // DESCRIPTION
    // 
    typedef ::votable_11::anyTEXT DESCRIPTION_type;
    typedef ::xsd::cxx::tree::optional< DESCRIPTION_type > DESCRIPTION_optional;
    typedef ::xsd::cxx::tree::traits< DESCRIPTION_type, char > DESCRIPTION_traits;

    const DESCRIPTION_optional&
    DESCRIPTION () const;

    DESCRIPTION_optional&
    DESCRIPTION ();

    void
    DESCRIPTION (const DESCRIPTION_type& x);

    void
    DESCRIPTION (const DESCRIPTION_optional& x);

    void
    DESCRIPTION (::std::auto_ptr< DESCRIPTION_type > p);

    // FIELD
    // 
    typedef ::votable_11::FIELD FIELD_type;
    typedef ::xsd::cxx::tree::sequence< FIELD_type > FIELD_sequence;
    typedef FIELD_sequence::iterator FIELD_iterator;
    typedef FIELD_sequence::const_iterator FIELD_const_iterator;
    typedef ::xsd::cxx::tree::traits< FIELD_type, char > FIELD_traits;

    const FIELD_sequence&
    FIELD () const;

    FIELD_sequence&
    FIELD ();

    void
    FIELD (const FIELD_sequence& s);

    // PARAM
    // 
    typedef ::votable_11::PARAM PARAM_type;
    typedef ::xsd::cxx::tree::sequence< PARAM_type > PARAM_sequence;
    typedef PARAM_sequence::iterator PARAM_iterator;
    typedef PARAM_sequence::const_iterator PARAM_const_iterator;
    typedef ::xsd::cxx::tree::traits< PARAM_type, char > PARAM_traits;

    const PARAM_sequence&
    PARAM () const;

    PARAM_sequence&
    PARAM ();

    void
    PARAM (const PARAM_sequence& s);

    // GROUP
    // 
    typedef ::votable_11::GROUP GROUP_type;
    typedef ::xsd::cxx::tree::sequence< GROUP_type > GROUP_sequence;
    typedef GROUP_sequence::iterator GROUP_iterator;
    typedef GROUP_sequence::const_iterator GROUP_const_iterator;
    typedef ::xsd::cxx::tree::traits< GROUP_type, char > GROUP_traits;

    const GROUP_sequence&
    GROUP () const;

    GROUP_sequence&
    GROUP ();

    void
    GROUP (const GROUP_sequence& s);

    // LINK
    // 
    typedef ::votable_11::LINK LINK_type;
    typedef ::xsd::cxx::tree::sequence< LINK_type > LINK_sequence;
    typedef LINK_sequence::iterator LINK_iterator;
    typedef LINK_sequence::const_iterator LINK_const_iterator;
    typedef ::xsd::cxx::tree::traits< LINK_type, char > LINK_traits;

    const LINK_sequence&
    LINK () const;

    LINK_sequence&
    LINK ();

    void
    LINK (const LINK_sequence& s);

    // DATA
    // 
    typedef ::votable_11::DATA DATA_type;
    typedef ::xsd::cxx::tree::optional< DATA_type > DATA_optional;
    typedef ::xsd::cxx::tree::traits< DATA_type, char > DATA_traits;

    const DATA_optional&
    DATA () const;

    DATA_optional&
    DATA ();

    void
    DATA (const DATA_type& x);

    void
    DATA (const DATA_optional& x);

    void
    DATA (::std::auto_ptr< DATA_type > p);

    // ID
    // 
    typedef ::xml_schema::id ID_type;
    typedef ::xsd::cxx::tree::optional< ID_type > ID_optional;
    typedef ::xsd::cxx::tree::traits< ID_type, char > ID_traits;

    const ID_optional&
    ID () const;

    ID_optional&
    ID ();

    void
    ID (const ID_type& x);

    void
    ID (const ID_optional& x);

    void
    ID (::std::auto_ptr< ID_type > p);

    // name
    // 
    typedef ::xml_schema::token name_type;
    typedef ::xsd::cxx::tree::optional< name_type > name_optional;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_optional&
    name () const;

    name_optional&
    name ();

    void
    name (const name_type& x);

    void
    name (const name_optional& x);

    void
    name (::std::auto_ptr< name_type > p);

    // ref
    // 
    typedef ::xml_schema::idref ref_type;
    typedef ::xsd::cxx::tree::optional< ref_type > ref_optional;
    typedef ::xsd::cxx::tree::traits< ref_type, char > ref_traits;

    const ref_optional&
    ref () const;

    ref_optional&
    ref ();

    void
    ref (const ref_type& x);

    void
    ref (const ref_optional& x);

    void
    ref (::std::auto_ptr< ref_type > p);

    // ucd
    // 
    typedef ::votable_11::ucdType ucd_type;
    typedef ::xsd::cxx::tree::optional< ucd_type > ucd_optional;
    typedef ::xsd::cxx::tree::traits< ucd_type, char > ucd_traits;

    const ucd_optional&
    ucd () const;

    ucd_optional&
    ucd ();

    void
    ucd (const ucd_type& x);

    void
    ucd (const ucd_optional& x);

    void
    ucd (::std::auto_ptr< ucd_type > p);

    // utype
    // 
    typedef ::xml_schema::string utype_type;
    typedef ::xsd::cxx::tree::optional< utype_type > utype_optional;
    typedef ::xsd::cxx::tree::traits< utype_type, char > utype_traits;

    const utype_optional&
    utype () const;

    utype_optional&
    utype ();

    void
    utype (const utype_type& x);

    void
    utype (const utype_optional& x);

    void
    utype (::std::auto_ptr< utype_type > p);

    // nrows
    // 
    typedef ::xml_schema::non_negative_integer nrows_type;
    typedef ::xsd::cxx::tree::optional< nrows_type > nrows_optional;
    typedef ::xsd::cxx::tree::traits< nrows_type, char > nrows_traits;

    const nrows_optional&
    nrows () const;

    nrows_optional&
    nrows ();

    void
    nrows (const nrows_type& x);

    void
    nrows (const nrows_optional& x);

    // Constructors.
    //
    TABLE ();

    TABLE (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    TABLE (const TABLE& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual TABLE*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~TABLE ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    DESCRIPTION_optional DESCRIPTION_;
    FIELD_sequence FIELD_;
    PARAM_sequence PARAM_;
    GROUP_sequence GROUP_;
    LINK_sequence LINK_;
    DATA_optional DATA_;
    ID_optional ID_;
    name_optional name_;
    ref_optional ref_;
    ucd_optional ucd_;
    utype_optional utype_;
    nrows_optional nrows_;
  };

  class FIELD: public ::xml_schema::type
  {
    public:
    // DESCRIPTION
    // 
    typedef ::votable_11::anyTEXT DESCRIPTION_type;
    typedef ::xsd::cxx::tree::optional< DESCRIPTION_type > DESCRIPTION_optional;
    typedef ::xsd::cxx::tree::traits< DESCRIPTION_type, char > DESCRIPTION_traits;

    const DESCRIPTION_optional&
    DESCRIPTION () const;

    DESCRIPTION_optional&
    DESCRIPTION ();

    void
    DESCRIPTION (const DESCRIPTION_type& x);

    void
    DESCRIPTION (const DESCRIPTION_optional& x);

    void
    DESCRIPTION (::std::auto_ptr< DESCRIPTION_type > p);

    // VALUES
    // 
    typedef ::votable_11::VALUES VALUES_type;
    typedef ::xsd::cxx::tree::optional< VALUES_type > VALUES_optional;
    typedef ::xsd::cxx::tree::traits< VALUES_type, char > VALUES_traits;

    const VALUES_optional&
    VALUES () const;

    VALUES_optional&
    VALUES ();

    void
    VALUES (const VALUES_type& x);

    void
    VALUES (const VALUES_optional& x);

    void
    VALUES (::std::auto_ptr< VALUES_type > p);

    // LINK
    // 
    typedef ::votable_11::LINK LINK_type;
    typedef ::xsd::cxx::tree::sequence< LINK_type > LINK_sequence;
    typedef LINK_sequence::iterator LINK_iterator;
    typedef LINK_sequence::const_iterator LINK_const_iterator;
    typedef ::xsd::cxx::tree::traits< LINK_type, char > LINK_traits;

    const LINK_sequence&
    LINK () const;

    LINK_sequence&
    LINK ();

    void
    LINK (const LINK_sequence& s);

    // ID
    // 
    typedef ::xml_schema::id ID_type;
    typedef ::xsd::cxx::tree::optional< ID_type > ID_optional;
    typedef ::xsd::cxx::tree::traits< ID_type, char > ID_traits;

    const ID_optional&
    ID () const;

    ID_optional&
    ID ();

    void
    ID (const ID_type& x);

    void
    ID (const ID_optional& x);

    void
    ID (::std::auto_ptr< ID_type > p);

    // unit
    // 
    typedef ::xml_schema::token unit_type;
    typedef ::xsd::cxx::tree::optional< unit_type > unit_optional;
    typedef ::xsd::cxx::tree::traits< unit_type, char > unit_traits;

    const unit_optional&
    unit () const;

    unit_optional&
    unit ();

    void
    unit (const unit_type& x);

    void
    unit (const unit_optional& x);

    void
    unit (::std::auto_ptr< unit_type > p);

    // datatype
    // 
    typedef ::votable_11::dataType datatype_type;
    typedef ::xsd::cxx::tree::optional< datatype_type > datatype_optional;
    typedef ::xsd::cxx::tree::traits< datatype_type, char > datatype_traits;

    const datatype_optional&
    datatype () const;

    datatype_optional&
    datatype ();

    void
    datatype (const datatype_type& x);

    void
    datatype (const datatype_optional& x);

    void
    datatype (::std::auto_ptr< datatype_type > p);

    // precision
    // 
    typedef ::votable_11::precType precision_type;
    typedef ::xsd::cxx::tree::optional< precision_type > precision_optional;
    typedef ::xsd::cxx::tree::traits< precision_type, char > precision_traits;

    const precision_optional&
    precision () const;

    precision_optional&
    precision ();

    void
    precision (const precision_type& x);

    void
    precision (const precision_optional& x);

    void
    precision (::std::auto_ptr< precision_type > p);

    // width
    // 
    typedef ::xml_schema::positive_integer width_type;
    typedef ::xsd::cxx::tree::optional< width_type > width_optional;
    typedef ::xsd::cxx::tree::traits< width_type, char > width_traits;

    const width_optional&
    width () const;

    width_optional&
    width ();

    void
    width (const width_type& x);

    void
    width (const width_optional& x);

    // ref
    // 
    typedef ::xml_schema::idref ref_type;
    typedef ::xsd::cxx::tree::optional< ref_type > ref_optional;
    typedef ::xsd::cxx::tree::traits< ref_type, char > ref_traits;

    const ref_optional&
    ref () const;

    ref_optional&
    ref ();

    void
    ref (const ref_type& x);

    void
    ref (const ref_optional& x);

    void
    ref (::std::auto_ptr< ref_type > p);

    // name
    // 
    typedef ::xml_schema::token name_type;
    typedef ::xsd::cxx::tree::optional< name_type > name_optional;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_optional&
    name () const;

    name_optional&
    name ();

    void
    name (const name_type& x);

    void
    name (const name_optional& x);

    void
    name (::std::auto_ptr< name_type > p);

    // ucd
    // 
    typedef ::votable_11::ucdType ucd_type;
    typedef ::xsd::cxx::tree::optional< ucd_type > ucd_optional;
    typedef ::xsd::cxx::tree::traits< ucd_type, char > ucd_traits;

    const ucd_optional&
    ucd () const;

    ucd_optional&
    ucd ();

    void
    ucd (const ucd_type& x);

    void
    ucd (const ucd_optional& x);

    void
    ucd (::std::auto_ptr< ucd_type > p);

    // utype
    // 
    typedef ::xml_schema::string utype_type;
    typedef ::xsd::cxx::tree::optional< utype_type > utype_optional;
    typedef ::xsd::cxx::tree::traits< utype_type, char > utype_traits;

    const utype_optional&
    utype () const;

    utype_optional&
    utype ();

    void
    utype (const utype_type& x);

    void
    utype (const utype_optional& x);

    void
    utype (::std::auto_ptr< utype_type > p);

    // arraysize
    // 
    typedef ::xml_schema::string arraysize_type;
    typedef ::xsd::cxx::tree::optional< arraysize_type > arraysize_optional;
    typedef ::xsd::cxx::tree::traits< arraysize_type, char > arraysize_traits;

    const arraysize_optional&
    arraysize () const;

    arraysize_optional&
    arraysize ();

    void
    arraysize (const arraysize_type& x);

    void
    arraysize (const arraysize_optional& x);

    void
    arraysize (::std::auto_ptr< arraysize_type > p);

    // type
    // 
    typedef ::votable_11::type1 type_type;
    typedef ::xsd::cxx::tree::optional< type_type > type_optional;
    typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

    const type_optional&
    type () const;

    type_optional&
    type ();

    void
    type (const type_type& x);

    void
    type (const type_optional& x);

    void
    type (::std::auto_ptr< type_type > p);

    // Constructors.
    //
    FIELD ();

    FIELD (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    FIELD (const FIELD& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual FIELD*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~FIELD ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    DESCRIPTION_optional DESCRIPTION_;
    VALUES_optional VALUES_;
    LINK_sequence LINK_;
    ID_optional ID_;
    unit_optional unit_;
    datatype_optional datatype_;
    precision_optional precision_;
    width_optional width_;
    ref_optional ref_;
    name_optional name_;
    ucd_optional ucd_;
    utype_optional utype_;
    arraysize_optional arraysize_;
    type_optional type_;
  };

  class GROUP: public ::xml_schema::type
  {
    public:
    // DESCRIPTION
    // 
    typedef ::votable_11::anyTEXT DESCRIPTION_type;
    typedef ::xsd::cxx::tree::optional< DESCRIPTION_type > DESCRIPTION_optional;
    typedef ::xsd::cxx::tree::traits< DESCRIPTION_type, char > DESCRIPTION_traits;

    const DESCRIPTION_optional&
    DESCRIPTION () const;

    DESCRIPTION_optional&
    DESCRIPTION ();

    void
    DESCRIPTION (const DESCRIPTION_type& x);

    void
    DESCRIPTION (const DESCRIPTION_optional& x);

    void
    DESCRIPTION (::std::auto_ptr< DESCRIPTION_type > p);

    // FIELDref
    // 
    typedef ::votable_11::FIELDref FIELDref_type;
    typedef ::xsd::cxx::tree::sequence< FIELDref_type > FIELDref_sequence;
    typedef FIELDref_sequence::iterator FIELDref_iterator;
    typedef FIELDref_sequence::const_iterator FIELDref_const_iterator;
    typedef ::xsd::cxx::tree::traits< FIELDref_type, char > FIELDref_traits;

    const FIELDref_sequence&
    FIELDref () const;

    FIELDref_sequence&
    FIELDref ();

    void
    FIELDref (const FIELDref_sequence& s);

    // PARAMref
    // 
    typedef ::votable_11::PARAMref PARAMref_type;
    typedef ::xsd::cxx::tree::sequence< PARAMref_type > PARAMref_sequence;
    typedef PARAMref_sequence::iterator PARAMref_iterator;
    typedef PARAMref_sequence::const_iterator PARAMref_const_iterator;
    typedef ::xsd::cxx::tree::traits< PARAMref_type, char > PARAMref_traits;

    const PARAMref_sequence&
    PARAMref () const;

    PARAMref_sequence&
    PARAMref ();

    void
    PARAMref (const PARAMref_sequence& s);

    // PARAM
    // 
    typedef ::votable_11::PARAM PARAM_type;
    typedef ::xsd::cxx::tree::sequence< PARAM_type > PARAM_sequence;
    typedef PARAM_sequence::iterator PARAM_iterator;
    typedef PARAM_sequence::const_iterator PARAM_const_iterator;
    typedef ::xsd::cxx::tree::traits< PARAM_type, char > PARAM_traits;

    const PARAM_sequence&
    PARAM () const;

    PARAM_sequence&
    PARAM ();

    void
    PARAM (const PARAM_sequence& s);

    // GROUP
    // 
    typedef ::votable_11::GROUP GROUP1_type;
    typedef ::xsd::cxx::tree::sequence< GROUP1_type > GROUP1_sequence;
    typedef GROUP1_sequence::iterator GROUP1_iterator;
    typedef GROUP1_sequence::const_iterator GROUP1_const_iterator;
    typedef ::xsd::cxx::tree::traits< GROUP1_type, char > GROUP1_traits;

    const GROUP1_sequence&
    GROUP1 () const;

    GROUP1_sequence&
    GROUP1 ();

    void
    GROUP1 (const GROUP1_sequence& s);

    // ID
    // 
    typedef ::xml_schema::id ID_type;
    typedef ::xsd::cxx::tree::optional< ID_type > ID_optional;
    typedef ::xsd::cxx::tree::traits< ID_type, char > ID_traits;

    const ID_optional&
    ID () const;

    ID_optional&
    ID ();

    void
    ID (const ID_type& x);

    void
    ID (const ID_optional& x);

    void
    ID (::std::auto_ptr< ID_type > p);

    // name
    // 
    typedef ::xml_schema::token name_type;
    typedef ::xsd::cxx::tree::optional< name_type > name_optional;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_optional&
    name () const;

    name_optional&
    name ();

    void
    name (const name_type& x);

    void
    name (const name_optional& x);

    void
    name (::std::auto_ptr< name_type > p);

    // ref
    // 
    typedef ::xml_schema::idref ref_type;
    typedef ::xsd::cxx::tree::optional< ref_type > ref_optional;
    typedef ::xsd::cxx::tree::traits< ref_type, char > ref_traits;

    const ref_optional&
    ref () const;

    ref_optional&
    ref ();

    void
    ref (const ref_type& x);

    void
    ref (const ref_optional& x);

    void
    ref (::std::auto_ptr< ref_type > p);

    // ucd
    // 
    typedef ::votable_11::ucdType ucd_type;
    typedef ::xsd::cxx::tree::optional< ucd_type > ucd_optional;
    typedef ::xsd::cxx::tree::traits< ucd_type, char > ucd_traits;

    const ucd_optional&
    ucd () const;

    ucd_optional&
    ucd ();

    void
    ucd (const ucd_type& x);

    void
    ucd (const ucd_optional& x);

    void
    ucd (::std::auto_ptr< ucd_type > p);

    // utype
    // 
    typedef ::xml_schema::string utype_type;
    typedef ::xsd::cxx::tree::optional< utype_type > utype_optional;
    typedef ::xsd::cxx::tree::traits< utype_type, char > utype_traits;

    const utype_optional&
    utype () const;

    utype_optional&
    utype ();

    void
    utype (const utype_type& x);

    void
    utype (const utype_optional& x);

    void
    utype (::std::auto_ptr< utype_type > p);

    // Constructors.
    //
    GROUP ();

    GROUP (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    GROUP (const GROUP& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual GROUP*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~GROUP ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    DESCRIPTION_optional DESCRIPTION_;
    FIELDref_sequence FIELDref_;
    PARAMref_sequence PARAMref_;
    PARAM_sequence PARAM_;
    GROUP1_sequence GROUP1_;
    ID_optional ID_;
    name_optional name_;
    ref_optional ref_;
    ucd_optional ucd_;
    utype_optional utype_;
  };

  class FIELDref: public ::xml_schema::type
  {
    public:
    // ref
    // 
    typedef ::xml_schema::idref ref_type;
    typedef ::xsd::cxx::tree::traits< ref_type, char > ref_traits;

    const ref_type&
    ref () const;

    ref_type&
    ref ();

    void
    ref (const ref_type& x);

    void
    ref (::std::auto_ptr< ref_type > p);

    // Constructors.
    //
    FIELDref (const ref_type&);

    FIELDref (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    FIELDref (const FIELDref& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual FIELDref*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~FIELDref ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< ref_type > ref_;
  };

  class PARAMref: public ::xml_schema::type
  {
    public:
    // ref
    // 
    typedef ::xml_schema::idref ref_type;
    typedef ::xsd::cxx::tree::traits< ref_type, char > ref_traits;

    const ref_type&
    ref () const;

    ref_type&
    ref ();

    void
    ref (const ref_type& x);

    void
    ref (::std::auto_ptr< ref_type > p);

    // Constructors.
    //
    PARAMref (const ref_type&);

    PARAMref (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    PARAMref (const PARAMref& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

    virtual PARAMref*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~PARAMref ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< ref_type > ref_;
  };

  class VALUES: public ::xml_schema::type
  {
    public:
    // MIN
    // 
    typedef ::votable_11::MIN MIN_type;
    typedef ::xsd::cxx::tree::optional< MIN_type > MIN_optional;
    typedef ::xsd::cxx::tree::traits< MIN_type, char > MIN_traits;

    const MIN_optional&
    MIN () const;

    MIN_optional&
    MIN ();

    void
    MIN (const MIN_type& x);

    void
    MIN (const MIN_optional& x);

    void
    MIN (::std::auto_ptr< MIN_type > p);

    // MAX
    // 
    typedef ::votable_11::MAX MAX_type;
    typedef ::xsd::cxx::tree::optional< MAX_type > MAX_optional;
    typedef ::xsd::cxx::tree::traits< MAX_type, char > MAX_traits;

    const MAX_optional&
    MAX () const;

    MAX_optional&
    MAX ();

    void
    MAX (const MAX_type& x);

    void
    MAX (const MAX_optional& x);

    void
    MAX (::std::auto_ptr< MAX_type > p);

    // OPTION
    // 
    typedef ::votable_11::OPTION OPTION_type;
    typedef ::xsd::cxx::tree::sequence< OPTION_type > OPTION_sequence;
    typedef OPTION_sequence::iterator OPTION_iterator;
    typedef OPTION_sequence::const_iterator OPTION_const_iterator;
    typedef ::xsd::cxx::tree::traits< OPTION_type, char > OPTION_traits;

    const OPTION_sequence&
    OPTION () const;

    OPTION_sequence&
    OPTION ();

    void
    OPTION (const OPTION_sequence& s);

    // ID
    // 
    typedef ::xml_schema::id ID_type;
    typedef ::xsd::cxx::tree::optional< ID_type > ID_optional;
    typedef ::xsd::cxx::tree::traits< ID_type, char > ID_traits;

    const ID_optional&
    ID () const;

    ID_optional&
    ID ();

    void
    ID (const ID_type& x);

    void
    ID (const ID_optional& x);

    void
    ID (::std::auto_ptr< ID_type > p);

    // type
    // 
    typedef ::votable_11::type2 type_type;
    typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

    const type_type&
    type () const;

    type_type&
    type ();

    void
    type (const type_type& x);

    void
    type (::std::auto_ptr< type_type > p);

    static const type_type&
    type_default_value ();

    // null
    // 
    typedef ::xml_schema::token null_type;
    typedef ::xsd::cxx::tree::optional< null_type > null_optional;
    typedef ::xsd::cxx::tree::traits< null_type, char > null_traits;

    const null_optional&
    null () const;

    null_optional&
    null ();

    void
    null (const null_type& x);

    void
    null (const null_optional& x);

    void
    null (::std::auto_ptr< null_type > p);

    // ref
    // 
    typedef ::xml_schema::idref ref_type;
    typedef ::xsd::cxx::tree::optional< ref_type > ref_optional;
    typedef ::xsd::cxx::tree::traits< ref_type, char > ref_traits;

    const ref_optional&
    ref () const;

    ref_optional&
    ref ();

    void
    ref (const ref_type& x);

    void
    ref (const ref_optional& x);

    void
    ref (::std::auto_ptr< ref_type > p);

    // Constructors.
    //
    VALUES ();

    VALUES (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    VALUES (const VALUES& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual VALUES*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~VALUES ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    MIN_optional MIN_;
    MAX_optional MAX_;
    OPTION_sequence OPTION_;
    ID_optional ID_;
    ::xsd::cxx::tree::one< type_type > type_;
    static const type_type type_default_value_;
    null_optional null_;
    ref_optional ref_;
  };

  class MIN: public ::xml_schema::type
  {
    public:
    // value
    // 
    typedef ::xml_schema::string value_type;
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    const value_type&
    value () const;

    value_type&
    value ();

    void
    value (const value_type& x);

    void
    value (::std::auto_ptr< value_type > p);

    // inclusive
    // 
    typedef ::votable_11::yesno inclusive_type;
    typedef ::xsd::cxx::tree::traits< inclusive_type, char > inclusive_traits;

    const inclusive_type&
    inclusive () const;

    inclusive_type&
    inclusive ();

    void
    inclusive (const inclusive_type& x);

    void
    inclusive (::std::auto_ptr< inclusive_type > p);

    static const inclusive_type&
    inclusive_default_value ();

    // Constructors.
    //
    MIN (const value_type&);

    MIN (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

    MIN (const MIN& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

    virtual MIN*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~MIN ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< value_type > value_;
    ::xsd::cxx::tree::one< inclusive_type > inclusive_;
    static const inclusive_type inclusive_default_value_;
  };

  class MAX: public ::xml_schema::type
  {
    public:
    // value
    // 
    typedef ::xml_schema::string value_type;
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    const value_type&
    value () const;

    value_type&
    value ();

    void
    value (const value_type& x);

    void
    value (::std::auto_ptr< value_type > p);

    // inclusive
    // 
    typedef ::votable_11::yesno inclusive_type;
    typedef ::xsd::cxx::tree::traits< inclusive_type, char > inclusive_traits;

    const inclusive_type&
    inclusive () const;

    inclusive_type&
    inclusive ();

    void
    inclusive (const inclusive_type& x);

    void
    inclusive (::std::auto_ptr< inclusive_type > p);

    static const inclusive_type&
    inclusive_default_value ();

    // Constructors.
    //
    MAX (const value_type&);

    MAX (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

    MAX (const MAX& x,
         ::xml_schema::flags f = 0,
         ::xml_schema::container* c = 0);

    virtual MAX*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~MAX ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< value_type > value_;
    ::xsd::cxx::tree::one< inclusive_type > inclusive_;
    static const inclusive_type inclusive_default_value_;
  };

  class OPTION: public ::xml_schema::type
  {
    public:
    // OPTION
    // 
    typedef ::votable_11::OPTION OPTION1_type;
    typedef ::xsd::cxx::tree::sequence< OPTION1_type > OPTION1_sequence;
    typedef OPTION1_sequence::iterator OPTION1_iterator;
    typedef OPTION1_sequence::const_iterator OPTION1_const_iterator;
    typedef ::xsd::cxx::tree::traits< OPTION1_type, char > OPTION1_traits;

    const OPTION1_sequence&
    OPTION1 () const;

    OPTION1_sequence&
    OPTION1 ();

    void
    OPTION1 (const OPTION1_sequence& s);

    // name
    // 
    typedef ::xml_schema::token name_type;
    typedef ::xsd::cxx::tree::optional< name_type > name_optional;
    typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

    const name_optional&
    name () const;

    name_optional&
    name ();

    void
    name (const name_type& x);

    void
    name (const name_optional& x);

    void
    name (::std::auto_ptr< name_type > p);

    // value
    // 
    typedef ::xml_schema::string value_type;
    typedef ::xsd::cxx::tree::optional< value_type > value_optional;
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    const value_optional&
    value () const;

    value_optional&
    value ();

    void
    value (const value_type& x);

    void
    value (const value_optional& x);

    void
    value (::std::auto_ptr< value_type > p);

    // Constructors.
    //
    OPTION ();

    OPTION (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    OPTION (const OPTION& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual OPTION*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~OPTION ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    OPTION1_sequence OPTION1_;
    name_optional name_;
    value_optional value_;
  };

  class LINK: public ::xml_schema::type
  {
    public:
    // ID
    // 
    typedef ::xml_schema::id ID_type;
    typedef ::xsd::cxx::tree::optional< ID_type > ID_optional;
    typedef ::xsd::cxx::tree::traits< ID_type, char > ID_traits;

    const ID_optional&
    ID () const;

    ID_optional&
    ID ();

    void
    ID (const ID_type& x);

    void
    ID (const ID_optional& x);

    void
    ID (::std::auto_ptr< ID_type > p);

    // content-role
    // 
    typedef ::votable_11::content_role content_role_type;
    typedef ::xsd::cxx::tree::optional< content_role_type > content_role_optional;
    typedef ::xsd::cxx::tree::traits< content_role_type, char > content_role_traits;

    const content_role_optional&
    content_role () const;

    content_role_optional&
    content_role ();

    void
    content_role (const content_role_type& x);

    void
    content_role (const content_role_optional& x);

    void
    content_role (::std::auto_ptr< content_role_type > p);

    // content-type
    // 
    typedef ::xml_schema::token content_type_type;
    typedef ::xsd::cxx::tree::optional< content_type_type > content_type_optional;
    typedef ::xsd::cxx::tree::traits< content_type_type, char > content_type_traits;

    const content_type_optional&
    content_type () const;

    content_type_optional&
    content_type ();

    void
    content_type (const content_type_type& x);

    void
    content_type (const content_type_optional& x);

    void
    content_type (::std::auto_ptr< content_type_type > p);

    // title
    // 
    typedef ::xml_schema::string title_type;
    typedef ::xsd::cxx::tree::optional< title_type > title_optional;
    typedef ::xsd::cxx::tree::traits< title_type, char > title_traits;

    const title_optional&
    title () const;

    title_optional&
    title ();

    void
    title (const title_type& x);

    void
    title (const title_optional& x);

    void
    title (::std::auto_ptr< title_type > p);

    // value
    // 
    typedef ::xml_schema::string value_type;
    typedef ::xsd::cxx::tree::optional< value_type > value_optional;
    typedef ::xsd::cxx::tree::traits< value_type, char > value_traits;

    const value_optional&
    value () const;

    value_optional&
    value ();

    void
    value (const value_type& x);

    void
    value (const value_optional& x);

    void
    value (::std::auto_ptr< value_type > p);

    // href
    // 
    typedef ::xml_schema::uri href_type;
    typedef ::xsd::cxx::tree::optional< href_type > href_optional;
    typedef ::xsd::cxx::tree::traits< href_type, char > href_traits;

    const href_optional&
    href () const;

    href_optional&
    href ();

    void
    href (const href_type& x);

    void
    href (const href_optional& x);

    void
    href (::std::auto_ptr< href_type > p);

    // gref
    // 
    typedef ::xml_schema::token gref_type;
    typedef ::xsd::cxx::tree::optional< gref_type > gref_optional;
    typedef ::xsd::cxx::tree::traits< gref_type, char > gref_traits;

    const gref_optional&
    gref () const;

    gref_optional&
    gref ();

    void
    gref (const gref_type& x);

    void
    gref (const gref_optional& x);

    void
    gref (::std::auto_ptr< gref_type > p);

    // action
    // 
    typedef ::xml_schema::uri action_type;
    typedef ::xsd::cxx::tree::optional< action_type > action_optional;
    typedef ::xsd::cxx::tree::traits< action_type, char > action_traits;

    const action_optional&
    action () const;

    action_optional&
    action ();

    void
    action (const action_type& x);

    void
    action (const action_optional& x);

    void
    action (::std::auto_ptr< action_type > p);

    // Constructors.
    //
    LINK ();

    LINK (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    LINK (const LINK& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual LINK*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~LINK ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ID_optional ID_;
    content_role_optional content_role_;
    content_type_optional content_type_;
    title_optional title_;
    value_optional value_;
    href_optional href_;
    gref_optional gref_;
    action_optional action_;
  };

  class DATA: public ::xml_schema::type
  {
    public:
    // TABLEDATA
    // 
    typedef ::votable_11::TABLEDATA TABLEDATA_type;
    typedef ::xsd::cxx::tree::optional< TABLEDATA_type > TABLEDATA_optional;
    typedef ::xsd::cxx::tree::traits< TABLEDATA_type, char > TABLEDATA_traits;

    const TABLEDATA_optional&
    TABLEDATA () const;

    TABLEDATA_optional&
    TABLEDATA ();

    void
    TABLEDATA (const TABLEDATA_type& x);

    void
    TABLEDATA (const TABLEDATA_optional& x);

    void
    TABLEDATA (::std::auto_ptr< TABLEDATA_type > p);

    // BINARY
    // 
    typedef ::votable_11::BINARY BINARY_type;
    typedef ::xsd::cxx::tree::optional< BINARY_type > BINARY_optional;
    typedef ::xsd::cxx::tree::traits< BINARY_type, char > BINARY_traits;

    const BINARY_optional&
    BINARY () const;

    BINARY_optional&
    BINARY ();

    void
    BINARY (const BINARY_type& x);

    void
    BINARY (const BINARY_optional& x);

    void
    BINARY (::std::auto_ptr< BINARY_type > p);

    // FITS
    // 
    typedef ::votable_11::FITS FITS_type;
    typedef ::xsd::cxx::tree::optional< FITS_type > FITS_optional;
    typedef ::xsd::cxx::tree::traits< FITS_type, char > FITS_traits;

    const FITS_optional&
    FITS () const;

    FITS_optional&
    FITS ();

    void
    FITS (const FITS_type& x);

    void
    FITS (const FITS_optional& x);

    void
    FITS (::std::auto_ptr< FITS_type > p);

    // Constructors.
    //
    DATA ();

    DATA (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    DATA (const DATA& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual DATA*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~DATA ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    TABLEDATA_optional TABLEDATA_;
    BINARY_optional BINARY_;
    FITS_optional FITS_;
  };

  class TABLEDATA: public ::xml_schema::type
  {
    public:
    // TR
    // 
    typedef ::votable_11::TR TR_type;
    typedef ::xsd::cxx::tree::sequence< TR_type > TR_sequence;
    typedef TR_sequence::iterator TR_iterator;
    typedef TR_sequence::const_iterator TR_const_iterator;
    typedef ::xsd::cxx::tree::traits< TR_type, char > TR_traits;

    const TR_sequence&
    TR () const;

    TR_sequence&
    TR ();

    void
    TR (const TR_sequence& s);

    // Constructors.
    //
    TABLEDATA ();

    TABLEDATA (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    TABLEDATA (const TABLEDATA& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

    virtual TABLEDATA*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~TABLEDATA ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    TR_sequence TR_;
  };

  class TD: public ::xml_schema::string
  {
    public:
    // encoding
    // 
    typedef ::votable_11::encodingType encoding_type;
    typedef ::xsd::cxx::tree::optional< encoding_type > encoding_optional;
    typedef ::xsd::cxx::tree::traits< encoding_type, char > encoding_traits;

    const encoding_optional&
    encoding () const;

    encoding_optional&
    encoding ();

    void
    encoding (const encoding_type& x);

    void
    encoding (const encoding_optional& x);

    void
    encoding (::std::auto_ptr< encoding_type > p);

    // Constructors.
    //
    TD ();

    TD (const char*);

    TD (const ::std::string&);

    TD (const ::xml_schema::string&);

    TD (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    TD (const TD& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    virtual TD*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~TD ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    encoding_optional encoding_;
  };

  class TR: public ::xml_schema::type
  {
    public:
    // TD
    // 
    typedef ::votable_11::TD TD_type;
    typedef ::xsd::cxx::tree::sequence< TD_type > TD_sequence;
    typedef TD_sequence::iterator TD_iterator;
    typedef TD_sequence::const_iterator TD_const_iterator;
    typedef ::xsd::cxx::tree::traits< TD_type, char > TD_traits;

    const TD_sequence&
    TD () const;

    TD_sequence&
    TD ();

    void
    TD (const TD_sequence& s);

    // Constructors.
    //
    TR ();

    TR (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    TR (const TR& x,
        ::xml_schema::flags f = 0,
        ::xml_schema::container* c = 0);

    virtual TR*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~TR ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    TD_sequence TD_;
  };

  class FITS: public ::xml_schema::type
  {
    public:
    // STREAM
    // 
    typedef ::votable_11::STREAM STREAM_type;
    typedef ::xsd::cxx::tree::traits< STREAM_type, char > STREAM_traits;

    const STREAM_type&
    STREAM () const;

    STREAM_type&
    STREAM ();

    void
    STREAM (const STREAM_type& x);

    void
    STREAM (::std::auto_ptr< STREAM_type > p);

    // extnum
    // 
    typedef ::xml_schema::positive_integer extnum_type;
    typedef ::xsd::cxx::tree::optional< extnum_type > extnum_optional;
    typedef ::xsd::cxx::tree::traits< extnum_type, char > extnum_traits;

    const extnum_optional&
    extnum () const;

    extnum_optional&
    extnum ();

    void
    extnum (const extnum_type& x);

    void
    extnum (const extnum_optional& x);

    // Constructors.
    //
    FITS (const STREAM_type&);

    FITS (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    FITS (const FITS& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual FITS*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~FITS ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< STREAM_type > STREAM_;
    extnum_optional extnum_;
  };

  class BINARY: public ::xml_schema::type
  {
    public:
    // STREAM
    // 
    typedef ::votable_11::STREAM STREAM_type;
    typedef ::xsd::cxx::tree::traits< STREAM_type, char > STREAM_traits;

    const STREAM_type&
    STREAM () const;

    STREAM_type&
    STREAM ();

    void
    STREAM (const STREAM_type& x);

    void
    STREAM (::std::auto_ptr< STREAM_type > p);

    // Constructors.
    //
    BINARY (const STREAM_type&);

    BINARY (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    BINARY (const BINARY& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual BINARY*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~BINARY ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< STREAM_type > STREAM_;
  };

  class STREAM: public ::xml_schema::string
  {
    public:
    // type
    // 
    typedef ::votable_11::type3 type_type;
    typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

    const type_type&
    type () const;

    type_type&
    type ();

    void
    type (const type_type& x);

    void
    type (::std::auto_ptr< type_type > p);

    static const type_type&
    type_default_value ();

    // href
    // 
    typedef ::xml_schema::uri href_type;
    typedef ::xsd::cxx::tree::optional< href_type > href_optional;
    typedef ::xsd::cxx::tree::traits< href_type, char > href_traits;

    const href_optional&
    href () const;

    href_optional&
    href ();

    void
    href (const href_type& x);

    void
    href (const href_optional& x);

    void
    href (::std::auto_ptr< href_type > p);

    // actuate
    // 
    typedef ::votable_11::actuate actuate_type;
    typedef ::xsd::cxx::tree::traits< actuate_type, char > actuate_traits;

    const actuate_type&
    actuate () const;

    actuate_type&
    actuate ();

    void
    actuate (const actuate_type& x);

    void
    actuate (::std::auto_ptr< actuate_type > p);

    static const actuate_type&
    actuate_default_value ();

    // encoding
    // 
    typedef ::votable_11::encodingType encoding_type;
    typedef ::xsd::cxx::tree::traits< encoding_type, char > encoding_traits;

    const encoding_type&
    encoding () const;

    encoding_type&
    encoding ();

    void
    encoding (const encoding_type& x);

    void
    encoding (::std::auto_ptr< encoding_type > p);

    static const encoding_type&
    encoding_default_value ();

    // expires
    // 
    typedef ::xml_schema::date_time expires_type;
    typedef ::xsd::cxx::tree::optional< expires_type > expires_optional;
    typedef ::xsd::cxx::tree::traits< expires_type, char > expires_traits;

    const expires_optional&
    expires () const;

    expires_optional&
    expires ();

    void
    expires (const expires_type& x);

    void
    expires (const expires_optional& x);

    void
    expires (::std::auto_ptr< expires_type > p);

    // rights
    // 
    typedef ::xml_schema::token rights_type;
    typedef ::xsd::cxx::tree::optional< rights_type > rights_optional;
    typedef ::xsd::cxx::tree::traits< rights_type, char > rights_traits;

    const rights_optional&
    rights () const;

    rights_optional&
    rights ();

    void
    rights (const rights_type& x);

    void
    rights (const rights_optional& x);

    void
    rights (::std::auto_ptr< rights_type > p);

    // Constructors.
    //
    STREAM ();

    STREAM (const char*);

    STREAM (const ::std::string&);

    STREAM (const ::xml_schema::string&);

    STREAM (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    STREAM (const STREAM& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual STREAM*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~STREAM ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< type_type > type_;
    static const type_type type_default_value_;
    href_optional href_;
    ::xsd::cxx::tree::one< actuate_type > actuate_;
    static const actuate_type actuate_default_value_;
    ::xsd::cxx::tree::one< encoding_type > encoding_;
    static const encoding_type encoding_default_value_;
    expires_optional expires_;
    rights_optional rights_;
  };

  class COOSYS: public ::xml_schema::string
  {
    public:
    // ID
    // 
    typedef ::xml_schema::id ID_type;
    typedef ::xsd::cxx::tree::traits< ID_type, char > ID_traits;

    const ID_type&
    ID () const;

    ID_type&
    ID ();

    void
    ID (const ID_type& x);

    void
    ID (::std::auto_ptr< ID_type > p);

    // equinox
    // 
    typedef ::votable_11::astroYear equinox_type;
    typedef ::xsd::cxx::tree::optional< equinox_type > equinox_optional;
    typedef ::xsd::cxx::tree::traits< equinox_type, char > equinox_traits;

    const equinox_optional&
    equinox () const;

    equinox_optional&
    equinox ();

    void
    equinox (const equinox_type& x);

    void
    equinox (const equinox_optional& x);

    void
    equinox (::std::auto_ptr< equinox_type > p);

    // epoch
    // 
    typedef ::votable_11::astroYear epoch_type;
    typedef ::xsd::cxx::tree::optional< epoch_type > epoch_optional;
    typedef ::xsd::cxx::tree::traits< epoch_type, char > epoch_traits;

    const epoch_optional&
    epoch () const;

    epoch_optional&
    epoch ();

    void
    epoch (const epoch_type& x);

    void
    epoch (const epoch_optional& x);

    void
    epoch (::std::auto_ptr< epoch_type > p);

    // system
    // 
    typedef ::votable_11::system system_type;
    typedef ::xsd::cxx::tree::traits< system_type, char > system_traits;

    const system_type&
    system () const;

    system_type&
    system ();

    void
    system (const system_type& x);

    void
    system (::std::auto_ptr< system_type > p);

    static const system_type&
    system_default_value ();

    // Constructors.
    //
    COOSYS (const ID_type&);

    COOSYS (const char*,
            const ID_type&);

    COOSYS (const ::std::string&,
            const ID_type&);

    COOSYS (const ::xml_schema::string&,
            const ID_type&);

    COOSYS (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    COOSYS (const COOSYS& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual COOSYS*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~COOSYS ();

    // Implementation.
    //
    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::flags);

    protected:
    ::xsd::cxx::tree::one< ID_type > ID_;
    equinox_optional equinox_;
    epoch_optional epoch_;
    ::xsd::cxx::tree::one< system_type > system_;
    static const system_type system_default_value_;
  };

  class version: public ::xml_schema::nmtoken
  {
    public:
    // Constructors.
    //
    version (const char*);

    version (const ::std::string&);

    version (const ::xml_schema::nmtoken&);

    version (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    version (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    version (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    version (const version& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual version*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    virtual 
    ~version ();
  };

  class type: public ::xml_schema::nmtoken
  {
    public:
    enum value
    {
      results,
      meta
    };

    type (value v);

    type (const char* v);

    type (const ::std::string& v);

    type (const ::xml_schema::nmtoken& v);

    type (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    type (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    type (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    type (const type& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

    virtual type*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    type&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_type_convert ();
    }

    protected:
    value
    _xsd_type_convert () const;

    public:
    static const char* const _xsd_type_literals_[2];
    static const value _xsd_type_indexes_[2];
  };

  class type1: public ::xml_schema::nmtoken
  {
    public:
    enum value
    {
      hidden,
      no_query,
      trigger,
      location
    };

    type1 (value v);

    type1 (const char* v);

    type1 (const ::std::string& v);

    type1 (const ::xml_schema::nmtoken& v);

    type1 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    type1 (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    type1 (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    type1 (const type1& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual type1*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    type1&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_type1_convert ();
    }

    protected:
    value
    _xsd_type1_convert () const;

    public:
    static const char* const _xsd_type1_literals_[4];
    static const value _xsd_type1_indexes_[4];
  };

  class type2: public ::xml_schema::nmtoken
  {
    public:
    enum value
    {
      legal,
      actual
    };

    type2 (value v);

    type2 (const char* v);

    type2 (const ::std::string& v);

    type2 (const ::xml_schema::nmtoken& v);

    type2 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    type2 (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    type2 (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    type2 (const type2& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual type2*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    type2&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_type2_convert ();
    }

    protected:
    value
    _xsd_type2_convert () const;

    public:
    static const char* const _xsd_type2_literals_[2];
    static const value _xsd_type2_indexes_[2];
  };

  class content_role: public ::xml_schema::nmtoken
  {
    public:
    enum value
    {
      query,
      hints,
      doc,
      location
    };

    content_role (value v);

    content_role (const char* v);

    content_role (const ::std::string& v);

    content_role (const ::xml_schema::nmtoken& v);

    content_role (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    content_role (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    content_role (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    content_role (const content_role& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

    virtual content_role*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    content_role&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_content_role_convert ();
    }

    protected:
    value
    _xsd_content_role_convert () const;

    public:
    static const char* const _xsd_content_role_literals_[4];
    static const value _xsd_content_role_indexes_[4];
  };

  class type3: public ::xml_schema::nmtoken
  {
    public:
    enum value
    {
      locator,
      other
    };

    type3 (value v);

    type3 (const char* v);

    type3 (const ::std::string& v);

    type3 (const ::xml_schema::nmtoken& v);

    type3 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    type3 (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    type3 (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    type3 (const type3& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

    virtual type3*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    type3&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_type3_convert ();
    }

    protected:
    value
    _xsd_type3_convert () const;

    public:
    static const char* const _xsd_type3_literals_[2];
    static const value _xsd_type3_indexes_[2];
  };

  class actuate: public ::xml_schema::nmtoken
  {
    public:
    enum value
    {
      onLoad,
      onRequest,
      other,
      none
    };

    actuate (value v);

    actuate (const char* v);

    actuate (const ::std::string& v);

    actuate (const ::xml_schema::nmtoken& v);

    actuate (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    actuate (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    actuate (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    actuate (const actuate& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

    virtual actuate*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    actuate&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_actuate_convert ();
    }

    protected:
    value
    _xsd_actuate_convert () const;

    public:
    static const char* const _xsd_actuate_literals_[4];
    static const value _xsd_actuate_indexes_[4];
  };

  class system: public ::xml_schema::nmtoken
  {
    public:
    enum value
    {
      eq_FK4,
      eq_FK5,
      ICRS,
      ecl_FK4,
      ecl_FK5,
      galactic,
      supergalactic,
      xy,
      barycentric,
      geo_app
    };

    system (value v);

    system (const char* v);

    system (const ::std::string& v);

    system (const ::xml_schema::nmtoken& v);

    system (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    system (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    system (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    system (const system& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

    virtual system*
    _clone (::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0) const;

    system&
    operator= (value v);

    virtual
    operator value () const
    {
      return _xsd_system_convert ();
    }

    protected:
    value
    _xsd_system_convert () const;

    public:
    static const char* const _xsd_system_literals_[10];
    static const value _xsd_system_indexes_[10];
  };
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace votable_11
{
  // Parse a URI or a local file.
  //

  ::std::auto_ptr< ::votable_11::VOTABLE >
  VOTABLE_read (const ::std::string& uri,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::votable_11::VOTABLE >
  VOTABLE_read (const ::std::string& uri,
                ::xml_schema::error_handler& eh,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::votable_11::VOTABLE >
  VOTABLE_read (const ::std::string& uri,
                ::xercesc::DOMErrorHandler& eh,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse std::istream.
  //

  ::std::auto_ptr< ::votable_11::VOTABLE >
  VOTABLE_read (::std::istream& is,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::votable_11::VOTABLE >
  VOTABLE_read (::std::istream& is,
                ::xml_schema::error_handler& eh,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::votable_11::VOTABLE >
  VOTABLE_read (::std::istream& is,
                ::xercesc::DOMErrorHandler& eh,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::votable_11::VOTABLE >
  VOTABLE_read (::std::istream& is,
                const ::std::string& id,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::votable_11::VOTABLE >
  VOTABLE_read (::std::istream& is,
                const ::std::string& id,
                ::xml_schema::error_handler& eh,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::votable_11::VOTABLE >
  VOTABLE_read (::std::istream& is,
                const ::std::string& id,
                ::xercesc::DOMErrorHandler& eh,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse xercesc::InputSource.
  //

  ::std::auto_ptr< ::votable_11::VOTABLE >
  VOTABLE_read (::xercesc::InputSource& is,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::votable_11::VOTABLE >
  VOTABLE_read (::xercesc::InputSource& is,
                ::xml_schema::error_handler& eh,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::votable_11::VOTABLE >
  VOTABLE_read (::xercesc::InputSource& is,
                ::xercesc::DOMErrorHandler& eh,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties& p = ::xml_schema::properties ());

  // Parse xercesc::DOMDocument.
  //

  ::std::auto_ptr< ::votable_11::VOTABLE >
  VOTABLE_read (const ::xercesc::DOMDocument& d,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties& p = ::xml_schema::properties ());

  ::std::auto_ptr< ::votable_11::VOTABLE >
  VOTABLE_read (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                ::xml_schema::flags f = 0,
                const ::xml_schema::properties& p = ::xml_schema::properties ());
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace votable_11
{
  void
  operator<< (::xercesc::DOMElement&, const anyTEXT&);

  void
  operator<< (::xercesc::DOMElement&, const astroYear&);

  void
  operator<< (::xercesc::DOMAttr&, const astroYear&);

  void
  operator<< (::xml_schema::list_stream&,
              const astroYear&);

  void
  operator<< (::xercesc::DOMElement&, const ucdType&);

  void
  operator<< (::xercesc::DOMAttr&, const ucdType&);

  void
  operator<< (::xml_schema::list_stream&,
              const ucdType&);

  void
  operator<< (::xercesc::DOMElement&, const arrayDEF&);

  void
  operator<< (::xercesc::DOMAttr&, const arrayDEF&);

  void
  operator<< (::xml_schema::list_stream&,
              const arrayDEF&);

  void
  operator<< (::xercesc::DOMElement&, const encodingType&);

  void
  operator<< (::xercesc::DOMAttr&, const encodingType&);

  void
  operator<< (::xml_schema::list_stream&,
              const encodingType&);

  void
  operator<< (::xercesc::DOMElement&, const dataType&);

  void
  operator<< (::xercesc::DOMAttr&, const dataType&);

  void
  operator<< (::xml_schema::list_stream&,
              const dataType&);

  void
  operator<< (::xercesc::DOMElement&, const precType&);

  void
  operator<< (::xercesc::DOMAttr&, const precType&);

  void
  operator<< (::xml_schema::list_stream&,
              const precType&);

  void
  operator<< (::xercesc::DOMElement&, const yesno&);

  void
  operator<< (::xercesc::DOMAttr&, const yesno&);

  void
  operator<< (::xml_schema::list_stream&,
              const yesno&);

  // Serialize to std::ostream.
  //

  void
  VOTABLE_write (::std::ostream& os,
                 const ::votable_11::VOTABLE& x, 
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::flags f = 0);

  void
  VOTABLE_write (::std::ostream& os,
                 const ::votable_11::VOTABLE& x, 
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::error_handler& eh,
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::flags f = 0);

  void
  VOTABLE_write (::std::ostream& os,
                 const ::votable_11::VOTABLE& x, 
                 const ::xml_schema::namespace_infomap& m,
                 ::xercesc::DOMErrorHandler& eh,
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::flags f = 0);

  // Serialize to xercesc::XMLFormatTarget.
  //

  void
  VOTABLE_write (::xercesc::XMLFormatTarget& ft,
                 const ::votable_11::VOTABLE& x, 
                 const ::xml_schema::namespace_infomap& m,
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::flags f = 0);

  void
  VOTABLE_write (::xercesc::XMLFormatTarget& ft,
                 const ::votable_11::VOTABLE& x, 
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::error_handler& eh,
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::flags f = 0);

  void
  VOTABLE_write (::xercesc::XMLFormatTarget& ft,
                 const ::votable_11::VOTABLE& x, 
                 const ::xml_schema::namespace_infomap& m,
                 ::xercesc::DOMErrorHandler& eh,
                 const ::std::string& e = "UTF-8",
                 ::xml_schema::flags f = 0);

  // Serialize to an existing xercesc::DOMDocument.
  //

  void
  VOTABLE_write (::xercesc::DOMDocument& d,
                 const ::votable_11::VOTABLE& x,
                 ::xml_schema::flags f = 0);

  // Serialize to a new xercesc::DOMDocument.
  //

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  VOTABLE_write (const ::votable_11::VOTABLE& x, 
                 const ::xml_schema::namespace_infomap& m,
                 ::xml_schema::flags f = 0);

  void
  operator<< (::xercesc::DOMElement&, const VOTABLE&);

  void
  operator<< (::xercesc::DOMElement&, const RESOURCE&);

  void
  operator<< (::xercesc::DOMElement&, const DEFINITIONS&);

  void
  operator<< (::xercesc::DOMElement&, const INFO&);

  void
  operator<< (::xercesc::DOMElement&, const PARAM&);

  void
  operator<< (::xercesc::DOMElement&, const TABLE&);

  void
  operator<< (::xercesc::DOMElement&, const FIELD&);

  void
  operator<< (::xercesc::DOMElement&, const GROUP&);

  void
  operator<< (::xercesc::DOMElement&, const FIELDref&);

  void
  operator<< (::xercesc::DOMElement&, const PARAMref&);

  void
  operator<< (::xercesc::DOMElement&, const VALUES&);

  void
  operator<< (::xercesc::DOMElement&, const MIN&);

  void
  operator<< (::xercesc::DOMElement&, const MAX&);

  void
  operator<< (::xercesc::DOMElement&, const OPTION&);

  void
  operator<< (::xercesc::DOMElement&, const LINK&);

  void
  operator<< (::xercesc::DOMElement&, const DATA&);

  void
  operator<< (::xercesc::DOMElement&, const TABLEDATA&);

  void
  operator<< (::xercesc::DOMElement&, const TD&);

  void
  operator<< (::xercesc::DOMElement&, const TR&);

  void
  operator<< (::xercesc::DOMElement&, const FITS&);

  void
  operator<< (::xercesc::DOMElement&, const BINARY&);

  void
  operator<< (::xercesc::DOMElement&, const STREAM&);

  void
  operator<< (::xercesc::DOMElement&, const COOSYS&);

  void
  operator<< (::xercesc::DOMElement&, const version&);

  void
  operator<< (::xercesc::DOMAttr&, const version&);

  void
  operator<< (::xml_schema::list_stream&,
              const version&);

  void
  operator<< (::xercesc::DOMElement&, const type&);

  void
  operator<< (::xercesc::DOMAttr&, const type&);

  void
  operator<< (::xml_schema::list_stream&,
              const type&);

  void
  operator<< (::xercesc::DOMElement&, const type1&);

  void
  operator<< (::xercesc::DOMAttr&, const type1&);

  void
  operator<< (::xml_schema::list_stream&,
              const type1&);

  void
  operator<< (::xercesc::DOMElement&, const type2&);

  void
  operator<< (::xercesc::DOMAttr&, const type2&);

  void
  operator<< (::xml_schema::list_stream&,
              const type2&);

  void
  operator<< (::xercesc::DOMElement&, const content_role&);

  void
  operator<< (::xercesc::DOMAttr&, const content_role&);

  void
  operator<< (::xml_schema::list_stream&,
              const content_role&);

  void
  operator<< (::xercesc::DOMElement&, const type3&);

  void
  operator<< (::xercesc::DOMAttr&, const type3&);

  void
  operator<< (::xml_schema::list_stream&,
              const type3&);

  void
  operator<< (::xercesc::DOMElement&, const actuate&);

  void
  operator<< (::xercesc::DOMAttr&, const actuate&);

  void
  operator<< (::xml_schema::list_stream&,
              const actuate&);

  void
  operator<< (::xercesc::DOMElement&, const system&);

  void
  operator<< (::xercesc::DOMAttr&, const system&);

  void
  operator<< (::xml_schema::list_stream&,
              const system&);
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // VOTABLE1_1_HXX
