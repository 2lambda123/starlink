      SUBROUTINE FDVDLD (IENTRY,IIX,IIY)
      DIMENSION       XP(70),  YP(70),  TEMP(70)
C
C THE VARIABLES IN DSAVE5 HAVE TO BE SAVED FOR THE NEXT CALL TO FDVDLD.
C
      COMMON /DSAVE5/ XSAVE(70), YSAVE(70), XSVN, YSVN, XSV1, YSV1,
     1                SLP1, SLPN, SSLP1, SSLPN, N, NSEG
C
C IOFFS IS AN INTERNAL PARAMETER. IT IS INITIALIZED IN DASHBD AND
C REFERENCED IN FDVDLD AND DRAWPV.
C
      COMMON /SMFLAG/ IOFFS
C
C IFSTF2 IS A FLAG TO CONTROL THAT FRSTD IS CALLED BEFORE VECTD IS
C CALLED.
C
      COMMON /DFFLAG/ IFSTF2
C
C IFLAG CONTROLS IF LASTD CAN BE CALLED DIRECTLY OR IF IT WAS JUST
C CALLED FROM BY VECTD SO THAT THIS CALL CAN BE IGNORED.
C
      COMMON /FDFLAG/ IFLAG
C
C NOTE THAT THIS IFSTF2 FLAG CANNOT BE IDENTICAL TO THE IFSTFL FLAG
C IN THE ROUTINE CFVLD, BECAUSE A CALL TO THE FRSTD ENTRY OF FDVDLD DOES
C NOT ELIMINATE THE NECESSITY OF A CALL TO THE FRSTD ENTRY OF CFVLD,
C AND REVERSE.
C
      COMMON/INTPR/IPAU,FPART,TENSN,NP,SMALL,L1,ADDLR,ADDTB,MLLINE,
     1    ICLOSE
      SAVE
C
C
C OTHER CONSTANTS.
C
      DATA PI /3.14159265358/
      DATA IDUMMY /0/
C
C
      GO TO (10,15,35),IENTRY
C
C *************************************
C
C ENTRY  FRSTD (XX,YY)
C
   10 DEG = 180./PI
C
      MX = IIX
      MY = IIY
      IFSTF2 = 0
      SSLP1 = 0.0
      SSLPN = 0.0
      XSVN = 0.0
      YSVN = 0.0
      IF (IOFFS .GE. 1) CALL CFVLD (1,MX,MY)
      IF (IOFFS .GE. 1) RETURN
C
C INITIALIZE THE POINT AND SEGMENT COUNTER
C N COUNTS THE NUMBER OF POINTS/SEGMENT
C
      N = 0
C
C NSEG = 0       FIRST SEGMENT
C NSEG = 1       MORE THAN ONE SEGMENT
C
      NSEG = 0
C
C SAVE THE X,Y COORDINATES OF THE FIRST POINT
C XSV1           CONTAINS THE X COORDINATE OF THE FIRST POINT
C                OF A LINE
C YSV1           CONTAINS THE Y COORDINATE OF THE FIRST POINT
C                OF A LINE
C
      XSV1 = MX
      YSV1 = MY
      GO TO 30
C
C *************************************
C
C     ENTRY VECTD (XX,YY)
C
   15 CONTINUE
C
C TEST FOR PREVIOUS FRSTD CALL
C
      IF (IFSTF2 .EQ. 0) GO TO 20
C
C INFORM USER - NO PREVIOUS CALL TO FRSTD. TREAT CALL AS FRSTD CALL.
C
      CALL SETER(' FDVDLD- VECTD CALL OCCURS BEFORE A CALL TO FRSTD.',
     -            1,1)
      GO TO 10
   20 MX = IIX
      MY = IIY
C
C VECTD          SAVES THE X,Y COORDINATES OF THE ACCEPTED
C                POINTS ON A LINE SEGMENT
C
      IF (IOFFS .GE. 1) CALL CFVLD (2,MX,MY)
      IF (IOFFS .GE. 1) RETURN
C
C IF THE NEW POINT IS TOO CLOSE TO THE PREVIOUS POINT, IGNORE IT
C
      IF (ABS(FLOAT(IFIX(XSVN)-MX))+ABS(FLOAT(IFIX(YSVN)-MY)) .LT.
     1    SMALL) RETURN
      IFLAG = 0
   30 N = N+1
C
C SAVE THE X,Y COORDINATES OF EACH POINT OF THE SEGMENT
C XSAVE          THE ARRAY OF X COORDINATES OF LINE SEGMENT
C YSAVE          THE ARRAY OF Y COORDINATES OF LINE SEGMENT
C
      XSAVE(N) = MX
      YSAVE(N) = MY
      XSVN = XSAVE(N)
      YSVN = YSAVE(N)
      IF (N .GE. L1-1) GO TO 40
      RETURN
C
C *************************************
C
C     ENTRY LASTD
C
   35 CONTINUE
      IF (IFSTF2 .NE. 0) RETURN
      IFSTF2 = 1
C
C LASTD          CHECKS FOR PERIODIC LINES AND SETS UP
C                  THE CALLS TO KURV1S AND KURV2S
C
      IF (IOFFS .GE. 1) CALL CFVLD (3,IDUMMY,IDUMMY)
      IF (IOFFS .GE. 1) RETURN
C
C IFLAG = 0      OK TO CALL LASTD DIRECTLY
C IFLAG = 1      LASTD WAS JUST CALLED FROM BY VECTD
C                IGNORE CALL TO LASTD
C
      IF (IFLAG .EQ. 1) RETURN
C
C COMPARE THE LAST POINT OF SEGMENT WITH FIRST POINT OF LINE
C
   40 IFLAG = 1
C
C IPRD = 0       PERIODIC LINE
C IPRD = 1       NON-PERIODIC LINE
C
      IPRD = 1
      IF (ABS(XSV1-XSVN)+ABS(YSV1-YSVN) .LT. SMALL) IPRD = 0
C
C TAKE CARE OF THE CASE OF ONLY TWO DISTINCT P0INTS ON A LINE
C
      IF (NSEG .GE. 1) GO TO 60
      IF (N-2) 150,140,50
   50 IF (N .GE. 4) GO TO 60
C
      IF (IPRD .NE. 0) GO TO 60
      DX = XSAVE(2)-XSAVE(1)
      DY = YSAVE(2)-YSAVE(1)
      SLOPE = ATAN2(DY,DX)*DEG+90.
      IF (SLOPE .GE. 360.) SLOPE = SLOPE-360.
      IF (SLOPE .LE. 0.) SLOPE = SLOPE+360.
      SLP1 = SLOPE
      SLPN = SLOPE
      ISLPSW = 0
      SIGMA = TENSN
      GO TO 100
   60 SIGMA = TENSN
      IF (IPRD .GE. 1) GO TO 80
      IF (NSEG .GE. 1) GO TO 70
C
C SET UP FLAGS FOR A  1  SEGMENT, PERIODIC LINE
C
      ISLPSW = 4
      XSAVE(N) = XSV1
      YSAVE(N) = YSV1
      GO TO 100
C
C SET UP FLAGS FOR AN N-SEGMENT, PERIODIC LINE
C
   70 SLP1 = SSLPN
      SLPN = SSLP1
      ISLPSW = 0
      GO TO 100
   80 IF (NSEG .GE. 1) GO TO 90
C
C SET UP FLAGS FOR THE 1ST SEGMENT OF A NON-PERIODIC LINE
C
      ISLPSW = 3
      GO TO 100
C
C SET UP FLAGS FOR THE NTH SEGMENT OF A NON-PERIODIC LINE
C
   90 SLP1 = SSLPN
      ISLPSW = 1
C
C CALL THE SMOOTHING ROUTINES
C
  100 CALL KURV1S (N,XSAVE,YSAVE,SLP1,SLPN,XP,YP,TEMP,S,SIGMA,ISLPSW)
C
C DETERMINE THE NUMBER OF POINTS TO INTERPOLATE FOR EACH SEGMENT
C
      IF (NSEG.GE.1 .AND. N.LT.L1-1) GO TO 110
      NPRIME = FLOAT(NP)-(S*FLOAT(NP)*.5)/32767.
      IF (S .GE. 32767.) NPRIME = .5*FLOAT(NP)
      NPL = AMAX1(FLOAT(NPRIME)*S/32767.,2.5)
  110 DT = 1./FLOAT(NPL)
      IX = IFIX (XSAVE(1))
      IY = IFIX (YSAVE(1))
      IF (NSEG .LE. 0) GO TO 112
      CALL DRAWPV (IX,IY,0)
      GO TO 114
  112 CONTINUE
      CALL CFVLD (1,IX,IY)
  114 CONTINUE
      T = 0.0
      NSLPSW = 1
      IF (NSEG .GE. 1) NSLPSW = 0
      NSEG = 1
      CALL KURV2S (T,XS,YS,N,XSAVE,YSAVE,XP,YP,S,SIGMA,NSLPSW,SLP)
C
C SAVE SLOPE AT THE FIRST POINT OF THE LINE
C
      IF (NSLPSW .GE. 1) SSLP1 = SLP
      NSLPSW = 0
      DO 120 I=1,NPL
         T = T+DT
         TT = -T
         IF (I .EQ. NPL) NSLPSW = 1
         CALL KURV2S (TT,XS,YS,N,XSAVE,YSAVE,XP,YP,S,SIGMA,NSLPSW,SLP)
C
C SAVE THE LAST SLOPE OF THIS LINE SEGMENT
C
         IF (NSLPSW .GE. 1) SSLPN = SLP
C
C DRAW EACH PART OF THE LINE SEGMENT
C
         IX = IFIX(XS)
         IY = IFIX (YS)
         CALL CFVLD (2,IX,IY)
  120 CONTINUE
      IF (IPRD .NE. 0) GO TO 130
C
C CONNECT THE LAST POINT WITH THE FIRST POINT OF A PERIODIC LINE
C
      IX = IFIX (XSV1)
      IY = IFIX (YSV1)
      CALL CFVLD (2,IX,IY)
C
C BEGIN THE NEXT LINE SEGMENT WITH THE LAST POINT OF THIS SEGMENT
C
  130 XSAVE(1) = XS
      YSAVE(1) = YS
      N = 1
      IF (IFSTF2 .EQ. 1) CALL CFVLD (3,IDUMMY,IDUMMY)
      GO TO 150
C
C FOR THE CASE WHEN THERE ARE ONLY 2 DISTINCT POINTS ON A LINE.
C
  140 CONTINUE
      IX1 = IFIX(XSAVE(1))
      IY1 = IFIX(YSAVE(1))
      IX2 = IFIX(XSAVE(N))
      IY2 = IFIX (YSAVE(N))
      CALL CUTUP (IX1,IY1,IX2,IY2)
C
  150 CONTINUE
      RETURN
      END
      SUBROUTINE KURV1S (N,X,Y,SLOP1,SLOPN,XP,YP,TEMP,S,SIGMA,ISLPSW)
C
C
C DIMENSION OF           X(N),Y(N),XP(N),YP(N),TEMP(N)
C ARGUMENTS
C
C LATEST REVISION        FEBRUARY 5, 1974
C
C PURPOSE                KURV1S DETERMINES THE PARAMETERS NECESSARY TO
C                        COMPUTE A SPLINE UNDER TENSION PASSING THROUGH
C                        A SEQUENCE OF PAIRS
C                        (X(1),Y(1)),...,(X(N),Y(N)) IN THE PLANE.
C                        THE SLOPES AT THE TWO ENDS OF THE CURVE MAY BE
C                        SPECIFIED OR OMITTED.  FOR ACTUAL COMPUTATION
C                        OF POINTS ON THE CURVE IT IS NECESSARY TO CALL
C                        THE SUBROUTINE KURV2S.
C
C USAGE                  CALL KURV1S(N,X,Y,SLP1,SLPN,XP,YP,TEMP,S,SIGMA)
C
C ARGUMENTS
C
C ON INPUT               N
C                          IS THE NUMBER OF POINTS TO BE INTERPOLATED
C                          (N .GE. 2).
C
C                        X
C                          IS AN ARRAY CONTAINING THE N X-COORDINATES
C                          OF THE POINTS.
C
C                        Y
C                          IS AN ARRAY CONTAINING THE N Y-COORDINATES
C                          OF THE POINTS.
C
C                        SLOP1 AND SLOPN
C                          CONTAIN THE DESIRED VALUES FOR THE SLOPE OF
C                          THE CURVE AT (X(1),Y(1)) AND (X(N),Y(N)),
C                          RESPECTIVELY.  THESE QUANTITIES ARE IN
C                          DEGREES AND MEASURED COUNTER-CLOCKWISE
C                          FROM THE POSITIVE X-AXIS.  IF ISLPSW IS NON-
C                          ZERO, ONE OR BOTH OF SLP1 AND SLPN MAY BE
C                          DETERMINED INTERNALLY BY KURV1S.
C
C                        XP AND YP
C                          ARE ARRAYS OF LENGTH AT LEAST N.
C
C                        TEMP
C                          IS AN ARRAY OF LENGTH AT LEAST N WHICH IS
C                          USED FOR SCRATCH STORAGE.
C
C                        SIGMA
C                          CONTAINS THE TENSION FACTOR.  THIS IS
C                          NON-ZERO AND INDICATES THE CURVINESS DESIRED.
C                          IF ABS(SIGMA) IS VERY LARGE (E.G., 50.) THE
C                          RESULTING CURVE IS VERY NEARLY A POLYGONAL
C                          LINE.  A STANDARD VALUE FOR SIGMA IS ABOUT 2.
C
C                        ISLPSW
C                          IS AN INTEGER INDICATING WHICH END SLOPES
C                          HAVE BEEN USER PROVIDED AND WHICH MUST BE
C                          COMPUTED BY KURV1S.  FOR ISLPSW
C                            = 0  INDICATES BOTH SLOPES ARE PROVIDED,
C                            = 1  ONLY SLOP1 IS PROVIDED,
C                            = 2  ONLY SLOPN IS PROVIDED,
C                            = 3  NEITHER SLOP1 NOR SLOPN IS PROVIDED.
C                            = 4  NEITHER SLOP1 NOR SLOPN IS PROVIDED,
C                                 BUT SLOP1=SLOPN.  IN THIS CASE X(1)=
C                                 X(N), Y(1)=Y(N) AND N.GE.3.
C ON OUTPUT              XP AND YP
C                          CONTAIN INFORMATION ABOUT THE CURVATURE OF
C                          THE CURVE AT THE GIVEN NODES.
C
C                        S
C                          CONTAINS THE POLYGONAL ARCLENGTH OF THE
C                          CURVE.
C
C                        N, X, Y, SLP1, SLPN, SIGMA AND ISLPSW ARE
C                        UNCHANGED.
C
C ENTRY POINTS           KURV1S
C
C SPECIAL CONDITIONS     NONE
C
C COMMON BLOCKS          NONE
C
C I/O                    NONE
C
C PRECISION              SINGLE
C
C REQUIRED ULIB          NONE
C ROUTINES
C
C SPECIALIST             RUSSELL K. REW, NCAR, BOULDER, COLORADO  80302
C
C LANGUAGE               FORTRAN
C
C HISTORY                ORIGINALLY WRITTEN BY A. K. CLINE, MARCH 1972.
C
C
C
C
      INTEGER         N
      REAL            X(N)       ,Y(N)       ,XP(N)      ,YP(N)      ,
     1                TEMP(N)    ,S          ,SIGMA
      SAVE
C
      DATA PI /3.1415926535897932/
C
      NN = N
      JSLPSW = ISLPSW
      SLP1 = SLOP1
      SLPN = SLOPN
      DEGRAD = PI/180.
      NM1 = NN-1
      NP1 = NN+1
      DELX1 = X(2)-X(1)
      DELY1 = Y(2)-Y(1)
      DELS1 = SQRT(DELX1*DELX1+DELY1*DELY1)
      DX1 = DELX1/DELS1
      DY1 = DELY1/DELS1
C
C DETERMINE SLOPES IF NECESSARY
C
      IF (JSLPSW .NE. 0) GO TO 70
   10 SLPP1 = SLP1*DEGRAD
      SLPPN = SLPN*DEGRAD
C
C SET UP RIGHT HAND SIDES OF TRIDIAGONAL LINEAR SYSTEM FOR XP
C AND YP
C
      XP(1) = DX1-COS(SLPP1)
      YP(1) = DY1-SIN(SLPP1)
      TEMP(1) = DELS1
      SS = DELS1
      IF (NN .EQ. 2) GO TO 30
      DO 20 I=2,NM1
         DELX2 = X(I+1)-X(I)
         DELY2 = Y(I+1)-Y(I)
         DELS2 = SQRT(DELX2*DELX2+DELY2*DELY2)
         DX2 = DELX2/DELS2
         DY2 = DELY2/DELS2
         XP(I) = DX2-DX1
         YP(I) = DY2-DY1
         TEMP(I) = DELS2
         DELX1 = DELX2
         DELY1 = DELY2
         DELS1 = DELS2
         DX1 = DX2
         DY1 = DY2
C
C ACCUMULATE POLYGONAL ARCLENGTH
C
         SS = SS+DELS1
   20 CONTINUE
   30 XP(NN) = COS(SLPPN)-DX1
      YP(NN) = SIN(SLPPN)-DY1
C
C DENORMALIZE TENSION FACTOR
C
      SIGMAP = ABS(SIGMA)*FLOAT(NN-1)/SS
C
C PERFORM FORWARD ELIMINATION ON TRIDIAGONAL SYSTEM
C
      S = SS
      DELS = SIGMAP*TEMP(1)
      EXPS = EXP(DELS)
      SINHS = .5*(EXPS-1./EXPS)
      SINHIN = 1./(TEMP(1)*SINHS)
      DIAG1 = SINHIN*(DELS*.5*(EXPS+1./EXPS)-SINHS)
      DIAGIN = 1./DIAG1
      XP(1) = DIAGIN*XP(1)
      YP(1) = DIAGIN*YP(1)
      SPDIAG = SINHIN*(SINHS-DELS)
      TEMP(1) = DIAGIN*SPDIAG
      IF (NN .EQ. 2) GO TO 50
      DO 40 I=2,NM1
         DELS = SIGMAP*TEMP(I)
         EXPS = EXP(DELS)
         SINHS = .5*(EXPS-1./EXPS)
         SINHIN = 1./(TEMP(I)*SINHS)
         DIAG2 = SINHIN*(DELS*(.5*(EXPS+1./EXPS))-SINHS)
         DIAGIN = 1./(DIAG1+DIAG2-SPDIAG*TEMP(I-1))
         XP(I) = DIAGIN*(XP(I)-SPDIAG*XP(I-1))
         YP(I) = DIAGIN*(YP(I)-SPDIAG*YP(I-1))
         SPDIAG = SINHIN*(SINHS-DELS)
         TEMP(I) = DIAGIN*SPDIAG
         DIAG1 = DIAG2
   40 CONTINUE
   50 DIAGIN = 1./(DIAG1-SPDIAG*TEMP(NM1))
      XP(NN) = DIAGIN*(XP(NN)-SPDIAG*XP(NM1))
      YP(NN) = DIAGIN*(YP(NN)-SPDIAG*YP(NM1))
C
C PERFORM BACK SUBSTITUTION
C
      DO 60 I=2,NN
         IBAK = NP1-I
         XP(IBAK) = XP(IBAK)-TEMP(IBAK)*XP(IBAK+1)
         YP(IBAK) = YP(IBAK)-TEMP(IBAK)*YP(IBAK+1)
   60 CONTINUE
      RETURN
   70 IF (NN .EQ. 2) GO TO 100
C
C IF NO SLOPES ARE GIVEN, USE SECOND ORDER INTERPOLATION ON
C INPUT DATA FOR SLOPES AT ENDPOINTS
C
      IF (JSLPSW .EQ. 4) GO TO 90
      IF (JSLPSW .EQ. 2) GO TO 80
      DELNM1 = SQRT((X(NN-2)-X(NM1))**2+(Y(NN-2)-Y(NM1))**2)
      DELN = SQRT((X(NM1)-X(NN))**2+(Y(NM1)-Y(NN))**2)
      DELNN = DELNM1+DELN
      C1 = (DELNN+DELN)/DELNN/DELN
      C2 = -DELNN/DELN/DELNM1
      C3 = DELN/DELNN/DELNM1
      SX = C3*X(NN-2)+C2*X(NM1)+C1*X(NN)
      SY = C3*Y(NN-2)+C2*Y(NM1)+C1*Y(NN)
C
      SLPN = ATAN2(SY,SX)/DEGRAD
   80 IF (JSLPSW .EQ. 1) GO TO 10
      DELS2 = SQRT((X(3)-X(2))**2+(Y(3)-Y(2))**2)
      DELS12 = DELS1+DELS2
      C1 = -(DELS12+DELS1)/DELS12/DELS1
      C2 = DELS12/DELS1/DELS2
      C3 = -DELS1/DELS12/DELS2
      SX = C1*X(1)+C2*X(2)+C3*X(3)
      SY = C1*Y(1)+C2*Y(2)+C3*Y(3)
C
      SLP1 = ATAN2(SY,SX)/DEGRAD
      GO TO 10
   90 DELN = SQRT((X(NM1)-X(NN))**2+(Y(NM1)-Y(NN))**2)
      DELNN = DELS1+DELN
      C1 = -DELS1/DELN/DELNN
      C2 = (DELS1-DELN)/DELS1/DELN
      C3 = DELN/DELNN/DELS1
      SX = C1*X(NM1)+C2*X(1)+C3*X(2)
      SY = C1*Y(NM1)+C2*Y(1)+C3*Y(2)
      IF (SX.EQ.0. .AND. SY.EQ.0.) SX = 1.
      SLP1 = ATAN2(SY,SX)/DEGRAD
      SLPN = SLP1
      GO TO 10
C
C IF ONLY TWO POINTS AND NO SLOPES ARE GIVEN, USE STRAIGHT
C LINE SEGMENT FOR CURVE
C
  100 IF (JSLPSW .NE. 3) GO TO 110
      XP(1) = 0.
      XP(2) = 0.
      YP(1) = 0.
      YP(2) = 0.
C
      SLP1 = ATAN2(Y(2)-Y(1),X(2)-X(1))/DEGRAD
      SLPN = SLP1
      RETURN
C
  110 IF (JSLPSW .EQ. 2)
     1    SLP1 = ATAN2(Y(2)-Y(1)-SLPN*(X(2)-X(1)),
     2                                X(2)-X(1)-SLPN*(Y(2)-Y(1)))/DEGRAD
C
      IF (JSLPSW .EQ. 1)
     1    SLPN = ATAN2(Y(2)-Y(1)-SLP1*(X(2)-X(1)),
     2                                X(2)-X(1)-SLP1*(Y(2)-Y(1)))/DEGRAD
      GO TO 10
      END
      SUBROUTINE KURV2S (T,XS,YS,N,X,Y,XP,YP,S,SIGMA,NSLPSW,SLP)
C
C
C
C DIMENSION OF           X(N),Y(N),XP(N),YP(N)
C ARGUMENTS
C
C LATEST REVISION        OCTOBER 22, 1973
C
C PURPOSE                KURV2S PERFORMS THE MAPPING OF POINTS IN THE
C                        INTERVAL (0.,1.) ONTO A CURVE IN THE PLANE.
C                        THE SUBROUTINE KURV1S SHOULD BE CALLED EARLIER
C                        TO DETERMINE CERTAIN NECESSARY PARAMETERS.
C                        THE RESULTING CURVE HAS A PARAMETRIC
C                        REPRESENTATION BOTH OF WHOSE COMPONENTS ARE
C                        SPLINES UNDER TENSION AND FUNCTIONS OF THE
C                        POLYGONAL ARCLENGTH PARAMETER.
C
C USAGE                  CALL KURV2S (T,XS,YS,N,X,Y,XP,YP,S,SIGMA)
C
C ARGUMENTS
C
C ON INPUT               T
C                          CONTAINS A REAL VALUE OF ABSOLUTE VALUE LESS
C                          THAN OR EQUAL TO 1. TO BE MAPPED TO A POINT
C                          ON THE CURVE.  THE SIGN OF T IS IGNORED AND
C                          THE INTERVAL (0.,1.) IS MAPPED ONTO THE
C                          ENTIRE CURVE.  IF T IS NEGATIVE, THIS
C                          INDICATES THAT THE SUBROUTINE HAS BEEN CALLED
C                          PREVIOUSLY (WITH ALL OTHER INPUT VARIABLES
C                          UNALTERED) AND THAT THIS VALUE OF T EXCEEDS
C                          THE PREVIOUS VALUE IN ABSOLUTE VALUE.  WITH
C                          SUCH INFORMATION THE SUBROUTINE IS ABLE TO
C                          MAP THE POINT MUCH MORE RAPIDLY.  THUS IF THE
C                          USER SEEKS TO MAP A SEQUENCE OF POINTS ONTO
C                          THE SAME CURVE, EFFICIENCY IS GAINED BY
C                          ORDERING THE VALUES INCREASING IN MAGNITUDE
C                          AND SETTING THE SIGNS OF ALL BUT THE FIRST
C                          NEGATIVE.
C
C                        N
C                          CONTAINS THE NUMBER OF POINTS WHICH WERE
C                          INTERPOLATED TO DETERMINE THE CURVE.
C
C                        X AND Y
C                          ARRAYS CONTAINING THE X- AND Y-COORDINATES
C                          OF THE INTERPOLATED POINTS.
C
C                        XP AND YP
C                          ARE THE ARRAYS OUTPUT FROM KURV1 CONTAINING
C                          CURVATURE INFORMATION.
C
C                        S
C                          CONTAINS THE POLYGONAL ARCLENGTH OF THE
C                          CURVE.
C
C                        SIGMA
C                          CONTAINS THE TENSION FACTOR (ITS SIGN IS
C                          IGNORED).
C
C                        NSLPSW
C                          IS AN INTEGER SWITCH WHICH TURNS ON OR OFF
C                          THE CALCULATION OF SLP
C                          NSLPSW
C                                 = 0 INDICATES THAT SLP WILL NOT BE
C                                     CALCULATED
C                                 = 1 SLP WILL BE CALCULATED
C
C                        THE PARAMETERS N, X, Y, XP, YP, S AND SIGMA
C                        SHOULD BE INPUT UNALTERED FROM THE OUTPUT OF
C                        KURV1S.
C
C ON OUTPUT              XS AND YS
C                          CONTAIN THE X- AND Y-COORDINATES OF THE IMAGE
C                          POINT ON THE CURVE.
C
C                        SLP
C                          CONTAINS THE SLOPE OF THE CURVE IN DEGREES AT
C                          THIS POINT.
C
C                        T, N, X, Y, XP, YP, S AND SIGMA ARE UNALTERED.
C
C ENTRY POINTS           KURV2S
C
C SPECIAL CONDITIONS     NONE
C
C COMMON BLOCKS          NONE
C
C I/O                    NONE
C
C PRECISION              SINGLE
C
C REQUIRED ULIB          NONE
C ROUTINES
C
C SPECIALIST             RUSSELL K. REW, NCAR, BOULDER, COLORADO  80302
C
C LANGUAGE               FORTRAN
C
C HISTORY                ORIGINALLY WRITTEN BY A. K. CLINE, MARCH 1972.
C
C
C
C
      INTEGER         N
      REAL            T          ,XS         ,YS         ,X(N)       ,
     1                Y(N)       ,XP(N)      ,YP(N)      ,S          ,
     2                SIGMA      ,SLP
      SAVE
C
      DATA PI /3.1415926535897932/
C
C
C DENORMALIZE SIGMA
C
      SIGMAP = ABS(SIGMA)*FLOAT(N-1)/S
C
C STRETCH UNIT INTERVAL INTO ARCLENGTH DISTANCE
C
      TN = ABS(T*S)
C
C FOR NEGATIVE T START SEARCH WHERE PREVIOUSLY TERMINATED,
C OTHERWISE START FROM BEGINNING
C
      IF (T .LT. 0.) GO TO 10
      DEGRAD = PI/180.
      I1 = 2
      XS = X(1)
      YS = Y(1)
      SUM = 0.
      IF (T .LT. 0.) RETURN
C
C DETERMINE INTO WHICH SEGMENT TN IS MAPPED
C
   10 DO 30 I=I1,N
         DELX = X(I)-X(I-1)
         DELY = Y(I)-Y(I-1)
         DELS = SQRT(DELX*DELX+DELY*DELY)
         IF (SUM+DELS-TN) 20,40,40
   20    SUM = SUM+DELS
   30 CONTINUE
C
C IF ABS(T) IS GREATER THAN 1., RETURN TERMINAL POINT ON
C CURVE
C
      XS = X(N)
      YS = Y(N)
      RETURN
C
C SET UP AND PERFORM INTERPOLATION
C
   40 DEL1 = TN-SUM
      DEL2 = DELS-DEL1
      EXPS1 = EXP(SIGMAP*DEL1)
      SINHD1 = .5*(EXPS1-1./EXPS1)
      EXPS2 = EXP(SIGMAP*DEL2)
      SINHD2 = .5*(EXPS2-1./EXPS2)
      EXPS = EXPS1*EXPS2
      SINHS = .5*(EXPS-1./EXPS)
      XS = (XP(I)*SINHD1+XP(I-1)*SINHD2)/SINHS+
     1     ((X(I)-XP(I))*DEL1+(X(I-1)-XP(I-1))*DEL2)/DELS
      YS = (YP(I)*SINHD1+YP(I-1)*SINHD2)/SINHS+
     1     ((Y(I)-YP(I))*DEL1+(Y(I-1)-YP(I-1))*DEL2)/DELS
      I1 = I
      IF (NSLPSW .EQ. 0) RETURN
      COSHD1 = .5*(EXPS1+1./EXPS1)*SIGMAP
      COSHD2 = .5*(EXPS2+1./EXPS2)*SIGMAP
      XT = (XP(I)*COSHD1-XP(I-1)*COSHD2)/SINHS+
     1     ((X(I)-XP(I))-(X(I-1)-XP(I-1)))/DELS
      YT = (YP(I)*COSHD1-YP(I-1)*COSHD2)/SINHS+
     1     ((Y(I)-YP(I))-(Y(I-1)-YP(I-1)))/DELS
      SLP = ATAN2(YT,XT)/DEGRAD
      RETURN
      END
      SUBROUTINE CUTUP (MX1,MY1,MX2,MY2)
C
C THE CONNECTION LINES BETWEEN POINTS PROCESSED WITH DASHSUPR ARE
C SMOOTHED AND THEREFORE MOST LINE SEGMENTS WILL BE VERY SHORT.
C IN CASE ONLY 2 POINTS ARE BEING PROCESSED NO SMOOTHING WILL BE DONE
C AND VERY LONG LINE SEGMENTS CAN OCCUR.
C SUCH LONG LINES ARE DIVIDED UP INTO SHORT SEGMENTS IN THE ROUTINE
C CUTUP, BECAUSE THE ALGORITHM FOR THE REMOVAL OF CROWDED LINES RELIES
C ON SHORT LINE SEGMENTS.
C
      COMMON/INTPR/IPAU,FPART,TENSN,NP,SMALL,L1,ADDLR,ADDTB,MLLINE,
     1    ICLOSE
      SAVE
C
C POSITION PEN AT THE BEGINNING OF THE LINE.
C
      CALL CFVLD (1,MX1,MY1)
C
C FOR BETTER ACCURACY CHOOSE LONGER COORDINATE AS BASIS FOR ITERATION.
C
      DX = MX2-MX1
      DY = MY2-MY1
      IF (ABS(DX)-ABS(DY)) 60,50,10
C
C DX IS LONGER THAN DY.
C
   10 SLOPE = DY/DX
      IF (DX .LT. 0.) GO TO 30
C
      DO 20 MX=MX1,MX2,MLLINE
         MY = IFIX(FLOAT(MY1)+FLOAT(MX-MX1)*SLOPE+.5)
         CALL CFVLD (2,MX,MY)
   20 CONTINUE
      GOTO 100
C
   30 CONTINUE
      DO 40 MX=MX2,MX1,MLLINE
         MY = IFIX(FLOAT(MY2)+FLOAT(MX-MX2)*SLOPE+.5)
         CALL CFVLD (2,MX,MY)
   40 CONTINUE
      GOTO 100
C
C DX AND DY HAVE SAME LENGTH.
C
   50 IF (DX .NE. 0.) GO TO 10
      CALL CFVLD (2,MX2,MY2)
      RETURN
C
C DY IS LONGER THAN DX.
C
   60 SLOPE = DX/DY
      IF (DY .LT. 0.) GO TO 80
C
      DO 70 MY=MY1,MY2,MLLINE
         MX = IFIX(FLOAT(MX1)+FLOAT(MY-MY1)*SLOPE+.5)
         CALL CFVLD (2,MX,MY)
   70 CONTINUE
      GOTO 100
C
   80 CONTINUE
C
      DO 90 MY=MY2,MY1,MLLINE
         MX = IFIX(FLOAT(MX2)+FLOAT(MY-MY2)*SLOPE+.5)
         CALL CFVLD (2,MX,MY)
   90 CONTINUE
C
  100 CONTINUE
      CALL CFVLD (2,MX2,MY2)
C
      RETURN
      END
      SUBROUTINE DRAWPV (IX,IY,IND)
C
C DRAWPV INTERCEPTS THE CALL TO PLOTIT.
C FOR IND=1 (PEN DOWN) IT CHECKS IF A LINE (PART OF IT) HAS TO BE DRAWN
C OR REMOVED.
C FOR IND=0 (PEN UP) IT CHECKS IF THE PEN HAS TO BE MOVED OR IF IT IS
C ALREADY CLOSE ENOUGH TO THE WANTED POSITION.
C FOR IND=2 DO NOT MOVE PEN.JUST SET POSITION OF PEN TO (IMPOS,IMPOS).
C
      COMMON/INTPR/IPAU,FPART,TENSN,NP,SMALL,L1,ADDLR,ADDTB,MLLINE,
     1    ICLOSE
C IOFFS IS AN INTERNAL PARAMETER. IT IS REFERENCED IN  DRAWPV AND
C FDVDLD AND INITIALIZED IN DASHBD.
C
      COMMON /SMFLAG/ IOFFS
C
C IN DSAVE3 THE STARTING POINT OF THE NEXT LINE SEGMENT TO BE DRAWN
C OR REMOVED IS SAVED.
C
      COMMON /DSAVE3/ IXSTOR,IYSTOR
C
C IX1,IY1,IX2 AND IY2 ARE USED TO STORE THE NEXT LINE SEGMENT TO BE
C MARKED, WHICH IS THE SEGMENT THAT WAS DRAWN LAST.
C
      COMMON /DSAVE4/ IX1,IY1,IX2,IY2
C
C ISKIP IS USED TO ADJUST DASHSUPR TO THE SIZE OF THE MODEL PICTURE AS
C DEFINED IN SUBROUTINE REMOVE. ISKIP IS INITIALIZED IN DASHBD.
C
      COMMON /DSUP1/ ISKIP
C
      LOGICAL LI, LM, HID
      LOGICAL LDUMMY
      SAVE
C
      DATA LDUMMY /.TRUE./
C
C BRANCH DEPENDING ON FUNCTION TO BE PERFORMED.
C
      IIND = IND + 1
      GOTO (2,1,3), IIND
C
    1 CONTINUE
C
C *************************************
C
C INTERCEPT PLOTIT(IX,IY,1) TO CHECK IF THE LINE TO BE DRAWN (PART OF
C IT) HAS TO BE REMOVED. DRAW AND MARK LINE IF FEASIBLE.
C
C
      IF (IOFFS .EQ. 0) GO TO 10
C
C DO NOT MARK LINES IF NOT REQUIRED.
C
      IXSTOR = IX
      IYSTOR = IY
      CALL PLOTIT (IX,IY,1)
      RETURN
C
C LINE HAS TO BE DRAWN AND MARKED.
C
   10 CONTINUE
      MX = IXSTOR
      MY = IYSTOR
      IXSTOR = IX
      IYSTOR = IY
      DX = IXSTOR - MX
      DY = IYSTOR - MY
C
C CHECK BEGINNING AND END POINT OF LINE, IF THEY ARE ALREADY MARKED.
C
      CALL REMOVE (IXSTOR,IYSTOR,LI,3)
      CALL REMOVE (MX,MY,LM,3)
C
C NOTHING TO DO , IF BEGINNING AND END POINT ARE ALREADY MARKED.
C
      IF (LI .AND. LM) RETURN
C
C DRAW A POINT IF LINE IS OF LENGTH 0.
C
      IF (DX .NE. 0. .OR. DY .NE. 0.) GO TO 15
      CALL PLOTIT (IXSTOR,IYSTOR,1)
      RETURN
   15 CONTINUE
C
      IF (LI .OR. LM) GO TO 20
C
C IF NEITHER STARTING NOR END POINT IS MARKED, DRAW LINE AND MARK IT.
C
      CALL PLOTIT (IXSTOR,IYSTOR,1)
      GO TO 80
C
C EITHER BEGINNING OR END POINT OF LINE WERE ALREADY MARKED.
C
   20 D = AMAX1(ABS(DX),ABS(DY))
      ID = D/FLOAT(ISKIP)
      DX = (DX/D)*FLOAT(ISKIP)
      DY = (DY/D)*FLOAT(ISKIP)
      IF (LM) GO TO 50
C
C STARTING POINT WAS NOT MARKED. FIND THE FIRST MARKED POINT.
C
      X = MX
      Y = MY
      DO 30 I=1,ID
         X = X+DX
         Y = Y+DY
         CALL REMOVE (IFIX(X+.5),IFIX(Y+.5),HID,3)
         IF (HID) GO TO 40
   30 CONTINUE
      X = FLOAT(IXSTOR)+DX
      Y = FLOAT(IYSTOR)+DY
   40 IXP = X+.5-DX
      IYP = Y+.5-DY
C FIRST MARKED POINT FOUND.
C DRAW LINE, SET PEN, MARK LINE.
      CALL PLOTIT (IXP,IYP,1)
      CALL PLOTIT (IXSTOR,IYSTOR,0)
      GO TO 80
C
C     FIRST PART IS HIDDEN
C       FIND THE FIRST VISIBLE POINT
C
   50 X = MX
      Y = MY
      DO 60 I=1,ID
         X = X+DX
         Y = Y+DY
         CALL REMOVE (IFIX(X+.5),IFIX(Y+.5),HID,3)
         IF (.NOT.HID) GO TO 70
   60 CONTINUE
      X = IXSTOR
      Y = IYSTOR
   70 IXP = X+.5
      IYP = Y+.5
C FIRST VISIBLE POINT FOUND.
C SET PEN, DRAW LINE, MARK LINE.
      CALL PLOTIT (IXP,IYP,0)
      CALL PLOTIT (IXSTOR,IYSTOR,1)
C
C
   80 CONTINUE
      CALL MARKL (IX1,IY1,IX2,IY2)
      IX1 = MX
      IY1 = MY
      IX2 = IXSTOR
      IY2 = IYSTOR
      RETURN
C
    2 CONTINUE
C
C *************************************
C
C INTERCEPT PLOTIT(IX,IY,0) TO SET THE STARTING POINT FOR THE NEXT
C LINE TO BE DRAWN OR REMOVED.
C
C CHECK IF PEN IS ALREADY CLOSE ENOUGH TO THE WANTED POSITION.
      DIFF = FLOAT(IABS(IXSTOR-IX)+IABS(IYSTOR-IY))
      IF (DIFF .LE. FLOAT(ICLOSE)) GO TO 110
C
      IXSTOR = IX
      IYSTOR = IY
      CALL PLOTIT (IXSTOR,IYSTOR,0)
      RETURN
C
    3 CONTINUE
C
C ****************************
C
C DO NOT MOVE PEN. JUST SET POSITION OF PEN TO (IMPOS,IMPOS).
C
      IXSTOR = IX
      IYSTOR = IY
C
  110 CONTINUE
C
      RETURN
      END
      SUBROUTINE MARKL (MX1,MY1,MX2,MY2)
C
C MARKL MARKS A LINE FROM POINT (MX1,MY1) TO POINT (MX2,MY2) IN THE
C MODEL PICTURE.
C
C ***********************************
C
C NOTE: LINES OF LENGTH LESS OR EQUAL 2 ARE NOT MARKED.
C       THE VERY FIRST POINT OF A LINE IS NOT MARKED, BUT IT WAS
C        MARKED WITH THE PRECEEDING LINE SEGMENT.
C
C ***********************************
C
C ISKIP IS USED TO ADJUST DASHSUPR TO THE SIZE OF THE MODEL PICTURE AS
C DEFINED IN THE SUBROUTINE REMOVE. ISKIP IS INITIALIZED IN DASHBD.
C
      COMMON /DSUP1/ ISKIP
C
      LOGICAL LDUMMY
      SAVE
C
      DATA LDUMMY /.TRUE./
C
      DX = MX2-MX1
      DY = MY2-MY1
      IF (ABS(DX)-ABS(DY)) 60,50,10
C
C DX IS LONGER THAN DY.
C
   10 SLOPE = DY/DX
      IF (DX .LT. 0.) GO TO 30
      MX1S = MX1+2*ISKIP
      MX2S = MX2-1*ISKIP
      IF (MX1S .GT. MX2S) RETURN
C
      DO 20 MX=MX1S,MX2S,ISKIP
         MY = IFIX(FLOAT(MY1)+FLOAT(MX-MX1)*SLOPE+.5)
         CALL REMOVE (MX,MY,LDUMMY,2)
   20 CONTINUE
      RETURN
C
   30 MX1S = MX1-2*ISKIP
      MX2S = MX2+1*ISKIP
      IF (MX1S .LT. MX2S) RETURN
      DO 40 MX=MX2S,MX1S,ISKIP
         MY = IFIX(FLOAT(MY2)+FLOAT(MX-MX2)*SLOPE+.5)
         CALL REMOVE (MX,MY,LDUMMY,2)
   40 CONTINUE
      RETURN
C
C DX AND DY HAVE SAME LENGTH.
C
   50 IF (DX .NE. 0.) GO TO 10
      CALL REMOVE (MX2,MY2,LDUMMY,2)
      RETURN
C
C DY IS LONGER THAN DX.
C
   60 SLOPE = DX/DY
      IF (DY .LT. 0.) GO TO 80
      MY1S = MY1+2*ISKIP
      MY2S = MY2-1*ISKIP
      IF (MY1S .GT. MY2S) RETURN
C
      DO 70 MY=MY1S,MY2S,ISKIP
         MX = IFIX(FLOAT(MX1)+FLOAT(MY-MY1)*SLOPE+.5)
         CALL REMOVE (MX,MY,LDUMMY,2)
   70 CONTINUE
      RETURN
C
   80 MY1S = MY1-2*ISKIP
      MY2S = MY2+1*ISKIP
      IF (MY1S .LT. MY2S) RETURN
C
      DO 90 MY=MY2S,MY1S,ISKIP
         MX = IFIX(FLOAT(MX2)+FLOAT(MY-MY2)*SLOPE+.5)
         CALL REMOVE (MX,MY,LDUMMY,2)
   90 CONTINUE
C
      RETURN
      END
      SUBROUTINE REMOVE (MX,MY,HIDDEN,IND)
C
C SUBROUTINE REMOVE CONTAINS THE DATA STRUCTURES FOR THE MODEL PICTURE
C WHICH IS USED TO DETERMINE IF A LINE WILL BE DRAWN OR REMOVED.
C ALL MANIPULATIONS ON THESE DATA STRUCTURES ARE DONE EXCLUSIVLY IN
C SUBROUTINE REMOVE.
C
C
C INPUT-OUTPUT-SPECIFICATIONS:
C
C  INPUT:
C   MX,MY: X- AND Y-COOORDINATES OF A POINT IN THE PLOTTING AREA.
C          MX AND MY RANGE FROM 0 TO 2**15-1.
C          NOTE: MX AND MY MAY BE LESS THAN 0 OR GREATER THAN 2**15-1
C                IN SOME SPECIAL CASES.
C   IND =1: REMOVE CALLED FROM RESET.
C          SET ALL ELEMENTS IN THE MODEL PICTURE TO NONMARKED.
C        =2: MARK THE POINT (MX,MY) AND THE POINTS NEXT TO IT.
C        =3: CHECK IF THE POINT (MX,MY) IS ALREADY MARKED. RETURN RESULT
C           IN HIDDEN.
C  OUTPUT:
C   MX, MY, AND IND ARE UNCHANGED.
C   HIDDEN: LOGICAL, ONLY RELEVANT IF IND=3.
C          RETURNS .TRUE. IF THE POINT WITH COORDINATES (MX,MY) IS
C          ALREADY MARKED, OTHERWISE .FALSE.
C  COMMON-BLOCKS:
C   ARRAY ISCREN IS CHANGED AS DEFINED ABOVE IF IND IS 1 OR 2.
C
C
C NOTE
C   THE IMPLEMENTATION OF THE MODEL PICTURE MAY BE CHANGED NOT HOWEVER
C   THE INPUT-OUTPUT SPECIFICATIONS STATED ABOVE.
C
C
C ALGORITHM
C THIS IMPLEMENTATION OF A MODEL PICTURE USES A BIT MAP. EACH PLOTTER
C ADDRESS (POINT) IS REPRESENTED BY A BIT IN THE ARRAY ISCREN. INITIALLY
C EACH BIT IS SET TO 0 BY A CALL TO THE SUBROUTINE RESET. WHEN A LINE
C IS DRAWN ALL BITS REPRESENTING POINTS ON THE LINE ARE SET TO 1. BEFORE
C A LINE IS DRAWN THE MODEL PICTURE IS CHECKED. IF THE BITS IN THE
C MODEL PICTURE REPRESENTING THE POINTS ON THE LINE ARE ALREADY 1 THEN
C THE LINE IS NOT DRAWN, OTHERWISE THE LINE IS DRAWN AND THE
C CORRESPONDING BITS ARE SET TO 1.
C
C
C
C
      LOGICAL HIDDEN
      SAVE
C
      DIMENSION MASK(64),MASK3(64)
C
C
C *********************************************************************
C
C MACHINE AND MODEL DEPENDENT DECLARATIONS AND CONSTANT DEFINITIONS
C
C
C CHOOSE NOW THE SIZE OF YOUR MODEL PICTURE AS NX BY NY.
C ONLY SIZES WITH NX EQUAL TO NY HAVE BEEN TESTED SO FAR.
C ALSO ONLY SIZES WITH NX AND NY POWERS OF 2 ARE POSSIBLE.
C MODEL PICTURES IN SIZE EQUAL TO OR CLOSE TO YOUR PLOTTER ADDRESS SPACE
C ARE RECOMMENDED.
C ASSUME THE MODEL PICTURE IS OF SIZE NX BY NY. THEN ARRAY ISCREN NEEDS
C NY COLUMNS AND NX/NBWD+1 ROWS WHERE NBWD IS THE NUMBER OF BITS PER
C INTEGER STORAGE UNIT.
      DIMENSION ISCREN(32,1024)
C E.G. FOR A 1024 BY 1024 MODEL PICTURE ON A 60 BIT MACHINE
C     DIMENSION ISCREN(18,1024)
C
C NX AND NY ARE THE LENGTHS OF THE MODEL PICTURE IN X AND Y DIRECTION.
C LX AND NY ARE THE DIMENSIONS OF THE ARRAY ISCREN WHICH IS USED TO
C REPRESENT THE MODEL PICTURE.
C FOR ANY SIZE OF A MODEL PICTURE THE NUMBER OF COLUMNS IN ISCREN IS
C ALWAYS EQUAL TO THE LENGTH OF THE MODEL PICTURE IN Y DIRECTION.
C
      DATA NX,NY,LX /1024,1024,32/
C E.G. FOR A 1024 BY 1024 MODEL PICTURE ON A 60 BIT MACHINE
C     DATA NX,NY,LX /1024,1024,18/
C
C NXSIZE IS AN INTEGER SUCH THAT 2**NXSIZE = NX
C NYSIZE IS AN INTEGER SUCH THAT 2**NYSIZE = NY
C
      DATA NXSIZE,NYSIZE /10,10/
C E. G. FOR A 1024 BY 1024 MODEL PICTURE
C     DATA NXSIZE,NYSIZE /10,10/
C
C
C END OF MACHINE AND MODEL DEPENDENT DECLARATIONS AND CONSTANT
C DEFINITIONS
C
C **********************************************************************
C
C ARRAY MASK CONTAINS SINGLE BIT MASKS FOR EACH BIT IN THE WORD.
C ENTRY I IN ARRAY MASK CONTAINS A WORD WITH THE I-TH BIT FROM THE RIGHT
C A 1 AND ALL OTHER BITS 0.
C THESE MASKS ARE USED TO CHECK IF A GIVEN POINT IN THE MODEL PICTURE
C HAS ALREADY BEEN MARKED.
C
C ARRAY MASK3 ALSO CONTAINS A MASK FOR EACH BIT IN THE WORD, BUT THE
C BIT TO THE LEFT AND THE BIT TO THE RIGHT ARE NOW SET AS WELL (EXCEPT
C AT THE EDGES). ENTRY I IN THE ARRAY MASK3 CONTAINS A WORD WITH THE
C (I-1)-TH,I-TH, AND(I+1)-TH BITS FROM THE RIGHT 1'S AND ALL OTHER BITS
C ZEROES.
C THESE MASKS ARE USED TO MARK 3 POINTS IN THE MODEL PICTURE AT THE SAME
C TIME.
C
C     FLAG FOR FIRST CALL (USED TO DETERMINE IF MASKS SHOULD
C     BE DEFINED BY CALLING INTMSK)
C
      DATA IFSTC/0/
C
C     DEFINE MASKS IF THIS IS THE FIRST CALL TO REMOVE
C
      IF (IFSTC .GT. 0) GO TO 5
C
C     CHECK IF THE IMPLEMENTATION-DEPENDENT CONSTANTS HAVE BEEN SET
C
      IF (NX .EQ. 0) THEN
        WRITE(6,500)
        STOP
      ENDIF
  500 FORMAT('     IN SUBROUTINE REMOVE OF DASHSUPR:',/
     -'       IMPLEMENTATION-DEPENDENT CONSTANTS NOT SET--',/
     -'       SEE INSTRUCTIONS AFTER INITIAL COMMENT CARDS.')
      CALL INTMSK(MASK,MASK3)
      IFSTC = 1
    5 CONTINUE
C
C RETRIEVE THE NUMBER OF BITS PER INTEGER STORAGE UNIT.
C
      NBPW = I1MACH(5)
C
C TRANSFORM THE INPUT COORDINATES INTO MODEL PICTURE COORDINATES.
C
      MX1 = ISHIFT (MX,NXSIZE-15)
      MY1 = ISHIFT (MY,NYSIZE-15)
C
C FIND THE ELEMENT IN THE ISCREN ARRAY REPRESENTING THE POINT (MX,MY).
C
      IX = MOD (MX1+NX,NX)
      IY = MOD (MY1+NY,NY) + 1
      IBIT = MOD(IX,NBPW)+1
      IX = IX/NBPW+1
C
C BRANCH DEPENDING ON FUNCTION TO BE PERFORMED
C
      GOTO (1,2,3) , IND
C
C ***********************************************
C
C CHECK IF THE POINT (MX,MY) IS ALREADY MARKED
C
    3 CONTINUE
      HIDDEN = .TRUE.
      ITEMP = IAND(ISCREN(IX,IY),MASK(IBIT))
      IF (ITEMP .EQ. 0) HIDDEN = .FALSE.
      RETURN
C
C ***********************************************
C
C MARK THE POINT (MX,MY) AND THE POINTS NEXT TO IT
C
    2 CONTINUE
C
C MARK THE POINTS (MX,MY) , (MX,MY+1) AND (MX,MY-1) IF THEY ARE IN
C THE PLOTTING AREA.
C MARK ALSO 3 POINTS FOR MX+1 AND MX-1 IN MOST CASES.
C
      ISCREN(IX,IY) = IOR(ISCREN(IX,IY),MASK3(IBIT))
      IF (IY .LT. NY) ISCREN(IX,IY+1) = IOR(ISCREN(IX,IY+1),MASK3(IBIT))
      IF (IY .GT. 1) ISCREN(IX,IY-1) = IOR(ISCREN(IX,IY-1),MASK3(IBIT))
      IF (IBIT .EQ. 1) GO TO 10
      IF (IBIT .EQ. NBPW) GO TO 20
      RETURN
C RETURN IF THE LEFT EDGE OF THE PLOTTING AREA IS REACHED.
   10 IF (IX .EQ. 1) RETURN
C
C MARK 3 POINTS TO THE LEFT OF (MX,MY)
C
      ISCREN(IX-1,IY) = IOR(ISCREN(IX-1,IY),MASK(NBPW))
      IF (IY .GT. 1) ISCREN(IX-1,IY-1) = IOR(ISCREN(IX-1,IY-1),
     1                                       MASK(NBPW))
      IF (IY .LT. NY)
     1    ISCREN(IX-1,IY+1) = IOR(ISCREN(IX-1,IY+1),MASK(NBPW))
      RETURN
C RETURN IF THE RIGHT EDGE OF THE PLOTTING AREA IS REACHED.
   20 IF (IX .EQ. LX) RETURN
C
C MARK 3 POINTS TO THE RIGHT OF (MX,MY).
C
      ISCREN(IX+1,IY) = IOR(ISCREN(IX+1,IY),MASK(1))
      IF (IY .GT. 1) ISCREN(IX+1,IY-1) =  IOR(ISCREN(IX+1,IY-1),MASK(1))
      IF (IY .LT. NY) ISCREN(IX+1,IY+1) = IOR(ISCREN(IX+1,IY+1),MASK(1))
      RETURN
C
C ***********************************************
C
C ENTRY RESET . SET ALL THE ELEMENTS IN THE ARRAY ISCREN TO 0.
C
    1 CONTINUE
      DO 40 J = 1,NY
      DO 30 I = 1,LX
         ISCREN(I,J) = 0
   30 CONTINUE
   40 CONTINUE
      RETURN
C
      END
      SUBROUTINE INTMSK(MASK,MASK3)
C
C     THIS SUBROUTINE INITIALIZES THE MASKS USED BY THE MODEL PICTURE
C
      DIMENSION MASK(*),MASK3(*)
      SAVE
C
C     GET NUMBER OF BITS PER WORD
C
      NBPW = I1MACH(5)
C
C     FILL MASKS
C
      IP1 = 1
      IP2 = 7
      MASK(1)  = 1
      MASK3(1) = 3
      DO 10 I=2,NBPW-1
      CALL SBYTES(MASK(I),IP1,NBPW-I,1,0,1)
      CALL SBYTES(MASK3(I),IP2,NBPW-I-1,3,0,1)
   10 CONTINUE
      CALL SBYTES(MASK(NBPW),IP1,0,1,0,1)
      CALL SBYTES(MASK3(NBPW),MASK3(1),0,2,0,1)
C
C     ZERO-FILL UNUSED PART OF MASKS
C
      DO 20 I=NBPW+1,64
      MASK(I) = 0
      MASK3(I) = 0
   20 CONTINUE
      RETURN
      END
      SUBROUTINE RESET
C
C USER ENTRY POINT.
C RESET INITIALIZES ALL POINTS IN THE MODEL PICTURE TO UNMARKED.
C
      LOGICAL LDUMMY
      SAVE
C
      DATA IDUMMY /0/
      DATA LDUMMY /.TRUE./
C
      CALL REMOVE (IDUMMY,IDUMMY,LDUMMY,1)
      RETURN
      END
      SUBROUTINE DASHDC (IPAT,JCRT,JSIZE)
C
C
C
C
C
C
      COMMON/INTPR/IPAU,FPART,TENSN,NP,SMALL,L1,ADDLR,ADDTB,MLLINE,
     1    ICLOSE
C
C USER ENTRY POINT.
C DASHDC GIVES AN INTERNAL REPRESENTATION TO THE DASH PATTERN WHICH IS
C SPECIFIED IN ITS ARGUMENTS. THIS INTERNAL REPRESENTATION IS PASSED
C TO ROUTINE CFVLD IN THE COMMON-BLOCK DASHD1.
C
      CHARACTER*(*) IPAT
      CHARACTER*1   IBLK, IGAP, ISOL, ICR
      CHARACTER*16  IPC(100)
C
C DASHD1 AND DASHD2 ARE USED
C FOR COMMUNICATION BETWEEN THE ROUTINES DASHDB, DASHDC, AND CFVLD.
C ISL, MNCSTR AND IGP ARE INITIALIZED IN DASHBD.
C
      COMMON /DASHD1/  ISL,  L,  ISIZE,  IP(100),  NWDSM1,  IPFLAG(100)
     1                 ,MNCSTR, IGP
      COMMON /DASHD2/  IPC
C
C IFCFLG IS THE FIRST CALL FLAG FOR DASHDB AND DASHDC.
C IT IS INITIALIZED IN DASHBD.
C
      COMMON /DDFLAG/ IFCFLG
C
C IFSTFL CONTROLS THAT FRSTD IS CALLED BEFORE VECTD IS CALLED (IN CFVLD)
C WHENEVER DASHDB OR DASHDC HAS BEEN CALLED.
C IT IS INITIALIZED IN DASHBD AND REFERENCED IN CFVLD.
C
      COMMON /DCFLAG/ IFSTFL
C
C IFSTF2 CONTROLS THAT THE FRSTD ENTRY IS CALLED IN FDVDLD BEFORE THE
C VECTD ENTRY IS CALLED WHENEVER DASHDB OR DASHDC HAS BEEN CALLED.
C IT IS INITIALIZED IN DASHBD AND REFERENCED IN FDVDLD.
C
      COMMON /DFFLAG/ IFSTF2
C
C LOCAL VARIABLES TO DASHDB AND DASHDC ARE SAVED IN DSAVE2 FOR
C THE NEXT CALL
C
      COMMON /DSAVE2/ MASK, NCHRWD, NBWD, MNCST1
C SAVE ALL VARIABLES
      SAVE
C
C NECESSARY ON SOME MACHINES TO GET BLOCK DATA LOADED
C
      EXTERNAL DASHBD
C
C NPD IS THE NUMBER OF WORDS IN IP
C
      DATA NPD/100/
C
C INITIALIZE CHARACTER FLAGS
C
      DATA IBLK,IGAP,ISOL/' ','''','$'/
C THE FOLLOWING CALL IS FOR LIBRARY STATISTICS GATHERING AT NCAR
      CALL Q8QST4 ('GRAPHX', 'DASHSUPR', 'DASHDC', 'VERSION  1')
C
C     NC IS THE NUMBER OF CHARACTERS IN IPAT
C
      NC = LEN(IPAT)
      IF (IFCFLG .EQ. 2) GOTO 10
C
C CHECK IF THE CONSTANTS IN THE BLOCKDATA DASHBD ARE LOADED CORRECTLY
C
      IF (MNCSTR .EQ. 15) GOTO 6
      CALL SETER('DASHDC -- BLOCKDATA DASHBD APPARRENTLY NOT LOADED CORR
     1ECTLY',1,2)
    6 CONTINUE
C
C INITIALIZATION
C
      MNCST1 = MNCSTR + 1
C
C MASK IS AN ALL SOLID PATTERN TO BE PASSED TO OPTN (65535=177777B).
C
      MASK=IOR(ISHIFT(32767,1),1)
C
C
      IFCFLG = 2
C
C NCHRTS - NUMBER OF CHARS IN THIS HOLLERITH STRING.
C L      - NUMBER OF WORDS IN THE FINAL PATTERN, POINTER TO IP ARRAY.
C ISL    - FLAG FOR ALL SOLID PATTERN (1) OR ALL GAP PATTERN (-1).
C IFSTFL - FLAG TO CONTROL THAT FRSTD IS CALLED IN CFVLD BEFORE VECTD IS
C          CALLED, WHENEVER DASHDB OR DASHDC HAS BEEN CALLED.
C IFSTF2 - FLAG TO CONTROL THAT FRSTD IS CALLED IN FDVDLD BEFORE VECTD
C          IS CALLED, WHENEVER DASHDB OR DASHDC HAS BEEN CALLED.
C
   10 CONTINUE
      NCHRTS = 0
      L = 0
      ISL = 0
      IFSTFL = 1
      IFSTF2 = 1
C
C RETRIEVE THE RESOLUTION AS SET BY THE USER.
C
      CALL GETUSV('XF',LXSAVE)
      CALL GETUSV('YF',LYSAVE)
C
C IADJUS - TO ADJUST NUMBERS TO THE GIVEN RESOLUTION.
C
      IADJUS = ISHIFT(1,15-LXSAVE)
      ICRT = JCRT*IADJUS
      ISIZE = JSIZE
      CHARW = FLOAT(ISIZE*IADJUS)
      IF (ISIZE .GT. 3) GO TO 30
      CHARW = 256. + FLOAT(ISIZE)*128.
      IF (ISIZE .EQ. 3) CHARW = 768.
C
   30 CONTINUE
      IF (ICRT .LT. 1) GO TO 230
      MODE = 2
C
C START MAIN LOOP
C
C THIS LOOP GENERATES THE IP ARRAY (NEEDED BY CURVED,VECTD,ETC.) FROM
C THE CHARACTER STRING IN IPAT.  EACH ITERATION OF THE LOOP PROCESSES
C ONE CHAR OF IPAT.  A SOLID OR GAP IS CONSIDERED TO BE A TYPE 1 ENTRY,
C AND A LABEL CHARACTER IS CONSIDERED TO BE A TYPE 2 ENTRY.
C
C IN THE CODE, L IS THE NUMBER OF CHANGES IN THE LINESTYLE (FROM GAP
C TO SOLID, SOLID TO CHARACTER, ETC.)  THE IP AND IPFLAG ARRAYS DESCRIBE
C THE LINE TO BE DRAWN, AND THESE ARRAYS ARE INDEXED FROM 1 TO L.  THE
C RELATIONSHIP BETWEEN IP AND IPFLAG IS:
C
C      IPFLAG(N)    IP(N)
C      ---------    -----
C          1        LENGTH (IN PLOTTER ADDRESS UNITS) OF SOLID LINE TO
C                   BE DRAWN.
C          0        NUMBER OF CHARACTERS TO BE PLOTTED.
C         -1        LENGTH (IN PLOTTER ADDRESS UNITS) OF GAP.
C
C THE 160 LOOP HANDLES 5 CASES:
C
C    1.)  CONTINUE TYPE 2 ENTRY (60-80)
C    2.)  START TYPE 2 ENTRY (80-90)
C    3.)  END TYPE 2 ENTRY AND START TYPE 1 ENTRY (90-160)
C    4.)  START TYPE 1 ENTRY, OR SWITCH TYPE 1 ENTRY FROM SOLID TO
C         GAP OR FROM GAP TO SOLID (140-160)
C    5.)  CONTINUE TYPE 1 ENTRY (150-160)
C
      DO 160 J=1,NC
C
C GET NEXT CHAR INTO ICR, RIGHT JUSTIFIED ZERO FILLED.
C
            ICR = IPAT(J:J)
C
C MODE SPECIFIES WHAT THE LAST CHARACTER PROCESSED WAS:
C
C    LAST ICR WAS $ (SOLID),      MODE IS 8
C    LAST ICR WAS ' (GAP),        MODE IS 2
C    LAST ICR WAS HOLLERITH CHAR, MODE IS 5
C
C NMODE SPECIFIES WHAT THE CURRENT CHARACTER TO BE PROCESSED IS:
C
C      ICR     NMODE
C      ---     -----
C       $        1
C       CHAR     0
C       '       -1
C
            NMODE = 0
            IF (ICR .EQ. IBLK) GO TO 160
            IF (ICR .EQ. IGAP) NMODE = -1
            IF (ICR .EQ. ISOL) NMODE = 1
            IF (L.EQ.0 .AND. NMODE.EQ.-1) MODE = 8
C
C NGO DETERMINES WHERE TO BRANCH BASED ON CASE TO BE PROCESSED.
C COMPUTE MODE FOR NEXT ITERATION.
C
            NGO = NMODE+MODE
            MODE = NMODE*3+5
            GO TO (150,80,140,90,60,90,140,80,150),NGO
C
C CHAR TO CHAR
C
C CASE 1) - CONTINUE TYPE 2 ENTRY.
C
   60      IF (NCHRTS .EQ. MNCSTR) GO TO 160
           NCHRTS = NCHRTS + 1
           IP(L) = NCHRTS
           IPC(L)(NCHRTS:NCHRTS) = ICR
           GO TO 160
C
C BLANK OR SOLID TO CHAR
C
C CASE 2) - START STRING ENTRY.  LGBSTR POINTS TO THE GAP WHICH
C           WILL CONTAIN THE STRING.
C
   80      LGBSTR = MIN0(L+1,NPD)
           L = MIN0(LGBSTR+1,NPD)
           IPFLAG(L) = 0
           NCHRTS    = 1
           IP(L)     = 1
           IPC(L)(NCHRTS:NCHRTS) = ICR
           GO TO 160
C
C CHAR TO SOLID OR GAP
C
C CASE 3) - END STRING ENTRY.  ICR IS A $ OR '.
C
   90      CONTINUE
           IP(LGBSTR) = CHARW*(FLOAT(NCHRTS) + .5)
           IPFLAG(LGBSTR) = -1
           IF (IGP .EQ. 0) IPFLAG(LGBSTR) = 1
C
C BLANK TO SOLID OR SOLID TO BLANK
C
C CASE 4) - START TYPE 1 ENTRY.
C
  140       L = MIN0(L+1,NPD)
            IP(L) = 0
C
C ADD TO A BLANK OR SOLID LINE
C
C CASE 5) - CONTINUE TYPE 1 ENTRY.  ICR IS A $ OR '.
C ADD ICRT UNITS TO THE PLOTTER ADDRESS UNITS IN IP(L).
C NMODE INDICATES IF IT IS A GAP OR A SOLID.
C
  150       IP(L) = IP(L) + ICRT
            IPFLAG(L) = NMODE
  160    CONTINUE
C
C IF LAST ICR PROCESSED WAS A LABEL CHARACTER, MUST END STRING
C ENTRY.
C
      IF (NGO.NE.2 .AND. NGO.NE.5 .AND. NGO.NE.8) GO TO 220
      IP(LGBSTR) = CHARW*(FLOAT(NCHRTS)+.5)
      IPFLAG(LGBSTR) = -1
      IF (IGP .EQ. 0) IPFLAG(LGBSTR) = 1
C
C IF IP ARRAY HAS ONLY ONE TYPE 1 ENTRY, SET ISL FLAG.
C
  220 IF (L .GT. 1) RETURN
      IBIG = ISHIFT(1,MAX0(LXSAVE,LYSAVE))
      IF (IP(L) .GE. IBIG) GO TO 230
      IF (IPFLAG(L)) 240,240,230
  230 ISL = 1
      RETURN
  240 ISL = -1
      RETURN
      END
      SUBROUTINE DASHDB (IPAT)
C
C ARGUMENTS              IPAT
C ON INPUT                 IPAT IS A 16-BIT DASH PATTERN.  BY DEFAULT
C                          EACH BIT IN THE PATTERN REPRESENTS 3 PLOTTER
C                          ADDRESS UNITS (1=SOLID, 0=BLANK)
C
C
C
C USER ENTRY POINT.
C DASHDB GIVES AN INTERNAL REPRESENTATION TO THE DASH PATTERN WHICH IS
C SPECIFIED IN ITS ARGUMENT. THIS INTERNAL REPRESENTATION IS PASSED
C TO ROUTINE CFVLD IN THE COMMON-BLOCK DASHD1.
C
      DIMENSION IPAT(1)
      COMMON/INTPR/IPAU,FPART,TENSN,NP,SMALL,L1,ADDLR,ADDTB,MLLINE,
     1    ICLOSE
C
C DASHD1 IS FOR COMMUNICATION BETWEEN THE ROUTINES DASHDB AND CFVLD.
C ISL, MNCSTR AND IGP ARE INITIALIZED IN DASHBD.
C
      COMMON /DASHD1/  ISL,  L,  ISIZE,  IP(100),  NWDSM1,  IPFLAG(100)
     1                 ,MNCSTR, IGP
C
C IFCFLG IS THE FIRST CALL FLAG FOR DASHDB. IT IS INITIALIZED IN DASHBD.
C
      COMMON /DDFLAG/ IFCFLG
C
C IFSTFL CONTROLS THAT FRSTD IS CALLED BEFORE VECTD IS CALLED (IN CFVLD)
C WHENEVER DASHDB HAS BEEN CALLED. IT IS INITIALIZED IN DASHBD AND
C REFERENCED IN CFVLD.
C
      COMMON /DCFLAG/ IFSTFL
C
C IFSTF2 CONTROLS THAT THE FRSTD ENTRY IS CALLED IN FDVDLD BEFORE THE
C VECTD ENTRY IS CALLED WHENEVER DASHDB OR DASHDC HAS BEEN CALLED.
C IT IS INITIALIZED IN DASHBD AND REFERENCED IN FDVDLD.
C
      COMMON /DFFLAG/ IFSTF2
C
C LOCAL VARIABLES TO DASHDB ARE SAVED IN DSAVE2 FOR THE NEXT CALL TO
C DASHDB.
C
      COMMON /DSAVE2/ MASK, NCHRWD, NBWD, MNCST1
C
C NECESSARY ON SOME MACHINES TO GET BLOCK DATA LOADED
C
      EXTERNAL DASHBD
      SAVE
C THE FOLLOWING CALL IS FOR LIBRARY STATISTICS GATHERING AT NCAR
      CALL Q8QST4 ('GRAPHX', 'DASHSUPR', 'DASHDB', 'VERSION  1')
      IF (IFCFLG .EQ. 2) GOTO 10
C
C CHECK IF THE CONSTANTS IN THE BLOCKDATA DASHBD ARE LOADED CORRECTLY
C
      IF (MNCSTR .EQ. 15) GOTO 6
      CALL SETER('DASHDB -- BLOCKDATA DASHBD APPARRENTLY NOT LOADED CORR
     1ECTLY',1,2)
    6 CONTINUE
C
C INITIALIZATION
C
      MNCST1 = MNCSTR + 1
C
C MASK IS AN ALL SOLID PATTERN
C
      MASK=IOR(ISHIFT(32767,1),1)
C
      IFCFLG = 2
C
C L - NUMBER OF WORDS IN THE FINAL PATTERN, POINTER TO IP ARRAY.
C ISL - FLAG FOR ALL SOLID PATTERN (1) OR ALL GAP PATTERN (-1).
C IFSTFL - FLAG TO CONTROL THAT FRSTD IS CALLED IN CFVLD BEFORE VECTD IS
C          CALLED, WHENEVER DASHDB OR DASHDC HAS BEEN CALLED.
C IFSTF2 - FLAG TO CONTROL THAT FRSTD IS CALLED IN FDVDLD BEFORE VECTD
C          IS CALLED, WHENEVER DASHDB OR DASHDC HAS BEEN CALLED.
C
   10 CONTINUE
      NCHRTS = 0
      L = 0
      ISL = 0
      IFSTFL = 1
      IFSTF2 = 1
C
      ICRT = IPAU*ISHIFT(1,15-10)
      IF (IPAT(1) .NE. 0) GO TO 260
      ISL = -1
      RETURN
  260 IF (IPAT(1) .NE. MASK) GO TO 270
      ISL = 1
      RETURN
  270 NMODE1 = IAND(ISHIFT(IPAT(1),-15),1)
      DO 290 I = 1,16
      IF (NMODE1 .NE. IAND(ISHIFT(IPAT(1),I-16),1)) GO TO 280
      NMODE1 = 1 - NMODE1
      L = L + 1
      IP(L) = 0
      IPFLAG(L) = 1 - 2*NMODE1
  280 IP(L) = IP(L) + ICRT
  290 CONTINUE
      RETURN
      END
      BLOCKDATA DASHBD
C
C DASHBD IS USED TO INITIALIZE VARIABLES IN NAMED COMMON.
C
      COMMON /DASHD1/  ISL,  L,  ISIZE,  IP(100),  NWDSM1,  IPFLAG(100)
     1                 ,MNCSTR, IGP
C
      COMMON /FDFLAG/ IFLAG
C
      COMMON /DFFLAG/ IFSTF2
C
      COMMON /DDFLAG/ IFCFLG
C
      COMMON /DCFLAG/ IFSTFL
C
      COMMON /CFFLAG/ IVCTFG
C
      COMMON /DSAVE3/ IXSTOR,IYSTOR
C
      COMMON /DSAVE4/ IX1,IY1,IX2,IY2
C
      COMMON /DSAVE5/ XSAVE(70), YSAVE(70), XSVN, YSVN, XSV1, YSV1,
     1                SLP1, SLPN, SSLP1, SSLPN, N, NSEG
C
      COMMON /SMFLAG/ IOFFS
C
      COMMON /DSUP1/ ISKIP
C
C
      COMMON/INTPR/IPAU,FPART,TENSN,NP,SMALL,L1,ADDLR,ADDTB,MLLINE,
     1    ICLOSE
      SAVE
C **********************************************************************
C
C CONSTANT DEPENDING ON THE IMPLEMENTATION OF THE MODEL PICTURE
C
C     LET NXSIZE BE DEFINED JUST AS IN SUBROUTINE REMOVE, NAMELY
C     SUCH THAT  2**NXSIZE = NUMBER OF MODEL PICTURE POINTS IN X- AND
C     Y- DIRECTION. (NXSIZE IS THE RESOLUTION OF THE MODEL PICTURE. THE
C     MODEL PICTURE IS ASSUMED TO BE QUADRATIC.)
C     THEN ISKIP IS DEFINED AS
C         ISKIP = 2**(15-NXSIZE)
C
C     ISKIP IS USED TO SPEED UP THE MARKING OF POINTS IN THE MODEL
C     PICTURE. THE FACT IS USED THAT 1 POINT IN THE MODEL PICTURE
C     REPRESENTS ISKIP*ISKIP METACODE ADDRESS UNITS.
C
      DATA ISKIP /32/
C     E.G. FOR A 1024 BY 1024 MODEL PICTURE
C     DATA ISKIP /32/
C
C **********************************************************************
C
C
C
C
C IFSTFL CONTROLS THAT FRSTD IS CALLED BEFORE VECTD IS CALLED (IN CFVLD)
C WHENEVER DASHDB OR DASHDC HAS BEEN CALLED.
C
      DATA IFSTFL /1/
C
C IVCTFG INDICATES IF VECTD IS BEING CALLED OR LASTD (IN CFVLD)
C
      DATA IVCTFG /1/
C
C IX1,IY1,IX2 AND IY2 ARE USED TO STORE THE NEXT LINE SEGMENT TO BE
C MARKED.
C
      DATA IX1,IY1,IX2,IY2 /0,0,0,0/
C
C ISL IS A FLAG FOR AN ALL SOLID PATTERN (+1) OR AN ALL GAP PATTERN (-1)
C
      DATA ISL /1/
C
C IGP IS AN INTERNAL PARAMETER. IT IS DESCRIBED IN THE DOCUMENTATION
C TO THE DASHED LINE PACKAGE.
C
      DATA IGP /9/
C
C MNCSTR IS THE MAXIMUM NUMBER OF CHARACTERS ALLOWED IN A HOLLERITH
C STRING PASSED TO DASHDB OR DASHDC.
C
      DATA MNCSTR /15/
C
C IOFFS IS AN INTERNAL PARAMETER.
C IOFFS IS USED IN FDVDLD AND DRAWPV.
C
      DATA IOFFS /0/
C
C
C  INTERNAL PARAMETERS
C
      DATA IPAU/3/
      DATA FPART/1./
      DATA TENSN/2.5/
      DATA NP/150/
      DATA SMALL/128./
      DATA L1/70/
      DATA ADDLR/2./
      DATA ADDTB/2./
      DATA MLLINE/384/
      DATA ICLOSE/6/
C
C IFSTF2 IS A FLAG TO CONTROL THAT FRSTD IS CALLED BEFORE VECTD IS
C CALLED (IN SUBROUTINE FDVDLD), WHENEVER DASHDB OR DASHDC
C HAS BEEN CALLED.
C
      DATA IFSTF2 /1/
C
C IFLAG CONTROLS IF LASTD CAN BE CALLED DIRECTLY OR IF IT WAS JUST
C CALLED FROM BY VECTD SO THAT THIS CALL CAN BE IGNORED.
C
      DATA IFLAG /1/
C
C IFCFLG IS THE FIRST CALL FLAG FOR SUBROUTINE DASHDB AND DASHDC.
C  1 = FIRST CALL TO DASHDB OR DASHDC.
C  2 = DASHDB OR DASHDC HAS BEEN CALLED BEFORE.
C
      DATA IFCFLG /1/
C
C IXSTOR AND IYSTOR CONTAIN THE CURRENT PEN POSITION. THEY ARE
C INITIALIZED TO AN IMPOSSIBLE VALUE.
C
      DATA IXSTOR,IYSTOR /-9999,-9999/
C
C SLP1 AND SLPN ARE INITIALIZED TO AVOID THAT THEY ARE PASSED AS ACTUAL
C PARAMETERS FROM FDVDLD TO KURV1S WITHOUT BEING DEFINED.
C
      DATA SLP1,SLPN /-9999.,-9999./
C
C
C
      END
      SUBROUTINE CFVLD (IENTRY,IIX,IIY)
C
C CFVLD CONNECTS POINTS WHOSE COORDINATES ARE SUPPLIED IN THE ARGUMENTS,
C ACCORDING TO THE DASH PATTERN WHICH IS PASSED FROM ROUTINE DASHDB OR
C DASHDC IN THE COMMON-BLOCK DASHD1.
C
      CHARACTER*16  IPC(100)
C
      COMMON/INTPR/IPAU,FPART,TENSN,NP,SMALL,L1,ADDLR,ADDTB,MLLINE,
     1    ICLOSE
C
C THE VARIABLES IN DASHD1 AND DASHD2 ARE USED FOR COMMUNICATION WITH
C DASHDC AND DASHDB.
C
      COMMON /DASHD1/  ISL,  L,  ISIZE,  IP(100),  NWDSM1,  IPFLAG(100)
     1                 ,MNCSTR, IGP
      COMMON /DASHD2/  IPC
C
C THE VARIABLES IN DSAVE1 HAVE TO BE SAVED FOR THE NEXT CALL TO CFVLD.
C
      COMMON /DSAVE1/ X,Y,X2,Y2,X3,Y3,M,BTI,IB,IX,IY
C
C THE FLAGS IFSTFL AND IVCTFG ARE INITIALIZED IN THE BLOCK DATA DASHBD.
C IFSTFL CONTROLS THAT FRSTD IS CALLED BEFORE VECTD IS CALLED.
C IVCTFG IS A FLAG TO INDICATE IF CFVLD IS BEING CALLED FROM VECTD OR
C LASTD.
C
      COMMON /DCFLAG/ IFSTFL
      COMMON /CFFLAG/ IVCTFG
      SAVE
C
C
C CMN IS USED TO DETERMINE WHEN TO STOP DRAWING A LINE SEGMENT
C
      DATA CMN/1.5/
C
C IMPOS IS USED AS AN IMPOSSIBLE PEN POSITION.
C
      DATA IMPOS /-9999/
C
C
C  ISL= -1  ALL BLANK  ) FLAG TO AVOID MOST CALCULATIONS
C        0  DASHED     )   IF PATTERN IS ALL SOLID OR
C        1  ALL SOLID  )   ALL BLANK
C
C     X,IX,Y,IY    CURRENT POSITION
C     X1,Y1        START OF A USER LINE SEGMENT
C     X2,Y2        END OF A USER LINE SEGMENT
C     X3,Y3        START OF A GAP PATTERN SEGMENT
C
C  SYMBOLS,IF PRESENT ARE CENTERED IN AN IMMEDIATLY PRECEEDING
C     GAP SEGMENT, OR DONE AT THE CURRENT POSITION OTHERWISE
C
C  SEGMENT TYPES ARE RECOGNIZED AS FOLLOWS
C     SOLID - WORD IN IP-ARRAY CONTAINS POSITIVE INTEGER, CORRESPONDING
C             ELEMENT IN IPFLAG IS 1.
C     GAP - WORD IN IP-ARRAY CONTAINS POSITIVE INTEGER, CORRESPONDING
C             ELEMENT IN IPFLAG IS -1.
C     SYMBOL - WORD IN IP-ARRAY CONTAINS CHARACTER REPRESENTATIONS.
C             CORRESPONDING ELEMENT IN IPFLAG IS 0.
C             SYMBOL COUNT FOR CHAR STRING IN CHAR NUMBER MNCSTR+1.
C     THE IP ARRAY AND THE IPFLAG ARRAY ARE COMPOSED OF L ELEMENTS.
C
C     BTI - BITS THIS INCREMENT
C     BPBX,BPBY BITS PER BIT X(Y)
C
C
C BRANCH DEPENDING ON FUNCTION TO BE PERFORMED.
C
      GO TO (330,305,350),IENTRY
C
C INITIALIZE VARIABLES (ENTRY FRSTD ONLY)
C
   30 CONTINUE
      X = IX
      Y = IY
      X2 = X
      X3 = X
      Y2 = Y
      Y3 = Y
      M = 1
      IB = IPFLAG(1)
      IF (IPFLAG(1) .NE. 0) GO TO 40
      IB = 0
      BTI = 0
   40 CONTINUE
      BTI = FLOAT(IP(1))*FPART
      GO TO 300
C
C MAIN LOOP START
C
   50 CONTINUE
         X1 = X2
         Y1 = Y2
         MX = IIX
         MY = IIY
         X2 = MX
         Y2 = MY
         DX = X2-X1
         DY = Y2-Y1
         D = SQRT(DX*DX+DY*DY)
         IF (D .LT. CMN) GO TO 190
   60    BPBX = DX/D
         BPBY = DY/D
         CALL DRAWPV (IX,IY,0)
   70    BTI = BTI-D
         IF (BTI) 100,100,80
C
C LINE SEGMENT WILL FIT IN CURRENT PATTERN ELEMENT
C
   80    X = X2
         Y = Y2
         IX = X2
         IY = Y2
         IF (IB) 200,160,90
   90    CALL DRAWPV (IX,IY,1)
         GO TO 200
C
C LINE SEGMENT WONT FIT IN CURRENT PATTERN ELEMENT
C DO IT TO END OF ELEMENT, SAVE HOW MUCH OF SEGMENT LEFT TO DO (D)
C
  100    BTI = BTI+D
         D = D-BTI
         X = X+BPBX*BTI
         Y = Y+BPBY*BTI
         IX = X+.5
         IY = Y+.5
         IF (IB) 110,160,120
  110    CALL DRAWPV (IX,IY,0)
         GO TO 130
  120    CALL DRAWPV (IX,IY,1)
C
C GET THE NEXT PATTERN ELEMENT
C
  130    M = MOD(M,L)+1
         IB = IPFLAG(M)
         IF (IB) 140,160,150
  140    X3 = X
         Y3 = Y
         BTI = FLOAT(IP(M))
         GO TO 70
  150    X3 = -1.
         BTI = FLOAT(IP(M))
         GO TO 70
C
C CHARACTER GENERATION
C
  160    S = 0.
         IF (IGP .NE. 9) GO TO 162
C
         DX = X-X3
         DY = Y-Y3
         GO TO 164
C
  162    CONTINUE
         DX = X - X1
         DY = Y - Y1
  164    CONTINUE
C
         IF (DY) 170,180,170
  170    S = ATAN2(DY,DX)
         IF (ABS(S-.00005) .GT. 1.5708) S = S-SIGN(3.14159,S)
  180    IF (IGP .NE. 9) GO TO 182
C
         MX = X3 + DX*.5
         MY = Y3 + DY*.5
         LIGP = 0
         GO TO 184
C
  182    CONTINUE
         MX = X
         MY = Y
         LIGP = 1
C
  184    CONTINUE
         IS = IFIX(S*180./3.14 + .5)
         IF (IS .LT. 0) IS = 360+IS
         CALL GETUSV('XF',LXSAVE)
         CALL GETUSV('YF',LYSAVE)
         MX = ISHIFT (MX,LXSAVE-15)
         MY = ISHIFT(MY,LYSAVE-15)
         CALL PWRTM(CPUX(MX),CPUY(MY),IPC(M)(1:IP(M)),ISIZE,IS,LIGP)
         CALL DRAWPV (IMPOS,IMPOS,2)
         CALL DRAWPV (IX,IY,0)
         GO TO 130
  190    X2 = X1
         Y2 = Y1
  200 CONTINUE
C
C EXIT IF CALL WAS TO VECTD.
C
      IF (IVCTFG .NE. 2) GO TO 210
      IVCTFG = 1
      GO TO 300
C
C EXIT IF NOT PLOTTING A GAP
C
  210 IF (IB .GE. 0) GO TO 300
C
C MUST BE IN A GAP AT END OF LASTD. EXIT IF NOT A LABEL GAP.
C
      MO = M
      M = MOD(M,L) + 1
      IF (IPFLAG(M) .NE. 0) GO TO 300
C
C CHECK PREVIOUS PLOTTED ELEMENT. WAS IT A GAP OR A LINE.
C
      MPREV = M - 2
      IF (MPREV .LE. 0) MPREV = MPREV + L
      IB = IPFLAG(MPREV)
      IF (IB .GE. 0) GO TO 250
C
C PREVIOUS ELEMENT WAS A GAP - LOOK FOR NEXT LINE.
C EXIT IF NO LINES IN PATTERN.
C
  230 CONTINUE
  240 M = MOD(M,L)+1
      IF (M .EQ. MO) GO TO 300
      IB = IPFLAG(M)
      IF (IB .EQ. 0) GOTO 245
      BTI = FLOAT(IP(M))
  245 CONTINUE
C
C IF IP(M) NOT A LINE, CONTINUE LOOKING.
C
      IF (IB) 240,230,280
C
C PREVIOUS ELEMENT WAS A LINE - LOOK FOR NEXT GAP.
C IF NO NON-LABEL GAPS IN PATTERN, GO TO 290.
C
  250 CONTINUE
  260 M = MOD(M,L)+1
      IF (M .EQ. MO) GO TO 290
      IB = IPFLAG(M)
      IF (IB .EQ. 0) GOTO 265
      BTI = FLOAT(IP(M))
  265 CONTINUE
C
C IF IP(M) NOT A GAP, CONTINUE LOOKING.
C
      IF (IB) 270,250,260
C
C FOUND A GAP. IF ITS A LABEL GAP, GO LOOK FOR NEXT GAP.
C
  270 MT = M
      M = MOD(M,L)+1
      IF (IPFLAG(M) .EQ. 0) GO TO 250
      M = MT
C
C M POINTS TO NEXT ELEMENT TO PLOT. SET UP AND GO PLOT.
C
  280 X1 = X3
      Y1 = Y3
      X = X3
      Y = Y3
      IX = X+0.5
      IY = Y+0.5
      DX = X2-X1
      DY = Y2-Y1
      D = SQRT(DX*DX+DY*DY)
      IF (D .GE. CMN) GO TO 60
      GO TO 300
C
C NO NON-LABEL GAPS IN THE PATTERN - FILL IN WITH SOLID LINE.
C
  290 IX = X3+0.5
      IY = Y3+0.5
      CALL DRAWPV (IX,IY,0)
      IX = X2
      IY = Y2
      CALL DRAWPV (IX,IY,1)
  300 RETURN
C
C *************************************
C
C ENTRY VECTD (XX,YY)
C
  305 CONTINUE
C
C TEST FOR PREVIOUS CALL TO FRSTD.
C
      IF (IFSTFL .EQ. 2) GO TO 310
C
C INFORM USER - NO PREVIOUS CALL TO FRSTD. TREAT CALL AS FRSTD CALL.
C
      CALL SETER ('CFVLD -- VECTD CALL OCCURS BEFORE A CALL TO FRSTD.',
     -             1,1)
      GO TO 330
  310 K = 1
      IVCTFG = 2
      IF (ISL) 300,50,320
  320 IX = IIX
      IY = IIY
      CALL DRAWPV (IX,IY,1)
      GO TO 300
C
C *************************************
C
C     ENTRY FRSTD (FLDX,FLDY)
C
  330 IX = IIX
      IY = IIY
      IFSTFL = 2
C AVOID UNEXPECTED PEN POSITION
      CALL DRAWPV (IMPOS,IMPOS,2)
      IF (ISL) 300,30,340
  340 CALL DRAWPV (IX,IY,0)
      GO TO 300
C
C *************************************
C
C     ENTRY LASTD
C
  350 CONTINUE
C
C TEST FOR PREVIOUS CALL TO FRSTD
C
      IF (IFSTFL .NE. 2) GO TO 300
      IFSTFL = 1
      K = 1
      IF (ISL .NE. 0) GO TO 300
      GO TO 210
      END
      SUBROUTINE FRSTD (X,Y)
C USER ENTRY PPINT.
      CALL FL2INT (X,Y,IIX,IIY)
      CALL FDVDLD (1,IIX,IIY)
      RETURN
      END
      SUBROUTINE VECTD (X,Y)
C USER ENTRY POINT.
      CALL FL2INT (X,Y,IIX,IIY)
      CALL FDVDLD (2,IIX,IIY)
      RETURN
      END
      SUBROUTINE LASTD
C USER ENTRY POINT. SEE DOCUMENTATION FOR PURPOSE.
      DATA IDUMMY /0/
      CALL FDVDLD (3,IDUMMY,IDUMMY)
C
C     FLUSH PLOTIT BUFFER
C
      CALL PLOTIT(0,0,0)
      RETURN
      END
      SUBROUTINE CURVED (X,Y,N)
C USER ENTRY POINT.
C
      DIMENSION X(N),Y(N)
C
      CALL FRSTD (X(1),Y(1))
      DO 10 I=2,N
         CALL VECTD (X(I),Y(I))
   10 CONTINUE
C
      CALL LASTD
C
      RETURN
      END
      SUBROUTINE LINED (XA,YA,XB,YB)
C USER ENTRY POINT.
C
      DATA IDUMMY /0/
      CALL FL2INT (XA,YA,IXA,IYA)
      CALL FL2INT (XB,YB,IXB,IYB)
C
      CALL CUTUP (IXA,IYA,IXB,IYB)
      CALL CFVLD (3,IDUMMY,IDUMMY)
C
      RETURN
      END
      SUBROUTINE PWRTM (X,Y,CHARS,JSIZE,JOR,JCNTR)
C
C
C PWRTM CAN BE CALLED TO DRAW CHARACTERS AND MARK THE REGIONS WHERE THE
C CHARACTERS HAVE BEEN DRAWN IN THE MODEL PICTURE.
C
C THE PARAMETERS TO PWRTM ARE EXACTLY THE SAME AS THE PARAMETERS TO
C THE UTILITY SUPPORT ROUTINE WTSTR.
C
C THE COORDINATES X AND Y ARE IN THE USER'S RESOLUTION, SINCE PWRTM
C IS A USER ENTRY POINT
C
      CHARACTER*(*) CHARS
C
C ISKIP IS INITIALIZED AND DESCRIBED IN BLOCKDATA DASHBD.
C
      COMMON /DSUP1/ ISKIP
C
      COMMON/INTPR/IPAU,FPART,TENSN,NP,SMALL,L1,ADDLR,ADDTB,MLLINE,
     1    ICLOSE
      SAVE
C
C
C A CONSTANT USED TO COMPUTE THE NUMBER OF LINES TO BE MARKED.
C SQTDTH = SQRT(2)/3
C
      DATA SQTDTH /.47133/
C
C COPY INTO LOCAL VARIABLES
C
      ICNTR = JCNTR
      ISIZE = JSIZE
      IOR = JOR
C
C RETRIEVE THE USER'S RESOLUTION.
C
         CALL GETUSV('XF',LXSAVE)
         CALL GETUSV('YF',LYSAVE)
C
C DRAW THE CHARACTER STRING
C
      CALL WTSTR (X,Y,CHARS,ISIZE,IOR,ICNTR)
C
C RETURN IF STRING IS OF LENGTH 0
C
      IC = LEN(CHARS)
      IF (IC .EQ. 0) RETURN
C
C TRANSFORM COORDINATES INTO RESOLUTION 15.
C
      CALL FL2INT (X,Y,MXS,MYS)
C
C ADJUST ADDLR AND ADDTB TO 15 BIT RESOLUTION.
C
      IFIFTE = ISHIFT (1,15-10)
      ATBAD = ADDTB*FLOAT(IFIFTE)
      ALRAD = ADDLR*FLOAT(IFIFTE)
C
C COMPUTE THE SIZE OF A CHARACTER IN THE STRING DRAWN
C
      FISIZE = ISIZE*ISHIFT(1,15-LXSAVE)
      IF (ISIZE .GT. 3) GO TO 30
      FISIZE = 256. + FLOAT(ISIZE)*128.
      IF (ISIZE .EQ. 3) FISIZE = 768.
   30 CONTINUE
      LNT = IFIX(FISIZE*FLOAT(IC)+2.*ALRAD+.5)
C
C COMPUTE THE ANGLE IN WHICH THE STRING WAS DRAWN
C
      ANGLE = (FLOAT(IOR)*2.*3.1415)/360.
C
      SA = SIN(ANGLE)
      CA = COS(ANGLE)
C
C CORRECT FOR CENTERING OPTION.
C
      IF (ICNTR .EQ. 0) SHIFT = .5*FLOAT(LNT)
      IF (ICNTR .EQ. -1) SHIFT = ALRAD
      IF (ICNTR .EQ. 1) SHIFT = FLOAT(LNT)-.5*FISIZE-ALRAD
C
C ADD FREE SPACE AT TOP AND BOTTOM
C
      FISIZE = FISIZE + 2.*ATBAD
C
C FIND THE LEFT AND THE RIGHT END OF THE AREA TO BE MARKED.
C
      MXS1 = FLOAT(MXS)-SHIFT*CA+.5*FISIZE*SA
      MYS1 = FLOAT(MYS)-SHIFT*SA-.5*FISIZE*CA
      MXS2 = FLOAT(MXS)+(FLOAT(LNT)-SHIFT)*CA+.5*FISIZE*SA
      MYS2 = FLOAT(MYS)+(FLOAT(LNT)-SHIFT)*SA-.5*FISIZE*CA
C
C COMPUTE THE NUMBER OF LINES TO BE MARKED.
C
      NLINES = FISIZE*SQTDTH
C
      R = AMAX0(NLINES-1,1)/FISIZE
C
C MARK THE AREA WHERE THE STRING WAS DRAWN
C
      DO 90 I=1,NLINES,ISKIP
         P = FLOAT(I-1)/R
         MX1 = FLOAT(MXS1)-P*SA
         MY1 = FLOAT(MYS1)+P*CA
         MX2 = FLOAT(MXS2)-P*SA
         MY2 = FLOAT(MYS2)+P*CA
         CALL MARKL (MX1,MY1,MX2,MY2)
   90 CONTINUE
C
      RETURN
C
C------REVISION HISTORY
C
C JUNE 1984          CONVERTED TO FORTRAN77 AND GKS
C
C-----------------------------------------------------------------------
C
      END
