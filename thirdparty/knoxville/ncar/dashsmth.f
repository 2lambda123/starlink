      SUBROUTINE FDVDLD (IENTRY,IIX,IIY)
      DIMENSION       XP(70),  YP(70),  TEMP(70)
C
C THE VARIABLES IN DSAVE5 HAVE TO BE SAVED FOR THE NEXT CALL TO FDVDLD.
C
      COMMON /DSAVE5/ XSAVE(70), YSAVE(70), XSVN, YSVN, XSV1, YSV1,
     1                SLP1, SLPN, SSLP1, SSLPN, N, NSEG
C
C IOFFS IS AN INTERNAL PARAMETER. IT IS INITIALIZED IN DASHBD AND
C REFERENCED IN FDVDLD AND DRAWPV.
C
      COMMON /SMFLAG/ IOFFS
C
C IFSTF2 IS A FLAG TO CONTROL THAT FRSTD IS CALLED BEFORE VECTD IS
C CALLED.
C
      COMMON /DFFLAG/ IFSTF2
C
C IFLAG CONTROLS IF LASTD CAN BE CALLED DIRECTLY OR IF IT WAS JUST
C CALLED FROM BY VECTD SO THAT THIS CALL CAN BE IGNORED.
C
      COMMON /FDFLAG/ IFLAG
C
C NOTE THAT THIS IFSTF2 FLAG CANNOT BE IDENTICAL TO THE IFSTFL FLAG
C IN THE ROUTINE CFVLD, BECAUSE A CALL TO THE FRSTD ENTRY OF FDVDLD DOES
C NOT ELIMINATE THE NECESSITY OF A CALL TO THE FRSTD ENTRY OF CFVLD,
C AND REVERSE.
C
      COMMON/INTPR/IPAU,FPART,TENSN,NP,SMALL,L1,ADDLR,ADDTB,MLLINE,
     1    ICLOSE
      SAVE
C
C
C OTHER CONSTANTS.
C
      DATA PI /3.14159265358/
      DATA IDUMMY /0/
C
C
      GO TO (10,15,35),IENTRY
C
C *************************************
C
C ENTRY  FRSTD (XX,YY)
C
   10 DEG = 180./PI
C
      MX = IIX
      MY = IIY
      IFSTF2 = 0
      SSLP1 = 0.0
      SSLPN = 0.0
      XSVN = 0.0
      YSVN = 0.0
      IF (IOFFS .GE. 1) CALL CFVLD (1,MX,MY)
      IF (IOFFS .GE. 1) RETURN
C
C INITIALIZE THE POINT AND SEGMENT COUNTER
C N COUNTS THE NUMBER OF POINTS/SEGMENT
C
      N = 0
C
C NSEG = 0       FIRST SEGMENT
C NSEG = 1       MORE THAN ONE SEGMENT
C
      NSEG = 0
C
C SAVE THE X,Y COORDINATES OF THE FIRST POINT
C XSV1           CONTAINS THE X COORDINATE OF THE FIRST POINT
C                OF A LINE
C YSV1           CONTAINS THE Y COORDINATE OF THE FIRST POINT
C                OF A LINE
C
      XSV1 = MX
      YSV1 = MY
      GO TO 30
C
C *************************************
C
C     ENTRY VECTD (XX,YY)
C
   15 CONTINUE
C
C TEST FOR PREVIOUS FRSTD CALL
C
      IF (IFSTF2 .EQ. 0) GO TO 20
C
C INFORM USER - NO PREVIOUS CALL TO FRSTD. TREAT CALL AS FRSTD CALL.
C
      CALL SETER(' FDVDLD- VECTD CALL OCCURS BEFORE A CALL TO FRSTD.',
     -            1,1)
      GO TO 10
   20 MX = IIX
      MY = IIY
C
C VECTD          SAVES THE X,Y COORDINATES OF THE ACCEPTED
C                POINTS ON A LINE SEGMENT
C
      IF (IOFFS .GE. 1) CALL CFVLD (2,MX,MY)
      IF (IOFFS .GE. 1) RETURN
C
C IF THE NEW POINT IS TOO CLOSE TO THE PREVIOUS POINT, IGNORE IT
C
      IF (ABS(FLOAT(IFIX(XSVN)-MX))+ABS(FLOAT(IFIX(YSVN)-MY)) .LT.
     1    SMALL) RETURN
      IFLAG = 0
   30 N = N+1
C
C SAVE THE X,Y COORDINATES OF EACH POINT OF THE SEGMENT
C XSAVE          THE ARRAY OF X COORDINATES OF LINE SEGMENT
C YSAVE          THE ARRAY OF Y COORDINATES OF LINE SEGMENT
C
      XSAVE(N) = MX
      YSAVE(N) = MY
      XSVN = XSAVE(N)
      YSVN = YSAVE(N)
      IF (N .GE. L1-1) GO TO 40
      RETURN
C
C *************************************
C
C     ENTRY LASTD
C
   35 CONTINUE
      IF (IFSTF2 .NE. 0) RETURN
      IFSTF2 = 1
C
C LASTD          CHECKS FOR PERIODIC LINES AND SETS UP
C                  THE CALLS TO KURV1S AND KURV2S
C
      IF (IOFFS .GE. 1) CALL CFVLD (3,IDUMMY,IDUMMY)
      IF (IOFFS .GE. 1) RETURN
C
C IFLAG = 0      OK TO CALL LASTD DIRECTLY
C IFLAG = 1      LASTD WAS JUST CALLED FROM BY VECTD
C                IGNORE CALL TO LASTD
C
      IF (IFLAG .EQ. 1) RETURN
C
C COMPARE THE LAST POINT OF SEGMENT WITH FIRST POINT OF LINE
C
   40 IFLAG = 1
C
C IPRD = 0       PERIODIC LINE
C IPRD = 1       NON-PERIODIC LINE
C
      IPRD = 1
      IF (ABS(XSV1-XSVN)+ABS(YSV1-YSVN) .LT. SMALL) IPRD = 0
C
C TAKE CARE OF THE CASE OF ONLY TWO DISTINCT P0INTS ON A LINE
C
      IF (NSEG .GE. 1) GO TO 60
      IF (N-2) 150,140,50
   50 IF (N .GE. 4) GO TO 60
C
      IF (IPRD .NE. 0) GO TO 60
      DX = XSAVE(2)-XSAVE(1)
      DY = YSAVE(2)-YSAVE(1)
      SLOPE = ATAN2(DY,DX)*DEG+90.
      IF (SLOPE .GE. 360.) SLOPE = SLOPE-360.
      IF (SLOPE .LE. 0.) SLOPE = SLOPE+360.
      SLP1 = SLOPE
      SLPN = SLOPE
      ISLPSW = 0
      SIGMA = TENSN
      GO TO 100
   60 SIGMA = TENSN
      IF (IPRD .GE. 1) GO TO 80
      IF (NSEG .GE. 1) GO TO 70
C
C SET UP FLAGS FOR A  1  SEGMENT, PERIODIC LINE
C
      ISLPSW = 4
      XSAVE(N) = XSV1
      YSAVE(N) = YSV1
      GO TO 100
C
C SET UP FLAGS FOR AN N-SEGMENT, PERIODIC LINE
C
   70 SLP1 = SSLPN
      SLPN = SSLP1
      ISLPSW = 0
      GO TO 100
   80 IF (NSEG .GE. 1) GO TO 90
C
C SET UP FLAGS FOR THE 1ST SEGMENT OF A NON-PERIODIC LINE
C
      ISLPSW = 3
      GO TO 100
C
C SET UP FLAGS FOR THE NTH SEGMENT OF A NON-PERIODIC LINE
C
   90 SLP1 = SSLPN
      ISLPSW = 1
C
C CALL THE SMOOTHING ROUTINES
C
  100 CALL KURV1S (N,XSAVE,YSAVE,SLP1,SLPN,XP,YP,TEMP,S,SIGMA,ISLPSW)
C
C DETERMINE THE NUMBER OF POINTS TO INTERPOLATE FOR EACH SEGMENT
C
      IF (NSEG.GE.1 .AND. N.LT.L1-1) GO TO 110
      NPRIME = FLOAT(NP)-(S*FLOAT(NP)*.5)/32767.
      IF (S .GE. 32767.) NPRIME = .5*FLOAT(NP)
      NPL = AMAX1(FLOAT(NPRIME)*S/32767.,2.5)
  110 DT = 1./FLOAT(NPL)
      IX = IFIX (XSAVE(1))
      IY = IFIX (YSAVE(1))
      IF (NSEG .LE. 0) GO TO 112
      CALL DRAWPV (IX,IY,0)
      GO TO 114
  112 CONTINUE
      CALL CFVLD (1,IX,IY)
  114 CONTINUE
      T = 0.0
      NSLPSW = 1
      IF (NSEG .GE. 1) NSLPSW = 0
      NSEG = 1
      CALL KURV2S (T,XS,YS,N,XSAVE,YSAVE,XP,YP,S,SIGMA,NSLPSW,SLP)
C
C SAVE SLOPE AT THE FIRST POINT OF THE LINE
C
      IF (NSLPSW .GE. 1) SSLP1 = SLP
      NSLPSW = 0
      DO 120 I=1,NPL
         T = T+DT
         TT = -T
         IF (I .EQ. NPL) NSLPSW = 1
         CALL KURV2S (TT,XS,YS,N,XSAVE,YSAVE,XP,YP,S,SIGMA,NSLPSW,SLP)
C
C SAVE THE LAST SLOPE OF THIS LINE SEGMENT
C
         IF (NSLPSW .GE. 1) SSLPN = SLP
C
C DRAW EACH PART OF THE LINE SEGMENT
C
         IX = IFIX(XS)
         IY = IFIX (YS)
         CALL CFVLD (2,IX,IY)
  120 CONTINUE
      IF (IPRD .NE. 0) GO TO 130
C
C CONNECT THE LAST POINT WITH THE FIRST POINT OF A PERIODIC LINE
C
      IX = IFIX (XSV1)
      IY = IFIX (YSV1)
      CALL CFVLD (2,IX,IY)
C
C BEGIN THE NEXT LINE SEGMENT WITH THE LAST POINT OF THIS SEGMENT
C
  130 XSAVE(1) = XS
      YSAVE(1) = YS
      N = 1
      IF (IFSTF2 .EQ. 1) CALL CFVLD (3,IDUMMY,IDUMMY)
      GO TO 150
C
C FOR THE CASE WHEN THERE ARE ONLY 2 DISTINCT POINTS ON A LINE.
C
  140 IX = IFIX (XSAVE(1))
      IY = IFIX (YSAVE(1))
      CALL CFVLD (1,IX,IY)
      IX = IFIX (XSAVE(N))
      IY = IFIX (YSAVE(N))
      CALL CFVLD (2,IX,IY)
      IF (IFSTF2 .EQ. 1) CALL CFVLD (3,IDUMMY,IDUMMY)
C
  150 CONTINUE
      RETURN
      END
      SUBROUTINE KURV1S (N,X,Y,SLOP1,SLOPN,XP,YP,TEMP,S,SIGMA,ISLPSW)
C
C
C DIMENSION OF           X(N),Y(N),XP(N),YP(N),TEMP(N)
C ARGUMENTS
C
C LATEST REVISION        FEBRUARY 5, 1974
C
C PURPOSE                KURV1S DETERMINES THE PARAMETERS NECESSARY TO
C                        COMPUTE A SPLINE UNDER TENSION PASSING THROUGH
C                        A SEQUENCE OF PAIRS
C                        (X(1),Y(1)),...,(X(N),Y(N)) IN THE PLANE.
C                        THE SLOPES AT THE TWO ENDS OF THE CURVE MAY BE
C                        SPECIFIED OR OMITTED.  FOR ACTUAL COMPUTATION
C                        OF POINTS ON THE CURVE IT IS NECESSARY TO CALL
C                        THE SUBROUTINE KURV2S.
C
C USAGE                  CALL KURV1S(N,X,Y,SLP1,SLPN,XP,YP,TEMP,S,SIGMA)
C
C ARGUMENTS
C
C ON INPUT               N
C                          IS THE NUMBER OF POINTS TO BE INTERPOLATED
C                          (N .GE. 2).
C
C                        X
C                          IS AN ARRAY CONTAINING THE N X-COORDINATES
C                          OF THE POINTS.
C
C                        Y
C                          IS AN ARRAY CONTAINING THE N Y-COORDINATES
C                          OF THE POINTS.
C
C                        SLOP1 AND SLOPN
C                          CONTAIN THE DESIRED VALUES FOR THE SLOPE OF
C                          THE CURVE AT (X(1),Y(1)) AND (X(N),Y(N)),
C                          RESPECTIVELY.  THESE QUANTITIES ARE IN
C                          DEGREES AND MEASURED COUNTER-CLOCKWISE
C                          FROM THE POSITIVE X-AXIS.  IF ISLPSW IS NON-
C                          ZERO, ONE OR BOTH OF SLP1 AND SLPN MAY BE
C                          DETERMINED INTERNALLY BY KURV1S.
C
C                        XP AND YP
C                          ARE ARRAYS OF LENGTH AT LEAST N.
C
C                        TEMP
C                          IS AN ARRAY OF LENGTH AT LEAST N WHICH IS
C                          USED FOR SCRATCH STORAGE.
C
C                        SIGMA
C                          CONTAINS THE TENSION FACTOR.  THIS IS
C                          NON-ZERO AND INDICATES THE CURVINESS DESIRED.
C                          IF ABS(SIGMA) IS VERY LARGE (E.G., 50.) THE
C                          RESULTING CURVE IS VERY NEARLY A POLYGONAL
C                          LINE.  A STANDARD VALUE FOR SIGMA IS ABOUT 2.
C
C                        ISLPSW
C                          IS AN INTEGER INDICATING WHICH END SLOPES
C                          HAVE BEEN USER PROVIDED AND WHICH MUST BE
C                          COMPUTED BY KURV1S.  FOR ISLPSW
C                            = 0  INDICATES BOTH SLOPES ARE PROVIDED,
C                            = 1  ONLY SLOP1 IS PROVIDED,
C                            = 2  ONLY SLOPN IS PROVIDED,
C                            = 3  NEITHER SLOP1 NOR SLOPN IS PROVIDED.
C                            = 4  NEITHER SLOP1 NOR SLOPN IS PROVIDED,
C                                 BUT SLOP1=SLOPN.  IN THIS CASE X(1)=
C                                 X(N), Y(1)=Y(N) AND N.GE.3.
C ON OUTPUT              XP AND YP
C                          CONTAIN INFORMATION ABOUT THE CURVATURE OF
C                          THE CURVE AT THE GIVEN NODES.
C
C                        S
C                          CONTAINS THE POLYGONAL ARCLENGTH OF THE
C                          CURVE.
C
C                        N, X, Y, SLP1, SLPN, SIGMA AND ISLPSW ARE
C                        UNCHANGED.
C
C ENTRY POINTS           KURV1S
C
C SPECIAL CONDITIONS     NONE
C
C COMMON BLOCKS          NONE
C
C I/O                    NONE
C
C PRECISION              SINGLE
C
C REQUIRED ULIB          NONE
C ROUTINES
C
C SPECIALIST             RUSSELL K. REW, NCAR, BOULDER, COLORADO  80302
C
C LANGUAGE               FORTRAN
C
C HISTORY                ORIGINALLY WRITTEN BY A. K. CLINE, MARCH 1972.
C
C
C
C
      INTEGER         N
      REAL            X(N)       ,Y(N)       ,XP(N)      ,YP(N)      ,
     1                TEMP(N)    ,S          ,SIGMA
      SAVE
C
      DATA PI /3.1415926535897932/
C
      NN = N
      JSLPSW = ISLPSW
      SLP1 = SLOP1
      SLPN = SLOPN
      DEGRAD = PI/180.
      NM1 = NN-1
      NP1 = NN+1
      DELX1 = X(2)-X(1)
      DELY1 = Y(2)-Y(1)
      DELS1 = SQRT(DELX1*DELX1+DELY1*DELY1)
      DX1 = DELX1/DELS1
      DY1 = DELY1/DELS1
C
C DETERMINE SLOPES IF NECESSARY
C
      IF (JSLPSW .NE. 0) GO TO 70
   10 SLPP1 = SLP1*DEGRAD
      SLPPN = SLPN*DEGRAD
C
C SET UP RIGHT HAND SIDES OF TRIDIAGONAL LINEAR SYSTEM FOR XP
C AND YP
C
      XP(1) = DX1-COS(SLPP1)
      YP(1) = DY1-SIN(SLPP1)

      TEMP(1) = DELS1
      SS = DELS1
      IF (NN .EQ. 2) GO TO 30
      DO 20 I=2,NM1
         DELX2 = X(I+1)-X(I)
         DELY2 = Y(I+1)-Y(I)
         DELS2 = SQRT(DELX2*DELX2+DELY2*DELY2)
         DX2 = DELX2/DELS2
         DY2 = DELY2/DELS2
         XP(I) = DX2-DX1
         YP(I) = DY2-DY1
         TEMP(I) = DELS2
         DELX1 = DELX2
         DELY1 = DELY2
         DELS1 = DELS2
         DX1 = DX2
         DY1 = DY2
C
C ACCUMULATE POLYGONAL ARCLENGTH
C
         SS = SS+DELS1
   20 CONTINUE
   30 XP(NN) = COS(SLPPN)-DX1
      YP(NN) = SIN(SLPPN)-DY1
C
C DENORMALIZE TENSION FACTOR
C
      SIGMAP = ABS(SIGMA)*FLOAT(NN-1)/SS
C
C PERFORM FORWARD ELIMINATION ON TRIDIAGONAL SYSTEM
C
      S = SS
      DELS = SIGMAP*TEMP(1)
      EXPS = EXP(DELS)
      SINHS = .5*(EXPS-1./EXPS)
      SINHIN = 1./(TEMP(1)*SINHS)
      DIAG1 = SINHIN*(DELS*.5*(EXPS+1./EXPS)-SINHS)
      DIAGIN = 1./DIAG1
      XP(1) = DIAGIN*XP(1)
      YP(1) = DIAGIN*YP(1)
      SPDIAG = SINHIN*(SINHS-DELS)
      TEMP(1) = DIAGIN*SPDIAG
      IF (NN .EQ. 2) GO TO 50
      DO 40 I=2,NM1
         DELS = SIGMAP*TEMP(I)
         EXPS = EXP(DELS)
         SINHS = .5*(EXPS-1./EXPS)
         SINHIN = 1./(TEMP(I)*SINHS)
         DIAG2 = SINHIN*(DELS*(.5*(EXPS+1./EXPS))-SINHS)
         DIAGIN = 1./(DIAG1+DIAG2-SPDIAG*TEMP(I-1))
         XP(I) = DIAGIN*(XP(I)-SPDIAG*XP(I-1))
         YP(I) = DIAGIN*(YP(I)-SPDIAG*YP(I-1))
         SPDIAG = SINHIN*(SINHS-DELS)
         TEMP(I) = DIAGIN*SPDIAG
         DIAG1 = DIAG2
   40 CONTINUE
   50 DIAGIN = 1./(DIAG1-SPDIAG*TEMP(NM1))
      XP(NN) = DIAGIN*(XP(NN)-SPDIAG*XP(NM1))
      YP(NN) = DIAGIN*(YP(NN)-SPDIAG*YP(NM1))
C
C PERFORM BACK SUBSTITUTION
C
      DO 60 I=2,NN
         IBAK = NP1-I
         XP(IBAK) = XP(IBAK)-TEMP(IBAK)*XP(IBAK+1)
         YP(IBAK) = YP(IBAK)-TEMP(IBAK)*YP(IBAK+1)
   60 CONTINUE
      RETURN
   70 IF (NN .EQ. 2) GO TO 100
C
C IF NO SLOPES ARE GIVEN, USE SECOND ORDER INTERPOLATION ON
C INPUT DATA FOR SLOPES AT ENDPOINTS
C
      IF (JSLPSW .EQ. 4) GO TO 90
      IF (JSLPSW .EQ. 2) GO TO 80
      DELNM1 = SQRT((X(NN-2)-X(NM1))**2+(Y(NN-2)-Y(NM1))**2)
      DELN = SQRT((X(NM1)-X(NN))**2+(Y(NM1)-Y(NN))**2)
      DELNN = DELNM1+DELN
      C1 = (DELNN+DELN)/DELNN/DELN
      C2 = -DELNN/DELN/DELNM1
      C3 = DELN/DELNN/DELNM1
      SX = C3*X(NN-2)+C2*X(NM1)+C1*X(NN)
      SY = C3*Y(NN-2)+C2*Y(NM1)+C1*Y(NN)
C
      SLPN = ATAN2(SY,SX)/DEGRAD
   80 IF (JSLPSW .EQ. 1) GO TO 10
      DELS2 = SQRT((X(3)-X(2))**2+(Y(3)-Y(2))**2)
      DELS12 = DELS1+DELS2
      C1 = -(DELS12+DELS1)/DELS12/DELS1
      C2 = DELS12/DELS1/DELS2
      C3 = -DELS1/DELS12/DELS2
      SX = C1*X(1)+C2*X(2)+C3*X(3)
      SY = C1*Y(1)+C2*Y(2)+C3*Y(3)
C
      SLP1 = ATAN2(SY,SX)/DEGRAD
      GO TO 10
   90 DELN = SQRT((X(NM1)-X(NN))**2+(Y(NM1)-Y(NN))**2)
      DELNN = DELS1+DELN
      C1 = -DELS1/DELN/DELNN
      C2 = (DELS1-DELN)/DELS1/DELN
      C3 = DELN/DELNN/DELS1
      SX = C1*X(NM1)+C2*X(1)+C3*X(2)
      SY = C1*Y(NM1)+C2*Y(1)+C3*Y(2)
      IF (SX.EQ.0. .AND. SY.EQ.0.) SX = 1.
      SLP1 = ATAN2(SY,SX)/DEGRAD
      SLPN = SLP1
      GO TO 10
C
C IF ONLY TWO POINTS AND NO SLOPES ARE GIVEN, USE STRAIGHT
C LINE SEGMENT FOR CURVE
C
  100 IF (JSLPSW .NE. 3) GO TO 110
      XP(1) = 0.
      XP(2) = 0.
      YP(1) = 0.
      YP(2) = 0.
C
      SLP1 = ATAN2(Y(2)-Y(1),X(2)-X(1))/DEGRAD
      SLPN = SLP1
      RETURN
C
  110 IF (JSLPSW .EQ. 2)
     1    SLP1 = ATAN2(Y(2)-Y(1)-SLPN*(X(2)-X(1)),
     2                                X(2)-X(1)-SLPN*(Y(2)-Y(1)))/DEGRAD
C
      IF (JSLPSW .EQ. 1)
     1    SLPN = ATAN2(Y(2)-Y(1)-SLP1*(X(2)-X(1)),
     2                                X(2)-X(1)-SLP1*(Y(2)-Y(1)))/DEGRAD
      GO TO 10
      END
      SUBROUTINE KURV2S (T,XS,YS,N,X,Y,XP,YP,S,SIGMA,NSLPSW,SLP)
C
C
C
C DIMENSION OF           X(N),Y(N),XP(N),YP(N)
C ARGUMENTS
C
C LATEST REVISION        OCTOBER 22, 1973
C
C PURPOSE                KURV2S PERFORMS THE MAPPING OF POINTS IN THE
C                        INTERVAL (0.,1.) ONTO A CURVE IN THE PLANE.
C                        THE SUBROUTINE KURV1S SHOULD BE CALLED EARLIER
C                        TO DETERMINE CERTAIN NECESSARY PARAMETERS.
C                        THE RESULTING CURVE HAS A PARAMETRIC
C                        REPRESENTATION BOTH OF WHOSE COMPONENTS ARE
C                        SPLINES UNDER TENSION AND FUNCTIONS OF THE
C                        POLYGONAL ARCLENGTH PARAMETER.
C
C ACCESS CARDS           *FORTRAN,S=ULIB,N=KURV
C                        *COSY
C
C USAGE                  CALL KURV2S (T,XS,YS,N,X,Y,XP,YP,S,SIGMA)
C
C ARGUMENTS
C
C ON INPUT               T
C                          CONTAINS A REAL VALUE OF ABSOLUTE VALUE LESS
C                          THAN OR EQUAL TO 1. TO BE MAPPED TO A POINT
C                          ON THE CURVE.  THE SIGN OF T IS IGNORED AND
C                          THE INTERVAL (0.,1.) IS MAPPED ONTO THE
C                          ENTIRE CURVE.  IF T IS NEGATIVE, THIS
C                          INDICATES THAT THE SUBROUTINE HAS BEEN CALLED
C                          PREVIOUSLY (WITH ALL OTHER INPUT VARIABLES
C                          UNALTERED) AND THAT THIS VALUE OF T EXCEEDS
C                          THE PREVIOUS VALUE IN ABSOLUTE VALUE.  WITH
C                          SUCH INFORMATION THE SUBROUTINE IS ABLE TO
C                          MAP THE POINT MUCH MORE RAPIDLY.  THUS IF THE
C                          USER SEEKS TO MAP A SEQUENCE OF POINTS ONTO
C                          THE SAME CURVE, EFFICIENCY IS GAINED BY
C                          ORDERING THE VALUES INCREASING IN MAGNITUDE
C                          AND SETTING THE SIGNS OF ALL BUT THE FIRST
C                          NEGATIVE.
C
C                        N
C                          CONTAINS THE NUMBER OF POINTS WHICH WERE
C                          INTERPOLATED TO DETERMINE THE CURVE.
C
C                        X AND Y
C                          ARRAYS CONTAINING THE X- AND Y-COORDINATES
C                          OF THE INTERPOLATED POINTS.
C
C                        XP AND YP
C                          ARE THE ARRAYS OUTPUT FROM KURV1 CONTAINING
C                          CURVATURE INFORMATION.
C
C                        S
C                          CONTAINS THE POLYGONAL ARCLENGTH OF THE
C                          CURVE.
C
C                        SIGMA
C                          CONTAINS THE TENSION FACTOR (ITS SIGN IS
C                          IGNORED).
C
C                        NSLPSW
C                          IS AN INTEGER SWITCH WHICH TURNS ON OR OFF
C                          THE CALCULATION OF SLP
C                          NSLPSW
C                                 = 0 INDICATES THAT SLP WILL NOT BE
C                                     CALCULATED
C                                 = 1 SLP WILL BE CALCULATED
C
C                        THE PARAMETERS N, X, Y, XP, YP, S AND SIGMA
C                        SHOULD BE INPUT UNALTERED FROM THE OUTPUT OF
C                        KURV1S.
C
C ON OUTPUT              XS AND YS
C                          CONTAIN THE X- AND Y-COORDINATES OF THE IMAGE
C                          POINT ON THE CURVE.
C
C                        SLP
C                          CONTAINS THE SLOPE OF THE CURVE IN DEGREES AT
C                          THIS POINT.
C
C                        T, N, X, Y, XP, YP, S AND SIGMA ARE UNALTERED.
C
C ENTRY POINTS           KURV2S
C
C SPECIAL CONDITIONS     NONE
C
C COMMON BLOCKS          NONE
C
C I/O                    NONE
C
C PRECISION              SINGLE
C
C REQUIRED ULIB          NONE
C ROUTINES
C
C SPECIALIST             RUSSELL K. REW, NCAR, BOULDER, COLORADO  80302
C
C LANGUAGE               FORTRAN
C
C HISTORY                ORIGINALLY WRITTEN BY A. K. CLINE, MARCH 1972.
C
C
C
C
      INTEGER         N
      REAL            T          ,XS         ,YS         ,X(N)       ,
     1                Y(N)       ,XP(N)      ,YP(N)      ,S          ,
     2                SIGMA      ,SLP
      SAVE
C
      DATA PI /3.1415926535897932/
C
C
C DENORMALIZE SIGMA
C
      SIGMAP = ABS(SIGMA)*FLOAT(N-1)/S
C
C STRETCH UNIT INTERVAL INTO ARCLENGTH DISTANCE
C
      TN = ABS(T*S)
C
C FOR NEGATIVE T START SEARCH WHERE PREVIOUSLY TERMINATED,
C OTHERWISE START FROM BEGINNING
C
      IF (T .LT. 0.) GO TO 10
      DEGRAD = PI/180.
      I1 = 2
      XS = X(1)
      YS = Y(1)
      SUM = 0.
      IF (T .LT. 0.) RETURN
C
C DETERMINE INTO WHICH SEGMENT TN IS MAPPED
C
   10 DO 30 I=I1,N
         DELX = X(I)-X(I-1)
         DELY = Y(I)-Y(I-1)
         DELS = SQRT(DELX*DELX+DELY*DELY)
         IF (SUM+DELS-TN) 20,40,40
   20    SUM = SUM+DELS
   30 CONTINUE
C
C IF ABS(T) IS GREATER THAN 1., RETURN TERMINAL POINT ON
C CURVE
C
      XS = X(N)
      YS = Y(N)
      RETURN
C
C SET UP AND PERFORM INTERPOLATION
C
   40 DEL1 = TN-SUM
      DEL2 = DELS-DEL1
      EXPS1 = EXP(SIGMAP*DEL1)
      SINHD1 = .5*(EXPS1-1./EXPS1)
      EXPS2 = EXP(SIGMAP*DEL2)
      SINHD2 = .5*(EXPS2-1./EXPS2)
      EXPS = EXPS1*EXPS2
      SINHS = .5*(EXPS-1./EXPS)
      XS = (XP(I)*SINHD1+XP(I-1)*SINHD2)/SINHS+
     1     ((X(I)-XP(I))*DEL1+(X(I-1)-XP(I-1))*DEL2)/DELS
      YS = (YP(I)*SINHD1+YP(I-1)*SINHD2)/SINHS+
     1     ((Y(I)-YP(I))*DEL1+(Y(I-1)-YP(I-1))*DEL2)/DELS
      I1 = I
      IF (NSLPSW .EQ. 0) RETURN
      COSHD1 = .5*(EXPS1+1./EXPS1)*SIGMAP
      COSHD2 = .5*(EXPS2+1./EXPS2)*SIGMAP
      XT = (XP(I)*COSHD1-XP(I-1)*COSHD2)/SINHS+
     1     ((X(I)-XP(I))-(X(I-1)-XP(I-1)))/DELS
      YT = (YP(I)*COSHD1-YP(I-1)*COSHD2)/SINHS+
     1     ((Y(I)-YP(I))-(Y(I-1)-YP(I-1)))/DELS
      SLP = ATAN2(YT,XT)/DEGRAD
      RETURN
      END
      SUBROUTINE RESET
C
C  THIS USER ENTRY POINT IS HERE ONLY FOR COMPATIBILITY WITH USE IN
C  THE CONREC FAMILY WHICH CALL RESET WHEN USED WITH DASHSUPR.
C
      RETURN
      END
      SUBROUTINE DASHDC (IPAT,JCRT,JSIZE)
C
C
C
C
C
C
      COMMON/INTPR/IPAU,FPART,TENSN,NP,SMALL,L1,ADDLR,ADDTB,MLLINE,
     1    ICLOSE
C
C USER ENTRY POINT.
C DASHDC GIVES AN INTERNAL REPRESENTATION TO THE DASH PATTERN WHICH IS
C SPECIFIED IN ITS ARGUMENTS. THIS INTERNAL REPRESENTATION IS PASSED
C TO ROUTINE CFVLD IN THE COMMON-BLOCK DASHD1.
C
      CHARACTER*(*) IPAT
      CHARACTER*1   IBLK, IGAP, ISOL, ICR
      CHARACTER*16  IPC(100)
C
C DASHD1 AND DASHD2 ARE USED
C FOR COMMUNICATION BETWEEN THE ROUTINES DASHDB, DASHDC AND CFVLD.
C ISL, MNCSTR AND IGP ARE INITIALIZED IN DASHBD.
C
      COMMON /DASHD1/  ISL,  L,  ISIZE,  IP(100),  NWDSM1,  IPFLAG(100)
     1                 ,MNCSTR, IGP
      COMMON /DASHD2/  IPC
C
C IFCFLG IS THE FIRST CALL FLAG FOR DASHDB AND DASHDC.
C IT IS INITIALIZED IN DASHBD.
C
      COMMON /DDFLAG/ IFCFLG
C
C IFSTFL CONTROLS THAT FRSTD IS CALLED BEFORE VECTD IS CALLED (IN CFVLD)
C WHENEVER DASHDB OR DASHDC HAVE BEEN CALLED.
C IT IS INITIALIZED IN DASHBD AND REFERENCED IN CFVLD.
C
      COMMON /DCFLAG/ IFSTFL
C
C IFSTF2 CONTROLS THAT THE FRSTD ENTRY IS CALLED IN FDVDLD BEFORE THE
C VECTD ENTRY IS CALLED WHENEVER DASHDB OR DASHDC HAVE BEEN CALLED.
C IT IS INITIALIZED IN DASHBD AND REFERENCED IN FDVDLD.
C
      COMMON /DFFLAG/ IFSTF2
C
C LOCAL VARIABLES TO DASHDB AND DASHDC ARE SAVED IN DSAVE2
C FOR THE NEXT CALL
C
      COMMON /DSAVE2/ MASK, NCHRWD, NBWD, MNCST1
C SAVE ALL VARIABLES
      SAVE
C
C NECESSARY ON SOME MACHINES TO GET BLOCK DATA LOADED
C
      EXTERNAL DASHBD
C
C NPD IS THE NUMBER OF WORDS IN IP
C
      DATA NPD/100/
C
C INITIALIZE CHARACTER FLAGS
C
      DATA IBLK,IGAP,ISOL/' ','''','$'/
C THE FOLLOWING CALL IS FOR LIBRARY STATISTICS GATHERING AT NCAR
      CALL Q8QST4 ('GRAPHX', 'DASHSMTH', 'DASHDC', 'VERSION  1')
C
C     NC IS THE NUMBER OF CHARACTERS IN IPAT
C
      NC = LEN(IPAT)
      IF (IFCFLG .EQ. 2) GOTO 10
C
C CHECK IF THE CONSTANTS IN THE BLOCKDATA DASHBD ARE LOADED CORRECTLY
C
      IF (MNCSTR .EQ. 15) GOTO 6
      CALL SETER('DASHDC -- BLOCKDATA DASHBD APPARRENTLY NOT LOADED CORR
     1ECTLY',1,2)
    6 CONTINUE
C
C INITIALIZATION
C
      MNCST1 = MNCSTR + 1
C
C MASK IS AN ALL SOLID PATTERN TO BE PASSED TO OPTN (65535=177777B).
C
      MASK=IOR(ISHIFT(32767,1),1)
C
C
      IFCFLG = 2
C
C NCHRTS - NUMBER OF CHARS IN THIS HOLLERITH STRING.
C L      - NUMBER OF WORDS IN THE FINAL PATTERN, POINTER TO IP ARRAY.
C ISL    - FLAG FOR ALL SOLID PATTERN (1) OR ALL GAP PATTERN (-1).
C IFSTFL - FLAG TO CONTROL THAT FRSTD IS CALLED IN CFVLD BEFORE VECTD IS
C          CALLED, WHENEVER DASHDB OR DASHDC HAVE BEEN CALLED.
C IFSTF2 - FLAG TO CONTROL THAT FRSTD IS CALLED IN FDVDLD BEFORE VECTD
C          IS CALLED, WHENEVER DASHDB OR DASHDC HAVE BEEN CALLED.
C
   10 CONTINUE
      NCHRTS = 0
      L = 0
      ISL = 0
      IFSTFL = 1
      IFSTF2 = 1
C
C RETRIEVE THE RESOLUTION AS SET BY THE USER.
C
      CALL GETUSV('XF',LXSAVE)
      CALL GETUSV('YF',LYSAVE)
C
C IADJUS - TO ADJUST NUMBERS TO THE GIVEN RESOLUTION.
C
      IADJUS = ISHIFT(1,15-LXSAVE)
      ICRT = JCRT*IADJUS
      ISIZE = JSIZE
      CHARW = FLOAT(ISIZE*IADJUS)
      IF (ISIZE .GT. 3) GO TO 30
      CHARW = 256. + FLOAT(ISIZE)*128.
      IF (ISIZE .EQ. 3) CHARW = 768.
C
   30 CONTINUE
      IF (ICRT .LT. 1) GO TO 230
      MODE = 2
C
C START MAIN LOOP
C
C THIS LOOP GENERATES THE IP ARRAY (NEEDED BY CURVED,VECTD,ETC.) FROM
C THE CHARACTER STRING IN IPAT.  EACH ITERATION OF THE LOOP PROCESSES
C ONE CHAR OF IPAT.  A SOLID OR GAP IS CONSIDERED TO BE A TYPE 1 ENTRY,
C AND A LABEL CHARACTER IS CONSIDERED TO BE A TYPE 2 ENTRY.
C
C IN THE CODE, L IS THE NUMBER OF CHANGES IN THE LINESTYLE (FROM GAP
C TO SOLID, SOLID TO CHARACTER, ETC.)  THE IP AND IPFLAG ARRAYS DESCRIBE
C THE LINE TO BE DRAWN, AND THESE ARRAYS ARE INDEXED FROM 1 TO L.  THE
C RELATIONSHIP BETWEEN IP AND IPFLAG IS:
C
C      IPFLAG(N)    IP(N)
C      ---------    -----
C          1        LENGTH (IN PLOTTER ADDRESS UNITS) OF SOLID LINE TO
C                   BE DRAWN.
C          0        NUMBER OF CHARACTERS TO BE PLOTTED.
C         -1        LENGTH (IN PLOTTER ADDRESS UNITS) OF GAP.
C
C THE 160 LOOP HANDLES 5 CASES:
C
C    1.)  CONTINUE TYPE 2 ENTRY (60-80)
C    2.)  START TYPE 2 ENTRY (80-90)
C    3.)  END TYPE 2 ENTRY AND START TYPE 1 ENTRY (90-160)
C    4.)  START TYPE 1 ENTRY, OR SWITCH TYPE 1 ENTRY FROM SOLID TO
C         GAP OR FROM GAP TO SOLID (140-160)
C    5.)  CONTINUE TYPE 1 ENTRY (150-160)
C
      DO 160 J=1,NC
C
C GET NEXT CHAR INTO ICR, RIGHT JUSTIFIED ZERO FILLED.
C
            ICR = IPAT(J:J)
C
C MODE SPECIFIES WHAT THE LAST CHARACTER PROCESSED WAS:
C
C    LAST ICR WAS $ (SOLID),      MODE IS 8
C    LAST ICR WAS ' (GAP),        MODE IS 2
C    LAST ICR WAS HOLLERITH CHAR, MODE IS 5
C
C NMODE SPECIFIES WHAT THE CURRENT CHARACTER TO BE PROCESSED IS:
C
C      ICR     NMODE
C      ---     -----
C       $        1
C       CHAR     0
C       '       -1
C
            NMODE = 0
            IF (ICR .EQ. IBLK) GO TO 160
            IF (ICR .EQ. IGAP) NMODE = -1
            IF (ICR .EQ. ISOL) NMODE = 1
            IF (L.EQ.0 .AND. NMODE.EQ.-1) MODE = 8
C
C NGO DETERMINES WHERE TO BRANCH BASED ON CASE TO BE PROCESSED.
C COMPUTE MODE FOR NEXT ITERATION.
C
            NGO = NMODE+MODE
            MODE = NMODE*3+5
            GO TO (150,80,140,90,60,90,140,80,150),NGO
C
C CHAR TO CHAR
C
C CASE 1) - CONTINUE TYPE 2 ENTRY.
C
   60      IF (NCHRTS .EQ. MNCSTR) GO TO 160
           NCHRTS = NCHRTS + 1
           IP(L) = NCHRTS
           IPC(L)(NCHRTS:NCHRTS) = ICR
           GO TO 160
C
C BLANK OR SOLID TO CHAR
C
C CASE 2) - START STRING ENTRY.  LGBSTR POINTS TO THE GAP WHICH
C           WILL CONTAIN THE STRING.
C
   80      LGBSTR = MIN0(L+1,NPD)
           L = MIN0(LGBSTR+1,NPD)
           IPFLAG(L) = 0
           NCHRTS    = 1
           IP(L)     = 1
           IPC(L)(NCHRTS:NCHRTS) = ICR
           GO TO 160
C
C CHAR TO SOLID OR GAP
C
C CASE 3) - END STRING ENTRY.  ICR IS A $ OR '.
C
   90      CONTINUE
           IP(LGBSTR) = CHARW*(FLOAT(NCHRTS) + .5)
           IPFLAG(LGBSTR) = -1
           IF (IGP .EQ. 0) IPFLAG(LGBSTR) = 1
C
C BLANK TO SOLID OR SOLID TO BLANK
C
C CASE 4) - START TYPE 1 ENTRY.
C
  140       L = MIN0(L+1,NPD)
            IP(L) = 0
C
C ADD TO A BLANK OR SOLID LINE
C
C CASE 5) - CONTINUE TYPE 1 ENTRY.  ICR IS A $ OR '.
C ADD ICRT UNITS TO THE PLOTTER ADDRESS UNITS IN IP(L).
C NMODE INDICATES IF IT IS A GAP OR A SOLID.
C
  150       IP(L) = IP(L) + ICRT
            IPFLAG(L) = NMODE
  160    CONTINUE
C
C IF LAST ICR PROCESSED WAS A LABEL CHARACTER, MUST END STRING
C ENTRY.
C
      IF (NGO.NE.2 .AND. NGO.NE.5 .AND. NGO.NE.8) GO TO 220
      IP(LGBSTR) = CHARW*(FLOAT(NCHRTS)+.5)
      IPFLAG(LGBSTR) = -1
      IF (IGP .EQ. 0) IPFLAG(LGBSTR) = 1
C
C IF IP ARRAY HAS ONLY ONE TYPE 1 ENTRY, SET ISL FLAG.
C
  220 IF (L .GT. 1) RETURN
      IBIG = ISHIFT(1,MAX0(LXSAVE,LYSAVE))
      IF (IP(L) .GE. IBIG) GO TO 230
      IF (IPFLAG(L)) 240,240,230
  230 ISL = 1
      RETURN
  240 ISL = -1
      RETURN
      END
      SUBROUTINE DASHDB (IPAT)
C
C ARGUMENTS              IPAT
C ON INPUT                 IPAT IS A 16-BIT DASH PATTERN.  BY DEFAULT
C                          EACH BIT IN THE PATTERN REPRESENTS 3 PLOTTER
C                          ADDRESS UNITS (1=SOLID, 0=BLANK)
C
C
C
C USER ENTRY POINT.
C DASHDB GIVES AN INTERNAL REPRESENTATION TO THE DASH PATTERN WHICH IS
C SPECIFIED IN ITS ARGUMENT. THIS INTERNAL REPRESENTATION IS PASSED
C TO ROUTINE CFVLD IN THE COMMON-BLOCK DASHD1.
C
      DIMENSION IPAT(1)
      COMMON/INTPR/IPAU,FPART,TENSN,NP,SMALL,L1,ADDLR,ADDTB,MLLINE,
     1    ICLOSE
C
C DASHD1 IS FOR COMMUNICATION BETWEEN THE ROUTINES DASHDB AND CFVLD.
C ISL, MNCSTR AND IGP ARE INITIALIZED IN DASHBD.
C
      COMMON /DASHD1/  ISL,  L,  ISIZE,  IP(100),  NWDSM1,  IPFLAG(100)
     1                 ,MNCSTR, IGP
C
C IFCFLG IS THE FIRST CALL FLAG FOR DASHDB. IT IS INITIALIZED IN DASHBD.
C
      COMMON /DDFLAG/ IFCFLG
C
C IFSTFL CONTROLS THAT FRSTD IS CALLED BEFORE VECTD IS CALLED (IN CFVLD)
C WHENEVER DASHDB HAS BEEN CALLED. IT IS INITIALIZED IN DASHBD AND
C REFERENCED IN CFVLD.
C
      COMMON /DCFLAG/ IFSTFL
C
C IFSTF2 CONTROLS THAT THE FRSTD ENTRY IS CALLED IN FDVDLD BEFORE THE
C VECTD ENTRY IS CALLED WHENEVER DASHDB OR DASHDC HAS BEEN CALLED. IT IS
C INITIALIZED IN DASHBD AND REFERENCED IN FDVDLD.
C
      COMMON /DFFLAG/ IFSTF2
C
C LOCAL VARIABLES TO DASHDB ARE SAVED IN DSAVE2 FOR THE NEXT CALL TO
C DASHDB.
C
      COMMON /DSAVE2/ MASK, NCHRWD, NBWD, MNCST1
C
C NECESSARY ON SOME MACHINES TO GET BLOCK DATA LOADED
C
      EXTERNAL DASHBD
      SAVE
C THE FOLLOWING CALL IS FOR LIBRARY STATISTICS GATHERING AT NCAR
      CALL Q8QST4 ('GRAPHX', 'DASHSMTH', 'DASHDB', 'VERSION  1')
      IF (IFCFLG .EQ. 2) GOTO 10
C
C CHECK IF THE CONSTANTS IN THE BLOCKDATA DASHBD ARE LOADED CORRECTLY
C
      IF (MNCSTR .EQ. 15) GOTO 6
      CALL SETER('DASHDB -- BLOCKDATA DASHBD APPARRENTLY NOT LOADED CORR
     1ECTLY',1,2)
    6 CONTINUE
C
C INITIALIZATION
C
      MNCST1 = MNCSTR + 1
C
C MASK IS AN ALL SOLID PATTERN
C
      MASK=IOR(ISHIFT(32767,1),1)
C
      IFCFLG = 2
C
C L - NUMBER OF WORDS IN THE FINAL PATTERN, POINTER TO IP ARRAY.
C ISL - FLAG FOR ALL SOLID PATTERN (1) OR ALL GAP PATTERN (-1).
C IFSTFL - FLAG TO CONTROL THAT FRSTD IS CALLED IN CFVLD BEFORE VECTD IS
C          CALLED, WHENEVER DASHDB OR DASHDC HAS BEEN CALLED.
C IFSTF2 - FLAG TO CONTROL THAT FRSTD IS CALLED IN FDVDLD BEFORE VECTD
C          IS CALLED, WHENEVER DASHDB OR DASHDC HAS BEEN CALLED.
C
   10 CONTINUE
      NCHRTS = 0
      L = 0
      ISL = 0
      IFSTFL = 1
      IFSTF2 = 1
C
      ICRT = IPAU*ISHIFT(1,15-10)
      IF (IPAT(1) .NE. 0) GO TO 260
      ISL = -1
      RETURN
  260 IF (IPAT(1) .NE. MASK) GO TO 270
      ISL = 1
      RETURN
  270 NMODE1 = IAND(ISHIFT(IPAT(1),-15),1)
      DO 290 I = 1,16
      IF (NMODE1 .NE. IAND(ISHIFT(IPAT(1),I-16),1)) GO TO 280
      NMODE1 = 1 - NMODE1
      L = L + 1
      IP(L) = 0
      IPFLAG(L) = 1 - 2*NMODE1
  280 IP(L) = IP(L) + ICRT
  290 CONTINUE
      RETURN
      END
      SUBROUTINE DRAWPV (IX,IY,IND)
C
C DRAWPV INTERCEPTS THE CALL TO PLOTIT TO CHECK IF THE PEN HAS TO BE
C MOVED OR IF IT IS ALREADY CLOSE ENOUGH TO THE WANTED POSITION.
C IF IND=2 NEVER MOVE PEN, JUST UPDATE VARIABLES IXSTOR AND IYSTOR.
C
C IN IXSTOR AND IYSTOR THE CURRENT POSITION OF THE PEN IS SAVED.
C
      COMMON /DSAVE3/ IXSTOR,IYSTOR
C
      COMMON/INTPR/IPAU,FPART,TENSN,NP,SMALL,L1,ADDLR,ADDTB,MLLINE,
     1    ICLOSE
      SAVE
      IIND = IND + 1
      GOTO (100,90,105), IIND
C
   90 CONTINUE
C
C DRAW LINE AND SAVE POSITION OF PEN.
C
      IXSTOR = IX
      IYSTOR = IY
      CALL PLOTIT (IXSTOR,IYSTOR,1)
      GOTO 110
C
  100 CONTINUE
C
C CHECK IF PEN IS ALREADY CLOSE ENOUGH TO THE WANTED POSITION.
C
      DIFF = FLOAT(IABS(IXSTOR-IX)+IABS(IYSTOR-IY))
      IF (DIFF .LE. FLOAT(ICLOSE)) GO TO 110
C
      IXSTOR = IX
      IYSTOR = IY
      CALL PLOTIT (IXSTOR,IYSTOR,0)
      GOTO 110
C
  105 CONTINUE
C
C DO NOT MOVE PEN. JUST UPDATE VARIABLES IXSTOR AND IYSTOR.
C
      IXSTOR = IX
      IYSTOR = IY
C
  110 CONTINUE
C
      RETURN
      END
      BLOCKDATA DASHBD
C
C DASHBD IS USED TO INITIALIZE VARIABLES IN NAMED COMMON.
C
      COMMON /DASHD1/  ISL,  L,  ISIZE,  IP(100),  NWDSM1,  IPFLAG(100)
     1                 ,MNCSTR, IGP
C
      COMMON /FDFLAG/ IFLAG
C
      COMMON /DDFLAG/ IFCFLG
C
      COMMON /DCFLAG/ IFSTFL
C
      COMMON /DFFLAG/ IFSTF2
C
      COMMON /CFFLAG/ IVCTFG
C
      COMMON /DSAVE3/ IXSTOR,IYSTOR
C
      COMMON /DSAVE5/ XSAVE(70), YSAVE(70), XSVN, YSVN, XSV1, YSV1,
     1                SLP1, SLPN, SSLP1, SSLPN, N, NSEG
C
      COMMON /SMFLAG/ IOFFS
C
      COMMON/INTPR/IPAU,FPART,TENSN,NP,SMALL,L1,ADDLR,ADDTB,MLLINE,
     1    ICLOSE
      SAVE
C
C IFSTFL CONTROLS THAT FRSTD IS CALLED BEFORE VECTD IS CALLED (IN CFVLD)
C WHENEVER DASHDB OR DASHDC HAS BEEN CALLED.
C
      DATA IFSTFL /1/
C
C IVCTFG INDICATES IF VECTD IS BEING CALLED OR LASTD (IN CFVLD)
C
      DATA IVCTFG /1/
C
C ISL IS A FLAG FOR AN ALL SOLID PATTERN (+1) OR AN ALL GAP PATTERN (-1)
C
      DATA ISL /1/
C
C IGP IS AN INTERNAL PARAMETER. IT IS DESCRIBED IN THE DOCUMENTATION
C TO THE DASHED LINE PACKAGE.
C
      DATA IGP /9/
C
C MNCSTR IS THE MAXIMUM NUMBER OF CHARACTERS ALLOWED IN A HOLLERITH
C STRING PASSED TO DASHDC.
C
      DATA MNCSTR /15/
C
C IOFFS IS AN INTERNAL PARAMETER.
C IOFFS IS USED IN FDVDLD AND DRAWPV.
C
      DATA IOFFS /0/
C
C  INTERNAL PARAMETERS
C
      DATA IPAU/3/
      DATA FPART/1./
      DATA TENSN/2.5/
      DATA NP/150/
      DATA SMALL/128./
      DATA L1/70/
      DATA ADDLR/2./
      DATA ADDTB/2./
      DATA MLLINE/384/
      DATA ICLOSE/6/
C
C IFSTF2 IS A FLAG TO CONTROL THAT FRSTD IS CALLED BEFORE VECTD IS
C CALLED (IN SUBROUTINE FDVDLD), WHENEVER DASHDB OR DASHDC
C HAS BEEN CALLED.
C
      DATA IFSTF2 /1/
C
C IFLAG CONTROLS IF LASTD CAN BE CALLED DIRECTLY OR IF IT WAS JUST
C CALLED FROM BY VECTD SO THAT THIS CALL CAN BE IGNORED.
C
      DATA IFLAG /1/
C
C IFCFLG IS THE FIRST CALL FLAG FOR SUBROUTINES DASHDB AND DASHDC.
C  1 = FIRST CALL TO DASHDB OR DASHDC.
C  2 = DASHDB OR DASHDC HAS BEEN CALLED BEFORE.
C
      DATA IFCFLG /1/
C
C IXSTOR AND IYSTOR CONTAIN THE CURRENT PEN POSITION. THEY ARE
C INITIALIZED TO AN IMPOSSIBLE VALUE.
C
      DATA IXSTOR,IYSTOR /-9999,-9999/
C
C SLP1 AND SLPN ARE INITIALIZED TO AVOID THAT THEY ARE PASSED AS ACTUAL
C PARAMETERS FROM FDVDLD TO KURV1S WITHOUT BEING DEFINED.
C
      DATA SLP1,SLPN /-9999.,-9999./
C
      END
      SUBROUTINE CFVLD (IENTRY,IIX,IIY)
C
C CFVLD CONNECTS POINTS WHOSE COORDINATES ARE SUPPLIED IN THE ARGUMENTS,
C ACCORDING TO THE DASH PATTERN WHICH IS PASSED FROM ROUTINE DASHDB
C OR DASHDC IN THE COMMON-BLOCK DASHD1.
C
      CHARACTER*16  IPC(100)
C
      COMMON/INTPR/IPAU,FPART,TENSN,NP,SMALL,L1,ADDLR,ADDTB,MLLINE,
     1    ICLOSE
C
C THE VARIABLES IN DASHD1 AND DASHD2 ARE USED FOR COMMUNICATION WITH
C DASHDC AND DASHDB.
C
      COMMON /DASHD1/  ISL,  L,  ISIZE,  IP(100),  NWDSM1,  IPFLAG(100)
     1                 ,MNCSTR, IGP
      COMMON /DASHD2/  IPC
C
C THE VARIABLES IN DSAVE1 HAVE TO BE SAVED FOR THE NEXT CALL TO CFVLD.
C
      COMMON /DSAVE1/ X,Y,X2,Y2,X3,Y3,M,BTI,IB,IX,IY
C
C THE FLAGS IFSTFL AND IVCTFG ARE INITIALIZED IN THE BLOCK DATA DASHBD.
C IFSTFL CONTROLS THAT FRSTD IS CALLED BEFORE VECTD IS CALLED.
C IVCTFG IS A FLAG TO INDICATE IF CFVLD IS BEING CALLED FROM VECTD OR
C LASTD.
C
      COMMON /DCFLAG/ IFSTFL
      COMMON /CFFLAG/ IVCTFG
      SAVE
C
C
C CMN IS USED TO DETERMINE WHEN TO STOP DRAWING A LINE SEGMENT
C
      DATA CMN/1.5/
C
C IMPOS IS USED AS AN IMPOSSIBLE PEN POSITION.
C
      DATA IMPOS /-9999/
C
C
C  ISL= -1  ALL BLANK  ) FLAG TO AVOID MOST CALCULATIONS
C        0  DASHED     )   IF PATTERN IS ALL SOLID OR
C        1  ALL SOLID  )   ALL BLANK
C
C     X,IX,Y,IY    CURRENT POSITION
C     X1,Y1        START OF A USER LINE SEGMENT
C     X2,Y2        END OF A USER LINE SEGMENT
C     X3,Y3        START OF A GAP PATTERN SEGMENT
C
C  SYMBOLS,IF PRESENT ARE CENTERED IN AN IMMEDIATLY PRECEEDING
C     GAP SEGMENT, OR DONE AT THE CURRENT POSITION OTHERWISE
C
C  SEGMENT TYPES ARE RECOGNIZED AS FOLLOWS
C     SOLID - WORD IN IP-ARRAY CONTAINS POSITIVE INTEGER, CORRESPONDING
C             ELEMENT IN IPFLAG IS 1.
C     GAP - WORD IN IP-ARRAY CONTAINS POSITIVE INTEGER, CORRESPONDING
C             ELEMENT IN IPFLAG IS -1.
C     SYMBOL - WORD IN IP-ARRAY CONTAINS CHARACTER REPRESENTATIONS.
C             CORRESPONDING ELEMENT IN IPFLAG IS 0.
C             SYMBOL COUNT FOR CHAR STRING IN CHAR NUMBER MNCSTR+1.
C     THE IP ARRAY AND THE IPFLAG ARRAY ARE COMPOSED OF L ELEMENTS.
C
C     BTI - BITS THIS INCREMENT
C     BPBX,BPBY BITS PER BIT X(Y)
C
C
C BRANCH DEPENDING ON FUNCTION TO BE PERFORMED.
C
      GO TO (330,305,350),IENTRY
C
C INITIALIZE VARIABLES (ENTRY FRSTD ONLY)
C
   30 CONTINUE
      X = IX
      Y = IY
      X2 = X
      X3 = X
      Y2 = Y
      Y3 = Y
      M = 1
      IB = IPFLAG(1)
      IF (IPFLAG(1) .NE. 0) GO TO 40
      IB = 0
      BTI = 0
   40 CONTINUE
      BTI = FLOAT(IP(1))*FPART
      GO TO 300
C
C MAIN LOOP START
C
   50 CONTINUE
         X1 = X2
         Y1 = Y2
         MX = IIX
         MY = IIY
         X2 = MX
         Y2 = MY
         DX = X2-X1
         DY = Y2-Y1
         D = SQRT(DX*DX+DY*DY)
         IF (D .LT. CMN) GO TO 190
   60    BPBX = DX/D
         BPBY = DY/D
         CALL DRAWPV (IX,IY,0)
   70    BTI = BTI-D
         IF (BTI) 100,100,80
C
C LINE SEGMENT WILL FIT IN CURRENT PATTERN ELEMENT
C
   80    X = X2
         Y = Y2
         IX = X2
         IY = Y2
         IF (IB) 200,160,90
   90    CALL DRAWPV (IX,IY,1)
         GO TO 200
C
C LINE SEGMENT WONT FIT IN CURRENT PATTERN ELEMENT
C DO IT TO END OF ELEMENT, SAVE HOW MUCH OF SEGMENT LEFT TO DO (D)
C
  100    BTI = BTI+D
         D = D-BTI
         X = X+BPBX*BTI
         Y = Y+BPBY*BTI
         IX = X+.5
         IY = Y+.5
         IF (IB) 110,160,120
  110    CALL DRAWPV (IX,IY,0)
         GO TO 130
  120    CALL DRAWPV (IX,IY,1)
C
C GET THE NEXT PATTERN ELEMENT
C
  130    M = MOD(M,L)+1
         IB = IPFLAG(M)
         IF (IB) 140,160,150
  140    X3 = X
         Y3 = Y
         BTI = FLOAT(IP(M))
         GO TO 70
  150    X3 = -1.
         BTI = FLOAT(IP(M))
         GO TO 70
C
C CHARACTER GENERATION
C
  160    S = 0.
         IF (IGP .NE. 9) GO TO 162
C
         DX = X-X3
         DY = Y-Y3
         GO TO 164
C
  162    CONTINUE
         DX = X - X1
         DY = Y - Y1
  164    CONTINUE
C
         IF (DY) 170,180,170
  170    S = ATAN2(DY,DX)
         IF (ABS(S-.00005) .GT. 1.5708) S = S-SIGN(3.14159,S)
  180    IF (IGP .NE. 9) GO TO 182
C
         MX = X3 + DX*.5
         MY = Y3 + DY*.5
         LIGP = 0
         GO TO 184
C
  182    CONTINUE
         MX = X
         MY = Y
         LIGP = 1
C
  184    CONTINUE
         IS = IFIX(S*180./3.14 + .5)
         IF (IS .LT. 0) IS = 360+IS
         CALL GETUSV('XF',LXSAVE)
         CALL GETUSV('YF',LYSAVE)
         MX = ISHIFT (MX,LXSAVE-15)
         MY = ISHIFT(MY,LYSAVE-15)
         CALL WTSTR(CPUX(MX),CPUY(MY),IPC(M)(1:IP(M)),ISIZE,IS,LIGP)
         CALL DRAWPV (IMPOS,IMPOS,2)
         CALL DRAWPV (IX,IY,0)
         GO TO 130
  190    X2 = X1
         Y2 = Y1
  200 CONTINUE
C
C EXIT IF CALL WAS TO VECTD.
C
      IF (IVCTFG .NE. 2) GO TO 210
      IVCTFG = 1
      GO TO 300
C
C EXIT IF NOT PLOTTING A GAP
C
  210 IF (IB .GE. 0) GO TO 300
C
C MUST BE IN A GAP AT END OF LASTD. EXIT IF NOT A LABEL GAP.
C
      MO = M
      M = MOD(M,L) + 1
      IF (IPFLAG(M) .NE. 0) GO TO 300
C
C CHECK PREVIOUS PLOTTED ELEMENT. WAS IT A GAP OR A LINE.
C
      MPREV = M - 2
      IF (MPREV .LE. 0) MPREV = MPREV + L
      IB = IPFLAG(MPREV)
      IF (IB .GE. 0) GO TO 250
C
C PREVIOUS ELEMENT WAS A GAP - LOOK FOR NEXT LINE.
C EXIT IF NO LINES IN PATTERN.
C
  230 CONTINUE
  240 M = MOD(M,L)+1
      IF (M .EQ. MO) GO TO 300
      IB = IPFLAG(M)
      IF (IB .EQ. 0) GOTO 245
      BTI = FLOAT(IP(M))
  245 CONTINUE
C
C IF IP(M) NOT A LINE, CONTINUE LOOKING.
C
      IF (IB) 240,230,280
C
C PREVIOUS ELEMENT WAS A LINE - LOOK FOR NEXT GAP.
C IF NO NON-LABEL GAPS IN PATTERN, GO TO 290.
C
  250 CONTINUE
  260 M = MOD(M,L)+1
      IF (M .EQ. MO) GO TO 290
      IB = IPFLAG(M)
      IF (IB .EQ. 0) GOTO 265
      BTI = FLOAT(IP(M))
  265 CONTINUE
C
C IF IP(M) NOT A GAP, CONTINUE LOOKING.
C
      IF (IB) 270,250,260
C
C FOUND A GAP. IF ITS A LABEL GAP, GO LOOK FOR NEXT GAP.
C
  270 MT = M
      M = MOD(M,L)+1
      IF (IPFLAG(M) .EQ. 0) GO TO 250
      M = MT
C
C M POINTS TO NEXT ELEMENT TO PLOT. SET UP AND GO PLOT.
C
  280 X1 = X3
      Y1 = Y3
      X = X3
      Y = Y3
      IX = X+0.5
      IY = Y+0.5
      DX = X2-X1
      DY = Y2-Y1
      D = SQRT(DX*DX+DY*DY)
      IF (D .GE. CMN) GO TO 60
      GO TO 300
C
C NO NON-LABEL GAPS IN THE PATTERN - FILL IN WITH SOLID LINE.
C
  290 IX = X3+0.5
      IY = Y3+0.5
      CALL DRAWPV (IX,IY,0)
      IX = X2
      IY = Y2
      CALL DRAWPV (IX,IY,1)
  300 RETURN
C
C *************************************
C
C ENTRY VECTD (XX,YY)
C
  305 CONTINUE
C
C TEST FOR PREVIOUS CALL TO FRSTD.
C
      IF (IFSTFL .EQ. 2) GO TO 310
C
C INFORM USER - NO PREVIOUS CALL TO FRSTD. TREAT CALL AS FRSTD CALL.
C
      CALL SETER ('CFVLD -- VECTD CALL OCCURS BEFORE A CALL TO FRSTD.',
     -             1,1)
      GO TO 330
  310 K = 1
      IVCTFG = 2
      IF (ISL) 300,50,320
  320 IX = IIX
      IY = IIY
      CALL DRAWPV (IX,IY,1)
      GO TO 300
C
C *************************************
C
C     ENTRY FRSTD (FLDX,FLDY)
C
  330 IX = IIX
      IY = IIY
      IFSTFL = 2
C AVOID UNEXPECTED PEN POSITION IF CALLS TO SYSTEM PLOT PACKAGE
C ROUTINES WERE MADE.
      CALL DRAWPV (IMPOS,IMPOS,2)
      IF (ISL) 300,30,340
  340 CALL DRAWPV (IX,IY,0)
      GO TO 300
C
C *************************************
C
C     ENTRY LASTD
C
  350 CONTINUE
C
C TEST FOR PREVIOUS CALL TO FRSTD
C
      IF (IFSTFL .NE. 2) GO TO 300
      IFSTFL = 1
      K = 1
      IF (ISL .NE. 0) GO TO 300
      GO TO 210
      END
      SUBROUTINE FRSTD (X,Y)
C USER ENTRY PPINT.
      CALL FL2INT (X,Y,IIX,IIY)
      CALL FDVDLD (1,IIX,IIY)
      RETURN
      END
      SUBROUTINE VECTD (X,Y)
C USER ENTRY POINT.
      CALL FL2INT (X,Y,IIX,IIY)
      CALL FDVDLD (2,IIX,IIY)
      RETURN
      END
      SUBROUTINE LASTD
C USER ENTRY POINT. SEE DOCUMENTATION FOR PURPOSE.
      DATA IDUMMY /0/
      CALL FDVDLD (3,IDUMMY,IDUMMY)
C
C     FLUSH PLOTIT BUFFER
C
      CALL PLOTIT(0,0,0)
      RETURN
      END
      SUBROUTINE CURVED (X,Y,N)
C USER ENTRY POINT.
C
      DIMENSION X(N),Y(N)
C
      CALL FRSTD (X(1),Y(1))
      DO 10 I=2,N
         CALL VECTD (X(I),Y(I))
   10 CONTINUE
C
      CALL LASTD
C
      RETURN
      END
      SUBROUTINE LINED (XA,YA,XB,YB)
C USER ENTRY POINT.
C
      DATA IDUMMY /0/
      CALL FL2INT (XA,YA,IXA,IYA)
      CALL FL2INT (XB,YB,IXB,IYB)
C
      CALL CFVLD (1,IXA,IYA)
      CALL CFVLD (2,IXB,IYB)
      CALL CFVLD (3,IDUMMY,IDUMMY)
C
      RETURN
C
C------REVISION HISTORY
C
C JUNE 1984          CONVERTED TO FORTRAN77 AND GKS
C
C DECEMBER 1979      ADDED REVISION HISTORY AND STATISTICS
C                    CALL
C
C-----------------------------------------------------------------------
C
      END
