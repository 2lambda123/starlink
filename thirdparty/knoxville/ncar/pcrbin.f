      PROGRAM PCRBIN
C
C Because of the difficulty of porting a binary file, the database
C for the  PWRITX  package is supplied on the distribution tape in
C the four card-image files
C
C   PWRITXC1
C   PWRITXC2
C   PWRITXD1
C   PWRITXD2
C
C PWRITX  uses a binary file as its database.  This program (PCRBIN),
C converts the four card-image files mentioned above into one binary
C file having four records.
C
C After  PCRBIN  has created the desired binary file, it calls two
C short test routines to make sure thae accessing of all records
C works correctly.  A message is printed as to the success or
C failure of the test routines.
C
C This program uses the support routines  ISHIFT, IAND, and IOR which
C are required locally-implemented support routines for the NCAR
C GKS package.  Also, the entry  SETER  of the error package ERPRT77
C is invoked.
C
C Before executing PCRBIN the implementation-dependent canstants in
C the BLOCKDATA DPORT must be set.  Also, make the four files
C PWRITXC1, PWRITXC2, PWRITXD1, and PWRITXD2 available on the
C units specified in BLOCKDATA DPORT.  Ready the unit specified
C in BLOCKDATA DPORT to recieve the created binary output file
C (the file which will ultimately be used by PWRITX.)
C
C **********************************************************************
C
C          D E C L A R A T I O N S
C
C **********************************************************************
C
C Note that the size of  IDD, IND, and IWORK  may have to be modified
C to contain the number of elements equal to the value of  IDDLEN and
C INDLEN  as computed in the code below.
C
      COMMON/PWRC0/IDD(8625),IND(789)
      COMMON/IDC0/LENWOR,IWORK(8625)
C
C  FOR INITIALIZATION OF CONSTANTS IN CREBIN
C
      COMMON/IDC2/MASK15(15)
C
C  FOR INITIALIZATION OF CONSTANTS IN CREBIN AND CREB15
C
      COMMON/IDC1/NBWD,IZERO,MA15
C
C  FOR INITIALIZATION OF MACHINE DEPENDENT CONSTANTS
C
      COMMON/PINIT2/FLAG
      LOGICAL FLAG
C
C CONSTANTS DEFINED IN BLOCK DATA DPORT.
      COMMON /IDC3/ IU1,IU2,IU3,IU4,IOUT,ICNUM1,ICNUM2,IDDLEN,INDLEN
C
C     EXTERNAL DPORT
C
C CHECK IF IMPLEMENTATION DEPENDENT CONSTANTS ARE INITIALIZED.
      IF (IU1.NE.0) GO TO 1
      CALL SETER(' PCRBIN - MACHINE DEPENDENT CONSTANTS NOT SET',1,2)
    1 CONTINUE
C
C
C            INITIALIZATION  PASS
C
C  CHECK IF DONE
C
      IF (FLAG) GO TO 9000
      FLAG = .TRUE.
C
C GET NUMBER OF BITS PER WORD
C
      NBWD = I1MACH(5)
C
C  FIND THE NUMBER OF 15 BIT PARSALS PER WORD
C
      NUM15 = NBWD/15
C
C  CALCULATE THE LENGTH OF ARRAYS IWORK,IDD,INDREQUIRED ON THIS
C  MACHINE.
C
      LENWOR = (ICNUM2*16*15-1)/NBWD +1
      IDDLEN = LENWOR
      INDLEN = (ICNUM1*16-1)/NUM15+1
C
C  GENERATE MASKS FOR THE LEFTMOST 1-15 BITS IN A WORD
C
      MASK = 1
      MASK = ISHIFT(MASK,(NBWD-1))
      MASK15(1) = 0
      DO 1000 I = 2,15
      MASK15(I) = ISHIFT(MASK15(I-1),-1)
      MASK15(I) = IOR(MASK,MASK15(I))
 1000 CONTINUE
C
C
C  END INITIALIZATION
 9000 CONTINUE
C
C
C
C FOR DIGITIZATION OF COMPLEX CHARACTER SET.
C
C
C CREATE 1 BINARY RECORD ON FILE IOUT CONTAINING THE CONTENTS OF THE
C ARRAY IND IN PWRITX.
      CALL CREB15(IU1,IOUT,ICNUM1,IWORK,LENWOR)
C
C
C CREATE 1 BINARY RECORD ON FILE IOUT CONTAINING THE CONTENTS OF THE
C ARRAY IDD IN PWRITX.
      CALL CREBIN(IU2,IOUT,ICNUM2,IWORK,LENWOR)
C
C
C FOR DIGITIZATION OF DUPLEX CHARACTER SET.
C
C
C CREATE 1 BINARY RECORD ON FILE IOUT CONTAINING THE CONTENTS OF THE
C ARRAY IND IN PWRITX.
      CALL CREB15(IU3,IOUT,ICNUM1,IWORK,LENWOR)
C
C
C CREATE 1 BINARY RECORD ON FILE IOUT CONTAINING THE CONTENTS OF THE
C ARRAY IDD IN PWRITX.
      CALL CREBIN(IU4,IOUT,ICNUM2,IWORK,LENWOR)
C
      ENDFILE IOUT
C
C 29-NOV-1991 P.C.T.Rees (STARLINK)
C    Assign I1MACH to the variable I1UNIT to comply with the Fortran 
C    standard.
C
      I1UNIT=I1MACH(2)
      WRITE(I1UNIT,101)
 101  FORMAT (1X,' PCRBIN - BINARY FILE CREATED')
C
C
C READ THE 2 RECORDS REPRESENTING THE COMPLEX CHARACTER SET.
      REWIND IOUT
      READ(IOUT) (IND(I),I=1,INDLEN)
      READ(IOUT) (IDD(I),I=1,IDDLEN)
      REWIND IOUT
C
C TEST THE ACCESSING OF THE COMPLEX CHARACTER SET.
C
      CALL CCHECK(IERR)
C
C
      WRITE(I1UNIT,102)
 102  FORMAT(1X,' PCRBIN - TEST COMPLEX SET')
C
C PRINT THE TEST RESULTS.
C
      IF (IERR .NE. 0) GOTO 2
      WRITE(I1UNIT,103)
 103  FORMAT(1X,' PCRBIN - TEST WAS SUCCESSFUL')
      GOTO 10
C
    2 CONTINUE
      IF (IERR .NE. 1) GOTO 3
      WRITE(I1UNIT,104)
 104  FORMAT(1X,' TEST SUCCESSFUL FOR 12 BIT BUT NOT FOR 6 BIT UNITS')
      GOTO 10
C
    3 CONTINUE
      IF (IERR .NE. 2) GOTO 4
      WRITE(I1UNIT,105)
 105  FORMAT(1X,' TEST SUCCESSFUL FOR 6 BIT BUT NOT FOR 12 BIT UNITS')
      GOTO 10
C
    4 CONTINUE
      WRITE(I1UNIT,106)
 106  FORMAT(1X,' PCRBIN - TEST NOT SUCCESSFUL')
C
C
   10 CONTINUE
C
C
C LOAD THE 2 RECORDS REPRESENTING THE DUPLEX CHARACTER SET.
      REWIND IOUT
      READ(IOUT) DUMREA
      READ(IOUT) DUMREA
      READ(IOUT) (IND(I),I=1,INDLEN)
      READ(IOUT) (IDD(I),I=1,IDDLEN)
      REWIND IOUT
C
C TEST ACCESSING OF DUPLEX CHARACTER SET.
C
      CALL DCHECK(IERR)
C
      WRITE(I1UNIT,200)
 200  FORMAT(1X,' PCRBIN - TEST DUPLEX SET')
C
C PRINT THE TEST RESULTS.
C
      IF (IERR .NE. 0) GOTO 11
      WRITE(I1UNIT,201)
 201  FORMAT(1X,' PCRBIN - TEST WAS SUCCESSFUL')
      GOTO 20
C
   11 CONTINUE
      IF (IERR .NE. 1) GOTO 12
      WRITE(I1UNIT,202)
 202  FORMAT(1X,' TEST SUCCESSFUL FOR 12 BIT BUT NOT FOR 6 BIT UNITS')
      GOTO 20
C
   12 CONTINUE
      IF (IERR .NE. 2) GOTO 13
      WRITE(I1UNIT,203)
 203  FORMAT(1X,' TEST SUCCESSFUL FOR 6 BIT BUT NOT FOR 12 BIT UNITS')
      GOTO 20
C
   13 CONTINUE
      WRITE(I1UNIT,204)
 204  FORMAT(1X,' PCRBIN - TEST NOT SUCCESSFUL')
C
C
   20 CONTINUE
C
      STOP
      END
      SUBROUTINE CREBIN(INUNIT,IOUTUN,INNUM,ITEMP,LENTEM)
C
C ROUTINE TO TRANSFORM A SEQUENCE OF INTEGERS INTO A CONTINUOUS BIT
C STREAM.
C
C ON ENTRY
C     INUNIT IS A FILE WHICH CONTAINS INNUM CARD IMAGES. EACH CARD
C     IMAGE CONTAINS 16 INTEGERS, EACH IN AN I5 FORMAT. EACH INTEGER
C     REPRESENTS A POSITIVE 15 BIT VALUE.
C     INUNIT CAN BE READ BY CREBIN.
C     IOUTUN IS A UNIT NUMBER WHERE CREBIN CAN WRITE A RECORD.
C     IOUTUN IS ASSUMED TO BE POSITIONED RIGHT.
C     ITEMP IS AN ARRAY OF LENGTH LENTEM. ITS ELEMENTS MAY HAVE
C     ANY VALUE.
C     LENTEM MUST BE (INNUM*15*16-1)/NBWD+1 OR BIGGER WHERE NBWD IS
C     THE NUMBER OF BITS PER WORD.
C     INNUM IS THE NUMBER OF CARD IMAGES ON FILE INUNIT.
C ON EXIT
C     THE VALUES OF INUNIT,IOUTUN, AND INNUM ARE UNCHANGED.
C     FILE INUNIT IS REWOUND BUT OTHERWISE UNCHANGED.
C     ITEMP CONTAINS THE INTEGERS FROM FILE INUNIT STORED
C     CONSECUTIVELY WITHOUT CONSIDERING WORD BOUNDARIES.
C     A BINARY RECORD IS CREATED ON UNIT IOUTUN WHICH CONTAINS THE FIRST
C     NUMOUT WORDS OF THE ARRAY ITEMP AS ONE LONG BIT STRING,
C     WHERE NUMOUT IS EXACTLY (INNUM*15*16-1)/NBWD+1.
C CALLS
C     IAND,IOR,ISHIFT
C
      DIMENSION ITEMP(LENTEM)
C
C TEMPORARY STORAGE TO CONTAIN 1 CARD IMAGE.
      DIMENSION ICARD(16)
C
C SEE BLOCK DATA DPORT FOR MEANING OF CONSTANTS IN COMMON BLOCKS.
      COMMON /IDC1/ NBWD, IZERO, MA15
      COMMON /IDC2/ MASK15(15)
C
C LOCAL VARIABLES
C   IWORD - THE ENTRY IN THE ARRAY ITEMP WHICH IS CURRENTLY BEING
C           FILLED
C   IN15 - CONTAINS 15 BIT UNIT, RIGHT JUSTIFIED.
C   IIN15 - CONTAINS THE 15 BIT UNIT - OR PART OF IT - AT THE POSITION
C           WHICH IT WILL HAVE IN ITEMP(IWORD)
C   IPOS - THE NUMBER OF THE FIRST BIT IN THE WORD ITEMP(IWORD), WHERE
C          THE NEXT 15 BIT UNIT WILL BE STORED - 1 .
C          (COUNT FROM LEFT TO RIGHT, START WITH 0)
C   ICARD - TEMPORARY STORAGE FOR 1 CARD IMAGE.
C
C
      REWIND INUNIT
C
      IWORD = 1
      IPOS = 0
      ITEMP(1) = IZERO
C
C LOOP THROUGH ALL CARD IMAGES.
      DO 1 I = 1,INNUM
      READ(INUNIT,100)(ICARD(J),J=1,16)
C LOOP THROUG ALL 15 BIT UNITS ON A CARD IMAGE.
      DO 10 J=1,16
      IN15 = ICARD(J)
C STORE 15 BIT UNIT AS A WHOLE IF POSSIBLE OR LEFT PART OF IT IF IT
C HITS WORD BOUNDARY.
      IIN15 = ISHIFT(IAND(IN15,MA15),NBWD-15-IPOS)
      ITEMP(IWORD) = IOR(ITEMP(IWORD),IIN15)
      IPOS = IPOS + 15
      IF (IPOS .LT. NBWD) GOTO 11
C WORD BOUNDARY REACHED. STORE RIGHT PART OF UNIT INTO NEXT WORD.
      IPOS = IPOS - NBWD
      IWORD = IWORD + 1
      ITEMP(IWORD) = IZERO
      IIN15 = ISHIFT(IAND(IN15,MA15),NBWD-IPOS)
      ITEMP(IWORD) = IOR(ITEMP(IWORD),IIN15)
      ITEMP(IWORD) = IAND(ITEMP(IWORD),MASK15(IPOS+1))
   11 CONTINUE
   10 CONTINUE
    1 CONTINUE
C
      WRITE(IOUTUN) (ITEMP(J),J=1,IWORD)
C
      REWIND INUNIT
C
  100 FORMAT(16I5)
C
      RETURN
      END
      SUBROUTINE CREB15(INUNIT,IOUTUN,INNUM,ITEMP,LENTEM)
C
C ROUTINE TO STORE A SEQUENCE OF INTEGERS INTO AN ARRAY.
C
C ON ENTRY
C     INUNIT IS A FILE WHICH CONTAINS INNUM CARD IMAGES. EACH CARD
C     IMAGE CONTAINS 16 INTEGERS, EACH IN AN I5 FORMAT. EACH INTEGER
C     REPRESENTS A POSITIVE 15 BIT VALUE.
C     INUNIT CAN BE READ BY CREB15.
C     IOUTUN IS A UNIT NUMBER WHERE CREB15 CAN WRITE A RECORD.
C     IOUTUN IS ASSUMED TO BE POSITIONED RIGHT.
C     ITEMP IS AN ARRAY OF LENGTH LENTEM. ITS ELEMENTS MAY HAVE
C     ANY VALUE.
C     LENTEM MUST BE (INNUM*16-1)/NUM15+1 OR BIGGER, WHERE NUM15 IS
C     THE NUMBER OF 15 BIT UNITS WHICH FIT AS A WHOLE INTO 1 WORD.
C     INNUM IS THE NUMBER OF CARD IMAGES ON FILE INUNIT.
C ON EXIT
C     THE VALUES OF INUNIT,IOUTUN, AND INNUM ARE UNCHANGED.
C     FILE INUNIT IS REWOUND BUT OTHERWISE UNCHANGED.
C     ITEMP CONTAINS THE INTEGERS FROM FILE INUNIT STORED LEFT
C     JUSTIFIED AS 15 BIT UNITS WITH AS MANY UNITS PER WORD AS
C     POSSIBLE WITHOUT CROSSING WORD BOUNDARIES.
C     A BINARY RECORD IS WRITTEN ON UNIT IOUTUN WHICH CONTAINS THE FIRST
C     NUMOUT WORDS OF THE ARRAY ITEMP AS ONE LONG BIT STRING,
C     WHERE NUMOUT IS EXACTLY (INNUM*16-1)/NUM15+1 AND NUM15 DEFINED
C     AS ABOVE.
C CALLS
C     IAND,IOR,ISHIFT
C
      DIMENSION ITEMP(LENTEM)
C
C TEMPORARY STORAGE TO CONTAIN 1 CARD IMAGE.
      DIMENSION ICARD(16)
C
C SEE BLOCK DATA DPORT FOR MEANING OF CONSTANTS IN COMMON BLOCK.
      COMMON /IDC1/ NBWD, IZERO, MA15
C
C
C LOCAL VARIABLES
C   IWORD - THE ENTRY IN THE ARRAY ITEMP WHICH IS CURRENTLY BEING
C           FILLED
C   IN15 - CONTAINS 15 BIT UNIT, RIGHT JUSTIFIED.
C   IIN15 - CONTAINS THE 15 BIT UNIT - OR PART OF IT - AT THE POSITION
C           WHICH IT WILL HAVE IN ITEMP(IWORD)
C   IPOS - THE NUMBER OF 15 BIT UNITS ALREADY STORED IN THE CURRENT
C          WORD + 1 .
C   ICARD - TEMPORARY STORAGE FOR 1 CARD IMAGE.
C   NUM15 - THE NUMBER OF 15 BIT UNITS WHICH FIT AS A WHOLE INTO 1 WORD.
C
C
C THE NUMBER OF 15 BIT UNITS WHICH FIT AS A WHOLE INTO ONE WORD.
C
      NUM15 = NBWD/15
C
      REWIND INUNIT
C
C
C
      IPOS = 1
      IWORD = 1
      ITEMP(1) = IZERO
C
C     READ THE INTEGERS FROM FILE INUNIT AND STORE THEM INTO THE
C     ARRAY ITEMP AS WHOLE UNITS, LEFT JUSTIFIED.
C
C LOOP THROUGH ALL CARD IMAGES.
      DO 1 I = 1,INNUM
      READ(INUNIT,100)(ICARD(J),J=1,16)
C LOOP THROUG ALL 15 BIT UNITS ON A CARD IMAGE.
      DO 10 J=1,16
      IN15 = ICARD(J)
C STORE 15 BIT UNIT AT CORRECT POSITION IN WORD.
      IIN15 = ISHIFT(IAND(IN15,MA15),NBWD-IPOS*15)
      ITEMP(IWORD) = IOR(IIN15,ITEMP(IWORD))
      IPOS = IPOS + 1
      IF (IPOS .LE. NUM15) GOTO 11
C START A NEW WORD.
      IPOS = 1
      IWORD = IWORD + 1
      ITEMP(IWORD) = IZERO
   11 CONTINUE
   10 CONTINUE
    1 CONTINUE
C
C
C WRITE 1 RECORD IN A BINARY FILE.
C
      WRITE(IOUTUN) (ITEMP(J),J=1,IWORD)
C
      REWIND INUNIT
C
  100 FORMAT(16I5)
C
      RETURN
      END
      BLOCKDATA DPORT
C
C FOR INITIALIZATION OF CONSTANTS.
C
C
C
C FOR INITIALIZATION OF CONSTANTS IN ROUTINES CREBIN AND CREB15.
      COMMON /IDC1/ NBWD, IZERO, MA15
C FOR INITIALIZATION OF CONSTANTS IN ROUTINE CREBIN.
      COMMON /IDC2/ MASK15(15)
C FOR INITIALIZATION OF CONSTANTS IN THE MAIN PROGRAM.
      COMMON /IDC3/ IU1,IU2,IU3,IU4,IOUT,ICNUM1,ICNUM2,IDDLEN,INDLEN
C FOR INITIALIZATION OF CONSTANTS IN ROUTINE XTCH.
      COMMON /PWRC2/ INDZER
C  NOTE THAT IWORK MAY BE CHANGED TO CONTAIN THE NUMBER OF ELEMENTS
C  EQUAL TO THE VALUE OF LENWOR.
      COMMON/IDC0/LENWOR , IWORK(8625)
C
C  INITIALIZATION FLAG FOR PCRBIN
C
      COMMON/PINIT2/FLAG
      LOGICAL FLAG
C
C  INITIALIZATION FOR MASK GENERATION
C
      COMMON/PINIT1/IFRST
      LOGICAL IFRST
C
C  MASKING AND OTHER MACHINE DEPENDENT CONSTANTS WHICH MUST BE
C  CALCULATED.
C
      COMMON/PINIT/MASK(4),MASK6(64),MASK12(64),LAST6,LAST12,IBIT15,
     1     MASK14,NUM15U,NBWD1
C
C  FLAG IS USED BY PCRBIN TO DECIDE IF INITIALIZATION HAS BEEN
C  COMPLEATED
C
      DATA FLAG/.FALSE./
C
C  IFRST IS USED BY XTCH TO DECIDE IF MASKS HAVE BEEN GENERATED
C
      DATA IFRST/.FALSE./
C
C  MA15 MASKS THE RIGHTMOST 15 BITS OF A WORD(77777B)
C
      DATA MA15/32767/
C
      DATA IZERO/0/
C
C
C
C THE NUMBER OF CARD IMAGES CONTAINED IN FILES C1.PWRITX AND D1.PWRITX.
      DATA ICNUM1 /49/
C THE NUMBER OF CARD IMAGES CONTAINED IN FILES C2.PWRITX AND D2.PWRITX.
      DATA ICNUM2 /575/
C A SPECIAL INDICATOR.
      DATA INDZER /-2048/
C
C
C **********************************************************************
C
C IMPLEMENTATION DEPENDENT CONSTANTS
C
C THE UNIT NUMBER WHERE FILE PWRITX.C1 CAN BE READ.
      DATA IU1 /1/
C THE UNIT NUMBER WHERE FILE PWRITX.C2 CAN BE READ.
      DATA IU2 /2/
C THE UNIT NUMBER WHERE FILE PWRITX.D1 CAN BE READ.
      DATA IU3 /3/
C THE UNIT NUMBER WHERE FILE PWRITX.D2 CAN BE READ.
      DATA IU4 /4/
C
C THE UNIT NUMBER WHERE PROGRAM PCRBIN CAN WRITE THE BINARY FILE
C IT CREATES.
      DATA IOUT /7/
C
C
C END OF IMPLEMENTATION DEPENDENT CONSTANTS
C
C **********************************************************************
C
      END
      SUBROUTINE XTCH (IPOINT,IPASS,LCNUM)
C
C RETRIEVES CHARACTER DIGITIZATION.
C
C ON ENTRY
C   IND - AN ARRAY CONTAINING 15 BIT UNITS. EACH WORD CONTAINS AS MANY
C         UNITS AS FIT AS A WHOLE INTO ONE WORD ON THIS PARTICULAR
C         IMPLEMENTATION.
C         EACH UNIT REPRESENTS A POINTER INTO THE ARRAY IDD AND AN
C         INDICATION OF THE FORMAT OF THE DATA WHICH CAN BE FOUND THERE.
C         IN EACH UNIT THE 14 BITS TO THE RIGHT REPRESENT THE NUMBER OF
C         THE ENTRY IN THE ARRAY IDD (FOR 60 BIT WORDS) WHERE THE
C         CORRESPONDING DIGITIZATION STARTS.IF THE FIRST BIT TO THE LEFT
C         IS 1 WE EXPECT 12 BIT UNITS IN THE ARRAY IDD, IF IT IS 0 WE
C         EXPECT 6 BIT UNITS IN IDD.
C   IDD-AN ARRAY CONTAINING CHARACTER DIGITIZATIONS. THE DIGITIZATIONS
C       CAN CONSIST OF EITHER 12BIT OR 6 BIT UNITS. THE DIGITIZATIONS
C       ARE STORED AS A BIT STREAM CROSSING WORD BOUNDARIES IF NECESSARY
C       FOR 60 BIT WORDS THEY START AT THE BEGINNING OF A WORD.
C       THE END OF A DIGITIZATION IS INDICATED BY 2 CONSECUTIVE UNITS
C       WITH ALL BITS 0.
C   IPOINT - AN INTEGER INDICATING THE IPOINT-TH UNIT STORED IN THE
C            ARRAY IND
C   LC - AN ARRAY. ENTRIES CAN HAVE ANY VALUE.
C   IPASS = 2 RETURN DIGITIZATION OF CHARACTER IDENTIFIED BY PARAMETER
C             IPOINT IN ARRAY LC
C         = 1  RETURN ONLY FIRST AND SECOND UNIT OF DIGITIZATION IN
C              LC(1) AND LC(2)
C   LCNUM - ANY VALUE
C
C ON EXIT
C   IDD - UNCHANGED
C   IND - UNCHANGED
C   IPOINT - UNCHANGED
C   IPASS - UNCHANGED
C   LC - IF NO DIGITIZATION FOUND, UNCHANGED
C        OTHERWISE
C        LC(I) CONTAINS THE I-TH UNIT OF THE DIGITIZATION OF THE
C        CHARACTER THAT WE GET WHEN WE RETRIEVE THE IPOIN-TH UNIT IN THE
C        ARRAY IND, INTERPRET THE FIRST BIT TO THE LEFT AS AN INDICATION
C        OF A 12 BIT OR 6 BIT DIGITIZATION AND THE 14 BITS TO THE RIGHT
C        AS THE NUMBER OF THE ENTRY IN THE ARRAY IDD (FOR 60 BIT WORDS)
C        WHERE THE DIGITIZATION OF THE CHARACTER STARTS.
C        NOTICE THAT EACH UNIT GOES THROUGH A TRANSFORMATION BEFORE IT
C        IS STORED IN LC. FROM 6 BIT UNITS 32 IS SUBTRACTED, FROM 12
C        BIT UNITS 2048 IS SUBTRACTED. ALSO A SPECIAL INDICATOR (-2048)
C        IS PUT INTO LC FOR UNITS WITH ALL BITS ZERO.
C   LCNUM - IF NO DIGITIZATION FOUND, 0
C           OTHERWISE
C           THE NUMBER OF THE ENTRY IN THE ARRAY LC WHICH CONTAINS THE
C           LAST UNIT OF THE DIGITIZATION OF THE CHARACTER.
C           IT CAN ALGORITHMICALLY BE DEFINED AS THE NUMBER OF UNITS
C           WHICH CAN BE ENCOUNTERED BEFORE 2 CONSECUTIVE UNITS WITH
C           ALL 0 UNITS WERE FOUND.ASSUME THAT THE STARTING POINT WAS
C           FOUND AS DESCRIBED ABOVE WHEN DESCRIBING THE ARRAY LC.
C
C CALLS
C   IAND,ISHIFT,IOR
C
C CALLED BY
C   PWRITX,CCHECK,DCHECK
C
C
C PWRC0 AND PWRC1 ARE FOR COMMUNICATION WITH ROUTINE PWRITX.
C ROUTINE XTCH RECEIVES VALUES IN PWRC0 AND RETURNS VALUES IN PWRC1.
      COMMON /PWRC1/ LC(150)
C
C
C  NOTE THE SIZE OF IDD AND IND MAY BE MODIFED TO CONTAIN THE NUMBER OF
C  ELEMENTS EQUAL TO THE VALUE OF IDDLEN AND INDLEN COMPUTED IN PWRITX.
C
      COMMON/PWRC0/IDD(8625),IND(789)
C
C  MASKING AND OTHER MACHINE DEPENDENT CONSTANTS WHICH MUST BE
C  CALCULATED.
C
      COMMON/PINIT/MASK(4),MASK6(64),MASK12(64),LAST6,LAST12,IBIT15,
     1     MASK14,NUM15U,NBWD
C
C
C  INITIALIZATION FLAG
C
      COMMON/PINIT1/IFRST
      LOGICAL IFRST
C
C PWRC2 IS FOR COMMUNICATION WITH THE BLOCK DATA.
      COMMON /PWRC2/ INDZER
C
C
C
C MAXUN - ARRAY CONTAINING MAXIMUM NUMBER OF UNITS TO BE RETRIEVED.
      DIMENSION MAXUN(2)
C
C THE NUMBER OF BITS PER POINTER IN THE ARRAY IND.
C
      DATA NBPP /15/
C
C THE NUMBER OF BITS IN A 6 BIT UNIT.
C
      DATA NBPU6 /6/
C
C THE NUMBER OF BITS IN A 12 BIT UNIT.
C
      DATA NBPU12 /12/
C
C FOR 6 BIT UNITS.  LC(I) = I-TH UNIT - IHALF6.
C
      DATA IHALF6 /32/
C
C FOR 12 BIT UNITS.  LC(I) = I-TH UNIT - IHAL12.
C
      DATA IHAL12 /2048/
C
C THE NUMBER OF UNITS TO BE RETRIEVED IF IPASS IS EQUAL TO 1.
C
      DATA MAXUN(1) /2/
C
C THE MAXIMUM NUMBER OF UNITS TO BE RETRIEVED IF IPASS IS 2.
C
      DATA MAXUN(2) /150/
C
C
C
C
C LOCAL VARIABLES
C
C IDD - ARRAY CONTAINING DIGITIZATIONS OF CHARACTERS.
C IND - ARRAY CONTAINING POINTERS INTO THESE DIGITIZATIONS.
C LC - ARRAY TO CONTAIN THE DIGITIZATION OF 1 CHARACTER, 1 UNIT PER WORD.
C IWORD - THE WORD IN THE ARRAY IND CONTAINING THE IPOINT-TH 15 BIT
C         UNIT.
C IPOS - THE IPOS-TH UNIT IN IND(IWORD) IS THE IPOINT-TH UNIT IN THE
C        ARRAY IND.
C IFIFTN - THE IPOINT-TH 15 BIT UNIT.
C IMODE - THE MODE OF THE DIGITIZATION
C         =0  6 BIT MODE
C         =1  12 BIT MODE
C IDIGP - POINTER TO THE START OF THE DIGITIZATION
C NUMMAX - THE MAXIMUM NUMBER OF DIGITIZATION UNITS TO BE RETRIEVED
C BIT - THE NUMBER OF THE BIT IN ARRAY IDD AT WHICH THE DIGITIZATION
C        STARTS
C IDDWOR - WORD IN ARRAY IDD CONTAINING BIT IBIT
C NPOS - POSITION OF BIT IBIT IN WORD IDDWOR
C NRIGHT - NUMBER OF BITS TO THE RIGHT OF BIT NPOS IN WORD + 1
C LCTEM - CONTAINS LEFT PART OF DIGITIZATION UNIT, IF UNIT CROSSES
C         WORD BOUNDARIES
C IDIGP - ENTRY IN THE ARRAY IDD (ASSUMED 60 BIT WORDS) WHERE THE
C         DIGITIZATION STARTS
C         =0  NO DIGITIZATION FOUND
C INDZER - AN INDICATION THAT AN ALL 0 BITS UNIT WAS ENCOUNTERED.
C
C                     INITIALIZATION OF MASKS
C
C  CHECK IF INTIIALIZATION ALREADY PERFORMED
C
      IF (IFRST) GO TO 1000
      IFRST = .TRUE.
C
C  GENERATE MASKS AND OTHER MACHINE DEPENDENT CONSTANTS
C
      CALL MKMSK
C
C  END INITIALIZATION
C
 1000 CONTINUE
C
C
C
C                  P A R T   1
C FIND IDIGP, ENTRY IN ARRAY IDD WHERE DIGITIZATION OF CHARACTER STARTS.
C FIND IMODE, INDICATION FOR FORMAT OF DIGITIZATION (12 BIT, 6 BIT).
C
C
C INITIALIZE THE NUMBER OF UNITS CONTAINED IN LC TO ZERO.
C
      LCNUM = 0
C
C FIND THE WORD IN THE ARRAY IND WHICH CONTAINS THE IPOINT- TH UNIT.
C
      IWORD = (IPOINT-1)/NUM15U + 1
C
C FIND THE NUMBER OF THE IPOINT-TH UNIT WITHIN THE WORD IWORD.
C
      IPOS = IPOINT - (IWORD-1)*NUM15U
C
C RETRIEVE THE 15 BIT UNIT .
C
      IFIFTN = IAND(MASK(IPOS),IND(IWORD))
C
C SHIFT THE 15 BIT UNIT TO THE RIGHT END OF THE WORD.
C
      IFIFTN = ISHIFT(IFIFTN,IPOS*NBPP-NBWD)
C
C RETRIEVE THE MODE OF THE DIGITIZATION POINTED TO.
C
      IMODE = IAND(IFIFTN,IBIT15)
      IF (IMODE .NE. 0) IMODE = 1
C
C RETRIEVE THE NUMBER OF THE ENTRY IN THE IDD ARRAY WHERE THE
C DIGITIZATION STARTS.
C
      IDIGP = IAND (IFIFTN,MASK14)
C
C RETURN IF NO DIGITIZATION EXISTS FOR THIS POINTER.
C
      IF (IDIGP .EQ. 0) RETURN
C
C                  P A R T   2
C STORE DIGITIZATION OF CHARACTER INTO ARRAY LC, 1 UNIT PER WORD.
C
C
C DEFINE THE MAXIMUM NUMBER OF UNITS TO BE RETRIEVED.
C
      NUMMAX = MAXUN(IPASS)
C
C BRANCH DEPENDING ON FORMAT OF DIGITIZATION.
C
      IMODE = IMODE + 1
      GOTO (1,2), IMODE
C
C SIX BIT FORMAT.
C
    1 CONTINUE
C
C FIND THE BIT WHERE THE DIGITIZATION OF THE CHARACTER STARTS.
      BIT = FLOAT((IDIGP-1)*60+1)
      IDDWOR = IFIX(BIT/FLOAT(NBWD)) + 1
      NPOS = IFIX(BIT - FLOAT(IDDWOR-1)*FLOAT(NBWD))
C
C LOOP FOR MAXIMUM NUMBER OF UNITS OR TILL END OF DIGITIZATION REACHED.
      DO 11 I = 1,NUMMAX
C INCREMENT THE NUMBER OF UNITS STORED IN LC.
      LCNUM = LCNUM + 1
C STORE UNIT INTO LC(I), RIGHT JUSTIFIED.
      LC(I) = IAND(IDD(IDDWOR),MASK6(NPOS))
      NRIGHT = NBWD - NPOS + 1
      LC(I) = ISHIFT(LC(I),NBPU6-NRIGHT)
C
C *** THIS PART IS ONLY FOR MACHINES WHERE NBWD CANNOT BE DIVIDED BY 6
      IF (NRIGHT .GE. NBPU6) GOTO 10
      LCTEM = IAND (IDD(IDDWOR),MASK6(NPOS))
      LCTEM = ISHIFT(LCTEM,NBPU6-NRIGHT)
      LC(I) = IAND(IDD(IDDWOR+1),MASK6(1))
      LC(I) = ISHIFT(LC(I),NBPU6-NRIGHT-NBWD)
      LSTORE = NBWD-NBPU6+NRIGHT+1
      LC(I) = IAND(LC(I),MASK6(LSTORE))
      LC(I) = IOR(LC(I),LCTEM)
   10 CONTINUE
C *** END OF PART FOR NBWD NOT DIVIDABLE BY 6
C
      LC(I) = IAND(LAST6,LC(I))
C INTERPRET UNIT AS POSITIVE OR NEGATIVE DISPLACEMENT.
      LC(I) = LC(I) - IHALF6
C IF THIS UNIT HAS ALL ZERO BITS, SET INDICATOR .
      IF (LC(I) .EQ. -IHALF6) LC(I) = INDZER
C THE FOLLOWING CHECK CAN ONLY BE DONE FOR I GREATER THAN 1.
      IF (I .EQ. 1) GOTO 100
C CHECK FOR END OF DIGITIZATION (2 ALL ZERO UNITS IN A ROW).
      IF (LC(I) .EQ. INDZER .AND. LC(I-1) .EQ. INDZER) GOTO 3
C DEFINE THE NEXT DIGITIZATION UNIT.
  100 CONTINUE
      NPOS = NPOS + NBPU6
      IF (NPOS .LT. NBWD) GOTO 101
      IDDWOR = IDDWOR + 1
      NPOS = NPOS - NBWD
  101 CONTINUE
C
   11 CONTINUE
      GOTO 3
C
C
C TWELVE BIT FORMAT.
C
C ALGORITHM EXACTLY AS FOR SIX BIT FORMAT
    2 CONTINUE
      BIT = FLOAT((IDIGP-1)*60+1)
      IDDWOR = IFIX(BIT/FLOAT(NBWD)) + 1
      NPOS = IFIX(BIT - FLOAT(IDDWOR-1)*FLOAT(NBWD))
      DO 21 I = 1,NUMMAX
      LCNUM = LCNUM + 1
      LC(I) = IAND(IDD(IDDWOR),MASK12(NPOS))
      NRIGHT = NBWD - NPOS + 1
      LC(I) = ISHIFT(LC(I),NBPU12-NRIGHT)
C
C *** THIS PART IS ONLY FOR MACHINES WHERE NBWD CANNOT BE DIVIDED BY 12
      IF (NRIGHT .GE. NBPU12) GOTO 20
      LCTEM = IAND (IDD(IDDWOR),MASK12(NPOS))
      LCTEM = ISHIFT(LCTEM,NBPU12-NRIGHT)
      LC(I) = IAND(IDD(IDDWOR+1),MASK12(1))
      LC(I) = ISHIFT(LC(I),NBPU12-NRIGHT-NBWD)
      LSTORE = NBWD-NBPU12+NRIGHT+1
      LC(I) = IAND(LC(I),MASK12(LSTORE))
      LC(I) = IOR(LC(I),LCTEM)
   20 CONTINUE
C *** END OF PART FOR NBWD NOT DIVIDABLE BY 12 ***
C
      LC(I) = IAND(LAST12,LC(I))
      LC(I) = LC(I) - IHAL12
      IF (LC(I) .EQ. -IHAL12) LC(I) = INDZER
      IF (I .EQ. 1) GOTO 200
      IF (LC(I) .EQ. INDZER .AND. LC(I-1) .EQ. INDZER) GOTO 3
  200 CONTINUE
      NPOS = NPOS + NBPU12
      IF (NPOS .LT. NBWD) GOTO 201
      IDDWOR = IDDWOR + 1
      NPOS = NPOS - NBWD
  201 CONTINUE
   21 CONTINUE
C
C
    3 CONTINUE
C
      RETURN
      END
      SUBROUTINE CCHECK (IERR)
C
C SHORT TEST ROUTINE FOR THE CORRECT ACCESSING OF THE COMPLEX CHARACTER
C SET.
C
C ON ENTRY
C   IERR MAY CONTAIN ANY VALUE.
C ON EXIT
C   IERR = 0 IF 2 SHORT TESTS OF THE DIGITIZATION RETRIEVAL PROCESS
C            WERE SUCCESSFUL
C        = 2 IF THE TEST WAS SUCCESSFUL FOR 6 BIT DIGITIZATION UNITS
C            BUT NOT SUCCESSFUL FOR 12 BIT DIGITIZATION UNITS
C        = 1 IF THE TEST WAS SUCCESSFUL FOR 12 BIT DIGITIZATION UNITS
C            BUT NOT SUCCESSFUL FOR 6 BIT DIGITIZATION UNITS.
C        = 3 IF NEITHER OF THE 2 TESTS WAS SUCCESSFUL.
C CALLS
C   XTCH
C
C
C PWRC1 IS FOR COMMUNICATION WITH SUBROUTINE XTCH.
      COMMON /PWRC1/ LC(150)
C
C THE ARRAY CONTAINING THE CORRECT DIGITIZATION OF CHARACTER +.
      DIMENSION LCPCOR(14)
C THE ARRAY CONTAINING THE CORRECT DIGITIZATION OF THE CHARACTER DEFINED
C BY THE OCTAL NUMBER 751.
      DIMENSION LCOCOR(30)
C
C TEST 1
C   RETRIEVE DIGITIZATION OF CHARACTER + WITH DEFAULT FUNCTION CODES
C   AND COMPARE IT TO THE CORRECT DIGITIZATION.
C   (TEST 6 BIT DIGITIZATION UNITS)
C TEST 2
C   RETRIEVE DIGITIZATION OF CHARACTER DEFINED BY THE OCTAL NUMBER 751
C   AND COMPARE IT WITH THE CORRECT DIGITIZATION.
C   (TEST 12 BIT DIGITIZATION UNITS)
C
C        ** DATA FOR TEST 1 **
C
C THE NUMBER OF THE UNIT IN ARRAY IND POINTING TO THE DIGITIZATION
C OF CHARACTER +.
      DATA IPLUSP /37/
C
C THE CORRECT NUMBER OF DIGITIZATION UNITS FOR CHARACTER +.
      DATA IPLUSN /14/
C
C THE CORRECT DIGITIZATION OF CHARACTER +.
      DATA LCPCOR(1) /-13/
      DATA LCPCOR(2) /13/
      DATA LCPCOR(3) /0/
      DATA LCPCOR(4) /9/
      DATA LCPCOR(5) /0/
      DATA LCPCOR(6) /-9/
      DATA LCPCOR(7) /-2048/
      DATA LCPCOR(8) /0/
      DATA LCPCOR(9) /-9/
      DATA LCPCOR(10) /0/
      DATA LCPCOR(11) /9/
      DATA LCPCOR(12) /0/
      DATA LCPCOR(13) /-2048/
      DATA LCPCOR(14) /-2048/
C
C        ** DATA FOR TEST 2 **
C
C THE NUMBER OF THE UNIT IN ARRAY IND POINTING TO THE DIGITIZATION OF
C THE CHARACTER DEFINED BY THE OCTAL NUMBER 751.
      DATA IOCTP /489/
C
C THE CORRECT NUMBER OF DIGITIZATION UNITS OF THE CHARACTER DEFINED BY
C THE OCTAL NUMBER 751.
      DATA IOCTN /30/
C
C THE CORRECT DIGITIZATION OF THE CHARACTER DEFINED BY THE OCTAL
C NUMBER 751.
      DATA LCOCOR(1) /-9/
      DATA LCOCOR(2) /9/
      DATA LCOCOR(3) /-5/
      DATA LCOCOR(4) /39/
      DATA LCOCOR(5) /-5/
      DATA LCOCOR(6) /0/
      DATA LCOCOR(7) /-5/
      DATA LCOCOR(8) /-39/
      DATA LCOCOR(9) /-2048/
      DATA LCOCOR(10) /0/
      DATA LCOCOR(11) /-4/
      DATA LCOCOR(12) /39/
      DATA LCOCOR(13) /-4/
      DATA LCOCOR(14) /0/
      DATA LCOCOR(15) /-4/
      DATA LCOCOR(16) /-39/
      DATA LCOCOR(17) /-2048/
      DATA LCOCOR(18) /0/
      DATA LCOCOR(19) /-5/
      DATA LCOCOR(20) /39/
      DATA LCOCOR(21) /6/
      DATA LCOCOR(22) /39/
      DATA LCOCOR(23) /-2048/
      DATA LCOCOR(24) /0/
      DATA LCOCOR(25) /-5/
      DATA LCOCOR(26) /-39/
      DATA LCOCOR(27) /6/
      DATA LCOCOR(28) /-39/
      DATA LCOCOR(29) /-2048/
      DATA LCOCOR(30) /-2048/
C
C
C THE PASS THROUGH PWRX TO BE SIMULATED IN BOTH TESTS.
      DATA IPASS /2/
C
C
      IER1 = 0
      IER2 = 0
C
C        ***** TEST 1 *****
C
C RETRIEVE DIGITIZATION OF CHARACTER +.
      CALL XTCH (IPLUSP,IPASS,NACT1)
C
C COMPARE THE NUMBER OF DIGITIZATION UNITS RETRIEVED TO THE CORRECT
C NUMBER.
      IF (NACT1 .EQ. IPLUSN) GOTO 1
      IER1 = 1
      GOTO 10
    1 CONTINUE
C
C COMPARE EACH OF THE RETRIEVED DIGITIZATION UNITS TO THE CORRECT UNIT.
      DO 2 I=1,NACT1
      IF (LC(I) .EQ. LCPCOR(I)) GOTO 2
      IER1 = 1
      GOTO 10
    2 CONTINUE
C
C        ***** TEST 2 *****
C
   10 CONTINUE
C RETRIEVE DIGITIZATION OF CHARACTER DEFINED BY OCTAL NUMBER 751.
      CALL XTCH (IOCTP,IPASS,NACT2)
C
C COMPARE THE NUMBER OF DIGITIZATION UNITS RETRIEVED TO THE CORRECT
C NUMBER.
      IF (NACT2 .EQ. IOCTN) GOTO 11
      IER2 = 2
      GOTO 30
   11 CONTINUE
C
C COMPARE EACH OF THE RETRIEVED DIGITIZATION UNITS TO THE CORRECT UNIT.
      DO 20 I = 1,NACT2
      IF (LC(I) .EQ. LCOCOR(I)) GOTO 20
      IER2 = 2
      GOTO 30
   20 CONTINUE
C
C
   30 CONTINUE
      IERR = IER1 + IER2
C
C
      RETURN
      END
      SUBROUTINE DCHECK (IERR)
C
C SHORT TEST ROUTINE FOR THE CORRECT ACCESSING OF THE DUPLEX CHARACTER
C SET.
C
C ON ENTRY
C   IERR MAY CONTAIN ANY VALUE.
C ON EXIT
C   IERR = 0 IF 2 SHORT TESTS OF THE DIGITIZATION RETRIEVAL PROCESS
C            WERE SUCCESSFUL
C        = 2 IF THE TEST WAS SUCCESSFUL FOR 6 BIT DIGITIZATION UNITS
C            BUT NOT SUCCESSFUL FOR 12 BIT DIGITIZATION UNITS
C        = 1 IF THE TEST WAS SUCCESSFUL FOR 12 BIT DIGITIZATION UNITS
C            BUT NOT SUCCESSFUL FOR 6 BIT DIGITIZATION UNITS.
C        = 3 IF NEITHER OF THE 2 TESTS WAS SUCCESSFUL.
C CALLS
C   XTCH
C
C
C PWRC1 IS FOR COMMUNICATION WITH SUBROUTINE XTCH.
      COMMON /PWRC1/ LC(150)
C
C THE ARRAY CONTAINING THE CORRECT DIGITIZATION OF CHARACTER +.
      DIMENSION LCPCOR(26)
C THE ARRAY CONTAINING THE CORRECT DIGITIZATION OF THE CHARACTER DEFINED
C BY THE OCTAL NUMBER 751.
      DIMENSION LCOCOR(30)
C
C TEST 1
C   RETRIEVE DIGITIZATION OF CHARACTER + WITH DEFAULT FUNCTION CODES
C   AND COMPARE IT TO THE CORRECT DIGITIZATION.
C   (TEST 6 BIT DIGITIZATION UNITS)
C TEST 2
C   RETRIEVE DIGITIZATION OF CHARACTER DEFINED BY THE OCTAL NUMBER 751
C   AND COMPARE IT WITH THE CORRECT DIGITIZATION.
C   (TEST 12 BIT DIGITIZATION UNITS)
C
C        ** DATA FOR TEST 1 **
C
C THE NUMBER OF THE UNIT IN ARRAY IND POINTING TO THE DIGITIZATION
C OF CHARACTER +.
      DATA IPLUSP /37/
C
C THE CORRECT NUMBER OF DIGITIZATION UNITS FOR CHARACTER +.
      DATA IPLUSN /26/
C
C THE CORRECT DIGITIZATION OF CHARACTER +.
      DATA LCPCOR(1) /-12/
      DATA LCPCOR(2) /13/
      DATA LCPCOR(3) /0/
      DATA LCPCOR(4) /-7/
      DATA LCPCOR(5) /0/
      DATA LCPCOR(6) /5/
      DATA LCPCOR(7) /-2048/
      DATA LCPCOR(8) /0/
      DATA LCPCOR(9) /1/
      DATA LCPCOR(10)/5/
      DATA LCPCOR(11)/1/
      DATA LCPCOR(12)/-7/
      DATA LCPCOR(13)/-2048/
      DATA LCPCOR(14)/0/
      DATA LCPCOR(15)/6/
      DATA LCPCOR(16)/-1/
      DATA LCPCOR(17)/-5/
      DATA LCPCOR(18)/-1/
      DATA LCPCOR(19)/-2048/
      DATA LCPCOR(20)/0/
      DATA LCPCOR(21)/-5/
      DATA LCPCOR(22)/0/
      DATA LCPCOR(23)/6/
      DATA LCPCOR(24)/0/
      DATA LCPCOR(25)/-2048/
      DATA LCPCOR(26)/-2048/
C
C        ** DATA FOR TEST 2 **
C
C THE NUMBER OF THE UNIT IN ARRAY IND POINTING TO THE DIGITIZATION OF
C THE CHARACTER DEFINED BY THE OCTAL NUMBER 751.
      DATA IOCTP /489/
C
C THE CORRECT NUMBER OF DIGITIZATION UNITS OF THE CHARACTER DEFINED BY
C THE OCTAL NUMBER 751.
      DATA IOCTN /30/
C
C THE CORRECT DIGITIZATION OF THE CHARACTER DEFINED BY THE OCTAL
C NUMBER 751.
      DATA LCOCOR(1) /-9/
      DATA LCOCOR(2) /9/
      DATA LCOCOR(3) /-5/
      DATA LCOCOR(4) /39/
      DATA LCOCOR(5) /-5/
      DATA LCOCOR(6) /0/
      DATA LCOCOR(7) /-5/
      DATA LCOCOR(8) /-39/
      DATA LCOCOR(9) /-2048/
      DATA LCOCOR(10) /0/
      DATA LCOCOR(11) /-4/
      DATA LCOCOR(12) /39/
      DATA LCOCOR(13) /-4/
      DATA LCOCOR(14) /0/
      DATA LCOCOR(15) /-4/
      DATA LCOCOR(16) /-39/
      DATA LCOCOR(17) /-2048/
      DATA LCOCOR(18) /0/
      DATA LCOCOR(19) /-5/
      DATA LCOCOR(20) /39/
      DATA LCOCOR(21) /6/
      DATA LCOCOR(22) /39/
      DATA LCOCOR(23) /-2048/
      DATA LCOCOR(24) /0/
      DATA LCOCOR(25) /-5/
      DATA LCOCOR(26) /-39/
      DATA LCOCOR(27) /6/
      DATA LCOCOR(28) /-39/
      DATA LCOCOR(29) /-2048/
      DATA LCOCOR(30) /-2048/
C
C
C THE PASS THROUGH PWRX TO BE SIMULATED IN BOTH TESTS.
      DATA IPASS /2/
C
C
      IER1 = 0
      IER2 = 0
C
C        ***** TEST 1 *****
C
C RETRIEVE DIGITIZATION OF CHARACTER +.
      CALL XTCH (IPLUSP,IPASS,NACT1)
C
C COMPARE THE NUMBER OF DIGITIZATION UNITS RETRIEVED TO THE CORRECT
C NUMBER.
      IF (NACT1 .EQ. IPLUSN) GOTO 1
      IER1 = 1
      GOTO 10
    1 CONTINUE
C
C COMPARE EACH OF THE RETRIEVED DIGITIZATION UNITS TO THE CORRECT UNIT.
      DO 2 I=1,NACT1
      IF (LC(I) .EQ. LCPCOR(I)) GOTO 2
      IER1 = 1
      GOTO 10
    2 CONTINUE
C
C        ***** TEST 2 *****
C
   10 CONTINUE
C RETRIEVE DIGITIZATION OF CHARACTER DEFINED BY OCTAL NUMBER 751.
      CALL XTCH (IOCTP,IPASS,NACT2)
C
C COMPARE THE NUMBER OF DIGITIZATION UNITS RETRIEVED TO THE CORRECT
C NUMBER.
      IF (NACT2 .EQ. IOCTN) GOTO 11
      IER2 = 2
      GOTO 30
   11 CONTINUE
C
C COMPARE EACH OF THE RETRIEVED DIGITIZATION UNITS TO THE CORRECT UNIT.
      DO 20 I = 1,NACT2
      IF (LC(I) .EQ. LCOCOR(I)) GOTO 20
      IER2 = 2
      GOTO 30
   20 CONTINUE
C
C
   30 CONTINUE
      IERR = IER1 + IER2
C
      RETURN
      END
      SUBROUTINE MKMSK
C
C  THIS ROUTINE GENERATES THE MACHINE DEPENDENT DATA VALUES
C  USED BY XTCH.
C
C
      COMMON/PINIT/MASK(4),MASK6(64),MASK12(64),LAST6,LAST12,
     1  IBIT15,MASK14,NUM15U,NBWD
C
C  MASK FOR 15 BIT PARSALS(77777B)
C
      IMSK1 = 32767
C
C
C  FIND THE NUMBER OF BITS PER WORD
C
      NBWD = I1MACH(5)
C
C  COMPUTE THE NUMBER OF 15 BIT PARSALS
C
      NUM15U = NBWD/15
C
C  IPRCT AND IPRCT2 ARE USED TO PREVENT SIGN EXTENSION WHEN DOING LEFT
C  SHIFTS.
C
      ITEMP = ISHIFT(IMSK1,(NBWD-16))
      IPRCT = ITEMP
      IT1 = NUM15U-1
      DO 100 I = 1,IT1
      IPRCT = ISHIFT(IPRCT,-15)
      IPRCT = IOR(ITEMP,IPRCT)
  100 CONTINUE
      IPRCT = IOR(IPRCT,IMSK1)
C
      IPRCT2 = ISHIFT(IPRCT,-14)
C
C  LEFT JUSTIFY
C
      LEFTJS = NBWD-15
      IMSK1 = ISHIFT(IMSK1,LEFTJS)
C
C  GENERATE THE MASKS FOR THE 15 BIT PARSALS
C
C
      DO 10 I = 1 , NUM15U
      MASK(I) = IMSK1
C
C  SHIFT FOR NEXT PARSAL
C
      IMSK1 = ISHIFT(IMSK1,-15)
C
C  PROTECT FROM SIGN EXTENSION(REVELANT ONLY ON FIRST PASS)
C
      IMSK1 = IAND(IMSK1,IPRCT2)
   10 CONTINUE
C
C
C  MASK FOR 6 BIT PARSALS (77B)
C
      IMSK2 = 63
C
C  MASK FOR 12 BIT PARSALS (7777B)
C
      IMSK3 = 4095
C
C  LEFT JUSTIFY
C
      LEFTJS = NBWD-6
      IMSK2 = ISHIFT(IMSK2,LEFTJS)
C
      LEFTJS = NBWD-12
      IMSK3 = ISHIFT(IMSK3,LEFTJS)
C
C  SET UP ALL POSSIBLE 6 AND 12 BIT UNITS
C  NOTE THAT MASKS WILL ALSO BE USED WHEN UNITS CROSS WORD BOUNDRIES
C
C
      DO 20 I = 1 , NBWD
C
C  6 BIT MASKS
C
      MASK6(I) = IMSK2
      IMSK2 = ISHIFT(IMSK2,-1)
C
C PROTECTION FROM SIGN EXTENSION (REVELANT ONLY ON THE FIRST PASS)
C
      IMSK2 = IAND(IMSK2,IPRCT)
C
C  12 BIT MASKS
C
      MASK12(I) = IMSK3
      IMSK3 = ISHIFT(IMSK3,-1)
C
C  PROTECT FROM SIGN EXTENSION (REVELANT ONLY ON THE FIRST PASS)
C
      IMSK3 = IAND(IMSK3,IPRCT)
   20 CONTINUE
C
C
C  MASK FOR 6 BIT RIGHT JUSTIFED UNIT (77B)
C
      LAST6 = 63
C
C  MAST FOR 12 BIT RIGHT JUSTIFED UNIT (7777B)
C
      LAST12 = 4095
C
C  MASK FOR 15-TH BIT FROM THE RIGHT (40000B)
C
      IBIT15 = 16384
C
C  MASK FOR 14 BIT RIGHT JUSTIFED UNIT (37777B)
C
      MASK14 = 16383
      RETURN
      END
      SUBROUTINE SETER(MESSG,NERR,IOPT)
C
C  FORCE LOAD OF BLOCKDATA
C
C     EXTERNAL UERRBD
      CHARACTER*(*) MESSG
      COMMON /UERRF/IERF
C
C  THE UNIT FOR ERROR MESSAGES IS I1MACH(4)
C
      IF (IERF .EQ. 0) THEN
      IERF = I1MACH(4)
      ENDIF
C
      NMESSG = LEN(MESSG)
      IF (NMESSG.GE.1) GO TO 10
C
C  A MESSAGE OF NON-POSITIVE LENGTH IS FATAL.
C
        WRITE(IERF,9000)
 9000   FORMAT(' ERROR    1 IN SETER - MESSAGE LENGTH NOT POSITIVE.')
        GO TO 60
C
   10 CONTINUE
      IF (NERR.NE.0) GO TO 20
C
C  CANNOT TURN THE ERROR STATE OFF USING SETER.
C
        WRITE(IERF,9001)
 9001   FORMAT(' ERROR    2 IN SETER - CANNOT HAVE NERR=0'/
     1         ' THE CURRENT ERROR MESSAGE FOLLOWS'/)
        CALL E9RIN(MESSG,NERR,.TRUE.)
        ITEMP=I8SAV(1,1,.TRUE.)
        GO TO 50
C
C  SET LERROR AND TEST FOR A PREVIOUS UNRECOVERED ERROR.
C
 20   CONTINUE
      IF (I8SAV(1,NERR,.TRUE.).EQ.0) GO TO 30
C
        WRITE(IERF,9002)
 9002   FORMAT(' ERROR    3 IN SETER -',
     1         ' AN UNRECOVERED ERROR FOLLOWED BY ANOTHER ERROR.'//
     2         ' THE PREVIOUS AND CURRENT ERROR MESSAGES FOLLOW.'///)
        CALL EPRIN
        CALL E9RIN(MESSG,NERR,.TRUE.)
        GO TO 50
C
C  SAVE THIS MESSAGE IN CASE IT IS NOT RECOVERED FROM PROPERLY.
C
 30   CALL E9RIN(MESSG,NERR,.TRUE.)
C
      IF (IOPT.EQ.1 .OR. IOPT.EQ.2) GO TO 40
C
C  MUST HAVE IOPT = 1 OR 2.
C
        WRITE(IERF,9003)
 9003   FORMAT(' ERROR    4 IN SETER - BAD VALUE FOR IOPT'//
     1         ' THE CURRENT ERROR MESSAGE FOLLOWS'///)
        GO TO 50
C
C  TEST FOR RECOVERY.
C
 40   CONTINUE
      IF (IOPT.EQ.2) GO TO 50
C
      IF (I8SAV(2,0,.FALSE.).EQ.1) RETURN
C
      CALL EPRIN
      CALL FDUM
      STOP
C
 50   CALL EPRIN
 60   CALL FDUM
      STOP
C
      END
      INTEGER FUNCTION I1MACH(I)
C
C  I/O UNIT NUMBERS.
C
C     I1MACH( 1) = THE STANDARD INPUT UNIT.
C
C     I1MACH( 2) = THE STANDARD OUTPUT UNIT.
C
C     I1MACH( 3) = THE STANDARD PUNCH UNIT.
C
C     I1MACH( 4) = THE STANDARD ERROR MESSAGE UNIT.
C
C  WORDS.
C
C     I1MACH( 5) = THE NUMBER OF BITS PER INTEGER STORAGE UNIT.
C
C     I1MACH( 6) = THE NUMBER OF CHARACTERS PER INTEGER STORAGE UNIT.
C
C  INTEGERS.
C
C     ASSUME INTEGERS ARE REPRESENTED IN THE S-DIGIT, BASE-A FORM
C
C     SIGN ( X(S-1)*A**(S-1) + ... + X(1)*A + X(0) )
C
C     WHERE 0 .LE. X(I) .LT. A FOR I=0,...,S-1.
C
C     I1MACH( 7) = A, THE BASE.
C
C     I1MACH( 8) = S, THE NUMBER OF BASE-A DIGITS.
C
C     I1MACH( 9) = A**S - 1, THE LARGEST MAGNITUDE.
C
C  FLOATING-POINT NUMBERS.
C
C     ASSUME FLOATING-POINT NUMBERS ARE REPRESENTED IN THE T-DIGIT,
C     BASE-B FORM
C
C     SIGN (B**E)*( (X(1)/B) + ... + (X(T)/B**T) )
C
C     WHERE 0 .LE. X(I) .LT. B FOR I=1,...,T,
C     0 .LT. X(1), AND EMIN .LE. E .LE. EMAX.
C
C     I1MACH(10) = B, THE BASE.
C
C  SINGLE-PRECISION
C
C     I1MACH(11) = T, THE NUMBER OF BASE-B DIGITS.
C
C     I1MACH(12) = EMIN, THE SMALLEST EXPONENT E.
C
C     I1MACH(13) = EMAX, THE LARGEST EXPONENT E.
C
C  DOUBLE-PRECISION
C
C     I1MACH(14) = T, THE NUMBER OF BASE-B DIGITS.
C
C     I1MACH(15) = EMIN, THE SMALLEST EXPONENT E.
C
C     I1MACH(16) = EMAX, THE LARGEST EXPONENT E.
C
C  TO ALTER THIS FUNCTION FOR A PARTICULAR ENVIRONMENT,
C  THE DESIRED SET OF DATA STATEMENTS SHOULD BE ACTIVATED BY
C  REMOVING THE C FROM COLUMN 1.  ALSO, THE VALUES OF
C  I1MACH(1) - I1MACH(4) SHOULD BE CHECKED FOR CONSISTENCY
C  WITH THE LOCAL OPERATING SYSTEM.
C
      INTEGER IMACH(16),OUTPUT
C
      EQUIVALENCE (IMACH(4),OUTPUT)
C
C     MACHINE CONSTANTS FOR THE BURROUGHS 1700 SYSTEM.
C
C     DATA IMACH( 1) /    7 /
C     DATA IMACH( 2) /    2 /
C     DATA IMACH( 3) /    2 /
C     DATA IMACH( 4) /    2 /
C     DATA IMACH( 5) /   36 /
C     DATA IMACH( 6) /    4 /
C     DATA IMACH( 7) /    2 /
C     DATA IMACH( 8) /   33 /
C     DATA IMACH( 9) / Z1FFFFFFFF /
C     DATA IMACH(10) /    2 /
C     DATA IMACH(11) /   24 /
C     DATA IMACH(12) / -256 /
C     DATA IMACH(13) /  255 /
C     DATA IMACH(14) /   60 /
C     DATA IMACH(15) / -256 /
C     DATA IMACH(16) /  255 /
C
C     MACHINE CONSTANTS FOR THE BURROUGHS 5700 SYSTEM.
C
C     DATA IMACH( 1) /    5 /
C     DATA IMACH( 2) /    6 /
C     DATA IMACH( 3) /    7 /
C     DATA IMACH( 4) /    6 /
C     DATA IMACH( 5) /   48 /
C     DATA IMACH( 6) /    6 /
C     DATA IMACH( 7) /    2 /
C     DATA IMACH( 8) /   39 /
C     DATA IMACH( 9) / O0007777777777777 /
C     DATA IMACH(10) /    8 /
C     DATA IMACH(11) /   13 /
C     DATA IMACH(12) /  -50 /
C     DATA IMACH(13) /   76 /
C     DATA IMACH(14) /   26 /
C     DATA IMACH(15) /  -50 /
C     DATA IMACH(16) /   76 /
C
C     MACHINE CONSTANTS FOR THE BURROUGHS 6700/7700 SYSTEMS.
C
C     DATA IMACH( 1) /    5 /
C     DATA IMACH( 2) /    6 /
C     DATA IMACH( 3) /    7 /
C     DATA IMACH( 4) /    6 /
C     DATA IMACH( 5) /   48 /
C     DATA IMACH( 6) /    6 /
C     DATA IMACH( 7) /    2 /
C     DATA IMACH( 8) /   39 /
C     DATA IMACH( 9) / O0007777777777777 /
C     DATA IMACH(10) /    8 /
C     DATA IMACH(11) /   13 /
C     DATA IMACH(12) /  -50 /
C     DATA IMACH(13) /   76 /
C     DATA IMACH(14) /   26 /
C     DATA IMACH(15) / -32754 /
C     DATA IMACH(16) /  32780 /
C
C     MACHINE CONSTANTS FOR THE CDC 6000/7000 SERIES.
C
C     DATA IMACH( 1) /    5 /
C     DATA IMACH( 2) /    6 /
C     DATA IMACH( 3) /    7 /
C     DATA IMACH( 4) /    6 /
C     DATA IMACH( 5) /   60 /
C     DATA IMACH( 6) /   10 /
C     DATA IMACH( 7) /    2 /
C     DATA IMACH( 8) /   48 /
C     DATA IMACH( 9) / 00007777777777777777B /
C     DATA IMACH(10) /    2 /
C     DATA IMACH(11) /   48 /
C     DATA IMACH(12) / -974 /
C     DATA IMACH(13) / 1070 /
C     DATA IMACH(14) /   96 /
C     DATA IMACH(15) / -927 /
C     DATA IMACH(16) / 1070 /
C
C     MACHINE CONSTANTS FOR THE CRAY 1
C
C     DATA IMACH( 1) /  100 /
C     DATA IMACH( 2) /  101 /
C     DATA IMACH( 3) /  102 /
C     DATA IMACH( 4) /  101 /
C     DATA IMACH( 5) /   64 /
C     DATA IMACH( 6) /    8 /
C     DATA IMACH( 7) /    2 /
C     DATA IMACH( 8) /   63 /
C     DATA IMACH( 9) / 777777777777777777777B /
C     DATA IMACH(10) /    2 /
C     DATA IMACH(11) /   48 /
C     DATA IMACH(12) / -8192 /
C     DATA IMACH(13) / 8191 /
C     DATA IMACH(14) /   96 /
C     DATA IMACH(15) / -8192 /
C     DATA IMACH(16) / 8191 /
C
C     MACHINE CONSTANTS FOR THE DATA GENERAL ECLIPSE S/200
C
C     DATA IMACH( 1) /   11 /
C     DATA IMACH( 2) /   12 /
C     DATA IMACH( 3) /    8 /
C     DATA IMACH( 4) /   10 /
C     DATA IMACH( 5) /   16 /
C     DATA IMACH( 6) /    2 /
C     DATA IMACH( 7) /    2 /
C     DATA IMACH( 8) /   15 /
C     DATA IMACH( 9) /32767 /
C     DATA IMACH(10) /   16 /
C     DATA IMACH(11) /    6 /
C     DATA IMACH(12) /  -64 /
C     DATA IMACH(13) /   63 /
C     DATA IMACH(14) /   14 /
C     DATA IMACH(15) /  -64 /
C     DATA IMACH(16) /   63 /
C
C     MACHINE CONSTANTS FOR THE HARRIS 220
C
C     DATA IMACH( 1) /    5 /
C     DATA IMACH( 2) /    6 /
C     DATA IMACH( 3) /    0 /
C     DATA IMACH( 4) /    6 /
C     DATA IMACH( 5) /   24 /
C     DATA IMACH( 6) /    3 /
C     DATA IMACH( 7) /    2 /
C     DATA IMACH( 8) /   23 /
C     DATA IMACH( 9) / 8388607 /
C     DATA IMACH(10) /    2 /
C     DATA IMACH(11) /   23 /
C     DATA IMACH(12) / -127 /
C     DATA IMACH(13) /  127 /
C     DATA IMACH(14) /   38 /
C     DATA IMACH(15) / -127 /
C     DATA IMACH(16) /  127 /
C
C     MACHINE CONSTANTS FOR THE HONEYWELL 600/6000 SERIES.
C
C     DATA IMACH( 1) /    5 /
C     DATA IMACH( 2) /    6 /
C     DATA IMACH( 3) /   43 /
C     DATA IMACH( 4) /    6 /
C     DATA IMACH( 5) /   36 /
C     DATA IMACH( 6) /    6 /
C     DATA IMACH( 7) /    2 /
C     DATA IMACH( 8) /   35 /
C     DATA IMACH( 9) / 0377777777777 /
C     DATA IMACH(10) /    2 /
C     DATA IMACH(11) /   27 /
C     DATA IMACH(12) / -127 /
C     DATA IMACH(13) /  127 /
C     DATA IMACH(14) /   63 /
C     DATA IMACH(15) / -127 /
C     DATA IMACH(16) /  127 /
C
C     MACHINE CONSTANTS FOR THE IBM 360/370 SERIES.
C     THE XEROX SIGMA 5/7/9 AND THE SEL SYSTEMS 85/86.
C
C     DATA IMACH( 1) /    5 /
C     DATA IMACH( 2) /    6 /
C     DATA IMACH( 3) /    7 /
C     DATA IMACH( 4) /    6 /
C     DATA IMACH( 5) /   32 /
C     DATA IMACH( 6) /    4 /
C     DATA IMACH( 7) /    2 /
C     DATA IMACH( 8) /   31 /
C     DATA IMACH( 9) / Z7FFFFFFF /
C     DATA IMACH(10) /   16 /
C     DATA IMACH(11) /    6 /
C     DATA IMACH(12) /  -64 /
C     DATA IMACH(13) /   63 /
C     DATA IMACH(14) /   14 /
C     DATA IMACH(15) /  -64 /
C     DATA IMACH(16) /   63 /
C
C     MACHINE CONSTANTS FOR THE PDP-10 (KA PROCESSOR).
C
C     DATA IMACH( 1) /    5 /
C     DATA IMACH( 2) /    6 /
C     DATA IMACH( 3) /    5 /
C     DATA IMACH( 4) /    6 /
C     DATA IMACH( 5) /   36 /
C     DATA IMACH( 6) /    5 /
C     DATA IMACH( 7) /    2 /
C     DATA IMACH( 8) /   35 /
C     DATA IMACH( 9) / '377777777777 /
C     DATA IMACH(10) /    2 /
C     DATA IMACH(11) /   27 /
C     DATA IMACH(12) / -128 /
C     DATA IMACH(13) /  127 /
C     DATA IMACH(14) /   54 /
C     DATA IMACH(15) / -101 /
C     DATA IMACH(16) /  127 /
C
C     MACHINE CONSTANTS FOR THE PDP-10 (KI PROCESSOR).
C
C     DATA IMACH( 1) /    5 /
C     DATA IMACH( 2) /    6 /
C     DATA IMACH( 3) /    5 /
C     DATA IMACH( 4) /    6 /
C     DATA IMACH( 5) /   36 /
C     DATA IMACH( 6) /    5 /
C     DATA IMACH( 7) /    2 /
C     DATA IMACH( 8) /   35 /
C     DATA IMACH( 9) / '377777777777 /
C     DATA IMACH(10) /    2 /
C     DATA IMACH(11) /   27 /
C     DATA IMACH(12) / -128 /
C     DATA IMACH(13) /  127 /
C     DATA IMACH(14) /   62 /
C     DATA IMACH(15) / -128 /
C     DATA IMACH(16) /  127 /
C
C     MACHINE CONSTANTS FOR PDP-11 FORTRAN'S SUPPORTING
C     32-BIT INTEGER ARITHMETIC AND VAX/VMS FORTRAN.
C
C     DATA IMACH( 1) /    5 /
C     DATA IMACH( 2) /    6 /
C     DATA IMACH( 3) /    5 /
C     DATA IMACH( 4) /    6 /
C     DATA IMACH( 5) /   32 /
C     DATA IMACH( 6) /    4 /
C     DATA IMACH( 7) /    2 /
C     DATA IMACH( 8) /   31 /
C     DATA IMACH( 9) / 2147483647 /
C     DATA IMACH(10) /    2 /
C     DATA IMACH(11) /   24 /
C     DATA IMACH(12) / -127 /
C     DATA IMACH(13) /  127 /
C     DATA IMACH(14) /   56 /
C     DATA IMACH(15) / -127 /
C     DATA IMACH(16) /  127 /
C
C     MACHINE CONSTANTS FOR SUN-4 AND DEC RISC FORTRAN.
C
      DATA IMACH( 1) /    5 /
      DATA IMACH( 2) /    6 /
      DATA IMACH( 3) /    5 /
      DATA IMACH( 4) /    0 /
      DATA IMACH( 5) /   32 /
      DATA IMACH( 6) /    4 /
      DATA IMACH( 7) /    2 /
      DATA IMACH( 8) /   31 /
      DATA IMACH( 9) / 2147483647 /
      DATA IMACH(10) /    2 /
      DATA IMACH(11) /   24 /
      DATA IMACH(12) / -127 /
      DATA IMACH(13) /  127 /
      DATA IMACH(14) /   52 /
      DATA IMACH(15) /-1023 /
      DATA IMACH(16) / 1023 /
C
C     MACHINE CONSTANTS FOR PDP-11 FORTRAN'S SUPPORTING
C     16-BIT INTEGER ARITHMETIC.
C
C     DATA IMACH( 1) /    5 /
C     DATA IMACH( 2) /    6 /
C     DATA IMACH( 3) /    5 /
C     DATA IMACH( 4) /    6 /
C     DATA IMACH( 5) /   16 /
C     DATA IMACH( 6) /    2 /
C     DATA IMACH( 7) /    2 /
C     DATA IMACH( 8) /   15 /
C     DATA IMACH( 9) / 32767 /
C     DATA IMACH(10) /    2 /
C     DATA IMACH(11) /   24 /
C     DATA IMACH(12) / -127 /
C     DATA IMACH(13) /  127 /
C     DATA IMACH(14) /   56 /
C     DATA IMACH(15) / -127 /
C     DATA IMACH(16) /  127 /
C
C     MACHINE CONSTANTS FOR THE UNIVAC 1100 SERIES.
C
C     NOTE THAT THE PUNCH UNIT, I1MACH(3), HAS BEEN SET TO 7
C     WHICH IS APPROPRIATE FOR THE UNIVAC-FOR SYSTEM.
C     IF YOU HAVE THE UNIVAC-FTN SYSTEM, SET IT TO 1.
C
C     DATA IMACH( 1) /    5 /
C     DATA IMACH( 2) /    6 /
C     DATA IMACH( 3) /    7 /
C     DATA IMACH( 4) /    6 /
C     DATA IMACH( 5) /   36 /
C     DATA IMACH( 6) /    6 /
C     DATA IMACH( 7) /    2 /
C     DATA IMACH( 8) /   35 /
C     DATA IMACH( 9) / O377777777777 /
C     DATA IMACH(10) /    2 /
C     DATA IMACH(11) /   27 /
C     DATA IMACH(12) / -128 /
C     DATA IMACH(13) /  127 /
C     DATA IMACH(14) /   60 /
C     DATA IMACH(15) /-1024 /
C     DATA IMACH(16) / 1023 /
C
C-----------------------------------------------------------------------
C DELETE NEXT TWO STATEMENTS AFTER SUPPLYING THE PROPER DATA STATEMENTS.
C      DATA IMACH (5) /0/
C      IF (IMACH(5) .EQ. 0) WRITE(6,500)
  500 FORMAT(45H I1MACH - MACHINE DEPENDENT CONSTANTS NOT SET )
C-----------------------------------------------------------------------
      IF (I .LT. 1 .OR. I .GT. 16) GO TO 10
C
      I1MACH=IMACH(I)
      RETURN
C
   10 CALL SETER('ERROR IN I1MACH - I OUT OF BOUNDS',1,2)
C
      STOP
C
      END
      FUNCTION ISHIFT(IWORD,N)
C IF N.GT.0, THEN SHIFT LEFT CIRCULAR
C IF N.LT.0, THEN SHIFT RIGHT ARITHMETIC
C
      DATA MASK/'FFFFFFFF'X/
C
      IF (N.GT.0) THEN
        ISHIFT = IOR(ISHFT(IWORD,N),ISHFT(IWORD,N-32))
C
      ELSE IF (N.EQ.0) THEN
        ISHIFT = IWORD
C
      ELSE
        ISHIFT = ISHFT(IWORD,N)
        IF(IWORD.LT.0) ISHIFT = IOR(ISHIFT,ISHFT(MASK,N+32))
C
      END IF
C
      RETURN
      END
      BLOCKDATA UERRBD
      COMMON /UERRF/IERF
C     DEFAULT ERROR UNIT
      DATA IERF/0/
      END
      SUBROUTINE E9RIN(MESSG,NERR,SAVE)
C
C  THIS ROUTINE STORES THE CURRENT ERROR MESSAGE OR PRINTS THE OLD ONE,
C  IF ANY, DEPENDING ON WHETHER OR NOT SAVE = .TRUE. .
C
      CHARACTER*(*) MESSG
      CHARACTER*113 MESSGP
      LOGICAL SAVE
      COMMON /UERRF/IERF
C
C  MESSGP STORES THE FIRST 113 CHARACTERS OF THE PREVIOUS MESSAGE
C
      SAVE MESSGP,NERRP
C
C  START WITH NO PREVIOUS MESSAGE.
C
      DATA MESSGP/'1'/
      DATA NERRP/0/
C
      IF (.NOT.SAVE) GO TO 20
C
C  SAVE THE MESSAGE.
C
        NERRP=NERR
        MESSGP = MESSG
C
        GO TO 30
C
 20   IF (I8SAV(1,0,.FALSE.).EQ.0) GO TO 30
C
C  PRINT THE MESSAGE.
C
      WRITE(IERF,9000) NERRP,MESSGP
 9000 FORMAT(' ERROR ',I4,' IN ',A113)
C
 30   RETURN
C
      END
      INTEGER FUNCTION I8SAV(ISW,IVALUE,SET)
C
C  IF (ISW = 1) I8SAV RETURNS THE CURRENT ERROR NUMBER AND
C               SETS IT TO IVALUE IF SET = .TRUE. .
C
C  IF (ISW = 2) I8SAV RETURNS THE CURRENT RECOVERY SWITCH AND
C               SETS IT TO IVALUE IF SET = .TRUE. .
C
      LOGICAL SET
C
      SAVE LERROR,LRECOV
C
C  START EXECUTION ERROR FREE AND WITH RECOVERY TURNED OFF.
C
      DATA LERROR/0/ , LRECOV/2/

      IF (ISW .EQ. 1) THEN
        I8SAV = LERROR
        IF (SET) LERROR = IVALUE
      ELSE IF (ISW .EQ. 2) THEN
        I8SAV = LRECOV
        IF (SET) LRECOV = IVALUE
      ENDIF
      RETURN
      END
      SUBROUTINE EPRIN
C
      CHARACTER*1 MESSG
C
      CALL E9RIN(MESSG,1,.FALSE.)
      RETURN
C
      END
      SUBROUTINE FDUM
C
C     DUMMY ROUTINE TO BE LOCALLY IMPLEMENTED
C
      RETURN
      END
