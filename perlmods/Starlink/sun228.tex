\documentclass[twoside,11pt]{article}

% ? Specify used packages
% \usepackage{graphicx}        %  Use this one for final production.
% \usepackage[draft]{graphicx} %  Use this one for drafting.
% ? End of specify used packages

\pagestyle{myheadings}

% -----------------------------------------------------------------------------
% ? Document identification
% Fixed part
\newcommand{\stardoccategory}  {Starlink User Note}
\newcommand{\stardocinitials}  {SUN}
\newcommand{\stardocsource}    {sun\stardocnumber}

% Variable part - replace [xxx] as appropriate.
\newcommand{\stardocnumber}    {228.2}
\newcommand{\stardocauthors}   {T.\ Jenness, F.\ Economou\\
                                Joint Astronomy Centre, Hilo, Hawaii}
\newcommand{\stardocdate}      {15 June 1999}
\newcommand{\stardoctitle}     {STARPERL -- Starlink perl modules}
\newcommand{\stardocversion}   {1.10}
\newcommand{\stardocmanual}    {User's manual}
\newcommand{\stardocabstract}  {The StarPerl package is a selection
of perl modules that provide access to Starlink infrastructure libraries.
Currently, interfaces are provided to the ADAM messaging system and
the Starlink Noticeboard system.
}

% Environment for indenting and using a small font.
\newenvironment{myquote}{\begin{quote}\begin{small}}{\end{small}\end{quote}}

\newcommand{\text}[1]{{\small \tt #1}}

% LaTeX document produced by pod2latex from "Init.pm.pod".
% The followings need be defined in the preamble of this document:
\def\C++{{\rm C\kern-.05em\raise.3ex\hbox{\footnotesize ++}}}
% \def\underscore{\leavevmode\kern.04em\vbox{\hrule width 0.4em height 0.3pt}}
\setlength{\parindent}{0pt}



% ? End of document identification
% -----------------------------------------------------------------------------

% +
%  Name:
%     sun227.tex
%
%  Purpose:
%     Template for Starlink User Note (SUN) documents.
%     Refer to SUN/199
%
%  Authors:
%     AJC: A.J.Chipperfield (Starlink, RAL)
%     BLY: M.J.Bly (Starlink, RAL)
%     PWD: Peter W. Draper (Starlink, Durham University)
%     TIMJ: Tim Jenness (Joint Astronomy Centre)

%  History:
%     17-JAN-1996 (AJC):
%        Original with hypertext macros, based on MDL plain originals.
%     16-JUN-1997 (BLY):
%        Adapted for LaTeX2e.
%        Added picture commands.
%     13-AUG-1998 (PWD):
%        Converted for use with LaTeX2HTML version 98.2 and
%        Star2HTML version 1.3.
%     16-Feb-1999 (TIMJ)
%        Convert template to SUN227 - STARPERL.
%     {Add further history here}
%
% -

\newcommand{\stardocname}{\stardocinitials /\stardocnumber}
\markboth{\stardocname}{\stardocname}
\setlength{\textwidth}{160mm}
\setlength{\textheight}{230mm}
\setlength{\topmargin}{-2mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\setlength{\unitlength}{1mm}

% -----------------------------------------------------------------------------
%  Hypertext definitions.
%  ======================
%  These are used by the LaTeX2HTML translator in conjunction with star2html.

%  Comment.sty: version 2.0, 19 June 1992
%  Selectively in/exclude pieces of text.
%
%  Author
%    Victor Eijkhout                                      <eijkhout@cs.utk.edu>
%    Department of Computer Science
%    University Tennessee at Knoxville
%    104 Ayres Hall
%    Knoxville, TN 37996
%    USA

%  Do not remove the %begin{latexonly} and %end{latexonly} lines (used by 
%  LaTeX2HTML to signify text it shouldn't process).
%begin{latexonly}
\makeatletter
\def\makeinnocent#1{\catcode`#1=12 }
\def\csarg#1#2{\expandafter#1\csname#2\endcsname}

\def\ThrowAwayComment#1{\begingroup
    \def\CurrentComment{#1}%
    \let\do\makeinnocent \dospecials
    \makeinnocent\^^L% and whatever other special cases
    \endlinechar`\^^M \catcode`\^^M=12 \xComment}
{\catcode`\^^M=12 \endlinechar=-1 %
 \gdef\xComment#1^^M{\def\test{#1}
      \csarg\ifx{PlainEnd\CurrentComment Test}\test
          \let\html@next\endgroup
      \else \csarg\ifx{LaLaEnd\CurrentComment Test}\test
            \edef\html@next{\endgroup\noexpand\end{\CurrentComment}}
      \else \let\html@next\xComment
      \fi \fi \html@next}
}
\makeatother

\def\includecomment
 #1{\expandafter\def\csname#1\endcsname{}%
    \expandafter\def\csname end#1\endcsname{}}
\def\excludecomment
 #1{\expandafter\def\csname#1\endcsname{\ThrowAwayComment{#1}}%
    {\escapechar=-1\relax
     \csarg\xdef{PlainEnd#1Test}{\string\\end#1}%
     \csarg\xdef{LaLaEnd#1Test}{\string\\end\string\{#1\string\}}%
    }}

%  Define environments that ignore their contents.
\excludecomment{comment}
\excludecomment{rawhtml}
\excludecomment{htmlonly}

%  Hypertext commands etc. This is a condensed version of the html.sty
%  file supplied with LaTeX2HTML by: Nikos Drakos <nikos@cbl.leeds.ac.uk> &
%  Jelle van Zeijl <jvzeijl@isou17.estec.esa.nl>. The LaTeX2HTML documentation
%  should be consulted about all commands (and the environments defined above)
%  except \xref and \xlabel which are Starlink specific.

\newcommand{\htmladdnormallinkfoot}[2]{#1\footnote{#2}}
\newcommand{\htmladdnormallink}[2]{#1}
\newcommand{\htmladdimg}[1]{}
\newcommand{\hyperref}[4]{#2\ref{#4}#3}
\newcommand{\htmlref}[2]{#1}
\newcommand{\htmlimage}[1]{}
\newcommand{\htmladdtonavigation}[1]{}

\newenvironment{latexonly}{}{}
\newcommand{\latex}[1]{#1}
\newcommand{\html}[1]{}
\newcommand{\latexhtml}[2]{#1}
\newcommand{\HTMLcode}[2][]{}

%  Starlink cross-references and labels.
\newcommand{\xref}[3]{#1}
\newcommand{\xlabel}[1]{}

%  LaTeX2HTML symbol.
\newcommand{\latextohtml}{\LaTeX2\texttt{HTML}}

%  Define command to re-centre underscore for Latex and leave as normal
%  for HTML (severe problems with \_ in tabbing environments and \_\_
%  generally otherwise).
\renewcommand{\_}{\texttt{\symbol{95}}}

% -----------------------------------------------------------------------------
%  Debugging.
%  =========
%  Remove % on the following to debug links in the HTML version using Latex.

% \newcommand{\hotlink}[2]{\fbox{\begin{tabular}[t]{@{}c@{}}#1\\\hline{\footnotesize #2}\end{tabular}}}
% \renewcommand{\htmladdnormallinkfoot}[2]{\hotlink{#1}{#2}}
% \renewcommand{\htmladdnormallink}[2]{\hotlink{#1}{#2}}
% \renewcommand{\hyperref}[4]{\hotlink{#1}{\S\ref{#4}}}
% \renewcommand{\htmlref}[2]{\hotlink{#1}{\S\ref{#2}}}
% \renewcommand{\xref}[3]{\hotlink{#1}{#2 -- #3}}
%end{latexonly}
% -----------------------------------------------------------------------------
% ? Document specific \newcommand or \newenvironment commands.
% ? End of document specific commands
% -----------------------------------------------------------------------------
%  Title Page.
%  ===========
\renewcommand{\thepage}{\roman{page}}
\begin{document}
\thispagestyle{empty}

%  Latex document header.
%  ======================
\begin{latexonly}
   CCLRC / {\textsc Rutherford Appleton Laboratory} \hfill {\textbf \stardocname}\\
   {\large Particle Physics \& Astronomy Research Council}\\
   {\large Starlink Project\\}
   {\large \stardoccategory\ \stardocnumber}
   \begin{flushright}
   \stardocauthors\\
   \stardocdate
   \end{flushright}
   \vspace{-4mm}
   \rule{\textwidth}{0.5mm}
   \vspace{5mm}
   \begin{center}
   {\Huge\textbf  \stardoctitle \\ [2.5ex]}
   {\LARGE\textbf \stardocversion \\ [4ex]}
   {\Huge\textbf  \stardocmanual}
   \end{center}
   \vspace{5mm}

% ? Add picture here if required for the LaTeX version.
%   e.g. \includegraphics[scale=0.3]{filename.ps}
% ? End of picture

% ? Heading for abstract if used.
   \vspace{10mm}
   \begin{center}
      {\Large\textbf Abstract}
   \end{center}
% ? End of heading for abstract.
\end{latexonly}

%  HTML documentation header.
%  ==========================
\begin{htmlonly}
   \xlabel{}
   \begin{rawhtml} <H1 ALIGN=CENTER> \end{rawhtml}
      \stardoctitle\\
      \stardocversion\\
      \stardocmanual
   \begin{rawhtml} </H1> <HR> \end{rawhtml}

% ? Add picture here if required for the hypertext version.
%   e.g. \includegraphics[scale=0.7]{filename.ps}
% ? End of picture

   \begin{rawhtml} <P> <I> \end{rawhtml}
   \stardoccategory\ \stardocnumber \\
   \stardocauthors \\
   \stardocdate
   \begin{rawhtml} </I> </P> <H3> \end{rawhtml}
      \htmladdnormallink{CCLRC}{http://www.cclrc.ac.uk} /
      \htmladdnormallink{Rutherford Appleton Laboratory}
                        {http://www.cclrc.ac.uk/ral} \\
      \htmladdnormallink{Particle Physics \& Astronomy Research Council}
                        {http://www.pparc.ac.uk} \\
   \begin{rawhtml} </H3> <H2> \end{rawhtml}
      \htmladdnormallink{Starlink Project}{http://star-www.rl.ac.uk/}
   \begin{rawhtml} </H2> \end{rawhtml}
   \htmladdnormallink{\htmladdimg{source.gif} Retrieve hardcopy}
      {http://star-www.rl.ac.uk/cgi-bin/hcserver?\stardocsource}\\

%  HTML document table of contents. 
%  ================================
%  Add table of contents header and a navigation button to return to this 
%  point in the document (this should always go before the abstract \section). 
  \label{stardoccontents}
  \begin{rawhtml} 
    <HR>
    <H2>Contents</H2>
  \end{rawhtml}
  \htmladdtonavigation{\htmlref{\htmladdimg{contents_motif.gif}}
        {stardoccontents}}

% ? New section for abstract if used.
  \section{\xlabel{abstract}Abstract}
% ? End of new section for abstract
\end{htmlonly}

% -----------------------------------------------------------------------------
% ? Document Abstract. (if used)
%  ==================
\stardocabstract
% ? End of document abstract
% -----------------------------------------------------------------------------
% ? Latex document Table of Contents (if used).
%  ===========================================
  \newpage
  \begin{latexonly}
    \setlength{\parskip}{0mm}
    \tableofcontents
    \setlength{\parskip}{\medskipamount}
    \markboth{\stardocname}{\stardocname}
  \end{latexonly}
% ? End of Latex document table of contents
% -----------------------------------------------------------------------------
\cleardoublepage
\renewcommand{\thepage}{\arabic{page}}
\setcounter{page}{1}

% ? Main text

\section{Introduction}

The Starperl package provides modules for perl/Starlink interoperability. The
purpose of this package is to allow access to the Starlink infrastructure
libraries from the \xref{perl}{sun193}{} programming language. Available
modules in this release are the ADAM module (for interface with the ADAM
messaging system), the EMS module and an interface to the Noticeboard system.

The mechanism for reading, writing and manipulating Starlink data format files
(NDF and HDS) from perl is documented in \xref{SUN/222}{sun222}{}.

\section{The usefulness of this package\label{stats}}

The ADAM  modules are useful in situations where there is a need for
efficient scripting without recourse to compiled code. An example of
such a script is to process a large number of files.

Suppose, for example that you wish to perform an operation (say calculation of
the standard deviation) on a thousand data frames using the
\xref{KAPPA}{sun95}{} \xref{\texttt{stats}}{sun95}{STATS} command. A unix
c-shell script to perform this task would have a significant overhead, as
every time the \texttt{stats} command is issued, the \xref{KAPPA}{sun95}{}
monolith has to be started up and run down. On the other hand a perl script
using the Starlink modules needs to run up the monolith only once, and while
it is resident in memory fire off messages requesting it to perform the
\xref{\texttt{stats}}{sun95}{STATS} operation.

Another use for these modules is in situations where accurate status
information needs to be propagated correctly to the calling
programme. An example of this is a data reduction pipeline in which
one wishes to not only detect the success or failure of a task, but
also particular status codes (such as whether a fitting routine failed
due to anomalies in the data or simply lack of disk space).

Additionally, it is sometimes convenient to use shared memory to pass
information between processes on the same machine. The NBS interface
provides a simple way of doing this from perl (even allowing the use
of tied hashes).

\section{The Starlink Perl modules}

All the modules from this distribution are placed in the \texttt{Starlink::}
hierarchy so that Starlink perl functionality does not clash with existing
modules.  The individual modules are discussed in the following sections.

\section{Using these modules}

The modules described in this document are distributed as standard
perl dynamic modules. Like all such modules, they can be included by
using the \texttt{use} function in perl at the start of your program:

\begin{myquote}
\begin{verbatim}
#!/star/Perl/bin/perl

use Starlink::modulename;
\end{verbatim}
\end{myquote}

See the perl \texttt{perlmods} man page for more information on using modules.


\section{EMS interface}

An interface to the Starlink EMS C library (\xref{SSN/4}{ssn4}{}) is
provided by the \texttt{Starlink::EMS} module. All routines described in
that document are available as well as internal routine for converting a
status code directly to the error mesage components (ems1\_get\_facility\_error).

The EMS functions can be imported using the '\texttt{ems}' tag:

\begin{myquote}
\begin{verbatim}
use Starlink::EMS qw/ :ems /;
\end{verbatim}
\end{myquote}

The following routines are available:

\texttt{ems\_annul(), ems\_begin(), ems\_eload(), ems\_end(),
ems\_errno(), ems\_facer(), ems\_fmtc(), ems\_fmtd(),
ems\_fmti(), ems\_fmtl(), ems\_fmtr() ems\_level(), ems\_mark(),
ems\_mload(), ems\_renew(), ems\_rep(), ems\_rlse(), ems\_setc(),
ems\_setd(), ems\_seti(), ems\_setl(), ems\_setr(), ems\_stat(),
ems\_syser()}.

One difference between the perl implementation and the C/Fortran version
described in \xref{SSN/4}{ssn4}{} concerns return values. Routines with
arguments that contain pure return values (as opposed to
modifications of an existing variable) return the values as
a perl array or scalar. The routines are:

\begin{myquote}
\begin{verbatim}
($par, $str, $status) = ems_load();
$level = ems_level();
$string = ems_mload($par, $str, $status);
\end{verbatim}
\end{myquote}

The \texttt{ems1\_get\_facility\_error()} routine is not documented in
\xref{SSN/4}{ssn4}{} but can be used to convert an error status to the
corresponding error code and text. This is similar to the
\texttt{ems\_facer()} routine (also available) but gives more control over the
use of this information and does not go via a token.  This command is
available in two forms. One form is identical to the C implementation, the
other provides the values as a perl array:

\begin{myquote}
\begin{verbatim}
ems1_get_facility_error($status, $facility, $ident, $text);
($facility, $ident, $text) = get_facility_error($status);
\end{verbatim}
\end{myquote}

When passed a status error code, this routine returns the facility
name, error identifier and error message. It is used by the perl/ADAM
module to decode error status codes returned by ADAM monoliths. 

Generic status values can be imported with the '\texttt{sai}' tag:

\begin{myquote}
\begin{verbatim}
use Starlink::EMS qw( :sai );

$ok = SAI__OK;
$warn = SAI__WARN;
$err  = SAI__ERROR;
\end{verbatim}
\end{myquote}
% $

An interface to MERS (\xref{SUN/104}{sun104}{}) is provided by the 
\xref{NDFPERL}{sun222}{} package (\xref{SUN/222}{sun222}{}).

\section{ADAM interface}

This package provides modules that allow perl to send and receive ADAM
messages. This allows a perl program to control ADAM monoliths without having
to launch a new process each time a data reduction task is required (as found
in \xref{shell scripts}{sc4}{} or using the \texttt{system} call from perl).


\subsection{A simple example}

Here is the code for the example discussed in section \ref{stats}. We have
written this script to find the standard deviation of all files in directory
matching the \texttt{obs*.sdf} pattern (such as \texttt{obs1.sdf},
\texttt{obs2.sdf}, etc).

This is what needs to happen in such as script

\begin{itemize} 

\item The Starlink modules are included

\item The ADAM messaging is started and the KAPPA monolith is loaded

\item Stuff happens

\end{itemize}

And here is what it really looks like:

\begin{myquote}
\begin{verbatim}
#!/star/Perl/bin/perl

# Include the modules}
use Starlink::AMS::Init;
use Starlink::AMS::Task;

# Start the messaging system
$ams = new Starlink::AMS::Init(1);

# Set timeout to be 30 seconds
$ams->timeout(30);

# Turn off all information messages (eg the output of stats)
# keeping error messages
$ams->messages(0);

# Now launch kappa (as an A-task) and store the object.
# The first argument uses '$$' (the process id) so that this
# script can be run without the possibility of clashing with another
# script using kappa on the same machine.
$kappa = new Starlink::AMS::Task("kappa_mon_$$", "$ENV{KAPPA_DIR}/kappa_mon");

# Now wait for kappa to load
$kappa->contactw || die "Error launching kappa - timeout";

# Now loop over the required files

foreach my $file (<obs*.sdf>) {

  # Remove the trailing sdf from the filename for ADAM tasks
  $file =~ s/\.sdf$//;

  # Run kappa stats
  $status = $kappa->obeyw("stats","ndf=$file");

  # Return status should be DTASK__ACTCOMPLETE
  die "error running stats" if $status != &Starlink::ADAM::DTASK__ACTCOMPLETE;

  # Retrieve the standard deviation and print it out
  ($status, $stdev) = $kappa->get("stats","sigma");

  die "Error retrieving statistics for file $file"
    if $status != &Starlink::ADAM::SAI__OK;

  print "$file : $stdev\n";

}

# Messaging system and monolith are shutdown automatically.

\end{verbatim}
\end{myquote}

\subsection{Component modules}

The perl-ADAM interface is made of four modules:

\begin{description}
\item[Starlink::ADAM] 

This is the low-level interface to libams. It should not be used directly
unless you are familiar with the AMS library.\footnote{In future releases this 
module might be renamed to Starlink::AMS::AMSLib. If this happens a stub
interface to Starlink::ADAM will be provided.} This module does provide
access to constants such as SAI\_\_OK and DTASK\_\_ACTCOMPLETE.

\item[Starlink::AMS::Core]

This is the lowest level task interface for controlling ADAM tasks. It should
not be used directly.

\item[Starlink::AMS::Init]

This is a high level object-oriented interface to the messaging layer. It is
used to turn on ADAM messaging, control timeouts and control the printing
of information and error messages.

\item[Starlink::AMS::Task]

This is a high-level object-oriented interface to ADAM tasks and provides
means for launching monoliths and sending CONTROL, OBEY, GET and SET
messages. An instance of this object is created for each monolith.

\end{description}

Only the high-level interface will  be discussed in this document.
The methods are described in the appendix.

\subsubsection{Starlink::AMS::Init}


This class is responsible for starting the messaging layer (unlike
\xref{STARTCL}{sun186}{} the messaging system is not initialised as soon as
the code is loaded) and controlling the user-interface to the messaging system
(such as timeouts and where the replies from the monolith are sent).

The messaging is initialised by creating a new instance of 
a Starlink::AMS::Init object. All further attempts to create a new
instance of this object will result in the \emph{same} object being
returned (i.e.\ only one instance of this object will actually exist).

\begin{myquote}
\begin{verbatim}
use Starlink::AMS::Init;

$ams = new Starlink::AMS::Init(1);  # Start messaging

$ams->timeout(600); # Set timeout to 10 minutes
\end{verbatim}
\end{myquote}

\subsubsection{Starlink::AMS::Task}

This class is responsible for launching and communicating with ADAM
monoliths. The monoliths can be launched as either A-tasks (where the
parameters are reset after each message and values stored in a
file in the ADAM\_USER directory) or as I-tasks (where the state
of the parameters is retained in the monolith). The default is to launch
monoliths as A-tasks since this replicates the behaviour seen from 
\xref{ICL}{sg5}{} and the Unix shell.

Example usage is:
\begin{myquote}
\begin{verbatim}
$kappa = new Starlink::AMS::Task("name","monolith_image");
$status = $kappa->obeyw("task", "params");
$status = $kappa->set("task","param","value");
($status, $value) = $kappa->get("task","param");
$dir = $kappa->control("default","dir");
$kappa->control("par_reset");
\end{verbatim}
\end{myquote}



\subsection{Constants}

Compiler constants are made available via the Starlink::ADAM module.
The available constants are: 

\begin{myquote}
SAI\_\_OK, SAI\_\_WARN, SAI\_\_ERROR\footnote{The 
SAI\_\_ constants are also available from the NDFPERL package and from the
Starlink::EMS module},

DTASK\_\_ACTSTART, DTASK\_\_ACTCOMPLETE, 

MESSYS\_\_INFINITE, MESSYS\_\_PARAMREQ, MESSYS\_\_PARAMREP, MESSYS\_\_INFORM,
MESSYS\_\_SYNC, MESSYS\_\_SYNCREP, MESSYS\_\_TRIGGER, MESSYS\_\_MESSAGE,

MSG\_VAL\_LEN, MSG\_NAME\_LEN, 

OBEY, GET, SET, CANCEL, CONTROL.
\end{myquote}

These constants are not exported by the module (the Autoloader module is used) 
and must be fully-qualified, eg:

\begin{myquote}
\begin{verbatim}
$good_status = &Starlink::ADAM::SAI__OK;
$complete    = &Starlink::ADAM::DTASK__ACTCOMPLETE;
\end{verbatim}
\end{myquote}

Note the use of the ampersand to indicate that this is actually an
autoloaded function and not a variable or perl constant.

\subsection{Limitations and bugs}

Currently the perl/ADAM interface does not make use of an event loop.
This means that, for example, a GET, SET, OBEYW or CONTROL message will
wait (block) for the monolith to respond before control is returned
to the perl program. A non-blocking OBEY is not yet available.

There seems to be a problem when removing monoliths from the message
system. When a monolith is killed it should send a message to
all processes that have previously talked to it via the messaging
system so that the communications are shut down cleanly. In the perl
implementation a segmentation fault occurs when attempting to talk
to a monolith that has been contacted before, but has since died.
This may be related to the fact that the perl interface is not
listening to messages at all times (no event loop). Currently, the
only solution is to create a new perl Task object with a different
name in the message system.

\section{Notice Board interface}

The Starlink::NBS module provides an interface to the Starlink
Noticeboard system (\xref{SUN/77}{sun77}{}). Additionally, it is possible
to tie the noticeboard to a perl variable allowing the notice board
to be manipulated using normal perl commands.

The noticeboard (NB) can be accessed using:

\begin{myquote}
\begin{verbatim}
use Starlink::NBS;

$nbs = new Starlink::NBS($nbsname);
\end{verbatim}
\end{myquote}

Once a top-level object exists, the find() method can be used to 
descend the hierarchy returning new Starlink::NBS objects each time.
This means that a Starlink::NBS object can be associated with a structure
in the NB or a primitive (i.e.\ an integer, or character string).

\begin{myquote}
\begin{verbatim}
$level1 = $nbs->find(".struct1.component");
($status, @values) = $level1->get;
\end{verbatim}
\end{myquote}

In general, it is much easier (and more obvious) to tie the NB
to a perl hash and then manipulate it as normal:

\begin{myquote}
\begin{verbatim}
use Data::Dumper;

tie %nb, ref($nbs), $nbs;
@values = $nb{struct1}{component};
print Dumper(\%nb); # list the Notice board
\end{verbatim}
\end{myquote}

More information can be found in the Starlink::NBS man page
(\texttt{perldoc Starlink::NBS} and in the appendix of this document).

\appendix

\section{Changes}

\subsection{New in version 1.10}

\begin{itemize}
\item Include Starlink::NBS module.
\item Add interface to all documented routines in the EMS library.
\item Fix bug in Starlink::AMS::Init that made it impossible to redirect
standard error to a different file handle.
\item Starlink::AMS::Core now uses Proc::Simple version 1.13
\end{itemize}


\section{ADAM interface specification}

This section describes the methods available from the Starlink::AMS::Init
and Starlink::AMS::Task modules.

\subsection{Starlink::AMS::Init}

The following methods are provided:

\begin{itemize}

\item[new()]%
\index{new@new}%

Create a new instance of Starlink::AMS::Init.
If a true argument is supplied the messaging system is also
initialised via the {\em init()\/} method.

\begin{myquote}
\begin{verbatim}
$ams = new Starlink::AMS::Init(1);  # Start messaging
$ams = new Starlink::AMS::Init(0);  # Delay messaging start
\end{verbatim}
\end{myquote}


\item[messages]%
\index{messages@messages}%
\hfill\\
Method to set whether standard messages returned from monoliths
are printed or not. If set to true the messages are printed
else they are ignored.

\begin{myquote}
\begin{verbatim}
$current = $ams->messages;
$ams->messages(0);
\end{verbatim}
\end{myquote}

Default is to print all messages.

\item[errors]%
\index{errors@errors}%
\hfill\\
Method to set whether error messages returned from monoliths
are printed or not. If set to true the errors are printed
else they are ignored.
\begin{myquote}
\begin{verbatim}
$current = $ams->errors;
$ams->errors(0);
\end{verbatim}
\end{myquote}

Default is to print all messages.

\item[timeout]%
\index{timeout@timeout}%
\hfill\\
Set or retrieve the timeout (in seconds) for some of the ADAM messages.
Default is 30 seconds.
\begin{myquote}
\begin{verbatim}
$ams->timeout(10);
$current = $ams->timeout;
\end{verbatim}
\end{myquote}

\item[stderr]%
\index{stderr@stderr}%
\hfill\\
Set and retrieve the current filehandle to be used for printing
error messages. Default is to use STDERR.

\item[stderr]%
\index{stderr@stderr}%
\hfill\\
Set and retrieve the current filehandle to be used for printing
normal ADAM messages. Default is to use STDOUT.

\item[paramrep]%
\index{paramrep@paramrep}%
\hfill\\
Set and retrieve the code reference that will be executed if
the parameter system needs to ask for a parameter.
Default behaviour is to call a routine that simply prompts
the user for the required value. The supplied subroutine
should accept three arguments (the parameter name, prompt string and
default value) and should return the required value.
\begin{myquote}
\begin{verbatim}
$self->paramrep(\&mysub);
\end{verbatim}
\end{myquote}

A simple check is made to make sure that the supplied argument
is a code reference.

Warning: It is possible to get into an infinite loop if you try
to continually return an unacceptable answer.

\item[init]%
\index{init@init}%
\hfill\\
Initialises the ADAM messaging system. This routine should always be
called before attempting to control I-tasks.

A relay task is spawned in order to test that the messaging system
is functioning correctly. The relay itself is not necessary for the
non-event loop implementation. If this command hangs then it is
likely that the messaging system is not running correctly (eg
because the system was shutdown uncleanly --- try removing named pipes
from the $\tilde{\hspace{0.4em}}$/adam directory).

Starlink Status is returned.

\item[shutdown]%
\index{shutdown@shutdown}%
\hfill\\
This method forces the Adam messaging system to be shutdown.
(It runs the adamtask\_exit routine in Starlink::AMS::Core).

Returns the status.

\end{itemize}

The messaging interface is automatically shutdown when the perl process is
exited. 

\subsection{Starlink::AMS::Task}

The methods provided by this class are:

\begin{itemize}

\item[new()]%
\index{new()@new()}%
\hfill\\
Create a new instance of a Starlink::AMS::Task object.
\begin{myquote}
\begin{verbatim}
$obj = new Starlink::AMS::Task;
$obj = new Starlink::AMS::Task("name_in_message_system","monolith");
\end{verbatim}
\end{myquote}

If supplied with arguments (matching those expected by {\em load()\/} ) the
specified task will be loaded upon creating the object. If the {\em load()\/}
fails then undef is returned (which will not be an object reference).

\item[name]%
\index{name@name}%
\hfill\\
The name used by the messaging system to contact the monolith.
Can be used to set or retrieve the value of name (do not set
this value from outside unless you know that a path to the 
new name exists in the messaging system).
\begin{myquote}
\begin{verbatim}
$name = $obj->name;
$name = $obj->name("name")
\end{verbatim}
\end{myquote}

\item[pid]%
\index{pid@pid}%

Returns the process object (derived from a Proc::Simple object)
of the monolith if the monolith was started by this object.
This can be used to query the process ID and to check that
the process associated with the monolith still exists.
\begin{myquote}
\begin{verbatim}
$proc = $obj->pid;
\end{verbatim}
\end{myquote}

\item[tasktype]%
\index{tasktype@tasktype}%
\hfill\\
Return or set the type of task associated with the object.
Should be either 'A' or 'I'.
\begin{myquote}
\begin{verbatim}
$task->tasktype('A');
\end{verbatim}
\end{myquote}

\item[monolith]%
\index{monolith@monolith}%
\hfill\\
Returns or sets the name of the monolith (not including path).
This is obtained by looking at the second argument to the
load method and is required for A-tasks when performing a parameter
get.

\item[adamdir]%
\index{adamdir@adamdir}%
\hfill\\
Retrieve the current value of \$ADAM\_{}USER. If not defined the
value of \$ADAM\_{}USER is stored --- this method is used to store the
value of \$ADAM\_{}USER at load time so that the location of any
adam parameter file can be found (for A-tasks).

\item[DESTROY]%
\index{DESTROY@DESTROY}%
\hfill\\
Destructor for this object. When the last reference to this
object is removed the destructor is executed automatically.
In this case the monolith attached to object is killed 
unless it is already {\em dead\/}(!) or it has been forgotten
via the {\em forget()\/} method.

\item[load]%
\index{load@load}%
\hfill\\
Load a monolith and set up the name in the messaging system.
This task is called by the 'new' method.
\begin{myquote}
\begin{verbatim}
$status = $obj->load("name","monolith_binary",{ TASKTYPE => 'A' });
\end{verbatim}
\end{myquote}

If the second argument is omitted it is assumed that the binary
is already running and can be called by "name".   

The last argument, if needed, is a reference to a hash containing
the load options. 

Options currently supported are:
\begin{myquote}
\begin{verbatim}
TASKTYPE => 'A' for A-task, 'I' for I-task.
MONOLITH => monolith name to be used for A-task parameter retrieval
\end{verbatim}
\end{myquote}

Default is to launch an A-task. Default task type when no monolith
or options are specified is 'I'.

The MONOLITH option can be used to configure A-tasks such that 
they can retrieve parameters from monoliths that were not started by this 
object. (It is identical to creating the object and then setting the
monolith name via the {\em monolith()\/} method)

If a path to a binary with name "name" already exists then the monolith
is not loaded.

\item[obeyw]%
\index{obeyw@obeyw}%
\hfill\\
Send an obey to a task and wait for a completion message
\begin{myquote}
\begin{verbatim}
$status = $obj->obeyw("action","params");
\end{verbatim}
\end{myquote}

\item[get]%
\index{get@get}%

Obtain the value of a parameter from a task. 
When called from an array context the status and values are returned
(multiple values are returned in an array). When called from a scalar
context the values are returned as a single string joined by commas.

\begin{myquote}
\begin{verbatim}
($status, @values) = $obj->get("task","param");
\end{verbatim}
\end{myquote}
or
\begin{myquote}
\begin{verbatim}
$value = $obj->get("task","param");
\end{verbatim}
\end{myquote}

If the monolith has been started as an A-task the adam messaging
system can not be used to retrieve the parameter value. Instead,
the par\_{}get routine from the perl NDF module is invoked.

\item[set]%
\index{set@set}%

Set the value of a parameter in an I-task.
\begin{myquote}
\begin{verbatim}
$status = $obj->set("action","param","value");
\end{verbatim}
\end{myquote}

This routine has no effect in A-tasks.

\item[control]%
\index{control@control}%
\hfill\\
Send control messages to a monolith.
\begin{myquote}
\begin{verbatim}
$obj->control("par_reset");
($value, $status)  = $obj->control("default","dir");
\end{verbatim}
\end{myquote}

\item[forget]%
\index{forget@forget}%
\hfill\\
Remove the monolith name from the list of known monoliths.
This method prevents the monolith from being killed when adam
exits or when the object is destroyed.

This routine has no input arguments. 

\item[contact]%
\index{contact@contact}%
\hfill\\
This method can be used to determine whether the object can
contact a monolith. Returns a 1 if we can contact a monolith and
a zero if we cant.

\item[contactw]%
\index{contactw@contactw}%
\hfill\\
This method will not return unless the monolith can be contacted.
It only returns with a timeout. Returns a '1' if we contacted okay
and a '0' if we timed out. It will timeout if it takes longer than
specified in Starlink::AMS::Init-$>$timeout.

\end{itemize}

\section{Starlink::NBS interface specification}

\subsection{Methods}

\subsubsection*{Constructors}%
\index{Constructors}

\begin{description}

\item[new]%
\index{new@new}%

Create a new instance of a Starlink::NBS object.
Only used directly to access the top level of the noticeboard
\begin{verbatim}
   $nbs_id  = new Starlink::NBS("nbsname");
\end{verbatim}

The {\em loadnbs()\/} method is invoked with the supplied argument.

\end{description}

\subsubsection*{Accessor Methods}%
\index{Accessor Methods}

These methods are for accessing the "instance" data.
With arguments they set the value, without arguments they
retrieve the current value.

\begin{description}

\item[path]%
\index{path@path}%
\hfill\\
Full path (name) to the item associated with this object
including the name of the noticeboard.

\item[id]%
\index{id@id}%

ID of the shared memory area.

\item[pos]%
\index{pos@pos}%

Position in structure.

\item[rootid]%
\index{rootid@rootid}%
\hfill\\
ID of the actual noticeboard.

\item[top]%
\index{top@top}%

True if this is a top-level object. False otherwise.

\item[status]%
\index{status@status}%
\hfill\\
Contains the current status associated with the object. Status from
each method call is placed in here (and usually returned with each
command). Methods will not do anything if the stored status is not
good. This behaves as an inherited status without having to pass
the status into the methods explicitly.

\item[debug]%
\index{debug@debug}%
\hfill\\
Turns debugging on or off. Default is off.

\item[nchilds]%
\index{nchilds@nchilds}%
\hfill\\
Returns the number of children associated with the current object.
Can not be set externally.

\end{description}

\subsubsection*{General Methods}%
\index{General Methods}

\begin{description}

\item[isokay]%
\index{isokay@isokay}%
\hfill\\
Method that simply returns whether status is acceptable (SAI\_{}\_{}OK)
or not. If everything is okay return 1, else return 0.

\item[loadnbs]%
\index{loadnbs@loadnbs}%
\hfill\\
Method to load a top level noticeboard

\item[type]%
\index{type@type}%
\hfill\\
Find the storage type of an object
\begin{verbatim}
 Arguments: None (but uses the current status of the object)
 Returns:  ($type, $status)
\end{verbatim}

\item[primitive]%
\index{primitive@primitive}%
\hfill\\
Determines whether the object is a primitive
\begin{verbatim}
  Arguments: None (but uses the current status of the object)
  Returns:  ($prim, $status)
  $prim is 1 if it is a primitive, 0 otherwise (including if status
  is bad).
\end{verbatim}

\item[name]%
\index{name@name}%
\hfill\\
Find the name of the object
\begin{verbatim}
   Arguments:  None (but uses the current status of the object)
   Returns:  ($name, $status)
\end{verbatim}

\item[size]%
\index{size@size}%
\hfill\\
Find the size of the item
\begin{verbatim}
 Arguments: None (but uses the current status of the object)
 Returns: ($size, $maxsize, $status)
\end{verbatim}

Returns status = NBS\_{}\_{}NOTPRIMITIVE if the object is not a primitive.
Returns status = NBS\_{}\_{}NILID  if the object is not defined

The returned size is the number of entries that can be contained.
(ie not bytes unless a \_{}CHAR) and depends on the type of the object.

\item[nth\_{}name(num)]%
\index{nth_name(num)@nth\_{}name(num)}%
\hfill\\
Return the name of the nth component in the objects structure.
\begin{verbatim}
 Arguments: number
 Return:    name
\end{verbatim}

\item[find]%
\index{find@find}%
\hfill\\
Find an item in a noticeboard. The full path name must be given.
The item must exist below the current object.
\begin{verbatim}
  Arguments: Full name of object (separated by dots)
             An object relative to the current object can be
             given if it starts with a '.'
\end{verbatim}

Returns an object blessed into {\tt Starlink::NBS} class.

\item[get]%
\index{get@get}%

Get the item corresponding to the current object.
Must be a primitive object
\begin{verbatim}
  Arguments: None (uses current status of object)
  Returns:   Status and The values (in array context)
               ($status, @values)
\end{verbatim}

\item[put]%
\index{put@put}%

Put values into the object
\begin{verbatim}
   Arguments: Values (however many values are supported)
   Returns:  Status
\end{verbatim}

\item[poke(item, val)]%
\index{poke(item, val)@poke(item, val)}%
\hfill\\
Set the value of item to 'val'.
This is the equivalent of a {\em find()\/} followed by a {\em put()\/}.
\begin{verbatim}
  $nbs->poke(".port_0.display_data", 'IMAGE');
\end{verbatim}

Status of the {\em put()\/} is returned.

\item[peek(item)]%
\index{peek(item)@peek(item)}%
\hfill\\
Return the value stored in item. This is the equivalent of a {\em find()\/}
followed by a {\em get()\/}
\begin{verbatim}
  ($value) = $nbs->peek(".port_0.display_data");
\end{verbatim}

undef is returned if bad status is encountered.
The values are returned in an array context.

\end{description}

\subsection{Tied interface}%
\index{TIE}

Scalar values in the noticeboard can be tied to scalar perl variables
using the perl {\em tie()\/} function.
\begin{verbatim}
   $what = $Nbs->find("primitive.object");
   tie ($object, ref($what), $what);
\end{verbatim}

Now \$object will automatically reflect the value in the notice board
associated with primitive.object. Note that this only works for
primitives (not structures).

Noticeboard structures can be tied to perl hashes also:
\begin{verbatim}
   $what = $Nbs->find("structure");
   tie (%hash, ref($what), $what);
\end{verbatim}

Now \%hash can be used to update the entire noticeboard structure.
Note that keys are always assumed to be relative to the 
tied object --- in effect this means that a '.' is automatically
prepended to all keys if one is not found. (see {\em find()\/}
for more information on relative addressing).

Note that ties can be broken by using simple copies.
For example, for
\begin{verbatim}
     %new = %hash
\end{verbatim}

\%new will not be tied even though \%hash was.

It is possible to tie a hash to the top-level noticeboard structure
and to access lower levels of the noticeboard entirely using the
tie. For example, a simple way to list the noticeboard contents
is to tie a hash to the top level and then use Data::Dumper to
list the hash.
\begin{verbatim}
  use Starlink::NBS;
  use Data::Dumper;
\end{verbatim}
\begin{verbatim}
  $nbs = new Starlink::NBS($nbsname);
  tie %hash, ref($nbs), $nbs;
\end{verbatim}
\begin{verbatim}
  print Dumper(\%hash);  
\end{verbatim}

A method is supplied for tieing NBS objects to variables:

\begin{description}

\item[tienbs]%
\index{tienbs@tienbs}%
\hfill\\
Tie a Starlink::NBS object to a perl variable. No arguments.  If the
object points to a structure a reference to a perl hash is returned.
If the object points to a primitive a reference to a perl scalar is
returned.

\end{description}

\subsection{Non-methods}%
\index{NON-METHODS}

In addition to the OO implementation. Direct hooks to the NBS library
can be accessed. They can be imported into your global namespace by
using:
\begin{verbatim}
      use Starlink::NBS qw/:nbslib/;
\end{verbatim}

The available commands are:
\begin{myquote}
\begin{verbatim}
nbs_find_item(envid, name, id, status)
nbs_find_noticeboard( noticeboard, topid, status)
nbs_find_nth_item(envid, posn, id, status)
nbs_get_children(id, children, status)
nbs_get_info(id, name, value, status)
nbs_get_name(id, name, status)
nbs_get_primitive(id, primitive, status)
nbs_get_shape(id, maxdims, dims, actdims, status)
nbs_get_size(id, maxbytes, actbytes, status)
nbs_get_type(id, type, status)
nbs_get_updated(id, updated, status)
nbs_get_value_c(id, $cvalue, status)
nbs_get_value_d(id, \@values, status)
nbs_get_value_f(id, \@values, status)
nbs_get_value_i(id, \@values, status)
nbs_get_value_l(id, \@values, status)
nbs_lose_item(id, option, status)
nbs_lose_noticeboard(id, option, status)
nbs_put_value_c(id, $string, status)
nbs_put_value_d(id, nvals, \@values, status)
nbs_put_value_f(id, nvals, \@values, status)
nbs_put_value_i(id, nvals, \@values, status)
nbs_put_value_l(id, nvals, \@values, status)
nbs_tune(name, value, oldvalue, status)
nbs_tune_noticeboard(id, name, value, oldvalue, status)
nbs_begin_definition(id, status)
nbs_define_structure(envsid, name, type, sid, status)
nbs_define_primitive(envsid, name, type, maxdims, maxbytes, sid, status)
nbs_define_shape(sid, ndims, dims, status)
nbs_end_definition(name, option, status)
nbs_restore_definition(name, save_name, status)
nbs_restore_noticeboard(name, save_name, status)
nbs_save_noticeboard(id, status)
\end{verbatim}
\end{myquote}

Note that nbs\_{}get\_{} and nbs\_{}put\_{} require a separate routine for each
type. Additionally, the get and set routines expect array arguments.




% ? End of main text
\end{document}
