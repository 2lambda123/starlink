\documentclass[twoside,11pt]{article}

%% Copyright 1998-2003 Particle Physics and Astronomy Research Council.
%% All Rights Reserved.

% ? Specify used packages
% \usepackage{graphicx}        %  Use this one for final production.
% \usepackage[draft]{graphicx} %  Use this one for drafting.
% ? End of specify used packages

\pagestyle{myheadings}

% -----------------------------------------------------------------------------
% ? Document identification
% Fixed part
\newcommand{\stardoccategory}  {Starlink User Note}
\newcommand{\stardocinitials}  {SUN}
\newcommand{\stardocsource}    {sun\stardocnumber}

% Variable part - replace [xxx] as appropriate.
\newcommand{\stardocnumber}    {228.5}
\newcommand{\stardocauthors}   {T.\ Jenness, F.\ Economou\\
                                Joint Astronomy Centre, Hilo, Hawaii}
\newcommand{\stardocdate}      {6 May 2003}
\newcommand{\stardoctitle}     {STARPERL -- Starlink perl modules}
\newcommand{\stardocversion}   {1.13}
\newcommand{\stardocmanual}    {User's manual}
\newcommand{\stardoccopyright} {Copyright \copyright\ 1998-2000,2003 Particle
  Physics and Astronomy Research Council}
\newcommand{\stardocabstract}  {The StarPerl package is a selection
of perl modules that provide access to Starlink infrastructure libraries.
Currently, interfaces are provided to the ADAM messaging system,
the Starlink Noticeboard system. Additional modules are provided to determine
version numbers of installed Starlink packages and to read NDF, HDS and
GSD format data files.
}

% Environment for indenting and using a small font.
\newenvironment{myquote}{\begin{quote}\begin{small}}{\end{small}\end{quote}}

\newcommand{\text}[1]{{\small \tt #1}}

% LaTeX document produced by pod2latex from "Init.pm.pod".
% The followings need be defined in the preamble of this document:
\def\C++{{\rm C\kern-.05em\raise.3ex\hbox{\footnotesize ++}}}
% \def\underscore{\leavevmode\kern.04em\vbox{\hrule width 0.4em height 0.3pt}}
\setlength{\parindent}{0pt}



% ? End of document identification
% -----------------------------------------------------------------------------
\newcommand{\task}[1]{{\sf #1}}
\newcommand{\Kappa}{\xref{{\sc{Kappa}}}{sun95}{}}
\newcommand{\Figaro}{\xref{{\sc{Figaro}}}{sun86}{}}
\newcommand{\ADAM}{\xref{{ADAM}}{sun144}{}}
\newcommand{\gsd}{\xref{{GSD}}{sun229}{}}
\newcommand{\ndf}{\xref{NDF}{sun33}{}}
\newcommand{\ems}{\xref{EMS}{ssn4}{}}
\newcommand{\perl}{\xref{\textsf{Perl}}{sun193}{}}

\newcommand{\hds}{\xref{HDS}{sun92}{}}
\newcommand{\ary}{\xref{ARY}{sun11}{}}
\newcommand{\mers}{\xref{MERS}{sun104}{}}
\newcommand{\parget}{\xref{\task{parget}}{sun95}{PARGET}}


\newcommand{\delobj}{\xref{\task{delobj}}{sun86}{DELOBJ}}
\newcommand{\creobj}{\xref{\task{creobj}}{sun86}{CREOBJ}}
\newcommand{\setobj}{\xref{\task{setobj}}{sun86}{SETOBJ}}
\newcommand{\copobj}{\xref{\task{copobj}}{sun86}{COPOBJ}}
\newcommand{\stats}{\xref{\task{stats}}{sun95}{STATS}}

\newcommand{\jcmt}{\htmladdnormallink{JCMT}{http://www.jach.hawaii.edu/JACpublic/JCMT}}

% +
%  Name:
%     sun227.tex
%
%  Purpose:
%     Template for Starlink User Note (SUN) documents.
%     Refer to SUN/199
%
%  Authors:
%     AJC: A.J.Chipperfield (Starlink, RAL)
%     BLY: M.J.Bly (Starlink, RAL)
%     PWD: Peter W. Draper (Starlink, Durham University)
%     TIMJ: Tim Jenness (Joint Astronomy Centre)

%  History:
%     17-JAN-1996 (AJC):
%        Original with hypertext macros, based on MDL plain originals.
%     16-JUN-1997 (BLY):
%        Adapted for LaTeX2e.
%        Added picture commands.
%     13-AUG-1998 (PWD):
%        Converted for use with LaTeX2HTML version 98.2 and
%        Star2HTML version 1.3.
%     16-Feb-1999 (TIMJ)
%        Convert template to SUN227 - STARPERL.
%     {Add further history here}
%
% -

\newcommand{\stardocname}{\stardocinitials /\stardocnumber}
\markboth{\stardocname}{\stardocname}
\setlength{\textwidth}{160mm}
\setlength{\textheight}{230mm}
\setlength{\topmargin}{-2mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\setlength{\unitlength}{1mm}

% -----------------------------------------------------------------------------
%  Hypertext definitions.
%  ======================
%  These are used by the LaTeX2HTML translator in conjunction with star2html.

%  Comment.sty: version 2.0, 19 June 1992
%  Selectively in/exclude pieces of text.
%
%  Author
%    Victor Eijkhout                                      <eijkhout@cs.utk.edu>
%    Department of Computer Science
%    University Tennessee at Knoxville
%    104 Ayres Hall
%    Knoxville, TN 37996
%    USA

%  Do not remove the %begin{latexonly} and %end{latexonly} lines (used by
%  LaTeX2HTML to signify text it shouldn't process).
%begin{latexonly}
\makeatletter
\def\makeinnocent#1{\catcode`#1=12 }
\def\csarg#1#2{\expandafter#1\csname#2\endcsname}

\def\ThrowAwayComment#1{\begingroup
    \def\CurrentComment{#1}%
    \let\do\makeinnocent \dospecials
    \makeinnocent\^^L% and whatever other special cases
    \endlinechar`\^^M \catcode`\^^M=12 \xComment}
{\catcode`\^^M=12 \endlinechar=-1 %
 \gdef\xComment#1^^M{\def\test{#1}
      \csarg\ifx{PlainEnd\CurrentComment Test}\test
          \let\html@next\endgroup
      \else \csarg\ifx{LaLaEnd\CurrentComment Test}\test
            \edef\html@next{\endgroup\noexpand\end{\CurrentComment}}
      \else \let\html@next\xComment
      \fi \fi \html@next}
}
\makeatother

\def\includecomment
 #1{\expandafter\def\csname#1\endcsname{}%
    \expandafter\def\csname end#1\endcsname{}}
\def\excludecomment
 #1{\expandafter\def\csname#1\endcsname{\ThrowAwayComment{#1}}%
    {\escapechar=-1\relax
     \csarg\xdef{PlainEnd#1Test}{\string\\end#1}%
     \csarg\xdef{LaLaEnd#1Test}{\string\\end\string\{#1\string\}}%
    }}

%  Define environments that ignore their contents.
\excludecomment{comment}
\excludecomment{rawhtml}
\excludecomment{htmlonly}

%  Hypertext commands etc. This is a condensed version of the html.sty
%  file supplied with LaTeX2HTML by: Nikos Drakos <nikos@cbl.leeds.ac.uk> &
%  Jelle van Zeijl <jvzeijl@isou17.estec.esa.nl>. The LaTeX2HTML documentation
%  should be consulted about all commands (and the environments defined above)
%  except \xref and \xlabel which are Starlink specific.

\newcommand{\htmladdnormallinkfoot}[2]{#1\footnote{#2}}
\newcommand{\htmladdnormallink}[2]{#1}
\newcommand{\htmladdimg}[1]{}
\newcommand{\hyperref}[4]{#2\ref{#4}#3}
\newcommand{\htmlref}[2]{#1}
\newcommand{\htmlimage}[1]{}
\newcommand{\htmladdtonavigation}[1]{}

\newenvironment{latexonly}{}{}
\newcommand{\latex}[1]{#1}
\newcommand{\html}[1]{}
\newcommand{\latexhtml}[2]{#1}
\newcommand{\HTMLcode}[2][]{}

%  Starlink cross-references and labels.
\newcommand{\xref}[3]{#1}
\newcommand{\xlabel}[1]{}

%  LaTeX2HTML symbol.
\newcommand{\latextohtml}{\LaTeX2\texttt{HTML}}

%  Define command to re-centre underscore for Latex and leave as normal
%  for HTML (severe problems with \_ in tabbing environments and \_\_
%  generally otherwise).
\renewcommand{\_}{\texttt{\symbol{95}}}

% -----------------------------------------------------------------------------
%  Debugging.
%  =========
%  Remove % on the following to debug links in the HTML version using Latex.

% \newcommand{\hotlink}[2]{\fbox{\begin{tabular}[t]{@{}c@{}}#1\\\hline{\footnotesize #2}\end{tabular}}}
% \renewcommand{\htmladdnormallinkfoot}[2]{\hotlink{#1}{#2}}
% \renewcommand{\htmladdnormallink}[2]{\hotlink{#1}{#2}}
% \renewcommand{\hyperref}[4]{\hotlink{#1}{\S\ref{#4}}}
% \renewcommand{\htmlref}[2]{\hotlink{#1}{\S\ref{#2}}}
% \renewcommand{\xref}[3]{\hotlink{#1}{#2 -- #3}}
%end{latexonly}
% -----------------------------------------------------------------------------
% ? Document specific \newcommand or \newenvironment commands.
% ? End of document specific commands
% -----------------------------------------------------------------------------
%  Title Page.
%  ===========
\renewcommand{\thepage}{\roman{page}}
\begin{document}
\thispagestyle{empty}

%  Latex document header.
%  ======================
\begin{latexonly}
  CCLRC / {\textsc Rutherford Appleton Laboratory} \hfill {\textbf \stardocname}\\
   {\large Particle Physics \& Astronomy Research Council}\\
   {\large Starlink Project\\}
   {\large \stardoccategory\ \stardocnumber}
   \begin{flushright}
   \stardocauthors\\
   \stardocdate
   \end{flushright}
   \vspace{-4mm}
   \rule{\textwidth}{0.5mm}
   \vspace{5mm}
   \begin{center}
   {\Huge\textbf  \stardoctitle \\ [2.5ex]}
   {\LARGE\textbf \stardocversion \\ [4ex]}
   {\Huge\textbf  \stardocmanual}
   \end{center}
   \vspace{5mm}

% ? Add picture here if required for the LaTeX version.
%   e.g. \includegraphics[scale=0.3]{filename.ps}
% ? End of picture

% ? Heading for abstract if used.
   \vspace{10mm}
   \begin{center}
      {\Large\textbf Abstract}
   \end{center}
% ? End of heading for abstract.
\end{latexonly}

%  HTML documentation header.
%  ==========================
\begin{htmlonly}
   \xlabel{}
   \begin{rawhtml} <H1 ALIGN=CENTER> \end{rawhtml}
      \stardoctitle\\
      \stardocversion\\
      \stardocmanual
   \begin{rawhtml} </H1> <HR> \end{rawhtml}

% ? Add picture here if required for the hypertext version.
%   e.g. \includegraphics[scale=0.7]{filename.ps}
% ? End of picture

   \begin{rawhtml} <P> <I> \end{rawhtml}
   \stardoccategory\ \stardocnumber \\
   \stardocauthors \\
   \stardocdate
   \begin{rawhtml} </I> </P> <H3> \end{rawhtml}
      \htmladdnormallink{CCLRC}{http://www.cclrc.ac.uk} /
      \htmladdnormallink{Rutherford Appleton Laboratory}
                        {http://www.cclrc.ac.uk/ral} \\
      \htmladdnormallink{Particle Physics \& Astronomy Research Council}
                        {http://www.pparc.ac.uk} \\
   \begin{rawhtml} </H3> <H2> \end{rawhtml}
      \htmladdnormallink{Starlink Project}{http://www.starlink.ac.uk/}
   \begin{rawhtml} </H2> \end{rawhtml}
   \htmladdnormallink{\htmladdimg{source.gif} Retrieve hardcopy}
      {http://www.starlink.ac.uk/cgi-bin/hcserver?\stardocsource}\\

%  HTML document table of contents.
%  ================================
%  Add table of contents header and a navigation button to return to this
%  point in the document (this should always go before the abstract \section).
  \label{stardoccontents}
  \begin{rawhtml}
    <HR>
    <H2>Contents</H2>
  \end{rawhtml}
  \htmladdtonavigation{\htmlref{\htmladdimg{contents_motif.gif}}
        {stardoccontents}}

% ? New section for abstract if used.
  \section{\xlabel{abstract}Abstract}
% ? End of new section for abstract
\end{htmlonly}

% -----------------------------------------------------------------------------
% ? Document Abstract. (if used)
%  ==================
\stardocabstract
% ? End of document abstract

% -----------------------------------------------------------------------------
% ? LateX Copyright Statement
%  =========================
\begin{latexonly}
\newpage
\vspace*{\fill}
\stardoccopyright
\end{latexonly}
% ? End of Latex copyright statement

% -----------------------------------------------------------------------------
% ? Latex document Table of Contents (if used).
%  ===========================================
  \newpage
  \begin{latexonly}
    \setlength{\parskip}{0mm}
    \tableofcontents
    \setlength{\parskip}{\medskipamount}
    \markboth{\stardocname}{\stardocname}
  \end{latexonly}
% ? End of Latex document table of contents
% -----------------------------------------------------------------------------
\cleardoublepage
\renewcommand{\thepage}{\arabic{page}}
\setcounter{page}{1}

% ? Main text

\section{Introduction}

The \textsc{Starperl} package provides modules for perl/Starlink
interoperability. The purpose of this package is to allow access to the
Starlink infrastructure libraries from the \xref{perl}{sun193}{} programming
language. Modules provided by this packages support  \ndf\ and \gsd\ file I/O,
the \ADAM\ messaging system, the \ems\ messaging layer  and an interface to
the Noticeboard system. Additionally a module is provided for determining the
version number of any installed Starlink package.

\section{The usefulness of this package\label{stats}}

The \ndf\ module can be used for reading, writing and modifying
the standard Starlink data format (NDF and HDS). This can be
very useful for changing headers and determining file properties
from within a program without having to launch \Kappa.

The \gsd\ module can be used for reading GSD data format files (SUN/229). This
is a non-standard data format currently in use at the \htmladdnormallink{James
  Clerk Maxwell Telescope}{http://www.jach.hawaii.edu/JACpublic/JCMT}.  The
module provides read-only access to GSD data.

The \texttt{starversion} command (and related) module can be used in shell
scripts or \perl\ programs to determine whether a particular version of a
package is installed. This is useful for providing backwards compatibility
when parameters are changed.

The \ADAM\  modules are useful in situations where there is a need for
efficient scripting without recourse to compiled code. An example of
such a script is to process a large number of files.

Suppose, for example that you wish to perform an operation (say calculation of
the standard deviation) on a thousand data frames using the
\xref{KAPPA}{sun95}{} \xref{\texttt{stats}}{sun95}{STATS} command. A unix
c-shell script to perform this task would have a significant overhead, as
every time the \texttt{stats} command is issued, the \xref{KAPPA}{sun95}{}
monolith has to be started up and run down. On the other hand a \perl\ script
using the Starlink modules needs to run up the monolith only once, and while
it is resident in memory fire off messages requesting it to perform the
\xref{\texttt{stats}}{sun95}{STATS} operation.

Another use for these modules is in situations where accurate status
information needs to be propagated correctly to the calling
programme. An example of this is a data reduction pipeline in which
one wishes to not only detect the success or failure of a task, but
also particular status codes (such as whether a fitting routine failed
due to anomalies in the data or simply lack of disk space).

Additionally, it is sometimes convenient to use shared memory to pass
information between processes on the same machine. The NBS interface
provides a simple way of doing this from \perl\ (even allowing the use
of tied hashes).

The Starlink::HDSPACK module provides a \perl\ alternative to using the
\Figaro\ \copobj, \creobj, and \setobj\ and \delobj\ commands.

\section{The Starlink Perl modules}

All the modules from this distribution are placed in the \texttt{Starlink::}
hierarchy so that Starlink \perl\ functionality does not clash with existing
modules.  The exceptions are the file I/O \ndf\ and \gsd\ modules which have
their own namespace.

The individual modules are discussed in the following sections.

\section{Using these modules}

The modules described in this document are distributed as standard
\perl\ dynamic modules. Like all such modules, they can be included by
using the \texttt{use} function in \perl\ at the start of your program:

\begin{myquote}
\begin{verbatim}
#!/star/Perl/bin/perl

use Starlink::Modulename;
\end{verbatim}
\end{myquote}

See the \perl\ \texttt{perlmods} man page for more information on using
modules.


\section{EMS interface\label{ems}}

An interface to the Starlink EMS C library (\xref{SSN/4}{ssn4}{}) is
provided by the \texttt{Starlink::EMS} module. All routines described in
that document are available as well as an internal routine for converting a
status code directly to the error mesage components (ems1\_get\_facility\_error).

The EMS functions can be imported using the '\texttt{ems}' tag:

\begin{myquote}
\begin{verbatim}
use Starlink::EMS qw/ :ems /;
\end{verbatim}
\end{myquote}

The following routines are available:

\texttt{ems\_annul(), ems\_begin(), ems\_eload(), ems\_end(),
ems\_errno(), ems\_facer(), ems\_fmtc(), ems\_fmtd(),
ems\_fmti(), ems\_fmtl(), ems\_fmtr() ems\_level(), ems\_mark(),
ems\_mload(), ems\_renew(), ems\_rep(), ems\_rlse(), ems\_setc(),
ems\_setd(), ems\_seti(), ems\_setl(), ems\_setr(), ems\_stat(),
ems\_syser(), ems\_tune(}.

The C versions of the names can also be imported via the `\texttt{Ems}'
tag:

\texttt{emsAnnul, emsBegin, emsEload, emsEnd, emsErrno, emsFacer,
emsFmtc, emsFmtd, emsFmti, emsFmtl, emsFmtr, emsLevel, emsMark, emsMload,
emsRenew, emsRep, emsRlse, emsSetc, emsSetd, emsSeti, emsSetl,
emsSetr, emsStat, emsSyser, emsTune}.

One difference between the \perl\ implementation and the C/Fortran version
described in \xref{SSN/4}{ssn4}{} concerns return values. Routines with
arguments that contain pure return values (as opposed to
modifications of an existing variable) return the values as
a \perl\ array or scalar. The routines are:

\begin{myquote}
\begin{verbatim}
($par, $str, $status) = ems_load();
$level = ems_level();
$string = ems_mload($par, $str, $status);
\end{verbatim}
\end{myquote}

The \texttt{ems1\_get\_facility\_error()} routine is not documented in
\xref{SSN/4}{ssn4}{} but can be used to convert an error status to the
corresponding error code and text. This is similar to the
\texttt{ems\_facer()} routine (also available) but gives more control over the
use of this information and does not go via a token.  This command is
available in two forms. One form is identical to the C implementation, the
other provides the values as a \perl\ array:

\begin{myquote}
\begin{verbatim}
ems1_get_facility_error($status, $facility, $ident, $text);
($facility, $ident, $text) = get_facility_error($status);
\end{verbatim}
\end{myquote}

When passed a status error code, this routine returns the facility
name, error identifier and error message. It is used by the perl/ADAM
module to decode error status codes returned by ADAM monoliths.

Generic status values can be imported with the '\texttt{sai}' tag:

\begin{myquote}
\begin{verbatim}
use Starlink::EMS qw( :sai );

$ok = SAI__OK;
$warn = SAI__WARN;
$err  = SAI__ERROR;
\end{verbatim}
\end{myquote}
% $

An interface to MERS (\xref{SUN/104}{sun104}{}) is provided by the
the \texttt{NDF} module (see \S\ref{ndfperl})

\section{NDF\label{ndfperl}}

The extensible N-dimensional data format (NDF) is a format for storing bulk
data in the form of N-dimensional arrays of numbers.  It is typically used
for storing spectra, images and similar datasets with higher dimensionality.
The NDF format is based on the Hierarchical Data System (HDS) and is
extensible; not only does it provide a comprehensive set of standard
ancillary items to describe the data, it can also be extended indefinitely
to handle additional user-defined information of any type.

The NDF module provides a \perl\ interface to the Fortran \ndf, \hds\ and
\mers\ (MSG and ERR) libraries that are supplied with the standard Starlink
software distribution.

This document assumes a basic knowledge of both \perl\ and the Starlink
programming environment.

The entire \ndf, \hds\ and \mers\ system can be imported into a \perl\ program
by using the \texttt{use} command:

\begin{myquote}
\begin{verbatim}
use NDF;
\end{verbatim}
\end{myquote}

If only a subset of these commands are required then it is possible to supply
the names of the subsystem to the \texttt{use} command:

\begin{myquote}
\begin{verbatim}
use NDF qw(:ndf :misc);
\end{verbatim}
\end{myquote}

would import just the \texttt{ndf\_} and miscellaneous commands into
the namespace. The remaining commands would still be available but must
be accessed through their package name (\emph{e.g.}\ \texttt{hds\_open}
would be available as \texttt{\&NDF::hds\_open}). The individual
subsystems along with the available commands are listed in appendix
\ref{ndfapp}.

Once the module has been loaded the library subroutines can be accessed
by using \perl\ commands of the same name. For example, the following
could be used in order to open and close an NDF file:

\begin{myquote}
\begin{verbatim}
#!/star/Perl/bin/perl

use NDF;

$status = &NDF::SAI__OK;   # Initialise good status

ndf_begin;                 # initialise the NDF system

ndf_find(&NDF::DAT__ROOT, 'ndf_test', $indf, $status);
ndf_annul($indf, $status); # Close the file

ndf_end($status);          # Close down NDF
\end{verbatim}
\end{myquote}

Note that the routine names are all in lower case, but apart from this
use the same syntax that would be used for accessing the Fortran
routine.  Section \ref{access_to_compiler_constants} describes how to
access constants such as \texttt{SAI\_\_OK} and \texttt{DAT\_\_ROOT}.

Example programs are available in the \texttt{t} sub-directory of the
installation tree, or, if installed, on Starlink systems in
\texttt{/star/examples/starperl}.

\subsection{\xlabel{access_to_compiler_constants}Access to compiler constants}%
\label{access_to_compiler_constants}\index{Access to compiler constants}

Occassionally it is necessary to access Starlink system constants
dealing with error status and system limitations.  Compiler constants
can be accessed via \texttt{\&NDF::(constant)} and are autoloaded as
required.  \emph{e.g.}, the value for \texttt{SAI\_\_OK} can be
accessed as \texttt{\&NDF::SAI\_\_OK}, as in:

\begin{myquote}
\begin{verbatim}
ndf_find(&NDF::DAT__ROOT,$filename,$indf,$status);
print "An error occurred\n" if ($status != &NDF::SAI__OK);
\end{verbatim}
\end{myquote}

At present all the \texttt{DAT\_\_}, \texttt{ERR\_\_}, \texttt{EMS\_\_},
\texttt{MSG\_\_} and \texttt{SAI\_\_} constants are available.  More
can be included as more C include files are created.  In the absence of
the necessary include files a request for a specific compiler constant
will be refused. Some of these constants are also exported by the
Starlink::EMS module (\S\ref{ems}).

\subsection{\xlabel{dealing_with_mapped_arrays}Dealing with MAPPED arrays}%
\label{dealing_with_mapped_arrays}\index{Dealing with MAPPED arrays}

Routines such as \texttt{ndf\_map} and \texttt{dat\_mapv} return
pointers to the data arrays. These pointers are handled differently in
\perl\ than in Fortran.

To read a mapped array you must first \emph{copy\/} the data from the mapped
array into a \perl\ array. Modifiying this \perl\ array \emph{will not\/} change
the mapped array. The \perl\ array must be copied back into the mapped
array for any changes to become permanent. To reduce resource requirements
you may want to unmap the array as soon as it has been copied to the
\perl\ array. Currently there is no way to access the mapped data directly.

In \perl\ the array must first be packed into a single string and this
string must then be copied to the mapped memory location.
For example:

\begin{myquote}
\begin{verbatim}
$mapped_string = pack("i*", @data);
ndf_map($indf, 'DATA', '_INTEGER', 'WRITE', $pntr, $el, $status);
string2mem($mapped_string, 4 * $el, $pntr);
\end{verbatim}
\end{myquote}

This copies a \perl\ data array to the NDF \texttt{DATA\_ARRAY}. If
\texttt{\$el} does not equal \texttt{\$\#data + 1} (\emph{i.e.}, the
number of entries in the \perl\ array) then odd things will happen.

The reverse process can be achieved using \texttt{mem2string} as follows:

\begin{myquote}
\begin{verbatim}
ndf_map($indf, 'DATA', '_INTEGER', 'READ', $pntr, $el, $status);
mem2string($pntr, 4 * $el, $mapped_string);
@data = unpack("i*", $mapped_string);
\end{verbatim}
\end{myquote}

Note that both \texttt{mem2string} and \texttt{string2mem} require the
\emph{number of bytes\/} to be mapped.  The data then has to be
unpacked into an array by the \perl\ \texttt{unpack} command. Obviously
for \texttt{\_REAL} data a different option should be used for
\texttt{pack}.  For large data arrays this method is extremely
inefficient and use of the \htmladdnormallinkfoot{Perl Data Language
(PDL)}{http://pdl.perl.org/} should be
considered\footnote{A module is available for reading NDF files into
PDL. The PDL::IO::NDF is distributed as part of PDL.}

Character arrays can be dealt with as follows:

\begin{myquote}
\begin{verbatim}
$mapped_string = pack("A20" x ($#data +1), @data);
ndf_map($indf, 'DATA', '_CHARACTER*20', 'WRITE', $pntr, $el, $status);
string2mem($mapped_string, 20*($#data +1), $pntr);
\end{verbatim}
\end{myquote}

This packs an array of \perl\ strings into a fixed length (space padded) string
of length 20 $\times$ (size of array) characters. The string is then copied to
the mapped array with \texttt{string2mem}.

Dealing with arrays is made easier by the \texttt{array2mem} and
\texttt{mem2array}  routines, which handle the packing for the
programmer. At present these routines do not work with character arrays
and the lower level \texttt{string2mem} and \texttt{mem2string}
routines must still be used.

To copy from a mapped array to a \perl\ array you use \texttt{mem2array}.
The routine requires the pointer to the mapped array, the pack type (as
used in the the \perl\ \texttt{pack} command, \emph{i.e.}
\texttt{"i$\ast$"} for ints, \texttt{"f$\ast$"} for floats) and the
number of elements, and returns the array.

For example:
\begin{myquote}
\begin{verbatim}
ndf_map($indf, 'DATA', '_INTEGER', 'READ', $pntr, $el, $status);
@data = mem2array($pntr, "i*", $el);
\end{verbatim}
\end{myquote}

To write to a mapped array, you use \texttt{array2mem}:

\begin{myquote}
\begin{verbatim}
ndf_map($indf, 'DATA', '_INTEGER', 'WRITE', $pntr, $el, $status);
array2mem(@data, "i*", $pntr);
\end{verbatim}
\end{myquote}

Remember that, at present, these routines \emph{do not\/} work with
\texttt{\_CHARACTER} arrays. In that case you must use the
\texttt{mem2string} and \texttt{string2mem} routines directly.

\subsection{\xlabel{accessing_fits_entries}Accessing FITS entries}%
\label{accessing_fits_entries}\index{Accessing FITS entries}

\textit{This approach is now deprecated. Please use the
  \texttt{Astro::FITS::Header} module (distributed as part of the
  \textsc{perlmods} package) whenever possible. The
  \texttt{Astro::FITS::Header} module provides much finer control of the
  header and can retain the key order.}

FITS entries are stored in the FITS extension of an NDF. The FITS array
can be accessed by using raw HDS commands as follows:

\begin{myquote}
\begin{verbatim}
ndf_xloc($indf, 'FITS', 'READ', $floc, $status);
dat_get1c($floc, 200, @fits, $nfits, $status);
\end{verbatim}
\end{myquote}

(The 200 indicates the maximum size of the array --- this can be any
value greater than or equal to the actual size of the array and can be
determined beforehand by using the \texttt{dat\_size} command).  The FITS
header information is now in the \perl\ \texttt{@fits} array and can be accessed
via \texttt{fits\_get\_item} and \texttt{fits\_get\_nth\_item}.

For example, to list all the values and keywords:

\begin{myquote}
\begin{verbatim}
for ($i=0; $i <= $#fits; $i++) {
  ($keyword, $value, $comment) = fits_get_nth_item(@fits, $i);
  print "$i: $keyword\t $value\n";
}
\end{verbatim}
\end{myquote}
% $

You can also use \texttt{fits\_extract\_key\_val} to
access the \texttt{nth} entry via

\begin{myquote}
\begin{verbatim}
($keyword, $value, $comment) = fits_extract_key_val($fits[$n]);
\end{verbatim}
\end{myquote}
% $

To find out the value that goes with a keyword:

\begin{myquote}
\begin{verbatim}
$inst = fits_get_item(@fits, 'INSTRUME');
print "Instrument is $inst\n";
\end{verbatim}
\end{myquote}

Remember that \perl\ has associative arrays:

\begin{myquote}
\begin{verbatim}
%fitsitem = ();
for ($i=0; $i <= $#fits; $i++) {
  ($keyword, $value, $comment) = fits_get_nth_item(@fits, $i);
  $fitsitem{$keyword} = $value;
}
\end{verbatim}
\end{myquote}

so that:

\begin{myquote}
\begin{verbatim}
print "$fitsitem{'INSTRUME'}\n";
\end{verbatim}
\end{myquote}

will print, say, SCUBA.

A general routine exists for reading the FITS header.
\texttt{fits\_read\_header} reads the FITS extension and returns the
reference to a hash array:

\begin{myquote}
\begin{verbatim}
($hashref, $status) = fits_read_header($file);
\end{verbatim}
\end{myquote}

The FITS entries can then be accessed as \verb+$$hashref{'ITEM'}+.
This takes the filename as an argument and returns the Starlink status.

\subsection{\xlabel{accessing_adam_parameters_from_atasks}Accessing ADAM parameters from A-tasks}%
\label{accessing_adam_parameters_from_atasks}\index{Accessing ADAM parameters from A-tasks}

ADAM A-tasks store their parameters in HDS files in the \texttt{ADAM\_USER}
directory (which defaults to \texttt{\$HOME/adam}). This routine retrieves the
value of a parameter for any ADAM task that uses the \texttt{ADAM\_USER}
directory and is based on the \Kappa\ task \parget.

For example
\begin{myquote}
\begin{verbatim}
($in) = par_get("data_array","GLOBAL", \$status);
\end{verbatim}
\end{myquote}

returns the current data set (stored in \texttt{GLOBAL.sdf}). Note that
the data is returned in an array context. The routine returns without
action if \texttt{\$status} is not set to \texttt{SAI\_\_OK} on entry.
Note that a reference to \texttt{\$status} is passed into this routine
so that the status can be modified on exit.

Either the \texttt{\$ADAM\_USER} or \texttt{\$HOME} environment
variable must be set so that the location of the parameter files can be
determined.

This command can not access parameter values of tasks that are currently
running.  In order to retrieve parameter values via the ADAM messaging system
the \texttt{Starlink::AMS::TASK} module (\S\ref{adam}) must be
used.

\subsection{\xlabel{notes}\label{notes}NOTES}

\subsubsection{Function calls}%
\index{Function calls}

The commands in this module use  \perl\ prototypes to check argument
passing. This means that arrays do not have to be referenced when being
used as arguments \emph{unless\/} the routine is called with an \texttt{\&}.

For example, both

\begin{myquote}
\begin{verbatim}
$value = fits_get_item(@fits, $keyword);
\end{verbatim}
\end{myquote}
and
\begin{myquote}
\begin{verbatim}
$value = &fits_get_item(\@fits, $keyword);
\end{verbatim}
\end{myquote}

are correct but
\begin{myquote}
\begin{verbatim}
$value = &fits_get_item(@fits, $keyword);
\end{verbatim}
\end{myquote}

will fail because \perl\ will pass all the members of the array and not the
reference to the array.

\subsubsection{Arrays}%
\index{Arrays}

Note that the \texttt{GetNx}/\texttt{PutNx} routines have not been
implemented in this module because plain Perl does not really support
N-dimensional arrays.  All data in plain \perl\ is vectorised.  If you
wish to use N-dimensional data structures in \perl\ you must use the
\htmladdnormallink{PDL}{http://pdl.perl.org}
module in conjunction with a vectorised read (see \emph{e.g.}, the
\texttt{rndf} command in \texttt{perldl} which stores all arrays as
true N-dimensional data sets). The PDL module is available from
\htmladdnormallinkfoot{CPAN}{http://www.cpan.org/}. Also
note that the Get1x/Put1x routines are implemented but are not
necessary since the vectorised routines can always be used instead.

\subsubsection{Accessing TYPEd data}%
\index{Accessing TYPEd data}

Although routines are available for accessing data of any type
(\emph{e.g.} \texttt{\_INTEGER}, \texttt{\_REAL}, \texttt{\_DOUBLE})
the untyped nature of \perl\ and the type conversion inherent in the NDF
routines mean that, in practice, only character handling routines are
needed to access data (\emph{e.g.} via \texttt{ndf\_xgt0c} or
\texttt{dat\_get1c}).  This does not apply to mapped data arrays where
the size of the data type must be known before unpacking.  The double
precision routines may be necessary since the type conversion routines
truncate to \texttt{\_REAL} precision when converting to \texttt{\_CHAR}.

\subsubsection{Printing History information}%
\index{Printing History information}

Whilst all the NDF history calls are implemented, \texttt{NDF\_HOUT} has
only a minimal functionality since \texttt{NDF\_HOUT} requires the name of a
Fortran subroutine.  Calling a \perl\ subroutine from Fortran has not been
implemented and \texttt{NDF\_HECHO} is called by default.



\section{ADAM interface\label{adam}}

This package provides modules that allow \perl\ to send and receive \ADAM\
messages. This allows a \perl\ program to control ADAM monoliths without having
to launch a new process each time a data reduction task is required (as found
in \xref{shell scripts}{sc4}{} or using the \texttt{system} call from perl).


\subsection{A simple example}

Here is the code for the example discussed in section \ref{stats}. We have
written this script to find the standard deviation of all files in directory
matching the \texttt{obs*.sdf} pattern (such as \texttt{obs1.sdf},
\texttt{obs2.sdf}, etc).

This is what needs to happen in such as script

\begin{itemize}

\item The Starlink modules are included

\item The ADAM messaging is started and the \Kappa\ monolith is loaded

\item Stuff happens

\end{itemize}

And here is what it really looks like:

\begin{myquote}
\begin{verbatim}
#!/star/Perl/bin/perl

# Include the modules}
use Starlink::AMS::Init;
use Starlink::AMS::Task;

# Start the messaging system
$ams = new Starlink::AMS::Init(1);

# Set timeout to be 30 seconds
$ams->timeout(30);

# Turn off all information messages (eg the output of stats)
# keeping error messages
$ams->messages(0);

# Now launch kappa (as an A-task) and store the object.
# The first argument uses '$$' (the process id) so that this
# script can be run without the possibility of clashing with another
# script using kappa on the same machine.
$kappa = new Starlink::AMS::Task("kappa_mon_$$", "$ENV{KAPPA_DIR}/kappa_mon");

# Now wait for kappa to load
$kappa->contactw || die "Error launching kappa - timeout";

# Now loop over the required files

foreach my $file (<obs*.sdf>) {

  # Remove the trailing sdf from the filename for ADAM tasks
  $file =~ s/\.sdf$//;

  # Run kappa stats
  $status = $kappa->obeyw("stats","ndf=$file");

  # Return status should be DTASK__ACTCOMPLETE
  die "error running stats" if $status != &Starlink::ADAM::DTASK__ACTCOMPLETE;

  # Retrieve the standard deviation and print it out
  ($status, $stdev) = $kappa->get("stats","sigma");

  die "Error retrieving statistics for file $file"
    if $status != &Starlink::ADAM::SAI__OK;

  print "$file : $stdev\n";

}

# Messaging system and monolith are shutdown automatically.

\end{verbatim}
\end{myquote}

\subsection{Component modules}

The perl-ADAM interface is made of four modules:

\begin{description}
\item[Starlink::ADAM]

This is the low-level interface to libams. It should not be used directly
unless you are familiar with the AMS library.\footnote{In future releases this
module might be renamed to Starlink::AMS::AMSLib. If this happens a stub
interface to Starlink::ADAM will be provided.} This module does provide
access to constants such as SAI\_\_OK and DTASK\_\_ACTCOMPLETE.

\item[Starlink::AMS::Core]

This is the lowest level task interface for controlling ADAM tasks. It should
not be used directly.

\item[Starlink::AMS::Init]

This is a high level object-oriented interface to the messaging layer. It is
used to turn on ADAM messaging, control timeouts and control the printing
of information and error messages.

\item[Starlink::AMS::Task]

This is a high-level object-oriented interface to ADAM tasks and provides
means for launching monoliths and sending CONTROL, OBEY, GET and SET
messages. An instance of this object is created for each monolith.

\end{description}

Only the high-level interface will  be discussed in this document.
The methods are described in the appendix.

\subsubsection{Starlink::AMS::Init}


This class is responsible for starting the messaging layer (unlike
\xref{STARTCL}{sun186}{} the messaging system is not initialised as soon as
the code is loaded) and controlling the user-interface to the messaging system
(such as timeouts and where the replies from the monolith are sent).

The messaging is initialised by creating a new instance of
a Starlink::AMS::Init object. All further attempts to create a new
instance of this object will result in the \emph{same} object being
returned (i.e.\ only one instance of this object will actually exist).

\begin{myquote}
\begin{verbatim}
use Starlink::AMS::Init;

$ams = new Starlink::AMS::Init(1);  # Start messaging

$ams->timeout(600); # Set timeout to 10 minutes
\end{verbatim}
\end{myquote}

\subsubsection{Starlink::AMS::Task}

This class is responsible for launching and communicating with ADAM
monoliths. The monoliths can be launched as either A-tasks (where the
parameters are reset after each message and values stored in a
file in the ADAM\_USER directory) or as I-tasks (where the state
of the parameters is retained in the monolith). The default is to launch
monoliths as A-tasks since this replicates the behaviour seen from
\xref{ICL}{sg5}{} and the Unix shell.

Example usage is:
\begin{myquote}
\begin{verbatim}
$kappa = new Starlink::AMS::Task("name","monolith_image");
$status = $kappa->obeyw("task", "params");
$status = $kappa->set("task","param","value");
($status, $value) = $kappa->get("task","param");
$dir = $kappa->control("default","dir");
$kappa->control("par_reset");
\end{verbatim}
\end{myquote}
% $


\subsection{Constants}

Compiler constants are made available via the Starlink::ADAM module.
The available constants are:

\begin{myquote}
SAI\_\_OK, SAI\_\_WARN, SAI\_\_ERROR\footnote{The
SAI\_\_ constants are also available from the NDF and the
Starlink::EMS modules},

DTASK\_\_ACTSTART, DTASK\_\_ACTCOMPLETE,

MESSYS\_\_INFINITE, MESSYS\_\_PARAMREQ, MESSYS\_\_PARAMREP, MESSYS\_\_INFORM,
MESSYS\_\_SYNC, MESSYS\_\_SYNCREP, MESSYS\_\_TRIGGER, MESSYS\_\_MESSAGE,

MSG\_VAL\_LEN, MSG\_NAME\_LEN,

OBEY, GET, SET, CANCEL, CONTROL.
\end{myquote}

These constants are not exported by the module (the Autoloader module is used)
and must be fully-qualified, eg:

\begin{myquote}
\begin{verbatim}
$good_status = &Starlink::ADAM::SAI__OK;
$complete    = &Starlink::ADAM::DTASK__ACTCOMPLETE;
\end{verbatim}
\end{myquote}

Note the use of the ampersand to indicate that this is actually an
autoloaded function and not a variable or \perl\ constant.

\subsection{Limitations and bugs}

Currently the perl/ADAM interface does not make use of an event loop.
This means that, for example, a GET, SET, OBEYW or CONTROL message will
wait (block) for the monolith to respond before control is returned
to the \perl\ program. A non-blocking OBEY is not yet available.

There seems to be a problem when removing monoliths from the message
system. When a monolith is killed it should send a message to
all processes that have previously talked to it via the messaging
system so that the communications are shut down cleanly. In the \perl\
implementation a segmentation fault occurs when attempting to talk
to a monolith that has been contacted before, but has since died.
This may be related to the fact that the \perl\ interface is not
listening to messages at all times (no event loop). Currently, the
only solution is to create a new \perl\ Task object with a different
name in the message system.

\section{Notice Board interface}

The Starlink::NBS module provides an interface to the Starlink
Noticeboard system (\xref{SUN/77}{sun77}{}). Additionally, it is possible
to tie the noticeboard to a \perl\ variable allowing the notice board
to be manipulated using normal \perl\ commands.

The noticeboard (NB) can be accessed using:

\begin{myquote}
\begin{verbatim}
use Starlink::NBS;

$nbs = new Starlink::NBS($nbsname);
\end{verbatim}
\end{myquote}

Once a top-level object exists, the find() method can be used to
descend the hierarchy returning new Starlink::NBS objects each time.
This means that a Starlink::NBS object can be associated with a structure
in the NB or a primitive (i.e.\ an integer, or character string).

\begin{myquote}
\begin{verbatim}
$level1 = $nbs->find(".struct1.component");
($status, @values) = $level1->get;
\end{verbatim}
\end{myquote}

In general, it is much easier (and more obvious) to tie the NB
to a \perl\ hash and then manipulate it as normal:

\begin{myquote}
\begin{verbatim}
use Data::Dumper;

tie %nb, ref($nbs), $nbs;
@values = $nb{struct1}{component};
print Dumper(\%nb); # list the Notice board
\end{verbatim}
\end{myquote}
% $

More information can be found in the Starlink::NBS man page
(\texttt{perldoc Starlink::NBS} and in the appendix of this document).


\section{HDS wrapper commands}

The Starlink::HDSPACK module provides some high level HDS manipulation
routines (cf. NDFPACK in \Kappa). Routines are provided for creating,
deleting, copying and setting the values of HDS structures and primitives. For
example:

\begin{myquote}
\begin{verbatim}
$status = copobj("file.more.fits","file1.more", $status);
$status = delobj("file.more.fits", $status);
$status = creobj("file", "NDF", $status);
$status = creobj("file.DATA_ARRAY", "ARRAY", $status);
$status = creobj("file.DATA_ARRAY.DATA", "_REAL",[20,30], $status);
$status = setobj("file.more.xxx",52.5,$status);
\end{verbatim}
\end{myquote}

To avoid confusion with \perl\ prototypes, these routines have to return
the status rather than changing the input status variable. A more perl-like
interface is available at the loss of inherited status:

\begin{myquote}
\begin{verbatim}
copy_hdsobj("file.more.fits","file1.more") or die "Oops";
create_hdsobj("file.DATA_ARRAY","ARRAY") or die "Oops2";
delete_hdsobj("file.more.fits") or die "Oops3";
set_hdsobj("file.more.xxx", 52.5) or die "Oops4";
\end{verbatim}
\end{myquote}

These are similar to the \Figaro\ \copobj, \creobj, \setobj\ and \delobj\
commands.  This module requires that the NDF module (\S\ref{ndfperl}) is
available.

A more detailed description can be found in the appendix.

\section{Starlink configuration}

Occasionally when writing or installing \perl\ programs it is desirable to
know the location of the installed Starlink tree. The Starlink::Config module
is provided for this purpose. It exports a hash (\%StarConfig) into the
current namespace. This hash contains the following keys:

\begin{description}
\item[Star] \mbox{}

    The root directory of the Starlink software
    installation.  This usually has a value of \texttt{/star}.

\item[Star\_Bin] \mbox{}

    The location for Starlink binary files. Usually in
    \texttt{/star/bin}.

\item[Star\_Inc] \mbox{}

    The location of the Starlink include files. Usually in
    \texttt{/star/include}.

\item[Star\_Lib] \mbox{}

    The location of the Starlink static libraries. Usually
    in \texttt{/star/lib}.

\item[Star\_Share] \mbox{}
    The location of Starlink shared libraries. Usually in
    \texttt{/star/share}.

\end{description}

\section{Version numbers}


When writing Perl programs that make use of Starlink applications
it is sometimes necessary to check the relevant version number
before attempting specific tasks. This module attempts to determine
the version number and returns it to the caller. It is not guaranteed
to be successful in all cases (since in some cases it is not
clear where to look for the version string) but does try a number of different
techniques before giving up.

\begin{myquote}
\begin{verbatim}
use Starlink::Versions qw/ starversion /;

($major, $minor, $patchlevel) = starversion('kappa');

$verstring = starversion_string('kappa');

print "yes" if starversion_gt('kappa', 'V0.15-2';

if (starversion('surf') gt v1.5.2) {
   ...
}
\end{verbatim}
\end{myquote}



The answer is cached such that a subsequent call will return the
precalculated answer without having to look for it. It is assumed that
a version will not change whilst this program is running!



By default no functions are imported into the users namespace unless
the function is requested explicitly. The \texttt{:Funcs} tag can be
specified to import all functions:

\begin{verbatim}
 use Starlink::Versions qw/ :Funcs /;
\end{verbatim}

The Starlink::Versions module can be used to determine the version
information of any Starlink package including libraries.

The following methods are used to determine version number.
In this example, it assumes that the caller is requesting the
version number for an application called ``prog''.

\begin{enumerate}
\item

Determine the installed directory by looking in the directory pointed
to by the environment variable \texttt{PROG\_DIR} for a file called
\texttt{version.dat}. Some applications such as POLPACK or KAPPA write
version numbers in this file. This allows the version number to be determined
directly from the \texttt{PROG\_DIR} rather than trying to determine it from
related directories (which relies on the application being properly
installed).

\item

If the previous method does not work look in directory

\begin{myquote}
\begin{verbatim}
$PROG_DIR/../../dates/
\end{verbatim}
\end{myquote} %$

or a file call \texttt{prog\_datestamp}. These files are written during a
standard Starlink install and contain package and version information.  The
file is searched for a version string.

\item

  If no environment variable \texttt{PROG\_DIR} can be found (or the directory
  does not exist), query \texttt{Starlink::Config} for the location of the
  standard Starlink directory and look in file

\begin{myquote}
\begin{verbatim}
$STARLINK/dates/prog_datestamp
\end{verbatim}
\end{myquote} %$

for a version string. The Starlink directory will not be searched if a
\texttt{PROG\_DIR} is found since there is no guarantee that we are running an
application from the standard Starlink tree (e.g. \texttt{/star} might contain
a version of \texttt{PROG} but we are using a version in a different tree).

\end{enumerate}


If these methds fail undefined values are returned. Note that
this module will not look explicitly in a Starlink install tree
unless it can not work out a directory tree to search as an alternative.

Finally, applications that do not have an application directory
or datestamp file can not have their version determined with this module.

In some cases the environment variable used to define an application
directory can not be derived directly from the application name
itself. Additionally, some date-stamp files use mixed case.

The following cases are treated specially by the module:

\begin{description}
\item[\textbf{Figaro}] \mbox{}

Figaro uses \texttt{FIG\_DIR} rather than \texttt{FIGARO\_DIR}.

\item[\textbf{StarX}] \mbox{}

The starx date-stamp file is called \texttt{starX\_datestamp}.

\item[\textbf{hdstrace}] \mbox{}

HDSTRACE uses an application directory that is not in the
standard location of \texttt{/star/bin/app/}. Rather it uses
\texttt{/star/bin}. In cases where the application dir ends in
\texttt{bin} the location of the datestamp directory is assumed
to be \texttt{../dates} rather than \texttt{../../dates}.

\end{description}

\subsection{\texttt{starversion}}

The \texttt{starversion} command is a \perl\ program that can be used in scripts
to determine version numbers.  It can return the 3 parts of the version number
(major version, minor version and patchlevel) separately or as a string of the
form "\textbf{Vm.n-p}".

If a single package is given as argument the version number is printed to the
screen with no other information allowing the output to be used in scripts.


\begin{myquote}
\begin{verbatim}
% starversion kappa
V0.15-2

% starversion -major kappa
0

% starversion -minor kappa
15

%starversion -major -minor kappa
0.15
\end{verbatim}
\end{myquote}

If more than one Starlink package is listed, version information
is printed for each along with the name of the application.

\begin{myquote}
\begin{verbatim}
% starversion kappa figaro
KAPPA:  V0.15-2
FIGARO: V5.5-1

% starversion -minor kappa figaro
KAPPA:  15
FIGARO: 5
\end{verbatim}
\end{myquote}


If a version number can not be determined, it is returned as \texttt{unknown}

\begin{myquote}
\begin{verbatim}
% starversion kappa blah
KAPPA: V0.15-5
BLAH:  UNKNOWN
\end{verbatim}
\end{myquote}

Additionally, the program can be used to compare the version of
an installed package with a supplied version number via the
\texttt{-compare} flag.

\begin{myquote}
\begin{verbatim}
% starversion -compare V0.15-2 kappa
1
\end{verbatim}
\end{myquote}

When comparing, \texttt{starversion} returns 0 if the version numbers match,
1 if the supplied version number is less than that of the installed
package and -1 if the supplied version number is greater than the
installed package.



If no application is specified, the program prints the current status
of the Starlink installation as stored in the \texttt{/star/admin/status}.
This contains the last time the system was updated.



The calling arguments are detailed in appendix \ref{starversion}.

\section{GSD}

The GSD add the ability to read \jcmt\ \gsd\ data from \perl. Since the
\gsd\ library is read only, GSD files can not be written by this module.
An interface using the C API is provided but in general it is recommended
that either the object-oriented or tied interfaces are used since these
are much simpler and hide the C API.

\begin{myquote}
\begin{verbatim}
use GSD;

$status = gsdOpenRead($file,$version,$label,$no_items,$fptr,$file_dsc,
                      $item_dsc,$data_ptr);
$status = gsdGet0c($file_dsc, $item_dsc, $data_ptr, $item, $data);
$status = gsdClose($fptr, $file_dsc, $item_dsc, $data_ptr);

$gsd = new GSD($filename);
@data = $gsd->GetByName('C13DAT');

tie %hash, 'GSD', $filename;
foreach (keys %hash) { print "$_\n";}

tie @array, 'GSD', $gsdobject;
foreach (0.. $#array) { print $array[$_],"\n";}
\end{verbatim}
\end{myquote}

Detailed information on this module can be found in appendix \ref{appgsd}.

The \texttt{gsdprint} shell command is provided to list the contents
of a GSD file to the screen. See \texttt{perldoc gsdprint} to get more
information on the calling arguments of this command.

\appendix

\section{Changes}

\subsection{New in version 1.14}

\begin{itemize}
\item Add \texttt{creobj} and \texttt{setobj} to the
  \texttt{Starlink::HDSPACK} interface.
\item Make sure we export \texttt{dat\_put0i} from the NDF module.
\item Fix compilation problem of GSD module with perl 5.8.0.
\end{itemize}

\subsection{New in version 1.13}

\begin{itemize}
\item Support EMS v2.0 (pure C). Including the addition of \texttt{emsTune}
  and \texttt{emsExpnd}. \texttt{emsFmt*} routines have been removed.
\item Fix problem in Starlink::AMS::Core with first character of parameter
  string always downcasing.
\item Fix problem in Starlink::HDSPACK when using './file' syntax. Now
  correctly return status from \texttt{\_find\_loc} function.
\end{itemize}

\subsection{New in version 1.12}

\begin{itemize}
\item The \texttt{starversion} command and Starlink::Versions module have
been added to help determine the version number of an installed Starlink
package.

\item New GSD module for reading \gsd\ format data files (the format generated
  by the \jcmt\ heterodyne instruments).

\item The NDF/perl documentation is now included in SUN/228 rather than
  SUN/222.

\item The \texttt{msg\_tune} and \texttt{err\_tune} subroutines are now
supported by the NDF module.

\item The Starlink::EMS module now exports the new format names (eg emsBegin)
  as well as the Fortran style (ems\_begin).

\item Miscellaneous module and test script cleanup.

\end{itemize}

\subsection{New in version 1.11}

\begin{itemize}
\item Include Starlink::HDSPACK for \texttt{copobj} and \texttt{delobj}
support.

\end{itemize}

\subsection{New in version 1.10}

\begin{itemize}
\item Include Starlink::NBS module.
\item Add interface to all documented routines in the EMS library.
\item Fix bug in Starlink::AMS::Init that made it impossible to redirect
standard error to a different file handle.
\item Starlink::AMS::Core now uses Proc::Simple version 1.13
\end{itemize}


\section{NDF module\label{ndfapp}}

This section lists name of each sub-system that can be imported via the
\perl\ \texttt{use} command. By default all sub-systems are loaded into the
current namespace.

\begin{description}

\item[:ndf] \mbox{}

This imports all the \texttt{NDF\_} functions for use.

\item[:msg] \mbox{}

This imports all the \texttt{MSG\_} functions.

\item[:err] \mbox{}

This imports all the Starlink error handling functions (\texttt{ERR\_}).

\item[:ary] \mbox{}

This imports some \texttt{ARY\_} functions.

\item[:hds] \mbox{}

This imports the \texttt{HDS\_} functions.

\item[:dat] \mbox{}

This imports most of the \texttt{DAT\_} functions.

\item[:cmp] \mbox{}

This imports most of the \texttt{CMP\_} functions.

\item[:misc] \mbox{}

This imports routines for converting DATA pointers to arrays and routines for
easy access to FITS arrays commonly found in NDFs. A routine for accessing
parameters stored by ADAM tasks is also available.

\end{description}

The following commands are available from the NDF module.
The command syntax for these commands can be found in the documentation
for each library (\ndf, \hds, \mers\ and \ary).

\begin{description}

\item[:ndf]%
\index{:ndf@:ndf}\mbox{}

All \texttt{ndf\_} routines are implemented except those dealing with
ADAM parameters (\emph{e.g.} \texttt{ndf\_assoc}).

\item[:ary]%
\index{:ary@:ary}\mbox{}

\begin{flushleft}
\texttt{ary\_annul} \texttt{ary\_dim} \texttt{ary\_find}
\texttt{ary\_map} \texttt{ary\_ndim} \texttt{ary\_size}
\texttt{ary\_unmap}
\end{flushleft}

\item[:msg]%
\index{:msg@:msg}\mbox{}

All \texttt{msg\_} routines are implemented:
\begin{flushleft}
\texttt{msg\_bell} \texttt{msg\_blank} \texttt{msg\_fmtc}
\texttt{msg\_fmtd} \texttt{msg\_fmti} \texttt{msg\_fmtl}
\texttt{msg\_fmtr} \texttt{msg\_iflev} \texttt{msg\_ifset}
\texttt{msg\_load} \texttt{msg\_out} \texttt{msg\_outif}
\texttt{msg\_renew} \texttt{msg\_setc} \texttt{msg\_setd}
\texttt{msg\_seti} \texttt{msg\_setl} \texttt{msg\_setr}
\end{flushleft}

\item[:err]%
\index{:err@:err}\mbox{}

All \texttt{err\_} routines are implemented:
\begin{flushleft}
\texttt{err\_annul} \texttt{err\_begin} \texttt{err\_end}
\texttt{err\_facer} \texttt{err\_fioer} \texttt{err\_flbel}
\texttt{err\_flush} \texttt{err\_level} \texttt{err\_load}
\texttt{err\_mark} \texttt{err\_rep} \texttt{err\_rlse}
\texttt{err\_stat} \texttt{err\_syser}
\end{flushleft}

\item[:hds]%
\index{:hds@:hds}\mbox{}

All \texttt{hds\_} routines are implemented:
\begin{flushleft}
\texttt{hds\_copy} \texttt{hds\_erase} \texttt{hds\_ewild}
\texttt{hds\_flush} \texttt{hds\_free} \texttt{hds\_group}
\texttt{hds\_gtune} \texttt{hds\_link} \texttt{hds\_lock}
\texttt{hds\_new} \texttt{hds\_open} \texttt{hds\_show}
\texttt{hds\_state} \texttt{hds\_stop} \texttt{hds\_trace}
\texttt{hds\_tune} \texttt{hds\_wild}
\end{flushleft}

\item[:dat]%
\index{:dat@:dat}\mbox{}

\begin{flushleft}
\texttt{dat\_alter} \texttt{dat\_annul} \texttt{dat\_basic}
\texttt{dat\_ccopy} \texttt{dat\_cctyp} \texttt{dat\_cell}
\texttt{dat\_clen} \texttt{dat\_clone} \texttt{dat\_coerc}
\texttt{dat\_copy} \texttt{dat\_drep} \texttt{dat\_erase}
\texttt{dat\_ermsg} \texttt{dat\_find} \texttt{dat\_get0c}
\texttt{dat\_get0d} \texttt{dat\_get0i} \texttt{dat\_get0l}
\texttt{dat\_get0r} \texttt{dat\_get1c} \texttt{dat\_get1d}
\texttt{dat\_get1i} \texttt{dat\_get1r} \texttt{dat\_getvc}
\texttt{dat\_getvd} \texttt{dat\_getvi} \texttt{dat\_getvr}
\texttt{dat\_index} \texttt{dat\_len} \texttt{dat\_map}
\texttt{dat\_mapc} \texttt{dat\_mapd} \texttt{dat\_mapi}
\texttt{dat\_mapl} \texttt{dat\_mapr} \texttt{dat\_mapv}
\texttt{dat\_mould} \texttt{dat\_move} \texttt{dat\_msg}
\texttt{dat\_name} \texttt{dat\_ncomp} \texttt{dat\_new}
\texttt{dat\_new0c} \texttt{dat\_new0d} \texttt{dat\_new0i}
\texttt{dat\_new0l} \texttt{dat\_new0r} \texttt{dat\_new1c}
\texttt{dat\_new1d} \texttt{dat\_new1i} \texttt{dat\_new1l}
\texttt{dat\_new1r} \texttt{dat\_newc} \texttt{dat\_paren}
\texttt{dat\_prec} \texttt{dat\_prim} \texttt{dat\_prmry}
\texttt{dat\_put0c} \texttt{dat\_put0d} \texttt{dat\_put0d}
\texttt{dat\_put0l} \texttt{dat\_put0r} \texttt{dat\_put1c}
\texttt{dat\_put1d} \texttt{dat\_put1i} \texttt{dat\_put1r}
\texttt{dat\_putd} \texttt{dat\_puti} \texttt{dat\_putr}
\texttt{dat\_putvc} \texttt{dat\_putvd} \texttt{dat\_putvi}
\texttt{dat\_putvr} \texttt{dat\_ref} \texttt{dat\_refct}
\texttt{dat\_renam} \texttt{dat\_reset} \texttt{dat\_retyp}
\texttt{dat\_shape} \texttt{dat\_size} \texttt{dat\_slice}
\texttt{dat\_state} \texttt{dat\_struc} \texttt{dat\_temp}
\texttt{dat\_there} \texttt{dat\_type} \texttt{dat\_unmap}
\texttt{dat\_valid} \texttt{dat\_vec} \texttt{dat\_where}
\texttt{dat\_put0i}
\end{flushleft}

\item[:cmp]%
\index{:cmp@:cmp}\mbox{}

\begin{flushleft}
\texttt{cmp\_get0c} \texttt{cmp\_get0d} \texttt{cmp\_get0i}
\texttt{cmp\_get0l} \texttt{cmp\_get0r} \texttt{cmp\_get1c}
\texttt{cmp\_get1d}  \texttt{cmp\_get1i} \texttt{cmp\_get1r}
\texttt{cmp\_getvc} \texttt{cmp\_getvd} \texttt{cmp\_getvi}
\texttt{cmp\_getvr} \texttt{cmp\_len} \texttt{cmp\_mapv}
\texttt{cmp\_mod}  \texttt{cmp\_modc} \texttt{cmp\_prim}
\texttt{cmp\_put0c} \texttt{cmp\_put0d} \texttt{cmp\_put0i}
\texttt{cmp\_put0l} \texttt{cmp\_put0r} \texttt{cmp\_put1c}
\texttt{cmp\_put1d} \texttt{cmp\_put1i} \texttt{cmp\_put1r}
\texttt{cmp\_putni} \texttt{cmp\_putvc} \texttt{cmp\_putvd}
\texttt{cmp\_putvi} \texttt{cmp\_putvr} \texttt{cmp\_shape}
\texttt{cmp\_size} \texttt{cmp\_struc} \texttt{cmp\_type}
\texttt{cmp\_unmap}
\end{flushleft}

\item[:misc]%
\index{:misc@:misc}\mbox{}

\begin{flushleft}
\texttt{mem2string} \texttt{string2mem} \texttt{array2mem}
\texttt{mem2array} \texttt{fits\_get\_nth\_item} \texttt{fits\_read\_header}
\texttt{fits\_get\_item} \texttt{fits\_extract\_key\_val}
\texttt{fits\_construct\_string} \texttt{par\_get}
\end{flushleft}

\end{description}


\section{ADAM interface specification}

This section describes the methods available from the Starlink::AMS::Init
and Starlink::AMS::Task modules.

\subsection{Starlink::AMS::Init}

The following methods are provided:

\begin{description}

\item[new()] \mbox{}

Create a new instance of Starlink::AMS::Init.
If a true argument is supplied the messaging system is also
initialised via the {\em init()\/} method.

\begin{myquote}
\begin{verbatim}
$ams = new Starlink::AMS::Init(1);  # Start messaging
$ams = new Starlink::AMS::Init(0);  # Delay messaging start
\end{verbatim}
\end{myquote}


\item[messages] \mbox{}

Method to set whether standard messages returned from monoliths
are printed or not. If set to true the messages are printed
else they are ignored.

\begin{myquote}
\begin{verbatim}
$current = $ams->messages;
$ams->messages(0);
\end{verbatim}
\end{myquote} %$

Default is to print all messages.

\item[errors] \mbox{}

Method to set whether error messages returned from monoliths
are printed or not. If set to true the errors are printed
else they are ignored.
\begin{myquote}
\begin{verbatim}
$current = $ams->errors;
$ams->errors(0);
\end{verbatim}
\end{myquote} %$

Default is to print all messages.

\item[timeout] \mbox{}

Set or retrieve the timeout (in seconds) for some of the ADAM messages.
Default is 30 seconds.
\begin{myquote}
\begin{verbatim}
$ams->timeout(10);
$current = $ams->timeout;
\end{verbatim}
\end{myquote} %$

\item[stderr] \mbox{}

Set and retrieve the current filehandle to be used for printing
error messages. Default is to use STDERR.

\item[stderr] \mbox{}

Set and retrieve the current filehandle to be used for printing
normal ADAM messages. Default is to use STDOUT.

\item[paramrep] \mbox{}

Set and retrieve the code reference that will be executed if
the parameter system needs to ask for a parameter.
Default behaviour is to call a routine that simply prompts
the user for the required value. The supplied subroutine
should accept three arguments (the parameter name, prompt string and
default value) and should return the required value.
\begin{myquote}
\begin{verbatim}
$self->paramrep(\&mysub);
\end{verbatim}
\end{myquote} %$

A simple check is made to make sure that the supplied argument
is a code reference.

Warning: It is possible to get into an infinite loop if you try
to continually return an unacceptable answer.

\item[init] \mbox{}

Initialises the ADAM messaging system. This routine should always be
called before attempting to control I-tasks.

A relay task is spawned in order to test that the messaging system
is functioning correctly. The relay itself is not necessary for the
non-event loop implementation. If this command hangs then it is
likely that the messaging system is not running correctly (eg
because the system was shutdown uncleanly --- try removing named pipes
from the $\tilde{\hspace{0.4em}}$/adam directory).

Starlink Status is returned.

\item[shutdown] \mbox{}

This method forces the Adam messaging system to be shutdown.
(It runs the adamtask\_exit routine in Starlink::AMS::Core).

Returns the status.

\end{description}

The messaging interface is automatically shutdown when the \perl\ process is
exited.

\subsection{Starlink::AMS::Task}

The methods provided by this class are:

\begin{description}

\item[new()] \mbox{}

Create a new instance of a Starlink::AMS::Task object.
\begin{myquote}
\begin{verbatim}
$obj = new Starlink::AMS::Task;
$obj = new Starlink::AMS::Task("name_in_message_system","monolith");
\end{verbatim}
\end{myquote}

If supplied with arguments (matching those expected by {\em load()\/} ) the
specified task will be loaded upon creating the object. If the {\em load()\/}
fails then undef is returned (which will not be an object reference).

\item[name] \mbox{}

The name used by the messaging system to contact the monolith.
Can be used to set or retrieve the value of name (do not set
this value from outside unless you know that a path to the
new name exists in the messaging system).
\begin{myquote}
\begin{verbatim}
$name = $obj->name;
$name = $obj->name("name")
\end{verbatim}
\end{myquote}

\item[pid] \mbox{}

Returns the process object (derived from a Proc::Simple object)
of the monolith if the monolith was started by this object.
This can be used to query the process ID and to check that
the process associated with the monolith still exists.
\begin{myquote}
\begin{verbatim}
$proc = $obj->pid;
\end{verbatim}
\end{myquote}

\item[tasktype] \mbox{}

Return or set the type of task associated with the object.
Should be either 'A' or 'I'.
\begin{myquote}
\begin{verbatim}
$task->tasktype('A');
\end{verbatim}
\end{myquote}  %$

\item[monolith] \mbox{}

Returns or sets the name of the monolith (not including path).
This is obtained by looking at the second argument to the
load method and is required for A-tasks when performing a parameter
get.

\item[adamdir] \mbox{}

Retrieve the current value of \$ADAM\_{}USER. If not defined the
value of \$ADAM\_{}USER is stored --- this method is used to store the
value of \$ADAM\_{}USER at load time so that the location of any
adam parameter file can be found (for A-tasks).

\item[DESTROY] \mbox{}

Destructor for this object. When the last reference to this
object is removed the destructor is executed automatically.
In this case the monolith attached to object is killed
unless it is already {\em dead\/}(!) or it has been forgotten
via the {\em forget()\/} method.

\item[load] \mbox{}

Load a monolith and set up the name in the messaging system.
This task is called by the 'new' method.
\begin{myquote}
\begin{verbatim}
$status = $obj->load("name","monolith_binary",{ TASKTYPE => 'A' });
\end{verbatim}
\end{myquote}

If the second argument is omitted it is assumed that the binary
is already running and can be called by "name".

The last argument, if needed, is a reference to a hash containing
the load options.

Options currently supported are:
\begin{myquote}
\begin{verbatim}
TASKTYPE => 'A' for A-task, 'I' for I-task.
MONOLITH => monolith name to be used for A-task parameter retrieval
\end{verbatim}
\end{myquote}

Default is to launch an A-task. Default task type when no monolith
or options are specified is `I'.

The MONOLITH option can be used to configure A-tasks such that
they can retrieve parameters from monoliths that were not started by this
object. (It is identical to creating the object and then setting the
monolith name via the {\em monolith()\/} method)

If a path to a binary with name "name" already exists then the monolith
is not loaded.

\item[obeyw] \mbox{}

Send an obey to a task and wait for a completion message
\begin{myquote}
\begin{verbatim}
$status = $obj->obeyw("action","params");
\end{verbatim}
\end{myquote}

\item[get] \mbox{}

Obtain the value of a parameter from a task.
When called from an array context the status and values are returned
(multiple values are returned in an array). When called from a scalar
context the values are returned as a single string joined by commas.

\begin{myquote}
\begin{verbatim}
($status, @values) = $obj->get("task","param");
\end{verbatim}
\end{myquote}
or
\begin{myquote}
\begin{verbatim}
$value = $obj->get("task","param");
\end{verbatim}
\end{myquote}

If the monolith has been started as an A-task the adam messaging
system can not be used to retrieve the parameter value. Instead,
the par\_{}get routine from the \perl\ NDF module (\S\ref{ndfperl}) is invoked.

\item[set] \mbox{}


Set the value of a parameter in an I-task.
\begin{myquote}
\begin{verbatim}
$status = $obj->set("action","param","value");
\end{verbatim}
\end{myquote}

This routine has no effect in A-tasks.

\item[control] \mbox{}

Send control messages to a monolith.
\begin{myquote}
\begin{verbatim}
$obj->control("par_reset");
($value, $status)  = $obj->control("default","dir");
\end{verbatim}
\end{myquote} %$

\item[forget] \mbox{}

Remove the monolith name from the list of known monoliths.
This method prevents the monolith from being killed when adam
exits or when the object is destroyed.

This routine has no input arguments.

\item[contact] \mbox{}

This method can be used to determine whether the object can
contact a monolith. Returns a 1 if we can contact a monolith and
a zero if we cant.

\item[contactw] \mbox{}

This method will not return unless the monolith can be contacted.
It only returns with a timeout. Returns a '1' if we contacted okay
and a '0' if we timed out. It will timeout if it takes longer than
specified in Starlink::AMS::Init-$>$timeout.

\end{description}

\section{Starlink::NBS interface specification}

\subsection{Methods}

\subsubsection*{Constructors}%
\index{Constructors}

\begin{description}

\item[new] \mbox{}

Create a new instance of a Starlink::NBS object.
Only used directly to access the top level of the noticeboard
\begin{myquote}
\begin{verbatim}
$nbs_id  = new Starlink::NBS("nbsname");
\end{verbatim}
\end{myquote} % $

The {\em loadnbs()\/} method is invoked with the supplied argument.

\end{description}

\subsubsection*{Accessor Methods}

These methods are for accessing the "instance" data.
With arguments they set the value, without arguments they
retrieve the current value.

\begin{description}

\item[path] \mbox{}

Full path (name) to the item associated with this object
including the name of the noticeboard.

\item[id] \mbox{}

ID of the shared memory area.

\item[pos] \mbox{}


Position in structure.

\item[rootid] \mbox{}

ID of the actual noticeboard.

\item[top] \mbox{}

True if this is a top-level object. False otherwise.

\item[status] \mbox{}

Contains the current status associated with the object. Status from
each method call is placed in here (and usually returned with each
command). Methods will not do anything if the stored status is not
good. This behaves as an inherited status without having to pass
the status into the methods explicitly.

\item[debug] \mbox{}

Turns debugging on or off. Default is off.

\item[nchilds] \mbox{}

Returns the number of children associated with the current object.
Can not be set externally.

\end{description}

\subsubsection*{General Methods}%
\index{General Methods}

\begin{description}

\item[isokay] \mbox{}

Method that simply returns whether status is acceptable (SAI\_{}\_{}OK)
or not. If everything is okay return 1, else return 0.

\item[loadnbs] \mbox{}

Method to load a top level noticeboard

\item[type] \mbox{}

Find the storage type of an object
\begin{myquote}
\begin{verbatim}
Arguments: None (but uses the current status of the object)
Returns:  ($type, $status)
\end{verbatim}
\end{myquote}

\item[primitive] \mbox{}

Determines whether the object is a primitive
\begin{myquote}
\begin{verbatim}
Arguments: None (but uses the current status of the object)
Returns:  ($prim, $status)
$prim is 1 if it is a primitive, 0 otherwise (including if status
is bad).
\end{verbatim}
\end{myquote} %$

\item[name] \mbox{}

Find the name of the object
\begin{myquote}
\begin{verbatim}
Arguments:  None (but uses the current status of the object)
Returns:  ($name, $status)
\end{verbatim}
\end{myquote}

\item[size] \mbox{}

Find the size of the item
\begin{myquote}
\begin{verbatim}
Arguments: None (but uses the current status of the object)
Returns: ($size, $maxsize, $status)
\end{verbatim}
\end{myquote} %$

Returns status = NBS\_{}\_{}NOTPRIMITIVE if the object is not a primitive.
Returns status = NBS\_{}\_{}NILID  if the object is not defined

The returned size is the number of entries that can be contained.
(ie not bytes unless a \_{}CHAR) and depends on the type of the object.

\item[nth\_{}name(num)] \mbox{}

Return the name of the nth component in the objects structure.
\begin{myquote}
\begin{verbatim}
Arguments: number
Return:    name
\end{verbatim}
\end{myquote}

\item[find] \mbox{}

Find an item in a noticeboard. The full path name must be given.
The item must exist below the current object.
\begin{myquote}
\begin{verbatim}
Arguments: Full name of object (separated by dots)
           An object relative to the current object can be
           given if it starts with a '.'
\end{verbatim}
\end{myquote}

Returns an object blessed into {\tt Starlink::NBS} class.

\item[get] \mbox{}

Get the item corresponding to the current object.
Must be a primitive object
\begin{myquote}
\begin{verbatim}
Arguments: None (uses current status of object)
Returns:   Status and The values (in array context)
           ($status, @values)
\end{verbatim}
\end{myquote} %$

\item[put] \mbox{}

Put values into the object
\begin{myquote}
\begin{verbatim}
Arguments: Values (however many values are supported)
Returns:  Status
\end{verbatim}
\end{myquote}

\item[poke(item, val)] \mbox{}

Set the value of item to 'val'.
This is the equivalent of a {\em find()\/} followed by a {\em put()\/}.
\begin{myquote}
\begin{verbatim}
$nbs->poke(".port_0.display_data", 'IMAGE');
\end{verbatim}
\end{myquote} %$

Status of the {\em put()\/} is returned.

\item[peek(item)] \mbox{}

Return the value stored in item. This is the equivalent of a {\em find()\/}
followed by a {\em get()\/}
\begin{myquote}
\begin{verbatim}
($value) = $nbs->peek(".port_0.display_data");
\end{verbatim}
\end{myquote}

\texttt{undef} is returned if bad status is encountered.
The values are returned in an array context.

\end{description}

\subsection{Tied interface}%
\index{TIE}

Scalar values in the noticeboard can be tied to scalar \perl\ variables
using the \perl\ {\em tie()\/} function.
\begin{myquote}
\begin{verbatim}
$what = $Nbs->find("primitive.object");
tie ($object, ref($what), $what);
\end{verbatim}
\end{myquote} %$

Now \$object will automatically reflect the value in the notice board
associated with primitive.object. Note that this only works for
primitives (not structures).

Noticeboard structures can be tied to \perl\ hashes also:
\begin{myquote}
\begin{verbatim}
$what = $Nbs->find("structure");
tie (%hash, ref($what), $what);
\end{verbatim}
\end{myquote}

Now \%hash can be used to update the entire noticeboard structure.
Note that keys are always assumed to be relative to the
tied object --- in effect this means that a '.' is automatically
prepended to all keys if one is not found. (see {\em find()\/}
for more information on relative addressing).

Note that ties can be broken by using simple copies.
For example, for
\begin{myquote}
\begin{verbatim}
%new = %hash
\end{verbatim}
\end{myquote}

\%new will not be tied even though \%hash was.

It is possible to tie a hash to the top-level noticeboard structure
and to access lower levels of the noticeboard entirely using the
tie. For example, a simple way to list the noticeboard contents
is to tie a hash to the top level and then use Data::Dumper to
list the hash.
\begin{myquote}
\begin{verbatim}
use Starlink::NBS;
use Data::Dumper;

$nbs = new Starlink::NBS($nbsname);
tie %hash, ref($nbs), $nbs;

print Dumper(\%hash);
\end{verbatim}
\end{myquote}

A method is supplied for tieing NBS objects to variables:

\begin{description}

\item[tienbs] \mbox{}

Tie a Starlink::NBS object to a \perl\ variable. No arguments.  If the
object points to a structure a reference to a \perl\ hash is returned.
If the object points to a primitive a reference to a \perl\ scalar is
returned.

\end{description}

\subsection{Non-methods}%
\index{NON-METHODS}

In addition to the OO implementation. Direct hooks to the NBS library
can be accessed. They can be imported into your global namespace by
using:
\begin{myquote}
\begin{verbatim}
use Starlink::NBS qw/:nbslib/;
\end{verbatim}
\end{myquote}

The available commands are:
\begin{myquote}
\begin{verbatim}
nbs_find_item(envid, name, id, status)
nbs_find_noticeboard( noticeboard, topid, status)
nbs_find_nth_item(envid, posn, id, status)
nbs_get_children(id, children, status)
nbs_get_info(id, name, value, status)
nbs_get_name(id, name, status)
nbs_get_primitive(id, primitive, status)
nbs_get_shape(id, maxdims, dims, actdims, status)
nbs_get_size(id, maxbytes, actbytes, status)
nbs_get_type(id, type, status)
nbs_get_updated(id, updated, status)
nbs_get_value_c(id, $cvalue, status)
nbs_get_value_d(id, \@values, status)
nbs_get_value_f(id, \@values, status)
nbs_get_value_i(id, \@values, status)
nbs_get_value_l(id, \@values, status)
nbs_lose_item(id, option, status)
nbs_lose_noticeboard(id, option, status)
nbs_put_value_c(id, $string, status)
nbs_put_value_d(id, nvals, \@values, status)
nbs_put_value_f(id, nvals, \@values, status)
nbs_put_value_i(id, nvals, \@values, status)
nbs_put_value_l(id, nvals, \@values, status)
nbs_tune(name, value, oldvalue, status)
nbs_tune_noticeboard(id, name, value, oldvalue, status)
nbs_begin_definition(id, status)
nbs_define_structure(envsid, name, type, sid, status)
nbs_define_primitive(envsid, name, type, maxdims, maxbytes, sid, status)
nbs_define_shape(sid, ndims, dims, status)
nbs_end_definition(name, option, status)
nbs_restore_definition(name, save_name, status)
nbs_restore_noticeboard(name, save_name, status)
nbs_save_noticeboard(id, status)
\end{verbatim}
\end{myquote}

Note that nbs\_{}get\_{} and nbs\_{}put\_{} require a separate routine for each
type. Additionally, the get and set routines expect array arguments.

\section{Starlink::HDSPACK interface specification}%
\index{HDSPACK.PM}

This module provides wrapper routines for common HDS manipulations.
Functions are provided for copying data structures between locations
and for deleting structures.

Two interfaces are provided. The first mirrors the \Figaro\ routines
\copobj, \creobj, \setobj\ and \delobj\ and use Starlink inherited status.
The more verbose functions provide wrappers that assume good status
on input and return perl status (either true or false).

\section{Functions}

The following functions provide the core functionality without worrying
about the Starlink environment.

\begin{description}

\item[\textbf{create\_hdsobj}] \mbox{}

Create a HDS object within an HDS structure.

\begin{verbatim}
  create_hdsobj( $path, $type, \@dims );
\end{verbatim}
\begin{verbatim}
  create_hdsobj( $path, $type );
\end{verbatim}


Returns 1 if successful, false otherwise. See \texttt{creobj}
for more details on the arguments.


\item[\textbf{set\_hdsobj}] \mbox{}

Set the value of an HDS object within an HDS structure.

\begin{verbatim}
  set_hdsobj( $path, $value );
\end{verbatim}


Returns 1 if successful, false otherwise. See \texttt{setobj}
for more details on the arguments.



Scalar values can be stored in scalar items and individual
elements of a data array can be addressed using parentheses:

\begin{verbatim}
 set_hdsobj("file.data_array(5,5)", 52);
\end{verbatim}


Array values can be supplied in vectorized form by using a reference
to an array. Note that an error will be raised if the number of
elements in the array does not match the number of elements in the HDS
object \textit{or} if the values overflow the underlying type.


\item[\textbf{delete\_hdsobj}] \mbox{}

Delete an HDS object from an HDS file.

\begin{verbatim}
  delete_hdsobj( $path );
\end{verbatim}


Returns 1 if successful, false otherwise. See \texttt{delobj}
for more details on the arguments.


\item[\textbf{copy\_hdsobj}] \mbox{}

Copy an HDS structure from one location to another.

\begin{verbatim}
  copy_hdsobj( $source, $destination );
\end{verbatim}


Returns 1 if successful, false otherwise. See \texttt{copobj}
for more details on the arguments.

\end{description}
\subsection*{Starlink status\label{Starlink_status}\index{Starlink status}}


The following functions are available using Starlink inherited status:

\begin{description}

\item[\textbf{retrieve\_locs}] \mbox{}

Given a full path to a HDS structure, returns an array of
locators corresponding to each structure referenced in the path.

\begin{verbatim}
  ($status, @locators) = retrieve_locs("file.more.fits", $mode, $status);
\end{verbatim}


The mode argument specifies the file access type. Can be 'READ', 'WRITE'
or 'UPDATE'.



In the above example, \texttt{@locators} would contain three entries,
a locator to the file itself, a locator to the \texttt{more} structure
and a locator to the \texttt{fits} component.



Bad status is returned if the named components do not exist or cannot
be opened.



This routine assumes we are in a valid error context (eg err\_begin()
has been called).



The locators returned by this routine must be annulled by the caller.


\item[\textbf{copobj}] \mbox{}

Copy an HDS object to a specified output structure.

\begin{verbatim}
  $status = copobj("file.more.fits", "file2.more.fits2", $status);
\end{verbatim}


The above example will copy the FITS component from \texttt{file.sdf} to
the \texttt{FITS2} extension of \texttt{file2.sdf}. If the target structure
already exists it is overwritten.



This routine assumes we are in a valid error context (eg err\_begin()
has been called).


\item[\textbf{setobj}] \mbox{}

Set the value of the named HDS object.

\begin{verbatim}
 $status = setobj("file.xxx", "hello");
 $status = setobj("file.more.fits", \@fits);
\end{verbatim}


Scalar values can be stored in scalar items and individual
elements of a data array can be addressed using parentheses:

\begin{verbatim}
 $status = setobj("file.data_array(5,5)", 52, $status);
\end{verbatim}


Array values can be supplied in vectorized form by using a reference
to an array. Note that an error will be raised if the number of
elements in the array does not match the number of elements in the HDS
object \textit{or} if the values overflow the underlying type.



The HDS object must refer to an HDS structure and not simply a root filename.



This routine assumes we are in a valid error context (eg err\_begin()
has been called).


\item[\textbf{delobj}] \mbox{}

Delete the named object structure.

\begin{verbatim}
  $status = delobj("file.more.fits", $status);
\end{verbatim}


This example will remove the FITS extension from \texttt{file.sdf}.



This routine assumes we are in a valid error context (eg err\_begin()
has been called).


\item[\textbf{creobj}] \mbox{}

Create a new HDS object, structure orprimitive, scalar or array.
Generally used to tweak data structures.

\begin{verbatim}
  $status = creobj( $object, $type, \@dims, $status );
\end{verbatim}


Where \texttt{\$object} is the name of the object to be created including
a full HDS path. Anything before the first dot is assumed to be
a filename specification (directory specification is allowed) and
everything after the first do is assumed to be a HDS hierarchy.
The entire hierarchy must exist except for the last element.



The second argument is the HDS type of the new object. Values such
as '\_REAL', '\_INTEGER' are treated as primitive types, all other
values are treated as structures (e.g. 'NDF'). Note that a character
string must be specified with its expected length if you wish
it to be presized (e.g. '\_CHAR' would create a single character
whereas '\_CHAR*15' would create space for 15 characters).



The third (optional) argument specfiies the dimensions of the new
object supplied as a reference to an array. If no argument is
specified the object is assumed to be a scalar (dims=0).



The last argument must be Starlink status.

\begin{verbatim}
  $status = creobj("file", "NDF", $status);
\end{verbatim}


Creates a file on disk of type "NDF".

\begin{verbatim}
  $status = creobj("file.DATA_ARRAY", 'ARRAY', $status);
\end{verbatim}


Creates a DATA\_ARRAY structure of type "ARRAY".

\begin{verbatim}
  $status = creobj("file.DATA_ARRAY.DATA", '_REAL', [20,30],
                   $status);
\end{verbatim}


Creates a REAL array of dimension 20x30 called 'DATA'.



Accepts and returns Starlink status. This routine assumes we are in a
valid error context (eg err\_begin() has been called).



Attempting to create entire NDFs using this routine is not recommended.

\end{description}

\section{Starlink::Versions\label{Starlink::Versions}\index{Starlink::Versions}}


The following functions are provided by the Starlink::Versions module:

\begin{description}

\item[starversion] \mbox{}

Given a Starlink application name returns the major, minor and
patchlevel version numbers.

\begin{myquote}
\begin{verbatim}
($major, $minor, $patchlevel) = starversion( 'prog' );
\end{verbatim}
\end{myquote} %$ %


Starting with Perl version 5.6.0, a \perl\ version string is returned
when \texttt{starversion} is called in a scalar context. This allows
versions to be compared directly using Perl.

\begin{myquote}
\begin{verbatim}
$version = starversion( 'prog' );
print "yes" if $version gt v0.15.2;
\end{verbatim}
\end{myquote}

Returns undef if a version number can not be determined.

\item[starversion\_string] \mbox{}

Returns the version string rather than the individual components.

\begin{myquote}
\begin{verbatim}
$string = starversion_string( 'prog' );
\end{verbatim}
\end{myquote} %$

The string will be of the form \texttt{Vm.n-p}. \texttt{undef} is returned
if a version can not be determined.

\item[starversion\_major] \mbox{}

Returns the major version number. Returns \texttt{undef} if a version
can not be determined.

\begin{myquote}
\begin{verbatim}
$major = starversion_major( 'prog' );
\end{verbatim}
\end{myquote} %$

\item[starversion\_minor] \mbox{}

Returns the minor version number. Returns \texttt{undef} if a version
can not be determined.

\begin{myquote}
\begin{verbatim}
$major = starversion_minor( 'prog' );
\end{verbatim}
\end{myquote} %$

\item[starversion\_patchlevel] \mbox{}

Returns the patchlevel number. Returns \texttt{undef} if a version
can not be determined.

\begin{myquote}
\begin{verbatim}
$patch = starversion_patchlevel( 'prog' );
\end{verbatim}
\end{myquote} %$

\item[starversion\_cmp] \mbox{}

  Can be used to compare the version number of a package with a supplied
  version number. Returns -1 if the supplied version is greater than that of
  the installed package (the installed package is older), 0 if it is the same,
  and 1 if it is less than that of the package (the installed package is
  newer).

\begin{myquote}
\begin{verbatim}
$cmp = starversion_cmp('prog','V0.15-3');
\end{verbatim}
\end{myquote} %$

The version string format should be one of:

\begin{myquote}
\begin{verbatim}
V1.2-3
V1.2.3
1.2-3
\end{verbatim}
\end{myquote}

\texttt{undef} is returned if a comparison could not be made due to
either the application having no version number or if the
supplied version string could not be parsed.



In \perl\ 5.6.0 this affect can be achieved directly using
the \texttt{starversion} command in a scalar context with a string literal
(but not with a standard Starlink version string):

\begin{myquote}
\begin{verbatim}
$cmp = starversion('prog') cmp v0.15.4;
\end{verbatim}
\end{myquote} %$

\item[starversion\_lt] \mbox{}

  Test whether the version of the installed package is less than a supplied
  version number. In other words, whether the installed package is older than
  the requested version.

\begin{myquote}
\begin{verbatim}
if ( starversion_lt('kappa', '0.15-2' ) {
  ...
}
\end{verbatim}
\end{myquote}

The version string format is described in the description of
\texttt{starversion\_cmp}



In \perl\ 5.6.0 this command can be implemented directly using a string literal:

\begin{myquote}
\begin{verbatim}
if ( starversion('prog') lt v0.15.2 ) {
  ...
}
\end{verbatim}
\end{myquote}

\item[starversion\_le] \mbox{}

Test whether the version of the installed package is less than
or equal to a supplied version number. In other words, whether the installed
package is newer than or same as the requested version.

\begin{myquote}
\begin{verbatim}
if ( starversion_le('kappa', '0.15-2' ) {
  ...
}
\end{verbatim}
\end{myquote}

The version string format is described in the description of
\texttt{starversion\_cmp}



In \perl\ 5.6.0 this command can be implemented directly using a
string literal:

\begin{myquote}
\begin{verbatim}
if ( starversion('prog') le v0.15.2 ) {
  ...
}
\end{verbatim}
\end{myquote}

\item[starversion\_eq] \mbox{}

Test whether the version of the installed package is equal to a supplied
version number. In other words, whether the installed package is older the
same version as that specified.

\begin{myquote}
\begin{verbatim}
if ( starversion_eq('kappa', '0.15-2' ) {
  ...
}
\end{verbatim}
\end{myquote}

The version string format is described in the description of
\texttt{starversion\_cmp}



In \perl\ 5.6.0 this command can be implemented directly using a string literal:

\begin{myquote}
\begin{verbatim}
if ( starversion('prog') eq v0.15.2 ) {
  ...
}
\end{verbatim}
\end{myquote}

\item[starversion\_gt] \mbox{}

Test whether the version of the installed package is greater than
a supplied version number. In other words, whether the installed
package is newer than the requested version.

\begin{myquote}
\begin{verbatim}
if ( starversion_gt('kappa', '0.15-2' ) {
  ...
}
\end{verbatim}
\end{myquote}

The version string format is described in the description of
\texttt{starversion\_cmp}



In \perl\ 5.6.0 this command can be implemented directly using a
string literal:

\begin{myquote}
\begin{verbatim}
if ( starversion('prog') gt v0.15.2 ) {
  ...
}
\end{verbatim}
\end{myquote}

\item[starversion\_ge] \mbox{}

Test whether the version of the installed package is greater than
or equal to a supplied version number. In other words, whether the installed
package is newer than or same as the requested version.

\begin{myquote}
\begin{verbatim}
if ( starversion_ge('kappa', '0.15-2' ) {
  ...
}
\end{verbatim}
\end{myquote}

The version string format is described in the description of
\texttt{starversion\_cmp}



In \perl\ 5.6.0 this command can be implemented directly using a
string literal:

\begin{myquote}
\begin{verbatim}
if ( starversion('prog') ge v0.15.2 ) {
  ...
}
\end{verbatim}
\end{myquote}

\end{description}

\subsection{\texttt{starversion} arguments\label{starversion}}

The following arguments are supported.

\begin{description}
\item[\textbf{-major}] \mbox{}

Print the major version number only. Can be used in conjunction with
\textbf{-minor} in order to print the first part of the version number.
Overrides the use of \textbf{-patchlevel}.

\item[\textbf{-minor}] \mbox{}

Return the minor version number only. Can be used in conjunction
with \textbf{-major} in order to print the first part of the version number.
Overrides the use of \textbf{-patchlevel}.

\item[\textbf{-patchlevel}] \mbox{}

Return the patchlevel only. Can not be used in conjunction with
\textbf{-major} or \textbf{-minor}.

\item[\textbf{-all}] \mbox{}

List version numbers for all packages listed in \texttt{\$STARLINK/dates}.
This overrides any list of packages supplied on the command-line.

\item[\textbf{-compare}] \mbox{}

Compare the supplied version string with that of a package.

\begin{myquote}
\begin{verbatim}
% starversion -compare V1.2-3 figaro
\end{verbatim}
\end{myquote}

When comparing, \texttt{starversion} returns 0 if the version numbers match,
1 if the supplied version number is less than that of the installed
package and -1 if the supplied version number is greater than the
installed package.

The version string format can be one of:

\begin{myquote}
\begin{verbatim}
V1.2-3
V1.2.3
1.2-3
\end{verbatim}
\end{myquote}

The 'V' can be upper or lower case.

\item[\textbf{-help}] \mbox{}

Print a help message.

\item[\textbf{-man}] \mbox{}

This documentation.

\item[\textbf{-version}] \mbox{}

Version number of \texttt{starversion}.

\end{description}

\section{GSD interface specification\label{appgsd}}

This section describes in detail the programming interface provided
by the perl GSD module.

\subsection{Library interface\label{LIBRARY_INTERFACE}\index{LIBRARY INTERFACE}}

The following library calls (as documented in SUN/229) are implemented
directly in the \perl\ interface:

\begin{description}
\item[File inquiry] \mbox{}

gsdOpenRead gsdClose gsdFind gsdItem gsdInqSize

\item[Scalar access] \mbox{}

gsdGet0d gsdGet0r gsdGet0i gsdGet0l gsdGet0c gsdGet0b gsdGet0w

\item[Array access] \mbox{}

gsdGet1d gsdGet1r gsdGet1i gsdGet1c

\item[Array access via string] \mbox{}

gsdGet1dp gsdGet1rp gsdGet1ip

\end{description}


Commands that return or require arrays must pass in a reference
to an array:

\begin{verbatim}
  gsdInqSize($file_dsc, $item_dsc, $data_ptr, $i, \@dimnm, \@dimunt,
             \@dimvals, $actdims, $size);
\end{verbatim}


Note also that the \texttt{gsdInqSize} subroutine does not require
a value for MAXDIMS since the \perl\ interface allows for the maximum
size automatically. The \texttt{gsdGet1x} functions return a vectorised
array rather than an N-D array.

\subsection{Object oriented interface\label{OBJECT_ORIENTED_INTERFACE}\index{OBJECT ORIENTED INTERFACE}}

An OO interface is provided. This can be used to hide
the GSD layer from the user.

\subsubsection*{Constructors\label{Constructors}\index{Constructors}}\begin{description}
\item[\textbf{new}] \mbox{}

Constructor. Takes a GSD filename as argument. Returns undef
on error.

\begin{myquote}
\begin{verbatim}
$gsd = new GSD("obs_das_0015.dat");
\end{verbatim}
\end{myquote} %$

\end{description}
\subsubsection*{Accessors\label{Accessors}\index{Accessors}}

Accessor methods are provided for some of the GSD file
information. Public access to the file descriptor, item descriptor
and data pointer are not provided.

\begin{description}
\item[\textbf{label}] \mbox{}

Returns the label of the GSD file.

\begin{myquote}
\begin{verbatim}
$version = $gsd->label;
\end{verbatim}
\end{myquote}

\item[\textbf{nitems}] \mbox{}

Returns the number of items stored in the GSD file.

\begin{myquote}
\begin{verbatim}
$version = $gsd->nitems;
\end{verbatim}
\end{myquote}

\item[\textbf{version}] \mbox{}

Returns the version number of the GSD file.

\begin{myquote}
\begin{verbatim}
$version = $gsd->version;
\end{verbatim}
\end{myquote}


\end{description}

\subsubsection{Simplified Library Methods\label{Simplified_Library_Methods}\index{Simplified Library Methods}}

This section describes simplified forms of the standard library
functions since you are meant to be writing Perl and not knowing
how C works. These methods hide the use of the item and file
descriptors and provide explicit return values.

\begin{description}
\item[\textbf{Find}] \mbox{}

Find the GSD item number by name.

\begin{myquote}
\begin{verbatim}
($itemno, $units, $type, $array) = $gsd->Find($name);
\end{verbatim}
\end{myquote}

Returns \texttt{undef} on error (technically 4 \texttt{undefs}).
In a scalar context, simply returns the item number.

\begin{myquote}
\begin{verbatim}
$itemno = $gsd->Find($name);
\end{verbatim}
\end{myquote} %$

Spaces are stripped from the end of the units string.

\item[\textbf{Get0x}] \mbox{}

All the \texttt{gsdGet0x} commands are available as methods of the following
form:

\begin{myquote}
\begin{verbatim}
  $data = $gsd->Get0x($itemno);
\end{verbatim}
\end{myquote} %$

Returns \texttt{undef} if an error occurred.

\item[\textbf{Get1x}] \mbox{}

  All the \texttt{gsdGet0x} commands are available as methods of the following
  form:

\begin{myquote}
\begin{verbatim}
@data = $gsd->Get1x($itemno, \@dimvals, \@start, \@end);
\end{verbatim}
\end{myquote} %$


Note that this routine does not require that the number of dimensions for
dimvals is given (this is known to \perl) or the number of values returned to
the user (you can simply find the size of the array).  \texttt{@dimvals} is an
array reflecting the required shape of the array which is to be sliced by
\texttt{@start} and \texttt{@end}. This does not necessarily have to match the
actual shape of the array item, allowing you to extract arbritrary slices by
modifying the dimensionality. It is assumed that the product of
\texttt{@dimvals} is not greater than the size of the GSD item (although this
is not checked!).



In addition, if only a single start and end position are required
they can be supplied as scalars

\begin{myquote}
\begin{verbatim}
@data = $gsd->Get1x($itemno, $size, 1, $size);
\end{verbatim}
\end{myquote}

Returns undef if an error occurred.

\item[\textbf{Item}] \mbox{}

Return the GSD item by number.

\begin{myquote}
\begin{verbatim}
($name, $units, $type, $array) = $gsd->Find($itemno);
\end{verbatim}
\end{myquote}

Returns undef on error (technically 4 undefs).
In a scalar context, simply returns the item name.

\begin{myquote}
\begin{verbatim}
$name = $gsd->Find($itemno);
\end{verbatim}
\end{myquote} %$

Trailing spaces are stripped from the end of the strings (since the
GSD library itself pads the string).

\item[\textbf{InqSize}] \mbox{}

Inquire the array size. Does not work on scalar items.

\begin{myquote}
\begin{verbatim}
 ($dimnm, $dimunt, $dimvals, $size) = $gsd->InqSize($itemno);
\end{verbatim}
\end{myquote}

This methods returns references to 3 arrays containing the
names of each dimension, the units of each dimension and the
size of each dimensions. The number of dimensions can be
retrieved simply by counting the number of entries in the
arrays. The total size of the array is returned for convenience
even though that is simply the product of \texttt{dimvals}.

Trailing spaces are stripped from strings.

\texttt{undef} (times 4) is returned on error.

\item[\textbf{DESTROY}] \mbox{}

Automatic destructor. This tidies up the object and frees
memory when the object goes out of scope. It is not
necessary to run this method explicitly.

This methods runs \texttt{gsdClose} so that the user does not
need to.

\end{description}

\subsubsection{Wrapper Methods\label{Wrapper_Methods}\index{Wrapper Methods}}

This section describes commands that are used to simplify GSD
access such that the data can be retrieved by name or number without
having to know what type the item is or whether it is an array item
or not. They hide the actual GSD library calls.

\begin{description}
\item[\textbf{GetByName}] \mbox{}

Returns the contents of the GSD item from the named entry.

\begin{myquote}
\begin{verbatim}
$data = $gsd->GetByName($name);
@data = $gsd->GetByName($name);
\end{verbatim}
\end{myquote} %$

Works for array and scalar types. The data are returned in their native
precision (float, double etc).  Trailing spaces are removed when character
values are returned.

In a scalar context, array items are returned as references to arrays (unless
they happen to be PDL objects (see the \emph{GSD::PDL} manpage in which case
the PDL is returned).

Returns \texttt{undef} on error.

\item[\textbf{GetByNum}] \mbox{}

Returns the contents of a GSD item from position.

\begin{myquote}
\begin{verbatim}
@data = $gsd->GetByNum($number);
$data = $gsd->GetByNum($number);
\end{verbatim}
\end{myquote} %$

Works for array and scalar types. The data are returned in their
native precision (float, double etc).  Trailing spaces are removed
when character values are returned.

In a scalar context, array items are returned as references to
arrays (unless they happen to be PDL objects (see the \emph{GSD::PDL} manpage)
in which case the PDL is returned).

Returns \texttt{undef} on error.

\end{description}

\subsection{Tied interface\label{TIED_INTERFACE}\index{TIED INTERFACE}}

It is also possible to tie a \perl\ array or hash to a GSD file
using the \texttt{tie} command:

\begin{myquote}
\begin{verbatim}
tie %hash, 'GSD', $filename;
tie @array, 'GSD', $filename;

tie %hash, 'GSD', $gsdobj;
tie @array, ref($gsdobj), $gsdobj;

$data = $hash{'NAME'};
$data = $array[5];

foreach ( keys %hash ) { print $_,"\n" }
\end{verbatim}
\end{myquote}

These provide a simplified interface to the \texttt{GetByNum} and
\texttt{GetByName} methods. Note that the data is vectorised.



If a GSD object is provided to the tie rather than a filename it is
assumed that the array or hash should be tied to the supplied object.
This allows the tie to be used when a file or tie has already been
setup (eg setting up a tie to an array and a hash for the same GSD
file is inefficient if the GSD file has to be opened separately for
each tie).

\begin{myquote}
\begin{verbatim}
tie %hash, 'GSD';
\end{verbatim}
\end{myquote}

The object associated with the tie can be retrieved either
by storing the return value directly or by using the \texttt{tied}
function. This is useful if further information is required such
as the dimensions and the units.

Note that following Perl convention, the first element in the array
(position 0) is GSD item 1.

Also, array items are returned in an array reference since hashes
and arrays can only return scalar items.  The GSD::PDL
module can be used for the tie in order to return PDL objects
rather than \perl\ arrays.


The array and hash are readonly.



% ? End of main text
\end{document}
