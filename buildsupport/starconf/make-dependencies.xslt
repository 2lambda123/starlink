<?xml version="1.0"?>
<!DOCTYPE xsl:stylesheet SYSTEM "xslt.dtd">

<xsl:stylesheet
  version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

  <xsl:output method="text"/>

  <xsl:template match="/">
    <xsl:apply-templates/>
    <xsl:apply-templates mode="getbuildsupport"/>
    <xsl:text>
</xsl:text>
  </xsl:template>

  <xsl:template match="componentset">
    <xsl:text># This file is generated by make-dependencies.xslt.
# It must be included into another makefile, and that file should
# define the variable MANIFEST to point to the directory which
# contains the collection of manifest files, typically /star/manifests

</xsl:text>
    <xsl:apply-templates select="component"/>
  </xsl:template>

  <xsl:template match="component">
    <xsl:text>$(MANIFEST)/</xsl:text>
    <xsl:value-of select="@id"/>
    <xsl:text>: </xsl:text>
    <xsl:apply-templates select="dependencies"/>
    <xsl:text>
	cd </xsl:text>
    <xsl:apply-templates select="path"/>
    <xsl:if test='@buildsupport[.="yes"]'>
     <!--  The buildsupport attribute is "yes" if this component
           is configured and built during bootstrapping; if so, it needs
           special handling.  Specifically, have it configured at this
           point, rather than waiting to be configured as a result of
           the ./configure at the top level. -->
      <xsl:text> \
		&amp;&amp; ./configure --prefix=$${BUILDSUPPORT_PREFIX=/star/buildsupport} &gt;configure-output.log</xsl:text>
    </xsl:if>
    <xsl:text> \
		&amp;&amp; make&gt;make.log &amp;&amp; make install-manifest&gt;&gt;make.log

</xsl:text>
  </xsl:template>

  <!-- The following does approximately the right thing, but it
       doesn't sort the resulting list of dependencies, and so can't
       remove duplicates.  It's not much use, actually. -->
  <xsl:template match="dependencies">
    <xsl:apply-templates select="include"/>
  </xsl:template>

  <xsl:template match="include">
    <xsl:variable name='ref' select='normalize-space()'/>
    <xsl:text> \
		</xsl:text>
    <xsl:value-of select="$ref"/>
    <xsl:apply-templates select="id($ref)/dependencies/include"/>
  </xsl:template>

  <!-- The following is very promising, as (I think) it makes a
       result-tree fragment (RTF) containing all of the dependencies.
       However, there's a very limited set of things you can do with
       RTFs, which does not include processing them in any with with
       xsl:sort or using xsl:apply-templates.  So this is useless.
       Perhaps it's the basis for a version using XSLT version 2.
  <xsl:template match="dependencies">
    <xsl:variable name="t">
      <xsl:apply-templates select="include" mode="collect"/>
    </xsl:variable>
    <xsl:copy-of select="$t"/>
  </xsl:template>

  <xsl:template match="include" mode="collect">
    <xsl:copy-of select="."/>
    <xsl:variable name="ref" select="normalize-space()"/>
    <xsl:apply-templates select="id($ref)/dependencies/include" mode="collect"/>
  </xsl:template>

  <xsl:template match="include">
    <xsl:text>INCLUDE </xsl:text>
    <xsl:value-of select="normalize-space()"/>
  </xsl:template>
-->

  <xsl:template match="componentset" mode="getbuildsupport">
    <xsl:text>buildsupport:</xsl:text>
    <xsl:apply-templates 
      select='component[@buildsupport="yes"]'
      mode="getbuildsupport"/>
  </xsl:template>

  <xsl:template match="component" mode="getbuildsupport">
    <xsl:text> \
		$(MANIFEST)/</xsl:text>
    <xsl:value-of select="@id"/>
  </xsl:template>

</xsl:stylesheet>
