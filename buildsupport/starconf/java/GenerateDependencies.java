import org.w3c.dom.*;
import java.util.Iterator;
import java.util.Set;
import java.util.Map;
import java.util.Stack;


/**
 * Generates a Makefile fragment containing the dependencies expressed
 * in a componentinfo XML file.
 *
 * <p>Usage:
 * <pre>
 * java GenerateDependencies componentset.xml >Makefile.dependencies
 * </pre>
 * <p>The input XML file must conform to the
 * <code>componentinfo.dtd</code> DTD, with a top-level element of
 * <code>&lt;componentset&gt;</code>.
 *
 * @author Norman Gray
 */
public class GenerateDependencies {

    private static java.util.Map allComponents;
    
    public static void main (String[] args) {
        if (args.length != 1) {
            System.err.println("GenerateDependencies: wrong number of arguments");
            System.exit(1);
        }
        String xmlinput = args[0];

        allComponents = new java.util.TreeMap();
        
        try {

            javax.xml.parsers.DocumentBuilder db 
                    = javax.xml.parsers.DocumentBuilderFactory
                    .newInstance().newDocumentBuilder();
            Document dom = db.parse(xmlinput);
            Element componentset = dom.getDocumentElement();
            NodeList componentList
                    = componentset.getElementsByTagName("component");

            for (int i=0; i<componentList.getLength(); i++) {
                Element e = (Element)componentList.item(i);
                Component c = new Component(e);
                allComponents.put(c.getName(), c);
            }
            
        } catch (java.io.IOException e) {
            System.err.println("IOException: " + e);
        } catch (org.xml.sax.SAXException e) {
            System.err.println("SAXException: " + e);
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            System.err.println("Can't create parser: " + e);
        }


        // We have now ingested the set of components and their
        // dependencies.  So now run through the set of components in
        // allComponents, writing out the Makefile fragment.  We
        // include all <sourceset> and <include> dependencies, plus
        // <link> dependencies if the <dependencies> element has
        // buildincludeslink="yes"

        String[] banner = {
            "# This file is generated by GenerateDependencies.java.",
            "# It must be included into another makefile,",
            "# and that file should define the variable MANIFEST",
            "# to point to the directory which contains the collection",
            "# of manifest files, typically /star/manifests.",
            "#",
            "# If the environment variable BUILDSUPPORT_PREFIX is defined",
            "# then the buildsupport tools will be REconfigured when they",
            "# are built; if not, they must be configured already.",
            "",
            "",
        };
        for (int i=0; i<banner.length; i++)
            System.out.println(banner[i]);
                    

        java.util.List allbuildsupport = new java.util.LinkedList();
        
        for (Iterator ci = allComponents.keySet().iterator(); ci.hasNext(); ) {
            Component c = (Component)allComponents.get(ci.next());


            Set alldeps = c.getAllDeps(Dependency.SOURCESET);
            if (alldeps == null) {
                System.err.println
                        ("Circularity detected in sourceset dependencies of "
                         + c.getName());
                System.exit(1);    
            }

            Set builddeps = c.getAllDeps(Dependency.BUILD);
            if (builddeps == null) {
                System.err.println
                        ("Circularity detected in include dependencies of "
                         + c.getName());
                System.exit(1);    
            }
            alldeps.addAll(builddeps);
            
            System.out.print("$(MANIFEST)/" + c.getName() + ':');
            for (Iterator i=alldeps.iterator(); i.hasNext(); ) {
                Dependency dep = (Dependency)i.next();
                System.out.print(" \\\n\t\t$(MANIFEST)/" + dep.packName());
            }
            System.out.println();
            System.out.println("\tcd " + c.componentPath() + " \\");
            if (c.getBuildsupport() != Component.BUILDSUPPORT_NO) {
                System.out.println("\t    && if test -n \"$$BUILDSUPPORT_PREFIX\"; then \\\n\t        ./configure --prefix=$$BUILDSUPPORT_PREFIX \\\n\t            >configure-output.log; \\\n\t    elif test ! -f Makefile; then \\\n\t        { t=\"Directory unconfigured but BUILDSUPPORT_PREFIX undefined\";\\\n\t          echo $t >configure-output.log; echo $t >&2; \\\n\t          exit 1; }; \\\n\t    else \\\n\t        echo \"No configuration necessary\" >configure-output.log; \\\n\t    fi \\");
                if (c.getBuildsupport() == Component.BUILDSUPPORT_AUTO)
                    allbuildsupport.add(c);
            }
            System.out.println("\t    && make>make.log && make install-manifest>>make.log");
            System.out.println();
        }

        System.out.print("buildsupport:");
        for (Iterator i=allbuildsupport.iterator(); i.hasNext(); ) {
            Component c = (Component)i.next();
            System.out.print(" \\\n\t\t$(MANIFEST)/" + c.getName());
        }
        System.out.println();
        
    }

    /**
     * Represents a single component.
     */
    private static class Component {

        private Element el;
        private Map allDeps;
        private String name;

        /**
         * This component is a buildsupport component, and should be
         * built automatically.  Value returned by getBuildsupport.
         */
        public static final int BUILDSUPPORT_AUTO = 1;
        /**
         * This component is a buildsupport component, but should not be
         * built automatically.  Value returned by getBuildsupport.
         */
        public static final int BUILDSUPPORT_NOAUTO = 2;
        /**
         * This component is not a buildsupport component.
         * Value returned by getBuildsupport.
         */
        public static final int BUILDSUPPORT_NO = 3;

        public Component(Element el) {
            this.el = el;
            allDeps = new java.util.HashMap();
        }

        /** Name of the component */
        public String getName() {
            if (name == null)
                name = el.getAttribute("id").intern();
            return name;
        }

        /** Retrieves the effective of the buildsupport attribute.
         * @return one of the values <code>BUILDSUPPORT_AUTO</code>,
         * <code>BUILDSUPPORT_NOAUTO</code> or <code>BUILDSUPPORT_NO</code>.
         */
        public int getBuildsupport() {
            String s = el.getAttribute("buildsupport");
            int ret;
            
            if (s.equals("yes"))
                ret = BUILDSUPPORT_AUTO;
            else if (s.equals("noauto"))
                ret = BUILDSUPPORT_NOAUTO;
            else
                // everything else: should be "no" or blank
                ret = BUILDSUPPORT_NO;
            return ret;
        }

        /**
         * Retrieves the path to this component.
         */
        public String componentPath() {
            NodeList nl = el.getElementsByTagName("path");
            if (nl.getLength() != 1) {
                System.err.println("Component " + getName()
                                   + " does not have precisely one <path> element");
                System.exit(1);
            }
            return nl.item(0).getFirstChild().getNodeValue();
        }
        
        /**
         * Gets the set of direct dependencies of this component.
         * @param type one of the type strings SOURCESET, INCLUDE,
         * LINK or USE.
         * @return a set containing the required dependencies
         */
        public Set getDeps(String type) {
            Set s = (Set)allDeps.get(type);
            if (s == null) {
                s = getElementContentsAsSet(type);
                allDeps.put(type, s);
            }
            return s;
        }

        /**
         * Gets the complete set of dependencies.  As for
         * <code>getDeps</code>, except that the dependencies of the
         * direct dependencies are returned, and so on recursively.
         * @param type one of the type strings
         * @return a set of all the dependencies, or null (and prints
         * a message on <code>stderr</code>) if it detects a circular
         * dependency.
         */
        public Set getAllDeps(String type) {
            Set collectedDeps = new java.util.TreeSet();

            Stack s = new Stack();
            s.push(getName());
            collectDeps(type, collectedDeps, s, true);
            if (collectedDeps.contains(new Dependency(getName()))) {
                return null;
            } else {
                return collectedDeps;
            }
            
        }

        /**
         * Collect all dependencies into a set.
         * @param type the type of dependencies to collect
         * @param allDeps the set which has the dependencies added to
         * it (NB, sideeffect)
         * @param pathHere a Stack holding the path of dependencies
         * which led us here, to help reporting circularities
         * @param warnCircular if true, warn when we detect
         * circularities; if false, silently omit them
         */
        private void collectDeps(String type, Set allDeps, Stack pathHere,
                                 boolean warnCircular) {
            Set currentDeps = getDeps(type);
            for (Iterator i=currentDeps.iterator(); i.hasNext(); ) {
                Dependency dep = (Dependency)i.next();
                if (! allDeps.contains(dep)) {
                    // process it
                    Component c = (Component)allComponents.get(dep.packName());
                    if (c == null) {
                        // never heard of it!
                        System.err.println("Package " + getName()
                                           + " depends on non-existent "
                                           + dep);
                    } else if (pathHere.search(dep.packName()) >= 0) {
                        // circular dependency
                        if (warnCircular) {
                            System.err.print("Circular dependency: "
                                             + dep.packName());
                            Stack pathCopy = (Stack)pathHere.clone();
                            while (! pathCopy.empty())
                                System.err.print(" <- " + pathCopy.pop());
                            System.err.println();
                            // ...but add it to the dependency list
                            // nonetheless.  This triggers an error
                            // message above.
                            allDeps.add(dep);
                            // But don't recurse.
                        }
                        // If we're not to warn about circularity (see
                        // below), then simply avoid adding this dependency.
                    } else {
                        // normal case
                        allDeps.add(dep);
                        pathHere.push(dep.packName());
                        c.collectDeps(type, allDeps, pathHere, true);

                        // Check if there are any option dependencies.  If
                        // so, add all of the dependencies of that type,
                        // too.  
                        if (dep.option() == Dependency.LINK)
                            // In this particular case it doesn't
                            // matter if we have a circular
                            // dependency: the link will still work.
                            // Thus suppress the warning that the
                            // above code normally produces in this case.
                            c.collectDeps(dep.option(), allDeps, pathHere,
                                          false);
                        else if (dep.option() != null)
                            System.err.println("Non-link option "
                                               + dep.option() 
                                               + " on component "
                                               + dep.packName()
                                               + " -- you sure?");

                        pathHere.pop();
                    }
                }
            }
        }

        /**
         * Finds all the child elements with the given name, and returns a
         * Set containing their contents.
         * @param elname the element name to be examined
         * @return a Set of Dependency objects
         */
        private Set getElementContentsAsSet(String elname) {
            Set deps = new java.util.TreeSet();
            NodeList nl = el.getElementsByTagName(elname);
            for (int i=0; i<nl.getLength(); i++) {
                try {
                    assert nl.item(i).getNodeType() == Node.ELEMENT_NODE;
                    deps.add(new Dependency((Element)nl.item(i)));
                } catch (IllegalArgumentException e) {
                    return null;
                }
            }
            return deps;
        }
    }

    /**
     * Encapsulates a dependency on a component.  Expresses that there
     * is a dependency of type {@link #type} on the component {@link
     * #packName}.
     */
    private static class Dependency
            implements Comparable {
        private String mytype;
        private String pack;
        private String option;

        public static final String SOURCESET = "sourceset".intern();
        public static final String BUILD = "build".intern();
        public static final String LINK = "link".intern();
        public static final String USE = "use".intern();
        private static final String DUMMY = "dummy".intern();

        Dependency(Element el) {

            String type = el.getNodeName().intern();
            if (type == SOURCESET
                || type == BUILD
                || type == LINK
                || type == USE)
                mytype = type;
            else
                throw new IllegalArgumentException
                        ("Element contains unrecognised text " + type);

            el.normalize();
            Node text = el.getFirstChild();
            if (text == null || text.getNodeType() != Node.TEXT_NODE)
                throw new IllegalArgumentException
                        ("Element does not contain text");
            pack = text.getNodeValue().intern();

            String attval = el.getAttribute("option");
            if (attval.length() > 0)
                option = attval.trim().intern();
        }

        /**
         * Dummy constructor so that strings can be tested for
         * equality with dependencies.
         */
        Dependency(String name) {
            pack = name.intern();
            mytype = DUMMY;
            option = null;
        }

        public String type() {
            return mytype;
        }
        public String packName() {
            return pack;
        }
        public String option() {
            return option;
        }
        public String toString() {
            return pack;
        }
        public boolean equals(Object o) {
            return o instanceof Dependency
                    && ((Dependency)o).packName() == packName();
        }
        public int compareTo(Object o) 
                throws ClassCastException {
            Dependency od = (Dependency)o; // throws Exception if not possible
            return pack.compareTo(od.pack);
        }
    }
}

