import org.w3c.dom.*;
import java.util.Iterator;
import java.util.Set;
import java.util.Map;
import java.util.Stack;


/**
 * Generates a Makefile fragment containing the dependencies expressed
 * in a componentinfo XML file.
 *
 * <p>Usage:
 * <pre>
 * java GenerateDependencies componentset.xml >Makefile.dependencies
 * </pre>
 * <p>The input XML file must conform to the
 * <code>componentinfo.dtd</code> DTD, with a top-level element of
 * <code>&lt;componentset&gt;</code>.
 *
 * @author Norman Gray
 */
public class GenerateDependencies {

    private static java.util.Map allComponents;
    private static boolean verbose = false;

    /**
     * Global status, returned at end, and incremented internally on errors.
     */
    private static int globalStatus = 0;

    public static void main (String[] args) {
        boolean testMode = false;
        String xmlinput = null;

        for (int i=0; i<args.length; i++) {
            if (args[i].startsWith("--")) {
                if (args[i].equals("--test"))
                    testMode = true;
                else if (args[i].equals("--verbose"))
                    verbose = true;
                else
                    Usage();
            } else {
                if (xmlinput != null)
                    Usage();
                else
                    xmlinput = args[i];
            }
        }

        if (xmlinput == null)
            Usage();

        allComponents = new java.util.TreeMap();
        
        try {

            javax.xml.parsers.DocumentBuilder db 
                    = javax.xml.parsers.DocumentBuilderFactory
                    .newInstance().newDocumentBuilder();
            Document dom = db.parse(xmlinput);
            Element componentset = dom.getDocumentElement();
            NodeList componentList
                    = componentset.getElementsByTagName("component");

            for (int i=0; i<componentList.getLength(); i++) {
                Element e = (Element)componentList.item(i);
                Component c = new Component(e);
                allComponents.put(c.getName(), c);
            }
            
        } catch (java.io.IOException e) {
            System.err.println("IOException: " + e);
        } catch (org.xml.sax.SAXException e) {
            System.err.println("SAXException: " + e);
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            System.err.println("Can't create parser: " + e);
        }


        // We have now ingested the set of components and their
        // dependencies.  So now run through the set of components in
        // allComponents, writing out the Makefile fragment.  We
        // include all <sourceset> and <include> dependencies, plus
        // <link> dependencies if the <dependencies> element has
        // buildincludeslink="yes"

        String manifestString = "$(MANIFEST)/";
        String newlineString = " \\\n\t\t";
        String makeBuildsupportString = "\t    && if test -n \"$$BUILDSUPPORT_PREFIX\"; then \\\n\t        ./configure --prefix=$$BUILDSUPPORT_PREFIX \\\n\t            >configure-output.log; \\\n\t    elif test ! -f Makefile; then \\\n\t        { t=\"Directory unconfigured but BUILDSUPPORT_PREFIX undefined\";\\\n\t          echo $$t >configure-output.log; echo $$t >&2; \\\n\t          exit 1; }; \\\n\t    else \\\n\t        echo \"No configuration necessary\" >configure-output.log; \\\n\t    fi \\";
        String makeString = "\t    && make>make.log && make install>>make.log";
        String cdString = "\tcd ";

        if (testMode) {
            manifestString = "";
            newlineString = "\n  ";
            makeBuildsupportString = "  (buildsupport)";
            makeString = "  --";
            cdString = "  path=";
        }

        // Banner at the top of the output file
        if (! testMode) {
            String[] banner = {
                "# This file is generated by GenerateDependencies.java.",
                "# It must be included into another makefile,",
                "# and that file should define the variable MANIFEST",
                "# to point to the directory which contains the collection",
                "# of manifest files, typically /star/manifests.",
                "#",
                "# If the environment variable BUILDSUPPORT_PREFIX is defined",
                "# then the buildsupport tools will be REconfigured when they",
                "# are built; if not, they must be configured already.",
                "",
                "",
            };
            for (int i=0; i<banner.length; i++)
                System.out.println(banner[i]);
        }

        java.util.List allbuildsupport = new java.util.LinkedList();
        
        for (Iterator ci = allComponents.keySet().iterator(); ci.hasNext(); ) {
            Component c = (Component)allComponents.get(ci.next());


            Set alldeps = c.getCompleteDependencies(Dependency.SOURCESET);
            if (alldeps == null) {
                System.err.println
                        ("Circularity detected in sourceset dependencies of "
                         + c.getName());
                if (testMode)
                    System.out.println("Component " + c
                                       + ": circular sourceset dependencies");
                else
                    globalStatus++;
                continue;
            }

            Set builddeps = c.getCompleteDependencies(Dependency.BUILD);
            if (builddeps == null) {
                System.err.println
                        ("Circularity detected in build dependencies of "
                         + c.getName());
                if (testMode)
                    System.out.println("Component " + c
                                       + ": circular build dependencies");
                else
                    globalStatus++;
                continue;
            }
            alldeps.addAll(builddeps);

            System.out.print(manifestString + c.getName() + ':');
            Component lastComponent = null;
            for (Iterator cpts=alldeps.iterator(); cpts.hasNext(); ) {
                Component cpt = ((Dependency)cpts.next()).component();
                if (cpt != lastComponent) {
                    System.out.print(newlineString + manifestString + cpt);
                    lastComponent = cpt;
                }
            }
            System.out.println();
            System.out.println(cdString + c.componentPath() + " \\");
            if (c.getBuildsupport() != Component.BUILDSUPPORT_NO) {
                System.out.println(makeBuildsupportString);
                allbuildsupport.add(c);
            }
            System.out.println(makeString);
            System.out.println();
        }

        // Add all of the buildsupport tools to either autoBuildsupport or
        // nonautoBuildsupport, depending on whether they are or are not
        // (respectively) to be build automatically.
        StringBuffer autoBuildsupport = new StringBuffer();
        StringBuffer nonautoBuildsupport = new StringBuffer();
        for (Iterator i=allbuildsupport.iterator(); i.hasNext(); ) {
            Component c = (Component)i.next();
            (c.getBuildsupport() == Component.BUILDSUPPORT_AUTO
             ? autoBuildsupport
             : nonautoBuildsupport)
                    .append(newlineString)
                    .append(manifestString)
                    .append(c.getName());
        }
        System.out.println();
        System.out.println("# Buildsupport tools -- building and cleaning");
        System.out.println("BUILDSUPPORT_MANIFESTS ="
                           + autoBuildsupport.toString());
        System.out.println("EXTRA_BUILDSUPPORT_MANIFESTS ="
                           + nonautoBuildsupport.toString());
        System.out.println();
        System.out.println("buildsupport: $(BUILDSUPPORT_MANIFESTS)");
        System.out.println("clean-buildsupport:");
        System.out.println("\trm -f $(BUILDSUPPORT_MANIFESTS) $(EXTRA_BUILDSUPPORT_MANIFESTS)");
        

        System.exit(globalStatus);
    }

    private static void Usage() {
        System.err.println("GenerateDependencies [--test] [--verbose] xml-file");
        System.exit(1);
    }

    /**
     * Represents a single component.
     */
    private static class Component {

        private Element el;
        /**
         * A map of all the direct dependencies.  The keys are dependency
         * types (SOURCESET, and so on).  Each element of this map
         * is a Set of Dependency objects.
         */
        private Map allDirectDependencies;
        /**
         * A map of all the dependencies.  The keys are dependency
         * types (SOURCESET, and so on).  Each element of this map is a
         * Set of Component objects.
         */
        private Map allComponentDependencies;

        /** The name of the component */
        private String name;

        /** The path to the component */
        private String path;

        private Set marks = new java.util.HashSet();

        /**
         * This component is a buildsupport component, and should be
         * built automatically.  Value returned by getBuildsupport.
         */
        public static final int BUILDSUPPORT_AUTO = 1;
        /**
         * This component is a buildsupport component, but should not be
         * built automatically.  Value returned by getBuildsupport.
         */
        public static final int BUILDSUPPORT_NOAUTO = 2;
        /**
         * This component is not a buildsupport component.
         * Value returned by getBuildsupport.
         */
        public static final int BUILDSUPPORT_NO = 3;

        public Component(Element el) {
            this.el = el;
            allDirectDependencies = new java.util.HashMap();
            allComponentDependencies = new java.util.HashMap();
        }

        /** Name of the component */
        public String getName() {
            if (name == null)
                name = el.getAttribute("id").intern();
            return name;
        }

        public String toString() {
            return name;
        }

        /** Retrieves the effective of the buildsupport attribute.
         * @return one of the values <code>BUILDSUPPORT_AUTO</code>,
         * <code>BUILDSUPPORT_NOAUTO</code> or <code>BUILDSUPPORT_NO</code>.
         */
        public int getBuildsupport() {
            String s = el.getAttribute("buildsupport");
            int ret;
            
            if (s.equals("yes"))
                ret = BUILDSUPPORT_AUTO;
            else if (s.equals("noauto"))
                ret = BUILDSUPPORT_NOAUTO;
            else
                // everything else: should be "no" or blank
                ret = BUILDSUPPORT_NO;
            return ret;
        }

        /**
         * Retrieves the path to this component.
         */
        public String componentPath() {
            if (path == null) {
                NodeList nl = el.getElementsByTagName("path");
                if (nl.getLength() != 1) {
                    System.err.println("Component " + getName()
                                       + " does not have precisely one <path> element");
                    System.exit(1);
                }
                path = nl.item(0).getFirstChild().getNodeValue();
            }
            return path;
        }
        
        /**
         * Gets the set of direct dependencies of this component.
         * @param type one of the type strings SOURCESET, INCLUDE, and so on.
         * @return a Set of Dependency objects
         */
        public Set getDeps(String type) {
            Set s = (Set)allDirectDependencies.get(type);
            if (s == null) {
                s = getElementDependenciesAsSet(type);
                allDirectDependencies.put(type, s);
            }
            return s;
        }

        /**
         * Gets the complete set of dependencies.  As for
         * <code>getDeps</code>, except that the dependencies of the
         * direct dependencies are returned, and so on recursively.
         *
         * @param type one of the type strings
         * @return a set of all the Dependency objects which this component
         *     depends on.  If it detects a circular dependency, return
         *     null, print a message on <code>stderr</code>, and increment
         *     {@link #globalStatus}.
         */
        public Set getCompleteDependencies(String type) {
            if (allComponentDependencies.containsKey(type))
                // our work is already done
                return (Set)allComponentDependencies.get(type); // JUMP OUT

             return getCompleteDependencies(type, true, 0);
        }

        private Set getCompleteDependencies(String type,
                                            boolean errorCircular,
                                            int recurseLevel) {
            boolean foundCircular = false;
            
            if (verbose) {
                System.err.println("[" + recurseLevel + "] "
                                   + this.toString()
                                   + ".getCompleteDependencies(" + type
                                   + ", " + errorCircular
                                   + ", " + recurseLevel
                                   + "): marks "
                                   + showSet(marks));
            }

            if (marks.contains(type)) {
                if (type == Dependency.LINK) {
                    return new java.util.TreeSet();
                } else {
                    System.err.println("Detected circular dependency on " + this);
                    return null;
                }
            }
            marks.add(type);
            
            // collectedDeps is a Set of Dependency objects
            Set collectedDeps = new java.util.TreeSet();
            for (Iterator i=getDeps(type).iterator(); i.hasNext(); ) {
                Dependency d = (Dependency)i.next();
                Component c = d.component();
                if (verbose)
                    System.err.println("[" + recurseLevel
                                       + "] ...depends on " + c);
                //                if (c == checkComponent) {
                collectedDeps.add(d);

                Set cdeps;      // Set of Dependency objects
                if (d.option() != null) {
                    if (verbose)
                        System.err.println("[" + recurseLevel
                                           + "] Component " + c
                                           + " has option " + d.option());
                    cdeps = c.getCompleteDependencies
                            (d.option(),
                             (d.option() == Dependency.LINK ? false : true),
                             recurseLevel+1);
                } else {
                    cdeps = c.getCompleteDependencies
                            (type,
                             (type == Dependency.LINK ? false : true),
                             recurseLevel+1);
                }
                
                if (cdeps == null) {
                    // We found circular dependencies.  As we work our
                    // way back up the call tree, print out the
                    // sequence of dependencies that brought us here.
                    System.err.println("...dependency of " + this);
                    foundCircular = true;
                } else {
                    collectedDeps.addAll(cdeps);
                }
            }
            if (verbose) {
                System.err.println("[" + recurseLevel
                                   + "] ...collected for " + this + ":");
                for (Iterator i=collectedDeps.iterator(); i.hasNext(); ) {
                    System.err.println("  " + i.next());
                }
            }

            try {
                allComponentDependencies.put
                        (type,
                         foundCircular ? null : collectedDeps);
            } catch (NullPointerException e) {
                System.err.println("Map does not permit null values");
                System.exit(1);
            }

            marks.remove(type);

            return (foundCircular ? null : collectedDeps);
        }

        private static String showSet(Set s) {
            StringBuffer sb = new StringBuffer("{");
            for (Iterator si=s.iterator(); si.hasNext(); )
                sb.append(' ').append(si.next().toString());
            sb.append(" }");
            return sb.toString();
        }

        /**
         * Finds all the child elements with the given name, and returns a
         * Set containing their contents.
         * @param elname the element name to be examined
         * @return a Set of Dependency objects
         */
        private Set getElementDependenciesAsSet(String elname) {
            Set deps = new java.util.TreeSet();
            NodeList nl = el.getElementsByTagName(elname);
            for (int i=0; i<nl.getLength(); i++) {
                try {
                    assert nl.item(i).getNodeType() == Node.ELEMENT_NODE;
                    deps.add(new Dependency((Element)nl.item(i)));
                } catch (IllegalArgumentException e) {
                    return null;
                }
            }
            return deps;
        }

//         public boolean equals(Object o) {
//             if (o == this)
//                 return true;
//             else if (o instanceof Component) {
//                 Component c = (Component) o;
//                 return c.name == name
//                         && c.path == path
//                         && c.getBuildsupport() == getBuildsupport();
//             } else {
//                 return false;
//             }
//         }
//         public int compareTo(Object o) 
//                 throws ClassCastException {
//             if (equals(o))
//                 return 0;
//             else {
//                 Component c = (Component)o;
//                 int i = name.compareTo(c.name);
//                 if (i != 0)
//                     return i;
//                 i = path.compareTo(c.path);
//                 if (i != 0)
//                     return i;
//                 i = getBuildsupport() - c.getBuildsupport();
//                 assert i != 0;  // or else equals() should have been true
//                 return i;
//             }
//         }
//         public int hashCode() {
//             return (name.hashCode() ^ path.hashCode()) + getBuildsupport();
//         }
    }

    /**
     * Encapsulates a dependency on a component.  Expresses that there
     * is a dependency of type {@link #type} on the component
     * {@link * #dependency}.
     */
    private static class Dependency
            implements Comparable {
        private String mytype;
        private String dependsOnComponentName;
        private Component dependsOnComponent;
        private String option;

        public static final String SOURCESET = "sourceset";
        public static final String BUILD = "build";
        public static final String LINK = "link";
        public static final String USE = "use";
        public static final String TEST = "test";
        private static final String DUMMY = "dummy";

        Dependency(Element el) {

            String type = el.getNodeName().intern();
            if (typeOK(type))
                mytype = type;
            else
                throw new IllegalArgumentException
                        ("Element contains unrecognised text " + type);

            el.normalize();
            Node text = el.getFirstChild();
            if (text == null || text.getNodeType() != Node.TEXT_NODE)
                throw new IllegalArgumentException
                        ("Element does not contain text");
            dependsOnComponentName = text.getNodeValue().intern();

            String attval = el.getAttribute("option");
            if (attval.length() > 0) {
                if (verbose)
                    System.err.println("dependency on "
                                       + dependsOnComponentName
                                       + ", option <" + attval + ">");
                option = attval.trim().intern();
                if (! typeOK(option)) {
                    System.err.println("Option " + option + " illegal");
                    option = null;
                }
            }
        }

        public String type() {
            return mytype;
        }

        public Component component() {
            if (dependsOnComponent == null) {
                dependsOnComponent =
                        (Component)allComponents.get(dependsOnComponentName);
                if (dependsOnComponent == null) {
                    System.err.println("Dependency " + dependsOnComponentName
                                       + " unknown");
                    System.exit(1);
                }
                assert dependsOnComponentName == dependsOnComponent.getName();
            }
            return dependsOnComponent;
        }

        public String option() {
            return option;
        }

        public String toString() {
            return dependsOnComponentName;
        }            

        /** Returns true if the type is one of the legal ones */
        private boolean typeOK(String type) {
            return (type == SOURCESET
                    || type == BUILD
                    || type == LINK
                    || type == USE
                    || type == TEST);
        }

        public boolean equals(Object o) {
            if (o == this)
                return true;
            else if (o instanceof Dependency) {
                Dependency d = (Dependency)o;
                return d.dependsOnComponentName == dependsOnComponentName
                        && d.mytype == mytype
                        && d.option == option;
            } else {
                return false;
            }
        }
        public int compareTo(Object o) 
                throws ClassCastException {
            if (equals(o))
                return 0;
            Dependency od = (Dependency)o; // throws Exception if not possible
            int i = dependsOnComponentName
                    .compareTo(od.dependsOnComponentName);
            if (i != 0)
                return i;
            i = mytype.compareTo(od.mytype);
            if (i != 0)
                return i;
            if (option == null) {
                assert od.option != null; // otherwise equals() was true
                return -1;
            } else {
                if (od.option == null)
                    return +1;
                else {
                    i = option.compareTo(od.option);
                    assert i != 0;      // otherwise equals() was true
                    return i;
                }
            }
        }

        public int hashCode() {
            return dependsOnComponentName.hashCode()
                    ^ mytype.hashCode()
                    ^ option.hashCode();
        }
    }
}

