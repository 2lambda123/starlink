import org.w3c.dom.*;
import java.util.Iterator;
import java.util.Set;
import java.util.Map;


/**
 * Generates a Makefile fragment containing the dependencies expressed
 * in a componentinfo XML file.
 *
 * <p>Usage:
 * <pre>
 * java GenerateDependencies componentset.xml >Makefile.dependencies
 * </pre>
 * <p>The input XML file must conform to the
 * <code>componentinfo.dtd</code> DTD, with a top-level element of
 * <code>&lt;componentset&gt;</code>.
 *
 * @author Norman Gray
 */
public class GenerateDependencies {

    private static java.util.Map allComponents;
    
    public static void main (String[] args) {
        if (args.length != 1) {
            System.err.println("Too few arguments");
            System.exit(1);
        }
        String xmlinput = args[0];

        allComponents = new java.util.TreeMap();
        
        try {

            javax.xml.parsers.DocumentBuilder db 
                    = javax.xml.parsers.DocumentBuilderFactory
                    .newInstance().newDocumentBuilder();
            Document dom = db.parse(xmlinput);
            Element componentset = dom.getDocumentElement();
            NodeList componentList
                    = componentset.getElementsByTagName("component");

            for (int i=0; i<componentList.getLength(); i++) {
                Element e = (Element)componentList.item(i);
                Component c = new Component(e);
                allComponents.put(c.getName(), c);
            }
            
        } catch (java.io.IOException e) {
            System.err.println("IOException: " + e);
        } catch (org.xml.sax.SAXException e) {
            System.err.println("SAXException: " + e);
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            System.err.println("Can't create parser: " + e);
        }


        // We have now ingested the set of components and their
        // dependencies.  So now run through the set of components in
        // allComponents, writing out the Makefile fragment.  We
        // include all <sourceset> and <include> dependencies, plus
        // <link> dependencies if the <dependencies> element has
        // buildincludeslink="yes"

        String[] banner = {
            "# This file is generated by GenerateDependencies.java.",
            "# It must be included into another makefile,",
            "# and that file should define the variable MANIFEST",
            "# to point to the directory which contains the collection",
            "# of manifest files, typically /star/manifests.",
            "",
            "",
        };
        for (int i=0; i<banner.length; i++)
            System.out.println(banner[i]);
                    

        java.util.List allbuildsupport = new java.util.LinkedList();
        
        for (Iterator ci = allComponents.keySet().iterator(); ci.hasNext(); ) {
            Component c = (Component)allComponents.get(ci.next());


            Set alldeps = c.getAllDeps(Dependency.SOURCESET);
            if (alldeps == null) {
                System.err.println
                        ("Circularity detected in sourceset dependencies of "
                         + c.getName());
                System.exit(1);    
            }

            Set builddeps = c.getAllDeps(Dependency.BUILD);
            if (builddeps == null) {
                System.err.println
                        ("Circularity detected in include dependencies of "
                         + c.getName());
                System.exit(1);    
            }
            alldeps.addAll(builddeps);
            
            System.out.print("$(MANIFEST)/" + c.getName() + ':');
            for (Iterator i=alldeps.iterator(); i.hasNext(); ) {
                Dependency dep = (Dependency)i.next();
                System.out.print(" \\\n\t\t$(MANIFEST)/" + dep.packName());
            }
            System.out.println();
            System.out.print("\tcd " + c.componentPath());
            if (c.isBuildsupport()) {
                System.out.print(" \\\n\t\t&& ./configure --prefix=$${BUILDSUPPORT_PREFIX=/star/buildsupport} >configure-output.log");
                allbuildsupport.add(c);
            }
            System.out.println(" \\\n\t\t&& make>make.log && make install-manifest>>make.log");
            System.out.println();
        }

        System.out.print("buildsupport:");
        for (Iterator i=allbuildsupport.iterator(); i.hasNext(); ) {
            Component c = (Component)i.next();
            System.out.print(" \\\n\t\t$(MANIFEST)/" + c.getName());
        }
        System.out.println();
        
    }

    /**
     * Represents a single component.
     */
    private static class Component {

        private Element el;
        private Map allDeps;
        private String name;

        public Component(Element el) {
            this.el = el;
            allDeps = new java.util.HashMap();
        }

        /** Name of the component */
        public String getName() {
            if (name == null)
                name = el.getAttribute("id");
            return name;
        }

        /** 
         * Tests whether the buildsupport=yes attribute is present on
         * the component element.
         */
        public boolean isBuildsupport() {
            String s = el.getAttribute("buildsupport");
            return (s.equals("yes"));
        }

        /**
         * Retrieves the path to this component.
         */
        public String componentPath() {
            NodeList nl = el.getElementsByTagName("path");
            if (nl.getLength() != 1) {
                System.err.println("Component " + getName()
                                   + " does not have precisely one <path> element");
                System.exit(1);
            }
            return nl.item(0).getFirstChild().getNodeValue();
        }
        
        /**
         * Gets the set of direct dependencies of this component.
         * @param type one of the type strings SOURCESET, INCLUDE,
         * LINK or USE.
         * @return a set containing the required dependencies
         */
        public Set getDeps(String type) {
            Set s = (Set)allDeps.get(type);
            if (s == null) {
                s = getElementContentsAsSet(type);
                allDeps.put(type, s);
            }
            return s;
        }

        /**
         * Gets the complete set of dependencies.  As for
         * <code>getDeps</code>, except that the dependencies of the
         * direct dependencies, and their dependencies, are returned.
         * @param one of the type strings
         * @return a set of all the dependencies, or null (and prints
         * a message on <code>stderr</code>) if it detects a circular dependency.
         */
        public Set getAllDeps(String type) {
            return getAllDeps(type, getName());
        }

        /**
         * Gets the complete set of dependencies, checking for
         * circularities.  As for <code>getAllDeps</code>, except that
         * if any of the dependencies are the string
         * <code>failIfFound</code>, then this is a circular
         * dependency, and this prints a warning message on
         * <code>stderr</code> and returns null.
         */
        private Set getAllDeps(String type, String failIfFound) {
            Set currentDeps = getDeps(type);
            Set ret = new java.util.TreeSet();
            ret.addAll(currentDeps);
            for (Iterator i=currentDeps.iterator(); i.hasNext(); ) {
                Dependency dep = (Dependency)i.next();
                if (dep.packName().equals(failIfFound)) {
                    System.err.println("Circular dependence of " + failIfFound
                                       + ": package " + getName()
                                       + " depends on " + failIfFound);
                    return null;
                }
                Component c = (Component)allComponents.get(dep.packName());
                if (c == null) {
                    System.err.println("Package " + getName()
                                       + " depends on non-existent "
                                       + dep.packName());
                    return null;
                }
                Set subdeps = c.getAllDeps(type, failIfFound);
                if (subdeps == null) {
                    System.err.println("Circular dependence of " + failIfFound
                                       + ": package " + getName()
                                       + " depends on " + dep.packName());
                    return null;
                } else {
                    ret.addAll(subdeps);
                }

                // Check if there are any option dependencies.  If so,
                // add all of the dependencies of that type, too.
                String optionDeps = dep.option();
                if (optionDeps != null)
                    ret.addAll(c.getAllDeps(optionDeps, failIfFound));
            }
            return ret;
        }

        /**
         * Finds all the child elements with the given name, and returns a
         * Set containing their contents.
         * @param elname the element name to be examined
         * @return a Set of Dependency objects
         */
        private Set getElementContentsAsSet(String elname) {
            Set deps = new java.util.TreeSet();
            NodeList nl = el.getElementsByTagName(elname);
            for (int i=0; i<nl.getLength(); i++) {
                try {
                    assert nl.item(i).getNodeType() == Node.ELEMENT_NODE;
                    deps.add(new Dependency((Element)nl.item(i)));
                } catch (IllegalArgumentException e) {
                    return null;
                }
            }
            return deps;
        }
    }

    private static class Dependency
            implements Comparable {
        private String mytype;
        private String pack;
        private String option;

        public static final String SOURCESET = "sourceset".intern();
        public static final String BUILD = "build".intern();
        public static final String LINK = "link".intern();
        public static final String USE = "use".intern();

        Dependency(Element el) {

            String type = el.getNodeName().intern();
            if (type == SOURCESET
                || type == BUILD
                || type == LINK
                || type == USE)
                mytype = type;
            else
                throw new IllegalArgumentException
                        ("Element contains unrecognised text " + type);

            el.normalize();
            Node text = el.getFirstChild();
            if (text == null || text.getNodeType() != Node.TEXT_NODE)
                throw new IllegalArgumentException
                        ("Element does not contain text");
            pack = text.getNodeValue().intern();

            String attval = el.getAttribute("option");
            if (attval.length() > 0)
                option = attval.trim().intern();
        }

        public String type() {
            return mytype;
        }
        public String packName() {
            return pack;
        }
        public String option() {
            return option;
        }
        public int compareTo(Object o) 
                throws ClassCastException {
            Dependency od = (Dependency)o; // throws Exception if not possible
            return pack.compareTo(od.pack);
        }
    }
}

