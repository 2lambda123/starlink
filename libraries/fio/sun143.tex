\documentclass[twoside,11pt]{article}

% ? Specify used packages
% \usepackage{graphicx}        %  Use this one for final production.
% \usepackage[draft]{graphicx} %  Use this one for drafting.
% ? End of specify used packages

\pagestyle{myheadings}

% -----------------------------------------------------------------------------
% ? Document identification
% Fixed part
\newcommand{\stardoccategory}  {Starlink User Note}
\newcommand{\stardocinitials}  {SUN}

% Variable part - replace [xxx] as appropriate.
\newcommand{\stardocnumber}    {143.4}
\newcommand{\stardocauthors}   {P M Allan \\ A J Chipperfield}
\newcommand{\stardocdate}      {20 July 2001}
\newcommand{\stardoctitle}     {FIO/RIO \\ [1ex]
                                FORTRAN file I/O routines} 
\newcommand{\stardocversion}   {Version 1.5}
\newcommand{\stardocmanual}    {Programmer's Manual}
\newcommand{\stardocsource}    {sun\stardocnumber}
\newcommand{\stardoccopyright} 
{Copyright \copyright\ 2000 Council for the Central Laboratory of the Research Councils}
\newcommand{\stardocabstract}
{FIO/RIO is a subroutine package that allows a FORTRAN programmer to access
sequential and direct access data files in a machine independent manner. The
package consists of stand alone FIO and RIO routines, which can be used
independently of the Starlink software environment, plus routines to interface 
to the Starlink parameter system.}
% ? End of document identification
% -----------------------------------------------------------------------------

% +
%  Name:
%     sun.tex
%
%  Purpose:
%     Template for Starlink User Note (SUN) documents.
%     Refer to SUN/199
%
%  Authors:
%     AJC: A.J.Chipperfield (Starlink, RAL)
%     BLY: M.J.Bly (Starlink, RAL)
%     PWD: Peter W. Draper (Starlink, Durham University)
%
%  History:
%     17-JAN-1996 (AJC):
%        Original with hypertext macros, based on MDL plain originals.
%     16-JUN-1997 (BLY):
%        Adapted for LaTeX2e.
%        Added picture commands.
%     13-AUG-1998 (PWD):
%        Converted for use with LaTeX2HTML version 98.2 and
%        Star2HTML version 1.3.
%      1-FEB-2000 (AJC):
%        Add Copyright statement in LaTeX
%     {Add further history here}
%
% -

\newcommand{\stardocname}{\stardocinitials /\stardocnumber}
\markboth{\stardocname}{\stardocname}
\setlength{\textwidth}{160mm}
\setlength{\textheight}{230mm}
\setlength{\topmargin}{-2mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\setlength{\unitlength}{1mm}

% -----------------------------------------------------------------------------
%  Hypertext definitions.
%  ======================
%  These are used by the LaTeX2HTML translator in conjunction with star2html.

%  Comment.sty: version 2.0, 19 June 1992
%  Selectively in/exclude pieces of text.
%
%  Author
%    Victor Eijkhout                                      <eijkhout@cs.utk.edu>
%    Department of Computer Science
%    University Tennessee at Knoxville
%    104 Ayres Hall
%    Knoxville, TN 37996
%    USA

%  Do not remove the %begin{latexonly} and %end{latexonly} lines (used by 
%  LaTeX2HTML to signify text it shouldn't process).
%begin{latexonly}
\makeatletter
\def\makeinnocent#1{\catcode`#1=12 }
\def\csarg#1#2{\expandafter#1\csname#2\endcsname}

\def\ThrowAwayComment#1{\begingroup
    \def\CurrentComment{#1}%
    \let\do\makeinnocent \dospecials
    \makeinnocent\^^L% and whatever other special cases
    \endlinechar`\^^M \catcode`\^^M=12 \xComment}
{\catcode`\^^M=12 \endlinechar=-1 %
 \gdef\xComment#1^^M{\def\test{#1}
      \csarg\ifx{PlainEnd\CurrentComment Test}\test
          \let\html@next\endgroup
      \else \csarg\ifx{LaLaEnd\CurrentComment Test}\test
            \edef\html@next{\endgroup\noexpand\end{\CurrentComment}}
      \else \let\html@next\xComment
      \fi \fi \html@next}
}
\makeatother

\def\includecomment
 #1{\expandafter\def\csname#1\endcsname{}%
    \expandafter\def\csname end#1\endcsname{}}
\def\excludecomment
 #1{\expandafter\def\csname#1\endcsname{\ThrowAwayComment{#1}}%
    {\escapechar=-1\relax
     \csarg\xdef{PlainEnd#1Test}{\string\\end#1}%
     \csarg\xdef{LaLaEnd#1Test}{\string\\end\string\{#1\string\}}%
    }}

%  Define environments that ignore their contents.
\excludecomment{comment}
\excludecomment{rawhtml}
\excludecomment{htmlonly}

%  Hypertext commands etc. This is a condensed version of the html.sty
%  file supplied with LaTeX2HTML by: Nikos Drakos <nikos@cbl.leeds.ac.uk> &
%  Jelle van Zeijl <jvzeijl@isou17.estec.esa.nl>. The LaTeX2HTML documentation
%  should be consulted about all commands (and the environments defined above)
%  except \xref and \xlabel which are Starlink specific.

\newcommand{\htmladdnormallinkfoot}[2]{#1\footnote{#2}}
\newcommand{\htmladdnormallink}[2]{#1}
\newcommand{\htmladdimg}[1]{}
\newcommand{\hyperref}[4]{#2\ref{#4}#3}
\newcommand{\htmlref}[2]{#1}
\newcommand{\htmlimage}[1]{}
\newcommand{\htmladdtonavigation}[1]{}

\newenvironment{latexonly}{}{}
\newcommand{\latex}[1]{#1}
\newcommand{\html}[1]{}
\newcommand{\latexhtml}[2]{#1}
\newcommand{\HTMLcode}[2][]{}

%  Starlink cross-references and labels.
\newcommand{\xref}[3]{#1}
\newcommand{\xlabel}[1]{}

%  LaTeX2HTML symbol.
\newcommand{\latextohtml}{\LaTeX2\texttt{HTML}}

%  Define command to re-centre underscore for Latex and leave as normal
%  for HTML (severe problems with \_ in tabbing environments and \_\_
%  generally otherwise).
\renewcommand{\_}{\texttt{\symbol{95}}}

% -----------------------------------------------------------------------------
%  Debugging.
%  =========
%  Remove % on the following to debug links in the HTML version using Latex.

% \newcommand{\hotlink}[2]{\fbox{\begin{tabular}[t]{@{}c@{}}#1\\\hline{\footnotesize #2}\end{tabular}}}
% \renewcommand{\htmladdnormallinkfoot}[2]{\hotlink{#1}{#2}}
% \renewcommand{\htmladdnormallink}[2]{\hotlink{#1}{#2}}
% \renewcommand{\hyperref}[4]{\hotlink{#1}{\S\ref{#4}}}
% \renewcommand{\htmlref}[2]{\hotlink{#1}{\S\ref{#2}}}
% \renewcommand{\xref}[3]{\hotlink{#1}{#2 -- #3}}
%end{latexonly}
% -----------------------------------------------------------------------------
% ? Document specific \newcommand or \newenvironment commands.
\newcommand{\sqt}[1]{`#1'}
\begin{htmlonly}
   \newcommand{\sqt}[1]{{\tt{'}}#1{\tt{'}}}
\end{htmlonly}
%+
%  Name:
%     SST.TEX

%  Purpose:
%     Define LaTeX commands for laying out Starlink routine descriptions.

%  Language:
%     LaTeX

%  Type of Module:
%     LaTeX data file.

%  Description:
%     This file defines LaTeX commands which allow routine documentation
%     produced by the SST application PROLAT to be processed by LaTeX and
%     by LaTeX2html. The contents of this file should be included in the
%     source prior to any statements that make of the sst commnds.

%  Notes:
%     The style file html.sty provided with LaTeX2html needs to be used.
%     This must be before this file.

%  Authors:
%     RFWS: R.F. Warren-Smith (STARLINK)
%     PDRAPER: P.W. Draper (Starlink - Durham University)

%  History:
%     10-SEP-1990 (RFWS):
%        Original version.
%     10-SEP-1990 (RFWS):
%        Added the implementation status section.
%     12-SEP-1990 (RFWS):
%        Added support for the usage section and adjusted various spacings.
%     8-DEC-1994 (PDRAPER):
%        Added support for simplified formatting using LaTeX2html.
%     {enter_further_changes_here}

%  Bugs:
%     {note_any_bugs_here}

%-

%  Define length variables.
\newlength{\sstbannerlength}
\newlength{\sstcaptionlength}
\newlength{\sstexampleslength}
\newlength{\sstexampleswidth}

%  Define a \tt font of the required size.
\latex{\newfont{\ssttt}{cmtt10 scaled 1095}}
\html{\newcommand{\ssttt}{\tt}}

%  Define a command to produce a routine header, including its name,
%  a purpose description and the rest of the routine's documentation.
\newcommand{\sstroutine}[3]{
   \goodbreak
   \rule{\textwidth}{0.5mm}
   \vspace{-7ex}
   \newline
   \settowidth{\sstbannerlength}{{\Large {\bf #1}}}
   \setlength{\sstcaptionlength}{\textwidth}
   \setlength{\sstexampleslength}{\textwidth}
   \addtolength{\sstbannerlength}{0.5em}
   \addtolength{\sstcaptionlength}{-2.0\sstbannerlength}
   \addtolength{\sstcaptionlength}{-5.0pt}
   \settowidth{\sstexampleswidth}{{\bf Examples:}}
   \addtolength{\sstexampleslength}{-\sstexampleswidth}
   \parbox[t]{\sstbannerlength}{\flushleft{\Large {\bf #1}}}
   \parbox[t]{\sstcaptionlength}{\center{\Large #2}}
   \parbox[t]{\sstbannerlength}{\flushright{\Large {\bf #1}}}
   \begin{description}
      #3
   \end{description}
}

%  Format the description section.
\newcommand{\sstdescription}[1]{\item[Description:] #1}

%  Format the usage section.
\newcommand{\sstusage}[1]{\item[Usage:] \mbox{}
\\[1.3ex]{\raggedright \ssttt #1}}

%  Format the invocation section.
\newcommand{\sstinvocation}[1]{\item[Invocation:]\hspace{0.4em}{\tt #1}}

%  Format the arguments section.
\newcommand{\sstarguments}[1]{
   \item[Arguments:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the returned value section (for a function).
\newcommand{\sstreturnedvalue}[1]{
   \item[Returned Value:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the parameters section (for an application).
\newcommand{\sstparameters}[1]{
   \item[Parameters:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the examples section.
\newcommand{\sstexamples}[1]{
   \item[Examples:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Define the format of a subsection in a normal section.
\newcommand{\sstsubsection}[1]{ \item[{#1}] \mbox{} \\}

%  Define the format of a subsection in the examples section.
\newcommand{\sstexamplesubsection}[2]{\sloppy
\item[\parbox{\sstexampleslength}{\ssttt #1}] \mbox{} \vspace{1.0ex}
\\ #2 }

%  Format the notes section.
\newcommand{\sstnotes}[1]{\item[Notes:] \mbox{} \\[1.3ex] #1}

%  Provide a general-purpose format for additional (DIY) sections.
\newcommand{\sstdiytopic}[2]{\item[{\hspace{-0.35em}#1\hspace{-0.35em}:}]
\mbox{} \\[1.3ex] #2}

%  Format the implementation status section.
\newcommand{\sstimplementationstatus}[1]{
   \item[{Implementation Status:}] \mbox{} \\[1.3ex] #1}

%  Format the bugs section.
\newcommand{\sstbugs}[1]{\item[Bugs:] #1}

%  Format a list of items while in paragraph mode.
\newcommand{\sstitemlist}[1]{
  \mbox{} \\
  \vspace{-3.5ex}
  \begin{itemize}
     #1
  \end{itemize}
}

%  Define the format of an item.
\newcommand{\sstitem}{\item}

%% Now define html equivalents of those already set. These are used by
%  latex2html and are defined in the html.sty files.
\begin{htmlonly}

%  sstroutine.
   \newcommand{\sstroutine}[3]{
      \subsection{#1\xlabel{#1}-\label{#1}#2}
      \begin{description}
         #3
      \end{description}
   }

%  sstdescription
   \newcommand{\sstdescription}[1]{\item[Description:]
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstusage
   \newcommand{\sstusage}[1]{\item[Usage:]
      \begin{description}
         {\ssttt #1}
      \end{description}
      \\
   }

%  sstinvocation
   \newcommand{\sstinvocation}[1]{\item[Invocation:]
      \begin{description}
         {\ssttt #1}
      \end{description}
      \\
   }

%  sstarguments
   \newcommand{\sstarguments}[1]{
      \item[Arguments:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstreturnedvalue
   \newcommand{\sstreturnedvalue}[1]{
      \item[Returned Value:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstparameters
   \newcommand{\sstparameters}[1]{
      \item[Parameters:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstexamples
   \newcommand{\sstexamples}[1]{
      \item[Examples:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstsubsection
   \newcommand{\sstsubsection}[1]{\item[{#1}]}

%  sstexamplesubsection
   \newcommand{\sstexamplesubsection}[2]{\item[{\ssttt #1}] #2}

%  sstnotes
   \newcommand{\sstnotes}[1]{\item[Notes:] #1 }

%  sstdiytopic
   \newcommand{\sstdiytopic}[2]{\item[{#1}] #2 }

%  sstimplementationstatus
   \newcommand{\sstimplementationstatus}[1]{
      \item[Implementation Status:] #1
   }

%  sstitemlist
   \newcommand{\sstitemlist}[1]{
      \begin{itemize}
         #1
      \end{itemize}
      \\
   }
%  sstitem
   \newcommand{\sstitem}{\item}

\end{htmlonly}

%  End of "sst.tex" layout definitions.
%.


%+
% Extra sst definitions written by PMA.
%-

% Define layout of brief listing sections - Pinched from SUN/33

\newcommand{\noteroutine}[2]{\htmlref{{\small \bf #1}}{#1} \nopagebreak \\
                             \hspace*{3em} {\em #2} \\[1.5ex]}
% ? End of document specific commands
% -----------------------------------------------------------------------------
%  Title Page.
%  ===========
\renewcommand{\thepage}{\roman{page}}
\begin{document}
\thispagestyle{empty}

%  Latex document header.
%  ======================
\begin{latexonly}
   CCLRC / \textsc{Rutherford Appleton Laboratory} \hfill \textbf{\stardocname}\\
   {\large Particle Physics \& Astronomy Research Council}\\
   {\large Starlink Project\\}
   {\large \stardoccategory\ \stardocnumber}
   \begin{flushright}
   \stardocauthors\\
   \stardocdate
   \end{flushright}
   \vspace{-4mm}
   \rule{\textwidth}{0.5mm}
   \vspace{5mm}
   \begin{center}
   {\Huge\textbf{\stardoctitle \\ [2.5ex]}}
   {\LARGE\textbf{\stardocversion \\ [4ex]}}
   {\Huge\textbf{\stardocmanual}}
   \end{center}
   \vspace{5mm}

% ? Add picture here if required for the LaTeX version.
%   e.g. \includegraphics[scale=0.3]{filename.ps}
% ? End of picture

% ? Heading for abstract if used.
   \vspace{10mm}
   \begin{center}
      {\Large\textbf{Abstract}}
   \end{center}
% ? End of heading for abstract.
\end{latexonly}

%  HTML documentation header.
%  ==========================
\begin{htmlonly}
   \xlabel{}
   \begin{rawhtml} <H1> \end{rawhtml}
      \stardoctitle\\
      \stardocversion\\
      \stardocmanual
   \begin{rawhtml} </H1> <HR> \end{rawhtml}

% ? Add picture here if required for the hypertext version.
%   e.g. \includegraphics[scale=0.7]{filename.ps}
% ? End of picture

   \begin{rawhtml} <P> <I> \end{rawhtml}
   \stardoccategory\ \stardocnumber \\
   \stardocauthors \\
   \stardocdate
   \begin{rawhtml} </I> </P> <H3> \end{rawhtml}
      \htmladdnormallink{CCLRC / Rutherford Appleton Laboratory}
                        {http://www.cclrc.ac.uk} \\
      \htmladdnormallink{Particle Physics \& Astronomy Research Council}
                        {http://www.pparc.ac.uk} \\
   \begin{rawhtml} </H3> <H2> \end{rawhtml}
      \htmladdnormallink{Starlink Project}{http://www.starlink.ac.uk/}
   \begin{rawhtml} </H2> \end{rawhtml}
   \htmladdnormallink{\htmladdimg{source.gif} Retrieve hardcopy}
      {http://www.starlink.ac.uk/cgi-bin/hcserver?\stardocsource}\\

%  HTML document table of contents. 
%  ================================
%  Add table of contents header and a navigation button to return to this 
%  point in the document (this should always go before the abstract \section). 
  \label{stardoccontents}
  \begin{rawhtml} 
    <HR>
    <H2>Contents</H2>
  \end{rawhtml}
  \htmladdtonavigation{\htmlref{\htmladdimg{contents_motif.gif}}
        {stardoccontents}}

% ? New section for abstract if used.
  \section{\xlabel{abstract}Abstract}
% ? End of new section for abstract
\end{htmlonly}

% -----------------------------------------------------------------------------
% ? Document Abstract. (if used)
%  ==================
\stardocabstract
% ? End of document abstract

% -----------------------------------------------------------------------------
% ? Latex Copyright Statement
%  =========================
\begin{latexonly}
\newpage
\vspace*{\fill}
\stardoccopyright
\end{latexonly}
% ? End of Latex copyright statement

% -----------------------------------------------------------------------------
% ? Latex document Table of Contents (if used).
%  ===========================================
  \newpage
  \begin{latexonly}
    \setlength{\parskip}{0mm}
    \tableofcontents
    \setlength{\parskip}{\medskipamount}
    \markboth{\stardocname}{\stardocname}
  \end{latexonly}
% ? End of Latex document table of contents
% -----------------------------------------------------------------------------

\cleardoublepage
\renewcommand{\thepage}{\arabic{page}}
\setcounter{page}{1}

\section{Introduction}

The FIO/RIO package is intended for handling record oriented files 
(e.g.\ simple text files) in both ADAM tasks and stand-alone FORTRAN programs.
Although most bulk data will be stored in HDS files, there are occasions when
the use of HDS is not appropriate. Writing formatted sequential files that are
intended for printing as reports is one obvious example. When it is necessary
to read and write record oriented files, then the use of FIO can ease the
writing of such programs and will assist in the production of portable
software.

The essential difference between the FIO and RIO routines is that FIO handles
sequential files and RIO handles direct access files (also known as random
access files, hence the R in RIO). The FIO routines are primarily intended for
handling formatted, sequential files, but some can also process unformatted,
sequential files. Formatted, sequential access files may have the first
character of each record interpreted as a carriage control character when the
file is printed. Whether or not a formatted file contains carriage control
characters can be specified when the file is created. RIO routines are
primarily used to handle unformatted, direct access files, although some can
handle formatted, direct access files as well.

FIO and RIO use a common table of file descriptors so that file descriptors
created by RIO routines may be used with appropriate FIO routines: 
e.g.\ FIO\_FNAME returns the filename associated with a file descriptor 
obtained via either FIO or RIO.

The normal Starlink `inherited status' error handling strategy is employed
throughout. Any FIO/RIO routine that fails will report an error and set the
STATUS argument to an appropriate value. Symbolic constants for these STATUS
values are given in appendix \ref{status-values}.

\section{FIO/RIO descriptors}

FIO/RIO uses internal file descriptors to maintain information about the files
that it processes. The descriptors contain the FORTRAN unit number of the file,
the name of the file, the access mode and the record size. Knowledge of the
access mode allows FIO/RIO to check for invalid operations, such as writing to
a read-only file. Checking for invalid I/O operations before they are actually
performed makes programs more robust, since the corresponding I/O error is
never generated.

The FIO/RIO file descriptors do not contain any more information about a file
than could be obtained by using the FORTRAN INQUIRE statement, but they store
the information in such a way that it is more efficient to use descriptors than
the INQUIRE statement.

\section{Using FIO/RIO}

FIO/RIO can be used in three main ways; you can use it in a minimalist way to
ease the writing of normal FORTRAN programs, you can use the extra
functionality provided by FIO file descriptors in stand alone FORTRAN programs,
or you can use the ADAM parameter system interface in ADAM programs.

\subsection{Routines to enhance simple FORTRAN I/O}

Some of the FIO/RIO routines do not use FIO file descriptors and are provided
to simplify common I/O operations. For example, FIO\_GUNIT will get an unused
FORTRAN unit number. Using this routine is better than `hard wiring' unit
numbers into code as you may not know what unit numbers other subroutines are
using. The routines that do not use the FIO file descriptors are:

\begin{description}
\item[FIO\_ERASE] Erase a file
\item[FIO\_GUNIT] Get a FORTRAN I/O unit number
\item[FIO\_PUNIT] Return an FORTRAN I/O unit number
\item[FIO\_REP]  Report an I/O error
\item[FIO\_SERR]  Report an I/O error
\item[FIO\_TEST]  Test if a status value belongs to a certain class of errors
\item[RIO\_ERASE] Erase a file
\end{description}

Here is an example of the use of some of these routines.

\begin{verbatim}
      ...
*  Get a unit number.
      CALL FIO_GUNIT( UNIT, STATUS )
*  Open a file.
      OPEN( UNIT=UNIT, FILE=FILNAM, STATUS='NEW', IOSTAT=ISTAT )
      IF ( IOSTAT .EQ. 0 ) THEN
*  Save the data.
         WRITE( UNIT, '(5F10.2)' ) ( X( I ), I = 1, 5 )
         CLOSE( UNIT )
      ELSE
*  Report an error
         CALL FIO_REP( UNIT, FILNAM, ISTAT, ' ', STATUS )
      END IF
*  Return the unit number.
      CALL FIO_PUNIT( UNIT, STATUS )
      ...
\end{verbatim}

Consistent use of the FIO\_GUNIT and FIO\_PUNIT routines has reduced the
likelihood of a clash of unit number between this part of the program and some
other part, and the use of FIO\_REP allows machine independent reporting of
any errors.

\subsection{The stand-alone subroutines}

In addition to the routines in the previous section, FIO provides a set of
routines to do some simple I/O on files. FIO maintains a set of file
descriptors for active files which are used by these routines. These
descriptors contain such things as the access mode of a file (read only,
update, etc.), which allow FIO to trap some errors rather than permitting a run
time error to occur. For example, if an attempt is made to write to a file that
has been opened with `read only' access, FIO will report the error, but the
program will not crash, allowing the user to take corrective action. Use of
these routines also makes user written code more portable. Issues such as
requiring CARRIAGECONTROL='LIST' in DEC FORTRAN OPEN statements are handled
internally. The routines that handle FIO file descriptors are:

\begin{description}
\item[FIO\_CLOSE] Close a file.
\item[FIO\_FNAME] Get the name of a file.
\item[FIO\_OPEN] Open a file.
\item[FIO\_READ]  Read a file.
\item[FIO\_READF] Read a file (faster than FIO\_READ).
\item[FIO\_RWIND] Rewind a file.
\item[FIO\_UNIT] Get the unit number of a file.
\item[FIO\_WRITE] Write a file.
\item[RIO\_CLOSE] Close a file.
\item[RIO\_OPEN] Open a file.
\item[RIO\_READ]  Read a file.
\item[RIO\_WRITE] Write a file.
\end{description}

Note that the same file descriptors are used by the FIO and RIO routines, so
these can be freely mixed, where appropriate.

Here is an example of the use of some of these routines.

\begin{verbatim}
      ...
*  Open a file.
      CALL FIO_OPEN( FILNAM, 'WRITE', 'LIST', 0, FD, STATUS )
*  Write the data.
         DO I = 1, N
            CALL FIO_WRITE( FD, BUF( I ), STATUS )
         END DO
*  Close the file.
      CALL FIO_CLOSE( FD, STATUS )
      ...
\end{verbatim}

Note that there is no testing for errors in this piece of code since the FIO
routines follow the normal Starlink convention for error handling and will not
execute if STATUS is bad. However, if the loop is to be executed many times, it
would be worth testing that the call to FIO\_OPEN was successful, otherwise you
could end up executing the loop many times to no effect.

\subsection{The environment level routines}

The last way of using FIO/RIO is in its fully integrated ADAM form. The
following routines provide an interface to the ADAM parameter system:

\begin{description}
\item[FIO\_ANNUL] Annul a file descriptor and close the file.
\item[FIO\_ASSOC] Open a file associated with an ADAM parameter.
\item[FIO\_CANCL] Close a file and cancel the parameter.
\item[RIO\_ANNUL] Annul a file descriptor and close the file.
\item[RIO\_ASSOC] Open a file associated with an ADAM parameter.
\item[RIO\_CANCL] Close a file and cancel the parameter.
\end{description}

These routines are typically used to get the name of a file through the ADAM
parameter system. For instance, the previous example could be re-written as:

\begin{verbatim}
      ...
*  Open a file.
      CALL FIO_ASSOC( PNAME, 'WRITE', 'LIST', 0, FD, STATUS )
*  Write the data.
         DO I = 1, N
            CALL FIO_WRITE( FD, BUF( I ), STATUS )
         END DO
*  Close the file.
      CALL FIO_CANCL( PNAME, STATUS )
      ...
\end{verbatim}

When the call to FIO\_ASSOC is executed, the name of the file will be obtained
via the parameter system. This may involve prompting the user, but the file
name could equally well be defaulted from the interface file. The interface
file might contain something like this:

\begin{verbatim}
      PARAMETER  FILE
        TYPE     'FILENAME'
        VPATH    'PROMPT'
        PROMPT   'Name of file to be created'
        PPATH    'CURRENT,DEFAULT'
        DEFAULT  newfile.dat
      END PARAMETER
\end{verbatim}

{\bf N.B.} At present, if you specify a file name that contains a directory
name in an interface file, then you must use the appropriate (Unix or VMS)
syntax.
In the future, FIO may be enhanced to handle environment variables and
logical names as part of the file specification.

\section{Access Mode, Format and Record Size of Files}

When a file is opened by one of FIO\_OPEN, FIO\_ASSOC, RIO\_OPEN or
RIO\_ASSOC, then various attributes of the file need to be specified. These are
the access mode, the format and the record size.

The access mode can be one of 'READ', 'WRITE', 'UPDATE' or 'APPEND'. 'READ'
specifies that the file is to be opened for reading only. This is required if
the protection of the file forbids writing to it, but it is good practice to
always use this option for files that will only ever be read. 'WRITE' specifies
that a new file is created and the file is opened for writing to. This also
allows the file to be read, as once a record has been written, it can then be
read. 'UPDATE' access opens an existing file for read and write access.
'APPEND' opens an existing file for read and write access. Any records written
to the file will be added to the end of the file current file. If the file does
not exist, it will be created.

The format specifies the type of the file. It can be one of 'LIST', 'FORTRAN'
or 'NONE' (for FIO\_OPEN and FIO\_ASSOC), 'FORMATTED' (for RIO\_OPEN and
RIO\_ASSOC), or 'UNFORMATTED'. 'LIST' specifies that the first character in a
record should not be interpreted as a carriage control character, and is
usually what is needed to produce simple text files. 'FORTRAN' specifies that
the first character in a record will be interpreted as a carriage control
character. This may be useful when producing reports that are to be printed on
a line printer. The FORTRAN~77 standard says that output record that are to be
printed will have their first characters interpreted as carriage control
characters, and implies, but does not state explicitly, that output records that
are not be be printed will not have their first characters interpreted as
carriage control characters. Unfortunately, it is rather vague as to what the
term {\em printing\/} actually means. An additional source of confusion is that
a standard FORTRAN OPEN statement will create files that do cause the first
character of each record to be interpreted as a carriage control character on
VMS, but not on Unix. In fact, Unix has no concept of the type of a file, so
files that have carriage control characters in them need to be passed through a
filter (often called fpr) for the carriage control characters to have their
desired effect.

A format of 'NONE' specifies that there is no carriage control character. This
differs from a format of 'LIST' on VMS or Ultrix as the file will print on a
single line when listed on a terminal or printed on a printer. On SunOS, a
format of 'NONE' has the same effect as 'LIST'. It is best to avoid this option
whenever possible. In fact, for formatted, sequential access files (i.e.\
simple text files), it is best to use a format of 'LIST' whenever possible.

A format of 'FORMATTED' will produce a formatted direct access file with
RIO\_OPEN or RIO\_ASSOC and a format of 'UNFORMATTED' will always produce an
unformatted file.

The record size is generally only needed for direct access files created by
RIO\_OPEN and RIO\_ASSOC. In other cases it should be specified as zero, which
causes FIO to use the default size of a record. In fact it is a violation of
the FORTRAN~77 standard to give a record length when opening a sequential file.
However, VMS requires the record length to be given when creating records that
are longer than the default of 133 bytes. If a record length is given to an FIO
routine on Unix, it will ignore it.


\section{INCLUDE files}
\label{include-files}

The include file {\tt FIO\_PAR} defines symbolic names for various constants
which  may be required by tasks. The most useful constants are FIO\_\_SZMOD,
which is used to specify the length of the access mode string in calls to
FIO\_OPEN and RIO\_OPEN, and FIO\_\_SZFNM, which is the maximum allowed length
of a filename in FIO/RIO.

If you need to test for explicit status values returned from FIO/RIO
subroutines, include the statement:

\begin{quote}{\tt
      INCLUDE 'FIO\_ERR'
}
\end{quote}

in the program. The return status can then be tested. For example:

\begin{verbatim}
      IF( STATUS .EQ. FIO__ERROR ) ...
\end{verbatim}

However, there are problems to do with portability when testing return status
values. These are dealt with in the next section.

\section{Reporting and handling errors}
\label{errors}

FIO/RIO routines all report errors if they return bad status values, so
programs that do all I/O through calls to FIO/RIO do not have to worry about
this. However, some programs use direct FORTRAN statements to perform I/O and
may still need to report errors. Two routines are provided to assist with this;
FIO\_SERR and FIO\_REP. FIO\_SERR is the simpler of the two. It takes an IOSTAT
value as its first argument, returns a corresponding FIO error value in its
status argument and reports an error. The error report is of the form:

\begin{quote}{\tt
FIO\_SERR: IOSTAT error $=$ Unit not connected
}
\end{quote}

This is fine if all you want to do is translate the IOSTAT value, but the error
report does not contain any contextual information such as the unit that was
not connected nor the file that it should have been connected to. For a fuller
report, the routine FIO\_REP is provided. This takes as input arguments the
unit number, the file name, the IOSTAT value and a message to be printed.
FIO\_REP sets three message tokens, FNAME, UNIT and IOSTAT and then reports the
message that it was given. This message can contain references to the message
tokens to provide a more meaningful error message. For example:

\begin{verbatim}
      OPEN( UNIT=UNUM, FILE=FILNAM, STATUS='OLD', IOSTAT=ISTAT )
      CALL FIO_REP( UNUM, FILNAM, ISTAT,
     :  'Error opening file ^FNAME. Status = ^IOSTAT', STATUS )
\end{verbatim}

In this case, the error report contains the fact that this error has been
generated when trying to open a file. To save having to generate an error
message for every call to FIO\_REP, it is possible to give a blank message,
which is equivalent to

\begin{verbatim}
      'Error with file ^FNAME on unit number ^UNIT; IOSTAT = ^IOSTAT'
\end{verbatim} % verbatim is necessary to get the ^ to come out right.

For a given value of IOSTAT, the value of status that is returned by FIO\_REP
is the same as that returned by FIO\_SERR.

\subsection{Handling errors}

Sometimes it is desired to take corrective action if a routine returns a
particular bad status value, and section \ref{include-files} contains an
example of how you might do this. Unfortunately there is a problem with testing
FIO/RIO status values that does not occur with most other packages.

FIO/RIO can generate two sorts of error codes. Firstly there are internal
FIO/RIO codes. There is no problem testing for these. Secondly there are codes
that are a translation of a FORTRAN IOSTAT value. It is these status codes that
gives rise to the problem as such values are inherently machine specific, thus
making it very difficult to write portable applications that test for bad
status values. It might be thought that the things that could go wrong with
FORTRAN I/O were sufficiently similar from one machine to another, that a
common set of error codes could be devised, but surprisingly this is not the
case in practice. The list of error codes that can be returned as IOSTAT values
are very different from one machine to another. Even when it looks like two
errors on different machines will be equivalent in practice, this does not
always turn out to be the case.

On account of these difficulties, FIO/RIO adopts the following strategy:

\begin{quote}{\it
If the text of an error message in the computer manufacturer's documentation is
the same for two different machines, then FIO/RIO will return the same status
value on those two machines. Otherwise different status values are returned on
the different machines.
}
\end{quote}

This strategy is applied quite rigorously, even when, at first sight, it looks
like two error messages might be equivalent. The only exception at present is
that `Cannot stat file' (on Ultrix) and `can't stat file' (on SunOS) return the
same error code. Not to do so smacks of pedantry of the highest order! This
strategy has been chosen as a balance between returning unique error codes on
all machines (which is barely any better than using the raw IOSTAT value) and
trying to guess which error codes are equivalent to each other (with the
likelihood of getting it wrong). Presumably if the text of two error messages
are identical, then they are intended to apply to the same situation. Even this
cannot be guaranteed, but it is the best one can do.

Occasionally, the Fortran run time system will return an IOSTAT value that
corresponds to a operating system error rather than a Fortran error. In such a
case, an error message describing the error will be generated and the status
will be set to the value of the symbolic constant FIO\_\_OSERR.

The strategy of only returning the same error number when the text of the
message is the same definitely errs on the side of caution. It means that
programs that are intended to be run on several different machines must often
test for different error codes, one for each machine type. For example, it is
quite common to test for {\tt FIO\_\_FILNF} (file not found) on VAX/VMS.
Unfortunately, there is no error that corresponds sufficiently closely to this
on SunOS. As well as being very tedious, it means that tests for bad status
values in application programs probably need to be modified to run on a new
computer. To minimize this problem, FIO/RIO provides the ability to test status
values for classes of errors. This is best described by an example. Suppose
that you have prompted a user for the name of an input file and you then try to
open a file using the returned string. If the program fails to open the file,
this might be for one of several reasons. It may be that the file
does not exist, or that the file exists, but you do not have the right to
access the file, or that the string typed in is not a valid file name 
(e.g.\ {\tt [PMA\}TEST.DAT} on VMS). 
In all of these situations, you can rely on the error reporting to tell the 
user what has gone wrong, but all the program cares about is that it has 
failed to open the file and that it should re-prompt the user. 
A program can test for a general class of errors by using the logical function
FIO\_TEST. This takes a character argument and a status value and returns TRUE
if the value of STATUS is in the class of errors described by the character
argument.
Here is an example:

\begin{verbatim}
      IF( FIO_TEST( 'OPEN error', STATUS ) ) THEN
         ...
      ENDIF
\end{verbatim}

Note that FIO\_TEST is not sensitive to the case of the character string
given as its first argument. An example of attempting to open a file using
FORTRAN I/O and then testing to see if this was successful is:

\begin{verbatim}
      CALL ERR_MARK
      OPEN( UNIT=UNUM, FILE=FILNAM, STATUS='OLD', IOSTAT=ISTAT )
      CALL FIO_REP( UNUM, FILNAM, ISTAT, ' ', STATUS )
*  Test for `could not open file'.
      IF( FIO_TEST( 'OPEN error', STATUS ) ) THEN
*  Handle the error if we can.
         ...
         CALL ERR_ANNUL( STATUS )
      END IF
      CALL ERR_RLSE
\end{verbatim}

This example has used a FORTRAN OPEN statement in the application code. It is
generally better to let FIO handle all file access as this makes for more
portable code. (It is also less typing.) In this case, the above example would
be written as:

\begin{verbatim}
      CALL ERR_MARK
      CALL FIO_OPEN( FILNAM, 'UPDATE', 'LIST', 0, FD, STATUS )
      IF( FIO_TEST( 'OPEN error', STATUS ) ) THEN
*  Handle the error if we can.
         ...
         CALL ERR_ANNUL( STATUS )
      END IF
      CALL ERR_RLSE
\end{verbatim}

A list of all the classes of errors that can be handled in this manner is given
in appendix~\ref{status-values}. At present, the list of error classes is
fixed, but it is intended that users will be able to define their own error
classes in a future release of FIO/RIO.

\subsection{Note to software developers}
\begin{quote}
{\it 
The routines that provide the interface to the ADAM parameter system report
errors by calling the ERR library. All other routines report errors by calling
the EMS library.}
\end{quote}

\section{Compiling and Linking}

\subsection{Unix}

On a Unix system, the FORTRAN compiler will only look for include files in the
directory that contains the source code of the program being compiled unless
the include file is given as an explicit path name. Consequently, the best way
of naming include files on a Unix system is to use soft links. For example, the
program contains lines such as:

\begin{quote}{\tt
      INCLUDE 'SAE\_PAR'
}
\end{quote}

and you create a soft link in your directory with the command:

\begin{quote}{\tt
\% ln -s /star/include/sae\_par SAE\_PAR
}
\end{quote}

A shell script called {\tt fio\_dev} is provided to create the appropriate soft
links for the FIO library.

To compile and link a program that uses FIO, type:

\begin{quote}{\tt
\% f77 prog.f -L/star/lib `fio\_link`
}
\end{quote}

To compile and link an ADAM program that uses FIO, type:

\begin{quote}{\tt
\% alink prog.f `fio\_link\_adam`
}
\end{quote}

\subsection{VMS}

The current version of FIO/RIO is distributed as a shareable image. Before
compiling a program that uses any of the FIO include files, or linking any
program that uses FIO, type 

\begin{quote}{\tt
\$ FIO\_DEV
}
\end{quote}

The FIO shareable image is included in the STAR\_LINK shareable image library,
so the preferred method of linking basic FORTRAN programs is:

\begin{quote}{\tt
\$ LINK progname,STAR\_LINK/OPT
}
\end{quote}

To link an ADAM program with FIO, type:

\begin{quote}{\tt
\$ ALINK progname
}
\end{quote}

The shareable libraries and object libraries are stored in FIO\_DIR, so if you
need to link explicitly with the shareable library, type:

\begin{quote}{\tt
\$ LINK progname,FIO\_LINK/OPT
}
\end{quote}

or to link with the object library, type:

\begin{quote}{\tt
\$ LINK progname,FIO\_DIR:FIO/LIB
}
\end{quote}

Linking with the object library is not recommended as it makes the size of
executable files larger than using shareable libraries and it will require
relinking programs to take advantage of bug fixes or updates.

\appendix

\newpage
\section{Alphabetical List of Routines}

\noteroutine{
   FIO\_ACTIV
}{
   Initialise FIO library for ADAM application
}
\noteroutine{
   FIO\_ANNUL
}{
   Annul a file descriptor and close the file
}
\noteroutine{
   FIO\_ASSOC
}{
   Create/open a sequential file associated with a parameter
}
\noteroutine{
   FIO\_CANCL
}{
   Close a file and cancel the parameter
}
\noteroutine{
   FIO\_CLOSE
}{
   Close a sequential file
}
\noteroutine{
   FIO\_DEACT
}{
   Deactivate FIO
}
\noteroutine{
   FIO\_ERASE
}{
   Delete a file
}
\noteroutine{
   FIO\_FNAME
}{
   Get the full file name of a file
}
\noteroutine{
   FIO\_GUNIT
}{
   Get a unit number
}
\noteroutine{
   FIO\_OPEN
}{
   Create/open a sequential file
}
\noteroutine{
   FIO\_PUNIT
}{
   Release a unit number
}
\noteroutine{
   FIO\_READ
}{
   Read sequential record
}
\noteroutine{
   FIO\_READF
}{
   Fast read sequential record
}
\noteroutine{
   FIO\_REP
}{
   Report error from FORTRAN I/O statements
}
\noteroutine{
   FIO\_RWIND
}{
   Rewind a sequential file
}
\noteroutine{
   FIO\_SERR
}{
   Set error status
}
\noteroutine{
   FIO\_START
}{
   Set up units numbers and open standard I/O streams
}
\noteroutine{
   FIO\_STOP
}{
   Close down FIO
}
\noteroutine{
   FIO\_TEST
}{
   Test if an FIO status value belongs to a certain class of errors
}
\noteroutine{
   FIO\_UNIT
}{
   Get a unit number given a file descriptor
}
\noteroutine{
   FIO\_WRITE
}{
   Write a sequential record
}
\noteroutine{
   RIO\_ANNUL
}{
   Annul a file descriptor and close the file
}
\noteroutine{
   RIO\_ASSOC
}{
   Create/open a direct access file associated with a parameter
}
\noteroutine{
   RIO\_CANCL
}{
   Close a file and cancel the parameter
}
\noteroutine{
   RIO\_CLOSE
}{
   Close a direct access file
}
\noteroutine{
   RIO\_ERASE
}{
   Delete a file
}
\noteroutine{
   RIO\_OPEN
}{
   Open a direct access file
}
\noteroutine{
   RIO\_READ
}{
   Read record from direct access file
}
\noteroutine{
   RIO\_WRITE
}{
   Write a record to a direct access file
}


\newpage
\section{Classified List of Routines}

\subsection{Simple I/O routines}

\noteroutine{
   FIO\_ERASE
}{
   Delete a file
}
\noteroutine{
   FIO\_GUNIT
}{
   Get a unit number
}
\noteroutine{
   FIO\_PUNIT
}{
   Release a unit number
}
\noteroutine{
   FIO\_REP
}{
   Report error from FORTRAN I/O statements
}
\noteroutine{
   FIO\_SERR
}{
   Set error status
}
\noteroutine{
   FIO\_TEST
}{
   Test if an FIO status value belongs to a certain class of errors
}
\noteroutine{
   RIO\_ERASE
}{
   Delete a file
}

\subsection{Stand alone routines}

\noteroutine{
   FIO\_CLOSE
}{
   Close a sequential file
}
\noteroutine{
   FIO\_FNAME
}{
   Get the full file name of a file
}
\noteroutine{
   FIO\_OPEN
}{
   Create/open a sequential file
}
\noteroutine{
   FIO\_READ
}{
   Read sequential record
}
\noteroutine{
   FIO\_READF
}{
   Fast read sequential record
}
\noteroutine{
   FIO\_RWIND
}{
   Rewind a sequential file
}
\noteroutine{
   FIO\_UNIT
}{
   Get a unit number given a file descriptor
}
\noteroutine{
   FIO\_WRITE
}{
   Write a sequential record
}
\noteroutine{
   RIO\_CLOSE
}{
   Close a direct access file
}
\noteroutine{
   RIO\_OPEN
}{
   Open a direct access file
}
\noteroutine{
   RIO\_READ
}{
   Read record from direct access file
}
\noteroutine{
   RIO\_WRITE
}{
   Write a record to a direct access file
}

\subsection{ADAM parameter system routines}

\noteroutine{
   FIO\_ANNUL
}{
   Annul a file descriptor and close the file
}
\noteroutine{
   FIO\_ASSOC
}{
   Create/open a sequential file associated with a parameter
}
\noteroutine{
   FIO\_CANCL
}{
   Close a file and cancel the parameter
}
\noteroutine{
   RIO\_ANNUL
}{
   Annul a file descriptor and close the file
}
\noteroutine{
   RIO\_ASSOC
}{
   Create/open a direct access file associated with a parameter
}
\noteroutine{
   RIO\_CANCL
}{
   Close a file and cancel the parameter
}

\subsection{Miscellaneous routines}

\noteroutine{
   FIO\_ACTIV
}{
   Initialise FIO library for ADAM application
}
\noteroutine{
   FIO\_DEACT
}{
   Deactivate FIO
}
\noteroutine{
   FIO\_START
}{
   Set up units numbers and open standard I/O streams
}
\noteroutine{
   FIO\_STOP
}{
   Close down FIO
}


\newpage
\section{Routine Descriptions}

\begin{small}
\sstroutine{
   FIO\_ANNUL
}{
   Annul a file descriptor and close the file
}{
   \sstdescription{
      This routine closes the file associated with the file descriptor
      FD, resets the file descriptor and removes the association with
      the ADAM parameter. It does not cancel the ADAM parameter though.
      This allows the value of the ADAM parameter to be reused.
   }
   \sstinvocation{
      CALL FIO\_ANNUL( FD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         The file descriptor
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If STATUS is not SAI\_\_OK on input, then the routine
            will still attempt to execute, but will return with STATUS set
            to the import value.
      }
   }
}
\sstroutine{
   FIO\_ASSOC
}{
   Create/open a sequential file associated with a parameter
}{
   \sstdescription{
      Open the sequential file specified by parameter PNAME and return
      a file descriptor for it.
   }
   \sstinvocation{
      CALL FIO\_ASSOC( PNAME, ACMODE, FORM, RECSZ, FD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Expression giving the name of a file parameter.
      }
      \sstsubsection{
         ACMODE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Expression giving the required access mode.
         Valid modes are:\\
         {\sqt{READ}} - Open the file READONLY. The file must exist.\\
         {\sqt{WRITE}} - Create a new file and open it to write.\\
         {\sqt{UPDATE}} - Open a file to write. The file must exist.\\
         {\sqt{APPEND}} - Open a file to append. The file need not exist.
      }
      \sstsubsection{
         FORM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Expression giving the required formatting of the file.
         Valid formats are:\\
         {\sqt{FORTRAN}} - Formatted file, normal Fortran interpretation
                     of the first character of each record.\\
         {\sqt{LIST}} - Formatted file, single spacing between records.\\
         {\sqt{NONE}} - Formatted file, no implied carriage control.\\
         {\sqt{UNFORMATTED}} - Unformatted, no implied carriage control.
      }
      \sstsubsection{
         RECSZ = INTEGER (Given)
      }{
         Expression giving the maximum record size in bytes.
         Set it to zero if the Fortran default is required.
      }
      \sstsubsection{
         FD = INTEGER (Returned)
      }{
         Variable to contain the file descriptor.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      External Routines Used
   }{
      CHR:
         CHR\_SIMLR
   }
}
\sstroutine{
   FIO\_CANCL
}{
   Close a file and cancel the parameter
}{
   \sstdescription{
      Close any open file that is associated with the parameter and
      cancel the parameter.
   }
   \sstinvocation{
      CALL FIO\_CANCL( PNAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Expression giving the name of a file parameter which has
         previously been associated with a file using FIO\_ASSOC.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If STATUS is not SAI\_\_OK on input, then the routine
            will still attempt to execute, but will return with STATUS set
            to the import value.
      }
   }
}
\sstroutine{
   FIO\_CLOSE
}{
   Close a sequential file
}{
   \sstdescription{
      Close the file with the specified file descriptor.
   }
   \sstinvocation{
      CALL FIO\_CLOSE( FD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         The file descriptor.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the STATUS variable is not SAI\_\_OK on input, then the
            routine will still attempt to execute, but will return with
            STATUS set to the import value.
      }
   }
}
\sstroutine{
   FIO\_ERASE
}{
   Delete a file
}{
   \sstdescription{
      Delete the named file.
   }
   \sstinvocation{
      CALL FIO\_ERASE( FILE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FILE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Expression giving the name of the file to be deleted.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FIO\_FNAME
}{
   Get the full file name of a file
}{
   \sstdescription{
      Get the full name of the file with the specified file
      descriptor.
   }
   \sstinvocation{
      CALL FIO\_FNAME( FD, FNAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         The file descriptor.
      }
      \sstsubsection{
         FNAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Variable to contain the full file name of the file.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FIO\_GUNIT
}{
   Get a unit number
}{
   \sstdescription{
      Get an unused Fortran unit number.
   }
   \sstinvocation{
      CALL FIO\_GUNIT( UNIT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         UNIT = INTEGER (Given)
      }{
         A variable to contain the unit number.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FIO\_OPEN
}{
   Create/open a sequential file
}{
   \sstdescription{
      Open a sequential file with the specified access mode.
      When the file is created, the specified carriage control mode and
      maximum record size will be used.
      Return a file descriptor which can be used to access the file.
   }
   \sstinvocation{
      CALL FIO\_OPEN( FILE, ACMODE, FORM, RECSZ, FD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FILE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Expression giving the name of the file to be opened.
      }
      \sstsubsection{
         ACMODE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Expression giving the required access mode.
         Valid modes are:\\
         {\sqt{READ}} - Open the file READONLY. The file must exist.\\
         {\sqt{WRITE}} - Create a new file and open it to write.\\
         {\sqt{UPDATE}} - Open a file to write. The file must exist.\\
         {\sqt{APPEND}} - Open a file to append. The file need not exist.
      }
      \sstsubsection{
         FORM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Expression giving the required formatting of the file.
         Valid formats are:\\
         {\sqt{FORTRAN}} - Formatted file, normal Fortran interpretation
                     of the first character of each record.\\
         {\sqt{LIST}} - Formatted file, single spacing between records.\\
         {\sqt{NONE}} - Formatted file, no implied carriage control.\\
         {\sqt{UNFORMATTED}} - Unformatted, no implied carriage control.
      }
      \sstsubsection{
         RECSZ = INTEGER (Given)
      }{
         Expression giving the maximum record size in bytes.
         Set it to zero if the Fortran default is required.
      }
      \sstsubsection{
         FD = INTEGER (Returned)
      }{
         Variable to contain the file descriptor.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FIO\_PUNIT
}{
   Release a unit number
}{
   \sstdescription{
      Give back a Fortran unit number to FIO.
   }
   \sstinvocation{
      CALL FIO\_PUNIT( UNIT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         UNIT = INTEGER (Given)
      }{
         Variable containing the unit number.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      If STATUS is not set to SAI\_\_OK on input, then the routine will
      still attempt to execute, but will return with STATUS set to the
      import value.
   }
}
\sstroutine{
   FIO\_READ
}{
   Read sequential record
}{
   \sstdescription{
      Read a record from the file with the specified file descriptor
      and return the {\sqt{used length}} of the buffer.
   }
   \sstinvocation{
      CALL FIO\_READ( FD, BUF, NCHAR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         The file descriptor.
      }
      \sstsubsection{
         BUF = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Variable to receive the record.
      }
      \sstsubsection{
         NCHAR = INTEGER (Returned)
      }{
         Variable to receive the number of characters read, ignoring
         trailing spaces.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      FIO\_READ reflects the behaviour of the underlying Fortran I/O system
      so identical behaviour on different platforms cannot be guaranteed.
      In particular, platforms differ in the way they handle records which
      are terminated by EOF rather than newline. Supported platforms currently
      behave as follows:

\begin{tabular}{lccc}
&                            Buffer                  &STATUS       &NCHAR\\
Alpha:       &Trailing spaces added      &SAI\_\_OK     &Used length\\
Solaris:     &No trailing spaces added   &FIO\_\_EOF        &0\\
Linux:       &No trailing spaces added   &FIO\_\_EOF        &0
\end{tabular}

      In the interests of efficiency, the buffer is not cleared before each
      READ so it is not possible for FIO\_READ to find the used length on
      Solaris or Linux in this case. The programmer may do so if required.
   }

   \sstdiytopic{
      External Routines Used
   }{
      CHR:
         CHR\_LEN
   }
}
\sstroutine{
   FIO\_READF
}{
   Fast read sequential record
}{
   \sstdescription{
      Read a record from the file with the specified file descriptor.
      Unlike FIO\_READ, this routine does not return the {\sqt{used length}}
      of the buffer and is therefore faster.
   }
   \sstinvocation{
      CALL FIO\_READF( FD, BUF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         The file descriptor.
      }
      \sstsubsection{
         BUF = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Variable to receive the record.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      FIO\_READF reflects the behaviour of the underlying Fortran I/O system
      so identical behaviour on different platforms cannot be guaranteed.
      In particular, platforms differ in the way they handle records which
      are terminated by EOF rather than newline. Supported platforms currently
      behave as follows:

\begin{tabular}{lccc}
&                            Buffer                  &STATUS\\
Alpha:       &Trailing spaces added      &SAI\_\_OK\\
Solaris:     &No trailing spaces added   &FIO\_\_EOF\\
Linux:       &No trailing spaces added   &FIO\_\_EOF
\end{tabular}
   }
}

\sstroutine{
   FIO\_REP
}{
   Report error from FORTRAN I/O statements
}{
   \sstdescription{
      Translate the value of IOSTAT to an FIO error code and report the
      corresponding error message.
   }
   \sstinvocation{
      CALL FIO\_REP( UNIT, FNAME, IOSTAT, MESS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         UNIT = INTEGER (Given)
      }{
         The Fortran I/O unit number.
      }
      \sstsubsection{
         FNAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the data file.
      }
      \sstsubsection{
         IOSTAT = INTEGER (Given)
      }{
         The value of IOSTAT from a Fortran I/O statement.
      }
      \sstsubsection{
         MESS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         An error message to be output.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         CALL FIO\_REP( UNIT, {\tt ' '}, IOSTAT, {\tt ' '}, STATUS )
      }{
         This will inquire the name of the file that is connected to
         UNIT and report an error message containing the unit number
         file name and which error occurred.
      }
      \sstexamplesubsection{
         CALL FIO\_REP( UNIT, {\tt ' '}, IOSTAT, 
                'Failed to open $\wedge$FNAME', STATUS )
      }{
         This example provides an explicit error message containing the
         token FNAME.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine sets the message tokens UNIT, FNAME and IOSTAT.
            They can be given in the text of the error message.

         \sstitem
         FNAME can be a general character string, a hyphen or blank.
            If FNAME is a general character string, it is used as the name
            of the file when reporting the error message.
            If FNAME is blank, then this routine uses INQUIRE to find the
            name of the file.
            If FNAME is a hyphen, then this routine does not set the token
            FNAME. It should be set before calling this routine if a
            sensible error message is to be produced.
      }
   }
}
\sstroutine{
   FIO\_RWIND
}{
   Rewind a sequential file
}{
   \sstdescription{
      Rewind a sequential access file.
   }
   \sstinvocation{
      CALL FIO\_RWIND( FD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         The file descriptor.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine must ONLY be used on sequential access files.
      }
   }
   \sstbugs{
      None known.
   }
}
\sstroutine{
   FIO\_SERR
}{
   Set error status
}{
   \sstdescription{
      Convert a Fortran IOSTAT error value into an FIO status value and
      report the error.
   }
   \sstinvocation{
      CALL FIO\_SERR( IOSTAT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IOSTAT = INTEGER (Given)
      }{
         Variable containing the Fortran error value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
         Set to contain the FIO status.
      }
   }
}
\sstroutine{
   FIO\_TEST
}{
   Test if an FIO status value belongs to a certain class of errors
}{
   \sstdescription{
      See if the value of STATUS corresponds one of the FIO error codes
      that correspond to the error class given as the first argument.
   }
   \sstinvocation{
      RESULT = FIO\_TEST( ERRCLS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         ERRCLS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the error class
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         FIO\_TEST = LOGICAL
      }{
         Whether STATUS is in the named class of errors.
      }
   }
   \sstexamples{
      \sstexamplesubsection{
         IF( FIO\_TEST( {\sqt{OPEN ERROR}}, STATUS ) ) THEN ...
      }{
         See if the value of STATUS is one of the values associated
         with the error class {\sqt{OPEN ERROR}}.
      }
   }
   \sstdiytopic{
      External Routines Used
   }{
      CHR:
         CHR\_SIMLR
   }
}
\sstroutine{
   FIO\_UNIT
}{
   Get a unit number given a file descriptor
}{
   \sstdescription{
      The Fortran unit number associated with the given file descriptor
      is returned.
   }
   \sstinvocation{
      CALL FIO\_UNIT( FD, UNIT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         The file descriptor.
      }
      \sstsubsection{
         UNIT = INTEGER (Returned)
      }{
         Variable to receive the unit number.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FIO\_WRITE
}{
   Write a sequential record
}{
   \sstdescription{
      Write a buffer to the file with the specified file descriptor.
   }
   \sstinvocation{
      CALL FIO\_WRITE( FD, BUF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         The file descriptor.
      }
      \sstsubsection{
         BUF = CHARACTER ( $*$ ) (Given)
      }{
         Expression containing the data to be written.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   RIO\_ANNUL
}{
   Annul a file descriptor and close the file
}{
   \sstdescription{
      This routine closes the file associated with the file descriptor
      FD, resets the file descriptor and removes the association with
      the ADAM parameter. It does not cancel the ADAM parameter though.
      This allows the value of the ADAM parameter to be reused.
   }
   \sstinvocation{
      CALL RIO\_ANNUL( FD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         The file descriptor
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If STATUS is not SAI\_\_OK on input, then the routine
            will still attempt to execute, but will return with STATUS set
            to the import value.
      }
   }
}
\sstroutine{
   RIO\_ASSOC
}{
   Create/open a direct access file associated with a parameter
}{
   \sstdescription{
      Open the direct access file specified by parameter PNAME and
      return a file descriptor for it.
   }
   \sstinvocation{
      CALL RIO\_ASSOC( PNAME, ACMODE, FORM, RECSZ, FD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Expression giving the name of a file parameter.
      }
      \sstsubsection{
         ACMODE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Expression giving the required access mode.
         Valid modes are:\\
         {\sqt{READ}} - Open the file READONLY. The file must exist.\\
         {\sqt{WRITE}} - Create a new file and open it to write/read.\\
         {\sqt{UPDATE}} - Open a file to read/write. The file must exist.\\
         {\sqt{APPEND}} - Open a file to write/read.
                    If the file does not already exist, create it.
                    (APPEND has no other effect for direct access)
      }
      \sstsubsection{
         FORM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Expression giving the required record formatting.
         Valid options are {\sqt{FORMATTED}} or {\sqt{UNFORMATTED}}
      }
      \sstsubsection{
         RECSZ = INTEGER (Given)
      }{
         Expression giving the record size in bytes.
         RECSZ is only used if ACMODE is {\sqt{WRITE}} or {\sqt{APPEND}}.
         If ACMODE is {\sqt{APPEND}} and the file already exists, RECSZ
         must agree with the existing record size.
      }
      \sstsubsection{
         FD = INTEGER (Returned)
      }{
         Variable to contain the file descriptor.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and returned)
      }{
         Global status
      }
   }
   \sstdiytopic{
      External Routines Used
   }{
      CHR:
         CHR\_SIMLR
   }
}
\sstroutine{
   RIO\_CANCL
}{
   Close a file and cancel the parameter
}{
   \sstdescription{
      Close any open file that is associated with the parameter and
      cancel the parameter.
   }
   \sstinvocation{
      CALL RIO\_CANCL( PNAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Expression giving the name of a file parameter which has
         previously been associated with a file using RIO\_ASSOC.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If STATUS is not SAI\_\_OK on input, then the routine
            will still attempt to execute, but will return with STATUS set
            to the import value.
      }
   }
}
\sstroutine{
   RIO\_CLOSE
}{
   Close a direct access file
}{
   \sstdescription{
      Close the file with the specified file descriptor.
   }
   \sstinvocation{
      CALL RIO\_CLOSE( FD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         A variable containing the file descriptor.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      If the STATUS variable is not SAI\_\_OK on input, then the routine
      will still attempt to execute, but will return with STATUS set to
      the import value.
   }
}
\sstroutine{
   RIO\_ERASE
}{
   Delete a file
}{
   \sstdescription{
      Delete the named file.
   }
   \sstinvocation{
      CALL RIO\_ERASE( FILE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FILE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Expression giving the name of the file to be deleted.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   RIO\_OPEN
}{
   Open a direct access file
}{
   \sstdescription{
      Open a direct access file with the specified access mode and
      record size.
      Return a file descriptor which can be used to access the file.
   }
   \sstinvocation{
      CALL RIO\_OPEN( FILE, ACMODE, FORM, RECSZ, FD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FILE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Expression giving the name of the file to be opened.
      }
      \sstsubsection{
         ACMODE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Expression giving the required access mode.
         Valid modes are:\\
         {\sqt{READ}} - Open the file READONLY. The file must exist.\\
         {\sqt{WRITE}} - Create a new file and open it to write/read.\\
         {\sqt{UPDATE}} - Open a file to read/write. The file must exist.\\
         {\sqt{APPEND}} - Open a file to write/read.
                    If the file does not already exist, create it.
                    (APPEND has no other effect for direct access)
      }
      \sstsubsection{
         FORM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Expression giving the required record formatting.
         {\sqt{FORMATTED}} or  {\sqt{UNFORMATTED}}
      }
      \sstsubsection{
         RECSZ = INTEGER (Given)
      }{
         Expression giving the record size in bytes.
         RECSZ is only used if ACMODE is {\sqt{WRITE}} or {\sqt{APPEND}}.
         If ACMODE is {\sqt{APPEND}} and the file already exists, RECSZ
         must agree with the existing record size.
      }
      \sstsubsection{
         FD = INTEGER (Returned)
      }{
         Variable to contain the file descriptor.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   RIO\_READ
}{
   Read record from direct access file
}{
   \sstdescription{
      Read the specified unformatted record from the file with the
      given file descriptor.
   }
   \sstinvocation{
      CALL RIO\_READ( FD, RECNO, NCHAR, BUF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         The file descriptor.
      }
      \sstsubsection{
         RECNO = INTEGER (Given)
      }{
         Expression giving the number of the record to be read.
      }
      \sstsubsection{
         NCHAR = INTEGER (Given)
      }{
         Expression giving the buffer size
      }
      \sstsubsection{
         BUF = BYTE( NCHAR ) (Returned)
      }{
         A byte array to receive the record.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   RIO\_WRITE
}{
   Write a record to a direct access file
}{
   \sstdescription{
      Write the specified record number, unformatted, to the file with
      the specified file descriptor.
   }
   \sstinvocation{
      CALL RIO\_WRITE( FD, RECNO, NCHAR, BUF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         The file descriptor.
      }
      \sstsubsection{
         RECNO = INTEGER (Given)
      }{
         Expression giving the number of the record to be written.
      }
      \sstsubsection{
         NCHAR = INTEGER (Given)
      }{
         Expression giving the buffer size.
      }
      \sstsubsection{
         BUF = BYTE( NCHAR ) (given)
      }{
         A byte array containing the data to be written.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status
      }
   }
}

\newpage
\section{Description of Miscellaneous Routines}

These routines are never needed in standard programs. However, they are
documented here for completeness as they have existed for several years and
there may be a case for calling them in certain time-critical applications.
Calling them will not speed up a program, but can move a small amount of
execution time from the body of a program to its initialization phase.

\sstroutine{
   FIO\_ACTIV
}{
   Initialise FIO library for ADAM application
}{
   \sstdescription{
      The FIO package and parameter system is initialised for the start
      of an executable image.
   }
   \sstinvocation{
      CALL FIO\_ACTIV( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine is not normally needed in a simple program
            as FIO activates itself when necessary.
      }
   }
}
\sstroutine{
   FIO\_DEACT
}{
   Deactivate FIO
}{
   \sstdescription{
      The FIO stand-alone and environment levels are de-activated for
      the end of an executable image.
   }
   \sstinvocation{
      CALL FIO\_DEACT( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If STATUS is not SAI\_\_OK on input, then the routine will still
            attempt to execute, but will return with STATUS set to the
            import value.

         \sstitem
         This routine is not normally needed as FIO is closed down by
            normal program termination.
      }
   }
}
\sstroutine{
   FIO\_START
}{
   Set up units numbers and open standard I/O streams
}{
   \sstdescription{
      Allocate unit numbers for use by FIO and mark them as available.
      Open standard input, output and error files.
   }
   \sstinvocation{
      CALL FIO\_START( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine is not normally needed in a simple program as FIO
            starts itself when necessary.
      }
   }
}
\sstroutine{
   FIO\_STOP
}{
   Close down FIO
}{
   \sstdescription{
      Close the FIO file descriptor system and all associated files.
   }
   \sstinvocation{
      CALL FIO\_STOP( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If STATUS is not SAI\_\_OK on input, then the routine will
            still attempt to execute, but will return with STATUS set to
            the import value.

         \sstitem
         This routine is not normally needed in a simple program as FIO
         is closed down by normal program termination.
      }
   }
}
\end{small}
\newpage
\section{FIO status values and error classes}
\label{status-values}

This appendix lists all of the error codes and classes.

As described in section \ref{errors}, FIO/RIO can return both machine
independent and machine specific error codes in the STATUS argument. Portable
programs should only test for the machine independent codes or test for error
classes using FIO\_TEST.

Note that, historically, the codes FIO\_\_ILLAC and FIO\_\_IVUNT have been used
both as machine independent internal FIO error codes and as VMS specific error
codes. This usage is retained for compatibility. It is unlikely to cause any
problems, but the user should be aware of this, particular if mixing direct
FORTRAN I/O operations with FIO calls that perform actual I/O.

Internal (machine independent) FIO status values:

\begin{tabular}{ll}
FIO\_\_EOF   & End of file \\
FIO\_\_ERROR & Error \\
FIO\_\_FDNFP & File descriptor does not have an associated file parameter
descriptor \\
FIO\_\_ILLAC \footnotemark[1] & Illegal access mode \\
FIO\_\_ILLFD & Illegal file descriptor \\
FIO\_\_INVRL & Invalid record length \\
FIO\_\_IVUNT \footnotemark[1] & Invalid unit number \\
FIO\_\_ISACT & File parameter is active \\
FIO\_\_IVACM & Invalid access mode \\
FIO\_\_IVFMT & Invalid format \\
FIO\_\_NOUNT & No more unit numbers available \\
FIO\_\_NTOPN & File not open \\
FIO\_\_OSERR & General operating system error code \\
FIO\_\_TOOFD & No more available file descriptors \\
FIO\_\_TOOFP & Too many file parameters \\
FIO\_\_UNKPA & Parameter is not a file parameter \\
\end{tabular}

\footnotetext[1]{See note about multiple use of this error code}

Error classes:

\begin{tabular}{ll}
\underline{Class name} & \underline{STATUS values that match the class} \\
OPEN error & FIO\_\_FILNF, FIO\_\_CFOLF, FIO\_\_COEXI, FIO\_\_NFEXI, \\
           & FIO\_\_NAMER, FIO\_\_NODEV, FIO\_\_OPNER, FIO\_\_PTAFD, \\
           & FIO\_\_PERMD, FIO\_\_ILLOP, FIO\_\_ALOPN, FIO\_\_TOOMF \\
CLOSE error & FIO\_\_CLSER, FIO\_\_ILLCL, FIO\_\_INCOC \\
READ error  & FIO\_\_RDER, FIO\_\_INPCN, FIO\_\_INREQ, FIO\_\_SYNAM, \\
            & FIO\_\_TOOMV, FIO\_\_RUNCH, FIO\_\_BLINP, FIO\_\_ILSTI, \\
            & FIO\_\_IINAM \\
WRITE error & FIO\_\_WRT, FIO\_\_REWRT, FIO\_\_OUTCN, FIO\_\_OUTOV \\
REWIND error & FIO\_\_REWER \\
BACKSPACE error & FIO\_\_BACER, FIO\_\_CNTBF \\
\end{tabular}

Note that references to error classes in programs are case insensitive.

\newpage
DEC FORTRAN (OSF/1, Ultrix and VMS) specific FIO status values:
\footnotetext[1]{See note about multiple use of this error code}

\begin{tabular}{ll}
FIO\_\_ALOPN & File already open \\
FIO\_\_BACER & BACKSPACE error \\
FIO\_\_CLSER & File close error \\
FIO\_\_CNTSF & Cannot stat file (Ultrix only) \\
FIO\_\_COEXI & Cannot overwrite existing file (Ultrix only) \\
FIO\_\_DLTER & File delete error \\
FIO\_\_DUPFL & Duplicate file \\
FIO\_\_ENDFL & ENDFILE error \\
FIO\_\_FILNF & File not found \\
FIO\_\_FINER & FIND error \\
FIO\_\_FORVR & Format/variable-type mismatch \\
FIO\_\_ILLAC \footnotemark[1] & Illegal access mode \\
FIO\_\_INCKC & Inconsistent key change or duplicate key \\
FIO\_\_INCOC & Inconsistent OPEN/CLOSE parameters \\
FIO\_\_INCRC & Inconsistent record length \\
FIO\_\_INCRG & Inconsistent file organization \\
FIO\_\_INCRT & Inconsistent record type \\
FIO\_\_INFOR & Infinite format loop \\
FIO\_\_INPCN & Input conversion error \\
FIO\_\_INREQ & Input statement requires too much data \\
FIO\_\_INSVR & Insufficient virtual memory \\
FIO\_\_INVMK & Invalid key match specifier for key direction \\
FIO\_\_INVKY & Invalid key specification \\
FIO\_\_INVRG & Invalid argument to FORTRAN Run-Time Library \\
FIO\_\_INVRV & Invalid reference to variable \\
FIO\_\_IVUNT \footnotemark[1] & Invalid unit number \\
FIO\_\_KEYVL & Keyword value error in OPEN statement \\
FIO\_\_LISYN & List-directed I/O syntax error \\
FIO\_\_MIXFL & Mixed file access modes \\
FIO\_\_NAMER & File name error \\
FIO\_\_NOCRC & No current record \\
FIO\_\_NODEV & No such device \\
FIO\_\_OPNER & File open error \\
FIO\_\_OPREQ & OPEN or DEFINE FILE required \\
FIO\_\_OUTCN & Output conversion error \\
FIO\_\_OUTFL & Outside file \\
FIO\_\_OUTOV & Output statement overflows record \\
FIO\_\_PTAFD & Permission to access file denied (Ultrix only) \\
FIO\_\_RDER  & File read error \\
FIO\_\_RECIO & Recursive I/O operation \\
FIO\_\_RECTL & Record too long \\
FIO\_\_REQSA & Requires seek ability (Ultrix only) \\
FIO\_\_REWER & REWIND error \\
FIO\_\_REWRT & REWRITE error \\
FIO\_\_SEGRC & Segmented record format error \\
\end{tabular}

\begin{tabular}{ll}
FIO\_\_SPLOC & Specified record locked \\
FIO\_\_SYNAM & Syntax error in NAMELIST input \\
FIO\_\_SYNER & Syntax error in format \\
FIO\_\_TOOMV & Too many values for NAMELIST variable \\
FIO\_\_TOORC & Too many records in I/O statement \\
FIO\_\_UNLER & UNLOCK error \\
FIO\_\_UNTNC & Unit not connected (Ultrix only) \\
FIO\_\_VFVAL & Variable format expression value error \\
FIO\_\_WRTER & File write error \\
\end{tabular}

Sun FORTRAN specific FIO status values:

\begin{tabular}{ll}
FIO\_\_BLINP & Blank logical input field (Sun Fortran 1.x only) \\
FIO\_\_CFOLF & Cannot find `OLD' file \\
FIO\_\_CNTBF & Cannot backspace file \\
FIO\_\_CNTSF & Can't stat file \\
FIO\_\_DIONA & Direct I/O not allowed \\
FIO\_\_ERFMT & Error in format \\
FIO\_\_FILEO & Error in FILEOPT parameter \\
FIO\_\_FIONA & Formatted I/O not allowed \\
FIO\_\_IINAM & Illegal input for namelist \\
FIO\_\_ILARG & Illegal argument \\
FIO\_\_ILINP & Illegal logical input field (Sun Fortran 2.x only) \\
FIO\_\_ILLUN & Illegal unit number \\
FIO\_\_ILOPU & Illegal operation for unit \\
FIO\_\_ILSTI & Incomprehensible list input \\
FIO\_\_INSPE & Incompatible specifiers in open (Sun Fortran 2.x only) \\
FIO\_\_NAARC & No $*$ after repeat count \\
FIO\_\_NEGRC & Negative repeat count \\
FIO\_\_NFEXI & `NEW' file exists \\
FIO\_\_OFBOR & Off beginning of record \\
FIO\_\_OFEOR & Off end of record \\
FIO\_\_OOFSP & Out of free space \\
FIO\_\_REQSA & Requires seek ability \\
FIO\_\_RUNCH & Read unexpected character \\
FIO\_\_SIONA & Sequential I/O not allowed \\
FIO\_\_TOOMF & Too many file opens -- no free descriptors (Sun Fortran 1.x
only) \\
FIO\_\_TRUNF & Truncation failed (Sun Fortran 1.x only) \\
FIO\_\_UIONA & Unformatted I/O not allowed \\
FIO\_\_UNKNO & Unknown system error \\
FIO\_\_UNTNC & Unit not connected \\
FIO\_\_UNTNO & Attempted operation on unit that is not open (Sun Fortran 1.x
only) \\
\end{tabular}

The following FIO error status codes may be returned on machines running SunOS
or Solaris. They correspond to operating system error rather than Fortran
errors. This is not an exhaustive list of all possible errors. Rather they are
those errors that it seemed to the author of the package to be worth detecting.

\begin{tabular}{ll}
FIO\_\_PERMD & Permission denied \\
FIO\_\_FTOOL & File to large \\
FIO\_\_NSLOD & No space left of device \\
FIO\_\_FNTL  & File name too long \\
FIO\_\_DQEXC & Disk quota exceeded \\
\end{tabular}

Redundant FIO status values:

These status values are no longer used by FIO. The symbolic constants are
retained so that old code that may refer to them will still compile. However,
any code that tests for them as a returned status value will never find these
values.

\begin{tabular}{ll}
FIO\_\_CRTER & File create error \\
FIO\_\_EREXH & Error establishing exit handler \\
FIO\_\_ILLCL & Illegal close request \\
FIO\_\_ILLOP & Illegal open request \\
FIO\_\_NOTFD & File not found (superseded by FIO\_\_FILNF) \\
FIO\_\_NTSUP & Option not supported yet \\
FIO\_\_OLORG & Illegal origin \\
FIO\_\_REDON & File is readonly \\
FIO\_\_TOMNY & Too many open files \\
\end{tabular}

\section{Implementation details}

The implementation uses FORTRAN I/O and FORTRAN 77 standards are used with 
the following exceptions:

\subsection{Alpha OSF/1}

\begin{itemize}
\item The READONLY keyword is used when opening files for reading only.
This is required under VMS to allow a user to open a file for which
only read access is permitted.
\item The CARRIAGECONTROL keyword is used.
\item The ACCESS $=$ APPEND keyword is available to permit the useful but
non-standard facility of appending to files.
\item The RECL option on the OPEN statement is allowed with sequential files.
\item The keyword ORGANIZATION (= 'RELATIVE') is used when creating direct
access files.
\item A byte array is used as the buffer for direct access I/O.
\end{itemize}

\subsection{Sun4 Solaris}

\begin{itemize}
\item The ACCESS $=$ APPEND keyword is available to permit the useful but
non-standard facility of appending to files.
\end{itemize}

\subsection{Ultrix and sunOS/4}
These are no longer fully supported but the same features apply as for alpha
OSF/1 and sun4 Solaris respectively.

\subsection{VMS}
\begin{itemize}
\item The READONLY keyword is used when opening files for reading only.
This is required under VMS to allow a user to open a file for which
only read access is permitted.
\item The CARRIAGECONTROL keyword is used.
\item The ACCESS $=$ APPEND keyword is available to permit the useful but
non-standard facility of appending to files.
\item The RECL option on the OPEN statement is allowed with sequential files.
\item Keywords BLOCKSIZE ($=$ 11*512) and ORGANIZATION (= 'RELATIVE') are used 
when creating direct access files.
\item A byte array is used as the buffer for direct access I/O.
\end{itemize}
Note that the VMS implementation is frozen at release 1.4.

\section{Changes and new features}

\subsection{in version 1.5}
The Unix makefile etc.\ have been updated to version 5, and an `END='
specifier inserted in RIO\_READ to trap a problem on Solaris if the record 
number is beyond the end of the file.

This release also runs on Linux.

This document has been slightly revised to reduce the prominence of VMS in the
descriptions (there are no changes of substance) and to facilitate the
production of the hypertext version.
Although the VMS implementation is now frozen, there have been no significant
developments so this document still describes both Unix and VMS implementations.


\subsection{in version 1.5-2}
The value of the public parameter FIO\_\_SZFNM is increased from 80 to
200.

The Linux version has been brought in line with other platforms to return
status FIO\_\_FILNF rather than the obsolete FIO\_\_NOTFD if it cannot find a
file which is supposed to exist.

Other minor changes are made to improve the consistency of behaviour
on different platforms under error conditions. A note on the effect of EOF
terminated records has been added to the descriptions of FIO\_READ and
FIO\_READF in SUN/143.


The makefile has been brought up to date - amongst other things, shared
libraries will now be produced on Linux.

The format of this document has been updated and early `Changes' sections have
been removed but there is no change in other sections.
\end{document}
