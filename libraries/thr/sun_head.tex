\documentclass[11pt,nolof]{starlink}

% -----------------------------------------------------------------------------
% ? Document identification
%------------------------------------------------------------------------------
\stardoccategory    {Starlink User Note}
\stardocinitials    {SUN}
\stardocsource      {sun\stardocnumber}
\stardocnumber      {266.1}
\stardocauthors     {D.S. Berry}
\stardocdate        {12th September 2011}
\stardoctitle       {THR \\ [\latex{1ex}]
                                A Thread Management Library}
\stardocversion     {Version 1.0}
\stardocmanual      {Programmer's Manual}
\stardocabstract {%
THR provides high level utility functions for creating and using pools of
persistent execution thread.
}
% ? End of document identification
% -----------------------------------------------------------------------------
% ? Document specific \providecommand or \newenvironment commands.

% ? End of document specific commands
% -----------------------------------------------------------------------------
%  Title Page.
%  ===========
\begin{document}
\scfrontmatter

\section {Introduction}

This library contains functions that can be used to create and use pools
of persistent worker threads. It is wrapper around various functions in
the pthread library.

Note, functions in this library cannot be used from Fortran.

This library currently includes:
\begin{enumerate}
\item Wrappers for the basic pthreads functions, that add
inherited status handling. These include:

\begin{itemize}
\item thrMutexInit: Initialise a mutex
\item thrCondInit: Initialise a condition variable
\item thrThreadCreate: Create a thread
\item thrMutexLock: Lock a mutex
\item thrMutexUnlock: Unlock a mutex
\item thrCondBroadcast: Broadcast a condition
\item thrCondSignal: Signal a condition
\item thrCondWait: Wait for a condition
\end {itemize}

\item A set of functions that maintains a pool of threads ready for
use. Each thread in the pool is described as a ``worker'' and the
whole pool is described as a ``workforce''. The idea is that a task is
split into separate jobs, and all jobs are performed in parallel by
the workers in the workforce. Once a workforce has been told about all
the jobs within a task (using thrAddJob), the calling thread waits
until all the jobs have been completed.

\end{enumerate}

\appendix
\section{\label{APP:SPEC}Function Descriptions}

% Routine descriptions:
% =====================
\small
