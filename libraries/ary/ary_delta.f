      SUBROUTINE ARY_DELTA( IARY1, ZAXIS, TYPE, MINRAT, PLACE, ZRATIO,
     :                      IARY2, STATUS )
*+
*  Name:
*     ARY_DELTA

*  Purpose:
*     Compress an array using delta compression.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL ARY_DELTA( IARY1, ZAXIS, TYPE, MINRAT, PLACE, ZRATIO, IARY2,
*                     STATUS )

*  Description:
*     The routine creates a copy of the supplied array stored in DELTA form,
*     which provides a lossless compression scheme for integer data. This
*     scheme assumes that adjacent integer values in the input array tend
*     to be close in value, and so differences between adjacent values can
*     be represented in fewer bits than the absolute values themselves.
*     The differences are taken along a nominated pixel axis within the
*     supplied array (specified by argument ZAXIS).
*
*     In practice, the scheme is limited currently to representing differences
*     between adjacent values using a HDS integer data type (specified by
*     argyument TYPE) - that is, arbitrary bit length is not yet supported.
*     So for instance an _INTEGER input array can be compressed by storing
*     differences as _WORD or _BYTE values, but a _WORD input array can only
*     be compressed by storing differences as _BYTE values.
*
*     Any input value that differs from its earlier neighbour by more than
*     the data range of the selected data type is stored explicitly using
*     the data type of the input array.
*
*     Further compression is achieved by replacing runs of equal input values
*     by a single occurrence of the value with a correspsonding repetition
*     count.
*
*     It should be noted that the degree of compression achieved is
*     dependent on the nature of the data, and it is possible for the
*     compressed array to occupy more space than the uncompressed array.
*     The compression factor actually achieved is returned in argument
*     ZRATIO (the ratio of the supplied array size to the compressed
*     array size). A minmum allowed compression ratio may be specified via
*     argument MINRAT. If the compression ratio is less than this value,
*     then the returned copy is left uncompressed.

*  Arguments:
*     IARY1 = INTEGER (Given)
*        The input array identifier. This can be stored in any form. If
*        it is already stored in DELTA form, it is uncompressed and then
*        re-compressed using the supplied compression parameters. If
*        is is stored in SCALED form, the internal integer values are
*        compressed and the scale and zero terms are copied into the
*        DELTA array.
*     ZAXIS = INTEGER (Given)
*        The index of the pixel axis along which differences are to be
*        taken. If this is zero, a default value will be selected that
*        gives the greatest compression. An error will be reported if a
*        value less than zero or greater than the number of axes in the
*        input array is supplied.
*     TYPE = CHARACTER * ( * ) (Given)
*        The data type in which to store the differences between adjacent
*        input values. This must be one of '_BYTE', '_WORD' or
*        '_INTEGER'. Additionally, a blank string may be supplied in which
*        case a default value will be selected that gives the greatest
*        compression.
*     MINRAT = REAL (Given)
*        The minimum allowed ZRATIO value. If compressing the input array
*        results in a ZRATIO value smaller than or equal to MINRAT, then
*        the returned array is left uncompressed. If the supplied value is
*        zero or negative, then the array will be compressed regardless of
*        the compression ratio.
*     PLACE = INTEGER (Given and Returned)
*        An array placeholder (e.g. generated by the ARY_PLACE routine)
*        which indicates the position in the data system where the new
*        array will reside. The placeholder is annulled by this
*        routine, and a value of ARY__NOPL will be returned (as defined
*        in the include file ARY_PAR).
*     ZRATIO = REAL (Returned)
*        The compression factor actually achieved (the ratio of the
*        supplied array size to the compressed array size). Genuine
*        compressions are represented by values more than 1.0, but values
*        less than 1.0 may be returned if the input data is not suited
*        to delta compression (i.e. if the "compression" actually expands
*        the array storage). Note, the returned value of ZRATIO may be
*        smaller than MINRAT, in which case the supplied array is left
*        unchanged. The returned compression factor is approximate as it
*        does not take into account the space occupied by the HDS metadata
*        describing the extra components of a DELTA array (i.e. the
*        component names, data types, dimensions, etc). This will only be
*        significant for very small arrays.
*     IARY2 = INTEGER (Returned)
*        Identifier for the new DELTA array.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Notes:
*     - An error will be reported if the supplied array does not hold
*     integer values. In the case of a SCALED array, the internal
*     (scaled) values must be integers, but the external (unscaled) values
*     can be of any data type.
*     - The compression axis and compressed data type actually used can
*     be determined by passing the returned array to ARY_GTDLT.
*     -  An error will result if the array, or any part of it, is
*     currently mapped for access (e.g. through another identifier).
*     -  An error will result if the array holds complex values.

*  Copyright:
*     Copyright (C) 2010 Science & Technology Facilities Council.
*     All Rights Reserved.

*  Licence:
*     This program is free software; you can redistribute it and/or
*     modify it under the terms of the GNU General Public License as
*     published by the Free Software Foundation; either version 2 of
*     the License, or (at your option) any later version.
*
*     This program is distributed in the hope that it will be
*     useful,but WITHOUT ANY WARRANTY; without even the implied
*     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
*     PURPOSE. See the GNU General Public License for more details.
*
*     You should have received a copy of the GNU General Public License
*     along with this program; if not, write to the Free Software
*     Foundation, Inc., 59 Temple Place,Suite 330, Boston, MA
*     02111-1307, USA

*  Authors:
*     DSB: David S Berry (JAC, Hawaii)
*     {enter_new_authors_here}

*  History:
*     25-OCT-2010 (DSB):
*        Original version.
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}

*-

*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants
      INCLUDE 'DAT_PAR'          ! DAT_ public constants
      INCLUDE 'PRM_PAR'          ! VAL_ public constants
      INCLUDE 'ARY_PAR'          ! ARY_ public constants
      INCLUDE 'ARY_ERR'          ! ARY_ error constants
      INCLUDE 'ARY_CONST'        ! ARY_ private constants

*  Global Variables:
      INCLUDE 'ARY_DCB'          ! ARY_ Data Control Block
      INCLUDE 'ARY_ACB'          ! ARY_ Access Control Block
      INCLUDE 'ARY_PCB'          ! ARY_ Placeholder Control Block

*  Arguments Given:
      INTEGER IARY1
      INTEGER ZAXIS
      CHARACTER TYPE*(*)
      REAL MINRAT

*  Arguments Given and Returned:
      INTEGER PLACE

*  Arguments Returned:
      REAL ZRATIO
      INTEGER IARY2

*  Status:
      INTEGER STATUS             ! Global status

*  Local Variables:
      CHARACTER LOCC*(DAT__SZLOC)! Locator for component
      CHARACTER LOCT*(DAT__SZLOC)! Locator for temporary copy of array
      CHARACTER NAME*(DAT__SZNAM)! Name of component
      CHARACTER TYPES( 3 )*( DAT__SZTYP ) ! Supported compressed data types
      CHARACTER ZTYOLD*( DAT__SZTYP ) ! Old compressed data type
      CHARACTER ZTYUSE*(DAT__SZTYP)   ! Best compressed data type
      INTEGER IACB1              ! Index to input array entry in the ACB
      INTEGER IACB2              ! Index to output array entry in the ACB
      INTEGER IACBT              ! Index to input copy entry in the ACB
      INTEGER ICOMP              ! Component index
      INTEGER IDCB1              ! Index to input array entry in the DCB
      INTEGER IDCB2              ! Index to output array entry in the DCB
      INTEGER IDCBT              ! Index to input copy entry in the DCB
      INTEGER IPCB               ! Index to placeholder entry in the PCB
      INTEGER NCOMP              ! Component count
      INTEGER NDIM               ! Number of axes in supplied array
      INTEGER ZAX                ! Current compression axis
      INTEGER ZAXOLD             ! Old compression axis
      INTEGER ZAXHI              ! Highest compression axis to test
      INTEGER ZAXLO              ! Lowest compression axis to test
      INTEGER ZAXUSE             ! Best compression axis
      INTEGER ZTY                ! Current compressed data type
      INTEGER ZTYHI              ! Highest compressed data type to test
      INTEGER ZTYLO              ! Lowest compressed data type to test
      LOGICAL ERASE              ! Whether to erase placeholder object
      REAL RATIO                 ! Compression ratio for current combination
      REAL ZRATOLD               ! Old compression ratio

      LOGICAL VALID


      DATA TYPES /'_BYTE', '_WORD', '_INTEGER' /
*.

*  Check inherited global status.
      IF( STATUS .NE. SAI__OK ) RETURN

*  Import the input array identifier.
      CALL ARY1_IMPID( IARY1, IACB1, STATUS )

*  If the array is not a base array, produce a temporary copy of it.
      IF( ACB_CUT( IACB1 ) ) THEN
         CALL ARY1_TEMP( 'ARRAY', 0, 0, LOCT, STATUS )
         CALL ARY1_CPY( IACB1, .TRUE., LOCT, .TRUE., IACBT, STATUS )

*  If the array is a base array, use it directly.
      ELSE
         LOCT = DAT__NOLOC
         IACBT = IACB1
      END IF

*  Check it is safe to index arrays using IACBT.
      IF( STATUS .NE. SAI__OK ) GO TO 999

*  Obtain an index to the input data object entry in the DCB and ensure
*  that storage form, data type and bounds information is available for it.
      IDCBT = ACB_IDCB( IACBT )
      CALL ARY1_DFRM( IDCBT, STATUS )
      CALL ARY1_DTYP( IDCBT, STATUS )
      CALL ARY1_DBND( IDCBT, STATUS )

*  Get the number of axes in the input array.
      NDIM = DCB_NDIM( IDCBT )

*  Report an error if the array holds complex values.
      IF( DCB_CPX( IDCBT ) .AND. STATUS .EQ. SAI__OK ) THEN
         STATUS = ARY__FRMCV
         CALL DAT_MSG( 'ARRAY', DCB_LOC( IDCBT ) )
         CALL ERR_REP( 'ARY_DELTA_CPX', 'The array ^ARRAY holds '//
     :                 'complex values (possible programming '//
     :                 'error).', STATUS )
         GO TO 999
      END IF

*  Report an error if the ZAXIS value is wrong.
      IF( ( ZAXIS .LT. 0 .OR. ZAXIS .GT. NDIM ) .AND.
     :     STATUS .EQ. SAI__OK ) THEN
         STATUS = ARY__DIMIN
         CALL MSG_SETI( 'Z', ZAXIS )
         CALL MSG_SETI( 'N', NDIM )
         CALL ERR_REP( 'ARY_DELTA_DIM', 'Compression axis ^Z is'//
     :                 ' invalid - it should be in the range 1 '//
     :                 'to ^N (possible programming error).',
     :                 STATUS )
         GO TO 999
      END IF

*  Check the supplied TYPE. Report an error if it is not a signed integer
*  type, or blank.
      IF( TYPE .NE. '_INTEGER' .AND. TYPE .NE. '_WORD' .AND.
     :    TYPE .NE. '_BYTE' .AND. TYPE .NE. ' ' .AND.
     :    STATUS .EQ. SAI__OK ) THEN
         STATUS = ARY__TYPIN
         CALL MSG_SETC( 'T', TYPE )
         CALL ERR_REP( 'ARY_DELTA_DIM', 'Illegal compressed '//
     :                 'data type ''^T'' - (possible programming '//
     :                 'error).', STATUS )
         GO TO 999
      END IF

*  Check if the data object is mapped. Report an error if it is.
      IF( ( DCB_NWRIT( IDCBT ) .NE. 0 ) .OR.
     :    ( DCB_NREAD( IDCBT ) .NE. 0 ) .AND.
     :     STATUS .EQ. SAI__OK ) THEN
         STATUS = ARY__ISMAP
         CALL DAT_MSG( 'ARRAY', DCB_LOC( IDCBT ) )
         CALL ERR_REP( 'ARY_DELTA_MAP', 'The array ^ARRAY is '//
     :                 'mapped for access, perhaps through '//
     :                 'another identifier (possible programming '//
     :                 'error).', STATUS )
         GO TO 999
      END IF

*  Indicate we have not yet created the output array.
      IACB2 = 0

*  Import the array placeholder, converting it to a PCB index.
      IPCB = 0
      CALL ARY1_IMPPL( PLACE, IPCB, STATUS )

*  If the array is already in delta form, we may be able simply to copy
*  it to produce the output array. If not, we need to uncompress it
*  before re-compressing it.
      IF( DCB_FRM( IDCBT ) .EQ. 'DELTA' ) THEN

*  If the supplied array was not a base array, then the act of copying it
*  (above) should have uncompressed any delta array, and so we can re-use
*  the LOCT locator here. Report an error if copying the array does not
*  seem to have uncompressed it.
         IF( LOCT .NE. DAT__NOLOC ) THEN
            STATUS = ARY__FATIN
            CALL ERR_REP( ' ', 'ARY_DELTA: Array has delta form '//
     :                    'after being copied (internal programming '//
     :                    'error).', STATUS )
            GO TO 999
         END IF

*  Get the old compression parameters.
         CALL ARY1_GTDLT( IDCBT, ZAXOLD, ZTYOLD, ZRATOLD, STATUS )

*  If they are the same as the new ones, just copy the supplied array to
*  create the output array. We want the copy to be a DELTA compressed
*  array, so do not expand the compressed array.
         IF( ZAXOLD .EQ. ZAXIS .AND. ZTYOLD .EQ. TYPE ) THEN
            CALL ARY1_CPY( IACB1, PCB_TMP( IPCB ), PCB_LOC( IPCB ),
     :                     .FALSE., IACB2, STATUS )

*  If they are not the same as the new ones, we need to uncompress the
*  supplied delta array so that we can re-compress it with the new
*  parameters. Taking a temporary copy of the supplied array is the
*  simplest way to uncompress it.
         ELSE
            CALL ARY1_TEMP( 'ARRAY', 0, 0, LOCT, STATUS )
            CALL ARY1_CPY( IACB1, .TRUE., LOCT, .TRUE., IACBT, STATUS )

*  Get the DCB entry for the uncompressed copy, and ensure type
*  informastion is available for it in the DCB.
            IDCBT = ACB_IDCB( IACBT )
            CALL ARY1_DTYP( IDCBT, STATUS )

         END IF
      END IF

*  If we created the output array above, there is nothing more to do.
      IF( IACB2 .EQ. 0 .AND. STATUS .EQ. SAI__OK ) THEN

*  If required, find the best compression parameters.
         IF( ZAXIS .EQ. 0 .OR. TYPE .EQ. ' ' ) THEN

*  Determine the range of ZAXIS to test.
            IF( ZAXIS .EQ. 0 ) THEN
               ZAXLO = 1
               ZAXHI = NDIM
            ELSE
               ZAXLO = ZAXIS
               ZAXHI = ZAXIS
            END IF

*  Determine the list of compressed data types to test.
            IF( TYPE .EQ. '_BYTE' ) THEN
               ZTYLO = 1
               ZTYHI = 1
            ELSE IF( TYPE .EQ. '_WORD' ) THEN
               ZTYLO = 2
               ZTYHI = 2
            ELSE IF( TYPE .EQ. '_INTEGER' ) THEN
               ZTYLO = 3
               ZTYHI = 3
            ELSE IF( DCB_TYP( IDCBT ) .EQ. '_INTEGER' ) THEN
               ZTYLO = 1
               ZTYHI = 3
            ELSE IF( DCB_TYP( IDCBT ) .EQ. '_WORD' ) THEN
               ZTYLO = 1
               ZTYHI = 2
            ELSE
               ZTYLO = 1
               ZTYHI = 1
            END IF

*  Initialise the best compression found so far.
            ZRATIO = VAL__MINR

*  Loop round all ZAXIS values
            DO ZAX = ZAXLO, ZAXHI

*  Skip this axis if it spans only a single pixel.
               IF( ACB_UBND( ZAX, IACBT ) .GT.
     :             ACB_LBND( ZAX, IACBT ) + 1 ) THEN

*  Loop round all compressed data types.
                  DO ZTY = ZTYLO, ZTYHI

*  See how much compression could be expected using this combination of
*  compression axis and data type.
                     CALL ARY1_S2DLT( DCB_LOC( IDCBT ), ZAX,
     :                                TYPES( ZTY ),ARY__NOLOC, RATIO,
     :                                STATUS )

*  Record the current compresson axis and type if this combination gives
*  more compression than any other combination tested so far.
                     IF( RATIO .GT. ZRATIO ) THEN
                        ZRATIO = RATIO
                        ZAXUSE = ZAX
                        ZTYUSE = TYPES( ZTY )
                     END IF

                  END DO
               END IF
            END DO

*  Otherwise, just use the supplied compression values.
         ELSE
            ZAXUSE = ZAXIS
            ZTYUSE = TYPE
         END IF

*  Create a new simple array structure in place of the placeholder
*  object, obtaining a DCB entry which refers to it. Creation of the
*  primitive array is deferred since we do not yet know how big it will need
*  to be.
         CALL ARY1_DCRE( .TRUE., DCB_TYP( IDCBT ), DCB_CPX( IDCBT ),
     :                   ACB_NDIM( IACBT ), ACB_LBND( 1, IACBT ),
     :                   ACB_UBND( 1, IACBT ), PCB_TMP( IPCB ),
     :                   PCB_LOC( IPCB ), IDCB2, STATUS )
         IF( STATUS .NE. SAI__OK ) GO TO 999

*  Erase all components within the data object - they will be re-created
*  in compressed form by ARY1_S2DLT.
         CALL DAT_NCOMP( DCB_LOC( IDCB2 ), NCOMP, STATUS )
         DO ICOMP = 1, NCOMP
            CALL DAT_INDEX( DCB_LOC( IDCB2 ), 1, LOCC, STATUS )
            CALL DAT_NAME( LOCC, NAME, STATUS )
            CALL DAT_ANNUL( LOCC, STATUS )
            CALL DAT_ERASE( DCB_LOC( IDCB2 ), NAME, STATUS )
         END DO

*  Now do the compression using the best combination.
         CALL ARY1_S2DLT( DCB_LOC( IDCBT ), ZAXUSE, ZTYUSE,
     :                    DCB_LOC( IDCB2 ), ZRATIO, STATUS )

*  If the compression ratio is too small, annul the DCB entry created
*  above and create a copy of the supplied array instead.
         IF( ZRATIO .LE. MINRAT ) THEN

*  The data object locator is needed as a placeholder for the copy, so
*  take a clone of it now, and then annul the DCB entry, without
*  disposing of the data object.
            CALL DAT_CLONE( DCB_LOC( IDCB2 ), PCB_LOC( IPCB ), STATUS )
            CALL ARY1_DANL( .FALSE., IDCB2, STATUS )

*  Empty the old data object so we can use it as a placeholder for the new
*  copy.
            CALL DAT_NCOMP( PCB_LOC( IPCB ), NCOMP, STATUS )
            DO ICOMP = 1, NCOMP
               CALL DAT_INDEX( PCB_LOC( IPCB ), 1, LOCC, STATUS )
               CALL DAT_NAME( LOCC, NAME, STATUS )
               CALL DAT_ANNUL( LOCC, STATUS )
               CALL DAT_ERASE( PCB_LOC( IPCB ), NAME, STATUS )
            END DO

            CALL ARY1_CPY( IACBT, PCB_TMP( IPCB ), PCB_LOC( IPCB ),
     :                     .TRUE., IACB2, STATUS )

*  If the compression ratio was high enough, and all went well, store the
*  new storage form in the DCB.
         ELSE IF( STATUS .EQ. SAI__OK ) THEN
            DCB_FRM( IDCB2 ) = 'DELTA'

*  Obtain a locator to the non-imaginary data component to the new array.
            CALL DAT_FIND( DCB_LOC( IDCB2 ), 'DATA', DCB_DLOC( IDCB2 ),
     :                     STATUS )

*  Indicate state information is out of date.
            DCB_KSTA( IDCB2 ) = .FALSE.

*  Create a base array entry in the ACB to refer to the output DCB entry.
            CALL ARY1_CRNBA( IDCB2, IACB2, STATUS )

         END IF
      END IF

*  Arrive here if an error occurrs.
 999  CONTINUE

*  If all went well, export an identifier for the output array
      IF( STATUS .EQ. SAI__OK ) THEN
         CALL ARY1_EXPID( IACB2, IARY2, STATUS )

*  If an error occurred, then annul the new ACB entry and reset the
*  IACB2 argument to zero.
         IF ( ( STATUS .NE. SAI__OK ) .AND. ( IACB2 .NE. 0 ) ) THEN
            CALL ARY1_ANL( IACB2, STATUS )
            IACB2 = 0
         END IF
      END IF

*  Annul any temporary base copy of the input array.
      IF( LOCT .NE. DAT__NOLOC ) CALL ARY1_ANTMP( LOCT, STATUS )

*  Annul the placeholder, erasing the associated object if any error has
*  occurred.
      IF( IPCB .NE. 0 ) THEN
         ERASE = ( STATUS .NE. SAI__OK )
         CALL ARY1_ANNPL( ERASE, IPCB, STATUS )
      END IF

*  Reset the PLACE argument.
      PLACE = ARY__NOPL

*  If an error occurred, then report context information and call the
*  error tracing routine.
      IF( STATUS .NE. SAI__OK ) THEN
         CALL ERR_REP( 'ARY_DELTA_ERR', 'ARY_DELTA: Error compressing'//
     :                 ' an array using delta compression.', STATUS )
         CALL ARY1_TRACE( 'ARY_DELTA', STATUS )
      END IF

      END
