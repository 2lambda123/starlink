/*
*      SUBROUTINE EMS_FIOER( TOKEN, IOSTAT )
*+
*  Name:
*     EMS_FIOER

*  Purpose:
*     Assign a Fortran I/O error message to a token (Alpha version).

*  Language:
*     ANSII C

*  Invocation:
*     CALL EMS_FIOER( TOKEN, IOSTAT )

*  Description:
*     The text of the error message associated with the Fortran I/O status 
*     value, IOSTAT, is assigned to the message token, TOKEN. This token may
*     then be included in an error message. 

*  Implementation Notes:
*     This function is only expected to be called from Fortran, so there is
*     not a C function emsFioer underlying this Fortran interface.

*  Alpha Specifics:
*     The header file foriosdef_alpha.h is adapted from
*     /usr/include/foriosdef.f for Alpha platforms

*  Arguments:
*     TOKEN = CHARACTER * ( * ) (Given)
*        The message token name.
*     IOSTAT = INTEGER (Given)
*        The Fortran I/O status value.

*  Authors:
*     A.J.Chipperfield (Starlink, RAL)
*     {enter_new_authors_here}

*  History:
*     14-MAR-2001 (AJC):
*        Original version, based upon Fortran version.
*     13-AUG-2000 (AJC):
*        #include ems1.h
*     {enter_changes_here}

*  Bugs:
*     {note_any_bugs_here}

*-
*/
#include "f77.h"
#include "ems_par.h"                  /* EMS_ parameters */
#include "ems_sys.h"                  /* EMS_ System constants */
#include "ems.h"                      /* EMS_ function prototypes */
#include "ems1.h"                     /* EMS1_ function prototypes */
#include "foriosdef_alpha.h"          /* Alpha error numbers */

F77_SUBROUTINE (ems_fioer)( CHARACTER(token), INTEGER(iostat) TRAIL(token) )
{
   char ctok[ EMS__SZMSG + 1 ];     /* Imported token name */
   char msg[ EMS__SZTOK + 1 ];      /* Message buffer */

   GENPTR_CHARACTER(token)
   GENPTR_INTEGER(iostat)

/* Import the token name */
   cnfImpn( token, token_length, EMS__SZNAM, ctok );

/* Initialise the message */
   msg[0] = '\0';

/*  Attempt to find a match to IOSTAT and load MESVAL appropriately. */
   if ( *iostat == 0 ) {
      strcpy( msg, "No error" );

   } else if ( *iostat == IOS_EOF ) {
      strcpy( msg, "End-of-file" );

   } else if ( *iostat == IOS_NOTFORSPE ) {
      strcpy( msg, "Not a FORTRAN-specific error" );

   } else if ( *iostat == IOS_PERACCFIL ) {
      strcpy( msg, "Permission to access file denied" );

   } else if ( *iostat == IOS_CANOVEEXI ) {
      strcpy( msg, "Cannot overwrite existing file" );

   } else if ( *iostat == IOS_UNINOTCON ) {
      strcpy( msg, "Unit not connected" );

   } else if ( *iostat == IOS_SYNERRNAM ) { 
      strcpy( msg, "Syntax error in NAMELIST input" );

   } else if ( *iostat == IOS_TOOMANVAL ) {
      strcpy( msg, "Too many values for NAMELIST variable" );

   } else if ( *iostat == IOS_INVREFVAR ) {
      strcpy( msg, "Invalid reference to variable in NAMELIST input" );

   } else if ( *iostat == IOS_REWERR ) {
      strcpy( msg, "REWIND error" );

   } else if ( *iostat == IOS_DUPFILSPE ) {
      strcpy( msg, "Duplicate file specifications" );

   } else if ( *iostat == IOS_INPRECTOO ) {
      strcpy( msg, "Input record too long" );

   } else if ( *iostat == IOS_BACERR ) {
      strcpy( msg, "BACKSPACE error" );

   } else if ( *iostat == IOS_ENDDURREA ) {
      strcpy( msg, "End-of-file during read" );

   } else if ( *iostat == IOS_RECNUMOUT ) {
      strcpy( msg, "Record number outside range" );

   } else if ( *iostat == IOS_OPEDEFREQ ) {
      strcpy( msg, "OPEN or DEFINE FILE required" );

   } else if ( *iostat == IOS_TOOMANREC ) {
      strcpy( msg, "Too many records in I/O statement" );

   } else if ( *iostat == IOS_CLOERR ) {
      strcpy( msg, "CLOSE error" );

   } else if ( *iostat == IOS_FILNOTFOU ) {
      strcpy( msg, "File not found" );

   } else if ( *iostat == IOS_OPEFAI ) {
      strcpy( msg, "Open failure" );

   } else if ( *iostat == IOS_MIXFILACC ) {
      strcpy( msg, "Mixed file access modes" );

   } else if ( *iostat == IOS_INVLOGUNI ) {
      strcpy( msg, "Invalid logical unit number" );

   } else if ( *iostat == IOS_ENDFILERR ) {
      strcpy( msg, "ENDFILE error" );

   } else if ( *iostat == IOS_UNIALROPE ) {
      strcpy( msg, "Unit already open" );

   } else if ( *iostat == IOS_SEGRECFOR ) {
      strcpy( msg, "Segmented record format error" );

   } else if ( *iostat == IOS_ATTACCNON ) {
      strcpy( msg, "Attempt to access non-existent record" );

   } else if ( *iostat == IOS_INCRECLEN ) {
      strcpy( msg, "Inconsistent record length" );

   } else if ( *iostat == IOS_ERRDURWRI ) {
      strcpy( msg, "Error during write" );

   } else if ( *iostat == IOS_ERRDURREA ) {
      strcpy( msg, "Error during read" );

   } else if ( *iostat == IOS_RECIO_OPE ) {
      strcpy( msg, "Recursive I/O operation" );

   } else if ( *iostat == IOS_INSVIRMEM ) {
      strcpy( msg, "Insufficient virtual memory" );

   } else if ( *iostat == IOS_NO_SUCDEV ) {
      strcpy( msg, "No such device" );

   } else if ( *iostat == IOS_FILNAMSPE ) {
      strcpy( msg, "File name specification error" );

   } else if ( *iostat == IOS_INCRECTYP ) {
      strcpy( msg, "Inconsistent record type" );

   } else if ( *iostat == IOS_KEYVALERR ) {
      strcpy( msg, "Keyword value error in OPEN statement" );

   } else if ( *iostat == IOS_INCOPECLO ) {
      strcpy( msg, "Inconsistent OPEN/CLOSE parameters" );

   } else if ( *iostat == IOS_WRIREAFIL ) {
      strcpy( msg, "Write to READONLY file" );

   } else if ( *iostat == IOS_INVARGFOR ) {
      strcpy( msg, "Invalid argument to FORTRAN Run-Time Library" );

   } else if ( *iostat == IOS_INCFILORG ) {
      strcpy( msg, "Inconsistent file organisation" );

   } else if ( *iostat == IOS_DELERR ) {
      strcpy( msg, "DELETE error" );

   } else if ( *iostat == IOS_FINERR ) {
      strcpy( msg, "FIND error" );

   } else if ( *iostat == IOS_LISIO_SYN ) {
      strcpy( msg, "List-directed I/O syntax error" );

   } else if ( *iostat == IOS_INFFORLOO ) {
      strcpy( msg, "Infinite format loop" );

   } else if ( *iostat == IOS_FORVARMIS ) {
      strcpy( msg, "Format/variable-type mismatch" );

   } else if ( *iostat == IOS_SYNERRFOR ) {
      strcpy( msg, "Syntax error in format" );

   } else if ( *iostat == IOS_OUTCONERR ) {
      strcpy( msg, "Output conversion error" );

   } else if ( *iostat == IOS_INPCONERR ) {
      strcpy( msg, "Input conversion error" );

   } else if ( *iostat == IOS_FLTINV ) {
      strcpy( msg, "Floating invalid" );

   } else if ( *iostat == IOS_OUTSTAOVE ) {
      strcpy( msg, "Output statement overflows record" );

   } else if ( *iostat == IOS_INPSTAREQ ) {
      strcpy( msg, "Input statement requires too much data" );

   } else if ( *iostat == IOS_VFEVALERR ) { 
      strcpy( msg, "Variable format expression value error" );

   } else if ( *iostat == IOS_ADJARRDIM ) { 
      strcpy( msg, "Adjustable array dimension error" );

   } else if ( *iostat == IOS_CANSTAFIL ) { 
      strcpy( msg, "Cannot stat file" );

   } else if ( *iostat == IOS_OPEREQSEE ) { 
      strcpy( msg, "Operation requires seek ability" );

   } else if ( *iostat == IOS_UNFIO_FMT ) { 
      strcpy( msg, "Unformatted I/O to unit open for formatted transfers" );

   } else if ( *iostat == IOS_FMTIO_UNF ) { 
      strcpy( msg, "Formatted I/O to unit open for unformatted transfers" );

   }

/*  Determine length of MESVAL and set message token accordingly. */
   if ( strlen(msg) > 0 ) {

/*  Set the message token. */
      ems1Stok( ctok, msg );

    } else {
/*  No message string exists, so call EMS_SYSER to attempt to find an 
*  associated operating system error message. */
      emsSyser( ctok, *iostat );
   }

}
