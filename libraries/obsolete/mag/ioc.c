
/* Global constants:                                                        */

#include <unistd.h>
#include <ctype.h>

#include "sae_par.h"                  /* ADAM constants                     */
#include "f77.h"                      /* C - Fortran interface              */
#include "ioc_incl.h"                 /* IOC constants                      */


/* Subroutine:  ioc_close (chan, status)
*+
*  Name:
*     IOC_CLOSE

*  Purpose:
*     Close a magnetic tape device

*  Language:
*    ANSI C

*  Invocation:
*     CALL IOC_CLOSE( CHAN, STATUS )

*  Description:
*     Invokes the low level close function to close the channel specified
*     by chan. It does its best to close the tape even if the input
*     status is bad. It returns the status of the close operation if it
*     produced an error; otherwise it returns the input status.
*     In practice its main effect is to release the i/o channel number
*     for re-use.

* Arguments:
*     CHAN = INTEGER (Given)
*        A small integer generated by ioc_open which identifies the specific
*        i/o channel being used.
*     STATUS = INTEGER (Given and Returned)
*        The Global status.

*  Notes:
*     It appears that some device drivers on some platforms automatically
*     write an end-of-tape mark when closing a tape which was opened
*     for writing. It is therefore not a good idea, for example, to
*     rewind a tape before closing it, as the result is to put an EOT
*     at the start of the tape!

*  References:
*     - see manual pages - man 2 close

*  Copyright:
*     Copyright (C) 1991, 1993 Science & Engineering Research Council.
*     All Rights Reserved.

*  Licence:
*     This program is free software; you can redistribute it and/or
*     modify it under the terms of the GNU General Public License as
*     published by the Free Software Foundation; either version 2 of
*     the License, or (at your option) any later version.
*
*     This program is distributed in the hope that it will be
*     useful,but WITHOUT ANY WARRANTY; without even the implied
*     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
*     PURPOSE. See the GNU General Public License for more details.
*
*     You should have received a copy of the GNU General Public License
*     along with this program; if not, write to the Free Software
*     Foundation, Inc., 59 Temple Place,Suite 330, Boston, MA
*     02111-1307, USA

*  Authors:
*     KFH: Ken Hartley (RAL)

*  History:
*     11-Dec-1991  (KFH):
*        Original version.
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}

*-
*-----------------------------------------------------------------------------
*/

F77_SUBROUTINE(ioc_close) ( INTEGER(chan), INTEGER(status) )

{

/* Pointers to arguments:                                                   */


   GENPTR_INTEGER(chan)
   GENPTR_INTEGER(status)

/* Local variables:                                                         */

   int istat;                         /* temporary storage for the status   */

   istat = close (*chan);

/* Handle error reporting                                                   */

   if (*status == SAI__OK && istat == -1 )
   {
      if (errno == EBADF)
         *status = MIO__INVCH;
      else
         *status = MIO__ERROR;
   }
}


/* Subroutine:  ioc_open (device, dev_len, acmode, acc_len, chan, status)
*+
*  Name:
*     IOC_OPEN

*  Purpose:
*     Open a magnetic tape device

*  Language:
*    ANSI C

*  Invocation:
*     CALL IOC_OPEN( DEVICE, LEN_DEV, ACMODE, LEN_AC, CHAN, STATUS)

*  Description:
*     Invokes the low level open function to open the specified device
*     for reading and/or writing, returning a channel number to be used
*     by all subsequent tape accesses.

* Arguments:
*     DEVICE = CHARACTER * ( * ) (Given)
*        A character variable which contains the name of the device
*        to be opened. Typically this will be something like
*        /dev/rst0, but in Unix the pathname of any file is acceptable.
*     LEN_DEV = INTEGER (Given)
*        The length of the character string DEVICE.
*        One way of defining this is to use the function LEN in the
*        argument list of the CALL.
*     ACMODE = CHARACTER * ( * ) (Given)
*        A word starting with r or R will cause the tape to be opened
*        for reading; one starting with w or W will cause it to be opened
*        for writing. Anything else will allow read and write access, but
*        this may be seen as an error on some devices.
*     LEN_AC = INTEGER (Given)
*        The length of the character string ACMODE.
*        One way of defining this is to use the function LEN in the
*        argument list of the CALL.
*     CHAN = INTEGER (Returned)
*        A small integer returned by the system which identifies the specific
*        i/o channel being used. More than one channel may be in use at a
*        time - the maximum number available is system dependent.
*     STATUS = INTEGER (Given and Returned)
*        The Global status.

*  References:
*     - see manual pages - man 2 open

*  Authors:
*     KFH: Ken Hartley (RAL)

*  History:
*     11-Dec-1991  (KFH):
*        Original version.
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}

*-
*-----------------------------------------------------------------------------
*/
F77_SUBROUTINE(ioc_open) ( CHARACTER(device), INTEGER(dev_1),
                           CHARACTER(acmode), INTEGER(acc_1),
                           INTEGER(chan), INTEGER(status) TRAIL(device)
                           TRAIL(acmode) )

{

/* Pointers to arguments:                                                   */


   GENPTR_CHARACTER(device)
   GENPTR_INTEGER(dev_1)
   GENPTR_CHARACTER(acmode)
   GENPTR_INTEGER(acc_1)
   GENPTR_INTEGER(chan)
   GENPTR_INTEGER(status)

/* Local variables                                                          */

   int flags;                     /* read/write flag for open               */
   int ichan;                     /* temporary storage for channel number   */
   char dev[25];                  /* working string from device             */
   char acc[10];                  /* working string from acmode             */

/* Import the two strings                                                   */

   cnf_imprt(device, *dev_1, dev);

   cnf_imprt(acmode, *acc_1, acc);

/* Check for inherited global status                                        */

   if (*status != SAI__OK) return;

/* set the flag to the appropriate system value depending on the first
 * letter of the string.                                                    */

   switch (toupper(acmode[0]))
   {   case 'R':
       { flags = O_RDONLY;
         break;
       }
       case 'W':
       { flags = O_WRONLY;
         break;
       }
       default:
         flags = O_RDWR;
   }

/*    Having established the type of access, open the device                */
      ichan = open (dev, flags);

/*    Handle error reporting - a return value of -1 indicates problems.     */

      if ( ichan == -1)

/*    The standard variable errno stores the error code returned by open    */
      {
         if (errno == EACCES )
            *status = MIO__ACVIO;
         else if (errno == ENOENT || errno == ENODEV )
            *status = MIO__NSHDV;
         else if (errno == EMFILE )
            *status = MIO__EXCCH;
         else
            *status = MIO__ERROR;
      }
      else
      {
         *status = SAI__OK;
      }

/* and return the assigned channel to the calling routine.                  */

   *chan = ichan;
}



/* Subroutine:  ioc_read (chan, , maxvals, buffer, actvals, status)
*+
*  Name:
*     IOC_READ

*  Purpose:
*     Read a block from a magnetic tape device

*  Language:
*    ANSI C

*  Invocation:
*     CALL IOC_READ( CHAN, MAXVALS, BUFFER, ACTVALS, STATUS )

*  Description:
*     Invokes the low level read function to read a block from the tape
*     specified by chan.

* Arguments:
*     CHAN = INTEGER (Given)
*        A small integer generated by ioc_open which identifies the specific
*        i/o channel being used.
*     MAXVALS = INTEGER (Given)
*        The size of BUFFER and hence the largest number of bytes which
*        can be read. Some devices may have fixed size blocks. If so, MAXVALS
*        must be large enough to handle these blocks.
*     BUFFER = BYTE ARRAY (Returned)
*        After a successful read operation it contains the ACTVALS bytes of
*        data which were read. In C BYTE variables are usually represented
*        by CHARACTERs.
*     ACTVALS = INTEGER (Returned)
*        The actual number of bytes returned. It must be less than or equal
*        to MAXVALS.
*     STATUS = INTEGER ( Given and Returned)
*        The Global status.

*  Notes:
*     If an error occurs whilst reading the block the number of bytes
*     read is returned as -1; if a tape mark is read then the number of
*     bytes read is 0.

*  References:
*     - see manual pages - man 2 read

*  Authors:
*     KFH: Ken Hartley (RAL)
*     PMA: Peter Allan (Starlink, RAL)

*  History:
*     11-Dec-1991  (KFH):
*        Original version.
*     29-APR-1993  (PMA):
*        Set status to MIO__EOF if the number of bytes read is zero.
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}

*-
*-----------------------------------------------------------------------------
*/

F77_SUBROUTINE(ioc_read) ( INTEGER(chan), INTEGER(maxvals),
                           BYTE_ARRAY(buffer), INTEGER(actvals),
                           INTEGER(status) )

{

/* Pointers to arguments:                                                   */


   GENPTR_INTEGER(chan)
   GENPTR_INTEGER(maxvals)
   GENPTR_BYTE_ARRAY(buffer)
   GENPTR_INTEGER(actvals)
   GENPTR_INTEGER(status)

/* Local variables:                                                         */

   int nvals;                /* Temporary storage for number of values read */

/* Test global status and return if not OK                                  */

   if (*status != SAI__OK) return;

/* Read a block                                                             */

   nvals = read(*chan, buffer, *maxvals);

/* Handle error reporting                                                   */

   if (nvals == -1)
   {
      if (errno == EBADF || errno == EINVAL)
      {
         *status = MIO__INVCH;
      }
      else if (errno == EIO)
      {
         *status = MIO__PARIT;
      }
      else
         *status = MIO__ERROR;
   }
   else
      if (nvals == 0)
         *status = MIO__EOF;
      else
         *status = SAI__OK;

/* Report actual number of values returned (-1 on error)                    */

   *actvals = nvals;
}



/* Subroutine:  ioc_rew (chan, status)
*+
*  Name:
*     IOC_REW

*  Purpose:
*     Rewinds a magnetic tape device

*  Language:
*    ANSI C

*  Invocation:
*     CALL IOC_REW( CHAN, STATUS )

*  Description:
*     Uses a Unix system ioctl to rewind a magnetic tape.

* Arguments:
*     CHAN = INTEGER (Given)
*        A small integer generated by ioc_open which identifies the specific
*        i/o channel being used.
*     STATUS = INTEGER (Given and Returned)
*        The Global status.

*  Notes:
*     It may sometimes be necessary to use this routine to clear a bad
*     error status such as might arise by trying to backspace beyond the
*     beginning of a tape.

*     It tries to rewind the tape even if the input status is bad; if the
*     rewind fails that status is reported, but otherwise it returns the
*     same status it was given.

*  References:
*     - see manual pages - man 4 mtio

*  Authors:
*     KFH: Ken Hartley (RAL)

*  History:
*     11-Dec-1991  (KFH):
*        Original version.
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}

*-
*-----------------------------------------------------------------------------
*/

F77_SUBROUTINE(ioc_rew) ( INTEGER(chan), INTEGER(status) )

{

/* Pointers to arguments:                                                   */


   GENPTR_INTEGER(chan)
   GENPTR_INTEGER(status)

/* Local variables:                                                         */


/* specific examples of generic data structures for these mt operations     */


   struct mtop oper;                  /* structure use by MTIOCTOP          */
   struct mtget stat;                 /* structure used for MTIOCGET        */

   int iret;                          /* return vlaue from the ioctl        */

/* Try to rewind the tape, irrespective of the input status                 */

   oper.mt_op = MTREW;
   oper.mt_count = 1;

   iret = ioctl(*chan, MTIOCTOP, &oper);
   (void)ioctl(*chan, MTIOCGET, (char *)&stat);

/* If the input status was good but rewind has created an
   error, then set the new status return;
   otherwise the status returned is the one received.
*/
   if (*status == SAI__OK && iret == -1)
      *status = MIO__ERROR;
}



/* Subroutine:  ioc_skipb (chan, dir, status)
*+
*  Name:
*     IOC_SKIPB

*  Purpose:
*     Skips backwards or forwards on the tape by one block.
*  Language:
*    ANSI C

*  Invocation:
*     CALL IOC_SKIPB( CHAN, DIR, STATUS )

*  Description:
*     Uses a Unix system ioctl to move the tape by one block or physical
*     record. The result is to place it at the next inter-block gap.

* Arguments:
*     CHAN = INTEGER (Given)
*        A small integer generated by ioc_open which identifies the specific
*        i/o channel being used.
*     DIR = INTEGER (Given)
*        Specifies the direction to be skipped. A positive value causes the
*        tape to be positioned one block further away from the beginning of
*        the tape (BOT). A negative values causes the tape to be positioned
*        one block nearer to the BOT.  A value of 0 is deemed to be an error
*        as it is ambiguous.
*     STATUS = INTEGER (Given and Returned)
*        The Global status.

*  Notes:
*     It is an error if a tape mark or BOT is encountered during a skip
*     operation. Device drivers differ in the actual location of the
*     tape after such an occurrence and it can sometimes be difficult
*     to continue with reading the tape. A rewind appears to clear all the
*     problems, but this loses the current position of the tape.
*  References:
*     - see manual pages - man 4 mtio

*  Authors:
*     KFH: Ken Hartley (RAL)

*  History:
*     11-Dec-1991  (KFH):
*        Original version.
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}

*-
*-----------------------------------------------------------------------------
*/

F77_SUBROUTINE(ioc_skipb) ( INTEGER(chan), INTEGER(dir), INTEGER(status) )

{

/* Pointers to arguments:                                                   */


   GENPTR_INTEGER(chan)
   GENPTR_INTEGER(dir)
   GENPTR_INTEGER(status)

/* Local variables:                                                         */


/* specific examples of generic data structures for these mt operations     */


   struct mtop oper;                  /* structure use by MTIOCTOP          */
   struct mtget stat;                 /* structure used for MTIOCGET        */

   int iret;                          /* return vlaue from the ioctl        */
   int istat;                         /* temporary store for status         */

/* test for bad input status                                                */

   if (*status != SAI__OK ) return;

/* Check direction of skip                                                  */

   if (*dir > 0)
   {
      oper.mt_op = MTFSR;
      istat = SAI__OK;
   }
   else if (*dir < 0)
   {
      oper.mt_op = MTBSR;
      istat = SAI__OK;
   }
   else
   {

/*     Note that a zero value is ambiguous so an error is reported          */

      istat = MIO__NTSUP;
   }

/* and do the skip provided an unambiguous direction is set                 */

   if (istat == SAI__OK)
   {
      oper.mt_count = 1;
      iret = ioctl(*chan, MTIOCTOP, &oper);
      (void)ioctl(*chan, MTIOCGET, (char *)&stat);
      if (iret == -1)
      {
         *status = MIO__ERROR;

/*       Try to clear bad status, but do not report if it fails             */

            oper.mt_op = MTNOP;
            (void)ioctl(*chan, MTIOCTOP, &oper);

      }
   }
   else
   {
      *status = istat;
   }
}



/* Subroutine:  ioc_skipf (chan, dir, status)
*+
*  Name:
*     IOC_SKIPF

*  Purpose:
*     Skips backwards or forwards on the tape by one file.
*  Language:
*    ANSI C

*  Invocation:
*     CALL IOC_SKIPF( CHAN, DIR, STATUS )

*  Description:
*     Uses a Unix system ioctl to move the tape by one file. The result
*     is to place it at the inter-block gap beyond the EOF (ie just before
*     it if going backwards or just after it if going forwards).

* Arguments:
*     CHAN = INTEGER (Given)
*        A small integer generated by ioc_open which identifies the specific
*        i/o channel being used.
*     DIR = INTEGER (Given)
*        Specifies the direction to be skipped. A positive value causes the
*        tape to be positioned just after the next file mark further away
*        from the beginning of the tape(BOT). A negative values causes the
*        tape to be positioned just before the next file mark nearer to the
*        BOT.  A value of 0 is deemed to be an error as it is ambiguous.
*     STATUS = INTEGER ( Returned)
*        The Global status.

*  Notes:
*     It is an error to skip beyond the BOT or EOT and is reported as such.
*  References:
*     - see manual pages - man 4 mtio

*  Authors:
*     KFH: Ken Hartley (RAL)

*  History:
*     11-Dec-1991  (KFH):
*        Original version.
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}

*-
*-----------------------------------------------------------------------------
*/

F77_SUBROUTINE(ioc_skipf) ( INTEGER(chan), INTEGER(dir), INTEGER(status) )

{

/* Pointers to arguments:                                                   */


   GENPTR_INTEGER(chan)
   GENPTR_INTEGER(dir)
   GENPTR_INTEGER(status)

/* Local variables:                                                         */


/* specific examples of generic data structures for these mt operations     */


   struct mtop oper;                  /* structure use by MTIOCTOP          */
   struct mtget stat;                 /* structure used for MTIOCGET        */

   int iret;                          /* return vlaue from the ioctl        */

/* test for bad input status                                                */

   if (*status != SAI__OK ) return;

/* First handle the forward skip option                                     */

   if (*dir > 0)
   {
      oper.mt_op = MTFSF;
      oper.mt_count = 1;
      iret = ioctl(*chan, MTIOCTOP, &oper);
      (void)ioctl(*chan, MTIOCGET, (char *)&stat);
      if (iret == -1)
      {
         *status = MIO__ERROR;

/*       Try to clear bad status, but do not report if it fails             */

            oper.mt_op = MTNOP;
            (void)ioctl(*chan, MTIOCTOP, &oper);
      }
      else
         *status = SAI__OK;
   }

/*    The backward skip is more difficult as slightly
      different approaches may be required for some devices on
      some platforms. This code gives the best chance of
      success and only reports an error on failure of both.
*/
   else if (*dir < 0)
   {
      oper.mt_op = MTBSF;
      oper.mt_count = 1;
      iret = ioctl(*chan, MTIOCTOP, &oper);
      if (iret == -1)
      {

/*       Try to clear bad status, but do not report if it fails             */

            oper.mt_op = MTNOP;
            (void)ioctl(*chan, MTIOCTOP, &oper);

         oper.mt_op = MTFSF;
         oper.mt_count = -1;
         iret = ioctl(*chan, MTIOCTOP, &oper);
         (void)ioctl(*chan, MTIOCGET, (char *)&stat);
         if (iret == -1)
         {
            *status = MIO__ERROR;

/*       Try to clear bad status, but do not report if it fails             */

            oper.mt_op = MTNOP;
            (void)ioctl(*chan, MTIOCTOP, &oper);

         }
         else
         {
            *status = SAI__OK;
         }
      }
      else
      {
         *status = SAI__OK;
      }
   }
   else
   {
      *status = MIO__ERROR;
   }
}



/* Subroutine:  ioc_weof (chan, status)
*+
*  Name:
*     IOC_WEOF

*  Purpose:
*     Write an End-of-File mark (or Tape Mark) on a magnetic tape device.

*  Language:
*    ANSI C

*  Invocation:
*     CALL IOC_WEOF( CHAN, STATUS )

*  Description:
*     Uses a Unix system ioctl to write an end-of-file mark (sometimes
*     called a tape mark) on to a magnetic tape.

* Arguments:
*     CHAN = INTEGER (Given)
*        A small integer generated by ioc_open which identifies the specific
*        i/o channel being used.
*     STATUS = INTEGER (Given and Returned)
*        The Global status.

*  Notes:
*     An end-of-file is indistinguishable from a zero length record and will
*     be read as such by ioc_read.

*  References:
*     - see manual pages - man 4 mtio

*  Authors:
*     KFH: Ken Hartley (RAL)

*  History:
*     11-Dec-1991  (KFH):
*        Original version.
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}

*-
*-----------------------------------------------------------------------------
*/

F77_SUBROUTINE(ioc_weof) ( INTEGER(chan), INTEGER(status) )

{

/* Pointers to arguments:                                                   */


   GENPTR_INTEGER(chan)
   GENPTR_INTEGER(status)

/* Local variables:                                                         */


/* specific examples of generic data structures for these mt operations     */


   struct mtop oper;                  /* structure use by MTIOCTOP          */
   struct mtget stat;                 /* structure used for MTIOCGET        */

   int iret;                          /* return value from the ioctl        */

/* Test for bad global status                                               */
   if (*status != SAI__OK) return;

/* Set up the control codes for the ioctls and then invoke them.            */

   oper.mt_op = MTWEOF;
   oper.mt_count = 1;

   iret = ioctl(*chan, MTIOCTOP, &oper);
   (void)ioctl(*chan, MTIOCGET, (char *)&stat);

/* Handle error reporting                                                   */

   if (iret == -1)
   {
      *status = MIO__ERROR;
   }
   else
   {
      *status = SAI__OK;
   }
}


/* Subroutine:  ioc_write (chan, , numvals, buffer, actvals, status)
*+
*  Name:
*     IOC_WRITE

*  Purpose:
*     Write a block to a magnetic tape device

*  Language:
*    ANSI C

*  Invocation:
*     CALL IOC_WRITE( CHAN, NUMVALS, BUFFER, ACTVALS, STATUS )

*  Description:
*     Invokes the low level write function to write a block to the tape
*     specified by chan.

* Arguments:
*     CHAN = INTEGER (Given)
*        A small integer generated by ioc_open which identifies the specific
*        i/o channel being used.
*     NUMVALS = INTEGER (Given)
*        The number of bytes to be written. It must be no larger than the
*        size of BUFFER.
*     BUFFER = BYTE ARRAY (Returned)
*        Array which contains the NUMVALS bytes of data to be written to the
*        tape. In C BYTE variables are usually represented
*        by CHARACTERs.
*     ACTVALS = INTEGER (Returned)
*        The actual number of bytes written. It is an error if this is not
*        equal to NUMVALS.
*     STATUS = INTEGER ( Given and Returned)
*        The Global status.

*  Notes:
*     If an error occurs whilst writing to the block the number of bytes
*     written is returned as -1.

*  References:
*     - see manual pages - man 2 write

*  Authors:
*     KFH: Ken Hartley (RAL)

*  History:
*     11-Dec-1991  (KFH):
*        Original version.
*     {enter_further_changes_here}

*  Bugs:
*     {note_any_bugs_here}

*-
*-----------------------------------------------------------------------------
*/

F77_SUBROUTINE(ioc_write) ( INTEGER(chan), INTEGER(numvals),
                            BYTE_ARRAY(buffer), INTEGER(actvals),
                            INTEGER(status) )

{

/* Pointers to arguments:                                                   */


   GENPTR_INTEGER(chan)
   GENPTR_INTEGER(numvals)
   GENPTR_BYTE_ARRAY(buffer)
   GENPTR_INTEGER(actvals)
   GENPTR_INTEGER(status)

/* Local variables:                                                         */

   int nvals;         /* Temporary storage for the number of values written */

/* Test global status and return if not OK                                  */

   if (*status != SAI__OK) return;

/* Write a block                                                            */

   nvals = write(*chan, buffer, *numvals);


/* Handle error reporting                                                   */

   if (nvals == -1 )
   {
      if (errno == EBADF || errno == EINVAL)
      {
         *status = MIO__INVCH;
      }
      else if (errno == EIO)
      {
         *status = MIO__DTCHK;
      }
      else
         *status = MIO__ERROR;
   }
   else
      *status = SAI__OK;

/* it is an error if the number of values written is not the
   same as the number requested
 */
   if (nvals != *numvals)
      *status = MIO__IVBSZ;

/* Report actual number of values written                                   */

   *actvals = nvals;
}

