\documentclass[11pt]{starlink}


% -----------------------------------------------------------------------------
% ? Document identification
\stardoccategory    {Starlink User Note}
\stardocinitials    {SUN}
\stardocsource      {sun\stardocnumber}
\stardocnumber      {171.1}
\stardocauthors   {P.M. Allan \\
                                A.J. Chipperfield}
\stardocdate        {12 November 1996}
\stardoctitle       {MAG \\ [\latex{1ex}]
                                Access to magnetic tapes}
\stardocversion     {Version 2.0}
\stardocmanual      {Programmer's Manual}
\stardocabstract {%
The MAG subroutine library allows a programmer to write portable programs
which access data stored on magnetic tapes.

By using the MAG routines, a program can read and write tapes, position the
tape (both in absolute terms and relative to the current position) and can
control the allocation of the tape drive and the physical mounting of the tape
on systems which provide that facility.

The library is currently supported for Sun Sparcstations running Solaris and
for DEC Alphas running OSF/1. Historically it has been supported for DEC
Ultrix and for SunOS and may still work for them.

The library is also available for VAX/VMS systems.
}
% ? End of document identification

% -----------------------------------------------------------------------------
% ? Document specific \providecommand or \newenvironment commands.
\providecommand{\dash}{--}

\providecommand{\noteroutine}[3]{\htmlref{\textbf{#1}}{#1}\textbf{#2}\hspace*{\fill}\nopagebreak \\
                             \hspace*{3em}\emph{#3}\hspace*{\fill}\par}

% ? End of document specific commands
% -----------------------------------------------------------------------------
%  Title Page.
%  ===========
\begin{document}
\scfrontmatter

\section{\xlabel{introduction}Introduction}

It is often the case that astronomical data are transported from the data
acquisition site (telescope, satellite ground station, \emph{etc.}) to the
astronomer's home institution via magnetic tape. The data on such tapes can be
in a variety of formats. The purpose of the MAG package is to allow
programmers to write applications programs that can access the raw data on the
tapes. MAG provides a means of processing magnetic tapes that is independent of
the type of computer on which the software is running and the type of tape
drive that is being used. MAG does no interpretation of the data format. It
deals in tape blocks and knows nothing about FITS, VMS BACKUP, tar, \emph{etc.}

By using the MAG routines, a program can read and write tapes, position the
tape (both in absolute terms and relative to the current position) and can
control the allocation of the tape drive and the physical mounting of the tape
on systems which provide that facility.

The use of the MAG package allows a programmer to write portable software. This
is very useful since different computer systems can differ greatly in the means
available for handling magnetic tapes. For example, on VMS it is quite common
to treat magnetic tapes as normal Fortran sequential files that can be opened,
read, written and closed using the Fortran statements OPEN, READ, WRITE and
CLOSE. On Suns, this is not the case and special subroutines are provided for
processing magnetic tapes. These differences are hidden from the programmer
when using the MAG package.

This document describes mainly the version of MAG available on Unix machines
but differences for the earlier
\htmlref{MAG on VAX/VMS}{vax}
are also described (in Appendix \ref{vax}).

The operations which can be performed on tapes using the MAG package
include:

\begin{itemize}
\item Allocating a tape drive and mounting the tape.
\item Opening and closing tape devices.
\item Reading and writing of data contained in tape blocks.
\item Relative tape movement (skip files/blocks and rewind).
\item Absolute tape positioning.
\end{itemize}

but note that not all operations are available on all types of tape deck.
Also note that the status values returned by different machines can differ.

\section{\xlabel{allocating_and_mounting_tapes}Allocating and mounting tapes}
Most of the MAG facilities are reasonably self explanatory and will be covered
in more detail in the following sections, but allocating and mounting tape
drives need some immediate explanation.

On some operating systems (VMS in particular), users can allocate a tape drive
to their own process (and any subprocesses) to prevent another user from
accidentally using the tape drive at the same time. Furthermore, on VMS it is
mandatory that a tape be `mounted' (positioned at the beginning of the data on
the tape) by means of the MOUNT command or by an equivalent subroutine call
from within a program before the program tries to read or write the tape. On
Unix, there are no equivalents of allocating or mounting tapes. On Unix, you
simply put the tape in the drive and proceed to use it. If you think this means
that someone can accidentally overwrite your tape, you are right, so be
careful.

There are MAG routines called MAG\_ALOC, MAG\_MOUNT, MAG\_DEAL and MAG\_DISM
for allocating, mounting, deallocating and dismounting tapes. They also
initialise/reset the MAG system so should be called even on Unix systems
\dash\ this also makes the software portable.

\section{\xlabel{using_mag_in_the_starlink_software_environment}Using MAG in the Starlink Software Environment}
MAG routines are designed to be used in the
\xref{Starlink Software Environment}{sg4}{}
and so get the names of the tape drives by means of environment program
parameters. The application refers to a tape device using a Device Parameter,
which is associated (via the Parameter System and Command Language and a data
file known as the
\htmlref{\textbf{device dataset}}{dataset_intro}) with the actual tape drive.
The device dataset is also used to preserve
\htmlref{position information}{positions}
for the tape between application
invocations (see Sections \ref{positions} and \ref{dataset_intro}).

We can see how the association is made by looking at the basic structure of
an application which reads from a tape:

\begin{small}
\begin{terminalv}
      INCLUDE 'SAE_PAR'          ! Define SAI__OK

      INTEGER STATUS             ! Status value
      INTEGER MT                 ! Magnetic Tape Descriptor

      ...

*  Make association between TAPE Device Parameter and actual device.
      CALL MAG_ASSOC( 'TAPE', 'READ', MT, STATUS )
      IF( STATUS .EQ. SAI__OK ) THEN

*  Rewind tape.
         CALL MAG_REW( MT, STATUS )

         ...
         Perform operations on tape
         ...

*  Release Tape device.
         CALL MAG_CANCL( 'TAPE', STATUS )

      ENDIF

      ..
\end{terminalv}
\end{small}

The MAG\_ASSOC call gets a value for the specified parameter (TAPE).
The given value should be the name by which the device is usually known
(not necessarily the actual device name). There should be an entry in the
device dataset to associate the common name with the system name for the
device.

The device is then opened with READ access (2nd argument), and
a Tape Descriptor returned in the MT variable (3rd argument). The tape
can subsequently be referenced using this tape descriptor, as can be
seen in the MAG\_REW call (which rewinds the tape).

The interface file for the above application could contain:

\begin{small}
\begin{terminalv}
PARAMETER TAPE
  TYPE    'TAPE'
  VPATH   'PROMPT'
  PROMPT  'Tape Deck'
  PPATH   'CURRENT,DEFAULT'
  DEFAULT /dev/nrmt0l
ENDPARAMETER
\end{terminalv}
\end{small}

When the application has finished with the tape, it uses MAG\_CANCL
to close the device, cancel the device parameter value and
to update the position information for this device in the device dataset.
MAG\_ANNUL may be used if it is required to close the device without
cancelling the parameter value.

Note that it is difficult to give a sensible value for the DEFAULT field of a
tape parameter in an interface file. The values that make sense vary from one
computer type to another and from one site to another.

\section{\xlabel{using_mag_standalone}Using MAG Stand-alone}
MAG may also be used stand-alone \dash\ that is without involving the
environment parameter system.
None of the subroutines which take a parameter name as an
argument may be used and the facility for remembering the tape position between
application invocations is not available as that is handled by the
environment-level subroutines.

For stand-alone use, tape devices are opened using MAG\_OPEN instead
of MAG\_ASSOC and closed using MAG\_CLOSE instead of MAG\_ANNUL or MAG\_CANCL.
Note that MAG\_OPEN is given the system name for the required device
\dash\ there is no indirection via the parameter system and device dataset
although the name may be an environment variable name which will be translated.

Within one application invocation, the tape position information will be
maintained (provided that it is initialized correctly).

\section{\xlabel{reading_and_writing_data}Reading and writing data}
Reading and writing data is very simple; there are routines, MAG\_READ
and MAG\_WRITE, to do the operations. The only noteworthy point is that the
routines deal with arrays of bytes and a byte is not a standard Fortran data
type. What is commonly done is to provide the routines with a buffer that is
an array of INTEGERs.
A Fortran INTEGER is commonly four bytes, but there is no guarantee
of this.

A more serious problem is that different computers store data with
different byte orders. For example if a tape was written on a Sun, then the
same program would read different INTEGER values off that tape when run on a
Sun and an Alpha. The situation is even worse with REAL or DOUBLE PRECISION
values.

Writing example:
\begin{small}
\begin{terminalv}
INTEGER STATUS              !Inherited status
INTEGER MT                  !Tape descriptor
INTEGER ACTVAL              !Number of bytes written/read
INTEGER BUFFER(100)         !Record buffer
INTEGER INTSIZE
PARAMETER ( INTSIZE=4)      !Number of bytes/integer

DO I = 1, 50
  BUFFER( I ) = I
ENDDO

CALL MAG_WRITE( MT, 50*INTSIZE, BUFFER, ACTVAL, STATUS )
...
\end{terminalv}
\end{small}
and the corresponding read could be:
\begin{small}
\begin{terminalv}
      CALL MAG_READ( MT, 100*INTSIZE, BUFFER, ACTVAL, STATUS )

      WRITE( *, 10) (BUFFER(I),I=1,ACTVAL/INTSIZE)
10    FORMAT( 10I4 )
         ...
\end{terminalv}
\end{small}

\section{\xlabel{absolute_tape_positions}\label{positions}Absolute tape positions}
Often, the data need to be read from or written to some position along
the tape other than its start. Programmers and users alike become
familiar with the idea of skipping over a number of files to get to
the correct tape position. If this must be done several times for a
particular tape, the user can get quite lost. This is especially true
if it is not obvious whether a program which reads a file also skips
over the tape mark at its end so that it is at the beginning of the next
file.

Some programs avoid the user learning how to skip and count files by
allowing tape positions to be referred to using absolute file numbers.
If the program is running in isolation (outside of any environment),
then this normally means that the tape is rewound afresh each time the
program is run. If the program is running in some kind of environment,
then the tape position can be remembered between runs.

The MAG package contains facilities for making absolute tape positions
available to the application (and hence the user) in a  way which is
independent of the environment. That is, the application asks for what
it wants and the MAG package provides the service. Thus if absolute
positioning is required the program just calls MAG routines that
specify the explicit file number. This forces the system to find
out the absolute position.

This is best demonstrated by an example. Suppose an application wishes
to refer to absolute file positions:

\begin{small}
\begin{terminalv}
..

INTEGER FILE                 ! File number
LOGICAL START                ! Whether at start of file
INTEGER BLOCK                ! Block number

..

FILE = 2
START = .TRUE.
BLOCK = 1
CALL MAG_MOVE(MT, FILE, START, BLOCK, STATUS)

..
\end{terminalv}
\end{small}

The MAG\_MOVE routine requires absolute tape positions, thus if the
application is running in an environment which remembers tape positions,
then this information is immediately available;  otherwise, this might
involve rewinding the tape.

The call to MAG\_MOVE then moves the tape to the file number indicated by
FILE (2nd argument).
The third argument (set to .TRUE.) indicates that the block number
(4th argument) is to be counted from the start of the file.
A value \textbf{.FALSE.\ } implies that the block numbering is from the end of the
file (as if the tape were being read in reverse). That is: block number 1,
from the end of the file, positions the tape between the the last block of
the file and the end-of-file mark. This is not the position from which the
program can read the last block of data.

At any time, the tape position can be enquired by, for example:

\begin{small}
\begin{terminalv}
..

CALL MAG_POS(MT, FILE, START, BLOCK, STATUS)

..
\end{terminalv}
\end{small}

where the returned values (FILE, START and BLOCK) correspond to the
MAG\_MOVE call. The values of these returned arguments are used to
indicate whether the tape position is known. For example, FILE=0
indicates that the absolute file number is not known, similarly for
BLOCK=0.

NOTE that this system is likely to be subverted if devices which automatically
reposition the tape on opening or closing are used.

\section{\xlabel{device_datasets}\label{device_datasets}Device Datasets}
\subsection{\xlabel{introduction_to_device_datasets}\label{dataset_intro}Introduction to Device Datasets}
MAG\_ASSOC and the other environment-level subroutines which have a
parameter name as an argument, look for information about each of the user's
tape devices in an
\xref{HDS}{sun92}{abstract}\footnote{Hierarchical Data System
(see SUN/92)} file, known as the \textbf{user's device dataset} or USRDEVDATA,
which is normally file \texttt{USRDEVDATA.sdf} in the user's
\xref{ADAM\_USER}{sun144}{ADAM_USER_directory}
directory (see SUN/144).
This may be overridden by setting the required filename in environment
variable USRDEVDATA. If the file does not exist, it will be created.

Figure~\ref{usrdevdata} shows the structure of a device dataset.
The name of each structure in the device dataset is the name by which the user
refers to the device.
The structure is used by the MAG package environment-level routines to hold the
system name of the device to be associated with it and to retain the absolute
tape position between runs.

If the user's name for the device is the same as the normal system name
(\texttt{/dev/rmt0h}, for example), the whole structure can be created by default.
However it is possible to create structures associating a user's `pet' name
for a device with its system name.

\begin{figure}[htbp]
\caption{\label{usrdevdata}The Structure of a Device Dataset}
\setlength{\unitlength}{1mm}
\begin{center}
\begin{picture}(135,140)
\thicklines

% Draw the structure of the USRDEVDATA container file

\put(0,130){\makebox(20,10){DEVICES}}
\put(20,135){\line(1,0){10}}
\put(30,135){\line(0,-1){100}}

\put(30,135){\line(1,0){10}}
\put(40,130){\makebox(25,10){DAT}}
\put(30,85){\line(1,0){10}}
\put(40,80){\makebox(25,10){EXABYTE}}
\put(30,35){\line(1,0){10}}
\put(40,30){\makebox(25,10){/DEV/RMT0L}}

\put(65,135){\line(1,0){20}}
   \put(87,130){\makebox(30,10)[l]{DEVICE}}
   \put(105,130){\makebox(20,10){'/dev/rmt0h'}}
\put(75,125){\line(1,0){10}}
   \put(87,120){\makebox(30,10)[l]{FILE}}
   \put(105,120){\makebox(20,10){1}}
\put(75,115){\line(1,0){10}}
   \put(87,110){\makebox(30,10)[l]{START}}
   \put(105,110){\makebox(20,10){TRUE}}
\put(75,105){\line(1,0){10}}
   \put(87,100){\makebox(30,10)[l]{BLOCK}}
   \put(105,100){\makebox(20,10){1}}
\put(75,135){\line(0,-1){30}}

\put(65,85){\line(1,0){20}}
   \put(87,80){\makebox(30,10)[l]{DEVICE}}
   \put(105,80){\makebox(35,10)[l]{'/dev/rmt1h'}}
\put(75,75){\line(1,0){10}}
   \put(87,70){\makebox(30,10)[l]{FILE}}
   \put(105,70){\makebox(20,10){9}}
\put(75,65){\line(1,0){10}}
   \put(87,60){\makebox(30,10)[l]{START}}
   \put(105,60){\makebox(20,10){TRUE}}
\put(75,55){\line(1,0){10}}
   \put(87,50){\makebox(30,10)[l]{BLOCK}}
   \put(105,50){\makebox(20,10){2}}
\put(75,85){\line(0,-1){30}}

\put(65,35){\line(1,0){20}}
   \put(87,30){\makebox(30,10)[l]{DEVICE}}
   \put(105,30){\makebox(20,10){'/dev/rmt0l'}}
\put(75,25){\line(1,0){10}}
   \put(87,20){\makebox(30,10)[l]{FILE}}
   \put(105,20){\makebox(20,10){\{undefined\}}}
\put(75,15){\line(1,0){10}}
   \put(87,10){\makebox(30,10)[l]{START}}
   \put(105,10){\makebox(20,10){TRUE}}
\put(75,5){\line(1,0){10}}
   \put(87,0){\makebox(30,10)[l]{BLOCK}}
   \put(105,0){\makebox(20,10){\{undefined\}}}
\put(75,35){\line(0,-1){30}}

\end{picture}
\end{center}

\end{figure}

\subsection{\xlabel{defining_a_pet_name_for_a}\xlabel{tapecreate}\label{tapecreate}Defining a `Pet' Name for a
Tape Device}
The command \textbf{tapecreate} may be used to create or alter a device dataset.
The system manager can use it to set up a system-wide device dataset
containing entries for every device on the system. Users may also use it to
create private user device datasets specifying their own names for devices.
However, it is more usual to use the system name for the device and rely on
automatic creation of device datasets by MAG\_ASSOC \emph{etc.}

For each required tape drive, an entry should be created in the file
\emph{e.g.} :
\begin{small}
\begin{terminalv}
tapecreate dat /dev/rmt0h ~/adam/USRDEVDATA
tapecreate datn /dev/nrtm0h ~/adam/USRDEVDATA
\end{terminalv}
\end{small}

\textbf{tapecreate} is a
\xref{Starlink Software Environment}{sg4}{}
program with parameters as follows:

The first parameter (DRIVE) is the name by which the device will be known to
the user. It can be any valid HDS structure name and will be prompted for if
not supplied on the command line.

The second argument (DEVICE) gives the system name for the device \dash\ it
will be prompted for if not supplied on the command line.
DEVICE can be the name of an environment variable which translates to a
system device name if so desired. The name will be translated to the
system device name when the device is opened for use.

The third parameter (DEVDATASET) is the name of the HDS file to be created or
updated (without the {\tt.sdf} extension) \dash\ it defaults to
\texttt{devdataset} if not supplied on the command line.
If the file does not exist, \textbf{tapecreate} will create it.

\subsection{\xlabel{runtime_creation_of_device_dataset_entries}Runtime Creation of Device Dataset Entries}
If no suitably named structure exists in USRDEVDATA when the
subroutine is called, an attempt is made to create it by copying the relevant
entry from a \textbf{system-wide device dataset}.
If the system-wide device dataset does not exist or no structure with the
required name exists in it, a structure will be created in USRDEVDATA with
the required name and assuming that the system name for the device is the same
(in lower case).

By default, the system-wide device dataset
is sought by looking for \textbf{../etc/devdataset.sdf} relative to each
directory on the user's PATH. However, an alternative file search path may be
specified as a list of file pathnames, separated by `:', in environment
variable DEVDATASET. (See Appendix \ref{vax} for filenames on VAX/VMS.)

This indirection of names between the user's name for a device and the
system device name, intended to assist portability, has proved confusing,
so system-wide device datasets (traditionally \texttt{/star/etc/devdataset.sdf})
are being phased out \dash\ the normal procedure will be to refer to the device
by its system name.

Note that \texttt{/star/etc/devdataset.sdf} will still be required by programs
linked with versions of MAG earlier than 2.0 if an appropriate structure does
not exist in the user's device dataset. Furthermore, filenames will be
\htmlref{different on VAX/VMS}{vax} (see Appendix \ref{vax}).

\subsection{\xlabel{saving_the_absolute_tape_position}Saving the Absolute Tape Position}
MAG\_ASSOC will read USRDEVDATA to determine which physical device to use, and
will copy the absolute tape position into the MAG common block.
To operate this system correctly, the tape must be mounted using MAG\_MOUNT
and the tape descriptor must be annulled using MAG\_CANCL or MAG\_ANNUL at the
end of each task invocation with the tape in a known position (\emph{i.e.}\ it knew
where it was to start with and was able to keep track of its movements).
MAG\_MOUNT will initialize the tape dataset to FILE=1, START=.TRUE., BLOCK=1
and MAG\_DISM will `undefine' the entries (as will the creation of an entry
in USRDEVDATA for a particular device).

MAG\_ANNUL/MAG\_CANCL will write the current tape position back to USRDEVDATA.

\section{\xlabel{error_handling}Error Handling}

The MAG subroutines use the Starlink error strategy. Each routine has a STATUS
argument and, in most cases, if the value of STATUS is not SAI\_\_OK on entry,
the routine returns without action. Exceptions to this are the `clear-up'
routines MAG\_ANNUL, MAG\_CANCL, MAG\_CLOSE and MAG\_DEACT which will attempt
to execute whatever the import status.

If an error is detected during execution, an error message may be reported
(but not output) using the \xref{ERR}{sun104}{err_error_reporting_system}
system (see SUN/104), and an appropriate STATUS value set.
Exceptions to this are the routines like MAG\_ASSOC which obtain a device name
via a parameter value. Errors in specifying the device name are reported
immediately and the user prompted for another value.

Note that STATUS values returned are rather system-specific. In most cases a
`best effort' is made to assign a value on the basis of the actual error
detected. Therefore, testing for explicit status values can result in
non-portable code. If, in spite of this warning, it is required to test for
explicit status values returned from MAG subroutines, include the statement:

\begin{small}
\begin{terminalv}
INCLUDE 'MAG_ERR'
\end{terminalv}
\end{small}

in the program. The status can then be tested by, for example:

\begin{small}
\begin{terminalv}
IF( STATUS .EQ. MAG__EOV ) RETURN
\end{terminalv}
\end{small}

If an error status is to be ignored, the error message stack should be
cleared and STATUS reset by calling subroutine
\xref{ERR\_ANNUL}{sun104}{ERR_ANNUL}.

\section{\xlabel{compiling_and_linking}Compiling and Linking}
Soft links for the the standard Starlink INCLUDE file SAE\_PAR (which defines
the OK status value, SAI\_\_OK, amongst other things) and the MAG INCLUDE file
MAG\_ERR (which defines the
\htmlref{MAG error codes}{mag_errors} may be set up in the current
working directory by obeying:
\begin{small}
\begin{terminalv}
% star_dev
% mag_dev
\end{terminalv}
\end{small}

Fortran statements of the form:
\begin{small}
\begin{terminalv}
INCLUDE 'SAE_PAR'
INCLUDE 'MAG_ERR'
\end{terminalv}
\end{small}
may then be used.

To link a program for use in the Starlink Software Environment,
the \texttt{mag\_\-link\_\-adam} script is used.

\begin{small}
\begin{terminalv}
% alink task.f `mag_link_adam`
\end{terminalv}
\end{small}

For a stand-alone program, use the \texttt{mag\_\-link} script.
For example:
\begin{small}
\begin{terminalv}
% f77 -o prog prog.f -L/star/lib `mag_link`.
\end{terminalv}
\end{small}

\begin{thebibliography}{9}
\bibitem{sg4} M D Lawden, \textit{ADAM \dash\ The Starlink Software Environment},
\xref{Starlink Guide 4}{sg4}{}.
\bibitem{sun92} R F Warren-Smith \& M D Lawden, \textit{HDS \dash\ Hierarchical Data
System}, \xref{Starlink User Note 92}{sun92}{}.
\bibitem{sun144} A J Chipperfield, \textit{ADAM \dash\ Unix Version},
\xref{Starlink User Note 144}{sun144}{}
\bibitem{sun104} P C T Rees \& A J Chipperfield, \textit{MERS (MSG and ERR )
\dash\ Message and Error Reporting Systems},
\xref{Starlink User Note 104}{sun104}{}
\end{thebibliography}

\appendix


\section{\xlabel{alphabetical_list_of_routines}Alphabetical List of Routines}

\noteroutine{MAG\_ALOC}{(PARAM, STATUS)}{Allocate tape device}
\noteroutine{MAG\_ANNUL}{(TD, STATUS)}{Annul tape descriptor, releasing any associated tape drive}
\noteroutine{MAG\_ASSOC}{(PARAM, MODE, TD, STATUS)}{Open a tape device defined by a parameter and return a descriptor}
\noteroutine{MAG\_CANCL}{(PARAM, STATUS)}{Close a tape device defined by a parameter}
\noteroutine{MAG\_CLOSE}{(TD, STATUS)}{Close a tape device, given a descriptor}
\noteroutine{MAG\_DEACT}{(STATUS)}{Annul all tape descriptors}
\noteroutine{MAG\_DEAL}{(PARAM, STATUS)}{De-allocate a tape device}
\noteroutine{MAG\_DISM}{(PARAM, UNLOAD, STATUS)}{Dismount tape from drive}
\noteroutine{MAG\_JEOV}{(TD, STATUS)}{Jump over an EOV condition (2 consecutive tape marks)}
\noteroutine{MAG\_JUMP}{(TD, NBLOCK, STATUS)}{Skip a specified number of physical blocks}
\noteroutine{MAG\_MOUNT}{(PARAM, MODE, STATUS)}{Mount tape on drive}
\noteroutine{MAG\_MOVE}{(TD, FILE, START, BLOCK, STATUS)}{Move to a specified file and block on tape}
\noteroutine{MAG\_OPEN}{(DEVICE, MODE, TD, STATUS)}{Open a tape device}
\noteroutine{MAG\_POS}{(TD, FILE, START, BLOCK, MOVED, STATUS)}{Enquire current tape file/block positions}
\noteroutine{MAG\_READ}{(TD, MAXVAL, VALUES, ACTVAL, STATUS)}{Read a block from tape}
\noteroutine{MAG\_REW}{(TD, STATUS)}{Rewind tape}
\noteroutine{MAG\_SET}{(TD, FILE, START, BLOCK, STATUS)}{Set current tape file/block positions}
\noteroutine{MAG\_SKIP}{(TD, NTM, STATUS)}{Skip a specified number of tape marks}
\noteroutine{MAG\_STOP}{( STATUS )}{Cancel all tape devices}
\noteroutine{MAG\_WRITE}{(TD, NVAL, VALUES, ACTVAL, STATUS)}{Write a block to tape}
\noteroutine{MAG\_WTM}{(TD, STATUS)}{Write tape mark}

\newpage
\section{\xlabel{routine_descriptions}Routine Descriptions}

\sstroutine{
   MAG\_ALOC
}{
   Allocate tape device
}{
   \sstdescription{
      Allocate the tape drive specified by the parameter for continued
      use.
   }
   \sstinvocation{
      CALL MAG\_ALOC(PARAM, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         PARAM=CHARACTER$*$($*$) (Given)
      }{
         Expression specifying the name of a Tape Device Parameter.
      }
      \sstsubsection{
         STATUS=INTEGER (Given and Returned)
      }{
         Variable holding the status value.
         If this variable is not SAI\_\_OK on input, then the routine
         will return without action.
         If the routine fails to complete, this variable will be set
         to an appropriate error number.
      }
   }
}
\sstroutine{
   MAG\_ANNUL
}{
   Annul tape descriptor, releasing any associated tape drive
}{
   \sstdescription{
      Release the tape drive associated with the tape descriptor.
      Annul the tape descriptor but do not cancel the associated
      parameter.
   }
   \sstinvocation{
      CALL MAG\_ANNUL(TD, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         TD=INTEGER (Given)
      }{
         A variable containing the tape descriptor.
      }
      \sstsubsection{
         STATUS=INTEGER (Given and Returned)
      }{
         Variable holding the status value.
         If the routine fails to complete, this variable will be set
         to an appropriate error number.
         If this variable is not SAI\_\_OK on input, then the routine
         will still attempt to execute, but will return with STATUS
         set to the import value.
      }
   }
}
\sstroutine{
   MAG\_ASSOC
}{
   Open a tape device defined by a parameter and return a descriptor
}{
   \sstdescription{
      Get a descriptor for a tape device specified by its Parameter Name.
   }
   \sstinvocation{
      CALL MAG\_ASSOC(PARAM, MODE, TD, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         PARAM=CHARACTER$*$($*$) (Given)
      }{
         Expression specifying the name of a Tape Device Parameter.
      }
      \sstsubsection{
         MODE=CHARACTER$*$($*$) (Given)
      }{
         Expression specifying the access mode: 'READ', 'WRITE' or
         'UPDATE' (read and write).
      }
      \sstsubsection{
         TD=INTEGER (Returned)
      }{
         A Variable to contain the tape descriptor.
      }
      \sstsubsection{
         STATUS=INTEGER (Given and Returned)
      }{
         Variable holding the status value.
         If this variable is not SAI\_\_OK on input, then the routine
         will return without action.
         If the routine fails to complete, this variable will be set
         to an appropriate error number.
      }
   }
}
\sstroutine{
   MAG\_CANCL
}{
   Close tape device defined by a parameter
}{
   \sstdescription{
      Release the tape drive associated with the parameter, annul the
      associated tape descriptor and cancel the parameter.
   }
   \sstinvocation{
      CALL MAG\_CANCL(PARAM, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         PARAM=CHARACTER$*$($*$) (Given)
      }{
         Expression specifying the name of a Tape Device Parameter,
         which has previously been associated with a device using
         MAG\_ASSOC.
      }
      \sstsubsection{
         STATUS=INTEGER (Given and Returned)
      }{
         Variable holding the status value.
         If the routine fails to complete, this variable will be set
         to an appropriate error number.
         If this variable is not SAI\_\_OK on input, then the routine
         will still attempt to execute, but will return with STATUS
         set to the import value.
      }
   }
}
\sstroutine{
   MAG\_CLOSE
}{
   Close a tape device, given a descriptor
}{
   \sstdescription{
      The device specified by the tape descriptor is closed, and
      forgotten by the MAG library.
   }
   \sstinvocation{
      CALL MAG\_CLOSE(TD, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         TD=INTEGER (Given)
      }{
         A variable containing the tape descriptor.
      }
      \sstsubsection{
         STATUS=INTEGER (Given and Returned)
      }{
         Variable holding the status value.   If the routine fails to
         complete, this variable will be set to an appropriate error number.
         If this variable is not SAI\_\_OK on input, then the routine will
         still attempt to execute, but will return with STATUS set to the
         import value.
      }
   }
}
\sstroutine{
   MAG\_DEACT
}{
   Annul all tape descriptors
}{
   \sstdescription{
      MAG\_ANNUL is performed for all open tape devices which were obtained
      with MAG\_ASSOC.
      The associated parameters are not cancelled.
   }
   \sstinvocation{
      CALL MAG\_DEACT(STATUS)
   }
   \sstarguments{
      \sstsubsection{
         STATUS=INTEGER (Given and Returned)
      }{
         Variable holding the status value.
         If the routine fails to complete, this variable will be set
         to an appropriate error number.
         If this variable is not SAI\_\_OK on input, then the routine
         will still attempt to execute, but will return with STATUS
         set to the import value.
      }
   }
}
\sstroutine{
   MAG\_DEAL
}{
   De-allocate a tape device
}{
   \sstdescription{
      De-allocate the tape drive specified by the parameter, from the
      process.
   }
   \sstinvocation{
      CALL MAG\_DEAL(PARAM, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         PARAM=CHARACTER$*$($*$) (Given)
      }{
         Expression specifying the name of a Tape Device Parameter.
      }
      \sstsubsection{
         STATUS=INTEGER (Given and Returned)
      }{
         Variable holding the status value.
         If this variable is not SAI\_\_OK on input, then the routine
         will return without action.
         If the routine fails to complete, this variable will be set
         to an appropriate error number.
      }
   }
}
\sstroutine{
   MAG\_DISM
}{
   Dismount tape from drive
}{
   \sstdescription{
      Dismount a tape from the tape drive specified by the parameter
      and set the entry for the drive in the user's device dataset
      (USRDEVDATA) to unknown position.
      If the dismount fails, the entry will be unaltered.
   }
   \sstinvocation{
      CALL MAG\_DISM(PARAM, UNLOAD, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         PARAM=CHARACTER$*$($*$) (Given)
      }{
         Expression specifying the name of a Tape Device Parameter.
      }
      \sstsubsection{
         UNLOAD=LOGICAL (Returned)
      }{
         Expression specifying whether the tape is to be unloaded.
         If .TRUE. the tape will be unloaded; if .FALSE. it will not.
      }
      \sstsubsection{
         STATUS=INTEGER (Given and Returned)
      }{
         Variable holding the status value.
         If this variable is not SAI\_\_OK on input, then the routine
         will return without action.
         If the routine fails to complete, this variable will be set
         to an appropriate error number.
      }
   }
}
\sstroutine{
   MAG\_JEOV
}{
   Jump over an EOV condition (2 consecutive tape marks)
}{
   \sstdescription{
      This jumps over an end-of-volume (EOV) condition, assuming that
      the tape is currently positioned between its two consecutive
      tape marks.
   }
   \sstinvocation{
      CALL MAG\_JEOV(TD, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         TD=INTEGER (Given)
      }{
         A variable containing the tape descriptor.
      }
      \sstsubsection{
         STATUS=INTEGER (Given and Returned)
      }{
         Variable holding the status value.
         If this variable is not SAI\_\_OK on input, then the routine
         will return without action.
         If the routine fails to complete, this variable will be set
         to an appropriate error number.
      }
   }
}
\sstroutine{
   MAG\_JUMP
}{
   Skip a specified number of physical blocks
}{
   \sstdescription{
      The tape is moved a specified number of blocks;  a negative
      number indicating backwards movement.
   }
   \sstinvocation{
      CALL MAG\_JUMP(TD, NBLOCK, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         TD=INTEGER (Given)
      }{
         A variable containing the tape descriptor.
      }
      \sstsubsection{
         NBLOCK=INTEGER (Given)
      }{
         Expression specifying the number of blocks to be skipped.
         A negative number indicates that the tape is to be moved
         in the reverse direction (towards its load point).
      }
      \sstsubsection{
         STATUS=INTEGER (Given and Returned)
      }{
         Variable holding the status value.
         If this variable is not SAI\_\_OK on input, then the routine
         will return without action.
         If the routine fails to complete, this variable will be set
         to an appropriate error number.
      }
   }
}
\sstroutine{
   MAG\_MOUNT
}{
   Mount tape on drive
}{
   \sstdescription{
      Mount a tape on the tape drive specified by the parameter and
      initialise the entry for the drive in the user's device dataset
      (USRDEVDATA).
      If the mount fails, the device entry will
      be cancelled (\emph{i.e.}\ set to unknown position) unless the failure
      was MAG\_\_DVMNT (device already mounted), in which case it will
      be unaltered.
   }
   \sstinvocation{
      CALL MAG\_MOUNT(PARAM, MODE, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         PARAM=CHARACTER$*$($*$) (Given)
      }{
         Expression specifying the name of a Tape Device Parameter.
      }
      \sstsubsection{
         MODE=CHARACTER$*$($*$) (given)
      }{
         Expression specifying the access mode: 'READ' or 'WRITE'.
         'WRITE' mode implies 'READ' also.
      }
      \sstsubsection{
         STATUS=INTEGER (Given and Returned)
      }{
         Variable holding the status value.
         If this variable is not SAI\_\_OK on input, then the routine
         will return without action.
         If the routine fails to complete, this variable will be set
         to an appropriate error number.
      }
   }
}
\sstroutine{
   MAG\_MOVE
}{
   Move to a specified file and block on tape
}{
   \sstdescription{
      Assuming that the current tape position is known, move to a
      position on the tape specified by a file and block number.
      The block number can be relative either to the start or the
      end of the specified file.
   }
   \sstinvocation{
      CALL MAG\_MOVE(TD, FILE, START, BLOCK, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         TD=INTEGER (Given)
      }{
         A variable containing the tape descriptor.
      }
      \sstsubsection{
         FILE=INTEGER (Given)
      }{
         Expression specifying the file number to which the tape
         is to be moved.
      }
      \sstsubsection{
         START=LOGICAL (Given)
      }{
         Expression indicating whether the block number is relative
         to the start or end of the specified file.
      }
      \sstsubsection{
         BLOCK=INTEGER (Given)
      }{
         Expression specifying the block number within the file at
         which the tape is to be positioned. Note that when START
         is false \emph{i.e.}\ BLOCK is relative to the end of the file, its
         value is what would be expected if the tape were being read
         backwards. This means that in order to position the tape to
         read the last block in the file, BLOCK must be set to 2 and
         not 1.
      }
      \sstsubsection{
         STATUS=INTEGER (Given and Returned)
      }{
         Variable holding the status value.
         If this variable is not SAI\_\_OK on input, then the routine
         will return without action.
         If the routine fails to complete, this variable will be set
         to an appropriate error number.
      }
   }
}
\sstroutine{
   MAG\_OPEN
}{
   Open a tape device
}{
   \sstdescription{
      The tape device is opened and a tape descriptor returned.
   }
   \sstinvocation{
      CALL MAG\_OPEN(DEVICE, MODE, TD, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         DEVICE=CHARACTER$*$($*$) (Given)
      }{
         Expression specifying the name of a Tape Device or an environment
         variable which translates to a Tape Device name.
      }
      \sstsubsection{
         MODE=CHARACTER$*$($*$) (Given)
      }{
         Expression specifying the access mode: 'READ', 'WRITE' or
         'UPDATE' (read and write).
      }
      \sstsubsection{
         TD=INTEGER (Returned)
      }{
         A variable to contain the tape descriptor.
      }
      \sstsubsection{
         STATUS=INTEGER (Given and Returned)
      }{
         Variable holding the status value.   If this variable is not
         SAI\_\_OK on input, then the routine will return without action.  If
         the routine fails to complete, this variable will be set to an
         appropriate error number.
      }
   }
}
\sstroutine{
   MAG\_POS
}{
   Enquire current tape file/block positions
}{
   \sstdescription{
      Return current tape position.
   }
   \sstinvocation{
      CALL MAG\_POS(TD, FILE, START, BLOCK, MOVED, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         TD=INTEGER (Given)
      }{
         A variable containing the tape descriptor.
      }
      \sstsubsection{
         FILE=INTEGER (Returned)
      }{
         Variable to receive the tape file number. This is returned
         zero if not known.
      }
      \sstsubsection{
         START=LOGICAL (Returned)
      }{
         Variable to receive whether the block number is relative
         to the start or end of the file.
      }
      \sstsubsection{
         BLOCK=INTEGER (Returned)
      }{
         Variable to receive the block number.   If START is TRUE
         then this is relative to the start of the file;  otherwise
         it is relative to the end of the file.
         It is returned zero if not known.
      }
      \sstsubsection{
         MOVED=LOGICAL (Returned)
      }{
         Variable to receive whether the tape has been moved.
      }
      \sstsubsection{
         STATUS=INTEGER (Given and Returned)
      }{
         Variable holding the status value.
         If this variable is not SAI\_\_OK on input, then the routine
         will return without action.
         If the routine fails to complete, this variable will be set
         to an appropriate error number.
      }
   }
}
\sstroutine{
   MAG\_READ
}{
   Read a block from tape
}{
   \sstdescription{
      Read a tape block into the array provided, and return its length
      in basic machine units (bytes).
   }
   \sstinvocation{
      CALL MAG\_READ(TD, MAXVAL, VALUES, ACTVAL, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         TD=INTEGER (Given)
      }{
         A variable containing the tape descriptor.
      }
      \sstsubsection{
         MAXVAL=INTEGER (Given)
      }{
         Expression specifying the size of the array (in bytes)
         into which data are to be read from tape.
      }
      \sstsubsection{
         VALUES(MAXVAL)=BYTE (Returned)
      }{
         Array to receive the binary contents of a tape block.
         It must be of sufficient size to contain the entire block.
      }
      \sstsubsection{
         ACTVAL=INTEGER (Returned)
      }{
         Variable to receive the actual number of bytes read.
      }
      \sstsubsection{
         STATUS=INTEGER (Given and Returned)
      }{
         Variable holding the status value.
         If this variable is not SAI\_\_OK on input, then the routine
         will return without action.
         If the routine fails to complete, this variable will be set
         to an appropriate error number.
      }
   }
}
\sstroutine{
   MAG\_REW
}{
   Rewind tape
}{
   \sstdescription{
      The tape is rewound to its load point.
   }
   \sstinvocation{
      CALL MAG\_REW(TD, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         TD=INTEGER (Given)
      }{
         A variable containing the tape descriptor.
      }
      \sstsubsection{
         STATUS=INTEGER (given and Returned)
      }{
         Variable holding the status value.
         If this variable is not SAI\_\_OK on input, then the routine
         will return without action.
         If the routine fails to complete, this variable will be set
         to an appropriate error number.
      }
   }
}
\sstroutine{
   MAG\_SET
}{
   Set current tape file/block positions
}{
   \sstdescription{
      Supply the MAG library with the current tape position.
   }
   \sstinvocation{
      CALL MAG\_SET(TD, FILE, START, BLOCK, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         TD=INTEGER (Given)
      }{
         A variable containing the tape descriptor.
      }
      \sstsubsection{
         FILE=INTEGER (Given)
      }{
         Expression specifying the tape file number.   This can be
         zero or negative if unknown.
      }
      \sstsubsection{
         START=LOGICAL (Given)
      }{
         Expression specifying whether the block number is relative
         to the start or end of the specified file.
      }
      \sstsubsection{
         BLOCK=INTEGER (Given)
      }{
         Expression specifying the block number.
         If START is TRUE then this is relative to the start of the
         file;  otherwise it is relative to the end of the file.
         It can be specified zero or negative if unknown.
      }
      \sstsubsection{
         STATUS=INTEGER (Given and Returned)
      }{
         Variable holding the status value.
         If this variable is not SAI\_\_OK on input, then the routine
         will return without action.
         If the routine fails to complete, this variable will be set
         to an appropriate error number.
      }
   }
}
\sstroutine{
   MAG\_SKIP
}{
   Skip a specified number of tape marks
}{
   \sstdescription{
      The tape is moved over a specified number of tape marks.
   }
   \sstinvocation{
      CALL MAG\_SKIP(TD, NTM, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         TD=INTEGER (Given)
      }{
         A variable containing the tape descriptor.
      }
      \sstsubsection{
         NTM=INTEGER (Given)
      }{
         Expression specifying the number of tape marks to be
         skipped.
         A negative number indicates that the tape is to be moved
         in the reverse direction (towards its load point).
      }
      \sstsubsection{
         STATUS=INTEGER (Given and Returned)
      }{
         Variable holding the status value.
         If this variable is not SAI\_\_OK on input, then the routine
         will return without action.
         If the routine fails to complete, this variable will be set
         to an appropriate error number.
      }
   }
}
\sstroutine{
   MAG\_STOP
}{
   Cancel all tape devices.
}{
   \sstdescription{
      MAG\_CANCL is performed for all open tape devices which were obtained
      with MAG\_ASSOC and the associated parameters are cancelled.
   }
   \sstinvocation{
      CALL MAG\_STOP( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The Global status.
      }
   }
}
\sstroutine{
   MAG\_WRITE
}{
   Write a block to tape
}{
   \sstdescription{
      A supplied byte array is written to tape as a single block.
   }
   \sstinvocation{
      CALL MAG\_WRITE(TD, NVAL, VALUES, ACTVAL, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         TD=INTEGER (Given)
      }{
         A variable containing the tape descriptor.
      }
      \sstsubsection{
         NVAL=INTEGER (Given)
      }{
         Expression specifying the number of bytes to be written
         to tape as a single block.
      }
      \sstsubsection{
         VALUES(NVAL)=BYTE (Given)
      }{
         Array containing the data to be written to tape.
      }
      \sstsubsection{
         ACTVAL=INTEGER (Returned)
      }{
         Variable to receive the actual number of bytes written.
      }
      \sstsubsection{
         STATUS=INTEGER (Given and Returned)
      }{
         Variable holding the status value.
         If this variable is not SAI\_\_OK on input, then the routine
         will return without action.
         If the routine fails to complete, this variable will be set
         to an appropriate error number.
      }
   }
}
\sstroutine{
   MAG\_WTM
}{
   Write tape mark
}{
   \sstdescription{
      A tape mark is written at the current tape position.
   }
   \sstinvocation{
      CALL MAG\_WTM(TD, STATUS)
   }
   \sstarguments{
      \sstsubsection{
         TD=INTEGER (Given)
      }{
         A variable containing the tape descriptor.
      }
      \sstsubsection{
         STATUS=INTEGER (Given and Returned)
      }{
         Variable holding the status value.
         If this variable is not SAI\_\_OK on input, then the routine
         will return without action.
         If the routine fails to complete, this variable will be set
         to an appropriate error number.
      }
   }
}

\newpage
\section{\xlabel{mag_status_values}\label{mag_errors}MAG status values}

The following status values may be reported by the MAG package. They are
defined in the MAG\_ERR include file.

MAG\_\_TOOTD  \dash\ No more available tape descriptors \\
MAG\_\_ILLTD  \dash\ Illegal tape descriptor \\
MAG\_\_TOMNY  \dash\ Too many open tapes \\
MAG\_\_ILLAC  \dash\ Illegal access mode \\
MAG\_\_UNKPA  \dash\ Parameter not found \\
MAG\_\_NTACT  \dash\ Parameter not currently active \\
MAG\_\_ISACT  \dash\ Parameter currently active \\
MAG\_\_ERACT  \dash\ Error activating MAG \\
MAG\_\_EREXH  \dash\ Error establishing exit handler for MAG \\
MAG\_\_IVACM  \dash\ Invalid access mode \\
MAG\_\_BUFTB  \dash\ Invalid buffer size \\
MAG\_\_UNKDV  \dash\ Unable to locate device in DEVDATASET \\
MAG\_\_NOASS  \dash\ No channel assigned to tape drive \\
MAG\_\_NOFIL  \dash\ No tape file specified \\
MAG\_\_NOPOS  \dash\ Tape position not known \\
MAG\_\_NOEOV  \dash\ End of volume not found \\
MAG\_\_EXCDV  \dash\ Too many tape devices \\
MAG\_\_ISOPN  \dash\ Tape device already open \\
MAG\_\_NTOPN  \dash\ Tape not open \\
MAG\_\_LCERR  \dash\ Unable to open DEVDATASET \\
MAG\_\_CRERR  \dash\ Unable to create Magnetic Tape dataset \\
MAG\_\_CNERR  \dash\ Unable to cancel Magnetic Tape dataset \\
MAG\_\_WRERR  \dash\ Error Writing to Magnetic Tape dataset \\
MAG\_\_RDERR  \dash\ Error Reading from Magnetic Tape dataset \\
MAG\_\_IVRSZ  \dash\ Invalid record size \\
MAG\_\_IVBSZ  \dash\ Invalid block size \\
MAG\_\_NTMUL  \dash\ Block size not a multiple of record size \\
MAG\_\_IVBUF  \dash\ Invalid buffer size \\
MAG\_\_ICBSZ  \dash\ Inconsistent block size \\
MAG\_\_NOREC  \dash\ Unknown record size \\
MAG\_\_ERROR  \dash\ Error \\
MAG\_\_NTSUP  \dash\ Option not supported \\
MAG\_\_DVALL  \dash\ Tape drive allocated to another user \\
MAG\_\_DVNAL  \dash\ Tape drive not allocated \\
MAG\_\_NSHDV  \dash\ No such tape drive \\
MAG\_\_DVASS  \dash\ Tape drive already assigned \\
MAG\_\_ACVIO  \dash\ Access violation \\
MAG\_\_BUFOV  \dash\ Buffer overflow \\
MAG\_\_DVMNT  \dash\ Tape drive already mounted \\
MAG\_\_REMOT  \dash\ Tape drive on remote node \\
MAG\_\_NOPRV  \dash\ No privilege for attempted operation \\
MAG\_\_INVCH  \dash\ Invalid channel \\
MAG\_\_EXQUO  \dash\ Quota exceeded \\
MAG\_\_EXCCH  \dash\ No channel available \\
MAG\_\_INVDV  \dash\ Illegal device name \\
MAG\_\_INVLG  \dash\ Illegal logical name \\
MAG\_\_CTLER  \dash\ Tape drive controller error \\
MAG\_\_DTCHK  \dash\ Tape write error \\
MAG\_\_DRVER  \dash\ Tape drive error \\
MAG\_\_EOF    \dash\ End of file on tape \\
MAG\_\_EOT    \dash\ End of tape \\
MAG\_\_EOV    \dash\ End of volume (2 tape marks) \\
MAG\_\_MDOFL  \dash\ Tape drive off line \\
MAG\_\_PARIT  \dash\ Parity error on tape \\
MAG\_\_UNSAF  \dash\ Tape drive unsafe \\
MAG\_\_VLINV  \dash\ Tape not mounted \\
MAG\_\_WTLCK  \dash\ Tape drive write locked \\
MAG\_\_DATOV  \dash\ Tape data block exceeds buffer size \\
MAG\_\_DVNMT  \dash\ Tape not mounted \\
MAG\_\_UNKSS  \dash\ Unknown System Service code \\
MAG\_\_BADSS  \dash\ System Service Failed


\section{\xlabel{use_of_mag_on_vms}\label{vax}Use of MAG on VMS}

The MAG library was originally developed as part of the ADAM environment on
VAX/VMS and is still available there. However, development of the VMS system
has ceased and the Unix system described in this document has already diverged
from it.
This appendix describes current differences.

\subsection{\xlabel{device_dataset_names}Device Dataset Names}
The system-wide device dataset on VMS is required and is defined by the
logical name DEVDATASET.
The user's device dataset is defined by the logical name USRDEVDATA.

\subsection{\xlabel{device_allocation_and_mounting}Device Allocation and Mounting}
This section deals with how to allocate and mount tape devices. It is only
relevant to VMS as these concepts do not apply on Unix.

The multi-process nature of normal ADAM working and the rules associated
with device allocation and mounting in VMS can result in confusion.

A simple strategy is to ALLOCATE the tape deck and MOUNT/FOREIGN the
tape using DCL in the top-level process before entering any user-interface
such as ICL (ICL also provides MOUNT and DISMOUNT commands in the
top-level process).
The advantage of using DCL's ALLOCATE command is that generic device names
may be specified.

Unfortunately, if MAG\_MOUNT is not used to mount the tape, the position
information in the MAG common block following the MAG\_ASSOC call may be
incorrect.
If absolute tape positions are not required, this presents no problems;
however, if absolute tape positions are to be used, special action must be
taken to ensure that the MAG package knows the correct position of the tape.
MAG\_REW as the first operation after MAG\_ASSOC in the task will ensure that
the position is correct, but the preferred method is to mount the tape by
running the TAPEMOUNT task (which calls MAG\_MOUNT) from DCL in the top-level
process. For example:

\small
\begin{terminalv}
      $ ADAMSTART
      $ ALL MKB
      %DCL-I-ALLOC, _RLSVS2$MKB300: allocated
      $ TAPEMOUNT MUC0 READ
      %MOUNT-I-MOUNTED,  mounted on _RLSVS2$MKB300:
      $ ICL
\end{terminalv}
\normalsize

The parameters of TAPEMOUNT are:
\begin{description}
\item[DRIVE] \hspace{5mm} The name of the tape to be mounted.
\item[ACMODE] \hspace{5mm} The required access mode ('READ' or 'WRITE')
\end{description}

When the user has finished with the tape, it may be dismounted using the
TAPEDISM task (which calls MAG\_DISM).

\emph{E.g.}
\small
\begin{terminalv}
      $ TAPEDISM MKB3000 NOUNLOAD
\end{terminalv}
\normalsize

The parameters of TAPEDISM are:
\begin{description}
\item[DRIVE] \hspace{5mm} The name of the tape to be dismounted.
\item[UNLOAD] Is the tape to be unloaded (TRUE or FALSE)? This parameter
defaults to TRUE if it is not specified.
\end{description}

If it is required that the tape is to be mounted in a subprocess, it
cannot be allocated in a different process (even the parent). It is
however available for use by other subprocesses or the parent process
even if the mounting process is killed.

\subsection{\xlabel{compiling_and_linking_on_vms}Compiling and Linking on VMS}

Logical names defining the MAG INCLUDE files are defined

To link an ADAM program with the MAG libraries, include ADAM\_LIB:MAGLINK/OPT
in the link command.

For example:

\begin{terminalv}
$ ALINK task,ADAM\_LIB:MAGLINK/OPT
\end{terminalv}

\section{\xlabel{changes_from_previous_versions}Changes from Previous Versions}
\subsection{\xlabel{changes_to_device_datasets}Changes to Device Datasets}
Prior to version 2.0, the user's device dataset, \texttt{USRDEVDATA.sdf} was
created in the current directory and the system-wide device dataset was assumed
to be \texttt{/star/etc/devdataset.sdf}.

The users device dataset may now be defined by environment variable USRDEVDATA
and will default to \texttt{USRDEVDATA.sdf} in the user's
\xref{ADAM\_USER directory}{sun144}{ADAM_USER_directory} (see SUN/144).

System-wide device datasets are not necessary for Version 2.0 onwards but
should be retained until all programs using MAG have been re-linked.
A search path for the dataset may be defined in environment variable
DEVDATASET, otherwise a standard search path will be used.

The system will now assume that user and system names for devices are the
same if no appropriate device dataset entry can be found.

For more details on the above, see the description of
\htmlref{device datasets}{device_datasets} (Section \ref{device_datasets}).

\subsection{\xlabel{update_mode}UPDATE Mode}
Tape devices can now be opened with access mode `UPDATE' (read and write),
provided that the facility is available for the particular deck.

\subsection{\xlabel{documentation}Documentation}
For the first time MAG is documented in this SUN.
\end{document}
