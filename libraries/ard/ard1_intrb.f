      SUBROUTINE ARD1_INTRB( THIS, NPOINT, NCOORD_IN, INDIM, IN,
     :                       FORWARD, NCOORD_OUT, OUTDIM, TYPE, NPAR,
     :                       PAR, FRM, OUT, STATUS )
*+
*  Name:
*     ARD1_INTRB

*  Purpose:
*     Transform distance along a curve into user coords

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL ARD1_INTRB( THIS, NPOINT, NCOORD_IN, INDIM, IN, FORWARD,
*                      NCOORD_OUT, OUTDIM, TYPE, NPAR, PAR, FRM, OUT, STATUS )

*  Description:
*     This routine applies a Mapping to transform distance along a curve
*     into the corresponding user coordinates.

*  Parameters:
*     THIS = INTEGER (Given)
*        Pointer to the Mapping to be applied.
*     NPOINT = INTEGER (Given)
*        The number of points to be transformed.
*     NCOORD_IN = INTEGER (Given)
*        The number of coordinates being supplied for each input point
*        (i.e. the number of dimensions of the space in which the
*        input points reside).
*     INDIM = INTEGER (Given)
*        The number of elements along the first dimension of the IN
*        array (which contains the input coordinates). This value is
*        required so that the coordinate values can be correctly
*        located if they do not entirely fill this array. The value
*        given should not be less than NPOINT.
*     IN( INDIM, NCOORD_IN ) = DOUBLE PRECISION (Given)
*        An array containing the coordinates of the input
*        (untransformed) points. These should be stored such that the
*        value of coordinate number COORD for input point number POINT
*        is found in element IN(POINT,COORD).
*     FORWARD = LOGICAL (Given)
*        A .TRUE. value indicates that the Mapping's forward
*        coordinate transformation is to be applied, while a .FALSE.
*        value indicates that the inverse transformation should be
*        used.
*     NCOORD_OUT = INTEGER (Given)
*        The number of coordinates being generated by the Mapping for
*        each output point (i.e. the number of dimensions of the
*        space in which the output points reside). This need not be
*        the same as NCOORD_IN.
*     OUTDIM = INTEGER (Given)
*        The number of elements along the first dimension of the OUT
*        array (which will contain the output coordinates). This value
*        is required so that the coordinate values can be correctly
*        located if they will not entirely fill this array. The value
*        given should not be less than NPOINT.
*     TYPE = INTEGER (Given)
*        The region type.
*     NPAR = INTEGER (Given)
*        The number of region parameters.
*     PAR( NPAR ) = DOUBLE PRECISION (Given)
*        Region parameters.
*     FRM = INTEGER (Given)
*        Frame pointer.
*     OUT( OUTDIM, NCOORD_OUT ) = DOUBLE PRECISION (Returned)
*        An array into which the coordinates of the output
*        (transformed) points will be written. These will be stored
*        such that the value of coordinate number COORD for output
*        point number POINT will be found in element OUT(POINT,COORD).
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Copyright:
*     Copyright (C) 2001 Central Laboratory of the Research Councils.
*     All Rights Reserved.

*  Licence:
*     This program is free software; you can redistribute it and/or
*     modify it under the terms of the GNU General Public License as
*     published by the Free Software Foundation; either version 2 of
*     the License, or (at your option) any later version.
*
*     This program is distributed in the hope that it will be
*     useful,but WITHOUT ANY WARRANTY; without even the implied
*     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
*     PURPOSE. See the GNU General Public License for more details.
*
*     You should have received a copy of the GNU General Public License
*     along with this program; if not, write to the Free Software
*     Foundation, Inc., 51 Franklin Street,Fifth Floor, Boston, MA
*     02110-1301, USA

*  Authors:
*     DSB: David Berry (STARLINK)
*     {enter_new_authors_here}

*  History:
*     27-JUN-2001 (DSB):
*        Original version.
*     {enter_changes_here}

*  Bugs:
*     {note_any_bugs_here}

*-

*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants
      INCLUDE 'PRM_PAR'          ! VAL_ constants
      INCLUDE 'AST_PAR'          ! AST_ constants and functions
      INCLUDE 'ARD_CONST'        ! ARD_ private constants
      INCLUDE 'ARD_ERR'          ! ARD_ error constants

*  Arguments Given:
      INTEGER THIS
      INTEGER NPOINT
      INTEGER NCOORD_IN
      INTEGER INDIM
      DOUBLE PRECISION IN( INDIM, NCOORD_IN )
      LOGICAL FORWARD
      INTEGER NCOORD_OUT
      INTEGER OUTDIM
      INTEGER TYPE
      INTEGER NPAR
      DOUBLE PRECISION PAR( NPAR )
      INTEGER FRM

*  Arguments Returned:
      DOUBLE PRECISION OUT( OUTDIM, NCOORD_OUT )

*  Status:
      INTEGER STATUS             ! Global status

*  Local Variables:
      DOUBLE PRECISION
     :     A1,              ! An angle
     :     D,               ! Distance along curve (0-1)
     :     EDLEN,           ! Distance along geodesic edge
     :     POS( 2 ),        ! Offset position
     :     R,               ! Ellipse radius
     :     STEP,            ! Offset step between vertices
     :     THETA,           ! Ellipse parameterized angle
     :     V1,              ! fractional number of sides moved
     :     W,               ! Sub-offset
     :     XH,              ! Upper X on box
     :     XW,              ! Width of X on box
     :     XL,              ! Lower X on box
     :     YH,              ! Upper Y on box
     :     YL,              ! Lower Y on box
     :     YW               ! Width of Y on box

      INTEGER
     :     IV1,             ! Index at start of side
     :     IV1L,            ! Previous vertex index
     :     IV2,             ! Index at end of side
     :     NV,              ! No. of vertices
     :     POINT           ! Point index

*.

*  Check inherited global status.
      IF ( STATUS .NE. SAI__OK ) RETURN

*  Calculate common values.
      IF( TYPE .EQ. ARD__BOX ) THEN
         XW = ABS( PAR( 3 ) )
         XL = PAR( 1 ) - 0.5*XW
         XH = PAR( 1 ) + 0.5*XW
         YW = ABS( PAR( 4 ) )
         YL = PAR( 2 ) - 0.5*YW
         YH = PAR( 2 ) + 0.5*YW

      ELSE IF( TYPE .EQ. ARD__POL ) THEN
         NV = NPAR/2
         STEP = 1.0D0/DBLE( NV )
         IV1L = -1

      END IF

*  Loop round each point.
      DO POINT = 1, NPOINT

*  Get the distance along the curve
         D = IN( POINT, 1 )

*  Check it is good.
         IF( D .EQ. AST__BAD .OR. D .LT. 0.0 .OR. D. GT. 1.0 ) THEN
            OUT( POINT, 1 ) = AST__BAD
            OUT( POINT, 2 ) = AST__BAD

         ELSE

*  BOX: Parameters are the supplied user co-ordinates of the box centre,
*  followed by the lengths of the box sides in user co-ordinates.
            IF( TYPE .EQ. ARD__BOX ) THEN

*  Corners of the box occur at offsets 0, 0.25, 0.5, 0.75 and 1.0. The edge
*  from 0 to 0.25 is parallel to the second axis.
               IF( D .LE. 0.25 ) THEN
                  OUT( POINT, 1 ) = XL
                  OUT( POINT, 2 ) = YL + 4.0*D*YW

               ELSE IF( D .LE. 0.5 ) THEN
                  OUT( POINT, 1 ) = XL + 4.0*( D - 0.25 )*XW
                  OUT( POINT, 2 ) = YH

               ELSE IF( D .LE. 0.75 ) THEN
                  OUT( POINT, 1 ) = XH
                  OUT( POINT, 2 ) = YH - 4.0*( D - 0.5 )*YW

               ELSE
                  OUT( POINT, 1 ) = XH - 4.0*( D - 0.75 )*XW
                  OUT( POINT, 2 ) = YL

               END IF

*  POLYGON: Parameters are pairs of user co-ordinates, each being a vertex of
*  the polygon.
            ELSE IF( TYPE .EQ. ARD__POL ) THEN

*  The polygom is closed. Use D=0 instead of D=1
               IF( D .EQ. 1.0 ) D = 0.0

*  Find the fractional number of sides moved around the polygon.
               V1 = D/STEP

*  Find the index of the vertex at the start of the edge (zero based).
               IV1 = INT( V1 )

*  Find the offset along the edge in the range 0 to 1.
               W = V1 - DBLE( IV1 )

*  If we are on a different edge to last time...
               IF( IV1 .NE. IV1L ) THEN
                  IV1L = IV1

*  Find the index of the vertex at the end of the edge (zero based).
                  IV2 = IV1 + 1
                  IF( IV2 .EQ. NV ) IV2 = 0

*  Find the geodesic distance along the edge.
                  EDLEN = AST_DISTANCE( FRM, PAR( 2*IV1 + 1 ),
     :                                  PAR( 2*IV2 + 1 ), STATUS )
               END IF

*  Find the coords of the point, by offsetting along a geodesic.
               CALL AST_OFFSET( FRM, PAR( 2*IV1 + 1 ),
     :                          PAR( 2*IV2 + 1 ), W*EDLEN,
     :                          POS, STATUS )

*  Store the results in the returned array.
               OUT( POINT, 1 ) = POS( 1 )
               OUT( POINT, 2 ) = POS( 2 )

*  CIRCLE: Parameters are the user co-ordinates of the centre of the circle
*  or sphere, followed by the radius.
            ELSE IF( TYPE .EQ. ARD__CIR ) THEN

*  The offset is an angular offset with D=1 meaning 2*PI. Offset away
*  from the centre along a geodesic radius to find the corresponding
*  position.
               A1 = AST_OFFSET2( FRM, PAR, D*ARD__TWOPI, PAR( 3 ), POS,
     :                           STATUS )

*  Store the results in the returned array.
               OUT( POINT, 1 ) = POS( 1 )
               OUT( POINT, 2 ) = POS( 2 )

*  ELLIPSE: Parameters are the user co-ordinates of the centre of the ellipse,
*  the half-lengths of the two axes of the ellipse, and the angle (in degrees)
*  between the first user axis and the first of the two ellipse axes.
*  Rotation from the 1st to the 2nd axis is positive.
            ELSE IF( TYPE .EQ. ARD__ELL ) THEN

*  Find the angle between the 1st ellipse axis and the required radius
*  vector.
               A1 = D*ARD__TWOPI

*  An ellipse is parameterized as x = a*cos(theta) y = b*sin(theta)
*  Find the radius to the ellipse at the angle A1.
               THETA = ATAN2( SIN( A1 )/PAR( 4 ), COS( A1 )/PAR( 3 ) )
               R = SQRT( ( PAR( 3 )*COS( THETA ) )**2 +
     :                   ( PAR( 4 )*SIN( THETA ) )**2 )

*  Offset away from the centre along a geodesic radius to find the
*  corresponding position.
               A1 = AST_OFFSET2( FRM, PAR,
     :                           ARD__DTOR*( 90.0 - PAR( 5 ) ) - A1,
     :                           R, POS, STATUS )

*  Store the results in the returned array.
               OUT( POINT, 1 ) = POS( 1 )
               OUT( POINT, 2 ) = POS( 2 )

*  Report an error and abort for any other keyword.
            ELSE
               STATUS = ARD__INTER
               CALL MSG_SETI( 'TYPE', TYPE )
               CALL ERR_REP( 'ARD1_INTRB_ERR1', 'Illegal keyword '//
     :                       'identifier (^TYPE) encountered in '//
     :                       'routine ARD1_INTRB (programming error).',
     :                       STATUS )
               GO TO 999
            END IF

         END IF

      END DO

 999  CONTINUE

      END
