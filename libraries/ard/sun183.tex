\documentclass[11pt]{starlink}

% -----------------------------------------------------------------------------
% ? Document identification
\stardoccategory    {Starlink User Note}
\stardocinitials    {SUN}
\stardocsource      {sun183.6}
\stardocnumber      {183.6}
\stardocauthors     {D.S. Berry}
\stardocdate        {2nd October 2007}
\stardoctitle    {ARD ---
                                A Textual Language for Describing
                                Regions within a Data Array}
\stardocversion     {Version 2.2}
\stardocmanual      {Programmer's Manual}
\stardocabstract {
The ARD (ASCII Region Definition) system provides a textual language for
describing regions within a data array, together with software for converting
a textual description into a pixel mask, or plotting it on a graphics
device. The textual language is based on a set of keywords identifying simple
shapes (boxes, circles, lines, etc.). These keywords can be combined together
using Boolean-style operators (AND, OR, NOT, etc.) to create more complex
shapes. Data arrays can be multi-dimensional.
}
% ? End of document identification
% -----------------------------------------------------------------------------


% -----------------------------------------------------------------------------
% ? Document specific \providecommand or \newenvironment commands.

% Command for displaying routines in routine lists:
% =================================================

\providecommand{\noteroutine}[3]{
\begin{description}
\item [{\small \bf {#1} \parbox[t]{4in}{#2}}]
\mbox{} \nopagebreak \\
{\em #3}
\end{description}
}

% ? End of document specific commands
% -----------------------------------------------------------------------------
%  Title Page.
%  ===========
\begin{document}
\scfrontmatter

\section{Introduction}

Astronomical applications often require the user to identify regions of interest
within a data array. For instance a statistics application may need to be told
the region within the input image in which it is to evaluate the pixel
statistics. Another example is a data calibration application which needs
to be told the regions in which the detector was unreliable so that it can flag
the corresponding output pixels as bad.

One way of identifying such regions is through the use of a pixel mask. In a
pixel mask, different pixel values are used to differentiate between those
pixels which are to be included by the application and those which are to be
excluded. Such pixel masks are usually the same size and shape as the data array
being processed by the application (so that a one-for-one correspondence exists
between mask pixels and data pixels). This results in such masks occupying large
amounts of disk space. More importantly, it means that different pixel masks are
required for data arrays with different sizes or shapes.

ARD circumvents these problems by using textual expressions (known as ``ARD
descriptions'') to describe the pixels to be included by the application.
Multi-dimensional data arrays can be handled. A simple 2-dimensional ARD
description such as:

\small
\begin{terminalv}
      CIRCLE( 20, 20, 5 ) .OR. RECT( 20, 20, 30, 30 )
\end{terminalv}
\normalsize

tells the application to process all pixels which are \emph{either} within a
circle centred on pixel coordinates (20,20) with a radius of 5 pixels,
\emph{or} are within the rectangle with opposite corners at pixels coordinates
(20,20) and (30,30). The \htmlref{ARD\_WORK}{ARD_WORK}
subroutine will convert an ARD description such as this into a pixel mask, with
a shape and size specified by the application. The application will usually know
the shape and size of the data array and so can ask \htmlref{ARD\_WORK}{ARD_WORK} to create a pixel
mask of the correct shape and size. Once the pixel mask is no longer needed,
the storage space used to hold the mask can be released; there is no need to
keep permanent copies of the pixel mask on disk.

As well as creating pixel masks, the ARD library also provides facilities
to plot an ARD description on a graphics device. The \htmlref{ARD\_PLOT}{ARD_PLOT}
routine draws the borders of the regions described in the ARD description,
using a supplied \emph{AST Plot} (see \xref{SUN/210}{sun210}{}) to perform
the graphics.

In the above example, positions and distances in the ARD description were given
in pixel coordinates. The ARD language includes two systems which allow
positions and distances to be given in other coordinate systems:
\begin{enumerate}

\item As of ARD version 2.0, the calling application can define an
arbitrary collection of coordinate systems (which need not be linearly
related to pixel coordinates) by supplying an \emph{AST FrameSet} (see
\xref{SUN/210}{sun210}{}). The FrameSet contains information which allows
positions to be mapped from any of these coordinate systems into pixel
coordinates. Positions within the ARD description can then be given
in any of these coordinates systems (a statement in the ARD description
indicating which system is being used). Thus, for instance, if the pixel
array has an RA/DEC calibration, the application could supply a FrameSet
indicating how to convert from RA/DEC to pixel coordinates. This would
allow the ARD description to include positions in RA/DEC.

In addition, the ARD description itself can include a FrameSet defining
a collection of inter-related coordinate systems (positions in the ARD
description should be given in the "current" Frame of this FrameSet). In
this case, an attempt is made to find a coordinate system which is
contained both within the FrameSet supplied by the calling application,
and within the FrameSet supplied in the ARD description. For instance,
extending the previous example, if an ARD description contains position
given in pixel coordinates in some other specific image and also contains a
FrameSet which relates pixel positions within that image to RA/DEC, then
positions will be mapped from pixel coordinates within the original
image, into RA/DEC, and then into pixel coordinates within the required
mask image. This effectively allows pixel positions to be given within
one image and then transformed so that they can be used within another
image.

\item The calling application can also define an ``application coordinate
system'' which is linearly related to pixel coordinates. Positions within the
ARD description can then either be given directly in application coordinates,
or in any coordinate system linearly related to application coordinates
(in which case the ARD description must include statements describing the
linear transformation). This system was present in version 1 of ARD and
is still present in the current version, but is now deprecated in favour
of the above more general system.

\end{enumerate}

\subsection{Some Example ARD Descriptions}
ARD descriptions are made up by using logical \htmlref{operators}{SEC:OPER}
(\htmlref{.AND.}{OP:AND}, \htmlref{.OR.}{OP:OR}, \htmlref{.NOT.}{OP:NOT},
etc.) to combine together \htmlref{keywords}{SEC:KEYW} which represent the basic shapes known to ARD.
\htmlref{statements}{SEC:STAT} can also be included which modify the way the ARD description is
interpreted (for instance, by setting up an alternative coordinate system).

The ARD library includes two subroutines (\htmlref{ARD\_GROUP}{ARD_GROUP} and
\htmlref{ARD\_GRPEX}{ARD_GRPEX}) which
simplify the task of obtaining ARD descriptions from the user or environment.
Using these routines, an ARD description can be supplied to an application
either directly, or by storing it in a text file and supplying the name of the
text file to the application. The following examples represent lines stored in a
text file. Such lines are effectively concatenated together into a single string
before being processed by ARD:

\small
\begin{terminalv}
      ROTBOX( 0, 0, 20, 10, 30 )
\end{terminalv}
\normalsize

This example is simply a single keyword representing one of the basic shapes
known to ARD. It selects all pixels which have centres on or within a
2-dimensional rotated box. The box is centred on coordinates (0,0) and has
sides of length 20 and 10. The first side of the box (i.e. the one with length
20) is at an angle of $30^{\circ}$ \hspace{1mm} to the array X axis (measured
anti-clockwise).

\small
\begin{terminalv}
      CIR( 0, 0, 10 ) .AND. .NOT. ( COLUMN( 10 ) .OR. ROW( 5 ) )
\end{terminalv}
\normalsize

This example uses logical \htmlref{operators}{SEC:OPER} and parentheses to combine several basic
shapes together into a more complex shape. It also shows the use of abbreviated
\htmlref{keywords}{SEC:KEYW}. All pixels within the circle of radius 10 centred on (0,0) are
selected, except for those which are on column 10 or row 5.

\small
\begin{terminalv}
      COFRAME( SKY, System=FK5, Equinox=2003.5 )
      BOX( 12:23:41, -89:14, 1h40m, 20m )
\end{terminalv}
\normalsize

This example shows the use of \htmlref{statements}{SEC:STAT} to specify the
coordinate system in which positions are supplied. In this case, the
\htmlref{COFRAME}{ST:COFRAME} statement indicates that positions are
supplied in FK5 equatorial (RA/DEC) coordinates, referred to the equinox
of 2003.5. The \htmlref{BOX}{KEY:BOX} keyword then selects a box centred
at RA $12^{h}23^{m}41^{s}$ and Dec. $-89^{\deg}14^{'}$. The box covers an
RA range of $1^{h}40^{m}$ and a Dec range of $20^{'}$. The edges of a BOX
region are always lines of constant axis value. Since this region is very
close to the south equatorial pole, the pixel region containing this
"box" will have quite strongly curved sides.

\small
\begin{terminalv}
      PIXEL(  1,  1 )
      PIXEL( 20, 13 )
      PIXEL(-55,122 )
      PIXEL(112, 87 )
      PIXEL( 33, 12 )
\end{terminalv}
\normalsize

This example demonstrates the ability of ARD to recognise implicit
\htmlref{.OR.}{OP:OR} operators. The list of \htmlref{PIXEL}{KEY:PIX}
keywords specifies a set of individual pixels. Since these keywords have
no intervening operators, ARD assumes that a \htmlref{.OR.}{OP:OR}
operator is to be inserted between each pair, i.e. the union of all the
individual pixels is assumed.

\subsection{\label{SEC:EXAMC}An Example ARD Application}

This section presents Fortran code for an ADAM application which obtains
a data array (in the form of an NDF structure, see \xref{SUN/33}{sun33}{})
and an ARD description from the environment, converts the ARD description
into a pixel mask, and then finds and displays the data sum within the
region specified by the ARD description. The application will deal with
NDFs of any dimensionality up to the limit imposed by the NDF\_ system.

\small
\begin{terminalv}
      SUBROUTINE ARD_TEST( STATUS )                             [1]
      IMPLICIT NONE

*  Include definitions of global constants.
      INCLUDE 'SAE_PAR'                                         [2]
      INCLUDE 'NDF_PAR'
      INCLUDE 'PRM_PAR'
      INCLUDE 'GRP_PAR'
      INCLUDE 'AST_PAR'

*  Declare local variables.
      INTEGER STATUS, IGRP, INDF, NDIM, IPDATA, IPMASK, EL,
     :        LBND( NDF__MXDIM ), UBND( NDF__MXDIM ),           [3]
     :        LBNDI( NDF__MXDIM ), UBNDI( NDF__MXDIM ),
     :        LBNDE( NDF__MXDIM ), UBNDE( NDF__MXDIM ),
     :        REGVAL
      REAL SUM, TRCOEF( 1 )
      INTEGER IWCS

*  Check inherited global status.
      IF ( STATUS .NE. SAI__OK ) RETURN                         [4]

*  Obtain an identifier for the input NDF.
      CALL NDF_ASSOC( 'NDF', 'READ', INDF, STATUS )             [5]

*  Obtain the bounds of the NDF.
      CALL NDF_BOUND( INDF, NDF__MXDIM, LBND, UBND, NDIM,       [6]
     :                STATUS )

*  Map the DATA component of the NDF.
      CALL NDF_MAP( INDF, 'DATA', '_REAL', 'READ', IPDATA, EL,  [7]
     :              STATUS )

*  Obtain an ARD description specifying the region in which
*  the pixel values are to be summed.
      CALL ARD_GROUP( 'REGION', GRP__NOID, IGRP, STATUS )       [8]

*  Obtain workspace to hold the pixel mask corresponding to
*  the supplied ARD description.
      CALL PSX_CALLOC( EL, '_INTEGER', IPMASK, STATUS )         [9]

*  Get an AST FrameSet describing the WCS coordinate Frames stored
*  in the NDF.
      CALL NDF_GTWCS( INDF, IWCS, STATUS )                      [10]

*  Indicate that positions within the ARD description can be given in
*  any coordinate Frame included in the above WCS FrameSet.
      CALL ARD_WCS( IWCS, ' ', STATUS )                              [11]

*  Indicate that the value 2 should be used to represent
*  pixels specified by the first keyword in the ARD
*  description.
      REGVAL = 2

*  Call ARD_WORK to store positive values at all mask pixels
*  specified by the ARD description, and zero at all other
*  pixels.
      CALL ARD_WORK( IGRP, NDIM, LBND, UBND, TRCOEF, .FALSE.,   [12]
     :               REGVAL, %VAL( IPMASK ), LBNDI, UBNDI,
     :               LBNDE,  UBNDE, STATUS )

*  Call a subroutine to sum the data in the specified regions.
      CALL SUMIT( EL, %VAL( IPDATA ), %VAL( IPMASK ), SUM,
     :            STATUS )                                      [13]

*  Display the data sum.
      CALL MSG_SETR( 'SUM', SUM )
      CALL MSG_OUT( 'ARD_TEST_MSG1', '  Data sum: ^SUM',        [14]
     :               STATUS )

*  Release the work space used to hold the pixel mask.
      CALL PSX_FREE( IPMASK, STATUS )                           [15]

*  Delete the group used to hold the ARD description.
      CALL GRP_DELET( IGRP, STATUS )                            [16]

*  Annul the AST FrameSet identifier.
      CALL AST_ANNUL( IWCS, STATUS )                            [17]

*  Annul the NDF identifier.
      CALL NDF_ANNUL( INDF, STATUS )                            [18]

      END
\end{terminalv}
\normalsize

\textbf{Programming notes:}

\begin{enumerate}

\item The example is actually an ADAM A-task, and so consists of a
subroutine with a single argument giving the inherited status value.
See \xref{SUN/101}{sun101}{} for further details about writing ADAM
A-tasks. A ``stand-alone'' equivalent to the
\htmlref{ARD\_GROUP}{ARD_GROUP} routine is available which can be used
with non-ADAM applications.

\item The INCLUDE statements are used to define the various ``symbolic
constants'', which are used in this routine. Starlink software makes
widespread use of such constants, which should always be defined in
this way rather than by using actual numerical values. They are
recognisable by the double underscore ``\_\_'' (e.g. ``SAI\_\_OK'')
which distinguishes them from subroutine names. SAE\_PAR defines
constants starting with ``SAI\_\_'', NDF\_PAR defines constants
starting with ``NDF\_\_'' (see \xref{SUN/33}{sun33}{}), PRM\_PAR
defines constants starting with ``VAL\_\_'' (see
\xref{SUN/39}{sun39}{}), GRP\_PAR defines constants starting with
``GRP\_\_'' (see \xref{SUN/150}{sun150}{}), and AST\_PAR defines
constants starting with ``AST\_\_'' (see \xref{SUN/210}{sun210}{}).

\item This application is designed to be able to handle data arrays of any
dimensionality, up to the limit set by the NDF library. This limit is given by
the symbolic constant NDF\_\_MXDIM, which is used in the declaration of various
arrays used to hold information describing each axis.

\item The value of the STATUS argument is checked. This is because the
application uses the Starlink error handling strategy (see
\xref{SUN/104}{sun104}{}), which
requires that a subroutine should do nothing unless its STATUS argument is set
to the value SAI\_\_OK on entry. Here, we simply return without action if STATUS
has the wrong value.

\item The input NDF is now obtained using the ADAM parameter 'NDF'. This may
involve prompting the user, or the NDF may be identified using some other means
(for instance, the NDF may have been specified on the command line which
invoked the application). An integer value is returned to the application in
variable INDF. This is an NDF \emph{identifier} and is used to refer to the NDF
throughout the rest of the application.

\item The shape and size of the NDF is now obtained. This returns the number of
dimensions, and the upper and lower bounds on each axis. These bounds are needed
to be able to correctly locate positions supplied within the ARD description.

\item The DATA array in the NDF is then accessed by calling NDF\_MAP. Rather
than returning actual data values, this routine returns a \emph{pointer} to the
data values in IPDATA. The total number of pixels in the array is returned in
EL.

\item Next, the ARD description is obtained using ADAM parameter
'REGION'. The returned ARD description is stored in a ``GRP group''
(rather like a Fortran character array). The GRP package is described
in \xref{SUN/150}{sun150}{} and programmers using ARD should be aware
of its contents. An integer value is returned in IGRP which is used to
identify the group containing the ARD description throughout the rest
of the application. The second argument is a ``null group identifier''
(a symbolic constant defined within the include file GRP\_PAR). It is
used to indicate that there is no existing ARD description on which to
base the new ARD description; a completely new ARD description must be
supplied.

\item We now obtain a pointer to a temporary array in which we can store the
pixel mask corresponding to the ARD description. The mask has the same number of
pixels as the data array, and each pixel stores an integer value. The PSX
library is a Fortran interface to the POSIX library and is described in SUN/121.

\item An NDF structure can have a range of ``World Coordinate Systems''
associated with it. Information describing these coordinate systems, and
how to transform positions between them, is stored in the \emph{WCS
component} of the NDF. The NDF\_GTWCS routine returns an identifier for an
AST FrameSet which is a representation of the WCS component. The facilities
of the \xref{AST library}{sun210}{} can then be used to manipulate the WCS
information in many different ways.

\item ARD\_WCS stores the supplied FrameSet pointer for later use by the
ARD\_WORK routine. Making this call to ARD\_WCS is
optional. If it were not made, then positions within the ARD description
would have to be supplied in pixel coordinates. Since we are in fact
calling ARD\_WCS, positions within the ARD description can be supplied in
any coordinate system which can be related to any of the coordinate
systems in the NDF's WCS FrameSet.

\item The subroutine \htmlref{ARD\_WORK}{ARD_WORK} is now called to create
the pixel mask identifying the pixels specified by the ARD description.
Positive values are stored in the mask for such pixels, and zero is
stored for all other pixels. Note, no value need be assigned to the TRCOEF
argument since it will be ignored anyway. This is because of the earlier call
to ARD\_WCS which specifies the WCS information, and makes the TRCOEF
argument redundant.

\item A subroutine is now called to add up the pixel values in the regions
specified by the ARD description. The pointer values returned by NDF\_MAP and
PSX\_CALLOC are turned into actual Fortran arrays at this point, which SUMIT can
access. This is done using the \%VAL function in the call to SUMIT. SUMIT
is not part of the ARD package, but would be written by the application
programmer. It may look like this:

\small
\begin{terminalv}
      SUBROUTINE SUMIT( EL, DATA, MASK, SUM, STATUS )
      IMPLICIT NONE

*  Include definitions of global constants.
      INCLUDE 'SAE_PAR'
      INCLUDE 'PRM_PAR'

*  Arguments Given.
      INTEGER EL
      REAL DATA( EL )
      INTEGER MASK( EL )

*  Arguments Returned.
      REAL SUM

*  Arguments Given and Returned.
      INTEGER STATUS

*  Declare local variables.
      INTEGER I

*  Check inherited global status.
      IF ( STATUS .NE. SAI__OK ) RETURN

*  Initialise the sum of the valid data values.
      SUM = 0.0

*  Loop round every element in the data array.
      DO I = 1, EL

*  Check to see if this pixel was included in the ARD
*  description. It will have a positive mask value if it was.
*  Skip over the pixel if it was not included.
         IF( MASK( I ) .GT. 0 ) THEN

*  The regions selected by the ARD description may contain
*  pixels which are flagged as unusable in the input NDF.
*  Such pixels have the value given by the symbolic constant
*  VAL__BADR and should not be included in the returned data
*  sum.
            IF( DATA( I ) .NE. VAL__BADR ) THEN
               SUM = SUM + DATA( I )
            END IF

         END IF

      END DO

      END
\end{terminalv}
\normalsize

The two arrays can be treated as one dimensional vectors because they are the
same size and shape. This makes it easy to process arrays of any dimensionality.


\item The data sum is displayed by assigning its value to an ``MSG token'' and
then incorporating this token into a message to be displayed on the standard
output device. See SUN/104 for a description of the MSG package.

\item The storage space used to hold the pixel mask is released so that it can
be re-used.

\item The storage space used by the GRP group to hold the ARD description is
released.

\item We now tell the AST library to release the resources used to store
the FrameSet read from the NDF.

\item Finally, the NDF is closed.
\end{enumerate}

\subsection{Supplying ARD Descriptions to an Application}
This section outlines some of the ways in which a user could supply an ARD
description in response to a prompt for the 'REGION' parameter in the example
application described in the previous section.

The first thing to be said is that the dimensionality of the ARD
description (i.e. the number of values used to represent a single
position in the ARD description) need not match that of the supplied NDF.
The ARD description may refer to some subset of the axes in the NDF, in
which case the mask will be applied independently to every value on the
unspecified axes. By default, ARD descriptions are always assumed to be
2-dimensional, but this default can be over-ridden by including a
\htmlref{DIMENSION}{ST:DIM} statement in the ARD description. Thus for
instance, if the positions in the ARD description are 3-dimensional, the user
may want to give an ARD description such as:

\small
\begin{terminalv}
      DIMENSION( 3 )
      CIRCLE( 40, 50, 60, 10) .OR. CIRCLE( 45, 55, 65, 10 )
\end{terminalv}
\normalsize

The \htmlref{DIMENSION}{ST:DIM} statement tells ARD to expect three values per position. The rest
of the ARD description specifies the union of two spheres (i.e. ``3-dimensional
circles''), centred on (40,50,60) and (45,55,65), each of radius 10. This ARD
description uses the default coordinate system established by the application's
call to \htmlref{ARD\_WORK}{ARD_WORK}. In the case of the application above, this default
coordinate system is just the pixel coordinate system of the NDF.

ARD uses the versatile facilities of the GRP package to obtain the ARD
description. The following examples outline some of the ways in which the above
ARD description could be specified in response to a prompt for parameter
'REGION'. For more details on the facilities of GRP, see \xref{SUN/150}{sun150}{}. In each case
the ``$>$'' represents the final character of the prompt string issued by the
ADAM parameter system and is not actually typed in by the user:

\begin{enumerate}

\item The entire ARD description could be given as a single literal string:

\small
\begin{terminalv}
      > DIMENSION(3) CIRCLE( 40, 50, 60, 10) .OR. CIRCLE( 45, 55, 65, 10 )
\end{terminalv}
\normalsize

All blanks and tabs are ignored.

\item The ARD description could be split up into several strings given in
response to successive prompts. This is particularly useful for long ARD
descriptions:

\small
\begin{terminalv}
      > DIMENSION(3) -
      > CIRCLE( 40, 50, 60, 10) .OR. -
      > CIRCLE( 45, 55, 65, 10 )
\end{terminalv}
\normalsize

If an ARD description ends with a minus sign (``$-$''), the \htmlref{ARD\_GROUP}{ARD_GROUP} subroutine
will issue another prompt and append any string supplied to the end of the
previously supplied string. This continues until an ARD description is supplied
which doesn't end with a minus sign.

\item ARD descriptions can be split anywhere except in the middle of a numerical
value. So, for instance, the following responses would be valid:

\small
\begin{terminalv}
      > DIMENSION(3) CIRCLE( 40, 50, -
      > 60, 10) .OR. CIRCLE( 45, 55, -
      > 65, 10 )
\end{terminalv}
\normalsize

\item If ARD finds adjacent keywords without any intervening operator, an
implicit \htmlref{.OR.}{OP:OR} is inserted between them. So the following, in which the \htmlref{.OR.}{OP:OR}
operator is not explicitly included, would give the same results as the previous
examples:

\small
\begin{terminalv}
      > DIMENSION(3) -
      > CIRCLE( 40, 50, 60, 10 ) -
      > CIRCLE( 45, 55, 65, 10 )
\end{terminalv}
\normalsize

\item Instead of supplying the ARD description directly in response to the
parameter prompt, it can be stored in a text file and the name of the text file
given in response to the prompt. To do this, the file name must be
preceded by an up-arrow symbol (``\verb+^+''). If the file \verb+desc.ard+
contained the three lines:

\small
\begin{terminalv}
      DIMENSION(3)
      CIRCLE( 40, 50, 60, 10 )
      CIRCLE( 45, 55, 65, 10 )
\end{terminalv}
\normalsize

then the user could give the following response:

\small
\begin{terminalv}
      > ^desc.ard
\end{terminalv}
\normalsize

The ARD description can be split between the lines of the file in any way the
user chooses.

\item If only part of the ARD description is stored in a text file, then the two
methods can be combined. For instance, if the \htmlref{DIMENSION}{ST:DIM} statement is omitted
from the file, so that \verb+desc.ard+ contains:

\small
\begin{terminalv}
      CIRCLE( 40, 50, 60, 10 )
      CIRCLE( 45, 55, 65, 10 )
\end{terminalv}
\normalsize

then the user could give the complete ARD description by giving the following
response:

\small
\begin{terminalv}
      > DIMENSION(3);^desc.ard
\end{terminalv}
\normalsize

This would cause the contents of the file \verb+desc.ard+ to be concatenated with the
string preceding the ``;'' character. Note, the semi-colon is not included in
the ARD description returned by \htmlref{ARD\_GROUP}{ARD_GROUP}.

\item If the ARD description were to be split over several files, the contents
of the files could be concatenated together in a similar way:

\small
\begin{terminalv}
      > ^desc1.ard;^desc2.ard;^desc3.ard
\end{terminalv}
\normalsize

This would cause the contents of files \verb+desc1.ard+, \verb+desc2.ard+ and
\verb+desc3.ard+ to be
combined to form the final ARD description.

\item Indirection through text files can be nested. So if the string

\small
\begin{terminalv}
      ^desc1.ard;^desc2.ard;^desc3.ard
\end{terminalv}
\normalsize

were stored in a file \verb+total.ard+, then the user could give the response:

\small
\begin{terminalv}
      > ^total.ard
\end{terminalv}
\normalsize

\end{enumerate}

\section{\xlabel{ARDSyntax}ARD Description Syntax}
An ARD description consists of a stream of \emph{fields}, optionally
separated by one or more spaces, or tabs. There are three types of fields:

\begin{enumerate}

\item \htmlref{\emph{Keyword}}{SEC:KEYW} fields: These specify the basic shapes known to ARD
(\htmlref{CIRCLE}{KEY:CIR}, \htmlref{BOX}{KEY:BOX}, etc.) from which more complex shapes are constructed.

\item \htmlref{\emph{Operator}}{SEC:OPER} fields: These are logical operators, as in Fortran
(\htmlref{.AND.}{OP:AND}, \htmlref{.OR.}{OP:OR}, \htmlref{.XOR.}{OP:XOR}, \htmlref{.NOT.}{OP:NOT} etc.).

\item \htmlref{\emph{Statement}}{SEC:STAT} fields: These are fields which
effect the way that the keyword fields are interpreted, e.g. setting up
the dimensionality of the system (\htmlref{DIMENSION}{ST:DIM}), the
recognized coordinate systems (\htmlref{COFRAME}{ST:COFRAME}), etc.

\end{enumerate}

Some keyword and statement fields require argument lists, and these are enclosed
within parentheses following the keyword or statement. Arguments are delimited
by commas.

\htmlref{keywords}{SEC:KEYW} and \htmlref{statements}{SEC:STAT} can be abbreviated to three characters (\htmlref{operators}{SEC:OPER} cannot
be abbreviated). ARD descriptions are case-insensitive, and white space (eg
spaces, blank records in a file, blank group expressions) is ignored.

\subsection{Restrictions on the Order of Fields}
An ARD description is basically an algebraic expression in which the \htmlref{operators}{SEC:OPER}
are \emph{logical} operators (\htmlref{.AND.}{OP:AND}, \htmlref{.OR.}{OP:OR}, etc.) and the operands are represented
by \htmlref{keywords}{SEC:KEYW} (\htmlref{CIRCLE}{KEY:CIR}, \htmlref{BOX}{KEY:BOX}, etc.) which notionally take true or false values
depending on whether or not the current pixel is inside or outside the specified
region. Therefore, all the usual restrictions exist on the placing of operators
and operands in algebraic expressions; binary operators (e.g. \htmlref{.AND.}{OP:AND}) must have
an operand or bracketed expression on each side, unary operators (e.g. \htmlref{.NOT.}{OP:NOT})
must be followed by an operand or bracketed expression, opening and closing
parentheses must balance, etc.

There are, however, certain ways in which an ARD description can depart from
this syntax:

\begin{itemize}

\item Statement fields can be embedded within an ARD description at any point.
They are always removed before evaluating the ARD description as an algebraic
expression.

\item If .TRUE. is supplied for \htmlref{ARD\_WORK}{ARD_WORK} argument CONCAT, then a single
operator field may appear before the first keyword field. In this case the
``missing'' operand value to the left of the first operator is defined by the
initial mask supplied to routine \htmlref{ARD\_WORK}{ARD_WORK}. If CONCAT is supplied .TRUE. and no
operator field is found before the first keyword field, then an implicit \htmlref{.OR.}{OP:OR}
operator is assumed.

\item If two keyword fields do not have an intervening operator field, then an
implicit \htmlref{.OR.}{OP:OR} operator is assumed. This allows a simple list of regions to
be specified such as:

\small
\begin{terminalv}
   #
   #  ARD description file
   #
   POLYGON( 20, 20, 50, 50, 25, 75)      # A triangle
   ELLIPSE( 10.0, 10.0, 8.0, 5.0, 45.0 )
   CIRCLE( 22, 22, 40 )
\end{terminalv}
\normalsize

This is effectively equivalent to:

\small
\begin{terminalv}
   POLYGON( 20, 20, 50, 50, 25, 75) .OR.
   ELLIPSE( 10.0, 10.0, 8.0, 5.0, 45.0 ) .OR.
   CIRCLE( 22, 22, 40 )
\end{terminalv}
\normalsize

The returned integer mask will contain positive values within the union of the
three regions, and zero outside.

\item If an operand is directly followed by a \htmlref{.NOT.}{OP:NOT} operator then an implicit
\htmlref{.OR.}{OP:OR} will be inserted in front of the \htmlref{.NOT.}{OP:NOT} This allows lists of regions such
as the following to be given:

\small
\begin{terminalv}
   POLYGON( 20, 20, 50, 50, 25, 75)
   .NOT.ELLIPSE( 10.0, 10.0, 8.0, 5.0, 45.0 )
   .NOT.CIRCLE( 22, 22, 40 )
\end{terminalv}
\normalsize

The returned mask will contain positive values for all pixels which are
\emph{either} within the polygon, or are \emph{not} within the ellipse, or are
\emph{not} within the circle. It may need to be emphasised here that \htmlref{.OR.}{OP:OR} operators
are inserted and not \htmlref{.AND.}{OP:AND} operators.

\end{itemize}

\subsection{\label{SEC:GRPCC}Group Expression Control Characters}
The following two sub-sections supply details of the interaction of ARD with the
GRP package, and may safely be skipped over on an initial reading through this
document.

The stream of ARD fields is supplied in the form of a GRP group expression (and
stored in a normal GRP group) with the following control characters (see
\xref{SUN/150}{sun150}{}):

\begin{itemize}

\item ``\verb+^+'' is used to mark the start of an indirection file, from which
further ARD fields should be read.

\item ``\verb+#+'' is used to initiate a comment.

\item ``\verb+;+'' is used to delimit GRP elements. A GRP element may contain
any
number of ARD fields (within the restrictions on string length set by GRP).
Argument lists for keyword and statement fields can be split between elements.
An element may consist of a single reference to an indirection file (using the
``\verb+^+'' character). In this case the element must not contain any
explicit ARD fields. Note, GRP elements cannot span records. Thus,
carriage returns (either in a file or entered at a prompt) also act as GRP
element delimiters, in addition to the ``\verb+;+'' character.

\item ``\verb+*+'' is used as the token which represents basis names
within a modification element.

\item ``\verb+|+'' is used to separate old and new substitution strings
when editing names.

\item The ``OPEN\_NEST'' and ``CLOSE\_NEST'' control characters are not used
(they are set ``null'').

\item ``\verb+-+'' is used as the flag character. If a group expression is
supplied which ends with ``\verb+-+'', then the user is re-prompted for a
further group expression, which will be appended to the end of the earlier ones.
The interpretation of ``\verb+-+'' as the GRP flag character takes precedence
over it's interpretation as a synonym for the \htmlref{.NOT.}{OP:NOT} operator.

\item ``\verb+{+'' is used to open a new kernel.

\item ``\verb+}+'' is used to close a kernel. A typical use of the kernel
characters is to allow the contents of an indirection file to be edited before
being used. An element such as ``\verb+{^file1.ard}|100|200|+'' would cause the
contents of \verb+file1.ard+ to be read, and then all occurrences of 100 would
be replaced by 200.

\end{itemize}

A complete ARD description can be broken across several lines of an indirection
file, or across several directly supplied group expressions (each one terminated
with the flag character ``\verb+-+''). However, breaks must occur either
\emph{between} fields or between values in a keyword or statement argument list.

\subsection{\label{SEC:MOD}Use of GRP Modification Elements}
The GRP system provides a facility which allows a user to modify the
contents of a group previously created by the calling application. To do
this, a ``modification element'' is included in the supplied ARD
description (or ``group expression'' to use GRP parlance). A GRP
identifier for an existing group can be supplied to the routines
\htmlref{ARD\_GROUP}{ARD_GROUP} and \htmlref{ARD\_GRPEX}{ARD_GRPEX}
(argument IGRP1). If the ARD description supplied by the user contains a
modification element, then the contents of the group identified by IGRP1
will be modified according to the instructions in the modification
element, and the results incorporated into the returned group. Note, the
specified editing is applied separately to each element in the existing
group, to produce the corresponding element for the new group. Elements are
delimited in ARD descriptions by the ``\verb+;+'' character, \emph{and by
carriage returns}.

For instance, suppose that the application has already created a group
containing the following ARD description:

\small
\begin{terminalv}
      CIRCLE( 0, 10, 10 ) .OR. CIRCLE( 0, -10, 10 )
\end{terminalv}
\normalsize

If the GRP identifier for this group is supplied as argument IGRP1 to
routine \htmlref{ARD\_GROUP}{ARD_GROUP}, the user may supply an ARD
description including a modification element such as:

\small
\begin{terminalv}
      ( * ) .AND. BOX( 0, 0, 5, 5 )
\end{terminalv}
\normalsize

The asterisk is replaced in turn by each element of the contents of the
group identified by IGRP1 (the ``basis'' group).
Thus, the above ARD description is equivalent to the following:

\small
\begin{terminalv}
      ( CIRCLE( 0, 10, 10 ) .OR. CIRCLE( 0, -10, 10 ) ) .AND. BOX( 0, 0, 5, 5 )
\end{terminalv}
\normalsize

Note, the original ARD description was supplied on a single line, and was
thus stored as a single element in the group. If it had spanned lines,
then each line would have been edited separately. For instance, if the
original ARD description had been supplied as follows, on two lines:

\small
\begin{terminalv}
      CIRCLE( 0, 10, 10 ) .OR.
      CIRCLE( 0, -10, 10 )
\end{terminalv}
\normalsize

then the modified ARD description would be :

\small
\begin{terminalv}
      ( CIRCLE( 0, 10, 10 ) .OR. ) .AND. BOX( 0, 0, 5, 5 )
      ( CIRCLE( 0, -10, 10 ) ) .AND. BOX( 0, 0, 5, 5 )
\end{terminalv}
\normalsize

This group expression would not be accepted by \htmlref{ARD\_WORK}{ARD_WORK}
because of the missing operand after the \htmlref{.OR.}{OP:OR} operator.

If the user has supplied the ARD description on a single line, and then
modified it using the following ARD description:

\small
\begin{terminalv}
      ( *|10|5| ) .AND. BOX( 0, 0, 5, 5 )
\end{terminalv}
\normalsize

then the basis group would be edited by replacing all occurrences of the
string ``10'' by the string ``5'', before being included in the final ARD
description. Thus the above would be equivalent to:

\small
\begin{terminalv}
      ( CIRCLE( 0, 5, 5 ) .OR. CIRCLE( 0, -5, 5 ) ) .AND. BOX( 0, 0, 5, 5 )
\end{terminalv}
\normalsize

The syntax of such modification elements is described fully in \xref{SUN/150}{sun150}{}.

\section{\xlabel{ARDInterpretation}Interpretation of ARD Descriptions}
After removal of all statement fields, and the insertion of any implicit \htmlref{.OR.}{OP:OR}
operators, the fields in an ARD description are treated as a Fortran-like
logical expression. Each keyword field forms a logical operand, acted upon by
the adjoining operator fields. \htmlref{operators}{SEC:OPER} have their usual Fortran precedence
(see Section \ref{SEC:OPER}). The order of evaluation can be changed by
enclosing sub-expressions within parentheses as usual. The interpretation of
operands depends on the type of keyword:

\begin{itemize}

\item Operands for regions which (in general) have non-zero volume (e.g.
\htmlref{POLYGON}{KEY:POL},
\htmlref{CIRCLE}{KEY:CIR}, \htmlref{BOX}{KEY:BOX}, etc.) are .TRUE. if the \emph{centre} of the current pixel lies on or
within the boundary of the region, and are .FALSE. otherwise.

\item Operands for regions which have zero volume (e.g.
\htmlref{POINT}{KEY:POINT},
\htmlref{LINE}{KEY:LINE}, \htmlref{ROW}{KEY:ROW}, \htmlref{COLUMN}{KEY:COL},
etc.) are .TRUE. if the boundary of the region passes \emph{through} the current
pixel. The pixel with index $I$ along some axis is assumed to cover a range of
pixel coordinates $P$ given by $(I-1) < P \leq I$.

\end{itemize}

\subsection{Values within the Pixel Mask}
The \htmlref{ARD\_WORK}{ARD_WORK} subroutine creates an array of integer values (the ``mask'') which
holds the result of evaluating the entire logical expression at each pixel.
Positive integers represent .TRUE. (i.e. included pixels) and zero represents
.FALSE. (i.e. excluded pixels).

Each keyword included in an ARD description is represented by a different
positive integer. This provides the possibility for applications to
differentiate between the different regions within an ARD description on the
basis of the pixel mask alone.

\subsubsection{Background Pixels}
The \htmlref{.NOT.}{OP:NOT} operator adds a few complications in that it requests pixels to be
included which are \emph{not} within a given region. For instance:

\small
\begin{terminalv}
      .NOT.CIRCLE( 0, 0, 10)
\end{terminalv}
\normalsize

includes all pixels which are not within the circle of radius 10 centred on the
origin. If (say) the value 2 was used to represent the \htmlref{CIRCLE}{KEY:CIR} region, what value
should be used to represent the pixels which are \emph{not} within the circle?
The solution adopted by ARD is to consider all pixels \emph{not} within a region
to be ``background'' pixels, and to reserve the value 1 to represent such
pixels. All \htmlref{.NOT.}{OP:NOT} operators in an ARD description use the value 1 to represent
included background pixels. Note, ARD doesn't know if a pixel is truly part of
the background or not, it just assumes that all pixels selected by a \htmlref{.NOT.}{OP:NOT}
operator will be background. This gives rise to a possible anomaly which can be
illustrated by the ARD description:

\small
\begin{terminalv}
      .NOT. ( .NOT. CIRCLE( 0, 0, 10 ) )
\end{terminalv}
\normalsize

One might expect this to be equivalent to the ARD description:

\small
\begin{terminalv}
      CIRCLE( 0, 0, 10 )
\end{terminalv}
\normalsize

but there will be a difference. The two ARD descriptions will store positive
values at the same pixels (i.e. those within the circle), but the values stored
will be different. In the first ARD description, the included pixels are
generated by a \htmlref{.NOT.}{OP:NOT} operator and so will be considered to be ``background''
pixels and will be represented by the value 1. In the second ARD description,
the included pixels are generated directly by the \htmlref{CIRCLE}{KEY:CIR} keyword and will be
represented by the value assigned to the keyword (which will be larger than 1).

The \htmlref{.EQV.}{OP:EQV} operator can also cause background pixels to be included in the
returned mask, and such background pixels are again represented by the value 1.
The ARD description:

\small
\begin{terminalv}
      CIRCLE( 0, 0, 10 ) .EQV. CIRCLE( 10, 0, 10)
\end{terminalv}
\normalsize

selects pixels which are either within both circles or within neither circle.
Pixels which are within neither circle form part of the background, and are
represented by the value 1. Pixels which are within both circles are represented
by the larger of the two values assigned to the two keywords.

\subsubsection{Assignment of Keyword Values}
The choice of which positive value to use to represent each keyword in the ARD
description is controlled by the REGVAL argument supplied to the \htmlref{ARD\_WORK}{ARD_WORK}
routine. If a positive value is supplied for REGVAL then the first keyword in the
ARD description (working from left to right) is assigned the supplied value.
Successive values are assigned to the remaining keywords. An error is reported
if REGVAL is supplied equal to 1. This is because 1 is reserved to represent
background pixels and may not be used to represent keywords.

If a zero or negative value is supplied for REGVAL, then the array of pixel
values supplied to \htmlref{ARD\_WORK}{ARD_WORK} in argument MASK is examined and the maximum value
found. This value is incremented by one and used to represent the first keyword
in the ARD description (if the incremented value is less than 2, then 2 is used
instead). Successive values are assigned to the remaining \htmlref{keywords}{SEC:KEYW}.

There is one exception to these rules; pixels selected using an \htmlref{INPUT}{KEY:INP} keyword
(see section \ref{SEC:MASK}) are assigned the values of the corresponding pixels
in the input mask supplied to \htmlref{ARD\_WORK}{ARD_WORK}, irrespective of the position of the
\htmlref{INPUT}{KEY:INP} keyword in the ARD description. The inclusion of \htmlref{INPUT}{KEY:INP} keywords within an
ARD description does not effect the integer values used to represent other
\htmlref{keywords}{SEC:KEYW}. Thus if REGVAL is supplied equal to 2 and the ARD description is:

\small
\begin{terminalv}
      CIRCLE( 0, 0, 10 ) .AND. ( INPUT .OR. CIRCLE( 0, 10, 10 ) )
\end{terminalv}
\normalsize

then the \htmlref{CIRCLE}{KEY:CIR}(0,0,10) region is assigned the value 2 and the \htmlref{CIRCLE}{KEY:CIR}(0,10,10)
region is assigned the value 3 (i.e. the \htmlref{INPUT}{KEY:INP} keyword is not included in the
count of \htmlref{keywords}{SEC:KEYW}).

On return from \htmlref{ARD\_WORK}{ARD_WORK} the REGVAL argument will hold a value one larger than
the value assigned to the last keyword in the ARD description.

\subsubsection{Pixels Included in Several Regions}
If a given pixel falls within more than one region, then the largest of the
values associated with the regions is stored at the pixel's location.
Specifically, the rules for determining the result of each operator are:

\begin{description}
\item [.AND.] - A zero is returned unless both operands are positive, in which
case the larger of the two positive values is returned.
\item [.OR.] - The larger of the two operand values is returned.
\item [.XOR.] - If either operand is zero, then the value of the other operand
is returned. If neither operand is zero, then zero is returned.
\item [.EQV.] - If neither of the operands is zero, then the larger of the two
operands is returned. If one of the operands is zero, then zero is returned. If
both of the operands are zero, then the value 1 is returned.
\item [.NOT.] - If the operand is positive, then zero is returned. If the
operand is zero, then 1 is returned.
\end{description}

Let's look at an example:

\small
\begin{terminalv}
      CIR( 0, 0, 50 )
      CIR( 0, 0, 40 )
      CIR( 0, 0, 30 )
      CIR( 0, 0, 20 )
      CIR( 0, 0, 10 )
\end{terminalv}
\normalsize

An implicit \htmlref{.OR.}{OP:OR} operator is assumed to exist between each of the \htmlref{CIRCLE}{KEY:CIR}
keywords. Let's assume that \htmlref{ARD\_WORK}{ARD_WORK} is called with argument REGVAL set to
2. The \htmlref{CIR}{KEY:CIR}(0,0,50) keyword is evaluated first and causes a circular region
of radius 50 to be filled with the value 2. Next, the \htmlref{CIR}{KEY:CIR}(0,0,40) keyword is
evaluated. The value used to represent included pixels is incremented to 3, and
a circular region of radius 40 is filled with this value, over-writing some of
the 2's which were written to the mask because of the previous keyword. Since
the circular regions are concentric (both being centred on the (0,0) ), this
will leave an annulus containing the value 2 around the edge of the circle
containing value 3. The remaining \htmlref{keywords}{SEC:KEYW} are processed in the same way, each
successive keyword over-writing all but an annulus of the circle created by the
previous keyword. The final mask consists of a set of concentric annuli, each of
thickness 10. Working outwards from the centre, the annuli have the values 6, 5,
4, 3 and 2. The REGVAL argument will be returned holding 7.

One consequence of allowing larger values to ``over-write'' smaller values is
that background pixels always get over-written by pixels which are selected by
virtue of being within a keyword region. Consider the following (assuming that
REGVAL is again supplied equal to 2):

\small
\begin{terminalv}
      CIRCLE( 0, 0, 10 ) .AND. .NOT. CIRCLE( 0, 0, 5 )
\end{terminalv}
\normalsize

This ARD description will be evaluated by first creating two intermediate masks,
one containing the \htmlref{CIRCLE}{KEY:CIR}(0,0,10) region and another containing the
\htmlref{.NOT.}{OP:NOT}\htmlref{CIRCLE}{KEY:CIR}(0,0,5) region. These two masks will then be combined together using
the \htmlref{.AND.}{OP:AND} operator to create the final mask. The first intermediate mask
contains the value 2 at all pixels which are within the \htmlref{CIRCLE}{KEY:CIR}(0,0,10) region,
and zero at all other pixels.

The second intermediate mask is initially set to hold the region \htmlref{CIRCLE}{KEY:CIR}(0,0,5).
This means that pixels within the circle are given the value 3 and all others
are given the value zero. The mask is then inverted to take account of the \htmlref{.NOT.}{OP:NOT}
operator. Pixels inside the circle which previously held the value 3 are changed
to zero (indicating that these pixels have \emph{not} been selected). Pixels
outside the circle which previously held the value zero are assigned the value 1
(indicating that these pixels are background pixels).

The last stage is to combine the two intermediate masks together following the
rules described above for an \htmlref{.AND.}{OP:AND} operator. Pixels which are further than 10
units from the origin (i.e. outside the \htmlref{CIRCLE}{KEY:CIR}(0,0,10) region) will hold zero in
the first mask and 1 in the second mask, and so will be assigned a
value zero in the final mask. Pixels which are between 5 and 10 units from the
origin (i.e. inside the first circle but not the second) will have the value 2
in the first mask and the value 1 in the second. Both these values are
positive and so the output mask pixel will also be positive. The rules for the
\htmlref{.AND.}{OP:AND} operator above say that the positive value used will be the larger of the
two values in the input masks. Thus the output mask pixels are assigned the
value 2. Pixels which are less than 5 units from the origin will have the value
2 in the first mask and the value zero in the second mask, and so are assigned
the value zero in the output mask. The final mask thus holds an annulus
extending from radius 5 to radius 10 in which the pixels hold the value 2, all
other pixels holding the value zero.

\subsection{\label{SEC:MASK}Supplying an Initial Pixel Mask}
It may sometimes be necessary for applications to combine together pixel masks
created from different ARD descriptions. To do this, the ARD descriptions should
be processed in turn by \htmlref{ARD\_WORK}{ARD_WORK} and they should use the ``\htmlref{INPUT}{KEY:INP}'' keyword.
This keyword refers to the pixel mask supplied to routine \htmlref{ARD\_WORK}{ARD_WORK} in argument
MASK; if a pixel holds a positive value in the supplied mask then the \htmlref{INPUT}{KEY:INP}
keyword is notionally .TRUE., and is notionally .FALSE. if the pixel value is
zero or negative. This keyword can be used at any point in an ARD description,
and can be included any number of times. A simple example of its use could be:

\small
\begin{terminalv}
      .NOT. INPUT
\end{terminalv}
\normalsize

which inverts the supplied mask. If the ARD description does not include any
references to the \htmlref{INPUT}{KEY:INP} keyword, then the application can force an \htmlref{INPUT}{KEY:INP} keyword
to be inserted at the start of the ARD description by supplying a .TRUE. value
for \htmlref{ARD\_WORK}{ARD_WORK} argument CONCAT. For instance, if CONCAT is supplied .TRUE., then
the ARD description:

\small
\begin{terminalv}
      BOX( 0, 0, 10, 10 ) .OR. CIR( 0, 0, 10 )
\end{terminalv}
\normalsize

becomes

\small
\begin{terminalv}
      INPUT BOX( 0, 0, 10, 10 ) .OR. CIR( 0, 0, 10 )
\end{terminalv}
\normalsize

There is now no operator between the \htmlref{INPUT}{KEY:INP} and \htmlref{BOX}{KEY:BOX} keywords, and so ARD inserts
an implicit \htmlref{.OR.}{OP:OR} so that the final ARD description used is:

\small
\begin{terminalv}
      INPUT .OR. BOX( 0, 0, 10, 10 ) .OR. CIR( 0, 0, 10 )
\end{terminalv}
\normalsize

If the supplied ARD description had started with an operator, for instance:

\small
\begin{terminalv}
      .AND.( BOX( 0, 0, 10, 10 ) .OR. CIR( 0, 0, 10 ) )
\end{terminalv}
\normalsize

then there would be no need to insert an implicit \htmlref{.OR.}{OP:OR} after the \htmlref{INPUT}{KEY:INP} keyword,
and so the final used ARD description would be:

\small
\begin{terminalv}
      INPUT .AND.( BOX( 0, 0, 10, 10 ) .OR. CIR( 0, 0, 10 ) )
\end{terminalv}
\normalsize

To re-iterate, an \htmlref{INPUT}{KEY:INP} keyword is inserted at the start of the ARD description
only if the ARD description as supplied contains no \htmlref{INPUT}{KEY:INP} keywords, \emph{and}
the \htmlref{ARD\_WORK}{ARD_WORK} argument CONCAT is supplied .TRUE.. If either of these conditions
is broken then the ARD description is left as supplied.

\subsection{\label{SEC:BBOX}Bounding Boxes}
To combine two large masks using a binary operator at every pixel can be
wasteful of processor time, especially if not many of the pixels have actually
been selected. To reduce this waste, ARD keeps track of the regions within the
mask where the selected pixels are located, and only processes pixels in those
regions. Precisely, ARD maintains a pair of ``bounding boxes'' throughout its
evaluation of an ARD description. These are referred to as the internal and
external bounding boxes. Each bounding box is a rectangular region of the mask.
The internal bounding box contains \emph{all} included pixels in the mask, but
may also contain some excluded pixels. Conversely, the external bounding box
contains all excluded pixels and may also contain some included pixels.

The upper and lower bounds of these boxes are returned to the calling
application when the mask is complete. If an application is only interested in
included pixels, it may then restrict its attention to the region of the data
array contained within the internal bounding box (all pixels outside this box
are guaranteed to be excluded). It is still necessary for the application to
check mask pixels to see if they are included or excluded, but the checks can
at least be restricted to the region of the internal bounding box. The external
bounding box can be used in a similar way if the application is only interested
in excluded pixels.

If \emph{all} mask pixels are included (i.e. if there are no excluded pixels)
then the external bounding box will be returned ``null'', and the internal
bounding box will be returned covering the entire mask. Likewise, if \emph{all}
mask pixels are excluded (i.e. if there are no included pixels) then the
internal bounding box will be returned ``null'', and the external bounding box
will be returned covering the entire mask. Null bounding boxes are identified by
the fact that the lower bound of each axis is greater than the corresponding
upper bound. This condition should always be checked for before using a
bounding box.

\section{\label{SEC:COORD}\xlabel{ARDCoords}Coordinate Systems}
ARD\_WORK needs to be able to locate pixels within the given pixel mask.
To do this, every position supplied in an ARD description must be
converted into \emph{pixel coordinates}. The position of the origin of
pixel coordinates within the mask is fixed by the upper and lower bounds
of the mask supplied to \htmlref{ARD\_WORK}{ARD_WORK}. The conventions
for pixel coordinates used by Starlink software are described in
\xref{Starlink System Note (SSN) 22}{ssn22}{}.

However, it is not always appropriate for an ARD description to describe
a region in terms of pixel coordinates. For instance, in a mosaic image
a given position on the sky may have different pixel coordinates in each
image. To describe a given region in pixel coordinates would therefore
require a separate description for each image. In this case, we would
ideally like to use a single ARD description in which the region was
defined in terms of RA and Dec. positions. This can be done, so long as
ARD\_WORK knows how to transform an RA/Dec position into pixel
coordinates within each of the specified pixel masks.

There are two schemes supported by the ARD library to allow the ARD
description to include positions in a coordinate system other than pixel
coordinates. As of version 2 of the ARD library, the facilities of the
AST library (see \xref{SUN/210}{sun210}{}) can be used to specify
positions within generalised non-linear coordinate systems. Prior to
version 2, positions needed to be supplied in a coordinate system which
was linearly related to pixel coordinates in the mask supplied to
ARD\_WORK. The version 1 scheme is still available in version 2 of the
library, but is deprecated.

\subsection{World Coordinate Systems in ARD Version 2}

ARD version 2 uses the facilities of the \xref{AST library}{sun210}{} to
manage coordinate systems. An AST ``FrameSet'' describes a collection of
related coordinate systems (also called ``Frames''), together with the
mappings which allows positions to be transformed from one Frame to
another. The calling application will always know how to locate a point
within the mask if the point is specified in pixel coordinates. If, in
addition, it can also locate points specified in one or more other
coordinate systems, then it should create a FrameSet describing all the
coordinate systems which it knows about, one of which must be pixel
coordinates within the mask\footnote{ARD recognizes this Frame by the
fact that its Domain attribute is set to ``PIXEL''.}. It then passes this
FrameSet to the ARD system by calling routine ARD\_WCS (this must be done
prior to calling ARD\_WORK)\footnote{You may be wondering why a separate
routine is used instead of simply passing the information to ARD\_WORK as
an argument. This was done so that existing application which use ARD
version 1 would continue to work without modification.}. This FrameSet is
known as the ``Application FrameSet'', and encapsulates knowledge of all
the coordinate systems known to the application.

If ARD\_WCS is not used, then a default application FrameSet containing a
single Frame describing pixel coordinates is generated automatically.

The ARD description must then include statements describing the
coordinate system in which positions are given within the ARD description.
This can be done in one of three ways:

\begin{enumerate}
\item By including a \htmlref{COFRAME}{ST:COFRAME} statement before any
keywords. A COFRAME statement describes a single coordinate system,
namely that in which positions are given within the ARD description.

ARD\_WORK will determine if there is any way of converting positions
given within this coordinate system into any of the coordinate systems
included in the Application FrameSet, and thus into pixel coordinates.
If there is, then the corresponding transformation is used to locate
positions within the pixel mask. Otherwise, an error is reported.

\item By including a \htmlref{WCS}{ST:WCS} statement before any
keywords. A WCS statement specifies a FrameSet describing all the
coordinate system known to the user. Positions within the ARD description
are then assumed to be given within the ``current'' Frame of this
FrameSet. This FrameSet is known as the ``User FrameSet'' to distinguish
it from the ``Application FrameSet''.

ARD\_WORK will search both FrameSets looking for a coordinate system
which is present in both. If such a Frame is found, the User FrameSet is
used to convert positions included in the ARD description into the common
Frame, and the Application FrameSet is then used to convert positions
from the common Frame into pixel coordinates. If no common Frame is
found, then an error is reported. It may be that there is more than one
common Frame, in this case priority is given to Frames describing
celestial coordinate systems, followed by pixel coordinate Frames,
followed by Frames with Domain GRID, followed by Frames with Domain
ARDAPP. The highest priority Frame found within this list is used as the
common Frame.

\item If there is neither a WCS nor a COFRAME statement in the ARD
description, then it is assumed that positions are supplied in a default
coordinate system. This default is determined as follows:

\begin{itemize}
\item If an application FrameSet has been specified using ARD\_WCS, then
the default coordinate system is the current Frame of the application
FrameSet. In this case, the $TR$ argument for routine ARD\_WORK is ignored.

\item If no application FrameSet has been specified using ARD\_WCS, then
the default coordinate system is obtained by transforming the pixel
coordinate system according to the values supplied for argument $TR$ when
calling ARD\_WORK. This is the system which was used prior to ARD version
2 (see the next section for more details).
\end{itemize}

In addition, the deprecated version 1 statements COEFFS, OFFSET, TWIST,
STRETCH, SCALE can be used to modify the relationship between the
coordinate system used within the ARD description and the default
coordinate system describe above. If any of these statements are found,
then any earlier COFRAME or WCS statements are ignored, and the requested
operation (stretch, twist, offset, \emph{etc}) is applied to the default
coordinate system described above.

\end{enumerate}

An ARD description can contain zero, one or more of the above WCS-related
statements. The positions, \emph{etc}, defining a given region in the
description are interpreted using the most recent WCS-related statement.
Thus, WCS information given later in an ARD description over-rides any
given earlier.

If any of the deprecated version 1 statements (COEFFS, OFFSET, TWIST,
STRETCH, SCALE) are found, then any earlier COFRAME or WCS statements are
ignored, and the requested operation (stretch, twist, offset, \emph{etc}) is
applied to the default coordinate system described above. For this
reason, you should not normally mix the old and the new statements.

\subsection{Coordinate Handling in ARD Prior to Version 2}

ARD version 1 required the transformation between ``user coordinates''
(\emph{i.e.} the coordinate system in which positions are supplied in the
ARD description) to pixel coordinates to be linear. This linear
transformation was split up into two components; the application specified
a linear transformation from pixel coordinates to ``application
coordinates'' when calling ARD\_WORK, and the ARD description included
statements which defined a linear transformation from application
coordinates to user coordinates (by default, user coordinates were
assumed to be identical with application coordinates). These two
components were concatenated to get the total transformation from pixel
to user coordinates.

\subsubsection{Application Coordinates}
Version 1 applications use the TRCOEF argument of the \htmlref{ARD\_WORK}{ARD_WORK}
routine to define the application coordinate system. TRCOEF would be supplied
holding the
coefficients of the linear mapping from application coordinates to pixel
coordinates. For instance, if a 2-dimensional application coordinates system
$(x_{a},y_{a})$ is required to be equal to pixel coordinates $(x_{p},y_{p})$,
but with the origin shifted to pixel coordinates $(10,20)$, then the linear
mapping from $(x_{a},y_{a})$ to $(x_{p},y_{p})$ is:
\small
\begin{eqnarray*}
x_{p} & = & 10 + 1.x_{a} + 0.y_{a} \\
y_{p} & = & 20 + 0.x_{a} + 1.y_{a}
\end{eqnarray*}
\normalsize

In this case TRCOEF would be supplied holding the 6 coefficient values
(10,1,0,20,0,1). In general, if ($Y_{1}$, $Y_{2}$, $Y_{3}$, ..., $Y_{N}$) are a
set of application coordinates in $N$ dimensions, and ($Z_{1}$, $Z_{2}$,
$Z_{3}$, ..., $Z_{N}$) are the corresponding pixel coordinates, then the
application supplies a set of constants $C_{1}$ to $C_{N*(N+1)}$, where:
\small
\begin{eqnarray*}
Z_{1} & = & C_{1} + C_{2}.Y_{1} + C_{3}.Y_{2} + ... + C_{N+1}.Y_{N} \\
Z_{2} & = & C_{N+2} + C_{N+3}.Y_{1} + C_{N+4}.Y_{2} + ... + C_{2.(N+1)}.Y_{N} \\
 ....\\
Z_{N} & = & C_{N.N} + C_{N.(N+1)}.Y_{1} + C_{N.(N+2)}.Y_{2} + ... + C_{N.(N+1)}.Y_{N}
\end{eqnarray*}
\normalsize

These constants can be supplied to \htmlref{ARD\_WORK}{ARD_WORK} as a 1-dimensional vector
$C$ with N.(N+1) elements, or as a 2-dimensional array $T$ with dimensions
( 0:N, N ) where:
\small
\begin{eqnarray*}
Z_{1} & = & T(0,1) + T(1,1).Y_{1} + T(2,1).Y_{2} + ... + T(N,1).Y_{N} \\
Z_{2} & = & T(0,2) + T(1,2).Y_{1} + T(2,2).Y_{2} + ... + T(N,2).Y_{N} \\
 ....\\
Z_{N} & = & T(0,N) + T(1,N).Y_{1} + T(2,N).Y_{2} + ... + T(N,N).Y_{N}
\end{eqnarray*}
\normalsize

The order in which the coefficient values are stored is the same in both
cases.

There will be many cases in which application coordinates are required to be
just equal to pixel coordinates. In this case the diagonal elements of the T
array ( T(1,1), T(2,2), etc.) would be set to one and all other elements of T
would be set to zero. This is likely to be a common requirement, and so
\htmlref{ARD\_WORK}{ARD_WORK} has a special facility for creating such a ``unit'' mapping. If the
first coefficient ( C(1) or T(0,1) ) is set equal to the symbolic constant
VAL\_\_BADR (defined in include file PRM\_PAR), then \htmlref{ARD\_WORK}{ARD_WORK} will ignore the
supplied values of TRCOEF and use a unit mapping instead.

\subsubsection{User Coordinates}
The positions and displacements within a Version 1 ARD description are
interpreted as
application coordinates by default. To supply positions
and displacements in some other linearly-related coordinate system, the ARD
description would contain statement fields defining the mapping from user
coordinates to application coordinates. Such mappings were set up using the
\htmlref{statements}{SEC:STAT}
\htmlref{COEFFS}{ST:COE},
\htmlref{OFFSET}{ST:OFF},
\htmlref{SCALE}{ST:SCALE},
\htmlref{TWIST}{ST:TWI} and
\htmlref{STRETCH}{ST:STR}.

For instance, if the application expects coordinates to be given in
arc-seconds but the user wishes to give them in arc-minutes, then the
statement \htmlref{SCALE}{ST:SCALE}( 60 ) should be included in the ARD
description before the first keyword. This mapping is then concatenated
with the mapping supplied by the application to get the mapping from user
coordinates to pixel coordinates.

The user coordinate system may be changed at any point within an ARD
description using suitable statement (\htmlref{COEFFS}{ST:COE}, etc.),
and the new mapping will be used to interpret all further positions until
the user coordinate system is modified again.

Arguments which specify distances (such as the radius of a circle for instance)
are subject to the current mapping. Thus, for instance, a circle may be
transformed into an ellipse if the coordinate axes have different scales.

\section{\label{SEC:KEYW}\xlabel{ARDKeywords}Keywords}
Keywords are fields within an ARD description which specify one of the
basic shapes known to ARD. Most are followed by an argument list giving
values for the size, position, orientation, etc., of the shape. Argument
lists are contained within parentheses, and arguments are separated by
commas. Positions and distances should be supplied in a format
appropriate to the current user coordinate system as determined by the
WCS and/or COFRAME statements. Keywords can be abbreviated to three
characters. The following keywords are currently supported ($N$
represents the dimensionality of the ARD description, and all positions
and distances are given in $N$-dimensional user coordinates):

\begin{description}

\item [\label{KEY:BOX}BOX] - A rectangular box with sides parallel to the
user coordinate axes. The argument list should contain $2*N$ values; the
first $N$ values give the coordinates of the box centre, and the
remaining $N$ values give the lengths of the box sides. It may sometimes
be more convenient to use the \htmlref{RECT}{KEY:REC} keyword which specifies
a rectangular box in terms of two diagonally opposite corners.

\item [\label{KEY:CIR}CIRCLE] - A circle (for $N=2$) or sphere (for $N>2$).
The argument list should contain $N+1$ values; the first $N$ values give
the coordinates of the centre of the circle or sphere, and the remaining
value gives the radius (in user coordinates).

\item [\label{KEY:COL}COLUMN] - A set of lines parallel to the second
axis of the user coordinate system. The argument list can contain any number
of values (one for each of the lines). Each argument value $X$ specifies that
the corresponding line should pass through the position $(X,0)$. This keyword
can only be used in 2-dimensional ARD descriptions.

\item [\label{KEY:ELL}ELLIPSE] - A 2-dimensional ellipse. The argument list
should contain 5 values; the first pair give the user coordinates of
the centre of the ellipse, the second pair give the half-lengths of the
two axes of the ellipse (in user coordinates), and the fifth value gives
the angle (in degrees) from the first axis of the user coordinate system
to the first axis of the ellipse (positive rotation is from the first to
the second user axis). This keyword can only be used in 2-dimensional ARD
descriptions.

\item [\label{KEY:FRA}FRAME] - The entire mask excluding a border of given
width. The argument list should contain a single value giving the width
of the border. This keyword can only be used in 2-dimensional ARD
descriptions. A further restriction on its use is that the current
mapping from user coordinates to pixel coordinates must be isomorphic
(i.e. each mask pixel must correspond to a square area in user
coordinates; the square may be rotated, shifted and/or scaled, but it
must still be a square). If this is not the case an error will be
reported by \htmlref{ARD\_WORK}{ARD_WORK}.

\item [\label{KEY:INP}INPUT] - The pixel mask supplied as input to routine
\htmlref{ARD\_WORK}{ARD_WORK}.

\item [\label{KEY:LIN}LINE] - A straight line between two given positions.
The argument list should contain $2*N$ values, the first set of $N$
values giving the user coordinates of the first position, and the second set
of $N$ values giving the second position. Only the section of the line
between (and including) the two positions is included in the mask.

\item [\label{KEY:PIX}PIXEL] - A set of individual pixels. The argument list
should contain an integer multiple of $N$ values; each set of $N$ values
giving the user coordinates of a point to be included.

\item [\label{KEY:POI}POINT] - POINT is a synonym for PIXEL.

\item [\label{KEY:POL}POLYGON] - A 2-dimensional polygonal area. The argument
list should contain an even number of values; each pair giving the
user coordinates of a vertex of the polygon. These vertices are joined
together in the order given to form the polygon. The last vertex is
joined to the first to close the polygon. This keyword can only be used
in 2-dimensional ARD descriptions. Note, the edges of a polygon are
\emph{geodesics} within the user coordinate Frame. So, for instance, if user
coordinates are RA and DEC then the edges of a polygon will correspond to
great circles on the sky.

\item [\label{KEY:REC}RECT] - A rectangular box with sides parallel to the
user coordinate axes. The argument list should contain $2*N$ values;
each set of $N$ values giving the coordinates of a pair of diagonally
opposite corners. It may sometimes be more convenient to use the BOX
keyword which specifies a rectangular box in terms of its centre and
dimensions.

\item [\label{KEY:ROT}ROTBOX] - A rotated box. The argument list should
contain 5 values; the first pair give the coordinates of the box centre,
the second pair give the lengths of the two sides, and the fifth value
gives the angle (in degrees) from the first axis of the user coordinate system
to the first side of the box (positive rotation is from the first to
the second user axis). This keyword can only be used in 2-dimensional ARD
Note, the
edges of a rotated box are \emph{geodesics} within the user coordinate
Frame. So, for instance, if user coordinates are RA and DEC then the
edges of a rotated box will correspond to great circles on the sky.

\item [\label{KEY:ROW}ROW] - A set of lines parallel to the first user axis.
The argument list can contain any number of values (one for each of the
lines). Each argument value $Y$ specifies that the corresponding line
should pass through the position $(0,Y)$. This keyword can only be used
in 2-dimensional ARD descriptions.

\item [\label{KEY:WHO}WHOLE] - This keyword selects all pixels in the mask. It
has no argument list.

\end{description}

\section{\label{SEC:OPER}\xlabel{ARDOperators}Operators}
Operators are fields within an ARD description which specify an operation to
perform on one or two keyword fields. They cannot be abbreviated, and the
leading and trailing dots must be included. The following operators are
supported (they are listed in order of decreasing precedence):

\begin{description}

\item [\label{OP:NOT}.NOT.] - Invert the region specified by the following keyword or
expression (i.e. included pixels become excluded, and excluded pixels become
included). A minus sign is recognised as a synonym for .NOT..

\item [\label{OP:AND}.AND.] - Take the intersection of the two regions. A pixel is included
only if it is within \emph{both} of the regions given on either side of the
.AND. field.

\item [\label{OP:OR}.OR.] - Take the union of the two regions. A pixel is included if it is
within \emph{either} of the regions given on either side of the .OR. field.

\item [\label{OP:XOR}.XOR.] - Take the exclusive OR of the two regions. A pixel is included if
it is within one, but not both, of the regions given on either side of the .XOR.
field.

\item [\label{OP:EQV}.EQV.] - Take the equivalence of the two regions. A pixel is included if
it is within \emph{both} of the regions given on either side of the .EQV. field,
or if it is within \emph{neither}.

\end{description}

.XOR. and .EQV. have equal precedence. Opening and closing parentheses
(``\verb+(+'' and ``\verb+)+'') can be used to bracket sub-expressions within
an ARD description.

\section{\label{SEC:STAT}\xlabel{ARDStatements}Statements}
Statements are fields within an ARD description which modify the way in
which \htmlref{keywords}{SEC:KEYW} are interpreted. They are followed by
an argument list giving various numerical or textual values. Statements can be
abbreviated to three characters. The following statements are currently
supported ($N$ represents the dimensionality of the ARD description):

\begin{description}

\item [\label{ST:DIM}DIMENSION( N )] - This establishes the number of
coordinates (N) required to describe a single point in the ARD description.
If no DIMENSION statement is found before the first keyword field, a value
of 2 is assumed for N. The dimensionality may not be changed after the first
keyword field, but multiple DIMENSION statements may be included (so long
as they all specify the same value for N) to improve readability, and to
allow the concatenation of multiple ARD descriptions which contain
compatible DIMENSION statements. Note, N gives the number of dimensions
in the user co-ordinate system; this may not necessaily be the saem as
the number of pixel axes in the mask array.

\item [\label{ST:COE}COEFFS( C1, C2, ... )] - \textbf{DEPRECATED. Use the COFRAME or WCS statement instead.} This establishes
a new linear mapping from user coordinates to application coordinates
replacing any previous mapping (see Section \ref{SEC:COORD}). The
statement must have $N*(N+1)$ arguments. If ($X_{1}$, $X_{2}$, $X_{3}$, ...,
$X_{N}$) are a set of user coordinates in $N$ dimensions, and ($Y_{1}$,
$Y_{2}$, $Y_{3}$, ..., $Y_{N}$) are the corresponding application coordinates,
then the argument list should contain a set of constants $C_{1}$ to
$C_{N*(N+1)}$, where:

\begin{eqnarray*}
Y_{1} & = & C_{1} + C_{2}.X_{1} + C_{3}.X_{2} + ... + C_{N+1}.X_{N} \\
Y_{2} & = & C_{N+2} + C_{N+3}.X_{1} + C_{N+4}.X_{2} + ... + C_{2.(N+1)}.X_{N} \\
 ....\\
Y_{N} & = & C_{N.N} + C_{N.(N+1)}.X_{1} + C_{N.(N+2)}.X_{2} + ... + C_{N.(N+1)}.X_{N}
\end{eqnarray*}

The mapping established replaces any previous mapping, and is used to transform
all following coordinates, until another mapping is established. The default
mapping results in user coordinates being identical with application
coordinates. The \htmlref{OFFSET}{ST:OFF}, \htmlref{SCALE}{ST:SCALE}, \htmlref{TWIST}{ST:TWI} and \htmlref{STRETCH}{ST:STR} statements allow complex
mappings to be created without the use of COEFF statement in certain cases.

\item [\label{ST:COFRAME}COFRAME(DOMAIN,...)] - Specifies the user
coordinate system (\emph{i.e.} the coordinate system in which positions
are supplied within the remainder of the ARD description). The first
argument is the Domain of the coordinate system. There are several
special values that causes specialised AST objects to be created to
descibe specific forms of coordinate systems:

\begin{itemize}
\item ``SKY'': If the ARD description is 2-dimensional, an AST SkyFrame will
be created.
\item ``TIME'': If the ARD description is 1-dimensional, an AST TimeFrame will
be created.
\item ``SPECTRUM'': If the ARD description is 1-dimensional, an AST SpecFrame
will be created.
\item ``DSBSPECTRUM'': If the ARD description is 1-dimensional, an AST DSBSpecFrame
will be created.
\end{itemize}

Any other Domain value will cause a simple AST Frame to be created
instead. Any subsequent arguments should be of the form \texttt{
<keyword>=<value>} where \texttt{ <keyword>} is the name of an AST attribute
and \texttt{ <value>} is the value to assign to the attribute.

\item [\label{ST:OFF}OFFSET( X, Y, Z, ... )] - \textbf{DEPRECATED. Use the COFRAME or WCS statement instead.} This modifies the current mapping
from user coordinates to application coordinates so that the origin of the
user coordinate system is moved by the given offsets in application
coordinates. The initial position for the origin of user coordinates is
(0,0,0,..). In a 2-dimensional ARD description, the first statement OFFSET(10,15)
would put the origin at (10,15) in the application coordinates system. A second
statement OFFSET(2,3) would move it to (12,18). The statement must have $N$
arguments.

\item [\label{ST:SCA}SCALE( F )] - \textbf{DEPRECATED. Use the COFRAME or WCS statement instead.} This modifies the current mapping from user coordinates to
application coordinates so that the user coordinate system is magnified by the
given factor F along all axes. The magnification is centred on the origin of the
application coordinate system.

\item [\label{ST:STR}STRETCH( F1, F2, F3, ... )] - \textbf{DEPRECATED. Use the COFRAME or WCS statement instead.} This modifies the current mapping from user
coordinates to application coordinates so that the user coordinate system is
magnified by the given factor $F_{i}$ along axis $i$. Unlike the SCALE
statement, the magnifications are centred on the origin of the \emph{user}
coordinate system (i.e. the position of the origin of the user coordinate
system within the application coordinate system is not changed by this
statement). The statement must have $N$ arguments.

\item [\label{ST:TWI}TWIST( T )] - \textbf{DEPRECATED. Use the COFRAME or WCS statement instead.} This statement modifies the current mapping from user
coordinates to application coordinates so that the user coordinate system is
rotated by an angle T (in degrees). The rotation is about the origin of the
application coordinate system. If the ARD description has more than 2
dimensions, then the rotation takes place in the X-Y plane. Rotation from the X
axis to the Y axis is positive. ``TWIST'' is used rather than the more obvious
``ROTATE'' in order to avoid a name clash with the keyword
\htmlref{ROTBOX}{KEY:ROT}.

\item [\label{ST:WCS}WCS(...)] - Specifies an AST FrameSet in which the
current Frame is the user coordinate system (\emph{i.e.} the coordinate
system in which positions are supplied within the remainder of the ARD
description). The ``argument list'' should be a textual dump of an AST
FrameSet as produced by the AST Channel class (\emph{e.g.} using the
AST\_SHOW routine). Each line of the dump should be stored as a separate
GRP element in the supplied ARD expression - the simplest way to do this
is probably to supply the ARD description within a text file, and put
each line of the dump on a separate line in the file:

\small
\begin{terminalv}
   WCS(<!!
       Begin FrameSet
       IsA Frame
       Nframe = 6
       ...
       ...
       End FrameSet
   !!>)
\end{terminalv}
\normalsize

The \verb+<!!+ and \verb+!!>+ strings tell GRP to treat the enclosed text as
verbatim text. That is, any GRP control characters found within the
body of the FrameSet dump are treated as literal characters.

\end{description}

\section{Compiling and Linking}

To compile and link a UNIX ADAM application with the ARD package, the following
commands should be used (see \xref{SUN/144}{sun144}{}):

\small
\verb#      % alink adamprog.f -L/star/lib# `\verb#ard_link_adam#`
\normalsize

(note the use of \emph{opening} apostrophes (`) rather than
closing apostrophe (') ). To compile and link a stand-alone UNIX application with
the ARD package, the following commands should be used:

\small
\verb#      % f77 prog.f -o prog -L/star/lib# `\verb#ard_link#`
\normalsize

This produces an executable image called \verb+prog+.

The ADAM and stand-alone versions of the ARD\_ system differ, in that the
stand-alone version does not contain the routine \htmlref{ARD\_GROUP}{ARD_GROUP}.

\appendix
\section{Alphabetical List of Routines}

% List of routines:
% =================

\noteroutine{ARD\_GROUP}{( PARAM, IGRP1, IGRP2, STATUS )}
            {Obtain an ARD description from the environment}
\noteroutine{ARD\_GRPEX}{( DESC, IGRP1, IGRP2, FLAG, STATUS )}
            {Store an explicitly supplied ARD description in a GRP group}
\noteroutine{ARD\_GTWCS}{( IGRP, NDIM, IWCS, STATUS )}
            {Return a FrameSet connecting pixel and user co-ordinates}
\noteroutine{ARD\_PLOT}{( IGRP, IPLOT, GBOX, REGVAL, STATUS )}
            {Draw the outline of an ARD description on a graphics device}
\noteroutine{ARD\_PTWCS}{( IWCS, IGRP, STATUS )}
            {Construct an ARD WCS statement and append it to a GRP group}
\noteroutine{ARD\_WCS}{( IWCS, DOMAIN, STATUS )}
            {Specify WCS information to be used in future calls to ARD\_WORK}
\noteroutine{ARD\_WORK}{( IGRP, NDIM, LBND, UBND, TRCOEF, CONCAT, REGVAL,
             MASK, LBNDI, UBNDI, LBNDE, UBNDE, STATUS )}
            {Create a pixel mask from an ARD description}

\newpage
\section{\label{APP:SPEC}Routine Descriptions}


\begin{small}

\sstroutine{
   ARD\_GROUP
}{
   Obtain an ARD description from the environment
}{
   \sstdescription{
      An ARD description is obtained from the environment using the
      supplied parameter name and stored in a group identified by the
      returned value of IGRP2. If the last character in the ARD
      description is a minus sign (\texttt{ "}-\texttt{ "}) then the parameter value is
      then cancelled and further ARD descriptions are obtained and
      appended to the returned group. This process continues until an
      ARD description is supplied which does not end with a minus
      sign, or a null value is supplied.

      If a GRP identifier for an existing group is supplied for IGRP1
      then the group will be used as the basis for any modification
      elements contained within the ARD descriptions obtained from the
      environment. No checks are made for modification elements if the
      symbolic constant GRP\_\_NOID is supplied for IGRP1.
   }
   \sstinvocation{
      CALL ARD\_GROUP( PARAM, IGRP1, IGRP2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The parameter name.
      }
      \sstsubsection{
         IGRP1 = INTEGER (Given)
      }{
         GRP identifier for a group to be used as a basis for
         modification elements.
      }
      \sstsubsection{
         IGRP2 = INTEGER (Returned)
      }{
         GRP identifier for the created group.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         No checks are made on the syntax of the ARD description.

         \sstitem
         The returned GRP identifier (IGRP2) should be deleted using
         GRP\_DELET when it is no longer needed.

         \sstitem
         If an error occurs either before or during this routine then
         IGRP2 will be returned holding the symbolic value GRP\_\_NOID
         (defined in include file GRP\_PAR).

         \sstitem
         An error is returned if the first value obtained for the
         parameter is a null value.
      }
   }
}
\sstroutine{
   ARD\_GRPEX
}{
   Store an ARD description in a GRP group
}{
   \sstdescription{
      The supplied ARD description is appended to the group
      identified by IGRP2. If the symbolic constant GRP\_\_NOID is
      supplied for IGRP2 then a new group is first created and its
      identifier is returned in IGRP2.

      If a GRP identifier for an existing group is supplied for IGRP1
      then the group will be used as the basis for any modification
      elements contained within the ARD description. No checks are
      made for modification elements if the symbolic constant GRP\_\_NOID
      is supplied for IGRP1.
   }
   \sstinvocation{
      CALL ARD\_GRPEX( DESC, IGRP1, IGRP2, FLAG, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DESC = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The ARD description.
      }
      \sstsubsection{
         IGRP1 = INTEGER (Given)
      }{
         GRP identifier for a group to be used as a basis for
         modification elements.
      }
      \sstsubsection{
         IGRP2 = INTEGER (Given and Returned)
      }{
         GRP identifier for the group holding the ARD description.
      }
      \sstsubsection{
         FLAG = LOGICAL (Returned)
      }{
         Returned .TRUE. if the last non-blank character in the
         supplied ARD description is a minus sign (\texttt{ "}-\texttt{ "}).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         No checks are made on the syntax of the ARD description.

         \sstitem
         The returned GRP identifier (IGRP2) should be deleted using
         GRP\_DELET when it is no longer needed.

         \sstitem
         The symbolic constant GRP\_\_NOID is defined in the include file
         GRP\_PAR.
      }
   }
}
\sstroutine{
   ARD\_GTWCS
}{
   Return a FrameSet connecting pixel and user co-ordinates
}{
   \sstdescription{
      This routine returns an AST pointer for a FrameSet describing the
      relationship between the user co-ordinate system used by the
      supplied ARD description, and the pixel coordinate Frame of the
      FrameSet stored by the most recent call to ARD\_WCS.
   }
   \sstinvocation{
      CALL ARD\_GTWCS( IGRP, NDIM, IWCS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         A GRP identifier for the group holding the ARD description.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of pixl axes in the mask array.
      }
      \sstsubsection{
         IWCS = INTEGER (Returned)
      }{
         An AST pointer to the FrameSet. The base Frame will be the pixel
         coordinate Frame in the FrameSet supplied via the most recent
         call to ARD\_WCS. The current Frame will be the user co-ordinate
         system specified by the supplied ARD description.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         An error is reported if the dimensionality of the ARD
         description is different to that of the mask array (as specified
         by argument NDIM).
      }
   }
}
\sstroutine{
   ARD\_PLOT
}{
   Plot the boundary of an ARD description
}{
   \sstdescription{
      This routine draws a curve marking the boundary of the ARD
      description supplied within group IGRP. It can also draw a boundary
      round a given sub-region by supplying a positive value for REGVAL.
      The ARD description must be 2-dimensional.
   }
   \sstinvocation{
      CALL ARD\_PLOT( IGRP, IPLOT, GBOX, REGVAL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         A GRP identifier for the group holding the 2-dimensional ARD
         description.
      }
      \sstsubsection{
         IPLOT = INTEGER (Given)
      }{
         An AST pointer to a Plot which will be used to draw the boundary.
         The Plot and the ARD description will be aligned in a suitable
         common coordinate Frame, present in both the Plot and the WCS
         FrameSet implied by the ARD description. If no such common Frame
         is available, an error is reported.
      }
      \sstsubsection{
         GBOX( 4 ) = REAL (Given)
      }{
         An array giving the position and extent of the plotting area
         (on the plotting surface of the underlying graphics system)
         in which graphical output is to appear. This must be specified
         in the base (i.e. GRAPHICS) Frame of the supplied Plot. This can
         be smaller than the area covered by the supplied Plot, in which
         case the graphics will be truncated.

         The first pair of values should give the coordinates of the
         bottom left corner of the plotting area and the second pair
         should give the coordinates of the top right corner. The
         coordinate on the horizontal axis should be given first in
         each pair.
      }
      \sstsubsection{
         REGVAL = INTEGER (Given and Returned)
      }{
         The index of the region within the ARD description to be outlined.
         If the value zero is supplied, the entire ARD description is
         outlined. If a positive value is supplied, then only the region
         with the specified index is outlined. If a negative value is
         supplied, then regions with indices greater than or equal to the
         absolute value are outlined. If the supplied value is not zero,
         then REGVAL is modified on return to hold one more than the largest
         value used to represent any of the keywords in the ARD description.
         The supplied value is left unchanged if it zero.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   ARD\_PTWCS
}{
   Construct an ARD WCS statement and append it to a GRP group
}{
   \sstdescription{
      This routine creates a WCS statement describing the supplied
      FrameSet, and appends the statement to the end of the supplied GRP
      group.
   }
   \sstinvocation{
      CALL ARD\_PTWCS( IWCS, IGRP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         An AST pointer to a FrameSet.
      }
      \sstsubsection{
         IGRP = INTEGER (Given and Returned)
      }{
         A GRP group identifier. If GRP\_\_NOID is supplied, a new group is
         created and its identifier returned.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   ARD\_WCS
}{
   Specify WCS information to be used in future calls to ARD\_WORK
}{
   \sstdescription{
      This routine can be used to specify the coordinate systems
      which can be used in subsequent calls to ARD\_WORK. ARD descriptions
      passed to subsequent calls to ARD\_WORK can include positions in any
      of the Frames included in the supplied FrameSet. The ARD description
      should include suitable COFRAME or WCS statements to indicate which
      coordinate system is being used. If no COFRAME or WCS statements
      are included in the ARD description, then it is assumed that
      positions within the ARD description are given in the current Frame
      of the supplied FrameSet, IWCS.

      If this routine is not called prior to ARD\_WORK (or if it is
      called with IWCS set AST\_\_NULL), then the ARD description must
      provide (either directly or through a WCS statement) positions in
      pixel coordinates.

      The FrameSet pointer supplied is simply stored by this routine.
      If any changes are subsequently made to the FrameSet by the calling
      routine, then these changes will be visible within ARD\_WORK. In
      particular, if the calling routine annuls the FrameSet pointer,
      then ARD\_WORK will fail.

      The supplied FrameSet will be used by all subsequent calls to ARD\_WORK
      until a new FrameSet is specified by calling ARD\_WCS again.
   }
   \sstinvocation{
      CALL ARD\_WCS( IWCS, DOMAIN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         An AST pointer to a FrameSet, or AST\_\_NULL.
      }
      \sstsubsection{
         DOMAIN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The Domain name corresponding to pixel coordinates within the
         mask array passed to routine ARD\_WORK. If a blank value is
         supplied, \texttt{ "}PIXEL\texttt{ "} will be used. The IWCS FrameSet (if supplied)
         must contain a Frame with this Domain. If the supplied string is
         longer than 40 characters, the trailing characters are ignored.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   ARD\_WORK
}{
   Convert an ARD description into a pixel mask
}{
   \sstdescription{
      This routine returns an array which contains a positive value
      for all pixels within the areas specified by a given ARD
      description, and zero for all other pixels.
   }
   \sstinvocation{
      CALL ARD\_WORK( IGRP, NDIM, LBND, UBND, TRCOEF, CONCAT, REGVAL,
                     MASK, LBNDI, UBNDI, LBNDE, UBNDE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         A GRP identifier for the group holding the ARD description.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of pixel axes in the mask array.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Given)
      }{
         The lower pixel index bounds of the mask array.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         The upper pixel index bounds of the mask array.
      }
      \sstsubsection{
         TRCOEF( 0:NDIM, NDIM ) = REAL (Given)
      }{
         The coefficients of the mapping from application coordinates
         (i.e. default user coordinates) to pixel coordinates. If the
         first element is equal to VAL\_\_BADR, then a unit mapping is used.
         This argument is ignored if a call to ARD\_WCS has already been
         made to establish WCS Information.
      }
      \sstsubsection{
         CONCAT = LOGICAL (Given)
      }{
         If .TRUE., then an INPUT keyword is inserted at the start of
         the ARD description so long as the ARD description does not
         already contain any INPUT keywords. If .FALSE., the ARD
         description is left as supplied.
      }
      \sstsubsection{
         REGVAL = INTEGER (Given and Returned)
      }{
         A positive integer to use to represent the first keyword in
         the ARD description (excluding INPUT keywords). An error is
         reported if the value 1 is supplied. If the supplied value is
         negative or zero, then the value used is one greater than the
         maximum pixel value supplied in MASK (except that 2 is used if
         the maximum mask value is 1 or less). On return, REGVAL holds
         one more than the largest value used to represent any of the
         keywords in the ARD description.
      }
      \sstsubsection{
         MASK( $*$ ) = INTEGER (Given and Returned)
      }{
         The mask array. Any negative values in the supplied array are
         treated as zero.
      }
      \sstsubsection{
         LBNDI( NDIM ) = INTEGER (Returned)
      }{
         The lower pixel bounds of a box which encompasses all internal
         pixels. If there are no internal pixels in the returned mask,
         each lower bound is returned greater than the corresponding
         upper bound.
      }
      \sstsubsection{
         UBNDI( NDIM ) = INTEGER (Returned)
      }{
         The upper pixel bounds of a box which encompasses all internal
         pixels.
      }
      \sstsubsection{
         LBNDE( NDIM ) = INTEGER (Returned)
      }{
         The lower pixel bounds of a box which encompasses all external
         pixels. If there are no external pixels in the returned mask,
         each lower bound is returned greater than the corresponding
         upper bound.
      }
      \sstsubsection{
         UBNDE( NDIM ) = INTEGER (Returned)
      }{
         The upper pixel bounds of a box which encompasses all external
         pixels.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}

\end{small}


\section{Acknowledgements}

The current ARD system arose out of previous system produced by Peter Draper. I
am grateful to the following people for useful suggestions: Peter Draper,
Malcolm Currie, Richard Saxton, Rodney Warren-Smith and Grant Privet.

\section{Changes Introduced in Version 2.0}

\begin{itemize}

\item Routines ARD\_PLOT has been added to allow border of an ARD
description to be drawn on a graphics device.

\item Routines ARD\_WCS and ARD\_PTWCS have been added to support the use
of WCS within ARD description.

\item The WCS and COFRAME statements have been introduced.

\item The COEFFS, STRETCH, OFFSET, SCALE and TWIST statements have been
deprecated in favour of the new WCS and COFRAME statements.

\end{itemize}

\section{Changes Introduced in Version 2.1}

\begin{itemize}

\item The COFRAME statement has been extended to include specific support
for TimeFrame, SpecFrame and DSBSpecFrame co-ordinate systems.

\item The user coordinate system used to describe positions and shapes
within an ARD expression can now refer to a sub-space of the axes defined
in the application WCS FrameSet. For instance, if the application is an
(RA,Dec,freq) cube, an ARD expression can be used that refers only to the
freq axis, in which case the same frequency region will be masked in all
(ra,dec) planes.

\end{itemize}

\section{Changes Introduced in Version 2.2}

\begin{itemize}

\item A new routine ARD\_GTWCS has been added that returns a FrameSet
    connecting PIXEL coordinates and user coordinates within a specified
    ARD description.

\end{itemize}

\end{document}
