#if HAVE_CONFIG_H
#include "config.h"
#endif
      SUBROUTINE ARD1_EVAL( INDEX1, NDIM, LBND, UBND, OPCSIZ, OPNSIZ,
     :                      STKSIZ, MSKSIZ, OPCODE, OPRNDS, STACK,
     :                      LEXSTK, UEXSTK, LINSTK, UINSTK, MASK,
     :                      LBEXT, UBEXT, LBINT, UBINT, INDEX, STATUS )
*+
*  Name:
*     ARD1_EVAL

*  Purpose:
*     Evaluate an ARD expression

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL ARD1_EVAL( INDEX1, NDIM, LBND, UBND, OPCSIZ, OPNSIZ, STKSIZ,
*                     MSKSIZ, OPCODE, OPRNDS, STACK, LEXSTK, UEXSTK,
*                     LINSTK, UINSTK, MASK, LBEXT, UBEXT, LBINT, UBINT,
*                     INDEX, STATUS )

*  Description:
*     The instructions which must be performed in order to evaluate the
*     ARD expression are supplied in OPCODE (together within any
*     argument values needed by the instructions) in the order in which
*     they are to be executed. The results of evaluating the ARD
*     expression at each pixel are returned in MASK.
*
*     Instructions usually operate on arrays held in a First In, Last
*     Out (FILO) stack. The array on the top of the stack is the
*     current working array, and lower entries in the stack hold
*     intermediate results.
*
*     Each array on the stack has two bounding boxes associated with
*     it; the exterior bounding box is the smallest box which contains
*     all exterior pixels (i.e.  array elements with the value 0 or
*     less ) the interior bounding box is the smallest box which
*     contains all interior pixels (i.e.  array elements with a value
*     greater than 0). Bounding boxes can be "infinite" in which
*     case the lower bound on the first axis is set to VAL__MAXI, they
*     can also be null (i.e. zero size) in which case the lower bound
*     on the first axis is set to VAL__MINI. The bounding boxes for
*     each array on the stack are stored on separate FILO stacks at the
*     same index as the array, and are popped and pushed in the same
*     way as the arrays on the main stack.
*
*     The bounding boxes of the returned MASK are found and returned.

*  Arguments:
*     INDEX1 = INTEGER (Given)
*        The value to assign to pixels selected by the first keyword in
*        the ARD description (excluding INPUT keywords).
*     NDIM = INTEGER (Given)
*        The no. of pixel axes.
*     LBND( NDIM ) = INTEGER (Given)
*        The lower pixel index bounds of the mask and the arrays on the
*        stack.
*     UBND( NDIM ) = INTEGER (Given)
*        The upper pixel index bounds of the mask and the arrays on the
*        stack.
*     OPCSIZ = INTEGER (Given)
*        The size of the OPCODE array.
*     OPNSIZ = INTEGER (Given)
*        The size of the OPRNDS array.
*     STKSIZ = INTEGER (Given)
*        The size of the various stack arrays. This must be sufficient
*        to allow the entire expression to be evaluated. ARD1_ALTRP
*        finds the required size. An error is reported if the stacks
*        over-flow.
*     MSKSIZ = INTEGER (Given)
*        The total number of pixels in the mask and each array on the
*        stack.
*     OPCODE( OPCSIZ ) = INTEGER (Given)
*        The list of instruction codes and associated argument values.
*        Each instruction code is followed immediately by any required
*        arguments. The array is generated by ARD1_ALTRP and should
*        commence with a "Load Supplied Mask" instruction, and end with
*        an "End Expression" instruction.
*     OPRNDS( OPNSIZ ) = DOUBLE PRECISION (Given)
*        A list of values describing each keyword field specified
*        within the ARD description. Each "Load Keyword Region"
*        instruction in OPCODE is followed by a single argument which
*        is a pointer into the OPRNDS array. The element of OPRNDS
*        pointed to in this way describe the region (see ARD1_LKR for
*        details).
*     STACK( MSKSIZ, STKSIZ ) = INTEGER (Given and Returned)
*        Workspace to hold the main array stack used to evaluate the ARD
*        expression.
*     LEXSTK( NDIM, STKSIZ ) = INTEGER (Given and Returned)
*        Workspace to hold the lower bounds of the exterior bounding
*        box for each array in STACK.
*     UEXSTK( NDIM, STKSIZ ) = INTEGER (Given and Returned)
*        Workspace to hold the upper bounds of the exterior bounding
*        box for each array in STACK.
*     LINSTK( NDIM, STKSIZ ) = INTEGER (Given and Returned)
*        Workspace to hold the lower bounds of the interior bounding
*        box for each array in STACK.
*     UINSTK( NDIM, STKSIZ ) = INTEGER (Given and Returned)
*        Workspace to hold the upper bounds of the interior bounding
*        box for each array in STACK.
*     MASK( MSKSIZ ) = INTEGER (Given and Returned)
*        The mask. On entry, holds the values to be used by any INPUT
*        keywords in the ARD description. On exit, contains the results
*        of evaluating the ARD expression at each pixel.  Excluded
*        pixels are assigned the value zero, and included pixels are
*        assigned a positive value.
*     LBEXT( NDIM ) = INTEGER (Returned)
*        The lower bounds of the exterior bounding box for the returned
*        values in MASK.
*     UBEXT( NDIM ) = INTEGER (Returned)
*        The upper bounds of the exterior bounding box for the returned
*        values in MASK.
*     LBINT( NDIM ) = INTEGER (Returned)
*        The lower bounds of the interior bounding box for the returned
*        values in MASK.
*     UBINT( NDIM ) = INTEGER (Returned)
*        The upper bounds of the interior bounding box for the returned
*        values in MASK.
*     INDEX = INTEGER (Returned)
*        Returned holding one more than the largest value assigned to
*        any of the keywords in the ARD description.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Copyright:
*     Copyright (C) 1994 Science & Engineering Research Council.
*     Copyright (C) 2001, 2004 Central Laboratory of the Research Councils.
*     Copyright (C) 2005 Particle Physics & Astronomy Research Council.
*     All Rights Reserved.

*  Licence:
*     This program is free software; you can redistribute it and/or
*     modify it under the terms of the GNU General Public License as
*     published by the Free Software Foundation; either version 2 of
*     the License, or (at your option) any later version.
*
*     This program is distributed in the hope that it will be
*     useful,but WITHOUT ANY WARRANTY; without even the implied
*     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
*     PURPOSE. See the GNU General Public License for more details.
*
*     You should have received a copy of the GNU General Public License
*     along with this program; if not, write to the Free Software
*     Foundation, Inc., 59 Temple Place,Suite 330, Boston, MA
*     02111-1307, USA

*  Authors:
*     DSB: David Berry (STARLINK)
*     PWD: Peter W. Draper (JAC, Durham University)
*     {enter_new_authors_here}

*  History:
*     1-MAR-1994 (DSB):
*        Original version.
*     18-JUL-2001 (DSB):
*        Modified for ARD version 2.0.
*     31-AUG-2004 (TIMJ):
*        Register the %LOC pointer with CNF prior to use..
*     29-JUL-2005 (PWD):
*        Make use of %LOC/LOC configurable.
*     {enter_changes_here}

*  Bugs:
*     {note_any_bugs_here}

*-

*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants
      INCLUDE 'ARD_CONST'        ! ARD_ private constants
      INCLUDE 'ARD_ERR'          ! ARD_ error constants
      INCLUDE 'PRM_PAR'          ! VAL_ constants
      INCLUDE 'CNF_PAR'          ! CNF_PREG

*  Global Variables:
      INCLUDE 'ARD_COM'          ! ARD_ common blocks
*        CNM_DSTK( ARD__NINST ) = INTEGER (Read)
*           The change in size of the stack as a result of executing
*           each instruction.
*        CMN_INSTR( ARD__NINST ) = CHARACTER * ( * ) (Read)
*           A string describing each instruction.

*  Arguments Given:
      INTEGER INDEX1
      INTEGER NDIM
      INTEGER LBND( NDIM )
      INTEGER UBND( NDIM )
      INTEGER OPCSIZ
      INTEGER OPNSIZ
      INTEGER STKSIZ
      INTEGER MSKSIZ
      INTEGER OPCODE( OPCSIZ )
      DOUBLE PRECISION OPRNDS( OPNSIZ )

*  Arguments Given and Returned:
      INTEGER STACK( MSKSIZ, STKSIZ )
      INTEGER LEXSTK( NDIM, STKSIZ )
      INTEGER UEXSTK( NDIM, STKSIZ )
      INTEGER LINSTK( NDIM, STKSIZ )
      INTEGER UINSTK( NDIM, STKSIZ )
      INTEGER MASK( MSKSIZ )

*  Arguments Returned:
      INTEGER LBEXT( NDIM )
      INTEGER UBEXT( NDIM )
      INTEGER LBINT( NDIM )
      INTEGER UBINT( NDIM )
      INTEGER INDEX

*  Status:
      INTEGER STATUS             ! Global status

*  External References:
      EXTERNAL ARD1_INIT         ! Initialise ARD common blocks

*  Local Variables:
      INTEGER
     :        CODE,              ! Current instruction code
     :        I,                 ! Loop count
     :        IOP,               ! Index of current value in OPCODE
     :        IOPND,             ! Pointer into OPRNDS array
     :        IPNTR,             ! Pointer from STACK subsection
     :        LEX0( ARD__MXDIM ),! Supplied mask bounding box low limits
     :        LIN0( ARD__MXDIM ),! Supplied mask bounding box low limits
     :        NEWTOS,            ! TOS after executing the instruction
     :        RINDEX,            ! Current region index
     :        TOS,               ! Index of array at top-of-stack
     :        UEX0( ARD__MXDIM ),! Supplied mask bounding box hi. limits
     :        UIN0( ARD__MXDIM ) ! Supplied mask bounding box hi. limits

      LOGICAL
     :        ISNEWREG,          ! Was the pointer registered?
     :        LOADED             ! Has the supplied mask been loaded?



*  Check inherited global status.
      IF ( STATUS .NE. SAI__OK ) RETURN

*  Initialise all the bounding boxes on the stack to be of "infinite"
*  size.
      DO I = 1, STKSIZ
         LEXSTK( 1, I ) = VAL__MAXI
         LINSTK( 1, I ) = VAL__MAXI
      END DO

*  Initialise a flag to indicate that the conetents of the supplied
*  mask have not yet been loaded onto the stack.
      LOADED = .FALSE.

*  Initialise the maximum region index used so far.
      INDEX = 0

*  Initialise the index of the top of the stack.
      TOS = 0

*  Initialise the index of the current instruction code in OPCODE.
      IOP = 0

*  Loop round the instructions supplied in OPCODE until an "End
*  Expression" instruction has been executed, or an error occurs.
      CODE = ARD__NUL

      DO WHILE( IOP .LT. OPCSIZ .AND. CODE .NE. ARD__END .AND.
     :          STATUS .EQ. SAI__OK )
         IOP = IOP + 1

*  Get the next instruction code.
         CODE = OPCODE( IOP )

*  Check for stack under-flow. Note, the "End Expression" instruction
*  has a value of zero for CMN_DSTK (rather than -1 which might be
*  expected) to prevent the following check from failing at the end of
*  the expression.
         IF( TOS + CMN_DSTK( CODE ) .LE. 0 ) THEN
            STATUS = ARD__INTER
            CALL ERR_REP( 'ARD1_EVAL_ERR1', 'Stack under-flow in '//
     :                    'ARD1_EVAL (programming error).', STATUS )
            GO TO 999
         END IF

*  Check for stack over-flow.
         IF( TOS + CMN_DSTK( CODE ) .GT. STKSIZ ) THEN
            STATUS = ARD__INTER
            CALL ERR_REP( 'ARD1_EVAL_ERR2', 'Stack over-flow in '//
     :                    'ARD1_EVAL (programming error).', STATUS )
            GO TO 999
         END IF

*  Process AND instructions...
         IF( CODE .EQ. ARD__AND ) THEN
            NEWTOS = TOS - 1
            CALL ARD1_AND( NDIM, LBND, UBND, MSKSIZ,
     :                     STACK( 1, TOS ),
     :                     LEXSTK( 1, TOS ), UEXSTK( 1, TOS ),
     :                     LINSTK( 1, TOS ), UINSTK( 1, TOS ),
     :                     STACK( 1, NEWTOS ),
     :                     LEXSTK( 1, NEWTOS ), UEXSTK( 1, NEWTOS ),
     :                     LINSTK( 1, NEWTOS ), UINSTK( 1, NEWTOS ),
     :                     STATUS )
            TOS = NEWTOS

*  Process OR instructions...
         ELSE IF( CODE .EQ. ARD__OR ) THEN
            NEWTOS = TOS - 1
            CALL ARD1_OR( NDIM, LBND, UBND, MSKSIZ,
     :                    STACK( 1, TOS ),
     :                    LEXSTK( 1, TOS ), UEXSTK( 1, TOS ),
     :                    LINSTK( 1, TOS ), UINSTK( 1, TOS ),
     :                    STACK( 1, NEWTOS ),
     :                    LEXSTK( 1, NEWTOS ), UEXSTK( 1, NEWTOS ),
     :                    LINSTK( 1, NEWTOS ), UINSTK( 1, NEWTOS ),
     :                    STATUS )
            TOS = NEWTOS

*  Process XOR instructions...
         ELSE IF( CODE .EQ. ARD__XOR ) THEN
            NEWTOS = TOS - 1
            CALL ARD1_XOR( NDIM, LBND, UBND, MSKSIZ,
     :                     STACK( 1, TOS ),
     :                     LEXSTK( 1, TOS ), UEXSTK( 1, TOS ),
     :                     LINSTK( 1, TOS ), UINSTK( 1, TOS ),
     :                     STACK( 1, NEWTOS ),
     :                     LEXSTK( 1, NEWTOS ), UEXSTK( 1, NEWTOS ),
     :                     LINSTK( 1, NEWTOS ), UINSTK( 1, NEWTOS ),
     :                     STATUS )
            TOS = NEWTOS

*  Process EQV instructions...
         ELSE IF( CODE .EQ. ARD__EQV ) THEN
            NEWTOS = TOS - 1
            CALL ARD1_EQV( NDIM, LBND, UBND, MSKSIZ,
     :                     STACK( 1, TOS ),
     :                     LEXSTK( 1, TOS ), UEXSTK( 1, TOS ),
     :                     LINSTK( 1, TOS ), UINSTK( 1, TOS ),
     :                     STACK( 1, NEWTOS ),
     :                     LEXSTK( 1, NEWTOS ), UEXSTK( 1, NEWTOS ),
     :                     LINSTK( 1, NEWTOS ), UINSTK( 1, NEWTOS ),
     :                     STATUS )
            TOS = NEWTOS

*  Process NOT instructions...
         ELSE IF( CODE .EQ. ARD__NOT ) THEN
            CALL ARD1_NOT( NDIM, LBND, UBND, MSKSIZ,
     :                     STACK( 1, TOS ),
     :                     LEXSTK( 1, TOS ), UEXSTK( 1, TOS ),
     :                     LINSTK( 1, TOS ), UINSTK( 1, TOS ),
     :                     STATUS )

*  Ignore "close brackets"  instructions.
         ELSE IF( CODE .EQ. ARD__CLS ) THEN

*  Ignore "open brackets" instructions.
         ELSE IF( CODE .EQ. ARD__OPN ) THEN

*  Process "end expression" instructions. Use the top-of-stack to
*  create the returned arrays.
         ELSE IF( CODE .EQ. ARD__END ) THEN

*  Return the bounds of the interior and exterior bounding boxes.
            DO I = 1, NDIM
               LBINT( I ) = LINSTK( I, TOS )
               UBINT( I ) = UINSTK( I, TOS )
               LBEXT( I ) = LEXSTK( I, TOS )
               UBEXT( I ) = UEXSTK( I, TOS )
            END DO

*  Copy the top-of-stack array to the returned mask.
            DO I = 1, MSKSIZ
               MASK( I ) = STACK( I, TOS )
            END DO

*  Process "Load Supplied Mask" instructions...
         ELSE IF( CODE .EQ. ARD__LSM ) THEN

*  Report an error if this is not the first instruction.
            IF( IOP .NE. 1 ) THEN
               STATUS = ARD__INTER
               CALL MSG_SETI( 'IOP', IOP )
               CALL ERR_REP( 'ARD1_EVAL_ERR3', 'LSM instruction found'//
     :                       'at operation index ^IOP in '//
     :                       'ARD1_EVAL (programming error).', STATUS )
               GO TO 999
            END IF

*  Copy the supplied mask to the top-of-stack, and find the bounding
*  boxes describing the mask.
            TOS = TOS + 1
            CALL ARD1_LSM( NDIM, LBND, UBND, MSKSIZ, MASK, LOADED,
     :                     STACK( 1, TOS ), LEX0, UEX0, LIN0,
     :                     UIN0, STATUS )

*  Initialise the top of stack bounding boxes.
            DO I = 1, NDIM
               LEXSTK( I, TOS ) = LEX0( I )
               UEXSTK( I, TOS ) = UEX0( I )
               LINSTK( I, TOS ) = LIN0( I )
               UINSTK( I, TOS ) = UIN0( I )
            END DO

*  Process "Load Keyword Region" instructions...
         ELSE IF( CODE .EQ. ARD__LKR ) THEN

*  The value following the instruction code is a pointer into the
*  operand array at which information describing the keyword region to
*  be loaded is stored. Get the value of the pointer.
            IOP = IOP + 1
            IF( IOP .LE. OPCSIZ ) THEN
               IOPND = OPCODE( IOP )

*  Load the array described by the corresponding keyword onto the
*  top-of-stack.
               TOS = TOS + 1

*  First we need a pointer from the STACK variable. This code is 64bit
*  friendly, need to translate to an INTEGER and register with CNF
#if HAVE_PERCENTLOC
               IPNTR = CNF_PREG( %LOC( STACK( 1, TOS ) ), ISNEWREG )
#else
               IPNTR = CNF_PREG( LOC( STACK( 1, TOS ) ), ISNEWREG )
#endif
               IF (IPNTR .EQ. 0 .OR. CNF_PVAL(IPNTR) .EQ. 0) THEN
                  IF ( STATUS .EQ. SAI__OK ) THEN
                     STATUS = SAI__ERROR
                     CALL ERR_REP( 'ARD1_EVAL_ERR3B',
     :                    'Unable to register work pointer with CNF',
     :                    STATUS )
                     GO TO 999
                  END IF
               END IF

               CALL ARD1_LKR( INDEX1, NDIM, LBND, UBND, MSKSIZ, MASK,
     :                        OPNSIZ, IOPND, LEX0, UEX0, LIN0, UIN0,
     :                        OPRNDS, IPNTR,
     :                        LEXSTK( 1, TOS ), UEXSTK( 1, TOS ),
     :                        LINSTK( 1, TOS ), UINSTK( 1, TOS ),
     :                        LOADED, RINDEX, STATUS )

*  Release the %LOC pointer from CNF so that it can be re-used
               IF (ISNEWREG .AND. IPNTR .NE. 0) CALL CNF_UNREGP( IPNTR )

*  Update the maximum value assigned to a keyword.
               IF( RINDEX .GT. INDEX ) INDEX = RINDEX

*  Report an error if no argument for the LKR instruction was found.
            ELSE IF( STATUS .EQ. SAI__OK ) THEN
               STATUS = ARD__INTER
               CALL MSG_SETC( 'OP', CMN_INSTR( ARD__LKR ) )
               CALL ERR_REP( 'ARD1_EVAL_ERR4', 'No argument for ^OP '//
     :                       'instruction found in ARD1_EVAL '//
     :                       '(programming error).', STATUS )
               GO TO 999

            END IF

*  Ignore NULL instructions.
         ELSE IF( CODE .EQ. ARD__NUL ) THEN

*  Report an error if the instruction is not recognised.
         ELSE
            STATUS = ARD__INTER
            CALL MSG_SETI( 'CODE', CODE )
            CALL ERR_REP( 'ARD1_EVAL_ERR5', 'Illegal instruction code'//
     :                    ' ^CODE encountered in ARD1_EVAL '//
     :                    '(programming error).', STATUS )
            GO TO 999
         END IF

      END DO

*  Increment the INDEX value so that it refers to the first keyword in
*  any subsequent ARD description.
      INDEX = INDEX +1

*  Report an error if the instructions in OPCODE have been exhausted
*  but no "End Expression" instruction has been encountered.
      IF( CODE .NE. ARD__END .AND. STATUS .EQ. SAI__OK ) THEN
         STATUS = ARD__INTER

         CALL MSG_SETC( 'OP', CMN_INSTR( ARD__END ) )
         CALL ERR_REP( 'ARD1_EVAL_ERR6', 'No ^OP instruction found in'//
     :                 ' ARD1_EVAL (programming error).', STATUS )
      END IF

*  Jump to here when an error occurs.
 999  CONTINUE

      END
