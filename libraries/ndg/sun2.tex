\documentclass[twoside,11pt]{article}

% ? Specify used packages
% \usepackage{graphicx}        %  Use this one for final production.
% \usepackage[draft]{graphicx} %  Use this one for drafting.
% ? End of specify used packages

\pagestyle{myheadings}

% -----------------------------------------------------------------------------
% ? Document identification
% Fixed part
\newcommand{\stardoccategory}  {Starlink User Note}
\newcommand{\stardocinitials}  {SUN}
\newcommand{\stardocsource}    {sun\stardocnumber}
\newcommand{\stardoccopyright} 
{Copyright \copyright\ 2000 Council for the Central Laboratory of the Research Councils}

% Variable part - replace [xxx] as appropriate.
\newcommand{\stardocnumber}    {2.8}
\newcommand{\stardocauthors}   {D.S.\ Berry \\ M.B.\ Taylor}
\newcommand{\stardocdate}      {3rd March 2009}
\newcommand{\stardoctitle}     {NDG \\ [\latex{1ex}]
                                Routines for Accessing Groups of NDFs}
\newcommand{\stardocversion}   {Version 5.6}
\newcommand{\stardocmanual}    {Programmer's Manual}
\newcommand{\stardocabstract}  {
This document describes the routines provided within the NDG subroutine 
library for accessing groups of NDF data objects. 
}
% ? End of document identification
% -----------------------------------------------------------------------------

% +
%  Name:
%     sun.tex
%
%  Purpose:
%     Template for Starlink User Note (SUN) documents.
%     Refer to SUN/199
%
%  Authors:
%     AJC: A.J.Chipperfield (Starlink, RAL)
%     BLY: M.J.Bly (Starlink, RAL)
%     PWD: Peter W. Draper (Starlink, Durham University)
%
%  History:
%     17-JAN-1996 (AJC):
%        Original with hypertext macros, based on MDL plain originals.
%     16-JUN-1997 (BLY):
%        Adapted for LaTeX2e.
%        Added picture commands.
%     13-AUG-1998 (PWD):
%        Converted for use with LaTeX2HTML version 98.2 and
%        Star2HTML version 1.3.
%      1-FEB-2000 (AJC):
%        Add Copyright statement in LaTeX
%     {Add further history here}
%
% -

\newcommand{\stardocname}{\stardocinitials /\stardocnumber}
\markboth{\stardocname}{\stardocname}
\setlength{\textwidth}{160mm}
\setlength{\textheight}{230mm}
\setlength{\topmargin}{-2mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\setlength{\unitlength}{1mm}

% -----------------------------------------------------------------------------
%  Hypertext definitions.
%  ======================
%  These are used by the LaTeX2HTML translator in conjunction with star2html.

%  Comment.sty: version 2.0, 19 June 1992
%  Selectively in/exclude pieces of text.
%
%  Author
%    Victor Eijkhout                                      <eijkhout@cs.utk.edu>
%    Department of Computer Science
%    University Tennessee at Knoxville
%    104 Ayres Hall
%    Knoxville, TN 37996
%    USA

%  Do not remove the %begin{latexonly} and %end{latexonly} lines (used by 
%  LaTeX2HTML to signify text it shouldn't process).
%begin{latexonly}
\makeatletter
\def\makeinnocent#1{\catcode`#1=12 }
\def\csarg#1#2{\expandafter#1\csname#2\endcsname}

\def\ThrowAwayComment#1{\begingroup
    \def\CurrentComment{#1}%
    \let\do\makeinnocent \dospecials
    \makeinnocent\^^L% and whatever other special cases
    \endlinechar`\^^M \catcode`\^^M=12 \xComment}
{\catcode`\^^M=12 \endlinechar=-1 %
 \gdef\xComment#1^^M{\def\test{#1}
      \csarg\ifx{PlainEnd\CurrentComment Test}\test
          \let\html@next\endgroup
      \else \csarg\ifx{LaLaEnd\CurrentComment Test}\test
            \edef\html@next{\endgroup\noexpand\end{\CurrentComment}}
      \else \let\html@next\xComment
      \fi \fi \html@next}
}
\makeatother

\def\includecomment
 #1{\expandafter\def\csname#1\endcsname{}%
    \expandafter\def\csname end#1\endcsname{}}
\def\excludecomment
 #1{\expandafter\def\csname#1\endcsname{\ThrowAwayComment{#1}}%
    {\escapechar=-1\relax
     \csarg\xdef{PlainEnd#1Test}{\string\\end#1}%
     \csarg\xdef{LaLaEnd#1Test}{\string\\end\string\{#1\string\}}%
    }}

%  Define environments that ignore their contents.
\excludecomment{comment}
\excludecomment{rawhtml}
\excludecomment{htmlonly}

%  Hypertext commands etc. This is a condensed version of the html.sty
%  file supplied with LaTeX2HTML by: Nikos Drakos <nikos@cbl.leeds.ac.uk> &
%  Jelle van Zeijl <jvzeijl@isou17.estec.esa.nl>. The LaTeX2HTML documentation
%  should be consulted about all commands (and the environments defined above)
%  except \xref and \xlabel which are Starlink specific.

\newcommand{\htmladdnormallinkfoot}[2]{#1\footnote{#2}}
\newcommand{\htmladdnormallink}[2]{#1}
\newcommand{\htmladdimg}[1]{}
\newcommand{\hyperref}[4]{#2\ref{#4}#3}
\newcommand{\htmlref}[2]{#1}
\newcommand{\htmlimage}[1]{}
\newcommand{\htmladdtonavigation}[1]{}

\newenvironment{latexonly}{}{}
\newcommand{\latex}[1]{#1}
\newcommand{\html}[1]{}
\newcommand{\latexhtml}[2]{#1}
\newcommand{\HTMLcode}[2][]{}

%  Starlink cross-references and labels.
\newcommand{\xref}[3]{#1}
\newcommand{\xlabel}[1]{}

%  LaTeX2HTML symbol.
\newcommand{\latextohtml}{\LaTeX2\texttt{HTML}}

%  Define command to re-centre underscore for Latex and leave as normal
%  for HTML (severe problems with \_ in tabbing environments and \_\_
%  generally otherwise).
\renewcommand{\_}{\texttt{\symbol{95}}}

% -----------------------------------------------------------------------------
%  Debugging.
%  =========
%  Remove % on the following to debug links in the HTML version using Latex.

% \newcommand{\hotlink}[2]{\fbox{\begin{tabular}[t]{@{}c@{}}#1\\\hline{\footnotesize #2}\end{tabular}}}
% \renewcommand{\htmladdnormallinkfoot}[2]{\hotlink{#1}{#2}}
% \renewcommand{\htmladdnormallink}[2]{\hotlink{#1}{#2}}
% \renewcommand{\hyperref}[4]{\hotlink{#1}{\S\ref{#4}}}
% \renewcommand{\htmlref}[2]{\hotlink{#1}{\S\ref{#2}}}
% \renewcommand{\xref}[3]{\hotlink{#1}{#2 -- #3}}
%end{latexonly}
% -----------------------------------------------------------------------------
% ? Document specific \newcommand or \newenvironment commands.

% Command for displaying routines in routine lists:
% =================================================

\newcommand{\noteroutine}[2]{{\small \bf #1} \\
                              \hspace*{3em} {\em #2} \\[1.5ex]}
\begin{htmlonly}
   \newcommand{\noteroutine}[2]{
      \begin{description}
         \item [{\bf {#1}}] {\em #2}
      \end{description}
   }
\end{htmlonly}

% Latex only section. Surround this with a latexonly environment.
\newcommand{\latexonlysection}[1]{\section{#1}}
\begin{htmlonly}
   \newcommand{\latexonlysection}[1]{#1}
\end{htmlonly}

%+
%  Name:
%     SST.TEX

%  Purpose:
%     Define LaTeX commands for laying out Starlink routine descriptions.

%  Language:
%     LaTeX

%  Type of Module:
%     LaTeX data file.

%  Description:
%     This file defines LaTeX commands which allow routine documentation
%     produced by the SST application PROLAT to be processed by LaTeX and
%     by LaTeX2html. The contents of this file should be included in the
%     source prior to any statements that make of the sst commnds.

%  Notes:
%     The style file html.sty provided with LaTeX2html needs to be used.
%     This must be before this file.

%  Authors:
%     RFWS: R.F. Warren-Smith (STARLINK)
%     PDRAPER: P.W. Draper (Starlink - Durham University)

%  History:
%     10-SEP-1990 (RFWS):
%        Original version.
%     10-SEP-1990 (RFWS):
%        Added the implementation status section.
%     12-SEP-1990 (RFWS):
%        Added support for the usage section and adjusted various spacings.
%     8-DEC-1994 (PDRAPER):
%        Added support for simplified formatting using LaTeX2html.
%     {enter_further_changes_here}

%  Bugs:
%     {note_any_bugs_here}

%-

%  Define length variables.
\newlength{\sstbannerlength}
\newlength{\sstcaptionlength}
\newlength{\sstexampleslength}
\newlength{\sstexampleswidth}

%  Define a \tt font of the required size.
\latex{\newfont{\ssttt}{cmtt10 scaled 1095}}
\html{\newcommand{\ssttt}{\tt}}

%  Define a command to produce a routine header, including its name,
%  a purpose description and the rest of the routine's documentation.
\newcommand{\sstroutine}[3]{
   \goodbreak
   \rule{\textwidth}{0.5mm}
   \vspace{-7ex}
   \newline
   \settowidth{\sstbannerlength}{{\Large {\bf #1}}}
   \setlength{\sstcaptionlength}{\textwidth}
   \setlength{\sstexampleslength}{\textwidth}
   \addtolength{\sstbannerlength}{0.5em}
   \addtolength{\sstcaptionlength}{-2.0\sstbannerlength}
   \addtolength{\sstcaptionlength}{-5.0pt}
   \settowidth{\sstexampleswidth}{{\bf Examples:}}
   \addtolength{\sstexampleslength}{-\sstexampleswidth}
   \parbox[t]{\sstbannerlength}{\flushleft{\Large {\bf #1}}}
   \parbox[t]{\sstcaptionlength}{\center{\Large #2}}
   \parbox[t]{\sstbannerlength}{\flushright{\Large {\bf #1}}}
   \begin{description}
      #3
   \end{description}
}

%  Format the description section.
\newcommand{\sstdescription}[1]{\item[Description:] #1}

%  Format the usage section.
\newcommand{\sstusage}[1]{\item[Usage:] \mbox{}
\\[1.3ex]{\raggedright \ssttt #1}}

%  Format the invocation section.
\newcommand{\sstinvocation}[1]{\item[Invocation:]\hspace{0.4em}{\tt #1}}

%  Format the arguments section.
\newcommand{\sstarguments}[1]{
   \item[Arguments:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the returned value section (for a function).
\newcommand{\sstreturnedvalue}[1]{
   \item[Returned Value:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the parameters section (for an application).
\newcommand{\sstparameters}[1]{
   \item[Parameters:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the examples section.
\newcommand{\sstexamples}[1]{
   \item[Examples:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Define the format of a subsection in a normal section.
\newcommand{\sstsubsection}[1]{ \item[{#1}] \mbox{} \\}

%  Define the format of a subsection in the examples section.
\newcommand{\sstexamplesubsection}[2]{\sloppy
\item[\parbox{\sstexampleslength}{\ssttt #1}] \mbox{} \vspace{1.0ex}
\\ #2 }

%  Format the notes section.
\newcommand{\sstnotes}[1]{\item[Notes:] \mbox{} \\[1.3ex] #1}

%  Provide a general-purpose format for additional (DIY) sections.
\newcommand{\sstdiytopic}[2]{\item[{\hspace{-0.35em}#1\hspace{-0.35em}:}]
\mbox{} \\[1.3ex] #2}

%  Format the implementation status section.
\newcommand{\sstimplementationstatus}[1]{
   \item[{Implementation Status:}] \mbox{} \\[1.3ex] #1}

%  Format the bugs section.
\newcommand{\sstbugs}[1]{\item[Bugs:] #1}

%  Format a list of items while in paragraph mode.
\newcommand{\sstitemlist}[1]{
  \mbox{} \\
  \vspace{-3.5ex}
  \begin{itemize}
     #1
  \end{itemize}
}

%  Define the format of an item.
\newcommand{\sstitem}{\item}

%% Now define html equivalents of those already set. These are used by
%  latex2html and are defined in the html.sty files.
\begin{htmlonly}

%  sstroutine.
   \newcommand{\sstroutine}[3]{
      \subsection{#1\xlabel{#1}-\label{#1}#2}
      \begin{description}
         #3
      \end{description}
   }

%  sstdescription
   \newcommand{\sstdescription}[1]{\item[Description:]
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstusage
   \newcommand{\sstusage}[1]{\item[Usage:]
      \begin{description}
         {\ssttt #1}
      \end{description}
      \\
   }

%  sstinvocation
   \newcommand{\sstinvocation}[1]{\item[Invocation:]
      \begin{description}
         {\ssttt #1}
      \end{description}
      \\
   }

%  sstarguments
   \newcommand{\sstarguments}[1]{
      \item[Arguments:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstreturnedvalue
   \newcommand{\sstreturnedvalue}[1]{
      \item[Returned Value:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstparameters
   \newcommand{\sstparameters}[1]{
      \item[Parameters:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstexamples
   \newcommand{\sstexamples}[1]{
      \item[Examples:] \\
      \begin{description}
         #1
      \end{description}
      \\
   }

%  sstsubsection
   \newcommand{\sstsubsection}[1]{\item[{#1}]}

%  sstexamplesubsection
   \newcommand{\sstexamplesubsection}[2]{\item[{\ssttt #1}] #2}

%  sstnotes
   \newcommand{\sstnotes}[1]{\item[Notes:] #1 }

%  sstdiytopic
   \newcommand{\sstdiytopic}[2]{\item[{#1}] #2 }

%  sstimplementationstatus
   \newcommand{\sstimplementationstatus}[1]{
      \item[Implementation Status:] #1
   }

%  sstitemlist
   \newcommand{\sstitemlist}[1]{
      \begin{itemize}
         #1
      \end{itemize}
      \\
   }
%  sstitem
   \newcommand{\sstitem}{\item}

\end{htmlonly}

%  End of "sst.tex" layout definitions.
%.



% ? End of document specific commands
% -----------------------------------------------------------------------------
%  Title Page.
%  ===========
\renewcommand{\thepage}{\roman{page}}
\begin{document}
\thispagestyle{empty}

%  Latex document header.
%  ======================
\begin{latexonly}
   CCLRC / \textsc{Rutherford Appleton Laboratory} \hfill \textbf{\stardocname}\\
   {\large Particle Physics \& Astronomy Research Council}\\
   {\large Starlink Project\\}
   {\large \stardoccategory\ \stardocnumber}
   \begin{flushright}
   \stardocauthors\\
   \stardocdate
   \end{flushright}
   \vspace{-4mm}
   \rule{\textwidth}{0.5mm}
   \vspace{5mm}
   \begin{center}
   {\Huge\textbf{\stardoctitle \\ [2.5ex]}}
   {\LARGE\textbf{\stardocversion \\ [4ex]}}
   {\Huge\textbf{\stardocmanual}}
   \end{center}
   \vspace{5mm}

% ? Add picture here if required for the LaTeX version.
%   e.g. \includegraphics[scale=0.3]{filename.ps}
% ? End of picture

% ? Heading for abstract if used.
   \vspace{10mm}
   \begin{center}
      {\Large\textbf{Abstract}}
   \end{center}
% ? End of heading for abstract.
\end{latexonly}

%  HTML documentation header.
%  ==========================
\begin{htmlonly}
   \xlabel{}
   \begin{rawhtml} <H1> \end{rawhtml}
      \stardoctitle\\
      \stardocversion\\
      \stardocmanual
   \begin{rawhtml} </H1> <HR> \end{rawhtml}

% ? Add picture here if required for the hypertext version.
%   e.g. \includegraphics[scale=0.7]{filename.ps}
% ? End of picture

   \begin{rawhtml} <P> <I> \end{rawhtml}
   \stardoccategory\ \stardocnumber \\
   \stardocauthors \\
   \stardocdate
   \begin{rawhtml} </I> </P> <H3> \end{rawhtml}
      \htmladdnormallink{CCLRC / Rutherford Appleton Laboratory}
                        {http://www.cclrc.ac.uk} \\
      \htmladdnormallink{Particle Physics \& Astronomy Research Council}
                        {http://www.pparc.ac.uk} \\
   \begin{rawhtml} </H3> <H2> \end{rawhtml}
      \htmladdnormallink{Starlink Project}{http://www.starlink.rl.ac.uk/}
   \begin{rawhtml} </H2> \end{rawhtml}
   \htmladdnormallink{\htmladdimg{source.gif} Retrieve hardcopy}
      {http://www.starlink.rl.ac.uk/cgi-bin/hcserver?\stardocsource}\\

%  HTML document table of contents. 
%  ================================
%  Add table of contents header and a navigation button to return to this 
%  point in the document (this should always go before the abstract \section). 
  \label{stardoccontents}
  \begin{rawhtml} 
    <HR>
    <H2>Contents</H2>
  \end{rawhtml}
  \htmladdtonavigation{\htmlref{\htmladdimg{contents_motif.gif}}
        {stardoccontents}}

% ? New section for abstract if used.
  \section{\xlabel{abstract}Abstract}
% ? End of new section for abstract
\end{htmlonly}

% -----------------------------------------------------------------------------
% ? Document Abstract. (if used)
%  ==================
\stardocabstract
% ? End of document abstract

% -----------------------------------------------------------------------------
% ? Latex Copyright Statement
%  =========================
\begin{latexonly}
\newpage
\vspace*{\fill}
\stardoccopyright
\end{latexonly}
% ? End of Latex copyright statement

% -----------------------------------------------------------------------------
% ? Latex document Table of Contents (if used).
%  ===========================================
  \newpage
  \begin{latexonly}
    \setlength{\parskip}{0mm}
    \tableofcontents
    \setlength{\parskip}{\medskipamount}
    \markboth{\stardocname}{\stardocname}
  \end{latexonly}
% ? End of Latex document table of contents
% -----------------------------------------------------------------------------

\cleardoublepage
\renewcommand{\thepage}{\arabic{page}}
\setcounter{page}{1}

\section {Introduction}

If an application prompts the user for an NDF using the facilities of the NDF\_ 
system (see \xref{SUN/33}{sun33}{}), the user may only reply with the name of a single NDF. Some
applications allow many input NDFs to be specified and the need to
type in every NDF name explicitly each time the program is run can become time
consuming. The NDG package provides a means of giving the user the
ability to specify a list (or ``Group'') of NDFs as a reply to a single prompt
for an parameter. 

The current version of NDG can process NDFs which are stored as
components within an HDS container file, and can also process foreign
data formats using the system described in \xref{SSN/20}{ssn20}{}.


\section {Interaction Between NDG and GRP}
NDG uses the facilities of the GRP package and users of NDG should be familiar
with the content of \xref{SUN/150}{sun150}{} which describes the GRP package. Groups
created by NDG routines should be deleted when no longer needed using
\xref{GRP\_DELET}{sun150}{GRP\_DELET}.

\section {General overview of the NDG\_ system}
As a broad outline, applications use the NDG\_ package as follows:

\begin{enumerate}

\item A call is made to \htmlref{NDG\_ASSOC}{NDG\_ASSOC} which causes the user 
to be prompted for a single parameter. This parameter can be of any type.
The user replies with a ``group expression'' (see
\xref{SUN/150}{sun150}{}), which contains the names of a group of {\em
existing} NDFs to be used as inputs by the application\footnote{The routine
\htmlref{NDG\_ASEXP}{NDG\_ASEXP} performs the same function but does not
use the parameter system - it expects the group expression to be supplied by 
the calling routine.}. For instance, the group expression may be

\begin{verbatim}
     m51_b[23]s1_ds,m51_b[23]s2_ds,m51_b[23]s2?_ds,^files.lis
\end{verbatim}

This is a complicated example, probably more complicated than would be
used in practice, but it highlights the facilities of the GRP and NDG
packages, e.g. wild cards (``?'', ``$*$'' or ``[..]'' ), lists of files,
or indirection through a text file (``\verb+^+'').

The \htmlref{NDG\_ASSOC}{NDG\_ASSOC} routine produces a list of explicit NDF names, which are stored
internally within the GRP system. 

\item What happens next depends on the application, but a common example may be
the initiation of a DO loop to loop through the input NDFs (NDG\_ASSOC returns
the total number of NDF names in the group). 

\item To access a particular NDF, the application calls routine \htmlref{NDG\_NDFAS}{NDG\_NDFAS}
supplying an index, $n$, within the group (i.e $n$ is an integer in the range 1
to the group size returned by NDG\_ASSOC). NDG\_NDFAS returns an NDF identifier
to the $n$th NDF in the group. This identifier can then be used to access the
NDF in the normal manner using the NDF\_ routines (\xref{SUN/33}{sun33}{}). The identifier
should be annulled when it is no longer needed using \xref{NDF\_ANNUL}{sun33}{NDF\_ANNUL} in the
normal way.

\item Once the application has finished processing the group of NDFs, it calls 
\xref{GRP\_DELET}{sun150}{GRP\_DELET} which deletes the group, releasing all resources reserved by the group.

\item Routine NDG\_ASSOC can also be used to append a list of NDF names 
obtained from the environment, to a previously defined group.

The routine \htmlref{NDG\_CREAT}{NDG\_CREAT} produces a group containing the names of 
NDFs which are to be created by the application. The routine \htmlref{NDG\_NDFCR}{NDG\_NDFCR} will 
create a new NDF with a name given by a group member, and returns an NDF 
identifier to it. Routine \htmlref{NDG\_NDFPR}{NDG\_NDFPR} creates a new NDF by propagation from a 
previously existing NDF, in a similar manner to the NDF routine \xref{NDF\_PROP}{sun33}{NDF\_PROP} (see 
\xref{SUN/33}{sun33}{}).

The names of output NDFs given by users usually relate to the input NDF names.
When NDG\_CREAT is called, it creates a group of NDF names either by modifying
all the names in a specified input group using a ``modification element'' (see
\xref{SUN/150}{sun150}{}), or by getting a list of new names from the user. 

\item Applications which produce a group of output NDFs could also produce a
text file holding the names of the output NDFs. Such a file can be used
as input to the next application, using the indirection facility. A text
file listing of all the NDFs in a group can be produced by routine
GRP\_LIST (or GRP\_LISTF).

\end{enumerate}

See the detailed descriptions of \htmlref{NDG\_ASSOC}{NDG\_ASSOC} and \htmlref{NDG\_CREAT}{NDG\_CREAT} below for details 
of the processing of existing and new NDF names.

\section{An example NDG application}

The following gives a short example of how NDG routines might be 
used within an ADAM task.
\begin{quote}
\latexonly{\small}
\begin{verbatim}
      SUBROUTINE COPY( STATUS )

*  Global Constants:
      INCLUDE 'GRP_PAR'          ! Standard GRP constants

*  Local Variables:
      INTEGER GIDIN              ! GRP identifier for group of input NDFs
      INTEGER GIDOUT             ! GRP identifer for group of output NDFs
      INTEGER I                  ! Loop counter
      INTEGER NDFIN              ! NDF identifier for input NDF
      INTEGER NDFOUT             ! NDF identifier for output NDF
      INTEGER NUMIN              ! Number of input NDFs
      INTEGER NUMOUT             ! Number of output NDFs
      INTEGER STATUS             ! The global status
      LOGICAL FLAG               ! Has group ended with flag character?
*.

*  Inialise the group identifiers to indicate that groups do not have
*  any initial members.
      GIDIN = GRP__NOID
      GIDOUT = GRP__NOID

*  Create group of input NDFs using the parameter IN.
      CALL NDG_ASSOC( 'IN', .TRUE., GIDIN, NUMIN, FLAG, STATUS )

*  Create group of output NDFs using the parameter OUT, which possibly
*  works by modifying the values in the input group.
      CALL NDG_CREAT( 'OUT', GIDIN, GIDOUT, NUMOUT, FLAG, STATUS )

*  Loop over group members.
      DO I = 1, NUMIN

*  Get the identifier for an existing NDF from the input group.
         CALL NDG_NDFAS( GIDIN, I, 'READ', NDFIN, STATUS )

*  Create a new NDF by propagation using the name in the output group.
         CALL NDG_NDFPR( NDFIN, 'Data,Variance,Quality,WCS', GIDOUT, I,
     :                   NDFOUT, STATUS )

*  Relase NDF resources.
         CALL NDF_ANNUL( NDFIN, STATUS )
         CALL NDF_ANNUL( NDFOUT, STATUS )
      END DO

*  Release GRP resources.
      CALL GRP_DELET( GIDIN, STATUS )
      CALL GRP_DELET( GIDOUT, STATUS )

      END
\end{verbatim}
\end{quote}
When this program is compiled and run, the user is asked for 
two ADAM parameters, IN and OUT.  Each NDF in the list specified
by the IN parameter is simply copied to the corresponding naem in the 
list specified by the OUT parameter.  For instance, running
\begin{quote}
\latexonly{\small}
\begin{verbatim}
copy in=data[12] out=*-new
\end{verbatim}
\end{quote}
would write new NDFs {\tt data1-new.sdf} and {\tt data2-new.sdf}
which were copies of the existing files {\tt data1.sdf} and {\tt data2.sdf}.
If {\tt data1} and {\tt data2} do not represent NDF structures,
an error will be signalled and the user will be prompted to enter
a different value for IN.
If any of the elements of the IN list represents an HDS container file
which holds multiple NDF structures directly within it, each of these
will be added to the list of NDFs to be processed, and the
output list will be constructed with a corresponding structure.
For instance, if the HDS file {\tt obs.sdf} contains three NDFs at
its top level called O1, O2 and O3, then invoking
\begin{quote}
\latexonly{\small}
\begin{verbatim}
copy in=obs out=obs-copy
\end{verbatim}
\end{quote}
will result in a new container file {\tt obs-copy.sdf} being written, 
which contains three NDF structures called O1, O2 and O3.

Note that a few corners have been cut in the above code,
in particular checking that the input and output groups have the
same size and STATUS testing.  Additionally, no action is taken
when the FLAG character is given at the end of a group specification --
conventionally this would indicate that the user should be allowed
to add further members.

\appendix

\begin{latexonly}
\latexonlysection{List of Routines}

\noteroutine{
      CALL NDG\_ASEXP( GRPEXP, VERB, IGRP1, IGRP2, SIZE, FLAG, STATUS )
}{
   Store names of existing NDFs supplied as a group expression by the
   calling routine.
}
\noteroutine{
      CALL NDG\_ASSO1( PARAM, VERB, MODE, INDF, FIELDS, STATUS )
}{
   Obtain an identifier for a single existing NDF using a specified
   parameter
}
\noteroutine{
      CALL NDG\_ASSOC( PARAM, VERB, IGRP, SIZE, FLAG, STATUS )
}{
   Store names of existing NDFs specified through the environment
}
\noteroutine{
      CALL NDG\_CREA1( PARAM, FTYPE, NDIM, LBND, UBND, INDF, NAME,
                      STATUS )
}{
   Create a single new simple NDF using a specified parameter
}
\noteroutine{
      CALL NDG\_CREAT( PARAM, IGRP0, IGRP, SIZE, FLAG, STATUS )
}{
   Obtain the names of a group of NDF to be created from the
   environment
}
\noteroutine{
      CALL NDG\_CREP1( PARAM, FTYPE, NDIM, UBND, INDF, NAME, STATUS )
}{
   Create a single new primitive NDF using a specified parameter
}
\noteroutine{
      CALL NDG\_GTSUP( IGRP, I, FIELDS, STATUS )
}{
   Get supplemental information for an NDF
}
\noteroutine{
      CALL NDG\_NDFAS( IGRP, INDEX, MODE, INDF, STATUS )
}{
   Obtain an NDF identifier for an existing NDF
}
\noteroutine{
      CALL NDG\_NDFCO( INDF1, IGRP, INDEX, INDF2, STATUS )
}{
   Obtain an NDF identifier for a new NDF created by copying an 
   existing NDF
}
\noteroutine{
      CALL NDG\_NDFCP( IGRP, INDEX, FTYPE, NDIM, UBND, INDF, STATUS )
}{
   Obtain an NDF identifier for a new primitive NDF
}
\noteroutine{
      CALL NDG\_NDFCR( IGRP, INDEX, FTYPE, NDIM, LBND, UBND, INDF,
                      STATUS )
}{
   Obtain an NDF identifier for a new simple NDF
}
\noteroutine{
      CALL NDG\_NDFPR( INDF1, CLIST, IGRP, INDEX, INDF2, STATUS )
}{
   Obtain an NDF identifier for a new NDF created by propagation from
   an existing NDF
}
\noteroutine{
      CALL NDG\_PROP1( INDF1, CLIST, PARAM, INDF2, NAME, STATUS )
}{
   Create a single new NDF by propagation using a specified parameter
}
\noteroutine{
      CALL NDG\_PTSUP( IGRP, I, FIELDS, STATUS )
}{
   Store suplemental information for an NDF
}
\noteroutine{
      CALL NDG\_SETSZ( IGRP, SIZE, STATUS )
}{
   Reduces the size of an NDG group
}

\end{latexonly}


\section{Full Fortrn Routine Specifications}
\label {SEC:FULLSPEC}

% Routine descriptions:
% =====================
\small


\sstroutine{
   NDG\_ASEXP
}{
   Store names of existing NDFs supplied as a group expression
}{
   \sstdescription{
      The supplied group expression is parsed (using the facilities of
      the GRP routine GRP\_GROUP, see SUN/150) to produce a list of
      explicit names for existing NDFs which are appended to the end of
      the supplied group (a new group is created if none is supplied).
      NDF identifiers for particular members of the group can be obtained
      using NDG\_NDFAS.

      If any of the NDFs specified by the group expression cannot be
      accessed, an error is reported and STATUS is returned equal to
      NDG\_\_NOFIL. If this happens strings holding the name of each
      bad NDF are appended to the group identified by IGRP1 (so long
      as IGRP1 is not equal to GRP\_\_NOID).
   }
   \sstinvocation{
      CALL NDG\_ASEXP( GRPEXP, VERB, IGRP1, IGRP2, SIZE, FLAG, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         GRPEXP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The group expression specifying the NDF names to be stored
         in the group.
      }
      \sstsubsection{
         VERB = LOGICAL (Given)
      }{
         If TRUE then errors which occur whilst accessing supplied NDFs
         are flushed so that the user can see the details ({\tt "}verbose{\tt "} mode).
         Otherwise, they are annulled and a general {\tt "}Cannot access file xyz{\tt "}
         message is reported instead.
      }
      \sstsubsection{
         IGRP1 = INTEGER (Given)
      }{
         The identifier of a group to which the names of any
         inaccessable NDFs will be appended. The group should already
         have been created by a call to GRP\_NEW, and should be deleted
         when no longer needed by a call to GRP\_DELET. If IGRP1 is
         supplied equal to symbolic constant GRP\_\_NOID, then no
         information is stored describing the bad NDFs.
      }
      \sstsubsection{
         IGRP2 = INTEGER (Given and Returned)
      }{
         The identifier of the group in which the NDF names are to be
         stored. A new group is created if the supplied value is GRP\_\_NOID.
         It should be deleted when no longer needed using GRP\_DELET.
      }
      \sstsubsection{
         SIZE = INTEGER (Returned)
      }{
         The total number of NDF names in the returned group IGRP2.
      }
      \sstsubsection{
         FLAG = LOGICAL (Returned)
      }{
         If the group expression was terminated by the GRP {\tt "}flag
         character{\tt "}, then FLAG is returned .TRUE. Otherwise it is
         returned .FALSE. Returned .FALSE. if an error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Any file names containing wildcards are expanded into a list of NDF
         names. The supplied strings are intepreted by a shell (/bin/tcsh if
         it exists, otherwise /bin/csh, otherwise /bin/sh), and so may
         contain shell meta-characters (eg twiddle, \$HOME, even command
         substitution and pipes - but pipe characters {\tt "}$|${\tt "} need to be escaped
         using a backslash {\tt "}$\backslash${\tt "} to avoid them being interpreted as GRP
         editing characters).

         \sstitem
         Each supplied name may include an HDS path. For instance,
         {\tt "}/home/dsb/mydata.a.c(1).b{\tt "} refers to an NDF stored in component
         {\tt "}a.c(1).b{\tt "} in the HDS container file /home/dsb/mydata.sdf. Note,
         wild cards are not allowed within HDS component paths (i.e. they
         are only allowed within the specification of the container file).

         \sstitem
         If an HDS object is specified which is not an NDF, then the
         object will be searched for NDF components. This search is
         recursive, in that any components of the specified object are also
         searched. The supplied name will be expanded into a group of names,
         one for each NDF found within the specified HDS object. Note, NDFs
         are not themselves searched for other NDFs. That is, the expanded
         group of names will not include any NDF which is contained within
         another NDF (i.e. NDFs which are stored as an extension item of
         another NDF are not included in the group). For instance, if the
         string {\tt "}fred{\tt "} is given, the HDS file fred.sdf will be searched for
         NDFs and the returned group will contain references for all NDFs
         found within fred.sdf.

         \sstitem
         If the environment variable NDF\_FORMATS\_IN is defined (see
         SSN/20) then all possible NDFs matching the supplied string are
         included in the returned group. For instance, if the string {\tt "}fred{\tt "}
         is supplied, then the returned group will contain references to all
         files with basename fred which also have a file type specified in
         NDF\_FORMATS\_IN. If a FITS file {\tt "}fred.fit{\tt "} exists, and HDS file
         {\tt "}fred.sdf{\tt "} also exists (and contains an NDF), then supplying the
         name {\tt "}fred{\tt "} will result in both being included in the returned
         group. If the file {\tt "}fred.sdf{\tt "} contains a component called {\tt "}.fit{\tt "},
         then this will be included in the returned group in place of
         {\tt "}fred.sdf{\tt "}.

         \sstitem
         NDFs contained within HDS files are opened in order to ensure
         that they are valid NDFs. The NDF name is returned in IGRP1 if there
         are no valid NDFs matching a supplied name. No check is made that any
         foreign data files contain valid NDFs since this would involve a
         potentially expensive data conversion. So, for instance, {\tt "}$*$.fit{\tt "} could
         pick up FITS catalogues as well as FITS images. If a foreign data file
         does not contain a valid NDF, an error will be reported when the NDF
         is accessed using NDG\_NDFAS.

         \sstitem
         Each element in the returned group contains a full specification
         for an NDF. Several other groups are created by this routine, and
         are associated with the returned group by means of a GRP {\tt "}owner-slave{\tt "}
         relationship. These supplemental groups are automatically deleted
         when the returned group is deleted using GRP\_DELET. The returned
         group should not be altered using GRP directly because corresponding
         changes may need to be made to the supplemental groups. Routines
         NDG\_SETSZ, NDG\_GTSUP and NDG\_PTSUP are provided to manipulate the
         entire chain of groups. The full chain (starting from the head) is
         as follows:

         \sstitem
            NDF slice specifications

         \sstitem
            HDS paths

         \sstitem
            File types

         \sstitem
            Base file names

         \sstitem
            Directory paths

         \sstitem
            Full NDF specification (this is the returned group IGRP)
      }
   }
}
\sstroutine{
   NDG\_ASSO1
}{
   Obtain an identifier for a single existing NDF using a specified
   parameter
}{
   \sstdescription{
      This routine is equivalent to NDF\_ASSOC except that it allows the
      NDF to be specified using a GRP group expression (for instance, its
      name may be given within a text file, etc). The first NDF in the
      group expression is returned. Any other names in the group
      expression are ignored. Supplemental information describing the
      separate fields in the NDF specification are also returned.
   }
   \sstinvocation{
      CALL NDG\_ASSO1( PARAM, VERB, MODE, INDF, FIELDS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the ADAM parameter.
      }
      \sstsubsection{
         VERB = LOGICAL (Given)
      }{
         If TRUE then errors which occur whilst accessing supplied NDFs
         are flushed so that the user can see them before re-prompting for
         a new NDF ({\tt "}verbose{\tt "} mode). Otherwise, they are annulled and
         a general {\tt "}Cannot access file xyz{\tt "} message is displayed before
         re-prompting.
      }
      \sstsubsection{
         MODE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Type of NDF access required: {\tt '}READ{\tt '}, {\tt '}UPDATE{\tt '} or {\tt '}WRITE{\tt '}.
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         FIELDS( 6 ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Each element contains the following on exit:
         \begin{enumerate}
         \item NDF slice specifications
         \item HDS paths
         \item File types
         \item Base file names
         \item Directory paths
         \item Full NDF specification (this is the returned group - IGRP)
         \end{enumerate}
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   NDG\_ASSOC
}{
   Store names of existing NDFs specified through the environment
}{
   \sstdescription{
      A group expression is obtained from the environment using the
      supplied parameter. The expression is parsed (using the
      facilities of the GRP routine GRP\_GROUP, see \xref{SUN/150}{sun150}{}) to produce
      a list of explicit names for existing NDFs which are appended to the
      end of the supplied group (a new group is created if none is
      supplied). If an error occurs while parsing the group expression, the
      user is re-prompted for a new group expression. NDF identifiers for
      particular members of the group can be obtained using NDG\_NDFAS.
   }
   \sstinvocation{
      CALL NDG\_ASSOC( PARAM, VERB, IGRP, SIZE, FLAG, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER$*$($*$) (Given)
      }{
         The parameter with which to associate the group expression.
      }
      \sstsubsection{
         VERB = LOGICAL (Given)
      }{
         If TRUE then errors which occur whilst accessing supplied NDFs
         are flushed so that the user can see them before re-prompting for
         a new NDF ({\tt "}verbose{\tt "} mode). Otherwise, they are annulled and
         a general {\tt "}Cannot access file xyz{\tt "} message is displayed before
         re-prompting.
      }
      \sstsubsection{
         IGRP = INTEGER (Given and Returned)
      }{
         The identifier of the group in which the NDF names are to be
         stored. A new group is created if the supplied value is GRP\_\_NOID.
         It should be deleted when no longer needed using GRP\_DELET.
      }
      \sstsubsection{
         SIZE = INTEGER (Returned)
      }{
         The total number of NDF names in the returned group.
      }
      \sstsubsection{
         FLAG = LOGICAL (Returned)
      }{
         If the group expression was terminated by the GRP {\tt "}flag
         character{\tt "}, then FLAG is returned true. Otherwise it is
         returned false. Returned .FALSE. if an error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Any file names containing wildcards or "[..]" globbing patterns
	 are expanded into a list of NDF names. The supplied strings are
	 intepreted by a shell (/bin/tcsh if it exists, otherwise
	 /bin/csh, otherwise /bin/sh), and so may contain shell
	 meta-characters (eg twiddle, \$HOME, even command substitution
	 and pipes - but pipe characters {\tt "}$|${\tt "} need to be
	 escaped using a backslash {\tt "}$\backslash${\tt "} to avoid
	 them being interpreted as GRP editing characters).

         \sstitem
         Each supplied name may include an HDS path. For instance,
         {\tt "}/home/dsb/mydata.a.c(1).b{\tt "} refers to an NDF stored in component
         {\tt "}a.c(1).b{\tt "} in the HDS container file /home/dsb/mydata.sdf. Note,
         wild cards are not allowed within HDS component paths (i.e. they
         are only allowed within the specification of the container file).

         \sstitem
         If an HDS object is specified which is not an NDF, then the
         object will be searched for NDF components. This search is
         recursive, in that any components of the specified object are also
         searched. The supplied name will be expanded into a group of names,
         one for each NDF found within the specified HDS object. Note, NDFs
         are not themselves searched for other NDFs. That is, the expanded
         group of names will not include any NDF which is contained within
         another NDF (i.e. NDFs which are stored as an extension item of
         another NDF are not included in the group). For instance, if the
         string {\tt "}fred{\tt "} is given, the HDS file fred.sdf will be searched for
         NDFs and the returned group will contain references for all NDFs
         found within fred.sdf.

         \sstitem
         If the environment variable NDF\_FORMATS\_IN is defined (see
         \xref{SSN/20}{ssn20}{}) then only the highest priority file with any give file name
         is included in the returned group. The priority of a file is
         determined by its file type. Native NDFs (.sdf) have highest
         priority. After that, priority decreases along the list of file
         types specified in NDF\_FORMATS\_OUT. If no file type is given by
         the user, the highest priority available file type is used. If an
         explicit file type is given, then that file type is used.

         \sstitem

         Care should be taken if a trailing string enclosed in square
	 brackets is appended to the end of the file name. These are
	 interpreted first as a globbing pattern. Thus {\tt
	 "}fred[12]{\tt "} would match files with base names {\tt
	 "}fred1{\tt "} and {\tt "}fred2{\tt "}. If the pattern does not
	 match any existing files, then the trailing {\tt "}[..]{\tt "}
	 string is next interpreted as a foreign extension specifier.
	 Thus if fred.fit is a multi-extension FITS file, {\tt
	 "}fred[12]{\tt "} would be interpreted as the twelth image
	 extension in fred.fit only if files cannot be found with
	 basenames {\tt "}fred1{\tt "} or {\tt "}fred2{\tt "}.

         \sstitem
         NDFs contained within HDS files are opened in order to ensure
         that they are valid NDFs. The user is notified if there are no
         valid NDFs matching a supplied name, and they are asked to supply
         a replacement parameter value. No check is made that any foreign
         data files contain valid NDFs since this would involve a potentially
         expensive data conversion. So, for instance, {\tt "}$*$.fit{\tt "} could pick up
         FITS catalogues as well as FITS images. If a foreign data file does
         not contain a valid NDF, an error will be reported when the NDF is
         accessed using NDG\_NDFAS.

         \sstitem
         Each element in the returned group contains a full specification
         for an NDF. Several other groups are created by this routine, and
         are associated with the returned group by means of a GRP {\tt "}owner-slave{\tt "}
         relationship. These supplemental groups are automatically deleted
         when the returned group is deleted using GRP\_DELET. The returned
         group should not be altered using GRP directly because corresponding
         changes may need to be made to the supplemental groups. Routines
         NDG\_SETSZ, NDG\_GTSUP and NDG\_PTSUP are provided to manipulate the
         entire chain of groups. The full chain (starting from the head) is
         as follows:

         \sstitem
            NDF slice specifications

         \sstitem
            HDS paths

         \sstitem
            File types

         \sstitem
            Base file names

         \sstitem
            Directory paths

         \sstitem
            Full NDF specification (this is the returned group IGRP)

         \sstitem
         If an error is reported the group is returned unaltered. If
         no group is supplied, an empty group is returned.

         \sstitem
         A null value (!) can be given for the parameter to indicate
         that no more NDFs are to be specified. The corresponding error
         is annulled before returning unless no NDFs have been added to
         the group.

         \sstitem
         If the last character in the supplied group expression is
         a colon (:), a list of the NDFs represented by the group
         expression (minus the colon) is displayed, but none are
         actually added to the group. The user is then re-prompted for
         a new group expression.
      }
   }
}

\sstroutine{
   NDG\_BEGPV
}{
   Begin an NDF provenance block
}{
   \sstdescription{
      This routine should be called to mark the start of an NDF
      provenance block. The block should be ended by a matching
      call to NDG\_ENDPV. See NDG\_ENDPV for more details.

      Note - provenance blocks must not be nested.
   }
   \sstinvocation{
      CALL NDG\_BEGPV( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}

\sstroutine{
   NDG\_COPY
}{
   Copy a section of an existing NDG group to a new group
}{
   \sstdescription{
      This routine extends the functionality of GRP\_COPY when copying
      elements from a group created by NDG. Such groups have
      {\tt "}supplemental information{\tt "} associated with them that holds further
      information about each NDF in the group. This function ensures that
      the returned group also has such supplemental information.

      NDG{\tt '}s supplemental information is stored in a chain of {\tt "}slave
      groups{\tt "} that are attached to each other using the facilities of
      GRP (e.g. see GRP\_SOWN). The supplied group is the lowest level
      {\tt "}slave{\tt "} in this chain.
   }
   \sstinvocation{
      CALL NDG\_COPY( IGRP, INDXLO, INDXHI, REJECT, IGRP2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP1 = INTEGER (Given)
      }{
         A GRP identifier for the input group.
      }
      \sstsubsection{
         INDXLO = INTEGER (Given)
      }{
         The lowest index to reject or to copy.
      }
      \sstsubsection{
         INDXHI = INTEGER (Given)
      }{
         The highest index to reject or to copy.
      }
      \sstsubsection{
         REJECT = LOGICAL ( Given)
      }{
         If reject is .TRUE., then names in the given range are
         rejected.  Otherwise, names in the given range are copied.
      }
      \sstsubsection{
         IGRP2 = INTEGER (Returned)
      }{
         A GRP identifier for the created group. Returned equal to
         GRP\_\_NOID if an error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}

\sstroutine{
   NDG\_CPSUP
}{
   Copy supplemental information for an NDF
}{
   \sstdescription{
      Copies an entry with its supplemental information from one group to
      another, appending it to the end of the output group.
   }
   \sstinvocation{
      CALL NDG\_CPSUP( IGRP1, I, IGRP2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP1 = INTEGER (Given)
      }{
         The NDG group as returned by NDG\_ASSOC, etc.
      }
      \sstsubsection{
         I = INTEGER (Given)
      }{
         The index, within IGRP1, of the entry to copy.
      }
      \sstsubsection{
         IGRP2 = INTEGER (Given)
      }{
         The NDG group to which the copied information should be appended.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}

\sstroutine{
   NDG\_CREA1
}{
   Create a single new simple NDF using a specified parameter
}{
   \sstdescription{
      This routine is equivalent to NDF\_CREAT except that it allows the
      NDF to be specified using a GRP group expression (for instance, its
      name may be given within a text file, etc). The first NDF in the
      group expression is returned. Any other names in the group
      expression are ignored. Any modification elements in the supplied
      group expression will be treated literally.
   }
   \sstinvocation{
      CALL NDG\_CREA1( PARAM, FTYPE, NDIM, LBND, UBND, INDF, NAME,
                      STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the ADAM parameter.
      }
      \sstsubsection{
         FTYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Full data type of the NDF{\tt '}s DATA component (e.g. {\tt '}\_DOUBLE{\tt '} or
         {\tt '}COMPLEX\_REAL{\tt '}).
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of NDF dimensions.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Given)
      }{
         Lower pixel-index bounds of the NDF.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         Upper pixel-index bounds of the NDF.
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The full file specification for the NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   NDG\_CREAT
}{
   Obtain the names of a group of NDF to be created from the
   environment
}{
   \sstdescription{
      A group expression is obtained from the environment using the
      supplied parameter. The expression is parsed (using the
      facilities of the GRP routine GRP\_GROUP, see \xref{SUN/150}{sun150}{}) to produce
      a list of explicit NDF names. These names are appended
      to the group identified by IGRP. The user is re-prompted if an
      error occurs while parsing the group expression. If IGRP has the
      value GRP\_\_NOID on entry, then a new group is created and IGRP is
      returned holding the new group identifier.

      If IGRP0 holds a valid group identifier on entry, then the group
      identified by IGRP0 is used as the basis for any modification
      element contained in the group expression obtained from the
      environment. If IGRP0 holds an invalid identifier (such as
      GRP\_\_NOID) on entry then modification elements are included
      literally in the output group.
   }
   \sstinvocation{
      CALL NDG\_CREAT( PARAM, IGRP0, IGRP, SIZE, FLAG, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER$*$($*$) (Given)
      }{
         The parameter with which to associate the group.
      }
      \sstsubsection{
         IGRP0 = INTEGER (Given)
      }{
         The GRP identifier for the group to be used as the basis for
         any modification elements. If a valid GRP identifier is
         supplied, and if the supplied group expression contains a
         modification element, then:

         \sstitemlist{

            \sstitem
            the basis token (an asterisk) is replaced by the file basename
            associated with the corresponding element of the basis group (the
            {\tt "}basis NDF{\tt "}).

            \sstitem
            if no directory specification is included in the group expression,
            the directory specification associated with the basis NDF is used.

            \sstitem
            if no HDS component path is included in the group expression,
            the HDS component path associated with the basis NDF (if any) is
            used. Any required higher level HDS objects are created in the
            output HDS file by copying the structure of the HDS file containing
            the basis NDF. Thus if, the basis NDF is fred.a.b(2).c, and the
            group expression is {\tt "}$*$\_a{\tt "}, then an HDS container file called
            {\tt "}fred\_a.sdf{\tt "} is created by copying fred.sdf and then deleting all
            NDFs from fred\_a.sdf (unless this has already been done while
            creating a previous member of the returned group). Other non-NDF
            components in fred\_a.sdf are retained. This ensures that all necessary
            structure exists in fred\_a.sdf, so that the NDF fred\_a.a.b(2).c
            can be created when necessary.

         }
         The supplied group will often be created by NDG\_ASSOC, but
         groups created {\tt "}by hand{\tt "} using GRP directly can also be used
         (i.e. without the supplemental groups created by NDG). In
         this case, there are no defaults for directory path, file type,
         or HDS component path, and the basis token ({\tt "}$*${\tt "}) in the group
         expression represents the full basis file specification supplied
         in IGRP0, not just the file basename.
      }
      \sstsubsection{
         IGRP = INTEGER (Given and Returned)
      }{
         The GRP identifier for the group to which the supplied .sdf
         files are to be appended.
      }
      \sstsubsection{
         SIZE = INTEGER (Returned)
      }{
         The total number of file names in the returned group.
      }
      \sstsubsection{
         FLAG = LOGICAL (Returned)
      }{
         If the group expression was terminated by the GRP {\tt "}flag{\tt "}
         character, then FLAG is returned .TRUE. Otherwise it is
         returned .FALSE. Returned .FALSE. if an error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If an error is reported the group is returned unaltered.

         \sstitem
         A null value (!) can be given for the parameter to indicate
         that no more NDFs are to be specified. The corresponding error
         is annulled before returning unless no NDFs have been added to
         the group.

         \sstitem
         Explicit file types are included in all the elements of the returned
         group. This is done because the name may be passed out to a script (eg
         POLPACK:POLKA) which may change the value of NDF\_FORMATS\_OUT before
         using the NDF name. If no file type is supplied in the group
         expression, then the first file type listed in the current value of
         the NDF\_FORMATS\_OUT environment variable (see \xref{SSN/20}{ssn20}{}) is used. If
         this is {\tt "}$*${\tt "} then the file type is copied from the corresponding input
         file if a modification element was used to specify the output file
         name (if the NDF was not specified by a modification element, the
         second file type in NDF\_FORMATS\_OUT is used).

         \sstitem
         If the last character in the supplied group expression is
         a colon (:), a list of the NDFs represented by the group
         expression (minus the colon) is displayed, but none are
         actually added to the group. The user is then re-prompted for
         a new group expression.

         \sstitem
         The returned group has no associated groups holding supplemental
         information (unlike the group returned by NDG\_ASSOC).
      }
   }
}
\sstroutine{
   NDG\_CREP1
}{
   Create a single new primitive NDF using a specified parameter
}{
   \sstdescription{
      This routine is equivalent to NDF\_CREP except that it allows the
      NDF to be specified using a GRP group expression (for instance, its
      name may be given within a text file, etc). The first NDF in the
      group expression is returned. Any other names in the group
      expression are ignored. Any modification elements in the supplied
      group expression will be treated literally.
   }
   \sstinvocation{
      CALL NDG\_CREP1( PARAM, FTYPE, NDIM, UBND, INDF, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the ADAM parameter.
      }
      \sstsubsection{
         FTYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Type of the NDF{\tt '}s DATA component (e.g. {\tt '}\_REAL{\tt '}). Note that
         complex types are not permitted when creating a primitive NDF.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of NDF dimensions.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         Upper pixel-index bounds of the NDF (the lower bound of each
         dimension is taken to be 1).
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The full file specification for the NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}

\sstroutine{
   NDG\_CREXP
}{
   Store the names of a specified group of NDF to be created
}{
   \sstdescription{
      The supplied group expression is parsed (using the facilities of
      the GRP routine GRP\_GROUP, see SUN/150) to produce a list of
      explicit NDF names. No check is made to see if these NDFs exist
      or not, and any wild-cards in the NDF names are ignored. The names
      are appended to the group identified by IGRP. If IGRP has the
      value GRP\_\_NOID on entry, then a new group is created and IGRP is
      returned holding the new group identifier.

      If IGRP0 holds a valid group identifier on entry, then the group
      identified by IGRP0 is used as the basis for any modification
      element contained in the supplied group expression. If IGRP0 holds
      an invalid identifier (such as GRP\_\_NOID) on entry then
      modification elements are included literally in the output group.
   }
   \sstinvocation{
      CALL NDG\_CREXP( GRPEXP, IGRP0, IGRP, SIZE, FLAG, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         GRPEXP = CHARACTER$*$($*$) (Given)
      }{
         The group expression specifying the NDF names to be stored in
         the group.
      }
      \sstsubsection{
         IGRP0 = INTEGER (Given)
      }{
         The GRP identifier for the group to be used as the basis for
         any modification elements.
      }
      \sstsubsection{
         IGRP = INTEGER (Given and Returned)
      }{
         The GRP identifier for the group to which the supplied NDF
         names are to be appended.
      }
      \sstsubsection{
         SIZE = INTEGER (Returned)
      }{
         The total number of NDF names in the returned group.
      }
      \sstsubsection{
         FLAG = LOGICAL (Returned)
      }{
         If the group expression was terminated by the GRP {\tt "}flag{\tt "}
         character, then FLAG is returned .TRUE. Otherwise it is
         returned .FALSE. Retuned .FALSE. if an error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}

\sstroutine{
   NDG\_CTPRV
}{
   Count the number of ancestors used in the creation of an NDF
}{
   \sstdescription{
      This routine returns the number of ancestors described in the
      {\tt "}PROVENANCE{\tt "} extension of the supplied INDF.
   }
   \sstinvocation{
      CALL NDG\_CTPRV( INDF, NANC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         An identifier for the NDF containing the provenance information.
      }
      \sstsubsection{
         NANC = INTEGER (Returned)
      }{
         The number of ancestor NDFs stored in the provenance information
         of INDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}

\sstroutine{
   NDG\_ENDPV
}{
   End an NDF provenance block
}{
   \sstdescription{
      This routine should be called to mark the end of an NDF
      provenance block. The block should have been started by a
      matching call to NDG\_BEGPV. Note, provenance blocks must
      not be nested.

      During a provenance block, a list is maintained of all the 
      existing NDFs that have had their Data array mapped (either in 
      read or update mode) during the block. Another list is maintained 
      of all the NDFs that have been written (either existing NDFs 
      accessed in update mode or new NDFs) during the block.

      When the block ends, the provenance information within each
      NDF in the second may be modified to include all the NDFs in the
      first list as parents. Whether or not this occurs is controlled by
      the AUTOPROV environment variable. If AUTOPROV is set to {\tt '}1{\tt '} then
      the input NDFs are added to the provenance information in the
      output NDF. If AUTOPROV is set to anything other than {\tt '}1{\tt '} then the
      output provenance is not updated. If AUTOPROV is not set at all,
      then the output provenance will be updated only if one or more of
      the input NDFs contains a PROVENANCE extension.
   }
   \sstinvocation{
      CALL NDG\_ENDPV( CREATR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         CREATR = CHARACTER $*$ ( $*$ ) (Given)
      }{
         An identifier for the software that created INDF1 (usually the
         name of the calling application). The format of the identifier
         is arbitrary, but the form {\tt "}PACKAGE:COMMAND{\tt "} is recommended.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}

\sstroutine{
   NDG\_FMPRV
}{
   Format the provenance information from an NDF
}{
   \sstdescription{
      This routine returns an AST KeyMap holding a set of text strings
      containing information taken from the {\tt "}PROVENANCE{\tt "} extension in INDF.

      The returned KeyMap has an entry with key {\tt "}0{\tt "} that describes the
      supplied NDF. It also has an entry describing each ancestor NDF.
      These entries have keys {\tt "}1{\tt "}, {\tt "}2{\tt "}, {\tt "}3{\tt "}, etc, up to the number of
      ancestors in the NDF.

      Each of these entries contains a pointer to another AST KeyMap
      which may contain any subset of the following entries (all of which
      are strings):

      {\tt "}ID{\tt "} - the integer index within the ancestors array (zero for the
             main NDF).

      {\tt "}PATH{\tt "} - The full path or base name for the NDF (see argument {\tt "}BASE{\tt "}).

      {\tt "}DATE{\tt "} - The date of creation of the NDF.

      {\tt "}CREATOR{\tt "} - The software item that created the NDF.

      {\tt "}PARENTS{\tt "} - A comma separated list of indicies into the ancestors
                  array that identifies the direct parents of the NDF.

      {\tt "}MORE{\tt "} - A summary of the contents of the MORE structure associated
               with the NDF.

      A missing key implies that the corresponding item of information is
      not available.

      Finally, the returned KeyMap has an entry with key {\tt "}MXLEN{\tt "} that is
      again a pointer to another KeyMap with the same entries listed above.
      However, this time the entries are integers, not strings, and holds
      the maximum field width used to format the strings. Also, all
      entries are guaranteed to be present in the keymap (but may hold
      zero if none of the ancestors contained a particular item of
      information).
   }
   \sstinvocation{
      CALL NDG\_FMPRV( INDF, BASE, KEYMAP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         An identifier for the NDF containing the provenance information.
      }
      \sstsubsection{
         BASE = LOGICAL (Given)
      }{
         If .TRUE., then the PATH field in the returned KeyMap holds the
         base name of each NDF rather than the full path.
      }
      \sstsubsection{
         KEYMAP = INTEGER (Returned)
      }{
         A pointer to the returned AST KeyMap.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   NDG\_GTPRV
}{
   Get provenance information from an NDF
}{
   \sstdescription{
      This routine returns information from the {\tt "}PROVENANCE{\tt "} extension
      in INDF, describing the ancestor NDF with a given index.
   }
   \sstinvocation{
      CALL NDG\_GTPRV( INDF, IANC, PROV, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         An identifier for the NDF containing the provenance information.
      }
      \sstsubsection{
         IANC = INTEGER (Given)
      }{
         The index of the ancestor NDF for which information should be
         returned. A value of zero will result in information about the NDF
         specified by INDF being returned. Otherwise, the IANC value
         is used as an index into the ANCESTORS array in the PROVENANCE
         extension. No error is reported if IANC is too large (i.e.
         larger than the value returned by NDG\_CTPRV), but DAT\_\_NOLOC
         will be returned for PROV.
      }
      \sstsubsection{
         PROV = CHARACTER $*$ (DAT\_\_SZLOC) (Returned)
      }{
         A locator for a temporary HDS object containing the following
         components:

         \sstitemlist{

            \sstitem
            {\tt "}PATH{\tt "}: A string holding the path of the ancestor NDF.

            \sstitem
            {\tt "}DATE{\tt "}: A string holding the formatted UTC date and time at
              which the provenance information for the ancestor NDF was
              recorded.

            \sstitem
            {\tt "}CREATOR{\tt "}: A string identifying the software that created the
              ancestor NDF.

            \sstitem
            {\tt "}MORE{\tt "}: Any extra information stored with the ancestor.

            \sstitem
            {\tt "}PARENTS{\tt "}: A 1D vector of integers that are the indices of the
              immediate parents of the ancestor.

         }
         If the specified ancestor does not have any of these items of
         information, then the corresponding component will not be
         present in the returned HDS object. For instance, if the
         ancestor has no immediate parent NDFs, then the {\tt "}PARENTS{\tt "}
         component will not be present in the returned HDS object. The
         returned locator should be annulled using DAT\_ANNUL when no
         longer needed.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}

\sstroutine{
   NDG\_GTSUP
}{
   Get supplemental information for an NDF
}{
   \sstdescription{
      Returns the supplemental information associated with a given entry
      in an NDG group.
   }
   \sstinvocation{
      CALL NDG\_GTSUP( IGRP, I, FIELDS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         The NDG group as returned by NDG\_ASSOC, etc. This should be the last
         group in a GRP owner-slave chain.
      }
      \sstsubsection{
         I = INTEGER (Given)
      }{
         The index of the required entry.
      }
      \sstsubsection{
         FIELDS( 6 ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The supplemental information associated with the entry specified
         by I. Each element of the returned array contains the following:
         \begin{enumerate}
            \item NDF slice specification (if any)
            \item HDS path (if any)
            \item File type
            \item Base file name
            \item Directory path
            \item Full NDF specification
         \end{enumerate}

         This information is obtained from a set of groups associated with
         the supplied group IGRP by means of a chain of GRP {\tt "}owner-slave{\tt "}
         relationships. If any of these groups do not exist, the correponding
         elements of the above array are returned blank. Note, element 6,
         the full NDF specification, is obtained directly from the supplied
         group IGRP.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}

\sstroutine{
   NDG\_MDPRV
}{
   Get provenance information from an NDF
}{
   \sstdescription{
      This routine modifies the information stored for a given ancestor
      in the {\tt "}PROVENANCE{\tt "} extension of an NDF. The new values to store
      are supplied in an HDS structure such as is returned by NDG\_GTPRV.
   }
   \sstinvocation{
      CALL NDG\_MDPRV( INDF, IANC, PROV, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         An identifier for the NDF containing the provenance information.
      }
      \sstsubsection{
         IANC = INTEGER (Given)
      }{
         The index of the ancestor NDF for which information should be
         modified. A value of zero will result in information about the NDF
         specified by INDF being modified. Otherwise, the IANC value
         is used as an index into the ANCESTORS array in the PROVENANCE
         extension. An error is reported if IANC is too large.
      }
      \sstsubsection{
         PROV = CHARACTER $*$ (DAT\_\_SZLOC) (Returned)
      }{
         A locator for an HDS object containing the values to store. It
         should have at least the following components:

         \sstitemlist{

            \sstitem
            {\tt "}PATH{\tt "}: A string holding the path of the ancestor NDF.

            \sstitem
            {\tt "}DATE{\tt "}: A string holding the formatted UTC date and time at
              which the provenance information for the ancestor NDF was
              recorded.

            \sstitem
            {\tt "}CREATOR{\tt "}: A string identifying the software that created the
              ancestor NDF.

            \sstitem
            {\tt "}MORE{\tt "}: Any extra information stored with the ancestor.

         }
         If the {\tt "}DATE{\tt "}, {\tt "}CREATOR{\tt "} or {\tt "}MORE{\tt "} components are missing then
         the corresponding item of information will be deleted from the
         provenance extension. An error is reported if {\tt "}PATH{\tt "} is missing.
         Note, the PARENTS list stored with the specified ancestor cannot
         be modified (any {\tt "}PARENTS{\tt "} component in the supplied HDS structure
         will be ignored).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}

\sstroutine{
   NDF\_MOREG
}{
   Search for NDFs within the extensions of a supplied NDF
}{
   \sstdescription{
      Each extension within the supplied NDF is searched to see if it
      contains any NDFs. The paths to any such NDFs are appended to the
      end of the supplied group (a new group is created if none is
      supplied). NDF identifiers for particular members of the group can
      be obtained using NDG\_NDFAS.
   }
   \sstinvocation{
      CALL NDF\_MOREG( INDF, IGRP, SIZE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         The identifier for the NDF to be searched.
      }
      \sstsubsection{
         IGRP = INTEGER (Given and Returned)
      }{
         The identifier of the group in which NDF names are to be
         stored. A new group is created if the supplied value is GRP\_\_NOID.
         It should be deleted when no longer needed using GRP\_DELET.
      }
      \sstsubsection{
         SIZE = INTEGER (Returned)
      }{
         The total number of NDF names in the returned group IGRP.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Each element in the returned group contains a full specification
         for an NDF. Several other groups are created by this routine, and
         are associated with the returned group by means of a GRP {\tt "}owner-slave{\tt "}
         relationship. These supplemental groups are automatically deleted
         when the returned group is deleted using GRP\_DELET. The returned
         group should not be altered using GRP directly because corresponding
         changes may need to be made to the supplemental groups. Routines
         NDG\_SETSZ, NDG\_GTSUP and NDG\_PTSUP are provided to manipulate the
         entire chain of groups. The full chain (starting from the head) is
         as follows:

         \sstitem
            NDF slice specifications

         \sstitem
            HDS paths

         \sstitem
            File types

         \sstitem
            Base file names

         \sstitem
            Directory paths

         \sstitem
            Full NDF specification (this is the returned group IGRP)
      }
   }
}

\sstroutine{
   NDG\_NDFAS
}{
   Obtain an NDF identifier for an existing NDF
}{
   \sstdescription{
      The routine returns an NDF identifier for an existing NDF. The
      name of the NDF is held at a given index within a given group.
      It is equivalent to NDF\_ASSOC.
   }
   \sstinvocation{
      CALL NDG\_NDFAS( IGRP, INDEX, MODE, INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         A GRP identifier for a group holding the names of NDFs. This
         will often be creted using NDG\_ASSOC, but groups created {\tt "}by
         hand{\tt "} using GRP directly (i.e. without the supplemental groups
         created by NDG\_ASSOC) can also be used.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index within the group at which the name of the NDF to be
         accessed is stored.
      }
      \sstsubsection{
         MODE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Type of NDF access required: {\tt '}READ{\tt '}, {\tt '}UPDATE{\tt '} or {\tt '}WRITE{\tt '}.
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If this routine is called with STATUS set, then a value of
         NDF\_\_NOID will be returned for the INDF argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. The NDF\_\_NOID
         constant is defined in the include file NDF\_PAR.
      }
   }
}

\sstroutine{
   NDG\_NDFCO
}{
   Obtain an NDF identifier for a new NDF created by copying an existing NDF
}{
   \sstdescription{
      The routine returns an NDF identifier for a new NDF created by
      copying an existing NDF. The name of the new NDF is held
      at a given index within a given group. It is equivalent to NDF\_PROP.
   }
   \sstinvocation{
      CALL NDG\_NDFCO( INDF1, IGRP, INDEX, INDF2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF1 = INTEGER (Given)
      }{
         Identifier for an existing NDF (or NDF section) to act as a
         template.
      }
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         A GRP identifier for a group holding the names of NDFs. This
         will often be creted using NDG\_ASSOC, but groups created {\tt "}by
         hand{\tt "} using GRP directly (i.e. without the supplemental groups
         created by NDG\_ASSOC) can also be used.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index within the group at which the name of the NDF to be
         accessed is stored.
      }
      \sstsubsection{
         INDF2 = INTEGER (Returned)
      }{
         Identifier for the new NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If this routine is called with STATUS set, then a value of
         NDF\_\_NOID will be returned for the INDF2 argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. The NDF\_\_NOID
         constant is defined in the include file NDF\_PAR.
      }
   }
}

\sstroutine{
   NDG\_NDFCP
}{
   Obtain an NDF identifier for a new primitive NDF
}{
   \sstdescription{
      The routine returns an NDF identifier for a new primitive NDF created
      with the specified attributes. The name of the new NDF is held
      at a given index within a given group. It is equivalent to NDF\_CREP.
   }
   \sstinvocation{
      CALL NDG\_NDFCP( IGRP, INDEX, FTYPE, NDIM, UBND, INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         A GRP identifier for a group holding the names of NDFs. This
         will often be creted using NDG\_ASSOC, but groups created {\tt "}by
         hand{\tt "} using GRP directly (i.e. without the supplemental groups
         created by NDG\_ASSOC) can also be used.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index within the group at which the name of the NDF to be
         created is stored.
      }
      \sstsubsection{
         FTYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Type of the NDF{\tt '}s DATA component (e.g. {\tt '}\_REAL{\tt '}). Note that
         complex types are not permitted when creating a primitive NDF.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of NDF dimensions.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         Upper pixel-index bounds of the NDF (the lower bound of each
         dimension is taken to be 1).
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}

\sstroutine{
   NDG\_NDFCR
}{
   Obtain an NDF identifier for a new simple NDF
}{
   \sstdescription{
      The routine returns an NDF identifier for a new simple NDF created
      with the specified attributes. The name of the new NDF is held
      at a given index within a given group. It is equivalent to NDF\_CREAT.
   }
   \sstinvocation{
      CALL NDG\_NDFCR( IGRP, INDEX, FTYPE, NDIM, LBND, UBND, INDF,
                      STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         A GRP identifier for a group holding the names of NDFs. This
         will often be creted using NDG\_CREAT, but groups created {\tt "}by
         hand{\tt "} using GRP directly can also be used.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index within the group at which the name of the NDF to be
         created is stored.
      }
      \sstsubsection{
         FTYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Full data type of the NDF{\tt '}s DATA component (e.g. {\tt '}\_DOUBLE{\tt '} or
         {\tt '}COMPLEX\_REAL{\tt '}).
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of NDF dimensions.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Given)
      }{
         Lower pixel-index bounds of the NDF.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         Upper pixel-index bounds of the NDF.
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}

\sstroutine{
   NDG\_NDFPR
}{
   Obtain an NDF identifier for a new NDF created by propagation from
   an existing NDF
}{
   \sstdescription{
      The routine returns an NDF identifier for a new NDF created by
      propagation from an existing NDF. The name of the new NDF is held
      at a given index within a given group. It is equivalent to NDF\_PROP.
   }
   \sstinvocation{
      CALL NDG\_NDFPR( INDF1, CLIST, IGRP, INDEX, INDF2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF1 = INTEGER (Given)
      }{
         Identifier for an existing NDF (or NDF section) to act as a
         template.
      }
      \sstsubsection{
         CLIST = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A comma-separated list of the NDF components which are to be
         propagated to the new data structure. By default, the HISTORY,
         LABEL and TITLE components and all extensions are propagated.
      }
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         A GRP identifier for a group holding the names of NDFs. This
         will often be creted using NDG\_ASSOC, but groups created {\tt "}by
         hand{\tt "} using GRP directly (i.e. without the supplemental groups
         created by NDG\_ASSOC) can also be used.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index within the group at which the name of the NDF to be
         accessed is stored.
      }
      \sstsubsection{
         INDF2 = INTEGER (Returned)
      }{
         Identifier for the new NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If this routine is called with STATUS set, then a value of
         NDF\_\_NOID will be returned for the INDF2 argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. The NDF\_\_NOID
         constant is defined in the include file NDF\_PAR.
      }
   }
}

\sstroutine{
   NDG\_PROP1
}{
   Create a single new NDF by propagation using a specified parameter
}{
   \sstdescription{
      This routine is equivalent to NDF\_PROP except that it allows the
      NDF to be specified using a GRP group expression (for instance, its
      name may be given within a text file, etc). The first NDF in the
      group expression is returned. Any other names in the group
      expression are ignored. Modification elements use the name of the
      supplied NDF as the basis name.
   }
   \sstinvocation{
      CALL NDG\_PROP1( INDF1, CLIST, PARAM, INDF2, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF1 = INTEGER (Given)
      }{
         Identifier for an existing NDF (or NDF section) to act as a
         template.
      }
      \sstsubsection{
         CLIST = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A comma-separated list of the NDF components which are to be
         propagated to the new data structure. By default, the HISTORY,
         LABEL and TITLE components and all extensions are propagated.
      }
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the ADAM parameter for the new NDF.
      }
      \sstsubsection{
         INDF2 = INTEGER (Returned)
      }{
         Identifier for the new NDF.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The full file specification for the NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}

\sstroutine{
   NDG\_PTPRV
}{
   Add provenance information to an NDF
}{
   \sstdescription{
      This routine stores information in the {\tt "}PROVENANCE{\tt "} extension of
      INDF1 indicating that INDF2 was used in the creation of INDF1.
      The provenance information is stored in an NDF extension call
      {\tt "}PROVENANCE{\tt "}.
   }
   \sstinvocation{
      CALL NDG\_PTPRV( INDF1, INDF2, MORE, ISROOT, CREATR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF1 = INTEGER (Given)
      }{
         An identifier for a newly created NDF.
      }
      \sstsubsection{
         INDF2 = INTEGER (Given)
      }{
         An identifier for an NDF that was used in the creation of INDF1.
      }
      \sstsubsection{
         MORE = CHARACTER $*$ (DAT\_\_SZLOC) (Given)
      }{
         A locator for an HDS structure containing arbitrary additional
         information about INDF2, and how INDF2 was used in the creation
         of INDF1. This information is stored in the provenance extension
         of INDF1.
      }
      \sstsubsection{
         ISROOT = LOGICAL (Given)
      }{
         If TRUE, then INDF2 will be treated as a root NDF. That is,
         any provenance information in INDF2 is ignored. If FALSE, then
         any provenance information in INDF2 is copied into INDF1. INDF2
         is then only a root NDF if it contains no provenance information.
      }
      \sstsubsection{
         CREATR = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A text identifier for the software that created INDF1 (usually the
         name of the calling application). The format of the identifier
         is arbitrary, but the form {\tt "}PACKAGE:COMMAND{\tt "} is recommended.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The PROVENANCE extension in an NDF contains four components:
         {\tt "}PARENTS{\tt "}, {\tt "}ANCESTORS{\tt "}, {\tt "}CREATOR{\tt "} and {\tt "}DATE{\tt "}. The DATE component is
         a character string holding the date and time at which the information
         in the provenance extension was last modified. The date is UTC
         formatted by PSX\_ASCTIME. The ANCESTORS component is a 1D array
         of {\tt "}PROV{\tt "} structures (described below). Each element describes a
         single NDF that was used in the creation of the main NDF, either
         directly or indirectly. The PARENTS component is a 1D integer
         array holding the indices within the ANCESTORS array of the NDFs
         that are the direct parents of the main NDF. The CREATOR component
         holds an arbitrary identifier for the software that created the
         main NDF.

         \sstitem
         Each PROV structure describes a single NDF that was used in the
         creation of the main NDF, and contains up to four components; {\tt "}PARENTS{\tt "},
         {\tt "}DATE{\tt "}, {\tt "}PATH{\tt "}, {\tt "}CREATOR{\tt "} and {\tt "}MORE{\tt "}. If present, the PARENTS component
         is a 1D integer array holding the the indices within the ANCESTORS array
         of the direct parents of the ancestor NDF. If PARENTS is not present,
         the ancestor NDF is a {\tt "}root{\tt "} NDF (that is, it has no known parents).
         If present, the DATE component is a string holding the formatted UTC
         date at which the provenance information for the ancestor NDF was
         determined. If this date is not known, the DATE component will not
         be present (this will be the case, for instance, for all root NDFs).
         The PATH component will always be present, and is a string holding
         the full path to the ancestor NDF. This includes any HDS path
         within the container file, but will not include any NDF or HDS section
         specifier. Neither will it include the trailing {\tt "}.sdf{\tt "} suffix. If
         present, the MORE component is an arbitrary HDS structure in which
         any extra information about the ancestor NDF can be stored. The
         CREATOR component holds an arbitrary identifier for the software that
         created the ancestor NDF.
      }
   }
}

\sstroutine{
   NDG\_PTSUP
}{
   Store suplemental information for an NDF
}{
   \sstdescription{
      Stores the supplied items of supplemental information for a given
      entry in an NDG group. The GRP groups needed to store this
      supplemental information are created if they do not already exist,
      and associated with the supplied group by means of a chain of GRP
      {\tt "}owner-slave{\tt "} relationships. They will be deleted automaticaly when
      the supplied group is deleted using GRP\_DELET.
   }
   \sstinvocation{
      CALL NDG\_PTSUP( IGRP, I, FIELDS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         The NDG group as returned by NDG\_ASSOC, etc. This should be the last
         group in a GRP owner-slave chain.
      }
      \sstsubsection{
         I = INTEGER (Given)
      }{
         The index of the required entry.
      }
      \sstsubsection{
         FIELDS( 6 ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The supplemental information to be stored with the entry specified
         by I. Each element of the supplied array should contain the
         following:
            \begin{enumerate}
            \item NDF slice specification (if any)
            \item HDS path (if any)
            \item File type
            \item Base file name
            \item Directory path
            \item Full NDF specification
            \end{enumerate}
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}

\sstroutine{
   NDG\_RMPRV
}{
   Remove provenance information from an NDF
}{
   \sstdescription{
      This routine removes a given ancestor from the {\tt "}PROVENANCE{\tt "}
      extension in INDF. The direct parents of the removed ancestor are
      assigned to the direct children of the removed ancestor.
   }
   \sstinvocation{
      CALL NDG\_RMPRV( INDF, IANC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         An identifier for the NDF containing the provenance information.
      }
      \sstsubsection{
         IANC = INTEGER (Given)
      }{
         The index of the ancestor NDF to be removed. The supplied value
         must be at least 1, and must be no more than the number of
         ancestors in the provenance extension (as returned by NDG\_CTPRV).
         An error is reported otherwise.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}

\sstroutine{
   NDG\_RTPRV
}{
   Identify the root ancestors of an NDF
}{
   \sstdescription{
      This routine uses the PROVENANCE extension of the supplied NDF to
      obtain and return information identifying the root ancestors of
      the supplied NDF. An ancestor is a root ancestor if it does not itself
      have any ancestors.
   }
   \sstinvocation{
      CALL NDG\_RTPRV( INDF, ROOTS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         An identifier for the NDF containing the provenance information.
      }
      \sstsubsection{
         ROOTS = INTEGER (Returned)
      }{
         A pointer to a new AST KeyMap. This KeyMap will contain an entry for
         each root ancestor. The key associated with each entry is the path
         to the NDF and the value of the entry is an integer that gives the
         position of the root ancestor within the list of all ancestors. This
         integer value can be supplied to ndgGtprv in order to get further
         information about the root ancestor.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}

\sstroutine{
   NDG\_SETSZ
}{
   Reduces the size of an NDG group
}{
   \sstdescription{
      This routine should be used instead of GRP\_SETSZ to set the size of
      a group created by NDG. It sets the size of the supplied group, and
      also sets the size of each of the aupplemental groups associated with
      the supplied group.
   }
   \sstinvocation{
      CALL NDG\_SETSZ( IGRP, SIZE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         The NDG group as returned by NDG\_ASSOC, etc. This should be the last
         group in a GRP owner-slave chain.
      }
      \sstsubsection{
         SIZE = INTEGER (Given)
      }{
         The new group size. Must be less than or equal to the size of the
         smallest group in the chain.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}

\newpage

\section{Full C Function Specifications}

\sstroutine{
   ndgCtprv
}{
   Count the number of ancestors used in the creation of an NDF
}{
   \sstdescription{
      This routine returns the number of ancestors described in the
      {\tt "}PROVENANCE{\tt "} extension of the supplied INDF.
   }
   \sstinvocation{
      void ndgCtprv( int indf, int $*$nanc, int $*$status )
   }
   \sstarguments{
      \sstsubsection{
         indf
      }{
         An identifier for the NDF containing the provenance information.
      }
      \sstsubsection{
         nanc
      }{
         Pointer to an int in which to returned the number of ancestor NDFs
         stored in the provenance information of INDF.
      }
      \sstsubsection{
         status
      }{
         The global status.
      }
   }
}
\sstroutine{
   ndgFmprv
}{
   Format the provenance information from an NDF
}{
   \sstdescription{
      This routine returns an AST KeyMap holding a set of text strings
      containing information taken from the {\tt "}PROVENANCE{\tt "} extension in INDF.

      The returned KeyMap has an entry with key {\tt "}0{\tt "} that describes the
      supplied NDF. It also has an entry describing each ancestor NDF.
      These entries have keys {\tt "}1{\tt "}, {\tt "}2{\tt "}, {\tt "}3{\tt "}, etc, up to the number of
      ancestors in the NDF.

      Each of these entries contains a pointer to another AST KeyMap
      which may contain any subset of the following entries (all of which
      are strings):

      {\tt "}ID{\tt "} - the integer index within the ancestors array (zero for the
             main NDF).

      {\tt "}PATH{\tt "} - The full path or base name for the NDF (see {\tt "}base{\tt "}).

      {\tt "}DATE{\tt "} - The date of creation of the NDF.

      {\tt "}CREATOR{\tt "} - The software item that created the NDF.

      {\tt "}PARENTS{\tt "} - A comma separated list of indicies into the ancestors
                  array that identifies the direct parents of the NDF.

      {\tt "}MORE{\tt "} - A summary of the contents of the MORE structure associated
               with the NDF.

      Finally, the returned KeyMap has an entry with key {\tt "}MXLEN{\tt "} that is
      again a pointer to another KeyMap with the same entries listed above.
      However, this time the entries are integers, not strings, and holds
      the maximum field width used to format the strings.
   }
   \sstinvocation{
      void ndgFmprv( int indf, int base, AstKeyMap $*$$*$keymap, int $*$status )
   }
   \sstarguments{
      \sstsubsection{
         indf
      }{
         An identifier for the NDF containing the provenance information.
      }
      \sstsubsection{
         base
      }{
         If non-zero, then the PATH field in the returned KeyMap holds the
         base name of each NDF rather than the full path.
      }
      \sstsubsection{
         keymap
      }{
         A location at which to returned a pointer to the returned AST KeyMap.
      }
      \sstsubsection{
         status
      }{
         The global status.
      }
   }
}
\sstroutine{
   ndgGtprv
}{
   Get provenance information from an NDF
}{
   \sstdescription{
      This routine returns information from the {\tt "}PROVENANCE{\tt "} extension
      in INDF, describing the ancestor NDF with a given index.
   }
   \sstinvocation{
      void ndgGtprv( int indf, int ianc, HDSLoc $*$$*$prov, int $*$status )
   }
   \sstarguments{
      \sstsubsection{
         indf
      }{
         An identifier for the NDF containing the provenance information.
      }
      \sstsubsection{
         ianc
      }{
         The index of the ancestor NDF for which information should be
         returned. A value of zero will result in information about the NDF
         specified by {\tt "}indf{\tt "} being returned. Otherwise, the {\tt "}ianc{\tt "} value
         is used as an index into the ANCESTORS array in the PROVENANCE
         extension. No error is reported if {\tt "}ianc{\tt "} is too large, but a
         NULL pointer will be returned for {\tt "}prov{\tt "}.
      }
      \sstsubsection{
         prov
      }{
         The location at which to return a pointer to a locator for a
         temporary HDS object containing the following components:

         \sstitemlist{

            \sstitem
            {\tt "}PATH{\tt "}: A string holding the path of the ancestor NDF.

            \sstitem
            {\tt "}DATE{\tt "}: A string holding the formatted UTC date and time at
              which the provenance information for the ancestor NDF was
              recorded.

            \sstitem
            {\tt "}CREATOR{\tt "}: A string identifying the software that created the
              ancestor NDF.

            \sstitem
            {\tt "}MORE{\tt "}: Any extra information stored with the ancestor.

            \sstitem
            {\tt "}PARENTS{\tt "}: A 1D vector of integers that are the indices of the
              immediate parents of the ancestor.

         }
         If the specified ancestor does not have any of these items of
         information, then the corresponding component will not be
         present in the returned HDS object. For instance, if the
         ancestor has no immediate parent NDFs, then the {\tt "}PARENTS{\tt "}
         component will not be present in the returned HDS object. The
         returned locator should be annulled using datAnnul when no
         longer needed.
      }
      \sstsubsection{
         status
      }{
         The global status.
      }
   }
}
\sstroutine{
   ndgGtprvk
}{
   Create a KeyMap holding provenance information from an NDF
}{
   \sstdescription{
      This routine returns information from the {\tt "}PROVENANCE{\tt "} extension
      in INDF, describing the ancestor NDF with a given index. It is
      similar to ndgGtprv except that the nformation is returned in the
      form of an AST KeyMap rather than an HDS structure.
   }
   \sstinvocation{
      void ndgGtprvk( int indf, int ianc, AstKeyMap $*$$*$prov, HDSLoc $*$$*$more,
                      int $*$status )
   }
   \sstarguments{
      \sstsubsection{
         indf
      }{
         An identifier for the NDF containing the provenance information.
      }
      \sstsubsection{
         ianc
      }{
         The index of the ancestor NDF for which information should be
         returned. A value of zero will result in information about the NDF
         specified by {\tt "}indf{\tt "} being returned. Otherwise, the {\tt "}ianc{\tt "} value
         is used as an index into the ANCESTORS array in the PROVENANCE
         extension. No error is reported if {\tt "}ianc{\tt "} is too large (i.e.
         larger than the value returned by ndgCtprv), but NULL will be
         returned in {\tt "}$*$prov{\tt "}.
      }
      \sstsubsection{
         prov
      }{
         The location at which to return a pointer to an AST KeyMap
         containing entries with the following keys and values:

         \sstitemlist{

            \sstitem
            {\tt "}PATH{\tt "}: A string holding the path of the ancestor NDF.

            \sstitem
            {\tt "}DATE{\tt "}: A string holding the formatted UTC date and time at
              which the provenance information for the ancestor NDF was
              recorded.

            \sstitem
            {\tt "}CREATOR{\tt "}: A string identifying the software that created the
              ancestor NDF.

            \sstitem
            {\tt "}PARENTS{\tt "}: A 1D vector of integers that are the indices of the
              immediate parents of the ancestor.

            \sstitem
            {\tt "}MORE{\tt "}: A KeyMap containing extra scalar information stored
            with the ancestor. Only scalar items stored directly within the
            top level of the MORE structure are returned in the KeyMap. The
            HDS name of the component is used as the key. The full contents
            of the MORE structure are returned by the {\tt "}more{\tt "} parameter (see
            below).

         }
         If the specified ancestor does not have any of these items of
         information, then the corresponding entry will not be present
         in the returned KeyMap. For instance, if the ancestor has no
         immediate parent NDFs, then the {\tt "}PARENTS{\tt "} entry will not be
         present in the KeyMap. A NULL pointer will be returned if the
         NDF has no provenance extension, or if {\tt "}ianc{\tt "} is outside the
         bounds of the ANCESTORS array (and is not zero).
      }
      \sstsubsection{
         more
      }{
         The location at which to return a pointer to a locator for a
         temporary HDS object containing a full deep copy of the MORE
         structure associated with the requested ancestor. The
         returned locator should be annulled using datAnnul when no
         longer needed. A NULL pointer may be supplied for this parameter
         if the MORE structure is not needed. A NULL pointer will be
         returned if the requested ancestor has no MORE component. Note,
         the returned object will be assigned an arbitrary HDS Name,
         which will not in general be {\tt "}MORE{\tt "}.
      }
      \sstsubsection{
         status
      }{
         The global status.
      }
   }
}
\sstroutine{
   ndgPtprv
}{
   Add provenance information to an NDF
}{
   \sstdescription{
      This routine stores information in the {\tt "}PROVENANCE{\tt "} extension of
      INDF1 indicating that INDF2 was used in the creation of INDF1.
      The provenance information is stored in an NDF extension call
      {\tt "}PROVENANCE{\tt "}.
   }
   \sstinvocation{
      void ndgPtprv( int indf1, int indf2, HDSLoc $*$more, int isroot,
                     const char $*$creator, int $*$status )
   }
   \sstarguments{
      \sstsubsection{
         indf1
      }{
         An identifier for a newly created NDF.
      }
      \sstsubsection{
         indf2
      }{
         An identifier for an NDF that was used in the creation of INDF1.
      }
      \sstsubsection{
         more
      }{
         A locator for an HDS structure containing arbitrary additional
         information about INDF2, and how INDF2 was used in the creation
         of INDF1. This information is stored in the provenance extension
         of INDF1.
      }
      \sstsubsection{
         isroot
      }{
         If non-zero, then INDF2 will be treated as a root NDF. That is,
         any provenance information in INDF2 is ignored. If zero, then
         any provenance information in INDF2 is copied into INDF1. INDF2
         is then only a root NDF if it contains no provenance information.
      }
      \sstsubsection{
         creator
      }{
         A text identifier for the software that created INDF1 (usually the
         name of the calling application). The format of the identifier
         is arbitrary, but the form {\tt "}PACKAGE:COMMAND{\tt "} is recommended.
      }
      \sstsubsection{
         status
      }{
         The global status.
      }
   }
}
\sstroutine{
   ndgRmprv
}{
   Remove provenance information from an NDF
}{
   \sstdescription{
      This routine removes a given ancestor from the {\tt "}PROVENANCE{\tt "}
      extension in INDF. The direct parents of the removed ancestor are
      assigned to the direct children of the removed ancestor.
   }
   \sstinvocation{
      void ndgRmprv( int indf, int ianc, int $*$status )
   }
   \sstarguments{
      \sstsubsection{
         indf
      }{
         An identifier for the NDF containing the provenance information.
      }
      \sstsubsection{
         ianc
      }{
         The index of the ancestor NDF to be removed. The supplied value
         must be at least 1, and must be no more than the number of
         ancestors in the provenance extension (as returned by NDG\_CTPRV).
         An error is reported otherwise.
      }
      \sstsubsection{
         status
      }{
         The global status.
      }
   }
}
\sstroutine{
   ndgRmprvs
}{
   Remove multiple ancestors from the provenance information in an NDF
}{
   \sstdescription{
      This routine removes one or more ancestors from the {\tt "}PROVENANCE{\tt "}
      extension in INDF. The direct parents of the removed ancestor are
      assigned to the direct children of the removed ancestor.

      Using this function once is more efficient than calling ndgRmprv
      to remove each individual ancestor.
   }
   \sstinvocation{
      void ndgRmprv( int indf, int nanc, int $*$anc, int $*$status )
   }
   \sstarguments{
      \sstsubsection{
         indf
      }{
         An identifier for the NDF containing the provenance information.
      }
      \sstsubsection{
         nanc
      }{
         The length of the {\tt "}anc{\tt "} array.
      }
      \sstsubsection{
         anc
      }{
         Pointer to an array holding the indices of the ancestor NDFs to be
         removed. Each supplied value must be at least 1, and must be no
         more than the number of ancestors in the provenance extension
         (as returned by NDG\_CTPRV). An error is reported otherwise. The
         supplied list is sorted into decreasing order before use so that
         the highest index ancestor is removed first.
      }
      \sstsubsection{
         status
      }{
         The global status.
      }
   }
}
\sstroutine{
   ndgRtprv
}{
   Identify the root ancestors of an NDF
}{
   \sstdescription{
      This routine uses the PROVENANCE extension of the supplied NDF to
      obtain and return information identifying the root ancestors of
      the supplied NDF. An ancestor is a root ancestor if it does not itself
      have any ancestors.
   }
   \sstinvocation{
      void ndgRtprv( int indf, AstKeyMap $*$$*$roots, int $*$status )
   }
   \sstarguments{
      \sstsubsection{
         indf
      }{
         An identifier for the NDF containing the provenance information.
      }
      \sstsubsection{
         roots
      }{
         A location at which to return a pointer to an AST KeyMap. This
         KeyMap will contain an entry for each root ancestor. The key
         associated with each entry is the path to the NDF and the value
         of the entry is an integer that gives the position of the root
         ancestor within the list of all ancestors. This integer value
         can be supplied to ndgGtprv in order to get further information
         about the root ancestor.
      }
      \sstsubsection{
         status
      }{
         The global status.
      }
   }
}
\sstroutine{
   ndgMdprv
}{
   Modify provenance information in an NDF
}{
   \sstdescription{
      This routine modifies the information stored for a given ancestor
      in the {\tt "}PROVENANCE{\tt "} extension of an NDF. The new values to store
      are supplied in an HDS structure such as is returned by ndgGtprv.
   }
   \sstinvocation{
      void ndgMdprv( int indf, int ianc, HDSLoc $*$prov, int $*$status )
   }
   \sstarguments{
      \sstsubsection{
         indf
      }{
         An identifier for the NDF containing the provenance information.
      }
      \sstsubsection{
         ianc
      }{
         The index of the ancestor NDF for which information should be
         modified. A value of zero will result in information about the NDF
         specified by {\tt "}indf{\tt "} being modified. Otherwise, the {\tt "}ianc{\tt "} value
         is used as an index into the ANCESTORS array in the PROVENANCE
         extension. An error is reported if {\tt "}ianc{\tt "} is too large.
      }
      \sstsubsection{
         prov
      }{
         A locator for an HDS object containing the values to store. It
         should have at least the following components:

         \sstitemlist{

            \sstitem
            {\tt "}PATH{\tt "}: A string holding the path of the ancestor NDF.

            \sstitem
            {\tt "}DATE{\tt "}: A string holding the formatted UTC date and time at
              which the provenance information for the ancestor NDF was
              recorded.

            \sstitem
            {\tt "}CREATOR{\tt "}: A string identifying the software that created the
              ancestor NDF.

            \sstitem
            {\tt "}MORE{\tt "}: Any extra information stored with the ancestor.

         }
         If the {\tt "}DATE{\tt "}, {\tt "}CREATOR{\tt "} or {\tt "}MORE{\tt "} components are missing then
         the corresponding item of information will be deleted from the
         provenance extension. An error is reported if {\tt "}PATH{\tt "} is missing.
         Note, the PARENTS list stored with the specified ancestor cannot
         be modified (any {\tt "}PARENTS{\tt "} component in the supplied HDS structure
         will be ignored).
      }
      \sstsubsection{
         status
      }{
         The global status.
      }
   }
}


\section{Changes Introduced in NDG Version 5.6}
\begin{itemize}
   \item A new C function ndgRmprvs has been added, that removes multiple
         provenance ancestors from an NDF.
   \item A new C function ndgGtprvk has been added, that returns provenance
         information for a given ancestor in the form of an AST KeyMap.
\end{itemize}

\section{Changes Introduced in NDG Version 5.5}
\begin{itemize}
   \item A new routine NDG\_MOREG has been added which searchs the
         extensions of a supplied NDF for encapsulated NDFs, appending
         the paths to such NDFs to a supplied GRP group.
\end{itemize}

\section{Changes Introduced in NDG Version 5.4}
\begin{itemize}
   \item Added new routines: NDG\_MDPRV.
\end{itemize}

\section{Changes Introduced in NDG Version 5.3}
\begin{itemize}
   \item Added routines for storing and retrieving provenance information:
         NDG\_PTPRV, NDG\_RTPRV, NDG\_GTPRV, NDG\_BEGPV and NDG\_ENDPV.
\end{itemize}

\section{Changes Introduced in NDG Version 5.2}
\begin{itemize}
   \item The C routine ndg1\_regsb.c has been changed to avoid warning 
         message about "tmpnam" when linking applications on Redhat Linux 
	 systems.
\end{itemize}

\section{Changes Introduced in NDG Version 5.1}
\begin{itemize}
   \item A new routine NDG\_ASEXP has been added which allows a group of
         existing NDFs to be created from a group expression supplied as 
         a subroutine argument. This is very similar to NDG\_ASSOC except
         that NDG\_ASSOC gets the group expression from the parameter system
         instead of from its argument list.
\end{itemize}

\end{document}
