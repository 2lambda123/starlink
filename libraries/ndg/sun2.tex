\documentstyle[11pt]{article}
\pagestyle{myheadings}

% -----------------------------------------------------------------------------
% ? Document identification
%------------------------------------------------------------------------------
\newcommand{\stardoccategory}  {Starlink User Note}
\newcommand{\stardocinitials}  {SUN}
\newcommand{\stardocsource}    {sun2.5}
\newcommand{\stardocnumber}    {2.5}
\newcommand{\stardocauthors}   {D.S.\ Berry \\ M.B.\ Taylor}
\newcommand{\stardocdate}      {12th November 2004}
\newcommand{\stardoctitle}     {NDG \\ [1ex]
                                Routines for Accessing Groups of NDFs}
\newcommand{\stardocversion}   {Version 5.2}
\newcommand{\stardocmanual}    {Programmer's Manual}
% ? End of document identification
% -----------------------------------------------------------------------------

\newcommand{\stardocname}{\stardocinitials /\stardocnumber}
\markright{\stardocname}
\setlength{\textwidth}{160mm}
\setlength{\textheight}{230mm}
\setlength{\topmargin}{-2mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\setlength{\unitlength}{1mm}

% -----------------------------------------------------------------------------
%  Hypertext definitions.
%  ======================
%  These are used by the LaTeX2HTML translator in conjunction with star2html.

%  Comment.sty: version 2.0, 19 June 1992
%  Selectively in/exclude pieces of text.
%
%  Author
%    Victor Eijkhout                                      <eijkhout@cs.utk.edu>
%    Department of Computer Science
%    University Tennessee at Knoxville
%    104 Ayres Hall
%    Knoxville, TN 37996
%    USA

%  Do not remove the %\begin{rawtex} and %\end{rawtex} lines (used by
%  star2html to signify raw TeX that latex2html cannot process).
%\begin{rawtex}
\makeatletter
\def\makeinnocent#1{\catcode`#1=12 }
\def\csarg#1#2{\expandafter#1\csname#2\endcsname}

\def\ThrowAwayComment#1{\begingroup
    \def\CurrentComment{#1}%
    \let\do\makeinnocent \dospecials
    \makeinnocent\^^L% and whatever other special cases
    \endlinechar`\^^M \catcode`\^^M=12 \xComment}
{\catcode`\^^M=12 \endlinechar=-1 %
 \gdef\xComment#1^^M{\def\test{#1}
      \csarg\ifx{PlainEnd\CurrentComment Test}\test
          \let\html@next\endgroup
      \else \csarg\ifx{LaLaEnd\CurrentComment Test}\test
            \edef\html@next{\endgroup\noexpand\end{\CurrentComment}}
      \else \let\html@next\xComment
      \fi \fi \html@next}
}
\makeatother

\def\includecomment
 #1{\expandafter\def\csname#1\endcsname{}%
    \expandafter\def\csname end#1\endcsname{}}
\def\excludecomment
 #1{\expandafter\def\csname#1\endcsname{\ThrowAwayComment{#1}}%
    {\escapechar=-1\relax
     \csarg\xdef{PlainEnd#1Test}{\string\\end#1}%
     \csarg\xdef{LaLaEnd#1Test}{\string\\end\string\{#1\string\}}%
    }}

%  Define environments that ignore their contents.
\excludecomment{comment}
\excludecomment{rawhtml}
\excludecomment{htmlonly}
%\end{rawtex}

%  Hypertext commands etc. This is a condensed version of the html.sty
%  file supplied with LaTeX2HTML by: Nikos Drakos <nikos@cbl.leeds.ac.uk> &
%  Jelle van Zeijl <jvzeijl@isou17.estec.esa.nl>. The LaTeX2HTML documentation
%  should be consulted about all commands (and the environments defined above)
%  except \xref and \xlabel which are Starlink specific.

\newcommand{\htmladdnormallinkfoot}[2]{#1\footnote{#2}}
\newcommand{\htmladdnormallink}[2]{#1}
\newcommand{\htmladdimg}[1]{}
\newenvironment{latexonly}{}{}
\newcommand{\hyperref}[4]{#2\ref{#4}#3}
\newcommand{\htmlref}[2]{#1}
\newcommand{\htmlimage}[1]{}
\newcommand{\htmladdtonavigation}[1]{}

%  Starlink cross-references and labels.
\newcommand{\xref}[3]{#1}
\newcommand{\xlabel}[1]{}

%  LaTeX2HTML symbol.
\newcommand{\latextohtml}{{\bf LaTeX}{2}{\tt{HTML}}}

%  Define command to re-centre underscore for Latex and leave as normal
%  for HTML (severe problems with \_ in tabbing environments and \_\_
%  generally otherwise).
\newcommand{\latex}[1]{#1}
\newcommand{\setunderscore}{\renewcommand{\_}{{\tt\symbol{95}}}}
\latex{\setunderscore}

%  Redefine the \tableofcontents command. This procrastination is necessary
%  to stop the automatic creation of a second table of contents page
%  by latex2html.
\newcommand{\latexonlytoc}[0]{\tableofcontents}

% -----------------------------------------------------------------------------
%  Debugging.
%  =========
%  Remove % on the following to debug links in the HTML version using Latex.

% \newcommand{\hotlink}[2]{\fbox{\begin{tabular}[t]{@{}c@{}}#1\\\hline{\footnotesize #2}\end{tabular}}}
% \renewcommand{\htmladdnormallinkfoot}[2]{\hotlink{#1}{#2}}
% \renewcommand{\htmladdnormallink}[2]{\hotlink{#1}{#2}}
% \renewcommand{\hyperref}[4]{\hotlink{#1}{\S\ref{#4}}}
% \renewcommand{\htmlref}[2]{\hotlink{#1}{\S\ref{#2}}}
% \renewcommand{\xref}[3]{\hotlink{#1}{#2 -- #3}}
% -----------------------------------------------------------------------------
% ? Document specific \newcommand or \newenvironment commands.
% ? End of document specific commands
% -----------------------------------------------------------------------------
%  Title Page.
%  ===========
\renewcommand{\thepage}{\roman{page}}
\begin{document}
\thispagestyle{empty}

%  Latex document header.
%  ======================
\begin{latexonly}
   CCLRC / {\sc Rutherford Appleton Laboratory} \hfill {\bf \stardocname}\\
   {\large Particle Physics \& Astronomy Research Council}\\
   {\large Starlink Project\\}
   {\large \stardoccategory\ \stardocnumber}
   \begin{flushright}
   \stardocauthors\\
   \stardocdate
   \end{flushright}
   \vspace{-4mm}
   \rule{\textwidth}{0.5mm}
   \vspace{5mm}
   \begin{center}
   {\Huge\bf  \stardoctitle \\ [2.5ex]}
   {\LARGE\bf \stardocversion \\ [4ex]}
   {\Huge\bf  \stardocmanual}
   \end{center}
   \vspace{5mm}

% ? Heading for abstract if used.
   \vspace{10mm}
   \begin{center}
      {\Large\bf Abstract}
   \end{center}
% ? End of heading for abstract.
\end{latexonly}

%  HTML documentation header.
%  ==========================
\begin{htmlonly}
   \xlabel{}
   \begin{rawhtml} <H1> \end{rawhtml}
      \stardoctitle\\
      \stardocversion\\
      \stardocmanual
   \begin{rawhtml} </H1> \end{rawhtml}

% ? Add picture here if required.
% ? End of picture

   \begin{rawhtml} <P> <I> \end{rawhtml}
   \stardoccategory \stardocnumber \\
   \stardocauthors \\
   \stardocdate
   \begin{rawhtml} </I> </P> <H3> \end{rawhtml}
      \htmladdnormallink{CCLRC}{http://www.cclrc.ac.uk} /
      \htmladdnormallink{Rutherford Appleton Laboratory}
                        {http://www.cclrc.ac.uk/ral} \\
      \htmladdnormallink{Particle Physics \& Astronomy Research Council}
                        {http://www.pparc.ac.uk} \\
   \begin{rawhtml} </H3> <H2> \end{rawhtml}
      \htmladdnormallink{Starlink Project}{http://star-www.rl.ac.uk/}
   \begin{rawhtml} </H2> \end{rawhtml}
   \htmladdnormallink{\htmladdimg{source.gif} Retrieve hardcopy}
      {http://star-www.rl.ac.uk/cgi-bin/hcserver?\stardocsource}\\

%  HTML document table of contents.
%  ================================
%  Add table of contents header and a navigation button to return to this
%  point in the document (this should always go before the abstract \section).
  \label{stardoccontents}
  \begin{rawhtml}
    <HR>
    <H2>Contents</H2>
  \end{rawhtml}
  \renewcommand{\latexonlytoc}[0]{}
  \htmladdtonavigation{\htmlref{\htmladdimg{contents_motif.gif}}
        {stardoccontents}}

% ? New section for abstract if used.
  \section{\xlabel{abstract}Abstract}


% ? End of new section for abstract
\end{htmlonly}

% -----------------------------------------------------------------------------
% ? Document Abstract. (if used)
%   ==================

This document describes the routines provided within the NDG subroutine 
library for accessing groups of NDF data objects. 

% ? End of document
% -----------------------------------------------------------------------------
% ? Latex document Table of Contents (if used).
%  ===========================================
 \newpage
 \begin{latexonly}
   \setlength{\parskip}{0mm}
   \latexonlytoc
   \setlength{\parskip}{\medskipamount}
   \markright{\stardocname}
 \end{latexonly}
% ? End of Latex document table of contents
% -----------------------------------------------------------------------------
\newpage
\renewcommand{\thepage}{\arabic{page}}
\setcounter{page}{1}

\section {Introduction}

If an application prompts the user for an NDF using the facilities of the NDF\_ 
system (see \xref{SUN/33}{sun33}{}), the user may only reply with the name of a single NDF. Some
applications allow many input NDFs to be specified and the need to
type in every NDF name explicitly each time the program is run can become time
consuming. The NDG package provides a means of giving the user the
ability to specify a list (or ``Group'') of NDFs as a reply to a single prompt
for an parameter. 

The current version of NDG can process NDFs which are stored as
components within an HDS container file, and can also process foreign
data formats using the system described in \xref{SSN/20}{ssn20}{}.


\section {Interaction Between NDG and GRP}
NDG uses the facilities of the GRP package and users of NDG should be familiar
with the content of \xref{SUN/150}{sun150}{} which describes the GRP package. Groups
created by NDG routines should be deleted when no longer needed using
\xref{GRP\_DELET}{sun150}{GRP\_DELET}.

\section {General overview of the NDG\_ system}
As a broad outline, applications use the NDG\_ package as follows:

\begin{enumerate}

\item A call is made to \htmlref{NDG\_ASSOC}{NDG\_ASSOC} which causes the user 
to be prompted for a single parameter. This parameter can be of any type.
The user replies with a ``group expression'' (see
\xref{SUN/150}{sun150}{}), which contains the names of a group of {\em
existing} NDFs to be used as inputs by the application\footnote{The routine
\htmlref{NDG\_ASEXP}{NDG\_ASEXP} performs the same function but does not
use the parameter system - it expects the group expression to be supplied by 
the calling routine.}. For instance, the group expression may be

\begin{verbatim}
     m51_b[23]s1_ds,m51_b[23]s2_ds,m51_b[23]s2?_ds,^files.lis
\end{verbatim}

This is a complicated example, probably more complicated than would be
used in practice, but it highlights the facilities of the GRP and NDG
packages, e.g. wild cards (``?'', ``$*$'' or ``[..]'' ), lists of files,
or indirection through a text file (``\verb+^+'').

The \htmlref{NDG\_ASSOC}{NDG\_ASSOC} routine produces a list of explicit NDF names, which are stored
internally within the GRP system. 

\item What happens next depends on the application, but a common example may be
the initiation of a DO loop to loop through the input NDFs (NDG\_ASSOC returns
the total number of NDF names in the group). 

\item To access a particular NDF, the application calls routine \htmlref{NDG\_NDFAS}{NDG\_NDFAS}
supplying an index, $n$, within the group (i.e $n$ is an integer in the range 1
to the group size returned by NDG\_ASSOC). NDG\_NDFAS returns an NDF identifier
to the $n$th NDF in the group. This identifier can then be used to access the
NDF in the normal manner using the NDF\_ routines (\xref{SUN/33}{sun33}{}). The identifier
should be annulled when it is no longer needed using \xref{NDF\_ANNUL}{sun33}{NDF\_ANNUL} in the
normal way.

\item Once the application has finished processing the group of NDFs, it calls 
\xref{GRP\_DELET}{sun150}{GRP\_DELET} which deletes the group, releasing all resources reserved by the group.

\item Routine NDG\_ASSOC can also be used to append a list of NDF names 
obtained from the environment, to a previously defined group.

The routine \htmlref{NDG\_CREAT}{NDG\_CREAT} produces a group containing the names of 
NDFs which are to be created by the application. The routine \htmlref{NDG\_NDFCR}{NDG\_NDFCR} will 
create a new NDF with a name given by a group member, and returns an NDF 
identifier to it. Routine \htmlref{NDG\_NDFPR}{NDG\_NDFPR} creates a new NDF by propagation from a 
previously existing NDF, in a similar manner to the NDF routine \xref{NDF\_PROP}{sun33}{NDF\_PROP} (see 
\xref{SUN/33}{sun33}{}).

The names of output NDFs given by users usually relate to the input NDF names.
When NDG\_CREAT is called, it creates a group of NDF names either by modifying
all the names in a specified input group using a ``modification element'' (see
\xref{SUN/150}{sun150}{}), or by getting a list of new names from the user. 

\item Applications which produce a group of output NDFs could also produce a
text file holding the names of the output NDFs. Such a file can be used
as input to the next application, using the indirection facility. A text
file listing of all the NDFs in a group can be produced by routine
GRP\_LIST (or GRP\_LISTF).

\end{enumerate}

See the detailed descriptions of \htmlref{NDG\_ASSOC}{NDG\_ASSOC} and \htmlref{NDG\_CREAT}{NDG\_CREAT} below for details 
of the processing of existing and new NDF names.

\section{An example NDG application}

The following gives a short example of how NDG routines might be 
used within an ADAM task.
\begin{quote}
\latexonly{\small}
\begin{verbatim}
      SUBROUTINE COPY( STATUS )

*  Global Constants:
      INCLUDE 'GRP_PAR'          ! Standard GRP constants

*  Local Variables:
      INTEGER GIDIN              ! GRP identifier for group of input NDFs
      INTEGER GIDOUT             ! GRP identifer for group of output NDFs
      INTEGER I                  ! Loop counter
      INTEGER NDFIN              ! NDF identifier for input NDF
      INTEGER NDFOUT             ! NDF identifier for output NDF
      INTEGER NUMIN              ! Number of input NDFs
      INTEGER NUMOUT             ! Number of output NDFs
      INTEGER STATUS             ! The global status
      LOGICAL FLAG               ! Has group ended with flag character?
*.

*  Inialise the group identifiers to indicate that groups do not have
*  any initial members.
      GIDIN = GRP__NOID
      GIDOUT = GRP__NOID

*  Create group of input NDFs using the parameter IN.
      CALL NDG_ASSOC( 'IN', .TRUE., GIDIN, NUMIN, FLAG, STATUS )

*  Create group of output NDFs using the parameter OUT, which possibly
*  works by modifying the values in the input group.
      CALL NDG_CREAT( 'OUT', GIDIN, GIDOUT, NUMOUT, FLAG, STATUS )

*  Loop over group members.
      DO I = 1, NUMIN

*  Get the identifier for an existing NDF from the input group.
         CALL NDG_NDFAS( GIDIN, I, 'READ', NDFIN, STATUS )

*  Create a new NDF by propagation using the name in the output group.
         CALL NDG_NDFPR( NDFIN, 'Data,Variance,Quality,WCS', GIDOUT, I,
     :                   NDFOUT, STATUS )

*  Relase NDF resources.
         CALL NDF_ANNUL( NDFIN, STATUS )
         CALL NDF_ANNUL( NDFOUT, STATUS )
      END DO

*  Release GRP resources.
      CALL GRP_DELET( GIDIN, STATUS )
      CALL GRP_DELET( GIDOUT, STATUS )

      END
\end{verbatim}
\end{quote}
When this program is compiled and run, the user is asked for 
two ADAM parameters, IN and OUT.  Each NDF in the list specified
by the IN parameter is simply copied to the corresponding naem in the 
list specified by the OUT parameter.  For instance, running
\begin{quote}
\latexonly{\small}
\begin{verbatim}
copy in=data[12] out=*-new
\end{verbatim}
\end{quote}
would write new NDFs {\tt data1-new.sdf} and {\tt data2-new.sdf}
which were copies of the existing files {\tt data1.sdf} and {\tt data2.sdf}.
If {\tt data1} and {\tt data2} do not represent NDF structures,
an error will be signalled and the user will be prompted to enter
a different value for IN.
If any of the elements of the IN list represents an HDS container file
which holds multiple NDF structures directly within it, each of these
will be added to the list of NDFs to be processed, and the
output list will be constructed with a corresponding structure.
For instance, if the HDS file {\tt obs.sdf} contains three NDFs at
its top level called O1, O2 and O3, then invoking
\begin{quote}
\latexonly{\small}
\begin{verbatim}
copy in=obs out=obs-copy
\end{verbatim}
\end{quote}
will result in a new container file {\tt obs-copy.sdf} being written, 
which contains three NDF structures called O1, O2 and O3.

Note that a few corners have been cut in the above code,
in particular checking that the input and output groups have the
same size and STATUS testing.  Additionally, no action is taken
when the FLAG character is given at the end of a group specification --
conventionally this would indicate that the user should be allowed
to add further members.

\appendix
% Command for displaying routines in routine lists:
% =================================================

\newcommand{\noteroutine}[2]{{\small \bf #1} \\
                              \hspace*{3em} {\em #2} \\[1.5ex]}

\begin{htmlonly}
\renewcommand{\noteroutine}[2]{
\begin{description}
\item [{\bf {#1}}] 
{\em #2}
\end{description}
}


\end{htmlonly}

\appendix 

\section{List of Routines}

\noteroutine{
      CALL NDG\_ASEXP( GRPEXP, VERB, IGRP1, IGRP2, SIZE, FLAG, STATUS )
}{
   Store names of existing NDFs supplied as a group expression by the
   calling routine.
}
\noteroutine{
      CALL NDG\_ASSO1( PARAM, VERB, MODE, INDF, FIELDS, STATUS )
}{
   Obtain an identifier for a single existing NDF using a specified
   parameter
}
\noteroutine{
      CALL NDG\_ASSOC( PARAM, VERB, IGRP, SIZE, FLAG, STATUS )
}{
   Store names of existing NDFs specified through the environment
}
\noteroutine{
      CALL NDG\_CREA1( PARAM, FTYPE, NDIM, LBND, UBND, INDF, NAME,
                      STATUS )
}{
   Create a single new simple NDF using a specified parameter
}
\noteroutine{
      CALL NDG\_CREAT( PARAM, IGRP0, IGRP, SIZE, FLAG, STATUS )
}{
   Obtain the names of a group of NDF to be created from the
   environment
}
\noteroutine{
      CALL NDG\_CREP1( PARAM, FTYPE, NDIM, UBND, INDF, NAME, STATUS )
}{
   Create a single new primitive NDF using a specified parameter
}
\noteroutine{
      CALL NDG\_GTSUP( IGRP, I, FIELDS, STATUS )
}{
   Get supplemental information for an NDF
}
\noteroutine{
      CALL NDG\_NDFAS( IGRP, INDEX, MODE, INDF, STATUS )
}{
   Obtain an NDF identifier for an existing NDF
}
\noteroutine{
      CALL NDG\_NDFCO( INDF1, IGRP, INDEX, INDF2, STATUS )
}{
   Obtain an NDF identifier for a new NDF created by copying an 
   existing NDF
}
\noteroutine{
      CALL NDG\_NDFCP( IGRP, INDEX, FTYPE, NDIM, UBND, INDF, STATUS )
}{
   Obtain an NDF identifier for a new primitive NDF
}
\noteroutine{
      CALL NDG\_NDFCR( IGRP, INDEX, FTYPE, NDIM, LBND, UBND, INDF,
                      STATUS )
}{
   Obtain an NDF identifier for a new simple NDF
}
\noteroutine{
      CALL NDG\_NDFPR( INDF1, CLIST, IGRP, INDEX, INDF2, STATUS )
}{
   Obtain an NDF identifier for a new NDF created by propagation from
   an existing NDF
}
\noteroutine{
      CALL NDG\_PROP1( INDF1, CLIST, PARAM, INDF2, NAME, STATUS )
}{
   Create a single new NDF by propagation using a specified parameter
}
\noteroutine{
      CALL NDG\_PTSUP( IGRP, I, FIELDS, STATUS )
}{
   Store suplemental information for an NDF
}
\noteroutine{
      CALL NDG\_SETSZ( IGRP, SIZE, STATUS )
}{
   Reduces the size of an NDG group
}




\section{Full Routine Specifications}
\label {SEC:FULLSPEC}

% +
%  Name:
%     SST.TEX

%  Purpose:
%     Define LaTeX commands for laying out Starlink routine descriptions.

%  Language:
%     LaTeX

%  Type of Module:
%     LaTeX data file.

%  Description:
%     This file defines LaTeX commands which allow routine documentation
%     produced by the SST application PROLAT to be processed by LaTeX and
%     by LaTeX2HTML. The contents of this file should be included in the
%     source prior to any statements that make use of the SST commands.

%  Notes:
%     The commands defined in the style file html.sty provided with LaTeX2html
%     are used. These should either be made available by using the appropriate
%     sun.tex (with hypertext extensions) or by putting the file html.sty
%     on your TEXINPUTS path (and including the name as part of the
%     documentstyle declaration).

%  Authors:
%     RFWS: R.F. Warren-Smith (STARLINK)
%     PDRAPER: P.W. Draper (Starlink - Durham University)

%  History:
%     10-SEP-1990 (RFWS):
%        Original version.
%     10-SEP-1990 (RFWS):
%        Added the implementation status section.
%     12-SEP-1990 (RFWS):
%        Added support for the usage section and adjusted various spacings.
%     8-DEC-1994 (PDRAPER):
%        Added support for simplified formatting using LaTeX2html.
%     {enter_further_changes_here}

%  Bugs:
%     {note_any_bugs_here}

% -

%  Define length variables.
\newlength{\sstbannerlength}
\newlength{\sstcaptionlength}
\newlength{\sstexampleslength}
\newlength{\sstexampleswidth}

%  Define a \tt font of the required size.
\newfont{\ssttt}{cmtt10 scaled 1095}

%  Define a command to produce a routine header, including its name,
%  a purpose description and the rest of the routine's documentation.
\newcommand{\sstroutine}[3]{
   \goodbreak
   \rule{\textwidth}{0.5mm}
   \vspace{-7ex}
   \newline
   \settowidth{\sstbannerlength}{{\Large {\bf #1}}}
   \setlength{\sstcaptionlength}{\textwidth}
   \setlength{\sstexampleslength}{\textwidth}
   \addtolength{\sstbannerlength}{0.5em}
   \addtolength{\sstcaptionlength}{-2.0\sstbannerlength}
   \addtolength{\sstcaptionlength}{-5.0pt}
   \settowidth{\sstexampleswidth}{{\bf Examples:}}
   \addtolength{\sstexampleslength}{-\sstexampleswidth}
   \parbox[t]{\sstbannerlength}{\flushleft{\Large {\bf #1}}}
   \parbox[t]{\sstcaptionlength}{\center{\Large #2}}
   \parbox[t]{\sstbannerlength}{\flushright{\Large {\bf #1}}}
   \begin{description}
      #3
   \end{description}
}

%  Format the description section.
\newcommand{\sstdescription}[1]{\item[Description:] #1}

%  Format the usage section.
\newcommand{\sstusage}[1]{\item[Usage:] \mbox{} \\[1.3ex] {\ssttt #1}}


%  Format the invocation section.
\newcommand{\sstinvocation}[1]{\item[Invocation:]\hspace{0.4em}{\tt #1}}

%  Format the arguments section.
\newcommand{\sstarguments}[1]{
   \item[Arguments:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the returned value section (for a function).
\newcommand{\sstreturnedvalue}[1]{
   \item[Returned Value:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the parameters section (for an application).
\newcommand{\sstparameters}[1]{
   \item[Parameters:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the examples section.
\newcommand{\sstexamples}[1]{
   \item[Examples:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Define the format of a subsection in a normal section.
\newcommand{\sstsubsection}[1]{ \item[{#1}] \mbox{} \\}

%  Define the format of a subsection in the examples section.
\newcommand{\sstexamplesubsection}[2]{\sloppy
\item[\parbox{\sstexampleslength}{\ssttt #1}] \mbox{} \\ #2 }

%  Format the notes section.
\newcommand{\sstnotes}[1]{\item[Notes:] \mbox{} \\[1.3ex] #1}

%  Provide a general-purpose format for additional (DIY) sections.
\newcommand{\sstdiytopic}[2]{\item[{\hspace{-0.35em}#1\hspace{-0.35em}:}] \mbox{} \\[1.3ex] #2}

%  Format the implementation status section.
\newcommand{\sstimplementationstatus}[1]{
   \item[{Implementation Status:}] \mbox{} \\[1.3ex] #1}

%  Format the bugs section.
\newcommand{\sstbugs}[1]{\item[Bugs:] #1}

%  Format a list of items while in paragraph mode.
\newcommand{\sstitemlist}[1]{
  \mbox{} \\
  \vspace{-3.5ex}
  \begin{itemize}
     #1
  \end{itemize}
}

%  Define the format of an item.
\newcommand{\sstitem}{\item}

%  Now define html equivalents of those already set. These are used by
%  latex2html and are defined in the html.sty files.
\begin{htmlonly}

%  Re-define \ssttt.
   \newcommand{\ssttt}{\tt}

%  \sstroutine.
   \renewcommand{\sstroutine}[3]{
      \subsection{#1\xlabel{#1}-\label{#1}#2}
      \begin{description}
         #3
      \end{description}
   }

%  \sstdescription
   \renewcommand{\sstdescription}[1]{\item[Description:]
      \begin{description}
         #1
      \end{description}
   }

%  \sstusage
   \renewcommand{\sstusage}[1]{\item[Usage:]
      \begin{description}
         {\ssttt #1}
      \end{description}
   }

%  \sstinvocation
   \renewcommand{\sstinvocation}[1]{\item[Invocation:]
      \begin{description}
         {\ssttt #1}
      \end{description}
   }

%  \sstarguments
   \renewcommand{\sstarguments}[1]{
      \item[Arguments:]
      \begin{description}
         #1
      \end{description}
   }

%  \sstreturnedvalue
   \renewcommand{\sstreturnedvalue}[1]{
      \item[Returned Value:]
      \begin{description}
         #1
      \end{description}
   }

%  \sstparameters
   \renewcommand{\sstparameters}[1]{
      \item[Parameters:]
      \begin{description}
         #1
      \end{description}
   }

%  \sstexamples
   \renewcommand{\sstexamples}[1]{
      \item[Examples:]
      \begin{description}
         #1
      \end{description}
   }

%  \sstsubsection
   \renewcommand{\sstsubsection}[1]{\item[{#1}]}

%  \sstexamplesubsection
   \renewcommand{\sstexamplesubsection}[2]{\item[{\ssttt #1}] \\ #2}

%  \sstnotes
   \renewcommand{\sstnotes}[1]{\item[Notes:]
      \begin{description}
         #1
      \end{description}
   }

%  \sstdiytopic
   \renewcommand{\sstdiytopic}[2]{\item[{#1}]
      \begin{description}
         #2
      \end{description}
   }

%  \sstimplementationstatus
   \renewcommand{\sstimplementationstatus}[1]{\item[Implementation Status:]
      \begin{description}
         #1
      \end{description}
   }

%  \sstitemlist
   \newcommand{\sstitemlist}[1]{
      \begin{itemize}
         #1
      \end{itemize}
   }
\end{htmlonly}

%  End of "sst.tex" layout definitions.
% .
% @(#)sst.tex   1.4   95/06/06 11:46:41   95/06/06 11:49:58

% Routine descriptions:
% =====================
\small


\newpage
\sstroutine{
   NDG\_ASEXP
}{
   Store names of existing NDFs supplied as a group expression
}{
   \sstdescription{
      The supplied group expression is parsed (using the facilities of
      the GRP routine GRP\_GROUP, see SUN/150) to produce a list of
      explicit names for existing NDFs which are appended to the end of
      the supplied group (a new group is created if none is supplied).
      NDF identifiers for particular members of the group can be obtained
      using NDG\_NDFAS.

      If any of the NDFs specified by the group expression cannot be
      accessed, an error is reported and STATUS is returned equal to
      NDG\_\_NOFIL. If this happens strings holding the name of each
      bad NDF are appended to the group identified by IGRP1 (so long
      as IGRP1 is not equal to GRP\_\_NOID).
   }
   \sstinvocation{
      CALL NDG\_ASEXP( GRPEXP, VERB, IGRP1, IGRP2, SIZE, FLAG, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         GRPEXP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The group expression specifying the NDF names to be stored
         in the group.
      }
      \sstsubsection{
         VERB = LOGICAL (Given)
      }{
         If TRUE then errors which occur whilst accessing supplied NDFs
         are flushed so that the user can see the details ({\tt "}verbose{\tt "} mode).
         Otherwise, they are annulled and a general {\tt "}Cannot access file xyz{\tt "}
         message is reported instead.
      }
      \sstsubsection{
         IGRP1 = INTEGER (Given)
      }{
         The identifier of a group to which the names of any
         inaccessable NDFs will be appended. The group should already
         have been created by a call to GRP\_NEW, and should be deleted
         when no longer needed by a call to GRP\_DELET. If IGRP1 is
         supplied equal to symbolic constant GRP\_\_NOID, then no
         information is stored describing the bad NDFs.
      }
      \sstsubsection{
         IGRP2 = INTEGER (Given and Returned)
      }{
         The identifier of the group in which the NDF names are to be
         stored. A new group is created if the supplied value is GRP\_\_NOID.
         It should be deleted when no longer needed using GRP\_DELET.
      }
      \sstsubsection{
         SIZE = INTEGER (Returned)
      }{
         The total number of NDF names in the returned group IGRP2.
      }
      \sstsubsection{
         FLAG = LOGICAL (Returned)
      }{
         If the group expression was terminated by the GRP {\tt "}flag
         character{\tt "}, then FLAG is returned .TRUE. Otherwise it is
         returned .FALSE. Returned .FALSE. if an error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Any file names containing wildcards are expanded into a list of NDF
         names. The supplied strings are intepreted by a shell (/bin/tcsh if
         it exists, otherwise /bin/csh, otherwise /bin/sh), and so may
         contain shell meta-characters (eg twiddle, \$HOME, even command
         substitution and pipes - but pipe characters {\tt "}$|${\tt "} need to be escaped
         using a backslash {\tt "}$\backslash${\tt "} to avoid them being interpreted as GRP
         editing characters).

         \sstitem
         Each supplied name may include an HDS path. For instance,
         {\tt "}/home/dsb/mydata.a.c(1).b{\tt "} refers to an NDF stored in component
         {\tt "}a.c(1).b{\tt "} in the HDS container file /home/dsb/mydata.sdf. Note,
         wild cards are not allowed within HDS component paths (i.e. they
         are only allowed within the specification of the container file).

         \sstitem
         If an HDS object is specified which is not an NDF, then the
         object will be searched for NDF components. This search is
         recursive, in that any components of the specified object are also
         searched. The supplied name will be expanded into a group of names,
         one for each NDF found within the specified HDS object. Note, NDFs
         are not themselves searched for other NDFs. That is, the expanded
         group of names will not include any NDF which is contained within
         another NDF (i.e. NDFs which are stored as an extension item of
         another NDF are not included in the group). For instance, if the
         string {\tt "}fred{\tt "} is given, the HDS file fred.sdf will be searched for
         NDFs and the returned group will contain references for all NDFs
         found within fred.sdf.

         \sstitem
         If the environment variable NDF\_FORMATS\_IN is defined (see
         SSN/20) then all possible NDFs matching the supplied string are
         included in the returned group. For instance, if the string {\tt "}fred{\tt "}
         is supplied, then the returned group will contain references to all
         files with basename fred which also have a file type specified in
         NDF\_FORMATS\_IN. If a FITS file {\tt "}fred.fit{\tt "} exists, and HDS file
         {\tt "}fred.sdf{\tt "} also exists (and contains an NDF), then supplying the
         name {\tt "}fred{\tt "} will result in both being included in the returned
         group. If the file {\tt "}fred.sdf{\tt "} contains a component called {\tt "}.fit{\tt "},
         then this will be included in the returned group in place of
         {\tt "}fred.sdf{\tt "}.

         \sstitem
         NDFs contained within HDS files are opened in order to ensure
         that they are valid NDFs. The NDF name is returned in IGRP1 if there
         are no valid NDFs matching a supplied name. No check is made that any
         foreign data files contain valid NDFs since this would involve a
         potentially expensive data conversion. So, for instance, {\tt "}$*$.fit{\tt "} could
         pick up FITS catalogues as well as FITS images. If a foreign data file
         does not contain a valid NDF, an error will be reported when the NDF
         is accessed using NDG\_NDFAS.

         \sstitem
         Each element in the returned group contains a full specification
         for an NDF. Several other groups are created by this routine, and
         are associated with the returned group by means of a GRP {\tt "}owner-slave{\tt "}
         relationship. These supplemental groups are automatically deleted
         when the returned group is deleted using GRP\_DELET. The returned
         group should not be altered using GRP directly because corresponding
         changes may need to be made to the supplemental groups. Routines
         NDG\_SETSZ, NDG\_GTSUP and NDG\_PTSUP are provided to manipulate the
         entire chain of groups. The full chain (starting from the head) is
         as follows:

         \sstitem
            NDF slice specifications

         \sstitem
            HDS paths

         \sstitem
            File types

         \sstitem
            Base file names

         \sstitem
            Directory paths

         \sstitem
            Full NDF specification (this is the returned group IGRP)
      }
   }
}
\sstroutine{
   NDG\_ASSO1
}{
   Obtain an identifier for a single existing NDF using a specified
   parameter
}{
   \sstdescription{
      This routine is equivalent to NDF\_ASSOC except that it allows the
      NDF to be specified using a GRP group expression (for instance, its
      name may be given within a text file, etc). The first NDF in the
      group expression is returned. Any other names in the group
      expression are ignored. Supplemental information describing the
      separate fields in the NDF specification are also returned.
   }
   \sstinvocation{
      CALL NDG\_ASSO1( PARAM, VERB, MODE, INDF, FIELDS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the ADAM parameter.
      }
      \sstsubsection{
         VERB = LOGICAL (Given)
      }{
         If TRUE then errors which occur whilst accessing supplied NDFs
         are flushed so that the user can see them before re-prompting for
         a new NDF ({\tt "}verbose{\tt "} mode). Otherwise, they are annulled and
         a general {\tt "}Cannot access file xyz{\tt "} message is displayed before
         re-prompting.
      }
      \sstsubsection{
         MODE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Type of NDF access required: {\tt '}READ{\tt '}, {\tt '}UPDATE{\tt '} or {\tt '}WRITE{\tt '}.
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         FIELDS( 6 ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Each element contains the following on exit:
         \begin{enumerate}
         \item NDF slice specifications
         \item HDS paths
         \item File types
         \item Base file names
         \item Directory paths
         \item Full NDF specification (this is the returned group - IGRP)
         \end{enumerate}
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\newpage
\sstroutine{
   NDG\_ASSOC
}{
   Store names of existing NDFs specified through the environment
}{
   \sstdescription{
      A group expression is obtained from the environment using the
      supplied parameter. The expression is parsed (using the
      facilities of the GRP routine GRP\_GROUP, see \xref{SUN/150}{sun150}{}) to produce
      a list of explicit names for existing NDFs which are appended to the
      end of the supplied group (a new group is created if none is
      supplied). If an error occurs while parsing the group expression, the
      user is re-prompted for a new group expression. NDF identifiers for
      particular members of the group can be obtained using NDG\_NDFAS.
   }
   \sstinvocation{
      CALL NDG\_ASSOC( PARAM, VERB, IGRP, SIZE, FLAG, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER$*$($*$) (Given)
      }{
         The parameter with which to associate the group expression.
      }
      \sstsubsection{
         VERB = LOGICAL (Given)
      }{
         If TRUE then errors which occur whilst accessing supplied NDFs
         are flushed so that the user can see them before re-prompting for
         a new NDF ({\tt "}verbose{\tt "} mode). Otherwise, they are annulled and
         a general {\tt "}Cannot access file xyz{\tt "} message is displayed before
         re-prompting.
      }
      \sstsubsection{
         IGRP = INTEGER (Given and Returned)
      }{
         The identifier of the group in which the NDF names are to be
         stored. A new group is created if the supplied value is GRP\_\_NOID.
         It should be deleted when no longer needed using GRP\_DELET.
      }
      \sstsubsection{
         SIZE = INTEGER (Returned)
      }{
         The total number of NDF names in the returned group.
      }
      \sstsubsection{
         FLAG = LOGICAL (Returned)
      }{
         If the group expression was terminated by the GRP {\tt "}flag
         character{\tt "}, then FLAG is returned true. Otherwise it is
         returned false. Returned .FALSE. if an error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Any file names containing wildcards or "[..]" globbing patterns
	 are expanded into a list of NDF names. The supplied strings are
	 intepreted by a shell (/bin/tcsh if it exists, otherwise
	 /bin/csh, otherwise /bin/sh), and so may contain shell
	 meta-characters (eg twiddle, \$HOME, even command substitution
	 and pipes - but pipe characters {\tt "}$|${\tt "} need to be
	 escaped using a backslash {\tt "}$\backslash${\tt "} to avoid
	 them being interpreted as GRP editing characters).

         \sstitem
         Each supplied name may include an HDS path. For instance,
         {\tt "}/home/dsb/mydata.a.c(1).b{\tt "} refers to an NDF stored in component
         {\tt "}a.c(1).b{\tt "} in the HDS container file /home/dsb/mydata.sdf. Note,
         wild cards are not allowed within HDS component paths (i.e. they
         are only allowed within the specification of the container file).

         \sstitem
         If an HDS object is specified which is not an NDF, then the
         object will be searched for NDF components. This search is
         recursive, in that any components of the specified object are also
         searched. The supplied name will be expanded into a group of names,
         one for each NDF found within the specified HDS object. Note, NDFs
         are not themselves searched for other NDFs. That is, the expanded
         group of names will not include any NDF which is contained within
         another NDF (i.e. NDFs which are stored as an extension item of
         another NDF are not included in the group). For instance, if the
         string {\tt "}fred{\tt "} is given, the HDS file fred.sdf will be searched for
         NDFs and the returned group will contain references for all NDFs
         found within fred.sdf.

         \sstitem
         If the environment variable NDF\_FORMATS\_IN is defined (see
         \xref{SSN/20}{ssn20}{}) then only the highest priority file with any give file name
         is included in the returned group. The priority of a file is
         determined by its file type. Native NDFs (.sdf) have highest
         priority. After that, priority decreases along the list of file
         types specified in NDF\_FORMATS\_OUT. If no file type is given by
         the user, the highest priority available file type is used. If an
         explicit file type is given, then that file type is used.

         \sstitem

         Care should be taken if a trailing string enclosed in square
	 brackets is appended to the end of the file name. These are
	 interpreted first as a globbing pattern. Thus {\tt
	 "}fred[12]{\tt "} would match files with base names {\tt
	 "}fred1{\tt "} and {\tt "}fred2{\tt "}. If the pattern does not
	 match any existing files, then the trailing {\tt "}[..]{\tt "}
	 string is next interpreted as a foreign extension specifier.
	 Thus if fred.fit is a multi-extension FITS file, {\tt
	 "}fred[12]{\tt "} would be interpreted as the twelth image
	 extension in fred.fit only if files cannot be found with
	 basenames {\tt "}fred1{\tt "} or {\tt "}fred2{\tt "}.

         \sstitem
         NDFs contained within HDS files are opened in order to ensure
         that they are valid NDFs. The user is notified if there are no
         valid NDFs matching a supplied name, and they are asked to supply
         a replacement parameter value. No check is made that any foreign
         data files contain valid NDFs since this would involve a potentially
         expensive data conversion. So, for instance, {\tt "}$*$.fit{\tt "} could pick up
         FITS catalogues as well as FITS images. If a foreign data file does
         not contain a valid NDF, an error will be reported when the NDF is
         accessed using NDG\_NDFAS.

         \sstitem
         Each element in the returned group contains a full specification
         for an NDF. Several other groups are created by this routine, and
         are associated with the returned group by means of a GRP {\tt "}owner-slave{\tt "}
         relationship. These supplemental groups are automatically deleted
         when the returned group is deleted using GRP\_DELET. The returned
         group should not be altered using GRP directly because corresponding
         changes may need to be made to the supplemental groups. Routines
         NDG\_SETSZ, NDG\_GTSUP and NDG\_PTSUP are provided to manipulate the
         entire chain of groups. The full chain (starting from the head) is
         as follows:

         \sstitem
            NDF slice specifications

         \sstitem
            HDS paths

         \sstitem
            File types

         \sstitem
            Base file names

         \sstitem
            Directory paths

         \sstitem
            Full NDF specification (this is the returned group IGRP)

         \sstitem
         If an error is reported the group is returned unaltered. If
         no group is supplied, an empty group is returned.

         \sstitem
         A null value (!) can be given for the parameter to indicate
         that no more NDFs are to be specified. The corresponding error
         is annulled before returning unless no NDFs have been added to
         the group.

         \sstitem
         If the last character in the supplied group expression is
         a colon (:), a list of the NDFs represented by the group
         expression (minus the colon) is displayed, but none are
         actually added to the group. The user is then re-prompted for
         a new group expression.
      }
   }
}
\newpage
\sstroutine{
   NDG\_CREA1
}{
   Create a single new simple NDF using a specified parameter
}{
   \sstdescription{
      This routine is equivalent to NDF\_CREAT except that it allows the
      NDF to be specified using a GRP group expression (for instance, its
      name may be given within a text file, etc). The first NDF in the
      group expression is returned. Any other names in the group
      expression are ignored. Any modification elements in the supplied
      group expression will be treated literally.
   }
   \sstinvocation{
      CALL NDG\_CREA1( PARAM, FTYPE, NDIM, LBND, UBND, INDF, NAME,
                      STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the ADAM parameter.
      }
      \sstsubsection{
         FTYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Full data type of the NDF{\tt '}s DATA component (e.g. {\tt '}\_DOUBLE{\tt '} or
         {\tt '}COMPLEX\_REAL{\tt '}).
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of NDF dimensions.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Given)
      }{
         Lower pixel-index bounds of the NDF.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         Upper pixel-index bounds of the NDF.
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The full file specification for the NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\newpage
\sstroutine{
   NDG\_CREAT
}{
   Obtain the names of a group of NDF to be created from the
   environment
}{
   \sstdescription{
      A group expression is obtained from the environment using the
      supplied parameter. The expression is parsed (using the
      facilities of the GRP routine GRP\_GROUP, see \xref{SUN/150}{sun150}{}) to produce
      a list of explicit NDF names. These names are appended
      to the group identified by IGRP. The user is re-prompted if an
      error occurs while parsing the group expression. If IGRP has the
      value GRP\_\_NOID on entry, then a new group is created and IGRP is
      returned holding the new group identifier.

      If IGRP0 holds a valid group identifier on entry, then the group
      identified by IGRP0 is used as the basis for any modification
      element contained in the group expression obtained from the
      environment. If IGRP0 holds an invalid identifier (such as
      GRP\_\_NOID) on entry then modification elements are included
      literally in the output group.
   }
   \sstinvocation{
      CALL NDG\_CREAT( PARAM, IGRP0, IGRP, SIZE, FLAG, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER$*$($*$) (Given)
      }{
         The parameter with which to associate the group.
      }
      \sstsubsection{
         IGRP0 = INTEGER (Given)
      }{
         The GRP identifier for the group to be used as the basis for
         any modification elements. If a valid GRP identifier is
         supplied, and if the supplied group expression contains a
         modification element, then:

         \sstitemlist{

            \sstitem
            the basis token (an asterisk) is replaced by the file basename
            associated with the corresponding element of the basis group (the
            {\tt "}basis NDF{\tt "}).

            \sstitem
            if no directory specification is included in the group expression,
            the directory specification associated with the basis NDF is used.

            \sstitem
            if no HDS component path is included in the group expression,
            the HDS component path associated with the basis NDF (if any) is
            used. Any required higher level HDS objects are created in the
            output HDS file by copying the structure of the HDS file containing
            the basis NDF. Thus if, the basis NDF is fred.a.b(2).c, and the
            group expression is {\tt "}$*$\_a{\tt "}, then an HDS container file called
            {\tt "}fred\_a.sdf{\tt "} is created by copying fred.sdf and then deleting all
            NDFs from fred\_a.sdf (unless this has already been done while
            creating a previous member of the returned group). Other non-NDF
            components in fred\_a.sdf are retained. This ensures that all necessary
            structure exists in fred\_a.sdf, so that the NDF fred\_a.a.b(2).c
            can be created when necessary.

         }
         The supplied group will often be created by NDG\_ASSOC, but
         groups created {\tt "}by hand{\tt "} using GRP directly can also be used
         (i.e. without the supplemental groups created by NDG). In
         this case, there are no defaults for directory path, file type,
         or HDS component path, and the basis token ({\tt "}$*${\tt "}) in the group
         expression represents the full basis file specification supplied
         in IGRP0, not just the file basename.
      }
      \sstsubsection{
         IGRP = INTEGER (Given and Returned)
      }{
         The GRP identifier for the group to which the supplied .sdf
         files are to be appended.
      }
      \sstsubsection{
         SIZE = INTEGER (Returned)
      }{
         The total number of file names in the returned group.
      }
      \sstsubsection{
         FLAG = LOGICAL (Returned)
      }{
         If the group expression was terminated by the GRP {\tt "}flag{\tt "}
         character, then FLAG is returned .TRUE. Otherwise it is
         returned .FALSE. Returned .FALSE. if an error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If an error is reported the group is returned unaltered.

         \sstitem
         A null value (!) can be given for the parameter to indicate
         that no more NDFs are to be specified. The corresponding error
         is annulled before returning unless no NDFs have been added to
         the group.

         \sstitem
         Explicit file types are included in all the elements of the returned
         group. This is done because the name may be passed out to a script (eg
         POLPACK:POLKA) which may change the value of NDF\_FORMATS\_OUT before
         using the NDF name. If no file type is supplied in the group
         expression, then the first file type listed in the current value of
         the NDF\_FORMATS\_OUT environment variable (see \xref{SSN/20}{ssn20}{}) is used. If
         this is {\tt "}$*${\tt "} then the file type is copied from the corresponding input
         file if a modification element was used to specify the output file
         name (if the NDF was not specified by a modification element, the
         second file type in NDF\_FORMATS\_OUT is used).

         \sstitem
         If the last character in the supplied group expression is
         a colon (:), a list of the NDFs represented by the group
         expression (minus the colon) is displayed, but none are
         actually added to the group. The user is then re-prompted for
         a new group expression.

         \sstitem
         The returned group has no associated groups holding supplemental
         information (unlike the group returned by NDG\_ASSOC).
      }
   }
}
\newpage
\sstroutine{
   NDG\_CREP1
}{
   Create a single new primitive NDF using a specified parameter
}{
   \sstdescription{
      This routine is equivalent to NDF\_CREP except that it allows the
      NDF to be specified using a GRP group expression (for instance, its
      name may be given within a text file, etc). The first NDF in the
      group expression is returned. Any other names in the group
      expression are ignored. Any modification elements in the supplied
      group expression will be treated literally.
   }
   \sstinvocation{
      CALL NDG\_CREP1( PARAM, FTYPE, NDIM, UBND, INDF, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the ADAM parameter.
      }
      \sstsubsection{
         FTYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Type of the NDF{\tt '}s DATA component (e.g. {\tt '}\_REAL{\tt '}). Note that
         complex types are not permitted when creating a primitive NDF.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of NDF dimensions.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         Upper pixel-index bounds of the NDF (the lower bound of each
         dimension is taken to be 1).
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The full file specification for the NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\newpage
\sstroutine{
   NDG\_GTSUP
}{
   Get supplemental information for an NDF
}{
   \sstdescription{
      Returns the supplemental information associated with a given entry
      in an NDG group.
   }
   \sstinvocation{
      CALL NDG\_GTSUP( IGRP, I, FIELDS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         The NDG group as returned by NDG\_ASSOC, etc. This should be the last
         group in a GRP owner-slave chain.
      }
      \sstsubsection{
         I = INTEGER (Given)
      }{
         The index of the required entry.
      }
      \sstsubsection{
         FIELDS( 6 ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The supplemental information associated with the entry specified
         by I. Each element of the returned array contains the following:
         \begin{enumerate}
            \item NDF slice specification (if any)
            \item HDS path (if any)
            \item File type
            \item Base file name
            \item Directory path
            \item Full NDF specification
         \end{enumerate}

         This information is obtained from a set of groups associated with
         the supplied group IGRP by means of a chain of GRP {\tt "}owner-slave{\tt "}
         relationships. If any of these groups do not exist, the correponding
         elements of the above array are returned blank. Note, element 6,
         the full NDF specification, is obtained directly from the supplied
         group IGRP.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\newpage
\sstroutine{
   NDG\_NDFAS
}{
   Obtain an NDF identifier for an existing NDF
}{
   \sstdescription{
      The routine returns an NDF identifier for an existing NDF. The
      name of the NDF is held at a given index within a given group.
      It is equivalent to NDF\_ASSOC.
   }
   \sstinvocation{
      CALL NDG\_NDFAS( IGRP, INDEX, MODE, INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         A GRP identifier for a group holding the names of NDFs. This
         will often be creted using NDG\_ASSOC, but groups created {\tt "}by
         hand{\tt "} using GRP directly (i.e. without the supplemental groups
         created by NDG\_ASSOC) can also be used.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index within the group at which the name of the NDF to be
         accessed is stored.
      }
      \sstsubsection{
         MODE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Type of NDF access required: {\tt '}READ{\tt '}, {\tt '}UPDATE{\tt '} or {\tt '}WRITE{\tt '}.
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If this routine is called with STATUS set, then a value of
         NDF\_\_NOID will be returned for the INDF argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. The NDF\_\_NOID
         constant is defined in the include file NDF\_PAR.
      }
   }
}
\newpage
\sstroutine{
   NDG\_NDFCO
}{
   Obtain an NDF identifier for a new NDF created by copying an existing NDF
}{
   \sstdescription{
      The routine returns an NDF identifier for a new NDF created by
      copying an existing NDF. The name of the new NDF is held
      at a given index within a given group. It is equivalent to NDF\_PROP.
   }
   \sstinvocation{
      CALL NDG\_NDFCO( INDF1, IGRP, INDEX, INDF2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF1 = INTEGER (Given)
      }{
         Identifier for an existing NDF (or NDF section) to act as a
         template.
      }
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         A GRP identifier for a group holding the names of NDFs. This
         will often be creted using NDG\_ASSOC, but groups created {\tt "}by
         hand{\tt "} using GRP directly (i.e. without the supplemental groups
         created by NDG\_ASSOC) can also be used.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index within the group at which the name of the NDF to be
         accessed is stored.
      }
      \sstsubsection{
         INDF2 = INTEGER (Returned)
      }{
         Identifier for the new NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If this routine is called with STATUS set, then a value of
         NDF\_\_NOID will be returned for the INDF2 argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. The NDF\_\_NOID
         constant is defined in the include file NDF\_PAR.
      }
   }
}
\newpage
\sstroutine{
   NDG\_NDFCP
}{
   Obtain an NDF identifier for a new primitive NDF
}{
   \sstdescription{
      The routine returns an NDF identifier for a new primitive NDF created
      with the specified attributes. The name of the new NDF is held
      at a given index within a given group. It is equivalent to NDF\_CREP.
   }
   \sstinvocation{
      CALL NDG\_NDFCP( IGRP, INDEX, FTYPE, NDIM, UBND, INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         A GRP identifier for a group holding the names of NDFs. This
         will often be creted using NDG\_ASSOC, but groups created {\tt "}by
         hand{\tt "} using GRP directly (i.e. without the supplemental groups
         created by NDG\_ASSOC) can also be used.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index within the group at which the name of the NDF to be
         created is stored.
      }
      \sstsubsection{
         FTYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Type of the NDF{\tt '}s DATA component (e.g. {\tt '}\_REAL{\tt '}). Note that
         complex types are not permitted when creating a primitive NDF.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of NDF dimensions.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         Upper pixel-index bounds of the NDF (the lower bound of each
         dimension is taken to be 1).
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\newpage
\sstroutine{
   NDG\_NDFCR
}{
   Obtain an NDF identifier for a new simple NDF
}{
   \sstdescription{
      The routine returns an NDF identifier for a new simple NDF created
      with the specified attributes. The name of the new NDF is held
      at a given index within a given group. It is equivalent to NDF\_CREAT.
   }
   \sstinvocation{
      CALL NDG\_NDFCR( IGRP, INDEX, FTYPE, NDIM, LBND, UBND, INDF,
                      STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         A GRP identifier for a group holding the names of NDFs. This
         will often be creted using NDG\_CREAT, but groups created {\tt "}by
         hand{\tt "} using GRP directly can also be used.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index within the group at which the name of the NDF to be
         created is stored.
      }
      \sstsubsection{
         FTYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Full data type of the NDF{\tt '}s DATA component (e.g. {\tt '}\_DOUBLE{\tt '} or
         {\tt '}COMPLEX\_REAL{\tt '}).
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of NDF dimensions.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Given)
      }{
         Lower pixel-index bounds of the NDF.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         Upper pixel-index bounds of the NDF.
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\newpage
\sstroutine{
   NDG\_NDFPR
}{
   Obtain an NDF identifier for a new NDF created by propagation from
   an existing NDF
}{
   \sstdescription{
      The routine returns an NDF identifier for a new NDF created by
      propagation from an existing NDF. The name of the new NDF is held
      at a given index within a given group. It is equivalent to NDF\_PROP.
   }
   \sstinvocation{
      CALL NDG\_NDFPR( INDF1, CLIST, IGRP, INDEX, INDF2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF1 = INTEGER (Given)
      }{
         Identifier for an existing NDF (or NDF section) to act as a
         template.
      }
      \sstsubsection{
         CLIST = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A comma-separated list of the NDF components which are to be
         propagated to the new data structure. By default, the HISTORY,
         LABEL and TITLE components and all extensions are propagated.
      }
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         A GRP identifier for a group holding the names of NDFs. This
         will often be creted using NDG\_ASSOC, but groups created {\tt "}by
         hand{\tt "} using GRP directly (i.e. without the supplemental groups
         created by NDG\_ASSOC) can also be used.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index within the group at which the name of the NDF to be
         accessed is stored.
      }
      \sstsubsection{
         INDF2 = INTEGER (Returned)
      }{
         Identifier for the new NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If this routine is called with STATUS set, then a value of
         NDF\_\_NOID will be returned for the INDF2 argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. The NDF\_\_NOID
         constant is defined in the include file NDF\_PAR.
      }
   }
}
\newpage
\sstroutine{
   NDG\_PROP1
}{
   Create a single new NDF by propagation using a specified parameter
}{
   \sstdescription{
      This routine is equivalent to NDF\_PROP except that it allows the
      NDF to be specified using a GRP group expression (for instance, its
      name may be given within a text file, etc). The first NDF in the
      group expression is returned. Any other names in the group
      expression are ignored. Modification elements use the name of the
      supplied NDF as the basis name.
   }
   \sstinvocation{
      CALL NDG\_PROP1( INDF1, CLIST, PARAM, INDF2, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF1 = INTEGER (Given)
      }{
         Identifier for an existing NDF (or NDF section) to act as a
         template.
      }
      \sstsubsection{
         CLIST = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A comma-separated list of the NDF components which are to be
         propagated to the new data structure. By default, the HISTORY,
         LABEL and TITLE components and all extensions are propagated.
      }
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the ADAM parameter for the new NDF.
      }
      \sstsubsection{
         INDF2 = INTEGER (Returned)
      }{
         Identifier for the new NDF.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The full file specification for the NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\newpage
\sstroutine{
   NDG\_PTSUP
}{
   Store suplemental information for an NDF
}{
   \sstdescription{
      Stores the supplied items of supplemental information for a given
      entry in an NDG group. The GRP groups needed to store this
      supplemental information are created if they do not already exist,
      and associated with the supplied group by means of a chain of GRP
      {\tt "}owner-slave{\tt "} relationships. They will be deleted automaticaly when
      the supplied group is deleted using GRP\_DELET.
   }
   \sstinvocation{
      CALL NDG\_PTSUP( IGRP, I, FIELDS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         The NDG group as returned by NDG\_ASSOC, etc. This should be the last
         group in a GRP owner-slave chain.
      }
      \sstsubsection{
         I = INTEGER (Given)
      }{
         The index of the required entry.
      }
      \sstsubsection{
         FIELDS( 6 ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The supplemental information to be stored with the entry specified
         by I. Each element of the supplied array should contain the
         following:
            \begin{enumerate}
            \item NDF slice specification (if any)
            \item HDS path (if any)
            \item File type
            \item Base file name
            \item Directory path
            \item Full NDF specification
            \end{enumerate}
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\newpage
\sstroutine{
   NDG\_SETSZ
}{
   Reduces the size of an NDG group
}{
   \sstdescription{
      This routine should be used instead of GRP\_SETSZ to set the size of
      a group created by NDG. It sets the size of the supplied group, and
      also sets the size of each of the aupplemental groups associated with
      the supplied group.
   }
   \sstinvocation{
      CALL NDG\_SETSZ( IGRP, SIZE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         The NDG group as returned by NDG\_ASSOC, etc. This should be the last
         group in a GRP owner-slave chain.
      }
      \sstsubsection{
         SIZE = INTEGER (Given)
      }{
         The new group size. Must be less than or equal to the size of the
         smallest group in the chain.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}

\newpage
\section{Changes Introduced in NDG Version 5.2}
\begin{itemize}
   \item The C routine ndg1\_regsb.c has been changed to avoid warning 
         message about "tmpnam" when linking applications on Redhat Linux 
	 systems.
\end{itemize}

\section{Changes Introduced in NDG Version 5.1}
\begin{itemize}
   \item A new routine NDG\_ASEXP has been added which allows a group of
         existing NDFs to be created from a group expression supplied as 
         a subroutine argument. This is very similar to NDG\_ASSOC except
         that NDG\_ASSOC gets the group expression from the parameter system
         instead of from its argument list.
\end{itemize}

\end{document}
