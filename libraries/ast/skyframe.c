/*
*class++
*  Name:
*     SkyFrame

*  Purpose:
*     Celestial coordinate system description.

*  Constructor Function:
c     astSkyFrame
f     AST_SKYFRAME

*  Description:
*     A SkyFrame is a specialised form of Frame which describes
*     celestial longitude/latitude coordinate systems. The particular
*     celestial coordinate system to be represented is specified by
*     setting the SkyFrame's System attribute (currently, the default
*     is FK5) qualified, as necessary, by a mean Equinox value and/or
*     an Epoch.
*
*     All the coordinate values used by a SkyFrame are in
*     radians. These may be formatted in more conventional ways for
c     display by using astFormat.
f     display by using AST_FORMAT.

*  Inheritance:
*     The SkyFrame class inherits from the Frame class.

*  Attributes:
*     In addition to those attributes common to all Frames, every
*     SkyFrame also has the following attributes:
*
*     - AsTime(axis): Format celestial coordinates as times?
*     - Epoch: Epoch of observation
*     - Equinox: Epoch of the mean equinox
*     - LatAxis: Index of the latitude axis
*     - LonAxis: Index of the longitude axis
*     - NegLon: Display longitude values in the range [-pi,pi]?
*     - Projection: Sky projection description.
*     - System: Celestial coordinate system

*  Functions:
c     The SkyFrame class does not define any new functions beyond those
f     The SkyFrame class does not define any new routines beyond those
*     which are applicable to all Frames.

*  Copyright:
*     <COPYRIGHT_STATEMENT>

*  Authors:
*     RFWS: R.F. Warren-Smith (Starlink)
*     DSB: David S. Berry (Starlink)

*  History:
*     4-MAR-1996 (RFWS):
*        Original version.
*     17-MAY-1996 (RFWS):
*        Tidied up, etc.
*     31-JUL-1996 (RFWS):
*        Added support for attributes and a public interface.
*     11-SEP-1996 (RFWS):
*        Added Gap (written by DSB).
*     24-SEP-1996 (RFWS):
*        Added I/O facilities.
*     27-FEB-1997 (RFWS):
*        Improved the public prologues.
*     27-MAY-1997 (RFWS):
*        Modified to use a new public interface to the SlaMap class
*        and to use the astSimplify method to remove redundant
*        conversions.
*     16-JUN-1997 (RFWS):
*        Fixed bug in axis associations returned by astMatch if axes
*        were swapped.
*     16-JUL-1997 (RFWS):
*        Added Projection attribute.
*     14-NOV-1997 (RFWS):
*        Corrected the omission of axis permutations from astNorm.
*     21-JAN-1998 (RFWS):
*        Ensure that Title and Domain values appropriate to a SkyFrame
*        are preserved if a Frame result is generated by SubFrame.
*     26-FEB-1998 (RFWS):
*        Over-ride the astUnformat method.
*     3-APR-2001 (DSB):
*        Added "Unknown" option for the System attribute. Added read-only
*        attributes LatAxis and LonAxis.
*     21-JUN-2001 (DSB):
*        Added astAngle and astOffset2.
*     4-SEP-2001 (DSB):
*        Added NegLon attribute, and astResolve method.
*     9-SEP-2001 (DSB):
*        Added astBear method.
*     21-SEP-2001 (DSB):
*        Removed astBear method.
*     10-OCT-2002 (DSB):
*        Moved definitions of macros for SkyFrame system values from
*        this file into skyframe.h.
*class--
*/

/* Module Macros. */
/* ============== */
/* Set the name of the class we are implementing. This indicates to
   the header files that define class interfaces that they should make
   "protected" symbols available. */
#define astCLASS SkyFrame

/* Header files. */
/* ============= */
/* Interface definitions. */
/* ---------------------- */
#include "error.h"               /* Error reporting facilities */
#include "memory.h"              /* Memory allocation facilities */
#include "object.h"              /* Base Object class */
#include "pointset.h"            /* Sets of points (for AST__BAD) */
#include "unitmap.h"             /* Unit Mappings */
#include "permmap.h"             /* Coordinate permutations */
#include "cmpmap.h"              /* Compound Mappings */
#include "slamap.h"              /* SLALIB sky coordinate Mappings */
#include "skyaxis.h"             /* Sky axes */
#include "frame.h"               /* Parent Frame class */
#include "skyframe.h"            /* Interface definition for this class */
#include "slalib.h"              /* SLALIB library interface */

/* Error code definitions. */
/* ----------------------- */
#include "ast_err.h"             /* AST error codes */

/* C header files. */
/* --------------- */
#include <ctype.h>
#include <float.h>
#include <limits.h>
#include <math.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdio.h>
#include <string.h>

/* Module Variables. */
/* ================= */
/* Define the class virtual function table and its initialisation flag as
   static variables. */
static AstSkyFrameVtab class_vtab; /* Virtual function table */
static int class_init = 0;       /* Virtual function table initialised? */

/* Pointers to parent class methods which are used or extended by this
   class. */
static const char *(* parent_format)( AstFrame *, int, double );
static const char *(* parent_getattrib)( AstObject *, const char * );
static const char *(* parent_getdomain)( AstFrame * );
static const char *(* parent_getformat)( AstFrame *, int );
static const char *(* parent_getlabel)( AstFrame *, int );
static const char *(* parent_getsymbol)( AstFrame *, int );
static const char *(* parent_gettitle)( AstFrame * );
static const char *(* parent_getunit)( AstFrame *, int );
static double (* parent_gap)( AstFrame *, int, double, int * );
static int (* parent_getdirection)( AstFrame *, int );
static int (* parent_match)( AstFrame *, AstFrame *, int **, int **, AstMapping **, AstFrame ** );
static int (* parent_subframe)( AstFrame *, AstFrame *, int, const int *, const int *, AstMapping **, AstFrame ** );
static int (* parent_testattrib)( AstObject *, const char * );
static int (* parent_testformat)( AstFrame *, int );
static int (* parent_unformat)( AstFrame *, int, const char *, double * );
static void (* parent_clearattrib)( AstObject *, const char * );
static void (* parent_clearformat)( AstFrame *, int );
static void (* parent_overlay)( AstFrame *, const int *, AstFrame * );
static void (* parent_setattrib)( AstObject *, const char * );
static void (* parent_setformat)( AstFrame *, int, const char * );
static void (* parent_setmaxaxes)( AstFrame *, int );
static void (* parent_setminaxes)( AstFrame *, int );

/* Prototypes for Private Member Functions. */
/* ======================================== */
static AstSkySystemType GetSystem( AstSkyFrame * );
static AstSkySystemType SystemCode( const char * );
static const char *FmtDecimalYr( double, int );
static const char *Format( AstFrame *, int, double );
static const char *GetAttrib( AstObject *, const char * );
static const char *GetDomain( AstFrame * );
static const char *GetFormat( AstFrame *, int );
static const char *GetLabel( AstFrame *, int );
static const char *GetProjection( AstSkyFrame * );
static const char *GetSymbol( AstFrame *, int );
static const char *GetTitle( AstFrame * );
static const char *GetUnit( AstFrame *, int );
static const char *SystemString( AstSkySystemType );
static double Angle( AstFrame *, const double[], const double[], const double[] );
static double Distance( AstFrame *, const double[], const double[] );
static double Gap( AstFrame *, int, double, int * );
static double GetEpoch( AstSkyFrame * );
static double GetEquinox( AstSkyFrame * );
static double Offset2( AstFrame *, const double[2], double, double, double[2] );
static double ReadDateTime( const char * );
static int ChrMatch( const char *, const char * );
static int GetAsTime( AstSkyFrame *, int );
static int GetDirection( AstFrame *, int );
static int GetLatAxis( AstSkyFrame * );
static int GetLonAxis( AstSkyFrame * );
static int GetNegLon( AstSkyFrame * );
static int IsEquatorial( AstSkySystemType );
static int MakeSkyMapping( AstSkyFrame *, AstSkyFrame *, AstMapping ** );
static int Match( AstFrame *, AstFrame *, int **, int **, AstMapping **, AstFrame ** );
static int SubFrame( AstFrame *, AstFrame *, int, const int *, const int *, AstMapping **, AstFrame ** );
static int TestAsTime( AstSkyFrame *, int );
static int TestAttrib( AstObject *, const char * );
static int TestEpoch( AstSkyFrame * );
static int TestEquinox( AstSkyFrame * );
static int TestNegLon( AstSkyFrame * );
static int TestProjection( AstSkyFrame * );
static int TestSystem( AstSkyFrame * );
static int Unformat( AstFrame *, int, const char *, double * );
static void ClearAsTime( AstSkyFrame *, int );
static void ClearAttrib( AstObject *, const char * );
static void ClearEpoch( AstSkyFrame * );
static void ClearEquinox( AstSkyFrame * );
static void ClearNegLon( AstSkyFrame * );
static void ClearProjection( AstSkyFrame * );
static void ClearSystem( AstSkyFrame * );
static void Copy( const AstObject *, AstObject * );
static void Delete( AstObject * );
static void Dump( AstObject *, AstChannel * );
static void InitVtab( AstSkyFrameVtab * );
static void Norm( AstFrame *, double[] );
static void Offset( AstFrame *, const double[], const double[], double, double[] );
static void Overlay( AstFrame *, const int *, AstFrame * );
static void Resolve( AstFrame *, const double [], const double [], const double [], double [], double *, double * );
static void SetAsTime( AstSkyFrame *, int, int );
static void SetAttrib( AstObject *, const char * );
static void SetEpoch( AstSkyFrame *, double );
static void SetEquinox( AstSkyFrame *, double );
static void SetNegLon( AstSkyFrame *, int );
static void SetMaxAxes( AstFrame *, int );
static void SetMinAxes( AstFrame *, int );
static void SetProjection( AstSkyFrame *, const char * );
static void SetSystem( AstSkyFrame *, AstSkySystemType );
static void Shapp( double, double *, double *, double, double * );
static void Shcal( double, double, double, double *, double * );

/* Member functions. */
/* ================= */
static double Angle( AstFrame *this_frame, const double a[], 
                     const double b[], const double c[] ) {
/*
*  Name:
*     Angle

*  Purpose:
*     Calculate the angle subtended by two points at a third point.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     double Angle( AstFrame *this_frame, const double a[], 
*                   const double b[], const double c[] )

*  Class Membership:
*     SkyFrame member function (over-rides the astAngle method
*     inherited from the Frame class).

*  Description:
*     This function finds the angle at point B between the line
*     joining points A and B, and the line joining points C 
*     and B. These lines will in fact be geodesic curves (great circles).

*  Parameters:
*     this
*        Pointer to the SkyFrame.
*     a 
*        An array of double, with one element for each SkyFrame axis,
*        containing the coordinates of the first point.
*     b 
*        An array of double, with one element for each SkyFrame axis,
*        containing the coordinates of the second point.
*     c 
*        An array of double, with one element for each SkyFrame axis,
*        containing the coordinates of the third point.

*  Returned Value:
*     The angle in radians, from the line AB to the line CB, in
*     the range $\pm \pi$ with positive rotation is in the same sense 
*     as rotation from axis 2 to axis 1.

*  Notes:
*     - This function will return a "bad" result value (AST__BAD) if
*     any of the input coordinates has this value.
*     - A "bad" value will also be returned if points A and B are
*     co-incident, or if points B and C are co-incident.
*     - A "bad" value will also be returned if this function is
*     invoked with the AST error status set, or if it should fail for
*     any reason.
*/

   AstSkyFrame *this;            /* Pointer to SkyFrame structure */
   const int *perm;              /* Axis permutation array */
   double aa[ 2 ];               /* Permuted a coordinates */
   double anga;                  /* Angle from north to the line BA */
   double angc;                  /* Angle from north to the line BC */
   double bb[ 2 ];               /* Permuted b coordinates */
   double cc[ 2 ];               /* Permuted c coordinates */
   double result;                /* Value to return */
   int stat;                     /* Status return from SLALIB */
   static double piby2;          /* Value of pi/2 */
   static int init = 0;          /* Value of pi/2 initialised? */

/* Initialise. */
   result = AST__BAD;

/* Check the global error status. */
   if ( !astOK ) return result;

/* If not already done, obtain a value for pi/2 from SLALIB by
   converting 90 degrees into radians. */
   if ( !init ) {   
      slaDaf2r( 90, 0, 0.0, &piby2, &stat );
      init = 1;
   }

/* Obtain a pointer to the SkyFrame structure. */
   this = (AstSkyFrame *) this_frame;

/* Obtain a pointer to the SkyFrame's axis permutation array. */
   perm = astGetPerm( this );
   if ( astOK ) {

/* Check that all supplied coordinates are OK. */
      if ( ( a[ 0 ] != AST__BAD ) && ( a[ 1 ] != AST__BAD ) &&
           ( b[ 0 ] != AST__BAD ) && ( b[ 1 ] != AST__BAD ) &&
           ( c[ 0 ] != AST__BAD ) && ( c[ 1 ] != AST__BAD ) ) {

/* Apply the axis permutation array to obtain the coordinates of the
   three points in the required (longitude,latitude) order. */
         aa[ perm[ 0 ] ] = a[ 0 ];
         aa[ perm[ 1 ] ] = a[ 1 ];
         bb[ perm[ 0 ] ] = b[ 0 ];
         bb[ perm[ 1 ] ] = b[ 1 ];
         cc[ perm[ 0 ] ] = c[ 0 ];
         cc[ perm[ 1 ] ] = c[ 1 ];

/* Check that A and B are not co-incident. */
         if( aa[ 0 ] != bb[ 0 ] || aa[ 1 ] != bb[ 1 ] ) {

/* Check that C and B are not co-incident. */
            if( cc[ 0 ] != bb[ 0 ] || cc[ 1 ] != bb[ 1 ] ) {

/* Find the angle from north to the line BA. */
               anga = slaDbear( bb[ 0 ], bb[ 1 ], aa[ 0 ], aa[ 1 ] );

/* Find the angle from north to the line BC. */
               angc = slaDbear( bb[ 0 ], bb[ 1 ], cc[ 0 ], cc[ 1 ] );

/* Find the difference. */
               result = angc - anga;

/* This value is the angle from north, but we want the angle from axis 2.
   If the axes have been swapped so that axis 2 is actually the longitude
   axis, then we need to correct this result. */
               if( perm[ 0 ] != 0 ) result = piby2 - result;

/* Fold the result into the range +/- PI. */
               result = slaDrange( result );
            }
         }
      }
   }

/* Return the result. */
   return result;
}

static int ChrMatch( const char *str1, const char *str2 ) {
/*
*  Name:
*     ChrMatch

*  Purpose:
*     Case insensitive string comparison.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     int ChrMatch( const char *str1, const char *str2 )

*  Class Membership:
*     SkyFrame member function.

*  Description:
*     This function compares two null terminated strings for equality,
*     discounting differences in case and any trailing white space in either
*     string.

*  Parameters:
*     str1
*        Pointer to the first string.
*     str2
*        Pointer to the second string.

*  Returned Value:
*     Non-zero if the two strings match, otherwise zero.

*  Notes:
*     -  A value of zero is returned if this function is invoked with the
*     global error status set or if it should fail for any reason.
*/

/* Local Variables: */
   int match;                    /* Strings match? */

/* Check the global error status. */
   if ( !astOK ) return 0;

/* Initialise. */
   match = 1;

/* Loop to compare characters in the two strings until a mis-match occurs or
   we reach the end of the longer string. */
   while ( match && ( *str1 || *str2 ) ) {

/* Two characters match if (a) we are at the end of one string and the other
   string contains white space or (b) both strings contain the same character
   when converted to lower case. */
      match = ( !*str1 && isspace( *str2 ) ) ||
              ( !*str2 && isspace( *str1 ) ) ||
              ( tolower( *str1 ) == tolower( *str2 ) );

/* Step through each string a character at a time until its end is reached. */
      if ( *str1 ) str1++;
      if ( *str2 ) str2++;
   }

/* Return the result. */
   return match;
}
   
static void ClearAsTime( AstSkyFrame *this, int axis ) {
/*
*  Name:
*     ClearAsTime

*  Purpose:
*     Clear the value of the AsTime attribute for a SkyFrame's axis.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     void ClearAsTime( AstSkyFrame *this, int axis )

*  Class Membership:
*     SkyFrame member function.

*  Description:
*     This function clears any value that has been set for the AsTime
*     attribute for a specified axis of a SkyFrame. This attribute indicates
*     whether axis values should be formatted as times (as opposed to angles)
*     by default.

*  Parameters:
*     this
*        Pointer to the SkyFrame.
*     axis
*        Index of the axis for which the value is to be cleared (zero based).

*  Returned Value:
*     void.
*/

/* Local Variables: */
   AstAxis *ax;                  /* Pointer to Axis object */

/* Check the global error status. */
   if ( !astOK ) return;

/* Validate the axis index. */
   (void) astValidateAxis( this, axis, "astClearAsTime" );

/* Obtain a pointer to the Axis object. */
   ax = astGetAxis( this, axis );

/* If the Axis is a SkyAxis, clear the AsTime attribute (if it is not a
   SkyAxis, it will not have this attribute anyway). */
   if ( astIsASkyAxis( ax ) ) astClearAxisAsTime( ax );

/* Annul the Axis pointer. */
   ax = astAnnul( ax );
}

static void ClearAttrib( AstObject *this_object, const char *attrib ) {
/*
*  Name:
*     ClearAttrib

*  Purpose:
*     Clear an attribute value for a SkyFrame.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     void ClearAttrib( AstObject *this, const char *attrib )

*  Class Membership:
*     SkyFrame member function (over-rides the astClearAttrib protected
*     method inherited from the Frame class).

*  Description:
*     This function clears the value of a specified attribute for a
*     SkyFrame, so that the default value will subsequently be used.

*  Parameters:
*     this
*        Pointer to the SkyFrame.
*     attrib
*        Pointer to a null terminated string specifying the attribute
*        name.  This should be in lower case with no surrounding white
*        space.

*  Notes:
*     - This function uses one-based axis numbering so that it is
*     suitable for external (public) use.
*/

/* Local Variables: */
   AstSkyFrame *this;            /* Pointer to the SkyFrame structure */
   int axis;                     /* SkyFrame axis number */
   int len;                      /* Length of attrib string */
   int nc;                       /* No. characters read by astSscanf */

/* Check the global error status. */
   if ( !astOK ) return;

/* Obtain a pointer to the SkyFrame structure. */
   this = (AstSkyFrame *) this_object;

/* Obtain the length of the "attrib" string. */
   len = strlen( attrib );

/* Check the attribute name and clear the appropriate attribute. */

/* AsTime(axis). */
/* ------------- */
   if ( nc = 0,
        ( 1 == astSscanf( attrib, "astime(%d)%n", &axis, &nc ) )
        && ( nc >= len ) ) {
      astClearAsTime( this, axis - 1 );

/* Epoch. */
/* ------ */
   } else if ( !strcmp( attrib, "epoch" ) ) {
      astClearEpoch( this );

/* Equinox. */
/* -------- */
   } else if ( !strcmp( attrib, "equinox" ) ) {
      astClearEquinox( this );

/* NegLon. */
/* ------- */
   } else if ( !strcmp( attrib, "neglon" ) ) {
      astClearNegLon( this );

/* Projection. */
/* ----------- */
   } else if ( !strcmp( attrib, "projection" ) ) {
      astClearProjection( this );

/* System. */
/* ------- */
   } else if ( !strcmp( attrib, "system" ) ) {
      astClearSystem( this );
   
/* If the name was not recognised, test if it matches any of the
   read-only attributes of this class. If it does, then report an
   error. */
   } else if ( !strcmp( attrib, "lataxis" ) ||
               !strcmp( attrib, "lonaxis" ) ) {
      astError( AST__NOWRT, "astClear: Invalid attempt to clear the \"%s\" "
                "value for a %s.", attrib, astGetClass( this ) );
      astError( AST__NOWRT, "This is a read-only attribute." );

/* If the attribute is not recognised, pass it on to the parent method
   for further interpretation. */
   } else {
      (*parent_clearattrib)( this_object, attrib );
   }
}

static double Distance( AstFrame *this_frame,
                        const double point1[], const double point2[] ) {
/*
*  Name:
*     Distance

*  Purpose:
*     Calculate the distance between two points.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     double Distance( AstFrame *this,
*                      const double point1[], const double point2[] )

*  Class Membership:
*     SkyFrame member function (over-rides the astDistance method
*     inherited from the Frame class).

*  Description:
*     This function finds the distance between two points whose
*     SkyFrame coordinates are given. The distance calculated is that
*     along the geodesic curve (i.e. great circle) that joins the two
*     points.

*  Parameters:
*     this
*        Pointer to the SkyFrame.
*     point1
*        An array of double, with one element for each SkyFrame axis,
*        containing the coordinates of the first point.
*     point2
*        An array of double, with one element for each SkyFrame axis,
*        containing the coordinates of the second point.

*  Returned Value:
*     The distance between the two points, in radians.

*  Notes:
*     - This function will return a "bad" result value (AST__BAD) if
*     any of the input coordinates has this value.
*     - A "bad" value will also be returned if this function is
*     invoked with the AST error status set or if it should fail for
*     any reason.
*/

/* Local Variables: */
   AstSkyFrame *this;            /* Pointer to SkyFrame structure */
   const int *perm;              /* Axis permutation array */
   double p1[ 2 ];               /* Permuted point1 coordinates */
   double p2[ 2 ];               /* Permuted point2 coordinates */
   double result;                /* Value to return */

/* Initialise. */
   result = AST__BAD;

/* Check the global error status. */
   if ( !astOK ) return result;

/* Obtain a pointer to the SkyFrame structure. */
   this = (AstSkyFrame *) this_frame;

/* Obtain a pointer to the SkyFrame's axis permutation array. */
   perm = astGetPerm( this );
   if ( astOK ) {

/* Check that all supplied coordinates are OK. */
      if ( ( point1[ 0 ] != AST__BAD ) && ( point1[ 1 ] != AST__BAD ) &&
           ( point2[ 0 ] != AST__BAD ) && ( point2[ 1 ] != AST__BAD ) ) {

/* Apply the axis permutation array to obtain the coordinates of the
   two points in the required (longitude,latitude) order. */
         p1[ perm[ 0 ] ] = point1[ 0 ];
         p1[ perm[ 1 ] ] = point1[ 1 ];
         p2[ perm[ 0 ] ] = point2[ 0 ];
         p2[ perm[ 1 ] ] = point2[ 1 ];

/* Calculate the great circle distance between the points in radians. */
         result = slaDsep( p1[ 0 ], p1[ 1 ], p2[ 0 ], p2[ 1 ] );
      }
   }

/* Return the result. */
   return result;
}

static const char *FmtDecimalYr( double year, int digits ) {
/*
*  Name:
*     FmtDecimalYr

*  Purpose:
*     Format an epoch expressed in years as a decimal string.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     const char *FmtDecimalYr( double year, int digits )

*  Class Membership:
*     SkyFrame member function.

*  Description:
*     This function formats an epoch expressed in years as a decimal string
*     and returns a pointer to the result. It is intended for formatting 
*     SkyFrame Equinox and Epoch values for display.

*  Parameters:
*     year
*        The epoch to be formatted.
*     digits
*        The number of digits of precision required.

*  Returned Value:
*     Pointer to a null terminated string containing the formatted value.

*  Notes:
*     - The result string is stored in static memory and may be
*     over-written by a subsequent invocation of this function.
*     - A NULL pointer is returned if this function is invoked with
*     the global error status set or if it should fail for any reason.
*/

/* Local Constants: */
#define BUFF_LEN 50              /* Max characters in result string */

/* Local Variables: */
   const char *result;           /* Pointer value to return */
   int nc;                       /* Number of characters in buffer */
   static char buff[ BUFF_LEN + 1 ]; /* Buffer for result string */

/* Check the global error status. */
   if ( !astOK ) return NULL;

/* Limit the precision to what is meaningful. */
   digits = ( digits > DBL_DIG ) ? DBL_DIG : digits;

/* Format the year value. Use "g" format to avoid buffer overflow and
   to get useful diagnostic output if a silly value is given. */
   nc = sprintf( buff, "%#.*g", digits, year );

/* Set the result value. */
   result = buff;

/* Loop to remove redundant zeros from the end of the result. */
   while ( buff[ --nc ] == '0' ) buff[ nc ] = '\0';

/* If the last character is now a decimal point, put back one zero. */
   if ( buff[ nc ] == '.' ) {
      buff[ ++nc ] = '0';
      buff[ ++nc ] = '\0';
   }

/* Return the result. */
   return buff;

/* Undefine macros local to this function. */
#undef BUFF_LEN
}

static const char *Format( AstFrame *this_frame, int axis, double value ) {
/*
*  Name:
*     Format

*  Purpose:
*     Format a coordinate value for a SkyFrame axis.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     const char *Format( AstFrame *this, int axis, double value )

*  Class Membership:
*     SkyFrame member function (over-rides the astFormat method inherited
*     from the Frame class).

*  Description:
*     This function returns a pointer to a string containing the formatted
*     (character) version of a coordinate value for a SkyFrame axis. The
*     formatting applied is that specified by a previous invocation of the
*     astSetFormat method. A suitable default format is applied if necessary,
*     and this may depend on which sky coordinate system the SkyFrame
*     describes.

*  Parameters:
*     this
*        Pointer to the SkyFrame.
*     axis
*        The number of the axis (zero-based) for which formatting is to be
*        performed.
*     value
*        The coordinate value to be formatted, in radians.

*  Returned Value:
*     A pointer to a null-terminated string containing the formatted value.

*  Notes:
*     -  A NULL pointer will be returned if this function is invoked with the
*     global error status set, or if it should fail for any reason.
*/

/* Local Variables: */
   AstSkyFrame *this;            /* Pointer to the SkyFrame structure */
   const char *result;           /* Pointer value to return */
   int format_set;               /* Format attribute set? */

/* Check the global error status. */
   if ( !astOK ) return NULL;

/* Obtain a pointer to the SkyFrame structure. */
   this = (AstSkyFrame *) this_frame;

/* Validate the axis index. */
   (void) astValidateAxis( this, axis, "astFormat" );

/* Determine if a Format value has been set for the axis and set a temporary
   value if it has not. Use the GetFormat member function for this class
   together with member functions inherited from the parent class (rather than
   using the object's methods directly) because if any of these methods have
   been over-ridden by a derived class the Format string syntax may no longer
   be compatible with this class. */
   format_set = (*parent_testformat)( this_frame, axis );
   if ( !format_set ) {
      (*parent_setformat)( this_frame, axis, GetFormat( this_frame, axis ) );
   }

/* Use the Format member function inherited from the parent class to format the
   value and return a pointer to the resulting string. */
   result = (*parent_format)( this_frame, axis, value );

/* If necessary, clear any temporary Format value that was set above. */
   if ( !format_set ) (*parent_clearformat)( this_frame, axis );

/* If an error occurred, clear the returned value. */
   if ( !astOK ) result = NULL;

/* Return the result. */
   return result;
}

static double Gap( AstFrame *this_frame, int axis, double gap, int *ntick ) {
/*
*  Name:
*     Gap

*  Purpose:
*     Find a "nice" gap for tabulating SkyFrame axis values.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     double Gap( AstFrame *this, int axis, double gap, int *ntick )

*  Class Membership:
*     SkyFrame member function (over-rides the protected astGap method
*     inherited from the Frame class).

*  Description:
*     This function returns a gap size which produces a nicely spaced
*     series of formatted values for a SkyFrame axis, the returned gap
*     size being as close as possible to the supplied target gap
*     size. It also returns a convenient number of divisions into
*     which the gap can be divided.

*  Parameters:
*     this
*        Pointer to the SkyFrame.
*     axis
*        The number of the axis (zero-based) for which a gap is to be found.
*     gap
*        The target gap size.
*     ntick
*        Address of an int in which to return a convenient number of
*        divisions into which the gap can be divided.

*  Returned Value:
*     The nice gap size.

*  Notes:
*     - A value of zero is returned if the target gap size is zero.
*     - A negative gap size is returned if the supplied gap size is negative.
*     - A value of zero will be returned if this function is invoked
*     with the global error status set, or if it should fail for any
*     reason.
*/

/* Local Variables: */
   AstSkyFrame *this;            /* Pointer to the SkyFrame structure */
   double result;                /* Gap value to return */
   int format_set;               /* Format attribute set? */

/* Check the global error status. */
   if ( !astOK ) return 0.0;

/* Obtain a pointer to the SkyFrame structure. */
   this = (AstSkyFrame *) this_frame;

/* Validate the axis index. */
   (void) astValidateAxis( this, axis, "astGap" );

/* Determine if a Format value has been set for the axis and set a
   temporary value if it has not. Use the GetFormat member function
   for this class together with member functions inherited from the
   parent class (rather than using the object's methods directly)
   because if any of these methods have been over-ridden by a derived
   class the Format string syntax may no longer be compatible with
   this class. */
   format_set = (*parent_testformat)( this_frame, axis );
   if ( !format_set ) {
      (*parent_setformat)( this_frame, axis, GetFormat( this_frame, axis ) );
   }

/* Use the Gap member function inherited from the parent class to find
   the gap size. */
   result = (*parent_gap)( this_frame, axis, gap, ntick );

/* If necessary, clear any temporary Format value that was set above. */
   if ( !format_set ) (*parent_clearformat)( this_frame, axis );

/* If an error occurred, clear the returned value. */
   if ( !astOK ) result = 0.0;

/* Return the result. */
   return result;
}

static int GetAsTime( AstSkyFrame *this, int axis ) {
/*
*  Name:
*     GetAsTime

*  Purpose:
*     Obtain the value of the AsTime attribute for a SkyFrame's axis.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     int GetAsTime( AstSkyFrame *this, int axis )

*  Class Membership:
*     SkyFrame member function.

*  Description:
*     This function returns the boolean value of the AsTime attribute for a
*     specified axis of a SkyFrame. This value indicates whether axis values
*     should be formatted as times (as opposed to angles) by default.

*  Parameters:
*     this
*        Pointer to the SkyFrame.
*     axis
*        Index of the axis for which information is required (zero based).

*  Returned Value:
*     Zero or one, according to the setting of the AsTime attribute (if no
*     value has previously been set, a suitable default is returned).

*  Notes:
*     -  A value of zero will be returned if this function is invoked with the
*     global error status set, or if it should fail for any reason.
*/

/* Local Variables: */
   AstAxis *ax;                  /* Pointer to Axis object */
   int axis_p;                   /* Permuted axis index */
   int result;                   /* Result to be returned */

/* Check the global error status. */
   if ( !astOK ) return 0;

/* Initialise. */
   result = 0;

/* Validate and permute the axis index. */
   axis_p = astValidateAxis( this, axis, "astGetAsTime" );

/* Obtain a pointer to the required Axis object. */
   ax = astGetAxis( this, axis );

/* Determine if the AsTime attribute has been set for the axis (this can only
   be the case if the object is a SkyAxis). If the attribute is set, obtain its
   value. */
   if ( astIsASkyAxis( ax ) && astTestAxisAsTime( ax ) ) {
      result = astGetAxisAsTime( ax );

/* Otherwise, check which (permuted) axis is involved. Only the first
   (longitude) axis may be displayed as a time by default. */
   } else if ( axis_p == 0 ) {

/* Test for those coordinate systems which normally have their longitude axes
   displayed as times (basically, those that involve the Earth's equator) and
   set the returned value appropriately. */
      result = IsEquatorial( astGetSystem( this ) );
   }

/* Annul the Axis object pointer. */
   ax = astAnnul( ax );

/* Return the result. */
   return result;
}

static const char *GetAttrib( AstObject *this_object, const char *attrib ) {
/*
*  Name:
*     GetAttrib

*  Purpose:
*     Get the value of a specified attribute for a SkyFrame.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     const char *GetAttrib( AstObject *this, const char *attrib )

*  Class Membership:
*     SkyFrame member function (over-rides the protected astGetAttrib
*     method inherited from the Frame class).

*  Description:
*     This function returns a pointer to the value of a specified
*     attribute for a SkyFrame, formatted as a character string.

*  Parameters:
*     this
*        Pointer to the SkyFrame.
*     attrib
*        Pointer to a null-terminated string containing the name of
*        the attribute whose value is required. This name should be in
*        lower case, with all white space removed.

*  Returned Value:
*     - Pointer to a null-terminated string containing the attribute
*     value.

*  Notes:
*     - This function uses one-based axis numbering so that it is
*     suitable for external (public) use.
*     - The returned string pointer may point at memory allocated
*     within the SkyFrame, or at static memory. The contents of the
*     string may be over-written or the pointer may become invalid
*     following a further invocation of the same function or any
*     modification of the SkyFrame. A copy of the string should
*     therefore be made if necessary.
*     - A NULL pointer will be returned if this function is invoked
*     with the global error status set, or if it should fail for any
*     reason.
*/

/* Local Constants: */
#define BUFF_LEN 50              /* Max. characters in result buffer */

/* Local Variables: */
   AstSkyFrame *this;            /* Pointer to the SkyFrame structure */
   AstSkySystemType system;      /* System attribute value */
   const char *result;           /* Pointer value to return */
   double epoch;                 /* Epoch attribute value (as MJD) */
   double equinox;               /* Equinox attribute value (as MJD) */
   int as_time;                  /* AsTime attribute value */
   int axis;                     /* SkyFrame axis number */
   int neglon;                   /* Display long. values as [-pi,pi]? */
   int len;                      /* Length of attrib string */
   int nc;                       /* No. characters read by astSscanf */
   static char buff[ BUFF_LEN + 1 ]; /* Buffer for string result */

/* Initialise. */
   result = NULL;

/* Check the global error status. */   
   if ( !astOK ) return result;

/* Obtain a pointer to the SkyFrame structure. */
   this = (AstSkyFrame *) this_object;

/* Obtain the length of the attrib string. */
   len = strlen( attrib );

/* Compare "attrib" with each recognised attribute name in turn,
   obtaining the value of the required attribute. If necessary, write
   the value into "buff" as a null-terminated string in an appropriate
   format.  Set "result" to point at the result string. */

/* AsTime(axis). */
/* ------------- */
   if ( nc = 0,
        ( 1 == astSscanf( attrib, "astime(%d)%n", &axis, &nc ) )
        && ( nc >= len ) ) {
      as_time = astGetAsTime( this, axis - 1 );
      if ( astOK ) {
         (void) sprintf( buff, "%d", as_time );
         result = buff;
      }

/* Epoch. */
/* ------ */
   } else if ( !strcmp( attrib, "epoch" ) ) {
      epoch = astGetEpoch( this );
      if ( astOK ) {

/* Format the Epoch as decimal years. Use a Besselian epoch if it will
   be less than 1984.0, otherwise use a Julian epoch. */
         result = FmtDecimalYr( ( epoch < slaEpj2d( 1984.0 ) ) ?
                                slaEpb( epoch ) : slaEpj( epoch ), DBL_DIG );
      }

/* Equinox. */
/* -------- */
   } else if ( !strcmp( attrib, "equinox" ) ) {
      equinox = astGetEquinox( this );
      if ( astOK ) {

/* Format the Equinox as decimal years. Use a Besselian epoch if it
   will be less than 1984.0, otherwise use a Julian epoch. */
         result = FmtDecimalYr( ( equinox < slaEpj2d( 1984.0 ) ) ?
                                slaEpb( equinox ) : slaEpj( equinox ),
                                DBL_DIG );
      }

/* LatAxis */
/* -------- */
   } else if ( !strcmp( attrib, "lataxis" ) ) {
      axis = astGetLatAxis( this );
      if ( astOK ) {
         (void) sprintf( buff, "%d", axis + 1 );
         result = buff;
      }

/* LonAxis */
/* -------- */
   } else if ( !strcmp( attrib, "lonaxis" ) ) {
      axis = astGetLonAxis( this );
      if ( astOK ) {
         (void) sprintf( buff, "%d", axis + 1 );
         result = buff;
      }

/* NegLon */
/* ------ */
   } else if ( !strcmp( attrib, "neglon" ) ) {
      neglon = astGetNegLon( this );
      if ( astOK ) {
         (void) sprintf( buff, "%d", neglon );
         result = buff;
      }

/* Projection. */
/* ----------- */
   } else if ( !strcmp( attrib, "projection" ) ) {
      result = astGetProjection( this );

/* System. */
/* ------- */
/* Obtain the System code and convert to a string. (Note that this
   will fail if derived classes have extended the range of codes in
   use, in which case they must also over-ride this attribute name in
   astGetAttrib to extend the range of strings returned.) */
   } else if ( !strcmp( attrib, "system" ) ) {
      system = astGetSystem( this );
      if ( astOK ) {
         result = SystemString( system );

/* Report an error if the value was not recognised. */
         if ( !result ) {
            astError( AST__SCSIN,
                     "astGetAttrib(%s): Corrupt %s contains invalid sky "
                     "coordinate system identification code (%d).",
                     astGetClass( this ), astGetClass( this ), (int) system );
         }   
      }

/* If the attribute name was not recognised, pass it on to the parent
   method for further interpretation. */
   } else {
      result = (*parent_getattrib)( this_object, attrib );
   }

/* Return the result. */
   return result;

/* Undefine macros local to this function. */
#undef BUFF_LEN
}

static int GetDirection( AstFrame *this_frame, int axis ) {
/*
*  Name:
*     GetDirection

*  Purpose:
*     Obtain the value of the Direction attribute for a SkyFrame axis.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     int GetDirection( AstFrame *this_frame, int axis )

*  Class Membership:
*     SkyFrame member function (over-rides the astGetDirection method inherited
*     from the Frame class).

*  Description:
*     This function returns the value of the Direction attribute for a
*     specified axis of a SkyFrame. A suitable default value is returned if no
*     Direction value has previously been set.

*  Parameters:
*     this
*        Pointer to the SkyFrame.
*     axis
*        Axis index (zero-based) identifying the axis for which information is
*        required.

*  Returned Value:
*     Zero or one, depending on the Direction attribute value.

*  Notes:
*     -  A value of zero will be returned if this function is invoked with the
*     global error status set, or if it should fail for any reason.
*/

/* Local Variables: */
   AstAxis *ax;                  /* Pointer to Axis object */
   AstSkyFrame *this;            /* Pointer to the SkyFrame structure */
   int as_time_set;              /* AsTime attribute set? */
   int axis_p;                   /* Permuted axis index */
   int is_latitude;              /* IsLatitude attribute value */
   int is_latitude_set;          /* IsLatitude attribute set? */
   int result;                   /* Result to be returned */
   int skyaxis;                  /* Axis object is a SkyAxis? */

/* Check the global error status. */
   if ( !astOK ) return 0;

/* Initialise. */
   result = 0;

/* Obtain a pointer to the SkyFrame structure. */
   this = (AstSkyFrame *) this_frame;

/* Validate and permute the axis index. */
   axis_p = astValidateAxis( this, axis, "astGetDirection" );

/* Check if a value has been set for the axis Direction attribute. If so,
   obtain its value. */
   if ( astTestDirection( this, axis ) ) {
      result = (*parent_getdirection)( this_frame, axis );

/* Otherwise, we will generate a default Direction value. Obtain a pointer to
   the Axis object for the SkyFrame's axis. */
   } else {
      ax = astGetAxis( this, axis );

/* Determine the settings of any attributes that may affect the default
   Direction value. */
      skyaxis = astIsASkyAxis( ax );
      if ( skyaxis ) {
         as_time_set = astTestAsTime( this, axis );
         is_latitude_set = astTestAxisIsLatitude( ax );
         is_latitude = astGetAxisIsLatitude( ax );

/* If no AsTime value is set for the axis, set a temporary value as determined
   by the astGetAsTime method, which supplies suitable defaults for the axes of
   a SkyFrame. */
         if ( !as_time_set ) {
            astSetAsTime( this, axis, astGetAsTime( this, axis ) );
         }

/* Temporarly over-ride the SkyAxis IsLatitude attribute, regardless of its
   setting, as the second axis of a SkyFrame is always the latitude axis. */
         astSetAxisIsLatitude( ax, axis_p == 1 );
      }

/* Invoke the parent method to obtain a default Direction value. */
      result = (*parent_getdirection)( this_frame, axis );

/* Now restore the attributes that were temporarily over-ridden above to their
   previous states. */
      if ( skyaxis ) {
         if ( !as_time_set ) astClearAsTime( this, axis );
         if ( !is_latitude_set ) {
            astClearAxisIsLatitude( ax );
         } else {
            astSetAxisIsLatitude( ax, is_latitude );
         }
      }

/* Annul the pointer to the Axis object. */
      ax = astAnnul( ax );
   }

/* If an error occurred, clear the result value. */
   if ( !astOK ) result = 0;

/* Return the result. */
   return result;
}

static const char *GetDomain( AstFrame *this_frame ) {
/*
*  Name:
*     GetDomain

*  Purpose:
*     Obtain a pointer to the Domain attribute string for a SkyFrame.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     const char *GetDomain( AstFrame *this )

*  Class Membership:
*     SkyFrame member function (over-rides the astGetDomain protected
*     method inherited from the Frame class).

*  Description:
*    This function returns a pointer to the Domain attribute string
*    for a SkyFrame.

*  Parameters:
*     this
*        Pointer to the SkyFrame.

*  Returned Value:
*     A pointer to a constant null-terminated string containing the
*     Domain value.

*  Notes:
*     - The returned pointer or the string it refers to may become
*     invalid following further invocation of this function or
*     modification of the SkyFrame.
*     - A NULL pointer is returned if this function is invoked with
*     the global error status set or if it should fail for any reason.
*/

/* Local Variables: */
   AstSkyFrame *this;            /* Pointer to SkyFrame structure */
   const char *result;           /* Pointer value to return */

/* Initialise. */
   result = NULL;

/* Check the global error status. */
   if ( !astOK ) return result;

/* Obtain a pointer to the SkyFrame structure. */
   this = (AstSkyFrame *) this_frame;

/* If a Domain attribute string has been set, invoke the parent method
   to obtain a pointer to it. */
   if ( astTestDomain( this ) ) {
      result = (*parent_getdomain)( this_frame );

/* Otherwise, provide a pointer to a suitable default string. */
   } else {
      result = "SKY";
   }

/* Return the result. */
   return result;
}

static const char *GetFormat( AstFrame *this_frame, int axis ) {
/*
*  Name:
*     GetFormat

*  Purpose:
*     Access the Format string for a SkyFrame axis.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     const char *GetFormat( AstFrame *this, int axis )

*  Class Membership:
*     SkyFrame member function (over-rides the astGetFormat method inherited
*     from the Frame class).

*  Description:
*     This function returns a pointer to the Format string for a specified axis
*     of a SkyFrame. A pointer to a suitable default string is returned if no
*     Format value has previously been set.

*  Parameters:
*     this
*        Pointer to the SkyFrame.
*     axis
*        Axis index (zero-based) identifying the axis for which information is
*        required.

*  Returned Value:
*     Pointer to a null-terminated character string containing the requested
*     information.

*  Notes:
*     -  A NULL pointer will be returned if this function is invoked with the
*     global error status set, or if it should fail for any reason.
*/

/* Local Constants: */
#define BUFF_LEN 50              /* Max characters in Format string */

/* Local Variables: */
   AstAxis *ax;                  /* Pointer to Axis object */
   AstSkyFrame *this;            /* Pointer to the SkyFrame structure */
   const char *result;           /* Pointer value to return */
   int as_time;                  /* Value of AsTime attribute */
   int as_time_set;              /* AsTime attribute set? */
   int axis_p;                   /* Permuted axis index */
   int digits;                   /* Number of digits of precision */
   int is_latitude;              /* Value of IsLatitude attribute */
   int is_latitude_set;          /* IsLatitude attribute set? */
   int parent;                   /* Use parent method? */
   int skyaxis;                  /* Is the Axis a SkyAxis? */
   static char buff[ BUFF_LEN + 1 ]; /* Local buffer for result string */

/* Check the global error status. */
   if ( !astOK ) return NULL;

/* Initialise. */
   result = NULL;

/* Obtain a pointer to the SkyFrame structure. */
   this = (AstSkyFrame *) this_frame;

/* Validate and permute the axis index. */
   axis_p = astValidateAxis( this, axis, "astGetFormat" );

/* Obtain a pointer to the Axis structure. */
   ax = astGetAxis( this, axis );

/* Decide whether the parent astGetFormat method is able to provide the format
   string we require. We must use the parent method if the Axis is not a
   SkyAxis, because the syntax of the Format string would become unsuitable
   for use with the Axis astFormat method if it was over-ridden here. We also
   use the parent method to return a Format pointer if an explicit Format
   string has already been set. */
   skyaxis = astIsASkyAxis( ax );
   parent = ( !skyaxis || (*parent_testformat)( this_frame, axis ) );

/* If neither of the above conditions apply, we may still be able to use the
   parent method if the Axis (actually a SkyAxis) is required to behave as a
   normal RA or DEC axis, as this is the standard behaviour provided by the
   SkyAxis class. Examine the SkyFrame's System attribute to determine if its
   axes should behave in this way. */
   if ( !parent ) parent = IsEquatorial( astGetSystem( this ) );

/* If using the parent method and dealing with a SkyAxis, determine the
   settings of any attributes that may affect the Format string. */
   if ( astOK ) {
      if ( parent ) {
         if ( skyaxis ) {
            as_time_set = astTestAsTime( this, axis );
            is_latitude_set = astTestAxisIsLatitude( ax );
            is_latitude = astGetAxisIsLatitude( ax );

/* If no AsTime value is set for the axis, set a temporary value as determined
   by the astGetAsTime method, which supplies suitable defaults for the axes of
   a SkyFrame. */
            if ( !as_time_set ) {
               astSetAsTime( this, axis, astGetAsTime( this, axis ) );
	    }

/* Temporarly over-ride the SkyAxis IsLatitude attribute, regardless of its
   setting, as the second axis of a SkyFrame is always the latitude axis. */
            astSetAxisIsLatitude( ax, axis_p == 1 );
         }

/* Invoke the parent method to obtain a pointer to the Format string. */
         result = (*parent_getformat)( this_frame, axis );

/* Now restore the attributes that were temporarily over-ridden above to their
   previous states. */
         if ( skyaxis ) {
            if ( !as_time_set ) astClearAsTime( this, axis );
            if ( !is_latitude_set ) {
               astClearAxisIsLatitude( ax );
            } else {
               astSetAxisIsLatitude( ax, is_latitude );
            }
         }

/* If the parent method is unsuitable, we must construct a new Format string
   here. This affects only those coordinate systems whose axes do not behave
   like standard RA/DEC axes (e.g. typically ecliptic, galactic and
   supergalactic coordinates). For these, we format values as decimal degrees
   (or decimal hours if the AsTime attribute is set). Obtain the AsTime
   value. */
      } else { 
         as_time = astGetAsTime( this, axis );

/* Determine how many digits of precision to use. This is obtained from the
   SkyAxis Digits attribute (if set), otherwise from the Digits attribute of
   the enclosing SkyFrame. */
         if ( astTestAxisDigits( ax ) ) {
            digits = astGetAxisDigits( ax );
         } else {
            digits = astGetDigits( this );
         }

/* If a time format is required, generate a Format string using decimal
   hours. */
         if ( astOK ) {
            if ( as_time ) {
               if ( digits <= 2 ) {
                  result = "h";
               } else {
                  (void) sprintf( buff, "h.%d", digits - 2 );
                  result = buff;
               }

/* Otherwise use decimal degrees. */
            } else {
               if ( digits <= 3 ) {
                  result = "d";
               } else {
                  (void) sprintf( buff, "d.%d", digits - 3 );
                  result = buff;
               }
	    }
	 }
      }
   }

/* Annul the Axis pointer. */
   ax = astAnnul( ax );

/* If an error occurred, clear the returned value. */
   if ( !astOK ) result = NULL;

/* Return the result. */
   return result;

/* Undefine macros local to this function. */
#undef BUFF_LEN
}

static const char *GetLabel( AstFrame *this, int axis ) {
/*
*  Name:
*     GetLabel

*  Purpose:
*     Access the Label string for a SkyFrame axis.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     const char *GetLabel( AstFrame *this, int axis )

*  Class Membership:
*     SkyFrame member function (over-rides the astGetLabel method inherited
*     from the Frame class).

*  Description:
*     This function returns a pointer to the Label string for a specified axis
*     of a SkyFrame.

*  Parameters:
*     this
*        Pointer to the SkyFrame.
*     axis
*        Axis index (zero-based) identifying the axis for which information is
*        required.

*  Returned Value:
*     Pointer to a constant null-terminated character string containing the
*     requested information.

*  Notes:
*     -  A NULL pointer will be returned if this function is invoked with the
*     global error status set, or if it should fail for any reason.
*/

/* Local Variables: */
   AstSkySystemType system;      /* Code identifying type of sky coordinates */
   const char *result;           /* Pointer to label string */
   int axis_p;                   /* Permuted axis index */

/* Check the global error status. */
   if ( !astOK ) return NULL;

/* Initialise. */
   result = NULL;

/* Validate and permute the axis index. */
   axis_p = astValidateAxis( this, axis, "astGetLabel" );

/* Check if a value has been set for the required axis label string. If so,
   invoke the parent astGetLabel method to obtain a pointer to it. */
   if ( astTestLabel( this, axis ) ) {
      result = (*parent_getlabel)( this, axis );

/* Otherwise, identify the sky coordinate system described by the SkyFrame. */
   } else {
      system = astGetSystem( this );

/* If OK, supply a pointer to a suitable default label string. */
      if ( astOK ) {

/* Equatorial coordinate systems. */
         if ( IsEquatorial( system ) ) {
	    result = ( axis_p == 0 ) ? "Right ascension" :
	                               "Declination";

/* Ecliptic coordinates. */
         } else if ( system == AST__ECLIPTIC ) {
	    result = ( axis_p == 0 ) ? "Ecliptic longitude" :
                                       "Ecliptic latitude";

/* Galactic coordinates. */
         } else if ( system == AST__GALACTIC ) {
	    result = ( axis_p == 0 ) ? "Galactic longitude" :
                                       "Galactic latitude";

/* Supergalactic coordinates. */
         } else if ( system == AST__SUPERGALACTIC ) {
	    result = ( axis_p == 0 ) ? "Supergalactic longitude" :
                                       "Supergalactic latitude";

/* Unknown spherical coordinates. */
         } else if ( system == AST__UNKNOWN ) {
	    result = ( axis_p == 0 ) ? "Longitude" :
                                       "Latitude";

/* Report an error if the coordinate system was not recognised. */
         } else {
	    astError( AST__SCSIN, "astGetLabel(%s): Corrupt %s contains "
		      "invalid sky coordinate system identification code "
		      "(%d).", astGetClass( this ), astGetClass( this ),
		      (int) system );
         }
      }
   }

/* Return the result. */
   return result;
}

static int GetLatAxis( AstSkyFrame *this ) {
/*
*  Name:
*     GetLatAxis

*  Purpose:
*     Obtain the index of the latitude axis of a SkyFrame.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     int GetLatAxis( AstSkyFrame *this )

*  Class Membership:
*     SkyFrame member function.

*  Description:
*     This function returns the zero-based index of the latitude axis of 
*     a SkyFrame, taking into account any current axis permutation.

*  Parameters:
*     this
*        Pointer to the SkyFrame.

*  Returned Value:
*     The zero based axis index (0 or 1) of the latitude axis.

*  Notes:
*     -  A value of one will be returned if this function is invoked with the
*     global error status set, or if it should fail for any reason.
*/

/* Local Variables: */
   int result;                   /* Result to be returned */
   const int *perm;              /* Axis permutation array */

/* Check the global error status. */
   if ( !astOK ) return 1;

/* Initialise. */
   result = 1;

/* Obtain a pointer to the SkyFrame's axis permutation array. */
   perm = astGetPerm( this );
   if ( astOK ) {

/* Identify the latitude axis. */
      if( perm[ 0 ] == 1 ) {
         result = 0;
      } else {
         result = 1;
      }

   }

/* Return the result. */
   return result;

}

static int GetLonAxis( AstSkyFrame *this ) {
/*
*  Name:
*     GetLonAxis

*  Purpose:
*     Obtain the index of the longitude axis of a SkyFrame.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     int GetLonAxis( AstSkyFrame *this )

*  Class Membership:
*     SkyFrame member function.

*  Description:
*     This function returns the zero-based index of the longitude axis of 
*     a SkyFrame, taking into account any current axis permutation.

*  Parameters:
*     this
*        Pointer to the SkyFrame.

*  Returned Value:
*     The zero based axis index (0 or 1) of the longitude axis.

*  Notes:
*     -  A value of zero will be returned if this function is invoked with the
*     global error status set, or if it should fail for any reason.
*/

/* Local Variables: */
   int result;                   /* Result to be returned */
   const int *perm;              /* Axis permutation array */

/* Check the global error status. */
   if ( !astOK ) return 0;

/* Initialise. */
   result = 0;

/* Obtain a pointer to the SkyFrame's axis permutation array. */
   perm = astGetPerm( this );
   if ( astOK ) {

/* Identify the longitude axis. */
      if( perm[ 0 ] == 0 ) {
         result = 0;
      } else {
         result = 1;
      }

   }

/* Return the result. */
   return result;

}

static const char *GetSymbol( AstFrame *this, int axis ) {
/*
*  Name:
*     GetSymbol

*  Purpose:
*     Obtain a pointer to the Symbol string for a SkyFrame axis.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     const char *GetSymbol( AstFrame *this, int axis )

*  Class Membership:
*     SkyFrame member function (over-rides the astGetSymbol method inherited
*     from the Frame class).

*  Description:
*     This function returns a pointer to the Symbol string for a specified axis
*     of a SkyFrame.

*  Parameters:
*     this
*        Pointer to the SkyFrame.
*     axis
*        Axis index (zero-based) identifying the axis for which information is
*        required.

*  Returned Value:
*     Pointer to a constant null-terminated character string containing the
*     requested information.

*  Notes:
*     -  A NULL pointer will be returned if this function is invoked with the
*     global error status set, or if it should fail for any reason.
*/

/* Local Variables: */
   AstSkySystemType system;      /* Code identifying type of sky coordinates */
   const char *result;           /* Pointer to symbol string */
   int axis_p;                   /* Permuted axis index */

/* Check the global error status. */
   if ( !astOK ) return NULL;

/* Initialise. */
   result = NULL;

/* Validate and permute the axis index. */
   axis_p = astValidateAxis( this, axis, "astGetSymbol" );

/* Check if a value has been set for the required axis symbol string. If so,
   invoke the parent astGetSymbol method to obtain a pointer to it. */
   if ( astTestSymbol( this, axis ) ) {
      result = (*parent_getsymbol)( this, axis );

/* Otherwise, identify the sky coordinate system described by the SkyFrame. */
   } else {
      system = astGetSystem( this );

/* If OK, supply a pointer to a suitable default Symbol string. */
      if ( astOK ) {

/* Equatorial coordinate systems. */
         if ( IsEquatorial( system ) ) {
	    result = ( axis_p == 0 ) ? "RA" : "Dec";

/* Ecliptic coordinates. */
         } else if ( system == AST__ECLIPTIC ) {
	    result = ( axis_p == 0 ) ? "Lambda" : "Beta";

/* Galactic coordinates. */
         } else if ( system == AST__GALACTIC ) {
	    result = ( axis_p == 0 ) ? "l" : "b";

/* Supergalactic coordinates. */
         } else if ( system == AST__SUPERGALACTIC ) {
	    result = ( axis_p == 0 ) ? "SGL" : "SGB";

/* Unknown spherical coordinates. */
         } else if ( system == AST__UNKNOWN ) {
	    result = ( axis_p == 0 ) ? "Lon" : "Lat";

/* Report an error if the coordinate system was not recognised. */
         } else {
	    astError( AST__SCSIN, "astGetSymbol(%s): Corrupt %s contains "
		      "invalid sky coordinate system identification code "
		      "(%d).", astGetClass( this ), astGetClass( this ),
		      (int) system );
         }
      }
   }

/* Return the result. */
   return result;
}

static const char *GetTitle( AstFrame *this_frame ) {
/*
*  Name:
*     GetTitle

*  Purpose:
*     Obtain a pointer to the Title string for a SkyFrame.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     const char *GetTitle( AstFrame *this_frame )

*  Class Membership:
*     SkyFrame member function (over-rides the astGetTitle method inherited
*     from the Frame class).

*  Description:
*     This function returns a pointer to the Title string for a SkyFrame.
*     A pointer to a suitable default string is returned if no Title value has
*     previously been set.

*  Parameters:
*     this
*        Pointer to the SkyFrame.

*  Returned Value:
*     Pointer to a null-terminated character string containing the requested
*     information.

*  Notes:
*     -  A NULL pointer will be returned if this function is invoked with the
*     global error status set, or if it should fail for any reason.
*/

/* Local Constants: */
#define BUFF_LEN 200             /* Max characters in result string */

/* Local Variables: */
   AstSkyFrame *this;            /* Pointer to SkyFrame structure */
   AstSkySystemType system;      /* Code identifying type of sky coordinates */
   const char *p;                /* Character pointer */
   const char *projection;       /* Pointer to sky projection description */
   const char *result;           /* Pointer to result string */
   double epoch;                 /* Value of Epoch attribute */
   double equinox;               /* Value of Equinox attribute */
   int lproj;                    /* Length of sky projection description */
   int pos;                      /* Buffer position to enter text */
   static char buff[ BUFF_LEN + 1 ]; /* Buffer for result string */

/* Check the global error status. */
   if ( !astOK ) return NULL;

/* Initialise. */
   result = NULL;

/* Obtain a pointer to the SkyFrame structure. */
   this = (AstSkyFrame *) this_frame;

/* See if a Title string has been set. If so, use the parent astGetTitle
   method to obtain a pointer to it. */
   if ( astTestTitle( this ) ) {
      result = (*parent_gettitle)( this_frame );

/* Otherwise, we will generate a default Title string. Obtain the values of the
   SkyFrame's attributes that determine what this string will be. */
   } else {
      epoch = astGetEpoch( this );
      equinox = astGetEquinox( this );
      projection = astGetProjection( this );
      system = astGetSystem( this );

/* Classify the coordinate system type and create an appropriate Title
   string.  (Note that when invoking the FmtDecimalYr function we must
   use a separate sprintf on each occasion so as not to over-write its
   internal buffer before the result string has been used.) */
      if ( astOK ) {
         result = buff;
         switch ( system ) {

/* FK4 equatorial coordinates. */
/* --------------------------- */
/* Display the Equinox and Epoch values. */
	 case AST__FK4:
	    pos = sprintf( buff,
		           "FK4 equatorial coordinates; mean equinox B%s; ",
		           FmtDecimalYr( slaEpb( equinox ), 9 ) );
            pos += sprintf( buff + pos,
                            "epoch B%s", FmtDecimalYr( slaEpb( epoch ), 9 ) );
	    break;

/* FK4 coordinates with no E-terms of aberration. */
/* ---------------------------------------------- */
/* Display the Equinox and Epoch values. */
	 case AST__FK4_NO_E:
	    pos = sprintf( buff,
			   "FK4 equatorial coordinates; no E-terms; mean "
			   "equinox B%s; ",
                           FmtDecimalYr( slaEpb( equinox ), 9 ) );
            pos += sprintf( buff + pos,
                            "epoch B%s", FmtDecimalYr( slaEpb( epoch ), 9 ) );
	    break;

/* FK5 equatorial coordinates. */
/* --------------------------- */
/* Display only the Equinox value. */
	 case AST__FK5:
	    pos = sprintf( buff,
                           "FK5 equatorial coordinates; mean equinox J%s",
                           FmtDecimalYr( slaEpj( equinox ), 9 ) );
	    break;

/* Geocentrc apparent equatorial coordinates. */
/* ------------------------------------------ */
/* Display only the Epoch value. */
	 case AST__GAPPT:
	    pos = sprintf( buff,
                           "Geocentric apparent equatorial coordinates; "
                           "epoch J%s", FmtDecimalYr( slaEpj( epoch ), 9 ) );
	    break;

/* Ecliptic coordinates. */
/* --------------------- */
/* Display only the Equinox value. */
	 case AST__ECLIPTIC:
	    pos = sprintf( buff,
                           "Ecliptic coordinates; mean equinox J%s",
                           FmtDecimalYr( slaEpj( equinox ), 9 ) );
	    break;

/* Galactic coordinates. */
/* --------------------- */
/* Do not display an Equinox or Epoch value. */
	 case AST__GALACTIC:
	    pos = sprintf( buff, "IAU (1958) galactic coordinates" );
	    break;

/* Supergalactic coordinates. */
/* -------------------------- */
/* Do not display an Equinox or Epoch value. */
	 case AST__SUPERGALACTIC:
	    pos = sprintf( buff,
                           "De Vaucouleurs supergalactic coordinates" );
	    break;

/* Unknown coordinates. */
/* -------------------------- */
	 case AST__UNKNOWN:
	    pos = sprintf( buff,
                           "Spherical coordinates" );
	    break;

/* Report an error if the coordinate system was not recognised. */
	 default:
	    astError( AST__SCSIN, "astGetTitle(%s): Corrupt %s contains "
		      "invalid sky coordinate system identification code "
		      "(%d).", astGetClass( this ), astGetClass( this ),
		     (int) system );
	    break;
         }

/* If OK, determine the length of the sky projection description,
   after removing trailing white space. */
         if ( astOK ) {
            for ( lproj = (int) strlen( projection ); lproj > 0; lproj-- ) {
               if ( !isspace( projection[ lproj - 1 ] ) ) break;
            }

/* If a non-blank description of the sky projection is available,
   append it to the title string, checking that the end of the buffer
   is not over-run. */
            if ( lproj ) {
               p = "; ";
               while ( ( pos < BUFF_LEN ) && *p ) buff[ pos++ ] = *p++;
               p = projection;
               while ( ( pos < BUFF_LEN ) &&
                       ( p < ( projection + lproj ) ) ) buff[ pos++ ] = *p++;
               p = " projection";
               while ( ( pos < BUFF_LEN ) && *p ) buff[ pos++ ] = *p++;
               buff[ pos ] = '\0';
            }
         }
      }
   }

/* If an error occurred, clear the returned pointer value. */
   if ( !astOK ) result = NULL;

/* Return the result. */
   return result;

/* Undefine macros local to this function. */
#undef BUFF_LEN
}

static const char *GetUnit( AstFrame *this_frame, int axis ) {
/*
*  Name:
*     astGetUnit

*  Purpose:
*     Obtain a pointer to the Unit string for a SkyFrame's axis.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     const char *GetUnit( AstFrame *this_frame, int axis )

*  Class Membership:
*     SkyFrame member function (over-rides the astGetUnit method inherited
*     from the Frame class).

*  Description:
*     This function returns a pointer to the Unit string for a specified axis
*     of a SkyFrame. If the Unit attribute has not been set for the axis, a
*     pointer to a suitable default string is returned instead. This string may
*     depend on the value of the Format attribute for the axis and, in turn, on
*     the type of sky coordinate system that the SkyFrame describes.

*  Parameters:
*     this
*        Pointer to the SkyFrame.
*     axis
*        The number of the axis (zero-based) for which information is required.

*  Returned Value:
*     A pointer to a null-terminated string containing the Unit value.

*  Notes:
*     -  A NULL pointer will be returned if this function is invoked with the
*     global error status set, or if it should fail for any reason.
*/

/* Local Variables: */
   AstSkyFrame *this;            /* Pointer to the SkyFrame structure */
   const char *result;           /* Pointer value to return */
   int format_set;               /* Format attribute set? */

/* Check the global error status. */
   if ( !astOK ) return NULL;

/* Obtain a pointer to the SkyFrame structure. */
   this = (AstSkyFrame *) this_frame;

/* Validate the axis index. */
   (void) astValidateAxis( this, axis, "astGetUnit" );

/* The Unit value may depend on the value of the Format attribute, so
   determine if a Format value has been set for the axis and set a
   temporary value if it has not. Use the GetFormat member function
   for this class together with member functions inherited from the
   parent class (rather than using the object's methods directly)
   because if any of these methods have been over-ridden by a derived
   class the Format string syntax may no longer be compatible with
   this class. */
   format_set = (*parent_testformat)( this_frame, axis );
   if ( !format_set ) {
      (*parent_setformat)( this_frame, axis, GetFormat( this_frame, axis ) );
   }

/* Use the parent GetUnit method to return a pointer to the required Unit
   string. */
   result = (*parent_getunit)( this_frame, axis );

/* If necessary, clear any temporary Format value that was set above. */
   if ( !format_set ) (*parent_clearformat)( this_frame, axis );

/* If an error occurred, clear the returned value. */
   if ( !astOK ) result = NULL;

/* Return the result. */
   return result;
}

static void InitVtab( AstSkyFrameVtab *vtab ) {
/*
*  Name:
*     InitVtab

*  Purpose:
*     Initialise a virtual function table for a SkyFrame.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     void InitVtab( AstSkyFrameVtab *vtab )

*  Class Membership:
*     SkyFrame member function.

*  Description:
*     This function initialises the component of a virtual function
*     table which is used by the SkyFrame class.

*  Parameters:
*     vtab
*        Pointer to the virtual function table. The components used by
*        all ancestral classes should already have been initialised.
*/

/* Local Variables: */
   AstFrameVtab *frame;          /* Pointer to Frame component of Vtab */
   AstObjectVtab *object;        /* Pointer to Object component of Vtab */

/* Check the local error status. */
   if ( !astOK ) return;

/* Store a unique "magic" value in the virtual function table. This
   will be used (by astIsASkyFrame) to determine if an object belongs
   to this class.  We can conveniently use the address of the (static)
   class_init variable to generate this unique value. */
   vtab->check = &class_init;

/* Initialise member function pointers. */
/* ------------------------------------ */
/* Store pointers to the member functions (implemented here) that
   provide virtual methods for this class. */
   vtab->ClearAsTime = ClearAsTime;
   vtab->ClearEpoch = ClearEpoch;
   vtab->ClearEquinox = ClearEquinox;
   vtab->ClearNegLon = ClearNegLon;
   vtab->ClearProjection = ClearProjection;
   vtab->ClearSystem = ClearSystem;
   vtab->GetAsTime = GetAsTime;
   vtab->GetEpoch = GetEpoch;
   vtab->GetEquinox = GetEquinox;
   vtab->GetNegLon = GetNegLon;
   vtab->GetLatAxis = GetLatAxis;
   vtab->GetLonAxis = GetLonAxis;
   vtab->GetProjection = GetProjection;
   vtab->GetSystem = GetSystem;
   vtab->SetAsTime = SetAsTime;
   vtab->SetEpoch = SetEpoch;
   vtab->SetEquinox = SetEquinox;
   vtab->SetNegLon = SetNegLon;
   vtab->SetProjection = SetProjection;
   vtab->SetSystem = SetSystem;
   vtab->TestAsTime = TestAsTime;
   vtab->TestEpoch = TestEpoch;
   vtab->TestEquinox = TestEquinox;
   vtab->TestNegLon = TestNegLon;
   vtab->TestProjection = TestProjection;
   vtab->TestSystem = TestSystem;

/* Save the inherited pointers to methods that will be extended, and
   replace them with pointers to the new member functions. */
   object = (AstObjectVtab *) vtab;
   frame = (AstFrameVtab *) vtab;

   parent_clearattrib = object->ClearAttrib;
   object->ClearAttrib = ClearAttrib;
   parent_getattrib = object->GetAttrib;
   object->GetAttrib = GetAttrib;
   parent_setattrib = object->SetAttrib;
   object->SetAttrib = SetAttrib;
   parent_testattrib = object->TestAttrib;
   object->TestAttrib = TestAttrib;

   parent_format = frame->Format;
   frame->Format = Format;
   parent_gap = frame->Gap;
   frame->Gap = Gap;
   parent_getdirection = frame->GetDirection;
   frame->GetDirection = GetDirection;
   parent_getdomain = frame->GetDomain;
   frame->GetDomain = GetDomain;
   parent_getformat = frame->GetFormat;
   frame->GetFormat = GetFormat;
   parent_getlabel = frame->GetLabel;
   frame->GetLabel = GetLabel;
   parent_getsymbol = frame->GetSymbol;
   frame->GetSymbol = GetSymbol;
   parent_gettitle = frame->GetTitle;
   frame->GetTitle = GetTitle;
   parent_getunit = frame->GetUnit;
   frame->GetUnit = GetUnit;
   parent_match = frame->Match;
   frame->Match = Match;
   parent_overlay = frame->Overlay;
   frame->Overlay = Overlay;
   parent_setmaxaxes = frame->SetMaxAxes;
   frame->SetMaxAxes = SetMaxAxes;
   parent_setminaxes = frame->SetMinAxes;
   frame->SetMinAxes = SetMinAxes;
   parent_subframe = frame->SubFrame;
   frame->SubFrame = SubFrame;
   parent_unformat = frame->Unformat;
   frame->Unformat = Unformat;

/* Store replacement pointers for methods which will be over-ridden by new
   member functions implemented here. */
   frame->Angle = Angle;
   frame->Distance = Distance;
   frame->Norm = Norm;
   frame->Resolve = Resolve;
   frame->Offset = Offset;
   frame->Offset2 = Offset2;

/* Store pointers to inherited methods that will be invoked explicitly
   by this class. */
   parent_clearformat = frame->ClearFormat;
   parent_setformat = frame->SetFormat;
   parent_testformat = frame->TestFormat;

/* Declare the copy constructor, destructor and class dump
   function. */
   astSetCopy( vtab, Copy );
   astSetDelete( vtab, Delete );
   astSetDump( vtab, Dump, "SkyFrame",
               "Description of celestial coordinate system" );
}

static int IsEquatorial( AstSkySystemType system ) {
/*
*  Name:
*     IsEquatorial

*  Purpose:
*     Test for an equatorial sky coordinate system.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     int IsEquatorial( AstSkySystemType system )

*  Class Membership:
*     SkyFrame member function.

*  Description:
*     This function returns a boolean value to indicate if a sky coordinate
*     system is equatorial.

*  Parameters:
*     system
*        Code to identify the sky coordinate system.

*  Returned Value:
*     Non-zero if the sky coordinate system is equatorial, otherwise zero.

*  Notes:
*     -  A value of zero is returned if this function is invoked with the
*     global error status set or if it should fail for any reason.
*/

/* Local Variables: */
   int result;                   /* Result value to return */

/* Check the global error status. */
   if ( !astOK ) return 0;

/* Determine if the sky coordinate system is an equatorial one. */
   result = ( ( system == AST__FK4 ) ||
              ( system == AST__FK4_NO_E ) ||
              ( system == AST__FK5 ) ||
              ( system == AST__GAPPT ) );

/* Return the result. */
   return result;
}

static int MakeSkyMapping( AstSkyFrame *target, AstSkyFrame *result,
                           AstMapping **map ) {
/*
*  Name:
*     MakeSkyMapping

*  Purpose:
*     Generate a Mapping between two SkyFrames.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     int MakeSkyMapping( AstSkyFrame *target, AstSkyFrame *result,
*                         AstMapping **map )

*  Class Membership:
*     SkyFrame member function.

*  Description:
*     This function takes two SkyFrames and generates a Mapping that
*     converts between them, taking account of differences in their
*     coordinate systems, equinox value, epoch, etc. (but not allowing
*     for any axis permutations).

*  Parameters:
*     target
*        Pointer to the first SkyFrame.
*     result
*        Pointer to the second SkyFrame.
*     map
*        Pointer to a location which is to receive a pointer to the
*        returned Mapping. The forward transformation of this Mapping
*        will convert from "target" coordinates to "result"
*        coordinates, and the inverse transformation will convert in
*        the opposite direction (all coordinate values in radians).

*  Returned Value:
*     Non-zero if the Mapping could be generated, or zero if the two
*     SkyFrames are sufficiently un-related that no meaningful Mapping
*     can be produced.

*  Notes:
*     A value of zero is returned if this function is invoked with the
*     global error status set or if it should fail for any reason.
*/

/* Local Constants: */
#define MAX_ARGS 2               /* Max arguments for an SlaMap conversion */

/* Local Variables: */
   AstSkySystemType system;      /* Code to identify coordinate system */
   AstSlaMap *slamap;            /* Pointer to SlaMap */
   double args[ MAX_ARGS ];      /* Conversion argument array */
   double epoch;                 /* Epoch as Modified Julian Date */
   double epoch_B;               /* Besselian epoch as decimal years */
   double equinox;               /* Equinox as Modified Julian Date */
   double equinox_B;             /* Besselian equinox as decimal years */
   double equinox_J;             /* Julian equinox as decimal years */
   int match;                    /* Mapping can be generated? */

/* Check the global error status. */
   if ( !astOK ) return 0;

/* Initialise the returned values. */
   match = 1;
   *map = NULL;

/* Create an initial (null) SlaMap. */
   slamap = astSlaMap( 0, "" );

/* Define local macros as shorthand for adding sky coordinate
   conversions to this SlaMap.  Each macro simply stores details of
   the additional arguments in the "args" array and then calls
   astSlaAdd. The macros differ in the number of additional argument
   values. */
#define TRANSFORM_0(cvt) \
        astSlaAdd( slamap, cvt, NULL );

#define TRANSFORM_1(cvt,arg0) \
        args[ 0 ] = arg0; \
        astSlaAdd( slamap, cvt, args );

#define TRANSFORM_2(cvt,arg0,arg1) \
        args[ 0 ] = arg0; \
        args[ 1 ] = arg1; \
        astSlaAdd( slamap, cvt, args );

/* Convert _to_ FK5 J2000.0 coordinates. */
/* ===================================== */
/* The overall conversion is formulated in two phases. In this first
   phase, we convert from the target coordinate system to standard sky
   coordinates expressed using the FK5 system, mean equinox
   J2000.0. */

/* Obtain the sky coordinate system, equinox and epoch of the target
   SkyFrame. */
   system = astGetSystem( target );
   equinox = astGetEquinox( target );
   epoch = astGetEpoch( target );
   if ( astOK ) {

/* Convert the equinox and epoch values (stored as Modified Julian
   Dates) into the equivalent Besselian and Julian epochs (as decimal
   years). */
      equinox_B = slaEpb( equinox );
      equinox_J = slaEpj( equinox );
      epoch_B = slaEpb( epoch );

/* Formulate the conversion... */

/* From FK4. */
/* --------- */
/* If necessary, apply the old-style FK4 precession model to bring the
   equinox to B1950.0, with rigorous handling of the E-terms of
   aberration. Then convert directly to FK5 J2000.0 coordinates. */
      if ( system == AST__FK4 ) {
         if ( equinox_B != 1950.0 ) {
            TRANSFORM_1( "SUBET", equinox_B )
            TRANSFORM_2( "PREBN", equinox_B, 1950.0 )
            TRANSFORM_1( "ADDET", 1950.0 )
         }
         TRANSFORM_1( "FK45Z", epoch_B )

/* From FK4 with no E-terms. */
/* ------------------------- */
/* This is the same as above, except that we do not need to subtract
   the E-terms initially as they are already absent. */
      } else if ( system == AST__FK4_NO_E ) {
         if ( equinox_B != 1950.0 ) {
            TRANSFORM_2( "PREBN", equinox_B, 1950.0 )
         }
         TRANSFORM_1( "ADDET", 1950.0 )
         TRANSFORM_1( "FK45Z", epoch_B )

/* From FK5. */
/* --------- */
/* We simply need to apply a precession correction for the change of
   equinox.  Omit even this if the equinox is already J2000.0. */
      } else if ( system == AST__FK5 ) {
         if ( equinox_J != 2000.0 ) {
            TRANSFORM_2( "PREC", equinox_J, 2000.0 );
         }

/* From geocentric apparent. */
/* ------------------------- */
/* This conversion is supported directly by SLALIB. */
      } else if ( system == AST__GAPPT ) {
         TRANSFORM_2( "AMP", epoch, 2000.0 )

/* From ecliptic coordinates. */
/* -------------------------- */
/* This conversion is supported directly by SLALIB. */
      } else if ( system == AST__ECLIPTIC ) {
         TRANSFORM_1( "ECLEQ", equinox )

/* From galactic coordinates. */
/* -------------------------- */
/* This conversion is supported directly by SLALIB. */
      } else if ( system == AST__GALACTIC ) {
         TRANSFORM_0( "GALEQ" )

/* From supergalactic coordinates. */
/* ------------------------------- */
/* Convert to galactic coordinates and then to FK5 J2000.0
   equatorial. */
      } else if ( system == AST__SUPERGALACTIC ) {
         TRANSFORM_0( "SUPGAL" )
         TRANSFORM_0( "GALEQ" )

/* From unknown coordinates. */
/* ------------------------------- */
/* No conversion is possible. */
      } else if ( system == AST__UNKNOWN ) {
         match = 0;
      }
   }

/* Convert _from_ FK5 J2000.0 coordinates. */
/* ======================================= */
/* In this second phase, we convert to the result coordinate system
   from the standard sky coordinates generated above. */

/* Obtain the sky coordinate system, equinox and epoch of the result
   SkyFrame. */
   system = astGetSystem( result );
   equinox = astGetEquinox( result );
   epoch = astGetEpoch( result );
   if ( astOK && match ) {

/* Convert the equinox and epoch values (stored as Modified Julian
   Dates) into the equivalent Besselian and Julian epochs (as decimal
   years). */
      equinox_B = slaEpb( equinox );
      equinox_J = slaEpj( equinox );
      epoch_B = slaEpb( epoch );

/* To FK4. */
/* ------- */
/* Convert directly from FK5 J2000.0 to FK4 B1950.0 coordinates at the
   appropriate epoch. Then, if necessary, apply the old-style FK4
   precession model to bring the equinox to that required, with
   rigorous handling of the E-terms of aberration. */
      if ( system == AST__FK4 ) {
         TRANSFORM_1( "FK54Z", epoch_B )
         if ( equinox_B != 1950.0 ) {
            TRANSFORM_1( "SUBET", 1950.0 )
            TRANSFORM_2( "PREBN", 1950.0, equinox_B )
            TRANSFORM_1( "ADDET", equinox_B )
         }

/* To FK4 with no E-terms. */
/* ----------------------- */
/* This is the same as above, except that we do not need to add the
   E-terms at the end. */
      } else if ( system == AST__FK4_NO_E ) {
         TRANSFORM_1( "FK54Z", epoch_B )
         TRANSFORM_1( "SUBET", 1950.0 )
         if ( equinox_B != 1950.0 ) {
            TRANSFORM_2( "PREBN", 1950.0, equinox_B )
         }

/* To FK5. */
/* ------- */
/* We simply need to apply a precession correction for the change of
   equinox.  Omit even this if the required equinox is J2000.0. */
      } else if ( system == AST__FK5 ) {
         if ( equinox_J != 2000.0 ) {
            TRANSFORM_2( "PREC", 2000.0, equinox_J )
         }

/* To geocentric apparent. */
/* ----------------------- */
/* This conversion is supported directly by SLALIB. */
      } else if ( system == AST__GAPPT ) {
         TRANSFORM_2( "MAP", 2000.0, epoch )

/* To ecliptic coordinates. */
/* ------------------------ */
/* This conversion is supported directly by SLALIB. */
      } else if ( system == AST__ECLIPTIC ) {
         TRANSFORM_1( "EQECL", equinox )

/* To galactic coordinates. */
/* ------------------------ */
/* This conversion is supported directly by SLALIB. */
      } else if ( system == AST__GALACTIC ) {
         TRANSFORM_0( "EQGAL" )

/* To supergalactic coordinates. */
/* ----------------------------- */
/* Convert to galactic coordinates and then to supergalactic. */
      } else if ( system == AST__SUPERGALACTIC ) {
         TRANSFORM_0( "EQGAL" )
         TRANSFORM_0( "GALSUP" )

/* To unknown coordinates. */
/* ----------------------------- */
/* No conversion is possible. */
      } else if ( system == AST__UNKNOWN ) {
         match = 0;
      }
   }

/* Simplify the SlaMap produced above (this eliminates any redundant
   conversions) and annul the original pointer. */
   *map = astSimplify( slamap );
   slamap = astAnnul( slamap );

/* If an error occurred, annul the returned Mapping and clear the
   returned values. */
   if ( !astOK ) {
      *map = astAnnul( *map );
      match = -1;
   }

/* Return the result. */
   return match;

/* Undefine macros local to this function. */
#undef MAX_ARGS
#undef TRANSFORM_0
#undef TRANSFORM_1
#undef TRANSFORM_2
}

static int Match( AstFrame *template_frame, AstFrame *target,
                  int **template_axes, int **target_axes, AstMapping **map,
                  AstFrame **result ) {
/*
*  Name:
*     Match

*  Purpose:
*     Determine if conversion is possible between two coordinate systems.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     int Match( AstFrame *template, AstFrame *target,
*                int **template_axes, int **target_axes,
*                AstMapping **map, AstFrame **result )

*  Class Membership:
*     SkyFrame member function (over-rides the protected astMatch method
*     inherited from the Frame class).

*  Description:
*     This function matches a "template" SkyFrame to a "target" Frame and
*     determines whether it is possible to convert coordinates between them.
*     If it is, a mapping that performs the transformation is returned along
*     with a new Frame that describes the coordinate system that results when
*     this mapping is applied to the "target" coordinate system. In addition,
*     information is returned to allow the axes in this "result" Frame to be
*     associated with the corresponding axes in the "target" and "template"
*     Frames from which they are derived.

*  Parameters:
*     template
*        Pointer to the template SkyFrame. This describes the coordinate system
*        (or set of possible coordinate systems) into which we wish to convert
*        our coordinates.
*     target
*        Pointer to the target Frame. This describes the coordinate system in
*        which we already have coordinates.
*     template_axes
*        Address of a location where a pointer to int will be returned if the
*        requested coordinate conversion is possible. This pointer will point
*        at a dynamically allocated array of integers with one element for each
*        axis of the "result" Frame (see below). It must be freed by the caller
*        (using astFree) when no longer required.
*
*        For each axis in the result Frame, the corresponding element of this
*        array will return the index of the template SkyFrame axis from which
*        it is derived. If it is not derived from any template SkyFrame axis,
*        a value of -1 will be returned instead.
*     target_axes
*        Address of a location where a pointer to int will be returned if the
*        requested coordinate conversion is possible. This pointer will point
*        at a dynamically allocated array of integers with one element for each
*        axis of the "result" Frame (see below). It must be freed by the caller
*        (using astFree) when no longer required.
*
*        For each axis in the result Frame, the corresponding element of this
*        array will return the index of the target Frame axis from which it
*        is derived. If it is not derived from any target Frame axis, a value
*        of -1 will be returned instead.
*     map
*        Address of a location where a pointer to a new Mapping will be
*        returned if the requested coordinate conversion is possible. If
*        returned, the forward transformation of this Mapping may be used to
*        convert coordinates between the "target" Frame and the "result"
*        Frame (see below) and the inverse transformation will convert in the
*        opposite direction.
*     result
*        Address of a location where a pointer to a new Frame will be returned
*        if the requested coordinate conversion is possible. If returned, this
*        Frame describes the coordinate system that results from applying the
*        returned Mapping (above) to the "target" coordinate system. In
*        general, this Frame will combine attributes from (and will therefore
*        be more specific than) both the target and the template Frames. In
*        particular, when the template allows the possibility of transformaing
*        to any one of a set of alternative coordinate systems, the "result"
*        Frame will indicate which of the alternatives was used.

*  Returned Value:
*     A non-zero value is returned if the requested coordinate conversion is
*     possible. Otherwise zero is returned (this will not in itself result in
*     an error condition).

*  Notes:
*     -  A value of zero will be returned if this function is invoked with the
*     global error status set, or if it should fail for any reason.

*  Implementation Notes:
*     This implementation addresses the matching of a SkyFrame class object to
*     any other class of Frame. A SkyFrame will match any class of SkyFrame
*     (i.e. possibly from a derived class) but will not match a less
*     specialised class of Frame.
*/

/* Local Variables: */
   AstFrame *frame0;             /* Pointer to Frame underlying axis 0 */
   AstFrame *frame1;             /* Pointer to Frame underlying axis 1 */
   AstSkyFrame *template;        /* Pointer to template SkyFrame structure */
   int iaxis0;                   /* Axis index underlying axis 0 */
   int iaxis1;                   /* Axis index underlying axis 1 */
   int match;                    /* Coordinate conversion possible? */
   int swap1;                    /* Template axes swapped? */
   int swap2;                    /* Target axes swapped? */
   int swap;                     /* Additional axis swap needed? */
   int target_naxes;             /* Number of target axes */

/* Initialise the returned values. */
   *template_axes = NULL;
   *target_axes = NULL;
   *map = NULL;
   *result = NULL;
   match = 0;

/* Check the global error status. */
   if ( !astOK ) return match;

/* Obtain a pointer to the template SkyFrame structure. */
   template = (AstSkyFrame *) template_frame;

/* Obtain the number of axes in the target Frame. */
   target_naxes = astGetNaxes( target );

/* The first criterion for a match is that the template matches as a
   Frame class object. This ensures that the number of axes (2) and
   domain, etc. of the target Frame are suitable. Invoke the parent
   "astMatch" method to verify this. */
   match = (*parent_match)( template_frame, target,
                            template_axes, target_axes, map, result );

/* If a match was found, annul the returned objects, which are not
   needed, but keep the memory allocated for the axis association
   arrays, which we will re-use. */
   if ( astOK && match ) {
      *map = astAnnul( *map );
      *result = astAnnul( *result );
   }

/* If OK so far, obtain pointers to the primary Frames which underlie
   both target axes. */
   if ( match && astOK ) {
      astPrimaryFrame( target, 0, &frame0, &iaxis0 );
      astPrimaryFrame( target, 1, &frame1, &iaxis1 );

/* The next criterion for a match is that the first of these Frames
   must be a SkyFrame (or from a class derived from SkyFrame). */
      match = astIsASkyFrame( frame0 );

/* If this test is passed, we can now test that the second Frame is
   the same one as the first one, and that the underlying axis indices
   are 0 and 1, in either order. This then ensures that we have a
   single SkyFrame (not a compound Frame) with both axes present. */
      if ( match && astOK ) {
         match = ( frame0 == frame1 ) &&
                 ( ( ( iaxis0 == 0 ) && ( iaxis1 == 1 ) ) ||
                   ( ( iaxis1 == 0 ) && ( iaxis0 == 1 ) ) );
      }

/* Annul the Frame pointers used in the above tests. */
      frame0 = astAnnul( frame0 );
      frame1 = astAnnul( frame1 );
   }

/* If a possible match has been detected, we must now decide how the
   order of the axes in the result Frame relates to the order of axes
   in the target Frame. There are two factors involved. The first
   depends on whether the axis permutation array for the template
   SkyFrame (whose method we are executing) causes an axis
   reversal. Determine this by permuting axis index zero. */
   if ( astOK && match ) {
      swap1 = ( astValidateAxis( template, 0, "astMatch" ) != 0 );

/* The second factor depends on whether the axes of the underlying
   primary SkyFrame are reversed when seen in the target Frame. */
      swap2 = ( iaxis0 != 0 );

/* Combine these to determine if an additional axis swap will be
   needed. */
      swap = ( swap1 != swap2 );

/* Now check to see if this additional swap is permitted by the
   template's Permute attribute. */
      match = ( !swap || astGetPermute( template ) );
   }

/* If the Frames still match, we next set up the axis association
   arrays. */
   if ( astOK && match ) {

/* If the target axis order is to be preserved, then the target axis
   association involves no permutation but the template axis
   association may involve an axis swap. */
      if ( astGetPreserveAxes( template ) ) {
         (*template_axes)[ 0 ] = swap;
         (*template_axes)[ 1 ] = !swap;
         (*target_axes)[ 0 ] = 0;
         (*target_axes)[ 1 ] = 1;

/* Otherwise, any swap applies to the target axis association
   instead. */
      } else {
         (*template_axes)[ 0 ] = 0;
         (*template_axes)[ 1 ] = 1;
         (*target_axes)[ 0 ] = swap;
         (*target_axes)[ 1 ] = !swap;
      }

/* Use the target's "astSubFrame" method to create a new Frame (the
   result Frame) with copies of the target axes in the required
   order. This process also overlays the template attributes on to the
   target Frame and returns a Mapping between the target and result
   Frames which effects the required coordinate conversion. */
      match = astSubFrame( target, template, 2, *target_axes, *template_axes,
                           map, result );

/* If an error occurred, or conversion to the result Frame's
   coordinate system was not possible, then free all memory, annul the
   returned objects, and reset the returned value. */
      if ( !astOK || !match ) {
         *template_axes = astFree( *template_axes );
         *target_axes = astFree( *target_axes );
         *map = astAnnul( *map );
         *result = astAnnul( result );
         match = 0;
      }
   }

/* Return the result. */
   return match;
}

static void Norm( AstFrame *this_frame, double value[] ) {
/*
*  Name:
*     Norm

*  Purpose:
*     Normalise a set of SkyFrame coordinates.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     void Norm( AstAxis *this, double value[] )

*  Class Membership:
*     SkyFrame member function (over-rides the astNorm method inherited
*     from the Frame class).

*  Description:
*     This function converts a set of SkyFrame coordinate values,
*     which might potentially be unsuitable for display to a user (for
*     instance, may lie outside the expected range of values) into a
*     set of acceptable alternative values suitable for display.
*
*     This is done by wrapping coordinates so that the latitude lies
*     in the range (-pi/2.0) <= latitude <= (pi/2.0). If the NegLon
*     attribute is zero (the default), then the wrapped longitude value 
*     lies in the range 0.0 <= longitude < (2.0*pi). Otherwise, it lies
*     in the range -pi <= longitude < pi.

*  Parameters:
*     this
*        Pointer to the SkyFrame.
*     value
*        An array of double, with one element for each SkyFrame axis.
*        This should contain the initial set of coordinate values,
*        which will be modified in place.
*/

/* Local Variables: */
   AstSkyFrame *this;            /* Pointer to the SkyFrame structure */
   const int *perm;              /* Axis permutation array */
   double sky_lat;               /* Sky latitude value */
   double sky_long;              /* Sky longitude value */
   double v[ 2 ];                /* Permuted value coordinates */
   int stat;                     /* Status return from SLALIB */
   static double pi;             /* Value of pi */
   static int init = 0;          /* Value of pi initialised? */

/* Check the global error status. */
   if ( !astOK ) return;

/* If not already done, obtain a value for pi from SLALIB by
   converting 180 degrees into radians. */
   if ( !init ) {   
      slaDaf2r( 180, 0, 0.0, &pi, &stat );
      init = 1;
   }

/* Obtain a pointer to the SkyFrame structure. */
   this = (AstSkyFrame *) this_frame;

/* Obtain a pointer to the SkyFrame's axis permutation array. */
   perm = astGetPerm( this );
   if ( astOK ) {

/* Obtain the sky longitude and latitude values, allowing for any axis
   permutation. */
      v[ perm[ 0 ] ] = value[ 0 ];
      v[ perm[ 1 ] ] = value[ 1 ];
      sky_long = v[ 0 ];
      sky_lat = v[ 1 ];

/* Test if both values are OK (i.e. not "bad"). */
      if ( ( sky_long != AST__BAD ) && ( sky_lat != AST__BAD ) ) {

/* Fold the longitude value into the range 0 to 2*pi and the latitude into
   the range -pi to +pi. */
         sky_long = slaDranrm( sky_long );
         sky_lat = slaDrange( sky_lat );

/* If the latitude now exceeds pi/2, shift the longitude by pi in whichever
   direction will keep it in the range 0 to 2*pi. */
         if ( sky_lat > ( pi / 2.0 ) ) {
            sky_long += ( sky_long < pi ) ? pi : -pi;

/* Reflect the latitude value through the pole, so it lies in the range 0 to
   pi/2. */
            sky_lat = pi - sky_lat;

/* If the latitude is less than -pi/2, shift the longitude in the same way
   as above. */
         } else if ( sky_lat < -( pi / 2.0 ) ) {
            sky_long += ( sky_long < pi ) ? pi : -pi;

/* But reflect the latitude through the other pole, so it lies in the range
   -pi/2 to 0. */
            sky_lat = -pi - sky_lat;
         }

/* If only the longitude value is valid, wrap it into the range 0 to 2*pi. */
      } else if ( sky_long != AST__BAD ) {
         sky_long = slaDranrm( sky_long );

/* If only the latitude value is valid, wrap it into the range -pi to +pi. */
      } else if ( sky_lat != AST__BAD ) {
         sky_lat = slaDrange( sky_lat );

/* Then refect through one of the poles (as above), if necessary, to move it
   into the range -pi/2 to +pi/2. */
         if ( sky_lat > ( pi / 2.0 ) ) {
            sky_lat = pi - sky_lat;
         } else if ( sky_lat < -( pi / 2.0 ) ) {
            sky_lat = -pi - sky_lat;
         }
      }

/* Convert 2*pi longitude into zero. Allow for a small error. */
      if ( fabs( sky_long - ( 2.0 * pi ) ) <=
          ( 2.0 * pi ) * ( DBL_EPSILON * (double) FLT_RADIX ) ) sky_long = 0.0;

/* If the NegLon attribute is set, and the longitude value is good,
   convert it into the range -pi to +pi. */
      if( sky_long != AST__BAD && astGetNegLon( this ) ) {
         sky_long = slaDrange( sky_long );
      }

/* Return the new values, allowing for any axis permutation. */
      v[ 0 ] = sky_long;
      v[ 1 ] = sky_lat;
      value[ 0 ] = v[ perm[ 0 ] ];
      value[ 1 ] = v[ perm[ 1 ] ];
   }
}

static void Offset( AstFrame *this_frame, const double point1[],
                    const double point2[], double offset, double point3[] ) {
/*
*  Name:
*     Offset

*  Purpose:
*     Calculate an offset along a geodesic curve.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     void Offset( AstFrame *this,
*                  const double point1[], const double point2[],
*                  double offset, double point3[] )

*  Class Membership:
*     SkyFrame member function (over-rides the astOffset method
*     inherited from the Frame class).

*  Description:
*     This function finds the SkyFrame coordinate values of a point
*     which is offset a specified distance along the geodesic curve
*     (i.e. great circle) between two other points.

*  Parameters:
*     this
*        Pointer to the SkyFrame.
*     point1
*        An array of double, with one element for each SkyFrame axis.
*        This should contain the coordinates of the point marking the
*        start of the geodesic curve.
*     point2
*        An array of double, with one element for each SkyFrame axis.
*        This should contain the coordinates of the point marking the
*        end of the geodesic curve.
*     offset
*        The required offset from the first point along the geodesic
*        curve, in radians. If this is positive, it will be towards
*        the second point. If it is negative, it will be in the
*        opposite direction. This offset need not imply a position
*        lying between the two points given, as the curve will be
*        extrapolated if necessary.
*     point3
*        An array of double, with one element for each SkyFrame axis
*        in which the coordinates of the required point will be
*        returned.

*  Notes:
*     - The geodesic curve used by this function is the path of
*     shortest distance between two points, as defined by the
*     astDistance function.
*     - This function will return "bad" coordinate values (AST__BAD)
*     if any of the input coordinates has this value.
*     - "Bad" coordinate values will also be returned if the two
*     points supplied are coincident (or otherwise fail to uniquely
*     specify a geodesic curve) but the requested offset is non-zero.
*/

/* Local Variables: */
   AstSkyFrame *this;            /* Pointer to the SkyFrame structure */
   const int *perm;              /* Pointer to axis permutation array */
   double mrot[ 3 ][ 3 ];        /* Rotation matrix */
   double p1[ 2 ];               /* Permuted coordinates for point1 */
   double p2[ 2 ];               /* Permuted coordinates for point2 */
   double p3[ 2 ];               /* Permuted coordinates for point3 */
   double scale;                 /* Scale factor */
   double v1[ 3 ];               /* 3-vector for p1 */
   double v2[ 3 ];               /* 3-vector for p2 */
   double v3[ 3 ];               /* 3-vector for p3 */
   double vmod;                  /* Modulus of vector */
   double vrot[ 3 ];             /* Vector along rotation axis */

/* Check the global error status. */
   if ( !astOK ) return;

/* Obtain a pointer to the SkyFrame structure. */
   this = (AstSkyFrame *) this_frame;

/* Obtain a pointer to the SkyFrame's axis permutation array. */
   perm = astGetPerm( this );
   if ( astOK ) {

/* Check that all supplied coordinates are OK. If not, generate "bad"
   output coordinates. */
      if ( ( point1[ 0 ] == AST__BAD ) || ( point1[ 1 ] == AST__BAD ) ||
           ( point2[ 0 ] == AST__BAD ) || ( point2[ 1 ] == AST__BAD ) ) {
         point3[ 0 ] = AST__BAD;
         point3[ 1 ] = AST__BAD;

/* Otherwise, apply the axis permutation array to obtain the
   coordinates of the two input points in the required
   (longitude,latitude) order. */
      } else {
         p1[ perm[ 0 ] ] = point1[ 0 ];
         p1[ perm[ 1 ] ] = point1[ 1 ];
         p2[ perm[ 0 ] ] = point2[ 0 ];
         p2[ perm[ 1 ] ] = point2[ 1 ];

/* Convert each point into a 3-vector of unit length. */
         slaDcs2c( p1[ 0 ], p1[ 1 ], v1 );
         slaDcs2c( p2[ 0 ], p2[ 1 ], v2 );

/* Find the cross product between these two vectors (the vector order
   is reversed here to compensate for the sense of rotation introduced
   by slaDav2m and slaDmxv below). */
         slaDvxv( v2, v1, v3 );

/* Normalise the cross product vector, also obtaining its original
   modulus. */
         slaDvn( v3, vrot, &vmod );

/* If the original modulus was zero, the input points are either
   coincident or diametrically opposite, so do not uniquely define a
   great circle. In either case, we can only generate output
   coordinates if the offset required is an exact multiple of pi. If
   it is, generate the 3-vector that results from rotating the first
   input point through this angle. */
         if ( vmod == 0.0 ) {
            if ( sin( offset ) == 0.0 ) {
               scale = cos( offset );
               v3[ 0 ] = v1[ 0 ] * scale;
               v3[ 1 ] = v1[ 1 ] * scale;
               v3[ 2 ] = v1[ 2 ] * scale;

/* Convert the 3-vector back into spherical cooordinates and then
   constrain the longitude result to lie in the range 0 to 2*pi
   (slaDcc2s doesn't do this itself). */
               slaDcc2s( v3, &p3[ 0 ], &p3[ 1 ] );
               p3[ 0 ] = slaDranrm( p3[ 0 ] );

/* If the offset was not a multiple of pi, generate "bad" output
   coordinates. */
            } else {
               p3[ 0 ] = AST__BAD;
               p3[ 1 ] = AST__BAD;
            }

/* If the two input points define a great circle, scale the normalised
   cross product vector to make its length equal to the required
   offset (angle) between the first input point and the result. */
         } else {
            vrot[ 0 ] *= offset;
            vrot[ 1 ] *= offset;
            vrot[ 2 ] *= offset;

/* Generate the rotation matrix that implements this rotation and use
   it to rotate the first input point (3-vector) to give the required
   result (3-vector). */
            slaDav2m( vrot, mrot );
            slaDmxv( mrot, v1, v3 );

/* Convert the 3-vector back into spherical cooordinates and then
   constrain the longitude result to lie in the range 0 to 2*pi. */
            slaDcc2s( v3, &p3[ 0 ], &p3[ 1 ] );
            p3[ 0 ] = slaDranrm( p3[ 0 ] );
         }

/* Permute the result coordinates to undo the effect of the SkyFrame
   axis permutation array. */
         point3[ 0 ] = p3[ perm[ 0 ] ];
         point3[ 1 ] = p3[ perm[ 1 ] ];
      }
   }
}

static double Offset2( AstFrame *this_frame, const double point1[2],
                       double angle, double offset, double point2[2] ) {
/*
*  Name:
*     Offset2

*  Purpose:
*     Calculate an offset along a geodesic curve at a given bearing.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     double Offset2( AstFrame *this_frame, const double point1[2],
*                     double angle, double offset, double point2[2] )

*  Class Membership:
*     SkyFrame member function (over-rides the astOffset2 method
*     inherited from the Frame class).

*  Description:
*     This function finds the SkyFrame coordinate values of a point
*     which is offset a specified distance along the geodesic curve
*     (i.e. great circle) at a given angle from a given starting point.

*  Parameters:
*     this
*        Pointer to the SkyFrame.
*     point1
*        An array of double, with one element for each SkyFrame axis.
*        This should contain the coordinates of the point marking the
*        start of the geodesic curve.
*     angle
*        The angle (in radians) from the positive direction of the second
*        axis, to the direction of the required position, as seen from
*        the starting position. Positive rotation is in the sense of 
*        rotation from the positive direction of axis 2 to the positive 
*        direction of axis 1.
*     offset
*        The required offset from the first point along the geodesic
*        curve, in radians. If this is positive, it will be towards
*        the given angle. If it is negative, it will be in the
*        opposite direction. 
*     point2
*        An array of double, with one element for each SkyFrame axis
*        in which the coordinates of the required point will be
*        returned.

*  Returned Value:
*     The direction of the geodesic curve at the end point. That is, the 
*     angle (in radians) between the positive direction of the second
*     axis and the continuation of the geodesic curve at the requested
*     end point. Positive rotation is in the sense of rotation from
*     the positive direction of axis 2 to the positive direction of axis 
*     1.

*  Notes:
*     - The geodesic curve used by this function is the path of
*     shortest distance between two points, as defined by the
*     astDistance function.
*     - This function will return "bad" coordinate values (AST__BAD)
*     if any of the input coordinates has this value.
*/

/* Local Variables: */
   AstSkyFrame *this;          /* Pointer to the SkyFrame structure */
   const int *perm;            /* Pointer to axis permutation array */
   double p1[ 2 ];             /* Permuted coordinates for point1 */
   double p2[ 2 ];             /* Permuted coordinates for point2 */
   double result;              /* The returned answer */
   double cosoff;              /* Cosine of offset */
   double cosa1;               /* Cosine of longitude at start */
   double cosb1;               /* Cosine of latitude at start */
   double pa;                  /* A position angle measured from north */
   double q1[ 3 ];             /* Vector PI/2 away from R4 in meridian of R4 */
   double q2[ 3 ];             /* Vector PI/2 away from R4 on equator */
   double q3[ 3 ];             /* Vector PI/2 away from R4 on great circle */
   double r0[ 3 ];             /* Reference position vector */
   double r3[ 3 ];             /* Vector PI/2 away from R0 on great circle */
   double sinoff;              /* Sine of offset */
   double sina1;               /* Sine of longitude at start */
   double sinb1;               /* Sine of latitude at start */
   int stat;                   /* Status return from SLALIB */
   static double piby2;        /* Value of pi/2 */
   static int init = 0;        /* Value of pi/2 initialised? */

/* Initialise. */
   result = AST__BAD;

/* Check the global error status. */
   if ( !astOK ) return result;

/* If not already done, obtain a value for pi/2 from SLALIB by
   converting 90 degrees into radians. */
   if ( !init ) {   
      slaDaf2r( 90, 0, 0.0, &piby2, &stat );
      init = 1;
   }

/* Obtain a pointer to the SkyFrame structure. */
   this = (AstSkyFrame *) this_frame;

/* Obtain a pointer to the SkyFrame's axis permutation array. */
   perm = astGetPerm( this );
   if ( astOK ) {

/* Check that all supplied values are OK. If not, generate "bad"
   output coordinates. */
      if ( ( point1[ 0 ] == AST__BAD ) || ( point1[ 1 ] == AST__BAD ) ||
           ( angle == AST__BAD ) || ( offset == AST__BAD ) ) {
         point2[ 0 ] = AST__BAD;
         point2[ 1 ] = AST__BAD;

/* Otherwise, apply the axis permutation array to obtain the
   coordinates of the starting point in the required (longitude,latitude) 
   order. */
      } else {
         p1[ perm[ 0 ] ] = point1[ 0 ];
         p1[ perm[ 1 ] ] = point1[ 1 ];

/* If the axes are permuted, convert the supplie dangle into a position
   angle. */
         pa = ( perm[ 0 ] == 0 )? angle: piby2 - angle;

/* Use Shcal to calculate the required vectors R0 (representing
   the reference point) and R3 (representing the point which is 90
   degrees away from the reference point, along the required great
   circle). The XY plane defines zero latitude, Z is in the direction
   of increasing latitude, X is towards zero longitude, and Y is
   towards longitude 90 degrees. */
         Shcal( p1[ 0 ], p1[ 1 ], pa, r0, r3 );

/* Use Shapp to use R0 and R3 to calculate the new position. */
         Shapp( offset, r0, r3,  p1[ 0 ], p2 );

/* Normalize the result. */
         astNorm( this, p2 );

/* Create the vector Q1 representing the point in the meridian of the
   required point which has latitude 90 degrees greater than the
   required point. */
         sina1 = sin( p2[ 0 ] );
         cosa1 = cos( p2[ 0 ] );
         sinb1 = sin( p2[ 1 ] );
         cosb1 = cos( p2[ 1 ] );
   
         q1[ 0 ] = -sinb1*cosa1;
         q1[ 1 ] = -sinb1*sina1;
         q1[ 2 ] = cosb1;

/* Create the vector Q2 representing the point on the equator (i.e. a
   latitude of zero), which has a longitude 90 degrees to the west of
   the required point. */
         q2[ 0 ] = -sina1;
         q2[ 1 ] =  cosa1;
         q2[ 2 ] =  0.0;

/* Create the vector Q3 representing the point which is 90 degrees away
   from the required point, along the required great circle. */
         cosoff = cos( offset );
         sinoff = sin( offset );
   
         q3[ 0 ] = -sinoff*r0[ 0 ] + cosoff*r3[ 0 ];
         q3[ 1 ] = -sinoff*r0[ 1 ] + cosoff*r3[ 1 ];
         q3[ 2 ] = -sinoff*r0[ 2 ] + cosoff*r3[ 2 ];

/* Calculate the position angle of the great circle at the required
   point. */
         pa = atan2( slaDvdv( q3, q2 ), slaDvdv( q3, q1 ) );

/* Convert this from a pa into the required angle. */
         result = ( perm[ 0 ] == 0 )? pa: piby2 - pa;

/* Ensure that the end angle is in the range 0 to 2*pi. */
         result = slaDranrm( result );

/* Permute the result coordinates to undo the effect of the SkyFrame
   axis permutation array. */
         point2[ 0 ] = p2[ perm[ 0 ] ];
         point2[ 1 ] = p2[ perm[ 1 ] ];
      }
   }

/* Return the result. */
   return result;

}

static void Overlay( AstFrame *template, const int *template_axes,
                     AstFrame *result ) {
/*
*  Name:
*     Overlay

*  Purpose:
*     Overlay the attributes of a template SkyFrame on to another Frame.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     void Overlay( AstFrame *template, const int *template_axes,
*                   AstFrame *result )

*  Class Membership:
*     SkyFrame member function (over-rides the protected astOverlay method
*     inherited from the Frame class).

*  Description:
*     This function overlays attributes of a SkyFrame (the "template") on to
*     another Frame, so as to over-ride selected attributes of that second
*     Frame. Normally only those attributes which have been specifically set
*     in the template will be transferred. This implements a form of
*     defaulting, in which a Frame acquires attributes from the template, but
*     retains its original attributes (as the default) if new values have not
*     previously been explicitly set in the template.
*
*     Note that if the result Frame is a SkyFrame and a change of sky
*     coordinate system occurs as a result of overlaying its System
*     attribute, then some of its original attribute values may no
*     longer be appropriate (e.g. the Title, or attributes describing
*     its axes). In this case, these will be cleared before overlaying
*     any new values.

*  Parameters:
*     template
*        Pointer to the template SkyFrame, for which values should have been
*        explicitly set for any attribute which is to be transferred.
*     template_axes
*        Pointer to an array of int, with one element for each axis of the
*        "result" Frame (see below). For each axis in the result frame, the
*        corresponding element of this array should contain the (zero-based)
*        index of the template axis to which it corresponds. This array is used
*        to establish from which template axis any axis-dependent attributes
*        should be obtained.
*
*        If any axis in the result Frame is not associated with a template
*        axis, the corresponding element of this array should be set to -1.
*     result
*        Pointer to the Frame which is to receive the new attribute values.

*  Returned Value:
*     void

*  Notes:
*     -  In general, if the result Frame is not from the same class as the
*     template SkyFrame, or from a class derived from it, then attributes may
*     exist in the template SkyFrame which do not exist in the result Frame. In
*     this case, these attributes will not be transferred.
*/


/* Local Variables: */
   AstSkySystemType new_system;  /* Code identifying new sky cordinates */
   AstSkySystemType old_system;  /* Code identifying old sky coordinates */
   int axis;                     /* Loop counter for result SkyFrame axes */
   int skyframe;                 /* Result Frame is a SkyFrame? */

/* Check the global error status. */
   if ( !astOK ) return;

/* If the result Frame is a SkyFrame, we must test to see if overlaying its
   System attribute will change the type of sky coordinate system it
   describes. Determine the value of this attribute for the result and template
   SkyFrames. */
   skyframe = astIsASkyFrame( result );   
   if ( skyframe ) {
      old_system = astGetSystem( result );
      new_system = astGetSystem( template );

/* If the coordinate system will change, any value already set for the result
   SkyFrame's Title will no longer be appropriate, so clear it. */
      if ( new_system != old_system ) {
         astClearTitle( result );

/* Test if the old and new sky coordinate systems are similar enough to make
   use of the same axis attribute values (e.g. if they are both equatorial
   systems, then they can both use the same axis labels, etc.). */
         if ( IsEquatorial( new_system ) != IsEquatorial( old_system ) ) {

/* If necessary, clear inappropriate values for all those axis attributes
   whose access functions are over-ridden by this class (these access functions
   will then provide suitable defaults appropriate to the new coordinate system
   instead). */
            for ( axis = 0; axis < 2; axis++ ) {
               astClearAsTime( result, axis );
               astClearDirection( result, axis );
               astClearFormat( result, axis );
               astClearLabel( result, axis );
               astClearSymbol( result, axis );
               astClearUnit( result, axis );
            }
         }
      }
   }

/* Invoke the parent class astOverlay method to transfer attributes inherited
   from the parent class. */
   (*parent_overlay)( template, template_axes, result );

/* Check if the result Frame is a SkyFrame or from a class derived from
   SkyFrame. If not, we cannot transfer SkyFrame attributes to it as it is
   insufficiently specialised. In this case simply omit these attributes. */
   if ( skyframe && astOK ) {

/* Define a macro that tests whether an attribute is set in the template and,
   if so, transfers its value to the result. */
#define OVERLAY(attribute) \
   if ( astTest##attribute( template ) ) { \
      astSet##attribute( result, astGet##attribute( template ) ); \
   }

/* Use the macro to transfer each SkyFrame attribute in turn. */
      OVERLAY(Epoch);
      OVERLAY(Equinox);
      OVERLAY(Projection);
      OVERLAY(System);
      OVERLAY(NegLon);
   }

/* Undefine macros local to this function. */
#undef OVERLAY
}

static double ReadDateTime( const char *value ) {
/*
*  Name:
*     ReadDateTime

*  Purpose:
*     Read a date/time string.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     double ReadDateTime( const char *value )

*  Class Membership:
*     SkyFrame member function.

*  Description:
*     This function reads a date/time string in a variety of formats and
*     returns the resulting time as a Modified Julian Date. If the string
*     cannot be interpreted as a date/time or contains invalid values, an
*     error is reported.

*  Parameters:
*     value
*        Pointer to a null terminated string containing the value to be read.

*  Returned Value:
*     The time as a Modified Julian date.

*  Date/Time Formats:
*     The date/time formats supported by this function are listed below. These
*     are interpreted in a case-insensitive manner and the function is
*     generally flexible about the presence of additional white space and the
*     use of alternative field delimiters.
*
*     Besselian Epoch
*        Expressed in decimal years, with or without decimal places
*        ("B1950" or "B1976.13", for example).
*     Julian Epoch
*        Expressed in decimal years, with or without decimal places
*        ("J2000" or "J2100.9", for example).
*     Year
*        Decimal years, with or without decimal places ("1996.8" for example).
*        Such values are interpreted as a Besselian epoch (see above) if less
*        than 1984.0 and as a Julian epoch otherwise.
*     Julian Date
*        With or without decimal places ("JD 2454321.9" for example).
*     Modified Julian Date
*        With or without decimal places ("MJD 54321.4" for example).
*     Gregorian Calendar Date
*        With the month expressed as an integer or 3-character
*        abbreviation, and with optional decimal places to represent a
*        fraction of a day ("1996-10-2" or "1996-Oct-2.6" for
*        example). If no fractional part of a day is given, the time
*        refers to the start of the day (zero hours).
*     Gregorian Date and Time
*        Any calendar date (as above) but with a fraction of a day expressed
*        as hours, minutes and seconds ("1996-Oct-2 12:13:56.985" for example).

*  Notes:
*     -  The date/time value is interpreted as a calendar date and time, not
*     linked to any particular time system. Thus, interpretation of hours,
*     minutes and seconds is done in the obvious manner assuming 86400 seconds
*     in a day. No allowance for is made, for instance, for leap seconds or for
*     the varying length of a second in some time systems.
*     -  A value of AST__BAD is returned if this function is invoked with the
*     global error status set or if it should fail for any reason.
*/

/* Local Vaiables: */
   char cmonth[ 4 ];             /* Buffer for name of month */
   char sep1[ 2 ];               /* Year/month separator string */
   char sep2[ 2 ];               /* Month/day separator string */
   char sep3[ 2 ];               /* Hour/minute separator string */
   char sep4[ 2 ];               /* Minute/second separator string */
   const char *v;                /* Pointer into value string */
   double day;                   /* Day number plus fraction of whole day */
   double epoch;                 /* Epoch stored as decimal years */
   double hms;                   /* Hours, min & sec as fraction of a day */
   double jd;                    /* Julian Date */
   double mjd;                   /* Modified Julian Date */
   double result;                /* Result to be returned */
   double sec;                   /* Seconds and fractions of a second */
   int hour;                     /* Number of hours */
   int iday;                     /* Number of whole days */
   int l;                        /* Length of string remaining */
   int len;                      /* Length of string */
   int match;                    /* Date/time string has correct form? */
   int minute;                   /* Number of minutes */
   int month;                    /* Number of months */
   int nc;                       /* Number of characters read from string */
   int stat;                     /* Status return from SLALIB functions */
   int year;                     /* Number of years */

/* Check the global error status. */
   if ( !astOK ) return AST__BAD;

/* Initialise. */
   result = AST__BAD;

/* Obtain the length of the input string. */
   len = (int) strlen( value );

/* Attempt to read the string using each recognised format in turn. */

/* Besselian epoch in decimal years (e.g. "B1950.0"). */
/* ================================================== */
   if ( nc = 0,
        ( 1 == astSscanf( value, " %*1[Bb] %lf %n", &epoch, &nc ) )
        && ( nc >= len ) ) {

/* Convert to Modified Julian Date. */
      result = slaEpb2d( epoch );

/* Julian epoch in decimal years (e.g. "J2000.0"). */
/* =============================================== */
   } else if ( nc = 0,
               ( 1 == astSscanf( value, " %*1[Jj] %lf %n", &epoch, &nc ) )
               && ( nc >= len ) ) {

/* Convert to Modified Julian Date. */
      result = slaEpj2d( epoch );

/* Decimal years (e.g. "1976.2"). */
/* ============================== */
   } else if ( nc = 0,
               ( 1 == astSscanf( value, " %lf %n", &epoch, &nc ) )
               && ( nc >= len ) ) {

/* Convert to Modified Julian Date, treating the epoch as Julian or Besselian
   depending on whether it is 1984.0 or later. */
      result = ( epoch < 1984.0 ) ? slaEpb2d( epoch ) : slaEpj2d( epoch );

/* Modified Julian Date (e.g. "MJD 54321.0"). */
/* ============================================ */
   } else if ( nc = 0,
               ( 1 == astSscanf( value, " %*1[Mm] %*1[Jj] %*1[Dd] %lf %n",
                              &mjd, &nc ) ) && ( nc >= len ) ) {

/* Use the result directly. */
      result = mjd;

/* Julian Date (e.g. "JD 2454321.5"). */
/* ==================================== */
   } else if ( nc = 0,
               ( 1 == astSscanf( value, " %*1[Jj] %*1[Dd] %lf %n",
                              &jd, &nc ) ) && ( nc >= len ) ) {

/* Convert to Modified Julian Date. */
      result = jd - 2400000.5;

/* Gregorian calendar date (e.g. "1996-10-2" or "1996-Oct-2"). */
/* =========================================================== */
/* This format also allows day fractions expressed as decimal days, e.g:

      "1996-Oct-2.5001"

   or as hours, minutes and seconds, e.g:

      "1996-Oct-2 12:14:30.52"

   Various alternative field delimiters are also allowed. */
   } else {

/* Note that the method used to parse this format relies heavily on
   conditional execution controlled by "&&" and "||" operators. Initialise
   the variables used. */
      v = value;
      l = len;
      *cmonth = '\0';
      year = month = iday = hour = minute = 0;
      day = sec = 0.0;

/* Identify the year and month. */
/* ---------------------------- */
/* Try to match an initial " 1996 - 10 -" or " 1996 10 " or similar. */
      match =
         ( nc = 0, ( 4 == astSscanf( v, " %d %1[:/-] %2d %1[:/-]%n",
                                  &year, sep1, &month, sep2, &nc ) ) );
      match = match ||
         ( nc = 0, ( 4 == astSscanf( v, " %d%1[ ] %2d%1[ ]%n",
                                  &year, sep1, &month, sep2, &nc ) ) );

/* If that failed, allow " 1996 - Oct -" or " 1996 Oct " or similar. */
      match = match ||
         ( nc = 0, ( 4 == astSscanf( v,
                                  " %d %1[:/-] %3[ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                                  "abcdefghijklmnopqrstuvwxyz] %1[:/-]%n",
                                  &year, sep1, cmonth, sep2, &nc ) ) );
      match = match ||
         ( nc = 0, ( 4 == astSscanf( v,
                                  " %d%1[ ] %3[ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                                  "abcdefghijklmnopqrstuvwxyz]%1[ ]%n",
                                  &year, sep1, cmonth, sep2, &nc ) ) );

/* Alternative field separators are permitted above, but ensure that
   they are both the same. */
      match = match && ( *sep1 == *sep2 );

/* Identify the day and fraction of day. */
/*-------------------------------------- */
/* If the above matched correctly, modify the string pointer "v" to
   the next character to be interpreted and decrement the remaining
   string length. */
      if ( match ) {
         v += nc;
         l -= nc;

/* We now try to match the following characters but without reading
   any values.  This is done to ensure the string has the correct form
   (e.g. exclude "-" signs and exponents in numbers, which are
   otherwise hard to detect). */

/* Try to match " 12.3456 " or similar. */
         match =
            ( nc = 0, ( 0 == astSscanf( v, " %*2[0123456789].%*[0123456789] %n",
                                     &nc ) )
                      && ( nc == l ) );

/* If that failed, then try to match " 12. " or similar. */
         match = match ||
            ( nc = 0, ( 0 == astSscanf( v, " %*2[0123456789]. %n", &nc ) )
                      && ( nc == l ) );

/* If that also failed, then try to match just " 12 " or similar. */
         match = match ||
            ( nc = 0, ( 0 == astSscanf( v, " %*2[0123456789] %n", &nc ) )
                      && ( nc == l ) );

/* If any of the above patterns matched, now read the data (the day number)
   as a double value. */
         if ( match ) {
            match = ( nc = 0, ( 1 == astSscanf( v, " %lf %n", &day, &nc ) )
                              && ( nc == l ) );

/* If none of the above matched, then look to see if the day fraction has been
   given in hours, minutes and seconds by trying to match " 12 03 : 45 :" or
   " 12 13 45 " or similar. */
         } else {
            match =
               ( nc = 0, ( 5 == astSscanf( v,
                                        " %2d%*1[ ] %2d %1[:/-] %2d %1[:/-]%n",
                                        &iday, &hour, sep3, &minute, sep4,
                                        &nc ) ) );
            match = match ||
               ( nc = 0, ( 5 == astSscanf( v, " %2d%*1[ ] %2d%1[ ] %2d%1[ ]%n",
                                        &iday, &hour, sep3, &minute, sep4,
                                        &nc ) ) );

/* Alternative field separators are permitted above, but ensure that
   they are both the same. */
            match = match && ( *sep3 == *sep4 );

/* If the day number was read as an integer, convert it to double. */
            if ( match ) day = (double) iday;

/* Identify the seconds field. */
/* --------------------------- */
/* If hours and minutes fields have been matched, now look for the
   final seconds (and fractions of seconds) field. This is similar to
   the day/fraction field (see earlier) in that we first check that it
   has the correct form before reading its value. */

/* Adjust the string pointer and remaining string length. */
            if ( match ) {
               v += nc;
               l -= nc;

/* Try to match " 12.3456 " or similar. */
               match =
                  ( nc = 0, ( 0 == astSscanf( v,
                                          " %*2[0123456789].%*[0123456789] %n",
                                           &nc ) )
                            && ( nc == l ) );

/* If that failed, then try to match " 12. " or similar. */
               match = match ||
                  ( nc = 0, ( 0 == astSscanf( v, " %*2[0123456789]. %n", &nc ) )
                            && ( nc == l ) );

/* If that also failed, then try to match just " 12 " or similar. */
               match = match ||
                  ( nc = 0, ( 0 == astSscanf( v, " %*2[0123456789] %n", &nc ) )
                            && ( nc == l ) );

/* If any of the above patterns matched, now read the data (the number of
   seconds) as a double value. */
               if ( match ) {
                  match = ( nc = 0, ( 1 == astSscanf( v, " %lf %n", &sec, &nc ) )
                                    && ( nc == l ) );
               }
            }
         }
      }

/* Interpret the values that were read. */
/* ------------------------------------ */
/* We execute this if all of the above text matching was successful,
   transferred the required number of data values, and consumed the
   entire input string. */
      if ( match ) {

/* See if the month was given as a character string (e.g. "Oct") instead of
   a number. If so, define local variables for use in converting it. */
         if ( *cmonth ) {
            char lcmonth[ 4 ];      /* Lower case copy of month string */
            const char *ptr;        /* Pointer result from look up */
            const char *table =     /* Month look up table */
                       "jan feb mar apr may jun jul aug sep oct nov dec";
            int i;                  /* Loop counter for characters */

/* Convert the month string to lower case. */
            for ( i = 0; cmonth[ i ]; i++ ) {
               lcmonth[ i ] = tolower( cmonth[ i ] );
            }
            lcmonth[ i ] = '\0';

/* Look the month up in the table of months and generate the required month
   number. */
            if ( ( ptr = strstr( table, lcmonth ) ) ) {
               month = 1 + ( ptr - table ) / 4;

/* If the lookup failed, report an error. */
   	    } else {
               astError( AST__DTERR, "Month value \"%s\" is invalid.",
                         cmonth );
            }
         }

/* If OK, extract the integral day number and convert years, months and days
   to a Modified Julian Date. */
         if ( astOK ) {
            iday = (int) day;
            slaCaldj( year, month, iday, &mjd, &stat );

/* Examine the return status from the conversion and report an appropriate
   error if necessary. */
            switch ( stat ) {
            case 1:
               astError( AST__DTERR, "Year value (%d) is invalid.", year );
               break;
            case 2:
               astError( AST__DTERR, "Month value (%d) is invalid.", month );
               break;
            case 3:
               astError( AST__DTERR, "Day value (%.*g) is invalid.", DBL_DIG,
                         day );
               break;

/* If conversion to MJD was successful, add any fractional part of a day to the
   result. */
            default:
               mjd += ( day - (double) iday );

/* Convert hours, minutes and seconds to a fraction of a day (this will give
   zero if none of these quantities was supplied). */
               slaDtf2d( hour, minute, sec, &hms, &stat );

/* Examine the return status from the conversion and report an appropriate
   error if necessary. */
               switch ( stat ) {
               case 1:
                  astError( AST__DTERR, "Hour value (%d) is invalid.", hour );
                  break;
               case 2:
                  astError( AST__DTERR, "Minute value (%d) is invalid.",
                            minute );
                  break;
               case 3:
                  astError( AST__DTERR, "Seconds value (%.*g) is invalid.",
                            DBL_DIG, sec );
                  break;

/* Add the fraction of a day derived from hours, minutes and seconds fields to
   the result. */
               default:
                  mjd += hms;
                  break;
               }
               break;
            }

/* Return the result, if no error occurred. */
            if ( astOK ) result = mjd;
         }

/* If none of the supported date/time formats matched, then report an error. */
      } else {
         astError( AST__DTERR, "Date/time does not have the correct form." );
      }
   }

/* Return the result. */
   return result;
}

static void Resolve( AstFrame *this_frame, const double point1[], 
                     const double point2[], const double point3[],
                     double point4[], double *d1, double *d2 ){
/*
*  Name:
*     Resolve

*  Purpose:
*     Resolve a vector into two orthogonal components

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     void Resolve( AstFrame *this, const double point1[], 
*                   const double point2[], const double point3[],
*                   double point4[], double *d1, double *d2 )

*  Class Membership:
*     SkyFrame member function (over-rides the astResolve method
*     inherited from the Frame class).

*  Description:
*     This function resolves a vector into two perpendicular components.
*     The vector from point 1 to point 2 is used as the basis vector.
*     The vector from point 1 to point 3 is resolved into components 
*     parallel and perpendicular to this basis vector. The lengths of the 
*     two components are returned, together with the position of closest 
*     aproach of the basis vector to point 3. 
*
*     Each vector is a geodesic curve. For a SkyFrame, these are great
*     circles on the celestial sphere.

*  Parameters:
*     this
*        Pointer to the Frame.
*     point1
*        An array of double, with one element for each Frame axis
*        (Naxes attribute). This marks the start of the basis vector,
*        and of the vector to be resolved.
*     point2
*        An array of double, with one element for each Frame axis
*        (Naxes attribute). This marks the end of the basis vector.
*     point3
*        An array of double, with one element for each Frame axis
*        (Naxes attribute). This marks the end of the vector to be
*        resolved.
*     point4
*        An array of double, with one element for each Frame axis
*        in which the coordinates of the point of closest approach of the
*        basis vector to point 3 will be returned.
*     d1
*        The address of a location at which to return the distance from
*        point 1 to point 4 (that is, the length of the component parallel 
*        to the basis vector). Positive values are in the same sense as 
*        movement from point 1 to point 2.
*     d2
*        The address of a location at which to return the distance from
*        point 4 to point 3 (that is, the length of the component
*        perpendicular to the basis vector). The returned value is always
*        positive.

*  Notes:
*     - This function will return "bad" coordinate values (AST__BAD)
*     if any of the input coordinates has this value, or if the required
*     output values are undefined.
*/

/* Local Variables: */
   AstSkyFrame *this;            /* Pointer to the SkyFrame structure */
   const int *perm;              /* Pointer to axis permutation array */
   double n1[ 3 ];               /* Unit normal to grt crcl thru p1 and p2 */
   double n2[ 3 ];               /* Unit normal to grt crcl thru p3 and p4 */
   double p1[ 2 ];               /* Permuted coordinates for point1 */
   double p2[ 2 ];               /* Permuted coordinates for point2 */
   double p3[ 2 ];               /* Permuted coordinates for point3 */
   double p4[ 2 ];               /* Permuted coordinates for point4 */
   double v1[ 3 ];               /* 3-vector for p1 */
   double v2[ 3 ];               /* 3-vector for p2 */
   double v3[ 3 ];               /* 3-vector for p3 */
   double v4[ 3 ];               /* 3-vector for p4 */
   double v5[ 3 ];               /* 3-vector 90 degs away from p1 */
   double vmod;                  /* Modulus of vector */
   double vtemp[ 3 ];            /* Temporary vector workspace */

/* Check the global error status. */
   if ( !astOK ) return;

/* Obtain a pointer to the SkyFrame structure. */
   this = (AstSkyFrame *) this_frame;

/* Store initial bad output values. */
   point4[ 0 ] = AST__BAD;
   point4[ 1 ] = AST__BAD;
   *d1 = AST__BAD;
   *d2 = AST__BAD;

/* Check that all supplied values are OK. */
   if ( ( point1[ 0 ] != AST__BAD ) && ( point1[ 1 ] != AST__BAD ) &&
        ( point2[ 0 ] != AST__BAD ) && ( point2[ 1 ] != AST__BAD ) &&
        ( point3[ 0 ] != AST__BAD ) && ( point3[ 1 ] != AST__BAD ) ) {

/* If so, obtain a pointer to the SkyFrame's axis permutation array. */
      perm = astGetPerm( this );
      if ( astOK ) {

/* Apply the axis permutation array to obtain the coordinates of the 
   three supplied point in the required (longitude,latitude) order. */
         p1[ perm[ 0 ] ] = point1[ 0 ];
         p1[ perm[ 1 ] ] = point1[ 1 ];
         p2[ perm[ 0 ] ] = point2[ 0 ];
         p2[ perm[ 1 ] ] = point2[ 1 ];
         p3[ perm[ 0 ] ] = point3[ 0 ];
         p3[ perm[ 1 ] ] = point3[ 1 ];

/* Convert each point into a 3-vector of unit length. */
         slaDcs2c( p1[ 0 ], p1[ 1 ], v1 );
         slaDcs2c( p2[ 0 ], p2[ 1 ], v2 );
         slaDcs2c( p3[ 0 ], p3[ 1 ], v3 );

/* Find the cross product between the first two vectors, and normalize is. 
   This is the unit normal to the great circle plane defining parallel 
   distance. */
         slaDvxv( v2, v1, vtemp );
         slaDvn( vtemp, n1, &vmod );

/* Return with bad values if the normal is undefined (i.e. if the first two 
   vectors are identical or diametrically opposite). */
         if( vmod > 0.0 ) {

/* Now take the cross product of the normal vector and v1. This gives a
   point, v5, on the great circle which is 90 degrees away from v1, in the
   direction of v2. */
            slaDvxv( v1, n1, v5 );

/* Find the cross product of the outlying point (point 3), and the vector
   n1 found above, and normalize it. This is the unit normal to the great 
   circle plane defining perpendicular distance. */
            slaDvxv( v3, n1, vtemp );
            slaDvn( vtemp, n2, &vmod );

/* Return with bad values if the normal is undefined (i.e. if the
   outlying point is normal to the great circle defining the basis 
   vector). */
            if( vmod > 0.0 ) {

/* The point of closest approach, point 4, is the point which is normal
   to both normal vectors (i.e. the intersection of the two great circles).
   This is the cross product of n1 and n2. No need to normalize this time 
   since both n1 and n2 are unit vectors, and so v4 will already be a
   unit vector. */
               slaDvxv( n1, n2, v4 );

/* The dot product of v4 and v1 is the cos of the parallel distance,
   d1, whilst the dot product of v4 and v5 is the sin of the parallel
   distance. Use these to get the parallel distance with the correct
   sign, in the range -PI to +PI. */
               *d1 = atan2( slaDvdv( v4, v5 ), slaDvdv( v4, v1 ) );

/* The dot product of v4 and v3 is the cos of the perpendicular distance,
   d2, whilst the dot product of n1 and v3 is the sin of the perpendicular
   distance. Use these to get the perpendicular distance. */
               *d2 = fabs( atan2( slaDvdv( v3, n1 ), slaDvdv( v3, v4 ) ) );

/* Convert the 3-vector representing the intersection of the two planes 
   back into spherical cooordinates and then constrain the longitude result 
   to lie in the range 0 to 2*pi. */
               slaDcc2s( v4, &p4[ 0 ], &p4[ 1 ] );
               p4[ 0 ] = slaDranrm( p4[ 0 ] );

/* Permute the result coordinates to undo the effect of the SkyFrame
   axis permutation array. */
               point4[ 0 ] = p4[ perm[ 0 ] ];
               point4[ 1 ] = p4[ perm[ 1 ] ];
            }
         }
      }
   }

   return;

}

static void SetAsTime( AstSkyFrame *this, int axis, int value ) {
/*
*  Name:
*     SetAsTime

*  Purpose:
*     Set a value for the AsTime attribute for a SkyFrame's axis.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     void SetAsTime( AstSkyFrame *this, int axis, int value )

*  Class Membership:
*     SkyFrame member function.

*  Description:
*     This function sets the boolean value of the AsTime attribute for a
*     specified axis of a SkyFrame. This value indicates whether axis values
*     should be formatted as times (as opposed to angles) by default.

*  Parameters:
*     this
*        Pointer to the SkyFrame.
*     axis
*        Index of the axis for which a value is to be set (zero based).
*     value
*        The boolean value to be set.

*  Returned Value:
*     void.
*/

/* Local Variables: */
   AstAxis *ax;                  /* Pointer to Axis object */
   AstSkyAxis *new_ax;           /* Pointer to new SkyAxis object */

/* Check the global error status. */
   if ( !astOK ) return;

/* Validate the axis index. */
   (void) astValidateAxis( this, axis, "astSetAsTime" );

/* Obtain a pointer to the Axis object. */
   ax = astGetAxis( this, axis );

/* Check if the Axis object is a SkyAxis. If not, we will replace it with
   one. */
   if ( !astIsASkyAxis( ax ) ) {

/* Create a new SkyAxis and overlay the attributes of the original Axis. */
      new_ax = astSkyAxis( "" );
      astAxisOverlay( ax, new_ax );

/* Modify the SkyFrame to use the new Skyaxis and annul the original Axis
   pointer. Retain a pointer to the new SkyAxis. */
      astSetAxis( this, axis, new_ax );
      ax = astAnnul( ax );
      ax = (AstAxis *) new_ax;
   }

/* Set a value for the Axis AsTime attribute. */
   astSetAxisAsTime( ax, value );

/* Annul the Axis pointer. */
   ax = astAnnul( ax );
}

static void SetAttrib( AstObject *this_object, const char *setting ) {
/*
*  Name:
*     SetAttrib

*  Purpose:
*     Set an attribute value for a SkyFrame.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     void SetAttrib( AstObject *this, const char *setting )

*  Class Membership:
*     SkyFrame member function (extends the astSetAttrib method inherited from
*     the Mapping class).

*  Description:
*     This function assigns an attribute value for a SkyFrame, the attribute
*     and its value being specified by means of a string of the form:
*
*        "attribute= value "
*
*     Here, "attribute" specifies the attribute name and should be in lower
*     case with no white space present. The value to the right of the "="
*     should be a suitable textual representation of the value to be assigned
*     and this will be interpreted according to the attribute's data type.
*     White space surrounding the value is only significant for string
*     attributes.

*  Parameters:
*     this
*        Pointer to the SkyFrame.
*     setting
*        Pointer to a null terminated string specifying the new attribute
*        value.

*  Returned Value:
*     void

*  Attributes:
*     As well as those attributes inherited from the parent class, this
*     function also accepts values for the following additional attributes:
*
*        Epoch (double, read as a string)
*        Equinox (double, read as a string)
*        System (AstSkySystemType, read as a string)

*  Notes:
*     This protected method is intended to be invoked by the Object astSet
*     method and makes additional attributes accessible to it.
*/

/* Local Vaiables: */
   AstSkyFrame *this;            /* Pointer to the SkyFrame structure */
   AstSkySystemType system_code; /* System type code */
   double mjd;                   /* Modified Julian Date */
   int astime;                   /* Value of AsTime attribute */
   int axis;                     /* Axis index */
   int epoch;                    /* Offset of Projection attribute value */
   int equinox;                  /* Offset of Equinox attribute value */
   int len;                      /* Length of setting string */
   int nc;                       /* Number of characters read by astSscanf */
   int neglon;                   /* Display -ve longitudes? */
   int projection;               /* Offset of Epoch attribute value */
   int system;                   /* Offset of System attribute value */

/* Check the global error status. */
   if ( !astOK ) return;

/* Obtain a pointer to the SkyFrame structure. */
   this = (AstSkyFrame *) this_object;

/* Obtain the length of the setting string. */
   len = strlen( setting );

/* Test for each recognised attribute in turn, using "astSscanf" to parse the
   setting string and extract the attribute value (or an offset to it in the
   case of string values). In each case, use the value set in "nc" to check
   that the entire string was matched. Once a value has been obtained, use the
   appropriate method to set it. */

/* AsTime(axis). */
/* ------------- */
   if ( nc = 0,
        ( 2 == astSscanf( setting, "astime(%d)= %d %n", &axis, &astime, &nc ) )
        && ( nc >= len ) ) {
      astSetAsTime( this, axis - 1, astime );

/* Epoch. */
/* ------ */
   } else if ( nc = 0,
        ( 0 == astSscanf( setting, "epoch=%n%*[^\n]%n", &epoch, &nc ) )
        && ( nc >= len ) ) {

/* Convert the Epoch value to a Modified Julian Date before use. */
      mjd = ReadDateTime( setting + epoch );
      if ( astOK ) {
         astSetEpoch( this, mjd );

/* Report contextual information if the conversion failed. */
      } else {
         astError( AST__ATTIN, "astSetAttrib(%s): Invalid epoch value "
                   "\"%s\" given for sky coordinate system.",
                   astGetClass( this ), setting + epoch );
      }

/* Equinox. */
/* -------- */
   } else if ( nc = 0,
               ( 0 == astSscanf( setting, "equinox=%n%*[^\n]%n",
                              &equinox, &nc ) ) && ( nc >= len ) ) {

/* Convert the Equinox value to a Modified Julian Date before use. */
      mjd = ReadDateTime( setting + equinox );
      if ( astOK ) {
         astSetEquinox( this, mjd );

/* Report contextual information if the conversion failed. */
      } else {
         astError( AST__ATTIN, "astSetAttrib(%s): Invalid equinox value "
                   "\"%s\" given for sky coordinate system.",
                   astGetClass( this ), setting + equinox );
      }

/* NegLon. */
/* ------- */
   } else if ( nc = 0,
             ( 1 == astSscanf( setting, "neglon= %d %n", &neglon, &nc ) )
               && ( nc >= len ) ) {
      astSetNegLon( this, neglon );

/* Projection. */
/* ----------- */
   } else if ( nc = 0,
               ( 0 == astSscanf( setting, "projection=%n%*[^\n]%n",
                              &projection, &nc ) )
               && ( nc >= len ) ) {
      astSetProjection( this, setting + projection );

/* System. */
/* ------- */
   } else if ( nc = 0,
               ( 0 == astSscanf( setting, "system= %n%*s %n", &system, &nc ) )
               && ( nc >= len ) ) {

/* Convert the string to a System code before use. */
      system_code = SystemCode( system + setting );
      if ( system_code != AST__NOSKYSYSTEM ) {
         astSetSystem( this, system_code );

/* Report an error if the string value wasn't recognised. */
      } else {
         astError( AST__ATTIN,
                   "astSetAttrib(%s): Invalid sky coordinate system "
                   "description \"%s\".",
                   astGetClass( this ), system + setting );
      }
   
/* Define a macro to see if the setting string matches any of the
   read-only attributes of this class. */
#define MATCH(attrib) \
        ( nc = 0, ( 0 == astSscanf( setting, attrib "=%*[^\n]%n", &nc ) ) && \
                  ( nc >= len ) )

/* If the attribute was not recognised, use this macro to report an error
   if a read-only attribute has been specified. */
   } else if ( MATCH( "lataxis" ) ||
               MATCH( "lonaxis" ) ) {
      astError( AST__NOWRT, "astSet: The setting \"%s\" is invalid for a %s.",
                setting, astGetClass( this ) );
      astError( AST__NOWRT, "This is a read-only attribute." );

/* Pass any unrecognised setting to the parent method for further
   interpretation. */
   } else {
      (*parent_setattrib)( this_object, setting );
   }
}

static void SetMaxAxes( AstFrame *this_frame, int maxaxes ) {
/*
*  Name:
*     SetMaxAxes

*  Purpose:
*     Set a value for the MaxAxes attribute of a SkyFrame.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     void SetMaxAxes( AstFrame *this, int maxaxes )

*  Class Membership:
*     SkyFrame member function (over-rides the astSetMaxAxes method
*     inherited from the Frame class).

*  Description:
*     This function sets the MaxAxes value for a SkyFrame to 2, which is the
*     only valid value for a SkyFrame, regardless of the value supplied.

*  Parameters:
*     this
*        Pointer to the SkyFrame.
*     maxaxes
*        The new value to be set (ignored).

*  Returned Value:
*     void.
*/

/* Check the global error status. */
   if ( !astOK ) return;

/* Use the parent astSetMaxAxes method to set a value of 2. */
   (*parent_setmaxaxes)( this_frame, 2 );
}

static void SetMinAxes( AstFrame *this_frame, int minaxes ) {
/*
*  Name:
*     SetMinAxes

*  Purpose:
*     Set a value for the MinAxes attribute of a SkyFrame.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     void SetMinAxes( AstFrame *this, int minaxes )

*  Class Membership:
*     SkyFrame member function (over-rides the astSetMinAxes method
*     inherited from the Frame class).

*  Description:
*     This function sets the MinAxes value for a SkyFrame to 2, which is the
*     only valid value for a SkyFrame, regardless of the value supplied.

*  Parameters:
*     this
*        Pointer to the SkyFrame.
*     minaxes
*        The new value to be set (ignored).

*  Returned Value:
*     void.
*/

/* Check the global error status. */
   if ( !astOK ) return;

/* Use the parent astSetMinAxes method to set a value of 2. */
   (*parent_setminaxes)( this_frame, 2 );
}

static void Shapp( double dist, double *r0, double *r3, double a0, 
                   double *p4 ){
/*
*  Name:
*     Shapp

*  Purpose:
*     Use the vectors calculated by Shcal to find a sky position
*     which is offset along a given position angle.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     void Shapp( double dist, double *r0, double *r3, double a0, 
*                 double *p4 )

*  Class Membership:
*     SkyFrame member function.

*  Description:
*     This function uses the vectors R0 and R3 calculated previously by
*     Shcal to find the sky position which is offset away from the
*     "reference" position (see function Offset2) by a given arc
*     distance, along a given great circle.
*
*     No checks are made for AST__BAD values.

*  Parameters:
*     dist 
*        The arc distance to move away from the reference position
*        in the given direction, in radians.
*     r0
*        Pointer to an array holding the 3-vector representing the reference 
*        position.
*     r3
*        Pointer to an array holding the 3-vector representing the 
*        point which is 90 degrees away from the reference point, along 
*        the required great circle.
*     a0 
*        The sky longitude of the reference position, in radians.
*     p4 
*        Pointer to an array of 2 doubles in which to put the sky longitude 
*        and latitude of the required point, in radians.

*/

/* Local Variables: */
   double cosdst;            /* Cosine of DIST */
   double r4[ 3 ];           /* Required position vector */
   double sindst;            /* Sine of DIST */

/* Check the global error status. */
   if ( !astOK ) return;

/* Store commonly used values. */
   sindst = sin( dist );
   cosdst = cos( dist );

/* The vector R4 representing the required point is produced as a
   linear sum of R0 and R3. */
   r4[ 0 ] = cosdst*r0[ 0 ] + sindst*r3[ 0 ];
   r4[ 1 ] = cosdst*r0[ 1 ] + sindst*r3[ 1 ];
   r4[ 2 ] = cosdst*r0[ 2 ] + sindst*r3[ 2 ];

/* Create the longitude of the required point. If this point is at 
   a pole it is assigned the same longitude as the reference point. */
   if( r4[ 0 ] != 0.0 || r4[ 1 ] != 0.0 ) {
      p4[ 0 ] = atan2( r4[ 1 ], r4[ 0 ] );
   } else {
      p4[ 0 ] = a0;
   }

/* Create the latitude of the required point. */
   if( r4[ 2 ] > 1.0 ) { 
      r4[ 2 ] = 1.0;
   } else if( r4[ 2 ] < -1.0 ) {
      r4[ 2 ] = -1.0;
   }
   p4[ 1 ] = asin( r4[ 2 ] );

}

static void Shcal( double a0, double b0, double angle, double *r0, 
                   double *r3 ) {
/*
*  Name:
*     Shcal

*  Purpose:
*     Calculate vectors required by Offset2.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     void Shcal( double a0, double b0, double angle, double *r0, 
*                 double *r3 )

*  Class Membership:
*     SkyFrame member function.

*  Description:
*     This function calculates the 3-vector R0, representing the given
*     sky position (A0,B0), and the 3-vector R3, representing the sky
*     position which is 90 degrees away from R0, along a great circle
*     passing through R0 at a position angle given by ANGLE. Each
*     3-vector holds Cartesian (X,Y,Z) values with origin at the centre
*     of the celestial sphere. The XY plane is the "equator", the Z
*     axis is in the direction of the "north pole", X is towards zero
*     longitude (A=0), and Y is towards longitude 90 degrees.
*
*     No checks are made for AST__BAD input values.

*  Parameters:
*     a0 
*        The sky longitude of the given position, in radians.
*     b0 
*        The sky latitude of the given position, in radians.
*     angle 
*        The position angle of a great circle passing through the given
*        position.  That is, the angle from north to the required
*        direction, in radians. Positive angles are in the sense of
*        rotation from north to east.
*     r0
*        A pointer to an array to receive 3-vector R0. See above.
*     r3
*        A pointer to an array to receive 3-vector R3. See above.

*/

/* Local Variables: */
   double cosa0;         /* Cosine of A0 */
   double cosb0;         /* Cosine of B0 */
   double cospa;         /* Cosine of ANGLE */
   double r1[ 3 ];       /* Vector PI/2 away from R0 in meridian of R0 */
   double r2[ 3 ];       /* Vector PI/2 away from R0 on equator */
   double sinpa;         /* Sine of ANGLE */
   double sina0;         /* Sine of A0 */
   double sinb0;         /* Sine of B0 */

/* Check the global error status. */
   if ( !astOK ) return;

/* Store commonly used values. */
   sina0 = sin( a0 );
   cosa0 = cos( a0 );
   sinb0 = sin( b0 );
   cosb0 = cos( b0 );
   sinpa = sin( angle );
   cospa = cos( angle );

/* Create the vector R0 representing the given point. The XY plane
   defines zero latitude, Z is in the direction of increasing latitude,
   X is towards zero longitude, and Y is towards longitude 90 degrees. */
   r0[ 0 ] =  cosb0*cosa0;
   r0[ 1 ] =  cosb0*sina0;
   r0[ 2 ] =  sinb0;

/* Create the vector R1 representing the point in the meridian of the
   given point which has latitude 90 degrees greater than the
   given point. */
   r1[ 0 ] = -sinb0*cosa0;
   r1[ 1 ] = -sinb0*sina0;
   r1[ 2 ] =  cosb0;

/* Create the vector R2 representing the point on the equator (i.e. a
   latitude of zero), which has a longitude 90 degrees to the west of
   the given point. */
   r2[ 0 ] = -sina0;
   r2[ 1 ] =  cosa0;
   r2[ 2 ] =  0.0;

/* Create the vector R3 representing the point which is 90 degrees away
   from the given point, along the required great circle. */
   r3[ 0 ] =  cospa*r1[ 0 ] + sinpa*r2[ 0 ];
   r3[ 1 ] =  cospa*r1[ 1 ] + sinpa*r2[ 1 ];
   r3[ 2 ] =  cospa*r1[ 2 ] + sinpa*r2[ 2 ];

/* Return */
   return;
}

static int SubFrame( AstFrame *target_frame, AstFrame *template,
                     int result_naxes, const int *target_axes,
                     const int *template_axes, AstMapping **map,
                     AstFrame **result ) {
/*
*  Name:
*     SubFrame

*  Purpose:
*     Select axes from a SkyFrame and convert to the new coordinate system.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     int SubFrame( AstFrame *target, AstFrame *template,
*                   int result_naxes, const int *target_axes,
*                   const int *template_axes, AstMapping **map,
*                   AstFrame **result )

*  Class Membership:
*     SkyFrame member function (over-rides the protected astSubFrame method
*     inherited from the Frame class).

*  Description:
*     This function selects a requested sub-set (or super-set) of the axes from
*     a "target" SkyFrame and creates a new Frame with copies of the selected
*     axes assembled in the requested order. It then optionally overlays the
*     attributes of a "template" Frame on to the result. It returns both the
*     resulting Frame and a Mapping that describes how to convert between the
*     coordinate systems described by the target and result Frames. If
*     necessary, this Mapping takes account of any differences in the Frames'
*     attributes due to the influence of the template.

*  Parameters:
*     target
*        Pointer to the target SkyFrame, from which axes are to be selected.
*     template
*        Pointer to the template Frame, from which new attributes for the
*        result Frame are to be obtained. Optionally, this may be NULL, in
*        which case no overlaying of template attributes will be performed.
*     result_naxes
*        Number of axes to be selected from the target Frame. This number may
*        be greater than or less than the number of axes in this Frame (or
*        equal).
*     target_axes
*        Pointer to an array of int with result_naxes elements, giving a list
*        of the (zero-based) axis indices of the axes to be selected from the
*        target SkyFrame. The order in which these are given determines the
*        order in which the axes appear in the result Frame. If any of the
*        values in this array is set to -1, the corresponding result axis will
*        not be derived from the target Frame, but will be assigned default
*        attributes instead.
*     template_axes
*        Pointer to an array of int with result_naxes elements. This should
*        contain a list of the template axes (given as zero-based axis indices)
*        with which the axes of the result Frame are to be associated. This
*        array determines which axes are used when overlaying axis-dependent
*        attributes of the template on to the result. If any element of this
*        array is set to -1, the corresponding result axis will not receive any
*        template attributes.
*
*        If the template argument is given as NULL, this array is not used and
*        a NULL pointer may also be supplied here.
*     map
*        Address of a location to receive a pointer to the returned Mapping.
*        The forward transformation of this Mapping will describe how to
*        convert coordinates from the coordinate system described by the target
*        SkyFrame to that described by the result Frame. The inverse
*        transformation will convert in the opposite direction.
*     result
*        Address of a location to receive a pointer to the result Frame.

*  Returned Value:
*     A non-zero value is returned if coordinate conversion is possible
*     between the target and the result Frame. Otherwise zero is returned and
*     *map and *result are returned as NULL (but this will not in itself
*     result in an error condition). In general, coordinate conversion should
*     always be possible if no template Frame is supplied but may not always
*     be possible otherwise.

*  Notes:
*     -  A value of zero will be returned if this function is invoked with the
*     global error status set, or if it should fail for any reason.

*  Implementation Notes:
*     -  This implementation addresses the selection of axes from a SkyFrame
*     object. This results in another object of the same class only if both
*     axes of the SkyFrame are selected, once each. Otherwise, the result is a
*     Frame class object which inherits the SkyFrame's axis information (if
*     appropriate) but none of the other properties of a SkyFrame.
*     -  In the event that a SkyFrame results, the returned Mapping will take
*     proper account of the relationship between the target and result sky
*     coordinate systems.
*     -  In the event that a Frame class object results, the returned Mapping
*     will only represent a selection/permutation of axes.

*  Implementation Deficiencies:
*     -  Any axis selection is currently permitted. Probably this should be
*     restricted so that each axis can only be selected once. The
*     astValidateAxisSelection method will do this but currently there are bugs
*     in the CmpFrame class that cause axis selections which will not pass this
*     test. Install the validation when these are fixed.
*/

/* Local Variables: */
   AstAxis *ax;                  /* Pointer to result Frame Axis object */
   AstMapping *tmpmap;           /* Temporary Mapping pointer */
   AstPermMap *permmap;          /* Pointer to PermMap */
   AstSkyFrame *target;          /* Pointer to the SkyFrame structure */
   AstSkyFrame *temp;            /* Pointer to copy of target SkyFrame */
   int match;                    /* Coordinate conversion is possible? */
   int perm[ 2 ];                /* Permutation array for axis swap */
   int result_swap;              /* Swap result SkyFrame coordinates? */
   int target_axis;              /* Target SkyFrame axis index */
   int target_swap;              /* Swap target SkyFrame coordinates? */

/* Initialise the returned values. */
   *map = NULL;
   *result = NULL;
   match = 0;

/* Check the global error status. */
   if ( !astOK ) return match;

/* Obtain a pointer to the target SkyFrame structure. */
   target = (AstSkyFrame *) target_frame;

/* Result is a SkyFrame. */
/* --------------------- */
/* Check if the result Frame is to have two axes obtained by selecting
   both of the target SkyFrame axes, in either order. If so, the
   result will also be a SkyFrame. */
   if ( ( result_naxes == 2 ) &&
        ( ( ( target_axes[ 0 ] == 0 ) && ( target_axes[ 1 ] == 1 ) ) ||
          ( ( target_axes[ 0 ] == 1 ) && ( target_axes[ 1 ] == 0 ) ) ) ) {

/* Form the result from a copy of the target and then permute its axes
   into the order required. */
      *result = astCopy( target );
      astPermAxes( *result, target_axes );

/* If required, overlay the template attributes on to the result SkyFrame. */
      if ( template ) astOverlay( template, template_axes, *result );

/* Generate a Mapping that takes account of changes in the sky coordinate
   system (equinox, epoch, etc.) between the target SkyFrame and the result
   SkyFrame. If this Mapping can be generated, set "match" to indicate that
   coordinate conversion is possible. */
      match = ( MakeSkyMapping( target, (AstSkyFrame *) *result, map ) != 0 );

/* If a Mapping has been obtained, it will expect coordinate values to be
   supplied in (longitude,latitude) pairs. Test whether we need to swap the
   order of the target SkyFrame coordinates to conform with this. */
      if ( astOK && match ) {
         target_swap = ( astValidateAxis( target, 0, "astSubFrame" ) != 0 );

/* Coordinates will also be delivered in (longitude,latitude) pairs, so check
   to see whether the result SkyFrame coordinate order should be swapped. */
         result_swap = ( target_swap != ( target_axes[ 0 ] != 0 ) );

/* If either set of coordinates needs swapping, create a PermMap that
   will swap a pair of coordinates. */
         permmap = NULL;
         if ( target_swap || result_swap ) {
            perm[ 0 ] = 1;
            perm[ 1 ] = 0;
            permmap = astPermMap( 2, perm, 2, perm, NULL, "" );
         }

/* If necessary, prefix this PermMap to the main Mapping. */
         if ( target_swap ) {
            tmpmap = (AstMapping *) astCmpMap( permmap, *map, 1, "" );
            *map = astAnnul( *map );
            *map = tmpmap;
         }

/* Also, if necessary, append it to the main Mapping. */
         if ( result_swap ) {
            tmpmap = (AstMapping *) astCmpMap( *map, permmap, 1, "" );
            *map = astAnnul( *map );
            *map = tmpmap;
         }

/* Annul the pointer to the PermMap (if created). */
         if ( permmap ) permmap = astAnnul( permmap );
      }

/* Result is not a SkyFrame. */
/* ------------------------- */
/* In this case, we select axes as if the target were from the Frame
   class.  However, since the resulting data will then be separated
   from their enclosing SkyFrame, default attribute values may differ
   if the methods for obtaining them were over-ridden by the SkyFrame
   class. To overcome this, we ensure that these values are explicitly
   set for the result Frame (rather than relying on their
   defaults). */
   } else {

/* Make a temporary copy of the target SkyFrame. We will explicitly
   set the attribute values in this copy so as not to modify the
   original. */
      temp = astCopy( target );

/* Define a macro to test if an attribute is set. If not, set it
   explicitly to its default value. */
#define SET(attribute) \
   if ( !astTest##attribute( temp ) ) { \
      astSet##attribute( temp, astGet##attribute( temp ) ); \
   }

/* Set attribute values which apply to the Frame as a whole and which
   we want to retain, but whose defaults are over-ridden by the
   SkyFrame class. */
      SET(Domain)
      SET(Title)

/* Now loop to set explicit attribute values for each axis. */
      for ( target_axis = 0; target_axis < 2; target_axis++ ) {

/* Define a macro to test if an axis attribute is set. If not, set it
   explicitly to its default value. */
#define SET_AXIS(attribute) \
   if ( !astTest##attribute( temp, target_axis ) ) { \
      astSet##attribute( temp, target_axis, \
                         astGet##attribute( temp, target_axis ) ); \
   }

/* Use this macro to set explicit values for all the axis attributes
   for which the SkyFrame class over-rides the default value. */
         SET_AXIS(AsTime)
         SET_AXIS(Format)
         SET_AXIS(Label)
         SET_AXIS(Symbol)
         SET_AXIS(Unit)

/* Now handle axis attributes for which there are no SkyFrame access
   methods.  For these we require a pointer to the temporary
   SkyFrame's Axis object. */
         ax = astGetAxis( temp, target_axis );

/* Set an explicit value for the IsLatitude attribute. */
         astSetAxisIsLatitude( ax,
                               ( astValidateAxis( temp, target_axis,
                                                  "astSubFrame" ) == 1 ) );

/* Annul the Axis object pointer. */
         ax = astAnnul( ax );
      }

/* Invoke the astSubFrame method inherited from the Frame class to
   produce the result Frame by selecting the required set of axes and
   overlaying the template Frame's attributes. */
      match = (*parent_subframe)( (AstFrame *) temp, template,
                                  result_naxes, target_axes, template_axes,
                                  map, result );

/* Delete the temporary copy of the target SkyFrame. */
      temp = astDelete( temp );
   }

/* If an error occurred or no match was found, annul the returned
   objects and reset the returned result. */
   if ( !astOK || !match ) {
      *map = astAnnul( *map );
      *result = astAnnul( *result );
      match = 0;
   }

/* Return the result. */
   return match;

/* Undefine macros local to this function. */
#undef SET
#undef SET_AXIS
}

static AstSkySystemType SystemCode( const char *system ) {
/*
*  Name:
*     SystemCode

*  Purpose:
*     Convert a string into a coordinate system type code.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     AstSkySystemType SystemCode( const char *system )

*  Class Membership:
*     SkyFrame member function.

*  Description:
*     This function converts a string used for the external
*     description of a sky coordinate system into a SkyFrame
*     coordinate system type code (System attribute value). It is the
*     inverse of the SystemString function.

*  Parameters:
*     system
*        Pointer to a constant null-terminated string containing the
*        external description of the sky coordinate system.

*  Returned Value:
*     The System type code.

*  Notes:
*     - A value of AST__NOSKYSYSTEM is returned if the sky coordinate
*     system description was not recognised. This does not produce an
*     error.
*     - A value of AST__NOSKYSYSTEM is also returned if this function
*     is invoked with the global error status set or if it should fail
*     for any reason.
*/

/* Local Variables: */
   AstSkySystemType result;      /* Result value to return */

/* Initialise. */
   result = AST__NOSKYSYSTEM;

/* Check the global error status. */
   if ( !astOK ) return result;

/* Match the "system" string against each possibility and assign the
   result. */
   if ( ChrMatch( "FK4", system ) ) {
      result = AST__FK4;

   } else if ( ChrMatch( "FK4_NO_E", system ) ||
               ChrMatch( "FK4-NO-E", system ) ) {
      result = AST__FK4_NO_E;

   } else if ( ChrMatch( "FK5", system ) ||
               ChrMatch( "Equatorial", system ) ) {
      result = AST__FK5;

   } else if ( ChrMatch( "GAPPT", system ) ||
               ChrMatch( "GEOCENTRIC", system ) ||
               ChrMatch( "APPARENT", system ) ) {
         result = AST__GAPPT;

   } else if ( ChrMatch( "ECLIPTIC", system ) ) {
      result = AST__ECLIPTIC;

   } else if ( ChrMatch( "GALACTIC", system ) ) {
      result = AST__GALACTIC;

   } else if ( ChrMatch( "SUPERGALACTIC", system ) ) {
      result = AST__SUPERGALACTIC;

   } else if ( ChrMatch( "UNKNOWN", system ) ) {
      result = AST__UNKNOWN;
   }

/* Return the result. */
   return result;
}

static const char *SystemString( AstSkySystemType system ) {
/*
*  Name:
*     SystemString

*  Purpose:
*     Convert a coordinate system type code into a string.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     const char *SystemString( AstSkySystemType system )

*  Class Membership:
*     SkyFrame member function.

*  Description:
*     This function converts a SkyFrame coordinate system type code
*     (System attribute value) into a string suitable for use as an
*     external representation of the coordinate system type.

*  Parameters:
*     system
*        The coordinate system type code.

*  Returned Value:
*     Pointer to a constant null-terminated string containing the
*     textual equivalent of the type code supplied.

*  Notes:
*     - A NULL pointer value is returned if the sky coordinate system
*     code was not recognised. This does not produce an error.
*     - A NULL pointer value is also returned if this function is
*     invoked with the global error status set or if it should fail
*     for any reason.
*/

/* Local Variables: */
   const char *result;           /* Pointer value to return */

/* Initialise. */
   result = NULL;

/* Check the global error status. */
   if ( !astOK ) return result;

/* Match the "system" value against each possibility and convert to a
   string pointer. (Where possible, return the same string as would be
   used in the FITS WCS representation of the coordinate system). */
   switch ( system ) {
   case AST__FK4:
      result = "FK4";
      break;

   case AST__FK4_NO_E:
      result = "FK4-NO-E";
      break;

   case AST__FK5:
      result = "FK5";
      break;

   case AST__GAPPT:
      result = "GAPPT";
      break;

   case AST__ECLIPTIC:
      result = "ECLIPTIC";
      break;

   case AST__GALACTIC:
      result = "GALACTIC";
      break;

   case AST__SUPERGALACTIC:
      result = "SUPERGALACTIC";
      break;

   case AST__UNKNOWN:
      result = "Unknown";
      break;
   }

/* Return the result pointer. */
   return result;
}

static int TestAsTime( AstSkyFrame *this, int axis ) {
/*
*  Name:
*     TestAsTime

*  Purpose:
*     Determine if a value has been set for a SkyFrame's AsTime attribute.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     int TestAsTime( AstSkyFrame *this, int axis )

*  Class Membership:
*     SkyFrame member function.

*  Description:
*     This function returns a boolean value to indicate if a value has
*     previously been set for the AsTime attribute for a specified axis of a
*     SkyFrame. This attribute indicates whether axis values should be
*     formatted as times (as opposed to angles) by default.

*  Parameters:
*     this
*        Pointer to the SkyFrame.
*     axis
*        Index of the axis for which information is required (zero based).

*  Returned Value:
*     Zero or one, according to whether the AsTime attribute has been set.

*  Notes:
*     -  A value of zero will be returned if this function is invoked with the
*     global error status set, or if it should fail for any reason.
*/

/* Local Variables. */
   AstAxis *ax;                  /* Pointer to Axis object */
   int result;                   /* Result to be returned */

/* Check the global error status. */
   if ( !astOK ) return 0;

/* Validate the axis index. */
   (void) astValidateAxis( this, axis, "astTestAsTime" );

/* Obtain a pointer to the Axis object. */
   ax = astGetAxis( this, axis );

/* Determine if the AsTime attribute has been set for it (it cannot have been
   set unless the object is a SkyAxis). */
   result = ( astIsASkyAxis( ax ) && astTestAxisAsTime( ax ) );

/* Annul the Axis pointer. */
   ax = astAnnul( ax );

/* Return the result. */
   return result;
}

static int TestAttrib( AstObject *this_object, const char *attrib ) {
/*
*  Name:
*     TestAttrib

*  Purpose:
*     Test if a specified attribute value is set for a SkyFrame.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     int TestAttrib( AstObject *this, const char *attrib )

*  Class Membership:
*     SkyFrame member function (over-rides the astTestAttrib protected
*     method inherited from the Frame class).

*  Description:
*     This function returns a boolean result (0 or 1) to indicate whether
*     a value has been set for one of a SkyFrame's attributes.

*  Parameters:
*     this
*        Pointer to the SkyFrame.
*     attrib
*        Pointer to a null terminated string specifying the attribute
*        name.  This should be in lower case with no surrounding white
*        space.

*  Returned Value:
*     One if a value has been set, otherwise zero.

*  Notes:
*     - This function uses one-based axis numbering so that it is
*     suitable for external (public) use.
*     - A value of zero will be returned if this function is invoked
*     with the global status set, or if it should fail for any reason.
*/

/* Local Variables: */
   AstSkyFrame *this;            /* Pointer to the SkyFrame structure */
   int axis;                     /* SkyFrame axis number */
   int len;                      /* Length of attrib string */
   int nc;                       /* No. characters read by astSscanf */
   int result;                   /* Result value to return */

/* Initialise. */
   result = 0;

/* Check the global error status. */
   if ( !astOK ) return result;

/* Obtain a pointer to the SkyFrame structure. */
   this = (AstSkyFrame *) this_object;

/* Obtain the length of the attrib string. */
   len = strlen( attrib );

/* Check the attribute name and test the appropriate attribute. */

/* AsTime(axis). */
/* ------------- */
   if ( nc = 0,
        ( 1 == astSscanf( attrib, "astime(%d)%n", &axis, &nc ) )
        && ( nc >= len ) ) {
      result = astTestAsTime( this, axis - 1 );

/* Epoch. */
/* ------ */
   } else if ( !strcmp( attrib, "epoch" ) ) {
      result = astTestEpoch( this );

/* Equinox. */
/* -------- */
   } else if ( !strcmp( attrib, "equinox" ) ) {
      result = astTestEquinox( this );

/* NegLon. */
/* ------- */
   } else if ( !strcmp( attrib, "neglon" ) ) {
      result = astTestNegLon( this );

/* Projection. */
/* ----------- */
   } else if ( !strcmp( attrib, "projection" ) ) {
      result = astTestProjection( this );

/* System. */
/* ------- */
   } else if ( !strcmp( attrib, "system" ) ) {
      result = astTestSystem( this );

/* If the name is not recognised, test if it matches any of the
   read-only attributes of this class. If it does, then return
   zero. */
   } else if ( !strcmp( attrib, "lataxis" ) ||
        !strcmp( attrib, "lonaxis" ) ) {
      result = 0;

/* If the attribute is not recognised, pass it on to the parent method
   for further interpretation. */
   } else {
      result = (*parent_testattrib)( this_object, attrib );
   }

/* Return the result, */
   return result;
}

static int Unformat( AstFrame *this_frame, int axis, const char *string,
                     double *value ) {
/*
*  Name:
*     Unformat

*  Purpose:
*     Read a formatted coordinate value for a SkyFrame axis.

*  Type:
*     Private function.

*  Synopsis:
*     #include "skyframe.h"
*     int Unformat( AstFrame *this, int axis, const char *string,
*                   double *value )

*  Class Membership:
*     SkyFrame member function (over-rides the public astUnformat
*     method inherited from the Frame class).

*  Description:
*     This function reads a formatted coordinate value for a SkyFrame
*     axis (supplied as a string) and returns the equivalent numerical
*     value as a double. It also returns the number of characters read
*     from the string.

*  Parameters:
*     this
*        Pointer to the SkyFrame.
*     axis
*        The number of the SkyFrame axis for which the coordinate
*        value is to be read (axis numbering starts at zero for the
*        first axis).
*     string
*        Pointer to a constant null-terminated string containing the
*        formatted coordinate value.
*     value
*        Pointer to a double in which the coordinate value read will
*        be returned (in radians).

*  Returned Value:
*     The number of characters read from the string to obtain the
*     coordinate value.

*  Notes:
*     - Any white space at the beginning of the string will be
*     skipped, as also will any trailing white space following the
*     coordinate value read. The function's return value will reflect
*     this.
*     - A function value of zero (and no coordinate value) will be
*     returned, without error, if the string supplied does not contain
*     a suitably formatted value.
*     - The string "<bad>" is recognised as a special case and will
*     generate the value AST__BAD, without error. The test for this
*     string is case-insensitive and permits embedded white space.
*     - A function result of zero will be returned and no coordinate
*     value will be returned via the "value" pointer if this function
*     is invoked with the global error status set, or if it should
*     fail for any reason.
*/

/* Local Variables: */
   AstSkyFrame *this;            /* Pointer to the SkyFrame structure */
   double coord;                 /* Coordinate value read */
   int format_set;               /* Format attribute set? */
   int nc;                       /* Number of characters read */

/* Initialise. */
   nc = 0;

/* Check the global error status. */
   if ( !astOK ) return nc;

/* Obtain a pointer to the SkyFrame structure. */
   this = (AstSkyFrame *) this_frame;

/* Validate the axis index. */
   (void) astValidateAxis( this, axis, "astUnformat" );

/* Determine if a Format value has been set for the axis and set a
   temporary value if it has not. Use the GetFormat member function
   for this class together with member functions inherited from the
   parent class (rather than using the object's methods directly)
   because if any of these methods have been over-ridden by a derived
   class the Format string syntax may no longer be compatible with
   this class. */
   format_set = (*parent_testformat)( this_frame, axis );
   if ( !format_set ) {
      (*parent_setformat)( this_frame, axis, GetFormat( this_frame, axis ) );
   }

/* Use the Unformat member function inherited from the parent class to
   read the coordinate value. */
   nc = (*parent_unformat)( this_frame, axis, string, &coord );

/* If necessary, clear any temporary Format value that was set above. */
   if ( !format_set ) (*parent_clearformat)( this_frame, axis );

/* If an error occurred, clear the number of characters read. */
   if ( !astOK ) {
      nc = 0;

/* Otherwise, if characters were read, return the coordinate value. */
   } else if ( nc ) {
      *value = coord;
   }

/* Return the number of characters read. */
   return nc;
}

/* Functions which access class attributes. */
/* ---------------------------------------- */
/*
*att++
*  Name:
*     AsTime(axis)

*  Purpose:
*     Format celestal coordinates as times?

*  Type:
*     Public attribute.

*  Synopsis:
*     Integer (boolean).

*  Description:
*     This attribute specifies the default style of formatting to be
c     used (e.g. by astFormat) for the celestial coordinate values
f     used (e.g. by AST_FORMAT) for the celestial coordinate values
*     described by a SkyFrame. It takes a separate boolean value for
*     each SkyFrame axis so that, for instance, the setting
*     "AsTime(2)=0" specifies the default formatting style for
*     celestial latitude values.
*
*     If the AsTime attribute for a SkyFrame axis is zero, then
*     coordinates on that axis will be formatted as angles by default
*     (using degrees, minutes and seconds), otherwise they will be
*     formatted as times (using hours, minutes and seconds).
*
*     The default value of AsTime is chosen according to the sky
*     coordinate system being represented, as determined by the
*     SkyFrame's System attribute. This ensures, for example, that
*     right ascension values will be formatted as times by default,
*     following normal conventions.

*  Applicability:
*     SkyFrame
*        All SkyFrames have this attribute.

*  Notes:
*     - The AsTime attribute operates by changing the default value of
*     the corresponding Format(axis) attribute. This, in turn, may
*     also affect the value of the Unit(axis) attribute.
*     - Only the default style of formatting is affected by the AsTime
*     value. If an explicit Format(axis) value is set, it will
*     over-ride any effect from the AsTime attribute.
*att--
*/

/*
*att++
*  Name:
*     Epoch

*  Purpose:
*     Epoch of observation.

*  Type:
*     Public attribute.

*  Synopsis:
*     Floating point.

*  Description:
*     This attribute is used to qualify the celestial coordinate
*     system described by a SkyFrame, by giving the moment in time
*     when the coordinates are known to be correct. Often, this will
*     be the date of observation.
*
*     The Epoch value is important in cases where the coordinates of
*     sources may change with time. Possible reasons for this include:
*     (i) changing aberration of light caused by the observer's
*     velocity (e.g. due to the Earth's motion around the Sun), (ii)
*     changing gravitational deflection by the Sun due to changes in
*     the observer's position with time, (iii) fictitious motion due
*     to rotation of non-inertial coordinate systems (e.g. the old FK4
*     system), and (iv) proper motion of the source itself (although
*     this last effect is not handled by the SkyFrame class because it
*     affects individual sources rather than the coordinate system as
*     a whole).
*
*     The Epoch attribute is stored as a Modified Julian Date, but
*     when setting its value it may be given in a variety of
*     formats. See the "Input Formats" section (below) for details.
*
*     The default Epoch value is B1950.0 (Besselian) for the old
*     FK4-based coordinate systems (see the System attribute) and
*     J2000.0 (Julian) for all others.

*  Input Formats:
*     The formats accepted when setting an Epoch value are listed
*     below. They are all case-insensitive and are generally tolerant
*     of extra white space and alternative field delimiters:
*
*     - Besselian Epoch: Expressed in decimal years, with or without
*     decimal places ("B1950" or "B1976.13" for example).
*
*     - Julian Epoch: Expressed in decimal years, with or without
*     decimal places ("J2000" or "J2100.9" for example).
*
*     - Year: Decimal years, with or without decimal places ("1996.8"
*     for example).  Such values are interpreted as a Besselian epoch
*     (see above) if less than 1984.0 and as a Julian epoch otherwise.
*
*     - Julian Date: With or without decimal places ("JD 2454321.9" for
*     example).
*
*     - Modified Julian Date: With or without decimal places
*     ("MJD 54321.4" for example).
*
*     - Gregorian Calendar Date: With the month expressed either as an
*     integer or a 3-character abbreviation, and with optional decimal
*     places to represent a fraction of a day ("1996-10-2" or
*     "1996-Oct-2.6" for example). If no fractional part of a day is
*     given, the time refers to the start of the day (zero hours).
*
*     - Gregorian Date and Time: Any calendar date (as above) but with
*     a fraction of a day expressed as hours, minutes and seconds
*     ("1996-Oct-2 12:13:56.985" for example).

*  Output Format:
*     When enquiring Epoch values, the format used is the "Year"
*     format described under "Input Formats". This is a value in
*     decimal years which will be a Besselian epoch if less than
*     1984.0 and a Julian epoch otherwise.  By omitting any character
*     prefix, this format allows the Epoch value to be obtained as
*     either a character string or a floating point value.

*  Applicability:
*     SkyFrame
*        All SkyFrames have this attribute.

*  Notes:
*     - Care must be taken to distinguish the Epoch value, which
*     relates to motion (or apparent motion) of the source, from the
*     superficially similar Equinox value. The latter is used to
*     qualify a coordinate system which is itself in motion in a
*     (notionally) predictable way as a result of being referred to a
*     slowly moving reference plane (e.g. the equator).
*     - See the description of the System attribute for details of
*     which qualifying attributes apply to each celestial coordinate
*     system.
*att--
*/
/* Clear the Epoch value by setting it to AST__BAD. */
astMAKE_CLEAR(SkyFrame,Epoch,epoch,AST__BAD)

/* Provide a default value of B1950.0 or J2000.0 depending on the System
   setting. */
astMAKE_GET(SkyFrame,Epoch,double,AST__BAD,(
            ( this->epoch != AST__BAD ) ? this->epoch :
               ( ( ( astGetSystem( this ) == AST__FK4 ) ||
                   ( astGetSystem( this ) == AST__FK4_NO_E ) ) ?
                    slaEpb2d( 1950.0 ) : slaEpj2d( 2000.0 ) ) ))

/* Allow any Epoch value to be set. */
astMAKE_SET(SkyFrame,Epoch,double,epoch,value)

/* An Epoch value is set if it is not equal to AST__BAD. */
astMAKE_TEST(SkyFrame,Epoch,( this->epoch != AST__BAD ))

/*
*att++
*  Name:
*     Equinox

*  Purpose:
*     Epoch of the mean equinox.

*  Type:
*     Public attribute.

*  Synopsis:
*     Floating point.

*  Description:
*     This attribute is used to qualify those celestial coordinate
*     systems described by a SkyFrame which are notionally based on
*     the ecliptic (the plane of the Earth's orbit around the Sun)
*     and/or the Earth's equator.
*
*     Both of these planes are in motion and their positions are
*     difficult to specify precisely. In practice, therefore, a model
*     ecliptic and/or equator are used instead. These, together with
*     the point on the sky that defines the coordinate origin (the
*     intersection of the two planes termed the "mean equinox") move
*     with time according to some model which removes the more rapid
*     fluctuations. The SkyFrame class supports both the old FK4 and
*     the current FK5 models.
*
*     The position of a fixed source expressed in any of these
*     coordinate systems will appear to change with time due to
*     movement of the coordinate system itself (rather than motion of
*     the source).  Such coordinate systems must therefore be
*     qualified by a moment in time (the "epoch of the mean equinox"
*     or "equinox" for short) which allows the position of the model
*     coordinate system on the sky to be determined. This is the role
*     of the Equinox attribute.
*
*     The Equinox attribute is stored as a Modified Julian Date, but
*     when setting or getting its value you may use the same formats
*     as for the Epoch attribute (q.v.).
*
*     The default Equinox value is B1950.0 (Besselian) for the old
*     FK4-based coordinate systems (see the System attribute) and
*     J2000.0 (Julian) for all others.

*  Applicability:
*     SkyFrame
*        All SkyFrames have this attribute.

*  Notes:
*     - Care must be taken to distinguish the Equinox value, which
*     relates to the definition of a time-dependent coordinate system
*     (based on solar system reference planes which are in motion),
*     from the superficially similar Epoch value. The latter is used
*     to qualify coordinate systems where the positions of sources
*     change with time (or appear to do so) for a variety of other
*     reasons, such as aberration of light caused by the observer's
*     motion, etc.
*     - See the description of the System attribute for details of
*     which qualifying attributes apply to each celestial coordinate
*     system.
*att--
*/
/* Clear the Equinox value by setting it to AST__BAD. */
astMAKE_CLEAR(SkyFrame,Equinox,equinox,AST__BAD)

/* Provide a default value of B1950.0 or J2000.0 depending on the System
   setting. */
astMAKE_GET(SkyFrame,Equinox,double,AST__BAD,(
            ( this->equinox != AST__BAD ) ? this->equinox :
               ( ( ( astGetSystem( this ) == AST__FK4 ) ||
                   ( astGetSystem( this ) == AST__FK4_NO_E ) ) ?
                    slaEpb2d( 1950.0 ) : slaEpj2d( 2000.0 ) ) ))

/* Allow any Equinox value to be set. */
astMAKE_SET(SkyFrame,Equinox,double,equinox,value)

/* An Equinox value is set if it is not equal to AST__BAD. */
astMAKE_TEST(SkyFrame,Equinox,( this->equinox != AST__BAD ))


/*
*att++
*  Name:
*     LatAxis

*  Purpose:
*     Index of the latitude axis.

*  Type:
*     Public attribute.

*  Synopsis:
*     Floating point.

*  Description:
*     This read-only attribute gives the index (1 or 2) of the latitude 
*     axis within the SkyFrame (taking into account any current axis 
*     permutations).

*  Applicability:
*     SkyFrame
*        All SkyFrames have this attribute.

*att--
*/

/*
*att++
*  Name:
*     LonAxis

*  Purpose:
*     Index of the longitude axis.

*  Type:
*     Public attribute.

*  Synopsis:
*     Floating point.

*  Description:
*     This read-only attribute gives the index (1 or 2) of the longitude 
*     axis within the SkyFrame (taking into account any current axis 
*     permutations).

*  Applicability:
*     SkyFrame
*        All SkyFrames have this attribute.

*att--
*/

/*
*att++
*  Name:
*     NegLon

*  Purpose:
*     Display negative longitude values?

*  Type:
*     Public attribute.

*  Synopsis:
*     Integer (boolean).

*  Description:
*     This attribute is a boolean value which controls how longitude values
c     are normalized for display by astNorm.
f     are normalized for display by AST_NORM.
*
*     If the NegLon attribute is zero (the default), then normalized 
*     longitude values will be in the range zero to 2.pi. If NegLon is
*     non-zero, then normalized longitude values will be in the range -pi 
*     to pi. 

*  Applicability:
*     SkyFrame
*        All SkyFrames have this attribute.
*att--
*/
/* Clear the NegLon value by setting it to -INT_MAX. */
astMAKE_CLEAR(SkyFrame,NegLon,neglon,-INT_MAX)

/* Supply a default of 0 if no NegLon value has been set. */
astMAKE_GET(SkyFrame,NegLon,int,0,( ( this->neglon != -INT_MAX ) ?
                                   this->neglon : 0 ))

/* Set a NegLon value of 1 if any non-zero value is supplied. */
astMAKE_SET(SkyFrame,NegLon,int,neglon,( value != 0 ))

/* The NegLon value is set if it is not -INT_MAX. */
astMAKE_TEST(SkyFrame,NegLon,( this->neglon != -INT_MAX ))

/*
*att++
*  Name:
*     Projection

*  Purpose:
*     Sky projection description.

*  Type:
*     Public attribute.

*  Synopsis:
*     String.

*  Description:
*     This attribute provides a place to store a description of the
*     type of sky projection used when a SkyFrame is attached to a
*     2-dimensional object, such as an image or plotting surface. For
*     example, typical values might be "orthographic", "Hammer-Aitoff"
*     or "cylindrical equal area".
*
*     The Projection value is purely descriptive and does not affect
*     the celestial coordinate system represented by the SkyFrame in
*     any way. If it is set to a non-blank string, the description
*     provided may be used when forming the default value for the
*     SkyFrame's Title attribute (so that typically it will appear in
*     graphical output, for instance). The default value is an empty
*     string.

*  Applicability:
*     SkyFrame
*        All SkyFrames have this attribute.
*att--
*/
/* Clear the Projection value by freeing the allocated memory and
   assigning a NULL pointer. */
astMAKE_CLEAR(SkyFrame,Projection,projection,astFree( this->projection ))

/* If the Projection value is not set, return a pointer to an empty
   string. */
astMAKE_GET(SkyFrame,Projection,const char *,NULL,( this->projection ?
                                                    this->projection : "" ))

/* Set a Projection value by freeing any previously allocated memory,
   allocating new memory, storing the string and saving the pointer to
   the copy. */
astMAKE_SET(SkyFrame,Projection,const char *,projection,astStore(
                     this->projection, value, strlen( value ) + (size_t) 1 ))

/* The Projection value is set if the pointer to it is not NULL. */
astMAKE_TEST(SkyFrame,Projection,( this->projection != NULL ))

/*
*att++
*  Name:
*     System

*  Purpose:
*     Celestial coordinate system.

*  Type:
*     Public attribute.

*  Synopsis:
*     String.

*  Description:
*     This attribute identifies the particular celestial coordinate
*     system represented by a SkyFrame, and may take any of the values
*     listed in the "Celestial Coordinate Systems" section (below).
*
*     Currently, the default System value is "FK5". However, this
*     default may change in future as new astrometric standards
*     evolve. The intention is to track the most modern appropriate
*     standard. For this reason, you should use the default only if
*     this is what you intend (and can tolerate any associated slight
*     change in future). If you intend to use the FK5 system
*     indefinitely, then you should specify it explicitly.

*  Applicability:
*     SkyFrame
*        All SkyFrames have this attribute.

*  Celestial Coordinate Systems:
*     The SkyFrame class supports the following System values (all are
*     case-insensitive) and associated celestial coordinate systems:
*
*     - "FK4": The old FK4 (barycentric) equatorial coordinate system,
*     which should be qualified by an Equinox value. The underlying
*     model on which this is based is non-inertial and rotates slowly
*     with time, so for accurate work FK4 coordinate systems should
*     also be qualified by an Epoch value.
*
*     - "FK4-NO-E" or "FK4_NO_E": The old FK4 (barycentric) equatorial
*     system but without the "E-terms of aberration" (e.g. some radio
*     catalogues). This coordinate system should also be qualified by
*     both an Equinox and an Epoch value.
*
*     - "FK5" or "EQUATORIAL": The modern FK5 (barycentric) equatorial
*     coordinate system. This should be qualified by an Equinox value.
*
*     - "GAPPT", "GEOCENTRIC" or "APPARENT": The geocentric apparent
*     equatorial coordinate system, which gives the apparent positions
*     of sources relative to the true plane of the Earth's equator and
*     the equinox (the coordinate origin) at a time specified by the
*     qualifying Epoch value. (Note that no Equinox is needed to
*     qualify this coordinate system because no model "mean equinox"
*     is involved.)  These coordinates give the apparent right
*     ascension and declination of a source for a specified date of
*     observation, and therefore form an approximate basis for
*     pointing a telescope. Note, however, that they are applicable to
*     a fictitious observer at the Earth's centre, and therefore
*     ignore such effects as atmospheric refraction and the (normally
*     much smaller) aberration of light due to the rotational velocity
*     of the Earth's surface.  Geocentric apparent coordinates are
*     derived from the standard FK5 (J2000.0) barycentric coordinates
*     by taking account of the gravitational deflection of light by
*     the Sun (usually small), the aberration of light caused by the
*     motion of the Earth's centre with respect to the barycentre
*     (larger), and the precession and nutation of the Earth's spin
*     axis (normally larger still).
*
*     - "ECLIPTIC": Ecliptic coordinates (IAU 1980), referred to the
*     ecliptic and mean equinox specified by the qualifying Equinox
*     value.
*
*     - "GALACTIC": Galactic coordinates (IAU 1958).
*
*     - "SUPERGALACTIC": De Vaucouleurs Supergalactic coordinates.
*
*     - "UNKNOWN": Any other general spherical coordinate system. No
*     Mapping can be created between a pair of SkyFrames if either of the
*     SkyFrames has System set to "Unknown".
*
*     Where more than one alternative System value is shown above, the
*     first of these will be returned when an enquiry is made.
*att--
*/
/* Clear the System value by setting it to AST__NOSKYSYSTEM. */
astMAKE_CLEAR(SkyFrame,System,system,AST__NOSKYSYSTEM)

/* Provide a default sky coordinate system of AST__FK5. */
astMAKE_GET(SkyFrame,System,AstSkySystemType,AST__NOSKYSYSTEM,(
            ( this->system == AST__NOSKYSYSTEM ) ? AST__FK5 : this->system ) )

/* Validate the System value being set and report an error if necessary. */
astMAKE_SET(SkyFrame,System,AstSkySystemType,system,(
            ( ( value >= AST__SKYSYSTEM_FIRST ) &&
              ( value <= AST__SKYSYSTEM_LAST ) ) ?
                 value :
                 ( astError( AST__ATTIN, "astSetSystem(%s): Bad value (%d) "
                             "given for System attribute.",
                             astGetClass( this ), (int) value ),

/* Leave the value unchanged on error. */
                                            this->system ) ) )

/* The System value is set if it is not AST__NOSKYSYSTEM. */
astMAKE_TEST(SkyFrame,System,( this->system != AST__NOSKYSYSTEM ))

/* Copy constructor. */
/* ----------------- */
static void Copy( const AstObject *objin, AstObject *objout ) {
/*
*  Name:
*     Copy

*  Purpose:
*     Copy constructor for SkyFrame objects.

*  Type:
*     Private function.

*  Synopsis:
*     void Copy( const AstObject *objin, AstObject *objout )

*  Description:
*     This function implements the copy constructor for SkyFrame objects.

*  Parameters:
*     objin
*        Pointer to the object to be copied.
*     objout
*        Pointer to the object being constructed.

*  Notes:
*     -  This constructor makes a deep copy.
*/

/* Local Variables: */
   AstSkyFrame *in;              /* Pointer to input SkyFrame */
   AstSkyFrame *out;             /* Pointer to output SkyFrame */

/* Check the global error status. */
   if ( !astOK ) return;

/* Obtain pointers to the input and output SkyFrames. */
   in = (AstSkyFrame *) objin;
   out = (AstSkyFrame *) objout;

/* For safety, first clear any references to the input memory from
   the output SkyFrame. */
   out->projection = NULL;

/* If necessary, allocate memory in the output SkyFrame and store a
   copy of the input Projection string. */
   if ( in->projection ) out->projection = astStore( NULL, in->projection,
                                      strlen( in->projection ) + (size_t) 1 );

/* If an error occurred, free any allocated memory. */
   if ( !astOK ) {
      out->projection = astFree( out->projection );
   }
}

/* Destructor. */
/* ----------- */
static void Delete( AstObject *obj ) {
/*
*  Name:
*     Delete

*  Purpose:
*     Destructor for SkyFrame objects.

*  Type:
*     Private function.

*  Synopsis:
*     void Delete( AstObject *obj )

*  Description:
*     This function implements the destructor for SkyFrame objects.

*  Parameters:
*     obj
*        Pointer to the object to be deleted.

*  Notes:
*     This function attempts to execute even if the global error status is
*     set.
*/

/* Local Variables: */
   AstSkyFrame *this;            /* Pointer to SkyFrame */

/* Obtain a pointer to the SkyFrame structure. */
   this = (AstSkyFrame *) obj;

/* Free the memory used for the Projection string if necessary. */
   this->projection = astFree( this->projection );
}

/* Dump function. */
/* -------------- */
static void Dump( AstObject *this_object, AstChannel *channel ) {
/*
*  Name:
*     Dump

*  Purpose:
*     Dump function for SkyFrame objects.

*  Type:
*     Private function.

*  Synopsis:
*     void Dump( AstObject *this, AstChannel *channel )

*  Description:
*     This function implements the Dump function which writes out data
*     for the SkyFrame class to an output Channel.

*  Parameters:
*     this
*        Pointer to the SkyFrame whose data are being written.
*     channel
*        Pointer to the Channel to which the data are being written.
*/

/* Local Variables: */
   AstSkyFrame *this;            /* Pointer to the SkyFrame structure */
   AstSkySystemType system;      /* System attribute value */
   const char *sval;             /* Pointer to string value */
   double dval;                  /* Double value */
   int bessyr;                   /* Format as Besselian years (else Julian) */
   int helpful;                  /* Helpful to display un-set value? */
   int ival;                     /* Integer value */
   int set;                      /* Attribute value set? */

/* Check the global error status. */
   if ( !astOK ) return;

/* Obtain a pointer to the SkyFrame structure. */
   this = (AstSkyFrame *) this_object;

/* Write out values representing the instance variables for the
   SkyFrame class.  Accompany these with appropriate comment strings,
   possibly depending on the values being written.*/

/* In the case of attributes, we first use the appropriate (private)
   Test...  member function to see if they are set. If so, we then use
   the (private) Get... function to obtain the value to be written
   out.

   For attributes which are not set, we use the astGet... method to
   obtain the value instead. This will supply a default value
   (possibly provided by a derived class which over-rides this method)
   which is more useful to a human reader as it corresponds to the
   actual default attribute value.  Since "set" will be zero, these
   values are for information only and will not be read back. */

/* System. */
/* ------- */
   set = TestSystem( this );
   system = set ? GetSystem( this ) : astGetSystem( this );

/* If set, convert explicitly to a string for the external
   representation. */
   if ( set ) {
      if ( astOK ) {
         sval = SystemString( system );

/* Report an error if the System value was not recognised. */
         if ( !sval ) {
            astError( AST__SCSIN,
                     "astWrite(%s): Corrupt %s contains invalid sky "
                     "coordinate system identification code (%d).",
                     astGetClass( channel ), astGetClass( this ),
                     (int) system );
         }
      }

/* If not set, use astGetAttrib which returns a string value using
   (possibly over-ridden) methods. */
   } else {
      sval = astGetAttrib( this_object, "system" );
   }

/* Write out the value. */
   astWriteString( channel, "System", set, 1, sval,
                   "Celestial coordinate system type" );

/* Projection. */
/* ----------- */
   set = TestProjection( this );
   sval = set ? GetProjection( this ) : astGetProjection( this );
   astWriteString( channel, "Proj", set, 0, sval,
                   "Description of sky projection" );

/* Epoch. */
/* ------ */
   set = TestEpoch( this );
   dval = set ? GetEpoch( this ) : astGetEpoch( this );

/* Decide whether the Epoch value is relevant to ths current
   coordinate system. */
   helpful = ( ( system == AST__FK4 ) ||
               ( system == AST__FK4_NO_E ) ||
               ( system == AST__GAPPT ) );

/* Convert MJD to Besselian or Julian years, depending on the value. */
   bessyr = ( dval < slaEpj2d( 1984.0 ) );
   dval = bessyr ? slaEpb( dval ) : slaEpj( dval );
   astWriteDouble( channel, "Epoch", set, helpful, dval,
                   bessyr ? "Besselian epoch of observation" :
                            "Julian epoch of observation" );

/* NegLon. */
/* ------- */
   set = TestNegLon( this );
   ival = set ? GetNegLon( this ) : astGetNegLon( this );
   astWriteInt( channel, "NegLon", set, 0, ival,
                ival ? "Display negative longitude values" :
                       "Display positive longitude values" );

/* Equinox. */
/* -------- */
   set = TestEquinox( this );
   dval = set ? GetEquinox( this ) : astGetEquinox( this );

/* Decide whether the Equinox value is relevant to ths current
   coordinate system. */
   helpful = ( ( system == AST__FK4 ) ||
               ( system == AST__FK4_NO_E ) ||
               ( system == AST__FK5 ) ||
               ( system == AST__ECLIPTIC ) );

/* Convert MJD to Besselian or Julian years, depending on the value. */
   bessyr = ( dval < slaEpj2d( 1984.0 ) );
   dval = bessyr ? slaEpb( dval ) : slaEpj( dval );
   astWriteDouble( channel, "Eqnox", set, helpful, dval,
                   bessyr ? "Besselian epoch of mean equinox" :
                            "Julian epoch of mean equinox" );
}

/* Standard class functions. */
/* ========================= */
/* Implement the astIsASkyFrame and astCheckSkyFrame functions using the macros
   defined for this purpose in the "object.h" header file. */
astMAKE_ISA(SkyFrame,Frame,check,&class_init)
astMAKE_CHECK(SkyFrame)

AstSkyFrame *astSkyFrame_( const char *options, ... ) {
/*
*+
*  Name:
*     astSkyFrame

*  Purpose:
*     Create a SkyFrame.

*  Type:
*     Protected function.

*  Synopsis:
*     #include "skyframe.h"
*     AstSkyFrame *astSkyFrame( const char *options, ... )

*  Class Membership:
*     SkyFrame constructor.

*  Description:
*     This function creates a new SkyFrame and optionally initialises its
*     attributes.

*  Parameters:
*     options
*        Pointer to a null terminated string containing an optional
*        comma-separated list of attribute assignments to be used for
*        initialising the new SkyFrame. The syntax used is the same as for the
*        astSet method and may include "printf" format specifiers identified
*        by "%" symbols in the normal way.
*     ...
*        If the "options" string contains "%" format specifiers, then an
*        optional list of arguments may follow it in order to supply values to
*        be substituted for these specifiers. The rules for supplying these
*        are identical to those for the astSet method (and for the C "printf"
*        function).

*  Returned Value:
*     A pointer to the new SkyFrame.

*  Notes:
*     -  A NULL pointer will be returned if this function is invoked with the
*     global error status set, or if it should fail for any reason.
*-

*  Implementation Notes:
*     - This function implements the basic SkyFrame constructor which
*     is available via the protected interface to the SkyFrame class.
*     A public interface is provided by the astSkyFrameId_ function.
*/

/* Local Variables: */
   AstSkyFrame *new;             /* Pointer to new SkyFrame */
   va_list args;                 /* Variable argument list */

/* Check the global status. */
   if ( !astOK ) return NULL;

/* Initialise the SkyFrame, allocating memory and initialising the virtual
   function table as well if necessary. */
   new = astInitSkyFrame( NULL, sizeof( AstSkyFrame ), !class_init, &class_vtab,
                          "SkyFrame" );

/* If successful, note that the virtual function table has been initialised. */
   if ( astOK ) {
      class_init = 1;

/* Obtain the variable argument list and pass it along with the options string
   to the astVSet method to initialise the new SkyFrame's attributes. */
      va_start( args, options );
      astVSet( new, options, args );
      va_end( args );

/* If an error occurred, clean up by deleting the new object. */
      if ( !astOK ) new = astDelete( new );
   }

/* Return a pointer to the new SkyFrame. */
   return new;
}

AstSkyFrame *astInitSkyFrame_( void *mem, size_t size, int init,
                               AstSkyFrameVtab *vtab, const char *name ) {
/*
*+
*  Name:
*     astInitSkyFrame

*  Purpose:
*     Initialise a SkyFrame.

*  Type:
*     Protected function.

*  Synopsis:
*     #include "skyframe.h"
*     AstSkyFrame *astInitSkyFrame( void *mem, size_t size, int init,
*                                   AstFrameVtab *vtab, const char *name )

*  Class Membership:
*     SkyFrame initialiser.

*  Description:
*     This function is provided for use by class implementations to initialise
*     a new SkyFrame object. It allocates memory (if necessary) to accommodate
*     the SkyFrame plus any additional data associated with the derived class.
*     It then initialises a SkyFrame structure at the start of this memory. If
*     the "init" flag is set, it also initialises the contents of a virtual
*     function table for a SkyFrame at the start of the memory passed via the
*     "vtab" parameter.

*  Parameters:
*     mem
*        A pointer to the memory in which the SkyFrame is to be created. This
*        must be of sufficient size to accommodate the SkyFrame data
*        (sizeof(SkyFrame)) plus any data used by the derived class. If a value
*        of NULL is given, this function will allocate the memory itself using
*        the "size" parameter to determine its size.
*     size
*        The amount of memory used by the SkyFrame (plus derived class data).
*        This will be used to allocate memory if a value of NULL is given for
*        the "mem" parameter. This value is also stored in the SkyFrame
*        structure, so a valid value must be supplied even if not required for
*        allocating memory.
*     init
*        A logical flag indicating if the SkyFrame's virtual function table is
*        to be initialised. If this value is non-zero, the virtual function
*        table will be initialised by this function.
*     vtab
*        Pointer to the start of the virtual function table to be associated
*        with the new SkyFrame.
*     name
*        Pointer to a constant null-terminated character string which contains
*        the name of the class to which the new object belongs (it is this
*        pointer value that will subsequently be returned by the astGetClass
*        method).

*  Returned Value:
*     A pointer to the new SkyFrame.

*  Notes:
*     -  A null pointer will be returned if this function is invoked with the
*     global error status set, or if it should fail for any reason.
*-
*/

/* Local Variables: */
   AstSkyAxis *ax;               /* Pointer to SkyAxis object */
   AstSkyFrame *new;             /* Pointer to the new SkyFrame */
   int axis;                     /* Loop counter for axes */

/* Check the global status. */
   if ( !astOK ) return NULL;

/* Initialise a Frame structure (the parent class) as the first component
   within the SkyFrame structure, allocating memory if necessary. */
   new = (AstSkyFrame *) astInitFrame( mem, size, init,
                                       (AstFrameVtab *) vtab, name, 2 );

/* If necessary, initialise the virtual function table. */
/* ---------------------------------------------------- */
      if ( init ) InitVtab( vtab );
      if ( astOK ) {

/* Initialise the SkyFrame data. */
/* ----------------------------- */
/* Initialise all attributes to their "undefined" values. */
      new->epoch = AST__BAD;
      new->equinox = AST__BAD;
      new->projection = NULL;
      new->system = AST__NOSKYSYSTEM;
      new->neglon = -INT_MAX;

/* Loop to replace the Axis object associated with each SkyFrame axis with
   a SkyAxis object instead. */
      for ( axis = 0; axis < 2; axis++ ) {

/* Create the new SkyAxis, assign it to the required SkyFrame axis and then
   annul the SkyAxis pointer. */
         ax = astSkyAxis( "" );
         astSetAxis( new, axis, ax );
         ax = astAnnul( ax );
      }

/* If an error occurred, clean up by deleting the new object. */
      if ( !astOK ) new = astDelete( new );
   }

/* Return a pointer to the new object. */
   return new;
}

AstSkyFrame *astLoadSkyFrame_( void *mem, size_t size, int init,
                               AstSkyFrameVtab *vtab, const char *name,
                               AstChannel *channel ) {
/*
*+
*  Name:
*     astLoadSkyFrame

*  Purpose:
*     Load a SkyFrame.

*  Type:
*     Protected function.

*  Synopsis:
*     #include "skyframe.h"
*     AstSkyFrame *astLoadSkyFrame_( void *mem, size_t size, int init,
*                                    AstSkyFrameVtab *vtab, const char *name,
*                                    AstChannel *channel )

*  Class Membership:
*     SkyFrame loader.

*  Description:
*     This function is provided to load a new SkyFrame using data read
*     from a Channel. It first loads the data used by the parent class
*     (which allocates memory if necessary) and then initialises a
*     SkyFrame structure in this memory, using data read from the
*     input Channel.
*
*     If the "init" flag is set, it also initialises the contents of a
*     virtual function table for a SkyFrame at the start of the memory
*     passed via the "vtab" parameter.

*  Parameters:
*     mem
*        A pointer to the memory into which the SkyFrame is to be
*        loaded.  This must be of sufficient size to accommodate the
*        SkyFrame data (sizeof(SkyFrame)) plus any data used by
*        derived classes. If a value of NULL is given, this function
*        will allocate the memory itself using the "size" parameter to
*        determine its size.
*     size
*        The amount of memory used by the SkyFrame (plus derived class
*        data).  This will be used to allocate memory if a value of
*        NULL is given for the "mem" parameter. This value is also
*        stored in the SkyFrame structure, so a valid value must be
*        supplied even if not required for allocating memory.
*
*        If the "vtab" parameter is NULL, the "size" value is ignored
*        and sizeof(AstSkyFrame) is used instead.
*     init
*        A boolean flag indicating if the SkyFrame's virtual function
*        table is to be initialised. If this value is non-zero, the
*        virtual function table will be initialised by this function.
*
*        If the "vtab" parameter is NULL, the "init" value is ignored
*        and the (static) virtual function table initialisation flag
*        for the SkyFrame class is used instead.
*     vtab
*        Pointer to the start of the virtual function table to be
*        associated with the new SkyFrame. If this is NULL, a pointer
*        to the (static) virtual function table for the SkyFrame class
*        is used instead.
*     name
*        Pointer to a constant null-terminated character string which
*        contains the name of the class to which the new object
*        belongs (it is this pointer value that will subsequently be
*        returned by the astGetClass method).
*
*        If the "vtab" parameter is NULL, the "name" value is ignored
*        and a pointer to the string "SkyFrame" is used instead.

*  Returned Value:
*     A pointer to the new SkyFrame.

*  Notes:
*     - A null pointer will be returned if this function is invoked
*     with the global error status set, or if it should fail for any
*     reason.
*-
*/

/* Local Variables: */
   AstSkyFrame *new;             /* Pointer to the new SkyFrame */
   char *sval;                   /* Pointer to string value */

/* Initialise. */
   new = NULL;

/* Check the global error status. */
   if ( !astOK ) return new;

/* If a NULL virtual function table has been supplied, then this is
   the first loader to be invoked for this SkyFrame. In this case the
   SkyFrame belongs to this class, so supply appropriate values to be
   passed to the parent class loader (and its parent, etc.). */
   if ( !vtab ) {
      size = sizeof( AstSkyFrame );
      init = !class_init;
      vtab = &class_vtab;
      name = "SkyFrame";
   }

/* Invoke the parent class loader to load data for all the ancestral
   classes of the current one, returning a pointer to the resulting
   partly-built SkyFrame. */
   new = astLoadFrame( mem, size, init, (AstFrameVtab *) vtab, name,
                       channel );

/* If required, initialise the part of the virtual function table used
   by this class. */
   if ( init ) InitVtab( vtab );

/* Note if we have successfully initialised the (static) virtual
   function table owned by this class (so that this is done only
   once). */
   if ( astOK ) {
      if ( ( vtab == &class_vtab ) && init ) class_init = 1;

/* Read input data. */
/* ================ */
/* Request the input Channel to read all the input data appropriate to
   this class into the internal "values list". */
      astReadClassData( channel, "SkyFrame" );

/* Now read each individual data item from this list and use it to
   initialise the appropriate instance variable(s) for this class. */

/* In the case of attributes, we first read the "raw" input value,
   supplying the "unset" value as the default. If a "set" value is
   obtained, we then use the appropriate (private) Set... member
   function to validate and set the value properly. */

/* System. */
/* ------- */
/* Set the default and read the external representation as a string. */
   new->system = AST__NOSKYSYSTEM;
   sval = astReadString( channel, "system", NULL );

/* If a value was read, convert from a string to a System code. */
   if ( sval ) {
      if ( astOK ) {
         new->system = SystemCode( sval );

/* Report an error if the value wasn't recognised. */
         if ( new->system == AST__NOSKYSYSTEM ) {
            astError( AST__ATTIN,
                      "astRead(%s): Invalid sky coordinate system description "
                      "\"%s\".", astGetClass( channel ), sval );
         }
      }

/* Free the string value. */
      sval = astFree( sval );
   }

/* Projection. */
/* ----------- */
   new->projection = astReadString( channel, "proj", NULL );

/* Epoch. */
/* ------ */
/* Interpret this as Besselian or Julian depending on its value. */
   new->epoch = astReadDouble( channel, "epoch", AST__BAD );
   if ( TestEpoch( new ) ) {
      SetEpoch( new, ( new->epoch < 1984.0 ) ? slaEpb2d( new->epoch ) :
                                               slaEpj2d( new->epoch ) );
   }

/* Equinox. */
/* -------- */
/* Interpret this as Besselian or Julian depending on its value. */
   new->equinox = astReadDouble( channel, "eqnox", AST__BAD );
   if ( TestEquinox( new ) ) {
      SetEquinox( new, ( new->equinox < 1984.0 ) ? slaEpb2d( new->equinox ) :
                                                   slaEpj2d( new->equinox ) );
   }

/* MatchEnd. */
/* --------- */
   new->neglon = astReadInt( channel, "neglon", -INT_MAX );
   if ( TestNegLon( new ) ) SetNegLon( new, new->neglon );

/* If an error occurred, clean up by deleting the new SkyFrame. */
      if ( !astOK ) new = astDelete( new );
   }

/* Return the new SkyFrame pointer. */
   return new;
}

/* Virtual function interfaces. */
/* ============================ */
/* These provide the external interface to the virtual functions defined by
   this class. Each simply checks the global error status and then locates and
   executes the appropriate member function, using the function pointer stored
   in the object's virtual function table (this pointer is located using the
   astMEMBER macro defined in "object.h").

   Note that the member function may not be the one defined here, as it may
   have been over-ridden by a derived class. However, it should still have the
   same interface. */
void astClearAsTime_( AstSkyFrame *this, int axis ) {
   if ( !astOK ) return;
   (**astMEMBER(this,SkyFrame,ClearAsTime))( this, axis );
}
int astGetAsTime_( AstSkyFrame *this, int axis ) {
   if ( !astOK ) return 0;
   return (**astMEMBER(this,SkyFrame,GetAsTime))( this, axis );
}
void astSetAsTime_( AstSkyFrame *this, int axis, int value ) {
   if ( !astOK ) return;
   (**astMEMBER(this,SkyFrame,SetAsTime))( this, axis, value );
}
int astTestAsTime_( AstSkyFrame *this, int axis ) {
   if ( !astOK ) return 0;
   return (**astMEMBER(this,SkyFrame,TestAsTime))( this, axis );
}
int astGetLatAxis_( AstSkyFrame *this ) { 
   if ( !astOK ) return 1; 
   return (**astMEMBER(this,SkyFrame,GetLatAxis))( this ); 
}
int astGetLonAxis_( AstSkyFrame *this ) { 
   if ( !astOK ) return 0; 
   return (**astMEMBER(this,SkyFrame,GetLonAxis))( this ); 
}

/* Special public interface functions. */
/* =================================== */
/* These provide the public interface to certain special functions
   whose public interface cannot be handled using macros (such as
   astINVOKE) alone. In general, they are named after the
   corresponding protected version of the function, but with "Id"
   appended to the name. */

/* Public Interface Function Prototypes. */
/* ------------------------------------- */
/* The following functions have public prototypes only (i.e. no
   protected prototypes), so we must provide local prototypes for use
   within this module. */
AstSkyFrame *astSkyFrameId_( const char *, ... );

/* Special interface function implementations. */
/* ------------------------------------------- */
AstSkyFrame *astSkyFrameId_( const char *options, ... ) {
/*
*++
*  Name:
c     astSkyFrame
f     AST_SKYFRAME

*  Purpose:
*     Create a SkyFrame.

*  Type:
*     Public function.

*  Synopsis:
c     #include "skyframe.h"
c     AstSkyFrame *astSkyFrame( const char *options, ... )
f     RESULT = AST_SKYFRAME( OPTIONS, STATUS )

*  Class Membership:
*     SkyFrame constructor.

*  Description:
*     This function creates a new SkyFrame and optionally initialises
*     its attributes.
*
*     A SkyFrame is a specialised form of Frame which describes
*     celestial longitude/latitude coordinate systems. The particular
*     celestial coordinate system to be represented is specified by
*     setting the SkyFrame's System attribute (currently, the default
*     is FK5) qualified, as necessary, by a mean Equinox value and/or
*     an Epoch.
*
*     All the coordinate values used by a SkyFrame are in
*     radians. These may be formatted in more conventional ways for
c     display by using astFormat.
f     display by using AST_FORMAT.

*  Parameters:
c     options
f     OPTIONS = CHARACTER * ( * ) (Given)
c        Pointer to a null-terminated string containing an optional
c        comma-separated list of attribute assignments to be used for
c        initialising the new SkyFrame. The syntax used is identical to
c        that for the astSet function and may include "printf" format
c        specifiers identified by "%" symbols in the normal way.
c        If no initialisation is required, a zero-length string may be
c        supplied.
f        A character string containing an optional comma-separated
f        list of attribute assignments to be used for initialising the
f        new SkyFrame. The syntax used is identical to that for the
f        AST_SET routine. If no initialisation is required, a blank
f        value may be supplied.
c     ...
c        If the "options" string contains "%" format specifiers, then
c        an optional list of additional arguments may follow it in
c        order to supply values to be substituted for these
c        specifiers. The rules for supplying these are identical to
c        those for the astSet function (and for the C "printf"
c        function).
f     STATUS = INTEGER (Given and Returned)
f        The global status.

*  Returned Value:
c     astSkyFrame()
f     AST_SKYFRAME = INTEGER
*        A pointer to the new SkyFrame.

*  Examples:
c     frame = astSkyFrame( "" );
c        Creates a SkyFrame to describe the default FK5 celestial
c        coordinate system, with the standard (default) mean Equinox of
c        J2000.0.
c     frame = astSkyFrame( "Equinox = J2005, Digits = 10" );
c        Creates a SkyFrame to describe the default FK5 celestial
c        coordinate system, but this time with a mean Equinox of J2005.0.
c        Because especially accurate coordinates will be used,
c        additional precision (10 digits) has been requested. This will
c        be used when coordinate values are formatted for display.
c     frame = astSkyFrame( "System = FK4, Equinox = 1955-sep-2" );
c        Creates a SkyFrame to describe the old FK4 celestial
c        coordinate system.  A default Epoch value (B1950.0) is used,
c        but the mean Equinox value is given explicitly as "1955-sep-2".
c     frame = astSkyFrame( "System = GAPPT, Epoch = %s", date );
c        Creates a SkyFrame to describe the Geocentric Apparent
c        celestial coordinate system. The Epoch value, which specifies
c        the date of observation, is obtained from a date/time string
c        supplied via the string pointer "date".
f     FRAME = AST_SKYFRAME( ' ', STATUS )
f        Creates a SkyFrame to describe the default FK5 celestial
f        coordinate system, with the standard (default) mean Equinox of
f        J2000.0.
f     FRAME = AST_SKYFRAME( 'Equinox = J2005, Digits = 10', STATUS )
f        Creates a SkyFrame to describe the default FK5 celestial
f        coordinate system, but this time with a mean Equinox of J2005.0.
f        Because especially accurate coordinates will be used,
f        additional precision (10 digits) has been requested. This will
f        be used when coordinate values are formatted for display.
f     FRAME = AST_SKYFRAME( 'System = FK4, Equinox = 1955-SEP-2', STATUS )
f        Creates a SkyFrame to describe the old FK4 celestial
f        coordinate system.  A default Epoch value (B1950.0) is used,
f        but the mean Equinox value is given explicitly as "1955-SEP-2".
f     FRAME = AST_SKYFRAME( 'System = GAPPT, Epoch = ' // DATE, STATUS )
f        Creates a SkyFrame to describe the Geocentric Apparent
f        celestial coordinate system. The Epoch value, which specifies
f        the date of observation, is obtained from a date/time string
f        contained in the character variable DATE.

*  Notes:
*     - Currently, the default celestial coordinate system is
*     FK5. However, this default may change in future as new
*     astrometric standards evolve. The intention is to track the most
*     modern appropriate standard. For this reason, you should use the
*     default only if this is what you intend (and can tolerate any
*     associated slight change in behaviour with future versions of
*     this function). If you intend to use the FK5 system
*     indefinitely, then you should specify it explicitly using an
c     "options" value of "System=FK5".
f     OPTIONS value of "System=FK5".
*     - Whichever celestial coordinate system is represented, it will
*     have two axes.  The first of these will be the longitude axis
*     and the second will be the latitude axis. This order can be
c     changed using astPermAxes if required.
f     changed using AST_PERMAXES if required.
*     - When conversion between two SkyFrames is requested (as when
c     supplying SkyFrames to astConvert),
f     supplying SkyFrames AST_CONVERT),
*     account will be taken of the nature of the celestial coordinate
*     systems they represent, together with any qualifying mean Equinox or
*     Epoch values, etc. The results will therefore fully reflect the
*     relationship between positions on the sky measured in the two
*     systems.
*     - A null Object pointer (AST__NULL) will be returned if this
c     function is invoked with the AST error status set, or if it
f     function is invoked with STATUS set to an error value, or if it
*     should fail for any reason.
*--

*  Implementation Notes:
*     - This function implements the external (public) interface to
*     the astSkyFrame constructor function. It returns an ID value
*     (instead of a true C pointer) to external users, and must be
*     provided because astSkyFrame_ has a variable argument list which
*     cannot be encapsulated in a macro (where this conversion would
*     otherwise occur).
*     - The variable argument list also prevents this function from
*     invoking astSkyFrame_ directly, so it must be a
*     re-implementation of it in all respects, except for the final
*     conversion of the result to an ID value.
*/

/* Local Variables: */
   AstSkyFrame *new;             /* Pointer to new SkyFrame */
   va_list args;                 /* Variable argument list */

/* Check the global status. */
   if ( !astOK ) return NULL;

/* Initialise the SkyFrame, allocating memory and initialising the virtual
   function table as well if necessary. */
   new = astInitSkyFrame( NULL, sizeof( AstSkyFrame ), !class_init, &class_vtab,
                          "SkyFrame" );

/* If successful, note that the virtual function table has been initialised. */
   if ( astOK ) {
      class_init = 1;

/* Obtain the variable argument list and pass it along with the options string
   to the astVSet method to initialise the new SkyFrame's attributes. */
      va_start( args, options );
      astVSet( new, options, args );
      va_end( args );

/* If an error occurred, clean up by deleting the new object. */
      if ( !astOK ) new = astDelete( new );
   }

/* Return an ID value for the new SkyFrame. */
   return astMakeId( new );
}
