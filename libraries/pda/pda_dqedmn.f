      SUBROUTINE PDA_DQEDMN(PDA_DQEDEV,MEQUA,NVARS,MCON,IND,BL,BU,X,
     .                      FJAC,LDFJAC, FB,IGO,IOPT,ROPT,IWA,WA,DX,XB,
     .                      B,BB,BLB,BUB,INDB,NPMAX,ZP,XP,QC,MDQC,PJ,WJ,
     .                      LDWJ,GR,DXL)
C***BEGIN PROLOGUE  DQEDMN
C***REFER TO  DQED
C***ROUTINES CALLED  DGECO,DGESL,PDA_IDAMAX,DNRM2,PDA_I1MACH,
C                    DQEDEV,DQEDGN,D1MACH,DAXPY,DSCAL,DCOPY,
C                    DVOUT,PDA_DDOT,CHRCNT,XERRWV
C***END PROLOGUE  DQEDMN
C     REVISED 861216-1100
C     REVISED YYMMDD-HHMM
      EXTERNAL PDA_DQEDEV
      DOUBLE PRECISION BL(*),BU(*),X(*),FJAC(LDFJAC,*)
      DOUBLE PRECISION DX(*),XB(*),B(*),BB(*)
      DOUBLE PRECISION BLB(*),BUB(*),ROPT(*),WA(*),PJ(*)
      DOUBLE PRECISION WJ(LDWJ,*),GR(*),DXL(*)
C     ARRAYS TO HOLD VALUES FOR 2-ND ORDER TERMS .
      DOUBLE PRECISION ZP(MEQUA,NPMAX),XP(NVARS,NPMAX),QC(MDQC,NPMAX)
C     SCALARS:
      DOUBLE PRECISION AJN,ALB,ALFAC,ALPHA,AUB,BBOOST,BOLD,CHG
      DOUBLE PRECISION CHGFAC,COLNRM,COND,COSL,COSM,COSQ,DFN,DXNRM
      DOUBLE PRECISION C1516,FB,FC,FL,PV,PVL,RC,RG,RB,PB,PD
      DOUBLE PRECISION RCOND,SEMIBG,T,TOLD,TOLF,TOLP,TOLSNR,TOLUSE
      DOUBLE PRECISION TOLX,TT,TWO,T2,ZERO,ONE,ZN,SS,SC
      DOUBLE PRECISION PDA_D1MACH,PDA_DDOT,PDA_DNRM2
      INTEGER IND(*),INDB(*),IOPT(*),IWA(*)
      LOGICAL RETREA,TERM,FULNWT,USEQ,NEWBST,PASSB,NOQUAD,NEWOPT
      LOGICAL LINMOD,REVERS,USEQL,MUSTCN,JACTRI
      INTEGER PDA_IDAMAX, PDA_I1MACH
      EXTERNAL PDA_I1MACH, PDA_IDAMAX, PDA_D1MACH, PDA_DDOT, PDA_DNRM2
      CHARACTER XMESS*128
      DATA IFLAG/0/
C--PROCEDURES--
C -NAME------TYPE--------ARGS------CLASS-----
C
C  DGECO                    6      SUBROUTINE
C  DGESL                    6      SUBROUTINE
C  PDA_IDAMAX    INTEGER        3      FUNCTION
C  PDA_DNRM2     REAL           3      FUNCTION
C  DQEDEV                   6      DUMMY-SUBR
C  DQEDGN                  15      SUBROUTINE
C  PDA_I1MACH    INTEGER        1      FUNCTION
C  PDA_D1MACH    REAL           1      FUNCTION
C  DAXPY                    6      SUBROUTINE
C  DSCAL                    4      SUBROUTINE
C  DCOPY                    5      SUBROUTINE
C  SVOUT                    4      SUBROUTINE
C  PDA_DDOT      REAL           5      FUNCTION
C  CHRCNT                   2      SUBROUTINE
C  XERRWV                  10      SUBROUTINE
C DQEDMN:
C GLOSSARY OF VARIABLES. NOTATION:
C DUMMY-ARG A DUMMY ARGUMENT, THAT IS AN ARGUMENT TO THIS PROG. UNIT.
C /S$A$V$E/ SAV DENOTES THAT THIS VARIABLE IS LOCAL TO THE ROUTINE
C               AND IS SAVED BETWEEN CALLS TO IT.
C INTEGER, REAL, DOUBLE PRECISION, LOGICAL, CHARACTER
C               THE TYPES OF THE VARIABLES.
C ADJ-ARR AN ADJUSTABLE ARRAY, THAT IS AN ARGUMENT TO THIS PROG. UNIT.
C NAME      MEMORY STATUS  TYPE     ARGUMENT   USES AND COMMENTS.
C                                    STATUS
C ----      -------------  ----     --------   ------------------
C AJN        /S$A$V$E/ SAV REAL              NORM GRAD VECTOR
C ALB        /S$A$V$E/ SAV REAL              TEMP BOUND VALUE
C ALFAC      /S$A$V$E/ SAV REAL              TRUST REGION FACTOR
C ALPHA      /S$A$V$E/ SAV REAL              TRUST REGION FACTOR
C AUB        /S$A$V$E/ SAV REAL              TEMP BOUND VALUE
C B          DUMMY-ARG     REAL      ADJ-ARY CURRENT TRUST BOUNDS
C BB         DUMMY-ARG     REAL      ADJ-ARY TRUST BOUNDS AT BEST
C BBOOST     /S$A$V$E/ SAV REAL              FACTOR TO BOOST BOUNDS
C BL         DUMMY-ARG     REAL      ADJ-ARY USER LOWER BOUNDS
C BLB        DUMMY-ARG     REAL      ADJ-ARY MODEL LOWER BOUNDS
C BOLD       /S$A$V$E/ SAV REAL              TEMP LAST BOUND VALUE
C BU         DUMMY-ARG     REAL      ADJ-ARY USER UPPER BOUNDS
C BUB        DUMMY-ARG     REAL      ADJ-ARY MODEL UPPER BOUNDS
C CHG        /S$A$V$E/ SAV REAL              TRUST REGION FACTOR
C CHGFAC     /S$A$V$E/ SAV REAL              TRUST REGION FACTOR
C COLNRM     /S$A$V$E/ SAV REAL              TEMP JACOBIAN COL NORM
C COND       /S$A$V$E/ SAV REAL              MAX COND NUMBER, QUAD TERM
C COSL       /S$A$V$E/ SAV REAL              COSINE, GRAD AND LIN STEP
C COSM       /S$A$V$E/ SAV REAL              COSINE, LIN AND QUAD STEP
C COSQ       /S$A$V$E/ SAV REAL              COSINE, GRAD AND QUAD STEP
C C1516      /S$A$V$E/ SAV REAL              THE CONSTANT 15/16
C DFN        /S$A$V$E/ SAV REAL              NORM J*DX/NORM DEL F
C DX         DUMMY-ARG     REAL      ADJ-ARY THE CHANGE, X=X-DX
C DXL        DUMMY-ARG     REAL      ADJ-ARY A CANDIDATE DX, LIN MODEL
C DXNRM      /S$A$V$E/ SAV REAL              NORM OF DX
C FB         DUMMY-ARG     REAL              NORM AT THE BEST X
C FC         /S$A$V$E/ SAV REAL              NORM AT THE CURRENT X
C FJAC       DUMMY-ARG     REAL      ADJ-ARY JACOBIAN ARRAY
C FL         /S$A$V$E/ SAV REAL              NORM AT THE LAST X
C FULNWT     /S$A$V$E/ SAV LOGICAL           FLAG, TOOK FULL STEP
C GR         DUMMY-ARG     REAL      ADJ-ARY GRADIENT VECTOR
C I          /S$A$V$E/ SAV INTEGER           DUMMY LOOP VARIABLE
C ICASE      /S$A$V$E/ SAV INTEGER           GATE VARIABLE
C IFLAG      /S$A$V$E/ SAV INTEGER           INTERNAL FIRST TIME FLAG
C IGO        DUMMY-ARG     INTEGER           DIRECT USER, PROGRAM ACTION
C NERR       /S$A$V$E/ SAV INTEGER           ERROR PROCESSOR NUMBER
C NEWBST     /S$A$V$E/ SAV LOGICAL           FLAG, GOT A NEW BEST
C NEWOPT     /S$A$V$E/ SAV LOGICAL           FLAG, SET AN OPTION
C NIT        /S$A$V$E/ SAV INTEGER           ITERS, QUAD MODEL SOLVING
C NMESS      /S$A$V$E/ SAV INTEGER           LENGTH OF ERROR MESSAGE
C NOQUAD     /S$A$V$E/ SAV LOGICAL           FLAG, SUPPRESS QUAD MODEL
C NOUT       /S$A$V$E/ SAV INTEGER           UNIT NUMBER, SAMPLE OUTPUT
C NP         /S$A$V$E/ SAV INTEGER           POTENTIAL QUAD TERMS + 1
C NPMAX      DUMMY-ARG     INTEGER           MAX NUMBER QUAD TERMS
C NT         /S$A$V$E/ SAV INTEGER           MIN(NVARS+1,MEQUA-1)
C NTTERM     /S$A$V$E/ SAV INTEGER           NUMBER QUAD TERMS USED
C NV         /S$A$V$E/ SAV INTEGER           NUMBER OF VARIABLES, MODEL
C NVARS      DUMMY-ARG     INTEGER           NUMBER OF USER VARIABLES
C ONE        /S$A$V$E/ SAV REAL              THE NUMBER 1.
C PASSB      /S$A$V$E/ SAV LOGICAL           FLAG, USER GAVE TRUST BNDS
C PB         /S$A$V$E/ SAV REAL              PREDICTED RESIDUAL, AT BEST
C PD         /S$A$V$E/ SAV REAL              1.5(FB+PB(PB/FB)) - 4PB
C PJ         DUMMY-ARG     REAL      ADJ-ARY J**T*F AND J*DX AT X
C PV         /S$A$V$E/ SAV REAL              PREDICTED RESIDUAL, CURRENT
C PVL        /S$A$V$E/ SAV REAL              PREDICTED RESIDUAL, LIN MOD
C QC         DUMMY-ARG     REAL      ADJ-ARY QUAD MODEL COEFFICIENTS
C RB         /S$A$V$E/ SAV REAL              ALPHA AFTER NOT A BEST
C RC         /S$A$V$E/ SAV REAL              RETREAT COEFFICIENT
C RCOND      /S$A$V$E/ SAV REAL              RECIPROCAL, QUAD TERM COEFF
C RDUM       /S$A$V$E/ SAV REAL              DUMMY VARIABLE, ERROR PROC
C RETREA     /S$A$V$E/ SAV LOGICAL           FLAG, WILL RETREAT
C REVERS     /S$A$V$E/ SAV LOGICAL           FLAG, REVERSE COMMUNICATION
C IGOELM     /S$A$V$E/ SAV INTEGER           BACK FROM LIN MOD EVALUATE
C IGOEQM     /S$A$V$E/ SAV INTEGER           BACK FROM QUAD MOD EVALUATE
C IGOTFC     /S$A$V$E/ SAV INTEGER           BACK FROM TEST FOR CONVERGE
C IGOW       /S$A$V$E/ SAV INTEGER           DIRECT, SOLVE QUAD MODEL
C IND        DUMMY-ARG     INTEGER   ADJ-ARY USER BOUND INDICATORS
C INDB       DUMMY-ARG     INTEGER   ADJ-ARY INTERNAL BOUND INDICATORS
C IOPT       DUMMY-ARG     INTEGER   ADJ-ARY USER OPTION ARRAY
C IPLS       /S$A$V$E/ SAV INTEGER
C IPRINT     /S$A$V$E/ SAV INTEGER           WANT OUTPUT IF .GT. 0
C ITERS      /S$A$V$E/ SAV INTEGER           NUMBER OF ITERATIONS
C ITMAX      /S$A$V$E/ SAV INTEGER           MAX NUMBER OF ITERATIONS
C IWA        DUMMY-ARG     INTEGER   ADJ-ARY WORKING ARRAY
C J          /S$A$V$E/ SAV INTEGER           DUMMY LOOP VARIABLE
C JACTRI     /S$A$V$E/ SAV LOGICAL           FLAG, JACOBIAN IS TRIANGLE
C JK         /S$A$V$E/ SAV INTEGER           TEMP LOOP VARIABLE
C JP         /S$A$V$E/ SAV INTEGER           OPTION ARRAY POINTER
C K          /S$A$V$E/ SAV INTEGER           DUMMY LOOP VARIABLE
C KL         /S$A$V$E/ SAV INTEGER           DIRECT STATE OF DQED
C KP         /S$A$V$E/ SAV INTEGER           OPTION ARRAY POINTER
C L          /S$A$V$E/ SAV INTEGER           DUMMY LOOP VARIABLE
C LDFJAC     DUMMY-ARG     INTEGER           ROW DIMENSION OF FJAC
C LDWJ       DUMMY-ARG     INTEGER           ROW DIMENSION OF WJ
C LEVEL      /S$A$V$E/ SAV INTEGER           ERROR PROC RESPONSE LEVEL
C LINMOD     /S$A$V$E/ SAV LOGICAL           FLAG, SOLVING LINEAR PROBLEM
C LK         /S$A$V$E/ SAV INTEGER           MIN(MEQUA,NVARS+1)
C LP         /S$A$V$E/ SAV INTEGER           OPTION ARRAY POINTER
C LPDIFF     /S$A$V$E/ SAV INTEGER           OPTION ARRAY INCREMENT
C MCON       DUMMY-ARG     INTEGER           NUMBER, LINEAR CONSTRAINTS
C MCONST     /S$A$V$E/ SAV INTEGER           NUMBER, MODEL CONSTRAINTS
C MDQC       DUMMY-ARG     INTEGER           ROW DIM OF QC(,)
C ME         /S$A$V$E/ SAV INTEGER           NUMBER, MODEL EQUATIONS
C MEQUA      DUMMY-ARG     INTEGER           NUMBER, USER EQUATIONS
C MK         /S$A$V$E/ SAV INTEGER           0 OR MIN(MEQUA,NVARS+NP+1)
C MUSTCN     /S$A$V$E/ SAV LOGICAL           FLAG, MUST TAKE FULL STEP
C NALL       /S$A$V$E/ SAV INTEGER           MCON+NVARS
C RG         /S$A$V$E/ SAV REAL              RETREAT GAUGE
C ROPT       DUMMY-ARG     REAL      ADJ-ARY USER PASSED OPTION DATA
C SEMIBG     /S$A$V$E/ SAV REAL              CONSTANT 1.D+10
C T          /S$A$V$E/ SAV REAL              TEMP VARIABLE
C TERM       /S$A$V$E/ SAV LOGICAL           FLAG, STOP THIS PROBLEM
C TOLD       /S$A$V$E/ SAV REAL              REL TOLERANCE ON CHANGE
C TOLF       /S$A$V$E/ SAV REAL              TOLERANCE ON FUNCTION
C TOLP       /S$A$V$E/ SAV REAL              TOLERANCE FOR MIN FLAG
C TOLSNR     /S$A$V$E/ SAV REAL              TOLERANCE FOR MIN FLAG
C TOLUSE     /S$A$V$E/ SAV REAL              TOLERANCE FOR QUAD MODEL
C TOLX       /S$A$V$E/ SAV REAL              ABS TOLERANCE ON CHANGE
C TT         /S$A$V$E/ SAV REAL              TEMP VARIABLE
C TWO        /S$A$V$E/ SAV REAL              CONSTANT 2.
C T2         /S$A$V$E/ SAV REAL              REL STEP WITHIN TRUST REG
C USEQ       /S$A$V$E/ SAV LOGICAL           USE QUAD MODEL THIS STEP
C USEQL      /S$A$V$E/ SAV LOGICAL           USED QUAD MODEL LAST STEP
C UT         DUMMY-ARG     REAL      ADJ-ARY WORKING ARRAY
C WA         DUMMY-ARG     REAL      ADJ-ARY WORKING ARRAY
C WJ         DUMMY-ARG     REAL      ADJ-ARY MODEL JACOBIAN ARRAY
C X          DUMMY-ARG     REAL      ADJ-ARY SOLUTION ARRAY
C XB         DUMMY-ARG     REAL      ADJ-ARY BEST VALUES OF X
C XMESS      /S$A$V$E/ SAV CHAR*128          TEMP FOR ERROR MESSAGE
C XP         DUMMY-ARG     REAL      ADJ-ARY WORKING ARRAY
C ZERO       /S$A$V$E/ SAV REAL              CONSTANT 0.
C ZN         /S$A$V$E/ SAV REAL              NORM J*DX/NORM DF
C ZP         DUMMY-ARG     REAL      ADJ-ARY WORKING ARRAY
C
      IF (IFLAG.NE.0) GO TO 50
*
      LK = MIN(MEQUA,NVARS+1)
      NT = MIN(NVARS+1,MEQUA-1)
      ZERO = 0.D0
      ONE = 1.D0
      TWO = 2.D0
C     DO(PROCESS OPTION ARRAY)
      GO TO 1100
*
   10 CONTINUE
C     DO(INITIALIZE OTHER VALUES)
      GO TO 1030
*
   20 CONTINUE
C     SET SO X(*)-DX(*) UPDATE WILL BE CORRECT FIRST TIME.
      DX(1) = ZERO
      CALL PDA_DCOPY(NVARS,DX,0,DX,1)
      K = 0
C     PDA_D1MACH(2)="INFINITY" ON THIS MACHINE.
      FB = PDA_D1MACH(2)
      DXNRM = FB
      FL = ZERO
C
C     MODEL PROBLEM RESIDUAL.
      PV = ZERO
      PVL = ZERO
      RETREA = .FALSE.
      FULNWT = .FALSE.
      TERM = .FALSE.
C     DO FOREVER
   30 CONTINUE
      ITERS = ITERS + 1
      IF (RETREA) THEN
C     MUST RETREAT TO BEST X VALUES.
          CALL PDA_DCOPY(NVARS,XB,1,X,1)
          K = 0
          KL = -1
          FL = FB
*
      ELSE
          KL = K
          DO 40 J = 1,NVARS
             X(J) = X(J) - DX(J)
   40     CONTINUE
      END IF
*
      IF (TERM) THEN
          IFLAG = 0
C     EXIT FOREVER
          GO TO 840
*
      END IF
*
      IFLAG = 1
      IGO = 1
      IF (NP.EQ.NPMAX-1 .AND. NP.LT.NVARS) IGO = -1
      IF (REVERS) THEN
C     THERE ARE TWO POSSIBLE WAYS TO GET FUNCTION AND DERIVATIVE
C     VALUES FROM THE USER.  THE OPTIONAL WAY IS REVERSE COMMUNICATION.
C     DO(RETURN TO USER PROGRAM UNIT)
          GO TO 1020
*
      ELSE
C     THE NOMINAL WAY IS THROUGH FORWARD COMMUNICATION.
          CALL PDA_DQEDEV(X,FJAC,LDFJAC,IGO,IOPT,ROPT)
      END IF
*
   50 CONTINUE
C     IF IGO HAS BEEN CHANGED BY THE USER TO A VALUE .GT. 1, THEN
C     THIS IS AN ABORT SIGNAL.  STOP UNLESS IT = 99.
      IF (IGO.EQ.99) THEN
C     IF IGO = 99 THE EVALUATION CAN'T BE PERFORMED.
C     WE FORCE A RETREAT AND RESTART IN THIS CASE.
          DO 70 I = MCON + 1, MCON + MEQUA
             FJAC(I,NVARS+1) = FC
             DO 60 J = 1,NVARS
                FJAC(I,J) = ZERO
   60        CONTINUE
   70     CONTINUE
C     A RETREAT IS FORCED TO OCCUR WITH THIS ASSIGNMENT.
          RETREA = .TRUE.
*
          END IF
*
          FC = PDA_DNRM2(MEQUA,FJAC(MCON+1,NVARS+1),1)
*
      IF (IGO.GT.1 .AND. IGO.NE.99) THEN
          IFLAG = 0
          CALL PDA_DCOPY(NVARS,XB,1,X,1)
C     DO(RETURN TO USER PROGRAM UNIT)
          GO TO 1020
*
      END IF
C     SAVE PAST FUNCTION AND VARIABLE VALUES.
C     DO NOT UPDATE THE PAST POINTS UNLESS THERE IS A
C     SIGNIFICANT CHANGE IN THE X(*) VALUES.
      IF (NP.GE.0) THEN
          IF (DXNRM.GT.TOLUSE*PDA_DNRM2(NVARS,X,1)) THEN
              LP = NVARS
              IF ( .NOT. NOQUAD) NP = MIN(NP,NPMAX-1,LP) + 1
              DO 150 J = NP - 1,1,-1
C     SAVE THE PAST VALUES OF THE VARIABLES.
C     DIFFERENCES ARE LATER COMPUTED USING THESE VALUES.
                 CALL PDA_DCOPY(NVARS,XP(1,J),1,XP(1,J+1),1)
C     SAVE THE PAST FUNCTION VALUES IN ZP( , ).
C     DIFFERENCES ARE LATER COMPUTED USING THESE VALUES.
                 CALL PDA_DCOPY(MEQUA,ZP(1,J),1,ZP(1,J+1),1)
  150         CONTINUE
          END IF
*
      END IF
C     PUT IN THE PRESENT VALUES OF THE VARIABLES.
      CALL PDA_DCOPY(NVARS,X,1,XP(1,1),1)
C     PUT IN THE PRESENT VALUES OF THE FUNCTIONS.
      CALL PDA_DCOPY(MEQUA,FJAC(MCON+1,NVARS+1),1,ZP(1,1),1)
C     THIS STATEMENT HAS THE EFFECT OF A FIRST TIME FLAG.
      NP = MAX(NP,0)
C     COMPUTE THE COSINES OF THE PAST MOVES WITH THE MOST CURRENT MOVE.
      DO 170 L = 2,NP
         DO 160 J = 1,NVARS
            QC(J,L) = XP(J,L) - XP(J,1)
  160    CONTINUE
  170 CONTINUE
      L = 3
  180 CONTINUE
C     DO WHILE(L.LE.NP)
      IF ( .NOT. (L.LE.NP)) GO TO 200
C     CALCULATE THE DIRECTION COSINES OF THE PAST MOVES.
      T = PDA_DDOT(NVARS,QC(1,2),1,QC(1,L),1)
      TT = PDA_DNRM2(NVARS,QC(1,2),1)*PDA_DNRM2(NVARS,QC(1,L),1)
      IF (TT.GT.ZERO) THEN
          T = T/TT
*
      ELSE
          T = ONE
      END IF
*
      IF (IPRINT.GT.0) THEN
          WRITE (NOUT,
     .      '('' PAST MOVE NUMBER, COSINE OF MOVE'',I3,2X,F6.2)') L - 2,
     .      T
      END IF
*
      IF(ABS(T) .GT. .98) THEN
C     DISCARD PAST INFORMATION ASSOCIATED WITH THIS MOVE IF CLOSE TO
C     A PAST MOVE.
          DO 190 J = L,NP - 1
             CALL PDA_DCOPY(MEQUA,ZP(1,J+1),1,ZP(1,J),1)
             CALL PDA_DCOPY(NVARS,XP(1,J+1),1,XP(1,J),1)
             CALL PDA_DCOPY(NVARS,QC(1,J+1),1,QC(1,J),1)
  190     CONTINUE
          NP = NP - 1
C     CYCLE WHILE
          GO TO 180
*
      END IF
*
      L = L + 1
C     END WHILE
      GO TO 180
*
  200 CONTINUE
C     COMPUTE FUNCTION DIFFERENCES IN QC( , ).
      DO 220 J = 1,NP - 1
         DO 210 I = 1,MEQUA
            QC(I,J+1) = ZP(I,J+1) - ZP(I,1)
  210    CONTINUE
  220 CONTINUE
C     NOW HAVE F(PAST)-F(CURRENT) IN QC( , ), COLS. 2,...,NP USED.
C     COMPUTE NORM OF DIFFERENCE OF FUNCTION VALUES.
      IF (NP.GT.1) THEN
          DFN = PDA_DNRM2(MEQUA,QC(1,2),1)
*
      ELSE
          DFN = ZERO
      END IF
*
      DO 240 I = 1,NP - 1
         DO 230 J = 1,NVARS
C     NEXT ADD PRODUCT OF JACOBIAN AND PAST VARIABLE DIFFERENCES.
            CALL PDA_DAXPY(MEQUA,- (XP(J,I+1)-XP(J,1)),FJAC(MCON+1,J),1,
     .                 QC(1,I+1),1)
  230    CONTINUE
  240 CONTINUE
C     DO FOREVER
  250 CONTINUE
C     COMPUTE THE SYMMETRIC MATRIX WHOSE ENTRIES ARE THE
C     SQUARES OF THE DOT PRODUCTS OF THE PAST DIRECTIONS.
C     THIS MATRIX IS REQUIRED TO OBTAIN THE QUADRATIC TERMS
C     ASSOCIATED WITH INTERPOLATING TO PAST FUNCTION VALUES.
      DO 280 L = 2,NP
         DO 270 J = L,NP
            T = ZERO
            DO 260 I = 1,NVARS
               T = T + (XP(I,J)-XP(I,1))* (XP(I,L)-XP(I,1))
  260       CONTINUE
            WJ(L-1,J-1) = T
            WJ(J-1,L-1) = T
  270    CONTINUE
  280 CONTINUE
C     COMPUTE NORM OF REMAINDER INCLUDING LINEAR TERMS,
C     USING THE LAST MOVE.
      USEQ = NP .GT. 1 .AND. .NOT. RETREA
      ZN = ONE
      IF (NP.GT.1) THEN
          ZN = PDA_DNRM2(MEQUA,QC(1,2),1)
C     COMPUTE RATIO OF Z TERMS TO CURRENT F VALUE..
          IF (USEQ) USEQ = (ZN .GT.1.D-4*DFN .AND. ZN .LT. DFN*.75D0)
     .              .OR. USEQL
          IF (DFN.GT.ZERO) THEN
              ZN = ZN/DFN
*
          ELSE
              ZN = ONE
          END IF
*
          IF (IPRINT.GT.0) THEN
              CALL PDA_DVOUT(1,ZN,
     .        '('' RATIO OF Z TERM TO PAST DF NORM'')',4)
          END IF
C     SCALE THE MATRIX (MATRIX := D*MATRIX*D, WHERE D**2 = RECIPROCAL
C     OF THE DIAGONAL TERMS OF THE MATRIX.
          DO 290 I = 1,NP - 1
             DXL(I) = WJ(I,I)
             IF (DXL(I).EQ.ZERO) THEN
                 NP = I
                 GO TO 250
*
             ELSE
                 DXL(I) = ONE/DXL(I)
             END IF
*
  290     CONTINUE
          DO 310 I = 1,NP - 1
             DO 300 J = 1,NP - 1
                WJ(I,J) = (WJ(I,J)*DXL(I))* (WJ(I,J)*DXL(J))
  300        CONTINUE
  310     CONTINUE
C     USE THE LINPACK ROUTINES DGECO(), DGESL() TO OBTAIN
C     THE COEFFICIENTS OF THE QUADRATIC TERMS, ONE ROW AT
C     A TIME.
          CALL PDA_DGECO(WJ,LDWJ,NP-1,IWA,RCOND,WA)
          IF (IPRINT.GT.0) WRITE (NOUT,
     .        '('' RCOND FROM DGECO() = '',2X,       1PD15.4)') RCOND
          IF (COND*RCOND.LT.ONE) THEN
              NP = NP - 1
C     CYCLE FOREVER
              GO TO 250
*
          END IF
*
          DO 340 I = 1,MEQUA
C     COPY A ROW OF THE INTERPOLATED DATA TO A WORKING ARRAY.
C     USE THIS ARRAY TO OBTAIN A ROW OF THE QUADRATIC TERMS.
             CALL PDA_DCOPY(NP-1,QC(I,2),MDQC,WA,1)
C     SCALE THE RIGHT HAND SIDE DATA.
             DO 320 J = 1,NP - 1
                WA(J) = WA(J)*DXL(J)
  320        CONTINUE
             CALL PDA_DGESL(WJ,LDWJ,NP-1,IWA,WA,0)
C     RESCALE THE SOLUTION DATA.
             DO 330 J = 1,NP - 1
                WA(J) = WA(J)*DXL(J)
  330        CONTINUE
C     THE FOLLOWING SIGN CHANGE COMES FROM A CHANGE
C     OF SIGN IN THE INNER LOOP MODEL PROBLEM.
             CALL PDA_DSCAL(NP-1,-TWO,WA,1)
             CALL PDA_DCOPY(NP-1,WA,1,QC(I,2),MDQC)
  340     CONTINUE
      END IF
*
  350 CONTINUE
C     EXIT FOREVER
C     END FOREVER
C     NOW HAVE THE QUADRATIC TERMS COMPUTED.
C     NEXT WILL TRIANGULARIZE THE JACOBIAN TO SAVE SPACE
C     WHEN USING THE QUADRATIC MODEL.
      IF (JACTRI) THEN
C     CONSTRUCT AND THEN APPLY PLANE ROTATIONS
C     TO ACHIEVE UPPER TRIANGULAR FORM.  THIS LOOP
C     AFFECTS THE JACOBIAN AND RIGHT HAND SIDE.
          DO 370 J = 1,NT
             DO 360 I = J + 1,MEQUA
                CALL PDA_DROTG(FJAC(MCON+J,J),FJAC(MCON+I,J),SC,SS)
                CALL PDA_DROT(NVARS-J+1,FJAC(MCON+J,J+1),LDFJAC,
     .                              FJAC(MCON+I,J+1),LDFJAC,SC,SS)
C     NOW APPLY THE TRANSFORMATION TO THE QUADRATIC TERMS.
                CALL PDA_DROT(NP-1,QC(J,2),MDQC,
     .                         QC(I,2),MDQC,SC,SS)

                FJAC(MCON+I,J) = ZERO
  360        CONTINUE
  370     CONTINUE
C     NOW WE FINISH TRIANGULARIZING THE QUADRATIC TERMS.
C     NOTE THAT THIS DOES NOT AFFECT THE RIGHT HAND SIDE.
          DO 390 L = 1,NP - 1
             DO 395 I=NVARS+L+2,MEQUA
             CALL PDA_DROTG(QC(NVARS+L+1,L+1),QC(I,L+1),SC,SS)
             CALL PDA_DROT(NP-L-1,QC(NVARS+L+1,MIN(L+2,NPMAX)),MDQC,
     .                        QC(I,MIN(L+2,NPMAX)),MDQC,SC,SS)
             QC(I,L+1) = ZERO
  395 CONTINUE
  390     CONTINUE
      END IF
C     COMPUTE CURRENT NORM OF J**T*F(X).
      DO 400 J = 1,NVARS
         IF (JACTRI) THEN
             JK = J
*
         ELSE
             JK = MEQUA
         END IF
*
         PJ(J) = PDA_DDOT(JK,FJAC(MCON+1,J),1,FJAC(MCON+1,NVARS+1),1)
  400 CONTINUE
      AJN = PDA_DNRM2(NVARS,PJ,1)
C SAVE J**T*F FOR DIRECTION TESTING WITH LINEAR AND QUADRATIC MOVES.
      IF (AJN.GT.ZERO) CALL PDA_DSCAL(NVARS,ONE/AJN,PJ,1)
      CALL PDA_DCOPY(NVARS,PJ,1,GR,1)
      NEWBST = FC .LT. FB
      IF (NEWBST) K = 0
      IF (K.EQ.0) THEN
          PB = ZERO
          PD = PDA_D1MACH(2)
C     WANT TO POSITION AT BEST X VALUES.
          IF ( .NOT. RETREA) THEN
              FB = FC
          END IF
*
          GO TO (410,430,450),2 - KL
*
          GO TO 470
C     CASE 1
  410     CONTINUE
C     IMMEDIATELY GOT A NEW BEST X.
          RG = ZERO
          IF (T2.LE.0.25D0) THEN
              BBOOST = ONE
              CHG = MAX(4.D0*T2,.1D0)
          END IF

          DO 420 J = 1,NVARS
             BB(J) = CHG*BB(J)
  420     CONTINUE
          T = .25D0/ (ALFAC-1.D0)
          ALPHA = (ZN+ALFAC*T)/ (ZN+T)
          ALFAC = 1.5*ALPHA
          BBOOST = MIN(1.5D0*ALPHA*BBOOST,SEMIBG)
          GO TO 490
C     CASE 2
  430     CONTINUE
          USEQL = .FALSE.
          RG = ZERO
C     AT THE INITIAL X.
          ALFAC = 256.D0
          DO 440 J = 1,NVARS
             IF ( .NOT. PASSB) THEN
                 BB(J) = -X(J)
             END IF
*
             IF (BB(J).EQ.ZERO) THEN
                 IF (JACTRI) THEN
                     JK = J
*
                 ELSE
                     JK = MEQUA
                 END IF
*
                 COLNRM = PDA_DNRM2(JK,FJAC(MCON+1,J),1)
                 IF (COLNRM.NE.ZERO) THEN
                     BB(J) = PDA_DDOT(JK,FJAC(MCON+1,J),1,
     .                       FJAC(MCON+1,NVARS+1),1)
                     BB(J) = -MAX(ABS(BB(J))/COLNRM/COLNRM,FC/COLNRM)
*
                 ELSE
                     BB(J) = -ONE
                 END IF
*
             END IF
*
             XB(J) = X(J)
             B(J) = BB(J)
  440     CONTINUE
          ALPHA = ONE
          BBOOST = 0.5D0
C     EXIT IF
          GO TO 520
C     CASE 3
  450     CONTINUE
C     RETREAT TO BEST X.
          IF (ALFAC.NE.256.D0) THEN
              ALPHA = MIN(4.D0/ALFAC,.25D0)
              ALFAC = 1.25D0
*
          ELSE
              ALPHA = .25D0*ALPHA
          END IF
*
          BBOOST = .25D0
          USEQL = .FALSE.
          DO 460 J = 1,NVARS
C
C     THE NEXT LINES HAVE THE EFFECT OF REDUCING THE BOUNDS
C     AT THE CURRENT BEST TO ABOUT 1/16 THEIR CURRENT VALUES
C     PROVIDED THE CURRENT BOUNDS ARE RELATIVELY SMALL.  IF
C     THE CURRENT BOUNDS ARE RELATIVELY LARGE, THE BOUNDS AT
C     THE BEST ARE LEFT ABOUT THE SAME.
             T = ABS(B(J))
             TT = ABS(BB(J))
             T = (T+.25D0*TT)/ (T+4.D0*TT)
             B(J) = T*BB(J)
             BB(J) = B(J)
             DX(J) = ZERO
  460     CONTINUE
C     EXIT IF
          GO TO 520
C     CASE OTHER
  470     CONTINUE
C     NOT IMMEDIATELY A BEST X.
          RB = ZERO
          DO 480 J = 1,NVARS
             RB = .125D0*MAX(RB,ABS((XB(J)-X(J))/BB(J)))
  480     CONTINUE
          ALPHA = RB
          ALFAC = TWO
          BBOOST = (1.D0+RG)/ (.25D0+2.D0*RG)
C     END CASE
  490     CONTINUE
          DO 500 J = 1,NVARS
             DX(J) = XB(J) - X(J)
             IF (DX(J).EQ.ZERO) THEN
                 B(J) = ALPHA*BB(J)
*
             ELSE
                 XB(J) = X(J)
                 B(J) = SIGN(ALPHA*BB(J),DX(J)) + BBOOST*DX(J)
             END IF
*
             BB(J) = SIGN(MIN(SQRT(PDA_D1MACH(2)),ABS(B(J))),B(J))
  500     CONTINUE
*
      ELSE
C     MUST MAKE SURE THAT PD GETS SET TO A REASONABLE VALUE.
C     COMPUTE A GAUGE FOR RETREATING IF DID NOT
C     GET A NEW BEST.
          ALPHA = (.5D0*ZN+1.D0)/ (ZN+1.D0)
          CHG = ALPHA*CHG
          IF (K.EQ.1) THEN
              CHG = MIN(CHG,T2)
              CHG = MAX(CHG,.1D0)
              PB = PV
              PD = 1.5D0* (FB+PB* (PB/FB)) - 4.D0*PB
          END IF
*
          DO 510 J = 1,NVARS
             B(J) = CHG*B(J)
             IF (K.EQ.1) BB(J) = B(J)
  510     CONTINUE
      END IF
*
  520 CONTINUE
C     DO(TEST FOR CONVERGENCE)
      ASSIGN 530 TO IGOTFC
      GO TO 980
*
  530 CONTINUE
      IF (TERM) THEN
          IFLAG = 0
C     EXIT FOREVER
          GO TO 840
*
      END IF
*
      K = K + 1
C     SOLVE MODEL BOUNDED PROBLEM.
      DO 590 J = 1,NVARS
         IF (B(J).LT.ZERO) THEN
             ALB = B(J)
             IF (DX(J).EQ.ZERO) THEN
C     THIS CASE IS REQD. TO AVOID USING BUB(*) AT THE INITIAL PT.
                 AUB = -C1516*ALB
*
             ELSE
                 AUB = MIN(-C1516*ALB,-DX(J)+BUB(J))
             END IF
*
         ELSE
             AUB = B(J)
             IF (DX(J).EQ.ZERO) THEN
                 ALB = -C1516*AUB
*
             ELSE
                 ALB = MAX(-C1516*AUB,-DX(J)+BLB(J))
             END IF
*
         END IF
*     THIS NEXT CODE, ENDING WITH ***, POINTS THE BOX TOWARDS THE BEST
*     VALUE OF X WHEN NOT AT A NEW BEST.
         IF (K.GE.2) THEN
             IF (XB(J).GT.X(J)) THEN
                 BUB(J) = BUB(J)*.25D0
                 IF (X(J)-BLB(J).GT.XB(J)) THEN
                     BLB(J) = BLB(J)*.75D0
*
                 ELSE
                     BLB(J) = MIN(BLB(J),.75D0* (X(J)-XB(J)))
                 END IF
*
             ELSE
                 BLB(J) = BLB(J)*.25D0
                 IF (X(J)-BUB(J).LT.XB(J)) THEN
                     BUB(J) = BUB(J)*.75D0
*
                 ELSE
                     BUB(J) = MAX(BUB(J),.75D0* (X(J)-XB(J)))
                 END IF
*
             END IF
*
         END IF
***
C     RESTRICT THE STEP FURTHER IF USER GIVES BOUNDS.
         ICASE = IND(J)
         GO TO (540,550,560,570),ICASE
C     CASE 1
  540    AUB = MIN(AUB,X(J)-BL(J))
         GO TO 580
C     CASE 2
  550    ALB = MAX(ALB,X(J)-BU(J))
         GO TO 580
C     CASE 3
  560    AUB = MIN(AUB,X(J)-BL(J))
         ALB = MAX(ALB,X(J)-BU(J))
         GO TO 580
C     CASE 4
  570    CONTINUE
C     END CASE
  580    BLB(J) = ALB
C     THIS NEXT LINE IS TO GUARANTEE THAT THE LOWER BOUND
C     IS .LE. THE UPPER BOUND.
         AUB = MAX(AUB,ALB)
         BUB(J) = AUB
         INDB(J) = 3
  590 CONTINUE
C     COMPUTE JACOBIAN*DX AND COMPARE NORM WITH CURRENT FUNCTION.
      IF (NP.GT.1) THEN
          PJ(1) = ZERO
          CALL PDA_DCOPY(LK,PJ,0,PJ,1)
          DO 600 J = 1,NVARS
             IF (JACTRI) THEN
                 JK = J
*
             ELSE
                 JK = MEQUA
             END IF
*
             CALL PDA_DAXPY(JK,DX(J),FJAC(MCON+1,J),1,PJ,1)
  600     CONTINUE
          T = PDA_DNRM2(LK,PJ,1)
C   THIS TEST SAYS TO USE THE QUADRATIC MODEL IF
C   THE LAST STEP IS APPROXIMATELY IN THE NULL SPACE
C   OF THE JACOBIAN.
          USEQ = USEQ .OR. T .LT. DFN*0.75D0
          IF (DFN.GT.ZERO) THEN
              DFN = T/DFN
*
          ELSE
              DFN = ZERO
          END IF
*
      END IF
*
      IF (IPRINT.GT.0) THEN
          CALL PDA_DVOUT(1,DFN,
     .        '('' RATIO OF J*DX NORM TO PAST DF NORM'')', 4)
      END IF
C     CHECK IF QUAD. MODEL IS BEING SUPPRESSED.
      USEQ = USEQ .AND. .NOT. NOQUAD
C     START THE PROCESS USING THE LINEAR MODEL.
      LINMOD = .TRUE.
      MCONST = MCON
CA:   DO FOREVER
  610 CONTINUE
C     COMPUTE THE REQUIRED DIMENSIONS OF THE MODEL PROBLEM.
      IF (LINMOD) THEN
          MK = 0
          ME = MIN(MEQUA,NVARS+1)
C     SET THE INITIAL VALUES FOR THE LINEAR MODEL PROBLEM.
          DX(1) = ZERO
          CALL PDA_DCOPY(NVARS,DX,0,DX,1)
*
      ELSE IF (USEQ) THEN
          MK = MIN(MEQUA,NVARS+NP+1)
          ME = NVARS + MK
          CALL PDA_DCOPY(MK,FJAC(MCON+1,NVARS+1),1,DX(NVARS+1),1)
*
      ELSE
C     EXIT FOREVER(A)
          GO TO 730
*
      END IF
*
      NV = NVARS + MK
C     NOTE THAT THE RESIDUALS ARE FREE VARIABLES.
      DO 620 I = NVARS + 1,NV
         INDB(I) = 4
  620 CONTINUE
      NIT = 0
C     THE JACOBIAN, RIGHT SIDE, QUAD. TERMS ARE AN
C     UPPER TRAPAZOIDAL DATA ARRAY.  THIS WILL MAKE SOLVING
C     THE MODEL PROBLEM MORE EFFICIENT.
C     DO FOREVER
  630 CONTINUE
C     CALL PDA_A SIMPLIFIED VERSION OF THE ALGORITHM TO SOLVE
C     THE MODEL PROBLEM.  THE FUNCTION AND JACOBIAN
C     ARE COMPUTED FOR THIS SUBPROBLEM DURING THE REVERSE
C     COMMUNICATION REQUESTS.
      CALL PDA_DQEDGN(ME,NV,MCONST,INDB,BLB,BUB,DX,WJ,LDWJ,PV,IGOW,
     .            IOPT(IPLS),ROPT,IWA,WA)
C     CHECK FOR AN ERROR THAT WAS SEEN IN THE LOW-LEVEL
C     NONLINEAR SOLVER.
      IF (IGOW.GT.7) THEN
          IGO = IGOW
          IFLAG = 0
C     DO(RETURN TO USER PROGRAM UNIT)
          GO TO 1020
*
      END IF
C     CLEAR OUT THE WJ(*,*) ARRAY THAT HOLDS
C     THE JACOBIAN FOR THE INNER LOOP PROBLEM.
      WJ(1,1) = ZERO
      CALL PDA_DCOPY(LDWJ* (NV+1),WJ,0,WJ,1)
      IF (USEQ .AND. .NOT. LINMOD) WJ(MCONST+1,NVARS+1) = ONE
C     PUT IN A UNIT MATRIX FOR THE PARTIALS
C     WITH RESPECT TO THE RESIDUALS.
      CALL PDA_DCOPY(MK,WJ(MCONST+1,NVARS+1),0,WJ(MCONST+1,NVARS+1),
     .               LDWJ+1)
      DO 640 I = 1,MCON
C     THE FORM OF THE UPDATE BEING COMPUTED IS X(*)-DX(*).
C     THE VALUE OF DX IS ITSELF COMPUTED AS THE SOLUTION
C     TO A NONLINEAR PROBLEM WITH UPDATES OF THE FORM
C     DX(*)-D(DX)(*).
         CALL PDA_DCOPY(NVARS,FJAC(I,1),LDFJAC,WJ(I,1),LDWJ)
         WJ(I,NV+1) = FJAC(I,NVARS+1) -
     .                PDA_DDOT(NVARS,DX,1,WJ(I,1),LDWJ)
  640 CONTINUE
C     SEE IF USER HAS GIVEN GENERAL CONSTRAINTS.
C     USE THESE CONSTRAINTS TO PLACE EQUIVALENT CONSTRAINTS
C     ON THE CHANGES BEING COMPUTED.
      DO 650 J = 1,MCON
         BLB(NV+J) = BL(J+NVARS)
         BUB(NV+J) = BU(J+NVARS)
         INDB(NV+J) = IND(J+NVARS)
  650 CONTINUE
C     DO(EVALUATE LINEAR MODEL)
      ASSIGN 660 TO IGOELM
      GO TO 940
*
  660 CONTINUE
C     DO(EVALUATE QUADRATIC MODEL)
      ASSIGN 670 TO IGOEQM
      GO TO 850
*
  670 CONTINUE
      IF (IGOW.GT.1) THEN
          PV = PDA_DNRM2(ME,WJ(MCONST+1,NV+1),1)
          IF (LINMOD) THEN
              PVL = PV
              CALL PDA_DCOPY(NVARS,DX,1,DXL,1)
              LINMOD = .FALSE.
C     CYCLE FOREVER(A)
              GO TO 610
C     IF THE PREDICTED NORM IS GREATER THAN THE CURRENT
C     RESIDUAL NORM, DROP THE QUADRATIC MODEL AND USE THE
C     LINEAR MODEL.
          ELSE IF ((PV.GE.FC) .AND. USEQ) THEN
              IF (IPRINT.GT.0) WRITE (NOUT,
     .            '('' ABANDON QUAD. MODEL.'')')
              USEQ = .FALSE.
          END IF
*
C     EXIT FOREVER(A)
          GO TO 730
*
      END IF
C     FOR EITHER CASE TRANSFER THE JACOBIAN FOR THE MODEL
C     PROBLEM.  THE TRANSPOSE OF THIS MATRIX IS THE PARTIALS
C     WITH RESPECT TO THE RESIDUALS.
      DO 680 J = 1,NVARS
         CALL PDA_DCOPY(MK,WJ(MCONST+1,J),1,WJ(MCONST+MK+J,NVARS+1),
     .                  LDWJ)
  680 CONTINUE
C     NOW UPDATE THE RESIDUALS FOR BOTH SETS OF MODEL EQUATIONS.
C     IN ROWS 1,...,MK THIS INVOLVES ADDING DX(NVARS+I) TO ROW I.
C     FOR ROWS MK+1,...,ME THIS REQUIRES ADDING MULTIPLES OF THE
C     COLS. OF THE TRANSPOSED JACOBIAN.
      DO 690 I = 1,MK
         T = DX(NVARS+I)
         WJ(MCONST+I,NV+1) = WJ(MCONST+I,NV+1) + T
  690 CONTINUE
C     SYMMETRIZE THE SECOND DERIVATIVE MATRIX.  THIS
C     IS NOT REQUIRED WHEN THE MODEL IS LINEAR, BUT IT
C     DOES NOT HURT THEN.
      IF (USEQ .AND. .NOT. LINMOD) THEN
          DO 710 J = 1,NVARS
             DO 700 I = J,NVARS
                WJ(MCONST+MK+I,J) = WJ(MCONST+MK+J,I)
  700        CONTINUE
  710     CONTINUE
      END IF
C     COMPUTE RESIDUALS ON THE EQUATIONS K*R = 0.
      DO 720 J = NVARS + 1,NV
         CALL PDA_DAXPY(NVARS,DX(J),WJ(MCONST+MK+1,J),1,
     .              WJ(MCONST+MK+1,NV+1),1)
  720 CONTINUE
      NIT = NIT + 1
      GO TO 630
C     END FOREVER
C     END FOREVER (A)
  730 CONTINUE
C     COMPUTE THE ANGLES BETWEEN THE LINEAR AND QUADRATIC STEP.
C     TAKE THE ONE, IF THERE IS A CHOICE, CLOSEST TO THE GRADIENT.
C     IF THE QUADRATIC MOVE IS QUITE CLOSE TO THE GRADIENT, TAKE
C     THAT MOVE IN PREFERENCE TO THE LINEAR MOVE.
      COSL = PDA_DDOT(NVARS,GR,1,DXL,1)
      T = PDA_DNRM2(NVARS,DXL,1)
      IF (T.GT.ZERO) COSL = COSL/T
      COSQ = -ONE
      COSM = -ONE
      TT = ZERO
      IF (USEQ) THEN
          COSQ = PDA_DDOT(NVARS,GR,1,DX,1)
          TT = PDA_DNRM2(NVARS,DX,1)
          IF (TT.GT.ZERO) COSQ = COSQ/TT
C     COMPUTE THE COSINE OF THE ANGLE BETWEEN THE QUAD. AND
C     LINEAR MOVES.
          IF (T.GT.ZERO .AND. TT.GT.ZERO)
     .         COSM = PDA_DDOT(NVARS,DX,1,DXL,1)/T/TT
      END IF
*
      IF (IPRINT.GT.0) WRITE (NOUT,
     .'('' COS OF QUAD. MOVE AND GRAD., COS OF LIN. MOVE AND GRAD., '//
     .'COS OF EACH MOVE'',/,'' FLAG FOR TRYING QUAD. MOVE.'',/, '//
     .'1P3D12.4,L6)') COSQ,COSL,COSM,USEQ
      IF (IPRINT.GT.0) WRITE (NOUT,
     .'('' LENGTH OF QUAD., THEN LINEAR MOVES'',/,1P2D12.4)') TT,T
C     CHOOSE MOVE PARTIALLY BASED ON ANGLE MOVES MAKE WITH EACH OTHER.
      USEQ = USEQ .AND. (COSM.GT.ZERO .OR. COSL.LT.COSM) .AND. COSQ .GT.
     .       ZERO
      USEQL = USEQ
*
      IF ( .NOT. USEQ) THEN
          PV = PVL
          CALL PDA_DCOPY(NVARS,DXL,1,DX,1)
          NTTERM = 0
*
      ELSE
          NTTERM = NP - 1
      END IF
C     TEST FOR NOISE IN MODEL PROBLEM SOLN.
      TERM = (PV.GE.FC) .AND. .NOT. RETREA .AND. .NOT. USEQ
      TERM = TERM .AND. MCON .EQ. 0
      TERM = .FALSE.
      IF (TERM) THEN
          IF (IPRINT.GT.0) THEN
              WRITE (NOUT,9021) PV,FC
          END IF
C     VALUE MEANS MODEL RES. .GE. NONLINEAR FUNCTION VALUE.
          IGO = 5
          IFLAG = 0
C     EXIT FOREVER
          GO TO 840
*
      END IF
*
      RC = ZERO
      IF (PV.GT.PB) RC = 4.D0* (PV-PB)/ (PV+PD)
C
C     IF USING A QUADRATIC MODEL AND RETREATING SEEMS TO BE
C     NECESSARY, SEE IF RETREATING WOULD BE NEEDED WITH A
C     LINEAR MODEL.  ONLY THEN RETREAT.
      IF (RC.LE.ONE .OR. .NOT. USEQ) GO TO 750
C     DO(EVALUATE LINEAR MODEL)
      NV = NVARS
      ASSIGN 740 TO IGOELM
      GO TO 940
*
  740 CONTINUE
      PVL = PDA_DNRM2(MIN(MEQUA,NVARS+1),WJ(MCONST+1,NV+1),1)
      IF (PVL.GT.PB) RC = 4.D0* (PVL-PB)/ (PVL+PD)
  750 CONTINUE
      RG = MAX(RG,RC)
      IF (IPRINT.GT.0) THEN
          WRITE (NOUT,9011) ITERS,FC,PV,RC,AJN,K,KL,FB,ALPHA,BBOOST,
     .      NIT,USEQ,NTTERM
          WRITE (NOUT,9001) '  X=', (X(J),J=1,NVARS)
          WRITE (NOUT,9001) ' DX=', (DX(J),J=1,NVARS)
          WRITE (NOUT,9001) '  B=', (B(J),J=1,NVARS)
          WRITE (NOUT,9001) ' LB=', (BLB(J),J=1,NALL)
          WRITE (NOUT,9001) ' UB=', (BUB(J),J=1,NALL)
          WRITE (NOUT,'('' ///END OF ITERATION.///'')')
      END IF
*
      RETREA = RC .GT. 1
      IF ( .NOT. RETREA) THEN
          CHG = ONE
          T2 = ZERO
          DO 810 J = 1,NVARS
             BOLD = B(J)
             T = DX(J)/BOLD
             ALB = TWO
             AUB = TWO
C    IF USER GIVES BOUNDS, AND THESE BOUNDS ARE HIT,
C    DO NOT DETRACT FROM DECLARING A FULL NEWTON STEP.
             ICASE = IND(J)
             GO TO (760,770,780,790),ICASE
C     CASE 1
  760        ALB = (X(J)-BL(J))/BOLD
             AUB = -SEMIBG
             GO TO 800
C     CASE 2
  770        AUB = (X(J)-BU(J))/BOLD
             ALB = -SEMIBG
             GO TO 800
C     CASE 3
  780        ALB = (X(J)-BL(J))/BOLD
             AUB = (X(J)-BU(J))/BOLD
             GO TO 800
C     CASE 4
  790        CONTINUE
             ALB = -SEMIBG
             AUB = -SEMIBG
C     END CASE
  800        CONTINUE
             IF (T.EQ.ONE) THEN
                 T2 = ONE
                 B(J) = BOLD + BOLD
                 CHG = CHG*CHGFAC
*
             ELSE
                 IF (ABS(T).LT..25D0 .AND. DX(J).NE.ZERO) THEN
                     B(J) = SIGN(.25D0*BOLD,DX(J)) + 3.D0*DX(J)
*
                 ELSE
                     B(J) = SIGN(BOLD,DX(J))
                 END IF
*
             END IF
C     THIS TEST AVOIDS THE USER BOUNDS IN DECLARING A NEWTON STEP.
             IF (ABS(ALB-T).GE..01D0*ABS(T) .AND. ABS(AUB-T).GE..01D0*
     .           ABS(T)) THEN
                 IF (T.GT.ZERO) THEN
                     T2 = MAX(T2,T)
*
                 ELSE
                     T2 = MAX(T2,-T/C1516)
                 END IF
*
             END IF
*
  810     CONTINUE
          FULNWT = T2 .LT. .99D0
          DXNRM = ABS(DX(PDA_IDAMAX(NVARS,DX,1)))
C     DO BLOCK
C     TEST FOR SMALL ABSOLUTE CHANGE IN X VALUES.
          TERM = DXNRM .LT. TOLD .AND. FULNWT
          IF (TERM) THEN
              IGO = 6
C     VALUE MEANS CHANGE (IN PARAMETERS) WAS SMALL AND A
C     FULL STEP (NOT HITTING TRUST CONSTRAINTS) TAKEN.
C     EXIT BLOCK
              GO TO 820
*
          END IF
*
          TERM = DXNRM .LT. PDA_DNRM2(NVARS,X,1)*TOLX .AND. FULNWT
          TERM = TERM .AND. (ITERS.GT.1)
          IF (TERM) THEN
              IGO = 7
C     VALUE MEANS RELATIVE CHANGE IN PARAMETERS WAS SMALL AND A
C     FULL STEP (NOT HITTING CONSTRAINTS WITH AT LEAST 2 ITERATIONS)
C     WAS TAKEN.
C     EXIT BLOCK
              GO TO 820
*
          END IF
C     EXIT IF
          GO TO 830
C     END BLOCK
  820     CONTINUE
C     CYCLE FOREVER
          GO TO 30
*
      END IF
*
  830 CONTINUE
      FL = FC
C     END FOREVER
      GO TO 30
*
  840 CONTINUE
C     DO(RETURN TO USER PROGRAM UNIT)
      GO TO 1020
C     PROCEDURE(EVALUATE QUADRATIC MODEL)
  850 CONTINUE
C     IF THE MODEL IS GENUINELY QUADRATIC, ADD IN THE EXTRA
C     TERMS AND COMPUTE THE SECOND DERIVATIVE INFORMATION.
      IF (USEQ .AND. .NOT. LINMOD) THEN
C     COMPUTE THE DOT PRODUCT OF CURRENT PROPOSED STEP AND
C     PAST DIRECTIONS REPRESENTED IN THE MODEL.
          DO 870 L = 1,NP - 1
             T = ZERO
             DO 860 J = 1,NVARS
                T = T + DX(J)* (XP(J,L+1)-XP(J,1))
  860        CONTINUE
             PJ(L) = T
  870     CONTINUE
C     STORAGE LAYOUT, WITH K = J**T, OF WJ(*,*).
C     [J    :  I    : F+R ]
C     [H    :  K    : K*R ]
C     ADD IN THE QUADRATIC TERMS FOR THE FUNCTION.
          DO 880 L = 1,NP - 1
             JK = MIN(NVARS+L+1,MEQUA)
             CALL PDA_DAXPY(JK,.5D0*PJ(L)**2,QC(1,L+1),1,
     .                      WJ(MCONST+1,NV+1),1)
  880     CONTINUE
C     ADD THE LINEAR TERMS TO THE INNER LOOP JACOBIAN.
          DO 900 L = 1,NP - 1
             JK = MIN(NVARS+L+1,MEQUA)
             DO 890 J = 1,NVARS
                CALL PDA_DAXPY(JK,PJ(L)* (XP(J,L+1)-XP(J,1)),QC(1,L+1),
     .                         1,WJ(MCONST+1,J),1)
  890        CONTINUE
  900     CONTINUE
C     COMPUTE THE UPPER TRIANGULAR PART OF THE SECOND
C     DERIVATIVE TERMS.
          DO 930 I = 1,NVARS
             DO 920 J = I,NVARS
                DO 910 L = 1,NP - 1
                   JK = MIN(NVARS+L+1,MEQUA)
                   WJ(MCONST+MK+I,J) = WJ(MCONST+MK+I,J) +
     .                                 (XP(J,L+1)-XP(J,1))*
     .                                 (XP(I,L+1)-XP(I,1))*
     .                            PDA_DDOT(JK,DX(NVARS+1),1,QC(1,L+1),1)
  910           CONTINUE
  920        CONTINUE
  930     CONTINUE
      END IF
C     END PROCEDURE
      GO TO IGOEQM
C     PROCEDURE(EVALUATE LINEAR MODEL)
  940 CONTINUE
C     TRANSFER THE JACOBIAN THAT WOULD RESULT FROM
C     USING JUST A LINEAR MODEL.
      DO 950 J = 1,NVARS
         IF (JACTRI) THEN
             JK = J
*
         ELSE
             JK = MEQUA
         END IF
*
         CALL PDA_DCOPY(JK,FJAC(MCON+1,J),1,WJ(MCONST+1,J),1)
  950 CONTINUE
C     TRANSFER THE PRESENT VALUES OF THE FUNCTION.
      CALL PDA_DCOPY(MIN(MEQUA,NVARS+1),FJAC(MCON+1,NVARS+1),1,
     .           WJ(MCONST+1,NV+1),1)
C     CHANGE SIGN FOR THE MODEL PROBLEM.
      DO 960 I = 1,MIN(MEQUA,NVARS+1)
         WJ(MCONST+I,NV+1) = -WJ(MCONST+I,NV+1)
  960 CONTINUE
C     COMPUTE THE LINEAR TERM OF THE MODEL.
      DO 970 J = 1,NVARS
         IF (JACTRI) THEN
             JK = J
*
         ELSE
             JK = MEQUA
         END IF
*
         CALL PDA_DAXPY(JK,DX(J),WJ(MCONST+1,J),1,WJ(MCONST+1,NV+1),1)
  970 CONTINUE
C     END PROCEDURE
      GO TO IGOELM
C     PROCEDURE(TEST FOR CONVERGENCE)
  980 CONTINUE
      TERM = ITERS .GE. ITMAX
      IF (TERM) THEN
          IGO = 8
C     VALUE MEANS THAT MAX. NUMBER OF ALLOWED ITERATIONS TAKEN.
C     EXIT PROCEDURE
          GO TO 1000
*
      END IF
C     TEST FOR SMALL FUNCTION NORM.
      TERM = FC .LE. TOLF
C     IF HAVE CONSTRAINTS MUST ALLOW AT LEAST ONE MOVE.
      TERM = TERM .AND. (MCON.EQ.0 .OR. ITERS.GT.1)
      IF (TERM) THEN
          IGO = 2
C     VALUE MEANS FUNCTION NORM WAS SMALL.
C     EXIT PROCEDURE
          GO TO 1000
*
      END IF
C     DO(TEST FOR NO CHANGE)
      GO TO 1010
*
  990 CONTINUE
      TERM = TERM .AND. .NOT. RETREA
      IF (TERM) THEN
          IGO = 3
C     VALUE MEANS THE FUNCTION IS PROBABLY REACHING A LOCAL MINIMUM
C     BUT MOVES ARE STILL HITTING TRUST REGION CONSTRAINTS.
          IF (FULNWT) IGO = 4
C     VALUE MEANS THAT FUNCTION IS REACHING A LOCAL MINIMUM
C     AND MOVES ARE NOT HITTING THE TRUST REGION CONSTRAINTS.
          IF (IGO.EQ.3) TERM = TERM .AND. .NOT. MUSTCN
C     EXIT PROCEDURE
          GO TO 1000
*
      END IF
C     END PROCEDURE
 1000 CONTINUE
      GO TO IGOTFC
C     PROCEDURE(TEST FOR NO CHANGE)
 1010 CONTINUE
      TERM = (ABS(FB-PV).LE.TOLSNR*FB) .AND. (ABS(FC-PV).LE.FB*TOLP)
      TERM = TERM .AND. (ABS(FC-FL).LE.FB*TOLSNR)
      TERM = TERM .AND. (ABS(PVL-PV).LE.FB*TOLSNR)
C     END PROCEDURE
      GO TO 990
C     PROCEDURE(RETURN TO USER PROGRAM UNIT)
 1020 CONTINUE
      RETURN
C     PROCEDURE(INITIALIZE OTHER VALUES)
 1030 CONTINUE
C     THE NUMBER OF PAST DIFFERENCES USED IN THE QUADRATIC MODEL.
      NP = 0
C     IF NO MORE EQUATIONS THAN VARIABLES, NO NEED TO
C     PRETRIANGULARIZE THE JACOBIAN MATRIX.
      JACTRI = MEQUA .GT. NVARS
C     MAKE SURE THAT VARIABLES SATISFY CONSTRAINTS.
C     GENERALLY THIS MAY TAKE A CALL PDA_TO DBOCLS().
C     AS LONG AS THE FUNCTIONS ARE DEFINED AT POINTS
C     THAT DO NOT SATISFY THE CONSTRAINTS, THE FIRST
C     ALGORITHM STEP WILL BRING IT ONTO THE CONSTRAINTS.
C
      DO 1090 J = 1,NVARS
         GO TO (1040,1050,1060,1070),IND(J)
C     CASE 1
 1040    X(J) = MAX(X(J),BL(J))
         GO TO 1080
C     CASE 2
 1050    X(J) = MIN(X(J),BU(J))
         GO TO 1080
C     CASE 3
 1060    X(J) = MAX(X(J),BL(J))
         X(J) = MIN(X(J),BU(J))
         GO TO 1080
C     CASE 4
 1070    CONTINUE
C     END CASE
 1080    CONTINUE
 1090 CONTINUE
      ITERS = 0
      NALL = MCON + NVARS
      CHGFAC = TWO** (-ONE/REAL(NVARS))
      C1516 = 15.D0/16.D0
      SEMIBG = 1.D10
C     END PROCEDURE
      GO TO 20
C     PROCEDURE(PROCESS OPTION ARRAY)
 1100 CONTINUE
      IPRINT = 0
C     PDA_I1MACH(2)=STANDARD OUTPUT UNIT.
      NOUT = PDA_I1MACH(2)
C     PDA_D1MACH(4)=RELPR=MACHINE REL. PREC.
      T = PDA_D1MACH(4)
      TOLF = SQRT(T)
      TOLUSE = TOLF
      TOLX = TOLF
      TOLD = TOLF
      TOLSNR = 1.D-5
      TOLP = 1.D-5
      COND = 30.
      ITMAX = 75
      LEVEL = 1
      IPLS = 0
      PASSB = .FALSE.
      NOQUAD = .FALSE.
      REVERS = .FALSE.
      MUSTCN = .FALSE.
      LP = 1
      LPDIFF = 0
C     DO FOREVER
 1110 CONTINUE
      LP = LP + LPDIFF
      LPDIFF = 2
      KP = IOPT(LP)
      NEWOPT = KP .GT. 0
      JP = ABS(KP)
C     SEE IF THIS IS THE LAST OPTION..
      IF (JP.EQ.99) THEN
          IF (NEWOPT) THEN
C     THE POINTER TO THE START OF OPTIONS FOR THE INNER LOOP
C     SOLVER MUST SATISFY THE REQUIREMENTS FOR THAT OPTION ARRAY.
              IF (IPLS.EQ.0) IPLS = LP
C     EXIT FOREVER
              GO TO 1120
*
          ELSE
              LPDIFF = 1
C     CYCLE FOREVER
              GO TO 1110
*
          END IF
*
      END IF
C     CHANGE PRINT OPTION.
      IF (JP.EQ.1) THEN
          IF (NEWOPT) IPRINT = IOPT(LP+1)
C     CYCLE FOREVER
          GO TO 1110
*
      END IF
C     SEE IF MAX. NUMBER OF ITERATIONS CHANGING.
      IF (JP.EQ.2) THEN
          IF (NEWOPT) ITMAX = IOPT(LP+1)
C     CYCLE FOREVER
          GO TO 1110
*
      END IF
C     SEE IF BOUNDS FOR THE TRUST REGION ARE BEING PASSED.
      IF (JP.EQ.3) THEN
          IF (NEWOPT) THEN
              CALL PDA_DCOPY(NVARS,ROPT(IOPT(LP+1)),1,BB,1)
              PASSB = .TRUE.
          END IF
C     CYCLE FOREVER
          GO TO 1110
*
      END IF
C     CHANGE TOLERANCE ON THE LENGTH OF THE RESIDUALS.
      IF (JP.EQ.4) THEN
          IF (NEWOPT) TOLF = ROPT(IOPT(LP+1))
C     CYCLE FOREVER
          GO TO 1110
*
      END IF
C     CHANGE TOLERANCE ON THE NORM OF THE RELATIVE
C     CHANGE TO THE PARAMETERS.
      IF (JP.EQ.5) THEN
          IF (NEWOPT) TOLX = ROPT(IOPT(LP+1))
C     CYCLE FOREVER
          GO TO 1110
*
      END IF
C     CHANGE TOLERANCE ON ABSOLUTE CHANGE TO THE PARAMETERS.
      IF (JP.EQ.6) THEN
          IF (NEWOPT) TOLD = ROPT(IOPT(LP+1))
C     CYCLE FOREVER
          GO TO 1110
*
      END IF
*
      IF (JP.EQ.7) THEN
C     CHANGE TOLERANCE FOR RELATIVE AGREEMENT BETWEEN
C     BEST FUNCTION NORM, LAST FUNCTION NORM AND THE
C     CURRENT FUNCTION NORM.
          IF (NEWOPT) TOLSNR = ROPT(IOPT(LP+1))
C     CYCLE FOREVER
          GO TO 1110
*
      END IF
*
      IF (JP.EQ.8) THEN
C     CHANGE TOLERANCE FOR AGREEMENT BETWEEN PREDICTED
C     VALUE OF RESIDUAL NORM AND THE PREVIOUS VALUE OF
C     THE RESIDUAL NORM.
          IF (NEWOPT) TOLP = ROPT(IOPT(LP+1))
C     CYCLE FOREVER
          GO TO 1110
*
      END IF
*
      IF (JP.EQ.9) THEN
C     CHANGE TOLERANCE SUCH THAT RELATIVE CHANGES IN THE
C     VALUES OF THE PARAMETERS IMPLY THAT THE PREVIOUS
C     VALUE OF THE FUNCTION WILL NOT BE USED IN THE
C     QUADRATIC MODEL.
          IF (NEWOPT) TOLUSE = ROPT(IOPT(LP+1))
C     CYCLE FOREVER
          GO TO 1110
*
      END IF
*
      IF (JP.EQ.10) THEN
C     CHANGE THE LARGEST CONDITION NUMBER TO ALLOW WHEN
C     SOLVING FOR THE QUADRATIC COEFFICIENTS OF THE MODEL.
          IF (NEWOPT) COND = ROPT(IOPT(LP+1))
C     CYCLE FOREVER
          GO TO 1110
*
      END IF
C     CHANGE THE PRINT LEVEL IN THE ERROR PROCESSOR.
      IF (JP.EQ.11) THEN
          IF (NEWOPT) LEVEL = IOPT(LP+1)
C     CYCLE FOREVER
          GO TO 1110
*
      END IF
C     PASS AN OPTION ARRAY TO THE CONSTRAINED LINEAR SOLVER.
C     THIS OPTION IS A POINTER TO THE START OF THE OPTION
C     ARRAY FOR THE SUBPROGRAM.
      IF (JP.EQ.12) THEN
          IF (NEWOPT) IPLS = IOPT(LP+1)
C     CYCLE FOREVER
          GO TO 1110
*
      END IF
C     MOVE THE PROCESSING POINTER BY THE VALUE IN THE
C     NEXT ENTRY OF THE OPTION ARRAY.  THIS DEVICE IS
C     INCLUDED SO THAT PASSING OPTIONS TO LOWER LEVEL
C     SUBROUTINES IS EASY TO DO.
      IF (JP.EQ.13) THEN
          IF (NEWOPT) LPDIFF = IOPT(LP+1)
C     CYCLE FOREVER
          GO TO 1110
*
      END IF
C     OPTION TO SUPPRESS USING THE QUADRATIC MODEL, EVER.
      IF (JP.EQ.14) THEN
          IF (NEWOPT) NOQUAD = IOPT(LP+1) .EQ. 1
C     CYCLE FOREVER
          GO TO 1110
*
      END IF
C     MORE STORAGE WAS GIVEN FOR THE QUADRATIC MODEL ARRAYS.
C     THIS OPTION WAS PROCESSED BY THE INTERFACE UNIT.
C     IF(JP.EQ.15)CYCLE FOREVER
      IF (JP.EQ.15) GO TO 1110
C     USE FORWARD COMMUNICATION TO GET THE DERIVATIVES
C     AND FUNCTION VALUES.
      IF (JP.EQ.16) THEN
          IF (NEWOPT) REVERS = IOPT(LP+1) .EQ. 1
C     CYCLE FOREVER
          GO TO 1110
*
      END IF
C     FORCE A FULL NEWTON STEP WHEN NEAR THE MINIMUM.
C     DO NOT ALLOW CONVERGENCE CLAIMS WHEN HITTING BOUNDS.
      IF (JP.EQ.17) THEN
          IF (NEWOPT) MUSTCN = IOPT(LP+1) .EQ. 1
C     CYCLE FOREVER
          GO TO 1110
*
      END IF
C     SAW AN OPTION (OR GARBAGE) THAT IS NOT ON THE LIST.
      XMESS =
     .'DQEDMN. INVALID OPTION PROCESSED. I1=IOPT(*) ENTRY. I2=IOPT(I1).'
      NERR = 07
      IGO = 15
      CALL PDA_CHRCNT(XMESS,NMESS)
      CALL PDA_XERRWV(XMESS,NMESS,NERR,LEVEL,2,LP,IOPT(LP),0,RDUM,RDUM)
      IFLAG = 0
C     DO(RETURN TO USER PROGRAM UNIT)
      GO TO 1020
C     END FOREVER
C     END PROCEDURE
 1120 CONTINUE
      GO TO 10
*
 9001 FORMAT (A4,1P10D12.4/ (4X,10D12.4))
 9011 FORMAT ('0ITER.=',I3,' FC=',1PD10.4,' PV=',1PD10.4,03X,' RC=',
     .  1PD10.4,' J**T*F=',1PD10.4,/,' K=',I4,' KL=',I4,/10X,' FB=',
     .  1PD10.4,' AL=',1PD10.4,' BB=',1PD12.4/' INNER ITERATIONS =',I5,
     .  ' USE QUAD. MODEL?=',L5,' NUM. OF TERMS =',I5)
 9021 FORMAT (' MODEL RESIDUAL.GE.CURRENT F. QUITTING.',1P2D12.5)
      END
