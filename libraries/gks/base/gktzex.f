C# IL>=a, OL>=0
      SUBROUTINE GKTZEX (NV,VX,VY,VXETT,IYETT,IETB,JETNXT,YMIN,TZ,FOUND)
*
* (C) COPYRIGHT ICL & SERC  1984
*

*---------------------------------------------------------------------
*
*  RUTHERFORD / ICL GKS SYSTEM
*
*  Type of routine:    Utility
*  Author:             KEVP
*
      INCLUDE '../include/check.inc'
*
*  PURPOSE OF THE ROUTINE
*  ----------------------
*     To extract a trapeziod from an Edge Table structure
*     as generated by GKTZME and possibly clipped.
*
*  MAINTENANCE LOG
*  ---------------
*     08/11/91  KEVP  Original Version Stabilised (C69)
*
*  ARGUMENTS
*  ---------
*     INP NV      Length of Edge Table
*     INP VX      Vertex X-coords (for edge bottoms)
*     I/O VY      Vertex Y-coords (for both ends of edges)
*     I/O VXETT   Edge Top X-coords
*     INP IYETT   Edge Top Vertex Indices (for Y-coords)
*     I/O IETB    Edge Bottom Vertex Indices (for both coords)
*     I/O JETNXT  Edge Table Link array for ordering the edges
*     INP YMIN    Lowest edge of clipping rectangle
*     OUT TZ      Trapezoid specification
*     OUT FOUND   True, if trapezoid has been found
*
      INTEGER IEDGE, NV, IYETT(NV), IETB(NV), JETNXT(0:NV)
      REAL VX(NV), VY(NV), VXETT(NV), YMIN, TZ(6)
      LOGICAL FOUND
*
* Note: The Edge Tables are passed as arguments
*         so that they may be re-indexed from zero or one.
*
*  COMMON BLOCKS
*  -------------
      INCLUDE '../include/gkmc.par'
*                           for QTOL
      INCLUDE '../include/gkerr.cmn'
*                           for KERROR
*
*  LOCALS
*  ------
*     Parameters specifying trapezoid data in array
*     JUPLEX  Upper-Left X
*     JLOLEX  Lower-Left X
*     JUPRIX  Upper-Right X
*     JLORIX  Lower-Right X
*     JUPY    Upper Y
*     JLOY    Lower Y
*
      INTEGER    JUPLEX,  JLOLEX,  JUPRIX,  JLORIX,  JUPY,  JLOY
      PARAMETER (JUPLEX=1,JLOLEX=2,JUPRIX=3,JLORIX=4,JUPY=5,JLOY=6)

*     BCROSS  True if, prov' trap' base is the crossing the sides
*     BXUPD   True if, X-ends of prov' trap' base need updating
*     COLLIN  True if, edges are collinear
*     CROSS   True if, edges cross
*     DEPTH   Depth below top of provisional trapezoid
*     E1X,E1Y First edge coords
*     E2X,E2Y Second edge coords
*     ECX,ECY Crossing coords
*     IBOLD   Old vertex indices of bottoms of first 4 edges
*     ISIDE   Do loop index over left/right - Current Side
*     ITRIG   Section of program triggering trapezoid
*     I4      Do loop index over first 4 edges in edge table
*     J       Do loop index - Never used within do loop
*     JLEFT   Array (2) index for Left side peak
*     JLO1X   Index in TZ of lower vertex of first side
*     JLO2X   Index in TZ of lower vertex of second side
*     JNEW    New Indices of Initial 4 Edges
*     JOLD    Old Indices of Initial 4 Edges
*     JPL     Array (2) index for Left side of possible peak
*     JPOSS   Index of Possible edge peak
*     JPR     Array (2) index for Right side of possible peak
*     JRIGHT  Array (2) index for Right side
*     JTZ     Indices of the two edges to form sides of the trapezoid
*     LPOSS   Index of Last edge before the Possible edge
*     PEAKCH  Edge table may need changing to make peak edges valid
*     REMOVE  True if left/right edge needs removing
*     SLOPE   Slopes of the sides of the trapezoid
*     TZI     X-coord of possible base end of provisional trapezoid
*     TZL,TZR X-coords of possible base of provisional trapezoid
*     VXBOT   Bottoms of edges forming sides of trapezoid (X-coords)
*     VXLTOP  Top of last before possible edge (X-coord)
*     VXPBOT  Bottom of possible edge (X-coord)
*     VXPTOP  Top of possible edge (X-coord)
*     VXTOP   Tops of edges forming sides of trapezoid (X-coords)
*     VYPBOT  Bottom of possible edge (Y-coord)
*     VYPTOP  Tops of possible edge (Y-coord)
*     VYTOP   Top of edges forming sides of trapezoid (Y-coord)
*     XOLD    Old Initial starts (top) of first 4 edges (X-coord)
*     YOLD    Old Initial starts (top) of first 4 edges (Y-coord)
*
      INTEGER JTZ(0:2), JPOSS, LPOSS, ISIDE, JLEFT,JRIGHT, I4, J
      INTEGER JOLD(4),JNEW(4), IBOLD(4), JPL,JPR, JLO1X,JLO2X, ITRIG
      REAL    E1X(2),E1Y(2),  E2X(2),E2Y(2), ECX(2),ECY(2)
      REAL    VXTOP(2),VYTOP, VXBOT(2),VYBOT(2), SLOPE(2)
      REAL    VXPTOP,VYPTOP, VXPBOT,VYPBOT, VXLTOP
      REAL    DEPTH, XOLD(4), YOLD(4), TZL,TZR, TZI
      LOGICAL REMOVE(2), BXUPD, PEAKCH, CROSS, COLLIN, BCROSS
*
*  ERRORS
*  ------
*    -2004  Invalid Edge Table
*
*  ALGORITHM
*  ---------
*     This routine assumes that the edge table structure supplied
*     does correspond to a polygon.
*     The edges are assumed to be sorted in the order of the Y-values
*     of their tops, downwards and edges of equal Y-value by the vertex
*     index of their tops.
*
*     The edge table does not explicitly include all horizontal edges.
*     Those derived from chopping of peak (refered to as peak edges)
*     are indicated by the presence of two edges with the same vertex
*     Y-index for their tops. To find such a pair easy to find the
*     edge table is sorted to ensure so that they are consecutive.
*
*     (1) The pair of edges with the highest tops (first pair as sorted)
*         are found. They must have the same Y-index for their edge tops.
*         The common Y-index defines an implicit peak edge.
*         If any of these highest two edges is horizontal it is removed
*         in such a manner as to preserve the peak edge.
*         The edge table is then manipulated to ensure that the
*         peak edges are valid (ie, they connect neighbouring edges).
*         The highest two edges are selected again an so on, till
*         neither are horizontal.
*         If no such pair of edges is found, quit reporting not found.
*
*     (2) A PROVISIONAL TRAPEZOID is formed out these two edges.
*         The top of this provisional trapezoid is the horizontal line
*         linking the two tops of the edges (the peak edge).
*         The sides are the two edges, with the one that goes lowest
*         truncated up to the same level as the other.
*         The base of the provisional trapezoid is the horizontal line
*         linking the two lower ends of the sides.
*         The calculating of the X-values of these lower vertices is not
*         done at this stage.
*         The remove flag is set true for the side that was not truncated
*         upwards and false for the other.
*
*     (3) If the base of the provisional trapezoid is below the clipping
*         rectangle, it is raised to the clipping rectangle and the
*         remove flags are both set false.
*
*     (4) The provisional trapezoid is checked to see if any edges
*         ocurr inside it. The base of the provisional trapezoid is
*         raised to the top of such an edge, when found.
*         The peak-change flag is set true and the remove flags
*         are both set false.
*
*     (5) The provisional trapezoid is checked for intersections
*         of each of its two sides with the other peak edges
*         implied by the edge table.
*         The base of the provisional trapezoid is raised to
*         any such crossing found, when found.
*         The peak-change flag is set true and the remove flags
*         are both set false.
*
*     (6) The provisional trapezoid is checked for intersections
*         of each of it two sides with other edges explicitly in
*         the edge table.
*         The base of the provisional trapezoid is raised to
*         any such crossing found, when found.
*         The peak-change flag is set false and the remove flags
*         are both set false.
*
*   Now the provisional trapezoid has become the trapezoid that,
*   which will be taken off the edge table.
*
*    (7)  The X-values of the lower corners are now calculated,
*         if this has not already been done.
*
*    (8)  The trapezoid is deleted from the edge table. This is
*         done by truncating downwards or removing either of the
*         highest two edges, according to the truncation flags.
*         If an edge is removed the peak edge at connecting it is
*         preserved by passing it on to the edge at its bottom.
*         If because of a trough this can't be done. The edge is
*         instead truncated downwards to zero length.
*         If an edge is truncated, it is moved to its new position
*         in the edge table ordering.
*
*    (9)  The the peak-change flag is on, the edge table is manipulated
*         to ensure that the peak edges are valid (ie, they connect
*         neighbouring edges). Also any two peak edges separated only
*         a pair of edges of zero length, they are joined together.
*
*   (10)  If no change has occured to the start (top) of the edge table,
*         report the no trapezoid was found to prevent infinite loop.
*
*  NOTE
*  ----
*    It is advisable to clip the edge table before sending to this
*    routine, so that time is not wasted on trapezoids that would be
*    clipped out of existence. This routine does not clip trapezoids
*    that cross the clipping boundary.
*
*    If an edge is deleted any pointer to it external to this routine
*    may still pick it up.
*---------------------------------------------------------------------

*     Find peak from which to extract trapezoid
*     (two edges containing the non-horizontal sides of trapezoid)
      CALL GKTZHP(NV,VX,VY,VXETT,IYETT,IETB,JETNXT,FOUND,JTZ)
*     Check for error
      IF(KERROR .NE. 0)THEN
         CALL GKBUG(-2004,'GKTZEX')
         GOTO 999
      ENDIF
*     Check to see if peak has been found to take trapezoid from
      IF(.NOT. FOUND)GOTO 999
*
*
      DO 5 ISIDE = 1,2
*        Note down details of edge to make them handy
         VXTOP(ISIDE) =  VXETT(JTZ(ISIDE))
         VYTOP        =  VY(IYETT(JTZ(ISIDE)))
         VXBOT(ISIDE) =  VX(IETB(JTZ(ISIDE)))
         VYBOT(ISIDE) =  VY(IETB(JTZ(ISIDE)))
         DEPTH = VYTOP - VYBOT(ISIDE)
         IF(DEPTH .GT. QTOL)THEN
            SLOPE(ISIDE) = (VXBOT(ISIDE)-VXTOP(ISIDE))/DEPTH
         ELSE
*           Error
            FOUND = .FALSE.
            GOTO 999
         ENDIF
    5 CONTINUE
*
*     Initialise Peak Change Flag
      PEAKCH = .FALSE.
*
*     Initialize first 4 edges - to check that they are in fact changed
*                                after trapezoid is removed.
      JOLD(1) = JTZ(1)
      JOLD(2) = JTZ(2)
      JOLD(3) = JETNXT(JOLD(2))
      JOLD(4) = JETNXT(JOLD(3))
      DO 50 I4=1,4
         IF(JOLD(I4) .GT. 0)THEN
            IBOLD(I4) = IETB(JOLD(I4))
            XOLD(I4) = VXETT(JOLD(I4))
            YOLD(I4) = VY(IYETT(JOLD(I4)))
         ELSE
            IBOLD(I4) = 0
            XOLD(I4) = 0.0
            YOLD(I4) = 0.0
         ENDIF
   50 CONTINUE
*
*     Determine Left and Right
      IF(VXTOP(1)+QTOL .LT. VXTOP(2))THEN
*        Top 1 left of top 2
         JLEFT  = 1
      ELSEIF(VXTOP(2)+QTOL .LT. VXTOP(1))THEN
*        Top 2 left of top 1
         JLEFT  = 2
      ELSEIF(SLOPE(1) .LT. SLOPE(2))THEN
*        Tops coincide and 1 slopes left of 2
         JLEFT = 1
      ELSE
*        Tops coincide and 2 slopes left of 1
         JLEFT = 2
      ENDIF
      JRIGHT = 3 - JLEFT

*     Set Upper Edge of trapezoid
      TZ(JUPLEX)  = VXTOP(JLEFT)
      TZ(JUPY)    = VYTOP
      TZ(JUPRIX)  = VXTOP(JRIGHT)
*     and initialize Y-level of provisional trapezoid base
      TZ(JLOY)    = VYBOT(1)

*     Set lower Y value of provisional Trapezoid (may be raised)
*     and the remove flags.
*     Defer setting of of lower X values of provisional Trapezoid.
      REMOVE(JLEFT)  = .TRUE.
      REMOVE(JRIGHT) = .TRUE.
      BXUPD          = .TRUE.
*     Base is not the intersection of the two sides
      BCROSS         = .FALSE.
      IF(VYBOT(JLEFT) .LT. VYBOT(JRIGHT)) THEN
         TZ(JLOY) = VYBOT(JRIGHT)
         REMOVE(JLEFT) = .FALSE.
         ITRIG = 2
      ELSEIF(VYBOT(JLEFT) .GT. VYBOT(JRIGHT))THEN
         TZ(JLOY) = VYBOT(JLEFT)
         REMOVE(JRIGHT)  = .FALSE.
         ITRIG = 1
      ELSE
         ITRIG = 0
      ENDIF
*
*
*  Is the base of the provional trapezoid below the clipping rectangle?
*  If yes, raise base of prov' trap' to it.
*
      IF(TZ(JLOY) .LT. YMIN)THEN
         TZ(JLOY) = YMIN
         REMOVE(1) = .FALSE.
         REMOVE(2) = .FALSE.
         ITRIG = 5
      ENDIF
*
*     Check depth of provisional trapezoid
      IF(TZ(JLOY) .GE. TZ(JUPY))THEN
         FOUND = .FALSE.
         GOTO 999
      ENDIF
*
*
*  Do any edges have their tops inside the provisional trapezoid?
*  If yes, raise base of prov' trap' to it.
*
*     Temporarily remove the two edges forming the trapezoid sides
      JETNXT(JTZ(0)) = JETNXT(JTZ(2))
      JPOSS = JETNXT(0)
*     Search edges in edge table ordering
      DO 110 J=1,NV+1
         JPOSS = JETNXT(JPOSS)
         IF(JPOSS .LE. 0) GOTO 111
         VXPTOP = VXETT(JPOSS)
         VYPTOP = VY(IYETT(JPOSS))
         DEPTH  = TZ(JUPY)-VYPTOP
         IF(DEPTH .GT. QTOL)THEN
            TZL    = TZ(JUPLEX) + SLOPE(JLEFT)*DEPTH
            TZR    = TZ(JUPRIX) + SLOPE(JRIGHT)*DEPTH
         ELSE
*           Ignore edge if at an upper corner of prov' trap'
            TZL    = TZ(JUPLEX) + QTOL
            TZR    = TZ(JUPRIX) - QTOL
            IF(TZL .GT. TZR) GOTO 110
         ENDIF
         IF(VYPTOP .GT. TZ(JLOY))THEN
            IF((TZL .LT. VXPTOP) .AND. (VXPTOP .LT. TZR))THEN
*           Such an edge has been found, raise base to it and quit loop.
               TZ(JLOY) = VYPTOP
               PEAKCH = .TRUE.
               REMOVE(1) = .FALSE.
               REMOVE(2) = .FALSE.
               ITRIG = 15
*              We have the X-coords of base, so might as well update
               TZ(JLOLEX) = TZL
               TZ(JLORIX) = TZR
               BXUPD = .FALSE.
*              Check depth of provisional trapezoid
               IF(TZ(JLOY) .GE. TZ(JUPY))THEN
                  PEAKCH = .TRUE.
               ENDIF
               GOTO 111
            ELSEIF(TZR .LT. TZL)THEN
*           The two sides of the provisional trapezoid have crossed,
*              raise base and quit loop.
               TZ(JLOY) = VYPTOP
*              Base not final, X-coords not updated now
               BXUPD = .TRUE.
               BCROSS = .TRUE.
               REMOVE(1) = .FALSE.
               REMOVE(2) = .FALSE.
               PEAKCH = .FALSE.
               ITRIG = 10
*              Check depth of provisional trapezoid
               IF(TZ(JLOY) .GE. TZ(JUPY))THEN
                  FOUND = .FALSE.
                  GOTO 999
               ENDIF
               GOTO 111
            ENDIF
         ELSE
*        Now below base - quit loop
            GOTO 111
         ENDIF
  110 CONTINUE
  111 CONTINUE
*     Put temporily removed edges back
      JETNXT(JTZ(0)) = JTZ(1)
*
*
*
*  Do any peak edges intersect the left of right sides of the
*  provisional trapezoid (if yes, raise base to peak edge)
*
*     Temporarily remove the two edges forming the trapezoid sides.
      JETNXT(JTZ(0)) = JETNXT(JTZ(2))
*     For each side
      DO 220 ISIDE=1,2
         JPOSS = 0
*        Search the other edges
         DO 210 J=2,NV
            LPOSS = JPOSS
            JPOSS = JETNXT(LPOSS)
            IF(JPOSS .LE. 0)GOTO 220
            VYPTOP = VY(IYETT(JPOSS))
            IF(VYPTOP .LT. TZ(JLOY))GOTO 220
            VXLTOP = VXETT(LPOSS)
            VXPTOP = VXETT(JPOSS)
            IF(IYETT(LPOSS) .EQ. IYETT(JPOSS))THEN
*           Peak edge found
*              Find left and Right
               IF(VXLTOP .LE. VXPTOP)THEN
                  JPL = LPOSS
                  JPR = JPOSS
               ELSE
                  JPL = JPOSS
                  JPR = LPOSS
               ENDIF
               DEPTH = TZ(JUPY) - VYPTOP
               TZI = VXTOP(ISIDE) + SLOPE(ISIDE)*DEPTH
               CROSS = .FALSE.
               IF(ABS(VXETT(JPL)-TZI) .LE. QTOL)THEN
                  IF(ABS(VXETT(JPR)-TZI) .LE. QTOL)THEN
*                 Side intersects a Peak
                     CALL GKTZSL(JTZ(ISIDE),JPL,
     :                           NV,VX,VY,VXETT,IYETT,IETB,CROSS)
                     IF(CROSS)THEN
                        CALL GKTZSL(JPR,JTZ(ISIDE),
     :                              NV,VX,VY,VXETT,IYETT,IETB,CROSS)
                     ENDIF
                  ELSE
*                 Side intersects left end of Peak Edge
                     IF(ISIDE .EQ. JRIGHT)THEN
                        CALL GKTZSL(JTZ(JRIGHT),JPL,
     :                              NV,VX,VY,VXETT,IYETT,IETB,CROSS)
                     ELSE
                        CROSS = ((TZ(JUPLEX) .LT. TZ(JUPRIX)) .OR.
     :                           (TZ(JUPY) .GT. VY(IYETT(JPOSS))))
                     ENDIF
                  ENDIF
               ELSEIF(ABS(VXETT(JPR)-TZI) .LE. QTOL)THEN
*              Side intersects right end of peak edge
                  IF(ISIDE .EQ. JLEFT)THEN
                     CALL GKTZSL(JPR,JTZ(JLEFT),
     :                           NV,VX,VY,VXETT,IYETT,IETB,CROSS)
                  ELSE
                     CROSS = ((TZ(JUPLEX) .LT. TZ(JUPRIX)) .OR.
     :                        (TZ(JUPY) .GT. VY(IYETT(JPOSS))))
                  ENDIF
               ELSEIF((VXETT(JPL) .LT. TZI) .AND.
     :                (TZI .LT. VXETT(JPR)))THEN
*              Side intersects peak edge interior
                  CROSS = .TRUE.
               ENDIF
               IF(CROSS)THEN
*                 Raise base of provisional trapezoid to crossing
                  TZ(JLOY) = VY(IYETT(JPOSS))
                  BXUPD = .TRUE.
                  BCROSS = .FALSE.
                  PEAKCH = .TRUE.
                  REMOVE(1) = .FALSE.
                  REMOVE(2) = .FALSE.
                  ITRIG = 21 + IABS(ISIDE-JLEFT)
*                 Check depth of provisional trapezoid
                  IF(TZ(JLOY) .GE. TZ(JUPY))THEN
                  ENDIF
               ENDIF
            ENDIF
  210    CONTINUE
  220 CONTINUE
*     Put the temporarily removed edges back.
      JETNXT(JTZ(0)) = JTZ(1)
*
*
*  Do any edges intersect the left or right of the
*  provisional trapezoid (if yes, raise base to intersection)
*
      DO 320 ISIDE=1,2
        JPOSS = 0
        DO 310 J=ISIDE,NV+1
          JPOSS = JETNXT(JPOSS)
          IF(JPOSS .EQ. JTZ(ISIDE))THEN
*         Skip self-same edge
             JPOSS = JETNXT(JPOSS)
          ENDIF
          IF(JPOSS .LE. 0) GOTO 320
*         Determine common Y-range, go to next edge if non-existent
          VYPTOP = VY(IYETT(JPOSS))
          IF(VYPTOP .LE. TZ(JLOY)) GOTO 320
          VYPBOT = VY(IETB(JPOSS))
          IF(VYPTOP .LT. VYPBOT) GOTO 310
*         Determine intersection
          E1X(1) = VXTOP(ISIDE)
          E1Y(1) = VYTOP
          E1X(2) = VXBOT(ISIDE)
          E1Y(2) = VYBOT(ISIDE)
          E2X(1) = VXETT(JPOSS)
          E2Y(1) = VY(IYETT(JPOSS))
          E2X(2) = VX(IETB(JPOSS))
          E2Y(2) = VY(IETB(JPOSS))
          CALL GKQLNI (E1X,E1Y,E2X,E2Y,CROSS,COLLIN,ECX,ECY)
          IF(CROSS .AND. .NOT.COLLIN)THEN
*         Non-Collinear Intersection has been found.
*            Raise base of provisional trapezoid to it,
             IF(ECY(1) .GT. TZ(JLOY))THEN
*            Crossing above base of provisional trapezoid
                IF(TZ(JUPY)-ECY(1) .GT. QTOL)THEN
*               Crossing not at top.
                  TZ(JLOY) = ECY(1)
                  BXUPD = .TRUE.
                  BCROSS = (IYETT(JPOSS) .EQ. IYETT(JTZ(1)))
*                 Set both edges not to be removed
                  REMOVE(1) = .FALSE.
                  REMOVE(2) = .FALSE.
*                 Reset peak change flag
                  PEAKCH = .FALSE.
                  ITRIG = 31 + IABS(ISIDE-JLEFT)
*                 Check depth of provisional trapezoid
                  IF(TZ(JLOY) .GE. TZ(JUPY))THEN
                     FOUND = .FALSE.
                     GOTO 999
                  ENDIF
                ENDIF
             ENDIF
          ENDIF
  310   CONTINUE
*       Edge Table Invalid - Sorted ordering should have ended with 0.
        CALL GKBUG(-2004,'GKTZEX')
        FOUND = .FALSE.
        GOTO 999
  320 CONTINUE

  500 CONTINUE
*
*     Here the base of the trapezoid is finalised

*     Set Lower Left and Right X-coords of Trapezoid, if necessary.
      IF(BXUPD)THEN
         TZ(JLOLEX) = TZ(JUPLEX)+(SLOPE(JLEFT))*(TZ(JUPY)-TZ(JLOY))
         IF(BCROSS)THEN
           TZ(JLORIX) = TZ(JLOLEX)
         ELSE
           TZ(JLORIX) = TZ(JUPRIX)+(SLOPE(JRIGHT))*(TZ(JUPY)-TZ(JLOY))
         ENDIF
      ENDIF

*     Remove Trapeziod from Edge Table
      IF((REMOVE(1) .AND. REMOVE(2)) .AND.
     :   (IETB(JTZ(1)) .EQ. IETB(JTZ(2))) )THEN
*     Remove two edges joined at bottom
         JETNXT(0) = JETNXT(JTZ(2))
      ELSE
*     Truncate both edges, then remove as required, preserving peak edge.
         IF(JLEFT .EQ. 1)THEN
            JLO1X = JLOLEX
            JLO2X = JLORIX
         ELSE
            JLO1X = JLORIX
            JLO2X = JLOLEX
         ENDIF
         CALL GKTZTP(JTZ(0),TZ(JLO1X),TZ(JLO2X),TZ(JLOY),
     :               NV,VY,VXETT,IYETT,IETB,JETNXT)
         IF(REMOVE(1))THEN
            CALL GKTZRE(JTZ(1),NV,VX,VY,VXETT,IYETT,IETB,JETNXT)
         ENDIF
         IF(REMOVE(2))THEN
            CALL GKTZRE(JTZ(2),NV,VX,VY,VXETT,IYETT,IETB,JETNXT)
         ENDIF
      ENDIF
*
*     Escape if error
      IF(KERROR .NE. 0)THEN
        FOUND = .FALSE.
        GOTO 999
      ENDIF

*     If necessary, ensure that the peak edges, implied by the edge
*     table are valid.
      IF(PEAKCH)THEN
         CALL GKTZVP(NV,VX,VY,VXETT,IYETT,IETB,JETNXT)
         PEAKCH = .FALSE.
      ENDIF

*
*     Count trapezoid as FOUND, only if
*     at least one of the first four edges on the edge table
*     has changed in
*     edge index, top vertex position or bottom vertex index.
      JNEW(1) = JETNXT(0)
      JNEW(2) = JETNXT(JNEW(1))
      JNEW(3) = JETNXT(JNEW(2))
      JNEW(4) = JETNXT(JNEW(3))
      FOUND = (JNEW(1) .NE. JOLD(1))
      FOUND = FOUND .OR. (JNEW(2) .NE. JOLD(2))
      IF(.NOT. FOUND)THEN
         FOUND = (JNEW(3) .NE. JOLD(3))
         FOUND = FOUND .OR. (JNEW(4) .NE. JOLD(4))
         IF(.NOT. FOUND)THEN
            DO 950 I4=1,4
               IF(JNEW(I4) .EQ. 0)GOTO 951
               FOUND = (IETB(JNEW(I4)) .NE. IBOLD(I4))
               IF(FOUND)GOTO 951
               FOUND = ((ABS(VXETT(JNEW(I4))-XOLD(I4)) .GT. QTOL)
     :          .OR. (ABS(VY(IYETT(JNEW(I4)))-YOLD(I4)) .GT. QTOL))
               IF(FOUND) GOTO 951
  950       CONTINUE
  951       CONTINUE
         ENDIF
      ENDIF
*
*     We could have just tested whether the Edge table is empty,
*     ie, JETNXT(0) = 0, but a scricter condition is used,
*     in case there is a bug.
*
*     Also, Trapezoid should have top above base of clipping rectangle
      FOUND = FOUND .AND. (TZ(JUPY) .GT. YMIN)

  999 CONTINUE
      END
