      SUBROUTINE FTS1_WKEY<T>( NCARD, BUFFER, STCARD, NAME, VALUE,
     :                         CMTBGN, COMNT, THERE, CARD, STATUS )
*+
*  Name:
*     FTS1_WKEYx

*  Purpose:
*     Write the value of type <COMM> to the specified keyword from a
*     buffer of FITS-header card images.

*  Language:
*     Starlink Fortran 77

*  Invocation:
*     CALL FTS1_WKEYx( NCARD, BUFFER, STCARD, NAME, CMTBGN, THERE,
*                      VALUE, COMNT, CARD, STATUS )

*  Description:
*     This routine searches a buffer containing the header card images
*     from a FITS file for card with keyword %NAME; and, if found,
*     override its original value with the given value %VALUE of type
*     <COMM>.  The keyword can have a comment string leading by the
*     character specified by %CMTBGN.  The search ends when the next
*     end of a header block, marked by the END keyword, is encountered
*     or the buffer is exhausted.  If the keyword is present %THERE is
*     true, otherwise it is false.  If the parameter is present more
*     than once in the header, only the first occurence will be used.
*
*     The name may be compound to permit writing of hierarchical
*     keywords. 
*
*     The buffer of FITS header card image should be mapped in the
*     'UPDATE' mode.
*     
*  Arguments:
*     NCARD = INTEGER (Given)
*        The number of card images in the buffer.
*     BUFFER( NCARD ) = CHARACTER * ( * ) (Given)
*        The buffer containing the header card images.
*     STCARD = INTEGER (Given)
*        The number of the card from which to start search.
*     NAME = CHARACTER *( * ) (Given)
*        The name of the keyword to be written a new value.  This may be
*        a compound name to handle hierarchical keywords, and it has the
*        form keyword1.keyword2.keyword3 etc.  The maximum number of
*        keywords per FITS card is 20.  Comparisons are performed in
*        uppercase and blanks are removed.  Each keyword must be no
*        longer than 8 characters.  The total length must not exceed
*        48 characters.  This is to allow for the value, and indentation
*        into a blank-keyword card (as hierarchical keywords are not
*        standard and so cannot be part of the standard keyword name).
*     VALUE = <TYPE> (Given)
*        The value to be used to override the original value of the
*        keyword.
*     CMTBGN = CHARACTER * ( 1 ) (Given)
*        The character which indicates the beginning of the comment
*        string of to be appended to the keyword.  Normally it is '/'.
*        when it is blank, no comment will be appended to the keyword.
*     COMNT = CHARACTER * ( * ) (Returned)
*        The comment string of the keyword.  It may be truncated at the
*        end to put into the space left after writing keyword value. 
*     THERE = LOGICAL (Returned)
*        If true, the specified keyword is present.
*     CARD = INTEGER (Returned)
*        The number of the last continuation comment card whose contents
*        are included in the returned string.
*     STATUS = INTEGER (Given and Returned)
*        The global status.

*  Implementation Status:
*     - There is a routine for each of the data types logical, integer,
*     real and double precision: replace "x" in the routine name by L,
*     I, R or D as appropriate.

*  Authors:
*     WG: Wei Gong (IPMAF)
*     MJC: Malcolm J. Currie (STARLINK)
*     {enter_new_authors_here}

*  History:
*     9-SEP-1991 (WG):
*        Original version.
*     1994 July 16 (MJC):
*        Renamed and tidied.  Fixed violations of the Fortran standard
*        for appending to character-strings.  Fixed bugs that made
*        comments and values uppercase, filtered the comments, and
*        positioned the comment string in the wrong location.  Used
*        parameters to define lengths of the parts of a FITS header
*        card.  Does not attempt to write a blank comment.

*     {enter_changes_here}

*  Bugs:
*     {note_any_bugs_here}

*-
      
*  Type Definitions:
      IMPLICIT NONE              ! No implicit typing

*  Global Constants:
      INCLUDE 'SAE_PAR'          ! Standard SAE constants

*  Arguments Given:
      INTEGER NCARD
      CHARACTER * ( 80 ) BUFFER( NCARD )
      INTEGER STCARD
      CHARACTER * ( * ) NAME
      <TYPE> VALUE
      CHARACTER * ( 1 ) CMTBGN
      CHARACTER * ( * ) COMNT

*  Arguments Returned:
      LOGICAL THERE
      INTEGER CARD

*  Status:
      INTEGER STATUS             ! Global status

*  External References:
      INTEGER CHR_LEN            ! The used length of a string

*  Local Constants:
      INTEGER COMCOL             ! Minimum column position for the start
                                 ! of a FITS comment
      PARAMETER ( COMCOL = 32 )

      INTEGER COMLN              ! Maximum number of characters in a
                                 ! FITS header card comment
      PARAMETER ( COMLN = 47 )

      INTEGER HKEYLN             ! Maximum number of characters in a
                                 ! FITS header card hierarchical keyword
      PARAMETER ( HKEYLN = 48 )

      INTEGER KEYLN              ! Maximum number of characters in a
                                 ! FITS header card keyword or
                                 ! hierarchical component thereof
      PARAMETER ( KEYLN = 8 )

      INTEGER MXWORD             ! Maximum number of hierarchical levels
                                 ! in a keyword
      PARAMETER ( MXWORD = 20 )

      INTEGER VALLN              ! Maximum number of characters in a
                                 ! FITS header card value
      PARAMETER ( VALLN = 70 )

*  Local Variables:
      INTEGER CARDLN             ! Used length of a card image
      INTEGER CDKYLN             ! Length of the keyword of a card
      CHARACTER * ( HKEYLN ) CMPKEY ! Compound name
      INTEGER CMPLN              ! Length of compound name
      CHARACTER * ( COMLN ) CMTSTR ! Comment string of a keyword
      LOGICAL COMPND             ! Compound-keyword flag
      CHARACTER * ( KEYLN ) CRDKEY ! Keyword of a card image
      INTEGER ENDW( MXWORD )     ! End column of each keyword
      INTEGER EQUALS             ! The position of equal sign
      INTEGER I                  ! Do loop indicator
      INTEGER KEYLEN             ! Length of specified keyword
      CHARACTER * ( HKEYLN ) KEYWRD  ! Specified keyword
      INTEGER LSTAT              ! Local status
      INTEGER NWORD              ! Number of keywords in a card image
      INTEGER STARTW( MXWORD )   ! Start column of each keyword
      CHARACTER * ( VALLN ) VALSTR ! String expression of keyword value
      INTEGER WORDLN             ! Length of each word
      CHARACTER * ( KEYLN ) WORDS( MXWORD ) ! Keywords in a card image
      INTEGER VALN               ! Length of the keyword value

*.

*  Check the inherited global status.
      IF ( STATUS .NE. SAI__OK ) RETURN

*  Remove blanks from the keyword to be searched.  Change the keyword to
*  uppercase and get its used length.
      KEYWRD = NAME
      CALL CHR_RMBLK( KEYWRD )
      CALL CHR_UCASE( KEYWRD )
      KEYLEN = CHR_LEN( KEYWRD )

*  Initialise the card number to be examined, and the found flag.
      CARD = MAX( 1, STCARD )
      THERE = .FALSE.

*  To see whether it is a compound name.
      COMPND = INDEX( KEYWRD, '.' ) .NE. 0

*  If the keyword to be searched for is not compound, ...
      IF ( .NOT. COMPND ) THEN

*  Compare the keyword on each card with the given keyword, until the
*  required card is found, or the 'END' card is met, or no card is left.
         DO WHILE ( ( .NOT. THERE ) .AND. ( CARD .LE. NCARD ) .AND.
     :              ( BUFFER( MIN( NCARD, CARD ) )( :3 ) .NE. 'END' ) )

*  Get the keyword of this card image, and its used length.
            CRDKEY = BUFFER( CARD )( :8 )
            CDKYLN = CHR_LEN( CRDKEY )

*  If the current card is the required keyword, ...
            IF ( CRDKEY( :CDKYLN ) .EQ. KEYWRD( :KEYLEN ) ) THEN

*  Set the found flag and get the position of the equals sign.
               THERE = .TRUE.
               EQUALS = INDEX( BUFFER( CARD ), '=' )
      
*  Otherwise go to the next card in the buffer.
            ELSE
               CARD = CARD + 1
            END IF
         END DO

*  If the keyword to be searched for is compound, ...
      ELSE

*  Get the keywords on the card and compare with given one, until the
*  required card is found, or the 'END' card is met, or no card is left.
         DO WHILE ( ( .NOT. THERE ) .AND. ( CARD .LE. NCARD ) .AND.
     :              ( BUFFER( MIN( NCARD, CARD ) )( :3 ) .NE. 'END' ) )

*  Keywords are located between the first character and the equals
*  sign.  So find the position of the equals sign first.
            EQUALS = INDEX( BUFFER( CARD ), '=' )

*  Then if the equals sign exists, extract the words from the FITS
*  card image.
            IF ( EQUALS .NE. 0 ) THEN
               CALL CHR_DCWRD( BUFFER( CARD )( :EQUALS - 1 ), MXWORD,
     :                         NWORD, STARTW, ENDW, WORDS, LSTAT )

*  Form the compound keyword by concatenating the words via the
*  delimiter.
               CMPLN = 0
               CMPKEY = ' '
               DO I = 1, NWORD
                  WORDLN = ENDW( I ) - STARTW( I ) + 1
                  CALL CHR_PUTC( WORDS( I )( :WORDLN ), CMPKEY, CMPLN )
                  IF( I .NE. NWORD ) CALL CHR_PUTC( '.', CMPKEY, CMPLN )
               END DO

*  Compare the (compound) keyword of the current card with that of the
*  compound keyword to be searched. If it is found, set the found flag.
               IF ( CMPKEY( :CMPLN ) .EQ. KEYWRD( :KEYLEN ) ) THEN
                  THERE = .TRUE.

*  Otherwise, go to the next card in the buffer.
               ELSE
                  CARD = CARD + 1
               END IF

*  If this card does not contain the equal sign, go to the next card.
            ELSE
               CARD = CARD + 1
            END IF
         END DO
      END IF

*  If the keyword is found, form the new image card.
      IF ( THERE ) THEN

*  Format the value string.
         CALL CHR_<T>TOC( VALUE, VALSTR, VALN )
         
*  See if there is any error during formation.
         IF ( VALSTR( : VALN ) .EQ. '*' ) THEN
            STATUS = SAI__ERROR
            CALL ERR_REP( 'FTS1_WKEY<T>_TYPCNV',
     :                    'Unable to convert the given value to '/
     :                   /'desired type.', STATUS )
            GOTO 999
         END IF

*  Blank out the previous value.
         BUFFER( CARD )( EQUALS + 1:EQUALS + COMCOL - KEYLN - 3 ) = ' '

*  Insert the new value, right justified.
         BUFFER( CARD )( COMCOL-1-VALN:COMCOL-2 ) = VALSTR( :VALN )

*  By definition the used length is 30.
         CARDLN = COMCOL - 2

*  If there is a comment string following keyword value, ...
         IF ( CMTBGN .NE. ' ' .AND. COMNT .NE. ' ' ) THEN
            CMTSTR = COMNT

*  If the length is less the minimum, pad the card with blanks to the
*  minimum length.  The comment cannot begin before the minimum length
*  of a non-character value, and so allowing for the space the comment
*  must not appear until two columns after this.
            CARDLN = MAX( CARDLN, COMCOL - 2 ) + 1

*  Append the comment string to the card, or as much as can fit on to
*  the card.  Notice that leading blanks are not removed from the
*  comment in case the user is attempting some clever alignment.  Since
*  a FITS comment may contain any ASCII character, it has not been
*  cleaned.
            CALL CHR_APPND( CMTBGN//' '//CMTSTR, BUFFER( CARD ),
     :                      CARDLN )
         END IF
      
      END IF

 999  CONTINUE

      END
