*+   ELNMB<T> - Write a range of element numbers into an array

      SUBROUTINE ELNMB<T>( X1, X2, ODIM, OUTARR, STATUS )
*
*    Description :
*
*     This routine writes numbers sequentially to a <COMM> 1-d
*     array, where the numbers are between defined integer limits and
*     are stepped by 1 from one pixel to the next.  In other words
*     the array value takes the element number plus an offset.
*     Only the first %ODIM elements can be accommodated in the output
*     array, should the section be larger than this.
*
*    Invocation :
*
*     CALL ELNMB<T>( X1, X2, ODIM, OUTARR, STATUS )
*
*    Arguments :
*
*     X1 = INTEGER( READ )
*         The first value to be written to the output array
*     X2 = INTEGER( READ )
*         The last value to be written to the output array
*     ODIM = INTEGER( READ )
*         The number of elements in the output array
*     OUTARR( ODIM ) = <TYPE>( WRITE )
*         The array into which the sub-array is copied.
*     STATUS = INTEGER( READ )
*         The status value on entry to this routine.
*
*    Method :
*
*     Check for error on entry - return if not o.k.
*     The maximum and minimum extents of the sub-array are found
*        and the maximum is constrained by the dimension of the output
*        array
*     The values are written to the output array, converting to the
*       appropriate type
*     End
*
*    Authors :
*
*     Malcolm J. Currie STARLINK ( RAL::CUR )
*
*    History :
*
*     1988 Oct 25 : Original ( RAL::CUR )
*
*    Type Definitions :

      IMPLICIT NONE            ! No assumed typing

*    Global Constants :

      INCLUDE 'SAE_PAR'        ! Global SSE definitions

*    Import :

      INTEGER
     :    ODIM,
     :    X1,
     :    X2

*    Export :

      <TYPE> OUTARR( ODIM )

*    External references :

      INCLUDE 'DCV_EXT'       ! Data-conversion external functions

*    Status :

      INTEGER STATUS

*    Local variables :

      INTEGER
     :  I, J,                  ! Counters
     :  LOWER,                 ! Lower bound of the sub-array
     :  UPPER                  ! Upper bound of the sub-array

*    Internal references :

      INCLUDE 'DCV_FUN'       ! Data-conversion statement functions

*-

*    If status value is bad, then return immediately

      IF ( STATUS .NE. SAI__OK ) RETURN

*    Copy input co-ordinates in case they are transposed

      LOWER = MIN( X1, X2 )
      UPPER = MAX( X1, X2 )

*    Only store as many values as can be accommodated

      UPPER = MIN( UPPER, ODIM + LOWER - 1 )

*    Copy the elements of the sub-array

      J = 0
      DO  I = LOWER, UPPER, 1
         J = J + 1
         OUTARR( J ) = DCV_ITO<T>( I )
      END DO

      END
