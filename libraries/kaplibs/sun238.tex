\documentstyle[11pt]{article}
\pagestyle{myheadings}

% -----------------------------------------------------------------------------
% ? Document identification
\newcommand{\stardoccategory}  {Starlink User Note}
\newcommand{\stardocinitials}  {SUN}
\newcommand{\stardocsource}    {sun\stardocnumber}
\newcommand{\stardocnumber}    {238.4}
\newcommand{\stardocauthors}   {D.S. Berry}
\newcommand{\stardocdate}      {16th March 2004}
\newcommand{\stardoctitle}     {KAPLIBS \\ [1ex]
                                Internal subroutines used within\\
                                the KAPPA package.}
\newcommand{\stardocversion}   {Version 2.7}
\newcommand{\stardocmanual}    {Programmer's Reference}
\newcommand{\stardocabstract}  {KAPLIBS is a package of Fortran subroutine 
libraries which were originally written as part of the KAPPA package (a
package of general purpose image processing and visualization tools).
KAPLIBS provides software developers with access to many of the internal
KAPPA routines, so that KAPPA-like applications can be written and built
independently of KAPPA.}

% ? End of document identification

% -----------------------------------------------------------------------------

\newcommand{\stardocname}{\stardocinitials /\stardocnumber}
\markright{\stardocname}
\setlength{\textwidth}{160mm}
\setlength{\textheight}{230mm}
\setlength{\topmargin}{-2mm}
\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\setlength{\unitlength}{1mm}

% -----------------------------------------------------------------------------
%  Hypertext definitions.
%  ======================
%  These are used by the LaTeX2HTML translator in conjunction with star2html.

%  Comment.sty: version 2.0, 19 June 1992
%  Selectively in/exclude pieces of text.
%
%  Author
%    Victor Eijkhout                                      <eijkhout@cs.utk.edu>
%    Department of Computer Science
%    University Tennessee at Knoxville
%    104 Ayres Hall
%    Knoxville, TN 37996
%    USA

%  Do not remove the %\begin{rawtex} and %\end{rawtex} lines (used by 
%  star2html to signify raw TeX that latex2html cannot process).
%\begin{rawtex}
\makeatletter
\def\makeinnocent#1{\catcode`#1=12 }
\def\csarg#1#2{\expandafter#1\csname#2\endcsname}

\def\ThrowAwayComment#1{\begingroup
    \def\CurrentComment{#1}%
    \let\do\makeinnocent \dospecials
    \makeinnocent\^^L% and whatever other special cases
    \endlinechar`\^^M \catcode`\^^M=12 \xComment}
{\catcode`\^^M=12 \endlinechar=-1 %
 \gdef\xComment#1^^M{\def\test{#1}
      \csarg\ifx{PlainEnd\CurrentComment Test}\test
          \let\html@next\endgroup
      \else \csarg\ifx{LaLaEnd\CurrentComment Test}\test
            \edef\html@next{\endgroup\noexpand\end{\CurrentComment}}
      \else \let\html@next\xComment
      \fi \fi \html@next}
}
\makeatother

\def\includecomment
 #1{\expandafter\def\csname#1\endcsname{}%
    \expandafter\def\csname end#1\endcsname{}}
\def\excludecomment
 #1{\expandafter\def\csname#1\endcsname{\ThrowAwayComment{#1}}%
    {\escapechar=-1\relax
     \csarg\xdef{PlainEnd#1Test}{\string\\end#1}%
     \csarg\xdef{LaLaEnd#1Test}{\string\\end\string\{#1\string\}}%
    }}

%  Define environments that ignore their contents.
\excludecomment{comment}
\excludecomment{rawhtml}
\excludecomment{htmlonly}
%\end{rawtex}

%  Hypertext commands etc. This is a condensed version of the html.sty
%  file supplied with LaTeX2HTML by: Nikos Drakos <nikos@cbl.leeds.ac.uk> &
%  Jelle van Zeijl <jvzeijl@isou17.estec.esa.nl>. The LaTeX2HTML documentation
%  should be consulted about all commands (and the environments defined above)
%  except \xref and \xlabel which are Starlink specific.

\newcommand{\htmladdnormallinkfoot}[2]{#1\footnote{#2}}
\newcommand{\htmladdnormallink}[2]{#1}
\newcommand{\htmladdimg}[1]{}
\newenvironment{latexonly}{}{}
\newcommand{\hyperref}[4]{#2\ref{#4}#3}
\newcommand{\htmlref}[2]{#1}
\newcommand{\htmlimage}[1]{}
\newcommand{\htmladdtonavigation}[1]{}

%  Starlink cross-references and labels.
\newcommand{\xref}[3]{#1}
\newcommand{\xlabel}[1]{}

%  LaTeX2HTML symbol.
\newcommand{\latextohtml}{{\bf LaTeX}{2}{\tt{HTML}}}

%  Define command to re-centre underscore for Latex and leave as normal
%  for HTML (severe problems with \_ in tabbing environments and \_\_
%  generally otherwise).
\newcommand{\latex}[1]{#1}
\newcommand{\setunderscore}{\renewcommand{\_}{{\tt\symbol{95}}}}
\latex{\setunderscore}

%  Redefine the \tableofcontents command. This procrastination is necessary 
%  to stop the automatic creation of a second table of contents page
%  by latex2html.
\newcommand{\latexonlytoc}[0]{\tableofcontents}

% -----------------------------------------------------------------------------
%  Debugging.
%  =========
%  Remove % on the following to debug links in the HTML version using Latex.

% \newcommand{\hotlink}[2]{\fbox{\begin{tabular}[t]{@{}c@{}}#1\\\hline{\footnotesize #2}\end{tabular}}}
% \renewcommand{\htmladdnormallinkfoot}[2]{\hotlink{#1}{#2}}
% \renewcommand{\htmladdnormallink}[2]{\hotlink{#1}{#2}}
% \renewcommand{\hyperref}[4]{\hotlink{#1}{\S\ref{#4}}}
% \renewcommand{\htmlref}[2]{\hotlink{#1}{\S\ref{#2}}}
% \renewcommand{\xref}[3]{\hotlink{#1}{#2 -- #3}}
% -----------------------------------------------------------------------------
% ? Document specific \newcommand or \newenvironment commands.
\newcommand{\latexonlysection}[1]{\section{#1}}
\newcommand{\latexonlysubsection}[1]{\subsection{#1}}
\newcommand{\latexonlysubsubsection}[1]{\subsubsection{#1}}
\begin{htmlonly}
   \newcommand{\latexonlysection}[1]{#1}
   \newcommand{\latexonlysubsection}[1]{#1}
   \newcommand{\latexonlysubsubsection}[1]{#1}
\end{htmlonly}
\newcommand{\st}[1]{{\em{#1}}}
\newcommand{\hi}[1]{{\tt{#1}}}
\newcommand{\latexelsehtml}[2]{#1}
\begin{htmlonly}
  \renewcommand{\latexelsehtml}[2]{#2}
\end{htmlonly}

% ? End of document specific commands
% -----------------------------------------------------------------------------
%  Title Page.
%  ===========
\renewcommand{\thepage}{\roman{page}}
\begin{document}
\thispagestyle{empty}

%  Latex document header.
%  ======================
\begin{latexonly}
   CCLRC / {\sc Rutherford Appleton Laboratory} \hfill {\bf \stardocname}\\
   {\large Particle Physics \& Astronomy Research Council}\\
   {\large Starlink Project\\}
   {\large \stardoccategory\ \stardocnumber}
   \begin{flushright}
   \stardocauthors\\
   \stardocdate
   \end{flushright}
   \vspace{-4mm}
   \rule{\textwidth}{0.5mm}
   \vspace{5mm}
   \begin{center}
   {\Huge\bf  \stardoctitle \\ [2.5ex]}
   {\LARGE\bf \stardocversion \\ [4ex]}
   {\Huge\bf  \stardocmanual}
   \end{center}
   \vspace{5mm}

% ? Heading for abstract if used.
   \vspace{10mm}
   \begin{center}
      {\Large\bf Abstract}
   \end{center}
% ? End of heading for abstract.
\end{latexonly}

%  HTML documentation header.
%  ==========================
\begin{htmlonly}
   \xlabel{}
   \begin{rawhtml} <H1> \end{rawhtml}
      \stardoctitle\\
      \stardocversion\\
      \stardocmanual
   \begin{rawhtml} </H1> \end{rawhtml}

% ? Add picture here if required.
% ? End of picture

   \begin{rawhtml} <P> <I> \end{rawhtml}
   \stardoccategory \stardocnumber \\
   \stardocauthors \\
   \stardocdate
   \begin{rawhtml} </I> </P> <H3> \end{rawhtml}
      \htmladdnormallink{CCLRC}{http://www.cclrc.ac.uk} /
      \htmladdnormallink{Rutherford Appleton Laboratory}
                        {http://www.cclrc.ac.uk/ral} \\
      \htmladdnormallink{Particle Physics \& Astronomy Research Council}
                        {http://www.pparc.ac.uk} \\
   \begin{rawhtml} </H3> <H2> \end{rawhtml}
      \htmladdnormallink{Starlink Project}{http://star-www.rl.ac.uk/}
   \begin{rawhtml} </H2> \end{rawhtml}
   \htmladdnormallink{\htmladdimg{source.gif} Retrieve hardcopy}
      {http://star-www.rl.ac.uk/cgi-bin/hcserver?\stardocsource}\\

%  HTML document table of contents. 
%  ================================
%  Add table of contents header and a navigation button to return to this 
%  point in the document (this should always go before the abstract \section). 
  \label{stardoccontents}
  \begin{rawhtml} 
    <HR>
    <H2>Contents</H2>
  \end{rawhtml}
  \renewcommand{\latexonlytoc}[0]{}
  \htmladdtonavigation{\htmlref{\htmladdimg{contents_motif.gif}}
        {stardoccontents}}

% ? New section for abstract if used.
  \section{\xlabel{abstract}Abstract}
% ? End of new section for abstract
\end{htmlonly}

% -----------------------------------------------------------------------------
% ? Document Abstract. (if used)
%  ==================
\stardocabstract
% ? End of document abstract
% -----------------------------------------------------------------------------
% ? Latex document Table of Contents (if used).
%  ===========================================
 \newpage
 \begin{latexonly}
   \setlength{\parskip}{0mm}
   \latexonlytoc
   \setlength{\parskip}{\medskipamount}
   \markright{\stardocname}
 \end{latexonly}
% ? End of Latex document table of contents
% -----------------------------------------------------------------------------
\cleardoublepage
\renewcommand{\thepage}{\arabic{page}}
\setcounter{page}{1}

\section {Introduction}

KAPPA is package of general purpose astronomical image processing and
visualization commands. It is documented in \xref{SUN/95}{sun95}{}. Over
the long history of the KAPPA package, many internal Fortran subroutines
have been written to provide facilities within KAPPA which have
subsequently proved to be of more general use outside KAPPA. In order to
gain the benefit of these internal KAPPA facilities, software developers
have in the past taken copies of the relevant routines and included them
in their own projects. The disadvantages of this are obvious - it is easy
to end up with many, potentially different, copies of the same routines
within a large software suite such as the Starlink Software Collection,
and bug fixes need to be implemented in many different places, rather
than a in single master copy.

Another way of using the internal KAPPA routines is to link your
applications directly against the libraries in the KAPPA package, but
this requires the KAPPA package to be installed anywhere where your
software is to be built, which is not always convenient.

To get round these problems, the KAPLIBS package was created to
contain the internal routines from KAPPA which are deemed to be
``generally useful''. Now, you only need to have KAPLIBS installed to
build your software, not the much larger KAPPA.

There are a large number of routines in KAPLIBS, making it potentially
difficult to find the routines you want. To ease this problem, a search
tool is provided which allows the contents of this document to be
searched (see \hyperref{here}{section }{}{SEC:SEARCH}).

\subsection{Stability of the KAPLIBS Interface}
KAPLIBS was created as a pragmatic solution to the problem of
proliferation of KAPPA source code in several other packages. One of the
reasons for previously keeping these routines hidden away within KAPPA was
so that changes could be made to the argument lists or functionality 
of these routines without breaking software within other packages. In
practice, it has hardly ever been necessary to change the interface to
routines after an initial development period, but the possibility still
exists that this may be necessary. For this reason, users of KAPLIBS
should be aware that \emph{it may occasionally be necessary to change the
interface to KAPLIBS routines}. Such changes will be listed within 
this document at each release. To aid developers decisions over which
routines to use, routines which are deemed to have a significant chance
of being changed within the foreseeable future are highlighted later in
this document. This class of routine will normally just include routines
which have only recently been written.

\subsection{The Scope of this Document}
The purpose of this document is to give reference information about the
argument lists and functionality of the internal KAPPA routines which are
contained within KAPLIBS. It does not give a detailed explanation of how
these routines should be used within a real application. Developers
should usually study examples of existing code within KAPPA for this
purpose. The source code for KAPPA is available from the Starlink
Software Librarian, {\tt ussc@star.rl.ac.uk}.

Applications within KAPPA are split up into several groups (called
``monoliths'), with names such as {\tt kapview}, {\tt ndfpack} and
(rather confusingly) {\tt kappa}. The top-level routines for the
applications in monolith {\tt xyz} are in the tar file {\tt
\$KAPPA\_DIR/xyz\_sub.tar}. Each application may use some
application-specific subroutines (\emph{i.e.} subroutines which are so
closely related to the purpose of a single application that they are not
deemed as ``generally useful''). These will be denoted by subroutines
names with prefix ``{\tt KPS1\_}'' and will be contained within the tar
file {\tt \$KAPPA\_DIR/kapsub\_sub.tar}.

\section{Naming Conventions}
Each subroutine within KAPLIBS has a name of the form {\tt <prefix>\_<name>}
where {\tt <prefix>} is a prefix indicating which KAPPA library the
routine belongs to, and {\tt <name>} is a unique name for the routine.
The prefix associated with each KAPPA library indicates something of the
purpose of that library. The following prefixes are currently included
within KAPLIBS:

\begin{description}

\item [CTG\_] These are routines for accessing groups of catalogues through
a single parameter using wild-cards, \emph{etc.}. This is analogous to
the way the NDG library (see \xref{SUN/95}{sun95}{}) accesses groups 
of NDFs using a single parameter.

\item [LPG\_] These are routines which are used to implement looping
within a monolith in order to allow a command to be repeatedly invoked
until all supplied data files (catalogues or NDFs) have been processed.
See the KAPPA monolith routines such as {\tt kapview\_mon.f}, {\tt
ndfpack\_mon.f} and {\tt kappa\_mon.f}. LPG routines should be used instead
of NDF or CAT routines to access NDFs or catalogues within applications
if this looping behaviour is required.

\item [AIF\_] These are old routines which were used to access parameter
values or temporary work space. They are gradually being replaced within
KAPPA by more modern routines provided by the PAR and PSX libraries.

\item [FTS1\_] These are routines used to access FITS files and headers - 
KAPPA's own {\tt fitsio}.

\item [IRA\_] These routines were initially part of the IRAS90 Astrometry
library (hence the IRA acronym). They are used to gain access to WCS
information stored within NDFs in the form of IRAS90 Astrometry extension.
This form of WCS is now deprecated in favour of the NDF WCS component.

\item [IRQ\_] These routines were initially part of the IRAS90 Astrometry
library (hence the IRQ acronym). They are used to manage and use textual
names representing bits in the NDF Quality component. Further information
about IRQ is available in the document id6.tex which is part of the
KAPLIBS source distribution.

\item [KPG1\_] These are other general purpose routines which do not fall
into such obvious groups.  Even within this library, though, there are
loose associations of routines, usually indicated by some common element
within the routine name. The following are some of the more significant
associations:

\begin{itemize}
\item Routines associated with use of the PGPLOT graphics package usually
have names which start ``{\tt KPG1\_PG}''.
\item Routines associated with use of the AGI graphics database usually
have names which start ``{\tt KPG1\_GD}''.
\item Routines associated with accessing or using WCS information usually 
have names which start ``{\tt KPG1\_AS}''.
\end{itemize}

\end{description}

Within all these groups, some routines have different versions for
processing data with different numerical types. The names of such
routines are identical except for the trailing one or two characters
which indicate the numerical type processed. These one or two character
codes are:

\begin{description}
\item [d] - Double precision floating point
\item [r] - Single precision floating point
\item [c] - Character
\item [i] - Single precision integer
\item [w] - Word (usually 2 bytes integers)
\item [uw] - Unsigned word (usually 2 bytes unsigned integers)
\item [bw] - Byte (usually 1 byte integers)
\item [ub] - Unsigned byte (usually 1 byte unsigned integers)
\item [l] - Logical 
\end{description}

Sometimes, routine names are documented as ending with a lower case
``x''. This indicates that routines exist for various of the above
numerical types. The \emph{actual} routines names will not include the trailing
``x'', but will have one of the above codes in place of the ``x''.

\section{Compiling and Linking}
To compile and link an application with the KAPLIBS package, the following
commands should be used (see \xref{SUN/144}{sun144}{}):

\small
\verb#      % kaplibs_dev#
\verb#      % alink adamprog.f# `\verb#kaplibs_link_adam#`
\verb#      % kaplibs_dev remove#
\normalsize

Note the use of {\em opening} apostrophes (`) rather than the more common
closing apostrophe (')\footnote{Currently, the parameter handling
routines within KAPLIBS have not been separated out, and so it is not
currently possible to link stand-alone (\emph{i.e.} ``non-Adam'')
applications against KAPLIBS.}.

This produces an executable image called {\bf prog}. The
\verb+kaplibs_dev+ command creates soft links within the current
directory to the various include files provided by KAPLIBS. These are
removed by the \verb+kaplibs_dev remove+ command.

\subsection{Linking with Native PGPLOT}
The commands described above will link the application with the Starlink
GKS version of the PGPLOT graphics library. If you wish to link with the
{\em native} version of PGPLOT, then include the switch ``-nogks'' as follows:

\small
\verb#      % kaplibs_dev#
\verb#      % alink adamprog.f# `\verb#kaplibs_link_adam -nogks#`
\verb#      % kaplibs_dev remove#
\normalsize

This will include native PGPLOT in the link list, and cause all GKS and IDI 
related items to be removed.


\section{Changes in Version 2.7}
\begin{itemize}
\item A new routine LPG_REPLA has been added. It controls a new option
   which allows a single NDF to be used as both input and output for an adam task. 
   The default is for this option to be disabled.
\end{itemize}

\section{Changes in Version 2.6}
\begin{itemize}
\item The GRF mdoule (grf\_kaplibs.c) has been upgraded to include the
extra functions needed by AST V3.2.
\end{itemize}

\section{Changes in Version 2.5}
\begin{itemize}
\item The KPG1\_FFT... routines have been made significantly faster (at
the expendse of using slightly more memory). For instance, a speed gain
of a factor 10 is typical for an array of 150000 points.
\end{itemize}

\section{Changes in Version 2.4}
\begin{itemize}
\item The KPG1\_WRLST routine now normalises the supplied positions (using
AST\_NORM) before writing them to the output catalogue.
\end{itemize}

\section{Changes in Version 2.3}
\begin{itemize}
\item The routine GETHLP has been moved from KAPPA to the KAPLIBS:KAPGEN library.
\end{itemize}

\section{Changes in Version 2.2}
\begin{itemize}
\item Script \verb+kaplibs_link+ has been added to enable linking of standalone 
applications.
\item The routine KPG1_DSFRM has been modified to include details of AST 
SpecFrames. \emph{The argument list has also been changed.}
\item The routine KPG1_ASMRG has been modified to attempt alignment in 
Domain SPECTRAL.
\end{itemize}

\section{Changes in Version 2.0}
\begin{itemize}
\item The ``-nogks'' switch has been added to the
\verb#kaplibs_link_adam# command, allowing applications to be linked with
native PGPLOT instead of the Starlink GKS-based PGPLOT.
\item The routine KPG1_WRLST now allows the user to choose the
co-ordinate system in which the positions are stored in the catalogue
columns. This is done using two ADAM parameters called COLFRAME and
COLEPOCH (these names are hard-wired into the routine to encourage
conformity). Consequently, applications which use this routine should add
definitions for these two parameters to their IFL files.
\item The routine KPG1_RDLST can now read positions from catalogues which
do not contain a WCS FrameSet, in certain special cases. That is, if the
catalogue contains columsn called RA and DEC, or X and Y. 
\item The IRAS90 IRQ library has been included. IRQ is used to manage
textual representations of NDF Quality bits.
\end{itemize}

\section{Changes in Version 2.1}
\begin{itemize}
\item The KPG1_CPSTY routine has been added to copy AST Plotting styles
from one graphical element to another.
\end{itemize}

\appendix

% Command for displaying routines in routine lists:
% =================================================

\newcommand{\noteroutine}[2]{{\small{\bf{#1}}}\nopagebreak\\
                             \hspace*{3em}\st{#2}\\[1.5ex]}
\begin{htmlonly}
   \renewcommand{\noteroutine}[2]{{\small{\bf{#1}}}\\
                                  --- \st{#2}\\[1.0ex]}
\end{htmlonly}

\begin{latexonly}
  \newpage
  \latexonlysection{Alphabetical List of Routines}
  \small

\noteroutine{AIF\_ANTMP}{
Annul a locator to a temporary object, thereby erasing the object
}
\noteroutine{AIF\_ASFIO}{
Opens a sequential file via a parameter
}
\noteroutine{AIF\_FLNAM}{
Returns the name of a file as a character string given its
parameter name
}
\noteroutine{AIF\_GETVM}{
Obtains a pointer and a locator to mapped HDS workspace
}
\noteroutine{AIF\_OPFIO}{
Opens a Fortran sequential file by name
}
\noteroutine{AIF\_PTFNM}{
Writes the name of an HDS file to a parameter
}
\noteroutine{AIF\_TEMP}{
Create a temporary HDS object
}
\noteroutine{CTG\_ASSO1}{
Obtain an identifier for a single existing catalogue using a
specified parameter
}
\noteroutine{CTG\_ASSOC}{
Store names of existing catalogues specified through the environment
}
\noteroutine{CTG\_CATAS}{
Obtain a CAT identifier for an existing catalogue
}
\noteroutine{CTG\_CATCR}{
Obtain a CAT identifier for a new catalogue
}
\noteroutine{CTG\_CREA1}{
Create a single new catalogue using a specified parameter
}
\noteroutine{CTG\_CREAT}{
Obtain the names of a group of catalogue to be created from the
environment
}
\noteroutine{CTG\_GTSUP}{
Get supplemental information for a catalogue
}
\noteroutine{CTG\_PTSUP}{
Store suplemental information for an catalogue
}
\noteroutine{CTG\_SETSZ}{
Reduces the size of a CTG group
}
\noteroutine{FTS1\_ASTWN}{
Displays any AST warning messages stored in the supplied FitsChan
}
\noteroutine{FTS1\_AXIS}{
Create an axis structure within an NDF from FITS header
information
}
\noteroutine{FTS1\_BLCAR}{
Determines whether or not the first card in a FITS record has a
blank keyword
}
\noteroutine{FTS1\_BSWAP}{
Swaps adjacent bytes in an array of bytes
}
\noteroutine{FTS1\_CHVAx}{
Replaces all occurrences of a value in an array with another
value
}
\noteroutine{FTS1\_CHVAx}{
Replaces all occurrences of a value in an array with another
value
}
\noteroutine{FTS1\_CHVAx}{
Replaces all occurrences of a value in an array with another
value
}
\noteroutine{FTS1\_COMNT}{
Get the value of a FITS COMMENT card from a buffer of cards
}
\noteroutine{FTS1\_CRNDF}{
For a FITS data array create an NDF, generating the NDF{\tt '}s name in
some circumstances
}
\noteroutine{FTS1\_DREAD}{
Obtains a FITS record from a disk file
}
\noteroutine{FTS1\_DTYPE}{
Obtain the input data type, scales and offsets for a FITS file
}
\noteroutine{FTS1\_EDFEX}{
Edits non-reserved keyword cards in a FITS extension of an NDF
}
\noteroutine{FTS1\_EDKEY}{
Edits keywords in a FITS card array
}
\noteroutine{FTS1\_EVKEY}{
Extracts a keyword and occurrence, and validates the keyword
}
\noteroutine{FTS1\_FNDFS}{
Read the first FrameSet from the supplied FitsChan
}
\noteroutine{FTS1\_FRMT}{
Obtain the input and output data format for a FITS file
}
\noteroutine{FTS1\_FTWCS}{
Uses coordinate system information in the supplied FITS headers
to create WCS and AXIS components in an NDF
}
\noteroutine{FTS1\_GKEYC}{
Gets the value and comment of a named header of type CHARACTER
from a buffer of FITS-header card images
}
\noteroutine{FTS1\_GKEYx}{
Gets the value and comment of a named header of type DOUBLE PRECISION from
a buffer of FITS-header card images
}
\noteroutine{FTS1\_GKEYx}{
Gets the value and comment of a named header of type INTEGER from
a buffer of FITS-header card images
}
\noteroutine{FTS1\_GKEYx}{
Gets the value and comment of a named header of type LOGICAL from
a buffer of FITS-header card images
}
\noteroutine{FTS1\_GKEYx}{
Gets the value and comment of a named header of type REAL from
a buffer of FITS-header card images
}
\noteroutine{FTS1\_GPARM}{
Add the group parameters to the FITS header records
}
\noteroutine{FTS1\_HDLOG}{
Outputs the FITS header cards to an ASCII file
}
\noteroutine{FTS1\_I2VXD}{
Converts a vector of 64-bit IEEE floating-point numbers to Vax-D
format
}
\noteroutine{FTS1\_I2VXR}{
Converts a vector of 32-bit IEEE floating-point numbers to Vax-F
format
}
\noteroutine{FTS1\_INKEY}{
Insert keywords to a FITS card array
}
\noteroutine{FTS1\_ISKEY}{
Inquires whether or not a string is a valid FITS keyword
}
\noteroutine{FTS1\_LOKEY}{
Locates an occurrence of a keyword in a FITS header
}
\noteroutine{FTS1\_MANDH}{
Obtain the values of the mandatory headers in a FITS file
}
\noteroutine{FTS1\_NDFCM}{
Create the title, units, axes, wcs, and FITS extension in an NDF
from the FITS headers
}
\noteroutine{FTS1\_NDF}{
Makes an NDF from a simple or group-format FITS file
}
\noteroutine{FTS1\_PHEAD}{
Process the headers in a FITS file on tape or disk
}
\noteroutine{FTS1\_PTKEY}{
Puts non-reserved keyword cards into FITS extension of an NDF file
}
\noteroutine{FTS1\_QTYPE}{
Determines the data type of a FITS header value
}
\noteroutine{FTS1\_RDATA}{
Read the data of a FITS file on disk or tape
}
\noteroutine{FTS1\_RFMOD}{
Reads a text file containing instructions for editing an NDF{\tt '}s
FITS extension
}
\noteroutine{FTS1\_RGRDA}{
Read the data of a FITS file in group format from disk or tape
}
\noteroutine{FTS1\_ROOTN}{
Creates the rootname for an NDF
}
\noteroutine{FTS1\_RSTAB}{
Read the table format from a FITS file and write to an ASCII file
}
\noteroutine{FTS1\_SCOFB}{
Applies scale and zero to a REAL data vector, and substitutes
magic values for blank FITS data
}
\noteroutine{FTS1\_SCTAB}{
Create an ASCII catalogue and description file in SCAR format
from a FITS tape or disk file
}
\noteroutine{FTS1\_SDSCF}{
Create a SCAR description file from a FITS table-format headers
}
\noteroutine{FTS1\_SKIP}{
Skip over the data of a FITS file
}
\noteroutine{FTS1\_TREAD}{
Obtains a FITS record from a tape file
}
\noteroutine{FTS1\_UKEYC}{
Writes the value of type CHARACTER to a keyword from a buffer
of FITS-header card images
}
\noteroutine{FTS1\_UKEYx}{
Write the value of type DOUBLE PRECISION to the specified keyword from a
buffer of FITS-header card images
}
\noteroutine{FTS1\_UKEYx}{
Write the value of type INTEGER to the specified keyword from a
buffer of FITS-header card images
}
\noteroutine{FTS1\_UKEYx}{
Write the value of type LOGICAL to the specified keyword from a
buffer of FITS-header card images
}
\noteroutine{FTS1\_UKEYx}{
Write the value of type REAL to the specified keyword from a
buffer of FITS-header card images
}
\noteroutine{FTS1\_VHEAD}{
Validates a FITS header card and reconstitutes to the standard
}
\noteroutine{FTS1\_WCSAX}{
Re-create AXIS structures from a WCS component FrameSet
}
\noteroutine{FTS1\_WCSDF}{
See if two FrameSets are different after being written to a
FitsChan
}
\noteroutine{FTS1\_WCSIM}{
Imports WCS information from the supplied FitsChan into the supplied
NDF
}
\noteroutine{FTS1\_WCSUT}{
Remove the spurious copy of the AXIS Frame which is left in
WCS component when using non-Native encodings
}
\noteroutine{FTS1\_WKEYC}{
Writes a FITS-header card for a CHARACTER value or a comment
}
\noteroutine{FTS1\_WKEYx}{
Writes a FITS-header card for a value of type DOUBLE PRECISION
}
\noteroutine{FTS1\_WKEYx}{
Writes a FITS-header card for a value of type INTEGER
}
\noteroutine{FTS1\_WKEYx}{
Writes a FITS-header card for a value of type LOGICAL
}
\noteroutine{FTS1\_WKEYx}{
Writes a FITS-header card for a value of type REAL
}
\noteroutine{IRA\_ANNUL}{
Annul an IRA identifier
}
\noteroutine{IRA\_CLOSE}{
Close down the IRA astrometry package
}
\noteroutine{IRA\_CONVT}{
Convert sky coordinates from one system to another
}
\noteroutine{IRA\_CREAT}{
Create an identifier for specified astrometry information
}
\noteroutine{IRA\_CTOD1}{
Converts a single formatted sky coordinate value into a double
precision value
}
\noteroutine{IRA\_CTOD}{
Converts formatted sky coordinate values into double precision
values
}
\noteroutine{IRA\_DTOC1}{
Convert a single floating point sky coordinate value to
character form
}
\noteroutine{IRA\_DTOC}{
Convert a pair of double precision sky coordinate values to
character form
}
\noteroutine{IRA\_EXPRT}{
Store astrometry information in an NDF
}
\noteroutine{IRA\_FIND}{
Find an astrometry structure within an NDF
}
\noteroutine{IRA\_GETCO}{
Obtain a pair of sky coordinates from the ADAM environment
}
\noteroutine{IRA\_GETEQ}{
Extract the epoch of the reference equinox from a string
specifying a Sky Coordinate System
}
\noteroutine{IRA\_GTCO1}{
Obtain a single sky coordinate value from the ADAM environment
}
\noteroutine{IRA\_GTSCS}{
Get the full name of a Sky Coordinate System (with equinox
specifier) from the environment
}
\noteroutine{IRA\_INIT}{
Initialise the IRA astrometry package
}
\noteroutine{IRA\_IPROJ}{
Return a list of supported projection names
}
\noteroutine{IRA\_ISCS}{
Return a list of supported sky coordinate systems
}
\noteroutine{IRA\_LOCAT}{
Set the location for new IRA astrometry structures
}
\noteroutine{IRA\_NORM}{
Convert sky coordinate values to the equivalent first order
values
}
\noteroutine{IRA\_READ}{
Get an identifier for astrometry information stored in an HDS
astrometry structure
}
\noteroutine{IRA\_SETEQ}{
Encode the epoch of a reference equinox within an SCS name
}
\noteroutine{IRA\_TRANS}{
Transform coordinate data
}
\noteroutine{IRA\_WRITE}{
Write astrometry information into an HDS object
}
\noteroutine{KPG1\_ABSET}{
Separates a list of items into a character array
}
\noteroutine{KPG1\_AGATC}{
Reports the character attributes of the current picture in the
graphics database
}
\noteroutine{KPG1\_AGFND}{
Selects the highest picture of a given name within the current AGI
picture
}
\noteroutine{KPG1\_AGREF}{
Obtains a name of or a locator to an object referenced in the
graphics database
}
\noteroutine{KPG1\_AINBx}{
Obtains for an axis the equivalent index co-ordinates given axis
values
}
\noteroutine{KPG1\_AINBx}{
Obtains for an axis the equivalent index co-ordinates given axis
values
}
\noteroutine{KPG1\_AINDx}{
Obtains for an axis the equivalent index co-ordinates given axis
values
}
\noteroutine{KPG1\_AINDx}{
Obtains for an axis the equivalent index co-ordinates given axis
values
}
\noteroutine{KPG1\_AKERx}{
Smooth a 2-dimensional array using an arbitrary rectangular
kernel
}
\noteroutine{KPG1\_AKERx}{
Smooth a 2-dimensional array using an arbitrary rectangular
kernel
}
\noteroutine{KPG1\_SOLIN}{
Sets the aspect source flag of the GKS linetype to bundled
}
\noteroutine{KPG1\_ARCOG}{
Allow the user to select an array component in a supplied NDF
}
\noteroutine{KPG1\_ARCOL}{
Forms a list of the available array components in an NDF
}
\noteroutine{KPG1\_ASAGD}{
Transform AGI world co-ordinates to AGI data co-ordinates
}
\noteroutine{KPG1\_ASCRV}{
Draw a polyline using AST
}
\noteroutine{KPG1\_ASDIS}{
Find the distance between two points
}
\noteroutine{KPG1\_ASDSV}{
Find the distances between a set of points
}
\noteroutine{KPG1\_ASFFR}{
Finds an Frame with a given Domain within a FrameSet
}
\noteroutine{KPG1\_ASFGT}{
Create a new Frame with a Domain specified through the environment
}
\noteroutine{KPG1\_ASFIL}{
Read spatial positions from a text file
}
\noteroutine{KPG1\_ASFIX}{
Modify the WCS FrameSet of an NDF to take account of
re-gridding the pixel array
}
\noteroutine{KPG1\_ASFRM}{
Set the current Frame in a FrameSet to a Frame specified through
the environment
}
\noteroutine{KPG1\_ASGDP}{
Find a position with good output co-ordinates within a given input
region of a supplied Mapping
}
\noteroutine{KPG1\_ASGET}{
Get an AST FrameSet from the WCS component of an NDF
}
\noteroutine{KPG1\_ASGFR}{
Reads a line of an AST Object description from a GRP group
}
\noteroutine{KPG1\_ASGFW}{
Writes a line of an AST Object description to a GRP group
}
\noteroutine{KPG1\_ASGRD}{
Draw a border or an annotated coordinate grid over an AST Plot
}
\noteroutine{KPG1\_ASGRP}{
Read spatial positions from a GRP group
}
\noteroutine{KPG1\_ASIRA}{
Creates an AST FrameSet from an IRAS90 astrometry structure
}
\noteroutine{KPG1\_ASLOG}{
Take log base 10 of each axis value (an AST IntraMap routine)
}
\noteroutine{KPG1\_ASMRG}{
Merge two FrameSets by aligning them in a common Frame
}
\noteroutine{KPG1\_ASOFF}{
Find a position offset by a given distance from one position
towards another position
}
\noteroutine{KPG1\_ASPLT}{
Create an AST Plot covering the current PGPLOT viewport
}
\noteroutine{KPG1\_ASPRP}{
Propagate the WCS component from one NDF to another with the same
number of axes, allowing for a linear mapping of the pixel coordinates
}
\noteroutine{KPG1\_ASPSY}{
Establish synonyms for AST attribute names
}
\noteroutine{KPG1\_ASPTP}{
Put a formatted AST position into a string
}
\noteroutine{KPG1\_ASREF}{
Associates an NDF optionally from a reference name or locator
}
\noteroutine{KPG1\_ASREG}{
Register all AST IntraMaps known by KAPPA
}
\noteroutine{KPG1\_ASSET}{
Allow the user to spcify attribute values for an AST Object
}
\noteroutine{KPG1\_ASSHR}{
Shrink a Plot so that it covers an area which allows all annotation
to fit within the specified area
}
\noteroutine{KPG1\_ASSIG}{
Ensure that the Current Frame from an NDF WCS FrameSet has no
insignificant axes
}
\noteroutine{KPG1\_ASSIM}{
Simplify a Plot
}
\noteroutine{KPG1\_ASSIR}{
Set the attributes of a SkyFrame to match an IRAS90 SCS
}
\noteroutine{KPG1\_ASSMP}{
Returns co-ordinates at evenly spaces positions along a given
poly-line
}
\noteroutine{KPG1\_ASSPL}{
Get a set of 1-d Mappings for each axis in a FrameSet
}
\noteroutine{KPG1\_ASSTS}{
Apply an attribute setting to a Plot
}
\noteroutine{KPG1\_ASSTY}{
Check for synonyms and colour names in AST attribute settings
}
\noteroutine{KPG1\_AST2H}{
Copy AST\_ data to an HDS object
}
\noteroutine{KPG1\_AVLUT}{
Associates, validates and maps an lookup table stored in an NDF
}
\noteroutine{KPG1\_AXANO}{
Generates an axis annotation from the NDF{\tt '}s axis label and units
}
\noteroutine{KPG1\_AXBNx}{
Find the bounds of an NDF{\tt '}s axis centre co-ordinates
}
\noteroutine{KPG1\_AXBNx}{
Find the bounds of an NDF{\tt '}s axis centre co-ordinates
}
\noteroutine{KPG1\_AXCOx}{
Obtains for an axis the axis indices given their values
}
\noteroutine{KPG1\_AXCOx}{
Obtains for an axis the axis indices given their values
}
\noteroutine{KPG1\_AXEXx}{
Calculates the extent of an NDF along an axis
}
\noteroutine{KPG1\_AXEXx}{
Calculates the extent of an NDF along an axis
}
\noteroutine{KPG1\_AXGVx}{
Find the first axis centre co-ordinate of an NDF above a
threshold
}
\noteroutine{KPG1\_AXGVx}{
Find the first axis centre co-ordinate of an NDF above a
threshold
}
\noteroutine{KPG1\_AXLIx}{
Determines whether an array{\tt '}s values are equally spaced
}
\noteroutine{KPG1\_AXLIx}{
Determines whether an array{\tt '}s values are equally spaced
}
\noteroutine{KPG1\_AXLIx}{
Determines whether an array{\tt '}s values are equally spaced
}
\noteroutine{KPG1\_AXLIx}{
Determines whether an array{\tt '}s values are equally spaced
}
\noteroutine{KPG1\_AXLIx}{
Determines whether an array{\tt '}s values are equally spaced
}
\noteroutine{KPG1\_AXLVx}{
Find the first axis centre co-ordinate of an NDF below a
threshold
}
\noteroutine{KPG1\_AXLVx}{
Find the first axis centre co-ordinate of an NDF below a
threshold
}
\noteroutine{KPG1\_AXRNG}{
Calculate the extent of an NDF along an axis
}
\noteroutine{KPG1\_AXTYP}{
Determines the implementation type for NDF axis arrays
}
\noteroutine{KPG1\_AXVLx}{
Obtains the axis-array values given their corresponding pixel
co-ordinates
}
\noteroutine{KPG1\_AXVLx}{
Obtains the axis-array values given their corresponding pixel
co-ordinates
}
\noteroutine{KPG1\_BILNR}{
Perform bi-linear interpolation checking for bad values
}
\noteroutine{KPG1\_BL1Dx}{
Smooth a 1D vector using a block average filter
}
\noteroutine{KPG1\_BL1Dx}{
Smooth a 1D vector using a block average filter
}
\noteroutine{KPG1\_BL1Dx}{
Smooth a 1D vector using a block average filter
}
\noteroutine{KPG1\_BL1Dx}{
Smooth a 1D vector using a block average filter
}
\noteroutine{KPG1\_BL1Dx}{
Smooth a 1D vector using a block average filter
}
\noteroutine{KPG1\_BL1Dx}{
Smooth a 1D vector using a block average filter
}
\noteroutine{KPG1\_BL1Dx}{
Smooth a 1D vector using a block average filter
}
\noteroutine{KPG1\_BLOCx}{
Smooth a 2-dimensional image using a rectangular box filter
}
\noteroutine{KPG1\_BLOCx}{
Smooth a 2-dimensional image using a rectangular box filter
}
\noteroutine{KPG1\_BMEDx}{
Smooths the input array using a block median filter
}
\noteroutine{KPG1\_BMEDx}{
Smooths the input array using a block median filter
}
\noteroutine{KPG1\_BOR2x}{
Places a border of constant values at the edges of a 2-d array
}
\noteroutine{KPG1\_BOR2x}{
Places a border of constant values at the edges of a 2-d array
}
\noteroutine{KPG1\_BOR2x}{
Places a border of constant values at the edges of a 2-d array
}
\noteroutine{KPG1\_BOR2x}{
Places a border of constant values at the edges of a 2-d array
}
\noteroutine{KPG1\_BOR2x}{
Places a border of constant values at the edges of a 2-d array
}
\noteroutine{KPG1\_BOR2x}{
Places a border of constant values at the edges of a 2-d array
}
\noteroutine{KPG1\_BOR2x}{
Places a border of constant values at the edges of a 2-d array
}
\noteroutine{KPG1\_CADDx}{
Add a constant to each element of a vectorised array
}
\noteroutine{KPG1\_CADDx}{
Add a constant to each element of a vectorised array
}
\noteroutine{KPG1\_CADDx}{
Add a constant to each element of a vectorised array
}
\noteroutine{KPG1\_CADDx}{
Add a constant to each element of a vectorised array
}
\noteroutine{KPG1\_CADDx}{
Add a constant to each element of a vectorised array
}
\noteroutine{KPG1\_CADDx}{
Add a constant to each element of a vectorised array
}
\noteroutine{KPG1\_CADDx}{
Add a constant to each element of a vectorised array
}
\noteroutine{KPG1\_CCPRO}{
Gets a character component for an output NDF with optional
propagation from another NDF
}
\noteroutine{KPG1\_CEIL}{
Return the smallest integer larger than or equal to a supplied value
}
\noteroutine{KPG1\_CHAXx}{
Check for usable AXIS structures
}
\noteroutine{KPG1\_CHAXx}{
Check for usable AXIS structures
}
\noteroutine{KPG1\_CHE2X}{
Evaluates a 2-dimensional Chebyshev polynomial
}
\noteroutine{KPG1\_CHE2X}{
Evaluates a 2-dimensional Chebyshev polynomial
}
\noteroutine{KPG1\_CHELx}{
Replaces the value of an array element with a specified value
}
\noteroutine{KPG1\_CHELx}{
Replaces the value of an array element with a specified value
}
\noteroutine{KPG1\_CHELx}{
Replaces the value of an array element with a specified value
}
\noteroutine{KPG1\_CHEPx}{
Evaluates a Chebyshev polynomial
}
\noteroutine{KPG1\_CHEPx}{
Evaluates a Chebyshev polynomial
}
\noteroutine{KPG1\_CHEVx}{
Evaluates a one-dimensional Chebyshev polynomial
}
\noteroutine{KPG1\_CHEVx}{
Evaluates a one-dimensional Chebyshev polynomial
}
\noteroutine{KPG1\_CHVAx}{
Replaces all occurrences of a value in an array with another
value
}
\noteroutine{KPG1\_CHVAx}{
Replaces all occurrences of a value in an array with another
value
}
\noteroutine{KPG1\_CHVAx}{
Replaces all occurrences of a value in an array with another
value
}
\noteroutine{KPG1\_CHVAx}{
Replaces all occurrences of a value in an array with another
value
}
\noteroutine{KPG1\_CHVAx}{
Replaces all occurrences of a value in an array with another
value
}
\noteroutine{KPG1\_CHVAx}{
Replaces all occurrences of a value in an array with another
value
}
\noteroutine{KPG1\_CHVAx}{
Replaces all occurrences of a value in an array with another
value
}
\noteroutine{KPG1\_CMADx}{
Compresses an n-dimensional array by summing in `rectangular{\tt '}
boxes
}
\noteroutine{KPG1\_CMADx}{
Compresses an n-dimensional array by summing in `rectangular{\tt '}
boxes
}
\noteroutine{KPG1\_CMAVx}{
Compresses an n-dimensional array by averaging in `rectangular{\tt '}
boxes
}
\noteroutine{KPG1\_CMAVx}{
Compresses an n-dimensional array by averaging in `rectangular{\tt '}
boxes
}
\noteroutine{KPG1\_CMPKx}{
Compresses an n-dimensional array by picking value at equally
spaced intervals
}
\noteroutine{KPG1\_CMPKx}{
Compresses an n-dimensional array by picking value at equally
spaced intervals
}
\noteroutine{KPG1\_CMPKx}{
Compresses an n-dimensional array by picking value at equally
spaced intervals
}
\noteroutine{KPG1\_CMPKx}{
Compresses an n-dimensional array by picking value at equally
spaced intervals
}
\noteroutine{KPG1\_CMPKx}{
Compresses an n-dimensional array by picking value at equally
spaced intervals
}
\noteroutine{KPG1\_CMPKx}{
Compresses an n-dimensional array by picking value at equally
spaced intervals
}
\noteroutine{KPG1\_CMPKx}{
Compresses an n-dimensional array by picking value at equally
spaced intervals
}
\noteroutine{KPG1\_CMULx}{
Multiply each element of a vectorised array by a constant
}
\noteroutine{KPG1\_CMULD}{
Multiply each element of a vectorised double precision array by a
constant
}
\noteroutine{KPG1\_CMULx}{
Multiply each element of a vectorised array by a constant
}
\noteroutine{KPG1\_CMULx}{
Multiply each element of a vectorised array by a constant
}
\noteroutine{KPG1\_CMULx}{
Multiply each element of a vectorised array by a constant
}
\noteroutine{KPG1\_CMULx}{
Multiply each element of a vectorised array by a constant
}
\noteroutine{KPG1\_CMULx}{
Multiply each element of a vectorised array by a constant
}
\noteroutine{KPG1\_CMVDx}{
Compresses n-dimensional data and variance arrays by summing in
`rectangular{\tt '} boxes
}
\noteroutine{KPG1\_CMVDx}{
Compresses n-dimensional data and variance arrays by summing in
`rectangular{\tt '} boxes
}
\noteroutine{KPG1\_CMVVx}{
Compresses n-dimensional data and variance arrays by averaging in
`rectangular{\tt '} boxes
}
\noteroutine{KPG1\_CMVVx}{
Compresses n-dimensional data and variance arrays by averaging in
`rectangular{\tt '} boxes
}
\noteroutine{KPG1\_CNLIM}{
Parse a character string into integer bounds
}
\noteroutine{KPG1\_COLNM}{
Finds the named colour nearest to an RGB triple
}
\noteroutine{KPG1\_CPBDD}{
Copy bad pixels
}
\noteroutine{KPG1\_CPBDR}{
Copy bad pixels
}
\noteroutine{KPG1\_CPNDB}{
Copy a section of an n-dimensional array
}
\noteroutine{KPG1\_CPNDD}{
Copy a section of an n-dimensional array
}
\noteroutine{KPG1\_CPNDI}{
Copy a section of an n-dimensional array
}
\noteroutine{KPG1\_CPNDR}{
Copy a section of an n-dimensional array
}
\noteroutine{KPG1\_CPNDUB}{
Copy a section of an n-dimensional array
}
\noteroutine{KPG1\_CPNDUW}{
Copy a section of an n-dimensional array
}
\noteroutine{KPG1\_CPNDW}{
Copy a section of an n-dimensional array
}
\noteroutine{KPG1\_CPNTx}{
Creates a primitive NDF with a title via the parameter system
}
\noteroutine{KPG1\_CPNTx}{
Creates a primitive NDF with a title via the parameter system
}
\noteroutine{KPG1\_CPNTx}{
Creates a primitive NDF with a title via the parameter system
}
\noteroutine{KPG1\_CPNTx}{
Creates a primitive NDF with a title via the parameter system
}
\noteroutine{KPG1\_CPNTx}{
Creates a primitive NDF with a title via the parameter system
}
\noteroutine{KPG1\_CPNTx}{
Creates a primitive NDF with a title via the parameter system
}
\noteroutine{KPG1\_CPNTx}{
Creates a primitive NDF with a title via the parameter system
}
\noteroutine{KPG1\_CPSTY}{
Copy the plotting style for an AST element to another AST element
}
\noteroutine{KPG1\_CROSS}{
Draws a cross at the specified pixel position
}
\noteroutine{KPG1\_CROUT}{
Creates and returns locators to the top-level and data-array of
an NDF-type structure
}
\noteroutine{KPG1\_CSHFT}{
Shift the characters left or right in a string
}
\noteroutine{KPG1\_CSUBx}{
Subtract a constant from each element of a vectorised array
}
\noteroutine{KPG1\_CSUBx}{
Subtract a constant from each element of a vectorised array
}
\noteroutine{KPG1\_CSUBx}{
Subtract a constant from each element of a vectorised array
}
\noteroutine{KPG1\_CSUBx}{
Subtract a constant from each element of a vectorised array
}
\noteroutine{KPG1\_CSUBx}{
Subtract a constant from each element of a vectorised array
}
\noteroutine{KPG1\_CSUBx}{
Subtract a constant from each element of a vectorised array
}
\noteroutine{KPG1\_CSUBx}{
Subtract a constant from each element of a vectorised array
}
\noteroutine{KPG1\_CTCPD}{
Copy values from catalogue columns to an array
}
\noteroutine{KPG1\_CTCPI}{
Copy values from catalogue columns to an array
}
\noteroutine{KPG1\_D2W2x}{
Converts linear data co-ordinates to world co-ordinates
}
\noteroutine{KPG1\_D2W2x}{
Converts linear data co-ordinates to world co-ordinates
}
\noteroutine{KPG1\_DANOT}{
Generates an annotation from the NDF{\tt '}s label and units
}
\noteroutine{KPG1\_DARAB}{
Determine the data limits for an array using a variety of methods
}
\noteroutine{KPG1\_DARAD}{
Determine the data limits for an array using a variety of methods
}
\noteroutine{KPG1\_DARAI}{
Determine the data limits for an array using a variety of methods
}
\noteroutine{KPG1\_DARAR}{
Determine the data limits for an array using a variety of methods
}
\noteroutine{KPG1\_DARAUB}{
Determine the data limits for an array using a variety of methods
}
\noteroutine{KPG1\_DARAUW}{
Determine the data limits for an array using a variety of methods
}
\noteroutine{KPG1\_DARAW}{
Determine the data limits for an array using a variety of methods
}
\noteroutine{KPG1\_DAUNI}{
Generates a string containing the units of an NDF{\tt '}s data or
variance component allowing for truncation
}
\noteroutine{KPG1\_DCLIx}{
Determines a linear transformation from pixel to NDF-axis
co-ordinates
}
\noteroutine{KPG1\_DCLIx}{
Determines a linear transformation from pixel to NDF-axis
co-ordinates
}
\noteroutine{KPG1\_DEBUG}{
Should the speified package report debug diagnostics?
}
\noteroutine{KPG1\_DIVx}{
Divide two vectorised arrays with optional variance information
}
\noteroutine{KPG1\_DIVx}{
Divide two vectorised arrays with optional variance information
}
\noteroutine{KPG1\_DNAG2R}{
Converts an NAG Hermitian Fourier transform array into an array
usable by FFTPACK routine KPG1\_DRFFTB
}
\noteroutine{KPG1\_DR2NAG}{
Converts an FFTPACK Hermitian Fourier transform array into
the equivalent NAG array
}
\noteroutine{KPG1\_DSFR1}{
Display a textual description of the Current Frame in a FrameSet
}
\noteroutine{KPG1\_DSFRM}{
Display a textual description of the Current Frame in a FrameSet
}
\noteroutine{KPG1\_DWSOx}{
Obtains for the scale and offset for a linear transformation from
world to data co-ordinates
}
\noteroutine{KPG1\_DWSOx}{
Obtains for the scale and offset for a linear transformation from
world to data co-ordinates
}
\noteroutine{KPG1\_ELNMx}{
Writes a range of element numbers into an array
}
\noteroutine{KPG1\_ELNMx}{
Writes a range of element numbers into an array
}
\noteroutine{KPG1\_ELNMx}{
Writes a range of element numbers into an array
}
\noteroutine{KPG1\_ELNMx}{
Writes a range of element numbers into an array
}
\noteroutine{KPG1\_ELNMx}{
Writes a range of element numbers into an array
}
\noteroutine{KPG1\_ELNMx}{
Writes a range of element numbers into an array
}
\noteroutine{KPG1\_ELNMx}{
Writes a range of element numbers into an array
}
\noteroutine{KPG1\_ENV0R}{
Reads a floating point value from an environment variable
}
\noteroutine{KPG1\_ENVDF}{
See if an environment variable is defined
}
\noteroutine{KPG1\_ERBAR}{
Plots various kinds of error bar
}
\noteroutine{KPG1\_EXPOx}{
Takes the exponential to an arbitrary base of an array and its
variance
}
\noteroutine{KPG1\_EXPOx}{
Takes the exponential to an arbitrary base of an array and its
variance
}
\noteroutine{KPG1\_EXPOx}{
Takes the exponential to an arbitrary base of an array and its
variance
}
\noteroutine{KPG1\_EXPOx}{
Takes the exponential to an arbitrary base of an array and its
variance
}
\noteroutine{KPG1\_EXPOx}{
Takes the exponential to an arbitrary base of an array and its
variance
}
\noteroutine{KPG1\_EXPOx}{
Takes the exponential to an arbitrary base of an array and its
variance
}
\noteroutine{KPG1\_EXPOx}{
Takes the exponential to an arbitrary base of an array and its
variance
}
\noteroutine{KPG1\_FFRx}{
Reads free-format floating-point data from a string
}
\noteroutine{KPG1\_FFRx}{
Reads free-format floating-point data from a string
}
\noteroutine{KPG1\_FFTBD}{
Takes the inverse (Backward) FFT of a real image
}
\noteroutine{KPG1\_FFTBR}{
Takes the inverse (Backward) FFT of a real image
}
\noteroutine{KPG1\_FFTFD}{
Takes the forward FFT of a real image
}
\noteroutine{KPG1\_FFTFR}{
Takes the forward FFT of a real image
}
\noteroutine{KPG1\_FHDAT}{
Converts the NDF history date into a more-pleasing format
}
\noteroutine{KPG1\_FILLx}{
Sets all elements in a vectorised array to a specified value
}
\noteroutine{KPG1\_FILLx}{
Sets all elements in a vectorised array to a specified value
}
\noteroutine{KPG1\_FILLx}{
Sets all elements in a vectorised array to a specified value
}
\noteroutine{KPG1\_FILLx}{
Sets all elements in a vectorised array to a specified value
}
\noteroutine{KPG1\_FILLx}{
Sets all elements in a vectorised array to a specified value
}
\noteroutine{KPG1\_FILLx}{
Sets all elements in a vectorised array to a specified value
}
\noteroutine{KPG1\_FILLx}{
Sets all elements in a vectorised array to a specified value
}
\noteroutine{KPG1\_FIT1D}{
Fit a least squares straight line to supplied data
}
\noteroutine{KPG1\_FLASx}{
Flashes image into a cell array
}
\noteroutine{KPG1\_FLASx}{
Flashes image into a cell array
}
\noteroutine{KPG1\_FLASx}{
Flashes image into a cell array
}
\noteroutine{KPG1\_FLASx}{
Flashes image into a cell array
}
\noteroutine{KPG1\_FLASx}{
Flashes image into a cell array
}
\noteroutine{KPG1\_FLCOx}{
Obtains a list of co-ordinates from a text file
}
\noteroutine{KPG1\_FLCOx}{
Obtains a list of co-ordinates from a text file
}
\noteroutine{KPG1\_FLIPx}{
Reverse the pixels in an N-dimensional array along a specified
dimension
}
\noteroutine{KPG1\_FLIPx}{
Reverse the pixels in an N-dimensional array along a specified
dimension
}
\noteroutine{KPG1\_FLIPx}{
Reverse the pixels in an N-dimensional array along a specified
dimension
}
\noteroutine{KPG1\_FLIPx}{
Reverse the pixels in an N-dimensional array along a specified
dimension
}
\noteroutine{KPG1\_FLIPx}{
Reverse the pixels in an N-dimensional array along a specified
dimension
}
\noteroutine{KPG1\_FLIPx}{
Reverse the pixels in an N-dimensional array along a specified
dimension
}
\noteroutine{KPG1\_FLIPx}{
Reverse the pixels in an N-dimensional array along a specified
dimension
}
\noteroutine{KPG1\_FLOOR}{
Return the largest integer smaller than or equal to a supplied value
}
\noteroutine{KPG1\_FLPTH}{
Get the full path to a file given relative to a specified root directory
}
\noteroutine{KPG1\_FRACx}{
Finds values corresponding to specified fractions of an array{\tt '}s
ordered distribution
}
\noteroutine{KPG1\_FRACx}{
Finds values corresponding to specified fractions of an array{\tt '}s
ordered distribution
}
\noteroutine{KPG1\_FRACx}{
Finds values corresponding to specified fractions of an array{\tt '}s
ordered distribution
}
\noteroutine{KPG1\_FRACx}{
Finds values corresponding to specified fractions of an array{\tt '}s
ordered distribution
}
\noteroutine{KPG1\_FRACx}{
Finds values corresponding to specified fractions of an array{\tt '}s
ordered distribution
}
\noteroutine{KPG1\_FRACx}{
Finds values corresponding to specified fractions of an array{\tt '}s
ordered distribution
}
\noteroutine{KPG1\_FRACx}{
Finds values corresponding to specified fractions of an array{\tt '}s
ordered distribution
}
\noteroutine{KPG1\_FRPIC}{
Creates a frame picture of a given size within the current
picture
}
\noteroutine{KPG1\_GAUFx}{
To fit a Gaussian to a one-dimensional array of data
}
\noteroutine{KPG1\_GAUFx}{
To fit a Gaussian to a one-dimensional array of data
}
\noteroutine{KPG1\_GAUFx}{
To fit a Gaussian to a one-dimensional array of data
}
\noteroutine{KPG1\_GAUFx}{
To fit a Gaussian to a one-dimensional array of data
}
\noteroutine{KPG1\_GAUFx}{
To fit a Gaussian to a one-dimensional array of data
}
\noteroutine{KPG1\_GAUFx}{
To fit a Gaussian to a one-dimensional array of data
}
\noteroutine{KPG1\_GAUFx}{
To fit a Gaussian to a one-dimensional array of data
}
\noteroutine{KPG1\_GAUSx}{
Smooth a 2-dimensional array using a symmetrical Gaussian PSF
}
\noteroutine{KPG1\_GAUSx}{
Smooth a 2-dimensional array using a symmetrical Gaussian PSF
}
\noteroutine{KPG1\_GAXLB}{
Obtains an axis annotation for an NDF axis
}
\noteroutine{KPG1\_GCA}{
Plots a cell array
}
\noteroutine{KPG1\_GDARE}{
Defines a region within the current PGPLOT window
}
\noteroutine{KPG1\_GDBND}{
Get the bounds of a new PGPLOT window from the environment
}
\noteroutine{KPG1\_GDGET}{
Get the AST Plot associated with an AGI picture
}
\noteroutine{KPG1\_GDNEW}{
Create a new DATA picture with ancillary pictures
}
\noteroutine{KPG1\_GDOLD}{
Create a new DATA picture with ancillary pictures aligned with
an existing DATA picture
}
\noteroutine{KPG1\_GDPUT}{
Save an AST Plot with a graphics database picture
}
\noteroutine{KPG1\_GDQPC}{
Return the extent of the current picture
}
\noteroutine{KPG1\_GDWIN}{
Set PGPLOT world co-ordinates to be the world co-ordinates
of the specified AGI picture
}
\noteroutine{KPG1\_GETIM}{
Get locators to an IMAGE-type structure and structure holding the
data array for data input
}
\noteroutine{KPG1\_GETYP}{
Obtains a valid HDS primitive data type via a parameter
}
\noteroutine{KPG1\_GHSTx}{
Calculates the histogram of an array of data
}
\noteroutine{KPG1\_GHSTx}{
Calculates the histogram of an array of data
}
\noteroutine{KPG1\_GHSTx}{
Calculates the histogram of an array of data
}
\noteroutine{KPG1\_GHSTx}{
Calculates the histogram of an array of data
}
\noteroutine{KPG1\_GHSTx}{
Calculates the histogram of an array of data
}
\noteroutine{KPG1\_GHSTx}{
Calculates the histogram of an array of data
}
\noteroutine{KPG1\_GHSTx}{
Calculates the histogram of an array of data
}
\noteroutine{KPG1\_GILST}{
Selects integers within a range of values
}
\noteroutine{KPG1\_GKEYx}{
Plots a colour-table key and title in the current SGS zone
}
\noteroutine{KPG1\_GKEYx}{
Plots a colour-table key and title in the current SGS zone
}
\noteroutine{KPG1\_GKEYx}{
Plots a colour-table key and title in the current SGS zone
}
\noteroutine{KPG1\_GKEYx}{
Plots a colour-table key and title in the current SGS zone
}
\noteroutine{KPG1\_GKEYx}{
Plots a colour-table key and title in the current SGS zone
}
\noteroutine{KPG1\_GKEYx}{
Plots a colour-table key and title in the current SGS zone
}
\noteroutine{KPG1\_GKEYx}{
Plots a colour-table key and title in the current SGS zone
}
\noteroutine{KPG1\_GNLBU}{
Obtains an axis annotation for NDF data or variance
}
\noteroutine{KPG1\_GNTIT}{
Obtains a title using the NDF title as the suggested default
}
\noteroutine{KPG1\_GPCOL}{
Obtains the red, green and blue intensities of a colour by value
or by name for the standard colour set
}
\noteroutine{KPG1\_GRAPH}{
Draws a line graph
}
\noteroutine{KPG1\_GRLM1}{
Find the default limits for a graph axis
}
\noteroutine{KPG1\_GRLM2}{
Find the default limits for a graph axis
}
\noteroutine{KPG1\_GRPHW}{
Draws a line graph, using supplied work arrays
}
\noteroutine{KPG1\_GTAXI}{
Select Frame axes using an environment parameter
}
\noteroutine{KPG1\_GTAXV}{
Gets one or more formatted axis values from the environment
}
\noteroutine{KPG1\_GTCHV}{
Obtain a vector of choices from the environment
}
\noteroutine{KPG1\_GTCOL}{
Obtain a marker colour, given a colour specification
}
\noteroutine{KPG1\_GTGRP}{
Obtain a group of strings from the environment
}
\noteroutine{KPG1\_GTNDF}{
Gets an NDF or NDF section with a specified number of significant
dimensions
}
\noteroutine{KPG1\_GTPOS}{
Get a spatial position from the environment
}
\noteroutine{KPG1\_GTWCS}{
Get an AST FrameSet from an NDF
}
\noteroutine{KPG1\_H2AST}{
Copy AST\_ data from an HDS object
}
\noteroutine{KPG1\_HCONx}{
Take the complex conjugate of an Hermitian image
}
\noteroutine{KPG1\_HCONx}{
Take the complex conjugate of an Hermitian image
}
\noteroutine{KPG1\_HMLTx}{
Multiply two Hermitian images
}
\noteroutine{KPG1\_HMLTx}{
Multiply two Hermitian images
}
\noteroutine{KPG1\_HMSG}{
Assign the name of an HDS object to a message token
}
\noteroutine{KPG1\_HRCPx}{
Finds the reciprocal of a purely real Hermitian image
}
\noteroutine{KPG1\_HSDSx}{
Tabulates an histogram
}
\noteroutine{KPG1\_HSDSx}{
Tabulates an histogram
}
\noteroutine{KPG1\_HSFLx}{
Writes an histogram to a Fortran formatted file
}
\noteroutine{KPG1\_HSFLx}{
Writes an histogram to a Fortran formatted file
}
\noteroutine{KPG1\_HSSTP}{
Calculates statistics from an histogram
}
\noteroutine{KPG1\_HSTAx}{
Compute simple ordered statistics for an array via an histogram
}
\noteroutine{KPG1\_HSTAx}{
Compute simple ordered statistics for an array via an histogram
}
\noteroutine{KPG1\_HSTAx}{
Compute simple ordered statistics for an array via an histogram
}
\noteroutine{KPG1\_HSTAx}{
Compute simple ordered statistics for an array via an histogram
}
\noteroutine{KPG1\_HSTAx}{
Compute simple ordered statistics for an array via an histogram
}
\noteroutine{KPG1\_HSTAx}{
Compute simple ordered statistics for an array via an histogram
}
\noteroutine{KPG1\_HSTAx}{
Compute simple ordered statistics for an array via an histogram
}
\noteroutine{KPG1\_HSTFx}{
Finds values corresponding to specified fractions of an histogram
}
\noteroutine{KPG1\_HSTFx}{
Finds values corresponding to specified fractions of an histogram
}
\noteroutine{KPG1\_HSTLO}{
Computes the values to display for a histogram
}
\noteroutine{KPG1\_HSTQx}{
Equalises the histogram of an array
}
\noteroutine{KPG1\_HSTQx}{
Equalises the histogram of an array
}
\noteroutine{KPG1\_HSTQx}{
Equalises the histogram of an array
}
\noteroutine{KPG1\_HSTQx}{
Equalises the histogram of an array
}
\noteroutine{KPG1\_HSTQx}{
Equalises the histogram of an array
}
\noteroutine{KPG1\_HSTQx}{
Equalises the histogram of an array
}
\noteroutine{KPG1\_HSTQx}{
Equalises the histogram of an array
}
\noteroutine{KPG1\_IDERR}{
Reports an IDI error and copies IDI status to inherited status
}
\noteroutine{KPG1\_IMPRG}{
Propagates NDF information for IMAGE-format applications
}
\noteroutine{KPG1\_INCOx}{
Obtains a list of co-ordinates from the environment
}
\noteroutine{KPG1\_INCOx}{
Obtains a list of co-ordinates from the environment
}
\noteroutine{KPG1\_IS3D}{
To sort the list of data orddat into increasing order, also sorts
the ancillary data DDAT and PDAT correspondingly
}
\noteroutine{KPG1\_IS3R}{
To sort the list of data orddat into increasing order, also sorts
the ancillary data DDAT and PDAT correspondingly
}
\noteroutine{KPG1\_ISCLx}{
Scale image between limits
}
\noteroutine{KPG1\_ISCLx}{
Scale image between limits
}
\noteroutine{KPG1\_ISCLx}{
Scale image between limits
}
\noteroutine{KPG1\_ISCLx}{
Scale image between limits
}
\noteroutine{KPG1\_ISCLx}{
Scale image between limits
}
\noteroutine{KPG1\_ISSCS}{
Extract the epoch of the reference equinox from a string
specifying an IRAS90 Sky Coordinate System
}
\noteroutine{KPG1\_IVCI}{
Obtains a valid colour index
}
\noteroutine{KPG1\_IWCG}{
Inquires a characteristic of a GKS device
}
\noteroutine{KPG1\_KEYZO}{
Obtains SGS zones for a frame and a key within the current zone
}
\noteroutine{KPG1\_KGODx}{
Sort through a dataset and throw away bad values
}
\noteroutine{KPG1\_LASTO}{
Locates the last occurrence of CVAL in STRING
}
\noteroutine{KPG1\_LGTRN}{
Saves a transformation for a base-10 logarithmic plot in the AGI
database
}
\noteroutine{KPG1\_LINTD}{
Obtains a linear transformation between 2 sets of x,y positions
with least squared error
}
\noteroutine{KPG1\_LISTC}{
Lists a character array to an ASCII file or reports it to the
user
}
\noteroutine{KPG1\_LITNx}{
Creates linear transformation expressions between two
n-dimensional co-ordinate systems
}
\noteroutine{KPG1\_LITNx}{
Creates linear transformation expressions between two
n-dimensional co-ordinate systems
}
\noteroutine{KPG1\_LITRx}{
Saves a transformation for a linear plot in the AGI database
}
\noteroutine{KPG1\_LITRx}{
Saves a transformation for a linear plot in the AGI database
}
\noteroutine{KPG1\_LLTRx}{
Saves a transformation for a data co-ordinate linear or
logarithmic plot in the AGI database
}
\noteroutine{KPG1\_LLTRx}{
Saves a transformation for a data co-ordinate linear or
logarithmic plot in the AGI database
}
\noteroutine{KPG1\_LOCTB}{
Locates the centroid of a blob image feature in an n-D array
}
\noteroutine{KPG1\_LOCTD}{
Locates the centroid of a blob image feature in an n-D array
}
\noteroutine{KPG1\_LOCTI}{
Locates the centroid of a blob image feature in an n-D array
}
\noteroutine{KPG1\_LOCTR}{
Locates the centroid of a blob image feature in an n-D array
}
\noteroutine{KPG1\_LOCTUB}{
Locates the centroid of a blob image feature in an n-D array
}
\noteroutine{KPG1\_LOCTUW}{
Locates the centroid of a blob image feature in an n-D array
}
\noteroutine{KPG1\_LOCTW}{
Locates the centroid of a blob image feature in an n-D array
}
\noteroutine{KPG1\_LOGAx}{
Takes the logarithm to an arbitrary base of an array and its
variance
}
\noteroutine{KPG1\_LOGAx}{
Takes the logarithm to an arbitrary base of an array and its
variance
}
\noteroutine{KPG1\_LOGAx}{
Takes the logarithm to an arbitrary base of an array and its
variance
}
\noteroutine{KPG1\_LOGAx}{
Takes the logarithm to an arbitrary base of an array and its
variance
}
\noteroutine{KPG1\_LOGAx}{
Takes the logarithm to an arbitrary base of an array and its
variance
}
\noteroutine{KPG1\_LOGAx}{
Takes the logarithm to an arbitrary base of an array and its
variance
}
\noteroutine{KPG1\_LOGAx}{
Takes the logarithm to an arbitrary base of an array and its
variance
}
\noteroutine{KPG1\_LSTAR}{
Write a section of a 2D array to a text file
}
\noteroutine{KPG1\_LTGET}{
Obtain a locator to an array holding a colour table for the currently
opened graphics device
}
\noteroutine{KPG1\_LTLOD}{
Load the colour table for the currently open graphics device
}
\noteroutine{KPG1\_LTSAV}{
Save the colour table for the currently open graphics device
}
\noteroutine{KPG1\_LUDCx}{
Performs an LU decomposition of a square matrix
}
\noteroutine{KPG1\_LUDCx}{
Performs an LU decomposition of a square matrix
}
\noteroutine{KPG1\_LUTIN}{
Transfers a lookup table between arrays that have different
numbers of colour indices
}
\noteroutine{KPG1\_LUTK2}{
Set up the pixel colour indices which form a LUT key
}
\noteroutine{KPG1\_LUTK3}{
Produce a GRAPH colour table key for KPG1\_LUTKY
}
\noteroutine{KPG1\_LUTK4}{
Produce an AST Mapping from pen number to RGB intensity
}
\noteroutine{KPG1\_LUTKY}{
Draw a key showing a colour table
}
\noteroutine{KPG1\_MACOL}{
Obtain a marker colour
}
\noteroutine{KPG1\_MANIB}{
Copy a data array with axis permutation and expansion
}
\noteroutine{KPG1\_MANID}{
Copy a data array with axis permutation and expansion
}
\noteroutine{KPG1\_MANII}{
Copy a data array with axis permutation and expansion
}
\noteroutine{KPG1\_MANIR}{
Copy a data array with axis permutation and expansion
}
\noteroutine{KPG1\_MANIUB}{
Copy a data array with axis permutation and expansion
}
\noteroutine{KPG1\_MANIUW}{
Copy a data array with axis permutation and expansion
}
\noteroutine{KPG1\_MANIW}{
Copy a data array with axis permutation and expansion
}
\noteroutine{KPG1\_MAP}{
Obtain mapped access to an array component of an NDF
}
\noteroutine{KPG1\_MDETx}{
Computes the determinant of a matrix
}
\noteroutine{KPG1\_MDETx}{
Computes the determinant of a matrix
}
\noteroutine{KPG1\_MEANx}{
Finds the mean of the good data values in an array
}
\noteroutine{KPG1\_MEANx}{
Finds the mean of the good data values in an array
}
\noteroutine{KPG1\_MEANx}{
Finds the mean of the good data values in an array
}
\noteroutine{KPG1\_MEANx}{
Finds the mean of the good data values in an array
}
\noteroutine{KPG1\_MEANx}{
Finds the mean of the good data values in an array
}
\noteroutine{KPG1\_MEANx}{
Finds the mean of the good data values in an array
}
\noteroutine{KPG1\_MEANx}{
Finds the mean of the good data values in an array
}
\noteroutine{KPG1\_MEDUB}{
Derives the unweighted median of a vector
}
\noteroutine{KPG1\_MEDUD}{
Derives the unweighted median of a vector
}
\noteroutine{KPG1\_MEDUI}{
Derives the unweighted median of a vector
}
\noteroutine{KPG1\_MEDUR}{
Derives the unweighted median of a vector
}
\noteroutine{KPG1\_MEDUUB}{
Derives the unweighted median of a vector
}
\noteroutine{KPG1\_MEDUUW}{
Derives the unweighted median of a vector
}
\noteroutine{KPG1\_MEDUW}{
Derives the unweighted median of a vector
}
\noteroutine{KPG1\_MIXVx}{
Obtains from a parameter character values from either a menu of
options or within a numeric range
}
\noteroutine{KPG1\_MIXVx}{
Obtains from a parameter character values from either a menu of
options or within a numeric range
}
\noteroutine{KPG1\_MIXVx}{
Obtains from a parameter character values from either a menu of
options or within a numeric range
}
\noteroutine{KPG1\_MIXVx}{
Obtains from a parameter character values from either a menu of
options or within a numeric range
}
\noteroutine{KPG1\_MIXVx}{
Obtains from a parameter character values from either a menu of
options or within a numeric range
}
\noteroutine{KPG1\_MIXVx}{
Obtains from a parameter character values from either a menu of
options or within a numeric range
}
\noteroutine{KPG1\_MIXVx}{
Obtains from a parameter character values from either a menu of
options or within a numeric range
}
\noteroutine{KPG1\_MKPOS}{
Mark a position on a graphics device
}
\noteroutine{KPG1\_MXMNx}{
Returns the maximum and minimum values of an array within
thresholds
}
\noteroutine{KPG1\_MXMNx}{
Returns the maximum and minimum values of an array within
thresholds
}
\noteroutine{KPG1\_MXMNx}{
Returns the maximum and minimum values of an array within
thresholds
}
\noteroutine{KPG1\_MXMNx}{
Returns the maximum and minimum values of an array within
thresholds
}
\noteroutine{KPG1\_MXMNx}{
Returns the maximum and minimum values of an array within
thresholds
}
\noteroutine{KPG1\_MXMNx}{
Returns the maximum and minimum values of an array within
thresholds
}
\noteroutine{KPG1\_MXMNx}{
Returns the maximum and minimum values of an array within
thresholds
}
\noteroutine{KPG1\_MODEx}{
To estimate the mean of a number of normally distributed data
values, some of which may be corrupt
}
\noteroutine{KPG1\_MODEx}{
To estimate the mean of a number of normally distributed data
values, some of which may be corrupt
}
\noteroutine{KPG1\_MODEx}{
To estimate the mean of a number of normally distributed data
values, some of which may be corrupt
}
\noteroutine{KPG1\_MODEx}{
To estimate the mean of a number of normally distributed data
values, some of which may be corrupt
}
\noteroutine{KPG1\_MODEx}{
To estimate the mean of a number of normally distributed data
values, some of which may be corrupt
}
\noteroutine{KPG1\_MODEx}{
To estimate the mean of a number of normally distributed data
values, some of which may be corrupt
}
\noteroutine{KPG1\_MODEx}{
To estimate the mean of a number of normally distributed data
values, some of which may be corrupt
}
\noteroutine{KPG1\_MONOx}{
Determines whether an array{\tt '}s values increase or decrease
monotonically
}
\noteroutine{KPG1\_MONOx}{
Determines whether an array{\tt '}s values increase or decrease
monotonically
}
\noteroutine{KPG1\_MTHEx}{
Evaluate a mathematical expression for a set of data and variance
arrays
}
\noteroutine{KPG1\_MTHEx}{
Evaluate a mathematical expression for a set of data and variance
arrays
}
\noteroutine{KPG1\_MULx}{
Multiply two vectorised arrays with optional variance information
}
\noteroutine{KPG1\_MULx}{
Multiply two vectorised arrays with optional variance information
}
\noteroutine{KPG1\_MULx}{
Multiply two vectorised arrays with optional variance information
}
\noteroutine{KPG1\_MXMEx}{
Returns the maximum and minimum values between thresholds of an
array including its errors
}
\noteroutine{KPG1\_MXMEx}{
Returns the maximum and minimum values between thresholds of an
array including its errors
}
\noteroutine{KPG1\_MXMEx}{
Returns the maximum and minimum values between thresholds of an
array including its errors
}
\noteroutine{KPG1\_MXMEx}{
Returns the maximum and minimum values between thresholds of an
array including its errors
}
\noteroutine{KPG1\_MXMEx}{
Returns the maximum and minimum values between thresholds of an
array including its errors
}
\noteroutine{KPG1\_MXMEx}{
Returns the maximum and minimum values between thresholds of an
array including its errors
}
\noteroutine{KPG1\_MXMEx}{
Returns the maximum and minimum values between thresholds of an
array including its errors
}
\noteroutine{KPG1\_MXMNx}{
Returns the maximum and minimum values of an array
}
\noteroutine{KPG1\_MXMNx}{
Returns the maximum and minimum values of an array
}
\noteroutine{KPG1\_MXMNx}{
Returns the maximum and minimum values of an array
}
\noteroutine{KPG1\_MXMNx}{
Returns the maximum and minimum values of an array
}
\noteroutine{KPG1\_MXMNx}{
Returns the maximum and minimum values of an array
}
\noteroutine{KPG1\_MXMNx}{
Returns the maximum and minimum values of an array
}
\noteroutine{KPG1\_MXMNx}{
Returns the maximum and minimum values of an array
}
\noteroutine{KPG1\_NACVT}{
Convert an HDS object hierarchy to native data representation
}
\noteroutine{KPG1\_NAG2R}{
Converts an NAG Hermitian Fourier transform array into an array
usable by FFTPACK routine KPG1\_RFFTB
}
\noteroutine{KPG1\_NAGTC}{
Swaps argument order when getting a mapped character array from
an HDS object
}
\noteroutine{KPG1\_NAPTC}{
Swaps argument order when putting a mapped character array into
an HDS object
}
\noteroutine{KPG1\_NBADD}{
Finds the number of bad values in an array
}
\noteroutine{KPG1\_NCAXS}{
Draws NCAR annotated axes in the current SGS zone
}
\noteroutine{KPG1\_NDFNM}{
Return the name of an NDF without a directory path (Unix only)
}
\noteroutine{KPG1\_NMCOL}{
Finds the RGB intensities of a named colour
}
\noteroutine{KPG1\_NOISx}{
Adds random Normal noise to a 1-d array
}
\noteroutine{KPG1\_NOISx}{
Adds random Normal noise to a 1-d array
}
\noteroutine{KPG1\_NOISx}{
Adds random Normal noise to a 1-d array
}
\noteroutine{KPG1\_NOISx}{
Adds random Normal noise to a 1-d array
}
\noteroutine{KPG1\_NOISx}{
Adds random Normal noise to a 1-d array
}
\noteroutine{KPG1\_NOISx}{
Adds random Normal noise to a 1-d array
}
\noteroutine{KPG1\_NOISx}{
Adds random Normal noise to a 1-d array
}
\noteroutine{KPG\_NTHMx}{
Returns the n smallest values in a BYTE array
}
\noteroutine{KPG\_NTHMx}{
Returns the n smallest values in a DOUBLE PRECISION array
}
\noteroutine{KPG\_NTHMx}{
Returns the n smallest values in a INTEGER array
}
\noteroutine{KPG\_NTHMx}{
Returns the n smallest values in a REAL array
}
\noteroutine{KPG\_NTHMx}{
Returns the n smallest values in a UNSIGNED BYTE array
}
\noteroutine{KPG\_NTHMx}{
Returns the n smallest values in a UNSIGNED WORD array
}
\noteroutine{KPG\_NTHMx}{
Returns the n smallest values in a WORD array
}
\noteroutine{KPG1\_NUMBx}{
Counts the number of elements with values or absolute values
above or below a limit
}
\noteroutine{KPG1\_NUMBx}{
Counts the number of elements with values or absolute values
above or below a limit
}
\noteroutine{KPG1\_NUMBx}{
Counts the number of elements with values or absolute values
above or below a limit
}
\noteroutine{KPG1\_NUMBx}{
Counts the number of elements with values or absolute values
above or below a limit
}
\noteroutine{KPG1\_NUMBx}{
Counts the number of elements with values or absolute values
above or below a limit
}
\noteroutine{KPG1\_NUMBx}{
Counts the number of elements with values or absolute values
above or below a limit
}
\noteroutine{KPG1\_NUMBx}{
Counts the number of elements with values or absolute values
above or below a limit
}
\noteroutine{KPG1\_NUMFL}{
This counts the number of lines in a text file
}
\noteroutine{KPG1\_ORVAR}{
To return the variances and covariances of the order statistics
from n to 1, assuming an initially normal distribution
}
\noteroutine{KPG1\_PACOL}{
Obtain a marker colour
}
\noteroutine{KPG1\_PALCI}{
Finds the nearest colour in the palette to a named colour
}
\noteroutine{KPG1\_PASTx}{
Pastes an array onto another
}
\noteroutine{KPG1\_PASTx}{
Pastes an array onto another
}
\noteroutine{KPG1\_PASTx}{
Pastes an array onto another
}
\noteroutine{KPG1\_PASTx}{
Pastes an array onto another
}
\noteroutine{KPG1\_PASTx}{
Pastes an array onto another
}
\noteroutine{KPG1\_PASTx}{
Pastes an array onto another
}
\noteroutine{KPG1\_PASTx}{
Pastes an array onto another
}
\noteroutine{KPG1\_PGCLR}{
Clear current PGPLOT viewport
}
\noteroutine{KPG1\_PGCLS}{
Close down the AGI database and PGPLOT workstation
}
\noteroutine{KPG1\_PGCOL}{
Obtain a marker colour, given a colour specification
}
\noteroutine{KPG1\_PGCUR}{
Use the cursor to get a set of points
}
\noteroutine{KPG1\_PGCUT}{
Cut a section out of the current PGPLOT window
}
\noteroutine{KPG1\_PGESC}{
Remove PGPLOT escape sequences from a text string
}
\noteroutine{KPG1\_PGLOC}{
Locate a component of an HDS structure relating to the currently
opened PGPLOT device
}
\noteroutine{KPG1\_PGLUT}{
Use an array of colour representations to set up the PGPLOT colour
table
}
\noteroutine{KPG1\_PGOPN}{
Open the AGI database and activate a PGPLOT workstation
}
\noteroutine{KPG1\_PGPIX}{
Display an image using PGPLOT
}
\noteroutine{KPG1\_PGSHT}{
Set the PGPLOT character size in world coordinates
}
\noteroutine{KPG1\_PGSTY}{
Establish values for graphics attributes
}
\noteroutine{KPG1\_PGTXT}{
Draw text using PGPLOT and return concatenation point
}
\noteroutine{KPG1\_PL2GE}{
Reads 2-dimensional polynomial information from a POLYNOMIAL
structure
}
\noteroutine{KPG1\_PL2PU}{
Writes 2-dimensional polynomial information to a POLYNOMIAL
structure
}
\noteroutine{KPG1\_PLCIP}{
Finds the nearest colour in the palette to a named colour
(PGPLOT version of KPG1\_PALCI)
}
\noteroutine{KPG1\_PLGET}{
Get the colour palette for the currently open graphics device from
a supplied array
}
\noteroutine{KPG1\_PLLOD}{
Load the colour palette for the currently open graphics device
}
\noteroutine{KPG1\_PLOTA}{
Open the graphics device and see if there is an existing DATA
picture with which the new DATA picture could be aligned
}
\noteroutine{KPG1\_PLOT}{
Prepare for graphics output
}
\noteroutine{KPG1\_PLOTN}{
Create a new DATA picture and ensure there is an AST Plot for it
}
\noteroutine{KPG1\_PLOTP}{
Create a new DATA picture, with optionally ancillary pictures
}
\noteroutine{KPG1\_PLOT}{
Save an AST Plot with an AGI DATA picture
}
\noteroutine{KPG1\_PLPUT}{
Put a section of the current colour palette into the supplied array
}
\noteroutine{KPG1\_PLSAV}{
Save the colour palette for the currently open graphics device
}
\noteroutine{KPG1\_PLTLN}{
Produces a graphical representation of a set of points in 2-D
}
\noteroutine{KPG1\_POISx}{
Takes values and returns them with Poisson noise added
}
\noteroutine{KPG1\_POISx}{
Takes values and returns them with Poisson noise added
}
\noteroutine{KPG1\_POISx}{
Takes values and returns them with Poisson noise added
}
\noteroutine{KPG1\_POISx}{
Takes values and returns them with Poisson noise added
}
\noteroutine{KPG1\_POISx}{
Takes values and returns them with Poisson noise added
}
\noteroutine{KPG1\_POISx}{
Takes values and returns them with Poisson noise added
}
\noteroutine{KPG1\_POISx}{
Takes values and returns them with Poisson noise added
}
\noteroutine{KPG1\_POWD}{
Raise each element of a vectorised array to a specified power
}
\noteroutine{KPG1\_POWR}{
Raise each element of a vectorised array to a specified power
}
\noteroutine{KPG1\_PQVID}{
Tests whether the current graphics device has suitable
image-display characteristics
}
\noteroutine{KPG1\_PRCUR}{
Prepares the graphics cursor to select points
}
\noteroutine{KPG1\_PRCVT}{
Convert an HDS primitive to a native data representation
}
\noteroutine{KPG1\_PRNTH}{
Locates the outer-most pair of parenthesis in a string
}
\noteroutine{KPG1\_PROWx}{
Put values into a row of a 2-dimensional array
}
\noteroutine{KPG1\_PROWx}{
Put values into a row of a 2-dimensional array
}
\noteroutine{KPG1\_PRSAx}{
Extracts a list of numerical values from a string
}
\noteroutine{KPG1\_PRSAx}{
Extracts a list of numerical values from a string
}
\noteroutine{KPG1\_PRSAx}{
Extracts a list of numerical values from a string
}
\noteroutine{KPG1\_PSEED}{
Set the PDA Random number seed
}
\noteroutine{KPG1\_PSFSx}{
Finds the approximate size of a 2-dimensional PSF
}
\noteroutine{KPG1\_PSFSx}{
Finds the approximate size of a 2-dimensional PSF
}
\noteroutine{KPG1\_PVERS}{
Parse a package version string
}
\noteroutine{KPG1\_PX2AX}{
Convert a pixel{\tt '}s indices into axis coordinates
}
\noteroutine{KPG1\_PXDPx}{
Expands an n-dimensional array by pixel duplication
}
\noteroutine{KPG1\_PXDPx}{
Expands an n-dimensional array by pixel duplication
}
\noteroutine{KPG1\_PXDPx}{
Expands an n-dimensional array by pixel duplication
}
\noteroutine{KPG1\_PXDPx}{
Expands an n-dimensional array by pixel duplication
}
\noteroutine{KPG1\_PXDPx}{
Expands an n-dimensional array by pixel duplication
}
\noteroutine{KPG1\_PXDPx}{
Expands an n-dimensional array by pixel duplication
}
\noteroutine{KPG1\_PXDPx}{
Expands an n-dimensional array by pixel duplication
}
\noteroutine{KPG1\_QCOL}{
Tests whether the current graphics device supports colour
}
\noteroutine{KPG1\_QIDAT}{
Inquires the number of colour indices and pixel dimensions of
the current workstation
}
\noteroutine{KPG1\_QNCOL}{
Inquires the number of intensity-table entries of the current
graphics device
}
\noteroutine{KPG1\_QNTLx}{
Finds a quantile in a (possibly weighted) set of data
}
\noteroutine{KPG1\_QNTLx}{
Finds a quantile in a (possibly weighted) set of data
}
\noteroutine{KPG1\_QSRTX}{
Sorts a vector via the Quicksort algorithm
}
\noteroutine{KPG1\_QSRTX}{
Sorts a vector via the Quicksort algorithm
}
\noteroutine{KPG1\_QSRTX}{
Sorts a vector via the Quicksort algorithm
}
\noteroutine{KPG1\_QSRTX}{
Sorts a vector via the Quicksort algorithm
}
\noteroutine{KPG1\_QSRTX}{
Sorts a vector via the Quicksort algorithm
}
\noteroutine{KPG1\_QSRTX}{
Sorts a vector via the Quicksort algorithm
}
\noteroutine{KPG1\_QSRTX}{
Sorts a vector via the Quicksort algorithm
}
\noteroutine{KPG1\_QSRTX}{
Sorts a vector via the Quicksort algorithm
}
\noteroutine{KPG1\_QVID}{
Tests whether the current graphics device has suitable
image-display characteristics
}
\noteroutine{KPG1\_R2NAG}{
Converts an FFTPACK Hermitian Fourier transform array into
the equivalent NAG array
}
\noteroutine{KPG1\_RCATW}{
Attempt to read an AST Object from a catalogue
}
\noteroutine{KPG1\_RDAST}{
Read AST\_ data as text from an HDS object
}
\noteroutine{KPG1\_RDLST}{
Reads a set of positions from a CAT catalogue
}
\noteroutine{KPG1\_REPRT}{
Reports a MSG message to user and also optionally write it to a file
}
\noteroutine{KPG1\_RETRx}{
Retrieves a value from an array
}
\noteroutine{KPG1\_RETRx}{
Retrieves a value from an array
}
\noteroutine{KPG1\_RETRx}{
Retrieves a value from an array
}
\noteroutine{KPG1\_RETRx}{
Retrieves a value from an array
}
\noteroutine{KPG1\_RETRx}{
Retrieves a value from an array
}
\noteroutine{KPG1\_RETRx}{
Retrieves a value from an array
}
\noteroutine{KPG1\_RETRx}{
Retrieves a value from an array
}
\noteroutine{KPG1\_RFCOx}{
Reads co-ordinate data from a text free-format file
}
\noteroutine{KPG1\_RFCOx}{
Reads co-ordinate data from a text free-format file
}
\noteroutine{KPG1\_RGLMT}{
Get the range limits of a range specification
}
\noteroutine{KPG1\_RGNDF}{
Get a group of existing NDFs
}
\noteroutine{KPG1\_RMAPx}{
Remaps an array{\tt '}s values according to an histogram key
}
\noteroutine{KPG1\_RMAPx}{
Remaps an array{\tt '}s values according to an histogram key
}
\noteroutine{KPG1\_RMAPx}{
Remaps an array{\tt '}s values according to an histogram key
}
\noteroutine{KPG1\_RMAPx}{
Remaps an array{\tt '}s values according to an histogram key
}
\noteroutine{KPG1\_RMAPx}{
Remaps an array{\tt '}s values according to an histogram key
}
\noteroutine{KPG1\_RMAPx}{
Remaps an array{\tt '}s values according to an histogram key
}
\noteroutine{KPG1\_RMAPx}{
Remaps an array{\tt '}s values according to an histogram key
}
\noteroutine{KPG1\_SATKC}{
Substitutes alphabetic (TRANSFORM) character tokens into a string
}
\noteroutine{KPG1\_SATKD}{
Substitutes alphabetic (TRANSFORM) numeric tokens into a string
}
\noteroutine{KPG1\_SCLOF}{
Applies a simple scaling and base-line shift to the values
contained in the input vector
}
\noteroutine{KPG1\_SCRSZ}{
Interrogates the system to find the width and height of the screen
on which it is running
}
\noteroutine{KPG1\_SDIMP}{
Obtains up to a number of significant dimensions of an NDF
}
\noteroutine{KPG1\_SDTRN}{
Saves the current SGS zone as a data picture and a reference to
the data object that was used to create it
}
\noteroutine{KPG1\_SECSH}{
Shifts bounds of upper dimensions that have one element to index
one
}
\noteroutine{KPG1\_SEED}{
Obtain a semi-random seed for random-number generation
}
\noteroutine{KPG1\_SGDIG}{
Determines the number of significant digits in a number
}
\noteroutine{KPG1\_SGDIM}{
Determines the number of significant dimensions in an NDF
}
\noteroutine{KPG1\_SHORT}{
Check whether a string matches a supplied abbreviation template
}
\noteroutine{KPG1\_SLICE}{
Find and remove any NDF slice specification from a name
}
\noteroutine{KPG1\_SNKTA}{
Write AST\_ data as text to a GRP group
}
\noteroutine{KPG1\_SOLIN}{
Sets the GKS line type to solid for all polylines
}
\noteroutine{KPG1\_SQSUx}{
Finds the sum of the squares of an array
}
\noteroutine{KPG1\_SQSUx}{
Finds the sum of the squares of an array
}
\noteroutine{KPG1\_SQSUx}{
Finds the sum of the squares of an array
}
\noteroutine{KPG1\_SRCTA}{
Read AST\_ data as text from a GRP group
}
\noteroutine{KPG1\_SSAZx}{
Applies a simple scaling and base-line shift to create the
output vector
}
\noteroutine{KPG1\_SSAZx}{
Applies a simple scaling and base-line shift to create the
output vector
}
\noteroutine{KPG1\_SSCOF}{
Applies a simple scaling and base-line shift to create the
output vector
}
\noteroutine{KPG1\_STATB}{
Compute simple statistics for an array
}
\noteroutine{KPG1\_STATD}{
Compute simple statistics for an array
}
\noteroutine{KPG1\_STATI}{
Compute simple statistics for an array
}
\noteroutine{KPG1\_STATR}{
Compute simple statistics for an array
}
\noteroutine{KPG1\_STATUB}{
Compute simple statistics for an array
}
\noteroutine{KPG1\_STATUW}{
Compute simple statistics for an array
}
\noteroutine{KPG1\_STATW}{
Compute simple statistics for an array
}
\noteroutine{KPG1\_STDSx}{
Display statistics generated by KPG1\_STATx and KPG1\_HSTAx
}
\noteroutine{KPG1\_STDSx}{
Display statistics generated by KPG1\_STATx and KPG1\_HSTAx
}
\noteroutine{KPG1\_STFLx}{
Write statistics generated by KPG1\_STATx and KPG1\_HSTAx to a
text file
}
\noteroutine{KPG1\_STFLx}{
Write statistics generated by KPG1\_STATx and KPG1\_HSTAx to a
text file
}
\noteroutine{KPG1\_STORx}{
Stores a value in an array
}
\noteroutine{KPG1\_STORx}{
Stores a value in an array
}
\noteroutine{KPG1\_STORx}{
Stores a value in an array
}
\noteroutine{KPG1\_STORx}{
Stores a value in an array
}
\noteroutine{KPG1\_STORx}{
Stores a value in an array
}
\noteroutine{KPG1\_STORx}{
Stores a value in an array
}
\noteroutine{KPG1\_STORx}{
Stores a value in an array
}
\noteroutine{KPG1\_TDLIx}{
Applies a constant-determinant transformation to an array by
linear interpolation
}
\noteroutine{KPG1\_TDLIx}{
Applies a constant-determinant transformation to an array by
linear interpolation
}
\noteroutine{KPG1\_TDLIx}{
Applies a constant-determinant transformation to an array by
linear interpolation
}
\noteroutine{KPG1\_TDLIx}{
Applies a constant-determinant transformation to an array by
linear interpolation
}
\noteroutine{KPG1\_TDLIx}{
Applies a constant-determinant transformation to an array by
linear interpolation
}
\noteroutine{KPG1\_TDLIx}{
Applies a constant-determinant transformation to an array by
linear interpolation
}
\noteroutine{KPG1\_TDLIx}{
Applies a constant-determinant transformation to an array by
linear interpolation
}
\noteroutine{KPG1\_THRSB}{
Sets pixels in array to defined new values outside limits
}
\noteroutine{KPG1\_THRSD}{
Sets pixels in array to defined new values outside limits
}
\noteroutine{KPG1\_THRSI}{
Sets pixels in array to defined new values outside limits
}
\noteroutine{KPG1\_THRSR}{
Sets pixels in array to defined new values outside limits
}
\noteroutine{KPG1\_THRSUB}{
Sets pixels in array to defined new values outside limits
}
\noteroutine{KPG1\_THRSUW}{
Sets pixels in array to defined new values outside limits
}
\noteroutine{KPG1\_THRSW}{
Sets pixels in array to defined new values outside limits
}
\noteroutine{KPG1\_TRALx}{
Finds the extreme co-ordinates of an n-d array after being
transformed
}
\noteroutine{KPG1\_TRALx}{
Finds the extreme co-ordinates of an n-d array after being
transformed
}
\noteroutine{KPG1\_TRBOx}{
Finds the extreme co-ordinates of an n-d array after being
transformed
}
\noteroutine{KPG1\_TRBOx}{
Finds the extreme co-ordinates of an n-d array after being
transformed
}
\noteroutine{KPG1\_TRIGD}{
Apply a trig function to each element of a vectorised array
}
\noteroutine{KPG1\_TRIGR}{
Apply a trig function to each element of a vectorised array
}
\noteroutine{KPG1\_TRLIx}{
Applies a constant-determinant transformation to an array by
linear interpolation
}
\noteroutine{KPG1\_TRLIx}{
Applies a constant-determinant transformation to an array by
linear interpolation
}
\noteroutine{KPG1\_TRLIx}{
Applies a constant-determinant transformation to an array by
linear interpolation
}
\noteroutine{KPG1\_TRLIx}{
Applies a constant-determinant transformation to an array by
linear interpolation
}
\noteroutine{KPG1\_TRLIx}{
Applies a constant-determinant transformation to an array by
linear interpolation
}
\noteroutine{KPG1\_TRLIx}{
Applies a constant-determinant transformation to an array by
linear interpolation
}
\noteroutine{KPG1\_TRLIx}{
Applies a constant-determinant transformation to an array by
linear interpolation
}
\noteroutine{KPG1\_TRPIx}{
Finds vectorised pixel indices after applying a transformation to
an array{\tt '}s pixel co-ordinates
}
\noteroutine{KPG1\_TRPIx}{
Finds vectorised pixel indices after applying a transformation to
an array{\tt '}s pixel co-ordinates
}
\noteroutine{KPG1\_TRSPx}{
Transposes a 2-d array
}
\noteroutine{KPG1\_TRSPx}{
Transposes a 2-d array
}
\noteroutine{KPG1\_TRSPx}{
Transposes a 2-d array
}
\noteroutine{KPG1\_TRSPx}{
Transposes a 2-d array
}
\noteroutine{KPG1\_TRSPx}{
Transposes a 2-d array
}
\noteroutine{KPG1\_TRSPx}{
Transposes a 2-d array
}
\noteroutine{KPG1\_TRSPx}{
Transposes a 2-d array
}
\noteroutine{KPG1\_UNZ2x}{
Unzips a 2-dimensional co-ordinate array into two 1-dimensional
arrays
}
\noteroutine{KPG1\_UNZ2x}{
Unzips a 2-dimensional co-ordinate array into two 1-dimensional
arrays
}
\noteroutine{KPG1\_VASVx}{
Assigns values to an output array from an input array using a list
of indices
}
\noteroutine{KPG1\_VASVx}{
Assigns values to an output array from an input array using a list
of indices
}
\noteroutine{KPG1\_VASVx}{
Assigns values to an output array from an input array using a list
of indices
}
\noteroutine{KPG1\_VASVx}{
Assigns values to an output array from an input array using a list
of indices
}
\noteroutine{KPG1\_VASVx}{
Assigns values to an output array from an input array using a list
of indices
}
\noteroutine{KPG1\_VASVx}{
Assigns values to an output array from an input array using a list
of indices
}
\noteroutine{KPG1\_VASVx}{
Assigns values to an output array from an input array using a list
of indices
}
\noteroutine{KPG1\_VEC2N}{
Convert vectorised array indices into N-dimensional form
}
\noteroutine{KPG1\_VERB}{
Should the speified package report verbose messages?
}
\noteroutine{KPG1\_MKCAT}{
Write an AST Object to a catalogue
}
\noteroutine{KPG1\_WGNDF}{
Get a group of output NDF names
}
\noteroutine{KPG1\_WMODx}{
To estimate the mean of a number of normally distributed data
values, some of which may be corrupt
}
\noteroutine{KPG1\_WMODx}{
To estimate the mean of a number of normally distributed data
values, some of which may be corrupt
}
\noteroutine{KPG1\_WMODx}{
To estimate the mean of a number of normally distributed data
values, some of which may be corrupt
}
\noteroutine{KPG1\_WMODx}{
To estimate the mean of a number of normally distributed data
values, some of which may be corrupt
}
\noteroutine{KPG1\_WMODx}{
To estimate the mean of a number of normally distributed data
values, some of which may be corrupt
}
\noteroutine{KPG1\_WMODx}{
To estimate the mean of a number of normally distributed data
values, some of which may be corrupt
}
\noteroutine{KPG1\_WMODx}{
To estimate the mean of a number of normally distributed data
values, some of which may be corrupt
}
\noteroutine{KPG1\_WRAST}{
Write AST\_ data as text to an HDS object
}
\noteroutine{KPG1\_WREAD}{
Read an AST Object from an HDS object
}
\noteroutine{KPG1\_WRLS2}{
Puts a set of positions into a text file as a CAT catalogue
}
\noteroutine{KPG1\_WRLST}{
Writes a set of positions to a text file as a CAT catalogue
}
\noteroutine{KPG1\_WTM3D}{
To form the weighted median of a list of ordered data values.
Incrementing the contributing pixel buffers and estimating the
variance change
}
\noteroutine{KPG1\_WTM3R}{
To form the weighted median of a list of ordered data values
}
\noteroutine{KPG1\_WWRT}{
Write WCS information to an HDS object
}
\noteroutine{KPG1\_XYD2W}{
Converts linear data co-ordinates to world co-ordinates
}
\noteroutine{KPG1\_XYZWx}{
Converts a 2-dimensional array into a list of x-y co-ordinates,
values and weights
}
\noteroutine{KPG1\_XYZWx}{
Converts a 2-dimensional array into a list of x-y co-ordinates,
values and weights
}
\noteroutine{KPG1\_ZONES}{
Creates zones for plotting with an existing DATA zone
}
\noteroutine{KPG1\_ZOPIC}{
Creates zones required to produce a plot with key and axes
}
\noteroutine{LPG\_AGAIN}{
Decide if the application should be executed again
}
\noteroutine{LPG\_ASSOC}{
Obtain an identifier for an existing NDF via the parameter system
}
\noteroutine{LPG\_CATASSOC}{
Obtain an identifier for an existing catalogue via the parameter
system
}
\noteroutine{LPG\_CATCREAT}{
Create a new catalogue via the parameter system
}
\noteroutine{LPG\_CREA1}{
Create a single new simple NDF using a specified parameter
}
\noteroutine{LPG\_CREAT}{
Create a new simple NDF via the parameter system
}
\noteroutine{LPG\_CREP1}{
Create a single new primitive NDF using a specified parameter
}
\noteroutine{LPG\_CREP}{
Create a new primitive NDF via the parameter system
}
\noteroutine{LPG\_PROP1}{
Create a single new NDF by propagation using a specified parameter
}
\noteroutine{LPG\_PROP}{
Propagate NDF information to create a new NDF via the
parameter system
}
\noteroutine{LPG\_REPLA}{
Indicate if input NDFs can be replaced
}
\noteroutine{LPG\_START}{
Initialise the contents of the LPG common blocks
}
\noteroutine{LPG\_STATE}{
Return the original PAR state of a parameter
}

  \normalsize
\end{latexonly}

\newpage
\section{\xlabel{ro_full}Routine Descriptions\label{ro:full}}

% +
%  Name:
%     SST.TEX

%  Purpose:
%     Define LaTeX commands for laying out Starlink routine descriptions.

%  Language:
%     LaTeX

%  Type of Module:
%     LaTeX data file.

%  Description:
%     This file defines LaTeX commands which allow routine documentation
%     produced by the SST application PROLAT to be processed by LaTeX and
%     by LaTeX2html. The contents of this file should be included in the
%     source prior to any statements that make of the sst commands.

%  Notes:
%     The commands defined in the style file html.sty provided with LaTeX2html 
%     are used. These should either be made available by using the appropriate
%     sun.tex (with hypertext extensions) or by putting the file html.sty 
%     on your TEXINPUTS path (and including the name as part of the  
%     documentstyle declaration).

%  Authors:
%     RFWS: R.F. Warren-Smith (STARLINK)
%     PDRAPER: P.W. Draper (Starlink - Durham University)

%  History:
%     10-SEP-1990 (RFWS):
%        Original version.
%     10-SEP-1990 (RFWS):
%        Added the implementation status section.
%     12-SEP-1990 (RFWS):
%        Added support for the usage section and adjusted various spacings.
%     8-DEC-1994 (PDRAPER):
%        Added support for simplified formatting using LaTeX2html.
%     {enter_further_changes_here}

%  Bugs:
%     {note_any_bugs_here}

% -

%  Define length variables.
\newlength{\sstbannerlength}
\newlength{\sstcaptionlength}
\newlength{\sstexampleslength}
\newlength{\sstexampleswidth}

%  Define a \tt font of the required size.
\newfont{\ssttt}{cmtt10 scaled 1095}

%  Define a command to produce a routine header, including its name,
%  a purpose description and the rest of the routine's documentation.
\newcommand{\sstroutine}[3]{
   \goodbreak
   \rule{\textwidth}{0.5mm}
   \vspace{-7ex}
   \newline
   \settowidth{\sstbannerlength}{{\Large {\bf #1}}}
   \setlength{\sstcaptionlength}{\textwidth}
   \setlength{\sstexampleslength}{\textwidth}
   \addtolength{\sstbannerlength}{0.5em}
   \addtolength{\sstcaptionlength}{-2.0\sstbannerlength}
   \addtolength{\sstcaptionlength}{-5.0pt}
   \settowidth{\sstexampleswidth}{{\bf Examples:}}
   \addtolength{\sstexampleslength}{-\sstexampleswidth}
   \parbox[t]{\sstbannerlength}{\flushleft{\Large {\bf #1}}}
   \parbox[t]{\sstcaptionlength}{\center{\Large #2}}
   \parbox[t]{\sstbannerlength}{\flushright{\Large {\bf #1}}}
   \begin{description}
      #3
   \end{description}
}

%  Format the description section.
\newcommand{\sstdescription}[1]{\item[Description:] #1}

%  Format the usage section.
\newcommand{\sstusage}[1]{\item[Usage:] \mbox{} \\[1.3ex] {\ssttt #1}}


%  Format the invocation section.
\newcommand{\sstinvocation}[1]{\item[Invocation:]\hspace{0.4em}{\tt #1}}

%  Format the arguments section.
\newcommand{\sstarguments}[1]{
   \item[Arguments:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the returned value section (for a function).
\newcommand{\sstreturnedvalue}[1]{
   \item[Returned Value:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the parameters section (for an application).
\newcommand{\sstparameters}[1]{
   \item[Parameters:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Format the examples section.
\newcommand{\sstexamples}[1]{
   \item[Examples:] \mbox{} \\
   \vspace{-3.5ex}
   \begin{description}
      #1
   \end{description}
}

%  Define the format of a subsection in a normal section.
\newcommand{\sstsubsection}[1]{ \item[{#1}] \mbox{} \\}

%  Define the format of a subsection in the examples section.
\newcommand{\sstexamplesubsection}[2]{\sloppy
\item[\parbox{\sstexampleslength}{\ssttt #1}] \mbox{} \\ #2 }

%  Format the notes section.
\newcommand{\sstnotes}[1]{\item[Notes:] \mbox{} \\[1.3ex] #1}

%  Provide a general-purpose format for additional (DIY) sections.
\newcommand{\sstdiytopic}[2]{\item[{\hspace{-0.35em}#1\hspace{-0.35em}:}] \mbox{} \\[1.3ex] #2}

%  Format the implementation status section.
\newcommand{\sstimplementationstatus}[1]{
   \item[{Implementation Status:}] \mbox{} \\[1.3ex] #1}

%  Format the bugs section.
\newcommand{\sstbugs}[1]{\item[Bugs:] #1}

%  Format a list of items while in paragraph mode.
\newcommand{\sstitemlist}[1]{
  \mbox{} \\
  \vspace{-3.5ex}
  \begin{itemize}
     #1
  \end{itemize}
}

%  Define the format of an item.
\newcommand{\sstitem}{\item}

%  Now define html equivalents of those already set. These are used by
%  latex2html and are defined in the html.sty files.
\begin{htmlonly}

%  Re-define \ssttt.
   \newcommand{\ssttt}{\tt}

%  sstroutine.
   \renewcommand{\sstroutine}[3]{
      \subsection{#1\xlabel{#1}-\label{#1}#2}
      \begin{description}
         #3
      \end{description}
   }

%  sstdescription
   \renewcommand{\sstdescription}[1]{\item[Description:]
      \begin{description}
         #1
      \end{description}
   }

%  sstusage
   \renewcommand{\sstusage}[1]{\item[Usage:]
      \begin{description}
         {\ssttt #1}
      \end{description}
   }

%  sstinvocation
   \renewcommand{\sstinvocation}[1]{\item[Invocation:]
      \begin{description}
         {\ssttt #1}
      \end{description}
   }

%  sstarguments
   \renewcommand{\sstarguments}[1]{
      \item[Arguments:]
      \begin{description}
         #1
      \end{description}
   }

%  sstreturnedvalue
   \renewcommand{\sstreturnedvalue}[1]{
      \item[Returned Value:]
      \begin{description}
         #1
      \end{description}
   }

%  sstparameters
   \renewcommand{\sstparameters}[1]{
      \item[Parameters:]
      \begin{description}
         #1
      \end{description}
   }

%  sstexamples
   \renewcommand{\sstexamples}[1]{
      \item[Examples:]
      \begin{description}
         #1
      \end{description}
   }

%  sstsubsection
   \renewcommand{\sstsubsection}[1]{\item[{#1}]}

%  sstexamplesubsection
   \renewcommand{\sstexamplesubsection}[2]{\item[{\ssttt #1}] \\ #2}

%  sstnotes
   \renewcommand{\sstnotes}[1]{\item[Notes:]
      \begin{description}
         #1
      \end{description}
   }

%  sstdiytopic
   \renewcommand{\sstdiytopic}[2]{\item[{#1}]
      \begin{description}
         #2
      \end{description}
   }

%  sstimplementationstatus
   \renewcommand{\sstimplementationstatus}[1]{\item[Implementation Status:] 
      \begin{description}
         #1
      \end{description}
   }

%  sstitemlist
   \newcommand{\sstitemlist}[1]{
      \begin{itemize}
         #1
      \end{itemize}
   }
\end{htmlonly}

%  End of "sst.tex" layout definitions.
% .
% @(#)sst.tex   1.4   95/06/06 11:46:41   96/07/05 10:28:17

\small

\sstroutine{
   AIF\_ANTMP
}{
   Annul a locator to a temporary object, thereby erasing the object
}{
   \sstdescription{
      The routine annuls a locator to a temporary object created by
      AIF\_TEMP, thereby causing the associated object to be erased and
      the file space associated with it to be released. If data are
      mapped to the object via HDS, then they are first unmapped.
   }
   \sstinvocation{
      CALL AIF\_ANTMP( LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         HDS locator to the temporary object to be annulled. The
         character variable supplied is reset to a blank string by this
         routine.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine attempts to execute even if STATUS is set on
         entry. However, no additional error report is made if it
         subsequently fails under these circumstances.
      }
   }
}
\sstroutine{
   AIF\_ASFIO
}{
   Opens a sequential file via a parameter
}{
   \sstdescription{
      This routine opens a sequential file via FIO\_ASSOC.  Up to four
      attempts may be made to open the file.  If a null response is
      supplied the file is not opened, and the flag returned indicates
      this fact.
   }
   \sstinvocation{
      CALL AIF\_ASFIO( PNFILE, ACMODE, FORM, RECSZ, FD, OPEN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNFILE = CHARACTER$*$($*$)
      }{
         Parameter name by which file is to be opened
      }
      \sstsubsection{
         ACMODE = CHARACTER$*$($*$)
      }{
         Expression giving the required access mode.
           Valid modes are: {\tt '}READ{\tt '}, {\tt '}WRITE{\tt '}, {\tt '}UPDATE{\tt '} and {\tt '}APPEND{\tt '}.
           For details, see FIO\_OPEN.
      }
      \sstsubsection{
         FORM = CHARACTER$*$($*$)( READ )
      }{
         Expression giving the required formatting of the file.
           Valid formats are: {\tt '}FORTRAN{\tt '}, {\tt '}LIST{\tt '}, {\tt '}NONE{\tt '} and
           {\tt '}UNFORMATTED{\tt '}. For details, see FIO\_OPEN.
      }
      \sstsubsection{
         RECSZ = INTEGER( READ )
      }{
         Expression giving the maximum record size in bytes.
           Set it to zero if the Fortran default is required.
      }
      \sstsubsection{
         FD = INTEGER( WRITE )
      }{
         Variable to contain the file descriptor.
      }
      \sstsubsection{
         OPEN = LOGICAL( WRITE )
      }{
         If true the file has been opened.
      }
      \sstsubsection{
         STATUS = INTEGER( READ, WRITE )
      }{
         Global status value
      }
   }
   \sstdiytopic{
      Method
   }{
      Check for error on entry - return if not o.k.
      Initialise looping flag
      Do while no error obtaining the name and opening the output file
        and maximum number of attempts not exceeded
         Get file name and open file
         If null returned then
            Set flag so that a log file will not be created
            Annul the error
            Exit from the loop
         Else if error occurred then
            If abort requested, do so
            Increment loop counter
            If maximum number of attempts not exceeded then
               Report error
            Else
               Set looping flag to exit
            Endif
              Cancel parameter used to get filename
         Else
            Set flag to indicate that the file has been opened
            Set looping flag to false
         Endif
      Enddo
      If error then
         Report and abort
      Endif
      Return
   }
   \sstbugs{
      None known.
   }
}
\sstroutine{
   AIF\_FLNAM
}{
   Returns the name of a file as a character string given its
   parameter name
}{
   \sstdescription{
      Normally, the handles to HDS data files are locators and files
      are obtained via the parameter system.  The name of a data
      file itself is not available to applications via the user-level
      parameter-system library, and so applications cannot place the
      file name in log files or use the it to generate compound names.
      This routine provides that functionality by calling internal
      parameter-system routines to obtain the name.  This routine also
      works for Fortran files associated via an ADAM parameter.
   }
   \sstinvocation{
      CALL AIF\_FLNAM( PARNAM, FILNAM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARNAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Parameter name associated with the data object whose name is
         required.
      }
      \sstsubsection{
         FILNAM = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The name of the file.  If \%FILNAM is not long enough a bad
         status is returned.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This cannot be used to obtain the names of objects within
            an HDS file.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         Must have obtained the file via the input parameter.
      }
   }
}
\sstroutine{
   AIF\_GETVM
}{
   Obtains a pointer and a locator to mapped HDS workspace
}{
   \sstdescription{
      This routine obtains and file maps a temporary array of a given
      data type and dimensions via HDS.  A pointer to the mapped work
      array is returned, as is a locator so that the temporary array
      may be annulled when no longer required.
   }
   \sstinvocation{
      CALL AIF\_GETVM( TYPE, NDIM, DIMS, PNTR, WKLOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The HDS data type of the temporary array.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of dimensions of the work array.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the temporary array.
      }
      \sstsubsection{
         PNTR = INTEGER (Returned)
      }{
         The pointer to the mapped temporary array.
      }
      \sstsubsection{
         WKLOC = CHARACTER $*$ ( DAT\_\_SZLOC )(Returned)
      }{
         The HDS locator to the temporary array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      The current HDS tuning parameter MAP is stored, so that the
      temporary array may be accessed via file mapping, and upon exit
      restored to its former value.
   }
}
\sstroutine{
   AIF\_OPFIO
}{
   Opens a Fortran sequential file by name
}{
   \sstdescription{
      This routine opens a sequential file via FIO\_OPEN.  Up to four
      attempts may be made to open the file.  If a null response is
      supplied the file is not opened, and the flag returned indicates
      this fact.
   }
   \sstinvocation{
      CALL AIF\_OPFIO( FILNAM, ACMODE, FORM, RECSZ, FD, OPEN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FILNAM = CHARACTER$*$($*$)
      }{
         The name of the file to be opened.
      }
      \sstsubsection{
         ACMODE = CHARACTER$*$($*$)
      }{
         Expression giving the required access mode.
           Valid modes are: {\tt '}READ{\tt '}, {\tt '}WRITE{\tt '}, {\tt '}UPDATE{\tt '} and {\tt '}APPEND{\tt '}.
           For details, see FIO\_OPEN.
      }
      \sstsubsection{
         FORM = CHARACTER$*$($*$)( READ )
      }{
         Expression giving the required formatting of the file.
           Valid formats are: {\tt '}FORTRAN{\tt '}, {\tt '}LIST{\tt '}, {\tt '}NONE{\tt '} and
           {\tt '}UNFORMATTED{\tt '}. For details, see FIO\_OPEN.
      }
      \sstsubsection{
         RECSZ = INTEGER( READ )
      }{
         Expression giving the maximum record size in bytes.
           Set it to zero if the Fortran default is required.
      }
      \sstsubsection{
         FD = INTEGER( WRITE )
      }{
         Variable to contain the file descriptor.
      }
      \sstsubsection{
         OPEN = LOGICAL( WRITE )
      }{
         If true the file has been opened.
      }
      \sstsubsection{
         STATUS = INTEGER( READ, WRITE )
      }{
         Global status value
      }
   }
   \sstdiytopic{
      Method
   }{
      Check for error on entry - return if not o.k.
      Initialise looping flag
      Do while no error obtaining the name and opening the output file
        and maximum number of attempts not exceeded
         Get file name and open file
         If error occurred then
            If abort requested, do so
            Increment loop counter
            If maximum number of attempts not exceeded then
               Report error
            Else
               Set looping flag to exit
            Endif
         Else
            Set flag to indicate that the file has been opened
            Set looping flag to false
         Endif
      Enddo
      If error then
         Report and abort
      Endif
      Return
   }
   \sstbugs{
      None known.
   }
}
\sstroutine{
   AIF\_PTFNM
}{
   Writes the name of an HDS file to a parameter
}{
   \sstdescription{
      Normally, the handles to HDS data files are locators and files
      are obtained via the parameter system.  However, some
      applications can generate sensible names, especially when dealing
      a long series of files that are to be created without manual
      intervention.  There is no direct mechanism in the user-level
      parameter-system library to put a name into the associated
      parameter.  This routine provides that functionality.
   }
   \sstinvocation{
      CALL AIF\_PTFNM( PARNAM, FILNAM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARNAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Parameter name associated with the data object whose name is
         to be written.
      }
      \sstsubsection{
         FILNAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the file.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This cannot be used to obtain the names of objects within
            an HDS file.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         Must have obtained the file via the input parameter.
      }
   }
}
\sstroutine{
   AIF\_TEMP
}{
   Create a temporary HDS object
}{
   \sstdescription{
      The routine creates a temporary HDS object with the specified
      type and shape. On the first invocation a temporary structure is
      created to contain such objects. Subsequently, temporary objects
      are created within this enclosing structure.
   }
   \sstinvocation{
      CALL AIF\_TEMP( TYPE, NDIM, DIM, LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         HDS type of object to be created.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of object dimensions.
      }
      \sstsubsection{
         DIM( NDIM ) = INTEGER (Given)
      }{
         Object dimensions.
      }
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Locator to temporary object.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A blank string will be returned for the LOC argument if this
         routine is called with STATUS set, although no further processing
         will occur. The same value will also be returned if the routine
         should fail for any reason.

         \sstitem
         This routine is a work-around to avoid the problems associated
         with calling DAT\_TEMP if the objects created must subsequently be
         erased.
      }
   }
}
\sstroutine{
   CTG\_ASSO1
}{
   Obtain an identifier for a single existing catalogue using a
   specified parameter
}{
   \sstdescription{
      This routine is equivalent to CAT\_ASSOC except that it allows the
      catalogue to be specified using a GRP group expression (for instance,
      its name may be given within a text file, etc). The first catalogue in
      the group expression is returned. Any other names in the group
      expression are ignored. Supplemental information describing the
      separate fields in the catalogue specification are also returned.
   }
   \sstinvocation{
      CALL CTG\_ASSO1( PARAM, VERB, MODE, CI, FIELDS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the ADAM parameter.
      }
      \sstsubsection{
         VERB = LOGICAL (Given)
      }{
         If TRUE then errors which occur whilst accessing supplied catalogues
         are flushed so that the user can see them before re-prompting for
         a new catalogue ({\tt "}verbose{\tt "} mode). Otherwise, they are annulled and
         a general {\tt "}Cannot access file xyz{\tt "} message is displayed before
         re-prompting.
      }
      \sstsubsection{
         MODE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Type of catalogue access required: {\tt '}READ{\tt '}, {\tt '}UPDATE{\tt '} or {\tt '}WRITE{\tt '}.
      }
      \sstsubsection{
         CI = INTEGER (Returned)
      }{
         catalogue identifier.
      }
      \sstsubsection{
         FIELDS( 5 ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Each element contains the following on exit:

            1 - FITS extension specification (eg {\tt "}\{3\}{\tt "}) if any
            2 - File type
            3 - Base file name
            4 - Directory path
            5 - Full catalogue specification
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   CTG\_ASSOC
}{
   Store names of existing catalogues specified through the environment
}{
   \sstdescription{
      A group expression is obtained from the environment using the
      supplied parameter. The expression is parsed (using the facilities
      of the GRP routine GRP\_GROUP, see SUN/150) to produce a list of
      explicit names for existing catalogues which are appended to the
      end of the supplied group (a new group is created if none is
      supplied). If an error occurs while parsing the group expression,
      the user is re-prompted for a new group expression. CAT identifiers
      for particular members of the group can be obtained using
      CTG\_CATAS.
   }
   \sstinvocation{
      CALL CTG\_ASSOC( PARAM, VERB, IGRP, SIZE, FLAG, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER$*$($*$) (Given)
      }{
         The parameter with which to associate the group expression.
      }
      \sstsubsection{
         VERB = LOGICAL (Given)
      }{
         If TRUE then errors which occur whilst accessing supplied catalogues
         are flushed so that the user can see them before re-prompting for
         a new catalogue ({\tt "}verbose{\tt "} mode). Otherwise, they are annulled and
         a general {\tt "}Cannot access file xyz{\tt "} message is displayed before
         re-prompting.
      }
      \sstsubsection{
         IGRP = INTEGER (Given and Returned)
      }{
         The identifier of the group in which the catalogue names are to be
         stored. A new group is created if the supplied value is GRP\_\_NOID.
         It should be deleted when no longer needed using GRP\_DELET.
      }
      \sstsubsection{
         SIZE = INTEGER (Returned)
      }{
         The total number of catalogue names in the returned group.
      }
      \sstsubsection{
         FLAG = LOGICAL (Returned)
      }{
         If the group expression was terminated by the GRP {\tt "}flag
         character{\tt "}, then FLAG is returned true. Otherwise it is
         returned false. Returned .FALSE. if an error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Any file names containing wildcards are expanded into a list of
         catalogue names. The supplied strings are intepreted by a shell
         (/bin/tcsh if it exists, otherwise /bin/csh, otherwise /bin/sh),
         and so may contain shell meta-characters (eg twiddle, \$HOME, even
         command substitution and pipes - but pipe characters {\tt "}$|${\tt "} need to be
         escaped using a backslash {\tt "}$\backslash${\tt "} to avoid them being interpreted as
         GRP editing characters).

         \sstitem
         Only the highest priority file with any give file name is included
         in the returned group. The priority of a file is determined by its
         file type. Priority decreases along the following list of file
         types: .FIT, .fit, .FITS, .fits, .GSC, .gsc, .TXT, .txt, .Txt, .sdf.
         If no file type is given by the user, the highest priority available
         file type is used. If an explicit file type is given, then that file
         type is used.

         \sstitem
         Names of catalogues stored in FITS format may include an FITS
         extension number. For instance, {\tt "}/home/dsb/mydata.fit\{3\} refers to
         a catalogue stored in the third extension of the FITS file
         myadata.fit.

         \sstitem
         Catalogues stored in HDS format must be stored as the top level
         object within the .sdf file.

         \sstitem
         All matching files are opened in order to ensure that they are
         valid catalogues. The user is notified if there are no valid
         catalogues matching a supplied name, and they are asked to supply a
         replacement parameter value.

         \sstitem
         Each element in the returned group contains a full specification
         for a catalogue. Several other groups are created by this routine,
         and are associated with the returned group by means of a GRP
         {\tt "}owner-slave{\tt "} relationship. These supplemental groups are
         automatically deleted when the returned group is deleted using
         GRP\_DELET. The returned group should not be altered using GRP
         directly because corresponding changes may need to be made to the
         supplemental groups. Routines CTG\_SETSZ, CTG\_GTSUP and CTG\_PTSUP
         are provided to manipulate the entire chain of groups. The full
         chain (starting from the head) is as follows:

         \sstitem
            FITS extension numbers (if any)

         \sstitem
            File types

         \sstitem
            Base file names

         \sstitem
            Directory paths

         \sstitem
            Full catalogue specification (this is the returned group IGRP)

         \sstitem
         If an error is reported the group is returned unaltered. If no
         group is supplied, an empty group is returned.

         \sstitem
         A null value (!) can be given for the parameter to indicate that
         no more catalogues are to be specified. The corresponding error is
         annulled before returning unless no catalogues have been added to
         the group.

         \sstitem
         If the last character in the supplied group expression is a colon
         (:), a list of the catalogues represented by the group expression
         (minus the colon) is displayed, but none are actually added to the
         group. The user is then re-prompted for a new group expression.
      }
   }
}
\sstroutine{
   CTG\_CATAS
}{
   Obtain a CAT identifier for an existing catalogue
}{
   \sstdescription{
      The routine returns a CAT identifier for an existing catalogue. The
      name of the catalogue is held at a given index within a given group.
      It is equivalent to CAT\_ASSOC.
   }
   \sstinvocation{
      CALL CTG\_CATAS( IGRP, INDEX, MODE, CI, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         A GRP identifier for a group holding the names of catalogues. This
         will often be creted using CTG\_ASSOC, but groups created {\tt "}by
         hand{\tt "} using GRP directly (i.e. without the supplemental groups
         created by CTG\_ASSOC) can also be used.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index within the group at which the name of the catalogue to be
         accessed is stored.
      }
      \sstsubsection{
         MODE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Type of catalogue access required: {\tt '}READ{\tt '}, or {\tt '}WRITE{\tt '}.
      }
      \sstsubsection{
         CI = INTEGER (Returned)
      }{
         catalogue identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If this routine is called with STATUS set, then a value of
         CAT\_\_NOID will be returned for the CI argument, although no
         further processing will occur. The same value will also be
         returned if the routine should fail for any reason. The CAT\_\_NOID
         constant is defined in the include file CAT\_PAR.
      }
   }
}
\sstroutine{
   CTG\_CATCR
}{
   Obtain a CAT identifier for a new catalogue
}{
   \sstdescription{
      The routine returns a CAT identifier for a new catalogue. The name
      of the new catalogue is held at a given index within a given group.
      It is equivalent to CAT\_CREAT, except that any existing catalogue
      with the specified name is first deleted (unless the catalogue
      specification includes a FITS extension specifier).
   }
   \sstinvocation{
      CALL CTG\_CATCR( IGRP, INDEX, CI, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         A GRP identifier for a group holding the names of catalogues. This
         will often be created using CTG\_CREAT, but groups created {\tt "}by
         hand{\tt "} using GRP directly can also be used.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index within the group at which the name of the catalogue to be
         created is stored.
      }
      \sstsubsection{
         CI = INTEGER (Returned)
      }{
         Catalogue identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   CTG\_CREA1
}{
   Create a single new catalogue using a specified parameter
}{
   \sstdescription{
      This routine is equivalent to CAT\_CREAT except that it allows the
      catalogue to be specified using a GRP group expression (for
      instance, its name may be given within a text file, etc), and it
      also ensures that any existing catalogue with the same name is
      deleted before the new one is created (so long as no FITS extension
      number is included in the catalogue specification). The first
      catalogue in the group expression is returned. Any other names in
      the group expression are ignored. Any modification elements in the
      supplied group expression will be treated literally.
   }
   \sstinvocation{
      CALL CTG\_CREA1( PARAM, CI, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the ADAM parameter.
      }
      \sstsubsection{
         CI = INTEGER (Returned)
      }{
         Catalogue identifier.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The file specification for the catalogue.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   CTG\_CREAT
}{
   Obtain the names of a group of catalogue to be created from the
   environment
}{
   \sstdescription{
      A group expression is obtained from the environment using the
      supplied parameter. The expression is parsed (using the
      facilities of the GRP routine GRP\_GROUP, see SUN/150) to produce
      a list of explicit catalogue names. These names are appended
      to the group identified by IGRP. The user is re-prompted if an
      error occurs while parsing the group expression. If IGRP has the
      value GRP\_\_NOID on entry, then a new group is created and IGRP is
      returned holding the new group identifier.

      If IGRP0 holds a valid group identifier on entry, then the group
      identified by IGRP0 is used as the basis for any modification
      element contained in the group expression obtained from the
      environment. If IGRP0 holds an invalid identifier (such as
      GRP\_\_NOID) on entry then modification elements are included
      literally in the output group.
   }
   \sstinvocation{
      CALL CTG\_CREAT( PARAM, IGRP0, IGRP, SIZE, FLAG, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER$*$($*$) (Given)
      }{
         The parameter with which to associate the group.
      }
      \sstsubsection{
         IGRP0 = INTEGER (Given)
      }{
         The GRP identifier for the group to be used as the basis for
         any modification elements. If a valid GRP identifier is
         supplied, and if the supplied group expression contains a
         modification element, then:

         \sstitemlist{

            \sstitem
            the basis token (an asterisk) is replaced by the file basename
            associated with the corresponding element of the basis group (the
            {\tt "}basis catalogue{\tt "}).

            \sstitem
            if no directory specification is included in the group expression,
            the directory specification associated with the basis catalogue is
            used.

         }
         The supplied group will often be created by CTG\_ASSOC, but
         groups created {\tt "}by hand{\tt "} using GRP directly can also be used
         (i.e. without the supplemental groups created by CTG). In
         this case, there are no defaults for directory path or file type,
         and the basis token ({\tt "}$*${\tt "}) in the group expression represents the
         full basis file specification supplied in IGRP0, not just the file
         basename.
      }
      \sstsubsection{
         IGRP = INTEGER (Given and Returned)
      }{
         The GRP identifier for the group to which the supplied
         files are to be appended.
      }
      \sstsubsection{
         SIZE = INTEGER (Returned)
      }{
         The total number of file names in the returned group.
      }
      \sstsubsection{
         FLAG = LOGICAL (Returned)
      }{
         If the group expression was terminated by the GRP {\tt "}flag{\tt "}
         character, then FLAG is returned .TRUE. Otherwise it is
         returned .FALSE. Returned .FALSE. if an error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Any FITS extensions specified in the group expression are ignored.

         \sstitem
         If an error is reported the group is returned unaltered.

         \sstitem
         A null value (!) can be given for the parameter to indicate
         that no more catalogues are to be specified. The corresponding error
         is annulled before returning unless no catalogues have been added to
         the group.

         \sstitem
         If no file type is supplied in the group expression, then the first
         file type listed in the current value of the CAT\_FORMATS\_OUT environment
         variable is used. If this is {\tt "}$*${\tt "} then the file type is copied from the
         corresponding input file if a modification element was used to specify
         the output file name (if the catalogue was not specified by a
         modification element, the second file type in CAT\_FORMATS\_OUT is
         used).

         \sstitem
         If the last character in the supplied group expression is
         a colon (:), a list of the catalogues represented by the group
         expression (minus the colon) is displayed, but none are
         actually added to the group. The user is then re-prompted for
         a new group expression.

         \sstitem
         The returned group has no associated groups holding supplemental
         information (unlike the group returned by CTG\_ASSOC).
      }
   }
}
\sstroutine{
   CTG\_GTSUP
}{
   Get supplemental information for a catalogue
}{
   \sstdescription{
      Returns the supplemental information associated with a given entry
      in a CTG group.
   }
   \sstinvocation{
      CALL CTG\_GTSUP( IGRP, I, FIELDS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         The CTG group as returned by CTG\_ASSOC, etc. This should be the last
         group in a GRP owner-slave chain.
      }
      \sstsubsection{
         I = INTEGER (Given)
      }{
         The index of the required entry.
      }
      \sstsubsection{
         FIELDS( 5 ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The supplemental information associated with the entry specified
         by I. Each element of the returned array contains the following:

            1 - FITS extension specification (eg {\tt "}\{3\}{\tt "}) if any
            2 - File type
            3 - Base file name
            4 - Directory path
            5 - Full catalogue specification

         This information is obtained from a set of groups associated with
         the supplied group IGRP by means of a chain of GRP {\tt "}owner-slave{\tt "}
         relationships. If any of these groups do not exist, the correponding
         elements of the above array are returned blank. Note, element 5,
         the full catalogue specification, is obtained directly from the
         supplied group IGRP.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   CTG\_PTSUP
}{
   Store suplemental information for an catalogue
}{
   \sstdescription{
      Stores the supplied items of supplemental information for a given
      entry in a CTG group. The GRP groups needed to store this
      supplemental information are created if they do not already exist,
      and associated with the supplied group by means of a chain of GRP
      {\tt "}owner-slave{\tt "} relationships. They will be deleted automaticaly when
      the supplied group is deleted using GRP\_DELET.
   }
   \sstinvocation{
      CALL CTG\_PTSUP( IGRP, I, FIELDS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         The CTG group as returned by CTG\_ASSOC, etc. This should be the last
         group in a GRP owner-slave chain.
      }
      \sstsubsection{
         I = INTEGER (Given)
      }{
         The index of the required entry.
      }
      \sstsubsection{
         FIELDS( 5 ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The supplemental information to be stored with the entry specified
         by I. Each element of the supplied array should contain the
         following:
            1 - FITS extension (eg {\tt "}\{3\}{\tt "}) if any
            2 - File type
            3 - Base file name
            4 - Directory path
            5 - Full catalogue specification
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   CTG\_SETSZ
}{
   Reduces the size of a CTG group
}{
   \sstdescription{
      This routine should be used instead of GRP\_SETSZ to set the size of
      a group created by CTG. It sets the size of the supplied group, and
      also sets the size of each of the supplemental groups associated with
      the supplied group.
   }
   \sstinvocation{
      CALL CTG\_SETSZ( IGRP, SIZE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         The CTG group as returned by CTG\_ASSOC, etc. This should be the last
         group in a GRP owner-slave chain.
      }
      \sstsubsection{
         SIZE = INTEGER (Given)
      }{
         The new group size. Must be less than or equal to the size of the
         smallest group in the chain.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_ASTWN
}{
   Displays any AST warning messages stored in the supplied FitsChan
}{
   \sstdescription{
      The AST library can store warning messages in a FItsChan in the
      form of header cards with the keyword {\tt "}ASTWARN{\tt "}. This routine
      searches for such cards and displays them nicely if any are found.
   }
   \sstinvocation{
      CALL FTS1\_ASTWN( FC, INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FC = INTEGER (Given)
      }{
         The AST pointer to the FitsChan.
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         The NDF identifier for the NDF being created.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_AXIS
}{
   Create an axis structure within an NDF from FITS header
   information
}{
   \sstdescription{
      The routine searches the FITSD header for the keywords that
      describe the axis structure.  If at least one reference value,
      CRVALn, exists then an axis component is created and filled with
      the appropriate values.  CDELTn defines the step between axis
      values.  If it is not present in the header it is set to 1.
      CRPIXn defines the reference pixel to which the reference value
      corresponds.  If is absent form the header pixel 1 is assumed to
      be the reference pixel.  If CTYPEn is in the header it is used to
      assigned a value to the nth axis{\tt '}s label component.

      The precision of the output axis-centre array depends on the
      absolute relative size of the offset to the scale.  Single
      precision is used if this ratio is greater than one hundred times
      the floating-point precision.
   }
   \sstinvocation{
      CALL FTS1\_AXIS( NCARD, HEADER, SCARD, NDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of card images in the buffer.
      }
      \sstsubsection{
         HEADER( NCARD ) = CHARACTER $*$ 80 (Given)
      }{
         The FITS header {\tt '}cards{\tt '}, each element corresponding to a
         80-character card.
      }
      \sstsubsection{
         SCARD = INTEGER (Given)
      }{
         The number of the card from where the search will begin.  This
         is needed because the headers make contain a dummy header
         prior to an extension.
      }
      \sstsubsection{
         NDF = INTEGER (Given)
      }{
         The identifier for the NDF to contain the axis structure.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_BLCAR
}{
   Determines whether or not the first card in a FITS record has a
   blank keyword
}{
   \sstdescription{
      This routine is needed for UNIX portability, since the calling
      application only knows the pointer to the FITS record, and not the
      actual values.  Hence a function is required.
   }
   \sstinvocation{
      RESULT = FTS1\_BLCAR( RECORD )
   }
   \sstarguments{
      \sstsubsection{
         RECORD( 36 ) = CHARACTER $*$ ( 80 ) (Given)
      }{
         The FITS record to be tested.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         FTS1\_BLCAR = LOGICAL
      }{
         If true, the first card image in RECORD has a blank keyword,
         i.e. characters 1 to 8 in the card image are blank.
      }
   }
}
\sstroutine{
   FTS1\_BSWAP
}{
   Swaps adjacent bytes in an array of bytes
}{
   \sstdescription{
      This swaps adjacent pairs of bytes in an array in situ.  This is
      VAX specific.
   }
   \sstinvocation{
      CALL FTS1\_BSWAP( NBYTE, BYTES, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NBYTE = INTEGER (Returned)
      }{
         Number of bytes.  An SAI\_\_ERROR will be returned if this is not
         an even number.
      }
      \sstsubsection{
         BYTES( NBYTE ) = BYTE (Given and Returned)
      }{
         The 16-bit words whose bytes are to be swapped.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_CHVAx
}{
   Replaces all occurrences of a value in an array with another
   value
}{
   \sstdescription{
      This routine copies the input array to the output array, except
      where a specified value occurs, and this is replaced with a new
      value throughout the output array.
   }
   \sstinvocation{
      CALL FTS1\_CHVAx( EL, INARR, OLDVAL, NEWVAL, OUTARR, NREP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input and output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The input array.
      }
      \sstsubsection{
         OLDVAL = ? (Given)
      }{
         Value to be replaced.
      }
      \sstsubsection{
         NEWVAL = ? (Given)
      }{
         New value to be substituted for the old value.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         The output array containing the modified values.
      }
      \sstsubsection{
         NREP = INTEGER (Returned)
      }{
         The number of replacements made.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays and values supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   FTS1\_CHVAx
}{
   Replaces all occurrences of a value in an array with another
   value
}{
   \sstdescription{
      This routine copies the input array to the output array, except
      where a specified value occurs, and this is replaced with a new
      value throughout the output array.
   }
   \sstinvocation{
      CALL FTS1\_CHVAx( EL, INARR, OLDVAL, NEWVAL, OUTARR, NREP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input and output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The input array.
      }
      \sstsubsection{
         OLDVAL = ? (Given)
      }{
         Value to be replaced.
      }
      \sstsubsection{
         NEWVAL = ? (Given)
      }{
         New value to be substituted for the old value.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         The output array containing the modified values.
      }
      \sstsubsection{
         NREP = INTEGER (Returned)
      }{
         The number of replacements made.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays and values supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   FTS1\_CHVAx
}{
   Replaces all occurrences of a value in an array with another
   value
}{
   \sstdescription{
      This routine copies the input array to the output array, except
      where a specified value occurs, and this is replaced with a new
      value throughout the output array.
   }
   \sstinvocation{
      CALL FTS1\_CHVAx( EL, INARR, OLDVAL, NEWVAL, OUTARR, NREP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input and output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The input array.
      }
      \sstsubsection{
         OLDVAL = ? (Given)
      }{
         Value to be replaced.
      }
      \sstsubsection{
         NEWVAL = ? (Given)
      }{
         New value to be substituted for the old value.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         The output array containing the modified values.
      }
      \sstsubsection{
         NREP = INTEGER (Returned)
      }{
         The number of replacements made.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays and values supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   FTS1\_COMNT
}{
   Get the value of a FITS COMMENT card from a buffer of cards
}{
   \sstdescription{
      This routine searches a buffer containing the header card images
      from a FITS file for the next card with keyword COMMENT.  The
      search begins at a defined card image; and ends when the next end
      of a header block, marked by the END keyword, is encountered or
      the buffer is exhausted.  The routine returns the comment string,
      and the number of the card image within the buffer array that
      contains the comment.  If the keyword is is present \%THERE is
      true, otherwise it is false.
   }
   \sstinvocation{
       CALL FTS1\_COMNT( NCARD, BUFFER, STCARD, THERE, VALUE, CARD,
      :                 STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of card images in the buffer.
      }
      \sstsubsection{
         BUFFER( NCARD ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The buffer containing the header card images.
      }
      \sstsubsection{
         STCARD = INTEGER (Given)
      }{
         The number of the card from which to search for the next
         comment card
      }
      \sstsubsection{
         THERE = LOGICAL (Returned)
      }{
         If true the parameter \%NAME is present.
      }
      \sstsubsection{
         VALUE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The comment string of the first COMMENT keyword found at or
         after \%STCARD.  The length should be at least 72 characters.
      }
      \sstsubsection{
         CARD = INTEGER(Returned)
      }{
         The number of the card containing the first COMMENT card. If
         no COMMENT card could be found this is returned with a value of
         zero.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   FTS1\_CRNDF
}{
   For a FITS data array create an NDF, generating the NDF{\tt '}s name in
   some circumstances
}{
   \sstdescription{
      This is a server routine for FITSIN.  It packages up the
      operations required to create an output NDF.  In automatic mode
      the filename is generated and put into the parameter to prevent
      prompting.  In manual mode the user is prompted for the file
      name of the NDF.
   }
   \sstinvocation{
       CALL FTS1\_CRNDF( PNNDF, FILROO, GCOUNT, NG, AUTO, FORMAT, NDIM,
      :                 DIMS, NDF, FILNAM, ASSOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNNDF = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter by which the filename of the output
         NDF will be obtained.
      }
      \sstsubsection{
         FILROO = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The rootname of the output NDF.  The suffix Gn, where n=\%NG, is
         appended in group-format mode to generate the filename.
         Otherwise in automatic mode the NDF filename is the rootname.
      }
      \sstsubsection{
         GCOUNT = INTEGER (Given)
      }{
         Number of data arrays in the FITS sub-file.  It should be one
         if there are no groups.
      }
      \sstsubsection{
         NG = INTEGER (Given)
      }{
         Number of the group.  It should be one if there are no groups.
      }
      \sstsubsection{
         AUTO = LOGICAL (Given)
      }{
         If true the processing should be done in automatic mode, where
         the user is not prompted for file names, since these are
         generated from the prefix, file and sub-file numbers.
      }
      \sstsubsection{
         FORMAT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The destination HDS format of the data array in the output
         file.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Dimensionality of the NDF.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the NDF.
      }
      \sstsubsection{
         NDF = INTEGER (Returned)
      }{
         The identifier of the created NDF.
      }
      \sstsubsection{
         FILNAM = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The filename of the output NDF.
      }
      \sstsubsection{
         ASSOC = LOGICAL (Returned)
      }{
         If false the NDF name was generated automatically.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_DREAD
}{
   Obtains a FITS record from a disk file
}{
   \sstdescription{
      This routine reads the byte stream from the FITS disk file
      and extracts a FITS record of 2880 bytes.  The blocksize of
      the disk file is arbitrary save that it be no more than the
      maximum FITS blocksize of 28800.
   }
   \sstinvocation{
       CALL FTS1\_DREAD ( LU, BLKSIZ, ACTSIZ, LINIT, BUFFER, OFFSET,
      :                  RECORD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LU = INTEGER (Given)
      }{
         The logical unit number for the disk-FITS file.
      }
      \sstsubsection{
         BLKSIZ = INTEGER (Given)
      }{
         The maximum blocksize and dimension of the file block.
      }
      \sstsubsection{
         ACTSIZ = INTEGER (Given and Returned)
      }{
         The actual block size.  This need not be a multiple of the
         FITS record length of 2880 bytes.  It must be known on input.
      }
      \sstsubsection{
         LINIT = LOGICAL (Given)
      }{
         If true, the current record counter (RECNUM) is reset to one.
         Should be true if a file is being read for the first time.
      }
      \sstsubsection{
         BUFFER( ACTSIZ ) = BYTE (Given and Returned)
      }{
         The buffer containing the block of data. This is only read
         when \%OFFSET does not equal \%ACTSIZ, i.e. there are some
         non-header data within it.
      }
      \sstsubsection{
         OFFSET = INTEGER (Given and Returned)
      }{
         The number of bytes in the current block already interpreted.
      }
      \sstsubsection{
         RECORD( 2880 ) = BYTE (Returned)
      }{
         The current FITS record.  Successive calls will read of the
         FITS records in sequence.
      }
      \sstsubsection{
         STATUS  = INTEGER(Given and Returned)
      }{
         Global status value.
      }
   }
   \sstdiytopic{
      Prior requirements
   }{
      \sstitemlist{

         \sstitem
         The disk file should already be open and the first block
         read.
      }
   }
}
\sstroutine{
   FTS1\_DTYPE
}{
   Obtain the input data type, scales and offsets for a FITS file
}{
   \sstdescription{
      This is a server routine for FITSIN.  It packages up the
      operations required to define the input data types, the scale
      factor and offset, the data-blank value, the number of bytes per
      data values.  This includes the group count, number of parameters
      per group and their group scalings for a non-standard data array.
   }
   \sstinvocation{
       CALL FTS1\_DTYPE( DARRAY, NONSDA, BITPIX, SCARD, NCARD, HEADER,
      :                 MXPARM, NDIM, DIMS, BSCALE, BZERO, BLANK, BADPIX,
      :                 IEEE, GCOUNT, PCOUNT, PTYPE, PSCALE, PZERO,
      :                 STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DARRAY = LOGICAL (Given)
      }{
         If true there is a data array present if the FITS file.
      }
      \sstsubsection{
         NONSDA = LOGICAL (Given)
      }{
         If true the data array is not standard, i.e. in group format.
         It is ignored if \%DARRAY is false.
      }
      \sstsubsection{
         BITPIX = INTEGER (Given)
      }{
         The value of the BITPIX keyword in the FITS header, i.e. the
         number of bits per data value.  If it is negative this
         indicates an IEEE-format file.
      }
      \sstsubsection{
         SCARD = INTEGER (Given)
      }{
         The number of the card from where the searches of the header
         will begin.  This is needed because the headers make contain a
         dummy header prior to an extension.
      }
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of card images in the header.
      }
      \sstsubsection{
         HEADER( NCARD ) = CHARACTER $*$ 80 (Given)
      }{
         The FITS headers in 80-character records.
      }
      \sstsubsection{
         MXPARM = INTEGER (Given)
      }{
         The maximum number of group parameters, and the dimension size
         for the various group arrays.
      }
      \sstsubsection{
         NDIM = INTEGER (Given and Returned)
      }{
         Dimensionality of the data array.  It may be modified if a)
         there is no data array, because a valid NDF must have a data
         array with physical dimensions (set to 1); or b) it is a
         non-standard array (i.e. groups) where the first dimension is
         zero, and so the dimensionality is reduced by one.
      }
      \sstsubsection{
         DIMS( DAT\_\_MXDIM ) = INTEGER (Given and Returned)
      }{
         The dimensions of the table.  It may be modified if a)
         there is no data array, because a valid NDF must have a data
         array with physical dimensions (set to 2 in 1-d); or b) it is
         a non-standard array (i.e. groups) where the first dimension
         is zero, and so the dimension sizes are shifted down one
         dimension.
      }
      \sstsubsection{
         BSCALE = REAL (Returned)
      }{
         The scale factor of the FITS integer data for their conversion
         to the true floating-point values.
      }
      \sstsubsection{
         BZERO = REAL (Returned)
      }{
         The offset of the FITS integer data for their conversion to
         the true floating-point values.
      }
      \sstsubsection{
         BLANK = INTEGER (Returned)
      }{
         The data-blank value equivalent to the bad-pixel flag.  It
         should be ignored if \%BADPIX is false.
      }
      \sstsubsection{
         BADPIX = LOGICAL (Returned)
      }{
         If true the data-blank was defined in the FITS header.
      }
      \sstsubsection{
         IEEE = LOGICAL (Returned)
      }{
         If true the FITS data are in IEEE floating-point format.
      }
      \sstsubsection{
         GCOUNT = INTEGER (Returned)
      }{
         The number of groups in the FITS sub-file.
      }
      \sstsubsection{
         PCOUNT = INTEGER (Returned)
      }{
         The number of group parameters in each group.
      }
      \sstsubsection{
         PTYPE( MXPARM ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The type (descriptive name) of each group parameter.
      }
      \sstsubsection{
         PSCALE( MXPARM ) = DOUBLE PRECISION (Returned)
      }{
         The scale factors of the group parameters so that the
         parameters may be converted to the true floating-point values.
      }
      \sstsubsection{
         PZERO( MXPARM ) = DOUBLE PRECISION (Returned)
      }{
         The offsets of the group parameters so that the parameters may
         be converted to the true floating-point values.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      The non-standard case of a floating-point data-blank value (BLANK)
      is handled assuming it is the true blank value as opposed to the
      blank value in the FITS data.  This is achieved by subtracting the
      offset and dividing by the scale factor and taking the nearest
      integer.
   }
}
\sstroutine{
   FTS1\_EDFEX
}{
   Edits non-reserved keyword cards in a FITS extension of an NDF
}{
   \sstdescription{
      This subroutine edits a number of non-reserved keyword cards in
      the FITS extension of an NDF file.  This subroutine inserts,
      updates, moves, deletes, reports, and tests the existence of a
      number of keyword cards in the FITS extension of an NDF.  The
      occurrence of keywords may be defined, when there are more than
      one cards of the same name.  The location of each insertion or
      move is immediately before some occurrence of a corresponding
      keyword.

      This routine itself merely deals with accessing and enlarging the
      FITS extension, obtaining worksapce, and being able to pass the
      mapped character arrays in the desired order to routine
      FTS1\_EDKEY via a dummy routine.  FTS1\_EDKEY actually performs the
      editing; look there for more details of the editing functions and
      rules.
   }
   \sstinvocation{
      CALL FTS1\_EDFEX( NKEY, EDITS, NAMES, PSTNS, KOCCUR, POCCUR,
                       VALUES, COMNTS, TYPES, FTSLOC, THERE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NKEY = INTEGER (Given)
      }{
         The number of keyword cards to be inserted into the FITS
         extension.
      }
      \sstsubsection{
         EDITS( NKEY ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The editing commands.  These need only be one character per
         element.  Allowed values are {\tt '}Delete{\tt '}, {\tt '}Exist{\tt '}, {\tt '}Move{\tt '},
         {\tt '}Rename{\tt '}, {\tt '}Print{\tt '}, {\tt '}Update{\tt '}, and {\tt '}Write{\tt '}, which can be
         abbreviated to the initial letter.

         {\tt '}Delete{\tt '} removes a named keyword.

         {\tt '}Exist{\tt '} reports TRUE to standard output if the named keyword
         exists in the header, and FALSE if the keyword is not present.

         {\tt '}Move{\tt '} relocates a named keyword to be immediately before a
         second keyword.  When this positional keyword is not supplied,
         it defaults to the END card, and if the END card is absent,
         the new location is at the end of the headers.

         {\tt '}Print{\tt '} causes the value of a named keyword to be displayed to
         standard output.  This will be a blank for a comment card.

         {\tt '}Rename{\tt '} renames a keyword, using the value as the new keyword.

         {\tt '}Update{\tt '} revises the value and/or the comment.  If a secondary
         keyword is defined explicitly, the card may be relocated at
         the same time.  If the secondary keyword does not exist, the
         card being edited is not moved.  Update requires that the
         keyword being edited exists.

         {\tt '}Write{\tt '} creates a new card given a value and an optional
         comment.  Its location uses the same rules as for the Move
         command.
      }
      \sstsubsection{
         NAMES( NKEY ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The names of the keywords to be edited in the FITS card array.
         A name may be compound to handle hierarchical keywords, and it
         has the form keyword1.keyword2.keyword3 etc.  The maximum
         number of keywords per FITS card is 20.  Each keyword must be
         no longer than 8 characters, and be a valid FITS keyword
         comprising alphanumeric characters, hyphen, and unsderscore.
         Any lowercase letters are converted to uppercase and blanks
         are removed before inserted or comparison with the existing
         keywords.

         The keywords {\tt '} {\tt '}, {\tt '}COMMENT{\tt '}, and {\tt '}HISTORY{\tt '} are comment cards
         and do not have a value.

         The keyword must exist except for the Write and Exist commands.
      }
      \sstsubsection{
         PSTNS( NKEY ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The position keyword names.  A position name may be compound
         to handle hierarchical keywords, and it has the form
         keyword1.keyword2.keyword3 etc.  The maximum number of
         keywords per FITS card is 20.  Each keyword must be no longer
         than 8 characters.  When locating the position card,
         comparisons are made in uppercase and with the blanks removed.

         The new keywords are inserted immediately before each
         corresponding position keyword.  If any name in it does not
         exist in FITS array, in the Write and Move edits its
         corresponding keyword will be inserted just before the END
         card or appended to FITS array when the END card does not
         exist (for the Write and Move edits); however, the card is not
         relocated for the Update edit.  If two or more new cards have
         the same position name, they will all be put just before the
         position name in the same order as they are in NAMES.

         A positional keyword is used by the Move, Write, and Update
         editing commands.
      }
      \sstsubsection{
         KOCCUR( NKEY ) = INTEGER (Given)
      }{
         The occurrences of the NAMES keywords to use.  Values less than
         or equal to 1 will manipulate the first occurrence of the
         keyword to insert.
      }
      \sstsubsection{
         POCCUR( NKEY ) = INTEGER (Given)
      }{
         The occurrences of the PSTNS keywords to use.  Values less than
         or equal to 1 will situate the inserted keyword immediately
         before the first occurrence of the positional keyword.
      }
      \sstsubsection{
         VALUES( NKEY ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The new values of the NAMES keywords for the Update and Write
         editing commands.  The special value {\tt '}\$V{\tt '} means use the
         current value of the NAMES keyword.  This makes it possible to
         modify a comment, leaving the value unaltered.  In addition
         \$V(keyword) requests that the value of the keyword given
         between the parentheses be assigned to the keyword being
         edited.  This positional keyword must exist and have a value
         for a Write edit; whereas the FITS-header value is unchanged
         for Update if there are problems with this positional keyword.

         For a Rename edit, VALUES has a different meaning; in this
         case it stores the replacement keyword name.
      }
      \sstsubsection{
         COMNTS( NKEY ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The comments to be written to the NAMES keywords for the
         Update and Write editing commands.  The special value {\tt '}\$C{\tt '}
         means use the current comment.  In addition \$C(keyword)
         requests that the comment of the keyword given between the
         parentheses be assigned to the keyword being edited.  If this
         positional keyword does not exist the comment is unchanged for
         Update, and is blank for a Write edit.
      }
      \sstsubsection{
         TYPES( NKEY ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The data types of the values to Write or Update.  This does
         allow some numeric or logical values to be written as strings.
         These will be one of the following: {\tt '}\_CHAR{\tt '},  {\tt '}\_DOUBLE{\tt '},
         {\tt '}\_INTEGER{\tt '}, {\tt '}\_LOGICAL{\tt '}, {\tt '}\_REAL{\tt '}.  In addition there are two
         special values: {\tt '}COMMENT{\tt '} to indicate that the card is a
         comment (so strictly it has no type), and {\tt '} {\tt '} to indicate that
         the data type is unknown, as occurs for a value defined by a
         reference keyword.  The length should be at least 8
         characters.
      }
      \sstsubsection{
         FTSLOC = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The locator to the FITS extension of the NDF.
      }
      \sstsubsection{
         THERE = LOGICAL (Returned)
      }{
         Result of final {\tt "}Exist{\tt "} operation.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      The FITS extension is mapped for update access.  It therefore must
      have some values assigned before using the routine.
   }
}
\sstroutine{
   FTS1\_EDKEY
}{
   Edits keywords in a FITS card array
}{
   \sstdescription{
      This subroutine inserts, updates, moves, deletes, reports, and
      tests the existence of a number of keyword cards in a FITS-header
      array.  The occurrence of keywords may be defined, when there are
      more than one cards of the same name.  The location of each
      insertion or move is immediately before some occurrence of a
      corresponding keyword.  The routine returns the modified
      FITS-header array.
   }
   \sstinvocation{
      CALL FTS1\_EDKEY( NOCARD, NKEY, MXCARD, EDITS, NAMES, PSTNS,
                       KOCCUR, POCCUR, VALUES, COMNTS, TYPES, FTSCAR,
                       ACTNUM, IARY1, IARY2, CARY, EXISTS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NOCARD = INTEGER (Given)
      }{
         Number of cards in the original FITS array.
      }
      \sstsubsection{
         NKEY = INTEGER (Given)
      }{
         The number of keyword cards to be inserted into the FITS-header
         array.
      }
      \sstsubsection{
         MXCARD = INTEGER (Given)
      }{
         Maximum number of cards in the resultant FITS array.  This must
         be not less than NOCARD $+$ NKEY $+$ 1.
      }
      \sstsubsection{
         EDITS( MAXMOD ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The editing commands.  These need only be one character per
         element.  Allowed values are {\tt '}Delete{\tt '}, {\tt '}Exist{\tt '}, {\tt '}Move{\tt '},
         {\tt '}Rename{\tt '}, {\tt '}Print{\tt '}, {\tt '}Update{\tt '}, and {\tt '}Write{\tt '}, which can be
         abbreviated to the initial letter.

         {\tt '}Delete{\tt '} removes a named keyword.

         {\tt '}Exist{\tt '} reports TRUE to standard output if the named keyword
         exists in the header, and FALSE if the keyword is not present.

         {\tt '}Move{\tt '} relocates a named keyword to be immediately before a
         second keyword.  When this positional keyword is not supplied,
         it defaults to the END card, and if the END card is absent,
         the new location is at the end of the headers.

         {\tt '}Print{\tt '} causes the value of a named keyword to be displayed to
         standard output.  This will be a blank for a comment card.

         {\tt '}Rename{\tt '} renames a keyword, using the value as the new keyword.

         {\tt '}Update{\tt '} revises the value and/or the comment.  If a secondary
         keyword is defined explicitly, the card may be relocated at
         the same time.  If the secondary keyword does not exist, the
         card being edited is not moved.  Update requires that the
         keyword being edited exists.

         {\tt '}Write{\tt '} creates a new card given a value and an optional
         comment.  Its location uses the same rules as for the Move
         command.
      }
      \sstsubsection{
         NAMES( NKEY ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The names of the keywords to be edited in the FITS card
         array.  A name may be compound to handle hierarchical
         keywords, and it has the form keyword1.keyword2.keyword3 etc.
         The maximum number of keywords per FITS card is 20.  Each
         keyword must be no longer than 8 characters, and be a valid
         FITS keyword comprising alphanumeric characters, hyphen, and
         unsderscore.  Any lowercase letters are converted to uppercase
         and blanks are removed before inserted or comparison with the
         existing keywords.

         The keywords {\tt '} {\tt '}, {\tt '}COMMENT{\tt '}, and {\tt '}HISTORY{\tt '} are comment cards
         and do not have a value.

         The keyword must exist except for the Write and Exist commands.
      }
      \sstsubsection{
         PSTNS( NKEY ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The position keyword names.  A position name may be compound
         to handle hierarchical keywords, and it has the form
         keyword1.keyword2.keyword3 etc.  The maximum number of
         keywords per FITS card is 20.  Each keyword must be no longer
         than 8 characters.  When locating the position card,
         comparisons are made in uppercase and with the blanks removed.

         The new keywords are inserted immediately before each
         corresponding position keyword.  If any name in it does not
         exist in FITS array, in the Write and Move edits its
         corresponding keyword will be inserted just before the END
         card or appended to FITS array when the END card does not
         exist; however, the card is not relocated for the Update edit.
         If two or more new cards have the same position name, they
         will all be put just before the position name in the same
         order as they are in NAMES.

         A positional keyword is used by the Move, Write, and Update
         editing commands.
      }
      \sstsubsection{
         KOCCUR( NKEY ) = INTEGER (Given)
      }{
         The occurrences of the NAMES keywords to use.  Values less than
         or equal to 1 will manipulate the first occurrence of the
         keyword to insert.
      }
      \sstsubsection{
         POCCUR( NKEY ) = INTEGER (Given)
      }{
         The occurrences of the PSTNS keywords to use.  Values less than
         or equal to 1 will situate the inserted keyword immediately
         before the first occurrence of the positional keyword.
      }
      \sstsubsection{
         VALUES( NKEY ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The new values of the NAMES keywords for the Update and Write
         editing commands.  The special value {\tt '}\$V{\tt '} means use the
         current value of the NAMES keyword.  This makes it possible to
         modify a comment, leaving the value unaltered.  In addition
         \$V(keyword) requests that the value of the keyword given
         between the parentheses be assigned to the keyword being
         edited.  This positional keyword must exist and have a value
         for a Write edit; whereas the FITS-header value is unchanged
         for Update if there are problems with this positional keyword.
         edited.

         For a Rename edit, VALUES has a different meaning; in this
         case it stores the replacement keyword name.
      }
      \sstsubsection{
         COMNTS( NKEY ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The comments to be written to the NAMES keywords for the
         Update and Write editing commands.  The special value {\tt '}\$C{\tt '}
         means use the current comment.  In addition \$C(keyword)
         requests that the comment of the keyword given between the
         parentheses be assigned to the keyword being edited.  If this
         positional keyword does not exist the comment is unchanged for
         Update, and is blank for a Write edit.
      }
      \sstsubsection{
         TYPES( NKEY ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The data types of the values to Write or Update.  This does
         allow some numeric or logical values to be written as strings.
         These will be one of the following: {\tt '}\_CHAR{\tt '},  {\tt '}\_DOUBLE{\tt '},
         {\tt '}\_INTEGER{\tt '}, {\tt '}\_LOGICAL{\tt '}, {\tt '}\_REAL{\tt '}.  In addition there are two
         special values: {\tt '}COMMENT{\tt '} to indicate that the card is a
         comment (so strictly it has no type), and {\tt '} {\tt '} to indicate that
         the data type is unknown, as occurs for a value defined by a
         reference keyword.  The length should be at least 8
         characters.
      }
      \sstsubsection{
         FTSCAR( MXCARD ) = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         On entry its first NOCARD elements hold the original FITS
         cards. On exit, its first ACTNUM elements hold the FITS cards
         after the insersion.
      }
      \sstsubsection{
         ACTNUM = INTEGER (Returned)
      }{
         The actual number of cards in the FITS array after inserting.
      }
      \sstsubsection{
         IARY1( MXCARD ) = INTEGER (Returned)
      }{
         The first temporary working space.
      }
      \sstsubsection{
         IARY2( MXCARD ) = INTEGER (Returned)
      }{
         The second temporary working space.
      }
      \sstsubsection{
         CARY( MXCARD ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         A temporary working space.
      }
      \sstsubsection{
         EXISTS = LOGICAL (Returned)
      }{
         The result of the last {\tt "}Exist{\tt "} operation.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         When an error occurs during editing, warning messages are sent
         at the normal reporting level, and processing continues to the
         next editing command.

         \sstitem
         The FITS fixed format is used for writing or updating
         headers, except for double-precision values requiring more space.
         The comment is delineated from the value by the string {\tt '} / {\tt '}.

         \sstitem
         The comments in comment cards begin one space following the
         keyword or from column 10 whichever is greater.

         \sstitem
         At present the following reserved keywords are neither
         modifiable nor movable: SIMPLE, BITPIX, NAXIS, NAXISn, EXTEND,
         PCOUNT, GCOUNT, XTENSION, BLOCKED, and END.  This is because
         order in the extension should be fixed and should not be
         changed by any routine.
      }
   }
}
\sstroutine{
   FTS1\_EVKEY
}{
   Extracts a keyword and occurrence, and validates the keyword
}{
   \sstdescription{
      This routine serves FTS1\_RFMOD.  It takes a string containing a
      keyword and an optional occurrence in brackets, and extracts the
      keyword and any occurrence.  It validates the keyword or the
      hierarchical keywords.  It also returns the length of the keyword.
   }
   \sstinvocation{
      CALL FTS1\_EVKEY( STRING, KEYWRD, LENGTH, OCCUR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STRING = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The string containing the keyword or hierarchical keyword in
         the form keyword1.keyword2.keyword3 etc.  There may be a
         trailing [number] string which defines the occcurence of the
         keyword.
      }
      \sstsubsection{
         KEYWRD = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The extracted keyword in uppercase.  The supplied length is
         recommended to be at least 48 to allow for six full-length
         keywords.
      }
      \sstsubsection{
         LENGTH = INTEGER (Returned)
      }{
         The length in characters of the keyword, so the keyword is
         KEYWRD( :LENGTH ).
      }
      \sstsubsection{
         OCCUR = INTEGER (Returned)
      }{
         The occurrence of the keyword to use.  If none is supplied in
         the STRING or the value is not a positive integer, OCCUR is
         assigned the value 1.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_FNDFS
}{
   Read the first FrameSet from the supplied FitsChan
}{
   \sstdescription{
      This routine reads Objects from the supplied FitsChan until a
      FrameSet is obtained, and returns the FrameSet.
   }
   \sstinvocation{
      CALL FTS1\_FNDFS( FC, OBJ, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FC = INTEGER (Given)
      }{
         An AST pointer to the FitsChan.
      }
      \sstsubsection{
         OBJ = INTEGER (Given)
      }{
         The AST pointer to the FrameSet.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The FitsChan is not rewound before reading. The first read starts at
         the current Card in the FitsChan.

         \sstitem
         No value is set for the FitsChan Encoding attribute.

         \sstitem
         OBJ is returned equal to AST\_\_NULL if no FrameSet can be read
         from the supplied FitsChan, or if an error occurs.
      }
   }
}
\sstroutine{
   FTS1\_FRMT
}{
   Obtain the input and output data format for a FITS file
}{
   \sstdescription{
      This is a server routine for FITSIN.  It packages up the
      operations required to define the input and output data formats
      (HDS types).
   }
   \sstinvocation{
       CALL FTS1\_FRMT( BITPIX, IEEE, FMTCNV, BPV, FMTIN, FMTOUT,
      :                STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BITPIX = INTEGER (Given)
      }{
         The value of the BITPIX keyword in the FITS header, i.e. the
         number of bits per data value.  If it is negative this
         indicates an IEEE-format file.
      }
      \sstsubsection{
         IEEE = LOGICAL (Given)
      }{
         If true the FITS data are in IEEE floating-point format.
      }
      \sstsubsection{
         FMTCNV = LOGICAL (Given)
      }{
         If true, format conversion from the integer FITS data to
         the real output data array is required.
      }
      \sstsubsection{
         BPV = INTEGER (Returned)
      }{
         The number of bytes per data value.
      }
      \sstsubsection{
         FMTIN = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The HDS format of the data in the FITS file.
      }
      \sstsubsection{
         FMTOUT = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The destination HDS format of the data array in the output
         file.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_FTWCS
}{
   Uses coordinate system information in the supplied FITS headers
   to create WCS and AXIS components in an NDF
}{
   \sstdescription{
      This constructs an AST FrameSet from the supplied FITS headers
      and adds it into the existing WCS information in the supplied NDF.
      It can also create AXIS structures (see below).

      The information needed to create the FrameSet can be stored several
      times in a single FITS header, using different keywords each time. Each
      of these descriptions is known as an {\tt "}encoding{\tt "} and AST supports several
      different encoding schemes (i.e. FITS-WCS, FITS-IRAF, DSS, NATIVE, etc).
      If the supplied FITS header contains more than one encoding then we
      need to choose which one to use. This decision is important because
      is is possible for encodings to be inconsistent (i.e. software may
      modify one encoding without making equivalent modifications to the
      other encodings). The simplest way to make this decision is to hand
      responsibility for it over to the user. In this case, the user
      supplies a list of preferred encodings, and the first of these encodings
      which exists in the FITS header gets used. If the user does not
      know which encoding to use, then we can make an intelligent guess by
      comparing the encodings to see which ones are consistent and which
      ones are not.

      In addition to the WCS component, this routine also creates AXIS
      Centre, Label and Units components in the NDF, but only if they do
      not already exist, and if the FrameSet read from the FITS header
      contains an AXIS Frame. NDF2FITS does not write out the AXIS Frame
      if it is equivalent to pixel coordinates, and so no AXIS structures
      will be created by this routine in this case. Also, if the AXIS Frame
      represents linear axis coordinates, then there will already be AXIS
      structures in the NDF (created earlier within FITSIN), and so again
      no AXIS  structures will be created by this routine. Thus, this routine
      will only create AXIS structures in the cases where the axis coordinates
      are non-linear.
   }
   \sstinvocation{
      CALL FTS1\_FTWCS( NCARD, HEADER, SCARD, INDF, NENCOD, ENCODS,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of cards in the array of headers, from the start of
         the first header section to the end of the current one.
      }
      \sstsubsection{
         HEADER( NCARD ) = CHARACTER $*$ 80 (Given)
      }{
         The buffer containing the header card images.
      }
      \sstsubsection{
         SCARD = INTEGER (Given)
      }{
         The number of the card from where searches will begin, and
         copying of the headers to the FITS extension.   Therefore
         NCARD - SCARD $+$ 1 headers will appear in the extension. This
         argument is needed because the headers make contain a dummy
         header prior to an extension.
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         The NDF identifier.
      }
      \sstsubsection{
         NENCOD = INTEGER (Given)
      }{
         The number of encodings supplied in ENCODS.
      }
      \sstsubsection{
         ENCODS( NENCOD ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The user{\tt '}s preferred AST encodings. If NENCOD is zero, then this
         is ignored, and an intelligent guess is made as to which encoding
         to use (see FTS1\_WCSIM).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_GKEYC
}{
   Gets the value and comment of a named header of type CHARACTER
   from a buffer of FITS-header card images
}{
   \sstdescription{
      This routine searches a buffer containing the header card images
      from a FITS file for a keyword NAME; and returns its value (as a
      character string) and comment, and the number of the card image
      within the buffer array that contains the named keyword.  The
      search ends when the next end of a header block, marked by the
      END keyword, is encountered or the buffer is exhausted.  If the
      keyword is present THERE is true, otherwise it is false.  If the
      keyword is expected to be present more than once then the
      argument NOCCUR controls which occurrence will be retrieved.  If
      a keyword is not found then no error results and the argument
      VALUE remains unmodified.

      The name may be compound to permit reading of hierarchical
      keywords (with a blank regulation keyword).  This routine will
      also work for HISTORY, COMMENT and the {\tt '} {\tt '} (blank) keyword
      comment cards.  Cards without an equals sign present are also
      regarded as comment cards.  Comment cards have no returned
      value, only a comment.
   }
   \sstinvocation{
      CALL FTS1\_GKEYC( NCARD, BUFFER, SCARD, NAME, NOCCUR, THERE, VALUE,
                       COMENT, CARD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of card images in the buffer.
      }
      \sstsubsection{
         BUFFER( NCARD ) = CHARACTER $*$ 80 (Given)
      }{
         The buffer containing the header card images.
      }
      \sstsubsection{
         SCARD = INTEGER (Given)
      }{
         The number of the card from where the search will begin.  This
         is needed because the headers may contain a dummy header
         prior to an extension.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the keyword whose value is required.  This may be
         a compound name to handle hierarchical keywords, and it has
         the form keyword1.keyword2.keyword3 etc.  The maximum number of
         keywords per FITS card is 20.  Comparisons are performed in
         uppercase and blanks are removed.  Each keyword must be no
         longer than 8 characters.
      }
      \sstsubsection{
         NOCCUR = INTEGER (Given)
      }{
         The value of this argument specifies which occurrence of a
         keyword should be used, if multiple ones are expected.  Any
         value less than or equal to 1 indicates the first occurrence.
      }
      \sstsubsection{
         THERE = LOGICAL (Returned)
      }{
         If .TRUE., the keyword given by argument NAME is present,
         regardless of the exit status.
      }
      \sstsubsection{
         VALUE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The value of the keyword.  The string is truncated to the
         length of VALUE if the FITS value contains more characters than
         that.
      }
      \sstsubsection{
         COMENT = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The comment associated with the keyword.
      }
      \sstsubsection{
         CARD = INTEGER (Returned)
      }{
         The number of the card containing the named keyword.  If the
         card could not be found this is set to zero.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   FTS1\_GKEYx
}{
   Gets the value and comment of a named header of type DOUBLE PRECISION from
   a buffer of FITS-header card images
}{
   \sstdescription{
      This routine searches a buffer containing the header card images
      from a FITS file for a keyword NAME; and returns its value and
      comment, and the number of the card image within the buffer array
      that contains the named keyword.  The search ends when the next
      end of a header block, marked by the END keyword, is encountered
      or the buffer is exhausted.  If the keyword is present, THERE is
      .TRUE., otherwise it is .FALSE.   Since all cards images are in
      character format, type conversion is performed.  An error status
      will be returned if the conversion has failed.  If the keyword
      expected to be present more than once, then the argument NOCCUR
      controls which occurrence will be retrieved.  If a keyword is not
      found, then no error results and the argument VALUE remains
      unmodified.

      The name may be compound to permit reading of hierarchical
      keywords.  This routine will probably only work for HISTORY,
      COMMENT and {\tt '} {\tt '} (blank) if there is just one value given on the
      line, i.e. only one {\tt "}keyword = value{\tt "} before any comment
      marker.  An error will result otherwise.
   }
   \sstinvocation{
      CALL FTS1\_GKEYx( NCARD, BUFFER, SCARD, NAME, NOCCUR, THERE,
                       VALUE, COMENT, CARD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of card images in the buffer.
      }
      \sstsubsection{
         BUFFER( NCARD ) = CHARACTER $*$ 80 (Given)
      }{
         The buffer containing the header card images.
      }
      \sstsubsection{
         SCARD = INTEGER (Given)
      }{
         The number of the card from where the search will begin.  This
         is needed because the headers may contain a dummy header
         prior to an extension.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the keyword whose value is required.  This may be
         a compound name to handle hierarchical keywords, and it has
         the form keyword1.keyword2.keyword3 etc.  The maximum number of
         keywords per FITS card is 20.  Comparisons are performed in
         uppercase and blanks are removed.  Each keyword must be no
         longer than 8 characters.
      }
      \sstsubsection{
         NOCCUR = INTEGER (Given)
      }{
         The value of this argument specifies which occurrence of a
         keyword should be used, if multiple ones are expected.  Any
         value less than or equal to 1 indicates the first occurrence.
      }
      \sstsubsection{
         THERE = LOGICAL (Returned)
      }{
         If .TRUE., the keyword given by argument NAME is present,
         regardless of the exit status.
      }
      \sstsubsection{
         VALUE = ? (Returned)
      }{
         The value of the keyword.
      }
      \sstsubsection{
         COMENT = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The comment associated with the keyword.
      }
      \sstsubsection{
         CARD = INTEGER (Returned)
      }{
         The number of the card containing the named keyword.  If the
         card could not be found this is set to zero.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the data types logical, integer,
         real and double precision: replace {\tt "}x{\tt "} in the routine name by
         L, I, R or D as appropriate.
      }
   }
}
\sstroutine{
   FTS1\_GKEYx
}{
   Gets the value and comment of a named header of type INTEGER from
   a buffer of FITS-header card images
}{
   \sstdescription{
      This routine searches a buffer containing the header card images
      from a FITS file for a keyword NAME; and returns its value and
      comment, and the number of the card image within the buffer array
      that contains the named keyword.  The search ends when the next
      end of a header block, marked by the END keyword, is encountered
      or the buffer is exhausted.  If the keyword is present, THERE is
      .TRUE., otherwise it is .FALSE.   Since all cards images are in
      character format, type conversion is performed.  An error status
      will be returned if the conversion has failed.  If the keyword
      expected to be present more than once, then the argument NOCCUR
      controls which occurrence will be retrieved.  If a keyword is not
      found, then no error results and the argument VALUE remains
      unmodified.

      The name may be compound to permit reading of hierarchical
      keywords.  This routine will probably only work for HISTORY,
      COMMENT and {\tt '} {\tt '} (blank) if there is just one value given on the
      line, i.e. only one {\tt "}keyword = value{\tt "} before any comment
      marker.  An error will result otherwise.
   }
   \sstinvocation{
      CALL FTS1\_GKEYx( NCARD, BUFFER, SCARD, NAME, NOCCUR, THERE,
                       VALUE, COMENT, CARD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of card images in the buffer.
      }
      \sstsubsection{
         BUFFER( NCARD ) = CHARACTER $*$ 80 (Given)
      }{
         The buffer containing the header card images.
      }
      \sstsubsection{
         SCARD = INTEGER (Given)
      }{
         The number of the card from where the search will begin.  This
         is needed because the headers may contain a dummy header
         prior to an extension.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the keyword whose value is required.  This may be
         a compound name to handle hierarchical keywords, and it has
         the form keyword1.keyword2.keyword3 etc.  The maximum number of
         keywords per FITS card is 20.  Comparisons are performed in
         uppercase and blanks are removed.  Each keyword must be no
         longer than 8 characters.
      }
      \sstsubsection{
         NOCCUR = INTEGER (Given)
      }{
         The value of this argument specifies which occurrence of a
         keyword should be used, if multiple ones are expected.  Any
         value less than or equal to 1 indicates the first occurrence.
      }
      \sstsubsection{
         THERE = LOGICAL (Returned)
      }{
         If .TRUE., the keyword given by argument NAME is present,
         regardless of the exit status.
      }
      \sstsubsection{
         VALUE = ? (Returned)
      }{
         The value of the keyword.
      }
      \sstsubsection{
         COMENT = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The comment associated with the keyword.
      }
      \sstsubsection{
         CARD = INTEGER (Returned)
      }{
         The number of the card containing the named keyword.  If the
         card could not be found this is set to zero.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the data types logical, integer,
         real and double precision: replace {\tt "}x{\tt "} in the routine name by
         L, I, R or D as appropriate.
      }
   }
}
\sstroutine{
   FTS1\_GKEYx
}{
   Gets the value and comment of a named header of type LOGICAL from
   a buffer of FITS-header card images
}{
   \sstdescription{
      This routine searches a buffer containing the header card images
      from a FITS file for a keyword NAME; and returns its value and
      comment, and the number of the card image within the buffer array
      that contains the named keyword.  The search ends when the next
      end of a header block, marked by the END keyword, is encountered
      or the buffer is exhausted.  If the keyword is present, THERE is
      .TRUE., otherwise it is .FALSE.   Since all cards images are in
      character format, type conversion is performed.  An error status
      will be returned if the conversion has failed.  If the keyword
      expected to be present more than once, then the argument NOCCUR
      controls which occurrence will be retrieved.  If a keyword is not
      found, then no error results and the argument VALUE remains
      unmodified.

      The name may be compound to permit reading of hierarchical
      keywords.  This routine will probably only work for HISTORY,
      COMMENT and {\tt '} {\tt '} (blank) if there is just one value given on the
      line, i.e. only one {\tt "}keyword = value{\tt "} before any comment
      marker.  An error will result otherwise.
   }
   \sstinvocation{
      CALL FTS1\_GKEYx( NCARD, BUFFER, SCARD, NAME, NOCCUR, THERE,
                       VALUE, COMENT, CARD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of card images in the buffer.
      }
      \sstsubsection{
         BUFFER( NCARD ) = CHARACTER $*$ 80 (Given)
      }{
         The buffer containing the header card images.
      }
      \sstsubsection{
         SCARD = INTEGER (Given)
      }{
         The number of the card from where the search will begin.  This
         is needed because the headers may contain a dummy header
         prior to an extension.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the keyword whose value is required.  This may be
         a compound name to handle hierarchical keywords, and it has
         the form keyword1.keyword2.keyword3 etc.  The maximum number of
         keywords per FITS card is 20.  Comparisons are performed in
         uppercase and blanks are removed.  Each keyword must be no
         longer than 8 characters.
      }
      \sstsubsection{
         NOCCUR = INTEGER (Given)
      }{
         The value of this argument specifies which occurrence of a
         keyword should be used, if multiple ones are expected.  Any
         value less than or equal to 1 indicates the first occurrence.
      }
      \sstsubsection{
         THERE = LOGICAL (Returned)
      }{
         If .TRUE., the keyword given by argument NAME is present,
         regardless of the exit status.
      }
      \sstsubsection{
         VALUE = ? (Returned)
      }{
         The value of the keyword.
      }
      \sstsubsection{
         COMENT = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The comment associated with the keyword.
      }
      \sstsubsection{
         CARD = INTEGER (Returned)
      }{
         The number of the card containing the named keyword.  If the
         card could not be found this is set to zero.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the data types logical, integer,
         real and double precision: replace {\tt "}x{\tt "} in the routine name by
         L, I, R or D as appropriate.
      }
   }
}
\sstroutine{
   FTS1\_GKEYx
}{
   Gets the value and comment of a named header of type REAL from
   a buffer of FITS-header card images
}{
   \sstdescription{
      This routine searches a buffer containing the header card images
      from a FITS file for a keyword NAME; and returns its value and
      comment, and the number of the card image within the buffer array
      that contains the named keyword.  The search ends when the next
      end of a header block, marked by the END keyword, is encountered
      or the buffer is exhausted.  If the keyword is present, THERE is
      .TRUE., otherwise it is .FALSE.   Since all cards images are in
      character format, type conversion is performed.  An error status
      will be returned if the conversion has failed.  If the keyword
      expected to be present more than once, then the argument NOCCUR
      controls which occurrence will be retrieved.  If a keyword is not
      found, then no error results and the argument VALUE remains
      unmodified.

      The name may be compound to permit reading of hierarchical
      keywords.  This routine will probably only work for HISTORY,
      COMMENT and {\tt '} {\tt '} (blank) if there is just one value given on the
      line, i.e. only one {\tt "}keyword = value{\tt "} before any comment
      marker.  An error will result otherwise.
   }
   \sstinvocation{
      CALL FTS1\_GKEYx( NCARD, BUFFER, SCARD, NAME, NOCCUR, THERE,
                       VALUE, COMENT, CARD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of card images in the buffer.
      }
      \sstsubsection{
         BUFFER( NCARD ) = CHARACTER $*$ 80 (Given)
      }{
         The buffer containing the header card images.
      }
      \sstsubsection{
         SCARD = INTEGER (Given)
      }{
         The number of the card from where the search will begin.  This
         is needed because the headers may contain a dummy header
         prior to an extension.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the keyword whose value is required.  This may be
         a compound name to handle hierarchical keywords, and it has
         the form keyword1.keyword2.keyword3 etc.  The maximum number of
         keywords per FITS card is 20.  Comparisons are performed in
         uppercase and blanks are removed.  Each keyword must be no
         longer than 8 characters.
      }
      \sstsubsection{
         NOCCUR = INTEGER (Given)
      }{
         The value of this argument specifies which occurrence of a
         keyword should be used, if multiple ones are expected.  Any
         value less than or equal to 1 indicates the first occurrence.
      }
      \sstsubsection{
         THERE = LOGICAL (Returned)
      }{
         If .TRUE., the keyword given by argument NAME is present,
         regardless of the exit status.
      }
      \sstsubsection{
         VALUE = ? (Returned)
      }{
         The value of the keyword.
      }
      \sstsubsection{
         COMENT = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The comment associated with the keyword.
      }
      \sstsubsection{
         CARD = INTEGER (Returned)
      }{
         The number of the card containing the named keyword.  If the
         card could not be found this is set to zero.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the data types logical, integer,
         real and double precision: replace {\tt "}x{\tt "} in the routine name by
         L, I, R or D as appropriate.
      }
   }
}
\sstroutine{
   FTS1\_GPARM
}{
   Add the group parameters to the FITS header records
}{
   \sstdescription{
      This is a server routine for FITSIN.  It packages up the
      operations required to add the group parameters to the HDS
      structure that contains the FITS header cards.  It also writes
      the group parameters to a log file is required.

      Each group parameter is evaluated in double precision from its
      scale and offset, and with the parameter name a pseudo FITS
      card is generated.  In the header structure the last card---has
      the END keyword---is overwritten. Once all the group parameters
      have been copied into the header structure, an END card is placed
      after them to preserve a valid FITS header section.
   }
   \sstinvocation{
       CALL FTS1\_GPARM( NCARD, HEADER, PCOUNT, PARAMS, PTYPE, PSCALE,
      :                 PZERO, BAD, BLANK, LOGHDR, FD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of header 80-character cards in the original FITS
         header.  It excludes the number of group parameters.
      }
      \sstsubsection{
         HEADER( NCARD $+$ PCOUNT ) = CHARACTER $*$ 80 (Given)
      }{
         The FITS headers in 80-character cards.  The aditional PCOUNT
         elements are for the group parameters.
      }
      \sstsubsection{
         PCOUNT = INTEGER (Given)
      }{
         The number of group parameters in each group.
      }
      \sstsubsection{
         PARAMS( PCOUNT ) = INTEGER (Given)
      }{
         The values of the group parameters in the header, i.e. before
         any scale and offset have been applied.
      }
      \sstsubsection{
         PTYPE( PCOUNT ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The type (descriptive name) of each group parameter.
      }
      \sstsubsection{
         PSCALE( PCOUNT ) = DOUBLE PRECISION (Given)
      }{
         The scale factors of the group parameters so that the
         parameters may be converted to the true floating-point values.
      }
      \sstsubsection{
         PZERO( PCOUNT ) = DOUBLE PRECISION (Given)
      }{
         The offsets of the group parameters so that the parameters may
         be converted to the true floating-point values.
      }
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true, testing and replacement of undefined parameters is to
         occur.  A blank value, as specified by \%BLANK, is replaced
         by the standard magic value.  If false, the value of \%BLANK
         is ignored.
      }
      \sstsubsection{
         BLANK = INTEGER (Given)
      }{
         Value of an undefined parameter.
      }
      \sstsubsection{
         LOGHDR = LOGICAL (Given)
      }{
         If true the evaluated group parameters written in FITS-card
         format will be written to the log file.
      }
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         The file descriptor for the log file.  It is ignored if \%LOGHDR
         is false.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_HDLOG
}{
   Outputs the FITS header cards to an ASCII file
}{
   \sstdescription{
      This is a server routine for FITSIN.  It packages up the
      operations required to write the FITS header cards (80-character)
      into an ASCII file.  A heading is also written giving the
      file and sub-file numbers.  The maximum record length of the
      ASCII file supported by this routine is 132 characters.  The
      minimum is 80 characters---an error is reported if it is smaller
      than 80.

      The file name appears in the caption before the headers.  It may
      be truncated if it is longer than the file recordsize less 30
      characters.  Truncation occurs at the start of the name and is
      designated via an ellipsis.
   }
   \sstinvocation{
      CALL FTS1\_HDLOG( HEADER, FD, CFN, SUBFIL, NHEADS, HDNUM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         HEADER( $*$ ) = CHARACTER $*$ 80 (Given)
      }{
         The FITS headers in 80-character records.
      }
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         The file descriptor for the log file.
      }
      \sstsubsection{
         CFN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The input filename or tape file number of the FITS file being
         processed.
      }
      \sstsubsection{
         SUBFIL = INTEGER (Given)
      }{
         The number of the sub-file/extension within the current FITS
         file being processed.
      }
      \sstsubsection{
         NHEADS = INTEGER (Given)
      }{
         The number of header sections in the sub-file.  This includes
         dummy FITS header sections.
      }
      \sstsubsection{
         HDNUM( $*$ ) = INTEGER (Given)
      }{
         The number of header cards within each header in the sub-file.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         The ASCII file must be opened.
      }
   }
}
\sstroutine{
   FTS1\_I2VXD
}{
   Converts a vector of 64-bit IEEE floating-point numbers to Vax-D
   format
}{
   \sstdescription{
      This is a dummy routine used to build the KAPPA FITS readers on
      UNIX.
   }
   \sstinvocation{
      CALL FTS1\_I2VXD( BSWAP, EL, BUF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BSWAP = LOGICAL (Given)
      }{
         Whether or not adjacent bytes are to be swapped.  If and only
         if BSWAP is 1 will the bytes be swapped.  Swapping must occur
         either prior or within this routine to obtain the correct
         Vax-D values.  An expression must not be given for this
         argument.  Bytes in the order 1 2 3 4 5 6 7 8 become
         2 1 4 3 6 5 8 7 after swapping.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of IEEE numbers to be converted.
      }
      \sstsubsection{
         BUF( EL ) = DOUBLE PRECISION (Given and Returned)
      }{
         On input the IEEE numbers to be converted.  On return these
         are converted to Vax-D format.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         {\tt "}IEEE Standard for Binary Floating-Point Arithmetic{\tt "},
         ANSI/IEEE 754, 1985.

         \sstitem
         {\tt "}Floating Point Agreement for FITS{\tt "}, D.C. Wells \& P. Grosbol,
         1990.
      }
   }
}
\sstroutine{
   FTS1\_I2VXR
}{
   Converts a vector of 32-bit IEEE floating-point numbers to Vax-F
   format
}{
   \sstdescription{
      This is a dummy routine used to build the KAPPA FITS readers on
      UNIX.
   }
   \sstinvocation{
      CALL FTS1\_I2VXR( BSWAP, WSWAP, EL, BUF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BSWAP = INTEGER (Given)
      }{
         Whether or not byte swapping is to take place.  If and only if
         BSWAP is 1 will the bytes be swapped.  Swapping must occur
         either prior or within this routine to obtain the correct Vax-F
         values.  An expression must not be given for this argument.
      }
      \sstsubsection{
         WSWAP = INTEGER (Given)
      }{
         Whether or not word swapping is to take place.  If and only if
         WSWAP is 1 will the words be swapped.  Swapping must occur
         either prior or within this routine to obtain the correct Vax-F
         values.  An expression must not be given for this argument.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of IEEE numbers to be converted.
      }
      \sstsubsection{
         BUF( EL ) = DOUBLE PRECISION (Given and Returned)
      }{
         On input the IEEE numbers to be converted.  On return these
         are converted to Vax-F format.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         {\tt "}IEEE Standard for Binary Floating-Point Arithmetic{\tt "},
         ANSI/IEEE 754, 1985.

         \sstitem
         {\tt "}Floating Point Agreement for FITS{\tt "}, D.C. Wells \& P. Grosbol,
         1990.
      }
   }
}
\sstroutine{
   FTS1\_INKEY
}{
   Insert keywords to a FITS card array
}{
   \sstdescription{
      This subroutine inserts a number of keyword cards into a
      FITS-header array just before some given keywords, and returns
      the position of these newly inserted cards in the FITS array
      after insertion.  If a given position keyword is not in the FITS
      header or is blank, its corresponding keyword card will be
      inserted just before the end card or appended to the present FITS
      array when end card does not exist.  If a keyword card to be
      inserted already exists in the FITS array, that card will
      be deleted and moved to the specified position.  For those new
      keyword cards, an equals sign {\tt '}={\tt '} will be put at the 9th column
      for simple keyword or immediately after keywords for compound
      ones; and a character value {\tt '}\{undefined\}{\tt '} will be given to them.

      The following reserved keywords are not modified: SIMPLE, BITPIX,
      NAXIS, NAXISn, EXTEND, PCOUNT, GCOUNT, XTENSION, BLOCKED, and END.
   }
   \sstinvocation{
      CALL FTS1\_INKEY( NOLDCA, NKEY, NAMES, PSTNS, FTSCAR,
      :                ACTNUM, IARY1, IARY2, CARY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NOLDCA = INTEGER (Given)
      }{
         Number of cards in the original FITS array.
      }
      \sstsubsection{
         NKEY = INTEGER (Given)
      }{
         The number of keyword cards to be inserted into the FITS-header
         array.
      }
      \sstsubsection{
         NAMES( NKEY ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The keywords to be inserted into FITS card array.
      }
      \sstsubsection{
         PSTNS( NKEY ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The position keyword names, before them the new keywords is
         inserted.  If any name in it does not exit in FITS array, its
         corresponding keyword will be inserted just before the end card
         or appended to FITS array when end card does not exist.  If two
         or more new cards have the same position name, they will all be
         put just before the position name in the same order as they are
         in NAMES.
      }
      \sstsubsection{
         FTSCAR( NOLDCA $+$ NKEY ) = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         On entry its first NOLDCA elements hold the original FITS
         cards. On exit, its first ACTNUM elements hold the FITS cards
         after the insersion.
      }
      \sstsubsection{
         ACTNUM = INTEGER (Returned)
      }{
         The actual number of cards in the FITS array after inserting.
      }
      \sstsubsection{
         IARY1( NOLDCA $+$ NKEY ) = INTEGER (Returned)
      }{
         The first temporary working space.
      }
      \sstsubsection{
         IARY2( NOLDCA $+$ NKEY ) = INTEGER (Returned)
      }{
         The second temporary working space.
      }
      \sstsubsection{
         CARY( NOLDCA $+$ NKEY ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         A temporary working space.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_ISKEY
}{
   Inquires whether or not a string is a valid FITS keyword
}{
   \sstdescription{
      This routine tests whether a given string would be a valid FITS
      header keyword or not.  For a keyword to be valid it must be
      no more than eight characters, and must comprise only uppercase
      Latin letters, numbers, underscore, and hyphen.
   }
   \sstinvocation{
      CALL FTS1\_ISKEY( KEYWRD, VALID, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         KEYWRD = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The string to be tested.
      }
      \sstsubsection{
         VALID = LOGICAL (Returned)
      }{
         If true, the string is a valid FITS header keyword.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      This routine does not convert the string to uppercase or remove
      leading blanks before validation.
   }
}
\sstroutine{
   FTS1\_LOKEY
}{
   Locates an occurrence of a keyword in a FITS header
}{
   \sstdescription{
      This routines find the location of a certain occurrence of a
      named keyword in an array of FITS headers.  Hierarchical
      keywords are allowed.  A bad status is returned if the desired
      keyword is not present in the header array.
   }
   \sstinvocation{
      CALL FTS1\_LOKEY( NCARD, HEADER, KEYWRD, OCCUR, CARD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of cards in the FITS header array.
      }
      \sstsubsection{
         HEADER( NCARD ) = CHARACTER $*$ ( 80 ) (Given)
      }{
         The array of FITS headers.
      }
      \sstsubsection{
         KEYWRD = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The keyword to search for in the array.  This may be a
         compound name to handle hierarchical keywords, and it has the
         form keyword1.keyword2.keyword3 etc.  The maximum number of
         keywords per FITS card is 20.  Comparisons are performed in
         uppercase and blanks are removed.  Each keyword must be no
         longer than 8 characters.
      }
      \sstsubsection{
         OCCUR = INTEGER (Given)
      }{
         The occurrence of the keyword to locate.  Values less than 1
         obtain the first occurrence.
      }
      \sstsubsection{
         CARD = INTEGER (Returned)
      }{
         The number of card containing the desired keyword.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_MANDH
}{
   Obtain the values of the mandatory headers in a FITS file
}{
   \sstdescription{
      This routine searches for the mandatory FITS header keywords
      stored in a buffer, and their values are returned, if they
      are present. Should an item be missing or have an unsupported
      value an error is reported, a bad status is set and the routine
      exits. This version supports mandatory descriptors that are not
      in the correct order.

      Currently, only simple FITS and group-format FITS are supported.

      The number of dimensions is reduced when the highest dimension is
      one.
   }
   \sstinvocation{
      CALL FTS1\_MANDH( FIRST, NCARD, HEADER, SCARD, BITPIX, NDIM, AXIS,
                       DARRAY, NONSDA, SIZE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FIRST = LOGICAL (Given)
      }{
         If true the buffer contains the first header of a FITS file.
         It is used to validate the header.
      }
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of card images in the header.
      }
      \sstsubsection{
         HEADER( NCARD ) = CHARACTER $*$ 80 (Given)
      }{
         The array of headers (80-character cards) to be searched for
         the mandatory keywords.
      }
      \sstsubsection{
         SCARD = INTEGER (Given)
      }{
         The number of the card from where the searches of the header
         will begin.  This is needed because the headers make contain a
         dummy header prior to an extension.
      }
      \sstsubsection{
         BITPIX = INTEGER (Returned)
      }{
         The number of bits per pixel of the data array.
      }
      \sstsubsection{
         NDIM = INTEGER (Returned)
      }{
         The number of active dimensions.
      }
      \sstsubsection{
         AXIS( DAT\_\_MXDIM ) = INTEGER (Returned)
      }{
         The dimensions of the data array.
      }
      \sstsubsection{
         DARRAY = LOGICAL (Returned)
      }{
         If true there is a data array.
      }
      \sstsubsection{
         NONSDA = LOGICAL (Returned)
      }{
         If true the data array is non-standard.
      }
      \sstsubsection{
         SIZE = INTEGER  (Returned)
      }{
         The number of pixels in the (or each) data array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   FTS1\_NDFCM
}{
   Create the title, units, axes, wcs, and FITS extension in an NDF
   from the FITS headers
}{
   \sstdescription{
      This routine adds the character components, axis structure, WCS
      component and FITS extension to an NDF.  It searches a buffer
      containing the FITS header card images for the OBJECT keyword whose
      value becomes the NDF title if present.  Similarly BUNIT is mapped to
      the NDF units.  The supplied header structure is copied to the
      FITS extension.
   }
   \sstinvocation{
      CALL FTS1\_NDFCM( NCARD, HEADER, SCARD, NDF, NENCOD, ENCODS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of cards in the array of headers, from the start of
         the first header section to the end of the current one.
      }
      \sstsubsection{
         HEADER( NCARD ) = CHARACTER $*$ 80 (Given)
      }{
         The buffer containing the header card images.
      }
      \sstsubsection{
         SCARD = INTEGER (Given)
      }{
         The number of the card from where searches will begin, and
         copying of the headers to the FITS extension.   Therefore
         NCARD - SCARD $+$ 1 headers will appear in the extension. This
         argument is needed because the headers make contain a dummy
         header prior to an extension.
      }
      \sstsubsection{
         NDF = INTEGER (Given)
      }{
         Identifier of the NDF to which to write the additional
         components and the FITS extension.
      }
      \sstsubsection{
         NENCOD = INTEGER (Given)
      }{
         The number of AST encodings supplied in ENCODS.
      }
      \sstsubsection{
         ENCODS( NENCOD ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The user{\tt '}s preferred AST encodings. If NENCOD is zero, then this
         is ignored, and an intelligent guess is made as to which encoding
         to use. The encoding determines which FITS headers are used to
         create the NDF WCS component.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   FTS1\_NDF
}{
   Makes an NDF from a simple or group-format FITS file
}{
   \sstdescription{
      This is a server routine for FITSIN/FITSDIN, hence the large
      argument list.  It packages up the operations required to create
      and name an NDF; copy the FITS data to the NDF{\tt '}s data array,
      performing a data conversion if requested and flagging blank data
      with the standard bad-pixel values; generate the other
      components: title, units, WCS, axis structure and the FITS extension.
      For group-format FITS data, a series of NDFs are created, one per
      group, each with a generated filename.  A null NDF may be given
      and this routine will exit, but permit the calling routine to
      continue to the next FITS file.
   }
   \sstinvocation{
      CALL FTS1\_NDF( HEADER, BFPNTR, RCPNTR, AUTO, PNNDF, MEDIUM, MD,
                     VMS, LENDIA, SIZE, NDIM, DIMS, BPV, FMTCNV, FMTIN,
                     FMTOUT, IEEE, BADPIX, BLANK, BSCALE, BZERO, DARRAY,
                     NONSDA, GCOUNT, PCOUNT, MXPARM, PTYPE, PSCALE,
                     PZERO, FILROO, LOGHDR, FD, CFN, SUBFIL, GEXTND,
                     NCARD, HEADER, SCARD, NENCOD, ENCODS, BLKSIZ, ACTSIZ,
                     OFFSET, CURREC, NEXT, PARAMS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         HEADER( $*$ ) = CHARACTER $*$ 80 (Given)
      }{
         The FITS headers in 80-character records.
      }
      \sstsubsection{
         BFPNTR = INTEGER (Given)
      }{
         Pointer to BUFFER( BLKSIZ ) = CHARACTER $*$ 1 (Given and Returned)
         The buffer containing the block of data. This is only read
         when \%OFFSET does not equal \%ACTSIZ, i.e. there are some
         non-header data within it.
      }
      \sstsubsection{
         RCPNTR = INTEGER (Given)
      }{
         Pointer to RECORD( 36 ) = CHARACTER $*$ ( 80 ) (Given and Returned)
         The buffer to hold the current FITS record.
      }
      \sstsubsection{
         AUTO = LOGICAL (Given)
      }{
         If true the processing should be done in automatic mode, where
         the user is not prompted for file names, since these are
         generated from \%FILROO with the sub-file or group numbers
         appended.
      }
      \sstsubsection{
         PNNDF = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter by which the filename of the output
         NDF will be obtained.
      }
      \sstsubsection{
         MEDIUM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The medium containing the FITS file.  Currently supported are
         {\tt '}DISK{\tt '} for a disk file, and {\tt '}TAPE{\tt '} for standard magnetic tape.
      }
      \sstsubsection{
         MD = INTEGER (Given)
      }{
         The tape or file descriptor depending on the value of \%MEDIUM.
      }
      \sstsubsection{
         VMS = LOGICAL (Given)
      }{
         If true, the operating system is VMS or RSX.  If false, the
         operating system is assumed to be UNIX.
      }
      \sstsubsection{
         LENDIA = LOGICAL (Given)
      }{
         If true, the machine uses Little Endian byte order (bytes
         swapped compared to FITS).  LENDIA is ignored when
         VMS = .TRUE..
      }
      \sstsubsection{
         SIZE = INTEGER (Given)
      }{
         The number of elements in the data array.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Dimensionality of the NDF.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the NDF.
      }
      \sstsubsection{
         BPV = INTEGER (Given)
      }{
         The number of bytes per data value.
      }
      \sstsubsection{
         FMTCNV = LOGICAL (Given)
      }{
         If true, format conversion from the integer FITS data to
         the real output data array is required.  This is ignored
         when BADPIX is false (which should be the case for IEEE
         floating-point data).
      }
      \sstsubsection{
         FMTIN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The HDS format of the data in the FITS file.  It will be
         ignored if there is no format conversion.
      }
      \sstsubsection{
         FMTOUT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The destination HDS format of the data array in the output
         file.
      }
      \sstsubsection{
         IEEE = LOGICAL (Given)
      }{
         If true the FITS data are in IEEE floating-point format.
      }
      \sstsubsection{
         BADPIX = LOGICAL (Given)
      }{
         If true the data-blank was defined in the FITS header.  It
         will be ignored if the data are in IEEE format.
      }
      \sstsubsection{
         BLANK = INTEGER (Given)
      }{
         The data-blank value equivalent to the bad-pixel flag.  It
         should be ignored if \%BADPIX is false.
      }
      \sstsubsection{
         BSCALE = REAL (Given)
      }{
         The scale factor of the FITS integer data for their conversion
         to the true floating-point values.
      }
      \sstsubsection{
         BZERO = REAL (Given)
      }{
         The offset of the FITS integer data for their conversion to
         the true floating-point values.
      }
      \sstsubsection{
         DARRAY = LOGICAL (Given)
      }{
         If true there is a data array present if the FITS file.
      }
      \sstsubsection{
         NONSDA = LOGICAL (Given)
      }{
         If true the data array is not standard, i.e. in group format.
         It is ignored if \%DARRAY is false.
      }
      \sstsubsection{
         GCOUNT = INTEGER (Given)
      }{
         The number of groups in the file.
      }
      \sstsubsection{
         PCOUNT = INTEGER (Given)
      }{
         The number of parameters per group in the file.
      }
      \sstsubsection{
         MXPARM = INTEGER (Given)
      }{
         The maximum number of group parameters, and the dimension size
         for the various group arrays.
      }
      \sstsubsection{
         PTYPE( MXPARM ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The type (descriptive name) of each group parameter.
      }
      \sstsubsection{
         PSCALE( MXPARM ) = DOUBLE PRECISION (Given)
      }{
         The scale factors of the group parameters so that the
         parameters may be converted to the true floating-point values.
      }
      \sstsubsection{
         PZERO( MXPARM ) = DOUBLE PRECISION (Given)
      }{
         The offsets of the group parameters so that the parameters may
         be converted to the true floating-point values.
      }
      \sstsubsection{
         FILROO = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The rootname of the output NDF.  The suffix Gn, where n=\%NG, is
         appended in group-format mode to generate the filename.
         Otherwise in automatic mode the NDF filename is the rootname.
      }
      \sstsubsection{
         LOGHDR = LOGICAL (Given)
      }{
         If true there is a log file open and records of the output file
         names will be written to it.
      }
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         The file descriptor for the log file.  It is ignored if \%LOGHDR
         is false.
      }
      \sstsubsection{
         CFN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The number on the tape of the FITS file being processed if
         MEDIUM is {\tt '}TAPE{\tt '}, or the input disk-FITS filename if MEDIUM
         is {\tt '}TAPE{\tt '}.
      }
      \sstsubsection{
         SUBFIL = INTEGER (Given)
      }{
         The number of the sub-file/extension within the current FITS
         file being processed.
      }
      \sstsubsection{
         GEXTND = LOGICAL (Given)
      }{
         If true there may be extensions in the FITS sub-file.
      }
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of header 80-character cards in the header.  Note
         the size of the structure will not do because it will normally
         have unfilled elements at the end, because of the way the
         work space is obtained in quanta.  It should be the sum of the
         headers and the group parameters.
      }
      \sstsubsection{
         SCARD = INTEGER (Given)
      }{
         The number of the card from where the searches of the header
         will begin.  This is needed because the headers make contain a
         dummy header prior to an extension.
      }
      \sstsubsection{
         NENCOD = INTEGER (Given)
      }{
         The number of AST encodings supplied in ENCODS.
      }
      \sstsubsection{
         ENCODS( NENCOD ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The user{\tt '}s preferred AST encodings. If NENCOD is zero, then this
         is ignored, and an intelligent guess is made as to which encoding
         to use. The encoding determines which FITS headers are used to
         create the NDF WCS component.
      }
      \sstsubsection{
         BLKSIZ = INTEGER (Given)
      }{
         The maximum blocksize and dimension of the tape/disk buffer.
      }
      \sstsubsection{
         ACTSIZ = INTEGER (Given and Returned)
      }{
         The actual block size (a multiple of the FITS record length of
         2880 bytes).  It is only an input argument for
         \%MEDIUM = {\tt '}DISK{\tt '}.
      }
      \sstsubsection{
         OFFSET = INTEGER (Given and Returned)
      }{
         The number of bytes in the current block already interpreted.
      }
      \sstsubsection{
         CURREC = LOGICAL (Given and Returned)
      }{
         If true the current FITS record is to be used immediately, i.e.
         it has alrady been read from tape or disk into \%RECORD.
      }
      \sstsubsection{
         NEXT = LOGICAL (Returned)
      }{
         This qualifies the status.  If true it instructs the calling
         routine to go to the next FITS sub-file, and if status is bad
         the calling routine should flush the error messages.
      }
      \sstsubsection{
         PARAMS( MXPARM $*$ BPV ) = BYTE (Returned)
      }{
         Numerical values of parameters associated with a group-format
         array.
      }
      \sstsubsection{
         STATUS  = INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   FTS1\_PHEAD
}{
   Process the headers in a FITS file on tape or disk
}{
   \sstdescription{
      This routine reads selected files off a FITS tape or disk and
      writes the header data into an HDS file, and they are reported to
      the user.  The dimension of the HDS buffer array in the HDS
      structure is enlarged if the buffer is filled.  The number of
      bytes of header cards in the last data block (of the current
      file) containing header data is returned.  This is to enable
      other routines to know where the data array starts in that
      buffer.  If this number equals the actual blocksize this means a
      new data block needs to be read to access the data array.
   }
   \sstinvocation{
       CALL FTS1\_PHEAD( BFPNTR, RCPNTR, RECORD, MEDIUM, MD, LOC, BLKSIZ,
      :                 MAXHDR, REPORT, ACTSIZ, OFFSET, CURREC, HSTART,
      :                 HDNUM, EXTEND, NHEADS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BFPNTR = INTEGER  (Given)
      }{
         Pointer to the BUFFER byte array
      }
      \sstsubsection{
         RCPNTR = INTEGER  (Given)
      }{
         Pointer to the RECORD byte array
      }
      \sstsubsection{
         RECORD( 36 ) = CHARACTER $*$ ( 80 ) (Given and Returned)
      }{
         The buffer to hold the current FITS record.  Note that this
         out of order for SGP/16, but it is needed here so that a
         mapped array may be passed.  This is a temporary kludge until
         the FITS readers are redesigned.
      }
      \sstsubsection{
         MEDIUM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The medium containing the FITS file.  Currently supported are
         {\tt '}DISK{\tt '} for a disk file, and {\tt '}TAPE{\tt '} for standard magnetic tape.
      }
      \sstsubsection{
         MD = INTEGER (Given)
      }{
         The tape or file descriptor depending on the value of \%MEDIUM.
      }
      \sstsubsection{
         LOC = CHARACTER $*$ ( DAT\_\_SZLOC ) (Given)
      }{
         The locator to the HDS object that will contain the header
         cards.
      }
      \sstsubsection{
         BLKSIZ = INTEGER (Given)
      }{
         The maximum blocksize and dimension of the data buffer.
      }
      \sstsubsection{
         MAXHDR = INTEGER (Given)
      }{
         The maximum number of header sections in the current sub-file.
      }
      \sstsubsection{
         REPORT = LOGICAL (Given)
      }{
         If true the header cards are reported to the user.
      }
      \sstsubsection{
         ACTSIZ = INTEGER (Given and Returned)
      }{
         The actual block size (a multiple of the FITS record length of
         2880 bytes).  It is only an input argument for
         \%MEDIUM = {\tt '}DISK{\tt '}.
      }
      \sstsubsection{
         OFFSET = INTEGER (Given and Returned)
      }{
         The number of bytes in the current block already interpreted
         as the header plus any earlier sub files.
      }
      \sstsubsection{
         CURREC = LOGICAL (Given and Returned)
      }{
         If true the current FITS record is to be used immediately, i.e.
         it has alrady been read from tape or disk into \%RECORD.  On
         exit it is true when a new record has been read to determine
         whether or not there is an extension, but no extension is
         found.
      }
      \sstsubsection{
         HSTART( MAXHDR ) = INTEGER (Returned)
      }{
         The number of the header card where each FITS header starts.
      }
      \sstsubsection{
         HDNUM( MAXHDR ) = INTEGER (Returned)
      }{
         The number of header records processed and stored in the
         output data structure, one per header section in the current
         sub-file.
      }
      \sstsubsection{
         EXTEND = LOGICAL (Returned)
      }{
         If true there are extensions in the FITS sub-file.
      }
      \sstsubsection{
         NHEADS = INTEGER (Returned)
      }{
         The number of header sections in the sub-file.  This includes
         dummy FITS header sections.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   FTS1\_PTKEY
}{
   Puts non-reserved keyword cards into FITS extension of an NDF file
}{
   \sstdescription{
      This subroutine inserts a number of non-reserved keyword cards
      into the FITS extension of an NDF file at the positions just
      before a specified keyword card.  If a keyword card exists in the
      extension, the routine will move the card to the specified
      position.  This provides a way to relocate the existing keyword
      card.  If a keyword card does not exist in the extension, the
      routine will put the keyword card at the specified position and
      will add an equals sign to it, at column 9 for simple keywords or
      immediately after the keyword for compound ones.  To those newly
      added keywords, a character value {\tt '}\{undefined\}{\tt '} is assigned.  To
      write new values for these keywords, you should use subroutine
      FTS1\_WKEYx.

      Following keywords are regarded as reserved keywords: SIMPLE,
      BITPIX, NAXIS, NAXISn, EXTEND, PCOUNT, GCOUNT and XTENSION.
      Their order in the extension should be fixed and should not be
      changed by any routine.  Therefore if any of them is included in
      the NAMES, it will be ignored.

      This subroutine can not be used to insert comment cards, that is,
      the cards with keyword {\tt '}COMMENT{\tt '} or {\tt '}HISTORY{\tt '}, etc.
   }
   \sstinvocation{
      CALL FTS1\_PTKEY( FTSLOC, NKEY, NAMES, PSTNS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FTSLOC = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The locator to the FITS extension of the NDF.
      }
      \sstsubsection{
         NKEY = INTEGER (Given)
      }{
         The number of keyword cards to be inserted into the FITS
         extension.
      }
      \sstsubsection{
         NAMES( NKEY ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The names of the keywords to be inserted.  This may be a
         compound name to handle hierarchical keywords, and it has the
         form keyword1.keyword2.keyword3 etc.  The maximum number of
         keywords per FITS card is 20.  Each keyword must be no longer
         than 8 characters.  When inserted, the lower case letters are
         converted to uppercase and blanks are removed.
      }
      \sstsubsection{
         PSTNS( NKEY ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The names of the cards before which the corresponding new
         keyword cards are inserted.  If any name in PSTNS does not
         exist in the original FITS card array or is blank, its
         corresponding new card will be inserted just before end-card
         or be appended to the original FITS card array when there is no
         end-card.  If two or more new cards have the same PSTNS name,
         they will all be put before the PSTNS name in the same order
         as they are in NAMES.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      The FITS extension is mapped for update access.  It therefore must
      have some values assigned before using the routine.
   }
}
\sstroutine{
   FTS1\_QTYPE
}{
   Determines the data type of a FITS header value
}{
   \sstdescription{
      This routine takes a FITS header card and determines the HDS data
      type of the value.  If there is no value because there is no
      equals sign present or the keyword is HISTORY or COMMENT, the
      type is returned as {\tt '}COMMENT{\tt '}.
   }
   \sstinvocation{
      CALL FTS1\_QTYPE( CARD, TYPE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         CARD = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The FITS header card.  It should be 80 character long, but
         the routine might work with less depending on the length of
         the value and keyword.
      }
      \sstsubsection{
         TYPE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The HDS data type of the header{\tt '}s value.   It is one of the
         following: {\tt '}\_INTEGER{\tt '}, {\tt '}\_REAL{\tt '}, {\tt '}\_DOUBLE{\tt '}, {\tt '}\_LOGICAL{\tt '}, {\tt '}\_CHAR{\tt '},
         or {\tt '}COMMENT{\tt '}.  The length should be at least
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_RDATA
}{
   Read the data of a FITS file on disk or tape
}{
   \sstdescription{
      This routine reads the byte stream in the data blocks from the
      FITS tape or disk file written in the simple format, and writes
      the data into an array.  The bytes may be reversed for VAX/VMS.
   }
   \sstinvocation{
       CALL FTS1\_RDATA ( MEDIUM, MD, SIZE, BPV, REVERS, BLKSIZ, ACTSIZ,
      :                  BUFFER, OFFSET, RECORD, RDISP, DARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         MEDIUM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The medium containing the FITS file.  Currently supported are
         {\tt '}DISK{\tt '} for a disk file, and {\tt '}TAPE{\tt '} for standard magnetic tape.
      }
      \sstsubsection{
         MD     = INTEGER (Given)
      }{
         The tape or file descriptor depending on the value of \%MEDIUM.
      }
      \sstsubsection{
         SIZE   = INTEGER (Given)
      }{
         Number of elements in the data array.
      }
      \sstsubsection{
         BPV    = INTEGER (Given)
      }{
         The number of bytes per data value.
      }
      \sstsubsection{
         REVERS = LOGICAL (Given)
      }{
         If true the FITS data bytes are to be reversed within each
         word (when BPV is 2) or each integer (when BPV is 4) etc.  If
         BPV=1 this flags makes no difference.  Normally, only 2{\tt '}s
         complement integer data need be reversed.  Floating-point data
         require adjacent bytes to be swapped.
      }
      \sstsubsection{
         BLKSIZ = INTEGER (Given)
      }{
         The maximum blocksize and dimension of the tape/disk buffer.
      }
      \sstsubsection{
         ACTSIZ = INTEGER (Given and Returned)
      }{
         The actual block size (a multiple of the FITS record length of
         2880 bytes).  It is only an input argument for
         \%MEDIUM = {\tt '}DISK{\tt '}.
      }
      \sstsubsection{
         BUFFER( BLKSIZ ) = BYTE (Given and Returned)
      }{
         The buffer containing the block of data. This is only read
         when \%OFFSET does not equal \%ACTSIZ, i.e. there are some
         non-header data within it.
      }
      \sstsubsection{
         OFFSET = INTEGER (Given and Returned)
      }{
         The number of bytes in the current block already interpreted.
      }
      \sstsubsection{
         RECORD( 2880 ) = BYTE (Given and Returned)
      }{
         The buffer to hold the current FITS record.
      }
      \sstsubsection{
         RDISP = INTEGER (Given and Returned)
      }{
         The number of bytes in the current record already interpreted.
         If this displacement is equal to the record length then a new
         FITS record will be obtained.  The displacement will be updated
         during processing of the group parameters and data, and
         therefore can have an arbitrary value between 0 and 2880.  Do
         not modify this argument outside this routine once initialised.
      }
      \sstsubsection{
         DARRAY( SIZE $*$ BPV ) = BYTE (Returned)
      }{
         The data array used to store the data read.
      }
      \sstsubsection{
         STATUS  = INTEGER(Given and Returned)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   FTS1\_RFMOD
}{
   Reads a text file containing instructions for editing an NDF{\tt '}s
   FITS extension
}{
   \sstdescription{
      This routines opens a text file and parses it to determine how to
      modify an NDF{\tt '}s FITS extension.  Details of the format and its
      interpretation is given in the item called {\tt "}File Format{\tt "}.  The
      routine returns the editing command, keyword, position, values,
      comment, and data type in arrays.
   }
   \sstinvocation{
      CALL FTS1\_RFMOD( FD, MAXMOD, NWRITE, EDITS, KEYWDS, KEYPOS,
                       KOCCUR, POCCUR, VALUES, COMNTS, TYPES, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         The FIO identifier of the text file containing the editing
         instructions.
      }
      \sstsubsection{
         MAXMOD = INTEGER (Given)
      }{
         The maximum number of modifications.
      }
      \sstsubsection{
         NWRITE = INTEGER (Returned)
      }{
         The number of modifications actually made.
      }
      \sstsubsection{
         EDITS( MAXMOD ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The editing commands.  Thus need only be one character per
         element.
      }
      \sstsubsection{
         KEYWDS( MAXMOD ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The FITS keywords to be modified into FITS card array.  The
         length should be at least 48 characters to allow for
         hierarchical keywords.
      }
      \sstsubsection{
         KEYPOS( MAXMOD ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The position keyword names.  The new keywords are inserted
         immediately before each corresponding position keyword.
         The length should be at least 48 characters to allow for
         hierarchical keywords.
      }
      \sstsubsection{
         KOCCUR( MAXMOD ) = INTEGER (Returned)
      }{
         The occurrences of the KEYWDS keywords to use.
      }
      \sstsubsection{
         POCCUR( MAXMOD ) = INTEGER (Returned)
      }{
         The occurrences of the KEYPOS keywords to use.
      }
      \sstsubsection{
         VALUES( MAXMOD ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The values to be given to the KEYWDS keywords.  The length
         should be at least 68 characters to allow for the maximum
         length of a value.
      }
      \sstsubsection{
         COMNTS( MAXMOD ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The comments of the NAME keywords to use.  The length should
         be at least 68 characters to allow for the maximum length of a
         comment, but normally 50 should be adequate.
      }
      \sstsubsection{
         TYPES( MAXMOD ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The data types of the values to write.  These will be one of
         the following: {\tt '}\_CHAR{\tt '},  {\tt '}\_DOUBLE{\tt '}, {\tt '}\_INTEGER{\tt '}, {\tt '}\_LOGICAL{\tt '},
         {\tt '}\_REAL{\tt '}.  In addition there are two special values: {\tt '}COMMENT{\tt '}
         to indicate that the card is a comment (so strictly it has no
         type), and {\tt '} {\tt '} to indicate that the data type is unknown, as
         occurs for a value defined by a reference keyword.  The length
         should be at least 8 characters.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      File Format
   }{
      The file consists of a series of lines, one per editing
      instruction, although blank lines and lines beginning with a ! or
      \# are treated as comments.  Note that the order does matter, as
      the edits are performed in the order given.

      The format is summarised below:

        command keyword\{[occur]\}\{(keyword\{[occur]\})\} \{value \{comment\}\}

      where braces indicate optional values, and occur is the
      occurrence of the keyword.  In effect there are four fields
      delineated by spaces that define the edit operation, keyword,
      value and comment.

      Field 1:  This specifies the editing operation.  Allowed values
      are Delete, Exist, Move, Read, Write, and Update, and can be
      abbreviated to the initial letter.  Delete removes a named
      keyword.  Read causes the value of a named keyword to be
      displayed to standard output.  Exist reports TRUE to standard
      output if the named keyword exists in the header, and FALSE if
      the keyword is not present.  Move relocates a named keyword to be
      immediately before a second keyword.  When this positional
      keyword is not supplied, it defaults to the END card, and if the
      END card is absent, the new location is at the end of the
      headers.  Write creates a new card given a value and an optional
      comment.  Its location uses the same rules as for the Move
      command.  Update revises the value and/or the comment.  If a
      secondary keyword is defined explicitly, the card may be
      relocated at the same time.  Update requires that the keyword
      exists.

      Field 2:  This specifies the keyword to edit, and optionally the
      position of that keyword in the header after the edit (for Move,
      Write and Update edits).  The new position in the header is
      immediately before a positional keyword, whose name is given in
      parentheses concatenated to the edit keyword.  See {\tt "}Field 1{\tt "} for
      defaulting when the position parameter is not defined or is null.

      Both the editing keyword and position keyword may be compound to
      handle hierarchical keywords.  In this case the form is
      keyword1.keyword2.keyword3 etc.  All keywords must be valid FITS
      keywords.  This means they must be no more than 8 characters
      long, and the only permitted characters are uppercase alphabetic,
      numbers, hyphen, and underscore.  Invalid keywords will be
      rejected.

      Both the edit and position keyword may have an occurrence
      specified in brackets [].  This enables editing of a keyword that
      is not the first occurrence of that keyword, or locate a edited
      keyword not at the first occurrence of the positional keyword.
      Note that it is not normal to have multiple occurrences of a
      keyword in a FITS header, unless it is blank, COMMENT or HISTORY.
      Any text other than a positive integer is interpreted as the
      first occurrence.

      Use a null value ({\tt '}{\tt '} or {\tt "}{\tt "}) if you want the card to be a comment
      with keyword other than COMMENT or HISTORY.  As blank keywords are
      used for hierarchical keywords, to write a comment in a blank
      keyword you must give a null edit keyword.  These have no keyword
      appears before the left parenthesis or bracket, such as (), [],
      [2], or (EPOCH).

      Field 3:
      This specifies the value to assign to the edited keyword in the
      the Write and Update operations, or the name of the new keyword
      in the Rename modification.  If the keyword exists, the existing
      value or keyword is replaced, as appropriate.  The data type used
      to store the value is inferred from the value itself.  See topic
      {\tt "}Value Data Types{\tt "}.

      For the Update and Write modifications there is a special value,
      \$V, which means use the current value of the edited keyword,
      provided that keyword exists.  This makes it possible to modify a
      comment, leaving the value unaltered.  In addition \$V(keyword)
      requests that the value of the keyword given between the
      parentheses be assigned to the keyword being edited.

      The value field is ignored when the keyword is COMMENT, HISTORY
      or blank and the modification is an Update or Write.

      Field 4:
      This specifies the comment to assign to the edited keyword for the
      Write and Update operations.  A leading {\tt '}/{\tt '} should not be
      supplied.

      There is a special value, \$C, which means use the current comment
      of the edited keyword, provided that keyword exists.  This makes
      it possible to modify a value, leaving the comment unaltered.  In
      addition \$C(keyword) requests that the comment of the keyword
      given between the parentheses be assigned to the edited keyword.

      To obtain leading spaces before some commentary, use a quote ({\tt '})
      or double quote ({\tt "}) as the first character of the comment.  There
      is no need to terminate the comment with a trailing and matching
      quotation character.  Also do not double quotes should one form
      part of the comment.
   }
   \sstdiytopic{
      Value Data Types
   }{
      The data type of the value is determined as follows:
      \sstitemlist{

         \sstitem
            Values enclosed in quotes ({\tt '}) or doubled quotes ({\tt "}) are
            strings.  Note that numeric or logical string values must
            be quoted to prevent them being converted to a numeric or
            logical value in the FITS extension.

         \sstitem
            Otherwise type conversions of the first word after the
            keywords are made to integer, double precision, and logical
            types in turn.  If a conversion is successful, that becomes the
            data type.  In the case of double precision, the type is set
            to real when the number of significant digits only warrants
            single precision.  If all the conversions failed the value
            is deemed to be a string.
      }
   }
   \sstdiytopic{
      Examples of the File Format
   }{
      The best way to illustrate the options is by listing some example
      lines.

          P AIRMASS
      This reports the value of keyword AIRMASS to standard output.

          E FILTER
      This determines whether keyword FILTER exists and reports TRUE or
      FALSE to standard output.

          D OFFSET
      This deletes the keyword OFFSET.

          Delete OFFSET[2]
      This deletes any second occurrence of keyword OFFSET.

          Rename OFFSET1[2] OFFSET2
      This renames the second occurrence of keyword OFFSET1 to have
      keyword OFFSET2.

          W AIRMASS 1.379
      This writes a real value to new keyword AIRMASS, which will be
      located at the end of the FITS extension.

          W FILTER(AIRMASS) Y
      This writes a logical true value to new keyword FILTER, which
      will be located just before the AIRMASS keyword, if it exists.

          Write FILTER(AIRMASS) {\tt '}Y{\tt '}
      As the preceding example except that this writes a character
      value {\tt "}Y{\tt "}.

          W COMMENT(AIRMASS) . Following values apply to mid-observation
      This writes a COMMENT card immediately before the AIRMASS card,
      the comment being {\tt "}Following values apply to mid-observation{\tt "}.

          W DROCOM(AIRMASS) {\tt '}{\tt '} Following values apply to mid-observation
      As the preceding example but this writes to a non-standard
      comment keyword called DROCOM.  Note the need to supply a null
      value.

          W (AIRMASS) {\tt '}{\tt '} Following values apply to mid-observation
      As the preceding example but this writes to a blank-keyword
      comment.

          U OBSERVER {\tt "}Dr. Peter O{\tt '}Leary{\tt "} Name of principal observer
      This updates the OBSERVER keyword with the string value
      {\tt "}Dr. Peter O{\tt '}Leary{\tt "}, and comment {\tt "}Name of principal observer{\tt "}.
      Note that had the value been enclosed in single quotes ({\tt '}), the
      apostrophe would need to be doubled.

          M OFFSET
      This moves the keyword OFFSET to just before the END card.

          Move OFFSET(SCALE)
      This moves the keyword OFFSET to just before the SCALE card.

          Move OFFSET[2](COMMENT[3])
      This moves the second occurrence of keyword OFFSET to just
      before the third COMMENT card.
   }
}
\sstroutine{
   FTS1\_RGRDA
}{
   Read the data of a FITS file in group format from disk or tape
}{
   \sstdescription{
      This routine reads a data block from the FITS tape or disk file
      that has byte stream of data in the groups format, and writes the
      data into an array.  The values of the parameters associated with
      the data array are also obtained.  The bytes may be reversed for
      VAX/VMS.
   }
   \sstinvocation{
       CALL FTS1\_RGRDA ( MEDIUM, MD, SIZE, BPV, REVERS, PCOUNT, BLKSIZ,
      :                  ACTSIZ, BUFFER, OFFSET, RECORD, RDISP, PARAM,
      :                  DARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         MEDIUM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The medium containing the FITS file.  Currently supported are
         {\tt '}DISK{\tt '} for a disk file, and {\tt '}TAPE{\tt '} for standard magnetic tape.
      }
      \sstsubsection{
         MD     = INTEGER (Given)
      }{
         The tape or file descriptor depending on the value of \%MEDIUM.
      }
      \sstsubsection{
         SIZE   = INTEGER (Given)
      }{
         Number of elements in the data array.  Note this is not the
         same as the number of bytes.
      }
      \sstsubsection{
         BPV    = INTEGER (Given)
      }{
         The number of bytes per data value.
      }
      \sstsubsection{
         REVERS = LOGICAL (Given)
      }{
         If true the FITS data bytes are to be reversed within each
         word (when BPV is 2) or each integer (when BPV is 4) etc.  If
         BPV=1 this flags makes no difference.  Normally, only 2{\tt '}s
         complement integer data need be reversed.  Floating-point data
         require adjacent bytes to be swapped.  Note that the group
         parameters are by definition in 2{\tt '}s complement integers, so are
         reversed regardless of the sense of this flag.
      }
      \sstsubsection{
         PCOUNT    = INTEGER (Given)
      }{
         The number of parameters associated with the data array.
      }
      \sstsubsection{
         BLKSIZ = INTEGER (Given)
      }{
         The maximum blocksize and dimension of the tape/disk buffer.
      }
      \sstsubsection{
         ACTSIZ = INTEGER (Given and Returned)
      }{
         The actual block size (a multiple of the FITS record length of
         2880 bytes).  It is only an input argument for
         \%MEDIUM = {\tt '}DISK{\tt '}.
      }
      \sstsubsection{
         BUFFER( BLKSIZ ) = BYTE (Given and Returned)
      }{
         The buffer containing the block of data. This is only read
         when \%OFFSET does not equal \%ACTSIZ, i.e. there are some
         non-header data within it.
      }
      \sstsubsection{
         OFFSET = INTEGER (Given and Returned)
      }{
         The number of bytes in the current block already interpreted.
      }
      \sstsubsection{
         RECORD( 2880 ) = BYTE (Given and Returned)
      }{
         The buffer to hold the current FITS record.
      }
      \sstsubsection{
         RDISP = INTEGER (Given and Returned)
      }{
         The number of bytes in the current record already interpreted.
         If this displacement is equal to the record length then a new
         FITS record will be obtained.  The displacement will be updated
         during processing of the group parameters and data, and
         therefore can have an arbitrary value between 0 and 2880.  Do
         not modify this argument outside this routine once initialised.
      }
      \sstsubsection{
         PARAM( PCOUNT $*$ BPV ) = BYTE (Returned)
      }{
         The parameters associated with the data array.
      }
      \sstsubsection{
         DARRAY( SIZE $*$ BPV ) = BYTE (Returned)
      }{
         The data array.
      }
      \sstsubsection{
         STATUS  = INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   FTS1\_ROOTN
}{
   Creates the rootname for an NDF
}{
   \sstdescription{
      This is a server routine for FITSIN.  It packages up the
      operations required to define the rootname for NDFs in
      automatic mode.  The rootname is the prefix followed by the
      file number underscore sub-file number (if present).
   }
   \sstinvocation{
       CALL FTS1\_ROOTN( MEDIUM, FN, SUBFIL, PREFIX, FILROO, NCROOT,
      :                 STATUS )
   }
   \sstarguments{
      \sstsubsection{
         MEDIUM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The medium containing the FITS file.  Currently supported are
         {\tt '}DISK{\tt '} for a disk file, and {\tt '}TAPE{\tt '} for standard magnetic tape.
      }
      \sstsubsection{
         CFN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The number on the tape of the FITS file being processed if
         MEDIUM is {\tt '}TAPE{\tt '}, or the input disk-FITS filename if MEDIUM
         is {\tt '}TAPE{\tt '}.
      }
      \sstsubsection{
         SUBFIL = INTEGER (Given)
      }{
         The number of the sub-file/extension within the current FITS
         file being processed.
      }
      \sstsubsection{
         PREFIX = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The prefix to be given to the file name of catalogues produced
         in automatic mode.  It is ignored when \%MEDIUM = {\tt '}DISK{\tt '}.
      }
      \sstsubsection{
         FILROO = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The root file name of NDFs (to be used in automatic mode).
      }
      \sstsubsection{
         NCROOT = INTEGER (Returned)
      }{
         The length in characters of the rootname.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_RSTAB
}{
   Read the table format from a FITS file and write to an ASCII file
}{
   \sstdescription{
      This routine reads the data blocks from a FITS table-format tape
      or disk file, and creates an ASCII file into which it writes the
      table.
   }
   \sstinvocation{
      CALL FTS1\_RSTAB ( TABLE, MEDIUM, MD, PNTABL, TABNAM, AUTO,
                        AXIS1, AXIS2, BLKSIZ, ACTSIZ, BUFFER,
                        OFFSET, CURREC, RECORD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TABLE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The work buffer to store a line of the table, i.e. must be
         AXIS1$+$1 bytes long.
      }
      \sstsubsection{
         MEDIUM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The medium containing the FITS file.  Currently supported are
         {\tt '}DISK{\tt '} for a disk file, and {\tt '}TAPE{\tt '} for standard magnetic tape.
      }
      \sstsubsection{
         MD     = INTEGER (Given)
      }{
         The tape or file descriptor depending on the value of \%MEDIUM.
      }
      \sstsubsection{
         PNTABL = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The parameter name used to create and associate the table
         file.
      }
      \sstsubsection{
         TABNAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The suggested name of the table file, unless \%AUTO is true
         when it is the actual name of the table file to be created.
      }
      \sstsubsection{
         AUTO = LOGICAL (Given)
      }{
         If true the supplied file name is used to open the table file
         rather than obtaining the file name via the parameter system.
      }
      \sstsubsection{
         AXIS1 = INTEGER (Given)
      }{
         Number of characters in a line of the table.
      }
      \sstsubsection{
         AXIS2 = INTEGER (Given)
      }{
         The number of lines in the table.
      }
      \sstsubsection{
         BLKSIZ = INTEGER (Given)
      }{
         The maximum blocksize and dimension of the tape/disk buffer.
      }
      \sstsubsection{
         ACTSIZ = INTEGER (Given and Returned)
      }{
         The actual block size (a multiple of the FITS record length of
         2880 bytes).  It is only an input argument for
         \%MEDIUM = {\tt '}DISK{\tt '}.
      }
      \sstsubsection{
         BUFFER( BLKSIZ ) = BYTE (Given and Returned)
      }{
         The buffer containing the block of data. This is only read
         when \%OFFSET does not equal \%ACTSIZ, i.e. there are some
         non-header data within it.
      }
      \sstsubsection{
         OFFSET = INTEGER (Given and Returned)
      }{
         The number of bytes in the current block already interpreted.
      }
      \sstsubsection{
         CURREC = LOGICAL (Given and Returned)
      }{
         If true the current FITS record is to be used immediately, i.e.
         it has alrady been read from tape or disk into \%RECORD.
      }
      \sstsubsection{
         RECORD( 2880 ) = BYTE (Given and Returned)
      }{
         The buffer to hold the current FITS record.
      }
      \sstsubsection{
         STATUS  = INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   FTS1\_SCOFB
}{
   Applies scale and zero to a REAL data vector, and substitutes
   magic values for blank FITS data
}{
   \sstdescription{
      This routine applies scale and offset to a 1-d REAL array.  Any
      pixels with the \%BLANK value are substituted by the standard
      magic value. On output, pixel is input value times scale plus
      offset.
   }
   \sstinvocation{
       CALL FTS1\_SCOFB ( BSCALE, BZERO, UNDEF, BLANK, SIZE, ARRAY,
      :                  STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BSCALE = REAL (Given)
      }{
         Scale factor to be applied to the array.
      }
      \sstsubsection{
         BZERO = REAL (Given)
      }{
         Offset to be applied to the array.
      }
      \sstsubsection{
         UNDEF = LOGICAL (Given)
      }{
         If true, testing and replacement of undefined data values is
         to occur.  A blank value, as specified by \%BLANK, is replaced
         by the standard magic value.  If false, the value of \%BLANK
         is ignored.
      }
      \sstsubsection{
         BLANK = INTEGER (Given)
      }{
         Value of an undefined datum.
      }
      \sstsubsection{
         SIZE  = INTEGER (Given)
      }{
         Number of elements in the data array.
      }
      \sstsubsection{
         ARRAY( SIZE ) = REAL (Given and Returned)
      }{
         The data array to which scaling and offset is to be applied.
      }
      \sstsubsection{
         STATUS  = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstbugs{
      None known.
   }
}
\sstroutine{
   FTS1\_SCTAB
}{
   Create an ASCII catalogue and description file in SCAR format
   from a FITS tape or disk file
}{
   \sstdescription{
      This is a server routine for FITSIN/FITSDIN.  It packages up the
      operations required to handle a FITS ASCII table file and turn it
      into an ASCII catalogue and SCAR description file.  The names of
      the output files are recorded in the logfile.
   }
   \sstinvocation{
       CALL FTS1\_SCTAB( HEADER, PNDSCF, PNTAB, MEDIUM, MD, NCARD, SCARD,
      :                 NDIM, DIMS, LOGHDR, FD, CFN, SUBFIL, PREFIX,
      :                 AUTO, BLKSIZ, ACTSIZ, BFPNTR, OFFSET, CURREC,
      :                 RCPNTR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         HEADER( NCARD ) = CHARACTER $*$ 80 (Given)
      }{
         The FITS headers in 80-character records.
      }
      \sstsubsection{
         PNDSCF = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter by which the filename of the SCAR
         description file will be obtained.
      }
      \sstsubsection{
         PNTAB = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter by which the filename of the
         table will be obtained.
      }
      \sstsubsection{
         MEDIUM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The medium containing the FITS file.  Currently supported are
         {\tt '}DISK{\tt '} for a disk file, and {\tt '}TAPE{\tt '} for standard magnetic tape.
      }
      \sstsubsection{
         MD = INTEGER (Given)
      }{
         The tape or file descriptor depending on the value of \%MEDIUM.
      }
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of card images in the buffer.
      }
      \sstsubsection{
         SCARD = INTEGER (Given)
      }{
         The number of the card from where the searches of the header
         will begin.  This is needed because the headers make contain a
         dummy header prior to an extension.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Dimensionality of the table.  At present only 2-d is supported.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the table.
      }
      \sstsubsection{
         LOGHDR = LOGICAL (Given)
      }{
         If true there is a log file open and records of the output file
         names will be written to it.
      }
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         The file descriptor for the log file.  It is ignored if \%LOGHDR
         is false.
      }
      \sstsubsection{
         CFN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The number on the tape of the FITS file being processed if
         MEDIUM is {\tt '}TAPE{\tt '}, or the input disk-FITS filename if MEDIUM
         is {\tt '}TAPE{\tt '}.
      }
      \sstsubsection{
         SUBFIL = INTEGER (Given)
      }{
         The number of the sub-file/extension within the current FITS
         file being processed.
      }
      \sstsubsection{
         PREFIX = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The prefix to be given to the file name of catalogues produced
         in automatic mode. It is ignored when \%MEDIUM = {\tt '}DISK{\tt '}.
      }
      \sstsubsection{
         AUTO = LOGICAL (Given)
      }{
         If true the processing should be done in automatic mode, where
         the user is not prompted for file names, since these are
         generated from the prefix, file and sub-file numbers in the
         case where the medium is tape.  The form is prefix\_file or
         prefix\_file\_subfile if the subfile is greater than 1.
         \%MEDIUM = {\tt '}DISK{\tt '} the prefix is ignored.
      }
      \sstsubsection{
         BLKSIZ = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The maximum block size and dimension of \%BUFFER.
      }
      \sstsubsection{
         ACTSIZ = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The actual block size on tape or disk (a multiple of the FITS
         record length of 2880 bytes). It is only an input argument for
         \%MEDIUM = {\tt '}DISK{\tt '}.
      }
      \sstsubsection{
         BFPNTR = INTEGER (Given)
      }{
         Pointer to the buffer containing catalogue data, the buffer
         itself will be updated each time a tape block is read.
         If the offset equals the block size then the existing data
         in the buffer will not be used.
      }
      \sstsubsection{
         OFFSET = INTEGER (Given and Returned)
      }{
         The number of bytes in the current block already interpreted
         as the header plus any earlier FITS files.
      }
      \sstsubsection{
         CURREC = LOGICAL (Given and Returned)
      }{
         If true the current FITS record is to be used immediately, i.e.
         it has alrady been read from tape or disk into \%RECORD.
      }
      \sstsubsection{
         RCPNTR = INTEGER (Given)
      }{
         A pointer to the buffer to hold the current FITS record of 36
         80-character card images.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         The magnetic tape or disk file must already be associated, and
         any log file must be opened.
         [routine\_prior\_requirements]...
      }
   }
}
\sstroutine{
   FTS1\_SDSCF
}{
   Create a SCAR description file from a FITS table-format headers
}{
   \sstdescription{
      This routine searches for the mandatory FITS-Tables-format header
      cards stored in a buffer, and their values are returned, if they
      are present. Should an item be missing or have an unsupported
      value an error is reported, a bad status is set and the routine
      exits. This version supports mandatory descriptors that are not
      in the correct order.

      There are two methods of opening the FACTS description file. The
      first associates the file with a parameter. Unfortunately, FIO
      filename parameters cannot be given dynamic values.  Therefore,
      the name of the table in the header card images is presented, and
      the naming rule for an FACTS description file given.  The user has
      to type in the file name, when prompted for the FACTS file to be
      created for ADC(/SCAR) usage. However, in the alternative,
      automatic mode, the supplied file name is used with the DSCF
      prefix to open the FACTS file without recourse to the parameter
      system. Information in the FITS headers is transferred to this
      description file.  The mandatory FACTS parameters for a sequential
      disk file are written plus EPOCH, VERSION, NRECORDS and AUTHOR
      where these are known. These are followed by FACTS records
      describing the fields in the table, and the ENDFIELD record.
      Finally all the comment lines in the FITS header are copied, in
      order, to the FACTS file.  Blank comment entries are inserted in
      the

      The syntax of the field{\tt '}s format descriptor is checked to see that
      it is standard.
   }
   \sstinvocation{
       CALL FTS1\_SDSCF( NCARD, HEADER, SCARD, PNDSCF, AUTO, TABNAM,
      :                 DSCFNM, NDIM, AXIS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of card images in the header.
      }
      \sstsubsection{
         HEADER( NCARD ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The buffer containing the table-format FITS header.
      }
      \sstsubsection{
         SCARD = INTEGER (Given)
      }{
         The number of the card from where the searches of the header
         will begin.  This is needed because the headers make contain a
         dummy header prior to an extension.
      }
      \sstsubsection{
         PNDSCF = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The parameter name used to create and associate the FACTS
         description file. It is only used when \%AUTO is false.
      }
      \sstsubsection{
         AUTO = LOGICAL (Given)
      }{
         If true the supplied file name is used to open the file
         rather than obtaining the file name via the parameter system.
      }
      \sstsubsection{
         TABNAM = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The name of the table file. It is read if \%AUTO is true and
         written when \%AUTO is false.
      }
      \sstsubsection{
         DSCFNM = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The name of the description file.
      }
      \sstsubsection{
         NDIM = INTEGER (Returned)
      }{
         The number of active dimensions.
      }
      \sstsubsection{
         AXIS( DAT\_\_MXDIM ) = INTEGER (Returned)
      }{
         The dimensions of the data array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The format specifier for each field is validated.
      }
   }
}
\sstroutine{
   FTS1\_SKIP
}{
   Skip over the data of a FITS file
}{
   \sstdescription{
      This routine skips over the data in a FITS file by reading the
      data blocks from the FITS file.  The file may be basic FITS,
      groups or an extension.
   }
   \sstinvocation{
       CALL FTS1\_SKIP ( MEDIUM, MD, SIZE, BPV, GCOUNT, PCOUNT, BLKSIZ,
      :                 ACTSIZ, BUFFER, OFFSET, RECORD, RDISP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         MEDIUM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The medium containing the FITS file.  Currently supported are
         {\tt '}DISK{\tt '} for a disk file, and {\tt '}TAPE{\tt '} for standard magnetic tape.
      }
      \sstsubsection{
         MD     = INTEGER (Given)
      }{
         The tape or file descriptor depending on the value of \%MEDIUM.
      }
      \sstsubsection{
         SIZE   = INTEGER (Given)
      }{
         The number of elements in the data array.
      }
      \sstsubsection{
         BPV    = INTEGER (Given)
      }{
         The number of bytes per data value.
      }
      \sstsubsection{
         GCOUNT = INTEGER (Given)
      }{
         The number of groups in the file.
      }
      \sstsubsection{
         PCOUNT = INTEGER (Given)
      }{
         The number of parameters per group in the file.
      }
      \sstsubsection{
         BLKSIZ = INTEGER (Given)
      }{
         The maximum blocksize and dimension of the tape buffer.
      }
      \sstsubsection{
         ACTSIZ = INTEGER (Given and Returned)
      }{
         The actual block size (a multiple of the FITS record length of
         2880 bytes).  It is only an input argument for
         \%MEDIUM = {\tt '}DISK{\tt '}.
      }
      \sstsubsection{
         BUFFER( BLKSIZ ) = BYTE (Given and Returned)
      }{
         The buffer containing the block of data. This is only read
         when \%OFFSET does not equal \%ACTSIZ, i.e. there are some
         non-header data within it.
      }
      \sstsubsection{
         OFFSET = INTEGER (Given and Returned)
      }{
         The number of bytes in the current block already interpreted.
      }
      \sstsubsection{
         RDISP = INTEGER (Given and Returned)
      }{
         The number of bytes in the current record already interpreted.
         If this displacement is equal to the record length then a new
         FITS record will be obtained.  The displacement will be updated
         during processing of the group parameters and data, and
         therefore can have an arbitrary value between 0 and 2880.  Do
         not modify this argument outside this routine once initialised.
      }
      \sstsubsection{
         RECORD( 2880 ) = BYTE (Given and Returned)
      }{
         The buffer to hold the current FITS record.
      }
      \sstsubsection{
         STATUS  = INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   FTS1\_TREAD
}{
   Obtains a FITS record from a tape file
}{
   \sstdescription{
      This routine reads the byte stream from the FITS tape file
      and extracts a FITS record of 2880 bytes.  The blocksize of
      the tape file is arbitrary save that it be no more than the
      maximum FITS blocksize of 28800.
   }
   \sstinvocation{
       CALL FTS1\_TREAD ( FD, BLKSIZ, ACTSIZ, BUFFER, OFFSET, RECORD,
      :                  STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         The tape descriptor.
      }
      \sstsubsection{
         BLKSIZ = INTEGER (Given)
      }{
         The maximum blocksize and dimension of the tape block.
      }
      \sstsubsection{
         ACTSIZ = INTEGER (Given and Returned)
      }{
         The actual block size.  This need not be a multiple of the
         FITS record length of 2880 bytes.  It must be known on input.
      }
      \sstsubsection{
         BUFFER( ACTSIZ ) = BYTE (Given and Returned)
      }{
         The buffer containing the block of data. This is only read
         when \%OFFSET does not equal \%ACTSIZ, i.e. there are some
         non-header data within it.
      }
      \sstsubsection{
         OFFSET = INTEGER (Given and Returned)
      }{
         The number of bytes in the current block already interpreted.
      }
      \sstsubsection{
         RECORD( 2880 ) = BYTE (Returned)
      }{
         The current FITS record.  Successive calls will read of the
         FITS records in sequence.
      }
      \sstsubsection{
         STATUS  = INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
   \sstdiytopic{
      Prior requirements
   }{
      \sstitemlist{

         \sstitem
         The tape file should already be open and the first block
         read.
      }
   }
   \sstbugs{
      None known.
   }
}
\sstroutine{
   FTS1\_UKEYC
}{
   Writes the value of type CHARACTER to a keyword from a buffer
   of FITS-header card images
}{
   \sstdescription{
      This routine searches a buffer containing the header card images
      from a FITS file for card with keyword \%NAME; and, if found,
      override its original value or with the given character value
      \%VALUE.  The keyword can have a comment string leading by the
      character specified by \%CMTBGN.  In addition comment-type
      keywords---those with keywords COMMENT, HISTORY, and blank,
      or argument COMCAR is .TRUE.---may also have their comments
      revised by \%COMNT (whereupon \%VALUE is ignored).  Selection of
      the desired card (especially important for commentary cards) can
      be controlled by the starting the search at card numbered
      \%STCARD.  The search ends when the next end of a header block,
      marked by the END keyword, is encountered or the buffer is
      exhausted.  If the keyword is present \%THERE is true, otherwise
      it is false.  If the parameter is present more than once in the
      header, only the first occurence will be used.

      The name may be compound to permit writing of hierarchical
      keywords.

      The buffer of FITS header card image should be mapped in the
      {\tt '}UPDATE{\tt '} mode.
   }
   \sstinvocation{
      CALL FTS1\_UKEYC( NCARD, BUFFER, STCARD, NAME, VALUE, CMTBGN,
                       COMNT, COMCAR, THERE, CARD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of card images in the buffer.
      }
      \sstsubsection{
         BUFFER( NCARD ) = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The buffer containing the header card images.
      }
      \sstsubsection{
         STCARD = INTEGER (Given)
      }{
         The number of the card from which to start search.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the keyword to be written a new value.  This may be
         a compound name to handle hierarchical keywords, and it has the
         form keyword1.keyword2.keyword3 etc.  The maximum number of
         keywords per FITS card is 20.  Comparisons are performed in
         uppercase and blanks are removed.  Each keyword must be no
         longer than 8 characters.  The total length must not exceed
         48 characters.  This is to allow for the value, and indentation
         into a blank-keyword card (as hierarchical keywords are not
         standard and so cannot be part of the standard keyword name).
      }
      \sstsubsection{
         VALUE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The value to be used to override the original value of the
         keyword.  It is ignored when the keyword is COMMENT, HISTORY,
         or blank.
      }
      \sstsubsection{
         CMTBGN = CHARACTER $*$ ( 1 ) (Given)
      }{
         The character which indicates the beginning of the comment
         string of to be appended to the keyword.  Normally it is {\tt '}/{\tt '}.
         when it is blank, no comment will be appended to the keyword.
         It is ignored when the keyword is COMMENT, HISTORY, or blank.
      }
      \sstsubsection{
         COMNT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The comment string of the keyword.  It may be truncated at the
         end to put into the space left after writing keyword value for
         non-commentary keywords.
      }
      \sstsubsection{
         COMCAR = LOGICAL (Given)
      }{
         If .TRUE., the supplied card is a comment and thus the value
         and comment delimiter are ignored, and just the keyword and
         comment string are used to generate the header card.
      }
      \sstsubsection{
         THERE = LOGICAL (Returned)
      }{
         If true, the specified keyword is present.
      }
      \sstsubsection{
         CARD = INTEGER (Returned)
      }{
         The number of the last continuation comment card whose contents
         are included in the returned string.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The comments are written from column 32 or higher if the value
         demands more than the customary 20 characters for the value.  A
         comment may be omitted if the value is so long to leave no room.

         \sstitem
         The BUFFER appears out of standard order because when this
         routine is called, BUFFER is expected to be a mapped array.
         This order prevents having to append several \%VAL(length)
         arguments instead of just the one.
      }
   }
}
\sstroutine{
   FTS1\_UKEYx
}{
   Write the value of type DOUBLE PRECISION to the specified keyword from a
   buffer of FITS-header card images
}{
   \sstdescription{
      This routine searches a buffer containing the header card images
      from a FITS file for card with keyword \%NAME; and, if found,
      override its original value with the given value \%VALUE of type
      DOUBLE PRECISION.  The keyword can have a comment string leading by the
      character specified by \%CMTBGN.  The search ends when the next
      end of a header block, marked by the END keyword, is encountered
      or the buffer is exhausted.  If the keyword is present \%THERE is
      true, otherwise it is false.  If the parameter is present more
      than once in the header, only the first occurence will be used.

      The name may be compound to permit writing of hierarchical
      keywords.

      The buffer of FITS header card image should be mapped in the
      {\tt '}UPDATE{\tt '} mode.
   }
   \sstinvocation{
      CALL FTS1\_UKEYx( NCARD, BUFFER, STCARD, NAME, VALUE, CMTBGN,
                       COMNT, THERE, CARD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of card images in the buffer.
      }
      \sstsubsection{
         BUFFER( NCARD ) = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The buffer containing the header card images.
      }
      \sstsubsection{
         STCARD = INTEGER (Given)
      }{
         The number of the card from which to start search.
      }
      \sstsubsection{
         NAME = CHARACTER $*$( $*$ ) (Given)
      }{
         The name of the keyword to be written a new value.  This may be
         a compound name to handle hierarchical keywords, and it has the
         form keyword1.keyword2.keyword3 etc.  The maximum number of
         keywords per FITS card is 20.  Comparisons are performed in
         uppercase and blanks are removed.  Each keyword must be no
         longer than 8 characters.  The total length must not exceed
         48 characters.  This is to allow for the value, and indentation
         into a blank-keyword card (as hierarchical keywords are not
         standard and so cannot be part of the standard keyword name).
      }
      \sstsubsection{
         VALUE = DOUBLE PRECISION (Given)
      }{
         The value to be used to override the original value of the
         keyword.
      }
      \sstsubsection{
         CMTBGN = CHARACTER $*$ ( 1 ) (Given)
      }{
         The character which indicates the beginning of the comment
         string of to be appended to the keyword.  Normally it is {\tt '}/{\tt '}.
         when it is blank, no comment will be appended to the keyword.
      }
      \sstsubsection{
         COMNT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The comment string of the keyword.  It may be truncated at the
         end to put into the space left after writing keyword value.
      }
      \sstsubsection{
         THERE = LOGICAL (Returned)
      }{
         If true, the specified keyword is present.
      }
      \sstsubsection{
         CARD = INTEGER (Returned)
      }{
         The number of the last continuation comment card whose contents
         are included in the returned string.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the data types logical, integer,
         real and double precision: replace {\tt "}x{\tt "} in the routine name by L,
         I, R or D as appropriate.

         \sstitem
         The comments are written from column 32 or higher if the value
         demands more than the customary 20 characters for the value.  A
         comment may be omitted if the value is so long to leave no room.

         \sstitem
         The BUFFER appears out of standard order because when this
         routine is called, BUFFER is expected to be a mapped array.
         This order prevents having to append several \%VAL(length)
         arguments instead of just the one.
      }
   }
}
\sstroutine{
   FTS1\_UKEYx
}{
   Write the value of type INTEGER to the specified keyword from a
   buffer of FITS-header card images
}{
   \sstdescription{
      This routine searches a buffer containing the header card images
      from a FITS file for card with keyword \%NAME; and, if found,
      override its original value with the given value \%VALUE of type
      INTEGER.  The keyword can have a comment string leading by the
      character specified by \%CMTBGN.  The search ends when the next
      end of a header block, marked by the END keyword, is encountered
      or the buffer is exhausted.  If the keyword is present \%THERE is
      true, otherwise it is false.  If the parameter is present more
      than once in the header, only the first occurence will be used.

      The name may be compound to permit writing of hierarchical
      keywords.

      The buffer of FITS header card image should be mapped in the
      {\tt '}UPDATE{\tt '} mode.
   }
   \sstinvocation{
      CALL FTS1\_UKEYx( NCARD, BUFFER, STCARD, NAME, VALUE, CMTBGN,
                       COMNT, THERE, CARD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of card images in the buffer.
      }
      \sstsubsection{
         BUFFER( NCARD ) = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The buffer containing the header card images.
      }
      \sstsubsection{
         STCARD = INTEGER (Given)
      }{
         The number of the card from which to start search.
      }
      \sstsubsection{
         NAME = CHARACTER $*$( $*$ ) (Given)
      }{
         The name of the keyword to be written a new value.  This may be
         a compound name to handle hierarchical keywords, and it has the
         form keyword1.keyword2.keyword3 etc.  The maximum number of
         keywords per FITS card is 20.  Comparisons are performed in
         uppercase and blanks are removed.  Each keyword must be no
         longer than 8 characters.  The total length must not exceed
         48 characters.  This is to allow for the value, and indentation
         into a blank-keyword card (as hierarchical keywords are not
         standard and so cannot be part of the standard keyword name).
      }
      \sstsubsection{
         VALUE = INTEGER (Given)
      }{
         The value to be used to override the original value of the
         keyword.
      }
      \sstsubsection{
         CMTBGN = CHARACTER $*$ ( 1 ) (Given)
      }{
         The character which indicates the beginning of the comment
         string of to be appended to the keyword.  Normally it is {\tt '}/{\tt '}.
         when it is blank, no comment will be appended to the keyword.
      }
      \sstsubsection{
         COMNT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The comment string of the keyword.  It may be truncated at the
         end to put into the space left after writing keyword value.
      }
      \sstsubsection{
         THERE = LOGICAL (Returned)
      }{
         If true, the specified keyword is present.
      }
      \sstsubsection{
         CARD = INTEGER (Returned)
      }{
         The number of the last continuation comment card whose contents
         are included in the returned string.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the data types logical, integer,
         real and double precision: replace {\tt "}x{\tt "} in the routine name by L,
         I, R or D as appropriate.

         \sstitem
         The comments are written from column 32 or higher if the value
         demands more than the customary 20 characters for the value.  A
         comment may be omitted if the value is so long to leave no room.

         \sstitem
         The BUFFER appears out of standard order because when this
         routine is called, BUFFER is expected to be a mapped array.
         This order prevents having to append several \%VAL(length)
         arguments instead of just the one.
      }
   }
}
\sstroutine{
   FTS1\_UKEYx
}{
   Write the value of type LOGICAL to the specified keyword from a
   buffer of FITS-header card images
}{
   \sstdescription{
      This routine searches a buffer containing the header card images
      from a FITS file for card with keyword \%NAME; and, if found,
      override its original value with the given value \%VALUE of type
      LOGICAL.  The keyword can have a comment string leading by the
      character specified by \%CMTBGN.  The search ends when the next
      end of a header block, marked by the END keyword, is encountered
      or the buffer is exhausted.  If the keyword is present \%THERE is
      true, otherwise it is false.  If the parameter is present more
      than once in the header, only the first occurence will be used.

      The name may be compound to permit writing of hierarchical
      keywords.

      The buffer of FITS header card image should be mapped in the
      {\tt '}UPDATE{\tt '} mode.
   }
   \sstinvocation{
      CALL FTS1\_UKEYx( NCARD, BUFFER, STCARD, NAME, VALUE, CMTBGN,
                       COMNT, THERE, CARD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of card images in the buffer.
      }
      \sstsubsection{
         BUFFER( NCARD ) = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The buffer containing the header card images.
      }
      \sstsubsection{
         STCARD = INTEGER (Given)
      }{
         The number of the card from which to start search.
      }
      \sstsubsection{
         NAME = CHARACTER $*$( $*$ ) (Given)
      }{
         The name of the keyword to be written a new value.  This may be
         a compound name to handle hierarchical keywords, and it has the
         form keyword1.keyword2.keyword3 etc.  The maximum number of
         keywords per FITS card is 20.  Comparisons are performed in
         uppercase and blanks are removed.  Each keyword must be no
         longer than 8 characters.  The total length must not exceed
         48 characters.  This is to allow for the value, and indentation
         into a blank-keyword card (as hierarchical keywords are not
         standard and so cannot be part of the standard keyword name).
      }
      \sstsubsection{
         VALUE = LOGICAL (Given)
      }{
         The value to be used to override the original value of the
         keyword.
      }
      \sstsubsection{
         CMTBGN = CHARACTER $*$ ( 1 ) (Given)
      }{
         The character which indicates the beginning of the comment
         string of to be appended to the keyword.  Normally it is {\tt '}/{\tt '}.
         when it is blank, no comment will be appended to the keyword.
      }
      \sstsubsection{
         COMNT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The comment string of the keyword.  It may be truncated at the
         end to put into the space left after writing keyword value.
      }
      \sstsubsection{
         THERE = LOGICAL (Returned)
      }{
         If true, the specified keyword is present.
      }
      \sstsubsection{
         CARD = INTEGER (Returned)
      }{
         The number of the last continuation comment card whose contents
         are included in the returned string.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the data types logical, integer,
         real and double precision: replace {\tt "}x{\tt "} in the routine name by L,
         I, R or D as appropriate.

         \sstitem
         The comments are written from column 32 or higher if the value
         demands more than the customary 20 characters for the value.  A
         comment may be omitted if the value is so long to leave no room.

         \sstitem
         The BUFFER appears out of standard order because when this
         routine is called, BUFFER is expected to be a mapped array.
         This order prevents having to append several \%VAL(length)
         arguments instead of just the one.
      }
   }
}
\sstroutine{
   FTS1\_UKEYx
}{
   Write the value of type REAL to the specified keyword from a
   buffer of FITS-header card images
}{
   \sstdescription{
      This routine searches a buffer containing the header card images
      from a FITS file for card with keyword \%NAME; and, if found,
      override its original value with the given value \%VALUE of type
      REAL.  The keyword can have a comment string leading by the
      character specified by \%CMTBGN.  The search ends when the next
      end of a header block, marked by the END keyword, is encountered
      or the buffer is exhausted.  If the keyword is present \%THERE is
      true, otherwise it is false.  If the parameter is present more
      than once in the header, only the first occurence will be used.

      The name may be compound to permit writing of hierarchical
      keywords.

      The buffer of FITS header card image should be mapped in the
      {\tt '}UPDATE{\tt '} mode.
   }
   \sstinvocation{
      CALL FTS1\_UKEYx( NCARD, BUFFER, STCARD, NAME, VALUE, CMTBGN,
                       COMNT, THERE, CARD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCARD = INTEGER (Given)
      }{
         The number of card images in the buffer.
      }
      \sstsubsection{
         BUFFER( NCARD ) = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The buffer containing the header card images.
      }
      \sstsubsection{
         STCARD = INTEGER (Given)
      }{
         The number of the card from which to start search.
      }
      \sstsubsection{
         NAME = CHARACTER $*$( $*$ ) (Given)
      }{
         The name of the keyword to be written a new value.  This may be
         a compound name to handle hierarchical keywords, and it has the
         form keyword1.keyword2.keyword3 etc.  The maximum number of
         keywords per FITS card is 20.  Comparisons are performed in
         uppercase and blanks are removed.  Each keyword must be no
         longer than 8 characters.  The total length must not exceed
         48 characters.  This is to allow for the value, and indentation
         into a blank-keyword card (as hierarchical keywords are not
         standard and so cannot be part of the standard keyword name).
      }
      \sstsubsection{
         VALUE = REAL (Given)
      }{
         The value to be used to override the original value of the
         keyword.
      }
      \sstsubsection{
         CMTBGN = CHARACTER $*$ ( 1 ) (Given)
      }{
         The character which indicates the beginning of the comment
         string of to be appended to the keyword.  Normally it is {\tt '}/{\tt '}.
         when it is blank, no comment will be appended to the keyword.
      }
      \sstsubsection{
         COMNT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The comment string of the keyword.  It may be truncated at the
         end to put into the space left after writing keyword value.
      }
      \sstsubsection{
         THERE = LOGICAL (Returned)
      }{
         If true, the specified keyword is present.
      }
      \sstsubsection{
         CARD = INTEGER (Returned)
      }{
         The number of the last continuation comment card whose contents
         are included in the returned string.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the data types logical, integer,
         real and double precision: replace {\tt "}x{\tt "} in the routine name by L,
         I, R or D as appropriate.

         \sstitem
         The comments are written from column 32 or higher if the value
         demands more than the customary 20 characters for the value.  A
         comment may be omitted if the value is so long to leave no room.

         \sstitem
         The BUFFER appears out of standard order because when this
         routine is called, BUFFER is expected to be a mapped array.
         This order prevents having to append several \%VAL(length)
         arguments instead of just the one.
      }
   }
}
\sstroutine{
   FTS1\_VHEAD
}{
   Validates a FITS header card and reconstitutes to the standard
}{
   \sstdescription{
      This routines takes a buffer containing text similar to a FITS
      header card and attempts to produce a correctly formatted FITS
      header card.  The validation process performs the following
      checks the input buffer:
        a) the length of the input buffer is no more than 80
        characters, otherwise it is truncated;
        b) the keyword only contains uppercase Latin alphabetic
        characters, numbers, underscore, and hyphen (this is a fatal
        error except for lowercase letters);
        c) value cards have an equals sign in column 9 and a space in
        column 10;
        d) quotes enclose character values;
        e) single quotes inside string values are doubled;
        f) character values are left justified to column 11 (retaining
        leading blanks) and contain at least 8 characters (padding with
        spaces if necessary);
        g) non-character values are right justified to column 30 for
        mandatory keywords, or when the fixed format is requested
        (unless the value is double-precision requiring more than 20
        digits);
        h) the comment delimiter is in column 32 for the mandatory
        keywords or when the fixed format is requested for non-character
        values, or is at least two characters following the value
        otherwise;
        i) an equals sign in column 9 of a commentary card is replaced
        by a space, issuing a warning message at normal reporting
        level; and
        j) comments begin at least two columns after the end of the
        comment delimiter.

      Some non-fatal errors---a), b), c), d), and i)---produce warning
      messages at message level MSG\_\_NORM.
   }
   \sstinvocation{
      CALL FTS1\_VHEAD( BUFFER, FIXED, CARD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BUFFER = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The FITS header {\tt '}card{\tt '} to be validated.
      }
      \sstsubsection{
         FIXED = LOGICAL (Given)
      }{
         If this is .TRUE., all values use the FITS fixed format with
         left-justified character strings starting two columns after
      }
      \sstsubsection{
         CARD = CHARACTER $*$ ( 80 ) (Returned)
      }{
         The validated FITS header {\tt '}card{\tt '}.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_WCSAX
}{
   Re-create AXIS structures from a WCS component FrameSet
}{
   \sstdescription{
      This routine creates NDF Axis structures from an AXIS Frame in the
      supplied FrameSet. It looks for AXIS and PIXEL Frames in the
      supplied FrameSet. If either of these Frames is not found, it does
      nothing. Otherwise, it attempts to create AXIS structures in the NDF
      from the AXIS Frame in the FrameSet. The AXIS Centre, Label and Unit
      components are set.
   }
   \sstinvocation{
      CALL FTS1\_WCSAX( INDF, FS, NDIM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         The NDF identifier.
      }
      \sstsubsection{
         FS = INTEGER (Given)
      }{
         An AST pointer for a FrameSet.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of axes in the NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_WCSDF
}{
   See if two FrameSets are different after being written to a
   FitsChan
}{
   \sstdescription{
      The returned function value indicates if the two FrameSets are
      inconsistent with each other. The two supplied FrameSets are written
      to two FitsChans, using the specified encoding. All keyword values
      in the two FitsChans are then compared. If any keyword has a
      significantly different value in the two FitsChans, then the
      FrameSets are inconsistent, and a .TRUE value is returned. Otherwise,
      .FALSE. is returned.
   }
   \sstinvocation{
      RETURN = FTS1\_WCSDF( ENCOD, FS1, FS2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         ENCOD = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The encoding scheme to use when converting the supplied
         FrameSets into FITS header cards.
      }
      \sstsubsection{
         FS1 = INTEGER (Given)
      }{
         An AST pointer to the first FrameSet.
      }
      \sstsubsection{
         FS2 = INTEGER (Given)
      }{
         An AST pointer to the second FrameSet.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A value of .TRUE. is returned if an error has already occurred,
         or if this function should fail for any reason.
      }
   }
   \sstdiytopic{
      Function Value
   }{
      FTS1\_WCSDF = LOGICAL (Returned)
         .TRUE. if the supplied FrameSets are inconsistent, and .FALSE.
         otherwise.
   }
}
\sstroutine{
   FTS1\_WCSIM
}{
   Imports WCS information from the supplied FitsChan into the supplied
   NDF
}{
   \sstdescription{
      An attempt is made to read an AST FrameSet (see SUN/210) from the
      supplied FitsChan. If succesful, it is added into the FrameSet
      representing the NDF{\tt '}s WCS component. This is done by connecting
      the base Frames of the two FrameSets with a UnitMap (on the
      assumption that they are equivalent). The modified FrameSet is
      then stored back in the NDF (the NDF library will automatically
      remove any PIXEL, GRID and AXIS Frames from the FrameSet as these
      are generated afresh each time NDF\_GTWCS is called).

      The supplied FitsChan may contain more than one description (or
      {\tt "}encoding{\tt "}) of the FrameSet to be added to the NDF, each
      encoding using a different set of header cards. These encodings
      may not all be consistent with each other. For instance, if a
      Starlink application stores a FrameSet twice in a FITS header using
      FITS-WCS and AST native encodings, an IRAF application may then
      modify the FITS-WCS encoding without making equivalent modifications
      to the native encoding. In this case, we should use the FITS-WCS
      encoding in preference to the native encoding when reconstructing
      the NDFs WCS component. On the other hand, if the two encodings were
      still consistent, it would be preferable to use the native encoding
      since the FITS-WCS encoding may not give a complete description of the
      original FrameSet.

      The choice of encoding has several stages:

      o  If the caller has supplied a list of preferred encodings in the
      ENCODS argument, then the first available encoding in this list is
      used.
      o  If no preferred encodings are supplied, then a check is made to
      see if a native encoding is available. If there is no native encoding,
      then the default encoding supplied by AST is used. This will be a
      non-native encoding selected on the basis of the header cards available
      in the FitsChan.
      o  If a native encoding is available, and is the only available
      encoding, then it is used.
      o  If both native and non-native encodings are available, then the
      first non-native encoding to be found which is inconsistent with the
      native encoding is used. If all encodings are consistent, then the
      native encoding is used. The first inconsistent encoding is used on
      the assumption that software which modifies the native encoding
      (i.e. mainly Starlink software) will also modify the non-native
      encodings so that they remain consistent. Foreign software however
      (i.e. non-AST software) will probably not bother to modify the native
      encoding when the non-native encoding is modified.
   }
   \sstinvocation{
      CALL FTS1\_WCSIM( FC, INDF, NENCOD, ENCODS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FC = INTEGER (Given)
      }{
         An AST pointer to the FitsChan in which to store the NDF{\tt '}s WCS
         information.
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         The NDF identifier.
      }
      \sstsubsection{
         NENCOD = INTEGER (Given)
      }{
         The number of encodings supplied in ENCODS.
      }
      \sstsubsection{
         ENCODS( NENCOD ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The preferred encodings to use, in order of preference (most
         preferable first). Ignored if NENCOD is zero.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_WCSUT
}{
   Remove the spurious copy of the AXIS Frame which is left in
   WCS component when using non-Native encodings
}{
   \sstdescription{
      This routine removes the Current Frame in the WCS component of an
      NDF if no value has been set for its Domain attribute, and if it
      corresponds closely to the AXIS Frame (i.e. if the Mapping from the
      Current Frame to the AXIS Frame is nearly a UnitMap).

      When using non-Native encoding, the AXIS Frame written by NDF2FITS
      will not have any associated Domain value, and so will not be
      recognised by the NDF library as an AXIS Frame when it is read back
      in by FITS2NDF. The Frame will therefore be left in the WCS
      component of the NDF, even though it is in reality a copy of the AXIS
      Frame. This routine removes such Frames.
   }
   \sstinvocation{
      CALL FTS1\_WCSUT( INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         The NDF identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_WKEYC
}{
   Writes a FITS-header card for a CHARACTER value or a comment
}{
   \sstdescription{
      This routine writes a FITS-header card using the supplied keyword,
      value, comment, and comment delimiter.  The card is either a
      character string value, or a comment card.  The latter occurs when
      the keyword is blank, HISTORY or COMMENT, or the COMCAR argument
      is .TRUE.; in this case both the supplied value and comment
      delimiter are ignored.  The name may be compound to permit
      writing of hierarchical keywords.
   }
   \sstinvocation{
      CALL FTS1\_WKEYC( NAME, CMTBGN, VALUE, COMNT, COMCAR, HEADER,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the keyword to be written.  This may be a compound
         name to handle hierarchical keywords, and it has the form
         keyword1.keyword2.keyword3 etc.  The maximum number of
         keywords per FITS card is 20.  The value is converted to
         uppercase and blanks are removed before being used.  Each
         keyword must be no longer than 8 characters.  The total length
         must not exceed 48 characters.  This is to allow for the
         value, and indentation into a blank-keyword card (as
         hierarchical keywords are not standard and so cannot be part
         of the standard keyword name).
      }
      \sstsubsection{
         VALUE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The value of the keyword.  It is ignored when the keyword is
         COMMENT, HISTORY, or blank, or COMCAR = .TRUE..
      }
      \sstsubsection{
         CMTBGN = CHARACTER $*$ ( 1 ) (Given)
      }{
         The character which indicates the beginning of the comment
         string of to be appended to the keyword.  Normally it is {\tt '}/{\tt '}.
         when it is blank, no comment will be appended to the keyword.
         It is ignored when the keyword is COMMENT, HISTORY, or blank,
         or COMCAR = .TRUE..
      }
      \sstsubsection{
         COMNT = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The comment string of the keyword.  It may be truncated at the
         end to put into the space left after writing keyword value for
         non-commentary keywords.
      }
      \sstsubsection{
         COMCAR = LOGICAL (Given)
      }{
         If .TRUE., the supplied card is a comment and thus the value
         and comment delimiter are ignored, and just the keyword and
         comment string are used to generate the header card.
      }
      \sstsubsection{
         HEADER = CHARACTER $*$ ( 80 ) (Returned)
      }{
         The created FITS-header card.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   FTS1\_WKEYx
}{
   Writes a FITS-header card for a value of type DOUBLE PRECISION
}{
   \sstdescription{
      This routine writes a FITS-header card using the supplied
      keyword, value, comment, and comment delimiter.  The value has
      data type DOUBLE PRECISION.  The name may be compound to permit writing
      of hierarchical keywords.
   }
   \sstinvocation{
      CALL FTS1\_WKEYx( NAME, CMTBGN, VALUE, COMNT, HEADER, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NAME = CHARACTER $*$( $*$ ) (Given)
      }{
         The name of the keyword to be written.  This may be a compound
         name to handle hierarchical keywords, and it has the form
         keyword1.keyword2.keyword3 etc.  The maximum number of
         keywords per FITS card is 20.  The value is converted to
         uppercase and blanks are removed before being used.  Each
         keyword must be no longer than 8 characters.  The total length
         must not exceed 48 characters.  This is to allow for the
         value, and indentation into a blank-keyword card (as
         hierarchical keywords are not standard and so cannot be part
         of the standard keyword name).
      }
      \sstsubsection{
         VALUE = DOUBLE PRECISION (Given)
      }{
         The value of the keyword.
      }
      \sstsubsection{
         CMTBGN = CHARACTER $*$ ( 1 ) (Given)
      }{
         The character which indicates the beginning of the comment
         string of to be appended to the keyword.  Normally it is {\tt '}/{\tt '}.
         when it is blank, no comment will be appended to the keyword.
      }
      \sstsubsection{
         COMNT = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The comment string of the keyword.  It may be truncated at the
         end to put into the space left after writing keyword value.
      }
      \sstsubsection{
         HEADER = CHARACTER $*$ ( 80 ) (Returned)
      }{
         The created FITS-header card.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the data types logical, integer,
         real and double precision: replace {\tt "}x{\tt "} in the routine name by L,
         I, R or D as appropriate.

         \sstitem
         The comments are written from column 32 or higher if the value
         demands more than the customary 20 characters for the value.  A
         comment may be omitted if the value is so long to leave no room.
      }
   }
}
\sstroutine{
   FTS1\_WKEYx
}{
   Writes a FITS-header card for a value of type INTEGER
}{
   \sstdescription{
      This routine writes a FITS-header card using the supplied
      keyword, value, comment, and comment delimiter.  The value has
      data type INTEGER.  The name may be compound to permit writing
      of hierarchical keywords.
   }
   \sstinvocation{
      CALL FTS1\_WKEYx( NAME, CMTBGN, VALUE, COMNT, HEADER, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NAME = CHARACTER $*$( $*$ ) (Given)
      }{
         The name of the keyword to be written.  This may be a compound
         name to handle hierarchical keywords, and it has the form
         keyword1.keyword2.keyword3 etc.  The maximum number of
         keywords per FITS card is 20.  The value is converted to
         uppercase and blanks are removed before being used.  Each
         keyword must be no longer than 8 characters.  The total length
         must not exceed 48 characters.  This is to allow for the
         value, and indentation into a blank-keyword card (as
         hierarchical keywords are not standard and so cannot be part
         of the standard keyword name).
      }
      \sstsubsection{
         VALUE = INTEGER (Given)
      }{
         The value of the keyword.
      }
      \sstsubsection{
         CMTBGN = CHARACTER $*$ ( 1 ) (Given)
      }{
         The character which indicates the beginning of the comment
         string of to be appended to the keyword.  Normally it is {\tt '}/{\tt '}.
         when it is blank, no comment will be appended to the keyword.
      }
      \sstsubsection{
         COMNT = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The comment string of the keyword.  It may be truncated at the
         end to put into the space left after writing keyword value.
      }
      \sstsubsection{
         HEADER = CHARACTER $*$ ( 80 ) (Returned)
      }{
         The created FITS-header card.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the data types logical, integer,
         real and double precision: replace {\tt "}x{\tt "} in the routine name by L,
         I, R or D as appropriate.

         \sstitem
         The comments are written from column 32 or higher if the value
         demands more than the customary 20 characters for the value.  A
         comment may be omitted if the value is so long to leave no room.
      }
   }
}
\sstroutine{
   FTS1\_WKEYx
}{
   Writes a FITS-header card for a value of type LOGICAL
}{
   \sstdescription{
      This routine writes a FITS-header card using the supplied
      keyword, value, comment, and comment delimiter.  The value has
      data type LOGICAL.  The name may be compound to permit writing
      of hierarchical keywords.
   }
   \sstinvocation{
      CALL FTS1\_WKEYx( NAME, CMTBGN, VALUE, COMNT, HEADER, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NAME = CHARACTER $*$( $*$ ) (Given)
      }{
         The name of the keyword to be written.  This may be a compound
         name to handle hierarchical keywords, and it has the form
         keyword1.keyword2.keyword3 etc.  The maximum number of
         keywords per FITS card is 20.  The value is converted to
         uppercase and blanks are removed before being used.  Each
         keyword must be no longer than 8 characters.  The total length
         must not exceed 48 characters.  This is to allow for the
         value, and indentation into a blank-keyword card (as
         hierarchical keywords are not standard and so cannot be part
         of the standard keyword name).
      }
      \sstsubsection{
         VALUE = LOGICAL (Given)
      }{
         The value of the keyword.
      }
      \sstsubsection{
         CMTBGN = CHARACTER $*$ ( 1 ) (Given)
      }{
         The character which indicates the beginning of the comment
         string of to be appended to the keyword.  Normally it is {\tt '}/{\tt '}.
         when it is blank, no comment will be appended to the keyword.
      }
      \sstsubsection{
         COMNT = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The comment string of the keyword.  It may be truncated at the
         end to put into the space left after writing keyword value.
      }
      \sstsubsection{
         HEADER = CHARACTER $*$ ( 80 ) (Returned)
      }{
         The created FITS-header card.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the data types logical, integer,
         real and double precision: replace {\tt "}x{\tt "} in the routine name by L,
         I, R or D as appropriate.

         \sstitem
         The comments are written from column 32 or higher if the value
         demands more than the customary 20 characters for the value.  A
         comment may be omitted if the value is so long to leave no room.
      }
   }
}
\sstroutine{
   FTS1\_WKEYx
}{
   Writes a FITS-header card for a value of type REAL
}{
   \sstdescription{
      This routine writes a FITS-header card using the supplied
      keyword, value, comment, and comment delimiter.  The value has
      data type REAL.  The name may be compound to permit writing
      of hierarchical keywords.
   }
   \sstinvocation{
      CALL FTS1\_WKEYx( NAME, CMTBGN, VALUE, COMNT, HEADER, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NAME = CHARACTER $*$( $*$ ) (Given)
      }{
         The name of the keyword to be written.  This may be a compound
         name to handle hierarchical keywords, and it has the form
         keyword1.keyword2.keyword3 etc.  The maximum number of
         keywords per FITS card is 20.  The value is converted to
         uppercase and blanks are removed before being used.  Each
         keyword must be no longer than 8 characters.  The total length
         must not exceed 48 characters.  This is to allow for the
         value, and indentation into a blank-keyword card (as
         hierarchical keywords are not standard and so cannot be part
         of the standard keyword name).
      }
      \sstsubsection{
         VALUE = REAL (Given)
      }{
         The value of the keyword.
      }
      \sstsubsection{
         CMTBGN = CHARACTER $*$ ( 1 ) (Given)
      }{
         The character which indicates the beginning of the comment
         string of to be appended to the keyword.  Normally it is {\tt '}/{\tt '}.
         when it is blank, no comment will be appended to the keyword.
      }
      \sstsubsection{
         COMNT = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The comment string of the keyword.  It may be truncated at the
         end to put into the space left after writing keyword value.
      }
      \sstsubsection{
         HEADER = CHARACTER $*$ ( 80 ) (Returned)
      }{
         The created FITS-header card.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the data types logical, integer,
         real and double precision: replace {\tt "}x{\tt "} in the routine name by L,
         I, R or D as appropriate.

         \sstitem
         The comments are written from column 32 or higher if the value
         demands more than the customary 20 characters for the value.  A
         comment may be omitted if the value is so long to leave no room.
      }
   }
}
\sstroutine{
   IRA\_ANNUL
}{
   Annul an IRA identifier
}{
   \sstdescription{
      This routine should be called when access to the astrometry
      information associated with an IRA identifier is no longer
      needed. It releases the resources used to store the astrometry
      information.

      This routine attempts to execute even if STATUS is bad on entry.
      However, in this case no error report will be produced if this
      routine subsequently fails.
   }
   \sstinvocation{
      CALL IRA\_ANNUL( IDA, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IDA = INTEGER ( Given )
      }{
         The IRA identifier to be annulled.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_CLOSE
}{
   Close down the IRA astrometry package
}{
   \sstdescription{
      This routine should be called once IRA facilities are no longer
      needed. It annulls any currently valid IRA identifiers, releasing
      any resources reserved by them. Once this routine has been called,
      any further use of IRA must be preceeded with a call to IRA\_INIT.

      This routine attempts to execute even if STATUS is set to a bad
      value on entry.
   }
   \sstinvocation{
      CALL IRA\_CLOSE( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_CONVT
}{
   Convert sky coordinates from one system to another
}{
   \sstdescription{
      This routine use SLALIB to convert a list of sky coordinates from
      one supported Sky Coordinate System (SCS) to any other supported
      system.  It is assumed that the observations were made at the
      date given by the Julian epoch supplied.  If the input and output
      coordinates are referred to different mean equinox, then
      precession is applied to convert the input coordinates to the
      output system.  No correction for nutation is included. If any of
      the input coordinate values are equal to the Starlink {\tt "}BAD{\tt "} value
      (VAL\_\_BADD) then the corresponding output values will both be set
      to the bad value.
   }
   \sstinvocation{
      CALL IRA\_CONVT( NVAL, AIN, BIN, SCSIN, SCSOUT, EPOCH, AOUT, BOUT,
                      STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NVAL = INTEGER (Given)
      }{
         The number of sky coordinate pairs to be converted.
      }
      \sstsubsection{
         AIN( NVAL ) = DOUBLE PRECISION (Given)
      }{
         A list of sky longitude coordinate values to be converted, in
         radians.
      }
      \sstsubsection{
         BIN( NVAL ) = DOUBLE PRECISION (Given)
      }{
         A list of sky latitude coordinate values to be converted, in
         radians.
      }
      \sstsubsection{
         SCSIN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A string holding the name of the sky coordinate system of the
         input list. Any unambiguous abbreviation will do. An optional
         equinox specifier may be included in the name (see ID2 section
         {\tt "}Sky Coordinates{\tt "}).
      }
      \sstsubsection{
         SCSOUT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A string holding the name of the sky coordinate system
         required for the output list. Any unambiguous abbreviation
         will do.An optional equinox specifier may be included in the
         name.
      }
      \sstsubsection{
         EPOCH = DOUBLE PRECISION (Given)
      }{
         The Julian epoch at which the observations were made. When
         dealing with IRAS data, the global constant IRA\_\_IRJEP should
         be specified. This constant is a Julian epoch suitable for all
         IRAS data.
      }
      \sstsubsection{
         AOUT( NVAL ) = DOUBLE PRECISION (Returned)
      }{
         The list of converted sky longitude coordinate values, in
         radians.
      }
      \sstsubsection{
         BOUT( NVAL ) = DOUBLE PRECISION (Returned)
      }{
         The list of converted sky latitude coordinate values, in
         radians.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_CREAT
}{
   Create an identifier for specified astrometry information
}{
   \sstdescription{
      The supplied astrometry information is stored in internal common
      blocks and an {\tt "}IRA identifier{\tt "} is returned which can be passed to
      other IRA routines to refer to the stored astrometry information.
      This identifier should be annulled when it is no longer required
      by calling IRA\_ANNUL. In addition, a call to IRA\_EXPRT may
      optionally be made to store the astrometry information in an NDF
      (see argument INDF).

      The projection used is specified by the argument PROJ, and must
      be one of the supported projection types (see routine IRA\_IPROJ).
      For more information on the available projections, see the ID/2
      appendix {\tt "}Projection Equations{\tt "}. Each projection requires the
      values for several parameters to be supplied in argument P. These
      parameters have the same meaning for all projections (for further
      details see ID/2 appendix {\tt "}Projection Equations{\tt "}):

      P(1): The longitude (in the Sky Coordinate System specified by
            argument SCS) of the reference point in radians.

      P(2): The latitude (in the Sky Coordinate System specified by
            argument SCS) of the reference point in radians.

      P(3): The first image coordinate (i.e. X value) of the reference
            point. Image coordinates are fractional values in which the
            centre of the pixel (1,1) has coordinates (0.5,0.5).

      P(4): The second image coordinate (i.e. Y value) of the
            reference point.

      P(5): The size along the X image axis, of a pixel centred at the
            reference point, in radians. Actual pixel size will vary
            over the image due to the distorting effect of the
            projection. The absolute value is used.

      P(6): The size along the Y image axis, of a pixel centred at the
            reference point, in radians. The absolute value is used.

      P(7): The position angle of the Y image axis, in radians. That is,
            the angle from north to the positive direction of the Y
            image axis, measured positive in the same sense as
            rotation from north to east. (Here {\tt "}north{\tt "} and {\tt "}east{\tt "} are
            defined by the value of SCS). The X image axis is 90 degrees
            west of the Y axis.

      P(8): An angle through which the celestial sphere is to be rotated
            before doing the projection. The axis of the rotation is a
            radius passing through the reference point. The rotation is
            in an anti-clockwise sense when looking from the reference
            point towards the centre of the celestial sphere. The value
            should be in radians. Changing this angle does not change
            the orientation of the image axes with respect to north
            (which is set by p(7)).
   }
   \sstinvocation{
      CALL IRA\_CREAT( PROJ, NP, P, SCS, EPOCH, INDF, IDA, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PROJ = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The projection type (see routine IRA\_IPROJ for a list of
         currently recognised values). Any unambiguous abbreviation can
         be given.
      }
      \sstsubsection{
         NP = INTEGER (Given)
      }{
         The size of array P.
      }
      \sstsubsection{
         P( NP ) = DOUBLE PRECISION (Given)
      }{
         The parameter values required by the projection.
      }
      \sstsubsection{
         SCS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the Sky Coordinate System which the projection is
         to create, or an unambiguous abbreviation. See routine IRA\_ISCS
         for a list of currently recognised values.  See ID2 section
         {\tt "}Sky Coordinates{\tt "}) for general information of Sky Coordinate
         Systems.
      }
      \sstsubsection{
         EPOCH = DOUBLE PRECISION (Given)
      }{
         The Julian epoch at which the observations were made. A single
         mean epoch is sufficient to describe all IRAS observations.
         Such a value is contained in the IRA constant IRA\_\_IRJEP.
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         The identifier for the NDF in which the astrometry information
         is to be stored. If an invalid NDF identifier is given (eg the
         value NDF\_\_NOID) then the astrometry information is not stored
         in an NDF (but IDA can still be used to refer to the astrometry
         information).
      }
      \sstsubsection{
         IDA = INTEGER (Returned)
      }{
         The returned IRA identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_CTOD1
}{
   Converts a single formatted sky coordinate value into a double
   precision value
}{
   \sstdescription{
      The input string is presumed to hold a sky coordinate value in
      character form. If NC is 1, the string is interpreted as a
      longitude value. If NC is 2, the string is interpreted as a
      latitude value.  This routine reads the string and produces a
      double precision value holding the coordinate value in radians.
      The value is not shifted into the first order range (eg if an
      angular value equivalent to 3$*$PI is given, the value 3$*$PI will be
      returned, not 1$*$PI). If the input string is blank the output
      value is set to the Starlink {\tt "}BAD{\tt "} value (VAL\_\_BADD). Refer to
      IRA\_CTOD for details of the allowed format for the input string.
   }
   \sstinvocation{
      CALL IRA\_CTOD1( TEXT, SCS, NC, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TEXT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The string containing the formatted version of the sky
         coordinate value. If this string is blank, VALUE is returned
         with the {\tt "}BAD{\tt "} value (VAL\_\_BADD), but no error report is
         made.
      }
      \sstsubsection{
         SCS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The sky coordinate system (see ID2 section {\tt "}Sky Coordinates{\tt "}).
         Any unambiguous abbreviation will do.
      }
      \sstsubsection{
         NC = INTEGER (Given)
      }{
         Determines which sky coordinate is to be used. If a value of 1
         is supplied, the string is interpreted as a longitude value
         (eg RA if an equatorial system is being used). If a value of 2
         is supplied, the string is interpreted as a latitude value.
         Any other value results in an error being reported.
      }
      \sstsubsection{
         VALUE = DOUBLE PRECISION (Returned)
      }{
         The numerical value of the sky coordinate represented by the
         string in TEXT. The value is in radians.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_CTOD
}{
   Converts formatted sky coordinate values into double precision
   values
}{
   \sstdescription{
      The input strings are presumed to hold sky coordinate values in
      character form.  This routine reads the strings and produces
      double precision values holding the coordinate values, in
      radians.

      Each input string can consist of a set of up to three {\tt "}fields{\tt "}.
      Each field starts with a numeric value (which can have a
      fractional part) terminated by a character string. This character
      string consists of an optional single character, called the
      terminator character, followed by an arbitrary number of spaces
      The terminator character (if present) must be one of the letters
      h,d,m,s or r.  An h terminator indicates that the field value is
      in units of hours. A d terminator indicates that the field value
      is in units of degrees.  An r terminator indicates that the field
      value is in units of radians.  An m terminator indicates that the
      field value is in units of minutes.  An s terminator indicates
      that the field value is in units of seconds.  The interpretation
      of minutes and seconds depends on whether the value is a time
      value or an angle value. The longitude value for equatorial sky
      coordinate systems (RA) is expected to be a measure of time, all
      other coordinate values are expected to be a measure of angle.
      These defaults are overriden if the first field is a {\tt "}degrees{\tt "},
      {\tt "}hours{\tt "} or {\tt "}radians{\tt "} field (as indicated by the presence of a d,
      h or r terminator character).  The interpretation of fields with
      no terminator character depends on which field is being
      considered. If the first field has no terminator, it is assumed
      to be either a degrees or hours field.  If the second or third
      field has no terminator, it is assumed to be a seconds field if
      the previous field was a minutes field, and a minutes field if
      the previous value was an hours or degrees field.

      In addition, an input string may contain a single field with no
      terminator character in an {\tt "}encoded{\tt "} form. {\tt "}Encoded{\tt "} fields are
      identified by the fact that the field contains 5 or more digits
      to the left of the decimal point (including leading zeros if
      necessary).  These fields are decoded into hours or degrees as
      follows: Any fractional part is taken as the fractional part of
      the seconds field, the tens and units digits are taken as the
      integer part of the seconds field, the hundreds and thousands
      digits are taken as the minutes fields, the remaining digits are
      taken as the degrees or hours field. Thus -12345.4 would be
      interpreted as (- 1 hour 23 mins 45.4 seconds) or (- 1 degree 23
      mins 45.4 seconds). The same value could also be specified as
      \sstitemlist{

         \sstitem
         1 23 45.5, -1h 23m 45.5s (if it represents a time value), or

         \sstitem
         1d 23 45.5 (if it represents an angular value).

      }
      The supplied values must be in their first order ranges (i.e. 0
      to 2.PI for longitude values and -PI/2 to $+$PI/2 for latitude
      values). Values outside these ranges cause an error to be
      reported, and the status value IRA\_\_RANGE is returned). The
      exception to this is if the string is prefixed with a {\tt "}$*${\tt "}
      character, in which case any numeric value may be supplied. In
      this case the supplied value is returned directly (eg if the
      string {\tt "}$*$400D{\tt "} is given, the radian equivalent of 400 degrees
      will be returned, not 40 (=400-360) degrees).  If either of the
      input strings are blank the corresponding output value is set to
      the Starlink {\tt "}BAD{\tt "} value (VAL\_\_BADD).
   }
   \sstinvocation{
      CALL IRA\_CTOD( ATEXT, BTEXT, SCS, A, B, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         ATEXT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The string containing the formatted version of the longitude
         value. If this string is blank, A is returned with the {\tt "}BAD{\tt "}
         value (VAL\_\_BADD), but no error is reported.
      }
      \sstsubsection{
         BTEXT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The string containing the formatted version of the latitude
         value. If this string is blank, B is returned with the {\tt "}BAD{\tt "}
         value (VAL\_\_BADD), but no error is reported.
      }
      \sstsubsection{
         SCS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The sky coordinate system (see ID2 section {\tt "}Sky Coordinates{\tt "}).
         Any unambiguous abbreviation will do.
      }
      \sstsubsection{
         A = DOUBLE PRECISION (Returned)
      }{
         The longitude value represented by the string ATEXT, in
         radians.
      }
      \sstsubsection{
         B = DOUBLE PRECISION (Returned)
      }{
         The latitude value represented by the string BTEXT, in
         radians.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_DTOC1
}{
   Convert a single floating point sky coordinate value to
   character form
}{
   \sstdescription{
      This routine creates a text string containing a formatted version
      of the given sky coordinate value. The value is assumed to be a
      longitude value if NC is 1, and a latitude if NC is 2. The
      formats of the output string are as described in routine
      IRA\_DTOC. Longitude values are shifted into the range 0 - 2$*$PI
      before being used.  Latitude values are shifted into the range
      $+$/- PI before being used. An error is reported if a latitude
      value then has an absolute value greater than PI/2 (this differs
      from the behaviour of IRA\_NORM which always reduces the latitude
      value to $+$/- PI/2).
   }
   \sstinvocation{
      CALL IRA\_DTOC1( VALUE, SCS, NC, STYLE, TEXT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VALUE = DOUBLE PRECISION (Given)
      }{
         The value of the sky coordinate to be formatted, in radians.
         If VALUE has the Starlink {\tt "}BAD{\tt "} value (VAL\_\_BADD) then the
         output string TEXT is set blank.
      }
      \sstsubsection{
         SCS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The sky coordinate system in use (see ID2 section {\tt "}Sky
         Coordinates{\tt "}). Any unambiguous abbreviation will do.
      }
      \sstsubsection{
         NC = INTEGER (Given)
      }{
         Determines which sky coordinate is given. If a value of 1 is
         supplied, VALUE is interpreted as a longitude value (eg RA if
         an equatorial system is being used).  If a value of 2 is
         supplied, VALUE is interpreted as a latitude value. Any other
         value causes an error to be reported.
      }
      \sstsubsection{
         STYLE = INTEGER (Given)
      }{
         A value in the range 1 to 5 which specifies the style of
         output formatting required. In addition a value of zero can be
         specified which causes a default style to be used dependant on
         the value of SCS. See routine IRA\_DTOC for a description of
         the styles and defaults.
      }
      \sstsubsection{
         TEXT = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The string containing the formatted description of the sky
         coordinate value. The variable supplied for TEXT should have a
         declared length equal to the value of parameter IRA\_\_SZFSC.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_DTOC
}{
   Convert a pair of double precision sky coordinate values to
   character form
}{
   \sstdescription{
      This routine creates a pair of text strings containing formatted
      versions of the given sky coordinate values.  The exact format
      depends on the type of sky coordinate system in use and the value
      of STYLE (see the {\tt "}Notes{\tt "} section below). The input coordinate
      values are shifted into their first order ranges before being used
      (see IRA\_NORM).
   }
   \sstinvocation{
      CALL IRA\_DTOC( A, B, SCS, STYLE, ATEXT, BTEXT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         A = DOUBLE PRECISION  (Given)
      }{
         The value of the sky longitude to be formatted, in radians. If
         A has the Starlink {\tt "}BAD{\tt "} value (VAL\_\_BADD) then the output
         string ATEXT is set blank.
      }
      \sstsubsection{
         B = DOUBLE PRECISION  (Given)
      }{
         The value of the sky latitude to be formatted, in radians. If
         B has the {\tt "}BAD{\tt "} value then the output string BTEXT is set
         blank.
      }
      \sstsubsection{
         SCS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The sky coordinate system in use (see ID2 section {\tt "}Sky
         Coordinates{\tt "}). Any unambiguous abbreviation will do.
      }
      \sstsubsection{
         STYLE = INTEGER (Given)
      }{
         A value in the range 1 to 5 which specifies the style of
         output formatting required.  Additionally, a value of zero can
         specified which causes a default style to be used dependant on
         the value of SCS.  See the {\tt "}Notes{\tt "} section below for a
         description of the individual styles and defaults for each
         SCS.
      }
      \sstsubsection{
         ATEXT = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The string containing the formatted description of the sky
         longitude value A. The variable supplied for ATEXT should
         have a declared length equal to the value of parameter
         IRA\_\_SZFSC.
      }
      \sstsubsection{
         BTEXT = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The string containing the formatted description of the sky
         latitude value B. The variable supplied for BTEXT should
         have a declared length equal to the value of parameter
         IRA\_\_SZFSC.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         SCS = {\tt "}EQUATORIAL{\tt "}
           Default is style 2 (used if argument STYLE is zero on entry).

      }
         STYLE = 1:  (a full description)

            {\tt "}RA = 12hrs 3m 0.02s{\tt "} and  {\tt "}DEC = -33deg 23m 0.00s{\tt "}

         STYLE = 2:  (a more brief form readable by IRA\_CTOD)

            {\tt "}12h 3m 0.02s{\tt "} and {\tt "}-33d 23m 0.00s{\tt "}

         STYLE = 3:  ( a very brief form readable by IRA\_CTOD)

            {\tt "}120300.00{\tt "} and {\tt "}-332300.00{\tt "} ( eg hhmmss.ss and ddmmss.ss )

         STYLE = 4:  (a brief form readable by IRA\_CTOD)

            {\tt "}12 03 0.02{\tt "} and {\tt "}-33 23 0.00{\tt "}

         STYLE = 5:  (a brief form readable by IRA\_CTOD)

            {\tt "}12.050006{\tt "} and {\tt "}-33.383333{\tt "} (eg fractional values in
                                       hours (RA) and degrees (DEC) )

      \sstitemlist{

         \sstitem
         SCS = {\tt "}GALACTIC{\tt "}
           Default is style 5 (used if argument STYLE is zero on entry).

      }
         STYLE = 1:

            {\tt "}l = 12deg 3m 0.02s{\tt "} and  {\tt "}b = -33deg 23m 0.00s{\tt "}

         STYLE = 2:

            {\tt "}12deg 3m 0.02s{\tt "} and {\tt "}-33d 23m 0.00s{\tt "}

         STYLE = 3:

            {\tt "}0120300.00{\tt "} and {\tt "}-332300.00{\tt "} (eg dddmmss.ss and ddmmss.ss )

         STYLE = 4:  (a brief form readable by IRA\_CTOD)

            {\tt "}12 03 0.02{\tt "} and {\tt "}-33 23 0.00{\tt "}

         STYLE = 5:  (a brief form readable by IRA\_CTOD)

            {\tt "}12.050006{\tt "} and {\tt "}-33.383333{\tt "} (eg fractional values in
                                         degrees )

      \sstitemlist{

         \sstitem
         SCS = {\tt "}ECLIPTIC{\tt "}
           Default is style 5 (used if argument STYLE is zero on entry).

      }
         STYLE = 1:

            {\tt "}Lambda = 12deg 3m 0.02s{\tt "} and  {\tt "}Beta = -33deg 23m 0.00s{\tt "}

         STYLE = 2:

            {\tt "}12deg 3m 0.02s{\tt "} and {\tt "}-33d 23m 0.00s{\tt "}

         STYLE = 3:

            {\tt "}0120300.00{\tt "} and {\tt "}-332300.00{\tt "} (eg dddmmss.ss and ddmmss.ss )

         STYLE = 4:  (a brief form readable by IRA\_CTOD)

            {\tt "}12 03 0.02{\tt "} and {\tt "}-33 23 0.00{\tt "}

         STYLE = 5:  (a brief form readable by IRA\_CTOD)

            {\tt "}12.050006{\tt "} and {\tt "}-33.383333{\tt "} (eg fractional values in
                                         degrees )
   }
}
\sstroutine{
   IRA\_EXPRT
}{
   Store astrometry information in an NDF
}{
   \sstdescription{
      An HDS structure is created containing the astrometry information
      identified by IDA. This {\tt "}astrometry structure{\tt "} is stored as a
      component of an extension within the NDF specified by INDF (any
      previous astrometry structure is over-written). The names of the
      NDF extension and the astrometry structure are set by a call to
      IRA\_LOCAT. If no such call is made the names of the extension and
      astrometry structure retain the values set up in IRA\_INIT ({\tt "}IRAS{\tt "}
      and {\tt "}ASTROMETRY{\tt "}).  The astrometry structure has an HDS data type
      of IRAS\_ASTROMETRY. The NDF extension must already exist before
      calling this routine.

      Any existing astrometry structure is first deleted from the NDF
      (in which ever extension it was found) before creating the new
      one.
   }
   \sstinvocation{
      CALL IRA\_EXPRT( IDA, INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IDA = INTEGER (Given)
      }{
         An IRA identifier for the astrometry information.
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         The identifier for the NDF in which the astrometry information
         is to be stored.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_FIND
}{
   Find an astrometry structure within an NDF
}{
   \sstdescription{
      A search is made for an astrometry structure within an NDF.  If
      one is found, THERE is returned true. If one is not found, no
      error is reported but THERE is returned false.  The name of the
      extension in which it was found is returned, together with the
      name of the astrometry structure, and a locator to the extension.
   }
   \sstinvocation{
      CALL IRA\_FIND( INDF, THERE, XNAME, ASNAME, LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         The NDF identifier.
      }
      \sstsubsection{
         THERE = LOGICAL (Returned)
      }{
         True if an astrometry structure was found, false otherwise.
      }
      \sstsubsection{
         XNAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The name of the NDF extension in which the astrometry
         structure was found. Blank if none found.
      }
      \sstsubsection{
         ASNAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The name of a component of the NDF extension holding the
         astrometry information. Blank if none found.
      }
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         A locator to the extension identified by XNAME. DAT\_\_NOLOC if
         no astrometry structure is found.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_GETCO
}{
   Obtain a pair of sky coordinates from the ADAM environment
}{
   \sstdescription{
      The ADAM parameters specified by arguments APAR and BPAR are used
      to acquire values for the first and second sky coordinates
      respectively, in the sky coordinate system specified by argument
      SCS. The parameters are obtained as literal character strings and
      decoded into floating point values. See routine IRA\_CTOD for a
      description of the allowed formats of the strings associated with
      these parameters. The input values of arguments A and B can
      optionally be supplied to the user as default parameter values.
      The parameter prompt strings contained in the application{\tt '}s
      interface file can be overridden by giving a non-blank value for
      argument PRMAPP. In this case, the prompts are formed by
      appending the value of PRMAPP to the coordinate descriptions
      returned by routine IRA\_SCNAM. For instance, if PRMAPP = {\tt "} of the
      field centre{\tt "}, and an equatorial sky coordinate system is in use,
      then the prompt for APAR will be {\tt "}Right Ascension of the field
      centre{\tt "}, and the prompt for BPAR will be {\tt "}Declination of the
      field centre{\tt "}. Note, the total length of the prompt strings is
      limited to 80 characters. If PRMAPP is blank, then the current
      prompt strings are used (initially equal to the values in the
      interface file).
   }
   \sstinvocation{
      CALL IRA\_GETCO( APAR, BPAR, PRMAPP, SCS, DEFLT, A, B, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         CHARACTER = APAR (Given)
      }{
         The name of the ADAM parameter (type LITERAL) to use
         for the sky longitude value.
      }
      \sstsubsection{
         CHARACTER = BPAR (Given)
      }{
         The name of the ADAM parameter (type LITERAL) to use
         for the sky latitude value.
      }
      \sstsubsection{
         PRMAPP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A string to append to each axis description to form the
         parameter prompt strings. If this is blank then the current
         prompt strings are used (i.e. initially set to the values in
         the interface file).
      }
      \sstsubsection{
         SCS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the sky coordinate system to use. Any unambiguous
         abbreviation will do (see ID2 section {\tt "}Sky Coordinates{\tt "}).
      }
      \sstsubsection{
         DEFLT = LOGICAL (Given)
      }{
         True if the input values of A and B are to be communicated to
         the environment as run-time defaults for the parameters
         specified by APAR and BPAR. If A or B is {\tt "}BAD{\tt "} on entry
         (i.e. equal to VAL\_\_BADD ) then no default is set up for the
         corresponding parameter.
      }
      \sstsubsection{
         A = DOUBLE PRECISION (Given and Returned)
      }{
         The value of the first sky coordinate. In radians.
      }
      \sstsubsection{
         B = DOUBLE PRECISION (Given and Returned)
      }{
         The value of the second sky coordinate. In radians.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_GETEQ
}{
   Extract the epoch of the reference equinox from a string
   specifying a Sky Coordinate System
}{
   \sstdescription{
      If, on entry, the argument SCS contains an explicit equinox
      specifier (see routine IRA\_ISCS), the epoch contained within it
      is returned in argument EQU as a double precision value, and
      argument BJ is returned equal to the character {\tt "}B{\tt "} or {\tt "}J{\tt "}
      depending on whether the epoch is Besselian or Julian. If there is
      no equinox specifier in argument SCS on entry, then the default of
      B1950 is returned.

      If the sky coordinate system specified by SCS is not referred to
      the equinox (eg GALACTIC) then EQU is returned equal to the
      Starlink {\tt "}BAD{\tt "} value VAL\_\_BADD, and BJ is returned blank.

      The argument NAME is returned holding the full (unabbreviated)
      name of the sky coordinate system without any equinox specifier.
      On exit, the argument SCS holds the full name plus an explicit
      equinox specifier (for systems which are referred to the
      equinox). Thus, if SCS contained {\tt "}EQUAT{\tt "} on entry, it would
      contain {\tt "}EQUATORIAL(B1950){\tt "} on exit.
   }
   \sstinvocation{
      CALL IRA\_GETEQ( SCS, EQU, BJ, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SCS = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         On entry this should contain an SCS name (or any unambiguous
         abbreviation), with or without an equinox specifier. On exit,
         it contains the full SCS name with an explicit equinox
         specifier (for those sky coordinate systems which are referred
         to the equinox). If no equinox specifier is present on entry,
         then a value of B1950 is used (if required). This variable
         should have a declared length given by the symbolic constant
         IRA\_\_SZSCS.
      }
      \sstsubsection{
         EQU = DOUBLE PRECISION (Returned)
      }{
         The epoch of the reference equinox. This is extracted
         from any explicit equinox specifier contained in SCS on entry.
         If there is no equinox specifier in SCS, a value of 1950.0
         is returned. If the sky coordinate system is not referred to
         the equinox (eg GALACTIC) the Starlink {\tt "}BAD{\tt "} value (VAL\_\_BADD)
         is returned, irrespective of any equinox specifier in SCS.
      }
      \sstsubsection{
         BJ = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Returned holding either the character B or J. Indicates if
         argument EQU gives a Besselian or Julian epoch. Returned blank
         if the sky coordinate system is not referred to the equinox.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The full name of the sky coordinate system without any equinox
         specifier. This variable should have a declared length given by
         the symbolic constant IRA\_\_SZSCS.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_GTCO1
}{
   Obtain a single sky coordinate value from the ADAM environment
}{
   \sstdescription{
      The ADAM parameter specified by argument PARAM is used to acquire
      a longitude or latitude value in the requested sky coordinate
      system. Argument NC determines which is to be obtained.  The
      string is decoded into a double precision number representing the
      sky position.  See the documentation for IRA\_CTOR for a
      description of the allowed formats.  The input sky coordinate
      value can optionally be communicated to the environment as a
      dynamic default.
   }
   \sstinvocation{
      CALL IRA\_GTCO1( PARAM, PROMPT, SCS, NC, DEFLT, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the ADAM parameter used to get the sky
         coordinate value.
      }
      \sstsubsection{
         PROMPT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A string to override the current prompt for the parameter.
         If this is blank, the prompt is left at its current value.
         The initial value for the prompt is defined in the interface
         file. Note, unlike routine IRA\_GETCO, the axis name is not
         automatically included in the prompt.
      }
      \sstsubsection{
         SCS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The sky coordinate system in use. Any unambiguous abbreviation
         will do  (see ID2 section {\tt "}Sky Coordinates{\tt "}).
      }
      \sstsubsection{
         NC = INTEGER (Given)
      }{
         Determines which sky coordinate is to be returned. If a value
         of 1 is supplied, the string obtained for the parameter is
         interpreted as a longitude value (eg RA if an equatorial
         system is being used). If a value of 2 is supplied, the string
         is interpreted as a latitude value.  Any other value causes an
         error to be reported.
      }
      \sstsubsection{
         DEFLT = LOGICAL (Given)
      }{
         If true, then the value of VALUE on entry is communicated to
         the environment as a dynamic default. If false, or if VALUE is
         {\tt "}BAD{\tt "} on entry (i.e. equal to VAL\_\_BADD), then no dynamic
         default is set up.
      }
      \sstsubsection{
         VALUE = DOUBLE PRECISION (Given and Returned)
      }{
         The sky coordinate value. On input it contains the default
         value (in radians) to use if DEFLT is true. On exit it
         contains the decoded value obtained from the environment, in
         radians.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_GTSCS
}{
   Get the full name of a Sky Coordinate System (with equinox
   specifier) from the environment
}{
   \sstdescription{
      The ADAM parameter specified by argument SCSPAR is used to get a
      character string from the environment. A check is done to make
      sure that the string obtained represents a supported Sky
      Coordinate System (SCS). The user may include an equinox
      specifier (see IRA\_ISCS) in the text string to override the
      default reference equinox of B1950. If an illegal SCS name is
      entered the user is reprompted. If DEFLT is given true, the value
      of SCS on entry is used as a default for the parameter.  The
      value of SCS is expanded (both on entry and exit) to a full SCS
      name (an abbreviation of the SCS may be supplied either by the
      calling routine or by the user instead of the full name).
   }
   \sstinvocation{
      CALL IRA\_GTSCS( SCSPAR, DEFLT, SCS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SCSPAR = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the ADAM parameter to use, which should be of type
         LITERAL.
      }
      \sstsubsection{
         DEFLT = LOGICAL (Given)
      }{
         If true, then the value of argument SCS on entry is used (after
         expansion) as the run-time default for the parameter.
      }
      \sstsubsection{
         SCS = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         On entry, specifies the default value for the parameter. On
         exit, contains the full version of the sky coordinate system
         entered by the user. The supplied variable should have a
         declared length given by symbolic constant IRA\_\_SZSCS.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_INIT
}{
   Initialise the IRA astrometry package
}{
   \sstdescription{
      This routine must be called before calling any other IRA routine
      which has an {\tt "}IDA{\tt "} argument. It is not necessary to call this
      routine before using routines such as IRA\_DIST which do not have
      an {\tt "}IDA{\tt "} argument. This routine annulls any currently valid IRA
      identifiers, sets the NDF extension name in which the astrometry
      structure is located to {\tt "}IRAS{\tt "}, sets the name of the astrometry
      structure to {\tt "}ASTROMETRY{\tt "}, and resets graphics options to their
      default values.
   }
   \sstinvocation{
      CALL IRA\_INIT( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_IPROJ
}{
   Return a list of supported projection names
}{
   \sstdescription{
      A string is returned containing the list of supported projection
      names and equivalent names. The names are separated by commas. The
      currently supported projections are:

      GNOMONIC ( or equivalently TANGENT\_PLANE )

      LAMBERT (  or equivalently CYLINDRICAL )

      AITOFF (  or equivalently ALL\_SKY )

      ORTHOGRAPHIC

      See ID/2 appendix {\tt "}Projection Equations{\tt "} for more details about
      the supported projections.
   }
   \sstinvocation{
      CALL IRA\_IPROJ( LIST, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LIST = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The list of supported projections and equivalent names. The
         character variable supplied for this argument should have a
         declared size equal to the value of parameter IRA\_\_SZPLS. If
         the supplied string is not long enough to hold all the names, a
         warning message is given, but no error status is returned. Each
         returned projection name has a maximum length given by symbolic
         constant IRA\_\_SZPRJ.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_ISCS
}{
   Return a list of supported sky coordinate systems
}{
   \sstdescription{
      A string is returned containing a list of names identifying the
      supported sky coordinate systems. The names in the output list
      are separated by commas.

      By default, Equatorial and Ecliptic coordinates are referred to
      the mean equinox of Besselian epoch 1950.0. The calling
      application can override this default by appending a string known
      as an {\tt "}equinox specifier{\tt "} to the end of the SCS name (in fact all
      IRA routines will accept any unambiguous abbreviation of the SCS
      name). An equinox specifier consists of a year with upto 4
      decimal places, preceded with the letter B or J to indicate a
      Besselian or Julian epoch, and enclosed in parentheses. The
      named coordinate system is then referred to the mean equinox of
      the epoch given in the equinox specifier. The following are
      examples of legal SCS values; EQUATORIAL(B1950), EQUAT(J2000),
      ECLIP, ECLIP(1983.2534), etc. If the date is not preceded with
      either B or J (as in the last example), a Besselian epoch is
      assumed if the date is less than 1984.0, and a Julian epoch is
      assumed otherwise.

      The currently supported sky coordinate systems are:

      EQUATORIAL

             The longitude axis is Right Ascension, the latitude axis
             is Declination. Other legal names can be made by appending
             an equinox specifier (eg EQUATORIAL(B1983.5) ). If no
             equinox specifier is added, the coordinates are referred
             to the mean equinox of Besselian epoch 1950.0. If the
             equinox is described by a Besselian epoch, the old FK4
             Bessel-Newcomb system is used. If a Julian epoch is used,
             the new IAU 1976, FK5, Fricke system is used.

      GALACTIC

             The longitude axis is galactic longitude and the latitude
             axis is galactic latitude, given in the IAU 1958 galactic
             coordinate system.

      ECLIPTIC

             The longitude axis is ecliptic longitude and the latitude
             axis is ecliptic latitude. Other legal names can be made
             by appending an equinox specifier (eg ECLIPTIC(B1983.5) ).
             If no equinox specifier is added, the coordinates are
             referred to the mean equinox of Besselian epoch 1950.0.

      All sky coordinate values supplied to, or returned from any IRA
      routine, are given in units of radians.
   }
   \sstinvocation{
      CALL IRA\_ISCS( LIST, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LIST = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The list of supported sky coordinate system names. The
         character variable supplied for this argument should have a
         declared size equal to the value of parameter IRA\_\_SZCLS. If
         the supplied string is not long enough to hold all the names, a
         warning message is given, but no error status is returned.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_LOCAT
}{
   Set the location for new IRA astrometry structures
}{
   \sstdescription{
      By default, IRA\_CREAT and IRA\_EXPRT store astrometry information
      in a component named {\tt "}ASTROMETRY{\tt "} within the {\tt "}IRAS{\tt "} NDF
      extension.  These names may be changed if necessary by calling
      this routine. The supplied arguments give the name of the NDF
      extension and the component name to be used by all future calls
      to IRA\_CREAT or IRA\_EXPRT. It should be ensured that the
      extension exists before calling IRA\_CREAT or IRA\_EXPRT.
   }
   \sstinvocation{
      CALL IRA\_LOCAT( XNAME, ASNAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         XNAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of NDF extension in which astrometry structures are to
         be created. If a blank value is supplied the current value is
         left unchanged.
      }
      \sstsubsection{
         ASNAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of a component of the NDF extension in which to store
         astrometry information. If a blank value is supplied the
         current value is left unchanged.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_NORM
}{
   Convert sky coordinate values to the equivalent first order
   values
}{
   \sstdescription{
      The given latitude value is shifted into the range $+$/- PI/2 ( a
      shift of PI may be introduced in the longitude value to achieve
      this). The longitude value is then shifted into the range 0 to
      2$*$PI. If either A or B has the Starlink {\tt "}BAD{\tt "} value on entry
      (VAL\_\_BADD) then both A and B are left unchanged on exit. Latitude
      values which are within 0.01 arc-seconds of either pole are
      modified to put them exactly at the pole.
   }
   \sstinvocation{
      CALL IRA\_NORM( A, B, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         A = DOUBLE PRECISION (Given and Returned)
      }{
         The longitude, in radians. On exit, the value is shifted in to
         the range 0 to 2$*$PI.
      }
      \sstsubsection{
         B = DOUBLE PRECISION (Given and Returned)
      }{
         The latitude value, in radians. On exit, the value is shifted
         in to the range -PI/2 to $+$PI/2.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_READ
}{
   Get an identifier for astrometry information stored in an HDS
   astrometry structure
}{
   \sstdescription{
      An attempt is made to read astrometry information from the
      supplied HDS object, assuming the object is an IRA astrometry
      structure. The astrometry information is copied into internal
      common blocks and an {\tt "}IRA identifier{\tt "} is returned which can be
      passed to other IRA routines to refer to the stored astrometry
      information.  This identifier should be annulled when it is no
      longer required by calling IRA\_ANNUL.
   }
   \sstinvocation{
      CALL IRA\_READ( LOC, IDA, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Given)
      }{
         An HDS locator to an astrometry structure. The constant
         IRA\_\_HDSTY gives the HDS type required for this object.
      }
      \sstsubsection{
         IDA = INTEGER (Returned)
      }{
         The IRA identifier which is used by other IRA routines to
         access the astrometry information.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_SETEQ
}{
   Encode the epoch of a reference equinox within an SCS name
}{
   \sstdescription{
      On entry, SCS contains the name of a Sky Coordinate System (or an
      unambiguous abbreviation), with or without an equinox specifier
      (see routine IRA\_ISCS). On exit, SCS contains the full name of
      the Sky Coordinate System with an equinox specifier appended,
      determined by arguments EQU and BJ. Any old equinox specifier is
      first removed. If the Sky Coordinate System is not referred to
      the equinox (eg GALACTIC) then no equinox specifier is included
      in SCS on exit.
   }
   \sstinvocation{
      CALL IRA\_SETEQ( EQU, BJ, SCS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EQU = DOUBLE PRECISION (Given)
      }{
         The epoch of the reference equinox. After calling this routine,
         the sky coordinates described by SCS are referred to the mean
         equinox of the epoch given by EQU. If EQU has the Starlink
         {\tt "}BAD{\tt "} value (VAL\_\_BADD) then no equinox specifier is included
         in SCS on exit.
      }
      \sstsubsection{
         BJ = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Determines if the epoch specified by argument EQU is a
         Besselian or Julian epoch. BJ should have the value {\tt "}B{\tt "} or {\tt "}J{\tt "}.
         Any other value causes an error report (except that a blank
         value causes {\tt "}B{\tt "} to be used if EQU is less than 1984.0 and {\tt "}J{\tt "}
         otherwise).
      }
      \sstsubsection{
         SCS = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         On entry, SCS should contain an unambiguous abbreviation of a
         supported Sky Coordinate System (see routine IRA\_ISCS), with or
         without an equinox specifier. On exit, SCS contains the full
         name of the Sky Coordinate System, appended with an equinox
         specifier determined by arguments EQU and BJ. If the Sky
         Coordinate System is not one that is referred to the equinox
         (eg GALACTIC) then no equinox specifier is included in SCS on
         exit. SCS should have a declared length equal to the symbolic
         constant IRA\_\_SZSCS.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_TRANS
}{
   Transform coordinate data
}{
   \sstdescription{
      Coordinate data are transformed from sky coordinates to image
      coordinates, or vice-versa, using the projection information
      identified by IDA. The direction of the transformation is
      determined by the argument FORWRD.  If any input coordinate
      values are equal to the Starlink {\tt "}BAD{\tt "} value (VAL\_\_BADD) then
      both the output values are set to the bad value.
   }
   \sstinvocation{
      CALL IRA\_TRANS( NVAL, IN1, IN2, FORWRD, SCS, IDA,
                      OUT1, OUT2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NVAL = INTEGER (Given)
      }{
         The number of coordinate points to be transformed.
      }
      \sstsubsection{
         IN1( NVAL ) = DOUBLE PRECISION (Given)
      }{
         If FORWRD is true, then IN1 holds values of the first image
         coordinate (X), otherwise IN1 holds values of the sky
         longitude.
      }
      \sstsubsection{
         IN2( NVAL ) = DOUBLE PRECISION (Given)
      }{
         If FORWRD is true, then IN2 holds values of the second image
         coordinate (Y), otherwise IN2 holds values of the sky
         latitude.
      }
      \sstsubsection{
         FORWRD = LOGICAL (Given)
      }{
         If true then the forward mapping is used from image coordinate
         to sky coordinate. Otherwise, the inverse mapping from sky
         coordinate to image coordinates is used.
      }
      \sstsubsection{
         SCS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the sky coordinate system in which sky coordinates
         are required (if FORWRD is true), or supplied (if FORWRD is
         false). Any unambiguous abbreviation will do. This need not be
         the same as the SCS identified by IDA.  See ID2 section {\tt "}Sky
         Coordinates{\tt "} for more information on Sky Coordinate Systems.
         A blank value will cause the system associated with IDA to be
         used.
      }
      \sstsubsection{
         IDA = INTEGER (Given)
      }{
         The IRA identifier for the astrometry information.
      }
      \sstsubsection{
         OUT1( NVAL ) = DOUBLE PRECISION (Returned)
      }{
         If FORWRD is true, then OUT1 holds values of the sky longitude
         corresponding to the image coordinates given in arrays IN1 and
         IN2. Otherwise, OUT1 holds values of the first image
         coordinate (X) corresponding to the input sky coordinates.
      }
      \sstsubsection{
         OUT2( NVAL ) = DOUBLE PRECISION (Returned)
      }{
         If FORWRD is true, then OUT2 holds values of the sky latitude
         corresponding to the image coordinates given in arrays IN1 and
         IN2. Otherwise, OUT2 holds values of the second image
         coordinate (Y) corresponding to the input sky coordinates.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   IRA\_WRITE
}{
   Write astrometry information into an HDS object
}{
   \sstdescription{
      The astrometry information identified by IDA is stored within the
      object located by argument LOC. The constant IRA\_\_HDSTY gives the
      HDS type required for the object. The object must have this type
      and be empty.
   }
   \sstinvocation{
      CALL IRA\_WRITE( IDA, LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IDA = INTEGER (Given)
      }{
         An IRA identifier for the astrometry information.
      }
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A locator to the object to which the astrometry information is
         to be written.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ABSET
}{
   Separates a list of items into a character array
}{
   \sstdescription{
      The routine separates a list of items into an character array and
      finds the minimum number of characters required to specify each
      item uniquely, and the length in characters of the longest item
      of the list.
   }
   \sstinvocation{
      CALL KPG1\_ABSET( SEPAR, OPTS, ARRAY, NELM, MINCH, MAXNOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SEPAR = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The separator that divides the list of items.
      }
      \sstsubsection{
         OPTS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Contains a list of items separated by the delimiter SEPAR.  It
         is limited to 132 characters.
      }
      \sstsubsection{
         ARRAY( $*$ ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The list divided into an array of values.  The list is in
         alphabetic order.
      }
      \sstsubsection{
         NELM = INTEGER (Returned)
      }{
         The number of elements in the list, and stored in ARRAY.
      }
      \sstsubsection{
         MCH( $*$ ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The minimum number of initial characters to identify each of
         the items in the list uniquely.  In the special case when an
         option equals the start of another option, MCH for the first
         option equals the option{\tt '}s length (ignoring trailing blanks)
         in characters; MCH for the the second will be at least one
         character greater.
      }
      \sstsubsection{
         MINCH = INTEGER (Returned)
      }{
         The minimum number of initial characters that can identify an
         item in the list uniquely.  In other words, the minimum value
         of the elements of MCH.
      }
      \sstsubsection{
         MAXNOC = INTEGER (Returned)
      }{
         The maximum length of an item in the array, ignoring trailing
         blanks.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The size and dimension of the character array must be
            sufficient to accommodate the length and number of strings.

         \sstitem
         Error status SAI\_\_ERROR is returned when the list of options
            is ambiguous.
      }
   }
}
\sstroutine{
   KPG1\_AGATC
}{
   Reports the character attributes of the current picture in the
   graphics database
}{
   \sstdescription{
      This routine inquires the name, comment, and label (if one is
      present) of the current picture in the AGI graphics database
      and reports their values.
   }
   \sstinvocation{
      CALL KPG1\_AGATC( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_AGFND
}{
   Selects the highest picture of a given name within the current AGI
   picture
}{
   \sstdescription{
      This routine searches forwards through the AGI database for a
      picture of a given name that lies within the current picture,
      including the current picture itself.  If one is found it
      becomes the new current picture.  If it could not be found a
      bad status will be returned, and the current picture is unchanged.
   }
   \sstinvocation{
      CALL KPG1\_AGFND( NAME, PICID, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the picture to be searched for in the graphics
         database.
      }
      \sstsubsection{
         PICID = INTEGER (Returned)
      }{
         The picture identifier of the most-recent picture named NAME.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_AGREF
}{
   Obtains a name of or a locator to an object referenced in the
   graphics database
}{
   \sstdescription{
      This routine determines whether a given picture in the AGI
      graphics database has an object associated with it by reference.
      If it has, the name of the object or a locator to the object is
      returned with the desired access mode.
   }
   \sstinvocation{
      CALL KPG1\_AGREF( PICID, ACCESS, THERE, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PICID = INTEGER (Given)
      }{
         The identifier of the picture with which a data object may
         be associated by reference.
      }
      \sstsubsection{
         ACCESS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Access mode to the object: {\tt '}READ{\tt '}, {\tt '}WRITE{\tt '} or {\tt '}UPDATE{\tt '}.
      }
      \sstsubsection{
         THERE = LOGICAL (Returned)
      }{
         If true the picture has an associated object and the returned
         name is meaningful.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The name of the data object referenced by picture PICID, or a
         locator to that object.  It should be ignored if THERE is
         .FALSE..  The value should be tested to see if it a locator or
         a name.  If it is a locator, it should be annulled by
         REF\_ANNUL.  A reasonable number of characters should be allowed
         to accommodate a name including its path and section.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      The code is a little convoluted because of a bug in AGI\_GTREF
      which means that a long name cannot be passed to it, if the
      reference is via a locator.
   }
}
\sstroutine{
   KPG1\_AINBx
}{
   Obtains for an axis the equivalent index co-ordinates given axis
   values
}{
   \sstdescription{
      This routine determines the indices within an axis array for a
      series of axis values.  It assumes that the array is
      monotonically increasing or decreasing, and is approximately
      linear.  This routine may be used for arbitrary 1-d arrays
      in addition to axes, provided these criteria are met.

      A Newton{\tt '}s approximation method is used comparing the actual value
      with a linear approximation.  The upper and lower bounds used to
      define the increment are adjusted given the deviation from the
      linear axis.  Once the value lies between adjacent array elements
      the nearer (by linear interpolation) becomes the required index.
   }
   \sstinvocation{
      CALL KPG1\_AINBx( LBND, UBND, AXIS, EL, VALUE, INDEX, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The lower bound of the axis array.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The upper bound of the axis array.
      }
      \sstsubsection{
         AXIS( LBND:UBND ) = ? (Given)
      }{
         The axis array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of values whose indices in the axis are to be found.
      }
      \sstsubsection{
         VALUE( EL ) = ? (Given)
      }{
         The axis-array values.
      }
      \sstsubsection{
         INDEX( EL ) = ? (Returned)
      }{
         The pixel indices of the values in the axis array.
         Notice that this is floating as fractional positions may be
         required. An index is set to the bad value when its input
         co-ordinate lies outside the range of co-ordinates in the
         axis or when the input co-ordinate is bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the data types real or double precision:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively, as
         appropriate.  The axis array and values, and the returned indices
         should have this data type as well.

         \sstitem
         No error report is made and bad status is not set should any
         input co-ordinate lie outside the range of co-ordinates of
         the axis.  Processing will continue through the list.
      }
   }
}
\sstroutine{
   KPG1\_AINBx
}{
   Obtains for an axis the equivalent index co-ordinates given axis
   values
}{
   \sstdescription{
      This routine determines the indices within an axis array for a
      series of axis values.  It assumes that the array is
      monotonically increasing or decreasing, and is approximately
      linear.  This routine may be used for arbitrary 1-d arrays
      in addition to axes, provided these criteria are met.

      A Newton{\tt '}s approximation method is used comparing the actual value
      with a linear approximation.  The upper and lower bounds used to
      define the increment are adjusted given the deviation from the
      linear axis.  Once the value lies between adjacent array elements
      the nearer (by linear interpolation) becomes the required index.
   }
   \sstinvocation{
      CALL KPG1\_AINBx( LBND, UBND, AXIS, EL, VALUE, INDEX, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The lower bound of the axis array.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The upper bound of the axis array.
      }
      \sstsubsection{
         AXIS( LBND:UBND ) = ? (Given)
      }{
         The axis array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of values whose indices in the axis are to be found.
      }
      \sstsubsection{
         VALUE( EL ) = ? (Given)
      }{
         The axis-array values.
      }
      \sstsubsection{
         INDEX( EL ) = ? (Returned)
      }{
         The pixel indices of the values in the axis array.
         Notice that this is floating as fractional positions may be
         required. An index is set to the bad value when its input
         co-ordinate lies outside the range of co-ordinates in the
         axis or when the input co-ordinate is bad.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the data types real or double precision:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively, as
         appropriate.  The axis array and values, and the returned indices
         should have this data type as well.

         \sstitem
         No error report is made and bad status is not set should any
         input co-ordinate lie outside the range of co-ordinates of
         the axis.  Processing will continue through the list.
      }
   }
}
\sstroutine{
   KPG1\_AINDx
}{
   Obtains for an axis the equivalent index co-ordinates given axis
   values
}{
   \sstdescription{
      This routine determines the indices within an axis array for a
      series of axis values.  It assumes that the array is
      monotonically increasing or decreasing, and is approximately
      linear.  This routine may be used for arbitrary 1-d arrays
      in addition to axes, provided these criteria are met.

      A Newton{\tt '}s approximation method is used comparing the actual value
      with a linear approximation.  The upper and lower bounds used to
      define the increment are adjusted given the deviation from the
      linear axis.  Once the value lies between adjacent array elements
      the nearer (by linear interpolation) becomes the required index.
   }
   \sstinvocation{
      CALL KPG1\_AINDx( LBND, UBND, AXIS, EL, VALUE, INDEX, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The lower bound of the axis array.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The upper bound of the axis array.
      }
      \sstsubsection{
         AXIS( LBND:UBND ) = ? (Given)
      }{
         The axis array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of values whose indices in the axis are to be found.
      }
      \sstsubsection{
         VALUE( EL ) = ? (Given)
      }{
         The axis-array values.
      }
      \sstsubsection{
         INDEX( EL ) = ? (Returned)
      }{
         The pixel indices of the values in the axis array.
         Notice that this is floating as fractional positions may be
         required.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the data types real or double precision:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively, as
         appropriate.  The axis array and values, and the returned indices
         should have this data type as well.
      }
   }
}
\sstroutine{
   KPG1\_AINDx
}{
   Obtains for an axis the equivalent index co-ordinates given axis
   values
}{
   \sstdescription{
      This routine determines the indices within an axis array for a
      series of axis values.  It assumes that the array is
      monotonically increasing or decreasing, and is approximately
      linear.  This routine may be used for arbitrary 1-d arrays
      in addition to axes, provided these criteria are met.

      A Newton{\tt '}s approximation method is used comparing the actual value
      with a linear approximation.  The upper and lower bounds used to
      define the increment are adjusted given the deviation from the
      linear axis.  Once the value lies between adjacent array elements
      the nearer (by linear interpolation) becomes the required index.
   }
   \sstinvocation{
      CALL KPG1\_AINDx( LBND, UBND, AXIS, EL, VALUE, INDEX, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The lower bound of the axis array.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The upper bound of the axis array.
      }
      \sstsubsection{
         AXIS( LBND:UBND ) = ? (Given)
      }{
         The axis array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of values whose indices in the axis are to be found.
      }
      \sstsubsection{
         VALUE( EL ) = ? (Given)
      }{
         The axis-array values.
      }
      \sstsubsection{
         INDEX( EL ) = ? (Returned)
      }{
         The pixel indices of the values in the axis array.
         Notice that this is floating as fractional positions may be
         required.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the data types real or double precision:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively, as
         appropriate.  The axis array and values, and the returned indices
         should have this data type as well.
      }
   }
}
\sstroutine{
   KPG1\_AKERx
}{
   Smooth a 2-dimensional array using an arbitrary rectangular
   kernel
}{
   \sstdescription{
      The routine smooths the array A using an arbitrary smoothing
      kernel, and returns the result in the array B.
   }
   \sstinvocation{
      CALL KPG1\_AKERx( IBOX, JBOX, WEIGHT, SAMBAD, WLIM, NX, NY,
                       BAD, VAR, A, B, BADOUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IBOX = INTEGER (Given)
      }{
         Half-size, in pixels along the x axis, of the box over which
         the smoothing will be applied (the actual box used has an edge
         which is 2$*$IBOX$+$1 pixels long). This defines the region within
         which the smoothing function is non-zero.
      }
      \sstsubsection{
         JBOX = INTEGER (Given)
      }{
         Half-size, in pixels along the y axis, of the box over which
         the smoothing will be applied (the actual box used has an edge
         which is 2$*$JBOX$+$1 pixels long). This defines the region within
         which the smoothing function is non-zero.
      }
      \sstsubsection{
         WEIGHT( 2 $*$ IBOX $+$ 1, 2 $*$ JBOX $+$ 1 ) = ? (Given)
      }{
         The weighting kernel.  It need not be normalised to one, but
         this is strongly preferred since it reduces the chance of
         overflows.
      }
      \sstsubsection{
         SAMBAD = LOGICAL (Given)
      }{
         If a .TRUE. value is given, then any {\tt "}bad{\tt "} pixels in the input
         array A will be propagated to the output array B (output
         values will be calculated for all other output pixels). If a
         .FALSE. value is given, then the WLIM argument is used to
         determine which output pixels will be bad (if any). This
         argument is not relevant if BAD is .FALSE..
      }
      \sstsubsection{
         WLIM = ? (Given)
      }{
         The minimum weighting that can be used to compute a smoothed
         output pixel if SAMBAD is .FALSE..  Any output pixels falling
         short of the specified weight will be set to the bad value
         (invalid pixels carry no weight, others have Gaussian weights
         about the central pixel).  The value must be greater than 0.0
         and should be less than or equal to 1.0. This argument is not
         used if SAMBAD is .TRUE. or if BAD is .FALSE..
      }
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         First dimension of the 2-d array A.
      }
      \sstsubsection{
         NY = INTEGER (Given)
      }{
         Second dimension of the 2-d array A.
      }
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether it is necessary to check for bad pixels in the input
         array A.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If a .FALSE. value is given for this argument, then smoothing
         will be performed as if the array supplied (A) is an array of
         data and the PSF will be used directly as specified. If a
         .TRUE. value is given, then smoothing will be applied as if
         the array is an array of variance values associated with an
         array of data; in this case, the effective PSF will be reduced
         in width by a factor 2 and the mean output values will be
         reduced to reflect the variance-reducing effect of smoothing.
      }
      \sstsubsection{
         A( NX, NY ) = ? (Given)
      }{
         Array containing the input image to be smoothed.
      }
      \sstsubsection{
         B( NX, NY ) = ? (Returned)
      }{
         Array containing the input image after smoothing.
      }
      \sstsubsection{
         BADOUT = LOGICAL (Returned)
      }{
         Whether there are bad pixel values in the output array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There are routines for processing double precision and real data.
         Replace {\tt "}x{\tt "} in the routine name by D or R as appropriate. The
         data types of the WLIM, A, B, and WEIGHT arguments must match the
         routine used.

         \sstitem
         This routine should not be used for symmetric kernels because
         there are faster algorithms for handling these special cases.
      }
   }
}
\sstroutine{
   KPG1\_AKERx
}{
   Smooth a 2-dimensional array using an arbitrary rectangular
   kernel
}{
   \sstdescription{
      The routine smooths the array A using an arbitrary smoothing
      kernel, and returns the result in the array B.
   }
   \sstinvocation{
      CALL KPG1\_AKERx( IBOX, JBOX, WEIGHT, SAMBAD, WLIM, NX, NY,
                       BAD, VAR, A, B, BADOUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IBOX = INTEGER (Given)
      }{
         Half-size, in pixels along the x axis, of the box over which
         the smoothing will be applied (the actual box used has an edge
         which is 2$*$IBOX$+$1 pixels long). This defines the region within
         which the smoothing function is non-zero.
      }
      \sstsubsection{
         JBOX = INTEGER (Given)
      }{
         Half-size, in pixels along the y axis, of the box over which
         the smoothing will be applied (the actual box used has an edge
         which is 2$*$JBOX$+$1 pixels long). This defines the region within
         which the smoothing function is non-zero.
      }
      \sstsubsection{
         WEIGHT( 2 $*$ IBOX $+$ 1, 2 $*$ JBOX $+$ 1 ) = ? (Given)
      }{
         The weighting kernel.  It need not be normalised to one, but
         this is strongly preferred since it reduces the chance of
         overflows.
      }
      \sstsubsection{
         SAMBAD = LOGICAL (Given)
      }{
         If a .TRUE. value is given, then any {\tt "}bad{\tt "} pixels in the input
         array A will be propagated to the output array B (output
         values will be calculated for all other output pixels). If a
         .FALSE. value is given, then the WLIM argument is used to
         determine which output pixels will be bad (if any). This
         argument is not relevant if BAD is .FALSE..
      }
      \sstsubsection{
         WLIM = ? (Given)
      }{
         The minimum weighting that can be used to compute a smoothed
         output pixel if SAMBAD is .FALSE..  Any output pixels falling
         short of the specified weight will be set to the bad value
         (invalid pixels carry no weight, others have Gaussian weights
         about the central pixel).  The value must be greater than 0.0
         and should be less than or equal to 1.0. This argument is not
         used if SAMBAD is .TRUE. or if BAD is .FALSE..
      }
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         First dimension of the 2-d array A.
      }
      \sstsubsection{
         NY = INTEGER (Given)
      }{
         Second dimension of the 2-d array A.
      }
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether it is necessary to check for bad pixels in the input
         array A.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If a .FALSE. value is given for this argument, then smoothing
         will be performed as if the array supplied (A) is an array of
         data and the PSF will be used directly as specified. If a
         .TRUE. value is given, then smoothing will be applied as if
         the array is an array of variance values associated with an
         array of data; in this case, the effective PSF will be reduced
         in width by a factor 2 and the mean output values will be
         reduced to reflect the variance-reducing effect of smoothing.
      }
      \sstsubsection{
         A( NX, NY ) = ? (Given)
      }{
         Array containing the input image to be smoothed.
      }
      \sstsubsection{
         B( NX, NY ) = ? (Returned)
      }{
         Array containing the input image after smoothing.
      }
      \sstsubsection{
         BADOUT = LOGICAL (Returned)
      }{
         Whether there are bad pixel values in the output array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There are routines for processing double precision and real data.
         Replace {\tt "}x{\tt "} in the routine name by D or R as appropriate. The
         data types of the WLIM, A, B, and WEIGHT arguments must match the
         routine used.

         \sstitem
         This routine should not be used for symmetric kernels because
         there are faster algorithms for handling these special cases.
      }
   }
}
\sstroutine{
   KPG1\_SOLIN
}{
   Sets the aspect source flag of the GKS linetype to bundled
}{
   \sstdescription{
      The routine sets the aspect source flag of the linetype of the
      current workstation to bundled.
   }
   \sstinvocation{
      CALL KPG1\_ANTSO( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      A GKS workstation should be open and active.
   }
}
\sstroutine{
   KPG1\_ARCOG
}{
   Allow the user to select an array component in a supplied NDF
}{
   \sstdescription{
      This routine allows the user to select an NDF array component
      selected from the ones available in the supplied NDF. Any of
      {\tt '}Data{\tt '}, {\tt '}Quality{\tt '}, {\tt '}Variance{\tt '}, and {\tt '}Error{\tt '} can be selected if
      they are present in the NDF. The user is re-prompted until a
      valid component name is obtained, or an error occurs.
   }
   \sstinvocation{
      CALL KPG1\_ARCOG( PARAM, INDF, MCOMP, COMP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The parameter to use.
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         The NDF identifier.
      }
      \sstsubsection{
         MCOMP = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The name of the selected array component for use with NDF\_MAP.
         The  returned values are {\tt '}Data{\tt '}, {\tt '}Quality{\tt '}, {\tt '}Variance{\tt '}, and
         {\tt '}Error{\tt '} for the array components DATA, QUALITY, VARIANCE, and
         ERROR respectively. Returned equal to {\tt '}Data{\tt '} if an error occurs.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Equal to MCOMP except that {\tt '}Variance{\tt '} is substituted in place of
         {\tt '}Error{\tt '}. Only NDF\_MAP accepts {\tt '}Error{\tt '} as a component name. All
         other NDF routines require {\tt '}Variance{\tt '} to be specified instead
         and so should use COMP instead of MCOMP.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ARCOL
}{
   Forms a list of the available array components in an NDF
}{
   \sstdescription{
      This routine takes a list of array components and checks whether
      or not each is defined within an NDF, and if it is, copy the
      component name to the output list.
   }
   \sstinvocation{
      CALL KPG1\_ARCOL( NDF, INLIST, EXLIST, LENGTH, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDF = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The identifier of the NDF to be inspected for certain array
         components.
      }
      \sstsubsection{
         INLIST = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A comma-separated list of the array components whose presence
         is to be tested.  Valid component names are {\tt '}Data{\tt '}, {\tt '}Quality{\tt '},
         {\tt '}Variance{\tt '}, and {\tt '}Error{\tt '}.  The component names may be
         abbreviated.
      }
      \sstsubsection{
         EXLIST = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         A comma-separated list of the array components of INLIST that
         are defined in the NDF.  Its length should be as long as the
         fully expanded list of components.  The components are tested
         in the order supplied.  Note that mixed case components are
         returned so that they may be used in reports to users.  Thus
         the  returned values are {\tt '}Data{\tt '}, {\tt '}Quality{\tt '}, {\tt '}Variance{\tt '}, and
         {\tt '}Error{\tt '} for the array components DATA, QUALITY, VARIANCE, and
         ERROR respectively.
      }
      \sstsubsection{
         LENGTH = INTEGER (Returned)
      }{
         The effective length of the output list. Returned equal to 1 if
         an error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASAGD
}{
   Transform AGI world co-ordinates to AGI data co-ordinates
}{
   \sstdescription{
      This routine transforms AGI world co-ordinates to AGI data co-ordinates
      using the TRANSFORM structure associated with the current AGI
      picture. It is intended for use as a transformation routine by an
      AST IntraMap.
   }
   \sstinvocation{
      CALL KPG1\_ASAGD( THIS, NPOINT, NCOORD\_IN, INDIM, IN, FORWARD,
                       NCOORD\_OUT, OUTDIM, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Bad input co-ordinates will be set to AST\_\_BAD, but TRANSFORM uses
         VAL\_\_BADD to mark bad values. We assume here that VAL\_\_BADD and
         AST\_\_BAD are the same.
      }
   }
}
\sstroutine{
   KPG1\_ASCRV
}{
   Draw a polyline using AST
}{
   \sstdescription{
      This routine draw a polyline between the supplied positions. These
      positions are presumed to refer to the (2D) Current coordinate Frame
      in the supplied AST Plot.

      If FAST is .TRUE., the supplied positions are transformed into
      graphics coordinates, and the polyline is then drawn as a series
      of straight line segments using PGPLOT directly. Drawing performed
      with FAST = .TRUE. is buffered to increase efficiency. Call this
      routine with N=0 to flush the buffer.

      If FAST is .FALSE., AST\_CURVE is used to draw the polyline as a
      series of geodesic curves in the Current Frame of the Plot. This
      will take into account any discontinuities in the Mapping from
      the Current Frame to the graphics coordinate Frame, but will be
      slower.
   }
   \sstinvocation{
      CALL KPG1\_ASCRV( IPLOT, FAST, N, X, Y, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPLOT = INTEGER (Given)
      }{
         A pointer to a Plot.
      }
      \sstsubsection{
         FAST = LOGICAL (Given)
      }{
         Is faster plotting required?
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         The number of points in the polyline. Zero to flush the buffer
         when drawing in fast mode.
      }
      \sstsubsection{
         X( N ) = REAL (Given)
      }{
         The X coordinates at the polyline points, in the Current Frame of
         the Plot.
      }
      \sstsubsection{
         Y( N ) = REAL (Given)
      }{
         The Y coordinates at the polyline points, in the Current Frame of
         the Plot.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASDIS
}{
   Find the distance between two points
}{
   \sstdescription{
      This routine returns the distance between two positions in the
      supplied co-ordinate Frame. Either the geodesic or Euclidean distance
      can be returned.
   }
   \sstinvocation{
      RESULT = KPG1\_ASDIS( FRAME, DIM, NAX, POS, I1, I2, GEO, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FRAME = INTEGER (Given)
      }{
         An AST pointer to the Frame. Only accessed if GEO is .TRUE.
      }
      \sstsubsection{
         DIM = INTEGER (Given)
      }{
         The size of the first dimension of the POS array.
      }
      \sstsubsection{
         NAX = INTEGER (Given)
      }{
         The number of axes in the Frame.
      }
      \sstsubsection{
         POS( DIM, NAX ) = DOUBLE PRECISION (Given)
      }{
         An array holding the co-ordinates at DIM positions within the
         supplied Frame.
      }
      \sstsubsection{
         I1 = INTEGER (Given)
      }{
         The index of the first position, in the range 1 to DIM.
      }
      \sstsubsection{
         I2 = INTEGER (Given)
      }{
         The index of the second position, in the range 1 to DIM.
      }
      \sstsubsection{
         GEO = LOGICAL (Given)
      }{
         Is the geodesic distance required?
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         KPG1\_ASDIS = DOUBLE PRECISION
      }{
         The distance between the two points.
      }
   }
}
\sstroutine{
   KPG1\_ASDSV
}{
   Find the distances between a set of points
}{
   \sstdescription{
      This routine returns the distance to each point in a set of points,
      from the first point, measured along the path joining the points.
      Geodesic distances within the supplied Frame are used.
   }
   \sstinvocation{
      CALL KPG1\_ASDSV( FRM, NP, NAX, POS, NORM, DIS, BAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FRM = INTEGER (Given)
      }{
         An AST pointer to the Frame.
      }
      \sstsubsection{
         NP = INTEGER (Given)
      }{
         The size of the first dimension of the POS array.
      }
      \sstsubsection{
         NAX = INTEGER (Given)
      }{
         The number of axes in the Frame.
      }
      \sstsubsection{
         POS( NP, NAX ) = DOUBLE PRECISION (Given)
      }{
         An array holding the co-ordinates at NP positions within the
         supplied Frame.
      }
      \sstsubsection{
         NORM = LOGICAL (Given)
      }{
         If .TRUE., the returned distances are normalised to a maximum
         value of 1.0.
      }
      \sstsubsection{
         DIS( NP ) = DOUBLE PRECISION (Returned)
      }{
         The distance along the path to each position, starting at the
         first position.
      }
      \sstsubsection{
         BAD = LOGICAL (Returned)
      }{
         Are there any AST\_\_BAD values in the returned array?
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   KPG1\_ASFFR
}{
   Finds an Frame with a given Domain within a FrameSet
}{
   \sstdescription{
      This routine finds the last Frame with a given Domain within a
      FrameSet, and returns its index. The Current Frame in the FrameSet
      is not changed.

      The first and last component Frames within CmpFrames are included
      in the search (component Frames in the middle of a CmpFrame cannot
      be found as yet). If a matching Frame is found within a CmpFrame,
      then a copy of the matching Frame is appended to the FrameSet. The
      returned Frame index refers to this extracted component Frame, rather
      than the CmpFrame from which it was extracted.
   }
   \sstinvocation{
      CALL KPG1\_ASFFR( TARGET, DOMAIN, IFRM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TARGET = INTEGER (Given)
      }{
         An AST pointer for a FrameSet containing the Frames to be
         searched.
      }
      \sstsubsection{
         DOMAIN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The Domain name to be searched for.
      }
      \sstsubsection{
         IFRM = INTEGER (Returned)
      }{
         The index of the matching Frame within the returned FrameSet.
         Returned equal to AST\_\_NOFRAME if no match was found, or if an
         error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASFGT
}{
   Create a new Frame with a Domain specified through the environment
}{
   \sstdescription{
      This routine creates a new AST Frame with a Domain specified through
      the environment. If the string obtained for the parameter looks
      like an IRAS90 {\tt "}Sky Co-ordinate System{\tt "} (SCS) specification, then
      a SkyFrame is returned with the properties specified by the SCS.
      Otherwise, a simple Frame is returned with the specified Domain,
      the number of axes in the Frame being specified by another environment
      parameter.
   }
   \sstinvocation{
      CALL KPG1\_ASFGT( PDOM, PDIM, PEP, FRM, NAX, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PDOM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of parameter to use to get Frame Domain.
      }
      \sstsubsection{
         PDIM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of parameter to use to get number of Frame axes. Only
         accessed if the value obtained for PDOM is not an IRAS90 SCS.
      }
      \sstsubsection{
         PEP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of parameter to use to get the epoch of observation. Only
         accessed if the value obtained for PDOM is an IRAS90 SCS.
      }
      \sstsubsection{
         FRM = INTEGER (Returned)
      }{
         An AST pointer to the returned Frame. Returned equal to
         AST\_\_NULL if an error occurs.
      }
      \sstsubsection{
         NAX = INTEGER (Returned)
      }{
         The number of axes in the returned Frame. Returned equal to zero
         if an error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASFIL
}{
   Read spatial positions from a text file
}{
   \sstdescription{
      This routine obtains formatted positions from a text file specified by
      an environment parameter. The positions are assumed to represent
      axis values in the supplied Frame.

      The file should contain 1 position per line. Each position is given by
      a set of strings delimited by comma, space or tab (the first gives the
      value for axis 1, the second for axis 2, etc). The number of strings
      per line should equal the number of axes in the supplied Frame.
      The user can specify the columns to use using parameter PARAM2.

      The file may contain blank lines, and comment lines commencing with
      {\tt "}!{\tt "} or {\tt "}\#{\tt "}.
   }
   \sstinvocation{
      CALL KPG1\_ASFIL( PARAM1, PARAM2, FRM, NP, IPOUT, FNAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM1 = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of an environment parameter to use to get the file.
      }
      \sstsubsection{
         PARAM2 = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of an environment parameter to use to get the indices of
         the columns within the text file which are to be used. If blank,
         the file must contain a column for every axis in FRM, all of which
         are used in the order 1, 2, 3, etc.
      }
      \sstsubsection{
         FRM = INTEGER (Given)
      }{
         A pointer to an AST Frame.
      }
      \sstsubsection{
         NP = INTEGER (Returned)
      }{
         The number of positions read from the file.
      }
      \sstsubsection{
         IPOUT = INTEGER (Returned)
      }{
         A pointer to an \_DOUBLE array {\tt "}COR( NP, $*$ ){\tt "} holding the obtained
         co-ordinates. The second dimension of the array is equal to the
         number of axes in the suppleid Frame. Should be released using
         PSX\_FREE when no longer needed.
      }
      \sstsubsection{
         FNAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The file{\tt '}s name. Not accesed if the declared length of the
         supplied string is 1 character.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASFIX
}{
   Modify the WCS FrameSet of an NDF to take account of
   re-gridding the pixel array
}{
   \sstdescription{
      This routine copies the WCS FrameSet from NDF1 to NDF2, re-mapping
      the PIXEL Frame using the specified Mapping in the process. It should
      be used to set up the WCS FrameSet of a newly created output NDF
      which has been formed by applying a geometric transformation to an
      input NDF.
   }
   \sstinvocation{
      CALL KPG1\_ASFIX( MAP, INDF1, INDF2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         MAP = INTEGER (Given)
      }{
         An AST Mapping from pixel co-ordinates in the INDF1 to pixel
         co-ordinates in INDF2.
      }
      \sstsubsection{
         INDF1 = INTEGER (Given)
      }{
         The input NDF.
      }
      \sstsubsection{
         INDF2 = INTEGER (Given)
      }{
         The output NDF. Any existing WCS FrameSet is discarded and
         replaced by a re-mapped copy of the WCS FrameSet from the input
         NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASFRM
}{
   Set the current Frame in a FrameSet to a Frame specified through
   the environment
}{
   \sstdescription{
      This routine allows the user to specify a new Current Frame for a
      FrameSet using an environment parameter.
   }
   \sstinvocation{
      CALL KPG1\_ASFRM( PARAM, EPARAM, IWCS, WCDOM, DCDOM, PROMPT, TOKEN,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of parameter to use to get Frame description.
      }
      \sstsubsection{
         EPARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of parameter to use to get Epoch value (if needed).
      }
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         An AST pointer to the FrameSet.
      }
      \sstsubsection{
         WCDOM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The Domain name to use if the user requests {\tt "}WORLD{\tt "} co-ordinates.
         No translation of WORLD takes place if a blank value is supplied.
      }
      \sstsubsection{
         DCDOM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The Domain name to use if the user requests {\tt "}DATA{\tt "} co-ordinates.
         No translation of DATA takes place if a blank value is supplied.
      }
      \sstsubsection{
         PROMPT = LOGICAL (Given)
      }{
         An error is always reported if the requested Frame is not
         available in the FrameSet. PROMPT controls what happens after
         the error has been reported. If .TRUE., then the error is
         flushed, the parameter is cancelled, and the user is re-prompted
         for a new \%PARAM value. Otherwise, the error is retained, and the
         routine exits with STATUS set to SAI\_\_ERROR.
      }
      \sstsubsection{
         TOKEN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A string containing an MSG message token reference (eg {\tt "}$\wedge$FRED{\tt "}).
         The value of the token is used within error messages and should
         describe the object (NDF, catalogue, etc) from which the supplied
         FrameSet is derived. If the token reference string is blank it is
         ignored.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine may add a new co-ordinate Frame into the FrameSet.

         \sstitem
         If the FrameSet contains more than one Frame with the requested
            Domain, then the last matching Frame in the FrameSet will be
            used (i.e. the one with highest index).
      }
   }
}
\sstroutine{
   KPG1\_ASGDP
}{
   Find a position with good output co-ordinates within a given input
   region of a supplied Mapping
}{
   \sstdescription{
      This routine finds a position which has good co-ordinates in the
      output Frame of the given Mapping, and returns both the input and
      output co-ordinates at this position. The position is constrained
      to lie within a specified box within the input Frame. The first
      point to be tested is the centre of the box. If this does not give
      valid output co-ordinates then a set of 10000 points randomly
      distributed within the box is tested. An error is reported if no
      good position can be found.
   }
   \sstinvocation{
      CALL KPG1\_ASGDP( MAP, NDIM1, NDIM2, LBND, UBND, INPOS, OUTPOS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         MAP = INTEGER (Given)
      }{
         The Mapping to use.
      }
      \sstsubsection{
         NDIM1 = INTEGER (Given)
      }{
         The number of input co-ordinates.
      }
      \sstsubsection{
         NDIM2 = INTEGER (Given)
      }{
         The number of output co-ordinates.
      }
      \sstsubsection{
         LBND( NDIM1 ) = DOUBLE PRECISION (Given)
      }{
         The lower bounds of the test box, within the input Frame of the
         supplied Mapping.
      }
      \sstsubsection{
         UBND( NDIM1 ) = DOUBLE PRECISION (Given)
      }{
         The upper bounds of the test box, within the input Frame of the
         supplied Mapping.
      }
      \sstsubsection{
         INPOS( NDIM1 ) = DOUBLE PRECISION (Returned)
      }{
         The returned input co-ordinates at the selected position.
         There will be no AST\_\_BAD values in this array.
      }
      \sstsubsection{
         OUTPOS( NDIM2 ) = DOUBLE PRECISION (Returned)
      }{
         The returned output co-ordinates at the selected position.
         There will be no AST\_\_BAD values in this array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASGET
}{
   Get an AST FrameSet from the WCS component of an NDF
}{
   \sstdescription{
      This routine determines the axes to be used from an NDF and returns a
      FrameSet representing the WCS information in the NDF.

      Each axis of the supplied NDF is checked to see if it is significant
      (i.e. has a size greater than 1).  The index of each significant axis
      is returned in SDIM, and the bounds of the axis are returned in SLBND
      and SUBND.  If EXACT is .TRUE., an error is reported if the number of
      significant axes is not exactly NDIM.  This mode is intended for case
      where (say) the user has supplied a single plane from a 3D data cube
      to an application which requires a 2D array.

      If EXACT is .FALSE. an error is only reported if the number of
      significant dimensions is higher than NDIM.  If there are less than
      NDIM significant dimensions then the insignificant dimensions are
      used (starting from the lowest) to ensure that the required number
      of dimensions are returned. This mode is intended for cases where (say)
      the user supplies a 1D data stream to an application which requires a
      2D array.

      The GRID Frame (i.e. the Base Frame) obtained from the NDFs WCS
      component is modified so that it has NDIM axes corresponding to the
      axes returned in SDIM (the value 1.0 is used for the other axes).

      Likewise, the PIXEL Frame obtained from the NDFs WCS component is
      modified so that it has NDIM axes corresponding to the axes returned
      in SDIM (the lower pixel bound is used for the other axes). The
      original PIXEL Frame is retained, but with Domain changed to
      NDF\_PIXEL.

      If TRIM is .TRUE., then the Current Frame obtained from the NDFs WCS
      component is also modified so that it has NDIM axes. If the original
      Current Frame has more than NDIM axes, then the axes to use are
      obtained from the environment using parameter USEAXIS. A new Current
      Frame is then made by picking these axes from the original Current
      Frame, assigning the value AST\_\_BAD to the axes which have not been
      chosen.

      If the original Current Frame has less than NDIM axes, then simple
      axes are added into the new Current Frame to make up a total of
      NDIM. These axes are given the value 1.0.
   }
   \sstinvocation{
      CALL KPG1\_ASGET( INDF, NDIM, EXACT, TRIM, REQINV, SDIM, SLBND, SUBND,
                       IWCS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         The identifier for the NDF.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of dimensions required by the application.
      }
      \sstsubsection{
         EXACT = LOGICAL (Given)
      }{
         Must the NDF have exactly NDIM significant axes? Otherwise it is
         acceptable for the NDIM axes to include some insignificant axes.
      }
      \sstsubsection{
         TRIM = LOGICAL (Given)
      }{
         Should the returned FrameSet be trimmed to ensure that the
         Current Frame has NDIM axes? Otherwise, the Current Frame read
         from the NDF is not changed.
      }
      \sstsubsection{
         REQINV = LOGICAL (Given)
      }{
         Is the inverse mapping (from Current Frame to Base Frame)
         required? If it is, an error is reported if the inverse mapping
         is not available. REQINV should be supplied .TRUE. in most cases.
      }
      \sstsubsection{
         SDIM( NDIM ) = INTEGER (Returned)
      }{
         The indices of the significant dimensions.
      }
      \sstsubsection{
         SLBND( NDIM ) = INTEGER (Returned)
      }{
         The lower pixel index bounds of the significant dimensions.  These
         are stored in the same order as the indices in SDIM.
      }
      \sstsubsection{
         SUBND( NDIM ) = INTEGER (Returned)
      }{
         The upper pixel index bounds of the significant dimensions.  These
         are stored in the same order as the indices in SDIM.
      }
      \sstsubsection{
         IWCS = INTEGER (Returned)
      }{
         An AST pointer to the WCS FrameSet. Returned equal to AST\_\_NULL
         if an error occurs. The Base Frame is an NDIM-dimensional GRID
         Domain.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the Current Frame in the returned FrameSet has no Title, then
         the Title is set to the value of the NDF TITLE component (so long
         as the NDF TITLE is not blank or undefined).
      }
   }
   \sstdiytopic{
      Parameters
   }{
      The name of the following environment parameter(s) are hard-wired
      into this subroutine in order to ensure conformity between application.

      USEAXIS = LITERAL (Read)
         A set of NDIM axes to be selected from the Current Frame. Each
         axis can be specified either by giving its index within the Current
         Frame in the range 1 to the number of axes in the Frame, or by
         giving its symbol. This parameter is only accessed if TRIM is
         .TRUE. and the original Current Frame in the supplied NDF has
         too many axes. The dynamic default selects the axes with the same
         indices as the selected NDF axes. The value should be given as a
         GRP group expression, with default control characters.
   }
}
\sstroutine{
   KPG1\_ASGFR
}{
   Reads a line of an AST Object description from a GRP group
}{
   \sstdescription{
      This routine reads a line of an AST Object description from a GRP
      group, removing the first character if it is a {\tt "}\#{\tt "} or a {\tt "}!{\tt "}. It then
      returns the line of text to the AST library using AST\_PUTLINE. It is
      intended to be used as a source function with AST\_CHANNEL.
   }
   \sstinvocation{
      CALL KPG1\_ASGFR( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASGFW
}{
   Writes a line of an AST Object description to a GRP group
}{
   \sstdescription{
      This routine writes a line of an AST Object description to a GRP
      group, optionally prepending it with the a given string. It is
      intended to be used as a sink function with AST\_CHANNEL.
   }
   \sstinvocation{
      CALL KPG1\_ASGFW( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASGRD
}{
   Draw a border or an annotated coordinate grid over an AST Plot
}{
   \sstdescription{
      This routine call AST\_BORDER to draw a border, or AST\_GRID to draw an
      annotated coordinate Grid over the supplied Plot. The current pgplot
      viewport can optionally be extended prior to drawing the grid so that
      it covers a specified AGI picture. If the pgplot viewport is left
      matching the plotting area supplied when the Plot was created, then
      certain component of the grid (i.e. exterior tick marks), are clipped
      by pgplot. To avoid this, IPIC should normally be given as the AGI
      identifier for the FRAME picture containing the plot.
   }
   \sstinvocation{
      CALL KPG1\_ASGRD( IPLOT, IPIC, GRID, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPLOT = INTEGER (Given)
      }{
         An AST pointer to the Plot.
      }
      \sstsubsection{
         IPIC = INTEGER (Given)
      }{
         An AGI identifier for the FRAME picture. Supply this as -1 if the
         current pgplot viewport is not to be changed.
      }
      \sstsubsection{
         GRID = LOGICAL (Read)
      }{
         Draw a grid using AST\_GRID? If .FALSE. then a border only is drawn
         (using AST\_BORDER).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The PGPLOT interface to the AGI library should be opened before
         calling this routine.
      }
   }
}
\sstroutine{
   KPG1\_ASGRP
}{
   Read spatial positions from a GRP group
}{
   \sstdescription{
      This routine reads formatted positions from a GRP group. The
      positions are assumed to be in the supplied Frame. Each element
      in the group should contain 1 position per line. Each position is
      given by a set of strings delimited by comma, space or tab (the
      first gives the value for axis 1, the second for axis 2, etc). The
      number of strings per element in the group should equal the number
      of axes in the Base Frame of the supplied FrameSet.

      An error is reported if any unreadable elements are found.
   }
   \sstinvocation{
      CALL KPG1\_ASGRP( PARAM, FRM, IGRP, NP, NAX, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of an environment parameter to use to get the indices of
         the columns within the text file which are to be used. If blank,
         the file must contain exactly NAX columns, all of which are used.
         If a null value is supplied, the dynamic default values will be
         used which is [1,2,3... NAX].
      }
      \sstsubsection{
         FRM = INTEGER (Given)
      }{
         A pointer to an AST Frame.
      }
      \sstsubsection{
         IGRP = INTEGER (Given)
      }{
         A GRP identifier for the group to read.
      }
      \sstsubsection{
         NP = INTEGER (Given)
      }{
         The number of positions which can be stored in the returned array.
      }
      \sstsubsection{
         NAX = INTEGER (Given)
      }{
         The number of axes in the supplied Frame.
      }
      \sstsubsection{
         OUT( NP, NAX ) = DOUBLE PRECISION (Returned)
      }{
         The array to hold the returned co-ordinates.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASIRA
}{
   Creates an AST FrameSet from an IRAS90 astrometry structure
}{
   \sstdescription{
      This routine creates an AST Frame describing the sky co-ordinates
      stored in an IRAS90 astrometry structure (see SUN/165), together with
      a Mapping from IRAS90 {\tt "}image co-ordinates{\tt "} to sky co-ordinates.
   }
   \sstinvocation{
      CALL KPG1\_ASIRA( IDA, FRM, MAP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine requires access to the IRA internal common blocks,
         and uses IRA internal subroutines.
      }
   }
}
\sstroutine{
   KPG1\_ASLOG
}{
   Take log base 10 of each axis value (an AST IntraMap routine)
}{
   \sstdescription{
      This routine transforms axis values by taking the logarithm (base
      10). The inverse exponentiates the supplied axis values. It is intended
      for use as a transformation routine by an AST IntraMap.
   }
   \sstinvocation{
      CALL KPG1\_ASLOG( THIS, NPOINT, NCOORD\_IN, INDIM, IN, FORWARD,
                       NCOORD\_OUT, OUTDIM, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Bad input co-ordinates will be set to AST\_\_BAD, but TRANSFORM uses
         VAL\_\_BADD to mark bad values. We assume here that VAL\_\_BADD and
         AST\_\_BAD are the same.
      }
   }
}
\sstroutine{
   KPG1\_ASMRG
}{
   Merge two FrameSets by aligning them in a common Frame
}{
   \sstdescription{
      This routine merges two FrameSet by aligning them in a suitable
      common Frame. The Current Frame in the second FrameSet becomes the
      Current Frame in the merged FrameSet. The domain search order for
      finding a suitable Frame is:

      1) The domain of the Current Frame in IWCS2, if not blank.
      2) {\tt "}SKY{\tt "}
      3) {\tt "}SPECTRUM{\tt "}
      4) {\tt "}PIXEL{\tt "}
      5) {\tt "}GRID{\tt "}
      6) The domain specified by argument DOMAIN, if not blank. If DOMAIN
         is blank, {\tt "}AGI\_WORLD{\tt "} is used.
      7) Any other suitable Frame.

      An error is reported if alignment is not possible, and a message
      identifying the alignment Frame is displayed if alignment is possible.
   }
   \sstinvocation{
      CALL KPG1\_ASMRG( IWCS1, IWCS2, DOMAIN, QUIET, IND, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IWCS1 = INTEGER (Given)
      }{
         An AST pointer to the first FrameSet. This is modified by adding
         all the Frames from IWCS2 into it. The Current Frame on exit is
         inherited from IWCS2.
      }
      \sstsubsection{
         IWCS2 = INTEGER (Given)
      }{
         An AST pointer to the second FrameSet. The Current and Base Frames
         are unchanged on exit.
      }
      \sstsubsection{
         DOMAIN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A comma separated list of domains in which alignment of the FrameSets
         should be attempted if alignment is not possible in the Current Frame
         of the second FrameSet, or SKY, SPECTRUM, PIXEL or GRID.
      }
      \sstsubsection{
         QUIET = LOGICAL (Given)
      }{
         Suppress the message identifying the alignment Frame?
      }
      \sstsubsection{
         IND = INTEGER (Given)
      }{
         The alignment message is padded with IND leading spaces.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASOFF
}{
   Find a position offset by a given distance from one position
   towards another position
}{
   \sstdescription{
      This routine returns the co-ordinates of a position which is a given
      distance along a curve joining one position to another position.
      The curve can be either be the geodesic or Euclidean curve joining
      the two points.
   }
   \sstinvocation{
      CALL KPG1\_ASOFF( FRAME, DIM, NAX, POS, I1, I2, GEO, DIS, OFFPOS,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FRAME = INTEGER (Given)
      }{
         An AST pointer to the Frame. Only accessed if GEO is .TRUE.
      }
      \sstsubsection{
         DIM = INTEGER (Given)
      }{
         The size of the first dimension of the POS array.
      }
      \sstsubsection{
         NAX = INTEGER (Given)
      }{
         The number of axes in the Frame.
      }
      \sstsubsection{
         POS( DIM, NAX ) = DOUBLE PRECISION (Given)
      }{
         An array holding the co-ordinates at DIM positions within the
         supplied Frame.
      }
      \sstsubsection{
         I1 = INTEGER (Given)
      }{
         The index of the first position, in the range 1 to DIM.
      }
      \sstsubsection{
         I2 = INTEGER (Given)
      }{
         The index of the second position, in the range 1 to DIM.
      }
      \sstsubsection{
         GEO = LOGICAL (Given)
      }{
         Is the geodesic distance required?
      }
      \sstsubsection{
         DIS = DOUBLE PRECISION (GIVEN)
      }{
         The distance to move away from position I1 towards position I2.
      }
      \sstsubsection{
         OFFPOS( NAX ) = DOUBLE PRECISION (Returned)
      }{
         The returned position.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   KPG1\_ASPLT
}{
   Create an AST Plot covering the current PGPLOT viewport
}{
   \sstdescription{
      This routine create a Plot civering the current PGPLOT viewport.
      The bounds of the PGPLOT window are changed if necessary to ensure
      that the PGPLOT world co-ordinate system corresponds to milliemtres
      from the bottom left corner of the view surface. This is the
      co-ordinate system used in the Base (GRAPHICS) Framre of the returned
      Plot.
   }
   \sstinvocation{
      CALL KPG1\_ASPLT(  IWCS, BOX, OPTS, IPLOT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         The FrameSet to include in the Plot. May be AST\_\_NULL.
      }
      \sstsubsection{
         BOX( 4 ) = DOUBLE PRECISION (Given)
      }{
         An array holding the bounds of the area within the Base Frame of
         IWCS which is to be mapped linearly onto the current PGPLOT
         viewport. The first pair of values should give the coordinates at
         the bottom left corner of the plotting area and the second pair
         should give the coordinates at the top right corner. The coordinate
         on the horizontal axis should be given first in each pair.
      }
      \sstsubsection{
         OPTS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A set of Plot attribute settings to be used when creating the
         Plot.
      }
      \sstsubsection{
         IPLOT = INTEGER (Returned)
      }{
         An AST pointer to the Plot. Returned equal to AST\_\_NULL if an
         error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The PGPLOT interface to the AGI library should be opened before
         calling this routine.
      }
   }
}
\sstroutine{
   KPG1\_ASPRP
}{
   Propagate the WCS component from one NDF to another with the same
   number of axes, allowing for a linear mapping of the pixel coordinates
}{
   \sstdescription{
      This routine copies the WCS FrameSet from INDF1, re-mapping the
      GRID Frame in the process so that pixel coordinates in the output
      NDF are related to pixel coordinates in the input NDF by the
      supplied linear transformation. The two NDFs must have the same
      number of axes (given by argument NDIM). The mapping from pixel
      coordinates in INDF1 ({\tt "}PIX1{\tt "}) to the corresponding pixel
      coordinates in INDF2 ({\tt "}PIX2{\tt "}) is:

         PIX2 = MATRIX . PIX1 $+$ OFFSET

      For instance, for NDIM = 2:

         X2 = MATRIX( 1, 1 ).X1 $+$ MATRIX( 2, 1 ).Y1 $+$ OFFSET( 1 )
         Y2 = MATRIX( 1, 2 ).X1 $+$ MATRIX( 2, 2 ).Y1 $+$ OFFSET( 2 )
   }
   \sstinvocation{
      CALL KPG1\_ASPRP( NDIM, INDF1, INDF2, MATRIX, OFFSET, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of dimensions. This should be the value returned by
         NDF\_BOUND, and should be the same for both INDF1 and INDF2.
      }
      \sstsubsection{
         INDF1 = INTEGER (Given)
      }{
         An identifier for the source NDF. This should have NDIM axes.
      }
      \sstsubsection{
         INDF2 = INTEGER (Given)
      }{
         An identifier for the destination NDF. This should also have NDIM
         axes.
      }
      \sstsubsection{
         MATRIX( NDIM, NDIM ) = DOUBLE PRECISION (Given)
      }{
         The matrix connecting PIX1 and PIX2.
      }
      \sstsubsection{
         OFFSET( NDIM ) = DOUBLE PRECISION (Given)
      }{
         The offset vector for PIX2.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASPSY
}{
   Establish synonyms for AST attribute names
}{
   \sstdescription{
      This routine establishes synonyms for AST attribute names or
      attribute qualifiers (qualifiers are strings in parenthesise following
      the attribute name - the {\tt "}graphical elements{\tt "} used by some Plot
      attributes are examples of qualifiers). The routine KPG1\_ASCHP is
      used to translated synonyms into values recognised by AST.

      Note, substitutions for synonyms are performed in the order in
      which they are defined, with later substitutions potentially
      modifying the results of earlier substitutions. For this reason,
      synonyms for specific name/qualifer pairs (eg {\tt "}FORMAT(VEC$*$TOR){\tt "} )
      should be defined $*$before$*$ synonyms for qualifiers alone (eg
      {\tt "}(VEC$*$TOR){\tt "} ). If these two examples were defined in the opposite
      order, then the qualifier in FORMAT(VEC) (i.e. {\tt "}VEC{\tt "}) would get
      replaced by the translation supplied for synonym {\tt "}(VEC$*$TOR){\tt "}, so
      that the resulting string would then fail to match the synonym
      {\tt "}FORMAT(VEC$*$TOR){\tt "} and so would not result in the correct translation.
   }
   \sstinvocation{
      CALL KPG1\_ASPSY( SYNON, TRAN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SYNON = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A synonym for an AST attribute name and/or qualifier. The
         supplied value is converted to upper case, and stripped of spaces.
         If the synonym contains just a qualifier (i.e. no attribute
         name), then KPG1\_ASCHP will substitute the qualifier from the
         translation irespective of the attribute name. Minimum
         abbreviations for attribute qualifiers may be given by including
         an asterisk in the qualifier to mark the end of the minimum
         abbreviation. If a blank value is supplied, then the resources used
         to store the synonyms and translations are released.
      }
      \sstsubsection{
         TRAN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The translation for the supplied synonym. This should be a legal
         AST attribute name/qualifier combination (but no check is made
         on this). The supplied value is converted to upper case, and
         stripped of spaces.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASPTP
}{
   Put a formatted AST position into a string
}{
   \sstdescription{
      This routine puts a formatted position into a text string starting
      at a specified index within the string. Axis symbols may optionally
      be included. The axis values are separated by a specified string.
   }
   \sstinvocation{
      CALL KPG1\_ASPTP( FRAME, NAX, POS, SYMBLS, SEP, TEXT, IAT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FRAME = INTEGER (Given)
      }{
         The Frame in which the position is defined.
      }
      \sstsubsection{
         NAX = INTEGER (Given)
      }{
         The number of axes in the Frame.
      }
      \sstsubsection{
         POS( NAX ) = DOUBLE PRECISION (Given)
      }{
         The position to format.
      }
      \sstsubsection{
         SYMBLS = LOGICAL (Given)
      }{
         Are axis symbols to be included? If so, each axis value is
         formatted with a {\tt "}symbol=value{\tt "} string.
      }
      \sstsubsection{
         SEP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The separator for axis values. Trailing spaces are significant.
      }
      \sstsubsection{
         TEXT = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The text to hold the formatted values.
      }
      \sstsubsection{
         IAT = INTEGER (Given and Returned)
      }{
         On entry, the index of the last character before the point at
         which the text is to be placed. On exit, the index of the last
         character written by this routine.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASREF
}{
   Associates an NDF optionally from a reference name or locator
}{
   \sstdescription{
      This routine obtains an NDF.  There is a search path of sources
      for the NDF checked in the following order: a) command line, b) a
      reference locator or name, c) elsewhere in the parameter system
      (usually by prompting.)  For a) and c) the NDF is obtained by
      association.  For b) a locator or name is imported into the NDF\_
      system; an error will result if the locator does not point to a
      valid NDF.  The role of this routine is to permit automatic
      processing of NDFs associated with database pictures.  The
      command-line access allows the NDF reference stored with the last
      DATA picture to be overridden.
   }
   \sstinvocation{
      CALL KPG1\_ASREF( PNNDF, MODE, GOTNAM, NAME, NDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNNDF = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the Starlink parameter to be associated with the
         input NDF.
      }
      \sstsubsection{
         MODE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Access mode to the NDF required: {\tt '}READ{\tt '} or {\tt '}UPDATE{\tt '}.
      }
      \sstsubsection{
         GOTNAM = LOGICAL (Given)
      }{
         If .TRUE., a name or locator to a potential NDF has already
         been obtained and is supplied to this routine through the NAME
         argument.  The name or locator may come from a reference in
         the graphics database.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the potential NDF, or a locator to it.
      }
      \sstsubsection{
         NDF = INTEGER (Returned)
      }{
         The identifier to the NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         The parameter should not have been associated before calling
         this routine.
      }
   }
}
\sstroutine{
   KPG1\_ASREG
}{
   Register all AST IntraMaps known by KAPPA
}{
   \sstdescription{
      This routine registers all AST IntraMaps known to KAPPA. It should
      be called before any AST routine which may use an IntraMap (such
      as a transformation routine, plotting routine, read/write routine,
      etc).
   }
   \sstinvocation{
      CALL KPG1\_ASSMP( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   KPG1\_ASSET
}{
   Allow the user to spcify attribute values for an AST Object
}{
   \sstdescription{
      This routine allows the user to set attributes for an AST Object (see
      SUN/210). The value to which an attribute is set in the returned
      Object is determined as follows:

      \sstitemlist{

         \sstitem
         If the user supplies a value for the attribute using the given
         parameter, then the Object is returned with the attribute set to the
         supplied value. The user supplies the attribute values as a GRP
         group expression in which each element is an AST attribute setting.

         \sstitem
         Otherwise, if the Object already had an explicit value set for the
         attribute on entry (i.e. if AST\_TEST returns .TRUE. for the
         attribute), then the value is unchanged on exit.

         \sstitem
         Otherwise, a search is made for a default value for the attribute
         using the search path described below. If a default value is found
         for the attribute then the Object is returned with the attribute set
         to the default value. The use of these defaults can be suppressed
         by including the string {\tt "}CLEAR{\tt "} as the first element in the group of
         attribute values supplied for the specified environment parameter.

      }
      Defaults are specified as a group of attribute setting strings within a
      {\tt "}defaults{\tt "} text file. This file is found using the following search
      path:

      1) If the environment variable $<$APP$>$\_$<$PARAM$>$ is defined ($<$APP$>$ and
      $<$PARAM$>$ in upper case), its value is taken to be the full path to
      the defaults file.

      2) If $<$APP$>$\_$<$PARAM$>$ is not defined, the file \$HOME/$<$app$>$\_$<$param$>$.def
      is used ($<$app$>$ and $<$param$>$ in lower case).

      3) If the file \$HOME/$<$app$>$\_$<$param$>$.def cannot be accessed, the file
      \$KAPPA\_DIR/$<$app$>$\_$<$param$>$.def is used.

      4) If the file \$KAPPA\_DIR/$<$app$>$\_$<$param$>$.def cannot be accessed, the
      value of environment variable KAPPA\_$<$PARAM$>$ is taken to be the full
      path to the defaults file.

      5) If KAPPA\_$<$PARAM$>$ is not defined, the file \$HOME/kappa\_$<$param$>$.def
      is used.

      6) If the file \$HOME/kappa\_$<$param$>$.def cannot be accessed, the file
      \$KAPPA\_DIR/kappa\_$<$param$>$.def is used.

      Each attribute setting within a group of settings should be of the
      form {\tt "}$<$name$>$=$<$value$>${\tt "}, where $<$name$>$ is taken to be the name of a
      Object attribute (or synonym set by KPG1\_ASPSY), and $<$value$>$ is taken
      to be the value to assign to the attribute. These attributes are
      described in SUN/210. No error is reported if unrecognised attribute
      names or illegal attribute values are specified.

      Before being used, the attribute settings are edited to replace any
      synonyms by their corresponding AST attribute names established by
      earlier calls to KPG1\_ASPSY. Colour names are also replaced by
      corresponding PGPLOT colour indices.
   }
   \sstinvocation{
      CALL KPG1\_ASSET( APP, PARAM, IOBJ, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         APP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the calling application in the form
         $<$package$>$\_$<$application$>$ (eg {\tt "}KAPPA\_DISPLAY{\tt "}), for use in messages.
      }
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use for getting the group expression.
      }
      \sstsubsection{
         IOBJ = INTEGER (Given and Returned)
      }{
         An AST pointer to the Object to be modified. Returned unchanged if
         an error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Colour attribute values may be supplied in any form recognised
         by KPG1\_PGCOL (eg colour name, MIN, MAX, integer index, etc), and
         the nearest colour in the current KAPPA pallette is used.

         \sstitem
         If a null value is supplied for the parameter, the error is
         annulled and the Object is returned unchanged (except for any
         defaults obtained using the usual search path).
      }
   }
}
\sstroutine{
   KPG1\_ASSHR
}{
   Shrink a Plot so that it covers an area which allows all annotation
   to fit within the specified area
}{
   \sstdescription{
      This routine creates a new Plot covering the same window as the
      current PGPLOT window, but thw window is shrunk in GRAPHICS space
      so that all the annotation produced by AST\_GRID falls within the PGPLOT
      viewport which is current on entry. The sizes of annotations, gaps,
      etc are shrunk if this is necessary in order to fit the annotations
      within the current PGPLOT viewport.
   }
   \sstinvocation{
      CALL KPG1\_ASSHR( ASP, F, X1, X2, Y1, Y2, JUST, IPLOT, OK, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         ASP = LOGICAL (Given)
      }{
         The aspect ratio of the required plotting area (i.e. excluding
         annotation) after shrinking. If this is zero or negative, the
         largest possible area is used for the plotting area.
      }
      \sstsubsection{
         F = REAL (Given)
      }{
         An amount by which to extend the margins left for annotation,
         expressed as a factor of the height or width of the plotting
         area. For instance, a value of 0.1 could be given to fit the
         annotation {\tt "}comfortably{\tt "} into the Plot. A value of 0.0 will
         result in the annotation being hard up against the edge of the
         plot.
      }
      \sstsubsection{
         X1 = REAL (Given)
      }{
         The GRAPHICS X co-ordinate at the left edge of the area into
         which the annotation is to fit.
      }
      \sstsubsection{
         X2 = REAL (Given)
      }{
         The GRAPHICS X co-ordinate at the right edge of the area into
         which the annotation is to fit.
      }
      \sstsubsection{
         Y1 = REAL (Given)
      }{
         The GRAPHICS Y co-ordinate at the bottom edge of the area into
         which the annotation is to fit.
      }
      \sstsubsection{
         Y2 = REAL (Given)
      }{
         The GRAPHICS Y co-ordinate at the top edge of the area into
         which the annotation is to fit.
      }
      \sstsubsection{
         JUST = CHARACTER$*$2 (Given)
      }{
         Indicates the justification of the new plot within the specified
         area.  {\tt '}BL{\tt '}, {\tt '}BC{\tt '}, {\tt '}BR{\tt '}, {\tt '}CL{\tt '}, {\tt '}CC{\tt '}, {\tt '}CR{\tt '}, {\tt '}TL{\tt '}, {\tt '}TC{\tt '} or {\tt '}TR{\tt '},
         where B is Bottom, C is Centre, T is Top, L is Left and R is
         Right. Only used if ASP $>$ 0. Must be upper case. Unrecognised
         values are treated as {\tt "}C{\tt "}.
      }
      \sstsubsection{
         IPLOT = INTEGER (Given and Returned)
      }{
         The Plot. The supplied Plot is annulled and a new one is
         returned in its place. The new Plot contains all the Frames of
         the supplied Plot, but its Plot attributes are all cleared. It may
         be necessary for the caller to re-instate these attributes.
      }
      \sstsubsection{
         OK = LOGICAL (Returned)
      }{
         Returned .FALSE. if there was insufficient room for the required
         Plot. No error is reported in this case, and IPLOT os returned
         unchanged.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASSIG
}{
   Ensure that the Current Frame from an NDF WCS FrameSet has no
   insignificant axes
}{
   \sstdescription{
      This routine looks for insignificant axes in the Current Frame of
      the supplied WCS FrameSet (an axis is insignificant if all pixels
      within the NDF pixel array has the same position on the axis). If
      any insignificant axes are found, a new Frame is added to the
      FrameSet containing only the significant axes from the Current Frame.
      This new Frame is added into the FrameSet and becomes the new
      Current Frame. The PermMap which connects it to the original
      Current Frame assigns the correct constant values to the
      insignificant axes whn used in the inverse direction.
   }
   \sstinvocation{
      CALL KPG1\_ASSIG( IWCS, NDIM, LBND, UBND, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         The WCS FrameSet from the NDF, as returned by KPG1\_GTWCS.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of dimensions in the NDF, as returned by NDF\_BOUND.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Returned)
      }{
         The lower pixel index bounds of the NDF, as returned by NDF\_BOUND.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Returned)
      }{
         The upper pixel index bounds of the NDF, as returned by NDF\_BOUND.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASSIM
}{
   Simplify a Plot
}{
   \sstdescription{
      This routine simplifies a Plot by adding a copy of the Current
      Frame into it, using a simplified version of the Mapping from
      Base to Current Frame. The new Frame becomes the Current Frame.

      This routine should be called before doing any plotting with a
      Plot in order to avoid the possiblity of intermediate Frames
      being used in which positions are undefined.

      Care should be taken decding where to call this routine since
      the simplification process can be expensive. Do not call it within
      a deep nested loop!
   }
   \sstinvocation{
      CALL KPG1\_ASSIM( IPLOT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPLOT = INTEGER (Given)
      }{
         An AST pointer to the Plot.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASSIR
}{
   Set the attributes of a SkyFrame to match an IRAS90 SCS
}{
   \sstdescription{
      This routine modifies the supplied skyframe so that it describes
      the celestial co-ordinate system given by the supplied IRAS90 {\tt "}Sky
      Co-ordinate System{\tt "} specified (see SUN/163). A .FALSE. function value
      is returned if the supplied string is not a valid IRAS90 SCS, but no
      error is reported.
   }
   \sstinvocation{
      RESULT = KPG1\_ASSIR( FRM, SCS, PEP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         KPG1\_ASSIR = LOGICAL
      }{
         .TRUE. if the supplied SCS string was a valid IRAS90 Sky
         Co-ordinate System specifier, and ,FALSE. otherwise.
      }
   }
}
\sstroutine{
   KPG1\_ASSMP
}{
   Returns co-ordinates at evenly spaces positions along a given
   poly-line
}{
   \sstdescription{
      This routine returns an a pointer to an array holding the
      co-ordinates at a set of NSAMP positions evenly spaced along a
      poly-line defined by NPOS {\tt "}profile positions{\tt "}.
   }
   \sstinvocation{
      CALL KPG1\_ASSMP( FRAME, ARRDIM, NAX, NPOS, POS, GEO, NSAMP, SAMP,
                       DELTA, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FRAME = INTEGER (Given)
      }{
         An AST pointer to the Frame in which the polyline is defined. This
         is used to define geodesic curves joining the supplied profile
         positions. Only accessed if GEO is .TRUE.
      }
      \sstsubsection{
         ARRDIM = INTEGER (Given)
      }{
         The size of the first dimension of POS.
      }
      \sstsubsection{
         NAX = INTEGER (Given)
      }{
         The number of axes in the Frame.
      }
      \sstsubsection{
         NPOS = INTEGER (Given)
      }{
         The number of profile positions defining the poly-line. This
         must be less than or equal to ARRDIM.
      }
      \sstsubsection{
         POS( ARRDIM, NAX ) = DOUBLE PRECISION (Given)
      }{
         The profile positions. The first axis indexes the position
         number, and the first NPOS elements should be used. The second
         axis indexes the axis number. An error is reported if any
         invalid positions are supplied.
      }
      \sstsubsection{
         GEO = LOGICAL (Given)
      }{
         Should the poly-line be constructed from geodesic curves in the
         supplied Frame? If not, the poly-line is made up of straight line
         segments in the supplied Frame.
      }
      \sstsubsection{
         NSAMP = INTEGER (Given)
      }{
         The number of samples required along the poly-line.
      }
      \sstsubsection{
         DELTA = DOUBLE PRECISION (Given and Returned)
      }{
         The increment between samples. If not known, this should be set
         to zero. Returned holding the used increment.
      }
      \sstsubsection{
         SAMP( NSAMP, NAX ) = DOUBLE PRECISION (Returned)
      }{
         The array holding the sample positions.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   KPG1\_ASSPL
}{
   Get a set of 1-d Mappings for each axis in a FrameSet
}{
   \sstdescription{
      This routine returns a set of AST Mapping pointers. Each Mapping
      has 1 input and 1 output. The I{\tt '}th Mapping goes from axis I in the
      Base Frame of the supplied FrameSet, to axis I in the Current Frame
      of the FrameSet.

      There should usually be a one-to-one correspondance between the
      axes in the Base and Current Frames in the FrameSet.
   }
   \sstinvocation{
      CALL KPG1\_ASSPL( IWCS, MXAX, MAP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         The AST pointer to the FrameSet.
      }
      \sstsubsection{
         MXAX = INTEGER (Given)
      }{
         The maximum number of mappings to be returned. Un-used elements
         are returned holding AST\_\_NULL.
      }
      \sstsubsection{
         MAP( MXAX ) = INTEGER (Returned)
      }{
         The Mapping pointers.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ASSTS
}{
   Apply an attribute setting to a Plot
}{
   \sstdescription{
      This routine applies the supplied attribute setting to the supplied
      Plot. The attribute setting should be of the form {\tt "}name=value{\tt "} where
      {\tt "}name{\tt "} is an AST attribute name or a synonym for an AST attribute
      name established by a call to KPG1\_ASPSY, and {\tt "}value{\tt "} is the value
      to assign to the attribute. If the attribute name contains either COLOR
      or COLOUR then the value string is checked to see if it is the name
      of a colour, and if so, the corresponding colour index is used
      instead. The resulting setting, after translation of synonyms and
      colour names is applied to the supplied Plot. If the Plot already
      has a set value for the specified attribute, then the behaviour depends
      on OVER; if OVER is .TRUE. then the new attribute value over-writes
      the value already in the Plot; if OVER is .FALSE. then the supplied
      setting is ignored.
   }
   \sstinvocation{
      CALL KPG1\_ASSTS( SETTNG, REPORT, OVER, IPLOT, BADAT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SETTING = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The attribute setting string.
      }
      \sstsubsection{
         REPORT = LOGICAL (Given)
      }{
         Should an error be reported if the attribute setting string
         is not legal?
      }
      \sstsubsection{
         OVER = LOGICAL (Given)
      }{
         Over-write existing attribute values in the Plot?
      }
      \sstsubsection{
         IPLOT = INTEGER (Given)
      }{
         An AST pointer to the Plot to be modified.
      }
      \sstsubsection{
         BADAT = LOGICAL (Given)
      }{
         Was the setting string invalid? If so, an appropriate error
         message will have been reported (unless REPORT is .FALSE.).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Colour attribute values may be supplied in any form recognised
         by KPG1\_PGCOL (eg colour name, MIN, MAX, integer index, etc), and
         the nearest colour in the current KAPPA pallette is used.
      }
   }
}
\sstroutine{
   KPG1\_ASSTY
}{
   Check for synonyms and colour names in AST attribute settings
}{
   \sstdescription{
      This routine splits the supplied AST attribute setting string up
      into a name and a value, replacing synonyms for AST attribute names
      or qualifiers with the corresponding AST names and qualifiers, and
      replacing colour names within the attribute value with corresponding
      PGPLOT colour indices. Synonyms for AST attribute names or
      qualifiers are set up using KPG1\_ASPSY.

      Matching of attribute names and attribute qualifiers are performed
      separately. The names are matched first. An attempt to match any
      supplied attribute qualifier against a synonym is only made if the
      attribute names match, or if the synonym does not contain an
      attribute name. Synonyms may specify minimum abbreviations for
      attribute qualifiers by including an asterisk within the qualifier
      string. The asterisk marks the end of the minimum abbreviation.
   }
   \sstinvocation{
      CALL KPG1\_ASSTY( SETTNG, NAME, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SETTNG = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The text to be checked, potetially containing synonyms and
         colour names.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The corresponding AST attribute name (with a possible qualifier).
      }
      \sstsubsection{
         VALUE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The corresponding AST attribute value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_AST2H
}{
   Copy AST\_ data to an HDS object
}{
   \sstdescription{
      This routine copies a line of text representing AST\_ data into a
      specified element of a 1-dimensional character array. It is
      intended for use when writing AST\_ data to an HDS object (i.e an
      HDS \_CHAR array).
   }
   \sstinvocation{
      CALL KPG1\_AST2H( DATA, ILINE, LINE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DATA( $*$ ) = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The character array into which the text is to be copied.
      }
      \sstsubsection{
         ILINE = INTEGER (Given)
      }{
         The index of the element in DATA which is to receive the text
         (the contents of other elements are returned unchanged).
      }
      \sstsubsection{
         LINE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The line of text to be inserted.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      This routine departs from the conventional argument order so as to
      accommodate the case where the DATA argument is a mapped HDS
      character array.
   }
}
\sstroutine{
   KPG1\_AVLUT
}{
   Associates, validates and maps an lookup table stored in an NDF
}{
   \sstdescription{
      This routine associates for read access an NDF that is presumed
      to contain a lookup table in its data array.  A series of
      validation checks are made: the array must be 2-dimensional, the
      first dimension must be 3, the range of values must lie in the
      range 0.0--1.0.  The last of these requires that the data array
      is mapped therefore for convenience and efficiency a pointer and
      length are returned.  The lookup table mapped with type \_REAL.
   }
   \sstinvocation{
      CALL KPG1\_AVLUT( PNLUT, NDFL, PNTRI, EL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNLUT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The ADAM parameter to be associated with the NDF.
      }
      \sstsubsection{
         NDFL = INTEGER (Returned)
      }{
         The identifier for the NDF containing the lookup table.
      }
      \sstsubsection{
         PNTRI( 1 ) = INTEGER (Returned)
      }{
         The pointer to the mapped NDF lookup table.
      }
      \sstsubsection{
         EL = INTEGER (Returned)
      }{
         The length of the mapped NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_AXANO
}{
   Generates an axis annotation from the NDF{\tt '}s axis label and units
}{
   \sstdescription{
      This routine examines a nominated axis for a label and units.
      It creates a string of the form {\tt "}label (units){\tt "} or {\tt "}label{\tt "} if the
      label but not the units are present.  If neither are present a
      supplied default is returned instead.
   }
   \sstinvocation{
      CALL KPG1\_AXANO( NDF, IAXIS, DEFAUL, AXSLAB, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDF = INTEGER (Given)
      }{
         The NDF identifier.
      }
      \sstsubsection{
         IAXIS = INTEGER (Given)
      }{
         The number of the axis whose character components are to be
         used.
      }
      \sstsubsection{
         DEFAUL = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A default to return in AXSLAB should there be no axis label.
      }
      \sstsubsection{
         AXSLAB = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The axis annotation.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         The identifier should be associated with an NDF.
      }
   }
}
\sstroutine{
   KPG1\_AXBNx
}{
   Find the bounds of an NDF{\tt '}s axis centre co-ordinates
}{
   \sstdescription{
      This routine determines the lowest and highest centre
      co-ordinate for an NDF axis array component.  Currently, it
      assumes that these will be the first and last elements.
   }
   \sstinvocation{
      CALL KPG1\_AXBNx( EL, CENTRE, AXLCO, AXUCO, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the axis.
      }
      \sstsubsection{
         CENTRE( EL ) = ? (Given)
      }{
         The NDF axis centre co-ordinates.
      }
      \sstsubsection{
         AXLCO = ? (Returned)
      }{
         The lowest centre co-ordinates for the axis.
      }
      \sstsubsection{
         AXUCO = ? (Returned)
      }{
         The highest centre co-ordinate for the axis.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the data types real or double precision:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively, as
         appropriate.  The centre array and the returned values
         should have this data type as well.
      }
   }
}
\sstroutine{
   KPG1\_AXBNx
}{
   Find the bounds of an NDF{\tt '}s axis centre co-ordinates
}{
   \sstdescription{
      This routine determines the lowest and highest centre
      co-ordinate for an NDF axis array component.  Currently, it
      assumes that these will be the first and last elements.
   }
   \sstinvocation{
      CALL KPG1\_AXBNx( EL, CENTRE, AXLCO, AXUCO, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the axis.
      }
      \sstsubsection{
         CENTRE( EL ) = ? (Given)
      }{
         The NDF axis centre co-ordinates.
      }
      \sstsubsection{
         AXLCO = ? (Returned)
      }{
         The lowest centre co-ordinates for the axis.
      }
      \sstsubsection{
         AXUCO = ? (Returned)
      }{
         The highest centre co-ordinate for the axis.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the data types real or double precision:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively, as
         appropriate.  The centre array and the returned values
         should have this data type as well.
      }
   }
}
\sstroutine{
   KPG1\_AXCOx
}{
   Obtains for an axis the axis indices given their values
}{
   \sstdescription{
      This routine determines floating-point axis indices within an axis
      array for a series of pixel co-ordinates.  It assumes that the
      array is monotonic and approximately linear, since it uses linear
      interpolation to derive the pixel indices.  This routine may be
      used for arbitrary 1-d arrays in addition to axes, provided this
      criterion is met.
   }
   \sstinvocation{
      CALL KPG1\_AXCOx( LBND, UBND, AXIS, EL, VALUE, INDEX, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The lower bound of the axis array.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The upper bound of the axis array.
      }
      \sstsubsection{
         AXIS( LBND:UBND ) = ? (Given)
      }{
         The axis array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of indices whose values in the axis array are to be
         found.
      }
      \sstsubsection{
         VALUE( EL ) = ? (Given)
      }{
         The axis-array values.
      }
      \sstsubsection{
         INDEX( EL ) = ? (Returned)
      }{
         The pixel co-ordinates of the values in the axis array.
         Notice that this is in floating point as fractional positions
         may be returned.  An index is set to the bad value when its
         input co-ordinate lies outside the range of co-ordinates in
         the axis.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the data types real or double precision:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively, as
         appropriate.  The axis array and co-ordinates, and the returned
         indices should have this data type as well.

         \sstitem
         An error report is made and bad status returned should any
         input co-ordinate lie outside the range of co-ordinates of
         the axis.  Processing will continue through the list.
      }
   }
}
\sstroutine{
   KPG1\_AXCOx
}{
   Obtains for an axis the axis indices given their values
}{
   \sstdescription{
      This routine determines floating-point axis indices within an axis
      array for a series of pixel co-ordinates.  It assumes that the
      array is monotonic and approximately linear, since it uses linear
      interpolation to derive the pixel indices.  This routine may be
      used for arbitrary 1-d arrays in addition to axes, provided this
      criterion is met.
   }
   \sstinvocation{
      CALL KPG1\_AXCOx( LBND, UBND, AXIS, EL, VALUE, INDEX, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The lower bound of the axis array.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The upper bound of the axis array.
      }
      \sstsubsection{
         AXIS( LBND:UBND ) = ? (Given)
      }{
         The axis array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of indices whose values in the axis array are to be
         found.
      }
      \sstsubsection{
         VALUE( EL ) = ? (Given)
      }{
         The axis-array values.
      }
      \sstsubsection{
         INDEX( EL ) = ? (Returned)
      }{
         The pixel co-ordinates of the values in the axis array.
         Notice that this is in floating point as fractional positions
         may be returned.  An index is set to the bad value when its
         input co-ordinate lies outside the range of co-ordinates in
         the axis.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the data types real or double precision:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively, as
         appropriate.  The axis array and co-ordinates, and the returned
         indices should have this data type as well.

         \sstitem
         An error report is made and bad status returned should any
         input co-ordinate lie outside the range of co-ordinates of
         the axis.  Processing will continue through the list.
      }
   }
}
\sstroutine{
   KPG1\_AXEXx
}{
   Calculates the extent of an NDF along an axis
}{
   \sstdescription{
      This routine calculates the starting and ending positions of an
      NDF{\tt '}s pixels along an axis, optionally taking account of the
      axis width and error values.
   }
   \sstinvocation{
      CALL KPG1\_AXEXx( EL, CENTRE, USEERR, ERROR, USEWID, WIDTH,
                       NSIGMA, ASTART, AEND, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the axis arrays.
      }
      \sstsubsection{
         CENTRE( EL ) = ? (Given)
      }{
         The centres of the pixels on the axis.
      }
      \sstsubsection{
         USEERR = LOGICAL (Given)
      }{
         Use the error array and NSIGMA in the calculation of the
         extent of the axis.
      }
      \sstsubsection{
         ERROR( EL ) = ? (Given)
      }{
         The errors of the pixel centres on the axis.  It is only
         required (accessed) when USEERR = .TRUE..
      }
      \sstsubsection{
         USEWID = LOGICAL (Given)
      }{
         Use the width array in the calculation of the extent of the
         axis.
      }
      \sstsubsection{
         WIDTH( EL ) = ? (Given)
      }{
         The widths of the pixels on the axis.
      }
      \sstsubsection{
         NSIGMA = ? (Given)
      }{
         Number of multiples of the error to use in the calculation
      }
      \sstsubsection{
         ASTART = ? (Returned)
      }{
         If the axis centre positions increase with NDF pixel index,
         this argument returns the axis position of the edge of the
         first pixel which has the lower co-ordinate. Otherwise it
         returns the axis position of the edge with the higher
         co-ordinate.
      }
      \sstsubsection{
         AEND = ? (Returned)
      }{
         If the axis centre positions increase with NDF pixel index,
         this argument returns the axis position of the edge of the
         last pixel which has the higher co-ordinate. Otherwise it
         returns the axis position of the edge with the lower
         co-ordinate.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_AXEXx
}{
   Calculates the extent of an NDF along an axis
}{
   \sstdescription{
      This routine calculates the starting and ending positions of an
      NDF{\tt '}s pixels along an axis, optionally taking account of the
      axis width and error values.
   }
   \sstinvocation{
      CALL KPG1\_AXEXx( EL, CENTRE, USEERR, ERROR, USEWID, WIDTH,
                       NSIGMA, ASTART, AEND, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the axis arrays.
      }
      \sstsubsection{
         CENTRE( EL ) = ? (Given)
      }{
         The centres of the pixels on the axis.
      }
      \sstsubsection{
         USEERR = LOGICAL (Given)
      }{
         Use the error array and NSIGMA in the calculation of the
         extent of the axis.
      }
      \sstsubsection{
         ERROR( EL ) = ? (Given)
      }{
         The errors of the pixel centres on the axis.  It is only
         required (accessed) when USEERR = .TRUE..
      }
      \sstsubsection{
         USEWID = LOGICAL (Given)
      }{
         Use the width array in the calculation of the extent of the
         axis.
      }
      \sstsubsection{
         WIDTH( EL ) = ? (Given)
      }{
         The widths of the pixels on the axis.
      }
      \sstsubsection{
         NSIGMA = ? (Given)
      }{
         Number of multiples of the error to use in the calculation
      }
      \sstsubsection{
         ASTART = ? (Returned)
      }{
         If the axis centre positions increase with NDF pixel index,
         this argument returns the axis position of the edge of the
         first pixel which has the lower co-ordinate. Otherwise it
         returns the axis position of the edge with the higher
         co-ordinate.
      }
      \sstsubsection{
         AEND = ? (Returned)
      }{
         If the axis centre positions increase with NDF pixel index,
         this argument returns the axis position of the edge of the
         last pixel which has the higher co-ordinate. Otherwise it
         returns the axis position of the edge with the lower
         co-ordinate.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_AXGVx
}{
   Find the first axis centre co-ordinate of an NDF above a
   threshold
}{
   \sstdescription{
      This routine determines the element number and value of the first
      axis centre co-ordinate of an NDF above a given threshold.
      Currently, it assumes that the centre values increase or decrease
      monotonically from the first to the last elements.

      A SAI\_\_ERROR status is returned when no centre value exceeds the
      threshold.
   }
   \sstinvocation{
      CALL KPG1\_AXGVx( EL, CENTRE, THRESH, ITH, VALTH, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the axis.
      }
      \sstsubsection{
         CENTRE( EL ) = ? (Given)
      }{
         The NDF axis centre co-ordinates.
      }
      \sstsubsection{
         THRESH = ? (Given)
      }{
         The threshold.
      }
      \sstsubsection{
         ITH = INTEGER (Returned)
      }{
         The index number of the element that first exceeds the
         threshold, or its negative when the co-ordinates decrease with
         increasing element number.
      }
      \sstsubsection{
         VALTH = ? (Returned)
      }{
         The centre co-ordinate that first exceeds the threshold.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision data types:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively.  The
         array and threshold supplied to the routine plus the co-ordinate
         that first exceeds the threshold must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_AXGVx
}{
   Find the first axis centre co-ordinate of an NDF above a
   threshold
}{
   \sstdescription{
      This routine determines the element number and value of the first
      axis centre co-ordinate of an NDF above a given threshold.
      Currently, it assumes that the centre values increase or decrease
      monotonically from the first to the last elements.

      A SAI\_\_ERROR status is returned when no centre value exceeds the
      threshold.
   }
   \sstinvocation{
      CALL KPG1\_AXGVx( EL, CENTRE, THRESH, ITH, VALTH, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the axis.
      }
      \sstsubsection{
         CENTRE( EL ) = ? (Given)
      }{
         The NDF axis centre co-ordinates.
      }
      \sstsubsection{
         THRESH = ? (Given)
      }{
         The threshold.
      }
      \sstsubsection{
         ITH = INTEGER (Returned)
      }{
         The index number of the element that first exceeds the
         threshold, or its negative when the co-ordinates decrease with
         increasing element number.
      }
      \sstsubsection{
         VALTH = ? (Returned)
      }{
         The centre co-ordinate that first exceeds the threshold.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision data types:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively.  The
         array and threshold supplied to the routine plus the co-ordinate
         that first exceeds the threshold must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_AXLIx
}{
   Determines whether an array{\tt '}s values are equally spaced
}{
   \sstdescription{
      This routine determines whether or not adjacent elements of a
      1-d array have values that are equally spaced, i.e. it tests for
      linearity.  It simply checks if the intervals between all
      successive pairs of elements are the same within the machine
      precision.
   }
   \sstinvocation{
      CALL KPG1\_AXLIx( EL, ARRAY, LVAL, UVAL, LINEAR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array.  It must be at least
         two.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         The array to be tested.
      }
      \sstsubsection{
         LVAL = ? (Returned)
      }{
         Value of the first array element.  If this is bad an estimated
         value is substituted when the array is linear.
      }
      \sstsubsection{
         UVAL = ? (Returned)
      }{
         Value of the last array element.  If this is bad an estimated
         value is substituted when the array is linear.
      }
      \sstsubsection{
         LINEAR = LOGICAL (Returned)
      }{
         True if the array is linear.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for most numeric data types: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, or UW as appropriate.  The array
         (and the variables for the first and last array elements) supplied
         to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_AXLIx
}{
   Determines whether an array{\tt '}s values are equally spaced
}{
   \sstdescription{
      This routine determines whether or not adjacent elements of a
      1-d array have values that are equally spaced, i.e. it tests for
      linearity.  It simply checks if the intervals between all
      successive pairs of elements are the same within the machine
      precision.
   }
   \sstinvocation{
      CALL KPG1\_AXLIx( EL, ARRAY, LVAL, UVAL, LINEAR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array.  It must be at least
         two.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         The array to be tested.
      }
      \sstsubsection{
         LVAL = ? (Returned)
      }{
         Value of the first array element.  If this is bad an estimated
         value is substituted when the array is linear.
      }
      \sstsubsection{
         UVAL = ? (Returned)
      }{
         Value of the last array element.  If this is bad an estimated
         value is substituted when the array is linear.
      }
      \sstsubsection{
         LINEAR = LOGICAL (Returned)
      }{
         True if the array is linear.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for most numeric data types: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, or UW as appropriate.  The array
         (and the variables for the first and last array elements) supplied
         to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_AXLIx
}{
   Determines whether an array{\tt '}s values are equally spaced
}{
   \sstdescription{
      This routine determines whether or not adjacent elements of a
      1-d array have values that are equally spaced, i.e. it tests for
      linearity.  It simply checks if the intervals between all
      successive pairs of elements are the same within the machine
      precision.
   }
   \sstinvocation{
      CALL KPG1\_AXLIx( EL, ARRAY, LVAL, UVAL, LINEAR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array.  It must be at least
         two.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         The array to be tested.
      }
      \sstsubsection{
         LVAL = ? (Returned)
      }{
         Value of the first array element.  If this is bad an estimated
         value is substituted when the array is linear.
      }
      \sstsubsection{
         UVAL = ? (Returned)
      }{
         Value of the last array element.  If this is bad an estimated
         value is substituted when the array is linear.
      }
      \sstsubsection{
         LINEAR = LOGICAL (Returned)
      }{
         True if the array is linear.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for most numeric data types: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, or UW as appropriate.  The array
         (and the variables for the first and last array elements) supplied
         to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_AXLIx
}{
   Determines whether an array{\tt '}s values are equally spaced
}{
   \sstdescription{
      This routine determines whether or not adjacent elements of a
      1-d array have values that are equally spaced, i.e. it tests for
      linearity.  It simply checks if the intervals between all
      successive pairs of elements are the same within the machine
      precision.
   }
   \sstinvocation{
      CALL KPG1\_AXLIx( EL, ARRAY, LVAL, UVAL, LINEAR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array.  It must be at least
         two.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         The array to be tested.
      }
      \sstsubsection{
         LVAL = ? (Returned)
      }{
         Value of the first array element.  If this is bad an estimated
         value is substituted when the array is linear.
      }
      \sstsubsection{
         UVAL = ? (Returned)
      }{
         Value of the last array element.  If this is bad an estimated
         value is substituted when the array is linear.
      }
      \sstsubsection{
         LINEAR = LOGICAL (Returned)
      }{
         True if the array is linear.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for most numeric data types: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, or UW as appropriate.  The array
         (and the variables for the first and last array elements) supplied
         to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_AXLIx
}{
   Determines whether an array{\tt '}s values are equally spaced
}{
   \sstdescription{
      This routine determines whether or not adjacent elements of a
      1-d array have values that are equally spaced, i.e. it tests for
      linearity.  It simply checks if the intervals between all
      successive pairs of elements are the same within the machine
      precision.
   }
   \sstinvocation{
      CALL KPG1\_AXLIx( EL, ARRAY, LVAL, UVAL, LINEAR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array.  It must be at least
         two.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         The array to be tested.
      }
      \sstsubsection{
         LVAL = ? (Returned)
      }{
         Value of the first array element.  If this is bad an estimated
         value is substituted when the array is linear.
      }
      \sstsubsection{
         UVAL = ? (Returned)
      }{
         Value of the last array element.  If this is bad an estimated
         value is substituted when the array is linear.
      }
      \sstsubsection{
         LINEAR = LOGICAL (Returned)
      }{
         True if the array is linear.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for most numeric data types: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, or UW as appropriate.  The array
         (and the variables for the first and last array elements) supplied
         to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_AXLVx
}{
   Find the first axis centre co-ordinate of an NDF below a
   threshold
}{
   \sstdescription{
      This routine determines the element number and value of the first
      axis centre co-ordinate of an NDF below a given threshold.
      Currently, it assumes that the centre values increase or decrease
      monotonically from the first to the last elements.

      A SAI\_\_ERROR status is returned when no centre value is less than
      the threshold.
   }
   \sstinvocation{
      CALL KPG1\_AXLVx( EL, CENTRE, THRESH, ITH, VALTH, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the axis.
      }
      \sstsubsection{
         CENTRE( EL ) = ? (Given)
      }{
         The NDF axis centre co-ordinates.
      }
      \sstsubsection{
         THRESH = ? (Given)
      }{
         The threshold.
      }
      \sstsubsection{
         ITH = INTEGER (Returned)
      }{
         The index number of the element that first has a value below
         the threshold, or its negative when the co-ordinates decrease
         with increasing element number.
      }
      \sstsubsection{
         VALTH = ? (Returned)
      }{
         The centre co-ordinate that first fails to exceed the
         threshold.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision data types:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively.  The
         array and threshold supplied to the routine plus the co-ordinate
         that first fails to exceed the threshold must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_AXLVx
}{
   Find the first axis centre co-ordinate of an NDF below a
   threshold
}{
   \sstdescription{
      This routine determines the element number and value of the first
      axis centre co-ordinate of an NDF below a given threshold.
      Currently, it assumes that the centre values increase or decrease
      monotonically from the first to the last elements.

      A SAI\_\_ERROR status is returned when no centre value is less than
      the threshold.
   }
   \sstinvocation{
      CALL KPG1\_AXLVx( EL, CENTRE, THRESH, ITH, VALTH, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the axis.
      }
      \sstsubsection{
         CENTRE( EL ) = ? (Given)
      }{
         The NDF axis centre co-ordinates.
      }
      \sstsubsection{
         THRESH = ? (Given)
      }{
         The threshold.
      }
      \sstsubsection{
         ITH = INTEGER (Returned)
      }{
         The index number of the element that first has a value below
         the threshold, or its negative when the co-ordinates decrease
         with increasing element number.
      }
      \sstsubsection{
         VALTH = ? (Returned)
      }{
         The centre co-ordinate that first fails to exceed the
         threshold.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision data types:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively.  The
         array and threshold supplied to the routine plus the co-ordinate
         that first fails to exceed the threshold must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_AXRNG
}{
   Calculate the extent of an NDF along an axis
}{
   \sstdescription{
      This routine calculates the starting and ending positions of an
      NDF{\tt '}s pixels along an axis, taking account of the axis width
      values.
   }
   \sstinvocation{
      CALL KPG1\_AXRNG( EL, CENTRE, WIDTH, ASTART, AEND, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the axis arrays.
      }
      \sstsubsection{
         CENTRE( EL ) = DOUBLE PRECISION (Given)
      }{
         The centres of the pixels on the axis.
      }
      \sstsubsection{
         WIDTH( EL ) = DOUBLE PRECISION (Given)
      }{
         The widths of the pixels on the axis.
      }
      \sstsubsection{
         ASTART = DOUBLE PRECISION (Returned)
      }{
         If the axis centre positions increase with NDF pixel index,
         this argument returns the axis position of the edge of the
         first pixel which has the lower co-ordinate. Otherwise it
         returns the axis position of the edge with the higher
         co-ordinate.
      }
      \sstsubsection{
         AEND = DOUBLE PRECISION (Returned)
      }{
         If the axis centre positions increase with NDF pixel index,
         this argument returns the axis position of the edge of the
         last pixel which has the higher co-ordinate. Otherwise it
         returns the axis position of the edge with the lower
         co-ordinate.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_AXTYP
}{
   Determines the implementation type for NDF axis arrays
}{
   \sstdescription{
      The routine returns the highest precision required to process
      the NDF axis component in all dimensions.  {\tt '}\_DOUBLE{\tt '} is returned
      if any of the arrays have type {\tt '}\_INTEGER{\tt '} or {\tt '}DOUBLE{\tt '}.
   }
   \sstinvocation{
      CALL KPG1\_AXTYP( NDF, COMP, ATYPE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDF = INTEGER (Given)
      }{
         The NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the axis array component whose implementation type
         is required: {\tt '}CENTRE{\tt '}, {\tt '}VARIANCE{\tt '}, or {\tt '}WIDTH{\tt '}.
      }
      \sstsubsection{
         ATYPE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The implementation type of the axis arrays.  It is in uppercase
         and is either {\tt '}\_REAL{\tt '} or {\tt '}\_DOUBLE{\tt '}.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      The NDF identifier must be valid and there must be an axis
      structure.
   }
}
\sstroutine{
   KPG1\_AXVLx
}{
   Obtains the axis-array values given their corresponding pixel
   co-ordinates
}{
   \sstdescription{
      This routine determines values within an axis array for a series
      of non-integer pixel co-ordinates.  It assumes that the array is
      monotonic and approximately linear, since it uses linear
      interpolation to derive the axis values. This routine may be
      used for arbitrary one-dimensional arrays in addition to axes,
      provided this criterion is met.
   }
   \sstinvocation{
      CALL KPG1\_AXVLx( LBND, UBND, AXIS, EL, PIXCO, DATCO, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The lower bound of the axis array.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The upper bound of the axis array.
      }
      \sstsubsection{
         AXIS( LBND:UBND ) = ? (Given)
      }{
         The axis array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of pixel co-ordinates whose values in the axis
         array are to be found.
      }
      \sstsubsection{
         PIXCO( EL ) = ? (Given)
      }{
         The pixel co-ordinates of the values in the axis array.
      }
      \sstsubsection{
         DATCO( EL ) = ? (Returned)
      }{
         The axis-array values.  A value is set to the bad value when
         its input co-ordinate lies outside the range of co-ordinates
         in the axis.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the data types real or double precision:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively, as
         appropriate.  The axis array and indices, and the returned values
         should have this data type as well.

         \sstitem
         A pixel co-ordinate that lies within the lower-bound or
         upper-bound element of the axis array but not between elements,
         and hence cannot have interpolation (i.e. PIXCO is less than LBND

         \sstitem
         0.5 or greater than UBND $+$ 0.5) return with the centre data
         co-ordinate of the lower-bound or upper-bound pixel respectively.

         \sstitem
         An error report is made and bad status returned should any
         input index lie outside the range of the bounds of the axis.
         Processing will continue through the list.
      }
   }
}
\sstroutine{
   KPG1\_AXVLx
}{
   Obtains the axis-array values given their corresponding pixel
   co-ordinates
}{
   \sstdescription{
      This routine determines values within an axis array for a series
      of non-integer pixel co-ordinates.  It assumes that the array is
      monotonic and approximately linear, since it uses linear
      interpolation to derive the axis values. This routine may be
      used for arbitrary one-dimensional arrays in addition to axes,
      provided this criterion is met.
   }
   \sstinvocation{
      CALL KPG1\_AXVLx( LBND, UBND, AXIS, EL, PIXCO, DATCO, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The lower bound of the axis array.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The upper bound of the axis array.
      }
      \sstsubsection{
         AXIS( LBND:UBND ) = ? (Given)
      }{
         The axis array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of pixel co-ordinates whose values in the axis
         array are to be found.
      }
      \sstsubsection{
         PIXCO( EL ) = ? (Given)
      }{
         The pixel co-ordinates of the values in the axis array.
      }
      \sstsubsection{
         DATCO( EL ) = ? (Returned)
      }{
         The axis-array values.  A value is set to the bad value when
         its input co-ordinate lies outside the range of co-ordinates
         in the axis.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the data types real or double precision:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively, as
         appropriate.  The axis array and indices, and the returned values
         should have this data type as well.

         \sstitem
         A pixel co-ordinate that lies within the lower-bound or
         upper-bound element of the axis array but not between elements,
         and hence cannot have interpolation (i.e. PIXCO is less than LBND

         \sstitem
         0.5 or greater than UBND $+$ 0.5) return with the centre data
         co-ordinate of the lower-bound or upper-bound pixel respectively.

         \sstitem
         An error report is made and bad status returned should any
         input index lie outside the range of the bounds of the axis.
         Processing will continue through the list.
      }
   }
}
\sstroutine{
   KPG1\_BILNR
}{
   Perform bi-linear interpolation checking for bad values
}{
   \sstdescription{
      An imaginary pixel is centred on the supplied interpolation
      position. The area of the overlap between this imaginary pixel
      and each of the four surrounding real pixels is found, and used
      as the weight for the corresponding pixel value. The returned
      interpolated value is the weighted mean of the four surrounding
      pixel values. A bad value is returned if any of these four pixels
      lie outside the image or have a bad value.

      The associated variance value is also returned if input variances
      are supplied.
   }
   \sstinvocation{
      CALL KPG1\_BILNR( X, Y, XLO, XHI, YLO, YHI, USEVAR, DATA, VAR,
                       INTERP, INTERV, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         X = REAL (Given)
      }{
         The pixel X coordinate at which to perform the interpolation.
      }
      \sstsubsection{
         Y = REAL (Given)
      }{
         The pixel Y coordinate at which to perform the interpolation.
      }
      \sstsubsection{
         XLO = INTEGER (Given)
      }{
         The lower bound on the array X axis.
      }
      \sstsubsection{
         XHI = INTEGER (Given)
      }{
         The upper bound on the array X axis.
      }
      \sstsubsection{
         YLO = INTEGER (Given)
      }{
         The lower bound on the array Y axis.
      }
      \sstsubsection{
         YHI = INTEGER (Given)
      }{
         The upper bound on the array Y axis.
      }
      \sstsubsection{
         USEVAR = LOGICAL (Given)
      }{
         Should a variance be returned?
      }
      \sstsubsection{
         DATA( XLO:XHI, YLO:YHI ) = REAL (Given)
      }{
         The data array to be interpolated.
      }
      \sstsubsection{
         VAR( XLO:XHI, YLO:YHI ) = REAL (Given)
      }{
         The variance array (only accessed if USEVAR is .TRUE.).
      }
      \sstsubsection{
         INTERP = REAL (Returned)
      }{
         The interpolated data value.
      }
      \sstsubsection{
         INTERV = REAL (Returned)
      }{
         The interpolated variance value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_BL1Dx
}{
   Smooth a 1D vector using a block average filter
}{
   \sstdescription{
      This routine smooths a 1D vector using a block average filter.
      Output pixels are set bad if all input pixels in the block are
      bad, or if the output pixel is in the first or last half block.
   }
   \sstinvocation{
      CALL KPG1\_BL1Dx( N, IN, SIZE, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         The number of elements of the array to be smoothed.
      }
      \sstsubsection{
         IN( N ) = BYTE (Given)
      }{
         The input array.
      }
      \sstsubsection{
         SIZE = INTEGER (Given)
      }{
         The size of the filter (in pixels).
      }
      \sstsubsection{
         OUT( N ) = BYTE (Returned)
      }{
         The output array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status.
      }
   }
}
\sstroutine{
   KPG1\_BL1Dx
}{
   Smooth a 1D vector using a block average filter
}{
   \sstdescription{
      This routine smooths a 1D vector using a block average filter.
      Output pixels are set bad if all input pixels in the block are
      bad, or if the output pixel is in the first or last half block.
   }
   \sstinvocation{
      CALL KPG1\_BL1Dx( N, IN, SIZE, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         The number of elements of the array to be smoothed.
      }
      \sstsubsection{
         IN( N ) = DOUBLE PRECISION (Given)
      }{
         The input array.
      }
      \sstsubsection{
         SIZE = INTEGER (Given)
      }{
         The size of the filter (in pixels).
      }
      \sstsubsection{
         OUT( N ) = DOUBLE PRECISION (Returned)
      }{
         The output array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status.
      }
   }
}
\sstroutine{
   KPG1\_BL1Dx
}{
   Smooth a 1D vector using a block average filter
}{
   \sstdescription{
      This routine smooths a 1D vector using a block average filter.
      Output pixels are set bad if all input pixels in the block are
      bad, or if the output pixel is in the first or last half block.
   }
   \sstinvocation{
      CALL KPG1\_BL1Dx( N, IN, SIZE, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         The number of elements of the array to be smoothed.
      }
      \sstsubsection{
         IN( N ) = INTEGER (Given)
      }{
         The input array.
      }
      \sstsubsection{
         SIZE = INTEGER (Given)
      }{
         The size of the filter (in pixels).
      }
      \sstsubsection{
         OUT( N ) = INTEGER (Returned)
      }{
         The output array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status.
      }
   }
}
\sstroutine{
   KPG1\_BL1Dx
}{
   Smooth a 1D vector using a block average filter
}{
   \sstdescription{
      This routine smooths a 1D vector using a block average filter.
      Output pixels are set bad if all input pixels in the block are
      bad, or if the output pixel is in the first or last half block.
   }
   \sstinvocation{
      CALL KPG1\_BL1Dx( N, IN, SIZE, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         The number of elements of the array to be smoothed.
      }
      \sstsubsection{
         IN( N ) = REAL (Given)
      }{
         The input array.
      }
      \sstsubsection{
         SIZE = INTEGER (Given)
      }{
         The size of the filter (in pixels).
      }
      \sstsubsection{
         OUT( N ) = REAL (Returned)
      }{
         The output array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status.
      }
   }
}
\sstroutine{
   KPG1\_BL1Dx
}{
   Smooth a 1D vector using a block average filter
}{
   \sstdescription{
      This routine smooths a 1D vector using a block average filter.
      Output pixels are set bad if all input pixels in the block are
      bad, or if the output pixel is in the first or last half block.
   }
   \sstinvocation{
      CALL KPG1\_BL1Dx( N, IN, SIZE, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         The number of elements of the array to be smoothed.
      }
      \sstsubsection{
         IN( N ) = BYTE (Given)
      }{
         The input array.
      }
      \sstsubsection{
         SIZE = INTEGER (Given)
      }{
         The size of the filter (in pixels).
      }
      \sstsubsection{
         OUT( N ) = BYTE (Returned)
      }{
         The output array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status.
      }
   }
}
\sstroutine{
   KPG1\_BL1Dx
}{
   Smooth a 1D vector using a block average filter
}{
   \sstdescription{
      This routine smooths a 1D vector using a block average filter.
      Output pixels are set bad if all input pixels in the block are
      bad, or if the output pixel is in the first or last half block.
   }
   \sstinvocation{
      CALL KPG1\_BL1Dx( N, IN, SIZE, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         The number of elements of the array to be smoothed.
      }
      \sstsubsection{
         IN( N ) = INTEGER$*$2 (Given)
      }{
         The input array.
      }
      \sstsubsection{
         SIZE = INTEGER (Given)
      }{
         The size of the filter (in pixels).
      }
      \sstsubsection{
         OUT( N ) = INTEGER$*$2 (Returned)
      }{
         The output array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status.
      }
   }
}
\sstroutine{
   KPG1\_BL1Dx
}{
   Smooth a 1D vector using a block average filter
}{
   \sstdescription{
      This routine smooths a 1D vector using a block average filter.
      Output pixels are set bad if all input pixels in the block are
      bad, or if the output pixel is in the first or last half block.
   }
   \sstinvocation{
      CALL KPG1\_BL1Dx( N, IN, SIZE, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         The number of elements of the array to be smoothed.
      }
      \sstsubsection{
         IN( N ) = INTEGER$*$2 (Given)
      }{
         The input array.
      }
      \sstsubsection{
         SIZE = INTEGER (Given)
      }{
         The size of the filter (in pixels).
      }
      \sstsubsection{
         OUT( N ) = INTEGER$*$2 (Returned)
      }{
         The output array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status.
      }
   }
}
\sstroutine{
   KPG1\_BLOCx
}{
   Smooth a 2-dimensional image using a rectangular box filter
}{
   \sstdescription{
      The routine smooths a 2-dimensional image using a rectangular box
      filter; each pixel is replaced by the mean of those good
      neighbours which lie within a box of specified size.
   }
   \sstinvocation{
      CALL KPG1\_BLOCx( BAD, SAMBAD, VAR, NX, NY, A, IBOXX,
                       IBOXY, NLIM, B, BADOUT, ASUM, NSUM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether it is necessary to check for bad pixels in the input
         image.
      }
      \sstsubsection{
         SAMBAD = LOGICAL (Given)
      }{
         If a .TRUE. value is given for this argument, then bad input
         pixels will be propagated to the output image unchanged (a
         smoothed output value will be calculated for all other
         pixels). If a .FALSE. value is given, then the NLIM argument
         determines whether an output pixel is good or bad.  The value
         of SAMBAD is not relevant if BAD is .FALSE..
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If a .FALSE. value is given for this argument, then the
         smoothing applied will be appropriate to a data image. If a
         .TRUE. value is given, then the smoothing will be appropriate
         to an image containing variance values. In the latter case the
         output values will be (on average) smaller than the input
         values to take account of the variance-reducing effect which
         smoothing produces.
      }
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         First dimension of the image to be smoothed.
      }
      \sstsubsection{
         NY = INTEGER (Given)
      }{
         Second dimension of the image to be smoothed.
      }
      \sstsubsection{
         A( NX, NY ) = ? (Given)
      }{
         Input image to be smoothed.
      }
      \sstsubsection{
         IBOXX = INTEGER (Given)
      }{
         Half-size of the smoothing box in pixels in the X direction
         (the actual size of the box used will be 2$*$IBOXX$+$1 pixels).
      }
      \sstsubsection{
         IBOXY = INTEGER (Given)
      }{
         Half-size of the smoothing box in pixels in the Y direction
         (the actual size of the box used will be 2$*$IBOXY$+$1 pixels).
      }
      \sstsubsection{
         NLIM = INTEGER (Given)
      }{
         Minimum number of good pixels which must be present in the
         smoothing box in order to calculate a smoothed output pixel.
         If this minimum number is not satisfied, then a bad output
         pixel will result. A value between 1 and the total number of
         pixels in the smoothing box should be supplied.
      }
      \sstsubsection{
         B( NX, NY ) = ? (Returned)
      }{
         The smoothed output image.
      }
      \sstsubsection{
         BADOUT = LOGICAL (Returned)
      }{
         Whether bad pixels are present in the output image.
      }
      \sstsubsection{
         ASUM( NX ) = ? (Returned)
      }{
         Workspace for the pixel sums.
      }
      \sstsubsection{
         NSUM( NX ) = INTEGER (Returned)
      }{
         Workspace for counting good pixels.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for processing single- and double-precision
         arrays; replace {\tt "}x{\tt "} in the routine name by R or D as appropriate.
         The data type of the A, B and ASUM arguments must match the
         routine used.
      }
   }
}
\sstroutine{
   KPG1\_BLOCx
}{
   Smooth a 2-dimensional image using a rectangular box filter
}{
   \sstdescription{
      The routine smooths a 2-dimensional image using a rectangular box
      filter; each pixel is replaced by the mean of those good
      neighbours which lie within a box of specified size.
   }
   \sstinvocation{
      CALL KPG1\_BLOCx( BAD, SAMBAD, VAR, NX, NY, A, IBOXX,
                       IBOXY, NLIM, B, BADOUT, ASUM, NSUM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether it is necessary to check for bad pixels in the input
         image.
      }
      \sstsubsection{
         SAMBAD = LOGICAL (Given)
      }{
         If a .TRUE. value is given for this argument, then bad input
         pixels will be propagated to the output image unchanged (a
         smoothed output value will be calculated for all other
         pixels). If a .FALSE. value is given, then the NLIM argument
         determines whether an output pixel is good or bad.  The value
         of SAMBAD is not relevant if BAD is .FALSE..
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If a .FALSE. value is given for this argument, then the
         smoothing applied will be appropriate to a data image. If a
         .TRUE. value is given, then the smoothing will be appropriate
         to an image containing variance values. In the latter case the
         output values will be (on average) smaller than the input
         values to take account of the variance-reducing effect which
         smoothing produces.
      }
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         First dimension of the image to be smoothed.
      }
      \sstsubsection{
         NY = INTEGER (Given)
      }{
         Second dimension of the image to be smoothed.
      }
      \sstsubsection{
         A( NX, NY ) = ? (Given)
      }{
         Input image to be smoothed.
      }
      \sstsubsection{
         IBOXX = INTEGER (Given)
      }{
         Half-size of the smoothing box in pixels in the X direction
         (the actual size of the box used will be 2$*$IBOXX$+$1 pixels).
      }
      \sstsubsection{
         IBOXY = INTEGER (Given)
      }{
         Half-size of the smoothing box in pixels in the Y direction
         (the actual size of the box used will be 2$*$IBOXY$+$1 pixels).
      }
      \sstsubsection{
         NLIM = INTEGER (Given)
      }{
         Minimum number of good pixels which must be present in the
         smoothing box in order to calculate a smoothed output pixel.
         If this minimum number is not satisfied, then a bad output
         pixel will result. A value between 1 and the total number of
         pixels in the smoothing box should be supplied.
      }
      \sstsubsection{
         B( NX, NY ) = ? (Returned)
      }{
         The smoothed output image.
      }
      \sstsubsection{
         BADOUT = LOGICAL (Returned)
      }{
         Whether bad pixels are present in the output image.
      }
      \sstsubsection{
         ASUM( NX ) = ? (Returned)
      }{
         Workspace for the pixel sums.
      }
      \sstsubsection{
         NSUM( NX ) = INTEGER (Returned)
      }{
         Workspace for counting good pixels.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for processing single- and double-precision
         arrays; replace {\tt "}x{\tt "} in the routine name by R or D as appropriate.
         The data type of the A, B and ASUM arguments must match the
         routine used.
      }
   }
}
\sstroutine{
   KPG1\_BMEDx
}{
   Smooths the input array using a block median filter
}{
   \sstdescription{
      The input array is filtered by replacing every pixel with the
      median of the pixel values contained in a rectangular region
      centred on the required output pixel.  If the box is so large in
      either dimension that an entire line or column is included for
      all output pixels, then the output values will be the same and so
      can be copied rather than re-calculated.
   }
   \sstinvocation{
      CALL KPG1\_BMEDx( BAD, SAMBAD, VAR, NX, NY, IN, HX, HY, NLIM,
                       OUT, BADOUT, WORK1, WORK2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether or not it is necessary to check for bad pixels in the
         input image.
      }
      \sstsubsection{
         SAMBAD = LOGICAL (Given)
      }{
         If a .TRUE. value is given for this argument, then bad input
         pixels will be propagated to the output image unchanged (a
         smoothed output value will be calculated for all other
         pixels).  If a .FALSE. value is given, then the NLIM argument
         determines whether an output pixel is good or bad.  The value
         of SAMBAD is not relevant if BAD is .FALSE..
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         Indicates if the input image holds data values or variance
         values.  This argument is currently ignored (input values are
         assumed to be data values).
      }
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         The first dimension of the input and output images.
      }
      \sstsubsection{
         NY = INTEGER (Given)
      }{
         The second dimension of the input and output images.
      }
      \sstsubsection{
         IN( NX, NY ) = ? (Given)
      }{
         The input image.
      }
      \sstsubsection{
         HX = INTEGER (Given)
      }{
         The half-width of the filter block along the first dimension,
         in pixels.
      }
      \sstsubsection{
         HY = INTEGER (Given)
      }{
         The half-width of the filter block along the second dimension,
         in pixels.
      }
      \sstsubsection{
         NLIM = INTEGER (Given)
      }{
         Minimum number of good pixels which must be present in the
         smoothing box in order to calculate a smoothed output pixel.
         If this minimum number is not satisfied, then a bad output
         pixel will result.  A value between 1 and the total number of
         pixels in the smoothing box should be supplied.
      }
      \sstsubsection{
         OUT( NX, NY ) = ? (Returned)
      }{
         The output image.
      }
      \sstsubsection{
         BADOUT = LOGICAL (Returned)
      }{
         Whether bad pixels are present in the output image.
      }
      \sstsubsection{
         WORK1( $*$ ) = ? (Returned)
      }{
         Work space.  It should have at least (2$*$HX$+$1)$*$(2$*$HY$+$1)
         elements.
      }
      \sstsubsection{
         WORK2( $*$ ) = INTEGER (Returned)
      }{
         Work space.  It should have at least (2$*$HX$+$1)$*$(2$*$HY$+$1)
         elements.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for processing single- and double-precision
         arrays; replace {\tt "}x{\tt "} in the routine name by R or D as appropriate.
         The data type of the IN, OUT, and WORK1 arguments must match the
         routine used.
      }
   }
}
\sstroutine{
   KPG1\_BMEDx
}{
   Smooths the input array using a block median filter
}{
   \sstdescription{
      The input array is filtered by replacing every pixel with the
      median of the pixel values contained in a rectangular region
      centred on the required output pixel.  If the box is so large in
      either dimension that an entire line or column is included for
      all output pixels, then the output values will be the same and so
      can be copied rather than re-calculated.
   }
   \sstinvocation{
      CALL KPG1\_BMEDx( BAD, SAMBAD, VAR, NX, NY, IN, HX, HY, NLIM,
                       OUT, BADOUT, WORK1, WORK2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether or not it is necessary to check for bad pixels in the
         input image.
      }
      \sstsubsection{
         SAMBAD = LOGICAL (Given)
      }{
         If a .TRUE. value is given for this argument, then bad input
         pixels will be propagated to the output image unchanged (a
         smoothed output value will be calculated for all other
         pixels).  If a .FALSE. value is given, then the NLIM argument
         determines whether an output pixel is good or bad.  The value
         of SAMBAD is not relevant if BAD is .FALSE..
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         Indicates if the input image holds data values or variance
         values.  This argument is currently ignored (input values are
         assumed to be data values).
      }
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         The first dimension of the input and output images.
      }
      \sstsubsection{
         NY = INTEGER (Given)
      }{
         The second dimension of the input and output images.
      }
      \sstsubsection{
         IN( NX, NY ) = ? (Given)
      }{
         The input image.
      }
      \sstsubsection{
         HX = INTEGER (Given)
      }{
         The half-width of the filter block along the first dimension,
         in pixels.
      }
      \sstsubsection{
         HY = INTEGER (Given)
      }{
         The half-width of the filter block along the second dimension,
         in pixels.
      }
      \sstsubsection{
         NLIM = INTEGER (Given)
      }{
         Minimum number of good pixels which must be present in the
         smoothing box in order to calculate a smoothed output pixel.
         If this minimum number is not satisfied, then a bad output
         pixel will result.  A value between 1 and the total number of
         pixels in the smoothing box should be supplied.
      }
      \sstsubsection{
         OUT( NX, NY ) = ? (Returned)
      }{
         The output image.
      }
      \sstsubsection{
         BADOUT = LOGICAL (Returned)
      }{
         Whether bad pixels are present in the output image.
      }
      \sstsubsection{
         WORK1( $*$ ) = ? (Returned)
      }{
         Work space.  It should have at least (2$*$HX$+$1)$*$(2$*$HY$+$1)
         elements.
      }
      \sstsubsection{
         WORK2( $*$ ) = INTEGER (Returned)
      }{
         Work space.  It should have at least (2$*$HX$+$1)$*$(2$*$HY$+$1)
         elements.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for processing single- and double-precision
         arrays; replace {\tt "}x{\tt "} in the routine name by R or D as appropriate.
         The data type of the IN, OUT, and WORK1 arguments must match the
         routine used.
      }
   }
}
\sstroutine{
   KPG1\_BOR2x
}{
   Places a border of constant values at the edges of a 2-d array
}{
   \sstdescription{
      This routine assigns a constant value to the edge pixels of a
      2-d array.  The width of the edge is adjustable along each
      axis, but it is the same for the leading and trailing edges along
      a given dimension.  If the border is wider than the array
      a SAI\_\_ERROR status is returned.
   }
   \sstinvocation{
      CALL KPG1\_BOR2x( VALUE, BORWID, DIM1, DIM2, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VALUE = ? (Given)
      }{
         Value to be assigned to the borders of the array.
      }
      \sstsubsection{
         BORWID( 2 ) = INTEGER (Given)
      }{
         The width in pixels of the borders in each dimension, x then y.
         Each must be less than its corresponding dimension.
      }
      \sstsubsection{
         DIM1 = INTEGER (Given)
      }{
         The first dimension of the array to have constant-valued
         peripheries.
      }
      \sstsubsection{
         DIM2 = INTEGER (Given)
      }{
         The second dimension of the array to have constant-valued
         peripheries.
      }
      \sstsubsection{
         ARRAY( DIM1, DIM2 ) = ? (Given and Returned)
      }{
         The array to have its borders set to a constant.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         array and value to be substituted that are supplied to the routine
         must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_BOR2x
}{
   Places a border of constant values at the edges of a 2-d array
}{
   \sstdescription{
      This routine assigns a constant value to the edge pixels of a
      2-d array.  The width of the edge is adjustable along each
      axis, but it is the same for the leading and trailing edges along
      a given dimension.  If the border is wider than the array
      a SAI\_\_ERROR status is returned.
   }
   \sstinvocation{
      CALL KPG1\_BOR2x( VALUE, BORWID, DIM1, DIM2, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VALUE = ? (Given)
      }{
         Value to be assigned to the borders of the array.
      }
      \sstsubsection{
         BORWID( 2 ) = INTEGER (Given)
      }{
         The width in pixels of the borders in each dimension, x then y.
         Each must be less than its corresponding dimension.
      }
      \sstsubsection{
         DIM1 = INTEGER (Given)
      }{
         The first dimension of the array to have constant-valued
         peripheries.
      }
      \sstsubsection{
         DIM2 = INTEGER (Given)
      }{
         The second dimension of the array to have constant-valued
         peripheries.
      }
      \sstsubsection{
         ARRAY( DIM1, DIM2 ) = ? (Given and Returned)
      }{
         The array to have its borders set to a constant.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         array and value to be substituted that are supplied to the routine
         must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_BOR2x
}{
   Places a border of constant values at the edges of a 2-d array
}{
   \sstdescription{
      This routine assigns a constant value to the edge pixels of a
      2-d array.  The width of the edge is adjustable along each
      axis, but it is the same for the leading and trailing edges along
      a given dimension.  If the border is wider than the array
      a SAI\_\_ERROR status is returned.
   }
   \sstinvocation{
      CALL KPG1\_BOR2x( VALUE, BORWID, DIM1, DIM2, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VALUE = ? (Given)
      }{
         Value to be assigned to the borders of the array.
      }
      \sstsubsection{
         BORWID( 2 ) = INTEGER (Given)
      }{
         The width in pixels of the borders in each dimension, x then y.
         Each must be less than its corresponding dimension.
      }
      \sstsubsection{
         DIM1 = INTEGER (Given)
      }{
         The first dimension of the array to have constant-valued
         peripheries.
      }
      \sstsubsection{
         DIM2 = INTEGER (Given)
      }{
         The second dimension of the array to have constant-valued
         peripheries.
      }
      \sstsubsection{
         ARRAY( DIM1, DIM2 ) = ? (Given and Returned)
      }{
         The array to have its borders set to a constant.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         array and value to be substituted that are supplied to the routine
         must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_BOR2x
}{
   Places a border of constant values at the edges of a 2-d array
}{
   \sstdescription{
      This routine assigns a constant value to the edge pixels of a
      2-d array.  The width of the edge is adjustable along each
      axis, but it is the same for the leading and trailing edges along
      a given dimension.  If the border is wider than the array
      a SAI\_\_ERROR status is returned.
   }
   \sstinvocation{
      CALL KPG1\_BOR2x( VALUE, BORWID, DIM1, DIM2, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VALUE = ? (Given)
      }{
         Value to be assigned to the borders of the array.
      }
      \sstsubsection{
         BORWID( 2 ) = INTEGER (Given)
      }{
         The width in pixels of the borders in each dimension, x then y.
         Each must be less than its corresponding dimension.
      }
      \sstsubsection{
         DIM1 = INTEGER (Given)
      }{
         The first dimension of the array to have constant-valued
         peripheries.
      }
      \sstsubsection{
         DIM2 = INTEGER (Given)
      }{
         The second dimension of the array to have constant-valued
         peripheries.
      }
      \sstsubsection{
         ARRAY( DIM1, DIM2 ) = ? (Given and Returned)
      }{
         The array to have its borders set to a constant.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         array and value to be substituted that are supplied to the routine
         must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_BOR2x
}{
   Places a border of constant values at the edges of a 2-d array
}{
   \sstdescription{
      This routine assigns a constant value to the edge pixels of a
      2-d array.  The width of the edge is adjustable along each
      axis, but it is the same for the leading and trailing edges along
      a given dimension.  If the border is wider than the array
      a SAI\_\_ERROR status is returned.
   }
   \sstinvocation{
      CALL KPG1\_BOR2x( VALUE, BORWID, DIM1, DIM2, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VALUE = ? (Given)
      }{
         Value to be assigned to the borders of the array.
      }
      \sstsubsection{
         BORWID( 2 ) = INTEGER (Given)
      }{
         The width in pixels of the borders in each dimension, x then y.
         Each must be less than its corresponding dimension.
      }
      \sstsubsection{
         DIM1 = INTEGER (Given)
      }{
         The first dimension of the array to have constant-valued
         peripheries.
      }
      \sstsubsection{
         DIM2 = INTEGER (Given)
      }{
         The second dimension of the array to have constant-valued
         peripheries.
      }
      \sstsubsection{
         ARRAY( DIM1, DIM2 ) = ? (Given and Returned)
      }{
         The array to have its borders set to a constant.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         array and value to be substituted that are supplied to the routine
         must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_BOR2x
}{
   Places a border of constant values at the edges of a 2-d array
}{
   \sstdescription{
      This routine assigns a constant value to the edge pixels of a
      2-d array.  The width of the edge is adjustable along each
      axis, but it is the same for the leading and trailing edges along
      a given dimension.  If the border is wider than the array
      a SAI\_\_ERROR status is returned.
   }
   \sstinvocation{
      CALL KPG1\_BOR2x( VALUE, BORWID, DIM1, DIM2, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VALUE = ? (Given)
      }{
         Value to be assigned to the borders of the array.
      }
      \sstsubsection{
         BORWID( 2 ) = INTEGER (Given)
      }{
         The width in pixels of the borders in each dimension, x then y.
         Each must be less than its corresponding dimension.
      }
      \sstsubsection{
         DIM1 = INTEGER (Given)
      }{
         The first dimension of the array to have constant-valued
         peripheries.
      }
      \sstsubsection{
         DIM2 = INTEGER (Given)
      }{
         The second dimension of the array to have constant-valued
         peripheries.
      }
      \sstsubsection{
         ARRAY( DIM1, DIM2 ) = ? (Given and Returned)
      }{
         The array to have its borders set to a constant.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         array and value to be substituted that are supplied to the routine
         must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_BOR2x
}{
   Places a border of constant values at the edges of a 2-d array
}{
   \sstdescription{
      This routine assigns a constant value to the edge pixels of a
      2-d array.  The width of the edge is adjustable along each
      axis, but it is the same for the leading and trailing edges along
      a given dimension.  If the border is wider than the array
      a SAI\_\_ERROR status is returned.
   }
   \sstinvocation{
      CALL KPG1\_BOR2x( VALUE, BORWID, DIM1, DIM2, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VALUE = ? (Given)
      }{
         Value to be assigned to the borders of the array.
      }
      \sstsubsection{
         BORWID( 2 ) = INTEGER (Given)
      }{
         The width in pixels of the borders in each dimension, x then y.
         Each must be less than its corresponding dimension.
      }
      \sstsubsection{
         DIM1 = INTEGER (Given)
      }{
         The first dimension of the array to have constant-valued
         peripheries.
      }
      \sstsubsection{
         DIM2 = INTEGER (Given)
      }{
         The second dimension of the array to have constant-valued
         peripheries.
      }
      \sstsubsection{
         ARRAY( DIM1, DIM2 ) = ? (Given and Returned)
      }{
         The array to have its borders set to a constant.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         array and value to be substituted that are supplied to the routine
         must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_CADDx
}{
   Add a constant to each element of a vectorised array
}{
   \sstdescription{
      The routine adds a constant to each element of a vectorised array
      to produce a new array. Bad value checking is performed if
      required.
   }
   \sstinvocation{
      CALL KPG1\_CADDx( BAD, EL, A, CONST, B, NERR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         A( EL ) = ? (Given)
      }{
         Input array.
      }
      \sstsubsection{
         CONST = DOUBLE PRECISION (Given)
      }{
         Constant to be added to each array element.
      }
      \sstsubsection{
         B( EL ) = ? (Returned)
      }{
         Output array.
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays supplied to the routine must have the data type specified.

         \sstitem
         This routine will handle numerical errors (i.e. overflow) by
         assigning the appropriate {\tt "}bad{\tt "} value to affected output array
         elements. If the constant supplied cannot be converted to the
         data type of the arrays without overflow, then all elements of
         the output array will be assigned this bad value and NERR will
         return the value of EL.
      }
   }
}
\sstroutine{
   KPG1\_CADDx
}{
   Add a constant to each element of a vectorised array
}{
   \sstdescription{
      The routine adds a constant to each element of a vectorised array
      to produce a new array. Bad value checking is performed if
      required.
   }
   \sstinvocation{
      CALL KPG1\_CADDx( BAD, EL, A, CONST, B, NERR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         A( EL ) = ? (Given)
      }{
         Input array.
      }
      \sstsubsection{
         CONST = DOUBLE PRECISION (Given)
      }{
         Constant to be added to each array element.
      }
      \sstsubsection{
         B( EL ) = ? (Returned)
      }{
         Output array.
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays supplied to the routine must have the data type specified.

         \sstitem
         This routine will handle numerical errors (i.e. overflow) by
         assigning the appropriate {\tt "}bad{\tt "} value to affected output array
         elements. If the constant supplied cannot be converted to the
         data type of the arrays without overflow, then all elements of
         the output array will be assigned this bad value and NERR will
         return the value of EL.
      }
   }
}
\sstroutine{
   KPG1\_CADDx
}{
   Add a constant to each element of a vectorised array
}{
   \sstdescription{
      The routine adds a constant to each element of a vectorised array
      to produce a new array. Bad value checking is performed if
      required.
   }
   \sstinvocation{
      CALL KPG1\_CADDx( BAD, EL, A, CONST, B, NERR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         A( EL ) = ? (Given)
      }{
         Input array.
      }
      \sstsubsection{
         CONST = DOUBLE PRECISION (Given)
      }{
         Constant to be added to each array element.
      }
      \sstsubsection{
         B( EL ) = ? (Returned)
      }{
         Output array.
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays supplied to the routine must have the data type specified.

         \sstitem
         This routine will handle numerical errors (i.e. overflow) by
         assigning the appropriate {\tt "}bad{\tt "} value to affected output array
         elements. If the constant supplied cannot be converted to the
         data type of the arrays without overflow, then all elements of
         the output array will be assigned this bad value and NERR will
         return the value of EL.
      }
   }
}
\sstroutine{
   KPG1\_CADDx
}{
   Add a constant to each element of a vectorised array
}{
   \sstdescription{
      The routine adds a constant to each element of a vectorised array
      to produce a new array. Bad value checking is performed if
      required.
   }
   \sstinvocation{
      CALL KPG1\_CADDx( BAD, EL, A, CONST, B, NERR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         A( EL ) = ? (Given)
      }{
         Input array.
      }
      \sstsubsection{
         CONST = DOUBLE PRECISION (Given)
      }{
         Constant to be added to each array element.
      }
      \sstsubsection{
         B( EL ) = ? (Returned)
      }{
         Output array.
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays supplied to the routine must have the data type specified.

         \sstitem
         This routine will handle numerical errors (i.e. overflow) by
         assigning the appropriate {\tt "}bad{\tt "} value to affected output array
         elements. If the constant supplied cannot be converted to the
         data type of the arrays without overflow, then all elements of
         the output array will be assigned this bad value and NERR will
         return the value of EL.
      }
   }
}
\sstroutine{
   KPG1\_CADDx
}{
   Add a constant to each element of a vectorised array
}{
   \sstdescription{
      The routine adds a constant to each element of a vectorised array
      to produce a new array. Bad value checking is performed if
      required.
   }
   \sstinvocation{
      CALL KPG1\_CADDx( BAD, EL, A, CONST, B, NERR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         A( EL ) = ? (Given)
      }{
         Input array.
      }
      \sstsubsection{
         CONST = DOUBLE PRECISION (Given)
      }{
         Constant to be added to each array element.
      }
      \sstsubsection{
         B( EL ) = ? (Returned)
      }{
         Output array.
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays supplied to the routine must have the data type specified.

         \sstitem
         This routine will handle numerical errors (i.e. overflow) by
         assigning the appropriate {\tt "}bad{\tt "} value to affected output array
         elements. If the constant supplied cannot be converted to the
         data type of the arrays without overflow, then all elements of
         the output array will be assigned this bad value and NERR will
         return the value of EL.
      }
   }
}
\sstroutine{
   KPG1\_CADDx
}{
   Add a constant to each element of a vectorised array
}{
   \sstdescription{
      The routine adds a constant to each element of a vectorised array
      to produce a new array. Bad value checking is performed if
      required.
   }
   \sstinvocation{
      CALL KPG1\_CADDx( BAD, EL, A, CONST, B, NERR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         A( EL ) = ? (Given)
      }{
         Input array.
      }
      \sstsubsection{
         CONST = DOUBLE PRECISION (Given)
      }{
         Constant to be added to each array element.
      }
      \sstsubsection{
         B( EL ) = ? (Returned)
      }{
         Output array.
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays supplied to the routine must have the data type specified.

         \sstitem
         This routine will handle numerical errors (i.e. overflow) by
         assigning the appropriate {\tt "}bad{\tt "} value to affected output array
         elements. If the constant supplied cannot be converted to the
         data type of the arrays without overflow, then all elements of
         the output array will be assigned this bad value and NERR will
         return the value of EL.
      }
   }
}
\sstroutine{
   KPG1\_CADDx
}{
   Add a constant to each element of a vectorised array
}{
   \sstdescription{
      The routine adds a constant to each element of a vectorised array
      to produce a new array. Bad value checking is performed if
      required.
   }
   \sstinvocation{
      CALL KPG1\_CADDx( BAD, EL, A, CONST, B, NERR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         A( EL ) = ? (Given)
      }{
         Input array.
      }
      \sstsubsection{
         CONST = DOUBLE PRECISION (Given)
      }{
         Constant to be added to each array element.
      }
      \sstsubsection{
         B( EL ) = ? (Returned)
      }{
         Output array.
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays supplied to the routine must have the data type specified.

         \sstitem
         This routine will handle numerical errors (i.e. overflow) by
         assigning the appropriate {\tt "}bad{\tt "} value to affected output array
         elements. If the constant supplied cannot be converted to the
         data type of the arrays without overflow, then all elements of
         the output array will be assigned this bad value and NERR will
         return the value of EL.
      }
   }
}
\sstroutine{
   KPG1\_CCPRO
}{
   Gets a character component for an output NDF with optional
   propagation from another NDF
}{
   \sstdescription{
      This routine uses the parameter sysyem to obtain a value for a
      selected character component of an output or updated NDF.  If the
      null value is supplied, the character component is copied from
      an input NDF to the output NDF, unless the component is undefined,
      in the input, in which case it is left undefined in the output.
   }
   \sstinvocation{
      CALL KPG1\_CCPRO( PNCOMP, COMP, NDFI, NDFO, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNCOMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the ADAM parameter used to obtain the character
         component{\tt '}s value.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the character component.  It must be {\tt '}TITLE{\tt '},
         {\tt '}LABEL{\tt '}, or {\tt '}UNITS{\tt '}.
      }
      \sstsubsection{
         NDFI = INTEGER (Given)
      }{
         The identifier of the input NDF from which a character component
         is to be copied to the output NDF.
      }
      \sstsubsection{
         NDFO = INTEGER (Given)
      }{
         The identifier of the output or updated NDF to which a
         character component is to be written.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_CEIL
}{
   Return the smallest integer larger than or equal to a supplied value
}{
   \sstdescription{
      This routine returns the smallest integer larger than or equal to
      a supplied value.
   }
   \sstinvocation{
      RESULT = KPG1\_CEIL( VALUE )
   }
   \sstarguments{
      \sstsubsection{
         VALUE = REAL (Given)
      }{
         The value.
      }
   }
   \sstdiytopic{
      Function Value
   }{
      KPG1\_CEIL = INTEGER
         The smallest integer larger than or equal to the supplied value.
   }
}
\sstroutine{
   KPG1\_CHAXx
}{
   Check for usable AXIS structures
}{
   \sstdescription{
      This routine looks for monotonic AXIS structures within the
      specified axes of the supplied NDF.  If all axes have such AXIS
      structures, then a flag (DATAVL) is returned .TRUE..  If any axis
      is non-monotonic, a warning message is issued, DATAVL is returned
      .FALSE., and a scale of 1.0 and offset of 0.0 are returned.

      Each axis is then checked for linearity.  If the axis is linear,
      then the corresponding scale and offset of the linear mapping from
      pixel to data co-ordinates are returned.  Otherwise a warning
      message is issued and the returned scale and offset refer to a
      linear approximation to the axis co-ordinate system.
   }
   \sstinvocation{
      CALL KPG1\_CHAXx( INDF, NDIM, DIM, DATAVL, SCALE, OFFSET, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         An identifier for the NDF.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of axes.
      }
      \sstsubsection{
         DIM( NDIM ) = INTEGER (Given)
      }{
         The indices of the axes to be checked, in increasing order.
      }
      \sstsubsection{
         DATAVL = LOGICAL (Returned)
      }{
         Returned .TRUE. if the NDF contains monotonic AXIS structures
         for all requested axes.  Returned .FALSE. otherwise.
      }
      \sstsubsection{
         SCALE( NDIM ) = ? (Returned)
      }{
         The scale factors in the linear relationships between axis
         co-ordinates and pixel co-ordinates.  Returned equal to 1.0 if
         DATVAL is returned .FALSE..
      }
      \sstsubsection{
         OFFSET( NDIM ) = ? (Returned)
      }{
         The offsets in the linear relationships between axis
         co-ordinates and pixel co-ordinates.  Returned equal to 0.0 if
         DATVAL is returned .FALSE..
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the real and double-precision
         data types: replace {\tt "}x{\tt "} in the routine name by D or R as
         appropriate.  The SCALE and OFFSET arrays supplied to the routine
         must have the data type specified.

         \sstitem
         The returned values of SCALE and OFFSET are such that:

      }
         DATA = SCALE( I ) $*$ PIXEL $+$ OFFSET( I )

      where PIXEL is a pixel co-ordinate for the I{\tt '}th dimension listed
      in array DIM (i.e. dimension DIM( I ) ), and DATA is the
      corresponding axis co-ordinate.
   }
}
\sstroutine{
   KPG1\_CHAXx
}{
   Check for usable AXIS structures
}{
   \sstdescription{
      This routine looks for monotonic AXIS structures within the
      specified axes of the supplied NDF.  If all axes have such AXIS
      structures, then a flag (DATAVL) is returned .TRUE..  If any axis
      is non-monotonic, a warning message is issued, DATAVL is returned
      .FALSE., and a scale of 1.0 and offset of 0.0 are returned.

      Each axis is then checked for linearity.  If the axis is linear,
      then the corresponding scale and offset of the linear mapping from
      pixel to data co-ordinates are returned.  Otherwise a warning
      message is issued and the returned scale and offset refer to a
      linear approximation to the axis co-ordinate system.
   }
   \sstinvocation{
      CALL KPG1\_CHAXx( INDF, NDIM, DIM, DATAVL, SCALE, OFFSET, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         An identifier for the NDF.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of axes.
      }
      \sstsubsection{
         DIM( NDIM ) = INTEGER (Given)
      }{
         The indices of the axes to be checked, in increasing order.
      }
      \sstsubsection{
         DATAVL = LOGICAL (Returned)
      }{
         Returned .TRUE. if the NDF contains monotonic AXIS structures
         for all requested axes.  Returned .FALSE. otherwise.
      }
      \sstsubsection{
         SCALE( NDIM ) = ? (Returned)
      }{
         The scale factors in the linear relationships between axis
         co-ordinates and pixel co-ordinates.  Returned equal to 1.0 if
         DATVAL is returned .FALSE..
      }
      \sstsubsection{
         OFFSET( NDIM ) = ? (Returned)
      }{
         The offsets in the linear relationships between axis
         co-ordinates and pixel co-ordinates.  Returned equal to 0.0 if
         DATVAL is returned .FALSE..
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the real and double-precision
         data types: replace {\tt "}x{\tt "} in the routine name by D or R as
         appropriate.  The SCALE and OFFSET arrays supplied to the routine
         must have the data type specified.

         \sstitem
         The returned values of SCALE and OFFSET are such that:

      }
         DATA = SCALE( I ) $*$ PIXEL $+$ OFFSET( I )

      where PIXEL is a pixel co-ordinate for the I{\tt '}th dimension listed
      in array DIM (i.e. dimension DIM( I ) ), and DATA is the
      corresponding axis co-ordinate.
   }
}
\sstroutine{
   KPG1\_CHE2X
}{
   Evaluates a 2-dimensional Chebyshev polynomial
}{
   \sstdescription{
      This routine evaluates a two-dimensional Chebyshev polynomial for
      one or more arguments.  It uses Clenshaw{\tt '}s recurrence
      relationship twice.
   }
   \sstinvocation{
      CALL KPG1\_CHE2X( NPTS, XMIN, XMAX, X, YMIN, YMAX, Y, XDEG,
                       YDEG, NCOEF, CC, NW, WORK, EVAL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         XMIN = ? (Given)
      }{
         The lower endpoint of the range of the fit along the first
         dimension.  The Chebyshev series representation is in terms of
         a normalised variable, evaluated as (2x - (XMAX $+$ XMIN) ) /
         (XMAX - XMIN), where x is the original variable.  XMIN must be
         less than XMAX.
      }
      \sstsubsection{
         XMAX = ? (Given)
      }{
         The upper endpoint of the range of the fit along the second
         dimension.  See XMIN.
      }
      \sstsubsection{
         X( NPTS ) = ? (Given)
      }{
         The co-ordinates along the first dimension for which the
         Chebyshev polynomial is to be evaluated.
      }
      \sstsubsection{
         YMIN = ? (Given)
      }{
         The lower endpoint of the range of the fit along the first
         dimension.  The Chebyshev series representation is in terms of
         a normalised variable, evaluated as (2y - (YMAX $+$ YMIN) ) /
         (YMAX - YMIN), where y is the original variable.  YMIN must be
         less than YMAX.
      }
      \sstsubsection{
         YMAX = ? (Given)
      }{
         The upper endpoint of the range of the fit along the second
         dimension.  See YMIN.
      }
      \sstsubsection{
         Y = ? (Given)
      }{
         The co-ordinate along the second dimension for which the
         Chebyshev polynomial is to be evaluated.
      }
      \sstsubsection{
         XDEG = INTEGER (Given)
      }{
         The degree of the polynomial along the first dimension.
      }
      \sstsubsection{
         YDEG = INTEGER (Given)
      }{
         The degree of the polynomial along the second dimension.
      }
      \sstsubsection{
         MCOEF = INTEGER (Given)
      }{
         The number of coefficients.  This must be at least the product
         of (XDEG$+$1) $*$ (YDEG$+$1).
      }
      \sstsubsection{
         CC( MCOEF ) = ? (Given)
      }{
         The Chebyshev coefficients.  These should be the order such
         that CCij is in CC( i$*$(YDEG$+$1)$+$j$+$1 ) for i=0,XDEG; j=0,YDEG.
         In other words the opposite order to Fortran standard.
      }
      \sstsubsection{
         NW = INTEGER (Given)
      }{
         The number of elements in the work array.  It must be at least
         XDEG $+$ 1.
      }
      \sstsubsection{
         WORK( NW ) = ? (Returned)
      }{
         Workspace.
      }
      \sstsubsection{
         EVAL( NPTS ) = ? (Returned)
      }{
         The evaluated polynomial for the supplied arguments.  Should an
         argument lie beyond the range ([XMIN,XMAX], [YMIN,YMAX] the
         bad value is returned in the corresponding element of EVAL.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for the real and double precision data types:
      replace {\tt "}x{\tt "} in the routine name by R or D respectively.  The
      XMIN, XMAX, X, YMIN, YMAX, Y, CC, WORK, and EVAL arguments
      supplied to the routine must have the data type specified.
   }
}
\sstroutine{
   KPG1\_CHE2X
}{
   Evaluates a 2-dimensional Chebyshev polynomial
}{
   \sstdescription{
      This routine evaluates a two-dimensional Chebyshev polynomial for
      one or more arguments.  It uses Clenshaw{\tt '}s recurrence
      relationship twice.
   }
   \sstinvocation{
      CALL KPG1\_CHE2X( NPTS, XMIN, XMAX, X, YMIN, YMAX, Y, XDEG,
                       YDEG, NCOEF, CC, NW, WORK, EVAL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         XMIN = ? (Given)
      }{
         The lower endpoint of the range of the fit along the first
         dimension.  The Chebyshev series representation is in terms of
         a normalised variable, evaluated as (2x - (XMAX $+$ XMIN) ) /
         (XMAX - XMIN), where x is the original variable.  XMIN must be
         less than XMAX.
      }
      \sstsubsection{
         XMAX = ? (Given)
      }{
         The upper endpoint of the range of the fit along the second
         dimension.  See XMIN.
      }
      \sstsubsection{
         X( NPTS ) = ? (Given)
      }{
         The co-ordinates along the first dimension for which the
         Chebyshev polynomial is to be evaluated.
      }
      \sstsubsection{
         YMIN = ? (Given)
      }{
         The lower endpoint of the range of the fit along the first
         dimension.  The Chebyshev series representation is in terms of
         a normalised variable, evaluated as (2y - (YMAX $+$ YMIN) ) /
         (YMAX - YMIN), where y is the original variable.  YMIN must be
         less than YMAX.
      }
      \sstsubsection{
         YMAX = ? (Given)
      }{
         The upper endpoint of the range of the fit along the second
         dimension.  See YMIN.
      }
      \sstsubsection{
         Y = ? (Given)
      }{
         The co-ordinate along the second dimension for which the
         Chebyshev polynomial is to be evaluated.
      }
      \sstsubsection{
         XDEG = INTEGER (Given)
      }{
         The degree of the polynomial along the first dimension.
      }
      \sstsubsection{
         YDEG = INTEGER (Given)
      }{
         The degree of the polynomial along the second dimension.
      }
      \sstsubsection{
         MCOEF = INTEGER (Given)
      }{
         The number of coefficients.  This must be at least the product
         of (XDEG$+$1) $*$ (YDEG$+$1).
      }
      \sstsubsection{
         CC( MCOEF ) = ? (Given)
      }{
         The Chebyshev coefficients.  These should be the order such
         that CCij is in CC( i$*$(YDEG$+$1)$+$j$+$1 ) for i=0,XDEG; j=0,YDEG.
         In other words the opposite order to Fortran standard.
      }
      \sstsubsection{
         NW = INTEGER (Given)
      }{
         The number of elements in the work array.  It must be at least
         XDEG $+$ 1.
      }
      \sstsubsection{
         WORK( NW ) = ? (Returned)
      }{
         Workspace.
      }
      \sstsubsection{
         EVAL( NPTS ) = ? (Returned)
      }{
         The evaluated polynomial for the supplied arguments.  Should an
         argument lie beyond the range ([XMIN,XMAX], [YMIN,YMAX] the
         bad value is returned in the corresponding element of EVAL.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for the real and double precision data types:
      replace {\tt "}x{\tt "} in the routine name by R or D respectively.  The
      XMIN, XMAX, X, YMIN, YMAX, Y, CC, WORK, and EVAL arguments
      supplied to the routine must have the data type specified.
   }
}
\sstroutine{
   KPG1\_CHELx
}{
   Replaces the value of an array element with a specified value
}{
   \sstdescription{
      This routine replaces a specified element of a vectorised array
      with a supplied value and returns the former value of the
      element.
   }
   \sstinvocation{
      CALL KPG1\_CHELx( EL, CHEL, NEWVAL, ARRAY, OLDVAL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the array.
      }
      \sstsubsection{
         CHEL = INTEGER (Given)
      }{
         The element number to be replaced.  It must lie between 1 and
         EL, otherwise an error report is made.
      }
      \sstsubsection{
         NEWVAL = ? (Given)
      }{
         The new value of the element.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given and Replaced)
      }{
         The array whose value is to be replaced.
      }
      \sstsubsection{
         OLDVAL = ? (Returned)
      }{
         The former value of the array element.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in the routine name by I, R, or D as
         appropriate.  Arguments ARRAY, NEWVAL and OLDVAL must have the
         data type specified.
      }
   }
}
\sstroutine{
   KPG1\_CHELx
}{
   Replaces the value of an array element with a specified value
}{
   \sstdescription{
      This routine replaces a specified element of a vectorised array
      with a supplied value and returns the former value of the
      element.
   }
   \sstinvocation{
      CALL KPG1\_CHELx( EL, CHEL, NEWVAL, ARRAY, OLDVAL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the array.
      }
      \sstsubsection{
         CHEL = INTEGER (Given)
      }{
         The element number to be replaced.  It must lie between 1 and
         EL, otherwise an error report is made.
      }
      \sstsubsection{
         NEWVAL = ? (Given)
      }{
         The new value of the element.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given and Replaced)
      }{
         The array whose value is to be replaced.
      }
      \sstsubsection{
         OLDVAL = ? (Returned)
      }{
         The former value of the array element.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in the routine name by I, R, or D as
         appropriate.  Arguments ARRAY, NEWVAL and OLDVAL must have the
         data type specified.
      }
   }
}
\sstroutine{
   KPG1\_CHELx
}{
   Replaces the value of an array element with a specified value
}{
   \sstdescription{
      This routine replaces a specified element of a vectorised array
      with a supplied value and returns the former value of the
      element.
   }
   \sstinvocation{
      CALL KPG1\_CHELx( EL, CHEL, NEWVAL, ARRAY, OLDVAL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the array.
      }
      \sstsubsection{
         CHEL = INTEGER (Given)
      }{
         The element number to be replaced.  It must lie between 1 and
         EL, otherwise an error report is made.
      }
      \sstsubsection{
         NEWVAL = ? (Given)
      }{
         The new value of the element.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given and Replaced)
      }{
         The array whose value is to be replaced.
      }
      \sstsubsection{
         OLDVAL = ? (Returned)
      }{
         The former value of the array element.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in the routine name by I, R, or D as
         appropriate.  Arguments ARRAY, NEWVAL and OLDVAL must have the
         data type specified.
      }
   }
}
\sstroutine{
   KPG1\_CHEPx
}{
   Evaluates a Chebyshev polynomial
}{
   \sstdescription{
      This evaluates a Chebyshev polynomial for orders zero to NTERM-1
      at a given normalised [-1,$+$1] co-ordinate.   It uses a recurrence
      relationship to evaluate beyond the second term.
   }
   \sstinvocation{
      CALL KPG1\_CHEPx( X, NTERM, T, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         X = ? (Given)
      }{
         The normalised co-ordinate for which the Chebyshev polynomial
         is to be evaluated.  It is assumed to lie in the range
         [-1,$+$1] having been normalised using the limits that created
         the coefficients.
      }
      \sstsubsection{
         NTERM = INTEGER (Given)
      }{
         The number of terms in the Chebyshev polynomial.  It equals the
         order plus one.
      }
      \sstsubsection{
         T( NTERM ) = ? (Returned)
      }{
         The evaluated Chebyshev polynomial for each term.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         T. Hopkins \& C.Phillips, 1988, {\tt "}Numerical Methods in Practice{\tt "},
         Addison-Wesley, p.190-191.
         [routine\_references]...
      }
   }
}
\sstroutine{
   KPG1\_CHEPx
}{
   Evaluates a Chebyshev polynomial
}{
   \sstdescription{
      This evaluates a Chebyshev polynomial for orders zero to NTERM-1
      at a given normalised [-1,$+$1] co-ordinate.   It uses a recurrence
      relationship to evaluate beyond the second term.
   }
   \sstinvocation{
      CALL KPG1\_CHEPx( X, NTERM, T, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         X = ? (Given)
      }{
         The normalised co-ordinate for which the Chebyshev polynomial
         is to be evaluated.  It is assumed to lie in the range
         [-1,$+$1] having been normalised using the limits that created
         the coefficients.
      }
      \sstsubsection{
         NTERM = INTEGER (Given)
      }{
         The number of terms in the Chebyshev polynomial.  It equals the
         order plus one.
      }
      \sstsubsection{
         T( NTERM ) = ? (Returned)
      }{
         The evaluated Chebyshev polynomial for each term.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         T. Hopkins \& C.Phillips, 1988, {\tt "}Numerical Methods in Practice{\tt "},
         Addison-Wesley, p.190-191.
         [routine\_references]...
      }
   }
}
\sstroutine{
   KPG1\_CHEVx
}{
   Evaluates a one-dimensional Chebyshev polynomial
}{
   \sstdescription{
      This routine evaluates a one-dimensional Chebyshev polynomial for
      one or more arguments.  It uses Clenshaw{\tt '}s recurrence
      relationship.
   }
   \sstinvocation{
      CALL KPG1\_CHEVx( XMIN, XMAX, NCOEF, CHCOEF, NPTS, X, EVAL,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         XMIN = ? (Given)
      }{
         The lower endpoint of the range of the fit.  The Chebyshev
         series representation is in terms of a normalised variable,
         evaluated as ( 2x - (XMAX $+$ XMIN) ) / (XMAX - XMIN), where x
         is the original variable.  XMIN must be less than XMAX.
      }
      \sstsubsection{
         XMAX = ? (Given)
      }{
         The upper endpoint of the range of the fit.  See XMIN.
      }
      \sstsubsection{
         NCOEF = INTEGER (Given)
      }{
         The number of coefficients.  This must be at least the
         polynomial order plus one.
      }
      \sstsubsection{
         CC( NCOEF ) = ? (Given)
      }{
         The Chebyshev coefficients.
      }
      \sstsubsection{
         NPTS = INTEGER (Given)
      }{
         The number of arguments for which the Chebyshev polynomial is
         to be evaluated.
      }
      \sstsubsection{
         X( NPTS ) = ? (Given)
      }{
         The arguments for which the Chebyshev polynomial is to be
         evaluated.
      }
      \sstsubsection{
         EVAL( NPTS ) = ? (Returned)
      }{
         The evaluated polynomial for the supplied arguments.  Should an
         argument lie beyond the range [XMIN,XMAX], the bad value is
         returned in the corresponding element of EVAL.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for the real and double precision data types:
      replace {\tt "}x{\tt "} in the routine name by R or D respectively.  The
      XMIN, XMAX, CC, X, and EVAL arguments supplied to the routine
      must have the data type specified.
   }
}
\sstroutine{
   KPG1\_CHEVx
}{
   Evaluates a one-dimensional Chebyshev polynomial
}{
   \sstdescription{
      This routine evaluates a one-dimensional Chebyshev polynomial for
      one or more arguments.  It uses Clenshaw{\tt '}s recurrence
      relationship.
   }
   \sstinvocation{
      CALL KPG1\_CHEVx( XMIN, XMAX, NCOEF, CHCOEF, NPTS, X, EVAL,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         XMIN = ? (Given)
      }{
         The lower endpoint of the range of the fit.  The Chebyshev
         series representation is in terms of a normalised variable,
         evaluated as ( 2x - (XMAX $+$ XMIN) ) / (XMAX - XMIN), where x
         is the original variable.  XMIN must be less than XMAX.
      }
      \sstsubsection{
         XMAX = ? (Given)
      }{
         The upper endpoint of the range of the fit.  See XMIN.
      }
      \sstsubsection{
         NCOEF = INTEGER (Given)
      }{
         The number of coefficients.  This must be at least the
         polynomial order plus one.
      }
      \sstsubsection{
         CC( NCOEF ) = ? (Given)
      }{
         The Chebyshev coefficients.
      }
      \sstsubsection{
         NPTS = INTEGER (Given)
      }{
         The number of arguments for which the Chebyshev polynomial is
         to be evaluated.
      }
      \sstsubsection{
         X( NPTS ) = ? (Given)
      }{
         The arguments for which the Chebyshev polynomial is to be
         evaluated.
      }
      \sstsubsection{
         EVAL( NPTS ) = ? (Returned)
      }{
         The evaluated polynomial for the supplied arguments.  Should an
         argument lie beyond the range [XMIN,XMAX], the bad value is
         returned in the corresponding element of EVAL.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for the real and double precision data types:
      replace {\tt "}x{\tt "} in the routine name by R or D respectively.  The
      XMIN, XMAX, CC, X, and EVAL arguments supplied to the routine
      must have the data type specified.
   }
}
\sstroutine{
   KPG1\_CHVAx
}{
   Replaces all occurrences of a value in an array with another
   value
}{
   \sstdescription{
      This routine copies the input array to the output array, except
      where a specified value occurs, and this is replaced with a new
      value throughout the output array.
   }
   \sstinvocation{
      CALL KPG1\_CHVAx( EL, INARR, OLDVAL, NEWVAL, OUTARR, NREP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input and output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The input array.
      }
      \sstsubsection{
         OLDVAL = ? (Given)
      }{
         Value to be replaced.
      }
      \sstsubsection{
         NEWVAL = ? (Given)
      }{
         New value to be substituted for the old value.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         The output array containing the modified values.
      }
      \sstsubsection{
         NREP = INTEGER (Returned)
      }{
         The number of replacements made.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays and values supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_CHVAx
}{
   Replaces all occurrences of a value in an array with another
   value
}{
   \sstdescription{
      This routine copies the input array to the output array, except
      where a specified value occurs, and this is replaced with a new
      value throughout the output array.
   }
   \sstinvocation{
      CALL KPG1\_CHVAx( EL, INARR, OLDVAL, NEWVAL, OUTARR, NREP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input and output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The input array.
      }
      \sstsubsection{
         OLDVAL = ? (Given)
      }{
         Value to be replaced.
      }
      \sstsubsection{
         NEWVAL = ? (Given)
      }{
         New value to be substituted for the old value.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         The output array containing the modified values.
      }
      \sstsubsection{
         NREP = INTEGER (Returned)
      }{
         The number of replacements made.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays and values supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_CHVAx
}{
   Replaces all occurrences of a value in an array with another
   value
}{
   \sstdescription{
      This routine copies the input array to the output array, except
      where a specified value occurs, and this is replaced with a new
      value throughout the output array.
   }
   \sstinvocation{
      CALL KPG1\_CHVAx( EL, INARR, OLDVAL, NEWVAL, OUTARR, NREP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input and output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The input array.
      }
      \sstsubsection{
         OLDVAL = ? (Given)
      }{
         Value to be replaced.
      }
      \sstsubsection{
         NEWVAL = ? (Given)
      }{
         New value to be substituted for the old value.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         The output array containing the modified values.
      }
      \sstsubsection{
         NREP = INTEGER (Returned)
      }{
         The number of replacements made.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays and values supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_CHVAx
}{
   Replaces all occurrences of a value in an array with another
   value
}{
   \sstdescription{
      This routine copies the input array to the output array, except
      where a specified value occurs, and this is replaced with a new
      value throughout the output array.
   }
   \sstinvocation{
      CALL KPG1\_CHVAx( EL, INARR, OLDVAL, NEWVAL, OUTARR, NREP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input and output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The input array.
      }
      \sstsubsection{
         OLDVAL = ? (Given)
      }{
         Value to be replaced.
      }
      \sstsubsection{
         NEWVAL = ? (Given)
      }{
         New value to be substituted for the old value.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         The output array containing the modified values.
      }
      \sstsubsection{
         NREP = INTEGER (Returned)
      }{
         The number of replacements made.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays and values supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_CHVAx
}{
   Replaces all occurrences of a value in an array with another
   value
}{
   \sstdescription{
      This routine copies the input array to the output array, except
      where a specified value occurs, and this is replaced with a new
      value throughout the output array.
   }
   \sstinvocation{
      CALL KPG1\_CHVAx( EL, INARR, OLDVAL, NEWVAL, OUTARR, NREP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input and output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The input array.
      }
      \sstsubsection{
         OLDVAL = ? (Given)
      }{
         Value to be replaced.
      }
      \sstsubsection{
         NEWVAL = ? (Given)
      }{
         New value to be substituted for the old value.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         The output array containing the modified values.
      }
      \sstsubsection{
         NREP = INTEGER (Returned)
      }{
         The number of replacements made.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays and values supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_CHVAx
}{
   Replaces all occurrences of a value in an array with another
   value
}{
   \sstdescription{
      This routine copies the input array to the output array, except
      where a specified value occurs, and this is replaced with a new
      value throughout the output array.
   }
   \sstinvocation{
      CALL KPG1\_CHVAx( EL, INARR, OLDVAL, NEWVAL, OUTARR, NREP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input and output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The input array.
      }
      \sstsubsection{
         OLDVAL = ? (Given)
      }{
         Value to be replaced.
      }
      \sstsubsection{
         NEWVAL = ? (Given)
      }{
         New value to be substituted for the old value.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         The output array containing the modified values.
      }
      \sstsubsection{
         NREP = INTEGER (Returned)
      }{
         The number of replacements made.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays and values supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_CHVAx
}{
   Replaces all occurrences of a value in an array with another
   value
}{
   \sstdescription{
      This routine copies the input array to the output array, except
      where a specified value occurs, and this is replaced with a new
      value throughout the output array.
   }
   \sstinvocation{
      CALL KPG1\_CHVAx( EL, INARR, OLDVAL, NEWVAL, OUTARR, NREP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input and output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The input array.
      }
      \sstsubsection{
         OLDVAL = ? (Given)
      }{
         Value to be replaced.
      }
      \sstsubsection{
         NEWVAL = ? (Given)
      }{
         New value to be substituted for the old value.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         The output array containing the modified values.
      }
      \sstsubsection{
         NREP = INTEGER (Returned)
      }{
         The number of replacements made.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays and values supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_CMADx
}{
   Compresses an n-dimensional array by summing in `rectangular{\tt '}
   boxes
}{
   \sstdescription{
      This routine compresses an n-dimensional array by integer factors
      along each dimension by summing the array values in a rectangular
      box.  The output may be normalised to take account of any bad
      values that may be present.
   }
   \sstinvocation{
      CALL KPG1\_CMADx( NDIM, DIMS, INARR, COMPRS, NLIM, NORMAL, OUTARR,
                       SUM, NUM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The dimensionality of the n-dimensional array.  It must be
         greater than one.  To handle a one-dimensional array, give it
         a second dummy dimension of 1.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the input n-dimensional array.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-dimensional data array.
      }
      \sstsubsection{
         COMPRS( NDIM ) = REAL (Given)
      }{
         The factors along each dimension by which the input array is
         compressed to form the output array.
      }
      \sstsubsection{
         NLIM = INTEGER (Given)
      }{
         The minimum number of good input elements in a compression box
         that permits the corresponding output array element to be good.
         If fewer than NLIM pixels participated in the sum, the output
         pixel will be bad.
      }
      \sstsubsection{
         NORMAL = LOGICAL (Given)
      }{
         If true, the summation is normalised to allow for bad data,
         i.e. the sum with each box is multiplied by the ratio of the
         total number of pixels in the box to the actual number
         included to yield the output pixel value.  If false, the output
         array element just equates to the sum of good pixels within
         each box.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Write)
      }{
         The compressed n-dimensional array.  Its dimension I must be
         given by DIMS( I )/COMPRS( I ).
      }
      \sstsubsection{
         SUM( $*$ ) = ? (Returned)
      }{
         Workspace used for efficiency in computing the summations.
         This should have size at least equal to DIMS( 1 ).
      }
      \sstsubsection{
         NUM( $*$ ) = INTEGER (Returned)
      }{
         Workspace used to count the number of good elements in the
         input box. This should have size at least equal to DIMS( 1 ).
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
         input and output data arrays plus a work space must have the
         data type specified.

         \sstitem
         There is no protection against overflows when the absolute data
         values are very large.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_CMADx
}{
   Compresses an n-dimensional array by summing in `rectangular{\tt '}
   boxes
}{
   \sstdescription{
      This routine compresses an n-dimensional array by integer factors
      along each dimension by summing the array values in a rectangular
      box.  The output may be normalised to take account of any bad
      values that may be present.
   }
   \sstinvocation{
      CALL KPG1\_CMADx( NDIM, DIMS, INARR, COMPRS, NLIM, NORMAL, OUTARR,
                       SUM, NUM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The dimensionality of the n-dimensional array.  It must be
         greater than one.  To handle a one-dimensional array, give it
         a second dummy dimension of 1.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the input n-dimensional array.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-dimensional data array.
      }
      \sstsubsection{
         COMPRS( NDIM ) = REAL (Given)
      }{
         The factors along each dimension by which the input array is
         compressed to form the output array.
      }
      \sstsubsection{
         NLIM = INTEGER (Given)
      }{
         The minimum number of good input elements in a compression box
         that permits the corresponding output array element to be good.
         If fewer than NLIM pixels participated in the sum, the output
         pixel will be bad.
      }
      \sstsubsection{
         NORMAL = LOGICAL (Given)
      }{
         If true, the summation is normalised to allow for bad data,
         i.e. the sum with each box is multiplied by the ratio of the
         total number of pixels in the box to the actual number
         included to yield the output pixel value.  If false, the output
         array element just equates to the sum of good pixels within
         each box.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Write)
      }{
         The compressed n-dimensional array.  Its dimension I must be
         given by DIMS( I )/COMPRS( I ).
      }
      \sstsubsection{
         SUM( $*$ ) = ? (Returned)
      }{
         Workspace used for efficiency in computing the summations.
         This should have size at least equal to DIMS( 1 ).
      }
      \sstsubsection{
         NUM( $*$ ) = INTEGER (Returned)
      }{
         Workspace used to count the number of good elements in the
         input box. This should have size at least equal to DIMS( 1 ).
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
         input and output data arrays plus a work space must have the
         data type specified.

         \sstitem
         There is no protection against overflows when the absolute data
         values are very large.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_CMAVx
}{
   Compresses an n-dimensional array by averaging in `rectangular{\tt '}
   boxes
}{
   \sstdescription{
      This routine compresses an n-dimensional array by integer factors
      along each dimension by averaging the array values in a
      rectangular box.
   }
   \sstinvocation{
      CALL KPG1\_CMAVx( NDIM, DIMS, INARR, COMPRS, NLIM, OUTARR,
                       SUM, NUM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The dimensionality of the n-dimensional array.  It must be
         greater than one.  To handle a one-dimensional array, give it
         a second dummy dimension of 1.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the input n-dimensional array.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-dimensional data array.
      }
      \sstsubsection{
         COMPRS( NDIM ) = REAL (Given)
      }{
         The factors along each dimension by which the input array is
         compressed to form the output array.
      }
      \sstsubsection{
         NLIM = INTEGER (Given)
      }{
         The minimum number of good input elements in a compression box
         that permits the corresponding output array element to be good.
         If fewer than NLIM pixels participated in the sum, the output
         pixel will be bad.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Write)
      }{
         The compressed n-dimensional array.  Its dimension I must be
         given by DIMS( I )/COMPRS( I ).
      }
      \sstsubsection{
         SUM( $*$ ) = ? (Returned)
      }{
         Workspace used for efficiency in computing the summations.
         This should have size at least equal to DIMS( 1 ).
      }
      \sstsubsection{
         NUM( $*$ ) = INTEGER (Returned)
      }{
         Workspace used to count the number of good elements in the
         input box. This should have size at least equal to DIMS( 1 ).
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
         input and output data arrays plus a work space must have the
         data type specified.

         \sstitem
         There is no protection against overflows when the absolute data
         values are very large.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_CMAVx
}{
   Compresses an n-dimensional array by averaging in `rectangular{\tt '}
   boxes
}{
   \sstdescription{
      This routine compresses an n-dimensional array by integer factors
      along each dimension by averaging the array values in a
      rectangular box.
   }
   \sstinvocation{
      CALL KPG1\_CMAVx( NDIM, DIMS, INARR, COMPRS, NLIM, OUTARR,
                       SUM, NUM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The dimensionality of the n-dimensional array.  It must be
         greater than one.  To handle a one-dimensional array, give it
         a second dummy dimension of 1.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the input n-dimensional array.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-dimensional data array.
      }
      \sstsubsection{
         COMPRS( NDIM ) = REAL (Given)
      }{
         The factors along each dimension by which the input array is
         compressed to form the output array.
      }
      \sstsubsection{
         NLIM = INTEGER (Given)
      }{
         The minimum number of good input elements in a compression box
         that permits the corresponding output array element to be good.
         If fewer than NLIM pixels participated in the sum, the output
         pixel will be bad.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Write)
      }{
         The compressed n-dimensional array.  Its dimension I must be
         given by DIMS( I )/COMPRS( I ).
      }
      \sstsubsection{
         SUM( $*$ ) = ? (Returned)
      }{
         Workspace used for efficiency in computing the summations.
         This should have size at least equal to DIMS( 1 ).
      }
      \sstsubsection{
         NUM( $*$ ) = INTEGER (Returned)
      }{
         Workspace used to count the number of good elements in the
         input box. This should have size at least equal to DIMS( 1 ).
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
         input and output data arrays plus a work space must have the
         data type specified.

         \sstitem
         There is no protection against overflows when the absolute data
         values are very large.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_CMPKx
}{
   Compresses an n-dimensional array by picking value at equally
   spaced intervals
}{
   \sstdescription{
      This routine compresses an n-dimensional array by integer factors
      along each dimension by selecting the array values at equal
      intervals along each dimension.  The intervals may be different
      in each dimension.  The starting point may be defined.  Bad
      values will just be copied like any other array value.
   }
   \sstinvocation{
      CALL KPG1\_CMPKx( NDIM, DIMS, INARR, COMPRS, OFFSET, OUTARR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The dimensionality of the n-dimensional array.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the input n-dimensional array.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-dimensional data array.
      }
      \sstsubsection{
         COMPRS( NDIM ) = REAL (Given)
      }{
         The factors along each dimension by which the input array is
         compressed to form the output array.
      }
      \sstsubsection{
         OFFSET( NDIM ) = REAL (Given)
      }{
         The pixel indices of the first input-array element that is to
         be put into the output array.  Subsequent selections are
         COMPRS pixels along, so these can be regarded as offsets of the
         selections.  The Ith offset must lie in the range 1 to
         COMPRS( I ).
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Write)
      }{
         The compressed n-dimensional array.  Its dimension I must be
         given by ( DIMS( I ) - OFFSET( I ) ) / COMPRS( I ) $+$ 1.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the all numeric data types: replace {\tt "}x{\tt "}
         in the routine name by B, D, I, R, UB, UW, or W as appropriate.
         The input and output data arrays must have the data type
         specified.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_CMPKx
}{
   Compresses an n-dimensional array by picking value at equally
   spaced intervals
}{
   \sstdescription{
      This routine compresses an n-dimensional array by integer factors
      along each dimension by selecting the array values at equal
      intervals along each dimension.  The intervals may be different
      in each dimension.  The starting point may be defined.  Bad
      values will just be copied like any other array value.
   }
   \sstinvocation{
      CALL KPG1\_CMPKx( NDIM, DIMS, INARR, COMPRS, OFFSET, OUTARR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The dimensionality of the n-dimensional array.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the input n-dimensional array.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-dimensional data array.
      }
      \sstsubsection{
         COMPRS( NDIM ) = REAL (Given)
      }{
         The factors along each dimension by which the input array is
         compressed to form the output array.
      }
      \sstsubsection{
         OFFSET( NDIM ) = REAL (Given)
      }{
         The pixel indices of the first input-array element that is to
         be put into the output array.  Subsequent selections are
         COMPRS pixels along, so these can be regarded as offsets of the
         selections.  The Ith offset must lie in the range 1 to
         COMPRS( I ).
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Write)
      }{
         The compressed n-dimensional array.  Its dimension I must be
         given by ( DIMS( I ) - OFFSET( I ) ) / COMPRS( I ) $+$ 1.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the all numeric data types: replace {\tt "}x{\tt "}
         in the routine name by B, D, I, R, UB, UW, or W as appropriate.
         The input and output data arrays must have the data type
         specified.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_CMPKx
}{
   Compresses an n-dimensional array by picking value at equally
   spaced intervals
}{
   \sstdescription{
      This routine compresses an n-dimensional array by integer factors
      along each dimension by selecting the array values at equal
      intervals along each dimension.  The intervals may be different
      in each dimension.  The starting point may be defined.  Bad
      values will just be copied like any other array value.
   }
   \sstinvocation{
      CALL KPG1\_CMPKx( NDIM, DIMS, INARR, COMPRS, OFFSET, OUTARR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The dimensionality of the n-dimensional array.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the input n-dimensional array.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-dimensional data array.
      }
      \sstsubsection{
         COMPRS( NDIM ) = REAL (Given)
      }{
         The factors along each dimension by which the input array is
         compressed to form the output array.
      }
      \sstsubsection{
         OFFSET( NDIM ) = REAL (Given)
      }{
         The pixel indices of the first input-array element that is to
         be put into the output array.  Subsequent selections are
         COMPRS pixels along, so these can be regarded as offsets of the
         selections.  The Ith offset must lie in the range 1 to
         COMPRS( I ).
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Write)
      }{
         The compressed n-dimensional array.  Its dimension I must be
         given by ( DIMS( I ) - OFFSET( I ) ) / COMPRS( I ) $+$ 1.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the all numeric data types: replace {\tt "}x{\tt "}
         in the routine name by B, D, I, R, UB, UW, or W as appropriate.
         The input and output data arrays must have the data type
         specified.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_CMPKx
}{
   Compresses an n-dimensional array by picking value at equally
   spaced intervals
}{
   \sstdescription{
      This routine compresses an n-dimensional array by integer factors
      along each dimension by selecting the array values at equal
      intervals along each dimension.  The intervals may be different
      in each dimension.  The starting point may be defined.  Bad
      values will just be copied like any other array value.
   }
   \sstinvocation{
      CALL KPG1\_CMPKx( NDIM, DIMS, INARR, COMPRS, OFFSET, OUTARR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The dimensionality of the n-dimensional array.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the input n-dimensional array.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-dimensional data array.
      }
      \sstsubsection{
         COMPRS( NDIM ) = REAL (Given)
      }{
         The factors along each dimension by which the input array is
         compressed to form the output array.
      }
      \sstsubsection{
         OFFSET( NDIM ) = REAL (Given)
      }{
         The pixel indices of the first input-array element that is to
         be put into the output array.  Subsequent selections are
         COMPRS pixels along, so these can be regarded as offsets of the
         selections.  The Ith offset must lie in the range 1 to
         COMPRS( I ).
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Write)
      }{
         The compressed n-dimensional array.  Its dimension I must be
         given by ( DIMS( I ) - OFFSET( I ) ) / COMPRS( I ) $+$ 1.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the all numeric data types: replace {\tt "}x{\tt "}
         in the routine name by B, D, I, R, UB, UW, or W as appropriate.
         The input and output data arrays must have the data type
         specified.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_CMPKx
}{
   Compresses an n-dimensional array by picking value at equally
   spaced intervals
}{
   \sstdescription{
      This routine compresses an n-dimensional array by integer factors
      along each dimension by selecting the array values at equal
      intervals along each dimension.  The intervals may be different
      in each dimension.  The starting point may be defined.  Bad
      values will just be copied like any other array value.
   }
   \sstinvocation{
      CALL KPG1\_CMPKx( NDIM, DIMS, INARR, COMPRS, OFFSET, OUTARR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The dimensionality of the n-dimensional array.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the input n-dimensional array.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-dimensional data array.
      }
      \sstsubsection{
         COMPRS( NDIM ) = REAL (Given)
      }{
         The factors along each dimension by which the input array is
         compressed to form the output array.
      }
      \sstsubsection{
         OFFSET( NDIM ) = REAL (Given)
      }{
         The pixel indices of the first input-array element that is to
         be put into the output array.  Subsequent selections are
         COMPRS pixels along, so these can be regarded as offsets of the
         selections.  The Ith offset must lie in the range 1 to
         COMPRS( I ).
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Write)
      }{
         The compressed n-dimensional array.  Its dimension I must be
         given by ( DIMS( I ) - OFFSET( I ) ) / COMPRS( I ) $+$ 1.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the all numeric data types: replace {\tt "}x{\tt "}
         in the routine name by B, D, I, R, UB, UW, or W as appropriate.
         The input and output data arrays must have the data type
         specified.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_CMPKx
}{
   Compresses an n-dimensional array by picking value at equally
   spaced intervals
}{
   \sstdescription{
      This routine compresses an n-dimensional array by integer factors
      along each dimension by selecting the array values at equal
      intervals along each dimension.  The intervals may be different
      in each dimension.  The starting point may be defined.  Bad
      values will just be copied like any other array value.
   }
   \sstinvocation{
      CALL KPG1\_CMPKx( NDIM, DIMS, INARR, COMPRS, OFFSET, OUTARR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The dimensionality of the n-dimensional array.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the input n-dimensional array.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-dimensional data array.
      }
      \sstsubsection{
         COMPRS( NDIM ) = REAL (Given)
      }{
         The factors along each dimension by which the input array is
         compressed to form the output array.
      }
      \sstsubsection{
         OFFSET( NDIM ) = REAL (Given)
      }{
         The pixel indices of the first input-array element that is to
         be put into the output array.  Subsequent selections are
         COMPRS pixels along, so these can be regarded as offsets of the
         selections.  The Ith offset must lie in the range 1 to
         COMPRS( I ).
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Write)
      }{
         The compressed n-dimensional array.  Its dimension I must be
         given by ( DIMS( I ) - OFFSET( I ) ) / COMPRS( I ) $+$ 1.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the all numeric data types: replace {\tt "}x{\tt "}
         in the routine name by B, D, I, R, UB, UW, or W as appropriate.
         The input and output data arrays must have the data type
         specified.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_CMPKx
}{
   Compresses an n-dimensional array by picking value at equally
   spaced intervals
}{
   \sstdescription{
      This routine compresses an n-dimensional array by integer factors
      along each dimension by selecting the array values at equal
      intervals along each dimension.  The intervals may be different
      in each dimension.  The starting point may be defined.  Bad
      values will just be copied like any other array value.
   }
   \sstinvocation{
      CALL KPG1\_CMPKx( NDIM, DIMS, INARR, COMPRS, OFFSET, OUTARR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The dimensionality of the n-dimensional array.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the input n-dimensional array.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-dimensional data array.
      }
      \sstsubsection{
         COMPRS( NDIM ) = REAL (Given)
      }{
         The factors along each dimension by which the input array is
         compressed to form the output array.
      }
      \sstsubsection{
         OFFSET( NDIM ) = REAL (Given)
      }{
         The pixel indices of the first input-array element that is to
         be put into the output array.  Subsequent selections are
         COMPRS pixels along, so these can be regarded as offsets of the
         selections.  The Ith offset must lie in the range 1 to
         COMPRS( I ).
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Write)
      }{
         The compressed n-dimensional array.  Its dimension I must be
         given by ( DIMS( I ) - OFFSET( I ) ) / COMPRS( I ) $+$ 1.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the all numeric data types: replace {\tt "}x{\tt "}
         in the routine name by B, D, I, R, UB, UW, or W as appropriate.
         The input and output data arrays must have the data type
         specified.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_CMULx
}{
   Multiply each element of a vectorised array by a constant
}{
   \sstdescription{
      The routine multiplies each element of a vectorised array by a
      constant to produce a new array. Bad value checking is performed
      if required.
   }
   \sstinvocation{
      CALL KPG1\_CMULx( BAD, EL, A, CONST, B, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         A( EL ) = ? (Given)
      }{
         Input array.
      }
      \sstsubsection{
         CONST = DOUBLE PRECISION (Given)
      }{
         Constant by which each array element is to be multiplied.
      }
      \sstsubsection{
         B( EL ) = ? (Returned)
      }{
         Output array.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         Number of bad values in the output array B.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric type except double
         precision: replace {\tt "}x{\tt "} in the routine name by R, I, W, UW, B or
         UB as appropriate. The arrays supplied to the routine must have
         the data type specified.

         \sstitem
         This routine will handle numerical errors (i.e. overflow) by
         assigning the appropriate {\tt "}bad{\tt "} value to affected output array
         elements.
      }
   }
}
\sstroutine{
   KPG1\_CMULD
}{
   Multiply each element of a vectorised double precision array by a
   constant
}{
   \sstdescription{
      The routine multiplies each element of a vectorised double
      precision array by a constant to produce a new double precision
      array. Bad value checking is performed if required.
   }
   \sstinvocation{
      CALL KPG1\_CMULD( BAD, EL, A, CONST, B, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         A( EL ) = DOUBLE PRECISION (Given)
      }{
         Input array.
      }
      \sstsubsection{
         CONST = DOUBLE PRECISION (Given)
      }{
         Constant by which each array element is to be multiplied.
      }
      \sstsubsection{
         B( EL ) = DOUBLE PRECISION (Returned)
      }{
         Output array.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         Number of bad values in the output array B.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine is intended for processing double precision data
         only. There is a related generic routine for processing other data
         types.

         \sstitem
         This routine will handle numerical errors (i.e. overflow) by
         assigning the appropriate {\tt "}bad{\tt "} value to affected output array
         elements.
      }
   }
}
\sstroutine{
   KPG1\_CMULx
}{
   Multiply each element of a vectorised array by a constant
}{
   \sstdescription{
      The routine multiplies each element of a vectorised array by a
      constant to produce a new array. Bad value checking is performed
      if required.
   }
   \sstinvocation{
      CALL KPG1\_CMULx( BAD, EL, A, CONST, B, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         A( EL ) = ? (Given)
      }{
         Input array.
      }
      \sstsubsection{
         CONST = DOUBLE PRECISION (Given)
      }{
         Constant by which each array element is to be multiplied.
      }
      \sstsubsection{
         B( EL ) = ? (Returned)
      }{
         Output array.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         Number of bad values in the output array B.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric type except double
         precision: replace {\tt "}x{\tt "} in the routine name by R, I, W, UW, B or
         UB as appropriate. The arrays supplied to the routine must have
         the data type specified.

         \sstitem
         This routine will handle numerical errors (i.e. overflow) by
         assigning the appropriate {\tt "}bad{\tt "} value to affected output array
         elements.
      }
   }
}
\sstroutine{
   KPG1\_CMULx
}{
   Multiply each element of a vectorised array by a constant
}{
   \sstdescription{
      The routine multiplies each element of a vectorised array by a
      constant to produce a new array. Bad value checking is performed
      if required.
   }
   \sstinvocation{
      CALL KPG1\_CMULx( BAD, EL, A, CONST, B, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         A( EL ) = ? (Given)
      }{
         Input array.
      }
      \sstsubsection{
         CONST = DOUBLE PRECISION (Given)
      }{
         Constant by which each array element is to be multiplied.
      }
      \sstsubsection{
         B( EL ) = ? (Returned)
      }{
         Output array.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         Number of bad values in the output array B.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric type except double
         precision: replace {\tt "}x{\tt "} in the routine name by R, I, W, UW, B or
         UB as appropriate. The arrays supplied to the routine must have
         the data type specified.

         \sstitem
         This routine will handle numerical errors (i.e. overflow) by
         assigning the appropriate {\tt "}bad{\tt "} value to affected output array
         elements.
      }
   }
}
\sstroutine{
   KPG1\_CMULx
}{
   Multiply each element of a vectorised array by a constant
}{
   \sstdescription{
      The routine multiplies each element of a vectorised array by a
      constant to produce a new array. Bad value checking is performed
      if required.
   }
   \sstinvocation{
      CALL KPG1\_CMULx( BAD, EL, A, CONST, B, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         A( EL ) = ? (Given)
      }{
         Input array.
      }
      \sstsubsection{
         CONST = DOUBLE PRECISION (Given)
      }{
         Constant by which each array element is to be multiplied.
      }
      \sstsubsection{
         B( EL ) = ? (Returned)
      }{
         Output array.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         Number of bad values in the output array B.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric type except double
         precision: replace {\tt "}x{\tt "} in the routine name by R, I, W, UW, B or
         UB as appropriate. The arrays supplied to the routine must have
         the data type specified.

         \sstitem
         This routine will handle numerical errors (i.e. overflow) by
         assigning the appropriate {\tt "}bad{\tt "} value to affected output array
         elements.
      }
   }
}
\sstroutine{
   KPG1\_CMULx
}{
   Multiply each element of a vectorised array by a constant
}{
   \sstdescription{
      The routine multiplies each element of a vectorised array by a
      constant to produce a new array. Bad value checking is performed
      if required.
   }
   \sstinvocation{
      CALL KPG1\_CMULx( BAD, EL, A, CONST, B, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         A( EL ) = ? (Given)
      }{
         Input array.
      }
      \sstsubsection{
         CONST = DOUBLE PRECISION (Given)
      }{
         Constant by which each array element is to be multiplied.
      }
      \sstsubsection{
         B( EL ) = ? (Returned)
      }{
         Output array.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         Number of bad values in the output array B.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric type except double
         precision: replace {\tt "}x{\tt "} in the routine name by R, I, W, UW, B or
         UB as appropriate. The arrays supplied to the routine must have
         the data type specified.

         \sstitem
         This routine will handle numerical errors (i.e. overflow) by
         assigning the appropriate {\tt "}bad{\tt "} value to affected output array
         elements.
      }
   }
}
\sstroutine{
   KPG1\_CMULx
}{
   Multiply each element of a vectorised array by a constant
}{
   \sstdescription{
      The routine multiplies each element of a vectorised array by a
      constant to produce a new array. Bad value checking is performed
      if required.
   }
   \sstinvocation{
      CALL KPG1\_CMULx( BAD, EL, A, CONST, B, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         A( EL ) = ? (Given)
      }{
         Input array.
      }
      \sstsubsection{
         CONST = DOUBLE PRECISION (Given)
      }{
         Constant by which each array element is to be multiplied.
      }
      \sstsubsection{
         B( EL ) = ? (Returned)
      }{
         Output array.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         Number of bad values in the output array B.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric type except double
         precision: replace {\tt "}x{\tt "} in the routine name by R, I, W, UW, B or
         UB as appropriate. The arrays supplied to the routine must have
         the data type specified.

         \sstitem
         This routine will handle numerical errors (i.e. overflow) by
         assigning the appropriate {\tt "}bad{\tt "} value to affected output array
         elements.
      }
   }
}
\sstroutine{
   KPG1\_CMVDx
}{
   Compresses n-dimensional data and variance arrays by summing in
   `rectangular{\tt '} boxes
}{
   \sstdescription{
      This routine compresses an n-dimensional data array and its
      associated variance array by integer factors along each dimension
      by summing the arrays{\tt '} values in a rectangular box.  The output
      data array may be normalised to take account of any bad values
      that may be present.
   }
   \sstinvocation{
      CALL KPG1\_CMVDx( NDIM, DIMS, INARR, INVAR, COMPRS, NLIM, NORMAL,
                       OUTARR, OUTVAR, SUM, NUM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The dimensionality of the n-dimensional arrays.  It must be
         greater than one.  To handle one-dimensional arrays, give them
         a second dummy dimension of 1.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the input n-dimensional arrays.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-dimensional data array.
      }
      \sstsubsection{
         INVAR( $*$ ) = ? (Given)
      }{
         The input n-dimensional variance array.
      }
      \sstsubsection{
         COMPRS( NDIM ) = REAL (Given)
      }{
         The factors along each dimension by which the input array is
         compressed to form the output array.
      }
      \sstsubsection{
         NLIM = INTEGER (Given)
      }{
         The minimum number of good input elements in a compression box
         that permits the corresponding output array element to be good.
         If fewer than NLIM pixels participated in the sum, the output
         pixel will be bad.
      }
      \sstsubsection{
         NORMAL = LOGICAL (Given)
      }{
         If .TRUE., the summation is normalised to allow for bad data,
         i.e. the sum with each box is multiplied by the ratio of the
         total number of pixels in the box to the actual number
         included to yield the output pixel value.  If .FALSE., the
         output array element just equates to the sum of good pixels
         within each box.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Write)
      }{
         The compressed n-dimensional data array.  Its dimension I must
         be given by DIMS( I )/COMPRS( I ).
      }
      \sstsubsection{
         OUTVAR( $*$ ) = ? (Write)
      }{
         The compressed n-dimensional variance array.  Its dimension I
         must be given by DIMS( I )/COMPRS( I ).
      }
      \sstsubsection{
         SUM( $*$ ) = ? (Returned)
      }{
         Workspace used for efficiency in computing the summations.
         This should have size at least equal to DIMS( 1 ) $*$ 2.
      }
      \sstsubsection{
         NUM( $*$ ) = INTEGER (Returned)
      }{
         Workspace used to count the number of good elements in the
         input box. This should have size at least equal to DIMS( 1 )
         $*$ 2.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
         input and output arrays plus a work space must have the data type
         specified.

         \sstitem
         There is no protection against overflows when the absolute data
         values are very large.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_CMVDx
}{
   Compresses n-dimensional data and variance arrays by summing in
   `rectangular{\tt '} boxes
}{
   \sstdescription{
      This routine compresses an n-dimensional data array and its
      associated variance array by integer factors along each dimension
      by summing the arrays{\tt '} values in a rectangular box.  The output
      data array may be normalised to take account of any bad values
      that may be present.
   }
   \sstinvocation{
      CALL KPG1\_CMVDx( NDIM, DIMS, INARR, INVAR, COMPRS, NLIM, NORMAL,
                       OUTARR, OUTVAR, SUM, NUM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The dimensionality of the n-dimensional arrays.  It must be
         greater than one.  To handle one-dimensional arrays, give them
         a second dummy dimension of 1.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the input n-dimensional arrays.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-dimensional data array.
      }
      \sstsubsection{
         INVAR( $*$ ) = ? (Given)
      }{
         The input n-dimensional variance array.
      }
      \sstsubsection{
         COMPRS( NDIM ) = REAL (Given)
      }{
         The factors along each dimension by which the input array is
         compressed to form the output array.
      }
      \sstsubsection{
         NLIM = INTEGER (Given)
      }{
         The minimum number of good input elements in a compression box
         that permits the corresponding output array element to be good.
         If fewer than NLIM pixels participated in the sum, the output
         pixel will be bad.
      }
      \sstsubsection{
         NORMAL = LOGICAL (Given)
      }{
         If .TRUE., the summation is normalised to allow for bad data,
         i.e. the sum with each box is multiplied by the ratio of the
         total number of pixels in the box to the actual number
         included to yield the output pixel value.  If .FALSE., the
         output array element just equates to the sum of good pixels
         within each box.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Write)
      }{
         The compressed n-dimensional data array.  Its dimension I must
         be given by DIMS( I )/COMPRS( I ).
      }
      \sstsubsection{
         OUTVAR( $*$ ) = ? (Write)
      }{
         The compressed n-dimensional variance array.  Its dimension I
         must be given by DIMS( I )/COMPRS( I ).
      }
      \sstsubsection{
         SUM( $*$ ) = ? (Returned)
      }{
         Workspace used for efficiency in computing the summations.
         This should have size at least equal to DIMS( 1 ) $*$ 2.
      }
      \sstsubsection{
         NUM( $*$ ) = INTEGER (Returned)
      }{
         Workspace used to count the number of good elements in the
         input box. This should have size at least equal to DIMS( 1 )
         $*$ 2.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
         input and output arrays plus a work space must have the data type
         specified.

         \sstitem
         There is no protection against overflows when the absolute data
         values are very large.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_CMVVx
}{
   Compresses n-dimensional data and variance arrays by averaging in
   `rectangular{\tt '} boxes
}{
   \sstdescription{
      This routine compresses an n-dimensional data array and its
      associated variance array by integer factors along each dimension
      by averaging the arrays{\tt '} values in a rectangular box.  The output
      data array may be variance-weighted average.
   }
   \sstinvocation{
      CALL KPG1\_CMVVx( NDIM, DIMS, INARR, INVAR, COMPRS, NLIM, WEIGHT,
                       OUTARR, OUTVAR, SUM, NUM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The dimensionality of the n-dimensional arrays.  It must be
         greater than one.  To handle one-dimensional arrays, give them
         a second dummy dimension of 1.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the input n-dimensional arrays.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-dimensional data array.
      }
      \sstsubsection{
         INVAR( $*$ ) = ? (Given)
      }{
         The input n-dimensional variance array.
      }
      \sstsubsection{
         COMPRS( NDIM ) = REAL (Given)
      }{
         The factors along each dimension by which the input array is
         compressed to form the output array.
      }
      \sstsubsection{
         NLIM = INTEGER (Given)
      }{
         The minimum number of good input elements in a compression box
         that permits the corresponding output array element to be good.
         If fewer than NLIM pixels participated in the sum, the output
         pixel will be bad.
      }
      \sstsubsection{
         WEIGHT = LOGICAL (Given)
      }{
         If true, the summation is weighted by the corresponding
         variance.  If false all the input good elements are given equal
         weight when forming the output data-array value.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Write)
      }{
         The compressed n-dimensional data array.  Its dimension I must
         be given by DIMS( I )/COMPRS( I ).
      }
      \sstsubsection{
         OUTVAR( $*$ ) = ? (Write)
      }{
         The compressed n-dimensional variance array.  Its dimension I
         must be given by DIMS( I )/COMPRS( I ).
      }
      \sstsubsection{
         SUM( $*$ ) = ? (Returned)
      }{
         Workspace used for efficiency in computing the summations.
         This should have size at least equal to DIMS( 1 ) $*$ 2.
      }
      \sstsubsection{
         NUM( $*$ ) = ? (Returned)
      }{
         Workspace used to count the number of good elements in the
         input box. This should have size at least equal to DIMS( 1 )
         $*$ 2.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
         input and output arrays plus a work space must have the data type
         specified.

         \sstitem
         There is no protection against overflows when the absolute data
         values are very large.

         \sstitem
         If the sum of variances in the weighted average is zero, the
         output element is bad.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_CMVVx
}{
   Compresses n-dimensional data and variance arrays by averaging in
   `rectangular{\tt '} boxes
}{
   \sstdescription{
      This routine compresses an n-dimensional data array and its
      associated variance array by integer factors along each dimension
      by averaging the arrays{\tt '} values in a rectangular box.  The output
      data array may be variance-weighted average.
   }
   \sstinvocation{
      CALL KPG1\_CMVVx( NDIM, DIMS, INARR, INVAR, COMPRS, NLIM, WEIGHT,
                       OUTARR, OUTVAR, SUM, NUM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The dimensionality of the n-dimensional arrays.  It must be
         greater than one.  To handle one-dimensional arrays, give them
         a second dummy dimension of 1.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the input n-dimensional arrays.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-dimensional data array.
      }
      \sstsubsection{
         INVAR( $*$ ) = ? (Given)
      }{
         The input n-dimensional variance array.
      }
      \sstsubsection{
         COMPRS( NDIM ) = REAL (Given)
      }{
         The factors along each dimension by which the input array is
         compressed to form the output array.
      }
      \sstsubsection{
         NLIM = INTEGER (Given)
      }{
         The minimum number of good input elements in a compression box
         that permits the corresponding output array element to be good.
         If fewer than NLIM pixels participated in the sum, the output
         pixel will be bad.
      }
      \sstsubsection{
         WEIGHT = LOGICAL (Given)
      }{
         If true, the summation is weighted by the corresponding
         variance.  If false all the input good elements are given equal
         weight when forming the output data-array value.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Write)
      }{
         The compressed n-dimensional data array.  Its dimension I must
         be given by DIMS( I )/COMPRS( I ).
      }
      \sstsubsection{
         OUTVAR( $*$ ) = ? (Write)
      }{
         The compressed n-dimensional variance array.  Its dimension I
         must be given by DIMS( I )/COMPRS( I ).
      }
      \sstsubsection{
         SUM( $*$ ) = ? (Returned)
      }{
         Workspace used for efficiency in computing the summations.
         This should have size at least equal to DIMS( 1 ) $*$ 2.
      }
      \sstsubsection{
         NUM( $*$ ) = ? (Returned)
      }{
         Workspace used to count the number of good elements in the
         input box. This should have size at least equal to DIMS( 1 )
         $*$ 2.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
         input and output arrays plus a work space must have the data type
         specified.

         \sstitem
         There is no protection against overflows when the absolute data
         values are very large.

         \sstitem
         If the sum of variances in the weighted average is zero, the
         output element is bad.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_CNLIM
}{
   Parse a character string into integer bounds
}{
   \sstdescription{
      This routine is used to parse a character specification which
      defines a range of integers.  The specification is of the form:

        Number[-number]

      If the second number is specified then it is assumed that a
      sequence of numbers are to be parsed, e.g. 4-6 (or 6-4) specifies
      integers 4, 5, 6; and bounds 4 and 6 are returned.  If only one
      number is specified, then both the returned bounds are set equal
      to it.

      An asterisk may be used as a wildcard.  Thus 5-$*$ specifies all
      numbers upwards from 5 inclusive, the upper bound being given by
      the largest integer.  $*$ indicates all integers, i.e. the bounds
      would be the smallest (non-bad) and largest integers. $*$-4
      would specify a range from the smallest integer to 4 inclusive.

      Arguments :
       NOS = CHARACTER $*$ ( $*$ ) (Given)
           Number specification.
       FIRST = INTEGER (Returned)
           First integer in the sequence.
       LAST  = INTEGER (Returned)
           Last integer in the sequence.
       STATUS = INTEGER (Given and Returned)
           Global status value.

      Algorithm:
      \sstitemlist{

         \sstitem
            Find character position of the number separator and wildcard
            if present. Report an error if the first character is a
            separator.

         \sstitem
            If there is no separator and no wildcard convert from
            character to integer the single value and use for the upper
            and lower limits.

         \sstitem
            If there is a separator and the wildcard comes before it
            set the lower limit to the minimum integer and convert the
            upper limit.

         \sstitem
            If there is a separator and the wildcard comes after it
            set the upper limit to the largest positive integer and
            convert the lower limit.

         \sstitem
            If there is a separator and no wildcard determine the first
            and last numbers either side of the separator by type
            conversion.  If the first is greater than the last then swap
            them.
      }
   }
   \sstinvocation{
      CALL KPG1\_CNLIM( NOS, FIRST, LAST, STATUS )
   }
}
\sstroutine{
   KPG1\_COLNM
}{
   Finds the named colour nearest to an RGB triple
}{
   \sstdescription{
      This returns the name of a colour in the standard colour set that
      matches an input R-G-B colour, or failing that, that is nearest
      to the input colour.  A city-block metric is used.
   }
   \sstinvocation{
      CALL KPG1\_COLNM( R, G, B, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         R = REAL (Given)
      }{
         The red intensity of the colour to be identified.  It should
         be in the range 0.0 to 1.0.
      }
      \sstsubsection{
         G = REAL (Given)
      }{
         The green intensity of the colour to be identified.  It should
         be in the range 0.0 to 1.0.
      }
      \sstsubsection{
         B = REAL (Given)
      }{
         The blue intensity of the colour to be identified.  It should
         be in the range 0.0 to 1.0.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The name of the nearest colour in the named colour set to the
         input RGB colour.  Note at least eighteen characters are
         required to avoid truncation.
      }
      \sstsubsection{
         STATUS = INTEGER (Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The actual R-G-B colours used will be constrained to lie in the
         range 0.0--1.0.
      }
   }
}
\sstroutine{
   KPG1\_CPBDD
}{
   Copy bad pixels
}{
   \sstdescription{
      This routine copies the bad pixels from one array into another.
   }
   \sstinvocation{
      CALL KPG1\_CPBDD( N, D1, D2, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         No. of points
      }
      \sstsubsection{
         D1( N ) = DOUBLE PRECISION (Given)
      }{
         The original data values.
      }
      \sstsubsection{
         D2( N ) = DOUBLE PRECISION (Given)
      }{
         An associated mask array.
      }
      \sstsubsection{
         OUT( N ) = DOUBLE PRECISION (Given)
      }{
         The returned array. Equal to D1 if both D1 and D2 are good (bad
         if either D1 or D2 is bad).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_CPBDR
}{
   Copy bad pixels
}{
   \sstdescription{
      This routine copies the bad pixels from one array into another.
   }
   \sstinvocation{
      CALL KPG1\_CPBDR( N, D1, D2, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         No. of points
      }
      \sstsubsection{
         D1( N ) = REAL (Given)
      }{
         The original data values.
      }
      \sstsubsection{
         D2( N ) = REAL (Given)
      }{
         An associated mask array.
      }
      \sstsubsection{
         OUT( N ) = REAL (Given)
      }{
         The returned array. Equal to D1 if both D1 and D2 are good (bad
         if either D1 or D2 is bad).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_CPNDB
}{
   Copy a section of an n-dimensional array
}{
   \sstdescription{
      This routine copies a specified section of the supplied
      n-dimensional array (IN) to an output array (OUT).
   }
   \sstinvocation{
      CALL KPG1\_CPNDB( NDIM, LBNDI, UBNDI, IN, LBNDO, UBNDO, OUT, EL,
                         STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of axes.
      }
      \sstsubsection{
         LBNDI( NDIM ) = INTEGER (Given)
      }{
         The lower pixel index bounds of the IN array.
      }
      \sstsubsection{
         UBNDI( NDIM ) = INTEGER (Given)
      }{
         The upper pixel index bounds of the IN array.
      }
      \sstsubsection{
         IN( $*$ ) = BYTE (Given)
      }{
         The input array. Bounds given by LBNDI and UBNDI.
      }
      \sstsubsection{
         LBNDO( NDIM ) = INTEGER (Given)
      }{
         The lower pixel index bounds of the area of the IN array to be
         copied to OUT.
      }
      \sstsubsection{
         UBNDO( NDIM ) = INTEGER (Given)
      }{
         The upper pixel index bounds of the area of the IN array to be
         copied to OUT.
      }
      \sstsubsection{
         OUT( $*$ ) = BYTE (Returned)
      }{
         The output array. Bounds given by LBNDO and UBNDO.
      }
      \sstsubsection{
         EL = INTEGER (Returned)
      }{
         The number of elements in the output array. Derived from LBNDO
         and UBNDO.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the output array is not completely contained within the input
         array, then the sections of the output array which fall outside the
         input arrays will be filled with bad values.
      }
   }
}
\sstroutine{
   KPG1\_CPNDD
}{
   Copy a section of an n-dimensional array
}{
   \sstdescription{
      This routine copies a specified section of the supplied
      n-dimensional array (IN) to an output array (OUT).
   }
   \sstinvocation{
      CALL KPG1\_CPNDD( NDIM, LBNDI, UBNDI, IN, LBNDO, UBNDO, OUT, EL,
                         STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of axes.
      }
      \sstsubsection{
         LBNDI( NDIM ) = INTEGER (Given)
      }{
         The lower pixel index bounds of the IN array.
      }
      \sstsubsection{
         UBNDI( NDIM ) = INTEGER (Given)
      }{
         The upper pixel index bounds of the IN array.
      }
      \sstsubsection{
         IN( $*$ ) = DOUBLE PRECISION (Given)
      }{
         The input array. Bounds given by LBNDI and UBNDI.
      }
      \sstsubsection{
         LBNDO( NDIM ) = INTEGER (Given)
      }{
         The lower pixel index bounds of the area of the IN array to be
         copied to OUT.
      }
      \sstsubsection{
         UBNDO( NDIM ) = INTEGER (Given)
      }{
         The upper pixel index bounds of the area of the IN array to be
         copied to OUT.
      }
      \sstsubsection{
         OUT( $*$ ) = DOUBLE PRECISION (Returned)
      }{
         The output array. Bounds given by LBNDO and UBNDO.
      }
      \sstsubsection{
         EL = INTEGER (Returned)
      }{
         The number of elements in the output array. Derived from LBNDO
         and UBNDO.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the output array is not completely contained within the input
         array, then the sections of the output array which fall outside the
         input arrays will be filled with bad values.
      }
   }
}
\sstroutine{
   KPG1\_CPNDI
}{
   Copy a section of an n-dimensional array
}{
   \sstdescription{
      This routine copies a specified section of the supplied
      n-dimensional array (IN) to an output array (OUT).
   }
   \sstinvocation{
      CALL KPG1\_CPNDI( NDIM, LBNDI, UBNDI, IN, LBNDO, UBNDO, OUT, EL,
                         STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of axes.
      }
      \sstsubsection{
         LBNDI( NDIM ) = INTEGER (Given)
      }{
         The lower pixel index bounds of the IN array.
      }
      \sstsubsection{
         UBNDI( NDIM ) = INTEGER (Given)
      }{
         The upper pixel index bounds of the IN array.
      }
      \sstsubsection{
         IN( $*$ ) = INTEGER (Given)
      }{
         The input array. Bounds given by LBNDI and UBNDI.
      }
      \sstsubsection{
         LBNDO( NDIM ) = INTEGER (Given)
      }{
         The lower pixel index bounds of the area of the IN array to be
         copied to OUT.
      }
      \sstsubsection{
         UBNDO( NDIM ) = INTEGER (Given)
      }{
         The upper pixel index bounds of the area of the IN array to be
         copied to OUT.
      }
      \sstsubsection{
         OUT( $*$ ) = INTEGER (Returned)
      }{
         The output array. Bounds given by LBNDO and UBNDO.
      }
      \sstsubsection{
         EL = INTEGER (Returned)
      }{
         The number of elements in the output array. Derived from LBNDO
         and UBNDO.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the output array is not completely contained within the input
         array, then the sections of the output array which fall outside the
         input arrays will be filled with bad values.
      }
   }
}
\sstroutine{
   KPG1\_CPNDR
}{
   Copy a section of an n-dimensional array
}{
   \sstdescription{
      This routine copies a specified section of the supplied
      n-dimensional array (IN) to an output array (OUT).
   }
   \sstinvocation{
      CALL KPG1\_CPNDR( NDIM, LBNDI, UBNDI, IN, LBNDO, UBNDO, OUT, EL,
                         STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of axes.
      }
      \sstsubsection{
         LBNDI( NDIM ) = INTEGER (Given)
      }{
         The lower pixel index bounds of the IN array.
      }
      \sstsubsection{
         UBNDI( NDIM ) = INTEGER (Given)
      }{
         The upper pixel index bounds of the IN array.
      }
      \sstsubsection{
         IN( $*$ ) = REAL (Given)
      }{
         The input array. Bounds given by LBNDI and UBNDI.
      }
      \sstsubsection{
         LBNDO( NDIM ) = INTEGER (Given)
      }{
         The lower pixel index bounds of the area of the IN array to be
         copied to OUT.
      }
      \sstsubsection{
         UBNDO( NDIM ) = INTEGER (Given)
      }{
         The upper pixel index bounds of the area of the IN array to be
         copied to OUT.
      }
      \sstsubsection{
         OUT( $*$ ) = REAL (Returned)
      }{
         The output array. Bounds given by LBNDO and UBNDO.
      }
      \sstsubsection{
         EL = INTEGER (Returned)
      }{
         The number of elements in the output array. Derived from LBNDO
         and UBNDO.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the output array is not completely contained within the input
         array, then the sections of the output array which fall outside the
         input arrays will be filled with bad values.
      }
   }
}
\sstroutine{
   KPG1\_CPNDUB
}{
   Copy a section of an n-dimensional array
}{
   \sstdescription{
      This routine copies a specified section of the supplied
      n-dimensional array (IN) to an output array (OUT).
   }
   \sstinvocation{
      CALL KPG1\_CPNDUB( NDIM, LBNDI, UBNDI, IN, LBNDO, UBNDO, OUT, EL,
                         STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of axes.
      }
      \sstsubsection{
         LBNDI( NDIM ) = INTEGER (Given)
      }{
         The lower pixel index bounds of the IN array.
      }
      \sstsubsection{
         UBNDI( NDIM ) = INTEGER (Given)
      }{
         The upper pixel index bounds of the IN array.
      }
      \sstsubsection{
         IN( $*$ ) = BYTE (Given)
      }{
         The input array. Bounds given by LBNDI and UBNDI.
      }
      \sstsubsection{
         LBNDO( NDIM ) = INTEGER (Given)
      }{
         The lower pixel index bounds of the area of the IN array to be
         copied to OUT.
      }
      \sstsubsection{
         UBNDO( NDIM ) = INTEGER (Given)
      }{
         The upper pixel index bounds of the area of the IN array to be
         copied to OUT.
      }
      \sstsubsection{
         OUT( $*$ ) = BYTE (Returned)
      }{
         The output array. Bounds given by LBNDO and UBNDO.
      }
      \sstsubsection{
         EL = INTEGER (Returned)
      }{
         The number of elements in the output array. Derived from LBNDO
         and UBNDO.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the output array is not completely contained within the input
         array, then the sections of the output array which fall outside the
         input arrays will be filled with bad values.
      }
   }
}
\sstroutine{
   KPG1\_CPNDUW
}{
   Copy a section of an n-dimensional array
}{
   \sstdescription{
      This routine copies a specified section of the supplied
      n-dimensional array (IN) to an output array (OUT).
   }
   \sstinvocation{
      CALL KPG1\_CPNDUW( NDIM, LBNDI, UBNDI, IN, LBNDO, UBNDO, OUT, EL,
                         STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of axes.
      }
      \sstsubsection{
         LBNDI( NDIM ) = INTEGER (Given)
      }{
         The lower pixel index bounds of the IN array.
      }
      \sstsubsection{
         UBNDI( NDIM ) = INTEGER (Given)
      }{
         The upper pixel index bounds of the IN array.
      }
      \sstsubsection{
         IN( $*$ ) = INTEGER$*$2 (Given)
      }{
         The input array. Bounds given by LBNDI and UBNDI.
      }
      \sstsubsection{
         LBNDO( NDIM ) = INTEGER (Given)
      }{
         The lower pixel index bounds of the area of the IN array to be
         copied to OUT.
      }
      \sstsubsection{
         UBNDO( NDIM ) = INTEGER (Given)
      }{
         The upper pixel index bounds of the area of the IN array to be
         copied to OUT.
      }
      \sstsubsection{
         OUT( $*$ ) = INTEGER$*$2 (Returned)
      }{
         The output array. Bounds given by LBNDO and UBNDO.
      }
      \sstsubsection{
         EL = INTEGER (Returned)
      }{
         The number of elements in the output array. Derived from LBNDO
         and UBNDO.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the output array is not completely contained within the input
         array, then the sections of the output array which fall outside the
         input arrays will be filled with bad values.
      }
   }
}
\sstroutine{
   KPG1\_CPNDW
}{
   Copy a section of an n-dimensional array
}{
   \sstdescription{
      This routine copies a specified section of the supplied
      n-dimensional array (IN) to an output array (OUT).
   }
   \sstinvocation{
      CALL KPG1\_CPNDW( NDIM, LBNDI, UBNDI, IN, LBNDO, UBNDO, OUT, EL,
                         STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of axes.
      }
      \sstsubsection{
         LBNDI( NDIM ) = INTEGER (Given)
      }{
         The lower pixel index bounds of the IN array.
      }
      \sstsubsection{
         UBNDI( NDIM ) = INTEGER (Given)
      }{
         The upper pixel index bounds of the IN array.
      }
      \sstsubsection{
         IN( $*$ ) = INTEGER$*$2 (Given)
      }{
         The input array. Bounds given by LBNDI and UBNDI.
      }
      \sstsubsection{
         LBNDO( NDIM ) = INTEGER (Given)
      }{
         The lower pixel index bounds of the area of the IN array to be
         copied to OUT.
      }
      \sstsubsection{
         UBNDO( NDIM ) = INTEGER (Given)
      }{
         The upper pixel index bounds of the area of the IN array to be
         copied to OUT.
      }
      \sstsubsection{
         OUT( $*$ ) = INTEGER$*$2 (Returned)
      }{
         The output array. Bounds given by LBNDO and UBNDO.
      }
      \sstsubsection{
         EL = INTEGER (Returned)
      }{
         The number of elements in the output array. Derived from LBNDO
         and UBNDO.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If the output array is not completely contained within the input
         array, then the sections of the output array which fall outside the
         input arrays will be filled with bad values.
      }
   }
}
\sstroutine{
   KPG1\_CPNTx
}{
   Creates a primitive NDF with a title via the parameter system
}{
   \sstdescription{
      This routine packages a common series of NDF calls when creating
      a primitive NDF, whose name is obtained from the parameter system,
      and also obtaining its title from the parameter system.  The need
      to handle an optional output file via the null character is
      catered.  The data type of the NDF data array is the same as the
      supplied array.  An NDF context is started and ended within this
      routine.
   }
   \sstinvocation{
      CALL KPG1\_CPNTx( PNNDF, PNTIT, NDIM, DIMS, ARRAY, NULL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNNDF = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The ADAM parameter name to obtain the name of the output NDF.
      }
      \sstsubsection{
         PNTIT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The ADAM parameter name to obtain the title of the output NDF.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of dimensions in the NDF{\tt '}s data array.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the NDF{\tt '}s data array.
      }
      \sstsubsection{
         ARRAY( $*$ ) = ? (Given)
      }{
         The array to be placed in the primitive NDF{\tt '}s data array.
      }
      \sstsubsection{
         NULL = LOGICAL (Given)
      }{
         If true a null value returned by either parameter GET is
         annulled.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         data array supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_CPNTx
}{
   Creates a primitive NDF with a title via the parameter system
}{
   \sstdescription{
      This routine packages a common series of NDF calls when creating
      a primitive NDF, whose name is obtained from the parameter system,
      and also obtaining its title from the parameter system.  The need
      to handle an optional output file via the null character is
      catered.  The data type of the NDF data array is the same as the
      supplied array.  An NDF context is started and ended within this
      routine.
   }
   \sstinvocation{
      CALL KPG1\_CPNTx( PNNDF, PNTIT, NDIM, DIMS, ARRAY, NULL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNNDF = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The ADAM parameter name to obtain the name of the output NDF.
      }
      \sstsubsection{
         PNTIT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The ADAM parameter name to obtain the title of the output NDF.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of dimensions in the NDF{\tt '}s data array.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the NDF{\tt '}s data array.
      }
      \sstsubsection{
         ARRAY( $*$ ) = ? (Given)
      }{
         The array to be placed in the primitive NDF{\tt '}s data array.
      }
      \sstsubsection{
         NULL = LOGICAL (Given)
      }{
         If true a null value returned by either parameter GET is
         annulled.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         data array supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_CPNTx
}{
   Creates a primitive NDF with a title via the parameter system
}{
   \sstdescription{
      This routine packages a common series of NDF calls when creating
      a primitive NDF, whose name is obtained from the parameter system,
      and also obtaining its title from the parameter system.  The need
      to handle an optional output file via the null character is
      catered.  The data type of the NDF data array is the same as the
      supplied array.  An NDF context is started and ended within this
      routine.
   }
   \sstinvocation{
      CALL KPG1\_CPNTx( PNNDF, PNTIT, NDIM, DIMS, ARRAY, NULL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNNDF = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The ADAM parameter name to obtain the name of the output NDF.
      }
      \sstsubsection{
         PNTIT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The ADAM parameter name to obtain the title of the output NDF.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of dimensions in the NDF{\tt '}s data array.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the NDF{\tt '}s data array.
      }
      \sstsubsection{
         ARRAY( $*$ ) = ? (Given)
      }{
         The array to be placed in the primitive NDF{\tt '}s data array.
      }
      \sstsubsection{
         NULL = LOGICAL (Given)
      }{
         If true a null value returned by either parameter GET is
         annulled.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         data array supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_CPNTx
}{
   Creates a primitive NDF with a title via the parameter system
}{
   \sstdescription{
      This routine packages a common series of NDF calls when creating
      a primitive NDF, whose name is obtained from the parameter system,
      and also obtaining its title from the parameter system.  The need
      to handle an optional output file via the null character is
      catered.  The data type of the NDF data array is the same as the
      supplied array.  An NDF context is started and ended within this
      routine.
   }
   \sstinvocation{
      CALL KPG1\_CPNTx( PNNDF, PNTIT, NDIM, DIMS, ARRAY, NULL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNNDF = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The ADAM parameter name to obtain the name of the output NDF.
      }
      \sstsubsection{
         PNTIT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The ADAM parameter name to obtain the title of the output NDF.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of dimensions in the NDF{\tt '}s data array.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the NDF{\tt '}s data array.
      }
      \sstsubsection{
         ARRAY( $*$ ) = ? (Given)
      }{
         The array to be placed in the primitive NDF{\tt '}s data array.
      }
      \sstsubsection{
         NULL = LOGICAL (Given)
      }{
         If true a null value returned by either parameter GET is
         annulled.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         data array supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_CPNTx
}{
   Creates a primitive NDF with a title via the parameter system
}{
   \sstdescription{
      This routine packages a common series of NDF calls when creating
      a primitive NDF, whose name is obtained from the parameter system,
      and also obtaining its title from the parameter system.  The need
      to handle an optional output file via the null character is
      catered.  The data type of the NDF data array is the same as the
      supplied array.  An NDF context is started and ended within this
      routine.
   }
   \sstinvocation{
      CALL KPG1\_CPNTx( PNNDF, PNTIT, NDIM, DIMS, ARRAY, NULL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNNDF = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The ADAM parameter name to obtain the name of the output NDF.
      }
      \sstsubsection{
         PNTIT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The ADAM parameter name to obtain the title of the output NDF.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of dimensions in the NDF{\tt '}s data array.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the NDF{\tt '}s data array.
      }
      \sstsubsection{
         ARRAY( $*$ ) = ? (Given)
      }{
         The array to be placed in the primitive NDF{\tt '}s data array.
      }
      \sstsubsection{
         NULL = LOGICAL (Given)
      }{
         If true a null value returned by either parameter GET is
         annulled.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         data array supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_CPNTx
}{
   Creates a primitive NDF with a title via the parameter system
}{
   \sstdescription{
      This routine packages a common series of NDF calls when creating
      a primitive NDF, whose name is obtained from the parameter system,
      and also obtaining its title from the parameter system.  The need
      to handle an optional output file via the null character is
      catered.  The data type of the NDF data array is the same as the
      supplied array.  An NDF context is started and ended within this
      routine.
   }
   \sstinvocation{
      CALL KPG1\_CPNTx( PNNDF, PNTIT, NDIM, DIMS, ARRAY, NULL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNNDF = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The ADAM parameter name to obtain the name of the output NDF.
      }
      \sstsubsection{
         PNTIT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The ADAM parameter name to obtain the title of the output NDF.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of dimensions in the NDF{\tt '}s data array.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the NDF{\tt '}s data array.
      }
      \sstsubsection{
         ARRAY( $*$ ) = ? (Given)
      }{
         The array to be placed in the primitive NDF{\tt '}s data array.
      }
      \sstsubsection{
         NULL = LOGICAL (Given)
      }{
         If true a null value returned by either parameter GET is
         annulled.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         data array supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_CPNTx
}{
   Creates a primitive NDF with a title via the parameter system
}{
   \sstdescription{
      This routine packages a common series of NDF calls when creating
      a primitive NDF, whose name is obtained from the parameter system,
      and also obtaining its title from the parameter system.  The need
      to handle an optional output file via the null character is
      catered.  The data type of the NDF data array is the same as the
      supplied array.  An NDF context is started and ended within this
      routine.
   }
   \sstinvocation{
      CALL KPG1\_CPNTx( PNNDF, PNTIT, NDIM, DIMS, ARRAY, NULL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNNDF = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The ADAM parameter name to obtain the name of the output NDF.
      }
      \sstsubsection{
         PNTIT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The ADAM parameter name to obtain the title of the output NDF.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of dimensions in the NDF{\tt '}s data array.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         The dimensions of the NDF{\tt '}s data array.
      }
      \sstsubsection{
         ARRAY( $*$ ) = ? (Given)
      }{
         The array to be placed in the primitive NDF{\tt '}s data array.
      }
      \sstsubsection{
         NULL = LOGICAL (Given)
      }{
         If true a null value returned by either parameter GET is
         annulled.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         data array supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_CPSTY
}{
   Copy the plotting style for an AST element to another AST element
}{
   \sstdescription{
      This routine copies the AST attributes which determine the colour,
      style, width, font and size. If IN is non-blank, then the
      attributes are copied from the element given by IN, to the
      element given by OUT - the original values of these attributes for
      element OUT are returned in ATTRS. If IN is blank, then the
      values supplied in ATTRS are copied to the element given by OUT -
      the original values of these attributes for element OUT are again
      returned in ATTRS.
   }
   \sstinvocation{
      CALL KPG1\_CPSTY( IPLOT, IN, OUT, ATTRS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPLOT = INTEGER (Given)
      }{
         The AST Plot.
      }
      \sstsubsection{
         IN = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The name of the source element (e.g. {\tt "}CURVES{\tt "}, {\tt "}AXIS1{\tt "}, etc), or
         blank.
      }
      \sstsubsection{
         OUT = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The name of the destination element (e.g. {\tt "}CURVES{\tt "}, {\tt "}AXIS1{\tt "}, etc).
      }
      \sstsubsection{
         ATTRS( 5 ) = REAL (Given and Returned)
      }{
         The entry values are ignored unless IN is blank, in which case
         the entry values should be the colour, width, style, size and font
         attribute values to associate with element OUT. On exit, the
         original colour, width, style, size and font attribute values
         associated with element OUT.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_CROSS
}{
   Draws a cross at the specified pixel position
}{
   \sstdescription{
      This routine accepts the co-ordinates of a point and draws a
      cross of defined size centred at that point.  The SGS buffers
      are flushed after the cross is drawn.

      An SGS device must already be open.
   }
   \sstinvocation{
      CALL KPG1\_CROSS( X, Y, SIZE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         X = REAL( READ )
      }{
         The X co-ordinate of the point.
      }
      \sstsubsection{
         Y = REAL( READ )
      }{
         The Y co-ordinate of the point.
      }
      \sstsubsection{
         SIZE = REAL( READ )
      }{
         The width and height of the cross in pixels
      }
      \sstsubsection{
         STATUS = INTEGER( READ )
      }{
         The status on entry to this subroutine.
      }
   }
   \sstdiytopic{
      Method
   }{
      The co-ordinates of the ends of the arms of the cross are
      calculated, then the cross is plotted.
   }
}
\sstroutine{
   KPG1\_CROUT
}{
   Creates and returns locators to the top-level and data-array of
   an NDF-type structure
}{
   \sstdescription{
      An NDF-type data structure, associated with the supplied
      parameter name is created.  A locator for this structure is
      returned.  A TITLE component, associated with another parameter
      name is created within the structure and a character value, is
      obtained from the parameter system and written to the TITLE
      component.  A DATA\_ARRAY component is created.  If the supplied
      origins are all one, DATA\_ARRAY is primitive, having the supplied
      dimensionality and dimensions, and is of type \_REAL.  Otherwise
      DATA\_ARRAY is a simple ARRAY-type structure containing the
      primitive \_REAL data array and origin information.  The locator to
      the primitive data array is also returned.
   }
   \sstinvocation{
      CALL KPG1\_CROUT( PARNAM, TLENAM, NDIM, DIMS, ORIGIN, LOCAT,
                       DATLOC, DNAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARNAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Parameter name associated with the NDF-type structure to
         be created.
      }
      \sstsubsection{
         TLENAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Parameter name associated with the TITLE component created
         in the new NDF-type structure.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Dimensionality of the data-array component of the new
         NDF-type structure.
      }
      \sstsubsection{
         DIMS( NDIM ) = INTEGER (Given)
      }{
         Dimensions of the data-array component of the new NDF-type
         structure.
      }
      \sstsubsection{
         ORIGIN( NDIM ) = INTEGER (Given)
      }{
         The origin information of the data array.  If a primitive
         NDF is to be created these should all be set to 1.  Note though
         if other ARRAY-type components---QUALITY and VARIANCE---are
         propagated, the origin data of ARRAY-type components must be
         consistent not to invalidate the NDF.  Therefore use the values
         returned by KPG1\_GETIM unless QUALITY and VARIANCE are not
         propagated.
      }
      \sstsubsection{
         LOCAT = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Locator to the new NDF-type structure.  If status is bad on
         exit this locator is annulled.  If status is bad on exit this
         locator is annulled.
      }
      \sstsubsection{
         DATLOC  = CHARACTER $*$ ( DAT\_\_SZLOC ) (Returned)
      }{
         The locator to the structure containing the primitive
         form of the data array.  If it is the top-level of the NDF
         structure, it will be a clone of LOCAT.  Either way it will
         require annulment.  If status is bad on exit this locator is
         annulled.
      }
      \sstsubsection{
         DNAME = CHARACTER $*$ ( DAT\_\_SZNAM ) (Returned)
      }{
         The name of the data array as this will be needed for access,
         and it is different depending on its location.  This argument
         is probably unnecessary, but it is here defensively, in case
         the origin is changed to or from the default.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This a stop-gap routine until the remainder of KAPPA
         IMAGE-format applications are converted to NDF.  It enables both
         primitive (i.e. IMAGE-format) and simple NDFs to be processed.

         \sstitem
         The maximum length of the TITLE component produced by this
         routine is 72 characters.
      }
   }
}
\sstroutine{
   KPG1\_CSHFT
}{
   Shift the characters left or right in a string
}{
   \sstdescription{
      This routine shifts all characters in a string by a given number of
      characters, padding with spaces at the ends.
   }
   \sstinvocation{
      CALL KPG1\_CSHFT( N, TEXT )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Returned)
      }{
         The number of characters to shift to the right. Negative values
         produce shifts to the left.
      }
      \sstsubsection{
         TEXT = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The text to be shifted.
      }
   }
}
\sstroutine{
   KPG1\_CSUBx
}{
   Subtract a constant from each element of a vectorised array
}{
   \sstdescription{
      The routine subtracts a constant from each element of a
      vectorised array to produce a new array. Bad value checking is
      performed if required.
   }
   \sstinvocation{
      CALL KPG1\_CSUBx( BAD, EL, A, CONST, B, NERR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         A( EL ) = ? (Given)
      }{
         Input array.
      }
      \sstsubsection{
         CONST = DOUBLE PRECISION (Given)
      }{
         Constant to be subtracted from each array element.
      }
      \sstsubsection{
         B( EL ) = ? (Returned)
      }{
         Output array.
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays supplied to the routine must have the data type specified.

         \sstitem
         This routine will handle numerical errors (i.e. overflow) by
         assigning the appropriate {\tt "}bad{\tt "} value to affected output array
         elements. If the constant supplied cannot be converted to the
         data type of the arrays without overflow, then all elements of
         the output array will be assigned this bad value and NERR will
         return the value of EL.
      }
   }
}
\sstroutine{
   KPG1\_CSUBx
}{
   Subtract a constant from each element of a vectorised array
}{
   \sstdescription{
      The routine subtracts a constant from each element of a
      vectorised array to produce a new array. Bad value checking is
      performed if required.
   }
   \sstinvocation{
      CALL KPG1\_CSUBx( BAD, EL, A, CONST, B, NERR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         A( EL ) = ? (Given)
      }{
         Input array.
      }
      \sstsubsection{
         CONST = DOUBLE PRECISION (Given)
      }{
         Constant to be subtracted from each array element.
      }
      \sstsubsection{
         B( EL ) = ? (Returned)
      }{
         Output array.
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays supplied to the routine must have the data type specified.

         \sstitem
         This routine will handle numerical errors (i.e. overflow) by
         assigning the appropriate {\tt "}bad{\tt "} value to affected output array
         elements. If the constant supplied cannot be converted to the
         data type of the arrays without overflow, then all elements of
         the output array will be assigned this bad value and NERR will
         return the value of EL.
      }
   }
}
\sstroutine{
   KPG1\_CSUBx
}{
   Subtract a constant from each element of a vectorised array
}{
   \sstdescription{
      The routine subtracts a constant from each element of a
      vectorised array to produce a new array. Bad value checking is
      performed if required.
   }
   \sstinvocation{
      CALL KPG1\_CSUBx( BAD, EL, A, CONST, B, NERR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         A( EL ) = ? (Given)
      }{
         Input array.
      }
      \sstsubsection{
         CONST = DOUBLE PRECISION (Given)
      }{
         Constant to be subtracted from each array element.
      }
      \sstsubsection{
         B( EL ) = ? (Returned)
      }{
         Output array.
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays supplied to the routine must have the data type specified.

         \sstitem
         This routine will handle numerical errors (i.e. overflow) by
         assigning the appropriate {\tt "}bad{\tt "} value to affected output array
         elements. If the constant supplied cannot be converted to the
         data type of the arrays without overflow, then all elements of
         the output array will be assigned this bad value and NERR will
         return the value of EL.
      }
   }
}
\sstroutine{
   KPG1\_CSUBx
}{
   Subtract a constant from each element of a vectorised array
}{
   \sstdescription{
      The routine subtracts a constant from each element of a
      vectorised array to produce a new array. Bad value checking is
      performed if required.
   }
   \sstinvocation{
      CALL KPG1\_CSUBx( BAD, EL, A, CONST, B, NERR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         A( EL ) = ? (Given)
      }{
         Input array.
      }
      \sstsubsection{
         CONST = DOUBLE PRECISION (Given)
      }{
         Constant to be subtracted from each array element.
      }
      \sstsubsection{
         B( EL ) = ? (Returned)
      }{
         Output array.
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays supplied to the routine must have the data type specified.

         \sstitem
         This routine will handle numerical errors (i.e. overflow) by
         assigning the appropriate {\tt "}bad{\tt "} value to affected output array
         elements. If the constant supplied cannot be converted to the
         data type of the arrays without overflow, then all elements of
         the output array will be assigned this bad value and NERR will
         return the value of EL.
      }
   }
}
\sstroutine{
   KPG1\_CSUBx
}{
   Subtract a constant from each element of a vectorised array
}{
   \sstdescription{
      The routine subtracts a constant from each element of a
      vectorised array to produce a new array. Bad value checking is
      performed if required.
   }
   \sstinvocation{
      CALL KPG1\_CSUBx( BAD, EL, A, CONST, B, NERR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         A( EL ) = ? (Given)
      }{
         Input array.
      }
      \sstsubsection{
         CONST = DOUBLE PRECISION (Given)
      }{
         Constant to be subtracted from each array element.
      }
      \sstsubsection{
         B( EL ) = ? (Returned)
      }{
         Output array.
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays supplied to the routine must have the data type specified.

         \sstitem
         This routine will handle numerical errors (i.e. overflow) by
         assigning the appropriate {\tt "}bad{\tt "} value to affected output array
         elements. If the constant supplied cannot be converted to the
         data type of the arrays without overflow, then all elements of
         the output array will be assigned this bad value and NERR will
         return the value of EL.
      }
   }
}
\sstroutine{
   KPG1\_CSUBx
}{
   Subtract a constant from each element of a vectorised array
}{
   \sstdescription{
      The routine subtracts a constant from each element of a
      vectorised array to produce a new array. Bad value checking is
      performed if required.
   }
   \sstinvocation{
      CALL KPG1\_CSUBx( BAD, EL, A, CONST, B, NERR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         A( EL ) = ? (Given)
      }{
         Input array.
      }
      \sstsubsection{
         CONST = DOUBLE PRECISION (Given)
      }{
         Constant to be subtracted from each array element.
      }
      \sstsubsection{
         B( EL ) = ? (Returned)
      }{
         Output array.
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays supplied to the routine must have the data type specified.

         \sstitem
         This routine will handle numerical errors (i.e. overflow) by
         assigning the appropriate {\tt "}bad{\tt "} value to affected output array
         elements. If the constant supplied cannot be converted to the
         data type of the arrays without overflow, then all elements of
         the output array will be assigned this bad value and NERR will
         return the value of EL.
      }
   }
}
\sstroutine{
   KPG1\_CSUBx
}{
   Subtract a constant from each element of a vectorised array
}{
   \sstdescription{
      The routine subtracts a constant from each element of a
      vectorised array to produce a new array. Bad value checking is
      performed if required.
   }
   \sstinvocation{
      CALL KPG1\_CSUBx( BAD, EL, A, CONST, B, NERR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         A( EL ) = ? (Given)
      }{
         Input array.
      }
      \sstsubsection{
         CONST = DOUBLE PRECISION (Given)
      }{
         Constant to be subtracted from each array element.
      }
      \sstsubsection{
         B( EL ) = ? (Returned)
      }{
         Output array.
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays supplied to the routine must have the data type specified.

         \sstitem
         This routine will handle numerical errors (i.e. overflow) by
         assigning the appropriate {\tt "}bad{\tt "} value to affected output array
         elements. If the constant supplied cannot be converted to the
         data type of the arrays without overflow, then all elements of
         the output array will be assigned this bad value and NERR will
         return the value of EL.
      }
   }
}
\sstroutine{
   KPG1\_CTCPD
}{
   Copy values from catalogue columns to an array
}{
   \sstdescription{
      This routine gets NEL values for a set of given CAT (see SUN/181)
      columns, derived from rows 1 to NEL of a given catalogue,
      selection, or index, and stores them in array OUT.
   }
   \sstinvocation{
      CALL KPG1\_CTCPD( CI, NAX, GI, NEL, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         CI = INTEGER (Given)
      }{
         The CAT identifier for the catalogue, selection or index
         containing the required data.
      }
      \sstsubsection{
         NAX= INTEGER (Given)
      }{
         The number of columns from which values are to be read.
      }
      \sstsubsection{
         GI( NAX ) = INTEGER (Given)
      }{
         The CAT identifiers for the column, expressions or parameters to be
         evaluated for rows 1 to NEL of the component identified by CI. If
         any elements of this array are CAT\_\_NOID, then the corresponding
         elements of OUT are filled with the row number.
      }
      \sstsubsection{
         NEL = INTEGER (Given)
      }{
         The number of rows to copy.
      }
      \sstsubsection{
         OUT( NEL, NAX ) = DOUBLE PRECISION (Returned)
      }{
         The returned values.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_CTCPI
}{
   Copy values from catalogue columns to an array
}{
   \sstdescription{
      This routine gets NEL values for a set of given CAT (see SUN/181)
      columns, derived from rows 1 to NEL of a given catalogue,
      selection, or index, and stores them in array OUT.
   }
   \sstinvocation{
      CALL KPG1\_CTCPI( CI, NAX, GI, NEL, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         CI = INTEGER (Given)
      }{
         The CAT identifier for the catalogue, selection or index
         containing the required data.
      }
      \sstsubsection{
         NAX= INTEGER (Given)
      }{
         The number of columns from which values are to be read.
      }
      \sstsubsection{
         GI( NAX ) = INTEGER (Given)
      }{
         The CAT identifiers for the column, expressions or parameters to be
         evaluated for rows 1 to NEL of the component identified by CI. If
         any elements of this array are CAT\_\_NOID, then the corresponding
         elements of OUT are filled with the row number.
      }
      \sstsubsection{
         NEL = INTEGER (Given)
      }{
         The number of rows to copy.
      }
      \sstsubsection{
         OUT( NEL, NAX ) = INTEGER (Returned)
      }{
         The returned values.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_D2W2x
}{
   Converts linear data co-ordinates to world co-ordinates
}{
   \sstdescription{
      The co-efficients of the linear transformation from world
      co-ordinates to data co-ordinates are supplied in arguments SCALE
      and OFFSET.  The inverse of this transformation is used to
      transform each supplied position from data to world co-ordinates.
   }
   \sstinvocation{
      CALL KPG1\_D2W2x( SCALE, OFFSET, NPOINT, XP, YP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SCALE( 2 ) = ? (Given)
      }{
         The scale factors in the linear relationships between axis
         co-ordinates and pixel co-ordinates.
      }
      \sstsubsection{
         OFFSET( 2 ) = ? (Given)
      }{
         The offsets in the linear relationships between axis
         co-ordinates and pixel co-ordinates.
      }
      \sstsubsection{
         NPOINT = INTEGER (Given)
      }{
         The number of points specified.
      }
      \sstsubsection{
         XP( NPOINT ) = ? (Given and Returned)
      }{
         On input the x data co-ordinate of each point.  On return the
         x world co-ordinate of each point.
      }
      \sstsubsection{
         YP( NPOINT ) = ? (Given and Returned)
      }{
         On input the y data co-ordinate of each point.  On return the
         y world co-ordinate of each point.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the real and double-precision
         data types: replace {\tt "}x{\tt "} in the routine name by D or R as
         appropriate.  The SCALE, OFFSET, XP and YP  arrays must have the
         data type specified.

         \sstitem
         The supplied values of SCALE and OFFSET are such that:

      }
         DATA = SCALE( I ) $*$ PIXEL $+$ OFFSET( I )

      where PIXEL is a pixel co-ordinate for the I{\tt '}th dimension, and
      DATA is the corresponding axis co-ordinate.
   }
}
\sstroutine{
   KPG1\_D2W2x
}{
   Converts linear data co-ordinates to world co-ordinates
}{
   \sstdescription{
      The co-efficients of the linear transformation from world
      co-ordinates to data co-ordinates are supplied in arguments SCALE
      and OFFSET.  The inverse of this transformation is used to
      transform each supplied position from data to world co-ordinates.
   }
   \sstinvocation{
      CALL KPG1\_D2W2x( SCALE, OFFSET, NPOINT, XP, YP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SCALE( 2 ) = ? (Given)
      }{
         The scale factors in the linear relationships between axis
         co-ordinates and pixel co-ordinates.
      }
      \sstsubsection{
         OFFSET( 2 ) = ? (Given)
      }{
         The offsets in the linear relationships between axis
         co-ordinates and pixel co-ordinates.
      }
      \sstsubsection{
         NPOINT = INTEGER (Given)
      }{
         The number of points specified.
      }
      \sstsubsection{
         XP( NPOINT ) = ? (Given and Returned)
      }{
         On input the x data co-ordinate of each point.  On return the
         x world co-ordinate of each point.
      }
      \sstsubsection{
         YP( NPOINT ) = ? (Given and Returned)
      }{
         On input the y data co-ordinate of each point.  On return the
         y world co-ordinate of each point.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the real and double-precision
         data types: replace {\tt "}x{\tt "} in the routine name by D or R as
         appropriate.  The SCALE, OFFSET, XP and YP  arrays must have the
         data type specified.

         \sstitem
         The supplied values of SCALE and OFFSET are such that:

      }
         DATA = SCALE( I ) $*$ PIXEL $+$ OFFSET( I )

      where PIXEL is a pixel co-ordinate for the I{\tt '}th dimension, and
      DATA is the corresponding axis co-ordinate.
   }
}
\sstroutine{
   KPG1\_DANOT
}{
   Generates an annotation from the NDF{\tt '}s label and units
}{
   \sstdescription{
      This routine examines the NDF for a label and units.  It creates a
      string of the form {\tt "}label (units){\tt "} or {\tt "}label{\tt "} if the label but not
      the units are present.  If neither are present a string comprising
      the array component followed by {\tt '} values{\tt '} is created.  If the
      label is defined but is blank, this same default is used.  Blank
      units are omitted.  The units are squared for the variance
      component.
   }
   \sstinvocation{
      CALL KPG1\_DANOT( NDF, COMP, DATLAB, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDF = INTEGER (Given)
      }{
         The NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the NDF array component: {\tt '}DATA{\tt '}, {\tt '}QUALITY{\tt '}, {\tt '}VARIANCE{\tt '},
         or {\tt '}ERROR{\tt '}, though it is used literally and not checked to
         be a member of this set.
      }
      \sstsubsection{
         DATLAB = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The composite annotation.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         The identifier should be associated with an NDF.
      }
   }
}
\sstroutine{
   KPG1\_DARAB
}{
   Determine the data limits for an array using a variety of methods
}{
   \sstdescription{
      This routine derives a data range applicable to the supplied array.
      It is intended to be used to specify the data limits for histogram
      plots and scaling data for image display.  There is a variety of
      methods available to derive the limits, of which a subset of
      appropriate methods can be defined by argument METHOD.

      The method is selected by the user through the literal parameter
      specified by PARAM.  The supplied string should consist of up to
      three sub-strings or elements, separated by commas.  In all but
      one method, the first element must specify the method to use.  If
      supplied, the other two elements should be numerical values as
      described below (default values will be used if these elements are
      not provided).  The following options are available.

      \sstitemlist{

         \sstitem
            {\tt "}Extended{\tt "} -- LOWER and UPPER are returned equal to the
            lowest and highest supplied data values, extended to give a
            margin of 2.5\% of the total data range at each end.

         \sstitem
            {\tt "}Extended,10,5{\tt "} -- Like {\tt "}Extended{\tt "}, except the margins at the
            two ends are specified as a pair of numerical value in the
            second and third elements of the array.  These values are
            percentages of the total data range.  So, {\tt "}Extended,10,5{\tt "}
            includes a margin of 10\% of the total data range in LOWER, and
            5\% in UPPER.  If only one numerical value is given, the same
            value is used for both limits.  If no value is given, both
            limits default to 2.5.  {\tt "}Range{\tt "} is equivalent to
            {\tt "}Extended,0,0{\tt "}.

         \sstitem
            {\tt "}Faint{\tt "} -- The scaling is between the mean data value minus
            one standard deviation and the mean data value plus seven
            standard deviations.  This is retained for historical reasons.

         \sstitem
            {\tt "}Limit{\tt "} --  Allows user to supply explicit lower and upper
            limiting values.  For example, {\tt "}Limit,10,20{\tt "} would set the lower
            limit to 10 and its upper limit to 20.  For compatibility
            reasons and for ease of use, this routine permits the omission
            of the method.  Thus {\tt "}10,20{\tt "} is equivalent to the previous
            example.  The upper limit may be numerically smaller than the
            lower limit, as might be needed for display scaling.  If fewer
            than two numerical values are supplied, the {\tt "}Range{\tt "} method is
            adopted.  The limits must be within the allowed range for the
            data type of the ARRAY argument.

         \sstitem
            {\tt "}Percentiles,5,95{\tt "} -- The second and third elements of the
            array are interpreted as percentiles.  For instance,
            {\tt "}Perc,5,95{\tt "} causes 5\% of the data points to be below LOWER, and
            10\% to be above the UPPER.  If only 1 value (p1) is supplied,
            the other one, p2, defaults to (100 - p1).  If no values are
            supplied, p1 and p2 default to 5 and 95 respectively.  Values
            must be in the range 0 to 100.

         \sstitem
            {\tt "}Range{\tt "} -- LOWER and UPPER are returned equal to the lowest
            and highest supplied array values.

         \sstitem
            {\tt "}Sigmas,2,3{\tt "} -- The second and third elements of the array
            are interpreted as multiples of the standard deviation of the
            data values.  For instance, {\tt "}S,2,3{\tt "} causes the LOWER to be the
            mean of the data values, minus two sigma, and UPPER to be the
            mean plus three sigma.  If only 1 value is supplied, the same
            value is used for both limits.  If no values are supplied, both
            values default to 3.0.

      }
      The above method names can be abbreviated to one character.

      If the parameter name is supplied as blank, then {\tt "}Range{\tt "} is
      assumed (i.e. LOWER and UPPER are chosen so that the
      encompasses the entire data range).

      The extreme values are reported unless the limits parameter PARAM
      is specified on the command line.  In this case extreme values
      are only calculated where necessary for the chosen method.
   }
   \sstinvocation{
      CALL KPG1\_DARAB( PARAM, EL, ARRAY, METHDS, BAD, LOWER,
                       UPPER, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use to get the method for chosing
         the default limits for the axis. May be blank.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements of the array to be analysed.
      }
      \sstsubsection{
         ARRAY( EL ) = BYTE (Given)
      }{
         The array for which the chosen statistics are required.
      }
      \sstsubsection{
         METHDS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A comma-separated list of methods by which the data limits may
         be specified.  Different tasks may require only a subset of
         the methods available.  The allowed methods are {\tt "}Faint{\tt "},
         {\tt "}Extended{\tt "}, {\tt "}Limit{\tt "}, {\tt "}Percentiles{\tt "}, {\tt "}Range{\tt "}, and {\tt "}Sigmas{\tt "}.
         See the description for details of these methods.
      }
      \sstsubsection{
         BAD = LOGICAL (Given and Returned)
      }{
         True when bad pixels may be present.
      }
      \sstsubsection{
         LOWER = DOUBLE PRECISION (Returned)
      }{
         The lower limit.
      }
      \sstsubsection{
         UPPER = DOUBLE PRECISION (Returned)
      }{
         The upper limit.
      }
      \sstsubsection{
         STATUS = INTEGER( Given \& Returned )
      }{
         Global status.
      }
   }
}
\sstroutine{
   KPG1\_DARAD
}{
   Determine the data limits for an array using a variety of methods
}{
   \sstdescription{
      This routine derives a data range applicable to the supplied array.
      It is intended to be used to specify the data limits for histogram
      plots and scaling data for image display.  There is a variety of
      methods available to derive the limits, of which a subset of
      appropriate methods can be defined by argument METHOD.

      The method is selected by the user through the literal parameter
      specified by PARAM.  The supplied string should consist of up to
      three sub-strings or elements, separated by commas.  In all but
      one method, the first element must specify the method to use.  If
      supplied, the other two elements should be numerical values as
      described below (default values will be used if these elements are
      not provided).  The following options are available.

      \sstitemlist{

         \sstitem
            {\tt "}Extended{\tt "} -- LOWER and UPPER are returned equal to the
            lowest and highest supplied data values, extended to give a
            margin of 2.5\% of the total data range at each end.

         \sstitem
            {\tt "}Extended,10,5{\tt "} -- Like {\tt "}Extended{\tt "}, except the margins at the
            two ends are specified as a pair of numerical value in the
            second and third elements of the array.  These values are
            percentages of the total data range.  So, {\tt "}Extended,10,5{\tt "}
            includes a margin of 10\% of the total data range in LOWER, and
            5\% in UPPER.  If only one numerical value is given, the same
            value is used for both limits.  If no value is given, both
            limits default to 2.5.  {\tt "}Range{\tt "} is equivalent to
            {\tt "}Extended,0,0{\tt "}.

         \sstitem
            {\tt "}Faint{\tt "} -- The scaling is between the mean data value minus
            one standard deviation and the mean data value plus seven
            standard deviations.  This is retained for historical reasons.

         \sstitem
            {\tt "}Limit{\tt "} --  Allows user to supply explicit lower and upper
            limiting values.  For example, {\tt "}Limit,10,20{\tt "} would set the lower
            limit to 10 and its upper limit to 20.  For compatibility
            reasons and for ease of use, this routine permits the omission
            of the method.  Thus {\tt "}10,20{\tt "} is equivalent to the previous
            example.  The upper limit may be numerically smaller than the
            lower limit, as might be needed for display scaling.  If fewer
            than two numerical values are supplied, the {\tt "}Range{\tt "} method is
            adopted.  The limits must be within the allowed range for the
            data type of the ARRAY argument.

         \sstitem
            {\tt "}Percentiles,5,95{\tt "} -- The second and third elements of the
            array are interpreted as percentiles.  For instance,
            {\tt "}Perc,5,95{\tt "} causes 5\% of the data points to be below LOWER, and
            10\% to be above the UPPER.  If only 1 value (p1) is supplied,
            the other one, p2, defaults to (100 - p1).  If no values are
            supplied, p1 and p2 default to 5 and 95 respectively.  Values
            must be in the range 0 to 100.

         \sstitem
            {\tt "}Range{\tt "} -- LOWER and UPPER are returned equal to the lowest
            and highest supplied array values.

         \sstitem
            {\tt "}Sigmas,2,3{\tt "} -- The second and third elements of the array
            are interpreted as multiples of the standard deviation of the
            data values.  For instance, {\tt "}S,2,3{\tt "} causes the LOWER to be the
            mean of the data values, minus two sigma, and UPPER to be the
            mean plus three sigma.  If only 1 value is supplied, the same
            value is used for both limits.  If no values are supplied, both
            values default to 3.0.

      }
      The above method names can be abbreviated to one character.

      If the parameter name is supplied as blank, then {\tt "}Range{\tt "} is
      assumed (i.e. LOWER and UPPER are chosen so that the
      encompasses the entire data range).

      The extreme values are reported unless the limits parameter PARAM
      is specified on the command line.  In this case extreme values
      are only calculated where necessary for the chosen method.
   }
   \sstinvocation{
      CALL KPG1\_DARAD( PARAM, EL, ARRAY, METHDS, BAD, LOWER,
                       UPPER, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use to get the method for chosing
         the default limits for the axis. May be blank.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements of the array to be analysed.
      }
      \sstsubsection{
         ARRAY( EL ) = DOUBLE PRECISION (Given)
      }{
         The array for which the chosen statistics are required.
      }
      \sstsubsection{
         METHDS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A comma-separated list of methods by which the data limits may
         be specified.  Different tasks may require only a subset of
         the methods available.  The allowed methods are {\tt "}Faint{\tt "},
         {\tt "}Extended{\tt "}, {\tt "}Limit{\tt "}, {\tt "}Percentiles{\tt "}, {\tt "}Range{\tt "}, and {\tt "}Sigmas{\tt "}.
         See the description for details of these methods.
      }
      \sstsubsection{
         BAD = LOGICAL (Given and Returned)
      }{
         True when bad pixels may be present.
      }
      \sstsubsection{
         LOWER = DOUBLE PRECISION (Returned)
      }{
         The lower limit.
      }
      \sstsubsection{
         UPPER = DOUBLE PRECISION (Returned)
      }{
         The upper limit.
      }
      \sstsubsection{
         STATUS = INTEGER( Given \& Returned )
      }{
         Global status.
      }
   }
}
\sstroutine{
   KPG1\_DARAI
}{
   Determine the data limits for an array using a variety of methods
}{
   \sstdescription{
      This routine derives a data range applicable to the supplied array.
      It is intended to be used to specify the data limits for histogram
      plots and scaling data for image display.  There is a variety of
      methods available to derive the limits, of which a subset of
      appropriate methods can be defined by argument METHOD.

      The method is selected by the user through the literal parameter
      specified by PARAM.  The supplied string should consist of up to
      three sub-strings or elements, separated by commas.  In all but
      one method, the first element must specify the method to use.  If
      supplied, the other two elements should be numerical values as
      described below (default values will be used if these elements are
      not provided).  The following options are available.

      \sstitemlist{

         \sstitem
            {\tt "}Extended{\tt "} -- LOWER and UPPER are returned equal to the
            lowest and highest supplied data values, extended to give a
            margin of 2.5\% of the total data range at each end.

         \sstitem
            {\tt "}Extended,10,5{\tt "} -- Like {\tt "}Extended{\tt "}, except the margins at the
            two ends are specified as a pair of numerical value in the
            second and third elements of the array.  These values are
            percentages of the total data range.  So, {\tt "}Extended,10,5{\tt "}
            includes a margin of 10\% of the total data range in LOWER, and
            5\% in UPPER.  If only one numerical value is given, the same
            value is used for both limits.  If no value is given, both
            limits default to 2.5.  {\tt "}Range{\tt "} is equivalent to
            {\tt "}Extended,0,0{\tt "}.

         \sstitem
            {\tt "}Faint{\tt "} -- The scaling is between the mean data value minus
            one standard deviation and the mean data value plus seven
            standard deviations.  This is retained for historical reasons.

         \sstitem
            {\tt "}Limit{\tt "} --  Allows user to supply explicit lower and upper
            limiting values.  For example, {\tt "}Limit,10,20{\tt "} would set the lower
            limit to 10 and its upper limit to 20.  For compatibility
            reasons and for ease of use, this routine permits the omission
            of the method.  Thus {\tt "}10,20{\tt "} is equivalent to the previous
            example.  The upper limit may be numerically smaller than the
            lower limit, as might be needed for display scaling.  If fewer
            than two numerical values are supplied, the {\tt "}Range{\tt "} method is
            adopted.  The limits must be within the allowed range for the
            data type of the ARRAY argument.

         \sstitem
            {\tt "}Percentiles,5,95{\tt "} -- The second and third elements of the
            array are interpreted as percentiles.  For instance,
            {\tt "}Perc,5,95{\tt "} causes 5\% of the data points to be below LOWER, and
            10\% to be above the UPPER.  If only 1 value (p1) is supplied,
            the other one, p2, defaults to (100 - p1).  If no values are
            supplied, p1 and p2 default to 5 and 95 respectively.  Values
            must be in the range 0 to 100.

         \sstitem
            {\tt "}Range{\tt "} -- LOWER and UPPER are returned equal to the lowest
            and highest supplied array values.

         \sstitem
            {\tt "}Sigmas,2,3{\tt "} -- The second and third elements of the array
            are interpreted as multiples of the standard deviation of the
            data values.  For instance, {\tt "}S,2,3{\tt "} causes the LOWER to be the
            mean of the data values, minus two sigma, and UPPER to be the
            mean plus three sigma.  If only 1 value is supplied, the same
            value is used for both limits.  If no values are supplied, both
            values default to 3.0.

      }
      The above method names can be abbreviated to one character.

      If the parameter name is supplied as blank, then {\tt "}Range{\tt "} is
      assumed (i.e. LOWER and UPPER are chosen so that the
      encompasses the entire data range).

      The extreme values are reported unless the limits parameter PARAM
      is specified on the command line.  In this case extreme values
      are only calculated where necessary for the chosen method.
   }
   \sstinvocation{
      CALL KPG1\_DARAI( PARAM, EL, ARRAY, METHDS, BAD, LOWER,
                       UPPER, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use to get the method for chosing
         the default limits for the axis. May be blank.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements of the array to be analysed.
      }
      \sstsubsection{
         ARRAY( EL ) = INTEGER (Given)
      }{
         The array for which the chosen statistics are required.
      }
      \sstsubsection{
         METHDS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A comma-separated list of methods by which the data limits may
         be specified.  Different tasks may require only a subset of
         the methods available.  The allowed methods are {\tt "}Faint{\tt "},
         {\tt "}Extended{\tt "}, {\tt "}Limit{\tt "}, {\tt "}Percentiles{\tt "}, {\tt "}Range{\tt "}, and {\tt "}Sigmas{\tt "}.
         See the description for details of these methods.
      }
      \sstsubsection{
         BAD = LOGICAL (Given and Returned)
      }{
         True when bad pixels may be present.
      }
      \sstsubsection{
         LOWER = DOUBLE PRECISION (Returned)
      }{
         The lower limit.
      }
      \sstsubsection{
         UPPER = DOUBLE PRECISION (Returned)
      }{
         The upper limit.
      }
      \sstsubsection{
         STATUS = INTEGER( Given \& Returned )
      }{
         Global status.
      }
   }
}
\sstroutine{
   KPG1\_DARAR
}{
   Determine the data limits for an array using a variety of methods
}{
   \sstdescription{
      This routine derives a data range applicable to the supplied array.
      It is intended to be used to specify the data limits for histogram
      plots and scaling data for image display.  There is a variety of
      methods available to derive the limits, of which a subset of
      appropriate methods can be defined by argument METHOD.

      The method is selected by the user through the literal parameter
      specified by PARAM.  The supplied string should consist of up to
      three sub-strings or elements, separated by commas.  In all but
      one method, the first element must specify the method to use.  If
      supplied, the other two elements should be numerical values as
      described below (default values will be used if these elements are
      not provided).  The following options are available.

      \sstitemlist{

         \sstitem
            {\tt "}Extended{\tt "} -- LOWER and UPPER are returned equal to the
            lowest and highest supplied data values, extended to give a
            margin of 2.5\% of the total data range at each end.

         \sstitem
            {\tt "}Extended,10,5{\tt "} -- Like {\tt "}Extended{\tt "}, except the margins at the
            two ends are specified as a pair of numerical value in the
            second and third elements of the array.  These values are
            percentages of the total data range.  So, {\tt "}Extended,10,5{\tt "}
            includes a margin of 10\% of the total data range in LOWER, and
            5\% in UPPER.  If only one numerical value is given, the same
            value is used for both limits.  If no value is given, both
            limits default to 2.5.  {\tt "}Range{\tt "} is equivalent to
            {\tt "}Extended,0,0{\tt "}.

         \sstitem
            {\tt "}Faint{\tt "} -- The scaling is between the mean data value minus
            one standard deviation and the mean data value plus seven
            standard deviations.  This is retained for historical reasons.

         \sstitem
            {\tt "}Limit{\tt "} --  Allows user to supply explicit lower and upper
            limiting values.  For example, {\tt "}Limit,10,20{\tt "} would set the lower
            limit to 10 and its upper limit to 20.  For compatibility
            reasons and for ease of use, this routine permits the omission
            of the method.  Thus {\tt "}10,20{\tt "} is equivalent to the previous
            example.  The upper limit may be numerically smaller than the
            lower limit, as might be needed for display scaling.  If fewer
            than two numerical values are supplied, the {\tt "}Range{\tt "} method is
            adopted.  The limits must be within the allowed range for the
            data type of the ARRAY argument.

         \sstitem
            {\tt "}Percentiles,5,95{\tt "} -- The second and third elements of the
            array are interpreted as percentiles.  For instance,
            {\tt "}Perc,5,95{\tt "} causes 5\% of the data points to be below LOWER, and
            10\% to be above the UPPER.  If only 1 value (p1) is supplied,
            the other one, p2, defaults to (100 - p1).  If no values are
            supplied, p1 and p2 default to 5 and 95 respectively.  Values
            must be in the range 0 to 100.

         \sstitem
            {\tt "}Range{\tt "} -- LOWER and UPPER are returned equal to the lowest
            and highest supplied array values.

         \sstitem
            {\tt "}Sigmas,2,3{\tt "} -- The second and third elements of the array
            are interpreted as multiples of the standard deviation of the
            data values.  For instance, {\tt "}S,2,3{\tt "} causes the LOWER to be the
            mean of the data values, minus two sigma, and UPPER to be the
            mean plus three sigma.  If only 1 value is supplied, the same
            value is used for both limits.  If no values are supplied, both
            values default to 3.0.

      }
      The above method names can be abbreviated to one character.

      If the parameter name is supplied as blank, then {\tt "}Range{\tt "} is
      assumed (i.e. LOWER and UPPER are chosen so that the
      encompasses the entire data range).

      The extreme values are reported unless the limits parameter PARAM
      is specified on the command line.  In this case extreme values
      are only calculated where necessary for the chosen method.
   }
   \sstinvocation{
      CALL KPG1\_DARAR( PARAM, EL, ARRAY, METHDS, BAD, LOWER,
                       UPPER, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use to get the method for chosing
         the default limits for the axis. May be blank.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements of the array to be analysed.
      }
      \sstsubsection{
         ARRAY( EL ) = REAL (Given)
      }{
         The array for which the chosen statistics are required.
      }
      \sstsubsection{
         METHDS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A comma-separated list of methods by which the data limits may
         be specified.  Different tasks may require only a subset of
         the methods available.  The allowed methods are {\tt "}Faint{\tt "},
         {\tt "}Extended{\tt "}, {\tt "}Limit{\tt "}, {\tt "}Percentiles{\tt "}, {\tt "}Range{\tt "}, and {\tt "}Sigmas{\tt "}.
         See the description for details of these methods.
      }
      \sstsubsection{
         BAD = LOGICAL (Given and Returned)
      }{
         True when bad pixels may be present.
      }
      \sstsubsection{
         LOWER = DOUBLE PRECISION (Returned)
      }{
         The lower limit.
      }
      \sstsubsection{
         UPPER = DOUBLE PRECISION (Returned)
      }{
         The upper limit.
      }
      \sstsubsection{
         STATUS = INTEGER( Given \& Returned )
      }{
         Global status.
      }
   }
}
\sstroutine{
   KPG1\_DARAUB
}{
   Determine the data limits for an array using a variety of methods
}{
   \sstdescription{
      This routine derives a data range applicable to the supplied array.
      It is intended to be used to specify the data limits for histogram
      plots and scaling data for image display.  There is a variety of
      methods available to derive the limits, of which a subset of
      appropriate methods can be defined by argument METHOD.

      The method is selected by the user through the literal parameter
      specified by PARAM.  The supplied string should consist of up to
      three sub-strings or elements, separated by commas.  In all but
      one method, the first element must specify the method to use.  If
      supplied, the other two elements should be numerical values as
      described below (default values will be used if these elements are
      not provided).  The following options are available.

      \sstitemlist{

         \sstitem
            {\tt "}Extended{\tt "} -- LOWER and UPPER are returned equal to the
            lowest and highest supplied data values, extended to give a
            margin of 2.5\% of the total data range at each end.

         \sstitem
            {\tt "}Extended,10,5{\tt "} -- Like {\tt "}Extended{\tt "}, except the margins at the
            two ends are specified as a pair of numerical value in the
            second and third elements of the array.  These values are
            percentages of the total data range.  So, {\tt "}Extended,10,5{\tt "}
            includes a margin of 10\% of the total data range in LOWER, and
            5\% in UPPER.  If only one numerical value is given, the same
            value is used for both limits.  If no value is given, both
            limits default to 2.5.  {\tt "}Range{\tt "} is equivalent to
            {\tt "}Extended,0,0{\tt "}.

         \sstitem
            {\tt "}Faint{\tt "} -- The scaling is between the mean data value minus
            one standard deviation and the mean data value plus seven
            standard deviations.  This is retained for historical reasons.

         \sstitem
            {\tt "}Limit{\tt "} --  Allows user to supply explicit lower and upper
            limiting values.  For example, {\tt "}Limit,10,20{\tt "} would set the lower
            limit to 10 and its upper limit to 20.  For compatibility
            reasons and for ease of use, this routine permits the omission
            of the method.  Thus {\tt "}10,20{\tt "} is equivalent to the previous
            example.  The upper limit may be numerically smaller than the
            lower limit, as might be needed for display scaling.  If fewer
            than two numerical values are supplied, the {\tt "}Range{\tt "} method is
            adopted.  The limits must be within the allowed range for the
            data type of the ARRAY argument.

         \sstitem
            {\tt "}Percentiles,5,95{\tt "} -- The second and third elements of the
            array are interpreted as percentiles.  For instance,
            {\tt "}Perc,5,95{\tt "} causes 5\% of the data points to be below LOWER, and
            10\% to be above the UPPER.  If only 1 value (p1) is supplied,
            the other one, p2, defaults to (100 - p1).  If no values are
            supplied, p1 and p2 default to 5 and 95 respectively.  Values
            must be in the range 0 to 100.

         \sstitem
            {\tt "}Range{\tt "} -- LOWER and UPPER are returned equal to the lowest
            and highest supplied array values.

         \sstitem
            {\tt "}Sigmas,2,3{\tt "} -- The second and third elements of the array
            are interpreted as multiples of the standard deviation of the
            data values.  For instance, {\tt "}S,2,3{\tt "} causes the LOWER to be the
            mean of the data values, minus two sigma, and UPPER to be the
            mean plus three sigma.  If only 1 value is supplied, the same
            value is used for both limits.  If no values are supplied, both
            values default to 3.0.

      }
      The above method names can be abbreviated to one character.

      If the parameter name is supplied as blank, then {\tt "}Range{\tt "} is
      assumed (i.e. LOWER and UPPER are chosen so that the
      encompasses the entire data range).

      The extreme values are reported unless the limits parameter PARAM
      is specified on the command line.  In this case extreme values
      are only calculated where necessary for the chosen method.
   }
   \sstinvocation{
      CALL KPG1\_DARAUB( PARAM, EL, ARRAY, METHDS, BAD, LOWER,
                       UPPER, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use to get the method for chosing
         the default limits for the axis. May be blank.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements of the array to be analysed.
      }
      \sstsubsection{
         ARRAY( EL ) = BYTE (Given)
      }{
         The array for which the chosen statistics are required.
      }
      \sstsubsection{
         METHDS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A comma-separated list of methods by which the data limits may
         be specified.  Different tasks may require only a subset of
         the methods available.  The allowed methods are {\tt "}Faint{\tt "},
         {\tt "}Extended{\tt "}, {\tt "}Limit{\tt "}, {\tt "}Percentiles{\tt "}, {\tt "}Range{\tt "}, and {\tt "}Sigmas{\tt "}.
         See the description for details of these methods.
      }
      \sstsubsection{
         BAD = LOGICAL (Given and Returned)
      }{
         True when bad pixels may be present.
      }
      \sstsubsection{
         LOWER = DOUBLE PRECISION (Returned)
      }{
         The lower limit.
      }
      \sstsubsection{
         UPPER = DOUBLE PRECISION (Returned)
      }{
         The upper limit.
      }
      \sstsubsection{
         STATUS = INTEGER( Given \& Returned )
      }{
         Global status.
      }
   }
}
\sstroutine{
   KPG1\_DARAUW
}{
   Determine the data limits for an array using a variety of methods
}{
   \sstdescription{
      This routine derives a data range applicable to the supplied array.
      It is intended to be used to specify the data limits for histogram
      plots and scaling data for image display.  There is a variety of
      methods available to derive the limits, of which a subset of
      appropriate methods can be defined by argument METHOD.

      The method is selected by the user through the literal parameter
      specified by PARAM.  The supplied string should consist of up to
      three sub-strings or elements, separated by commas.  In all but
      one method, the first element must specify the method to use.  If
      supplied, the other two elements should be numerical values as
      described below (default values will be used if these elements are
      not provided).  The following options are available.

      \sstitemlist{

         \sstitem
            {\tt "}Extended{\tt "} -- LOWER and UPPER are returned equal to the
            lowest and highest supplied data values, extended to give a
            margin of 2.5\% of the total data range at each end.

         \sstitem
            {\tt "}Extended,10,5{\tt "} -- Like {\tt "}Extended{\tt "}, except the margins at the
            two ends are specified as a pair of numerical value in the
            second and third elements of the array.  These values are
            percentages of the total data range.  So, {\tt "}Extended,10,5{\tt "}
            includes a margin of 10\% of the total data range in LOWER, and
            5\% in UPPER.  If only one numerical value is given, the same
            value is used for both limits.  If no value is given, both
            limits default to 2.5.  {\tt "}Range{\tt "} is equivalent to
            {\tt "}Extended,0,0{\tt "}.

         \sstitem
            {\tt "}Faint{\tt "} -- The scaling is between the mean data value minus
            one standard deviation and the mean data value plus seven
            standard deviations.  This is retained for historical reasons.

         \sstitem
            {\tt "}Limit{\tt "} --  Allows user to supply explicit lower and upper
            limiting values.  For example, {\tt "}Limit,10,20{\tt "} would set the lower
            limit to 10 and its upper limit to 20.  For compatibility
            reasons and for ease of use, this routine permits the omission
            of the method.  Thus {\tt "}10,20{\tt "} is equivalent to the previous
            example.  The upper limit may be numerically smaller than the
            lower limit, as might be needed for display scaling.  If fewer
            than two numerical values are supplied, the {\tt "}Range{\tt "} method is
            adopted.  The limits must be within the allowed range for the
            data type of the ARRAY argument.

         \sstitem
            {\tt "}Percentiles,5,95{\tt "} -- The second and third elements of the
            array are interpreted as percentiles.  For instance,
            {\tt "}Perc,5,95{\tt "} causes 5\% of the data points to be below LOWER, and
            10\% to be above the UPPER.  If only 1 value (p1) is supplied,
            the other one, p2, defaults to (100 - p1).  If no values are
            supplied, p1 and p2 default to 5 and 95 respectively.  Values
            must be in the range 0 to 100.

         \sstitem
            {\tt "}Range{\tt "} -- LOWER and UPPER are returned equal to the lowest
            and highest supplied array values.

         \sstitem
            {\tt "}Sigmas,2,3{\tt "} -- The second and third elements of the array
            are interpreted as multiples of the standard deviation of the
            data values.  For instance, {\tt "}S,2,3{\tt "} causes the LOWER to be the
            mean of the data values, minus two sigma, and UPPER to be the
            mean plus three sigma.  If only 1 value is supplied, the same
            value is used for both limits.  If no values are supplied, both
            values default to 3.0.

      }
      The above method names can be abbreviated to one character.

      If the parameter name is supplied as blank, then {\tt "}Range{\tt "} is
      assumed (i.e. LOWER and UPPER are chosen so that the
      encompasses the entire data range).

      The extreme values are reported unless the limits parameter PARAM
      is specified on the command line.  In this case extreme values
      are only calculated where necessary for the chosen method.
   }
   \sstinvocation{
      CALL KPG1\_DARAUW( PARAM, EL, ARRAY, METHDS, BAD, LOWER,
                       UPPER, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use to get the method for chosing
         the default limits for the axis. May be blank.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements of the array to be analysed.
      }
      \sstsubsection{
         ARRAY( EL ) = INTEGER$*$2 (Given)
      }{
         The array for which the chosen statistics are required.
      }
      \sstsubsection{
         METHDS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A comma-separated list of methods by which the data limits may
         be specified.  Different tasks may require only a subset of
         the methods available.  The allowed methods are {\tt "}Faint{\tt "},
         {\tt "}Extended{\tt "}, {\tt "}Limit{\tt "}, {\tt "}Percentiles{\tt "}, {\tt "}Range{\tt "}, and {\tt "}Sigmas{\tt "}.
         See the description for details of these methods.
      }
      \sstsubsection{
         BAD = LOGICAL (Given and Returned)
      }{
         True when bad pixels may be present.
      }
      \sstsubsection{
         LOWER = DOUBLE PRECISION (Returned)
      }{
         The lower limit.
      }
      \sstsubsection{
         UPPER = DOUBLE PRECISION (Returned)
      }{
         The upper limit.
      }
      \sstsubsection{
         STATUS = INTEGER( Given \& Returned )
      }{
         Global status.
      }
   }
}
\sstroutine{
   KPG1\_DARAW
}{
   Determine the data limits for an array using a variety of methods
}{
   \sstdescription{
      This routine derives a data range applicable to the supplied array.
      It is intended to be used to specify the data limits for histogram
      plots and scaling data for image display.  There is a variety of
      methods available to derive the limits, of which a subset of
      appropriate methods can be defined by argument METHOD.

      The method is selected by the user through the literal parameter
      specified by PARAM.  The supplied string should consist of up to
      three sub-strings or elements, separated by commas.  In all but
      one method, the first element must specify the method to use.  If
      supplied, the other two elements should be numerical values as
      described below (default values will be used if these elements are
      not provided).  The following options are available.

      \sstitemlist{

         \sstitem
            {\tt "}Extended{\tt "} -- LOWER and UPPER are returned equal to the
            lowest and highest supplied data values, extended to give a
            margin of 2.5\% of the total data range at each end.

         \sstitem
            {\tt "}Extended,10,5{\tt "} -- Like {\tt "}Extended{\tt "}, except the margins at the
            two ends are specified as a pair of numerical value in the
            second and third elements of the array.  These values are
            percentages of the total data range.  So, {\tt "}Extended,10,5{\tt "}
            includes a margin of 10\% of the total data range in LOWER, and
            5\% in UPPER.  If only one numerical value is given, the same
            value is used for both limits.  If no value is given, both
            limits default to 2.5.  {\tt "}Range{\tt "} is equivalent to
            {\tt "}Extended,0,0{\tt "}.

         \sstitem
            {\tt "}Faint{\tt "} -- The scaling is between the mean data value minus
            one standard deviation and the mean data value plus seven
            standard deviations.  This is retained for historical reasons.

         \sstitem
            {\tt "}Limit{\tt "} --  Allows user to supply explicit lower and upper
            limiting values.  For example, {\tt "}Limit,10,20{\tt "} would set the lower
            limit to 10 and its upper limit to 20.  For compatibility
            reasons and for ease of use, this routine permits the omission
            of the method.  Thus {\tt "}10,20{\tt "} is equivalent to the previous
            example.  The upper limit may be numerically smaller than the
            lower limit, as might be needed for display scaling.  If fewer
            than two numerical values are supplied, the {\tt "}Range{\tt "} method is
            adopted.  The limits must be within the allowed range for the
            data type of the ARRAY argument.

         \sstitem
            {\tt "}Percentiles,5,95{\tt "} -- The second and third elements of the
            array are interpreted as percentiles.  For instance,
            {\tt "}Perc,5,95{\tt "} causes 5\% of the data points to be below LOWER, and
            10\% to be above the UPPER.  If only 1 value (p1) is supplied,
            the other one, p2, defaults to (100 - p1).  If no values are
            supplied, p1 and p2 default to 5 and 95 respectively.  Values
            must be in the range 0 to 100.

         \sstitem
            {\tt "}Range{\tt "} -- LOWER and UPPER are returned equal to the lowest
            and highest supplied array values.

         \sstitem
            {\tt "}Sigmas,2,3{\tt "} -- The second and third elements of the array
            are interpreted as multiples of the standard deviation of the
            data values.  For instance, {\tt "}S,2,3{\tt "} causes the LOWER to be the
            mean of the data values, minus two sigma, and UPPER to be the
            mean plus three sigma.  If only 1 value is supplied, the same
            value is used for both limits.  If no values are supplied, both
            values default to 3.0.

      }
      The above method names can be abbreviated to one character.

      If the parameter name is supplied as blank, then {\tt "}Range{\tt "} is
      assumed (i.e. LOWER and UPPER are chosen so that the
      encompasses the entire data range).

      The extreme values are reported unless the limits parameter PARAM
      is specified on the command line.  In this case extreme values
      are only calculated where necessary for the chosen method.
   }
   \sstinvocation{
      CALL KPG1\_DARAW( PARAM, EL, ARRAY, METHDS, BAD, LOWER,
                       UPPER, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use to get the method for chosing
         the default limits for the axis. May be blank.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements of the array to be analysed.
      }
      \sstsubsection{
         ARRAY( EL ) = INTEGER$*$2 (Given)
      }{
         The array for which the chosen statistics are required.
      }
      \sstsubsection{
         METHDS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A comma-separated list of methods by which the data limits may
         be specified.  Different tasks may require only a subset of
         the methods available.  The allowed methods are {\tt "}Faint{\tt "},
         {\tt "}Extended{\tt "}, {\tt "}Limit{\tt "}, {\tt "}Percentiles{\tt "}, {\tt "}Range{\tt "}, and {\tt "}Sigmas{\tt "}.
         See the description for details of these methods.
      }
      \sstsubsection{
         BAD = LOGICAL (Given and Returned)
      }{
         True when bad pixels may be present.
      }
      \sstsubsection{
         LOWER = DOUBLE PRECISION (Returned)
      }{
         The lower limit.
      }
      \sstsubsection{
         UPPER = DOUBLE PRECISION (Returned)
      }{
         The upper limit.
      }
      \sstsubsection{
         STATUS = INTEGER( Given \& Returned )
      }{
         Global status.
      }
   }
}
\sstroutine{
   KPG1\_DAUNI
}{
   Generates a string containing the units of an NDF{\tt '}s data or
   variance component allowing for truncation
}{
   \sstdescription{
      This routines generates a string containing the units of an
      NDF{\tt '}s data or variance component.  If the length of the
      variable to store the string is shorter than the units field,
      the units string is truncated and an ellipsis is inserted.
      For the variance the data units are enclosed in parentheses
      and followed by {\tt '}$*$$*$2{\tt '}.  Again if the the length of the units
      string is too short, truncate the units within the parentheses
      and insert an ellipsis.  A null string is returned if the UNITS
      component does not exist within the NDF.
   }
   \sstinvocation{
      CALL KPG1\_DAUNI( NDF, COMP, UNITS, NCU, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDF = INTEGER (Given)
      }{
         The NDF identifier
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The NDF component: {\tt '}DATA{\tt '}, {\tt '}VARIANCE{\tt '}, {\tt '}QUALITY{\tt '} or {\tt '}ERROR{\tt '}.
         Any other component will result in a SAI\_\_ERROR status being
         returned immediately.
      }
      \sstsubsection{
         UNITS = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The string containing the units for the component, possibly
         truncated.  It is recommended that string should be at least
         20 characters long.  If COMP = {\tt '}VARIANCE{\tt '} the length must be
         no less than 9 characters; for COMP = {\tt '}DATA{\tt '} the minimum is 4
         characters; for COMP = {\tt '}ERROR{\tt '} the minimum is 5 characters;
         otherwise the routine returns immediately with the SAI\_\_ERROR
         status.
      }
      \sstsubsection{
         NCU = INTEGER (Returned)
      }{
         The length of the units string in characters ignoring trailing
         blanks. Always returned equal to zero if COMP = {\tt '}QUALITY{\tt '}.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_DCLIx
}{
   Determines a linear transformation from pixel to NDF-axis
   co-ordinates
}{
   \sstdescription{
      This routine obtains a data co-ordinate system from the NDF
      axes, and determines whether all the axes are linear.  If they
      are linear transformations between pixel co-ordinates and
      data co-ordinates are derived.  A warning message is reported
      for each individual non-linear axis.
   }
   \sstinvocation{
      CALL KPG1\_DCLIx( NDIM, NDF, DALBND, DAUBND, SCALE, OFFSET, LINEAR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of contiguous axes.  If it is negative, it indicates
         that not all the dimensions need be significant.
      }
      \sstsubsection{
         NDF = INTEGER (Given)
      }{
         The identifier of the NDF whose axes are to provide the data
         co-ordinates.  It must have at least NDIM dimensions, though
         this is not checked.
      }
      \sstsubsection{
         DALBND( NDIM ) = ? (Returned)
      }{
         The lower bounds of the data co-ordinates obtained from the
         NDF{\tt '}s axes.  Note that this gives the data co-ordinate at the
         lower side of the array element, and not at its centre.
      }
      \sstsubsection{
         DAUBND( NDIM ) = ?  (Returned)
      }{
         The upper bounds of the data co-ordinates obtained from the
         NDF{\tt '}s axes.   Note that this gives the data co-ordinate at the
         upper side of the array element, and not at its centre.
      }
      \sstsubsection{
         SCALE( NDIM ) = ? (Returned)
      }{
         The scale factors in the linear transformations from world
         to data co-ordinates.  They should be ignored if LINEAR is
         false.
      }
      \sstsubsection{
         OFFSET( NDIM ) = ? (Returned)
      }{
         The offsets in the linear transformations from world
         to data co-ordinates.  They should be ignored if LINEAR is
         false.
      }
      \sstsubsection{
         LINEAR = LOGICAL (Returned)
      }{
         If true the NDF axes are all linear and different from world
         co-ordinates.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision data types:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively.  The scale
         and offset, and the bounds returned by the routine must have
         the data type specified.

         \sstitem
         This routine assumes monotonic axes.
      }
   }
}
\sstroutine{
   KPG1\_DCLIx
}{
   Determines a linear transformation from pixel to NDF-axis
   co-ordinates
}{
   \sstdescription{
      This routine obtains a data co-ordinate system from the NDF
      axes, and determines whether all the axes are linear.  If they
      are linear transformations between pixel co-ordinates and
      data co-ordinates are derived.  A warning message is reported
      for each individual non-linear axis.
   }
   \sstinvocation{
      CALL KPG1\_DCLIx( NDIM, NDF, DALBND, DAUBND, SCALE, OFFSET, LINEAR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of contiguous axes.  If it is negative, it indicates
         that not all the dimensions need be significant.
      }
      \sstsubsection{
         NDF = INTEGER (Given)
      }{
         The identifier of the NDF whose axes are to provide the data
         co-ordinates.  It must have at least NDIM dimensions, though
         this is not checked.
      }
      \sstsubsection{
         DALBND( NDIM ) = ? (Returned)
      }{
         The lower bounds of the data co-ordinates obtained from the
         NDF{\tt '}s axes.  Note that this gives the data co-ordinate at the
         lower side of the array element, and not at its centre.
      }
      \sstsubsection{
         DAUBND( NDIM ) = ?  (Returned)
      }{
         The upper bounds of the data co-ordinates obtained from the
         NDF{\tt '}s axes.   Note that this gives the data co-ordinate at the
         upper side of the array element, and not at its centre.
      }
      \sstsubsection{
         SCALE( NDIM ) = ? (Returned)
      }{
         The scale factors in the linear transformations from world
         to data co-ordinates.  They should be ignored if LINEAR is
         false.
      }
      \sstsubsection{
         OFFSET( NDIM ) = ? (Returned)
      }{
         The offsets in the linear transformations from world
         to data co-ordinates.  They should be ignored if LINEAR is
         false.
      }
      \sstsubsection{
         LINEAR = LOGICAL (Returned)
      }{
         If true the NDF axes are all linear and different from world
         co-ordinates.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision data types:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively.  The scale
         and offset, and the bounds returned by the routine must have
         the data type specified.

         \sstitem
         This routine assumes monotonic axes.
      }
   }
}
\sstroutine{
   KPG1\_DEBUG
}{
   Should the speified package report debug diagnostics?
}{
   \sstdescription{
      This routine returns a logical flag indicating if a specified
      applications package should report debug diagnostics. This is the
      case if the environment variable $<$PACK$>$\_DEBUG is defined (the value
      assigned to the environment variable is immaterial).
   }
   \sstinvocation{
      CALL KPG1\_DEBUG( VERB, PACK, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DEBUG = LOGICAL (Returned)
      }{
         Should the package run in debug mode? Returned .FALSE, if an
         error has already occurred, or if this routine should fail for
         any reason.
      }
      \sstsubsection{
         PACK = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the package (eg {\tt "}KAPPA{\tt "}, {\tt "}POLPACK{\tt "}, etc).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine attempts to execute even if STATUS is set to an
         error on entry.
      }
   }
}
\sstroutine{
   KPG1\_DIVx
}{
   Divide two vectorised arrays with optional variance information
}{
   \sstdescription{
      The routine divides one vectorised array by another, with
      optional variance information. Bad value checking is also
      performed if required.
   }
   \sstinvocation{
      CALL KPG1\_DIVx( BAD, VAR, EL, A, VA, B, VB, C, VC, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether it is necessary to check for bad values in the input
         arrays. The routine will execute more rapidly if this checking
         can be omitted.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         Whether associated variance information is to be processed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         A( EL ) = ? (Given)
      }{
         First array of data, to be divided by the second array.
      }
      \sstsubsection{
         VA( EL ) = ? (Given)
      }{
         Variance values associated with the array A. Not used if VAR
         is set to .FALSE..
      }
      \sstsubsection{
         B( EL ) = ? (Given)
      }{
         Second array of data, to be divided into the first array.
      }
      \sstsubsection{
         VB( EL ) = ? (Given)
      }{
         Variance values associated with the array B. Not used if VAR
         is set to .FALSE..
      }
      \sstsubsection{
         C( EL ) = ? (Returned)
      }{
         Result of dividing array A by array B.
      }
      \sstsubsection{
         VC( EL ) = ? (Returned)
      }{
         Variance values associated with the array C. Not used if VAR
         is set to .FALSE..
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         Number of VAL\_\_BADx values in the returned results array (C).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the data types real and double
         precision: replace {\tt "}x{\tt "} in the routine name by R or D as
         appropriate.  The arrays passed to this routine should all have
         the specified data type.

         \sstitem
         This routine will NOT handle numerical overflow.
      }
   }
}
\sstroutine{
   KPG1\_DIVx
}{
   Divide two vectorised arrays with optional variance information
}{
   \sstdescription{
      The routine divides one vectorised array by another, with
      optional variance information. Bad value checking is also
      performed if required.
   }
   \sstinvocation{
      CALL KPG1\_DIVx( BAD, VAR, EL, A, VA, B, VB, C, VC, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether it is necessary to check for bad values in the input
         arrays. The routine will execute more rapidly if this checking
         can be omitted.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         Whether associated variance information is to be processed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         A( EL ) = ? (Given)
      }{
         First array of data, to be divided by the second array.
      }
      \sstsubsection{
         VA( EL ) = ? (Given)
      }{
         Variance values associated with the array A. Not used if VAR
         is set to .FALSE..
      }
      \sstsubsection{
         B( EL ) = ? (Given)
      }{
         Second array of data, to be divided into the first array.
      }
      \sstsubsection{
         VB( EL ) = ? (Given)
      }{
         Variance values associated with the array B. Not used if VAR
         is set to .FALSE..
      }
      \sstsubsection{
         C( EL ) = ? (Returned)
      }{
         Result of dividing array A by array B.
      }
      \sstsubsection{
         VC( EL ) = ? (Returned)
      }{
         Variance values associated with the array C. Not used if VAR
         is set to .FALSE..
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         Number of VAL\_\_BADx values in the returned results array (C).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the data types real and double
         precision: replace {\tt "}x{\tt "} in the routine name by R or D as
         appropriate.  The arrays passed to this routine should all have
         the specified data type.

         \sstitem
         This routine will NOT handle numerical overflow.
      }
   }
}
\sstroutine{
   KPG1\_DNAG2R
}{
   Converts an NAG Hermitian Fourier transform array into an array
   usable by FFTPACK routine KPG1\_DRFFTB
}{
   \sstdescription{
      This subroutine modifies the supplied array of Fourier co-efficients
      (as produced by NAG subroutine C06FAF) so that an inverse FFT can be
      performed on them using FFTPACK routine KPG1\_DRFFTB. The resulting inverse
      will have the same normalisation as the original data transformed
      using KPG1\_DRFFTF.

      This function is equivalent to PDA\_NAG2R except that it uses work
      space for greater speed.
   }
   \sstinvocation{
      CALL KPG1\_DNAG2R( NP, R, WORK )
   }
   \sstarguments{
      \sstsubsection{
         NP = INTEGER (Given)
      }{
         The size of the array.
      }
      \sstsubsection{
         R( NP ) = DOUBLE PRECISION (Given and Returned)
      }{
         The array holding the Fourier co-efficients. Supplied in NAG
         format and returned in FFTPACK format.
      }
      \sstsubsection{
         WORK( NP ) = DOUBLE PRECISION (Given and Returned)
      }{
         Work space.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A call to KPG1\_DR2NAG followed by a call to KPG1\_DNAG2R will result in
         the original data being divided by NP.
      }
   }
}
\sstroutine{
   KPG1\_DR2NAG
}{
   Converts an FFTPACK Hermitian Fourier transform array into
   the equivalent NAG array
}{
   \sstdescription{
      This subroutine re-orders and normalises the supplied array of
      Fourier co-efficients (as produced by FFTPACK subroutine KPG1\_DRFFTF)
      so that the returned array looks like the equivalent array returned
      by NAG routine C06FAF.

      This function is equivalent to PDA\_DR2NAG except that it uses work
      space for greater speed.

      The real and imaginary co-efficients produced by KPG1\_DRFFTF are numerically
      larger than the corresponding C06FAF co-efficients by a factor of
      SQRT( NP ), and are ordered differently. Both routines return A0
      (the zeroth real term, i.e. the DC level in the array) in element 1.
      KPG1\_DRFFTF then has corresponding real and imaginary terms in adjacent
      elements, whereas C06FAF has all the real terms together, followed by
      all the imaginary terms (in reverse order):

         KPG1\_DRFFTF:  A0,    A1, B1,     A2, B2,     A3, B3,   ...
         C06FAF:       A0,    A1, A2, A3, ...,        ..., B3, B2, B1

      The zeroth imaginary term (B0) always has the value zero and so is
      not stored in the array. Care has to be taken about the parity of the
      array size. If it is even, then there is one more real term than
      there is imaginary terms (excluding A0), i.e. if NP = 10, then the
      co-efficients are stored as follows:

         KPG1\_DRFFTF:  A0, A1, B1, A2, B2, A3, B3, A4, B4, A5
         C06FAF:       A0, A1, A2, A3, A4, A5, B4, B3, B2, B1

      If NP = 9, then the co-efficients are stored as follows:

         KPG1\_DRFFTF:  A0, A1, B1, A2, B2, A3, B3, A4, B4
         C06FAF:       A0, A1, A2, A3, A4, B4, B3, B2, B1
   }
   \sstinvocation{
      CALL KPG1\_DR2NAG( NP, R )
   }
   \sstarguments{
      \sstsubsection{
         NP = INTEGER (Given)
      }{
         The size of the array.
      }
      \sstsubsection{
         R( NP ) = DOUBLE PRECISION (Given and Returned)
      }{
         The array holding the Fourier co-efficients. Supplied in FFTPACK
         format and returned in NAG format.
      }
      \sstsubsection{
         WORK( NP ) = DOUBLE PRECISION (Given and Returned)
      }{
         Work space.
      }
   }
}
\sstroutine{
   KPG1\_DSFR1
}{
   Display a textual description of the Current Frame in a FrameSet
}{
   \sstdescription{
      This routine displays a textual description of the supplied AST Frame.
      The displayed information does not include any axis-specific details
      which are common to all classes of Frame (such as axis units, labels,
      etc).
   }
   \sstinvocation{
      CALL KPG1\_DSFR1( FRM, TEXT, NIND, FULL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FRM = INTEGER (Given)
      }{
         An AST pointer to the Frame.
      }
      \sstsubsection{
         TEXT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Text to display before the Frame description. May contain MSG
         tokens.
      }
      \sstsubsection{
         NIND = INTEGER (Given)
      }{
         Number of spaces to display at the start of each line.
      }
      \sstsubsection{
         FULL = LOGICAL (Given)
      }{
         Display full information?
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_DSFRM
}{
   Display a textual description of the Current Frame in a FrameSet
}{
   \sstdescription{
      This routine displays a textual description of the Current Frame
      in the supplied AST FrameSet.
   }
   \sstinvocation{
      CALL KPG1\_DSFRM( FSET, TEXT, FULL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FSET = INTEGER (Given)
      }{
         An AST pointer to the FrameSet.
      }
      \sstsubsection{
         TEXT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Text to display before the Frame description. May contain MSG
         tokens.
      }
      \sstsubsection{
         FULL = LOGICAL (Given)
      }{
         Display full information?
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_DWSOx
}{
   Obtains for the scale and offset for a linear transformation from
   world to data co-ordinates
}{
   \sstdescription{
      This routine determines a linear transformation between world
      (pixel) co-ordinates and data co-ordinates obtained from the axis
      structure.  A linear equation is solved using the two boundary
      conditions for the lower and upper bounds in world and data
      co-ordinates.
   }
   \sstinvocation{
      CALL KPG1\_DWSOx( LBND, UBND, AXIS, SCALE, OFFSET, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The lower bound of the axis array.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The upper bound of the axis array.
      }
      \sstsubsection{
         AXIS( LBND:UBND ) = ? (Given)
      }{
         The axis array.
      }
      \sstsubsection{
         SCALE = ? (Returned)
      }{
         The scale factor of the linear axis to transform from world
         co-ordinates to data co-ordinates.
      }
      \sstsubsection{
         OFFSET = ? (Returned)
      }{
         The offset of the linear axis at pixel 0 to transform from
         world co-ordinates to data co-ordinates.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the data types real or double precision:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively, as
         appropriate.  The axis array, and the returned scale and offset
         should have this data type as well.
      }
   }
}
\sstroutine{
   KPG1\_DWSOx
}{
   Obtains for the scale and offset for a linear transformation from
   world to data co-ordinates
}{
   \sstdescription{
      This routine determines a linear transformation between world
      (pixel) co-ordinates and data co-ordinates obtained from the axis
      structure.  A linear equation is solved using the two boundary
      conditions for the lower and upper bounds in world and data
      co-ordinates.
   }
   \sstinvocation{
      CALL KPG1\_DWSOx( LBND, UBND, AXIS, SCALE, OFFSET, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The lower bound of the axis array.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The upper bound of the axis array.
      }
      \sstsubsection{
         AXIS( LBND:UBND ) = ? (Given)
      }{
         The axis array.
      }
      \sstsubsection{
         SCALE = ? (Returned)
      }{
         The scale factor of the linear axis to transform from world
         co-ordinates to data co-ordinates.
      }
      \sstsubsection{
         OFFSET = ? (Returned)
      }{
         The offset of the linear axis at pixel 0 to transform from
         world co-ordinates to data co-ordinates.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the data types real or double precision:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively, as
         appropriate.  The axis array, and the returned scale and offset
         should have this data type as well.
      }
   }
}
\sstroutine{
   KPG1\_ELNMx
}{
   Writes a range of element numbers into an array
}{
   \sstdescription{
      This routine writes numbers sequentially to a 1-dimensional
      array, where the numbers are between defined integer limits and
      are stepped by 1 (or -1) from one pixel to the next.  In other
      words the array value takes the element number plus an offset.
      Only the first EL elements can be accommodated in the output
      array, should the section be larger than this.
   }
   \sstinvocation{
      CALL KPG1\_ELNMBx( LBND, UBND, EL, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The first value to be written to the output array.  If this is
         larger than argument UBND, the values will decrease by 1 for
         each element.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The last value to be written to the output array, provided
         there are sufficient elements to accommodate it.  If not
         only EL values will be stored.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the output array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Returned)
      }{
         The array into which the sub-array is copied.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY argument must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_ELNMx
}{
   Writes a range of element numbers into an array
}{
   \sstdescription{
      This routine writes numbers sequentially to a 1-dimensional
      array, where the numbers are between defined integer limits and
      are stepped by 1 (or -1) from one pixel to the next.  In other
      words the array value takes the element number plus an offset.
      Only the first EL elements can be accommodated in the output
      array, should the section be larger than this.
   }
   \sstinvocation{
      CALL KPG1\_ELNMBx( LBND, UBND, EL, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The first value to be written to the output array.  If this is
         larger than argument UBND, the values will decrease by 1 for
         each element.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The last value to be written to the output array, provided
         there are sufficient elements to accommodate it.  If not
         only EL values will be stored.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the output array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Returned)
      }{
         The array into which the sub-array is copied.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY argument must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_ELNMx
}{
   Writes a range of element numbers into an array
}{
   \sstdescription{
      This routine writes numbers sequentially to a 1-dimensional
      array, where the numbers are between defined integer limits and
      are stepped by 1 (or -1) from one pixel to the next.  In other
      words the array value takes the element number plus an offset.
      Only the first EL elements can be accommodated in the output
      array, should the section be larger than this.
   }
   \sstinvocation{
      CALL KPG1\_ELNMBx( LBND, UBND, EL, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The first value to be written to the output array.  If this is
         larger than argument UBND, the values will decrease by 1 for
         each element.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The last value to be written to the output array, provided
         there are sufficient elements to accommodate it.  If not
         only EL values will be stored.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the output array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Returned)
      }{
         The array into which the sub-array is copied.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY argument must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_ELNMx
}{
   Writes a range of element numbers into an array
}{
   \sstdescription{
      This routine writes numbers sequentially to a 1-dimensional
      array, where the numbers are between defined integer limits and
      are stepped by 1 (or -1) from one pixel to the next.  In other
      words the array value takes the element number plus an offset.
      Only the first EL elements can be accommodated in the output
      array, should the section be larger than this.
   }
   \sstinvocation{
      CALL KPG1\_ELNMBx( LBND, UBND, EL, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The first value to be written to the output array.  If this is
         larger than argument UBND, the values will decrease by 1 for
         each element.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The last value to be written to the output array, provided
         there are sufficient elements to accommodate it.  If not
         only EL values will be stored.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the output array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Returned)
      }{
         The array into which the sub-array is copied.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY argument must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_ELNMx
}{
   Writes a range of element numbers into an array
}{
   \sstdescription{
      This routine writes numbers sequentially to a 1-dimensional
      array, where the numbers are between defined integer limits and
      are stepped by 1 (or -1) from one pixel to the next.  In other
      words the array value takes the element number plus an offset.
      Only the first EL elements can be accommodated in the output
      array, should the section be larger than this.
   }
   \sstinvocation{
      CALL KPG1\_ELNMBx( LBND, UBND, EL, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The first value to be written to the output array.  If this is
         larger than argument UBND, the values will decrease by 1 for
         each element.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The last value to be written to the output array, provided
         there are sufficient elements to accommodate it.  If not
         only EL values will be stored.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the output array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Returned)
      }{
         The array into which the sub-array is copied.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY argument must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_ELNMx
}{
   Writes a range of element numbers into an array
}{
   \sstdescription{
      This routine writes numbers sequentially to a 1-dimensional
      array, where the numbers are between defined integer limits and
      are stepped by 1 (or -1) from one pixel to the next.  In other
      words the array value takes the element number plus an offset.
      Only the first EL elements can be accommodated in the output
      array, should the section be larger than this.
   }
   \sstinvocation{
      CALL KPG1\_ELNMBx( LBND, UBND, EL, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The first value to be written to the output array.  If this is
         larger than argument UBND, the values will decrease by 1 for
         each element.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The last value to be written to the output array, provided
         there are sufficient elements to accommodate it.  If not
         only EL values will be stored.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the output array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Returned)
      }{
         The array into which the sub-array is copied.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY argument must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_ELNMx
}{
   Writes a range of element numbers into an array
}{
   \sstdescription{
      This routine writes numbers sequentially to a 1-dimensional
      array, where the numbers are between defined integer limits and
      are stepped by 1 (or -1) from one pixel to the next.  In other
      words the array value takes the element number plus an offset.
      Only the first EL elements can be accommodated in the output
      array, should the section be larger than this.
   }
   \sstinvocation{
      CALL KPG1\_ELNMBx( LBND, UBND, EL, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The first value to be written to the output array.  If this is
         larger than argument UBND, the values will decrease by 1 for
         each element.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The last value to be written to the output array, provided
         there are sufficient elements to accommodate it.  If not
         only EL values will be stored.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the output array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Returned)
      }{
         The array into which the sub-array is copied.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY argument must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_ENV0R
}{
   Reads a floating point value from an environment variable
}{
   \sstdescription{
      This routine reads a floating point value from a specified
      environment variable. No error occurs if the environment variable
      is not defined, or has a non-numeric value, and the supplied value
      is returned unchanged.
   }
   \sstinvocation{
      CALL KPG1\_ENV0R( VARNAM, RVAL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VARNAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The environment variable to check.
      }
      \sstsubsection{
         RVAL = REAL (Returned)
      }{
         The value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ENVDF
}{
   See if an environment variable is defined
}{
   \sstdescription{
      This routine returns a logical flag indicating if the specified
      environment variable is defined.
   }
   \sstinvocation{
      CALL KPG1\_ENVDF( VARNAM, DEF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VARNAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The environment variable to check.
      }
      \sstsubsection{
         DEF = LOGICAL (Returned)
      }{
         Is the environment variable defined?
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine attempts to execute even if STATUS is set to an
         error on entry.
      }
   }
}
\sstroutine{
   KPG1\_ERBAR
}{
   Plots various kinds of error bar
}{
   \sstdescription{
      This routine plots error bars for an array of x-y co-ordinates.
      Argument ERRTYP specifies the appearance of the error bars, and
      ERRPEN the pen used to plot them.  The frequency of error bars is
      also controllable through argument FREQ.  Either axis may be
      logarithmic.
   }
   \sstinvocation{
      CALL KPG1\_ERBAR( ERRTYP, ERRPEN, FREQ, EL, XPOS, XERROR,
                       YPOS, YERROR, XMIN, XMAX, YMIN, YMAX,
                       XLOG, YLOG, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         ERRTYP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The way the errors are to be represented graphically.  ERRTYP
         can take the following values.
            {\tt "}BARS{\tt "}     A cross with serifs is plotted joining the x
                       error limits and then the y error limits.
            {\tt "}CROSS{\tt "}    A san-serif cross is plotted joining the x error
                       limits and then the y error limits.
            {\tt "}DIAMOND{\tt "}  Adjacent error limits are joined to form a error
                       diamond.
         The value is case insensitive and may be abbreviated.
      }
      \sstsubsection{
         ERRPEN = INTEGER (Given)
      }{
         The pen to be used to draw the error bars or diamond.  This
         should be positive, and preferably in the range 1 to 5 to
         ensure that there is an available pen.  There is no validation
         in this routine.
      }
      \sstsubsection{
         FREQ = INTEGER (Given)
      }{
         The frequency at which error bars are to be plotted.  So a
         value of 2 would mean that alternative points have error bars
         plotted.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of points to be plotted.
      }
      \sstsubsection{
         XPOS( EL ) = REAL (Given)
      }{
         The x co-ordinates of the points to be plotted.
      }
      \sstsubsection{
         XERROR( EL ) = REAL (Given)
      }{
         The x co-ordinate errors of the points to be plotted.
      }
      \sstsubsection{
         YPOS( EL ) = REAL (Given)
      }{
         The y co-ordinates of the points to be plotted.
      }
      \sstsubsection{
         YERROR( EL ) = REAL (Given)
      }{
         The y co-ordinate errors of the points to be plotted.
      }
      \sstsubsection{
         XMIN = REAL (Given)
      }{
         The lower x co-ordinate bound of the plot.
      }
      \sstsubsection{
         XMAX = REAL (Given)
      }{
         The upper x co-ordinate bound of the plot.
      }
      \sstsubsection{
         YMIN = REAL (Given)
      }{
         The lower y co-ordinate bound of the plot.
      }
      \sstsubsection{
         YMAX = REAL (Given)
      }{
         The upper y co-ordinate bound of the plot.
      }
      \sstsubsection{
         XLOG = LOGICAL (Given)
      }{
         If .TRUE., the x-axis is logarithmic, and thus the base-10
         logarithms of supplied x co-ordinates are used in plotting.
      }
      \sstsubsection{
         YLOG = LOGICAL (Given)
      }{
         If .TRUE., the y-axis is logarithmic, and thus the base-10
         logarithms of supplied y co-ordinates are used in plotting.
      }
      \sstsubsection{
         [argument\_spec]...
      }{
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      An SGS workstation must be open.
   }
}
\sstroutine{
   KPG1\_EXPOx
}{
   Takes the exponential to an arbitrary base of an array and its
   variance
}{
   \sstdescription{
      This routine fills the output array pixels with the results
      of taking the exponential of the pixels of the input array
      to the base specified, i.e. New\_value = Base $*$$*$ Old\_value.
      If the result is bigger than the maximum-allowed value
      then a bad pixel value is substituted in the output array.

      If variance is present it is computed as:                 2
          New\_Variance = Old\_Variance $*$ ( New\_value $*$ log Base )
   }
   \sstinvocation{
      CALL KPG1\_EXPOx( BAD, EL, INARR, VAR, INVAR, BASE, OUTARR,
                       OUTVAR, NERR, NERRV, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of elements in the input output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         Array containing input image data.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If .TRUE., there is a variance array to process.
      }
      \sstsubsection{
         INVAR( EL ) = ? (Given)
      }{
         Array containing input variance data, when VAR = .TRUE..
      }
      \sstsubsection{
         BASE = DOUBLE PRECISION (Given)
      }{
         Base of exponential to be used.  It must be a positive number.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Write)
      }{
         Array containing results of processing the input data.
      }
      \sstsubsection{
         OUTVAR( EL ) = ? (Write)
      }{
         Array containing results of processing the input variance
         data, when VAR = .TRUE..
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         data array.
      }
      \sstsubsection{
         NERRV = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         variance array, when VAR = .TRUE..
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         arrays supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_EXPOx
}{
   Takes the exponential to an arbitrary base of an array and its
   variance
}{
   \sstdescription{
      This routine fills the output array pixels with the results
      of taking the exponential of the pixels of the input array
      to the base specified, i.e. New\_value = Base $*$$*$ Old\_value.
      If the result is bigger than the maximum-allowed value
      then a bad pixel value is substituted in the output array.

      If variance is present it is computed as:                 2
          New\_Variance = Old\_Variance $*$ ( New\_value $*$ log Base )
   }
   \sstinvocation{
      CALL KPG1\_EXPOx( BAD, EL, INARR, VAR, INVAR, BASE, OUTARR,
                       OUTVAR, NERR, NERRV, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of elements in the input output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         Array containing input image data.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If .TRUE., there is a variance array to process.
      }
      \sstsubsection{
         INVAR( EL ) = ? (Given)
      }{
         Array containing input variance data, when VAR = .TRUE..
      }
      \sstsubsection{
         BASE = DOUBLE PRECISION (Given)
      }{
         Base of exponential to be used.  It must be a positive number.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Write)
      }{
         Array containing results of processing the input data.
      }
      \sstsubsection{
         OUTVAR( EL ) = ? (Write)
      }{
         Array containing results of processing the input variance
         data, when VAR = .TRUE..
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         data array.
      }
      \sstsubsection{
         NERRV = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         variance array, when VAR = .TRUE..
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         arrays supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_EXPOx
}{
   Takes the exponential to an arbitrary base of an array and its
   variance
}{
   \sstdescription{
      This routine fills the output array pixels with the results
      of taking the exponential of the pixels of the input array
      to the base specified, i.e. New\_value = Base $*$$*$ Old\_value.
      If the result is bigger than the maximum-allowed value
      then a bad pixel value is substituted in the output array.

      If variance is present it is computed as:                 2
          New\_Variance = Old\_Variance $*$ ( New\_value $*$ log Base )
   }
   \sstinvocation{
      CALL KPG1\_EXPOx( BAD, EL, INARR, VAR, INVAR, BASE, OUTARR,
                       OUTVAR, NERR, NERRV, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of elements in the input output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         Array containing input image data.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If .TRUE., there is a variance array to process.
      }
      \sstsubsection{
         INVAR( EL ) = ? (Given)
      }{
         Array containing input variance data, when VAR = .TRUE..
      }
      \sstsubsection{
         BASE = DOUBLE PRECISION (Given)
      }{
         Base of exponential to be used.  It must be a positive number.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Write)
      }{
         Array containing results of processing the input data.
      }
      \sstsubsection{
         OUTVAR( EL ) = ? (Write)
      }{
         Array containing results of processing the input variance
         data, when VAR = .TRUE..
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         data array.
      }
      \sstsubsection{
         NERRV = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         variance array, when VAR = .TRUE..
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         arrays supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_EXPOx
}{
   Takes the exponential to an arbitrary base of an array and its
   variance
}{
   \sstdescription{
      This routine fills the output array pixels with the results
      of taking the exponential of the pixels of the input array
      to the base specified, i.e. New\_value = Base $*$$*$ Old\_value.
      If the result is bigger than the maximum-allowed value
      then a bad pixel value is substituted in the output array.

      If variance is present it is computed as:                 2
          New\_Variance = Old\_Variance $*$ ( New\_value $*$ log Base )
   }
   \sstinvocation{
      CALL KPG1\_EXPOx( BAD, EL, INARR, VAR, INVAR, BASE, OUTARR,
                       OUTVAR, NERR, NERRV, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of elements in the input output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         Array containing input image data.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If .TRUE., there is a variance array to process.
      }
      \sstsubsection{
         INVAR( EL ) = ? (Given)
      }{
         Array containing input variance data, when VAR = .TRUE..
      }
      \sstsubsection{
         BASE = DOUBLE PRECISION (Given)
      }{
         Base of exponential to be used.  It must be a positive number.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Write)
      }{
         Array containing results of processing the input data.
      }
      \sstsubsection{
         OUTVAR( EL ) = ? (Write)
      }{
         Array containing results of processing the input variance
         data, when VAR = .TRUE..
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         data array.
      }
      \sstsubsection{
         NERRV = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         variance array, when VAR = .TRUE..
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         arrays supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_EXPOx
}{
   Takes the exponential to an arbitrary base of an array and its
   variance
}{
   \sstdescription{
      This routine fills the output array pixels with the results
      of taking the exponential of the pixels of the input array
      to the base specified, i.e. New\_value = Base $*$$*$ Old\_value.
      If the result is bigger than the maximum-allowed value
      then a bad pixel value is substituted in the output array.

      If variance is present it is computed as:                 2
          New\_Variance = Old\_Variance $*$ ( New\_value $*$ log Base )
   }
   \sstinvocation{
      CALL KPG1\_EXPOx( BAD, EL, INARR, VAR, INVAR, BASE, OUTARR,
                       OUTVAR, NERR, NERRV, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of elements in the input output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         Array containing input image data.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If .TRUE., there is a variance array to process.
      }
      \sstsubsection{
         INVAR( EL ) = ? (Given)
      }{
         Array containing input variance data, when VAR = .TRUE..
      }
      \sstsubsection{
         BASE = DOUBLE PRECISION (Given)
      }{
         Base of exponential to be used.  It must be a positive number.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Write)
      }{
         Array containing results of processing the input data.
      }
      \sstsubsection{
         OUTVAR( EL ) = ? (Write)
      }{
         Array containing results of processing the input variance
         data, when VAR = .TRUE..
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         data array.
      }
      \sstsubsection{
         NERRV = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         variance array, when VAR = .TRUE..
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         arrays supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_EXPOx
}{
   Takes the exponential to an arbitrary base of an array and its
   variance
}{
   \sstdescription{
      This routine fills the output array pixels with the results
      of taking the exponential of the pixels of the input array
      to the base specified, i.e. New\_value = Base $*$$*$ Old\_value.
      If the result is bigger than the maximum-allowed value
      then a bad pixel value is substituted in the output array.

      If variance is present it is computed as:                 2
          New\_Variance = Old\_Variance $*$ ( New\_value $*$ log Base )
   }
   \sstinvocation{
      CALL KPG1\_EXPOx( BAD, EL, INARR, VAR, INVAR, BASE, OUTARR,
                       OUTVAR, NERR, NERRV, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of elements in the input output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         Array containing input image data.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If .TRUE., there is a variance array to process.
      }
      \sstsubsection{
         INVAR( EL ) = ? (Given)
      }{
         Array containing input variance data, when VAR = .TRUE..
      }
      \sstsubsection{
         BASE = DOUBLE PRECISION (Given)
      }{
         Base of exponential to be used.  It must be a positive number.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Write)
      }{
         Array containing results of processing the input data.
      }
      \sstsubsection{
         OUTVAR( EL ) = ? (Write)
      }{
         Array containing results of processing the input variance
         data, when VAR = .TRUE..
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         data array.
      }
      \sstsubsection{
         NERRV = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         variance array, when VAR = .TRUE..
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         arrays supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_EXPOx
}{
   Takes the exponential to an arbitrary base of an array and its
   variance
}{
   \sstdescription{
      This routine fills the output array pixels with the results
      of taking the exponential of the pixels of the input array
      to the base specified, i.e. New\_value = Base $*$$*$ Old\_value.
      If the result is bigger than the maximum-allowed value
      then a bad pixel value is substituted in the output array.

      If variance is present it is computed as:                 2
          New\_Variance = Old\_Variance $*$ ( New\_value $*$ log Base )
   }
   \sstinvocation{
      CALL KPG1\_EXPOx( BAD, EL, INARR, VAR, INVAR, BASE, OUTARR,
                       OUTVAR, NERR, NERRV, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of elements in the input output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         Array containing input image data.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If .TRUE., there is a variance array to process.
      }
      \sstsubsection{
         INVAR( EL ) = ? (Given)
      }{
         Array containing input variance data, when VAR = .TRUE..
      }
      \sstsubsection{
         BASE = DOUBLE PRECISION (Given)
      }{
         Base of exponential to be used.  It must be a positive number.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Write)
      }{
         Array containing results of processing the input data.
      }
      \sstsubsection{
         OUTVAR( EL ) = ? (Write)
      }{
         Array containing results of processing the input variance
         data, when VAR = .TRUE..
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         data array.
      }
      \sstsubsection{
         NERRV = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         variance array, when VAR = .TRUE..
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         arrays supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_FFRx
}{
   Reads free-format floating-point data from a string
}{
   \sstdescription{
      A buffer containing free-format values separated by spaces
      or commas is decoded and the numerical values extracted.
      It packages up the equivalent SLALIB calls (SLA\_FLOTIN and
      SLA\_DFLTIN) in order to obtain an array of values with a single
      line of code, and provides standard error handling.  See SUN/67
      for more details of the parsing technique and limitations.

      If the desired number of values cannot be decoded from the string
      an error status SAI\_\_ERROR is set.
   }
   \sstinvocation{
      CALL KPG1\_FFRx( STRING, NVAL, ORIGIN, VALUES, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STRING = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The string containing the values to be decoded and extracted.
      }
      \sstsubsection{
         NVAL = INTEGER (Given)
      }{
         The number of values to extract from the string.
      }
      \sstsubsection{
         ORIGIN = INTEGER (Given and Returned)
      }{
         On input this is the column or pointer in the string from
         where the decoding commences.  On output it is advanced to the
         next number or the end of the buffer if there are no more
         numbers.
      }
      \sstsubsection{
         VALUES( NVAL ) = ? (Returned)
      }{
         The decoded values.  These are initialised to zero before
         decoiding commences.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for floating-point numeric data types:
         replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
         array returned from the routine must have the data type specified.
         [routine\_notes]...
      }
   }
}
\sstroutine{
   KPG1\_FFRx
}{
   Reads free-format floating-point data from a string
}{
   \sstdescription{
      A buffer containing free-format values separated by spaces
      or commas is decoded and the numerical values extracted.
      It packages up the equivalent SLALIB calls (SLA\_FLOTIN and
      SLA\_DFLTIN) in order to obtain an array of values with a single
      line of code, and provides standard error handling.  See SUN/67
      for more details of the parsing technique and limitations.

      If the desired number of values cannot be decoded from the string
      an error status SAI\_\_ERROR is set.
   }
   \sstinvocation{
      CALL KPG1\_FFRx( STRING, NVAL, ORIGIN, VALUES, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STRING = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The string containing the values to be decoded and extracted.
      }
      \sstsubsection{
         NVAL = INTEGER (Given)
      }{
         The number of values to extract from the string.
      }
      \sstsubsection{
         ORIGIN = INTEGER (Given and Returned)
      }{
         On input this is the column or pointer in the string from
         where the decoding commences.  On output it is advanced to the
         next number or the end of the buffer if there are no more
         numbers.
      }
      \sstsubsection{
         VALUES( NVAL ) = ? (Returned)
      }{
         The decoded values.  These are initialised to zero before
         decoiding commences.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for floating-point numeric data types:
         replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
         array returned from the routine must have the data type specified.
         [routine\_notes]...
      }
   }
}
\sstroutine{
   KPG1\_FFTBD
}{
   Takes the inverse (Backward) FFT of a real image
}{
   \sstdescription{
      The input array should hold a Fourier transform of a purely real
      image, in Hermitian format as produced by KPG1\_FFTFD, or
      KPG1\_HMLTD.  The inverse FFT of this image is taken and returned
      in OUT.
   }
   \sstinvocation{
      CALL KPG1\_FFTBD( M, N, IN, WORK, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         M = INTEGER (Given)
      }{
         Number of columns in the input array.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of rows in the input array.
      }
      \sstsubsection{
         IN( M, N ) = DOUBLE PRECISION (Given)
      }{
         The input array (a Fourier transform of a real image, stored in
         Hermitian format).
      }
      \sstsubsection{
         WORK( $*$ ) = DOUBLE PRECISION (Given)
      }{
         Work space.  This must be at least ( 3$*$MAX( M, N ) $+$ 15 )
         elements long.
      }
      \sstsubsection{
         OUT( M, N ) = DOUBLE PRECISION (Returned)
      }{
         The inverse FFT of the input array (a purely real image).
         Note, the same array can be specified for both input and
         output, in which case the supplied values are overwitten.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_FFTBR
}{
   Takes the inverse (Backward) FFT of a real image
}{
   \sstdescription{
      The input array should hold a Fourier transform of a purely real
      image, in Hermitian format as produced by KPG1\_FFTFR, or
      KPG1\_HMLTR.  The inverse FFT of this image is taken and returned
      in OUT.
   }
   \sstinvocation{
      CALL KPG1\_FFTBR( M, N, IN, WORK, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         M = INTEGER (Given)
      }{
         Number of columns in the input array.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of rows in the input array.
      }
      \sstsubsection{
         IN( M, N ) = REAL (Given)
      }{
         The input array (a Fourier transform of a real image, stored in
         Hermitian format).
      }
      \sstsubsection{
         WORK( $*$ ) = REAL (Given)
      }{
         Work space.  This must be at least ( 3$*$MAX( M, N ) $+$ 15 )
         elements long.
      }
      \sstsubsection{
         OUT( M, N ) = REAL (Returned)
      }{
         The inverse FFT of the input array (a purely real image).
         Note, the same array can be specified for both input and
         output, in which case the supplied values are overwitten.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_FFTFD
}{
   Takes the forward FFT of a real image
}{
   \sstdescription{
      The Fourier transform of the input (purely real) image is taken
      and returned in OUT.  The returned FT is stored in Hermitian format,
      in which the real and imaginary parts of the FT are combined into
      a single array. The FT can be inverted using KPG1\_FFTBD, and two
      Hermitian FTs can be multipled together using routine KPG1\_HMLTD.
   }
   \sstinvocation{
      CALL KPG1\_FFTFD( M, N, IN, WORK, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         M = INTEGER (Given)
      }{
         Number of columns in the input image.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of rows in the input image.
      }
      \sstsubsection{
         IN( M, N ) = DOUBLE PRECISION (Given)
      }{
         The input image.
      }
      \sstsubsection{
         WORK( $*$ ) = DOUBLE PRECISION (Given)
      }{
         Work space.  This must be at least ( 3$*$MAX( M, N ) $+$ 15 )
         elements long.
      }
      \sstsubsection{
         OUT( M, N ) = DOUBLE PRECISION (Returned)
      }{
         The FFT in Hermitian form.  Note, the same array can be used
         for both input and output, in which case the supplied values
         will be over-written.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_FFTFR
}{
   Takes the forward FFT of a real image
}{
   \sstdescription{
      The Fourier transform of the input (purely real) image is taken
      and returned in OUT.  The returned FT is stored in Hermitian
      format, in which the real and imaginary parts of the FT are
      combined into a single array.  The FT can be inverted using
      KPG1\_FFTBR, and two Hermitian FTs can be multipled together using
      routine KPG1\_HMLTR.
   }
   \sstinvocation{
      CALL KPG1\_FFTFR( M, N, IN, WORK, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         M = INTEGER (Given)
      }{
         Number of columns in the input image.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of rows in the input image.
      }
      \sstsubsection{
         IN( M, N ) = REAL (Given)
      }{
         The input image.
      }
      \sstsubsection{
         WORK( $*$ ) = REAL (Given)
      }{
         Work space. This must be at least ( 3$*$MAX( M, N ) $+$ 15 )
         elements long.
      }
      \sstsubsection{
         OUT( M, N ) = REAL (Returned)
      }{
         The FFT in Hermitian form.  Note, the same array can be used
         for both input and output, in which case the supplied values
         will be over-written.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_FHDAT
}{
   Converts the NDF history date into a more-pleasing format
}{
   \sstdescription{
      This makes a few minor modifications to the date string obtained
      from NDF history records to make it more like UNIX and
      astronomical style.  Specifically two hyphens around the month are
      replaced by spaces, and the second and third letters of the month
      are made lowercase.
   }
   \sstinvocation{
      CALL KPG1\_FHDAT( DATE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DATE = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         On input the NDF format for a date and time, namely
         YYYY-MMM-DD HH:MM:SS.SSS.  On exit, the KAPPA format for a
         date and time, namely YYYY Mmm DD HH:MM:SS.SSS
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_FILLx
}{
   Sets all elements in a vectorised array to a specified value
}{
   \sstdescription{
      This routine sets all the pixels in a 1-dimensional array to a
      specified value.
   }
   \sstinvocation{
      CALL KPG1\_FILLB( VALUE, EL, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VALUE = ? (Given)
      }{
         Value to be substituted in every pixel.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the array to be filled with a constant.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Returned)
      }{
         The output array containing a single value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B, or UB as appropriate.  The
         VALUE and ARRAY arguments must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_FILLx
}{
   Sets all elements in a vectorised array to a specified value
}{
   \sstdescription{
      This routine sets all the pixels in a 1-dimensional array to a
      specified value.
   }
   \sstinvocation{
      CALL KPG1\_FILLD( VALUE, EL, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VALUE = ? (Given)
      }{
         Value to be substituted in every pixel.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the array to be filled with a constant.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Returned)
      }{
         The output array containing a single value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B, or UB as appropriate.  The
         VALUE and ARRAY arguments must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_FILLx
}{
   Sets all elements in a vectorised array to a specified value
}{
   \sstdescription{
      This routine sets all the pixels in a 1-dimensional array to a
      specified value.
   }
   \sstinvocation{
      CALL KPG1\_FILLI( VALUE, EL, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VALUE = ? (Given)
      }{
         Value to be substituted in every pixel.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the array to be filled with a constant.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Returned)
      }{
         The output array containing a single value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B, or UB as appropriate.  The
         VALUE and ARRAY arguments must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_FILLx
}{
   Sets all elements in a vectorised array to a specified value
}{
   \sstdescription{
      This routine sets all the pixels in a 1-dimensional array to a
      specified value.
   }
   \sstinvocation{
      CALL KPG1\_FILLR( VALUE, EL, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VALUE = ? (Given)
      }{
         Value to be substituted in every pixel.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the array to be filled with a constant.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Returned)
      }{
         The output array containing a single value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B, or UB as appropriate.  The
         VALUE and ARRAY arguments must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_FILLx
}{
   Sets all elements in a vectorised array to a specified value
}{
   \sstdescription{
      This routine sets all the pixels in a 1-dimensional array to a
      specified value.
   }
   \sstinvocation{
      CALL KPG1\_FILLUB( VALUE, EL, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VALUE = ? (Given)
      }{
         Value to be substituted in every pixel.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the array to be filled with a constant.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Returned)
      }{
         The output array containing a single value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B, or UB as appropriate.  The
         VALUE and ARRAY arguments must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_FILLx
}{
   Sets all elements in a vectorised array to a specified value
}{
   \sstdescription{
      This routine sets all the pixels in a 1-dimensional array to a
      specified value.
   }
   \sstinvocation{
      CALL KPG1\_FILLUW( VALUE, EL, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VALUE = ? (Given)
      }{
         Value to be substituted in every pixel.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the array to be filled with a constant.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Returned)
      }{
         The output array containing a single value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B, or UB as appropriate.  The
         VALUE and ARRAY arguments must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_FILLx
}{
   Sets all elements in a vectorised array to a specified value
}{
   \sstdescription{
      This routine sets all the pixels in a 1-dimensional array to a
      specified value.
   }
   \sstinvocation{
      CALL KPG1\_FILLW( VALUE, EL, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VALUE = ? (Given)
      }{
         Value to be substituted in every pixel.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the array to be filled with a constant.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Returned)
      }{
         The output array containing a single value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B, or UB as appropriate.  The
         VALUE and ARRAY arguments must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_FIT1D
}{
   Fit a least squares straight line to supplied data
}{
   \sstdescription{
      A straight line is fitted to the data supplied in X and Y, using
      the least squares criterion. The returned values of M and C are
      the gradient and intercept of the fit, so that y = M.x $+$ C. The
      RMS residual of the Y data from the fit is returned in RMS.

      An error is reported if there are less than two good data values
      in Y, or if the X values cover a range of zero.
   }
   \sstinvocation{
      CALL KPG1\_FIT1D( LBND, UBND, Y, X, M, C, RMS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The lower bound of the X and Y arrays.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The upper bound of the X and Y arrays.
      }
      \sstsubsection{
         Y( LBND : UBND ) = DOUBLE PRECISION (Given)
      }{
         The Y data values. Any bad values are ignored.
      }
      \sstsubsection{
         X( LBND : UBND ) = DOUBLE PRECISION (Given)
      }{
         The X positions corresponding to each Y data value.
      }
      \sstsubsection{
         M = DOUBLE PRECISION (Returned)
      }{
         The gradient.
      }
      \sstsubsection{
         C = DOUBLE PRECISION (Returned)
      }{
         The intercept.
      }
      \sstsubsection{
         RMS = DOUBLE PRECISION (Returned)
      }{
         The RMS residual between the Y values and the fit.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_FLASx
}{
   Flashes image into a cell array
}{
   \sstdescription{
      This subroutine converts a BYTE 2-d array into an
      integer cell array without scaling it.  However, the cell array
      is computed by modulo arithmetic between the lowest and highest
      colour indices, or the complement of this should a negative
      scaling be required. The image is normally inverted for output on
      an image display, though this can be overridden.
   }
   \sstinvocation{
       CALL KPG1\_FLASx( BAD, DIM1, DIM2, INARR, LOWPEN, HIPEN, INVERT,
      :                 POSTIV, OUTARR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true bad pixels will be processed.  This should not be set
         to false unless the input array contains no bad pixels.
      }
      \sstsubsection{
         DIM1 = INTEGER (Given)
      }{
         The first dimension of the 2-d array.
      }
      \sstsubsection{
         DIM2 = INTEGER (Given)
      }{
         The second dimension of the 2-d array.
      }
      \sstsubsection{
         INARR( DIM1, DIM2 ) = ? (Given)
      }{
         The array of data to be flashed.
      }
      \sstsubsection{
         LOWPEN = INTEGER (Given)
      }{
         The lowest colour index to be used in case smaller values have
         been reserved for annotation.
      }
      \sstsubsection{
         HIPEN = INTEGER (Given)
      }{
         The highest colour index to be used.  Normally this is the
         number of greyscale intensities available on the chosen device.
      }
      \sstsubsection{
         INVERT = LOGICAL (Given)
      }{
         True if the image is to be inverted for display.
      }
      \sstsubsection{
         POSTIV = LOGICAL (Given)
      }{
         True if the display of the image is to be positive.
      }
      \sstsubsection{
         OUTARR( DIM1, DIM2 ) = INTEGER (Returned)
      }{
         The cell array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Value of the status on entering this subroutine.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for five numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, or W as appropriate.  The array
         supplied to the routine must have the data type specified.

         \sstitem
         The array is normally inverted so that the image will appear
         the correct way round when displayed as the GKS routine
         to display the image inverts it.
      }
   }
}
\sstroutine{
   KPG1\_FLASx
}{
   Flashes image into a cell array
}{
   \sstdescription{
      This subroutine converts a DOUBLE PRECISION 2-d array into an
      integer cell array without scaling it.  However, the cell array
      is computed by modulo arithmetic between the lowest and highest
      colour indices, or the complement of this should a negative
      scaling be required. The image is normally inverted for output on
      an image display, though this can be overridden.
   }
   \sstinvocation{
       CALL KPG1\_FLASx( BAD, DIM1, DIM2, INARR, LOWPEN, HIPEN, INVERT,
      :                 POSTIV, OUTARR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true bad pixels will be processed.  This should not be set
         to false unless the input array contains no bad pixels.
      }
      \sstsubsection{
         DIM1 = INTEGER (Given)
      }{
         The first dimension of the 2-d array.
      }
      \sstsubsection{
         DIM2 = INTEGER (Given)
      }{
         The second dimension of the 2-d array.
      }
      \sstsubsection{
         INARR( DIM1, DIM2 ) = ? (Given)
      }{
         The array of data to be flashed.
      }
      \sstsubsection{
         LOWPEN = INTEGER (Given)
      }{
         The lowest colour index to be used in case smaller values have
         been reserved for annotation.
      }
      \sstsubsection{
         HIPEN = INTEGER (Given)
      }{
         The highest colour index to be used.  Normally this is the
         number of greyscale intensities available on the chosen device.
      }
      \sstsubsection{
         INVERT = LOGICAL (Given)
      }{
         True if the image is to be inverted for display.
      }
      \sstsubsection{
         POSTIV = LOGICAL (Given)
      }{
         True if the display of the image is to be positive.
      }
      \sstsubsection{
         OUTARR( DIM1, DIM2 ) = INTEGER (Returned)
      }{
         The cell array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Value of the status on entering this subroutine.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for five numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, or W as appropriate.  The array
         supplied to the routine must have the data type specified.

         \sstitem
         The array is normally inverted so that the image will appear
         the correct way round when displayed as the GKS routine
         to display the image inverts it.
      }
   }
}
\sstroutine{
   KPG1\_FLASx
}{
   Flashes image into a cell array
}{
   \sstdescription{
      This subroutine converts a INTEGER 2-d array into an
      integer cell array without scaling it.  However, the cell array
      is computed by modulo arithmetic between the lowest and highest
      colour indices, or the complement of this should a negative
      scaling be required. The image is normally inverted for output on
      an image display, though this can be overridden.
   }
   \sstinvocation{
       CALL KPG1\_FLASx( BAD, DIM1, DIM2, INARR, LOWPEN, HIPEN, INVERT,
      :                 POSTIV, OUTARR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true bad pixels will be processed.  This should not be set
         to false unless the input array contains no bad pixels.
      }
      \sstsubsection{
         DIM1 = INTEGER (Given)
      }{
         The first dimension of the 2-d array.
      }
      \sstsubsection{
         DIM2 = INTEGER (Given)
      }{
         The second dimension of the 2-d array.
      }
      \sstsubsection{
         INARR( DIM1, DIM2 ) = ? (Given)
      }{
         The array of data to be flashed.
      }
      \sstsubsection{
         LOWPEN = INTEGER (Given)
      }{
         The lowest colour index to be used in case smaller values have
         been reserved for annotation.
      }
      \sstsubsection{
         HIPEN = INTEGER (Given)
      }{
         The highest colour index to be used.  Normally this is the
         number of greyscale intensities available on the chosen device.
      }
      \sstsubsection{
         INVERT = LOGICAL (Given)
      }{
         True if the image is to be inverted for display.
      }
      \sstsubsection{
         POSTIV = LOGICAL (Given)
      }{
         True if the display of the image is to be positive.
      }
      \sstsubsection{
         OUTARR( DIM1, DIM2 ) = INTEGER (Returned)
      }{
         The cell array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Value of the status on entering this subroutine.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for five numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, or W as appropriate.  The array
         supplied to the routine must have the data type specified.

         \sstitem
         The array is normally inverted so that the image will appear
         the correct way round when displayed as the GKS routine
         to display the image inverts it.
      }
   }
}
\sstroutine{
   KPG1\_FLASx
}{
   Flashes image into a cell array
}{
   \sstdescription{
      This subroutine converts a REAL 2-d array into an
      integer cell array without scaling it.  However, the cell array
      is computed by modulo arithmetic between the lowest and highest
      colour indices, or the complement of this should a negative
      scaling be required. The image is normally inverted for output on
      an image display, though this can be overridden.
   }
   \sstinvocation{
       CALL KPG1\_FLASx( BAD, DIM1, DIM2, INARR, LOWPEN, HIPEN, INVERT,
      :                 POSTIV, OUTARR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true bad pixels will be processed.  This should not be set
         to false unless the input array contains no bad pixels.
      }
      \sstsubsection{
         DIM1 = INTEGER (Given)
      }{
         The first dimension of the 2-d array.
      }
      \sstsubsection{
         DIM2 = INTEGER (Given)
      }{
         The second dimension of the 2-d array.
      }
      \sstsubsection{
         INARR( DIM1, DIM2 ) = ? (Given)
      }{
         The array of data to be flashed.
      }
      \sstsubsection{
         LOWPEN = INTEGER (Given)
      }{
         The lowest colour index to be used in case smaller values have
         been reserved for annotation.
      }
      \sstsubsection{
         HIPEN = INTEGER (Given)
      }{
         The highest colour index to be used.  Normally this is the
         number of greyscale intensities available on the chosen device.
      }
      \sstsubsection{
         INVERT = LOGICAL (Given)
      }{
         True if the image is to be inverted for display.
      }
      \sstsubsection{
         POSTIV = LOGICAL (Given)
      }{
         True if the display of the image is to be positive.
      }
      \sstsubsection{
         OUTARR( DIM1, DIM2 ) = INTEGER (Returned)
      }{
         The cell array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Value of the status on entering this subroutine.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for five numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, or W as appropriate.  The array
         supplied to the routine must have the data type specified.

         \sstitem
         The array is normally inverted so that the image will appear
         the correct way round when displayed as the GKS routine
         to display the image inverts it.
      }
   }
}
\sstroutine{
   KPG1\_FLASx
}{
   Flashes image into a cell array
}{
   \sstdescription{
      This subroutine converts a WORD 2-d array into an
      integer cell array without scaling it.  However, the cell array
      is computed by modulo arithmetic between the lowest and highest
      colour indices, or the complement of this should a negative
      scaling be required. The image is normally inverted for output on
      an image display, though this can be overridden.
   }
   \sstinvocation{
       CALL KPG1\_FLASx( BAD, DIM1, DIM2, INARR, LOWPEN, HIPEN, INVERT,
      :                 POSTIV, OUTARR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true bad pixels will be processed.  This should not be set
         to false unless the input array contains no bad pixels.
      }
      \sstsubsection{
         DIM1 = INTEGER (Given)
      }{
         The first dimension of the 2-d array.
      }
      \sstsubsection{
         DIM2 = INTEGER (Given)
      }{
         The second dimension of the 2-d array.
      }
      \sstsubsection{
         INARR( DIM1, DIM2 ) = ? (Given)
      }{
         The array of data to be flashed.
      }
      \sstsubsection{
         LOWPEN = INTEGER (Given)
      }{
         The lowest colour index to be used in case smaller values have
         been reserved for annotation.
      }
      \sstsubsection{
         HIPEN = INTEGER (Given)
      }{
         The highest colour index to be used.  Normally this is the
         number of greyscale intensities available on the chosen device.
      }
      \sstsubsection{
         INVERT = LOGICAL (Given)
      }{
         True if the image is to be inverted for display.
      }
      \sstsubsection{
         POSTIV = LOGICAL (Given)
      }{
         True if the display of the image is to be positive.
      }
      \sstsubsection{
         OUTARR( DIM1, DIM2 ) = INTEGER (Returned)
      }{
         The cell array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Value of the status on entering this subroutine.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for five numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, or W as appropriate.  The array
         supplied to the routine must have the data type specified.

         \sstitem
         The array is normally inverted so that the image will appear
         the correct way round when displayed as the GKS routine
         to display the image inverts it.
      }
   }
}
\sstroutine{
   KPG1\_FLCOx
}{
   Obtains a list of co-ordinates from a text file
}{
   \sstdescription{
      This routine obtains a list of n-dimensional co-ordinates for a
      series of positions.  The text file should contain on each line
      a set of free-format co-ordinates that defines a position, except
      for comment lines denoted by a hash or shriek in column 1.
      The file is opened using the supplied parameter.  A pass is made
      through the file to see how many records it contains.  Dynamic
      workspace is reserved to contain the co-ordinates, and the file
      is then rewound.  Another pass is made through the file to read
      the co-ordinate values which are then stored in the workspace.
      Pointers to the workspace are returned.  This workspace should be
      released by calling PSX\_FREE when it is no longer needed.
   }
   \sstinvocation{
      CALL KPG1\_FLCOx( PNAME, NDIM, POSCOD, NPOINT, IPCO, LBND, UBND,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the parameter with which to associate the text file.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of co-ordinate dimensions to read from the text
         file.
      }
      \sstsubsection{
         POSCOD( NDIM ) = INTEGER (Given)
      }{
         The column numbers of the co-ordinate information in order
         x, y, z, etc.  These must be positive.
      }
      \sstsubsection{
         NPOINT = INTEGER (Returned)
      }{
         The number of co-ordinate sets specified in the text file.
      }
      \sstsubsection{
         IPCO = INTEGER (Returned)
      }{
         A pointer to workspace of type \_DOUBLE and size NDIM by NPOINT
         holding the NDIM co-ordinates of each point.
      }
      \sstsubsection{
         LBND( NDIM ) = ? (Returned)
      }{
         The lower bounds of the input data, i.e. the minimum value for
         each co-ordinate.
      }
      \sstsubsection{
         UBND( NDIM ) = ? (Returned)
      }{
         The upper bounds of the input data, i.e. the maximum value for
         each co-ordinate.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the real or double-precision
         data types: replace {\tt "}x{\tt "} in the routine name by R or D
         respectively, as appropriate.  The returned co-ordinate array
         will have this type, and the supplied bounds arrays should also
         have the specified data type.

         \sstitem
         The number of points read from the file is reported at the
         normal reporting level.
      }
   }
}
\sstroutine{
   KPG1\_FLCOx
}{
   Obtains a list of co-ordinates from a text file
}{
   \sstdescription{
      This routine obtains a list of n-dimensional co-ordinates for a
      series of positions.  The text file should contain on each line
      a set of free-format co-ordinates that defines a position, except
      for comment lines denoted by a hash or shriek in column 1.
      The file is opened using the supplied parameter.  A pass is made
      through the file to see how many records it contains.  Dynamic
      workspace is reserved to contain the co-ordinates, and the file
      is then rewound.  Another pass is made through the file to read
      the co-ordinate values which are then stored in the workspace.
      Pointers to the workspace are returned.  This workspace should be
      released by calling PSX\_FREE when it is no longer needed.
   }
   \sstinvocation{
      CALL KPG1\_FLCOx( PNAME, NDIM, POSCOD, NPOINT, IPCO, LBND, UBND,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the parameter with which to associate the text file.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of co-ordinate dimensions to read from the text
         file.
      }
      \sstsubsection{
         POSCOD( NDIM ) = INTEGER (Given)
      }{
         The column numbers of the co-ordinate information in order
         x, y, z, etc.  These must be positive.
      }
      \sstsubsection{
         NPOINT = INTEGER (Returned)
      }{
         The number of co-ordinate sets specified in the text file.
      }
      \sstsubsection{
         IPCO = INTEGER (Returned)
      }{
         A pointer to workspace of type \_REAL and size NDIM by NPOINT
         holding the NDIM co-ordinates of each point.
      }
      \sstsubsection{
         LBND( NDIM ) = ? (Returned)
      }{
         The lower bounds of the input data, i.e. the minimum value for
         each co-ordinate.
      }
      \sstsubsection{
         UBND( NDIM ) = ? (Returned)
      }{
         The upper bounds of the input data, i.e. the maximum value for
         each co-ordinate.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the real or double-precision
         data types: replace {\tt "}x{\tt "} in the routine name by R or D
         respectively, as appropriate.  The returned co-ordinate array
         will have this type, and the supplied bounds arrays should also
         have the specified data type.

         \sstitem
         The number of points read from the file is reported at the
         normal reporting level.
      }
   }
}
\sstroutine{
   KPG1\_FLIPx
}{
   Reverse the pixels in an N-dimensional array along a specified
   dimension
}{
   \sstdescription{
      This routine reverses the order of the pixels in an N-dimensional
      array along a specified dimension. The pixel values are
      unchanged. The array may have any number of dimensions.
   }
   \sstinvocation{
      CALL KPG1\_FLIPx( NDIM, DIM, DATIN, IDIM, DATOUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of array dimensions.
      }
      \sstsubsection{
         DIM( NDIM ) = INTEGER (Given)
      }{
         Array of dimension sizes for each array dimension.
      }
      \sstsubsection{
         DATIN( $*$ ) = ? (Given)
      }{
         The input NDIM-dimensional array.
      }
      \sstsubsection{
         IDIM = INTEGER (Given)
      }{
         Number of the array dimension along which the pixel values are
         to be reversed (in the range 1 to NDIM).
      }
      \sstsubsection{
         DATOUT( $*$ ) = ? (Returned)
      }{
         Output array, with the pixels reversed.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each standard numeric type; replace {\tt "}x{\tt "}
         in the array name by D, R, I, W, UW, B or UB as appropriate. The
         data type of the arrays supplied must match the particular
         routine used.
      }
   }
}
\sstroutine{
   KPG1\_FLIPx
}{
   Reverse the pixels in an N-dimensional array along a specified
   dimension
}{
   \sstdescription{
      This routine reverses the order of the pixels in an N-dimensional
      array along a specified dimension. The pixel values are
      unchanged. The array may have any number of dimensions.
   }
   \sstinvocation{
      CALL KPG1\_FLIPx( NDIM, DIM, DATIN, IDIM, DATOUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of array dimensions.
      }
      \sstsubsection{
         DIM( NDIM ) = INTEGER (Given)
      }{
         Array of dimension sizes for each array dimension.
      }
      \sstsubsection{
         DATIN( $*$ ) = ? (Given)
      }{
         The input NDIM-dimensional array.
      }
      \sstsubsection{
         IDIM = INTEGER (Given)
      }{
         Number of the array dimension along which the pixel values are
         to be reversed (in the range 1 to NDIM).
      }
      \sstsubsection{
         DATOUT( $*$ ) = ? (Returned)
      }{
         Output array, with the pixels reversed.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each standard numeric type; replace {\tt "}x{\tt "}
         in the array name by D, R, I, W, UW, B or UB as appropriate. The
         data type of the arrays supplied must match the particular
         routine used.
      }
   }
}
\sstroutine{
   KPG1\_FLIPx
}{
   Reverse the pixels in an N-dimensional array along a specified
   dimension
}{
   \sstdescription{
      This routine reverses the order of the pixels in an N-dimensional
      array along a specified dimension. The pixel values are
      unchanged. The array may have any number of dimensions.
   }
   \sstinvocation{
      CALL KPG1\_FLIPx( NDIM, DIM, DATIN, IDIM, DATOUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of array dimensions.
      }
      \sstsubsection{
         DIM( NDIM ) = INTEGER (Given)
      }{
         Array of dimension sizes for each array dimension.
      }
      \sstsubsection{
         DATIN( $*$ ) = ? (Given)
      }{
         The input NDIM-dimensional array.
      }
      \sstsubsection{
         IDIM = INTEGER (Given)
      }{
         Number of the array dimension along which the pixel values are
         to be reversed (in the range 1 to NDIM).
      }
      \sstsubsection{
         DATOUT( $*$ ) = ? (Returned)
      }{
         Output array, with the pixels reversed.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each standard numeric type; replace {\tt "}x{\tt "}
         in the array name by D, R, I, W, UW, B or UB as appropriate. The
         data type of the arrays supplied must match the particular
         routine used.
      }
   }
}
\sstroutine{
   KPG1\_FLIPx
}{
   Reverse the pixels in an N-dimensional array along a specified
   dimension
}{
   \sstdescription{
      This routine reverses the order of the pixels in an N-dimensional
      array along a specified dimension. The pixel values are
      unchanged. The array may have any number of dimensions.
   }
   \sstinvocation{
      CALL KPG1\_FLIPx( NDIM, DIM, DATIN, IDIM, DATOUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of array dimensions.
      }
      \sstsubsection{
         DIM( NDIM ) = INTEGER (Given)
      }{
         Array of dimension sizes for each array dimension.
      }
      \sstsubsection{
         DATIN( $*$ ) = ? (Given)
      }{
         The input NDIM-dimensional array.
      }
      \sstsubsection{
         IDIM = INTEGER (Given)
      }{
         Number of the array dimension along which the pixel values are
         to be reversed (in the range 1 to NDIM).
      }
      \sstsubsection{
         DATOUT( $*$ ) = ? (Returned)
      }{
         Output array, with the pixels reversed.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each standard numeric type; replace {\tt "}x{\tt "}
         in the array name by D, R, I, W, UW, B or UB as appropriate. The
         data type of the arrays supplied must match the particular
         routine used.
      }
   }
}
\sstroutine{
   KPG1\_FLIPx
}{
   Reverse the pixels in an N-dimensional array along a specified
   dimension
}{
   \sstdescription{
      This routine reverses the order of the pixels in an N-dimensional
      array along a specified dimension. The pixel values are
      unchanged. The array may have any number of dimensions.
   }
   \sstinvocation{
      CALL KPG1\_FLIPx( NDIM, DIM, DATIN, IDIM, DATOUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of array dimensions.
      }
      \sstsubsection{
         DIM( NDIM ) = INTEGER (Given)
      }{
         Array of dimension sizes for each array dimension.
      }
      \sstsubsection{
         DATIN( $*$ ) = ? (Given)
      }{
         The input NDIM-dimensional array.
      }
      \sstsubsection{
         IDIM = INTEGER (Given)
      }{
         Number of the array dimension along which the pixel values are
         to be reversed (in the range 1 to NDIM).
      }
      \sstsubsection{
         DATOUT( $*$ ) = ? (Returned)
      }{
         Output array, with the pixels reversed.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each standard numeric type; replace {\tt "}x{\tt "}
         in the array name by D, R, I, W, UW, B or UB as appropriate. The
         data type of the arrays supplied must match the particular
         routine used.
      }
   }
}
\sstroutine{
   KPG1\_FLIPx
}{
   Reverse the pixels in an N-dimensional array along a specified
   dimension
}{
   \sstdescription{
      This routine reverses the order of the pixels in an N-dimensional
      array along a specified dimension. The pixel values are
      unchanged. The array may have any number of dimensions.
   }
   \sstinvocation{
      CALL KPG1\_FLIPx( NDIM, DIM, DATIN, IDIM, DATOUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of array dimensions.
      }
      \sstsubsection{
         DIM( NDIM ) = INTEGER (Given)
      }{
         Array of dimension sizes for each array dimension.
      }
      \sstsubsection{
         DATIN( $*$ ) = ? (Given)
      }{
         The input NDIM-dimensional array.
      }
      \sstsubsection{
         IDIM = INTEGER (Given)
      }{
         Number of the array dimension along which the pixel values are
         to be reversed (in the range 1 to NDIM).
      }
      \sstsubsection{
         DATOUT( $*$ ) = ? (Returned)
      }{
         Output array, with the pixels reversed.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each standard numeric type; replace {\tt "}x{\tt "}
         in the array name by D, R, I, W, UW, B or UB as appropriate. The
         data type of the arrays supplied must match the particular
         routine used.
      }
   }
}
\sstroutine{
   KPG1\_FLIPx
}{
   Reverse the pixels in an N-dimensional array along a specified
   dimension
}{
   \sstdescription{
      This routine reverses the order of the pixels in an N-dimensional
      array along a specified dimension. The pixel values are
      unchanged. The array may have any number of dimensions.
   }
   \sstinvocation{
      CALL KPG1\_FLIPx( NDIM, DIM, DATIN, IDIM, DATOUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of array dimensions.
      }
      \sstsubsection{
         DIM( NDIM ) = INTEGER (Given)
      }{
         Array of dimension sizes for each array dimension.
      }
      \sstsubsection{
         DATIN( $*$ ) = ? (Given)
      }{
         The input NDIM-dimensional array.
      }
      \sstsubsection{
         IDIM = INTEGER (Given)
      }{
         Number of the array dimension along which the pixel values are
         to be reversed (in the range 1 to NDIM).
      }
      \sstsubsection{
         DATOUT( $*$ ) = ? (Returned)
      }{
         Output array, with the pixels reversed.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each standard numeric type; replace {\tt "}x{\tt "}
         in the array name by D, R, I, W, UW, B or UB as appropriate. The
         data type of the arrays supplied must match the particular
         routine used.
      }
   }
}
\sstroutine{
   KPG1\_FLOOR
}{
   Return the largest integer smaller than or equal to a supplied value
}{
   \sstdescription{
      This routine returns the largest integer smaller than or equal to
      a supplied value.
   }
   \sstinvocation{
      RESULT = KPG1\_FLOOR( VALUE )
   }
   \sstarguments{
      \sstsubsection{
         VALUE = REAL (Given)
      }{
         The value.
      }
   }
   \sstdiytopic{
      Function Value
   }{
      KPG1\_CEIL = INTEGER
         The largest integer smaller than or equal to the supplied value.
   }
}
\sstroutine{
   KPG1\_FLPTH
}{
   Get the full path to a file given relative to a specified root directory
}{
   \sstdescription{
      This routine returns the full path to a file specified relative to
      the \$ROOT directory. The supplied file spec should be a UNIX-style
      file spec., but the returned full file path will be translated into
      the VMS equivalent if required.
   }
   \sstinvocation{
      CALL KPG1\_FLPTH( INSTR, OUTSTR, NC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         ROOT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         An environment variable which is to be translated to get the
         full path to the root directory. Eg, HOME, KAPPA\_DIR, etc. If a
         blank value is supplied, then the current working directory is
         used (\$PWD on Unix and \$PATH on VMS).
      }
      \sstsubsection{
         INSTR = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The file spec relative to the root directory. E.g. fred.dat,
         adam/display.sdf, etc.
      }
      \sstsubsection{
         OUTSTR = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The full file path. E.g. /home/dsb/fred.dat (DISK\$USER:[DSB]FRED.DAT
         on VMS), or /home/dsb/adam/display.sdf (DISK\$USER:[DSB.ADAM]DISPLAY.SDF on VMS).
         Returned blank if an error occurs.
      }
      \sstsubsection{
         NC = INTEGER (Returned)
      }{
         Number of characters used in OUTSTR. Returned equal to 0 if an
         error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_FRACx
}{
   Finds values corresponding to specified fractions of an array{\tt '}s
   ordered distribution
}{
   \sstdescription{
      This routine finds the values at defined fractions of an array{\tt '}s
      ordered distribution, such as percentiles.  Thus to find the
      upper-quartile value, the fraction would be 0.75.  Since it uses
      an histogram technique rather than sorting the whole array, for
      efficiency, the result may not be exactly correct.  However,
      the histogram has a large number of bins (10000), combined with
      linear interpolation between bins in the routine reduce the error.
      The histogram extends between the minimum and maximum data values.

      The routine also has an iterative method, whereby outliers, which
      compress the vast majority of data values into a few bins, are
      excluded from the histogram.  Clipping occurs from both ends.
      A contiguous series of bins are removed until the largest
      or smallest fraction is encountered.  Where the rejection of bins
      end, defines new limits, encompassing the vast majority of values.
      A new histogram is calculated using these revised limits.  The
      excluded outliers are still counted in the evaluation of the
      fractions.  The criterion for iteration may need tuning in the
      light of experience.  At present it is when there are fewer than
      4\% non-zero bins.

      The iteration can still fail to find accurate fractional values if
      smallest and largest fractions are close to 0 or 1 and correspond
      to extreme outliers.  The routine recognises this state and
      determines the values for each outlier fraction separately, and
      then uses the next interior fraction as the limit.  Then the
      routine proceeds with the clipping described above.
   }
   \sstinvocation{
      CALL KPG1\_FRACx( EL, ARRAY, NFRAC, FRAC, BAD, CLFRAC, VALUES,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements of the array to be analysed.
      }
      \sstsubsection{
         ARRAY( EL ) = BYTE (Given)
      }{
         The array for which the chosen statistics are required.
      }
      \sstsubsection{
         NFRAC = INTEGER (Given)
      }{
         Number of fractional positions.
      }
      \sstsubsection{
         FRAC( NFRAC ) = REAL (Given and Returned)
      }{
         Fractional positions in the histogram in the range 0.0--1.0.
         On exit they are arranged into ascending order.
      }
      \sstsubsection{
         BAD = LOGICAL (Given and Returned)
      }{
         True when bad pixels may be present.
      }
      \sstsubsection{
         CLFRAC( NFRAC ) = REAL (Returned)
      }{
         The clipped fractional positions in the histogram in the range
         0.0--1.0 after iterative clipping of the histogram.
      }
      \sstsubsection{
         VALUES( NFRAC ) = DOUBLE PRECISION (Returned)
      }{
         Values corresponding to the ordered fractional positions in
         the histogram.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numerical data type: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, W, UB or UW as appropriate.  The
         array supplied to the routine must have the data type specified.

         \sstitem
         For integer types the number of bins does not exceed the
         data range.  The number of bins is reduced as clipping occurs.
      }
   }
   \sstdiytopic{
      Deficiencies
   }{
      \sstitemlist{

         \sstitem
         The iterative algorithm is not especially efficient; for data
         with a very wide range the iterations can be numerous.  A
         sigma-clipping approach to remove the outliers might be better.

         \sstitem
         The adjustment of the limiting fractions is done for each
         limit separately, thus involving a further pass through the
         array.  At present it finds the more extreme outlier first by
         comparing the bin number of the limits with respect to the mean
         bin number.
      }
   }
}
\sstroutine{
   KPG1\_FRACx
}{
   Finds values corresponding to specified fractions of an array{\tt '}s
   ordered distribution
}{
   \sstdescription{
      This routine finds the values at defined fractions of an array{\tt '}s
      ordered distribution, such as percentiles.  Thus to find the
      upper-quartile value, the fraction would be 0.75.  Since it uses
      an histogram technique rather than sorting the whole array, for
      efficiency, the result may not be exactly correct.  However,
      the histogram has a large number of bins (10000), combined with
      linear interpolation between bins in the routine reduce the error.
      The histogram extends between the minimum and maximum data values.

      The routine also has an iterative method, whereby outliers, which
      compress the vast majority of data values into a few bins, are
      excluded from the histogram.  Clipping occurs from both ends.
      A contiguous series of bins are removed until the largest
      or smallest fraction is encountered.  Where the rejection of bins
      end, defines new limits, encompassing the vast majority of values.
      A new histogram is calculated using these revised limits.  The
      excluded outliers are still counted in the evaluation of the
      fractions.  The criterion for iteration may need tuning in the
      light of experience.  At present it is when there are fewer than
      4\% non-zero bins.

      The iteration can still fail to find accurate fractional values if
      smallest and largest fractions are close to 0 or 1 and correspond
      to extreme outliers.  The routine recognises this state and
      determines the values for each outlier fraction separately, and
      then uses the next interior fraction as the limit.  Then the
      routine proceeds with the clipping described above.
   }
   \sstinvocation{
      CALL KPG1\_FRACx( EL, ARRAY, NFRAC, FRAC, BAD, CLFRAC, VALUES,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements of the array to be analysed.
      }
      \sstsubsection{
         ARRAY( EL ) = DOUBLE PRECISION (Given)
      }{
         The array for which the chosen statistics are required.
      }
      \sstsubsection{
         NFRAC = INTEGER (Given)
      }{
         Number of fractional positions.
      }
      \sstsubsection{
         FRAC( NFRAC ) = REAL (Given and Returned)
      }{
         Fractional positions in the histogram in the range 0.0--1.0.
         On exit they are arranged into ascending order.
      }
      \sstsubsection{
         BAD = LOGICAL (Given and Returned)
      }{
         True when bad pixels may be present.
      }
      \sstsubsection{
         CLFRAC( NFRAC ) = REAL (Returned)
      }{
         The clipped fractional positions in the histogram in the range
         0.0--1.0 after iterative clipping of the histogram.
      }
      \sstsubsection{
         VALUES( NFRAC ) = DOUBLE PRECISION (Returned)
      }{
         Values corresponding to the ordered fractional positions in
         the histogram.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numerical data type: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, W, UB or UW as appropriate.  The
         array supplied to the routine must have the data type specified.

         \sstitem
         For integer types the number of bins does not exceed the
         data range.  The number of bins is reduced as clipping occurs.
      }
   }
   \sstdiytopic{
      Deficiencies
   }{
      \sstitemlist{

         \sstitem
         The iterative algorithm is not especially efficient; for data
         with a very wide range the iterations can be numerous.  A
         sigma-clipping approach to remove the outliers might be better.

         \sstitem
         The adjustment of the limiting fractions is done for each
         limit separately, thus involving a further pass through the
         array.  At present it finds the more extreme outlier first by
         comparing the bin number of the limits with respect to the mean
         bin number.
      }
   }
}
\sstroutine{
   KPG1\_FRACx
}{
   Finds values corresponding to specified fractions of an array{\tt '}s
   ordered distribution
}{
   \sstdescription{
      This routine finds the values at defined fractions of an array{\tt '}s
      ordered distribution, such as percentiles.  Thus to find the
      upper-quartile value, the fraction would be 0.75.  Since it uses
      an histogram technique rather than sorting the whole array, for
      efficiency, the result may not be exactly correct.  However,
      the histogram has a large number of bins (10000), combined with
      linear interpolation between bins in the routine reduce the error.
      The histogram extends between the minimum and maximum data values.

      The routine also has an iterative method, whereby outliers, which
      compress the vast majority of data values into a few bins, are
      excluded from the histogram.  Clipping occurs from both ends.
      A contiguous series of bins are removed until the largest
      or smallest fraction is encountered.  Where the rejection of bins
      end, defines new limits, encompassing the vast majority of values.
      A new histogram is calculated using these revised limits.  The
      excluded outliers are still counted in the evaluation of the
      fractions.  The criterion for iteration may need tuning in the
      light of experience.  At present it is when there are fewer than
      4\% non-zero bins.

      The iteration can still fail to find accurate fractional values if
      smallest and largest fractions are close to 0 or 1 and correspond
      to extreme outliers.  The routine recognises this state and
      determines the values for each outlier fraction separately, and
      then uses the next interior fraction as the limit.  Then the
      routine proceeds with the clipping described above.
   }
   \sstinvocation{
      CALL KPG1\_FRACx( EL, ARRAY, NFRAC, FRAC, BAD, CLFRAC, VALUES,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements of the array to be analysed.
      }
      \sstsubsection{
         ARRAY( EL ) = INTEGER (Given)
      }{
         The array for which the chosen statistics are required.
      }
      \sstsubsection{
         NFRAC = INTEGER (Given)
      }{
         Number of fractional positions.
      }
      \sstsubsection{
         FRAC( NFRAC ) = REAL (Given and Returned)
      }{
         Fractional positions in the histogram in the range 0.0--1.0.
         On exit they are arranged into ascending order.
      }
      \sstsubsection{
         BAD = LOGICAL (Given and Returned)
      }{
         True when bad pixels may be present.
      }
      \sstsubsection{
         CLFRAC( NFRAC ) = REAL (Returned)
      }{
         The clipped fractional positions in the histogram in the range
         0.0--1.0 after iterative clipping of the histogram.
      }
      \sstsubsection{
         VALUES( NFRAC ) = DOUBLE PRECISION (Returned)
      }{
         Values corresponding to the ordered fractional positions in
         the histogram.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numerical data type: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, W, UB or UW as appropriate.  The
         array supplied to the routine must have the data type specified.

         \sstitem
         For integer types the number of bins does not exceed the
         data range.  The number of bins is reduced as clipping occurs.
      }
   }
   \sstdiytopic{
      Deficiencies
   }{
      \sstitemlist{

         \sstitem
         The iterative algorithm is not especially efficient; for data
         with a very wide range the iterations can be numerous.  A
         sigma-clipping approach to remove the outliers might be better.

         \sstitem
         The adjustment of the limiting fractions is done for each
         limit separately, thus involving a further pass through the
         array.  At present it finds the more extreme outlier first by
         comparing the bin number of the limits with respect to the mean
         bin number.
      }
   }
}
\sstroutine{
   KPG1\_FRACx
}{
   Finds values corresponding to specified fractions of an array{\tt '}s
   ordered distribution
}{
   \sstdescription{
      This routine finds the values at defined fractions of an array{\tt '}s
      ordered distribution, such as percentiles.  Thus to find the
      upper-quartile value, the fraction would be 0.75.  Since it uses
      an histogram technique rather than sorting the whole array, for
      efficiency, the result may not be exactly correct.  However,
      the histogram has a large number of bins (10000), combined with
      linear interpolation between bins in the routine reduce the error.
      The histogram extends between the minimum and maximum data values.

      The routine also has an iterative method, whereby outliers, which
      compress the vast majority of data values into a few bins, are
      excluded from the histogram.  Clipping occurs from both ends.
      A contiguous series of bins are removed until the largest
      or smallest fraction is encountered.  Where the rejection of bins
      end, defines new limits, encompassing the vast majority of values.
      A new histogram is calculated using these revised limits.  The
      excluded outliers are still counted in the evaluation of the
      fractions.  The criterion for iteration may need tuning in the
      light of experience.  At present it is when there are fewer than
      4\% non-zero bins.

      The iteration can still fail to find accurate fractional values if
      smallest and largest fractions are close to 0 or 1 and correspond
      to extreme outliers.  The routine recognises this state and
      determines the values for each outlier fraction separately, and
      then uses the next interior fraction as the limit.  Then the
      routine proceeds with the clipping described above.
   }
   \sstinvocation{
      CALL KPG1\_FRACx( EL, ARRAY, NFRAC, FRAC, BAD, CLFRAC, VALUES,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements of the array to be analysed.
      }
      \sstsubsection{
         ARRAY( EL ) = REAL (Given)
      }{
         The array for which the chosen statistics are required.
      }
      \sstsubsection{
         NFRAC = INTEGER (Given)
      }{
         Number of fractional positions.
      }
      \sstsubsection{
         FRAC( NFRAC ) = REAL (Given and Returned)
      }{
         Fractional positions in the histogram in the range 0.0--1.0.
         On exit they are arranged into ascending order.
      }
      \sstsubsection{
         BAD = LOGICAL (Given and Returned)
      }{
         True when bad pixels may be present.
      }
      \sstsubsection{
         CLFRAC( NFRAC ) = REAL (Returned)
      }{
         The clipped fractional positions in the histogram in the range
         0.0--1.0 after iterative clipping of the histogram.
      }
      \sstsubsection{
         VALUES( NFRAC ) = DOUBLE PRECISION (Returned)
      }{
         Values corresponding to the ordered fractional positions in
         the histogram.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numerical data type: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, W, UB or UW as appropriate.  The
         array supplied to the routine must have the data type specified.

         \sstitem
         For integer types the number of bins does not exceed the
         data range.  The number of bins is reduced as clipping occurs.
      }
   }
   \sstdiytopic{
      Deficiencies
   }{
      \sstitemlist{

         \sstitem
         The iterative algorithm is not especially efficient; for data
         with a very wide range the iterations can be numerous.  A
         sigma-clipping approach to remove the outliers might be better.

         \sstitem
         The adjustment of the limiting fractions is done for each
         limit separately, thus involving a further pass through the
         array.  At present it finds the more extreme outlier first by
         comparing the bin number of the limits with respect to the mean
         bin number.
      }
   }
}
\sstroutine{
   KPG1\_FRACx
}{
   Finds values corresponding to specified fractions of an array{\tt '}s
   ordered distribution
}{
   \sstdescription{
      This routine finds the values at defined fractions of an array{\tt '}s
      ordered distribution, such as percentiles.  Thus to find the
      upper-quartile value, the fraction would be 0.75.  Since it uses
      an histogram technique rather than sorting the whole array, for
      efficiency, the result may not be exactly correct.  However,
      the histogram has a large number of bins (10000), combined with
      linear interpolation between bins in the routine reduce the error.
      The histogram extends between the minimum and maximum data values.

      The routine also has an iterative method, whereby outliers, which
      compress the vast majority of data values into a few bins, are
      excluded from the histogram.  Clipping occurs from both ends.
      A contiguous series of bins are removed until the largest
      or smallest fraction is encountered.  Where the rejection of bins
      end, defines new limits, encompassing the vast majority of values.
      A new histogram is calculated using these revised limits.  The
      excluded outliers are still counted in the evaluation of the
      fractions.  The criterion for iteration may need tuning in the
      light of experience.  At present it is when there are fewer than
      4\% non-zero bins.

      The iteration can still fail to find accurate fractional values if
      smallest and largest fractions are close to 0 or 1 and correspond
      to extreme outliers.  The routine recognises this state and
      determines the values for each outlier fraction separately, and
      then uses the next interior fraction as the limit.  Then the
      routine proceeds with the clipping described above.
   }
   \sstinvocation{
      CALL KPG1\_FRACx( EL, ARRAY, NFRAC, FRAC, BAD, CLFRAC, VALUES,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements of the array to be analysed.
      }
      \sstsubsection{
         ARRAY( EL ) = BYTE (Given)
      }{
         The array for which the chosen statistics are required.
      }
      \sstsubsection{
         NFRAC = INTEGER (Given)
      }{
         Number of fractional positions.
      }
      \sstsubsection{
         FRAC( NFRAC ) = REAL (Given and Returned)
      }{
         Fractional positions in the histogram in the range 0.0--1.0.
         On exit they are arranged into ascending order.
      }
      \sstsubsection{
         BAD = LOGICAL (Given and Returned)
      }{
         True when bad pixels may be present.
      }
      \sstsubsection{
         CLFRAC( NFRAC ) = REAL (Returned)
      }{
         The clipped fractional positions in the histogram in the range
         0.0--1.0 after iterative clipping of the histogram.
      }
      \sstsubsection{
         VALUES( NFRAC ) = DOUBLE PRECISION (Returned)
      }{
         Values corresponding to the ordered fractional positions in
         the histogram.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numerical data type: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, W, UB or UW as appropriate.  The
         array supplied to the routine must have the data type specified.

         \sstitem
         For integer types the number of bins does not exceed the
         data range.  The number of bins is reduced as clipping occurs.
      }
   }
   \sstdiytopic{
      Deficiencies
   }{
      \sstitemlist{

         \sstitem
         The iterative algorithm is not especially efficient; for data
         with a very wide range the iterations can be numerous.  A
         sigma-clipping approach to remove the outliers might be better.

         \sstitem
         The adjustment of the limiting fractions is done for each
         limit separately, thus involving a further pass through the
         array.  At present it finds the more extreme outlier first by
         comparing the bin number of the limits with respect to the mean
         bin number.
      }
   }
}
\sstroutine{
   KPG1\_FRACx
}{
   Finds values corresponding to specified fractions of an array{\tt '}s
   ordered distribution
}{
   \sstdescription{
      This routine finds the values at defined fractions of an array{\tt '}s
      ordered distribution, such as percentiles.  Thus to find the
      upper-quartile value, the fraction would be 0.75.  Since it uses
      an histogram technique rather than sorting the whole array, for
      efficiency, the result may not be exactly correct.  However,
      the histogram has a large number of bins (10000), combined with
      linear interpolation between bins in the routine reduce the error.
      The histogram extends between the minimum and maximum data values.

      The routine also has an iterative method, whereby outliers, which
      compress the vast majority of data values into a few bins, are
      excluded from the histogram.  Clipping occurs from both ends.
      A contiguous series of bins are removed until the largest
      or smallest fraction is encountered.  Where the rejection of bins
      end, defines new limits, encompassing the vast majority of values.
      A new histogram is calculated using these revised limits.  The
      excluded outliers are still counted in the evaluation of the
      fractions.  The criterion for iteration may need tuning in the
      light of experience.  At present it is when there are fewer than
      4\% non-zero bins.

      The iteration can still fail to find accurate fractional values if
      smallest and largest fractions are close to 0 or 1 and correspond
      to extreme outliers.  The routine recognises this state and
      determines the values for each outlier fraction separately, and
      then uses the next interior fraction as the limit.  Then the
      routine proceeds with the clipping described above.
   }
   \sstinvocation{
      CALL KPG1\_FRACx( EL, ARRAY, NFRAC, FRAC, BAD, CLFRAC, VALUES,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements of the array to be analysed.
      }
      \sstsubsection{
         ARRAY( EL ) = INTEGER$*$2 (Given)
      }{
         The array for which the chosen statistics are required.
      }
      \sstsubsection{
         NFRAC = INTEGER (Given)
      }{
         Number of fractional positions.
      }
      \sstsubsection{
         FRAC( NFRAC ) = REAL (Given and Returned)
      }{
         Fractional positions in the histogram in the range 0.0--1.0.
         On exit they are arranged into ascending order.
      }
      \sstsubsection{
         BAD = LOGICAL (Given and Returned)
      }{
         True when bad pixels may be present.
      }
      \sstsubsection{
         CLFRAC( NFRAC ) = REAL (Returned)
      }{
         The clipped fractional positions in the histogram in the range
         0.0--1.0 after iterative clipping of the histogram.
      }
      \sstsubsection{
         VALUES( NFRAC ) = DOUBLE PRECISION (Returned)
      }{
         Values corresponding to the ordered fractional positions in
         the histogram.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numerical data type: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, W, UB or UW as appropriate.  The
         array supplied to the routine must have the data type specified.

         \sstitem
         For integer types the number of bins does not exceed the
         data range.  The number of bins is reduced as clipping occurs.
      }
   }
   \sstdiytopic{
      Deficiencies
   }{
      \sstitemlist{

         \sstitem
         The iterative algorithm is not especially efficient; for data
         with a very wide range the iterations can be numerous.  A
         sigma-clipping approach to remove the outliers might be better.

         \sstitem
         The adjustment of the limiting fractions is done for each
         limit separately, thus involving a further pass through the
         array.  At present it finds the more extreme outlier first by
         comparing the bin number of the limits with respect to the mean
         bin number.
      }
   }
}
\sstroutine{
   KPG1\_FRACx
}{
   Finds values corresponding to specified fractions of an array{\tt '}s
   ordered distribution
}{
   \sstdescription{
      This routine finds the values at defined fractions of an array{\tt '}s
      ordered distribution, such as percentiles.  Thus to find the
      upper-quartile value, the fraction would be 0.75.  Since it uses
      an histogram technique rather than sorting the whole array, for
      efficiency, the result may not be exactly correct.  However,
      the histogram has a large number of bins (10000), combined with
      linear interpolation between bins in the routine reduce the error.
      The histogram extends between the minimum and maximum data values.

      The routine also has an iterative method, whereby outliers, which
      compress the vast majority of data values into a few bins, are
      excluded from the histogram.  Clipping occurs from both ends.
      A contiguous series of bins are removed until the largest
      or smallest fraction is encountered.  Where the rejection of bins
      end, defines new limits, encompassing the vast majority of values.
      A new histogram is calculated using these revised limits.  The
      excluded outliers are still counted in the evaluation of the
      fractions.  The criterion for iteration may need tuning in the
      light of experience.  At present it is when there are fewer than
      4\% non-zero bins.

      The iteration can still fail to find accurate fractional values if
      smallest and largest fractions are close to 0 or 1 and correspond
      to extreme outliers.  The routine recognises this state and
      determines the values for each outlier fraction separately, and
      then uses the next interior fraction as the limit.  Then the
      routine proceeds with the clipping described above.
   }
   \sstinvocation{
      CALL KPG1\_FRACx( EL, ARRAY, NFRAC, FRAC, BAD, CLFRAC, VALUES,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements of the array to be analysed.
      }
      \sstsubsection{
         ARRAY( EL ) = INTEGER$*$2 (Given)
      }{
         The array for which the chosen statistics are required.
      }
      \sstsubsection{
         NFRAC = INTEGER (Given)
      }{
         Number of fractional positions.
      }
      \sstsubsection{
         FRAC( NFRAC ) = REAL (Given and Returned)
      }{
         Fractional positions in the histogram in the range 0.0--1.0.
         On exit they are arranged into ascending order.
      }
      \sstsubsection{
         BAD = LOGICAL (Given and Returned)
      }{
         True when bad pixels may be present.
      }
      \sstsubsection{
         CLFRAC( NFRAC ) = REAL (Returned)
      }{
         The clipped fractional positions in the histogram in the range
         0.0--1.0 after iterative clipping of the histogram.
      }
      \sstsubsection{
         VALUES( NFRAC ) = DOUBLE PRECISION (Returned)
      }{
         Values corresponding to the ordered fractional positions in
         the histogram.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numerical data type: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, W, UB or UW as appropriate.  The
         array supplied to the routine must have the data type specified.

         \sstitem
         For integer types the number of bins does not exceed the
         data range.  The number of bins is reduced as clipping occurs.
      }
   }
   \sstdiytopic{
      Deficiencies
   }{
      \sstitemlist{

         \sstitem
         The iterative algorithm is not especially efficient; for data
         with a very wide range the iterations can be numerous.  A
         sigma-clipping approach to remove the outliers might be better.

         \sstitem
         The adjustment of the limiting fractions is done for each
         limit separately, thus involving a further pass through the
         array.  At present it finds the more extreme outlier first by
         comparing the bin number of the limits with respect to the mean
         bin number.
      }
   }
}
\sstroutine{
   KPG1\_FRPIC
}{
   Creates a frame picture of a given size within the current
   picture
}{
   \sstdescription{
      This routine obtains from the environment the size of the frame
      zone in metres up to the size of the current picture.  A new zone
      is created, optionally selecting the largest square zone
      within it and normalising the world co-ordinates.  This frame
      picture is saved with the specified label into the graphics
      database.
   }
   \sstinvocation{
       CALL KPG1\_FRPIC( PNXSIZ, PNYSIZ, LABEL, SQUARE, ZONE, PICID,
      :                 STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNXSIZ = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the ADAM parameter which is to be used to obtain
         the x size of the frame picture in metres.
      }
      \sstsubsection{
         PNYSIZ = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the ADAM parameter which is to be used to obtain
         the y size of the frame picture in metres.
      }
      \sstsubsection{
         LABEL = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The label for the frame picture.
      }
      \sstsubsection{
         SQUARE = LOGICAL (Given)
      }{
         If true the largest square within the sized zone becomes the
         frame picture, and it will have world co-ordinates from 0.0 to
         1.0 in both x and y.
      }
      \sstsubsection{
         ZONE = INTEGER (Returned)
      }{
         The SGS zone identifier of the frame.
      }
      \sstsubsection{
         PICID = INTEGER (Returned)
      }{
         The picture identifier of the frame picture.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         The AGI SGS interface must be active.
      }
   }
}
\sstroutine{
   KPG1\_GAUFx
}{
   To fit a Gaussian to a one-dimensional array of data
}{
   \sstdescription{
      This routine fits a Gaussian to a 1-d array of data.  It finds
      the amplitude, centre, sigma and background levels by an
      iterative method.
   }
   \sstinvocation{
       CALL KPG1\_GAUFx( DATA, LBND, UBND, NITER, TOLL, AMP, X0,
      :                  SIGMA, BACK, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DATA( LBND:UBND ) = ? (Given)
      }{
         The data array to be fitted by a Gaussian.
      }
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The lower bound of the data array.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The upper bound of the data array.
      }
      \sstsubsection{
         NITER = INTEGER (Given)
      }{
         The maximum number of refining iterations.
      }
      \sstsubsection{
         TOLL = REAL (Given)
      }{
         The accuracy criterion: absolute for the centre and relative
         for the amplitude and width.  The accuracy of back is assessed
         as a fraction of the Gaussian amplitude.
      }
      \sstsubsection{
         AMP = REAL (Returned)
      }{
         The Gaussian amplitude.
      }
      \sstsubsection{
         X0 = REAL (Returned)
      }{
         The Gaussian centre.
      }
      \sstsubsection{
         SIGMA = REAL (Returned)
      }{
         The {\tt '}sigma{\tt '} of the Gaussian.
      }
      \sstsubsection{
         BACK = REAL (Returned)
      }{
         The background signal level.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each numeric data type: replace {\tt "}x{\tt "} in the
      routine name by D, R, I, W, UW, B, UB as appropriate.  The array
      supplied to the routine must have the data type specified.
   }
}
\sstroutine{
   KPG1\_GAUFx
}{
   To fit a Gaussian to a one-dimensional array of data
}{
   \sstdescription{
      This routine fits a Gaussian to a 1-d array of data.  It finds
      the amplitude, centre, sigma and background levels by an
      iterative method.
   }
   \sstinvocation{
       CALL KPG1\_GAUFx( DATA, LBND, UBND, NITER, TOLL, AMP, X0,
      :                  SIGMA, BACK, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DATA( LBND:UBND ) = ? (Given)
      }{
         The data array to be fitted by a Gaussian.
      }
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The lower bound of the data array.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The upper bound of the data array.
      }
      \sstsubsection{
         NITER = INTEGER (Given)
      }{
         The maximum number of refining iterations.
      }
      \sstsubsection{
         TOLL = REAL (Given)
      }{
         The accuracy criterion: absolute for the centre and relative
         for the amplitude and width.  The accuracy of back is assessed
         as a fraction of the Gaussian amplitude.
      }
      \sstsubsection{
         AMP = REAL (Returned)
      }{
         The Gaussian amplitude.
      }
      \sstsubsection{
         X0 = REAL (Returned)
      }{
         The Gaussian centre.
      }
      \sstsubsection{
         SIGMA = REAL (Returned)
      }{
         The {\tt '}sigma{\tt '} of the Gaussian.
      }
      \sstsubsection{
         BACK = REAL (Returned)
      }{
         The background signal level.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each numeric data type: replace {\tt "}x{\tt "} in the
      routine name by D, R, I, W, UW, B, UB as appropriate.  The array
      supplied to the routine must have the data type specified.
   }
}
\sstroutine{
   KPG1\_GAUFx
}{
   To fit a Gaussian to a one-dimensional array of data
}{
   \sstdescription{
      This routine fits a Gaussian to a 1-d array of data.  It finds
      the amplitude, centre, sigma and background levels by an
      iterative method.
   }
   \sstinvocation{
       CALL KPG1\_GAUFx( DATA, LBND, UBND, NITER, TOLL, AMP, X0,
      :                  SIGMA, BACK, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DATA( LBND:UBND ) = ? (Given)
      }{
         The data array to be fitted by a Gaussian.
      }
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The lower bound of the data array.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The upper bound of the data array.
      }
      \sstsubsection{
         NITER = INTEGER (Given)
      }{
         The maximum number of refining iterations.
      }
      \sstsubsection{
         TOLL = REAL (Given)
      }{
         The accuracy criterion: absolute for the centre and relative
         for the amplitude and width.  The accuracy of back is assessed
         as a fraction of the Gaussian amplitude.
      }
      \sstsubsection{
         AMP = REAL (Returned)
      }{
         The Gaussian amplitude.
      }
      \sstsubsection{
         X0 = REAL (Returned)
      }{
         The Gaussian centre.
      }
      \sstsubsection{
         SIGMA = REAL (Returned)
      }{
         The {\tt '}sigma{\tt '} of the Gaussian.
      }
      \sstsubsection{
         BACK = REAL (Returned)
      }{
         The background signal level.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each numeric data type: replace {\tt "}x{\tt "} in the
      routine name by D, R, I, W, UW, B, UB as appropriate.  The array
      supplied to the routine must have the data type specified.
   }
}
\sstroutine{
   KPG1\_GAUFx
}{
   To fit a Gaussian to a one-dimensional array of data
}{
   \sstdescription{
      This routine fits a Gaussian to a 1-d array of data.  It finds
      the amplitude, centre, sigma and background levels by an
      iterative method.
   }
   \sstinvocation{
       CALL KPG1\_GAUFx( DATA, LBND, UBND, NITER, TOLL, AMP, X0,
      :                  SIGMA, BACK, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DATA( LBND:UBND ) = ? (Given)
      }{
         The data array to be fitted by a Gaussian.
      }
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The lower bound of the data array.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The upper bound of the data array.
      }
      \sstsubsection{
         NITER = INTEGER (Given)
      }{
         The maximum number of refining iterations.
      }
      \sstsubsection{
         TOLL = REAL (Given)
      }{
         The accuracy criterion: absolute for the centre and relative
         for the amplitude and width.  The accuracy of back is assessed
         as a fraction of the Gaussian amplitude.
      }
      \sstsubsection{
         AMP = REAL (Returned)
      }{
         The Gaussian amplitude.
      }
      \sstsubsection{
         X0 = REAL (Returned)
      }{
         The Gaussian centre.
      }
      \sstsubsection{
         SIGMA = REAL (Returned)
      }{
         The {\tt '}sigma{\tt '} of the Gaussian.
      }
      \sstsubsection{
         BACK = REAL (Returned)
      }{
         The background signal level.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each numeric data type: replace {\tt "}x{\tt "} in the
      routine name by D, R, I, W, UW, B, UB as appropriate.  The array
      supplied to the routine must have the data type specified.
   }
}
\sstroutine{
   KPG1\_GAUFx
}{
   To fit a Gaussian to a one-dimensional array of data
}{
   \sstdescription{
      This routine fits a Gaussian to a 1-d array of data.  It finds
      the amplitude, centre, sigma and background levels by an
      iterative method.
   }
   \sstinvocation{
       CALL KPG1\_GAUFx( DATA, LBND, UBND, NITER, TOLL, AMP, X0,
      :                  SIGMA, BACK, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DATA( LBND:UBND ) = ? (Given)
      }{
         The data array to be fitted by a Gaussian.
      }
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The lower bound of the data array.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The upper bound of the data array.
      }
      \sstsubsection{
         NITER = INTEGER (Given)
      }{
         The maximum number of refining iterations.
      }
      \sstsubsection{
         TOLL = REAL (Given)
      }{
         The accuracy criterion: absolute for the centre and relative
         for the amplitude and width.  The accuracy of back is assessed
         as a fraction of the Gaussian amplitude.
      }
      \sstsubsection{
         AMP = REAL (Returned)
      }{
         The Gaussian amplitude.
      }
      \sstsubsection{
         X0 = REAL (Returned)
      }{
         The Gaussian centre.
      }
      \sstsubsection{
         SIGMA = REAL (Returned)
      }{
         The {\tt '}sigma{\tt '} of the Gaussian.
      }
      \sstsubsection{
         BACK = REAL (Returned)
      }{
         The background signal level.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each numeric data type: replace {\tt "}x{\tt "} in the
      routine name by D, R, I, W, UW, B, UB as appropriate.  The array
      supplied to the routine must have the data type specified.
   }
}
\sstroutine{
   KPG1\_GAUFx
}{
   To fit a Gaussian to a one-dimensional array of data
}{
   \sstdescription{
      This routine fits a Gaussian to a 1-d array of data.  It finds
      the amplitude, centre, sigma and background levels by an
      iterative method.
   }
   \sstinvocation{
       CALL KPG1\_GAUFx( DATA, LBND, UBND, NITER, TOLL, AMP, X0,
      :                  SIGMA, BACK, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DATA( LBND:UBND ) = ? (Given)
      }{
         The data array to be fitted by a Gaussian.
      }
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The lower bound of the data array.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The upper bound of the data array.
      }
      \sstsubsection{
         NITER = INTEGER (Given)
      }{
         The maximum number of refining iterations.
      }
      \sstsubsection{
         TOLL = REAL (Given)
      }{
         The accuracy criterion: absolute for the centre and relative
         for the amplitude and width.  The accuracy of back is assessed
         as a fraction of the Gaussian amplitude.
      }
      \sstsubsection{
         AMP = REAL (Returned)
      }{
         The Gaussian amplitude.
      }
      \sstsubsection{
         X0 = REAL (Returned)
      }{
         The Gaussian centre.
      }
      \sstsubsection{
         SIGMA = REAL (Returned)
      }{
         The {\tt '}sigma{\tt '} of the Gaussian.
      }
      \sstsubsection{
         BACK = REAL (Returned)
      }{
         The background signal level.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each numeric data type: replace {\tt "}x{\tt "} in the
      routine name by D, R, I, W, UW, B, UB as appropriate.  The array
      supplied to the routine must have the data type specified.
   }
}
\sstroutine{
   KPG1\_GAUFx
}{
   To fit a Gaussian to a one-dimensional array of data
}{
   \sstdescription{
      This routine fits a Gaussian to a 1-d array of data.  It finds
      the amplitude, centre, sigma and background levels by an
      iterative method.
   }
   \sstinvocation{
       CALL KPG1\_GAUFx( DATA, LBND, UBND, NITER, TOLL, AMP, X0,
      :                  SIGMA, BACK, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DATA( LBND:UBND ) = ? (Given)
      }{
         The data array to be fitted by a Gaussian.
      }
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The lower bound of the data array.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The upper bound of the data array.
      }
      \sstsubsection{
         NITER = INTEGER (Given)
      }{
         The maximum number of refining iterations.
      }
      \sstsubsection{
         TOLL = REAL (Given)
      }{
         The accuracy criterion: absolute for the centre and relative
         for the amplitude and width.  The accuracy of back is assessed
         as a fraction of the Gaussian amplitude.
      }
      \sstsubsection{
         AMP = REAL (Returned)
      }{
         The Gaussian amplitude.
      }
      \sstsubsection{
         X0 = REAL (Returned)
      }{
         The Gaussian centre.
      }
      \sstsubsection{
         SIGMA = REAL (Returned)
      }{
         The {\tt '}sigma{\tt '} of the Gaussian.
      }
      \sstsubsection{
         BACK = REAL (Returned)
      }{
         The background signal level.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each numeric data type: replace {\tt "}x{\tt "} in the
      routine name by D, R, I, W, UW, B, UB as appropriate.  The array
      supplied to the routine must have the data type specified.
   }
}
\sstroutine{
   KPG1\_GAUSx
}{
   Smooth a 2-dimensional array using a symmetrical Gaussian PSF
}{
   \sstdescription{
      The routine smooths the array A using a symmetrical Gaussian
      point spread function and returns the result in the array B.
   }
   \sstinvocation{
      CALL KPG1\_GAUSx( SIGMA, IBOX, SAMBAD, WLIM, NX, NY, BAD,
                       VAR, A, B, BADOUT, WEIGHT, AMAR, WMAR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SIGMA = REAL (Given)
      }{
         Standard deviation of the Gaussian to be used for smoothing.
      }
      \sstsubsection{
         IBOX = INTEGER (Given)
      }{
         Half-size, in pixels, of the box over which the Gaussian
         smoothing profile will be applied (the actual box used has an
         edge which is 2$*$IBOX$+$1 pixels long). This defines the region
         within which the point spread function is non-zero.
      }
      \sstsubsection{
         SAMBAD = LOGICAL (Given)
      }{
         If a .TRUE. value is given, then any {\tt "}bad{\tt "} pixels in the input
         array A will be propagated to the output array B (output
         values will be calculated for all other output pixels). If a
         .FALSE. value is given, then the WLIM argument is used to
         determine which output pixels will be bad (if any). This
         argument is not relevant if BAD is .FALSE..
      }
      \sstsubsection{
         WLIM = ? (Given)
      }{
         The minimum weighting that can be used to compute a smoothed
         output pixel if SAMBAD is .FALSE..  Any output pixels falling
         short of the specified weight will be set to the bad value
         (invalid pixels carry no weight, others have Gaussian weights
         about the central pixel).  The value must be greater than 0.0
         and should be less than or equal to 1.0. This argument is not
         used if SAMBAD is .TRUE. or if BAD is .FALSE..
      }
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         First dimension of the 2-d array A.
      }
      \sstsubsection{
         NY = INTEGER (Given)
      }{
         Second dimension of the 2-d array A.
      }
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether it is necessary to check for bad pixels in the input
         array A.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If a .FALSE. value is given for this argument, then smoothing
         will be performed as if the array supplied (A) is an array of
         data and the PSF will be used directly as specified. If a
         .TRUE. value is given, then smoothing will be applied as if
         the array is an array of variance values associated with an
         array of data; in this case, the effective PSF will be reduced
         in width by a factor 2 and the mean output values will be
         reduced to reflect the variance-reducing effect of smoothing.
      }
      \sstsubsection{
         A( NX, NY ) = ? (Given)
      }{
         Array containing the input image to be smoothed.
      }
      \sstsubsection{
         BADOUT = LOGICAL (Returned)
      }{
         Whether there are bad pixel values in the output array.
      }
      \sstsubsection{
         WEIGHT( 2 $*$ IBOX $+$ 1 ) = ? (Returned)
      }{
         Workspace for the Gaussian weighting function.
      }
      \sstsubsection{
         AMAR( NX ) = ? (Returned)
      }{
         Workspace for the weighted sum of array values.
      }
      \sstsubsection{
         WMAR( NX ) = ? (Returned)
      }{
         Workspace for the sum of pixel weights.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There are routines for processing double precision and real data.
      Replace {\tt "}x{\tt "} in the routine name by D or R as appropriate. The
      data types of the WLIM, A, B, WEIGHT, AMAR, and WMAR arguments
      must match the routine used.
   }
}
\sstroutine{
   KPG1\_GAUSx
}{
   Smooth a 2-dimensional array using a symmetrical Gaussian PSF
}{
   \sstdescription{
      The routine smooths the array A using a symmetrical Gaussian
      point spread function and returns the result in the array B.
   }
   \sstinvocation{
      CALL KPG1\_GAUSx( SIGMA, IBOX, SAMBAD, WLIM, NX, NY, BAD,
                       VAR, A, B, BADOUT, WEIGHT, AMAR, WMAR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SIGMA = REAL (Given)
      }{
         Standard deviation of the Gaussian to be used for smoothing.
      }
      \sstsubsection{
         IBOX = INTEGER (Given)
      }{
         Half-size, in pixels, of the box over which the Gaussian
         smoothing profile will be applied (the actual box used has an
         edge which is 2$*$IBOX$+$1 pixels long). This defines the region
         within which the point spread function is non-zero.
      }
      \sstsubsection{
         SAMBAD = LOGICAL (Given)
      }{
         If a .TRUE. value is given, then any {\tt "}bad{\tt "} pixels in the input
         array A will be propagated to the output array B (output
         values will be calculated for all other output pixels). If a
         .FALSE. value is given, then the WLIM argument is used to
         determine which output pixels will be bad (if any). This
         argument is not relevant if BAD is .FALSE..
      }
      \sstsubsection{
         WLIM = ? (Given)
      }{
         The minimum weighting that can be used to compute a smoothed
         output pixel if SAMBAD is .FALSE..  Any output pixels falling
         short of the specified weight will be set to the bad value
         (invalid pixels carry no weight, others have Gaussian weights
         about the central pixel).  The value must be greater than 0.0
         and should be less than or equal to 1.0. This argument is not
         used if SAMBAD is .TRUE. or if BAD is .FALSE..
      }
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         First dimension of the 2-d array A.
      }
      \sstsubsection{
         NY = INTEGER (Given)
      }{
         Second dimension of the 2-d array A.
      }
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether it is necessary to check for bad pixels in the input
         array A.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If a .FALSE. value is given for this argument, then smoothing
         will be performed as if the array supplied (A) is an array of
         data and the PSF will be used directly as specified. If a
         .TRUE. value is given, then smoothing will be applied as if
         the array is an array of variance values associated with an
         array of data; in this case, the effective PSF will be reduced
         in width by a factor 2 and the mean output values will be
         reduced to reflect the variance-reducing effect of smoothing.
      }
      \sstsubsection{
         A( NX, NY ) = ? (Given)
      }{
         Array containing the input image to be smoothed.
      }
      \sstsubsection{
         BADOUT = LOGICAL (Returned)
      }{
         Whether there are bad pixel values in the output array.
      }
      \sstsubsection{
         WEIGHT( 2 $*$ IBOX $+$ 1 ) = ? (Returned)
      }{
         Workspace for the Gaussian weighting function.
      }
      \sstsubsection{
         AMAR( NX ) = ? (Returned)
      }{
         Workspace for the weighted sum of array values.
      }
      \sstsubsection{
         WMAR( NX ) = ? (Returned)
      }{
         Workspace for the sum of pixel weights.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There are routines for processing double precision and real data.
      Replace {\tt "}x{\tt "} in the routine name by D or R as appropriate. The
      data types of the WLIM, A, B, WEIGHT, AMAR, and WMAR arguments
      must match the routine used.
   }
}
\sstroutine{
   KPG1\_GAXLB
}{
   Obtains an axis annotation for an NDF axis
}{
   \sstdescription{
      This routine obtains an axis annotation from the parameter system.
      The suggested default is of the form {\tt "}label (units){\tt "} when there
      is both an axis label and units, or {\tt "}label{\tt "} if the label but not
      the units are present.  If neither are present a supplied default
      is used instead.  If a bad status, other than abort, is returned
      by the parameter system when getting the value, the error is
      annulled and the output annotation is the suggested default value.
   }
   \sstinvocation{
      CALL KPG1\_GAXLB( NDF, IAXIS, PNAXL, DEFAUL, AXSLAB, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDF = INTEGER (Given)
      }{
         The NDF identifier.
      }
      \sstsubsection{
         IAXIS = INTEGER (Given)
      }{
         The number of the axis whose character components are to be
         used.
      }
      \sstsubsection{
         PNAXL = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the ADAM parameter from which the annotation will
         be obtained.
      }
      \sstsubsection{
         DEFAUL = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The suggested default when the NDF axis does not have a label,
         and the actual value returned when a null (!) value or any
         other non-abort bad status is obtained from the parameter
         system.
      }
      \sstsubsection{
         AXSLAB = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The annotation obtained from the parameter system.  The dynamic
         default is limited to 128 characters.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_GCA
}{
   Plots a cell array
}{
   \sstdescription{
      This uses GKS to plot a cell array.  It is needed as an interface
      procedure for GKS 7.2 and 7.4 GCA usage, since these have
      different argument lists.  This is the GKS 7.4 version.
   }
   \sstinvocation{
      CALL KPG1\_GCA( PX, PX, QX, QY, NX, NY, LX, LY, KCOLA, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PX = REAL (Given)
      }{
         X world co-ordinate of lower-left corner of the cell array.
      }
      \sstsubsection{
         PY = REAL (Given)
      }{
         Y world co-ordinate of lower-left corner of the cell array.
      }
      \sstsubsection{
         QX = REAL (Given)
      }{
         X world co-ordinate of upper-right corner of the cell array.
      }
      \sstsubsection{
         QY = REAL (Given)
      }{
         Y world co-ordinate of upper-right corner of the cell array.
      }
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         Number of columns in the cell array.
      }
      \sstsubsection{
         NY = INTEGER (Given)
      }{
         Number of lines in the cell array.
      }
      \sstsubsection{
         LX = INTEGER (Given)
      }{
         X dimension of the cell array.
      }
      \sstsubsection{
         LY = INTEGER (Given)
      }{
         Y dimension of the cell array.
      }
      \sstsubsection{
         KCOLA( LX, LY ) = INTEGER (Given)
      }{
         The array of colour indices.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is no validation by this routine of the input arguments
         as they are passed directly to GCA.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         GKS must be in state WSAC or SGOP.
      }
   }
}
\sstroutine{
   KPG1\_GDARE
}{
   Defines a region within the current PGPLOT window
}{
   \sstdescription{
      This subroutine defines a two-dimensional region in the current
      PGPLOT window.  The region is defined by the given position
      justification, and the linear fraction along each axis of the
      current PGPLOT window; and an aspect ratio.  The linear fraction is
      applied first followed by the aspect-ratio constraint.
   }
   \sstinvocation{
      CALL KPG1\_GDARE( JUST, FRACT, ASPECT, X1, X2, Y1, Y2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         JUST = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Justification of the new region specified by a two-character
         code.  The first character controls the vertical location, and
         may be T, B, or C to create the new region at the top, bottom,
         or in the centre respectively.  The second defines the
         horizontal situation, and may be L, R, or C to define a new
         region to the left, right, or in the centre respectively.
         Thus a code of BR will make a new region in the bottom-right
         corner.  The justification code need not be in uppercase.
      }
      \sstsubsection{
         FRACT( 2 ) = REAL (Given)
      }{
         The fractional size of the new region applied along each axis.
         So values of 0.5,0.5 would create a picture 0.25 the area of
         the current window.
      }
      \sstsubsection{
         ASPECT  = REAL (Given)
      }{
         The aspect ratio of the new region (x/y).  If the value is
         negative, no aspect-ratio constraint is applied to define the
         new region.
      }
      \sstsubsection{
         X1 = REAL (Returned)
      }{
         Lower x world co-ordinate in the current window of the new
         region.
      }
      \sstsubsection{
         X2 = REAL (Returned)
      }{
         Upper x world co-ordinate in the current window of the new
         region.
      }
      \sstsubsection{
         Y1 = REAL (Returned)
      }{
         Lower y world co-ordinate in the current window of the new
         region.
      }
      \sstsubsection{
         Y2 = REAL (Returned)
      }{
         Upper y world co-ordinate in the current window of the new
         region.
      }
      \sstsubsection{
         STATUS  = INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   KPG1\_GDBND
}{
   Get the bounds of a new PGPLOT window from the environment
}{
   \sstdescription{
      This routine defines a 2-d region in the current PGPLOT window,
      getting the bounds of the region from the environment.
   }
   \sstinvocation{
      CALL KPG1\_GDBND( PNLOW, PNUPP, LBND, UBND, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNLOW = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Parameter name of lower-bound co-ordinates that defines a
         region.
      }
      \sstsubsection{
         PNUPP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Parameter name of lower-bound co-ordinates that defines a
         region.
      }
      \sstsubsection{
         LBND( 2 ) = REAL (Returned)
      }{
         Co-ordinates of the lower bound that defines a region.
      }
      \sstsubsection{
         UBND( 2 ) = REAL (Returned)
      }{
         Co-ordinates of the upper bound that defines a region.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_GDGET
}{
   Get the AST Plot associated with an AGI picture
}{
   \sstdescription{
      This routine makes the specified AGI picture current, creates a
      corresponding PGPLOT viewport and window, and returns a Plot
      associated with the picture.

      On exit, the PGPLOT viewport corresponds to the area encompassed by
      the specified picture. The world co-ordinate bounds within this
      viewport are set so that the PGPLOT world co-ordinate system is
      millimetres from the bottom left corner of the view surface. This
      corresponds to the Base (GRAPHICS) Frame in the returned Plot.

      The returned Plot will normally be obtained from the MORE structure
      in the graphics database (where it was stored by a previous AST-based
      application). The Base Frame will be a GRAPHICS Frame, giving
      millimetres from the bottom left corner of the view surface.

      If no Plot is available in the database, then an initial PLOT is
      created containing a Base Frame with Domain GRAPHICS (giving
      millimetres from the bottom left corner of the view surface), and
      a Current Frame corresponding to AGI world co-ordinates. The Frame
      to represent AGI world co-ordinates in the Plot may be supplied by
      the calling application (for instance, an application may supply a
      PIXEL Frame on the assumption that AGI world co-ordinates are pixel
      co-ordinates). If no such Frame is supplied then a simple Frame is
      used, with Domain set to AGI\_WORLD.

      A third Frame may optionally be added to the Plot representing AGI
      DATA co-ordinates. This Frame will have Domain AGI\_DATA, and the
      Mapping from world to data co-ordinates will be given by the
      TRANSFORM structure stored with the picture in the database. If
      present, it will be the Current Frame in the Plot on exit. See
      {\tt "}Usage{\tt "} below for warnings about using this option.

      Finally, some other Frames are added to the Plot representing
      various normalised co-ordinates:

      BASEPIC: The co-ordinates of the bottom left corner of the BASE
      picture are (0,0). The shorter dimension of the BASE picture has
      length 1.0, and the other axis has a length greater than 1.0.

      NDC: Normalized device coordinates. The bottom left corner of the
      screen is (0,0) and the top-right corner is (1,1).

      CURPIC: The co-ordinates of the bottom left corner of the current
      picture are (0,0). The shorter dimension of the current picture has
      length 1.0, and the other axis has a length greater than 1.0.

      CURNDC: The co-ordinates of the bottom left corner of the current
      picture are (0,0), and the top right corner is (1,1).

      If the Plot read from the database already contains any of these
      Frames then they are retained and no new Frame is added.
   }
   \sstinvocation{
      CALL KPG1\_GDGET( IPIC, WCFRM, MKDATA, IPLOT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPIC = INTEGER (Given)
      }{
         The AGI identifier for the picture. If a value of -1 is supplied,
         the identifier for the current picture is used.
      }
      \sstsubsection{
         WCFRM = INTEGER (Given)
      }{
         A pointer to an AST Frame which will be used to describe AGI
         world co-ordinates if the picture has no associated Plot. This
         argument is ignored if the picture already has a Plot stored with
         it in the database. If a null pointer (AST\_\_NULL) is supplied, then
         a default Frame is used with Domain set to AGI\_WORLD.
      }
      \sstsubsection{
         MKDATA = LOGICAL (Given)
      }{
         Should a Frame with Domain AGI\_DATA be included in the returned
         Plot to represent AGI DATA co-ordinates? This is ignored if the
         picture has a Plot already stored with it in the database.
      }
      \sstsubsection{
         IPLOT = INTEGER (Returned)
      }{
         An AST pointer to the Plot. Returned equal to AST\_\_NULL if an
         error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The PGPLOT interface to the AGI library should be opened before
         calling this routine.
      }
   }
}
\sstroutine{
   KPG1\_GDNEW
}{
   Create a new DATA picture with ancillary pictures
}{
   \sstdescription{
      This routine returns identifiers for a new DATA picture together
      with various ancillary pictures in the graphics database. On exit,
      the new DATA picture is the current AGI picture, and the PGPLOT
      viewport matches the DATA picture.

      A FRAME picture is only created if it would contain something other
      than the DATA picture (this is assumed to be the case if any
      ancillary pictures are requested, or if non-zero margins are requested
      around the DATA picture). If created, the FRAME picture has the
      maximum possible size. The DATA picture is then created with a size
      which allows all the requested ancillary pictures to be created within
      the FRAME picture.

      Various environment parameters are used to obtain options, etc. The
      names of these parameters are hard-wired into this subroutine in
      order to ensure conformity between application.
   }
   \sstinvocation{
      CALL KPG1\_GDNEW( COMMNT, MARGIN, NP, PNAME, PSIDE, PSIZE,
                       SASPEC, BOX, IPICD, IPICF, IPIC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         COMMENT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A comment to store with the new pictures added to the AGI
         database. This will usually by an indication of the application
         being run (eg KAPPA\_DISPLAY).
      }
      \sstsubsection{
         MARGIN( 4 ) = REAL (Given)
      }{
         The width of the borders to leave round the DATA picture, given
         as fractions of the corresponding dimension of the current picture.
         These should be supplied in the order bottom, right, top, left.
      }
      \sstsubsection{
         NP = INTEGER (Given)
      }{
         The number of extra pictures to be included in the FRAME pictures
         (the DATA picture itself is not included in this list). Margins are
         left round the DATA picture with widths given by MARGIN. Any extra
         pictures are placed outside these margins, in positions described by
         PSIDE and PSIZE.
      }
      \sstsubsection{
         PNAME( NP ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The names to store in the AGI database with the NP extra pictures.
      }
      \sstsubsection{
         PSIDE( NP ) = CHARACTER $*$ 1 (Given)
      }{
         Each element of this array should be one of L, R, T or B. It
         indicates which side of the FRAME picture an extra picture is to be
         placed. For Left and Right, the extra picture occupies the full
         height of the DATA picture, margins, and any previously created
         extra pictures. The picture is placed at the far Left or Right of
         all previously created pictures. For Top or Bottom, the extra picture
         occupies the full width of the DATA picture, margins, and any
         previously created extra pictures. The picture is placed at the top or
         bottom of all previously created pictures. Ignored if NP is zero.
      }
      \sstsubsection{
         PSIZE( NP ) = REAL (Given)
      }{
         The size of each extra picture. For Left and Right pictures, this
         is the width of the picture, and the value is given as a fraction
         of the width of the current picture. For Top and Bottom pictures,
         it is the height of the picture, and it is given as a fraction of
         the height of the current picture. Ignored if NP is zero.
      }
      \sstsubsection{
         SASPEC = REAL (Given)
      }{
         The aspect ratio with which a new DATA picture should be created.
         This is the height divided by the width of the DATA picture,
         assuming equal scales on each axis (eg metres). A value of zero
         causes the DATA picture to have the aspect ratio which produces
         the largest picture. The actual value used will depend on the
         value supplied for the FILL parameter (see above).
      }
      \sstsubsection{
         BOX( 4 ) = DOUBLE PRECISION (Given)
      }{
         The world coordinate bounds to give to the DATA picture if a new
         DATA picture is created. These should normally be pixel
         coordinates. The (x,y) coordinates of the bottom left corner should
         be given in elements 1 and 2, and the (x,y) coordinates of the top
         right corner should be given in elements 3 and 4. If the box has
         zero area, then world coordinates are set to centimetres from the
         bottom left corner of the DATA picture.
      }
      \sstsubsection{
         IPICD = INTEGER (Returned)
      }{
         An AGI identifier for the DATA picture.
      }
      \sstsubsection{
         IPICF = INTEGER (Returned)
      }{
         An AGI identifier for the FRAME picture. The world co-ordinate
         system is inherited from the current picture on entry. If no
         FRAME picture was created, then an AGI identifier for the current
         picture is returned.
      }
      \sstsubsection{
         IPIC( NP ) = INTEGER (Returned)
      }{
         An array of AGI identifiers corresponding to the extra pictures
         requested in ZSIDE and PSIZE. The world coordinate system for each
         picture is inherited from the FRAME picture. The actual size of a
         picture may be less than the requested size if there is insufficient
         room left in the FRAME picture to give it its requested size.
         Identifiers for pictures which would have zero size (i.e. fall
         completely outside the FRAME picture) are returned equal to -1,
         but no error is reported.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Picture identifiers are returned equal to -1 if an error occurs,
         or if the picture cannot be created.
      }
   }
   \sstdiytopic{
      Environment Parameters
   }{
      FILL = \_LOGICAL (Read)
         TRUE if the supplied aspect ratio (SASPEC) is to be ignored,
         creating the largest possible DATA picture within the current
         picture.  When FILL is FALSE, the DATA picture is created with
         the supplied aspect ratio. Not accessed if argument SASPEC is
         supplied equal to zero (i.e. (SASPEC .EQ. 0.0) implies FILL=YES)
   }
}
\sstroutine{
   KPG1\_GDOLD
}{
   Create a new DATA picture with ancillary pictures aligned with
   an existing DATA picture
}{
   \sstdescription{
      This routine creates a new DATA picture aligned with an existing
      DATA picture, together with any requested ancillary pictures. On
      exit, the new DATA picture is the current picture, and the current
      PGPLOT viewport corresponds to this picture.

      A FRAME picture is only created if it would contain something other
      than the DATA picture (this is assumed to be the case if any
      ancillary pictures are requested, or if non-zero margins are requested
      around the DATA picture). Ancillary pictures are given their
      requested sizes except that they are clipped at the bounds of the
      original current picture. The FRAME picture is also clipped at the
      bounds of the original current picture.
   }
   \sstinvocation{
      CALL KPG1\_GDOLD( MARGIN, COMMNT, NP, PNAME, PSIDE, PSIZE,
                       IPICD, IPICD0, IPICF, IPIC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         MARGIN( 4 ) = REAL (Given)
      }{
         The width of the borders to leave round the DATA picture, given
         as fractions of the corresponding dimension of the current picture.
         These should be supplied in the order bottom, right, top, left.
         They may be negative.
      }
      \sstsubsection{
         COMMNT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A comment to store with the new pictures added to the AGI
         database. This will usually by an indication of the application
         being run (eg KAPPA\_DISPLAY).
      }
      \sstsubsection{
         NP = INTEGER (Given)
      }{
         The number of extra pictures to be included in the FRAME picture
         (the DATA picture itself is not included in this list). Margins are
         left round the DATA picture with widths given by MARGIN. Any extra
         pictures are placed outside these margins, in positions described by
         PSIDE and PSIZE.
      }
      \sstsubsection{
         PNAME( NP ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The names to store in the AGI database with the NP extra pictures.
      }
      \sstsubsection{
         PSIDE( NP ) = CHARACTER $*$ 1 (Given)
      }{
         Each element of this array should be one of L, R, T or B. It
         indicates which side of the FRAME picture an extra picture is to be
         placed. For Left and Right, the extra picture occupies the full
         height of the DATA picture, margins, and any previously created
         extra pictures. The picture is placed at the far Left or Right of
         all previously created pictures. For Top or Bottom, the extra picture
         occupies the full width of the DATA picture, margins, and any
         previously created extra pictures. The picture is placed at the top or
         bottom of all previously created pictures. Ignored if NP is zero.
      }
      \sstsubsection{
         PSIZE( NP ) = REAL (Given)
      }{
         The size of each extra picture. For Left and Right pictures, this is
         the width of the picture, and the value is given as a fraction of
         the width of the current picture. For Top and Bottom pictures, it
         is the height of the picture, and it is given as a fraction of the
         height of the current picture. Ignored if NP is zero.
      }
      \sstsubsection{
         IPICD = INTEGER (Given)
      }{
         An AGI identifier for the existing DATA picture.
      }
      \sstsubsection{
         IPICD0 = INTEGER (Returned)
      }{
         An AGI identifier for the new DATA picture.
      }
      \sstsubsection{
         IPICF = INTEGER (Returned)
      }{
         An AGI identifier for the FRAME picture. Thw world cooridnate
         system is inherited form the current picture on entry. If no
         FRAME picture was created, then an AGI identifier for the current
         picture is returned.
      }
      \sstsubsection{
         IPIC( NP ) = INTEGER (Returned)
      }{
         An array of AGI identifiers corresponding to the extra pictures
         requested in ZSIDE and PSIZE. The world coordinate system for each
         picture is inherited from the FRAME picture. The actual size of a
         picture may be less than the requested size if there is insufficient
         room left in the FRAME picture to give it its requested size.
         Identifiers for pictures which would have zero size (i.e. fall
         completely outside the FRAME picture) are returned equal to -1,
         but no error is reported.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Picture identifiers are returned equal to -1 if an error occurs,
         or if the picture cannot be created.
      }
   }
}
\sstroutine{
   KPG1\_GDPUT
}{
   Save an AST Plot with a graphics database picture
}{
   \sstdescription{
      This routine saves the supplied AST Plot (see SUN/210) in the AGI
      database (see SUN/48) within the MORE structure of the specified
      picture. It can be retrieved if necessary using KPG1\_GDGET (see the
      prologue of KPG1\_GDGET for more information about using these two
      routines).

      If the supplied Plot contains a {\tt "}AGI Data{\tt "} Frame with the
      Domain given by DDOM in which the axes are scaled and shifted
      versions of the axes of the AGI world co-ordinate Frame
      (specified by argument WDOM), then a TRANSFORM structure defining
      AGI Data co-ordinates is stored with the DATA picture. This is purely
      for the benefit of non-AST based applications which may use AGI Data
      co-ordinates (AST-based applications should always use the Plot
      stored with the picture in preference to the TRANSFORM structure
      stored in the AGI database).
   }
   \sstinvocation{
      CALL KPG1\_GDPUT( IPIC, WDOM, DDOM, IPLOT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPIC = INTEGER (Given)
      }{
         The AGI identifier for the picture. A value of -1 causes the
         Plot to be stored with the current picture.
      }
      \sstsubsection{
         WDOM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Domain name of the co-ordinate Frame within IPLOT corresponding
         to AGI world co-ordinates. {\tt "}AGI\_WORLD{\tt "} is used if a blank value
         is supplied.
      }
      \sstsubsection{
         DDOM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Domain name of the co-ordinate Frame within IPLOT corresponding
         to AGI data co-ordinates. {\tt "}AXIS{\tt "} is used if a blank value
         is supplied.
      }
      \sstsubsection{
         IPLOT = INTEGER (Given)
      }{
         An AST pointer to the Plot to be stored with the picture. If
         AST\_\_NULL is supplied, any existing Plot stored with the picture is
         deleted.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The Base (GRAPHICS) Frame in the Plot should represent millimetres
         from the bottom left corner of the view surface.

         \sstitem
         An error is reported if the Plot contains any Frames which have the
         Domain AGI\_DATA.

         \sstitem
         The PGPLOT interface to the AGI library should be opened before
         calling this routine.

         \sstitem
         The Plot is stored in a component of the MORE structure named
         {\tt "}AST\_PLOT{\tt "} and with type {\tt "}WCS{\tt "}.
      }
   }
}
\sstroutine{
   KPG1\_GDQPC
}{
   Return the extent of the current picture
}{
   \sstdescription{
      This routine makes the current PGPLOT bviewport and window match
      the current AGI picture, and returns the extent of the picture in
      AGI world co-ordinates and physical coordinates (metres).
   }
   \sstinvocation{
      CALL KPG1\_GDQPC( X1, X2, Y1, Y2, XM, YM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         X1 = REAL (Returned)
      }{
         The X world coordinate of the bottom left corner.
      }
      \sstsubsection{
         Y1 = REAL (Returned)
      }{
         The Y world coordinate of the bottom left corner.
      }
      \sstsubsection{
         X2 = REAL (Returned)
      }{
         The X world coordinate of the top right corner.
      }
      \sstsubsection{
         Y2 = REAL (Returned)
      }{
         The Y world coordinate of the top right corner.
      }
      \sstsubsection{
         XM = REAL (Returned)
      }{
         The extent of the Y axis in metres.
      }
      \sstsubsection{
         YM = REAL (Returned)
      }{
         The extent of the Y axis in metres.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The PGPLOT interface to the AGI library should be opened before
         calling this routine.

         \sstitem
         The PGPLOT viewport corresponds to the current AGI picture
         on exit.
      }
   }
}
\sstroutine{
   KPG1\_GDWIN
}{
   Set PGPLOT world co-ordinates to be the world co-ordinates
   of the specified AGI picture
}{
   \sstdescription{
      This routine finds the bounds of the current PGPLOT viewport within
      the world-coordinate system of a specified AGI picture, and sets the
      PGPLOT window accordingly.
   }
   \sstinvocation{
      CALL  KPG1\_GDWIN( IPIC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPIC = INTEGER (Given)
      }{
         The AGI picture identifier. If -1, then the current picture is
         used.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_GETIM
}{
   Get locators to an IMAGE-type structure and structure holding the
   data array for data input
}{
   \sstdescription{
      Returns a locator to an IMAGE-type data-structure associated with
      a supplied parameter name, if a valid locator is not supplied.
      The DATA\_ARRAY component is examined to determine whether it is
      primitive or a structure.  Given the former, the second locator
      returned is the same as that to the IMAGE structure; on the other
      hand, DATA\_ARRAY is tested for being a simple ARRAY, if it is not
      an error status is set, if it is the second locator returned
      points to the DATA\_ARRAY structure.  The simple ARRAY structure
      is searched for origin and bad-pixel information.  Should the
      origin be not at 0 for each dimension, and/or the bad-pixel flag
      be set to false, warning messages are made.

      It will not handle other NDF variants save report an error.
   }
   \sstinvocation{
      CALL KPG1\_GETIM( PARNAM, LOCAT, DATLOC, DNAME, ORIGIN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARNAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Parameter name associated with the input IMAGE-type
         structure.  If this is blank, the supplied locator, LOCAT,
         will be assumed to be the locator to the top-level of an NDF
         (IMAGE-type) structure.
      }
      \sstsubsection{
         LOCAT  = CHARACTER $*$ ( DAT\_\_SZLOC ) (Given \& Returned)
      }{
         On input when PARNAM is blank, there will be no association
         with a parameter; the locator is assumed to point at the
         top level of an NDF, and will be unchanged on exit.

         If PARNAM is non blank, the input value of LOCAT is ignored.
         On exit LOCAT is the locator to the object associated with the
         given parameter name, unless status is bad, whereupon this
         locator is annulled.
      }
      \sstsubsection{
         DATLOC  = CHARACTER $*$ ( DAT\_\_SZLOC ) (Returned)
      }{
         The locator to the structure containing the primitive form of
         the data array.  If it is the top-level of the NDF (IMAGE)
         structure, it will be a clone of LOCAT.  Either way it will
         require annulment.  If status is bad on exit this locator is
         annulled.
      }
      \sstsubsection{
         DNAME = CHARACTER $*$ ( DAT\_\_SZNAM ) (Returned)
      }{
         The name of the data array as this will be needed for access,
         and it is different depending on its location.
      }
      \sstsubsection{
         ORIGIN( DAT\_\_MXDIM ) = INTEGER (Returned)
      }{
         The origin of the data array for each dimension.  It is set to
         1 for non-existent dimensions.  This argument returned so that
         if an output NDF is being created is will not be invalidated
         because of different origins in its ARRAY-type components.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This a stop-gap routine until the remainder of KAPPA
         IMAGE-format applications are converted to NDF.
      }
   }
}
\sstroutine{
   KPG1\_GETYP
}{
   Obtains a valid HDS primitive data type via a parameter
}{
   \sstdescription{
      This routine obtains and validates an HDS primitive data type,
      including the \_CHAR$*$n and LITERAL forms.  Unamibguous
      abbreviations may be supplied.  The user is reprompted up to four
      times if the value is not one of the allowed types.
   }
   \sstinvocation{
      CALL KPG1\_GETYP( PARAM, HDSTYP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The parameter through which the value is to be obtained.  The
         parameter data type should be LITERAL or \_CHAR.
      }
      \sstsubsection{
         HDSTYP = CHARACTER $*$ ( DAT\_\_SZTYP ) (Given)
      }{
         The unabbreviated HDS primitive type obtained.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Error reports are made and flushed inside the loop if the
         \_CHAR$*$n has an invalid {\tt "}n{\tt "} value.

         \sstitem
         Bad status is returned if no valid type has been obtained.
      }
   }
}
\sstroutine{
   KPG1\_GHSTx
}{
   Calculates the histogram of an array of data
}{
   \sstdescription{
      This routine calculates the truncated histogram of an array of
      data between defined limits and in a defined number of bins.
   }
   \sstinvocation{
       CALL KPG1\_GHSTx( BAD, DIM, ARRAY, NUMBIN, VALMAX, VALMIN, HIST,
      :                 STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If .TRUE., bad pixels will be processed.  This should not be
         set to false unless the input array contains no bad pixels.
      }
      \sstsubsection{
         DIM = INTEGER (Given)
      }{
         The dimension of the array whose histogram is required.
      }
      \sstsubsection{
         ARRAY( DIM ) = ? (Given)
      }{
         The input data array.
      }
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         Number of bins used in the histogram.  For integer data types
         this should result in a bin width of at least one unit.  So for
         example, byte data should never have more than 256 bins.
      }
      \sstsubsection{
         VALMAX = ? (Given)
      }{
         Maximum data value included in the array.
      }
      \sstsubsection{
         VALMIN = ? (Given)
      }{
         Minimum data value included in the array.
      }
      \sstsubsection{
         HIST( NUMBIN ) = INTEGER (Returned)
      }{
         Array containing the histogram.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, R, I, UB, UW, or W as appropriate.  The
         arguments ARRAY, VALMAX, and VALMIN must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_GHSTx
}{
   Calculates the histogram of an array of data
}{
   \sstdescription{
      This routine calculates the truncated histogram of an array of
      data between defined limits and in a defined number of bins.
   }
   \sstinvocation{
       CALL KPG1\_GHSTx( BAD, DIM, ARRAY, NUMBIN, VALMAX, VALMIN, HIST,
      :                 STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If .TRUE., bad pixels will be processed.  This should not be
         set to false unless the input array contains no bad pixels.
      }
      \sstsubsection{
         DIM = INTEGER (Given)
      }{
         The dimension of the array whose histogram is required.
      }
      \sstsubsection{
         ARRAY( DIM ) = ? (Given)
      }{
         The input data array.
      }
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         Number of bins used in the histogram.  For integer data types
         this should result in a bin width of at least one unit.  So for
         example, byte data should never have more than 256 bins.
      }
      \sstsubsection{
         VALMAX = ? (Given)
      }{
         Maximum data value included in the array.
      }
      \sstsubsection{
         VALMIN = ? (Given)
      }{
         Minimum data value included in the array.
      }
      \sstsubsection{
         HIST( NUMBIN ) = INTEGER (Returned)
      }{
         Array containing the histogram.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, R, I, UB, UW, or W as appropriate.  The
         arguments ARRAY, VALMAX, and VALMIN must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_GHSTx
}{
   Calculates the histogram of an array of data
}{
   \sstdescription{
      This routine calculates the truncated histogram of an array of
      data between defined limits and in a defined number of bins.
   }
   \sstinvocation{
       CALL KPG1\_GHSTx( BAD, DIM, ARRAY, NUMBIN, VALMAX, VALMIN, HIST,
      :                 STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If .TRUE., bad pixels will be processed.  This should not be
         set to false unless the input array contains no bad pixels.
      }
      \sstsubsection{
         DIM = INTEGER (Given)
      }{
         The dimension of the array whose histogram is required.
      }
      \sstsubsection{
         ARRAY( DIM ) = ? (Given)
      }{
         The input data array.
      }
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         Number of bins used in the histogram.  For integer data types
         this should result in a bin width of at least one unit.  So for
         example, byte data should never have more than 256 bins.
      }
      \sstsubsection{
         VALMAX = ? (Given)
      }{
         Maximum data value included in the array.
      }
      \sstsubsection{
         VALMIN = ? (Given)
      }{
         Minimum data value included in the array.
      }
      \sstsubsection{
         HIST( NUMBIN ) = INTEGER (Returned)
      }{
         Array containing the histogram.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, R, I, UB, UW, or W as appropriate.  The
         arguments ARRAY, VALMAX, and VALMIN must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_GHSTx
}{
   Calculates the histogram of an array of data
}{
   \sstdescription{
      This routine calculates the truncated histogram of an array of
      data between defined limits and in a defined number of bins.
   }
   \sstinvocation{
       CALL KPG1\_GHSTx( BAD, DIM, ARRAY, NUMBIN, VALMAX, VALMIN, HIST,
      :                 STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If .TRUE., bad pixels will be processed.  This should not be
         set to false unless the input array contains no bad pixels.
      }
      \sstsubsection{
         DIM = INTEGER (Given)
      }{
         The dimension of the array whose histogram is required.
      }
      \sstsubsection{
         ARRAY( DIM ) = ? (Given)
      }{
         The input data array.
      }
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         Number of bins used in the histogram.  For integer data types
         this should result in a bin width of at least one unit.  So for
         example, byte data should never have more than 256 bins.
      }
      \sstsubsection{
         VALMAX = ? (Given)
      }{
         Maximum data value included in the array.
      }
      \sstsubsection{
         VALMIN = ? (Given)
      }{
         Minimum data value included in the array.
      }
      \sstsubsection{
         HIST( NUMBIN ) = INTEGER (Returned)
      }{
         Array containing the histogram.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, R, I, UB, UW, or W as appropriate.  The
         arguments ARRAY, VALMAX, and VALMIN must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_GHSTx
}{
   Calculates the histogram of an array of data
}{
   \sstdescription{
      This routine calculates the truncated histogram of an array of
      data between defined limits and in a defined number of bins.
   }
   \sstinvocation{
       CALL KPG1\_GHSTx( BAD, DIM, ARRAY, NUMBIN, VALMAX, VALMIN, HIST,
      :                 STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If .TRUE., bad pixels will be processed.  This should not be
         set to false unless the input array contains no bad pixels.
      }
      \sstsubsection{
         DIM = INTEGER (Given)
      }{
         The dimension of the array whose histogram is required.
      }
      \sstsubsection{
         ARRAY( DIM ) = ? (Given)
      }{
         The input data array.
      }
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         Number of bins used in the histogram.  For integer data types
         this should result in a bin width of at least one unit.  So for
         example, byte data should never have more than 256 bins.
      }
      \sstsubsection{
         VALMAX = ? (Given)
      }{
         Maximum data value included in the array.
      }
      \sstsubsection{
         VALMIN = ? (Given)
      }{
         Minimum data value included in the array.
      }
      \sstsubsection{
         HIST( NUMBIN ) = INTEGER (Returned)
      }{
         Array containing the histogram.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, R, I, UB, UW, or W as appropriate.  The
         arguments ARRAY, VALMAX, and VALMIN must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_GHSTx
}{
   Calculates the histogram of an array of data
}{
   \sstdescription{
      This routine calculates the truncated histogram of an array of
      data between defined limits and in a defined number of bins.
   }
   \sstinvocation{
       CALL KPG1\_GHSTx( BAD, DIM, ARRAY, NUMBIN, VALMAX, VALMIN, HIST,
      :                 STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If .TRUE., bad pixels will be processed.  This should not be
         set to false unless the input array contains no bad pixels.
      }
      \sstsubsection{
         DIM = INTEGER (Given)
      }{
         The dimension of the array whose histogram is required.
      }
      \sstsubsection{
         ARRAY( DIM ) = ? (Given)
      }{
         The input data array.
      }
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         Number of bins used in the histogram.  For integer data types
         this should result in a bin width of at least one unit.  So for
         example, byte data should never have more than 256 bins.
      }
      \sstsubsection{
         VALMAX = ? (Given)
      }{
         Maximum data value included in the array.
      }
      \sstsubsection{
         VALMIN = ? (Given)
      }{
         Minimum data value included in the array.
      }
      \sstsubsection{
         HIST( NUMBIN ) = INTEGER (Returned)
      }{
         Array containing the histogram.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, R, I, UB, UW, or W as appropriate.  The
         arguments ARRAY, VALMAX, and VALMIN must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_GHSTx
}{
   Calculates the histogram of an array of data
}{
   \sstdescription{
      This routine calculates the truncated histogram of an array of
      data between defined limits and in a defined number of bins.
   }
   \sstinvocation{
       CALL KPG1\_GHSTx( BAD, DIM, ARRAY, NUMBIN, VALMAX, VALMIN, HIST,
      :                 STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If .TRUE., bad pixels will be processed.  This should not be
         set to false unless the input array contains no bad pixels.
      }
      \sstsubsection{
         DIM = INTEGER (Given)
      }{
         The dimension of the array whose histogram is required.
      }
      \sstsubsection{
         ARRAY( DIM ) = ? (Given)
      }{
         The input data array.
      }
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         Number of bins used in the histogram.  For integer data types
         this should result in a bin width of at least one unit.  So for
         example, byte data should never have more than 256 bins.
      }
      \sstsubsection{
         VALMAX = ? (Given)
      }{
         Maximum data value included in the array.
      }
      \sstsubsection{
         VALMIN = ? (Given)
      }{
         Minimum data value included in the array.
      }
      \sstsubsection{
         HIST( NUMBIN ) = INTEGER (Returned)
      }{
         Array containing the histogram.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, R, I, UB, UW, or W as appropriate.  The
         arguments ARRAY, VALMAX, and VALMIN must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_GILST
}{
   Selects integers within a range of values
}{
   \sstdescription{
      This routine selects integer numbers from LONUM to UPNUM. The
      routine gets a character string from the user and parses it to
      extract the specified numbers. The default selection is the all
      integers within the range LONUM to UPNUM.
   }
   \sstinvocation{
      CALL KPG1\_GILST( LONUM, UPNUM, MAXLIN, PARAM, FLAG, NUMBER,
                       NDISP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LONUM = INTEGER (Given)
      }{
         The lower limit of the selection range.
      }
      \sstsubsection{
         UPNUM = INTEGER (Given)
      }{
         The upper limit of the selection range.
      }
      \sstsubsection{
         MAXLIN = INTEGER (Given)
      }{
         The max. number of numbers can be selected.
      }
      \sstsubsection{
         PARAM = CHARACTER$*$($*$) (Given)
      }{
         The name of the parameter used to get the number specification
         from the user. It can be a list, separated by commas,
         comprising any reasonable combination of the following formats:

            ALL or $*$ - All integers between 1 and NUM

            xx,yy,zz - A list of integers.

            xx:yy - All integers between xx and yy inclusively. When xx
                    is omitted the range begins from 1, when yy is
                    omitted the range ends with UPNUM.

         Any number can be specified more than once but it has the same
         effect as just entering it once.
      }
      \sstsubsection{
         FLAG( LONUM : UPNUM ) = INTEGER (Returned)
      }{
         A temporary flag array used to flag the number which has been
         selected.
      }
      \sstsubsection{
         NUMBER( MAXLIN ) = INTEGER (Returned)
      }{
         The selected numbers.
      }
      \sstsubsection{
         NDISP = INTEGER (Returned)
      }{
         The number of selected numbers.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_GKEYx
}{
   Plots a colour-table key and title in the current SGS zone
}{
   \sstdescription{
      This subroutine draws a key in the current zone, consisting of a
      title and an equally spaced selection of the colour-table levels,
      each of which is annotated with the mean value corresponding to
      it.  Although it will work with colour it is intended for use in
      a grey-scale plot.  It assumes a linear mapping between data
      value and colour index.
   }
   \sstinvocation{
      CALL KPG1\_GKEYx( NLEVK, LEVL, LEVU, ZKEY, RMIN, RMAX, TITLE,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NLEVK = INTEGER (Given)
      }{
         Number of colour indices to be plotted up to 16.
      }
      \sstsubsection{
         LEVL = INTEGER (Given)
      }{
         Upper colour index used in the plot itself.
      }
      \sstsubsection{
         LEVU = INTEGER (Given)
      }{
         Upper colour index used in the plot itself.
      }
      \sstsubsection{
         ZKEY = REAL (Given)
      }{
         The fraction (to the right) of the square zone that will plot
         the key (about 0.15 to 0.2 produces acceptable results.)
      }
      \sstsubsection{
         RMIN = ? (Given)
      }{
         Value corresponding to LEVL in the plot.  (Black in a
         grey-scale plot.)
      }
      \sstsubsection{
         RMAX = ? (Given)
      }{
         Value corresponding to LEVU in the plot.  (White in a
         grey-scale plot.)
      }
      \sstsubsection{
         TITLE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Title, the maximum length depends on ZKEY; for ZKEY=0.2 only
         the first 25 characters will be displayed.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW or W as appropriate.  The
         data limits supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_GKEYx
}{
   Plots a colour-table key and title in the current SGS zone
}{
   \sstdescription{
      This subroutine draws a key in the current zone, consisting of a
      title and an equally spaced selection of the colour-table levels,
      each of which is annotated with the mean value corresponding to
      it.  Although it will work with colour it is intended for use in
      a grey-scale plot.  It assumes a linear mapping between data
      value and colour index.
   }
   \sstinvocation{
      CALL KPG1\_GKEYx( NLEVK, LEVL, LEVU, ZKEY, RMIN, RMAX, TITLE,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NLEVK = INTEGER (Given)
      }{
         Number of colour indices to be plotted up to 16.
      }
      \sstsubsection{
         LEVL = INTEGER (Given)
      }{
         Upper colour index used in the plot itself.
      }
      \sstsubsection{
         LEVU = INTEGER (Given)
      }{
         Upper colour index used in the plot itself.
      }
      \sstsubsection{
         ZKEY = REAL (Given)
      }{
         The fraction (to the right) of the square zone that will plot
         the key (about 0.15 to 0.2 produces acceptable results.)
      }
      \sstsubsection{
         RMIN = ? (Given)
      }{
         Value corresponding to LEVL in the plot.  (Black in a
         grey-scale plot.)
      }
      \sstsubsection{
         RMAX = ? (Given)
      }{
         Value corresponding to LEVU in the plot.  (White in a
         grey-scale plot.)
      }
      \sstsubsection{
         TITLE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Title, the maximum length depends on ZKEY; for ZKEY=0.2 only
         the first 25 characters will be displayed.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW or W as appropriate.  The
         data limits supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_GKEYx
}{
   Plots a colour-table key and title in the current SGS zone
}{
   \sstdescription{
      This subroutine draws a key in the current zone, consisting of a
      title and an equally spaced selection of the colour-table levels,
      each of which is annotated with the mean value corresponding to
      it.  Although it will work with colour it is intended for use in
      a grey-scale plot.  It assumes a linear mapping between data
      value and colour index.
   }
   \sstinvocation{
      CALL KPG1\_GKEYx( NLEVK, LEVL, LEVU, ZKEY, RMIN, RMAX, TITLE,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NLEVK = INTEGER (Given)
      }{
         Number of colour indices to be plotted up to 16.
      }
      \sstsubsection{
         LEVL = INTEGER (Given)
      }{
         Upper colour index used in the plot itself.
      }
      \sstsubsection{
         LEVU = INTEGER (Given)
      }{
         Upper colour index used in the plot itself.
      }
      \sstsubsection{
         ZKEY = REAL (Given)
      }{
         The fraction (to the right) of the square zone that will plot
         the key (about 0.15 to 0.2 produces acceptable results.)
      }
      \sstsubsection{
         RMIN = ? (Given)
      }{
         Value corresponding to LEVL in the plot.  (Black in a
         grey-scale plot.)
      }
      \sstsubsection{
         RMAX = ? (Given)
      }{
         Value corresponding to LEVU in the plot.  (White in a
         grey-scale plot.)
      }
      \sstsubsection{
         TITLE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Title, the maximum length depends on ZKEY; for ZKEY=0.2 only
         the first 25 characters will be displayed.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW or W as appropriate.  The
         data limits supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_GKEYx
}{
   Plots a colour-table key and title in the current SGS zone
}{
   \sstdescription{
      This subroutine draws a key in the current zone, consisting of a
      title and an equally spaced selection of the colour-table levels,
      each of which is annotated with the mean value corresponding to
      it.  Although it will work with colour it is intended for use in
      a grey-scale plot.  It assumes a linear mapping between data
      value and colour index.
   }
   \sstinvocation{
      CALL KPG1\_GKEYx( NLEVK, LEVL, LEVU, ZKEY, RMIN, RMAX, TITLE,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NLEVK = INTEGER (Given)
      }{
         Number of colour indices to be plotted up to 16.
      }
      \sstsubsection{
         LEVL = INTEGER (Given)
      }{
         Upper colour index used in the plot itself.
      }
      \sstsubsection{
         LEVU = INTEGER (Given)
      }{
         Upper colour index used in the plot itself.
      }
      \sstsubsection{
         ZKEY = REAL (Given)
      }{
         The fraction (to the right) of the square zone that will plot
         the key (about 0.15 to 0.2 produces acceptable results.)
      }
      \sstsubsection{
         RMIN = ? (Given)
      }{
         Value corresponding to LEVL in the plot.  (Black in a
         grey-scale plot.)
      }
      \sstsubsection{
         RMAX = ? (Given)
      }{
         Value corresponding to LEVU in the plot.  (White in a
         grey-scale plot.)
      }
      \sstsubsection{
         TITLE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Title, the maximum length depends on ZKEY; for ZKEY=0.2 only
         the first 25 characters will be displayed.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW or W as appropriate.  The
         data limits supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_GKEYx
}{
   Plots a colour-table key and title in the current SGS zone
}{
   \sstdescription{
      This subroutine draws a key in the current zone, consisting of a
      title and an equally spaced selection of the colour-table levels,
      each of which is annotated with the mean value corresponding to
      it.  Although it will work with colour it is intended for use in
      a grey-scale plot.  It assumes a linear mapping between data
      value and colour index.
   }
   \sstinvocation{
      CALL KPG1\_GKEYx( NLEVK, LEVL, LEVU, ZKEY, RMIN, RMAX, TITLE,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NLEVK = INTEGER (Given)
      }{
         Number of colour indices to be plotted up to 16.
      }
      \sstsubsection{
         LEVL = INTEGER (Given)
      }{
         Upper colour index used in the plot itself.
      }
      \sstsubsection{
         LEVU = INTEGER (Given)
      }{
         Upper colour index used in the plot itself.
      }
      \sstsubsection{
         ZKEY = REAL (Given)
      }{
         The fraction (to the right) of the square zone that will plot
         the key (about 0.15 to 0.2 produces acceptable results.)
      }
      \sstsubsection{
         RMIN = ? (Given)
      }{
         Value corresponding to LEVL in the plot.  (Black in a
         grey-scale plot.)
      }
      \sstsubsection{
         RMAX = ? (Given)
      }{
         Value corresponding to LEVU in the plot.  (White in a
         grey-scale plot.)
      }
      \sstsubsection{
         TITLE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Title, the maximum length depends on ZKEY; for ZKEY=0.2 only
         the first 25 characters will be displayed.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW or W as appropriate.  The
         data limits supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_GKEYx
}{
   Plots a colour-table key and title in the current SGS zone
}{
   \sstdescription{
      This subroutine draws a key in the current zone, consisting of a
      title and an equally spaced selection of the colour-table levels,
      each of which is annotated with the mean value corresponding to
      it.  Although it will work with colour it is intended for use in
      a grey-scale plot.  It assumes a linear mapping between data
      value and colour index.
   }
   \sstinvocation{
      CALL KPG1\_GKEYx( NLEVK, LEVL, LEVU, ZKEY, RMIN, RMAX, TITLE,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NLEVK = INTEGER (Given)
      }{
         Number of colour indices to be plotted up to 16.
      }
      \sstsubsection{
         LEVL = INTEGER (Given)
      }{
         Upper colour index used in the plot itself.
      }
      \sstsubsection{
         LEVU = INTEGER (Given)
      }{
         Upper colour index used in the plot itself.
      }
      \sstsubsection{
         ZKEY = REAL (Given)
      }{
         The fraction (to the right) of the square zone that will plot
         the key (about 0.15 to 0.2 produces acceptable results.)
      }
      \sstsubsection{
         RMIN = ? (Given)
      }{
         Value corresponding to LEVL in the plot.  (Black in a
         grey-scale plot.)
      }
      \sstsubsection{
         RMAX = ? (Given)
      }{
         Value corresponding to LEVU in the plot.  (White in a
         grey-scale plot.)
      }
      \sstsubsection{
         TITLE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Title, the maximum length depends on ZKEY; for ZKEY=0.2 only
         the first 25 characters will be displayed.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW or W as appropriate.  The
         data limits supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_GKEYx
}{
   Plots a colour-table key and title in the current SGS zone
}{
   \sstdescription{
      This subroutine draws a key in the current zone, consisting of a
      title and an equally spaced selection of the colour-table levels,
      each of which is annotated with the mean value corresponding to
      it.  Although it will work with colour it is intended for use in
      a grey-scale plot.  It assumes a linear mapping between data
      value and colour index.
   }
   \sstinvocation{
      CALL KPG1\_GKEYx( NLEVK, LEVL, LEVU, ZKEY, RMIN, RMAX, TITLE,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NLEVK = INTEGER (Given)
      }{
         Number of colour indices to be plotted up to 16.
      }
      \sstsubsection{
         LEVL = INTEGER (Given)
      }{
         Upper colour index used in the plot itself.
      }
      \sstsubsection{
         LEVU = INTEGER (Given)
      }{
         Upper colour index used in the plot itself.
      }
      \sstsubsection{
         ZKEY = REAL (Given)
      }{
         The fraction (to the right) of the square zone that will plot
         the key (about 0.15 to 0.2 produces acceptable results.)
      }
      \sstsubsection{
         RMIN = ? (Given)
      }{
         Value corresponding to LEVL in the plot.  (Black in a
         grey-scale plot.)
      }
      \sstsubsection{
         RMAX = ? (Given)
      }{
         Value corresponding to LEVU in the plot.  (White in a
         grey-scale plot.)
      }
      \sstsubsection{
         TITLE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Title, the maximum length depends on ZKEY; for ZKEY=0.2 only
         the first 25 characters will be displayed.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW or W as appropriate.  The
         data limits supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_GNLBU
}{
   Obtains an axis annotation for NDF data or variance
}{
   \sstdescription{
      This routine obtains an axis annotation from the parameter system.
      The suggested default has the form {\tt "}label (units){\tt "} when the NDF
      has both a label and units, or {\tt "}label{\tt "} if there is a label but not
      units.  When neither component is present the default is the
      component name follwed by {\tt "} values{\tt "}.  The units are squared for
      the variance component.  If a bad status, other than abort, is
      returned by the parameter system when getting the value, the
      error is annulled and the output annotation is the suggested
      default value.
   }
   \sstinvocation{
      CALL KPG1\_GNLBU( NDF, PNLAB, COMP, AXSLAB, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDF = INTEGER (Given)
      }{
         The NDF identifier.
      }
      \sstsubsection{
         PNLAB = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the ADAM parameter from which the annotation will
         be obtained.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the NDF array component: {\tt '}DATA{\tt '}, {\tt '}QUALITY{\tt '}, {\tt '}VARIANCE{\tt '},
         or {\tt '}ERROR{\tt '}, though it is used literally and not checked to
         be a member of this set.
      }
      \sstsubsection{
         AXSLAB = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The annotation obtained from the parameter system.  The dynamic
         default is limited to 128 characters.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_GNTIT
}{
   Obtains a title using the NDF title as the suggested default
}{
   \sstdescription{
      This routine obtains a title from the parameter system.  The
      suggested default is title of the input NDF if it has one,
      otherwise a supplied default is used.  If a bad status, other
      than abort, is returned by the parameter system when getting the
      value, the error is annulled and the output title is the default
      value.
   }
   \sstinvocation{
      CALL KPG1\_GNTIT( NDF, PNTITL, DEFAUL, TITLE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDF = INTEGER (Given)
      }{
         The NDF identifier.
      }
      \sstsubsection{
         PNTITL = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the ADAM parameter from which the title will be
         obtained.
      }
      \sstsubsection{
         DEFAUL = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The suggested default when the NDF does not have a title, or
         the actual value returned when a null (!) value or any other
         non-abort bad status is obtained from the parameter system.
      }
      \sstsubsection{
         TITLE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The title obtained from the parameter system.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_GPCOL
}{
   Obtains the red, green and blue intensities of a colour by value
   or by name for the standard colour set
}{
   \sstdescription{
      This routine obtains a colour via the ADAM parameter system.
      The colour may be either a named colour from the colour set; or
      red, green, and blue intensities separated by commas or spaces.
      If the named colour does not exist, or there is a problem
      extracting and converting the RGB values, or the RGB values are
      out of the range 0.0 to 1.0, an error is reported immediately
      and the user is prompted for another value.
   }
   \sstinvocation{
      CALL KPG1\_GPCOL( PNCOL, RGBINT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNCOL = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the ADAM parameter used to obtain the colour.  It
         must be of type \_CHAR or LITERAL.
      }
      \sstsubsection{
         RGBINT( 3 ) = REAL (Returned)
      }{
         The red, green and blue intensities of the selected colour.
         They are normalised to the range 0.0 to 1.0.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_GRAPH
}{
   Draws a line graph
}{
   \sstdescription{
      Opens a graphics device and draws a graph displaying a supplied
      set of points. Each point is defined by an X and Y value, plus an
      optional error bar. An AST Plot is returned so that the calling
      application can add further graphics to the plot if needed. When
      complete, the calling application should annul the Plot, and close
      the workstation:

        CALL AST\_ANNUL( IPLOT, STATUS )
        CALL AGP\_DEASS( {\tt '}DEVICE{\tt '}, .FALSE., STATUS )
   }
   \sstinvocation{
      CALL KPG1\_GRAPH( N, X, Y, NSIGMA, YSIGMA, XLAB, YLAB, TTL, XSYM,
                       YSYM, MODE, NULL, XL, XR, YB, YT, APP, QUIET,
                       LMODE, IPLOT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         No. of points
      }
      \sstsubsection{
         X( N ) = REAL (Given)
      }{
         X value at each point.
      }
      \sstsubsection{
         Y( N ) = REAL (Given)
      }{
         Y value at each point.
      }
      \sstsubsection{
         NSIGMA = REAL (Given)
      }{
         Controls the length of the vertical error bars. A value of zero
         suppresses error bars. Otherwise error bars are drawn which extend
         by from Y - NSIGMA$*$YSIGMA to Y $+$ NSIGMA$*$YSIGMA.
      }
      \sstsubsection{
         YSIGMA( N ) = REAL (Given)
      }{
         The standard deviation associated with each Y value.
      }
      \sstsubsection{
         XLAB = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A default label for the X axis. Only used if the user does not
         supply an alternative. Trailing spaces are ignored.
      }
      \sstsubsection{
         YLAB = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A default label for the Y axis. Only used if the user does not
         supply an alternative. Trailing spaces are ignored.
      }
      \sstsubsection{
         TTL = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A default title for the plot. Only used if the user does not
         supply an alternative.
      }
      \sstsubsection{
         XSYM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The default symbol for the horizontal axis. Only used if the user
         does not supply an alternative. This is not displayed on the
         screen, but will be stored with the Plot in the AGI database and
         (for instance) used by CURSOR as axis symbols when displaying the
         cursor positions on the screen.
      }
      \sstsubsection{
         YSYM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The default symbol for the vertical axis. Only used if the user
         does not supply an alternative. This is not displayed on the
         screen, but will be stored with the Plot in the AGI database and
         (for instance) used by CURSOR as axis symbols when displaying the
         cursor positions on the screen.
      }
      \sstsubsection{
         MODE = INTEGER (Given)
      }{
         Determines the way in which the data points are represented:
             1 - A {\tt "}staircase{\tt "} histogram, in which each horizontal line is
                 centred on the X position.
             2 - The points are joined by straight lines.
             3 - A marker is placed at each point.
             4 - (not used)
             5 - A {\tt "}chain{\tt "} in which each point is marker by a marker and also
                 join by straight lines to its neighbouring points.
      }
      \sstsubsection{
         NULL = LOGICAL (Given)
      }{
         If .TRUE., then the user may supply a null (!) value for most of the
         parameters accessed by this routine to indicate that nothing is to
         be plotted. In this case, no error is returned. Otherwise, a
         PAR\_\_NULL error status is returned if a null value is supplied.
      }
      \sstsubsection{
         XL = REAL (Given)
      }{
         The default value for the XLEFT parameter. If VAL\_\_BADR is
         supplied, the minimum of the X values is used (plus a small
         margin).
      }
      \sstsubsection{
         XR = REAL (Given)
      }{
         The default value for the XRIGHT parameter. If VAL\_\_BADR is
         supplied, the maximum of the X values is used (plus a small
         margin).
      }
      \sstsubsection{
         YB = REAL (Given)
      }{
         The default value for the YBOT parameter. If VAL\_\_BADR is
         supplied, the minimum of the low end of the Y error bars is
         used (plus a small margin).
      }
      \sstsubsection{
         YT = REAL (Given)
      }{
         The default value for the YTOP parameter. If VAL\_\_BADR is
         supplied, the maximum of the high end of the Y error bars is
         used (plus a small margin).
      }
      \sstsubsection{
         APP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the application in the form {\tt "}$<$package$>$\_$<$application$>${\tt "}.
         E.g. {\tt "}KAPPA\_NORMALIZE{\tt "}.
      }
      \sstsubsection{
         QUIET = LOGICAL (Given)
      }{
         If .FALSE., a message is displayed indicating the number of
         points which were plotted. If .TRUE., nothing is displayed on
         the alpha screen.
      }
      \sstsubsection{
         LMODE = LOGICAL (Given)
      }{
         If .TRUE., then the user is given the chance to specify the
         default vertical bounds for the plot using parameter LMODE. If
         .FALSE., the supplied bounds (YB, YT ) are used, and the
         eqivalent of {\tt "}Extended{\tt "} LMODE is used for any bounds which are
         not supplied.
      }
      \sstsubsection{
         IPLOT = INTEGER (Returned)
      }{
         The AST Plot used to do the drawing.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If an error occurs, or if no graphics is produced because the
         user supplied a null value for a parameter, IPLOT is returned equal
         to AST\_\_NULL, and PGPLOT is shut down.
      }
   }
   \sstdiytopic{
      Environment Parameters
   }{
      Various envirnment parameter names are used by this routine,
      to encourage uniformity in parameter naming, and behaviour.
      See KPG1\_GRPHW for details.
   }
}
\sstroutine{
   KPG1\_GRLM1
}{
   Find the default limits for a graph axis
}{
   \sstdescription{
      This routine returns one or both default limits for a graph axis.
      Any limits which are supplied by the calling routine are used as
      supplied. The user is only allowed to over-ride limits which are
      supplied as VAL\_\_BADR. The way in which these limits are chosen is
      specified by the user through the parameter specified by PARAM.
      This parameter can take the following values:

      \sstitemlist{

         \sstitem
            {\tt "}Range{\tt "} -- LIM1 and LIM2 are returned equal to the lowest and
            highest supplied data values (including error bars).

         \sstitem
            {\tt "}Extended{\tt "} -- LIM1 and LIM2 are returned equal to the lowest and
            highest supplied data values (including error bars), extended to
            give a margin of 2.5\% of the total data range at each end.

         \sstitem
            {\tt "}Extended,10,5{\tt "} -- Like {\tt "}Extended{\tt "}, except the margins at the
            two ends are specified as a pair of numerical value in the second
            and third elements of the array. These values are percentages of
            the total data range. So, {\tt "}Extended,10,5{\tt "} includes a margin of 10\%
            of the total data range in LIM1, and 5\% in LIM2. If only one
            numerical value is given, the same value is used for both limits. If
            no value is given, both limits default to 2.5. {\tt "}Range{\tt "} is equivalent
            to {\tt "}Extended,0,0{\tt "}.

         \sstitem
            {\tt "}Percentiles,5,95{\tt "} -- The second and third elements of the array
            are interpreted as percentiles. For instance, {\tt "}Perc,5,95{\tt "} causes 5\%
            of the data points (ignoring error bars) to be below LIM1, and 10\%
            to be above the LIM2. If only 1 value (p1) is supplied, the other
            one, p2, defaults to (100 - p1). If no values are supplied, p1 and
            p2 default to 5 and 95.

         \sstitem
            {\tt "}Sigma,2,3{\tt "} -- The second and third elements of the array are
            interpreted as multiples of the standard deviation of the data
            values (ignoring error bars). For instance, {\tt "}S,2,3{\tt "} causes the
            LIM1 to be the mean of the data values, minus two sigma, and LIM2
            to be the mean plus three sigma. If only 1 value is supplied, the
            same value is used for both limits. If no values are supplied, both
            values default to 3.0.

      }
      The above strings can be abbreviated to one character.

      If the parameter name is supplied as blank, then {\tt "}Extended{\tt "} is
      assumed (i.e. LIM1 and LIM2 are chosen so that the axis encompasses
      the entire data range including error bars, with 2.5\% margin at each
      end).

      If only 1 limit is required (i.e. if LIM1 or LIM2 are supplied not
      equal to VAL\_\_BADR), then only 1 numerical value can be supplied
      in the above limit descriptions.
   }
   \sstinvocation{
      CALL KPG1\_GRLM1( PARAM, N, D1, D2, NSIGMA, SIGMA, LIM1, LIM2,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use to get the method for chosing
         the default limits for the axis. May be blank.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         No. of points
      }
      \sstsubsection{
         D1( N ) = REAL (Given)
      }{
         The central data value at each point.
      }
      \sstsubsection{
         D2( N ) = REAL (Given)
      }{
         An associated mask array. D1( I ) is only used if both D1( I ) and
         D2( I ) are not equal to VAL\_\_BADR.
      }
      \sstsubsection{
         NSIGMA = REAL (Given)
      }{
         Controls the length of the error bars. The error bars are
         assumed to extended from D1( I ) - NSIGMA$*$SIGMA( I ) to
         D1( I ) $+$ NSIGMA$*$SIGMA( I ). A value of zero suppresses error
         bars.
      }
      \sstsubsection{
         SIGMA( N ) = REAL (Given)
      }{
         The standard deviation associated with each Y value. Not
         accessed if NSIGMA is zero.
      }
      \sstsubsection{
         LIM1 = REAL (Given and Returned)
      }{
         The chosen low data limit. Only returned if a value of VAL\_\_BADR
         is supplied, Otherwise, the supplied value is returned unchanged.
      }
      \sstsubsection{
         LIM2 = REAL (Given and Returned)
      }{
         The chosen high data limit. Only returned if a value of VAL\_\_BADR
         is supplied, Otherwise, the supplied value is returned unchanged.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_GRLM2
}{
   Find the default limits for a graph axis
}{
   \sstdescription{
      This routine returns the default limits for a graph axis. The
      way in which the limits are chosen is specified by the user through
      the parameter specified by PARAM. This parameter can take the
      following values:

      \sstitemlist{

         \sstitem
            {\tt "}Range{\tt "} -- LIM1 and LIM2 are returned equal to the lowest and
            highest supplied data values (including error bars).

         \sstitem
            {\tt "}Extended{\tt "} -- LIM1 and LIM2 are returned equal to the lowest and
            highest supplied data values (including error bars), extended to
            give a margin of 2.5\% of the total data range at each end.

         \sstitem
            {\tt "}Extended,10,5{\tt "} -- Like {\tt "}Extended{\tt "}, except the margins at the
            two ends are specified as a pair of numerical value in the second
            and third elements of the array. These values are percentages of
            the total data range. So, {\tt "}Extended,10,5{\tt "} includes a margin of 10\%
            of the total data range in LIM1, and 5\% in LIM2. If only one
            numerical value is given, the same value is used for both limits. If
            no value is given, both limits default to 2.5. {\tt "}Range{\tt "} is equivalent
            to {\tt "}Extended,0,0{\tt "}.

         \sstitem
            {\tt "}Percentiles,5,95{\tt "} -- The second and third elements of the array
            are interpreted as percentiles. For instance, {\tt "}Perc,5,95{\tt "} causes 5\%
            of the data points (ignoring error bars) to be below LIM1, and 10\%
            to be above the LIM2. If only 1 value (p1) is supplied, the other
            one, p2, defaults to (100 - p1). If no values are supplied, p1 and
            p2 default to 5 and 95.

         \sstitem
            {\tt "}Sigma,2,3{\tt "} -- The second and third elements of the array are
            interpreted as multiples of the standard deviation of the data
            values (ignoring error bars). For instance, {\tt "}S,2,3{\tt "} causes the
            LIM1 to be the mean of the data values, minus two sigma, and LIM2
            to be the mean plus three sigma. If only 1 value is supplied, the
            same value is used for both limits. If no values are supplied, both
            values default to 3.0.

      }
      The above strings can be abbreviated to one character.

      If the parameter name is supplied as blank, then {\tt "}Extended{\tt "} is
      assumed (i.e. LIM1 and LIM2 are chosen so that the axis encompasses
      the entire data range including error bars, with 2.5\% margin at each
      end).

      If only 1 limit is required (i.e. if LIM1 or LIM2 are supplied not
      equal to VAL\_\_BADD), then only 1 numerical value can be supplied
      in the above limit descriptions.
   }
   \sstinvocation{
      CALL KPG1\_GRLM2( PARAM, N, D1, D2, USEBAR, BAR, LIM1, LIM2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use to get the method for chosing
         the default limits for the axis. May be blank.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         No. of points
      }
      \sstsubsection{
         D1( N ) = DOUBLE PRECISION (Given)
      }{
         The central data value at each point.
      }
      \sstsubsection{
         D2( N ) = DOUBLE PRECISION (Given)
      }{
         An associated mask array. D1( I ) is only used if both D1( I ) and
         D2( I ) are not equal to VAL\_\_BADD.
      }
      \sstsubsection{
         USEBAR = LOGICAL (Given)
      }{
         Should BAR be used?
      }
      \sstsubsection{
         BAR( N,2 ) = DOUBLE PRECISION (Given)
      }{
         The upper and lower ends of each error bar. Assumed equal to D1
         if USEBAR is .FALSE. (i.e. no error bars).
      }
      \sstsubsection{
         LIM1 = DOUBLE PRECISION (Given and Returned)
      }{
         The chosen low data limit. Only returned if a value of VAL\_\_BADD
         is supplied, Otherwise, the supplied value is returned unchanged.
      }
      \sstsubsection{
         LIM2 = DOUBLE PRECISION (Given and Returned)
      }{
         The chosen high data limit. Only returned if a value of VAL\_\_BADD
         is supplied, Otherwise, the supplied value is returned unchanged.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_GRPHW
}{
   Draws a line graph, using supplied work arrays
}{
   \sstdescription{
      Opens a graphics device and draws a graph displaying a supplied
      set of points. Each point is defined by an X and Y value, plus an
      optional error bar. An AST Plot is returned so that the calling
      application can add further graphics to the plot if needed. When
      complete, the calling application should annul the Plot, and close
      the workstation:

        CALL AST\_ANNUL( IPLOT, STATUS )
        CALL KPG\_PGCLS( {\tt '}DEVICE{\tt '}, .FALSE., STATUS )
   }
   \sstinvocation{
      CALL KPG1\_GRPHW( N, X, Y, NSIGMA, YSIGMA, XLAB, YLAB, TTL,
                       XSYM, YSYM, MODE, NULL, XL, XR, YB, YT, APP,
                       QUIET, LMODE, DX, DY, DBAR, IPLOT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         No. of points
      }
      \sstsubsection{
         X( N ) = REAL (Given)
      }{
         X value at each point.
      }
      \sstsubsection{
         Y( N ) = REAL (Given)
      }{
         Y value at each point.
      }
      \sstsubsection{
         NSIGMA = REAL (Given)
      }{
         Controls the length of the vertical error bars. A value of zero
         suppresses error bars. Otherwise error bars are drawn which extend
         by from Y - NSIGMA$*$YSIGMA to Y $+$ NSIGMA$*$YSIGMA.
      }
      \sstsubsection{
         YSIGMA( N ) = REAL (Given)
      }{
         The standard deviation associated with each Y value. Not
         accessed if NSIGMA is zero.
      }
      \sstsubsection{
         XLAB = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A default label for the X axis. Only used if the user does not
         supply an alternative. Trailing spaces are ignored.
      }
      \sstsubsection{
         YLAB = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A default label for the Y axis. Only used if the user does not
         supply an alternative. Trailing spaces are ignored.
      }
      \sstsubsection{
         TTL = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A default title for the plot. Only used if the user does not
         supply an alternative.
      }
      \sstsubsection{
         XSYM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The default symbol for the horizontal axis. Only used if the user
         does not supply an alternative. This will be stored with the Plot
         in the AGI database and (for instance) used by CURSOR as axis
         symbols when displaying the curosir positions on the screen.
      }
      \sstsubsection{
         YSYM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The default symbol for the horizontal axis. Only used if the user
         does not supply an alternative. This will be stored with the Plot
         in the AGI database and (for instance) used by CURSOR as axis
         symbols when displaying the curosir positions on the screen.
      }
      \sstsubsection{
         MODE = INTEGER (Given)
      }{
         Determines the way in which the data points are represented:
             1 - A {\tt "}staircase{\tt "} histogram, in which each horizontal line is
                 centred on the X position.
             2 - The points are joined by straight lines.
             3 - A marker is placed at each point.
             4 - (not used)
             5 - A {\tt "}chain{\tt "} in which each point is marker by a marker and also
                 join by straight lines to its neighbouring points.
      }
      \sstsubsection{
         NULL = LOGICAL (Given)
      }{
         If .TRUE., then the user may supply a null (!) value for most of the
         parameters accessed by this routine to indicate that nothing is to
         be plotted. In this case, no error is returned. Otherwise, a
         PAR\_\_NULL error status is returned if a null value is supplied.
      }
      \sstsubsection{
         XL = REAL (Given)
      }{
         The default value for the XLEFT parameter. If VAL\_\_BADR is
         supplied, the minimum of the X values is used (plus a small
         margin).
      }
      \sstsubsection{
         XR = REAL (Given)
      }{
         The default value for the XRIGHT parameter. If VAL\_\_BADR is
         supplied, the maximum of the X values is used (plus a small
         margin).
      }
      \sstsubsection{
         YB = REAL (Given)
      }{
         The default value for the YBOT parameter. If VAL\_\_BADR is
         supplied, the minimum of the low end of the Y error bars is
         used (plus a small margin).
      }
      \sstsubsection{
         YT = REAL (Given)
      }{
         The default value for the YTOP parameter. If VAL\_\_BADR is
         supplied, the maximum of the high end of the Y error bars is
         used (plus a small margin).
      }
      \sstsubsection{
         APP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the application in the form {\tt "}$<$package$>$\_$<$application$>${\tt "}.
         E.g. {\tt "}KAPPA\_NORMALIZE{\tt "}.
      }
      \sstsubsection{
         QUIET = LOGICAL (Given)
      }{
         If .FALSE., a message is displayed indicating the number of
         points which were plotted. If .TRUE., nothing is displayed on
         the alpha screen.
      }
      \sstsubsection{
         LMODE = LOGICAL (Given)
      }{
         If .TRUE., then the user is given the chance to specify the
         default vertical bounds for the plot using parameter LMODE. If
         .FALSE., the supplied bounds (YB, YT ) are used, and the
         eqivalent of {\tt "}Extended{\tt "} LMODE is used for any bounds which are
         not supplied.
      }
      \sstsubsection{
         DX( N ) = DOUBLE PRECISION (Given and Returned)
      }{
         Work space.
      }
      \sstsubsection{
         DY( N ) = DOUBLE PRECISION (Given and Returned)
      }{
         Work space.
      }
      \sstsubsection{
         DBAR( N, 2 ) = DOUBLE PRECISION (Given and Returned)
      }{
         Work space. Not accessed if NSIGMA is zero.
      }
      \sstsubsection{
         IPLOT = INTEGER (Returned)
      }{
         The AST Plot used to do the drawing.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If an error occurs, or if no graphics is produced because the
         user supplied a null value for a parameter, IPLOT is returned equal
         to AST\_\_NULL, and PGPLOT is shut down.
      }
   }
   \sstdiytopic{
      Environment Parameters
   }{
      The following envirnment parameter names are used by this routine,
      to encourage uniformity in parameter naming, and behaviour:

         AXES = \_LOGICAL (Read)
            TRUE if annotated axes are to be produced.
         CLEAR = \_LOGICAL (Read)
            TRUE if the graphics device is to be cleared on opening.
         DEVICE = DEVICE (Read)
            The plotting device.
         LMODE = LITERAL (Read)
            If the subroutine argument LMODE is .TRUE., then parameter
            LMODE is used to specify how the default values for YBOT and
            YTOP are found. If argument LMODE is .FALSE. then {\tt "}Extended{\tt "}
            mode is always used. This parameter can take the following
            values:

      \sstitemlist{

         \sstitem
               {\tt "}Range{\tt "} -- The lowest and highest supplied data values are
               used (including error bars).

         \sstitem
               {\tt "}Extended{\tt "} -- The lowest and highest supplied data values
               are used (including error bars), extended to give a margin of
               2.5\% of the total data range at each end.

         \sstitem
               {\tt "}Extended,10,5{\tt "} -- Like {\tt "}Extended{\tt "}, except the margins at the
               two ends are specified as a pair of numerical value in the second
               and third elements of the array. These values are percentages of
               the total data range. So, {\tt "}Extended,10,5{\tt "} includes a margin of 10\%
               of the total data range in YBOT, and 5\% in YTOP. If only one
               numerical value is given, the same value is used for both limits.
               If no value is given, both limits default to 2.5. {\tt "}Range{\tt "} is
               equivalent to {\tt "}Extended,0,0{\tt "}.

         \sstitem
               {\tt "}Percentiles,5,95{\tt "} -- The second and third elements of the array
               are interpreted as percentiles. For instance, {\tt "}Perc,5,95{\tt "} causes
               5\% of the data points (ignoring error bars) to be below YBOT, and
               10\% to be above the YTOP. If only 1 value (p1) is supplied, the
               other one, p2, defaults to (100 - p1). If no values are supplied,
               p1 and p2 default to 5 and 95.

         \sstitem
               {\tt "}Sigma,2,3{\tt "} -- The second and third elements of the array are
               interpreted as multiples of the standard deviation of the data
               values (ignoring error bars). For instance, {\tt "}S,2,3{\tt "} causes the
               YBOT to be the mean of the data values, minus two sigma, and YTOP
               to be the mean plus three sigma. If only 1 value is supplied, the
               same value is used for both limits. If no values are supplied,
               both values default to 3.0.

      }
         The above strings can be abbreviated to one character.
         MARGIN( 4 ) = \_REAL (Read)
            The widths of the margins to leave for axis annotation, given
            as fractions of the corresponding dimension of the current picture.
            Four values may be given, in the order - bottom, right, top, left.
            If less than four values are given, extra values are used equal to
            the first supplied value. If these margins are too narrow any axis
            annotation may be clipped. The dynamic default is 0.15 (for all
            edges) if either annotated axes or a key are produced, and zero
            otherwise.
         MARKER = INTEGER )Read)
            The PGPLOT marker type to use. Only accessed if MODE is 3 or 5.
         STYLE = GROUP (Read)
            A description of the plotting style required. The following
            synonyms for graphical elements may be used:
            {\tt "}Err(Bars){\tt "} - Specifies colour, etc for error bars. Size(errbars)
                          scales the size of the serifs (i.e. a size value of
                          1.0 produces a default size).
            {\tt "}Sym(bols){\tt "} - Specifies colour, etc for markers (used in modes 3
                          and 5).
            {\tt "}Lin(es){\tt "}   - Specifies colour, etc for lines (used in modes 1, 2
                          and 5).
         XLEFT = \_REAL (Read)
            The axis value to place at the left hand end of the horizontal
            axis. The dynamic default is specified by argument XL. The value
            supplied may be greater than or less than the value supplied for
            XRIGHT.
         XRIGHT = \_REAL (Read)
            The axis value to place at the right hand end of the horizontal
            axis. The dynamic default is specified by argument XR. The value
            supplied may be greater than or less than the value supplied for
            XLEFT.
         YBOT = \_REAL (Read)
            The axis value to place at the bottom end of the vertical
            axis. The dynamic default is specified by argument YB. The value
            supplied may be greater than or less than the value supplied for
            YTOP.
         YTOP = \_REAL (Read)
            The axis value to place at the top end of the vertical axis.
            The dynamic default is specified by argument YT. The value
            supplied may be greater than or less than the value supplied
            for YBOT.
   }
}
\sstroutine{
   KPG1\_GTAXI
}{
   Select Frame axes using an environment parameter
}{
   \sstdescription{
      This routine returns the indices of selected axes in a supplied
      Frame. The axes to select are determined using the supplied
      environment parameter. Each axis can be specified either by giving
      its index within the Frame in the range 1 to the number of axes in
      the Frame, or by giving its symbol. If the first value supplied in
      AXES is not zero, the supplied axes are used as the dynamic default
      for the parameter. The parameter value should be given as a GRP group
      expression, with default GRP control characters.
   }
   \sstinvocation{
      CALL KPG1\_GTAXI( PARAM, FRAME, NAX, AXES, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use.
      }
      \sstsubsection{
         FRAME = INTEGER (Given)
      }{
         An AST pointer for the Frame from which axes may be chosen.
      }
      \sstsubsection{
         NAX = INTEGER (Given)
      }{
         The number of axes which must be selected.
      }
      \sstsubsection{
         AXES( NAX ) = INTEGER (Given and Returned)
      }{
         On entry, the axes to be specified as the dynamic default for the
         parameter (if AXES( 1 ) is not zero). On exit, the indices of the
         selected axes. If AXES(1) is zero the supplied values are ignored
         and a PAR\_\_NULL status value is returned if a null (!) value is
         supplied for the parameter. Otherwise, the PAR\_NULL status is
         annulled if a null value is supplied, and the supplied axes are
         returned.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Case is insignificant when comparing supplied strings with
         available axis symbols.
      }
   }
}
\sstroutine{
   KPG1\_GTAXV
}{
   Gets one or more formatted axis values from the environment
}{
   \sstdescription{
      This routine obtains one or more formatted values for a specified axis
      from the environment, using a specified parameter.

      If the string supplied for the parameter consists of a single colon,
      then a description of the Current co-ordinate Frame is displayed,
      together with an indication of the format required for each axis
      value, and a new parameter value is then obtained.
   }
   \sstinvocation{
      CALL KPG1\_GTAXV( PARAM, MXVAL, EXACT, FRAME, IAXIS, AXVAL, NVAL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use.
      }
      \sstsubsection{
         MXVAL = INTEGER (Given)
      }{
         The maximum number of values which can be supplied. It is not an
         error for less than MXVAL to be supplied. Must be no more than 20.
      }
      \sstsubsection{
         EXACT = LOGICAL( Given)
      }{
         If .TRUE., then the user must supply exactly MXVAL values, and
         he is reprompted if less than MXVAL are given. If .FALSE. then
         the user can give between 1 and MXVAL values.
      }
      \sstsubsection{
         FRAME = INTEGER (Given)
      }{
         A pointer to an AST Frame in which the axis lives.
      }
      \sstsubsection{
         IAXIS = INTEGER (Given)
      }{
         The index of the axis within the Frame for which a value is required.
      }
      \sstsubsection{
         AXVAL( MXVAL ) = DOUBLE PRECISION (Given and Returned)
      }{
         On entry, holds the axis values to use as the dynamic default for the
         parameter. On exit, holds the supplied axis value. No dynamic
         default is used if any of the supplied values is AST\_\_BAD.
      }
      \sstsubsection{
         NVAL = INTEGER (Returned)
      }{
         The number of values obtained using the parameter and returned in
         AXVAL.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If a null (!) parameter value is supplied, the supplied value of
         AXVAL is returned, and the error is annulled if the AXVAL value is
         not equal to AST\_\_BAD.

         \sstitem
         AXVAL is left unchanged if an error has already occurred.

         \sstitem
         AST\_\_BAD is returned in AXVAL if an error occurs during this routine.
      }
   }
}
\sstroutine{
   KPG1\_GTCHV
}{
   Obtain a vector of choices from the environment
}{
   \sstdescription{
      This routine gets NVAL strings from the user, selected from those
      supplied in OPTS. The indices of the supplied strings within OPTS
      are returned. The user supplies the strings in the form of a GRP
      group expression, using the default GRP control characters.

      The user may supply an integer value instead of a string, in which
      case the integer is understood to be the index of the required string
      within OPTS. If the supplied list of strings contains the integer
      itself, then the integer is understood to be a string, not an index.
   }
   \sstinvocation{
      CALL KPG1\_GTCHV( NOPT, OPTS, PARAM, NVAL, IDEF, VALS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NOPT = INTEGER (Given)
      }{
         The number of available options supplied in OPTS.
      }
      \sstsubsection{
         OPTS( NOPT ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         An array holding the options from which the user must choose.
         Leading and trailing white space is ignored. Blank options are
         not allowed.
      }
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use.
      }
      \sstsubsection{
         NVAL = INTEGER (Given)
      }{
         The number of choices required. The user must supply exactly
         this number of choices.
      }
      \sstsubsection{
         IDEF( NVAL ) = INTEGER (Given)
      }{
         The indices within OPTS of the default strings to use if a null (!)
         value is supplied for the parameter. If the first value is zero,
         a null parameter value results in a PAR\_\_NULL status being returned.
      }
      \sstsubsection{
         VALS( NVAL ) = INTEGER (Returned)
      }{
         The indices within OPTS of the selected options.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Case is insignificant when comparing supplied strings with
         available options.

         \sstitem
         A dynamic default is set for the parameter before accessing it if
         IDEF supplied suitable defaults. The default consists of a
         comma-separated list of the default options.
      }
   }
}
\sstroutine{
   KPG1\_GTCOL
}{
   Obtain a marker colour, given a colour specification
}{
   \sstdescription{
      This routine obtains a colour index to be used to mark features
      in an image display from a supplied string. The interpretation of
      this string provides a number of ways to specify the colour index
      requested.  The options are:

        {\tt '}MAX{\tt '}          - The maximum (non-reserved) colour index, i.e.
                         the highest colour index used for the display
                         of an image.
        {\tt '}MIN{\tt '}          - The minimum non-reserved colour index, i.e. the
                         lowest colour index used for the display of an
                         image.
        An integer     - The actual colour index. It is constrained
                         between 0 and the highest colour index.
        A named colour - Uses the named colour from the palette, and if
                         it is not present, the nearest colour from the
                         palette is selected.

      An error is reported if the string does not conform to any of these
      formats.
   }
   \sstinvocation{
      CALL KPG1\_GTCOL( COL, LP, UP, COLIND, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         COL = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The string specifying the required colour.
      }
      \sstsubsection{
         LP = INTEGER (Given)
      }{
         The lowest non-reserved colour index.
      }
      \sstsubsection{
         UP = INTEGER (Given)
      }{
         The highest non-reserved colour index.
      }
      \sstsubsection{
         COLIND = INTEGER (Returned)
      }{
         The colour index of the selected colour.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         A GKS image-display workstation must be open and active.
      }
   }
}
\sstroutine{
   KPG1\_GTGRP
}{
   Obtain a group of strings from the environment
}{
   \sstdescription{
      This routine obtains  group of strings using the specified
      parameter, and returns them in a GRP group (see SUN/150).

      The user specifies the strings by supplying a GRP group expression
      for the parameter value. If the final character in the supplied
      string is the group {\tt "}flag character{\tt "} (a minus sign by default), then
      the user is re-prompted for another group expression, and the strings
      specified by the second group expression are appended to the
      returned group. This continues until a group expression is supplied
      which does not end with the continuation character, or a null value is
      supplied (which is annulled).

      Normally, the {\tt "}current value{\tt "} for the parameter on exit would be
      the final group expression. If more than one group expression was
      supplied, then this will not represent the entire group. For this
      reason, this routine concatenates all the group expressions supplied,
      and stores the total group expression as the parameter value before
      exiting. Since a new value is stored for the parameter, the parameter
      should ne be given an access mode of READ in the interface file.

      If a null value is supplied the first time the parameter value is
      obtained, then the PAR\_\_NULL status is returned. If a null value is
      supplied on a subsequent access to the parameter, then the PAR\_\_NULL
      status is annulled.
   }
   \sstinvocation{
      CALL KPG1\_GTGRP( PARAM, IGRP, SIZE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use.
      }
      \sstsubsection{
         IGRP = INTEGER (Given and Returned)
      }{
         The group to use. If this is GRP\_\_NOID then a new group is
         created with default control characters and its identifier is
         returned. If the group already exists, its contents are discarded
         before adding new strings.
      }
      \sstsubsection{
         SIZE = INTEGER (Returned)
      }{
         The total size of the returned group. Returned equal to zero if an
         error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_GTNDF
}{
   Gets an NDF or NDF section with a specified number of significant
   dimensions
}{
   \sstdescription{
      The supplied parameter name is associated with an NDF through the
      environment, and an identifier is obtained for the NDF using the
      specified access mode.  Each axis of the NDF is checked to see if
      is significant (i.e. has a size greater than 1).  The index of
      each significant axis is returned in SDIM, and the bounds of the
      axis are returned in SLBND and SUBND.  If EXACT is .TRUE., an
      error is reported if the number of significant axes is not
      exactly NDIM.  If EXACT is .FALSE. an error is only reported if
      the number of significant dimensions is higher than NDIM.  If
      there are less than NDIM significant dimensions then the
      insignificant dimensions are used (starting from the lowest) to
      ensure that the required number of dimensions are returned.
   }
   \sstinvocation{
      CALL KPG1\_GTNDF( PARAM, NDIM, EXACT, MODE, INDF, SDIM, SLBND,
                       SUBND, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The parameter name.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of dimensions required.
      }
      \sstsubsection{
         EXACT = LOGICAL (Given)
      }{
         This should be supplied .FALSE. if an NDF with less than NDIM
         significant dimensions can be used.
      }
      \sstsubsection{
         MODE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The access mode required for the NDF.
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         An identifier for the NDF.
      }
      \sstsubsection{
         SDIM( NDIM ) = INTEGER (Returned)
      }{
         The indices of the significant dimensions.
      }
      \sstsubsection{
         SLBND( NDIM ) = INTEGER (Returned)
      }{
         The lower bounds of the significant dimensions.  These are
         stored in the same order as the indices in SDIM.
      }
      \sstsubsection{
         SUBND( NDIM ) = INTEGER (Returned)
      }{
         The upper bounds of the significant dimensions.  These are
         stored in the same order as the indices in SDIM.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_GTPOS
}{
   Get a spatial position from the environment
}{
   \sstdescription{
      This routine obtains a spatial position from the environment, using
      a specified parameter. The user supplies the position in the
      co-ordinate system of the Current Frame in the supplied WCS FrameSet.
      To be acceptable, the supplied position must correspond to a valid
      position (on all axes) in the Base Frame of the supplied FrameSet. If
      a Frame is supplied instead of a FrameSet this restriction is not
      imposed.

      If the position supplied in argument CC on entry is valid (i.e. does
      not contain any AST\_\_BAD values) then it is used as a dynamic
      default for the parameter. Otherwise, no dynamic default is used.

      The parameter is accessed as a single literal string containing a
      space or comma separated list of axis values. The allowed formats for
      the axis values depends on the class of the Current Frame in the
      supplied FrameSet, and are described in SUN/210.

      If the string supplied for the parameter consists of a single colon,
      then a description of the Current co-ordinate Frame is displayed,
      together with an indication of the format required for each axis
      value, and a new parameter value is then obtained.
   }
   \sstinvocation{
      CALL KPG1\_GTPOS( PARAM, IWCS, NULL, CC, BC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use.
      }
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         A pointer to an AST Frame or FrameSet.
      }
      \sstsubsection{
         NULL = LOGICAL (Given)
      }{
         If TRUE, a null (!) parameter value will result in the dynamic
         default value being used. If FALSE (or if there is no dynamic
         default), a null parameter value will result in a PAR\_\_NULL error
         status.
      }
      \sstsubsection{
         CC( $*$ ) = DOUBLE PRECISION (Given and Returned)
      }{
         On entry, holds the position to use as the dynamic default for the
         parameter, in the Current Frame of the supplied FrameSet (or
         Frame). On exit, holds the supplied position in the Current Frame.
         There should be one element for each axis in the Current Frame.
      }
      \sstsubsection{
         BC( $*$ ) = DOUBLE PRECISION (Returned)
      }{
         Returned holding the Base Frame position corresponding to the
         supplied Current Frame position. If a Frame is supplied for IWCS
         instead of a FrameSet, then BC will not be accessed. The returned
         values will be good on all axes.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         CC and BC are left unchanged if an error has already occurred.

         \sstitem
         Values of AST\_\_BAD are returned in CC (and optionally BC) if an
         error occurs during this routine.
      }
   }
}
\sstroutine{
   KPG1\_GTWCS
}{
   Get an AST FrameSet from an NDF
}{
   \sstdescription{
      This routine returns a FrameSet describing the WCS information
      in an NDF. If the NDF has no WCS component, any IRAS90 IRA
      structure is converted into a FrameSet and returned. If the NDF has
      no IRAS90 IRA structure, then an attempt is made to read a FrameSet
      from the FITS headers in the FITS extension. If the NDF has no FITS
      extension, then the default NDF FrameSet is returned.
   }
   \sstinvocation{
      CALL KPG1\_GTWCS( INDF, IWCS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         The identifier for the NDF.
      }
      \sstsubsection{
         IWCS = INTEGER (Returned)
      }{
         An AST pointer to the WCS FrameSet. Returned equal to AST\_\_NULL
         if an error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If a WCS FrameSet is created form an IRAS90 astrometry structure or
         a FITS extension, it will be stored in the supplied NDF if write
         access is available for the NDF.

         \sstitem
         The preferred AST encodings to use when interpreting FITS headers
         can be specified as a comma-delimited string using environment
         variable KAPPA\_ENCODINGS. If this variable is not defined, then the
         normal default encodings are used (see FITSDIN).
      }
   }
}
\sstroutine{
   KPG1\_H2AST
}{
   Copy AST\_ data from an HDS object
}{
   \sstdescription{
      This routine copies a line of text representing AST\_ data from a
      specified element of a 1-dimensional character array. It is
      intended for use when reading AST\_ data from an HDS object (i.e
      an HDS \_CHAR array).
   }
   \sstinvocation{
      CALL KPG1\_H2AST( DATA, ILINE, LINE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DATA( $*$ ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The character array from which the text is to be copied.
      }
      \sstsubsection{
         ILINE = INTEGER (Given)
      }{
         The index of the element in DATA which is to provide the text
         (the contents of other elements are ignored).
      }
      \sstsubsection{
         LINE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The line of text obtained.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_HCONx
}{
   Take the complex conjugate of an Hermitian image
}{
   \sstdescription{
      The complex conjugate of the supplied Hermitian image is returned.
      See routine KPG1\_HMLTx for more information on Hermitian images.
   }
   \sstinvocation{
      CALL KPG1\_HCONx( M, N, IN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         M = INTEGER (Given)
      }{
         Number of columns.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of rows.
      }
      \sstsubsection{
         IN( N, M ) =? (Given and Returned)
      }{
         On input it is the Hermitian image.  On exit it holds the
         complex conjugate of the supplied array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for processing single- and double-precision
         arrays; replace {\tt "}x{\tt "} in the routine name by R or D as appropriate.
         The data type of the IN argument must match the routine used.
      }
   }
}
\sstroutine{
   KPG1\_HCONx
}{
   Take the complex conjugate of an Hermitian image
}{
   \sstdescription{
      The complex conjugate of the supplied Hermitian image is returned.
      See routine KPG1\_HMLTx for more information on Hermitian images.
   }
   \sstinvocation{
      CALL KPG1\_HCONx( M, N, IN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         M = INTEGER (Given)
      }{
         Number of columns.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of rows.
      }
      \sstsubsection{
         IN( N, M ) =? (Given and Returned)
      }{
         On input it is the Hermitian image.  On exit it holds the
         complex conjugate of the supplied array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for processing single- and double-precision
         arrays; replace {\tt "}x{\tt "} in the routine name by R or D as appropriate.
         The data type of the IN argument must match the routine used.
      }
   }
}
\sstroutine{
   KPG1\_HMLTx
}{
   Multiply two Hermitian images
}{
   \sstdescription{
      Each input Hermitian image represents a COMPLEX image in which
      certain symmetries exist.  These symmetries allow all the
      information stored in the COMPLEX image to be compressed into a
      single REAL image.  This routine effectively unpacks the two REAL
      images given as input into two COMPLEX images, multiplies them
      together pixel-by-pixel to produce another COMPLEX image, and
      then packs the COMPLEX image back into a single Hermitian REAL
      image.  In fact it is not necessary to do the actual unpacking
      and packing of these Hermitian images; this algorithm generates
      the output Hermitian image directly and thus saves time.

      See the Notes for more details of Hermitian images and how they
      are multiplied.
   }
   \sstinvocation{
      CALL KPG1\_HMLTx( M, N, IN1, IN2, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         M = INTEGER (Given)
      }{
         Number of columns.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of rows.
      }
      \sstsubsection{
         IN1( N, M ) = ? (Given)
      }{
         The first input Hermitian image.
      }
      \sstsubsection{
         IN2( N, M ) = ? (Given)
      }{
         The second input Hermitian image.
      }
      \sstsubsection{
         OUT( N, M ) = ? (Returned)
      }{
         The product of the two input images, in Hermitian form.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for processing single- and double-precision
         arrays; replace {\tt "}x{\tt "} in the routine name by R or D as appropriate.
         The data type of the IN1, IN2, and OUT arguments must match the
         routine used.

         \sstitem
         Fourier transforms supplied in Hermitian form can be thought of
         as being derived as follows (see the NAG manual, introduction to
         Chapter C06 for more information on the storage of Hermitian
         FFTs):

      }
      1) Take the one-dimensional FFT of each row of the original image.
      2) Stack all these one-dimensional FFTs into a pair of
         2-dimensional images the same size as the original image. One
         2-dimensional image ({\tt "}A{\tt "}) holds the real part and the other
         ({\tt "}B{\tt "}) holds the imaginary part.  Each row of image A will have
         symmetry such that A(J,row) = A(M-J,row) (J goes from 0 to
         M-1), while each row of image B will have symmetry such that
         B(J,row) = -B(M-J,row).
      3) Take the one-dimensional FFT of each column of image A.
      4) Stack all these one-dimensional FFTs into a pair of 2D images,
         image AA holds the real part of each FFT, and image BA holds
         the imaginary part.  Each column of AA will have symmetry such
         that AA(column,K) = AA(column,N-K) (K goes from 0 to N-1),
         each column of BA will have symmetry such that BA(column,K) =
      \sstitemlist{

         \sstitem
            BA(column,N-K).
         5) Take the one-dimensional FFT of each column of image B.
         6) Stack all these one-dimensional FFTs into a pair of
            2-dimensional images, image AB holds the real part of each
            FFT, and image BB holds the imaginary part.  Each column of AB
            will have symmetry such that AB(column,K) = AB(column,N-K) (K
            goes from 0 to N), each column of BB will have symmetry such
            that BB(column,K) = -BB(column,N-K).
         7) The resulting four images all have either positive or negative
            symmetry in both axes.  The Hermitian FFT images supplied to
            this routine are made up of one quadrant from each image.  The
            bottom-left quadrant is taken from AA, the bottom-right
            quadrant is taken from AB, the top-left quadrant is taken from
            BA and the top-right quadrant is taken from BB.

      }
      The product of two Hermitian FFTs is itself Hermitian and so can
      be described in a similar manner.  If the first input FFT
      corresponds to the four images AA1, AB1, BA1 and BB1, and the
      second input FFT corresponds to the four images AA2, AB2, BA2,
      BB2, then the output is described by the four images AA, AB, BA
      and BB where:

      AA =  AA1$*$AA2 $+$ BB1$*$BB2 - BA1$*$BA2 - AB1$*$AB2
      BB =  AA1$*$BB2 $+$ BB1$*$AA2 $+$ BA1$*$AB2 $+$ AB1$*$BA2
      BA =  BA1$*$AA2 - AB1$*$BB2 $+$ AA1$*$BA2 - BB1$*$AB2
      AB = -BA1$*$BB2 $+$ AB1$*$AA2 $+$ AA1$*$AB2 - BB1$*$BA1
   }
}
\sstroutine{
   KPG1\_HMLTx
}{
   Multiply two Hermitian images
}{
   \sstdescription{
      Each input Hermitian image represents a COMPLEX image in which
      certain symmetries exist.  These symmetries allow all the
      information stored in the COMPLEX image to be compressed into a
      single REAL image.  This routine effectively unpacks the two REAL
      images given as input into two COMPLEX images, multiplies them
      together pixel-by-pixel to produce another COMPLEX image, and
      then packs the COMPLEX image back into a single Hermitian REAL
      image.  In fact it is not necessary to do the actual unpacking
      and packing of these Hermitian images; this algorithm generates
      the output Hermitian image directly and thus saves time.

      See the Notes for more details of Hermitian images and how they
      are multiplied.
   }
   \sstinvocation{
      CALL KPG1\_HMLTx( M, N, IN1, IN2, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         M = INTEGER (Given)
      }{
         Number of columns.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of rows.
      }
      \sstsubsection{
         IN1( N, M ) = ? (Given)
      }{
         The first input Hermitian image.
      }
      \sstsubsection{
         IN2( N, M ) = ? (Given)
      }{
         The second input Hermitian image.
      }
      \sstsubsection{
         OUT( N, M ) = ? (Returned)
      }{
         The product of the two input images, in Hermitian form.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for processing single- and double-precision
         arrays; replace {\tt "}x{\tt "} in the routine name by R or D as appropriate.
         The data type of the IN1, IN2, and OUT arguments must match the
         routine used.

         \sstitem
         Fourier transforms supplied in Hermitian form can be thought of
         as being derived as follows (see the NAG manual, introduction to
         Chapter C06 for more information on the storage of Hermitian
         FFTs):

      }
      1) Take the one-dimensional FFT of each row of the original image.
      2) Stack all these one-dimensional FFTs into a pair of
         2-dimensional images the same size as the original image. One
         2-dimensional image ({\tt "}A{\tt "}) holds the real part and the other
         ({\tt "}B{\tt "}) holds the imaginary part.  Each row of image A will have
         symmetry such that A(J,row) = A(M-J,row) (J goes from 0 to
         M-1), while each row of image B will have symmetry such that
         B(J,row) = -B(M-J,row).
      3) Take the one-dimensional FFT of each column of image A.
      4) Stack all these one-dimensional FFTs into a pair of 2D images,
         image AA holds the real part of each FFT, and image BA holds
         the imaginary part.  Each column of AA will have symmetry such
         that AA(column,K) = AA(column,N-K) (K goes from 0 to N-1),
         each column of BA will have symmetry such that BA(column,K) =
      \sstitemlist{

         \sstitem
            BA(column,N-K).
         5) Take the one-dimensional FFT of each column of image B.
         6) Stack all these one-dimensional FFTs into a pair of
            2-dimensional images, image AB holds the real part of each
            FFT, and image BB holds the imaginary part.  Each column of AB
            will have symmetry such that AB(column,K) = AB(column,N-K) (K
            goes from 0 to N), each column of BB will have symmetry such
            that BB(column,K) = -BB(column,N-K).
         7) The resulting four images all have either positive or negative
            symmetry in both axes.  The Hermitian FFT images supplied to
            this routine are made up of one quadrant from each image.  The
            bottom-left quadrant is taken from AA, the bottom-right
            quadrant is taken from AB, the top-left quadrant is taken from
            BA and the top-right quadrant is taken from BB.

      }
      The product of two Hermitian FFTs is itself Hermitian and so can
      be described in a similar manner.  If the first input FFT
      corresponds to the four images AA1, AB1, BA1 and BB1, and the
      second input FFT corresponds to the four images AA2, AB2, BA2,
      BB2, then the output is described by the four images AA, AB, BA
      and BB where:

      AA =  AA1$*$AA2 $+$ BB1$*$BB2 - BA1$*$BA2 - AB1$*$AB2
      BB =  AA1$*$BB2 $+$ BB1$*$AA2 $+$ BA1$*$AB2 $+$ AB1$*$BA2
      BA =  BA1$*$AA2 - AB1$*$BB2 $+$ AA1$*$BA2 - BB1$*$AB2
      AB = -BA1$*$BB2 $+$ AB1$*$AA2 $+$ AA1$*$AB2 - BB1$*$BA1
   }
}
\sstroutine{
   KPG1\_HMSG
}{
   Assign the name of an HDS object to a message token
}{
   \sstdescription{
      The routine assigns the full name (including the file name) of an
      HDS object to a message token for use with the ERR\_ and MSG\_
      routines (SUN/104). Appropriate syntax is used to represent file
      names which do not have the standard (.SDF) file type.
   }
   \sstinvocation{
      CALL KPG1\_HMSG( TOKEN, LOC )
   }
   \sstarguments{
      \sstsubsection{
         TOKEN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the message token.
      }
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Locator to the HDS object.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine has no STATUS argument and does not perform
         normal error checking. If it should fail, then no value will be
         assigned to the message token and this will be apparent in the
         final message.
      }
   }
   \sstdiytopic{
      VAX-specific features used
   }{
      \sstitemlist{

         \sstitem
         This routine makes assumptions about the form of a VMS file
         name.
      }
   }
}
\sstroutine{
   KPG1\_HRCPx
}{
   Finds the reciprocal of a purely real Hermitian image
}{
   \sstdescription{
      This routine replaces the supplied Hermitian image with one in
      which the real terms have been inverted (i.e. replaced by their
      reciprocal) and the imaginary terms have been set to zero.

      To form 1/H where H is a general complex Hermitian image, the
      numerator and denominator are both multiplied by the complex
      conjugate of H ({\tt "}H$*${\tt "}).  The denominator then becomes purely real
      and equal to the modulus squared of H.  The reciprocal of the
      denominator is then taken using this routine and the resulting
      array is multiplied by H$*$.  Thus the steps are:

      1) Call KPG1\_HCONx to form H$*$, the complex conjugate of H.
      2) Call KPG1\_HMLTx to multiply H by H$*$.  This gives a purely real
         image holding the squared modulus of H.
      3) Call KPG1\_HRCPx to take the reciprocal of H.H$*$.
      4) Call KPG1\_HMLTx to multiply the reciprocal of H.H$*$ by H$*$.
   }
   \sstinvocation{
      CALL KPG1\_HRCPx( M, N, BADVAL, D, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         M = INTEGER (Given)
      }{
         The number of columns in the Hermitian image D.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         The number of lines in the Hermitian image D.
      }
      \sstsubsection{
         BADVAL = ? (Given)
      }{
         A value to return instead of the reciprocal of the real term,
         if any real term is zero.
      }
      \sstsubsection{
         D( M, N ) = ? (Given and Returned)
      }{
         On entry, a purely real Hermitian image.  On exit, an
         Hermitian image representing the reciprocal of the supplied
         image (also purely real).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the double precision and real data
         types: replace {\tt "}x{\tt "} in the routine names by D or R as appropriate.
         The BADVAL and D arguments must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_HSDSx
}{
   Tabulates an histogram
}{
   \sstdescription{
      This routine reports an histogram to the user.
   }
   \sstinvocation{
      CALL KPG1\_HSDSx( NUMBIN, HIST, HRMIN, HRMAX, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         The number of bins in the histogram.
      }
      \sstsubsection{
         HIST( NUMBIN ) = INTEGER (Given)
      }{
         The array holding the histogram.
      }
      \sstsubsection{
         HRMIN = ? (Given)
      }{
         The minimum data value that could be included within the
         histogram.
      }
      \sstsubsection{
         HRMAX = ? (Given)
      }{
         The maximum data value that could be included within the
         histogram.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
         extreme values of the histogram must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_HSDSx
}{
   Tabulates an histogram
}{
   \sstdescription{
      This routine reports an histogram to the user.
   }
   \sstinvocation{
      CALL KPG1\_HSDSx( NUMBIN, HIST, HRMIN, HRMAX, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         The number of bins in the histogram.
      }
      \sstsubsection{
         HIST( NUMBIN ) = INTEGER (Given)
      }{
         The array holding the histogram.
      }
      \sstsubsection{
         HRMIN = ? (Given)
      }{
         The minimum data value that could be included within the
         histogram.
      }
      \sstsubsection{
         HRMAX = ? (Given)
      }{
         The maximum data value that could be included within the
         histogram.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
         extreme values of the histogram must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_HSFLx
}{
   Writes an histogram to a Fortran formatted file
}{
   \sstdescription{
      This routine writes an histogram to a Fortran ASCII file.
   }
   \sstinvocation{
      CALL KPG1\_HSFLx( FD, NUMBIN, HIST, HRMIN, HRMAX, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         Fortran file descriptor as provided by FIO.
      }
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         The number of bins in the histogram.
      }
      \sstsubsection{
         HIST( NUMBIN ) = INTEGER (Given)
      }{
         The array holding the histogram.
      }
      \sstsubsection{
         HRMIN = ? (Given)
      }{
         The minimum data value that could be included within the
         histogram.
      }
      \sstsubsection{
         HRMAX = ? (Given)
      }{
         The maximum data value that could be included within the
         histogram.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
         extreme values of the histogram must have the data type
         specified.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      The Fortran file must all ready be opened and should have a record
      length of at least 52 characters.
   }
}
\sstroutine{
   KPG1\_HSFLx
}{
   Writes an histogram to a Fortran formatted file
}{
   \sstdescription{
      This routine writes an histogram to a Fortran ASCII file.
   }
   \sstinvocation{
      CALL KPG1\_HSFLx( FD, NUMBIN, HIST, HRMIN, HRMAX, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         Fortran file descriptor as provided by FIO.
      }
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         The number of bins in the histogram.
      }
      \sstsubsection{
         HIST( NUMBIN ) = INTEGER (Given)
      }{
         The array holding the histogram.
      }
      \sstsubsection{
         HRMIN = ? (Given)
      }{
         The minimum data value that could be included within the
         histogram.
      }
      \sstsubsection{
         HRMAX = ? (Given)
      }{
         The maximum data value that could be included within the
         histogram.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
         extreme values of the histogram must have the data type
         specified.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      The Fortran file must all ready be opened and should have a record
      length of at least 52 characters.
   }
}
\sstroutine{
   KPG1\_HSSTP
}{
   Calculates statistics from an histogram
}{
   \sstdescription{
      This routine calculates certain statistical parameters for
      an histogram.  The median is derived by linear interpolation
      within an histogram bin. The mode is estimated from 3$*$median -
      2$*$mean, which is only valid for moderately skew distributions.
   }
   \sstinvocation{
      CALL KPG1\_HSSTP( NUMBIN, HIST, VALMAX, VALMIN, SUM, MEAN,
                       MEDIAN, MODE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         Number of bins in the histogram.
      }
      \sstsubsection{
         HIST( NUMBIN ) = INTEGER (Given)
      }{
         The histogram whose statistics are to be derived.
      }
      \sstsubsection{
         VALMAX = DOUBLE PRECISION (Given)
      }{
         Maximum data value included in the histogram.
      }
      \sstsubsection{
         VALMIN = DOUBLE PRECISION (Given)
      }{
         Minimum data value included in the histogram.
      }
      \sstsubsection{
         SUM = DOUBLE PRECISION (Returned)
      }{
         Sum of all values in the histogram.
      }
      \sstsubsection{
         MEAN = DOUBLE PRECISION (Returned)
      }{
         Mean of the histogram.
      }
      \sstsubsection{
         MEDIAN = DOUBLE PRECISION (Returned)
      }{
         Median of the histogram.
      }
      \sstsubsection{
         MODE = DOUBLE PRECISION (Returned)
      }{
         Mode of the histogram.  The bad value (VAL\_\_BADD) is returned
         if the calculated mode lies outside the data range of the
         histogram.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstdiytopic{
      References
   }{
      Moroney, M.J., 1957, {\tt "}Facts from Figures{\tt "} (Pelican)
      Goad, L.E. 1980, in {\tt "}Applications of Digital Image Processing to
        Astronomy{\tt "}, SPIE 264, 139.
   }
}
\sstroutine{
   KPG1\_HSTAx
}{
   Compute simple ordered statistics for an array via an histogram
}{
   \sstdescription{
      This routine computes simple ordered statistics for an array,
      namely: the number of valid pixels, the minimum and maximum pixel
      values (and their positions), the pixel sum, the mean, the mode,
      the median, and selected percentiles.  For efficiency reasons
      the routine computes an histogram, rather than completely
      sorting the data.  The accuracy of the statistics therefore
      depends inversely on the number of bins.
   }
   \sstinvocation{
      CALL KPG1\_HSTAX( BAD, EL, DATA, NUMPER, PERCNT, NGOOD, IMIN,
                       DMIN, IMAX, DMAX, SUM, MEAN, MEDIAN, MODE,
                       PERVAL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether checks for bad pixels should be performed on the array
         being analysed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of pixels in the array.
      }
      \sstsubsection{
         DATA( EL ) = ? (Given)
      }{
         Array to be analysed.
      }
      \sstsubsection{
         NUMPER = INTEGER (Given)
      }{
         Number of percentiles to evaluate.
      }
      \sstsubsection{
         PERCNT( NUMPER ) = REAL (Given and Returned)
      }{
         The array of percentiles to evaluate.  They must in the range
         0.0 to 100.0.  If there are none to calculate, set NUMPER to 1
         and pass the bad value in PERCNT( 1 ).  On exit these are
         placed in ascending order.
      }
      \sstsubsection{
         NGOOD = INTEGER (Returned)
      }{
         Number of valid pixels in the array.
      }
      \sstsubsection{
         IMIN = INTEGER (Returned)
      }{
         Index where the pixel with the lowest value was (first) found.
      }
      \sstsubsection{
         DMIN = DOUBLE PRECISION (Returned)
      }{
         Minimum pixel value in the array.
      }
      \sstsubsection{
         IMAX = INTEGER (Returned)
      }{
         Index where the pixel with the highest value was (first) found.
      }
      \sstsubsection{
         DMAX = DOUBLE PRECISION (Returned)
      }{
         Maximum pixel value in the array.
      }
      \sstsubsection{
         SUM = DOUBLE PRECISION (Returned)
      }{
         Sum of the valid pixels.
      }
      \sstsubsection{
         MEAN = DOUBLE PRECISION (Returned)
      }{
         Mean of the valid pixels.
      }
      \sstsubsection{
         MEDIAN = DOUBLE PRECISION (Returned)
      }{
         Median of the valid pixels.
      }
      \sstsubsection{
         MODE = DOUBLE PRECISION (Returned)
      }{
         Mode of the valid pixels.
      }
      \sstsubsection{
         PERVAL( NUMPER ) = DOUBLE PRECISION (Returned)
      }{
         Percentile values of the valid pixels.  These correspond to the
         ordered fractions returned in PERCNT.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the standard numeric types.
         Replace {\tt "}x{\tt "} in the routine name by D, R, I, W, UW, B or UB as
         appropriate. The data type of the array being analysed must match
         the particular routine used.

         \sstitem
         If NGOOD is zero, then the values of all the derived
         statistics will be undefined and will be set to the {\tt "}bad{\tt "} value
         appropriate to their data type (except for the pixel sum, which
         will be zero).

         \sstitem
         The median and percentiles are derived by linear interpolation
         within histogram bins, after clipping of outliers if the
         histogram is sparse.  The mode is estimated from 3$*$median -
         2$*$mean, which is only valid for moderately skew distributions.
      }
   }
   \sstdiytopic{
      References
   }{
      Moroney, M.J., 1957, {\tt "}Facts from Figures{\tt "} (Pelican)
      Goad, L.E. 1980, in {\tt "}Applications of Digital Image Processing to
        Astronomy{\tt "}, SPIE 264, 139.
   }
   \sstdiytopic{
      Deficiencies
   }{
      \sstitemlist{

         \sstitem
         Does not compute the median and any percentiles in a single
         invocation of KPG1\_FRACx.
      }
   }
}
\sstroutine{
   KPG1\_HSTAx
}{
   Compute simple ordered statistics for an array via an histogram
}{
   \sstdescription{
      This routine computes simple ordered statistics for an array,
      namely: the number of valid pixels, the minimum and maximum pixel
      values (and their positions), the pixel sum, the mean, the mode,
      the median, and selected percentiles.  For efficiency reasons
      the routine computes an histogram, rather than completely
      sorting the data.  The accuracy of the statistics therefore
      depends inversely on the number of bins.
   }
   \sstinvocation{
      CALL KPG1\_HSTAX( BAD, EL, DATA, NUMPER, PERCNT, NGOOD, IMIN,
                       DMIN, IMAX, DMAX, SUM, MEAN, MEDIAN, MODE,
                       PERVAL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether checks for bad pixels should be performed on the array
         being analysed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of pixels in the array.
      }
      \sstsubsection{
         DATA( EL ) = ? (Given)
      }{
         Array to be analysed.
      }
      \sstsubsection{
         NUMPER = INTEGER (Given)
      }{
         Number of percentiles to evaluate.
      }
      \sstsubsection{
         PERCNT( NUMPER ) = REAL (Given and Returned)
      }{
         The array of percentiles to evaluate.  They must in the range
         0.0 to 100.0.  If there are none to calculate, set NUMPER to 1
         and pass the bad value in PERCNT( 1 ).  On exit these are
         placed in ascending order.
      }
      \sstsubsection{
         NGOOD = INTEGER (Returned)
      }{
         Number of valid pixels in the array.
      }
      \sstsubsection{
         IMIN = INTEGER (Returned)
      }{
         Index where the pixel with the lowest value was (first) found.
      }
      \sstsubsection{
         DMIN = DOUBLE PRECISION (Returned)
      }{
         Minimum pixel value in the array.
      }
      \sstsubsection{
         IMAX = INTEGER (Returned)
      }{
         Index where the pixel with the highest value was (first) found.
      }
      \sstsubsection{
         DMAX = DOUBLE PRECISION (Returned)
      }{
         Maximum pixel value in the array.
      }
      \sstsubsection{
         SUM = DOUBLE PRECISION (Returned)
      }{
         Sum of the valid pixels.
      }
      \sstsubsection{
         MEAN = DOUBLE PRECISION (Returned)
      }{
         Mean of the valid pixels.
      }
      \sstsubsection{
         MEDIAN = DOUBLE PRECISION (Returned)
      }{
         Median of the valid pixels.
      }
      \sstsubsection{
         MODE = DOUBLE PRECISION (Returned)
      }{
         Mode of the valid pixels.
      }
      \sstsubsection{
         PERVAL( NUMPER ) = DOUBLE PRECISION (Returned)
      }{
         Percentile values of the valid pixels.  These correspond to the
         ordered fractions returned in PERCNT.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the standard numeric types.
         Replace {\tt "}x{\tt "} in the routine name by D, R, I, W, UW, B or UB as
         appropriate. The data type of the array being analysed must match
         the particular routine used.

         \sstitem
         If NGOOD is zero, then the values of all the derived
         statistics will be undefined and will be set to the {\tt "}bad{\tt "} value
         appropriate to their data type (except for the pixel sum, which
         will be zero).

         \sstitem
         The median and percentiles are derived by linear interpolation
         within histogram bins, after clipping of outliers if the
         histogram is sparse.  The mode is estimated from 3$*$median -
         2$*$mean, which is only valid for moderately skew distributions.
      }
   }
   \sstdiytopic{
      References
   }{
      Moroney, M.J., 1957, {\tt "}Facts from Figures{\tt "} (Pelican)
      Goad, L.E. 1980, in {\tt "}Applications of Digital Image Processing to
        Astronomy{\tt "}, SPIE 264, 139.
   }
   \sstdiytopic{
      Deficiencies
   }{
      \sstitemlist{

         \sstitem
         Does not compute the median and any percentiles in a single
         invocation of KPG1\_FRACx.
      }
   }
}
\sstroutine{
   KPG1\_HSTAx
}{
   Compute simple ordered statistics for an array via an histogram
}{
   \sstdescription{
      This routine computes simple ordered statistics for an array,
      namely: the number of valid pixels, the minimum and maximum pixel
      values (and their positions), the pixel sum, the mean, the mode,
      the median, and selected percentiles.  For efficiency reasons
      the routine computes an histogram, rather than completely
      sorting the data.  The accuracy of the statistics therefore
      depends inversely on the number of bins.
   }
   \sstinvocation{
      CALL KPG1\_HSTAX( BAD, EL, DATA, NUMPER, PERCNT, NGOOD, IMIN,
                       DMIN, IMAX, DMAX, SUM, MEAN, MEDIAN, MODE,
                       PERVAL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether checks for bad pixels should be performed on the array
         being analysed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of pixels in the array.
      }
      \sstsubsection{
         DATA( EL ) = ? (Given)
      }{
         Array to be analysed.
      }
      \sstsubsection{
         NUMPER = INTEGER (Given)
      }{
         Number of percentiles to evaluate.
      }
      \sstsubsection{
         PERCNT( NUMPER ) = REAL (Given and Returned)
      }{
         The array of percentiles to evaluate.  They must in the range
         0.0 to 100.0.  If there are none to calculate, set NUMPER to 1
         and pass the bad value in PERCNT( 1 ).  On exit these are
         placed in ascending order.
      }
      \sstsubsection{
         NGOOD = INTEGER (Returned)
      }{
         Number of valid pixels in the array.
      }
      \sstsubsection{
         IMIN = INTEGER (Returned)
      }{
         Index where the pixel with the lowest value was (first) found.
      }
      \sstsubsection{
         DMIN = DOUBLE PRECISION (Returned)
      }{
         Minimum pixel value in the array.
      }
      \sstsubsection{
         IMAX = INTEGER (Returned)
      }{
         Index where the pixel with the highest value was (first) found.
      }
      \sstsubsection{
         DMAX = DOUBLE PRECISION (Returned)
      }{
         Maximum pixel value in the array.
      }
      \sstsubsection{
         SUM = DOUBLE PRECISION (Returned)
      }{
         Sum of the valid pixels.
      }
      \sstsubsection{
         MEAN = DOUBLE PRECISION (Returned)
      }{
         Mean of the valid pixels.
      }
      \sstsubsection{
         MEDIAN = DOUBLE PRECISION (Returned)
      }{
         Median of the valid pixels.
      }
      \sstsubsection{
         MODE = DOUBLE PRECISION (Returned)
      }{
         Mode of the valid pixels.
      }
      \sstsubsection{
         PERVAL( NUMPER ) = DOUBLE PRECISION (Returned)
      }{
         Percentile values of the valid pixels.  These correspond to the
         ordered fractions returned in PERCNT.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the standard numeric types.
         Replace {\tt "}x{\tt "} in the routine name by D, R, I, W, UW, B or UB as
         appropriate. The data type of the array being analysed must match
         the particular routine used.

         \sstitem
         If NGOOD is zero, then the values of all the derived
         statistics will be undefined and will be set to the {\tt "}bad{\tt "} value
         appropriate to their data type (except for the pixel sum, which
         will be zero).

         \sstitem
         The median and percentiles are derived by linear interpolation
         within histogram bins, after clipping of outliers if the
         histogram is sparse.  The mode is estimated from 3$*$median -
         2$*$mean, which is only valid for moderately skew distributions.
      }
   }
   \sstdiytopic{
      References
   }{
      Moroney, M.J., 1957, {\tt "}Facts from Figures{\tt "} (Pelican)
      Goad, L.E. 1980, in {\tt "}Applications of Digital Image Processing to
        Astronomy{\tt "}, SPIE 264, 139.
   }
   \sstdiytopic{
      Deficiencies
   }{
      \sstitemlist{

         \sstitem
         Does not compute the median and any percentiles in a single
         invocation of KPG1\_FRACx.
      }
   }
}
\sstroutine{
   KPG1\_HSTAx
}{
   Compute simple ordered statistics for an array via an histogram
}{
   \sstdescription{
      This routine computes simple ordered statistics for an array,
      namely: the number of valid pixels, the minimum and maximum pixel
      values (and their positions), the pixel sum, the mean, the mode,
      the median, and selected percentiles.  For efficiency reasons
      the routine computes an histogram, rather than completely
      sorting the data.  The accuracy of the statistics therefore
      depends inversely on the number of bins.
   }
   \sstinvocation{
      CALL KPG1\_HSTAX( BAD, EL, DATA, NUMPER, PERCNT, NGOOD, IMIN,
                       DMIN, IMAX, DMAX, SUM, MEAN, MEDIAN, MODE,
                       PERVAL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether checks for bad pixels should be performed on the array
         being analysed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of pixels in the array.
      }
      \sstsubsection{
         DATA( EL ) = ? (Given)
      }{
         Array to be analysed.
      }
      \sstsubsection{
         NUMPER = INTEGER (Given)
      }{
         Number of percentiles to evaluate.
      }
      \sstsubsection{
         PERCNT( NUMPER ) = REAL (Given and Returned)
      }{
         The array of percentiles to evaluate.  They must in the range
         0.0 to 100.0.  If there are none to calculate, set NUMPER to 1
         and pass the bad value in PERCNT( 1 ).  On exit these are
         placed in ascending order.
      }
      \sstsubsection{
         NGOOD = INTEGER (Returned)
      }{
         Number of valid pixels in the array.
      }
      \sstsubsection{
         IMIN = INTEGER (Returned)
      }{
         Index where the pixel with the lowest value was (first) found.
      }
      \sstsubsection{
         DMIN = DOUBLE PRECISION (Returned)
      }{
         Minimum pixel value in the array.
      }
      \sstsubsection{
         IMAX = INTEGER (Returned)
      }{
         Index where the pixel with the highest value was (first) found.
      }
      \sstsubsection{
         DMAX = DOUBLE PRECISION (Returned)
      }{
         Maximum pixel value in the array.
      }
      \sstsubsection{
         SUM = DOUBLE PRECISION (Returned)
      }{
         Sum of the valid pixels.
      }
      \sstsubsection{
         MEAN = DOUBLE PRECISION (Returned)
      }{
         Mean of the valid pixels.
      }
      \sstsubsection{
         MEDIAN = DOUBLE PRECISION (Returned)
      }{
         Median of the valid pixels.
      }
      \sstsubsection{
         MODE = DOUBLE PRECISION (Returned)
      }{
         Mode of the valid pixels.
      }
      \sstsubsection{
         PERVAL( NUMPER ) = DOUBLE PRECISION (Returned)
      }{
         Percentile values of the valid pixels.  These correspond to the
         ordered fractions returned in PERCNT.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the standard numeric types.
         Replace {\tt "}x{\tt "} in the routine name by D, R, I, W, UW, B or UB as
         appropriate. The data type of the array being analysed must match
         the particular routine used.

         \sstitem
         If NGOOD is zero, then the values of all the derived
         statistics will be undefined and will be set to the {\tt "}bad{\tt "} value
         appropriate to their data type (except for the pixel sum, which
         will be zero).

         \sstitem
         The median and percentiles are derived by linear interpolation
         within histogram bins, after clipping of outliers if the
         histogram is sparse.  The mode is estimated from 3$*$median -
         2$*$mean, which is only valid for moderately skew distributions.
      }
   }
   \sstdiytopic{
      References
   }{
      Moroney, M.J., 1957, {\tt "}Facts from Figures{\tt "} (Pelican)
      Goad, L.E. 1980, in {\tt "}Applications of Digital Image Processing to
        Astronomy{\tt "}, SPIE 264, 139.
   }
   \sstdiytopic{
      Deficiencies
   }{
      \sstitemlist{

         \sstitem
         Does not compute the median and any percentiles in a single
         invocation of KPG1\_FRACx.
      }
   }
}
\sstroutine{
   KPG1\_HSTAx
}{
   Compute simple ordered statistics for an array via an histogram
}{
   \sstdescription{
      This routine computes simple ordered statistics for an array,
      namely: the number of valid pixels, the minimum and maximum pixel
      values (and their positions), the pixel sum, the mean, the mode,
      the median, and selected percentiles.  For efficiency reasons
      the routine computes an histogram, rather than completely
      sorting the data.  The accuracy of the statistics therefore
      depends inversely on the number of bins.
   }
   \sstinvocation{
      CALL KPG1\_HSTAX( BAD, EL, DATA, NUMPER, PERCNT, NGOOD, IMIN,
                       DMIN, IMAX, DMAX, SUM, MEAN, MEDIAN, MODE,
                       PERVAL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether checks for bad pixels should be performed on the array
         being analysed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of pixels in the array.
      }
      \sstsubsection{
         DATA( EL ) = ? (Given)
      }{
         Array to be analysed.
      }
      \sstsubsection{
         NUMPER = INTEGER (Given)
      }{
         Number of percentiles to evaluate.
      }
      \sstsubsection{
         PERCNT( NUMPER ) = REAL (Given and Returned)
      }{
         The array of percentiles to evaluate.  They must in the range
         0.0 to 100.0.  If there are none to calculate, set NUMPER to 1
         and pass the bad value in PERCNT( 1 ).  On exit these are
         placed in ascending order.
      }
      \sstsubsection{
         NGOOD = INTEGER (Returned)
      }{
         Number of valid pixels in the array.
      }
      \sstsubsection{
         IMIN = INTEGER (Returned)
      }{
         Index where the pixel with the lowest value was (first) found.
      }
      \sstsubsection{
         DMIN = DOUBLE PRECISION (Returned)
      }{
         Minimum pixel value in the array.
      }
      \sstsubsection{
         IMAX = INTEGER (Returned)
      }{
         Index where the pixel with the highest value was (first) found.
      }
      \sstsubsection{
         DMAX = DOUBLE PRECISION (Returned)
      }{
         Maximum pixel value in the array.
      }
      \sstsubsection{
         SUM = DOUBLE PRECISION (Returned)
      }{
         Sum of the valid pixels.
      }
      \sstsubsection{
         MEAN = DOUBLE PRECISION (Returned)
      }{
         Mean of the valid pixels.
      }
      \sstsubsection{
         MEDIAN = DOUBLE PRECISION (Returned)
      }{
         Median of the valid pixels.
      }
      \sstsubsection{
         MODE = DOUBLE PRECISION (Returned)
      }{
         Mode of the valid pixels.
      }
      \sstsubsection{
         PERVAL( NUMPER ) = DOUBLE PRECISION (Returned)
      }{
         Percentile values of the valid pixels.  These correspond to the
         ordered fractions returned in PERCNT.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the standard numeric types.
         Replace {\tt "}x{\tt "} in the routine name by D, R, I, W, UW, B or UB as
         appropriate. The data type of the array being analysed must match
         the particular routine used.

         \sstitem
         If NGOOD is zero, then the values of all the derived
         statistics will be undefined and will be set to the {\tt "}bad{\tt "} value
         appropriate to their data type (except for the pixel sum, which
         will be zero).

         \sstitem
         The median and percentiles are derived by linear interpolation
         within histogram bins, after clipping of outliers if the
         histogram is sparse.  The mode is estimated from 3$*$median -
         2$*$mean, which is only valid for moderately skew distributions.
      }
   }
   \sstdiytopic{
      References
   }{
      Moroney, M.J., 1957, {\tt "}Facts from Figures{\tt "} (Pelican)
      Goad, L.E. 1980, in {\tt "}Applications of Digital Image Processing to
        Astronomy{\tt "}, SPIE 264, 139.
   }
   \sstdiytopic{
      Deficiencies
   }{
      \sstitemlist{

         \sstitem
         Does not compute the median and any percentiles in a single
         invocation of KPG1\_FRACx.
      }
   }
}
\sstroutine{
   KPG1\_HSTAx
}{
   Compute simple ordered statistics for an array via an histogram
}{
   \sstdescription{
      This routine computes simple ordered statistics for an array,
      namely: the number of valid pixels, the minimum and maximum pixel
      values (and their positions), the pixel sum, the mean, the mode,
      the median, and selected percentiles.  For efficiency reasons
      the routine computes an histogram, rather than completely
      sorting the data.  The accuracy of the statistics therefore
      depends inversely on the number of bins.
   }
   \sstinvocation{
      CALL KPG1\_HSTAX( BAD, EL, DATA, NUMPER, PERCNT, NGOOD, IMIN,
                       DMIN, IMAX, DMAX, SUM, MEAN, MEDIAN, MODE,
                       PERVAL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether checks for bad pixels should be performed on the array
         being analysed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of pixels in the array.
      }
      \sstsubsection{
         DATA( EL ) = ? (Given)
      }{
         Array to be analysed.
      }
      \sstsubsection{
         NUMPER = INTEGER (Given)
      }{
         Number of percentiles to evaluate.
      }
      \sstsubsection{
         PERCNT( NUMPER ) = REAL (Given and Returned)
      }{
         The array of percentiles to evaluate.  They must in the range
         0.0 to 100.0.  If there are none to calculate, set NUMPER to 1
         and pass the bad value in PERCNT( 1 ).  On exit these are
         placed in ascending order.
      }
      \sstsubsection{
         NGOOD = INTEGER (Returned)
      }{
         Number of valid pixels in the array.
      }
      \sstsubsection{
         IMIN = INTEGER (Returned)
      }{
         Index where the pixel with the lowest value was (first) found.
      }
      \sstsubsection{
         DMIN = DOUBLE PRECISION (Returned)
      }{
         Minimum pixel value in the array.
      }
      \sstsubsection{
         IMAX = INTEGER (Returned)
      }{
         Index where the pixel with the highest value was (first) found.
      }
      \sstsubsection{
         DMAX = DOUBLE PRECISION (Returned)
      }{
         Maximum pixel value in the array.
      }
      \sstsubsection{
         SUM = DOUBLE PRECISION (Returned)
      }{
         Sum of the valid pixels.
      }
      \sstsubsection{
         MEAN = DOUBLE PRECISION (Returned)
      }{
         Mean of the valid pixels.
      }
      \sstsubsection{
         MEDIAN = DOUBLE PRECISION (Returned)
      }{
         Median of the valid pixels.
      }
      \sstsubsection{
         MODE = DOUBLE PRECISION (Returned)
      }{
         Mode of the valid pixels.
      }
      \sstsubsection{
         PERVAL( NUMPER ) = DOUBLE PRECISION (Returned)
      }{
         Percentile values of the valid pixels.  These correspond to the
         ordered fractions returned in PERCNT.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the standard numeric types.
         Replace {\tt "}x{\tt "} in the routine name by D, R, I, W, UW, B or UB as
         appropriate. The data type of the array being analysed must match
         the particular routine used.

         \sstitem
         If NGOOD is zero, then the values of all the derived
         statistics will be undefined and will be set to the {\tt "}bad{\tt "} value
         appropriate to their data type (except for the pixel sum, which
         will be zero).

         \sstitem
         The median and percentiles are derived by linear interpolation
         within histogram bins, after clipping of outliers if the
         histogram is sparse.  The mode is estimated from 3$*$median -
         2$*$mean, which is only valid for moderately skew distributions.
      }
   }
   \sstdiytopic{
      References
   }{
      Moroney, M.J., 1957, {\tt "}Facts from Figures{\tt "} (Pelican)
      Goad, L.E. 1980, in {\tt "}Applications of Digital Image Processing to
        Astronomy{\tt "}, SPIE 264, 139.
   }
   \sstdiytopic{
      Deficiencies
   }{
      \sstitemlist{

         \sstitem
         Does not compute the median and any percentiles in a single
         invocation of KPG1\_FRACx.
      }
   }
}
\sstroutine{
   KPG1\_HSTAx
}{
   Compute simple ordered statistics for an array via an histogram
}{
   \sstdescription{
      This routine computes simple ordered statistics for an array,
      namely: the number of valid pixels, the minimum and maximum pixel
      values (and their positions), the pixel sum, the mean, the mode,
      the median, and selected percentiles.  For efficiency reasons
      the routine computes an histogram, rather than completely
      sorting the data.  The accuracy of the statistics therefore
      depends inversely on the number of bins.
   }
   \sstinvocation{
      CALL KPG1\_HSTAX( BAD, EL, DATA, NUMPER, PERCNT, NGOOD, IMIN,
                       DMIN, IMAX, DMAX, SUM, MEAN, MEDIAN, MODE,
                       PERVAL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether checks for bad pixels should be performed on the array
         being analysed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of pixels in the array.
      }
      \sstsubsection{
         DATA( EL ) = ? (Given)
      }{
         Array to be analysed.
      }
      \sstsubsection{
         NUMPER = INTEGER (Given)
      }{
         Number of percentiles to evaluate.
      }
      \sstsubsection{
         PERCNT( NUMPER ) = REAL (Given and Returned)
      }{
         The array of percentiles to evaluate.  They must in the range
         0.0 to 100.0.  If there are none to calculate, set NUMPER to 1
         and pass the bad value in PERCNT( 1 ).  On exit these are
         placed in ascending order.
      }
      \sstsubsection{
         NGOOD = INTEGER (Returned)
      }{
         Number of valid pixels in the array.
      }
      \sstsubsection{
         IMIN = INTEGER (Returned)
      }{
         Index where the pixel with the lowest value was (first) found.
      }
      \sstsubsection{
         DMIN = DOUBLE PRECISION (Returned)
      }{
         Minimum pixel value in the array.
      }
      \sstsubsection{
         IMAX = INTEGER (Returned)
      }{
         Index where the pixel with the highest value was (first) found.
      }
      \sstsubsection{
         DMAX = DOUBLE PRECISION (Returned)
      }{
         Maximum pixel value in the array.
      }
      \sstsubsection{
         SUM = DOUBLE PRECISION (Returned)
      }{
         Sum of the valid pixels.
      }
      \sstsubsection{
         MEAN = DOUBLE PRECISION (Returned)
      }{
         Mean of the valid pixels.
      }
      \sstsubsection{
         MEDIAN = DOUBLE PRECISION (Returned)
      }{
         Median of the valid pixels.
      }
      \sstsubsection{
         MODE = DOUBLE PRECISION (Returned)
      }{
         Mode of the valid pixels.
      }
      \sstsubsection{
         PERVAL( NUMPER ) = DOUBLE PRECISION (Returned)
      }{
         Percentile values of the valid pixels.  These correspond to the
         ordered fractions returned in PERCNT.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the standard numeric types.
         Replace {\tt "}x{\tt "} in the routine name by D, R, I, W, UW, B or UB as
         appropriate. The data type of the array being analysed must match
         the particular routine used.

         \sstitem
         If NGOOD is zero, then the values of all the derived
         statistics will be undefined and will be set to the {\tt "}bad{\tt "} value
         appropriate to their data type (except for the pixel sum, which
         will be zero).

         \sstitem
         The median and percentiles are derived by linear interpolation
         within histogram bins, after clipping of outliers if the
         histogram is sparse.  The mode is estimated from 3$*$median -
         2$*$mean, which is only valid for moderately skew distributions.
      }
   }
   \sstdiytopic{
      References
   }{
      Moroney, M.J., 1957, {\tt "}Facts from Figures{\tt "} (Pelican)
      Goad, L.E. 1980, in {\tt "}Applications of Digital Image Processing to
        Astronomy{\tt "}, SPIE 264, 139.
   }
   \sstdiytopic{
      Deficiencies
   }{
      \sstitemlist{

         \sstitem
         Does not compute the median and any percentiles in a single
         invocation of KPG1\_FRACx.
      }
   }
}
\sstroutine{
   KPG1\_HSTFx
}{
   Finds values corresponding to specified fractions of an histogram
}{
   \sstdescription{
      This routine finds the values at defined fractions of an
      histogram.  Thus to find the lower-quartile value, the fraction
      would be 0.25.  Since an histogram technique is used rather than
      sorting the whole array, the result may not be exactly correct.
      An histogram with a large number of bins, and the use of linear
      interpolation between bins in the routine reduce the error.
   }
   \sstinvocation{
      CALL KPG1\_HSTFx( NUMBIN, HISTOG, MAXMUM, MINMUM, NFRAC, FRAC,
                       VALUES, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         The number of histogram bins.  The larger the number of bins
         the greater the accuracy of the results.  1000 to 10000 is
         recommended.
      }
      \sstsubsection{
         HISTOG( NUMBIN ) = INTEGER (Given)
      }{
         The histogram.
      }
      \sstsubsection{
         MAXMUM = ? (Given)
      }{
         The maximum value used to evaluate the histogram.
      }
      \sstsubsection{
         MINMUM = ? (Given)
      }{
         The minimum value used to evaluate the histogram.
      }
      \sstsubsection{
         NFRAC = INTEGER (Given)
      }{
         Number of fractional positions.
      }
      \sstsubsection{
         FRAC( NFRAC ) = REAL (Given and Returned)
      }{
         Fractional positions in the histogram in the range 0.0--1.0.
         On exit they are arranged into ascending order.
      }
      \sstsubsection{
         VALUES( NFRAC ) = ? (Returned)
      }{
         Values corresponding to the ordered fractional positions in
         the histogram.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-prcision data types:
         replace {\tt "}x{\tt "} in the routine name by R or D as appropriate.  The
         arguments MAXMUM, MINMUM, and VALUES must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_HSTFx
}{
   Finds values corresponding to specified fractions of an histogram
}{
   \sstdescription{
      This routine finds the values at defined fractions of an
      histogram.  Thus to find the lower-quartile value, the fraction
      would be 0.25.  Since an histogram technique is used rather than
      sorting the whole array, the result may not be exactly correct.
      An histogram with a large number of bins, and the use of linear
      interpolation between bins in the routine reduce the error.
   }
   \sstinvocation{
      CALL KPG1\_HSTFx( NUMBIN, HISTOG, MAXMUM, MINMUM, NFRAC, FRAC,
                       VALUES, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         The number of histogram bins.  The larger the number of bins
         the greater the accuracy of the results.  1000 to 10000 is
         recommended.
      }
      \sstsubsection{
         HISTOG( NUMBIN ) = INTEGER (Given)
      }{
         The histogram.
      }
      \sstsubsection{
         MAXMUM = ? (Given)
      }{
         The maximum value used to evaluate the histogram.
      }
      \sstsubsection{
         MINMUM = ? (Given)
      }{
         The minimum value used to evaluate the histogram.
      }
      \sstsubsection{
         NFRAC = INTEGER (Given)
      }{
         Number of fractional positions.
      }
      \sstsubsection{
         FRAC( NFRAC ) = REAL (Given and Returned)
      }{
         Fractional positions in the histogram in the range 0.0--1.0.
         On exit they are arranged into ascending order.
      }
      \sstsubsection{
         VALUES( NFRAC ) = ? (Returned)
      }{
         Values corresponding to the ordered fractional positions in
         the histogram.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-prcision data types:
         replace {\tt "}x{\tt "} in the routine name by R or D as appropriate.  The
         arguments MAXMUM, MINMUM, and VALUES must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_HSTLO
}{
   Computes the values to display for a histogram
}{
   \sstdescription{
      This routine find the set of (X,Y) values representing the centre
      of each bin in a given histogram. The logarithm of the supplied
      values are used if logarithmic axes are requested. In this case,
      zero or negative values result in VAL\_\_BADR values being returned.
   }
   \sstinvocation{
      CALL KPG1\_HSTLO( NHIST, HIST, HMIN, HMAX, XLOG, YLOG,
                       XLOC, YLOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NHIST = INTEGER (Given)
      }{
         The number of bins in the histogram.
      }
      \sstsubsection{
         HIST( NHIST ) = INTEGER (Given)
      }{
         The histogram whose locus is to be found.
      }
      \sstsubsection{
         HMIN = REAL (Given)
      }{
         The minimum data value that could be included within the
         histogram.
      }
      \sstsubsection{
         HMAX = REAL (Given)
      }{
         The maximum data value that could be included within the
         histogram.
      }
      \sstsubsection{
         XLOG = LOGICAL (Given)
      }{
         If .TRUE., logarithmic value are returned for the X axis.
      }
      \sstsubsection{
         YLOG = LOGICAL (Given)
      }{
         If .TRUE., logarithmic value are returned for the Y axis.
      }
      \sstsubsection{
         XLOC( NHIST ) = REAL( WRITE )
      }{
         Work array for the x locus of the histogram.
      }
      \sstsubsection{
         YLOC( NHIST ) = REAL( WRITE )
      }{
         Work array for the y locus of the histogram.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         This is the status value on entry to this subroutine.
      }
   }
}
\sstroutine{
   KPG1\_HSTQx
}{
   Equalises the histogram of an array
}{
   \sstdescription{
      This routine equalises (linearises) the histogram of an array.
      Thus approximately equal numbers of different values appear in
      output equalised version of the input array.
   }
   \sstinvocation{
      CALL KPG1\_HSTQx( BAD, EL, INARR, NUMBIN, OLDHST, MAP, OUTARR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true there may be bad values within the input array.  If
         false there are no bad values.  It is used as an efficiency
         mechanism.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The array to be equalised.
      }
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         Number of bins used in histogram.  A moderately large number of
         bins is recommended so that there is little artifactual
         quantisation is introduced, say a few thousand except for
         byte data.
      }
      \sstsubsection{
         OLDHST( NUMBIN ) = INTEGER (Returned)
      }{
         The histogram of the input array, i.e. before equalisation.
      }
      \sstsubsection{
         MAP( NUMBIN ) = INTEGER (Returned)
      }{
         Key to transform the input histogram{\tt '}s bin number to the
         equalised bin number after histogram mapping.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         The array containing the equalised values.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays supplied to and returned from this routine must have the
         data type specified.
      }
   }
   \sstdiytopic{
      References
   }{
      Gonzalez, R.C. and Wintz, P., 1977, {\tt "}Digital Image Processing{\tt "},
      Addison-Wesley, pp. 118--126.
   }
}
\sstroutine{
   KPG1\_HSTQx
}{
   Equalises the histogram of an array
}{
   \sstdescription{
      This routine equalises (linearises) the histogram of an array.
      Thus approximately equal numbers of different values appear in
      output equalised version of the input array.
   }
   \sstinvocation{
      CALL KPG1\_HSTQx( BAD, EL, INARR, NUMBIN, OLDHST, MAP, OUTARR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true there may be bad values within the input array.  If
         false there are no bad values.  It is used as an efficiency
         mechanism.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The array to be equalised.
      }
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         Number of bins used in histogram.  A moderately large number of
         bins is recommended so that there is little artifactual
         quantisation is introduced, say a few thousand except for
         byte data.
      }
      \sstsubsection{
         OLDHST( NUMBIN ) = INTEGER (Returned)
      }{
         The histogram of the input array, i.e. before equalisation.
      }
      \sstsubsection{
         MAP( NUMBIN ) = INTEGER (Returned)
      }{
         Key to transform the input histogram{\tt '}s bin number to the
         equalised bin number after histogram mapping.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         The array containing the equalised values.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays supplied to and returned from this routine must have the
         data type specified.
      }
   }
   \sstdiytopic{
      References
   }{
      Gonzalez, R.C. and Wintz, P., 1977, {\tt "}Digital Image Processing{\tt "},
      Addison-Wesley, pp. 118--126.
   }
}
\sstroutine{
   KPG1\_HSTQx
}{
   Equalises the histogram of an array
}{
   \sstdescription{
      This routine equalises (linearises) the histogram of an array.
      Thus approximately equal numbers of different values appear in
      output equalised version of the input array.
   }
   \sstinvocation{
      CALL KPG1\_HSTQx( BAD, EL, INARR, NUMBIN, OLDHST, MAP, OUTARR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true there may be bad values within the input array.  If
         false there are no bad values.  It is used as an efficiency
         mechanism.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The array to be equalised.
      }
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         Number of bins used in histogram.  A moderately large number of
         bins is recommended so that there is little artifactual
         quantisation is introduced, say a few thousand except for
         byte data.
      }
      \sstsubsection{
         OLDHST( NUMBIN ) = INTEGER (Returned)
      }{
         The histogram of the input array, i.e. before equalisation.
      }
      \sstsubsection{
         MAP( NUMBIN ) = INTEGER (Returned)
      }{
         Key to transform the input histogram{\tt '}s bin number to the
         equalised bin number after histogram mapping.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         The array containing the equalised values.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays supplied to and returned from this routine must have the
         data type specified.
      }
   }
   \sstdiytopic{
      References
   }{
      Gonzalez, R.C. and Wintz, P., 1977, {\tt "}Digital Image Processing{\tt "},
      Addison-Wesley, pp. 118--126.
   }
}
\sstroutine{
   KPG1\_HSTQx
}{
   Equalises the histogram of an array
}{
   \sstdescription{
      This routine equalises (linearises) the histogram of an array.
      Thus approximately equal numbers of different values appear in
      output equalised version of the input array.
   }
   \sstinvocation{
      CALL KPG1\_HSTQx( BAD, EL, INARR, NUMBIN, OLDHST, MAP, OUTARR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true there may be bad values within the input array.  If
         false there are no bad values.  It is used as an efficiency
         mechanism.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The array to be equalised.
      }
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         Number of bins used in histogram.  A moderately large number of
         bins is recommended so that there is little artifactual
         quantisation is introduced, say a few thousand except for
         byte data.
      }
      \sstsubsection{
         OLDHST( NUMBIN ) = INTEGER (Returned)
      }{
         The histogram of the input array, i.e. before equalisation.
      }
      \sstsubsection{
         MAP( NUMBIN ) = INTEGER (Returned)
      }{
         Key to transform the input histogram{\tt '}s bin number to the
         equalised bin number after histogram mapping.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         The array containing the equalised values.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays supplied to and returned from this routine must have the
         data type specified.
      }
   }
   \sstdiytopic{
      References
   }{
      Gonzalez, R.C. and Wintz, P., 1977, {\tt "}Digital Image Processing{\tt "},
      Addison-Wesley, pp. 118--126.
   }
}
\sstroutine{
   KPG1\_HSTQx
}{
   Equalises the histogram of an array
}{
   \sstdescription{
      This routine equalises (linearises) the histogram of an array.
      Thus approximately equal numbers of different values appear in
      output equalised version of the input array.
   }
   \sstinvocation{
      CALL KPG1\_HSTQx( BAD, EL, INARR, NUMBIN, OLDHST, MAP, OUTARR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true there may be bad values within the input array.  If
         false there are no bad values.  It is used as an efficiency
         mechanism.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The array to be equalised.
      }
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         Number of bins used in histogram.  A moderately large number of
         bins is recommended so that there is little artifactual
         quantisation is introduced, say a few thousand except for
         byte data.
      }
      \sstsubsection{
         OLDHST( NUMBIN ) = INTEGER (Returned)
      }{
         The histogram of the input array, i.e. before equalisation.
      }
      \sstsubsection{
         MAP( NUMBIN ) = INTEGER (Returned)
      }{
         Key to transform the input histogram{\tt '}s bin number to the
         equalised bin number after histogram mapping.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         The array containing the equalised values.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays supplied to and returned from this routine must have the
         data type specified.
      }
   }
   \sstdiytopic{
      References
   }{
      Gonzalez, R.C. and Wintz, P., 1977, {\tt "}Digital Image Processing{\tt "},
      Addison-Wesley, pp. 118--126.
   }
}
\sstroutine{
   KPG1\_HSTQx
}{
   Equalises the histogram of an array
}{
   \sstdescription{
      This routine equalises (linearises) the histogram of an array.
      Thus approximately equal numbers of different values appear in
      output equalised version of the input array.
   }
   \sstinvocation{
      CALL KPG1\_HSTQx( BAD, EL, INARR, NUMBIN, OLDHST, MAP, OUTARR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true there may be bad values within the input array.  If
         false there are no bad values.  It is used as an efficiency
         mechanism.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The array to be equalised.
      }
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         Number of bins used in histogram.  A moderately large number of
         bins is recommended so that there is little artifactual
         quantisation is introduced, say a few thousand except for
         byte data.
      }
      \sstsubsection{
         OLDHST( NUMBIN ) = INTEGER (Returned)
      }{
         The histogram of the input array, i.e. before equalisation.
      }
      \sstsubsection{
         MAP( NUMBIN ) = INTEGER (Returned)
      }{
         Key to transform the input histogram{\tt '}s bin number to the
         equalised bin number after histogram mapping.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         The array containing the equalised values.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays supplied to and returned from this routine must have the
         data type specified.
      }
   }
   \sstdiytopic{
      References
   }{
      Gonzalez, R.C. and Wintz, P., 1977, {\tt "}Digital Image Processing{\tt "},
      Addison-Wesley, pp. 118--126.
   }
}
\sstroutine{
   KPG1\_HSTQx
}{
   Equalises the histogram of an array
}{
   \sstdescription{
      This routine equalises (linearises) the histogram of an array.
      Thus approximately equal numbers of different values appear in
      output equalised version of the input array.
   }
   \sstinvocation{
      CALL KPG1\_HSTQx( BAD, EL, INARR, NUMBIN, OLDHST, MAP, OUTARR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true there may be bad values within the input array.  If
         false there are no bad values.  It is used as an efficiency
         mechanism.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The array to be equalised.
      }
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         Number of bins used in histogram.  A moderately large number of
         bins is recommended so that there is little artifactual
         quantisation is introduced, say a few thousand except for
         byte data.
      }
      \sstsubsection{
         OLDHST( NUMBIN ) = INTEGER (Returned)
      }{
         The histogram of the input array, i.e. before equalisation.
      }
      \sstsubsection{
         MAP( NUMBIN ) = INTEGER (Returned)
      }{
         Key to transform the input histogram{\tt '}s bin number to the
         equalised bin number after histogram mapping.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         The array containing the equalised values.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays supplied to and returned from this routine must have the
         data type specified.
      }
   }
   \sstdiytopic{
      References
   }{
      Gonzalez, R.C. and Wintz, P., 1977, {\tt "}Digital Image Processing{\tt "},
      Addison-Wesley, pp. 118--126.
   }
}
\sstroutine{
   KPG1\_IDERR
}{
   Reports an IDI error and copies IDI status to inherited status
}{
   \sstdescription{
      This routine simply packages the operations required to report
      an error from IDI, which does not use inherited status, and
      copy the IDI status to inherited status.  Since these operations
      should be called after each IDI call this routine can considerably
      shorten applications code.
   }
   \sstinvocation{
      CALL KPG1\_IDERR( ERR, IDSTAT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         ERR = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the error message.
      }
      \sstsubsection{
         IDSTAT = INTEGER (Given)
      }{
         The IDI status.  If this is IDI\_\_OK, the routine will not
         make an error report and the inherited status will not be
         altered.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_IMPRG
}{
   Propagates NDF information for IMAGE-format applications
}{
   \sstdescription{
      Until the NDF access routines are fully implemented in KAPPA,
      this routine provides a means by which KAPPA applications using
      the IMAGE data format may correctly propagate an input NDF.  Thus
      a pre-V1.0 KAPPA application will behave like a post-V1.0 one
      that only works on primitive DATA\_ARRAYs, and does not process
      VARIANCE, QUALITY, or HISTORY.

      See SGP/38 for more details of the NDF and its propagation rules.
   }
   \sstinvocation{
      CALL KPG1\_IMPRG( INLOC, CLIST, OUTLOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INLOC = CHARACTER $*$ ( $*$ ) (Read)
      }{
         Locator to the input NDF.
      }
      \sstsubsection{
         CLIST = CHARACTER $*$ ( $*$ ) (Read)
      }{
         A comma-separated list of the NDF components which are to be
         propagated from the input to the output NDF.  By default,
         HISTORY, LABEL and all extensions are propagated.  See below
         for further details.
      }
      \sstsubsection{
         OUTLOC = CHARACTER $*$ ( $*$ ) (Read)
      }{
         Locator to the output NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Component Propagation
   }{
      The template components whose values are to be propagated to
      initialise the new data structure are specified via the CLIST
      argument. Thus CLIST={\tt '}AXIS,QUALITY{\tt '} would cause the new NDF to
      inherit its axes structures and QUALITY values (if available) from
      the input structure, in addition to those propagated by default.
   }
}
\sstroutine{
   KPG1\_INCOx
}{
   Obtains a list of co-ordinates from the environment
}{
   \sstdescription{
      The supplied parameter is used to get a list of co-ordinates from
      the environment.  These co-ordinates are stored in dynamic
      workspace which is expanded as necessary so that any number of
      points can be given.  The user indicates the end of the list of
      points by a null value.  Pointers to the workspace arrays holding
      the co-ordinates are returned, and should be annulled when no
      longer needed by calling PSX\_FREE.
   }
   \sstinvocation{
      CALL KPG1\_INCOx( PNAME, NDIM, NPOINT, IPCO, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the parameter with which to associate the co-ordinates.
      }
      \sstsubsection{
         NDIM = INTEGER (Returned)
      }{
         The number of co-ordinate dimensions.  It must be positive and
         no more than DAT\_\_MXDIM.
      }
      \sstsubsection{
         NPOINT = INTEGER (Returned)
      }{
         The number of points specified.
      }
      \sstsubsection{
         IPCO = INTEGER (Returned)
      }{
         A pointer to workspace of type \_DOUBLE and size NDIM by NPOINT
         holding the co-ordinates of each point.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real or double-precision numeric data
         types: replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.
         The returned co-ordinate array will have the specified data type.
      }
   }
}
\sstroutine{
   KPG1\_INCOx
}{
   Obtains a list of co-ordinates from the environment
}{
   \sstdescription{
      The supplied parameter is used to get a list of co-ordinates from
      the environment.  These co-ordinates are stored in dynamic
      workspace which is expanded as necessary so that any number of
      points can be given.  The user indicates the end of the list of
      points by a null value.  Pointers to the workspace arrays holding
      the co-ordinates are returned, and should be annulled when no
      longer needed by calling PSX\_FREE.
   }
   \sstinvocation{
      CALL KPG1\_INCOx( PNAME, NDIM, NPOINT, IPCO, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the parameter with which to associate the co-ordinates.
      }
      \sstsubsection{
         NDIM = INTEGER (Returned)
      }{
         The number of co-ordinate dimensions.  It must be positive and
         no more than DAT\_\_MXDIM.
      }
      \sstsubsection{
         NPOINT = INTEGER (Returned)
      }{
         The number of points specified.
      }
      \sstsubsection{
         IPCO = INTEGER (Returned)
      }{
         A pointer to workspace of type \_REAL and size NDIM by NPOINT
         holding the co-ordinates of each point.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real or double-precision numeric data
         types: replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.
         The returned co-ordinate array will have the specified data type.
      }
   }
}
\sstroutine{
   KPG1\_IS3D
}{
   To sort the list of data orddat into increasing order, also sorts
   the ancillary data DDAT and PDAT correspondingly
}{
   \sstdescription{
      The routine uses an insert sort method. This has proven itself
      the quickest for sorting small sets of data lots of times, as in
      image stacking using ordered statistics. The method looks at the
      second value, compares this with the first if swaps if necessary,
      then it looks at the third, looks at the previous values swaps
      with the lowest (or not at all) and so on until all values have
      been passed. It is fast (for the case above ) simply because of
      the very few lines of operation. The sort is extended to the
      ancillary data DDAT, and PDAT these maintain their
      correspondence with the ORDDAT dataset on exit.
   }
   \sstinvocation{
      CALL KPG1\_IS3D( ORDDAT, DDAT, PDAT, NENT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         ORDDAT( NENT ) = DOUBLE PRECISION (Given and Returned)
      }{
         The data to order. On output it contains the data in increasing
         order.
      }
      \sstsubsection{
         DDAT( NENT ) = DOUBLE PRECISION (Given and Returned)
      }{
         A list of data associated with ORDDAT which needs to retain its
         correspondence with the items in ORDDAT.
      }
      \sstsubsection{
         PDAT( NENT ) = INTEGER (Given and Returned)
      }{
         A list of data associated with ORDDAT which needs to retain its
         correspondence with the items in ORDDAT (probably pointers).
      }
      \sstsubsection{
         NENT = INTEGER (Given)
      }{
         The number of entries in ORDDAT.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_IS3R
}{
   To sort the list of data orddat into increasing order, also sorts
   the ancillary data DDAT and PDAT correspondingly
}{
   \sstdescription{
      The routine uses an insert sort method. This has proven itself
      the quickest for sorting small sets of data lots of times, as in
      image stacking using ordered statistics. The method looks at the
      second value, compares this with the first if swaps if necessary,
      then it looks at the third, looks at the previous values swaps
      with the lowest (or not at all) and so on until all values have
      been passed. It is fast (for the case above ) simply because of
      the very few lines of operation. The sort is extended to the
      ancillary data DDAT, and PDAT these maintain their
      correspondence with the ORDDAT dataset on exit.
   }
   \sstinvocation{
      CALL KPG1\_IS3R( ORDDAT, DDAT, PDAT, NENT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         ORDDAT( NENT ) = REAL (Given and Returned)
      }{
         The data to order. On output it contains the data in increasing
         order.
      }
      \sstsubsection{
         DDAT( NENT ) = REAL (Given and Returned)
      }{
         A list of data associated with ORDDAT which needs to retain its
         correspondence with the items in ORDDAT.
      }
      \sstsubsection{
         PDAT( NENT ) = INTEGER (Given and Returned)
      }{
         A list of data associated with ORDDAT which needs to retain its
         correspondence with the items in ORDDAT (probably pointers).
      }
      \sstsubsection{
         NENT = INTEGER (Given)
      }{
         The number of entries in ORDDAT.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ISCLx
}{
   Scale image between limits
}{
   \sstdescription{
      The input 2-d array is scaled between lower and upper limits such
      that the lower limit and all values below it are set to a minimum
      value, the upper limit and all values above are set to a maximum
      value, and all valid values in between are assigned values using
      linear interpolation between the limits. The image may or may
      not be inverted.  The sign of the scaling can be reversed.  The
      scaled data are written to an integer output array.
   }
   \sstinvocation{
       CALL KPG1\_ISCLx( BAD, DIM1, DIM2, INARR, INVERT, LOWER, UPPER,
      :                 LOWLIM, UPPLIM, BADVAL, OUTARR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true there will be no checking for bad pixels.
      }
      \sstsubsection{
         DIM1 = INTEGER (Given)
      }{
         The first dimension of the 2-d arrays.
      }
      \sstsubsection{
         DIM2 = INTEGER (Given)
      }{
         The second dimension of the 2-d arrays.
      }
      \sstsubsection{
         INARR( DIM1, DIM2 ) = ? (Given)
      }{
         The original, unscaled image data.
      }
      \sstsubsection{
         LOWER = ? (Given)
      }{
         The data value that specifies the lower image-scaling limit.
         This may be smaller than \%UPPER to provide a negative scale
         factor.
      }
      \sstsubsection{
         UPPER = ? (Given)
      }{
         The data value that specifies the upper image-scaling limit.
      }
      \sstsubsection{
         INVERT = LOGICAL (Given)
      }{
         True if the image is to be inverted for display.
      }
      \sstsubsection{
         LOWLIM = INTEGER (Given)
      }{
         The lowest value to appear in the scaled array for good input
         data.
      }
      \sstsubsection{
         UPPLIM = INTEGER (Given)
      }{
         The highest value to appear in the scaled array for good input
         data.
      }
      \sstsubsection{
         BADVAL = INTEGER (Given)
      }{
         The value to be assigned to bad pixels in the scaled array.
      }
      \sstsubsection{
         OUTARR( DIM1, DIM2 ) = INTEGER (Returned)
      }{
         The scaled version of the image.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Value of the status on entering this subroutine.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         array supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_ISCLx
}{
   Scale image between limits
}{
   \sstdescription{
      The input 2-d array is scaled between lower and upper limits such
      that the lower limit and all values below it are set to a minimum
      value, the upper limit and all values above are set to a maximum
      value, and all valid values in between are assigned values using
      linear interpolation between the limits. The image may or may
      not be inverted.  The sign of the scaling can be reversed.  The
      scaled data are written to an integer output array.
   }
   \sstinvocation{
       CALL KPG1\_ISCLx( BAD, DIM1, DIM2, INARR, INVERT, LOWER, UPPER,
      :                 LOWLIM, UPPLIM, BADVAL, OUTARR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true there will be no checking for bad pixels.
      }
      \sstsubsection{
         DIM1 = INTEGER (Given)
      }{
         The first dimension of the 2-d arrays.
      }
      \sstsubsection{
         DIM2 = INTEGER (Given)
      }{
         The second dimension of the 2-d arrays.
      }
      \sstsubsection{
         INARR( DIM1, DIM2 ) = ? (Given)
      }{
         The original, unscaled image data.
      }
      \sstsubsection{
         LOWER = ? (Given)
      }{
         The data value that specifies the lower image-scaling limit.
         This may be smaller than \%UPPER to provide a negative scale
         factor.
      }
      \sstsubsection{
         UPPER = ? (Given)
      }{
         The data value that specifies the upper image-scaling limit.
      }
      \sstsubsection{
         INVERT = LOGICAL (Given)
      }{
         True if the image is to be inverted for display.
      }
      \sstsubsection{
         LOWLIM = INTEGER (Given)
      }{
         The lowest value to appear in the scaled array for good input
         data.
      }
      \sstsubsection{
         UPPLIM = INTEGER (Given)
      }{
         The highest value to appear in the scaled array for good input
         data.
      }
      \sstsubsection{
         BADVAL = INTEGER (Given)
      }{
         The value to be assigned to bad pixels in the scaled array.
      }
      \sstsubsection{
         OUTARR( DIM1, DIM2 ) = INTEGER (Returned)
      }{
         The scaled version of the image.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Value of the status on entering this subroutine.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         array supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_ISCLx
}{
   Scale image between limits
}{
   \sstdescription{
      The input 2-d array is scaled between lower and upper limits such
      that the lower limit and all values below it are set to a minimum
      value, the upper limit and all values above are set to a maximum
      value, and all valid values in between are assigned values using
      linear interpolation between the limits. The image may or may
      not be inverted.  The sign of the scaling can be reversed.  The
      scaled data are written to an integer output array.
   }
   \sstinvocation{
       CALL KPG1\_ISCLx( BAD, DIM1, DIM2, INARR, INVERT, LOWER, UPPER,
      :                 LOWLIM, UPPLIM, BADVAL, OUTARR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true there will be no checking for bad pixels.
      }
      \sstsubsection{
         DIM1 = INTEGER (Given)
      }{
         The first dimension of the 2-d arrays.
      }
      \sstsubsection{
         DIM2 = INTEGER (Given)
      }{
         The second dimension of the 2-d arrays.
      }
      \sstsubsection{
         INARR( DIM1, DIM2 ) = ? (Given)
      }{
         The original, unscaled image data.
      }
      \sstsubsection{
         LOWER = ? (Given)
      }{
         The data value that specifies the lower image-scaling limit.
         This may be smaller than \%UPPER to provide a negative scale
         factor.
      }
      \sstsubsection{
         UPPER = ? (Given)
      }{
         The data value that specifies the upper image-scaling limit.
      }
      \sstsubsection{
         INVERT = LOGICAL (Given)
      }{
         True if the image is to be inverted for display.
      }
      \sstsubsection{
         LOWLIM = INTEGER (Given)
      }{
         The lowest value to appear in the scaled array for good input
         data.
      }
      \sstsubsection{
         UPPLIM = INTEGER (Given)
      }{
         The highest value to appear in the scaled array for good input
         data.
      }
      \sstsubsection{
         BADVAL = INTEGER (Given)
      }{
         The value to be assigned to bad pixels in the scaled array.
      }
      \sstsubsection{
         OUTARR( DIM1, DIM2 ) = INTEGER (Returned)
      }{
         The scaled version of the image.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Value of the status on entering this subroutine.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         array supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_ISCLx
}{
   Scale image between limits
}{
   \sstdescription{
      The input 2-d array is scaled between lower and upper limits such
      that the lower limit and all values below it are set to a minimum
      value, the upper limit and all values above are set to a maximum
      value, and all valid values in between are assigned values using
      linear interpolation between the limits. The image may or may
      not be inverted.  The sign of the scaling can be reversed.  The
      scaled data are written to an integer output array.
   }
   \sstinvocation{
       CALL KPG1\_ISCLx( BAD, DIM1, DIM2, INARR, INVERT, LOWER, UPPER,
      :                 LOWLIM, UPPLIM, BADVAL, OUTARR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true there will be no checking for bad pixels.
      }
      \sstsubsection{
         DIM1 = INTEGER (Given)
      }{
         The first dimension of the 2-d arrays.
      }
      \sstsubsection{
         DIM2 = INTEGER (Given)
      }{
         The second dimension of the 2-d arrays.
      }
      \sstsubsection{
         INARR( DIM1, DIM2 ) = ? (Given)
      }{
         The original, unscaled image data.
      }
      \sstsubsection{
         LOWER = ? (Given)
      }{
         The data value that specifies the lower image-scaling limit.
         This may be smaller than \%UPPER to provide a negative scale
         factor.
      }
      \sstsubsection{
         UPPER = ? (Given)
      }{
         The data value that specifies the upper image-scaling limit.
      }
      \sstsubsection{
         INVERT = LOGICAL (Given)
      }{
         True if the image is to be inverted for display.
      }
      \sstsubsection{
         LOWLIM = INTEGER (Given)
      }{
         The lowest value to appear in the scaled array for good input
         data.
      }
      \sstsubsection{
         UPPLIM = INTEGER (Given)
      }{
         The highest value to appear in the scaled array for good input
         data.
      }
      \sstsubsection{
         BADVAL = INTEGER (Given)
      }{
         The value to be assigned to bad pixels in the scaled array.
      }
      \sstsubsection{
         OUTARR( DIM1, DIM2 ) = INTEGER (Returned)
      }{
         The scaled version of the image.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Value of the status on entering this subroutine.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         array supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_ISCLx
}{
   Scale image between limits
}{
   \sstdescription{
      The input 2-d array is scaled between lower and upper limits such
      that the lower limit and all values below it are set to a minimum
      value, the upper limit and all values above are set to a maximum
      value, and all valid values in between are assigned values using
      linear interpolation between the limits. The image may or may
      not be inverted.  The sign of the scaling can be reversed.  The
      scaled data are written to an integer output array.
   }
   \sstinvocation{
       CALL KPG1\_ISCLx( BAD, DIM1, DIM2, INARR, INVERT, LOWER, UPPER,
      :                 LOWLIM, UPPLIM, BADVAL, OUTARR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true there will be no checking for bad pixels.
      }
      \sstsubsection{
         DIM1 = INTEGER (Given)
      }{
         The first dimension of the 2-d arrays.
      }
      \sstsubsection{
         DIM2 = INTEGER (Given)
      }{
         The second dimension of the 2-d arrays.
      }
      \sstsubsection{
         INARR( DIM1, DIM2 ) = ? (Given)
      }{
         The original, unscaled image data.
      }
      \sstsubsection{
         LOWER = ? (Given)
      }{
         The data value that specifies the lower image-scaling limit.
         This may be smaller than \%UPPER to provide a negative scale
         factor.
      }
      \sstsubsection{
         UPPER = ? (Given)
      }{
         The data value that specifies the upper image-scaling limit.
      }
      \sstsubsection{
         INVERT = LOGICAL (Given)
      }{
         True if the image is to be inverted for display.
      }
      \sstsubsection{
         LOWLIM = INTEGER (Given)
      }{
         The lowest value to appear in the scaled array for good input
         data.
      }
      \sstsubsection{
         UPPLIM = INTEGER (Given)
      }{
         The highest value to appear in the scaled array for good input
         data.
      }
      \sstsubsection{
         BADVAL = INTEGER (Given)
      }{
         The value to be assigned to bad pixels in the scaled array.
      }
      \sstsubsection{
         OUTARR( DIM1, DIM2 ) = INTEGER (Returned)
      }{
         The scaled version of the image.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Value of the status on entering this subroutine.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         array supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_ISSCS
}{
   Extract the epoch of the reference equinox from a string
   specifying an IRAS90 Sky Coordinate System
}{
   \sstdescription{
      If, on entry, the argument SCS contains an explicit IRAS90 equinox
      specifier (see SUN/163), the epoch contained within it is returned
      in argument EQU as a double precision value, and argument BJ is
      returned equal to the character {\tt "}B{\tt "} or {\tt "}J{\tt "} depending on whether the
      epoch is Besselian or Julian. If there is no equinox specifier in
      argument SCS on entry, then the default of B1950 is returned.

      If the sky coordinate system specified by SCS is not referred to
      the equinox (eg GALACTIC) then EQU is returned equal to the
      Starlink {\tt "}BAD{\tt "} value VAL\_\_BADD, and BJ is returned blank.

      The argument NAME is returned holding the full (unabbreviated)
      name of the sky coordinate system without any equinox specifier.
      On exit, the argument SCS holds the full name plus an explicit
      equinox specifier (for systems which are referred to the
      equinox). Thus, if SCS contained {\tt "}EQUAT{\tt "} on entry, it would
      contain {\tt "}EQUATORIAL(B1950){\tt "} on exit.
   }
   \sstinvocation{
      RESULT = KPG1\_ISSCS( SCS, EQU, BJ, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SCS = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         On entry this should contain an IRAS90 SCS name (or any unambiguous
         abbreviation), with or without an equinox specifier. On exit,
         it contains the full SCS name with an explicit equinox
         specifier (for those sky coordinate systems which are referred
         to the equinox). If no equinox specifier is present on entry,
         then a value of B1950 is used (if required). This variable
         should have a declared length of 25.
      }
      \sstsubsection{
         EQU = DOUBLE PRECISION (Returned)
      }{
         The epoch of the reference equinox. This is extracted
         from any explicit equinox specifier contained in SCS on entry.
         If there is no equinox specifier in SCS, a value of 1950.0
         is returned. If the sky coordinate system is not referred to
         the equinox (eg GALACTIC) the Starlink {\tt "}BAD{\tt "} value (VAL\_\_BADD)
         is returned, irrespective of any equinox specifier in SCS.
      }
      \sstsubsection{
         BJ = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         Returned holding either the character B or J. Indicates if
         argument EQU gives a Besselian or Julian epoch. Returned blank
         if the sky coordinate system is not referred to the equinox.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The full name of the sky coordinate system without any equinox
         specifier. This variable should have a declared length of 25.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Function Value
   }{
      KPG1\_ISSCS = LOGICAL
         Returned .TRUE. if the supplied string is a valid IRAS90 SCS
         specifier, and .FALSE. otherwise (no error is reported).
   }
}
\sstroutine{
   KPG1\_IVCI
}{
   Obtains a valid colour index
}{
   \sstdescription{
      This obtains a valid colour index for a device.  By using the
      characteristics of the device sensible limits for the unreserved
      indices can be determined, and if the device is a workstation
      overlay or colour is unavailable, the colour index is defined to
      be 1.  In the former case, the unreserved or reserved colour
      index limits are supplied to KPG1\_MACOL which lets the value be
      the minimum or maximum unreserved or reserved colour index,
      a named colour in the palette, or any numbered colour index.
   }
   \sstinvocation{
      CALL KPG1\_IVCI( PNDEV, PNCOL, RESERV, CI, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNDEV = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The parameter name used to open the graphics device.
      }
      \sstsubsection{
         PNCOL = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The parameter name for the colour.
      }
      \sstsubsection{
         RESERV = LOGICAL (Given)
      }{
         Whether or not the limits for MIN and MAX values in KPG1\_MACOL
         are restricted to the palette (.TRUE.) or the unreserved pens
         (.FALSE.).
      }
      \sstsubsection{
         CI = INTEGER (Returned)
      }{
         The colour index to use.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      A GKS workstation must already be open.
   }
}
\sstroutine{
   KPG1\_IWCG
}{
   Inquires a characteristic of a GKS device
}{
   \sstdescription{
      This inquiries a characteristic of the current GKS graphics
      workstation by accessing GNS.
   }
   \sstinvocation{
      CALL KPG1\_IWCG( WKCHAR, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         WKCHAR = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the characteristic.  See SUN/57 for a full list.
      }
      \sstsubsection{
         VALUE = CHARACTER $*$ ( GNS\_\_SZKEY ) (Returned)
      }{
         The value of the specified characteristic for the current
         workstation.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_KEYZO
}{
   Obtains SGS zones for a frame and a key within the current zone
}{
   \sstdescription{
      This routine defines one frame SGS zone and optionally a zone for
      a key to the right of the frame.  The way these zones are defined
      depends on the shape of the data and the current picture.

      If there is no key zone required, the frame zone is the largest
      zone within the current zone that has a supplied data aspect
      ratio.  This is usually required to obtain square pixels.

      If there is a key required it{\tt '}s position depends on the aspect
      ratio of the data.  If the data are prolate a zone whose aspect
      ratio is the sum of data and key aspect ratios is divided to
      create the required zones.  For oblate data again the shape of the
      current zone affects the way the zone is divided.  For a prolate
      picture, the zones are reduced as far as needed for the key to
      retain its shape using a temporary zone.  The frame is the
      largest zone of its aspect ratio within the remainder of
      temporary zone.   For an oblate picture the key zone is made to
      the right.  The frame is the largest zone of its aspect ratio
      within the remainder of current zone, and is justified to the
      bottom left.  The temporary zone has aspect ratio of the current
      zone less the key.  The key has world co-ordinate whose bounds
      are 0.0--1.0 in both x and y directions.

      The current zone on input is re-instated when the routine exits.
   }
   \sstinvocation{
      CALL KPG1\_KEYZO( KEY, ASPKEY, ASP, ZONEF, ZONEK, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         KEY = LOGICAL (Given)
      }{
         If true a key zone is to be defined.
      }
      \sstsubsection{
         ASPKEY = REAL (Given)
      }{
         The aspect ratio of the key.  A value in the range 0.15--0.3
         is recommended.  A value outside the range 0--1.0, or less
         than ASPPIC when ASP is less than one will both cause the
         routine to return with an SAI\_\_ERROR status.
      }
      \sstsubsection{
         ASP = REAL (Given and Returned)
      }{
         The aspect ratio of the data associated with the plot.
         Usually, it is the ratio of the number of pixels in the x axis
         to that in the y.  If it is positive, it is unchanged on exit.

         If ASP is negative, this indicates a filled-type plot where
         the data aspect ratio is undefined.  However, the aspect ratio
         of the frame can be derived and this is returned on exit.
      }
      \sstsubsection{
         ZONEF = INTEGER (Returned)
      }{
         The SGS zone identifier for the frame.
      }
      \sstsubsection{
         ZONEK = INTEGER (Returned)
      }{
         The SGS zone identifier for the key.  It should be ignored
         when KEY = FALSE.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         SGS should be active.
      }
   }
}
\sstroutine{
   KPG1\_KGODx
}{
   Sort through a dataset and throw away bad values
}{
   \sstdescription{
      This routine copies good data and its variance from input arrays
      to to output arrays, leaving behind bad values.
   }
   \sstinvocation{
      CALL KPG1\_KGODx( VAR, NPTS, INARR, INVAR, NGOOD, OUTARR, OUTVAR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If .TRUE., copy the variance array as well, else only copy
         the data array.
      }
      \sstsubsection{
         NPTS = INTEGER (Given)
      }{
         The number of points in the input array.
      }
      \sstsubsection{
         INARR( NPTS ) = ? (Given)
      }{
         Input data array.
      }
      \sstsubsection{
         INVAR( NPTS ) = ? (Given)
      }{
         Input variance array.
      }
      \sstsubsection{
         NGOOD = INTEGER (Returned)
      }{
         Number of good points in the input data.
      }
      \sstsubsection{
         INARR( NPTS ) = ? (Returned)
      }{
         Output data array.
      }
      \sstsubsection{
         INVAR( NPTS ) = ? (Returned)
      }{
         Output variance array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Data are still good even if variance is bad.  Put another way,
         when the data is good, its corresponding variance is copied
         regardless of its value.

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW, or W as appropriate.  The
         arrays supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_LASTO
}{
   Locates the last occurrence of CVAL in STRING
}{
   \sstdescription{
      The routine locates the last occurence of the single character
      CVAL in STRING. If an occurence is not located then IAT is
      returned as 0.
   }
   \sstinvocation{
      CALL KPG1\_LASTO( STRING, CVAL, IAT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STRING = CHARACTER $*$ ( $*$ ) (Given)
      }{
         String to be searched for occurences of CVAL.
      }
      \sstsubsection{
         CVAL = CHARACTER $*$ ( 1 ) (Given)
      }{
         Character whose last occurence is to be located.
      }
      \sstsubsection{
         IAT = INTEGER (Returned)
      }{
         Position within STRING at which the last occurence of CVAL is
         located.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_LGTRN
}{
   Saves a transformation for a base-10 logarithmic plot in the AGI
   database
}{
   \sstdescription{
      This routine defines the transformations between world and a
      log10-log10 or log10-linear world co-ordinate system, and saves
      the transformation in the AGI database with the current picture.
   }
   \sstinvocation{
      CALL KPG1\_LGTRN( XLOG, YLOG, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         XLOG = LOGICAL (Given)
      }{
         If true the x-axis is logarithmic in world co-ordinates,
         otherwise it is linear.
      }
      \sstsubsection{
         YLOG = LOGICAL (Given)
      }{
         If true the y-axis is logarithmic in world co-ordinates,
         otherwise it is linear.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         There must be a current AGI picture.
      }
   }
}
\sstroutine{
   KPG1\_LINTD
}{
   Obtains a linear transformation between 2 sets of x,y positions
   with least squared error
}{
   \sstdescription{
      The co-efficients of a linear transformation are returned which
      maps the (XA,YA) positions to the corresponding (XB,YB) positions
      with least squares error. The type of fit can be specified as:

        o  A shift of origin only (IFIT 1)

        o  A shift and rotation (IFIT = 2)

        o  A shift, rotation and magnification (IFIT = 3)

        o  A shift, rotation, magnification and shear (IFIT = 4)

      If the value of IFIT is too high for the supplied data, a lower
      value will be used and returned in IFIT. The returned coefficients
      are such that:

        Fitted XB position = C(1) $+$ C(2)$*$XA $+$ C(3)$*$YA

        Fitted YB position = C(4) $+$ C(5)$*$XA $+$ C(6)$*$YA
   }
   \sstinvocation{
      CALL KPG1\_LINTD( N, XA, YA, XB, YB, IFIT, C, MAXERR, RMSERR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         The number of supplied positions.
      }
      \sstsubsection{
         XA( N ) = DOUBLE PRECISION (Given)
      }{
         The X  coordinates at the first set of positions.
      }
      \sstsubsection{
         YA( N ) = DOUBLE PRECISION (Given)
      }{
         The Y  coordinates at the first set of positions.
      }
      \sstsubsection{
         XB( N ) = DOUBLE PRECISION (Given)
      }{
         The X  coordinates at the second set of positions.
      }
      \sstsubsection{
         YB( N ) = DOUBLE PRECISION (Given)
      }{
         The Y  coordinates at the second set of positions.
      }
      \sstsubsection{
         IFIT = INTEGER (Given and Returned)
      }{
         The type of fit required. A lower value will be used (and
         returned) if a fit of the specified type could not be
         obtained.
      }
      \sstsubsection{
         C( 6 ) = DOUBLE PRECISION (Returned)
      }{
         The coefficients of the linear fit.
      }
      \sstsubsection{
         MAXERR = DOUBLE PRECISION (Returned)
      }{
         The maximum error between the supplied (XB,YB) positions and
         the fitted (XB,YB) positions, in pixels.
      }
      \sstsubsection{
         RMSERR = DOUBLE PRECISION (Returned)
      }{
         The RMS error between the supplied (XB,YB) positions and
         the fitted (XB,YB) positions, in pixels.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_LISTC
}{
   Lists a character array to an ASCII file or reports it to the
   user
}{
   \sstdescription{
      This takes a character array and either writes the array to an
      open ASCII file or uses the message system to report it to the
      user.
   }
   \sstinvocation{
      CALL KPG1\_LISTC( FD, EL, ARRAY, FILE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         The file descriptor for the log file.  It is ignored if
         FILE is false.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of character strings in the array.
      }
      \sstsubsection{
         ARRAY( EL ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The array of character strings.
      }
      \sstsubsection{
         FILE = LOGICAL (Given)
      }{
         If true the array is listed to the ASCII file otherwise the
         array is reported to the user.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         The ASCII file must be opened.
      }
   }
}
\sstroutine{
   KPG1\_LITNx
}{
   Creates linear transformation expressions between two
   n-dimensional co-ordinate systems
}{
   \sstdescription{
      This routine evaluates linear transformations between each of the
      dimensions of two co-ordinate systems of the same dimensionality.
      It substitutes the scale factors and offsets into chartacter
      expressions suitable for creating a TRANSFORM structure.
   }
   \sstinvocation{
      CALL KPG1\_LITNx( NDIM, ILBND, IUBND, OLBND, OUBND, ITOO, OTOI,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of dimensions in each co-ordinate system.
      }
      \sstsubsection{
         ILBND( NDIM ) = ? (Given)
      }{
         The lower bounds of the input co-ordinate system corresponding
         to points OLBND in the output co-ordinate system.
      }
      \sstsubsection{
         IUBND( NDIM ) = ? (Given)
      }{
         The upper bounds of the input co-ordinate system corresponding
         to points OUBND in the output co-ordinate system.
      }
      \sstsubsection{
         OLBND( NDIM ) = ? (Given)
      }{
         The lower bounds of the output co-ordinate system corresponding
         to points ILBND in the input co-ordinate system.
      }
      \sstsubsection{
         OUBND( NDIM ) = ? (Given)
      }{
         The upper bounds of the output co-ordinate system corresponding
         to points IUBND in the input co-ordinate system.
      }
      \sstsubsection{
         ITOO( NDIM ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The transformation expressions to convert from the input to
         the output co-ordinate system.  It should have a length at
         least of 26 $+$ 2 $*$ VAL\_\_SZD characters.
      }
      \sstsubsection{
         OTOI( NDIM ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The transformation expressions to convert from the output to
         the input co-ordinate system.  It should have a length at
         least of 26 $+$ 2 $*$ VAL\_\_SZD characters.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision data types:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively.  The
         bounds of the co-ordinate systems supplied to the routine must
         have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_LITNx
}{
   Creates linear transformation expressions between two
   n-dimensional co-ordinate systems
}{
   \sstdescription{
      This routine evaluates linear transformations between each of the
      dimensions of two co-ordinate systems of the same dimensionality.
      It substitutes the scale factors and offsets into chartacter
      expressions suitable for creating a TRANSFORM structure.
   }
   \sstinvocation{
      CALL KPG1\_LITNx( NDIM, ILBND, IUBND, OLBND, OUBND, ITOO, OTOI,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of dimensions in each co-ordinate system.
      }
      \sstsubsection{
         ILBND( NDIM ) = ? (Given)
      }{
         The lower bounds of the input co-ordinate system corresponding
         to points OLBND in the output co-ordinate system.
      }
      \sstsubsection{
         IUBND( NDIM ) = ? (Given)
      }{
         The upper bounds of the input co-ordinate system corresponding
         to points OUBND in the output co-ordinate system.
      }
      \sstsubsection{
         OLBND( NDIM ) = ? (Given)
      }{
         The lower bounds of the output co-ordinate system corresponding
         to points ILBND in the input co-ordinate system.
      }
      \sstsubsection{
         OUBND( NDIM ) = ? (Given)
      }{
         The upper bounds of the output co-ordinate system corresponding
         to points IUBND in the input co-ordinate system.
      }
      \sstsubsection{
         ITOO( NDIM ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The transformation expressions to convert from the input to
         the output co-ordinate system.  It should have a length at
         least of 26 $+$ 2 $*$ VAL\_\_SZR characters.
      }
      \sstsubsection{
         OTOI( NDIM ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The transformation expressions to convert from the output to
         the input co-ordinate system.  It should have a length at
         least of 26 $+$ 2 $*$ VAL\_\_SZR characters.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision data types:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively.  The
         bounds of the co-ordinate systems supplied to the routine must
         have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_LITRx
}{
   Saves a transformation for a linear plot in the AGI database
}{
   \sstdescription{
      This routine defines the transformations between world and a
      linear data co-ordinate system that has eithe, neither or both
      axes with reversed polarity (increasing right to left or top to
      bottom), and saves the transformation in the AGI database with
      the current picture.
   }
   \sstinvocation{
      CALL KPG1\_LITRx( SCALE, OFFSET, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SCALE( 2 ) = ? (Given)
      }{
         The scale factors of each linear axis to transform from world
         co-ordinates to data co-ordinates.
      }
      \sstsubsection{
         OFFSET( 2 ) = ? (Given)
      }{
         The offsets of each linear axis at pixel 0 to transform from
         world co-ordinates to data co-ordinates.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision data types:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively.  The scale
         and offset supplied to the routine must have the data type
         specified.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         There must be a current AGI picture.
      }
   }
}
\sstroutine{
   KPG1\_LITRx
}{
   Saves a transformation for a linear plot in the AGI database
}{
   \sstdescription{
      This routine defines the transformations between world and a
      linear data co-ordinate system that has eithe, neither or both
      axes with reversed polarity (increasing right to left or top to
      bottom), and saves the transformation in the AGI database with
      the current picture.
   }
   \sstinvocation{
      CALL KPG1\_LITRx( SCALE, OFFSET, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SCALE( 2 ) = ? (Given)
      }{
         The scale factors of each linear axis to transform from world
         co-ordinates to data co-ordinates.
      }
      \sstsubsection{
         OFFSET( 2 ) = ? (Given)
      }{
         The offsets of each linear axis at pixel 0 to transform from
         world co-ordinates to data co-ordinates.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision data types:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively.  The scale
         and offset supplied to the routine must have the data type
         specified.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         There must be a current AGI picture.
      }
   }
}
\sstroutine{
   KPG1\_LLTRx
}{
   Saves a transformation for a data co-ordinate linear or
   logarithmic plot in the AGI database
}{
   \sstdescription{
      This routine defines the transformations between world and a
      log10-log10 or log10-linear data co-ordinate system, that has
      either, neither or both axes with reversed polarity (increasing
      right to left or top to bottom), and saves the transformation in
      the AGI database with the current picture.
   }
   \sstinvocation{
      CALL KPG1\_LLTRx( XLOG, YLOG, SCALE, OFFSET, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         XLOG = LOGICAL (Given)
      }{
         If true the x-axis is logarithmic in data co-ordinates,
         otherwise it is linear.
      }
      \sstsubsection{
         YLOG = LOGICAL (Given)
      }{
         If true the y-axis is logarithmic in data co-ordinates,
         otherwise it is linear.
      }
      \sstsubsection{
         SCALE( 2 ) = ? (Given)
      }{
         The scale factors of each linear axis to transform from world
         co-ordinates to data co-ordinates.
      }
      \sstsubsection{
         OFFSET( 2 ) = ? (Given)
      }{
         The offsets of each linear axis at pixel 0 to transform from
         world co-ordinates to data co-ordinates.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision data types:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively.  The scale
         and offset supplied to the routine must have the data type
         specified.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         There must be a current AGI picture.
      }
   }
}
\sstroutine{
   KPG1\_LLTRx
}{
   Saves a transformation for a data co-ordinate linear or
   logarithmic plot in the AGI database
}{
   \sstdescription{
      This routine defines the transformations between world and a
      log10-log10 or log10-linear data co-ordinate system, that has
      either, neither or both axes with reversed polarity (increasing
      right to left or top to bottom), and saves the transformation in
      the AGI database with the current picture.
   }
   \sstinvocation{
      CALL KPG1\_LLTRx( XLOG, YLOG, SCALE, OFFSET, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         XLOG = LOGICAL (Given)
      }{
         If true the x-axis is logarithmic in data co-ordinates,
         otherwise it is linear.
      }
      \sstsubsection{
         YLOG = LOGICAL (Given)
      }{
         If true the y-axis is logarithmic in data co-ordinates,
         otherwise it is linear.
      }
      \sstsubsection{
         SCALE( 2 ) = ? (Given)
      }{
         The scale factors of each linear axis to transform from world
         co-ordinates to data co-ordinates.
      }
      \sstsubsection{
         OFFSET( 2 ) = ? (Given)
      }{
         The offsets of each linear axis at pixel 0 to transform from
         world co-ordinates to data co-ordinates.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision data types:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively.  The scale
         and offset supplied to the routine must have the data type
         specified.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         There must be a current AGI picture.
      }
   }
}
\sstroutine{
   KPG1\_LOCTB
}{
   Locates the centroid of a blob image feature in an n-D array
}{
   \sstdescription{
      This routine locates the centroid of a blob feature within
      a defined search area in an n-D array about suggested starting
      co-ordinates, and returns the final centroid position.  A blob
      is a series of connected pixels above or below the value of the
      surrounding background.

      The routine forms marginal profiles within a search square. A
      separate background estimate is subtracted from each sample in
      each of the profiles, in order to ensure that he profiles have
      a roughly flat background. The background estimate used for each
      profile sample is the lower quartile of the array values which were
      included in the sample. If this quartile cannot be calculated (in
      the case of a 1-d array, for instance, each sample will have only
      1 contribution and so the quartile cannot be found), the background
      estimate is taken from a straight line passing through the first and
      last points of the profile.

      A background value for each whole profile is then found, and the
      centroid of all data above this background level is found. The whole
      process is repeated a number of times, using the previous centroid
      position as the new initial guess position. Iterations continue
      until the maximum number of iterations is reached, or the requested
      accuracy is met, or until one of several error conditions is met.
   }
   \sstinvocation{
      CALL KPG1\_LOCTB( NDIM, LBND, UBND, ARRAY, INIT, SEARCH, POSTIV,
                       MXSHFT, MAXITE, TOLER, FINAL, SEL, WORK1, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The dimensionality of the n-d array.  It must be greater than
         1.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Given)
      }{
         The lower bounds of the n-d array.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         The upper bounds of the n-d array.
      }
      \sstsubsection{
         ARRAY( $*$ ) = BYTE (Given)
      }{
         The input data array.
      }
      \sstsubsection{
         INIT( NDIM ) = REAL (Given)
      }{
         The co-ordinates of the initial estimate position.
      }
      \sstsubsection{
         SEARCH( NDIM ) = INTEGER (Given)
      }{
         Size of the search region to be used in pixels along each
         dimension.  Each value must be odd and lie in the range 3--51.
      }
      \sstsubsection{
         POSTIV = LOGICAL (Given)
      }{
         True if image features are positive above the background.
      }
      \sstsubsection{
         MXSHFT( NDIM ) = REAL (Given)
      }{
         Maximum shifts allowable from the initial position along each
         dimension.
      }
      \sstsubsection{
         MAXITE = INTEGER  (Given)
      }{
         Maximum number of iterations to be used.  At least one
         iteration will be performed even if this is less than one.
      }
      \sstsubsection{
         TOLER = REAL (Given)
      }{
         Accuracy required in the centroid position.
      }
      \sstsubsection{
         SEL = INTEGER (Given)
      }{
         The number of elements in a search box (i.e. the product of the
         values in SEARCH).
      }
      \sstsubsection{
         FINAL( NDIM ) = REAL (Returned)
      }{
         The final co-ordinates of the centroid position.
      }
      \sstsubsection{
         WORK1( 51, SEL, NDIM ) = REAL (Returned)
      }{
         A work array.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the numeric data types: B, D,
         I, R, UB, UW, and W.

         \sstitem
         The lower and upper bounds must correspond to the dimension
         of the array which is passed by assumed size, and therefore the
         routine does not check for this.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_LOCTD
}{
   Locates the centroid of a blob image feature in an n-D array
}{
   \sstdescription{
      This routine locates the centroid of a blob feature within
      a defined search area in an n-D array about suggested starting
      co-ordinates, and returns the final centroid position.  A blob
      is a series of connected pixels above or below the value of the
      surrounding background.

      The routine forms marginal profiles within a search square. A
      separate background estimate is subtracted from each sample in
      each of the profiles, in order to ensure that he profiles have
      a roughly flat background. The background estimate used for each
      profile sample is the lower quartile of the array values which were
      included in the sample. If this quartile cannot be calculated (in
      the case of a 1-d array, for instance, each sample will have only
      1 contribution and so the quartile cannot be found), the background
      estimate is taken from a straight line passing through the first and
      last points of the profile.

      A background value for each whole profile is then found, and the
      centroid of all data above this background level is found. The whole
      process is repeated a number of times, using the previous centroid
      position as the new initial guess position. Iterations continue
      until the maximum number of iterations is reached, or the requested
      accuracy is met, or until one of several error conditions is met.
   }
   \sstinvocation{
      CALL KPG1\_LOCTD( NDIM, LBND, UBND, ARRAY, INIT, SEARCH, POSTIV,
                       MXSHFT, MAXITE, TOLER, FINAL, SEL, WORK1, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The dimensionality of the n-d array.  It must be greater than
         1.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Given)
      }{
         The lower bounds of the n-d array.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         The upper bounds of the n-d array.
      }
      \sstsubsection{
         ARRAY( $*$ ) = DOUBLE PRECISION (Given)
      }{
         The input data array.
      }
      \sstsubsection{
         INIT( NDIM ) = REAL (Given)
      }{
         The co-ordinates of the initial estimate position.
      }
      \sstsubsection{
         SEARCH( NDIM ) = INTEGER (Given)
      }{
         Size of the search region to be used in pixels along each
         dimension.  Each value must be odd and lie in the range 3--51.
      }
      \sstsubsection{
         POSTIV = LOGICAL (Given)
      }{
         True if image features are positive above the background.
      }
      \sstsubsection{
         MXSHFT( NDIM ) = REAL (Given)
      }{
         Maximum shifts allowable from the initial position along each
         dimension.
      }
      \sstsubsection{
         MAXITE = INTEGER  (Given)
      }{
         Maximum number of iterations to be used.  At least one
         iteration will be performed even if this is less than one.
      }
      \sstsubsection{
         TOLER = REAL (Given)
      }{
         Accuracy required in the centroid position.
      }
      \sstsubsection{
         SEL = INTEGER (Given)
      }{
         The number of elements in a search box (i.e. the product of the
         values in SEARCH).
      }
      \sstsubsection{
         FINAL( NDIM ) = REAL (Returned)
      }{
         The final co-ordinates of the centroid position.
      }
      \sstsubsection{
         WORK1( 51, SEL, NDIM ) = REAL (Returned)
      }{
         A work array.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the numeric data types: B, D,
         I, R, UB, UW, and W.

         \sstitem
         The lower and upper bounds must correspond to the dimension
         of the array which is passed by assumed size, and therefore the
         routine does not check for this.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_LOCTI
}{
   Locates the centroid of a blob image feature in an n-D array
}{
   \sstdescription{
      This routine locates the centroid of a blob feature within
      a defined search area in an n-D array about suggested starting
      co-ordinates, and returns the final centroid position.  A blob
      is a series of connected pixels above or below the value of the
      surrounding background.

      The routine forms marginal profiles within a search square. A
      separate background estimate is subtracted from each sample in
      each of the profiles, in order to ensure that he profiles have
      a roughly flat background. The background estimate used for each
      profile sample is the lower quartile of the array values which were
      included in the sample. If this quartile cannot be calculated (in
      the case of a 1-d array, for instance, each sample will have only
      1 contribution and so the quartile cannot be found), the background
      estimate is taken from a straight line passing through the first and
      last points of the profile.

      A background value for each whole profile is then found, and the
      centroid of all data above this background level is found. The whole
      process is repeated a number of times, using the previous centroid
      position as the new initial guess position. Iterations continue
      until the maximum number of iterations is reached, or the requested
      accuracy is met, or until one of several error conditions is met.
   }
   \sstinvocation{
      CALL KPG1\_LOCTI( NDIM, LBND, UBND, ARRAY, INIT, SEARCH, POSTIV,
                       MXSHFT, MAXITE, TOLER, FINAL, SEL, WORK1, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The dimensionality of the n-d array.  It must be greater than
         1.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Given)
      }{
         The lower bounds of the n-d array.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         The upper bounds of the n-d array.
      }
      \sstsubsection{
         ARRAY( $*$ ) = INTEGER (Given)
      }{
         The input data array.
      }
      \sstsubsection{
         INIT( NDIM ) = REAL (Given)
      }{
         The co-ordinates of the initial estimate position.
      }
      \sstsubsection{
         SEARCH( NDIM ) = INTEGER (Given)
      }{
         Size of the search region to be used in pixels along each
         dimension.  Each value must be odd and lie in the range 3--51.
      }
      \sstsubsection{
         POSTIV = LOGICAL (Given)
      }{
         True if image features are positive above the background.
      }
      \sstsubsection{
         MXSHFT( NDIM ) = REAL (Given)
      }{
         Maximum shifts allowable from the initial position along each
         dimension.
      }
      \sstsubsection{
         MAXITE = INTEGER  (Given)
      }{
         Maximum number of iterations to be used.  At least one
         iteration will be performed even if this is less than one.
      }
      \sstsubsection{
         TOLER = REAL (Given)
      }{
         Accuracy required in the centroid position.
      }
      \sstsubsection{
         SEL = INTEGER (Given)
      }{
         The number of elements in a search box (i.e. the product of the
         values in SEARCH).
      }
      \sstsubsection{
         FINAL( NDIM ) = REAL (Returned)
      }{
         The final co-ordinates of the centroid position.
      }
      \sstsubsection{
         WORK1( 51, SEL, NDIM ) = REAL (Returned)
      }{
         A work array.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the numeric data types: B, D,
         I, R, UB, UW, and W.

         \sstitem
         The lower and upper bounds must correspond to the dimension
         of the array which is passed by assumed size, and therefore the
         routine does not check for this.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_LOCTR
}{
   Locates the centroid of a blob image feature in an n-D array
}{
   \sstdescription{
      This routine locates the centroid of a blob feature within
      a defined search area in an n-D array about suggested starting
      co-ordinates, and returns the final centroid position.  A blob
      is a series of connected pixels above or below the value of the
      surrounding background.

      The routine forms marginal profiles within a search square. A
      separate background estimate is subtracted from each sample in
      each of the profiles, in order to ensure that he profiles have
      a roughly flat background. The background estimate used for each
      profile sample is the lower quartile of the array values which were
      included in the sample. If this quartile cannot be calculated (in
      the case of a 1-d array, for instance, each sample will have only
      1 contribution and so the quartile cannot be found), the background
      estimate is taken from a straight line passing through the first and
      last points of the profile.

      A background value for each whole profile is then found, and the
      centroid of all data above this background level is found. The whole
      process is repeated a number of times, using the previous centroid
      position as the new initial guess position. Iterations continue
      until the maximum number of iterations is reached, or the requested
      accuracy is met, or until one of several error conditions is met.
   }
   \sstinvocation{
      CALL KPG1\_LOCTR( NDIM, LBND, UBND, ARRAY, INIT, SEARCH, POSTIV,
                       MXSHFT, MAXITE, TOLER, FINAL, SEL, WORK1, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The dimensionality of the n-d array.  It must be greater than
         1.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Given)
      }{
         The lower bounds of the n-d array.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         The upper bounds of the n-d array.
      }
      \sstsubsection{
         ARRAY( $*$ ) = REAL (Given)
      }{
         The input data array.
      }
      \sstsubsection{
         INIT( NDIM ) = REAL (Given)
      }{
         The co-ordinates of the initial estimate position.
      }
      \sstsubsection{
         SEARCH( NDIM ) = INTEGER (Given)
      }{
         Size of the search region to be used in pixels along each
         dimension.  Each value must be odd and lie in the range 3--51.
      }
      \sstsubsection{
         POSTIV = LOGICAL (Given)
      }{
         True if image features are positive above the background.
      }
      \sstsubsection{
         MXSHFT( NDIM ) = REAL (Given)
      }{
         Maximum shifts allowable from the initial position along each
         dimension.
      }
      \sstsubsection{
         MAXITE = INTEGER  (Given)
      }{
         Maximum number of iterations to be used.  At least one
         iteration will be performed even if this is less than one.
      }
      \sstsubsection{
         TOLER = REAL (Given)
      }{
         Accuracy required in the centroid position.
      }
      \sstsubsection{
         SEL = INTEGER (Given)
      }{
         The number of elements in a search box (i.e. the product of the
         values in SEARCH).
      }
      \sstsubsection{
         FINAL( NDIM ) = REAL (Returned)
      }{
         The final co-ordinates of the centroid position.
      }
      \sstsubsection{
         WORK1( 51, SEL, NDIM ) = REAL (Returned)
      }{
         A work array.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the numeric data types: B, D,
         I, R, UB, UW, and W.

         \sstitem
         The lower and upper bounds must correspond to the dimension
         of the array which is passed by assumed size, and therefore the
         routine does not check for this.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_LOCTUB
}{
   Locates the centroid of a blob image feature in an n-D array
}{
   \sstdescription{
      This routine locates the centroid of a blob feature within
      a defined search area in an n-D array about suggested starting
      co-ordinates, and returns the final centroid position.  A blob
      is a series of connected pixels above or below the value of the
      surrounding background.

      The routine forms marginal profiles within a search square. A
      separate background estimate is subtracted from each sample in
      each of the profiles, in order to ensure that he profiles have
      a roughly flat background. The background estimate used for each
      profile sample is the lower quartile of the array values which were
      included in the sample. If this quartile cannot be calculated (in
      the case of a 1-d array, for instance, each sample will have only
      1 contribution and so the quartile cannot be found), the background
      estimate is taken from a straight line passing through the first and
      last points of the profile.

      A background value for each whole profile is then found, and the
      centroid of all data above this background level is found. The whole
      process is repeated a number of times, using the previous centroid
      position as the new initial guess position. Iterations continue
      until the maximum number of iterations is reached, or the requested
      accuracy is met, or until one of several error conditions is met.
   }
   \sstinvocation{
      CALL KPG1\_LOCTUB( NDIM, LBND, UBND, ARRAY, INIT, SEARCH, POSTIV,
                       MXSHFT, MAXITE, TOLER, FINAL, SEL, WORK1, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The dimensionality of the n-d array.  It must be greater than
         1.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Given)
      }{
         The lower bounds of the n-d array.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         The upper bounds of the n-d array.
      }
      \sstsubsection{
         ARRAY( $*$ ) = BYTE (Given)
      }{
         The input data array.
      }
      \sstsubsection{
         INIT( NDIM ) = REAL (Given)
      }{
         The co-ordinates of the initial estimate position.
      }
      \sstsubsection{
         SEARCH( NDIM ) = INTEGER (Given)
      }{
         Size of the search region to be used in pixels along each
         dimension.  Each value must be odd and lie in the range 3--51.
      }
      \sstsubsection{
         POSTIV = LOGICAL (Given)
      }{
         True if image features are positive above the background.
      }
      \sstsubsection{
         MXSHFT( NDIM ) = REAL (Given)
      }{
         Maximum shifts allowable from the initial position along each
         dimension.
      }
      \sstsubsection{
         MAXITE = INTEGER  (Given)
      }{
         Maximum number of iterations to be used.  At least one
         iteration will be performed even if this is less than one.
      }
      \sstsubsection{
         TOLER = REAL (Given)
      }{
         Accuracy required in the centroid position.
      }
      \sstsubsection{
         SEL = INTEGER (Given)
      }{
         The number of elements in a search box (i.e. the product of the
         values in SEARCH).
      }
      \sstsubsection{
         FINAL( NDIM ) = REAL (Returned)
      }{
         The final co-ordinates of the centroid position.
      }
      \sstsubsection{
         WORK1( 51, SEL, NDIM ) = REAL (Returned)
      }{
         A work array.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the numeric data types: B, D,
         I, R, UB, UW, and W.

         \sstitem
         The lower and upper bounds must correspond to the dimension
         of the array which is passed by assumed size, and therefore the
         routine does not check for this.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_LOCTUW
}{
   Locates the centroid of a blob image feature in an n-D array
}{
   \sstdescription{
      This routine locates the centroid of a blob feature within
      a defined search area in an n-D array about suggested starting
      co-ordinates, and returns the final centroid position.  A blob
      is a series of connected pixels above or below the value of the
      surrounding background.

      The routine forms marginal profiles within a search square. A
      separate background estimate is subtracted from each sample in
      each of the profiles, in order to ensure that he profiles have
      a roughly flat background. The background estimate used for each
      profile sample is the lower quartile of the array values which were
      included in the sample. If this quartile cannot be calculated (in
      the case of a 1-d array, for instance, each sample will have only
      1 contribution and so the quartile cannot be found), the background
      estimate is taken from a straight line passing through the first and
      last points of the profile.

      A background value for each whole profile is then found, and the
      centroid of all data above this background level is found. The whole
      process is repeated a number of times, using the previous centroid
      position as the new initial guess position. Iterations continue
      until the maximum number of iterations is reached, or the requested
      accuracy is met, or until one of several error conditions is met.
   }
   \sstinvocation{
      CALL KPG1\_LOCTUW( NDIM, LBND, UBND, ARRAY, INIT, SEARCH, POSTIV,
                       MXSHFT, MAXITE, TOLER, FINAL, SEL, WORK1, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The dimensionality of the n-d array.  It must be greater than
         1.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Given)
      }{
         The lower bounds of the n-d array.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         The upper bounds of the n-d array.
      }
      \sstsubsection{
         ARRAY( $*$ ) = INTEGER$*$2 (Given)
      }{
         The input data array.
      }
      \sstsubsection{
         INIT( NDIM ) = REAL (Given)
      }{
         The co-ordinates of the initial estimate position.
      }
      \sstsubsection{
         SEARCH( NDIM ) = INTEGER (Given)
      }{
         Size of the search region to be used in pixels along each
         dimension.  Each value must be odd and lie in the range 3--51.
      }
      \sstsubsection{
         POSTIV = LOGICAL (Given)
      }{
         True if image features are positive above the background.
      }
      \sstsubsection{
         MXSHFT( NDIM ) = REAL (Given)
      }{
         Maximum shifts allowable from the initial position along each
         dimension.
      }
      \sstsubsection{
         MAXITE = INTEGER  (Given)
      }{
         Maximum number of iterations to be used.  At least one
         iteration will be performed even if this is less than one.
      }
      \sstsubsection{
         TOLER = REAL (Given)
      }{
         Accuracy required in the centroid position.
      }
      \sstsubsection{
         SEL = INTEGER (Given)
      }{
         The number of elements in a search box (i.e. the product of the
         values in SEARCH).
      }
      \sstsubsection{
         FINAL( NDIM ) = REAL (Returned)
      }{
         The final co-ordinates of the centroid position.
      }
      \sstsubsection{
         WORK1( 51, SEL, NDIM ) = REAL (Returned)
      }{
         A work array.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the numeric data types: B, D,
         I, R, UB, UW, and W.

         \sstitem
         The lower and upper bounds must correspond to the dimension
         of the array which is passed by assumed size, and therefore the
         routine does not check for this.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_LOCTW
}{
   Locates the centroid of a blob image feature in an n-D array
}{
   \sstdescription{
      This routine locates the centroid of a blob feature within
      a defined search area in an n-D array about suggested starting
      co-ordinates, and returns the final centroid position.  A blob
      is a series of connected pixels above or below the value of the
      surrounding background.

      The routine forms marginal profiles within a search square. A
      separate background estimate is subtracted from each sample in
      each of the profiles, in order to ensure that he profiles have
      a roughly flat background. The background estimate used for each
      profile sample is the lower quartile of the array values which were
      included in the sample. If this quartile cannot be calculated (in
      the case of a 1-d array, for instance, each sample will have only
      1 contribution and so the quartile cannot be found), the background
      estimate is taken from a straight line passing through the first and
      last points of the profile.

      A background value for each whole profile is then found, and the
      centroid of all data above this background level is found. The whole
      process is repeated a number of times, using the previous centroid
      position as the new initial guess position. Iterations continue
      until the maximum number of iterations is reached, or the requested
      accuracy is met, or until one of several error conditions is met.
   }
   \sstinvocation{
      CALL KPG1\_LOCTW( NDIM, LBND, UBND, ARRAY, INIT, SEARCH, POSTIV,
                       MXSHFT, MAXITE, TOLER, FINAL, SEL, WORK1, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The dimensionality of the n-d array.  It must be greater than
         1.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Given)
      }{
         The lower bounds of the n-d array.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         The upper bounds of the n-d array.
      }
      \sstsubsection{
         ARRAY( $*$ ) = INTEGER$*$2 (Given)
      }{
         The input data array.
      }
      \sstsubsection{
         INIT( NDIM ) = REAL (Given)
      }{
         The co-ordinates of the initial estimate position.
      }
      \sstsubsection{
         SEARCH( NDIM ) = INTEGER (Given)
      }{
         Size of the search region to be used in pixels along each
         dimension.  Each value must be odd and lie in the range 3--51.
      }
      \sstsubsection{
         POSTIV = LOGICAL (Given)
      }{
         True if image features are positive above the background.
      }
      \sstsubsection{
         MXSHFT( NDIM ) = REAL (Given)
      }{
         Maximum shifts allowable from the initial position along each
         dimension.
      }
      \sstsubsection{
         MAXITE = INTEGER  (Given)
      }{
         Maximum number of iterations to be used.  At least one
         iteration will be performed even if this is less than one.
      }
      \sstsubsection{
         TOLER = REAL (Given)
      }{
         Accuracy required in the centroid position.
      }
      \sstsubsection{
         SEL = INTEGER (Given)
      }{
         The number of elements in a search box (i.e. the product of the
         values in SEARCH).
      }
      \sstsubsection{
         FINAL( NDIM ) = REAL (Returned)
      }{
         The final co-ordinates of the centroid position.
      }
      \sstsubsection{
         WORK1( 51, SEL, NDIM ) = REAL (Returned)
      }{
         A work array.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the numeric data types: B, D,
         I, R, UB, UW, and W.

         \sstitem
         The lower and upper bounds must correspond to the dimension
         of the array which is passed by assumed size, and therefore the
         routine does not check for this.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_LOGAx
}{
   Takes the logarithm to an arbitrary base of an array and its
   variance
}{
   \sstdescription{
      This routine fills the output array pixels with the results
      of taking the logarithm of the pixels of the input array
      to the base specified, i.e. New\_value = Log    Old\_value.
                                                 Base
      If the input pixel is negative, then a bad pixel value is
      used for the output value.

      To find the logarithm to any base, the following algorithm
      is used, providing the base is positive and not equal to one:

          New\_Value  =  Log Old\_Value / Log Base
                           e               e

      If variance is present it is computed as:                 2
          New\_Variance = Old\_Variance / ( Old\_value $*$ log Base )
                                                         e
   }
   \sstinvocation{
      CALL KPG1\_LOGAx( BAD, EL, INARR, VAR, INVAR, BASE, OUTARR,
                       OUTVAR, NERR, NERRV, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of elements in the input output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         Array containing input image data.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If .TRUE., there is a variance array to process.
      }
      \sstsubsection{
         INVAR( EL ) = ? (Given)
      }{
         Array containing input variance data, when VAR = .TRUE..
      }
      \sstsubsection{
         BASE = DOUBLE PRECISION (Given)
      }{
         Base of logarithm to be used.  It must be a positive number.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Write)
      }{
         Array containing results of processing the input data.
      }
      \sstsubsection{
         OUTVAR( EL ) = ? (Write)
      }{
         Array containing results of processing the input variance
         data, when VAR = .TRUE..
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         data array.
      }
      \sstsubsection{
         NERRV = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         variance array, when VAR = .TRUE..
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         arrays supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_LOGAx
}{
   Takes the logarithm to an arbitrary base of an array and its
   variance
}{
   \sstdescription{
      This routine fills the output array pixels with the results
      of taking the logarithm of the pixels of the input array
      to the base specified, i.e. New\_value = Log    Old\_value.
                                                 Base
      If the input pixel is negative, then a bad pixel value is
      used for the output value.

      To find the logarithm to any base, the following algorithm
      is used, providing the base is positive and not equal to one:

          New\_Value  =  Log Old\_Value / Log Base
                           e               e

      If variance is present it is computed as:                 2
          New\_Variance = Old\_Variance / ( Old\_value $*$ log Base )
                                                         e
   }
   \sstinvocation{
      CALL KPG1\_LOGAx( BAD, EL, INARR, VAR, INVAR, BASE, OUTARR,
                       OUTVAR, NERR, NERRV, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of elements in the input output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         Array containing input image data.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If .TRUE., there is a variance array to process.
      }
      \sstsubsection{
         INVAR( EL ) = ? (Given)
      }{
         Array containing input variance data, when VAR = .TRUE..
      }
      \sstsubsection{
         BASE = DOUBLE PRECISION (Given)
      }{
         Base of logarithm to be used.  It must be a positive number.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Write)
      }{
         Array containing results of processing the input data.
      }
      \sstsubsection{
         OUTVAR( EL ) = ? (Write)
      }{
         Array containing results of processing the input variance
         data, when VAR = .TRUE..
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         data array.
      }
      \sstsubsection{
         NERRV = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         variance array, when VAR = .TRUE..
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         arrays supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_LOGAx
}{
   Takes the logarithm to an arbitrary base of an array and its
   variance
}{
   \sstdescription{
      This routine fills the output array pixels with the results
      of taking the logarithm of the pixels of the input array
      to the base specified, i.e. New\_value = Log    Old\_value.
                                                 Base
      If the input pixel is negative, then a bad pixel value is
      used for the output value.

      To find the logarithm to any base, the following algorithm
      is used, providing the base is positive and not equal to one:

          New\_Value  =  Log Old\_Value / Log Base
                           e               e

      If variance is present it is computed as:                 2
          New\_Variance = Old\_Variance / ( Old\_value $*$ log Base )
                                                         e
   }
   \sstinvocation{
      CALL KPG1\_LOGAx( BAD, EL, INARR, VAR, INVAR, BASE, OUTARR,
                       OUTVAR, NERR, NERRV, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of elements in the input output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         Array containing input image data.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If .TRUE., there is a variance array to process.
      }
      \sstsubsection{
         INVAR( EL ) = ? (Given)
      }{
         Array containing input variance data, when VAR = .TRUE..
      }
      \sstsubsection{
         BASE = DOUBLE PRECISION (Given)
      }{
         Base of logarithm to be used.  It must be a positive number.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Write)
      }{
         Array containing results of processing the input data.
      }
      \sstsubsection{
         OUTVAR( EL ) = ? (Write)
      }{
         Array containing results of processing the input variance
         data, when VAR = .TRUE..
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         data array.
      }
      \sstsubsection{
         NERRV = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         variance array, when VAR = .TRUE..
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         arrays supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_LOGAx
}{
   Takes the logarithm to an arbitrary base of an array and its
   variance
}{
   \sstdescription{
      This routine fills the output array pixels with the results
      of taking the logarithm of the pixels of the input array
      to the base specified, i.e. New\_value = Log    Old\_value.
                                                 Base
      If the input pixel is negative, then a bad pixel value is
      used for the output value.

      To find the logarithm to any base, the following algorithm
      is used, providing the base is positive and not equal to one:

          New\_Value  =  Log Old\_Value / Log Base
                           e               e

      If variance is present it is computed as:                 2
          New\_Variance = Old\_Variance / ( Old\_value $*$ log Base )
                                                         e
   }
   \sstinvocation{
      CALL KPG1\_LOGAx( BAD, EL, INARR, VAR, INVAR, BASE, OUTARR,
                       OUTVAR, NERR, NERRV, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of elements in the input output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         Array containing input image data.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If .TRUE., there is a variance array to process.
      }
      \sstsubsection{
         INVAR( EL ) = ? (Given)
      }{
         Array containing input variance data, when VAR = .TRUE..
      }
      \sstsubsection{
         BASE = DOUBLE PRECISION (Given)
      }{
         Base of logarithm to be used.  It must be a positive number.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Write)
      }{
         Array containing results of processing the input data.
      }
      \sstsubsection{
         OUTVAR( EL ) = ? (Write)
      }{
         Array containing results of processing the input variance
         data, when VAR = .TRUE..
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         data array.
      }
      \sstsubsection{
         NERRV = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         variance array, when VAR = .TRUE..
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         arrays supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_LOGAx
}{
   Takes the logarithm to an arbitrary base of an array and its
   variance
}{
   \sstdescription{
      This routine fills the output array pixels with the results
      of taking the logarithm of the pixels of the input array
      to the base specified, i.e. New\_value = Log    Old\_value.
                                                 Base
      If the input pixel is negative, then a bad pixel value is
      used for the output value.

      To find the logarithm to any base, the following algorithm
      is used, providing the base is positive and not equal to one:

          New\_Value  =  Log Old\_Value / Log Base
                           e               e

      If variance is present it is computed as:                 2
          New\_Variance = Old\_Variance / ( Old\_value $*$ log Base )
                                                         e
   }
   \sstinvocation{
      CALL KPG1\_LOGAx( BAD, EL, INARR, VAR, INVAR, BASE, OUTARR,
                       OUTVAR, NERR, NERRV, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of elements in the input output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         Array containing input image data.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If .TRUE., there is a variance array to process.
      }
      \sstsubsection{
         INVAR( EL ) = ? (Given)
      }{
         Array containing input variance data, when VAR = .TRUE..
      }
      \sstsubsection{
         BASE = DOUBLE PRECISION (Given)
      }{
         Base of logarithm to be used.  It must be a positive number.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Write)
      }{
         Array containing results of processing the input data.
      }
      \sstsubsection{
         OUTVAR( EL ) = ? (Write)
      }{
         Array containing results of processing the input variance
         data, when VAR = .TRUE..
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         data array.
      }
      \sstsubsection{
         NERRV = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         variance array, when VAR = .TRUE..
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         arrays supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_LOGAx
}{
   Takes the logarithm to an arbitrary base of an array and its
   variance
}{
   \sstdescription{
      This routine fills the output array pixels with the results
      of taking the logarithm of the pixels of the input array
      to the base specified, i.e. New\_value = Log    Old\_value.
                                                 Base
      If the input pixel is negative, then a bad pixel value is
      used for the output value.

      To find the logarithm to any base, the following algorithm
      is used, providing the base is positive and not equal to one:

          New\_Value  =  Log Old\_Value / Log Base
                           e               e

      If variance is present it is computed as:                 2
          New\_Variance = Old\_Variance / ( Old\_value $*$ log Base )
                                                         e
   }
   \sstinvocation{
      CALL KPG1\_LOGAx( BAD, EL, INARR, VAR, INVAR, BASE, OUTARR,
                       OUTVAR, NERR, NERRV, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of elements in the input output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         Array containing input image data.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If .TRUE., there is a variance array to process.
      }
      \sstsubsection{
         INVAR( EL ) = ? (Given)
      }{
         Array containing input variance data, when VAR = .TRUE..
      }
      \sstsubsection{
         BASE = DOUBLE PRECISION (Given)
      }{
         Base of logarithm to be used.  It must be a positive number.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Write)
      }{
         Array containing results of processing the input data.
      }
      \sstsubsection{
         OUTVAR( EL ) = ? (Write)
      }{
         Array containing results of processing the input variance
         data, when VAR = .TRUE..
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         data array.
      }
      \sstsubsection{
         NERRV = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         variance array, when VAR = .TRUE..
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         arrays supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_LOGAx
}{
   Takes the logarithm to an arbitrary base of an array and its
   variance
}{
   \sstdescription{
      This routine fills the output array pixels with the results
      of taking the logarithm of the pixels of the input array
      to the base specified, i.e. New\_value = Log    Old\_value.
                                                 Base
      If the input pixel is negative, then a bad pixel value is
      used for the output value.

      To find the logarithm to any base, the following algorithm
      is used, providing the base is positive and not equal to one:

          New\_Value  =  Log Old\_Value / Log Base
                           e               e

      If variance is present it is computed as:                 2
          New\_Variance = Old\_Variance / ( Old\_value $*$ log Base )
                                                         e
   }
   \sstinvocation{
      CALL KPG1\_LOGAx( BAD, EL, INARR, VAR, INVAR, BASE, OUTARR,
                       OUTVAR, NERR, NERRV, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input array.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of elements in the input output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         Array containing input image data.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If .TRUE., there is a variance array to process.
      }
      \sstsubsection{
         INVAR( EL ) = ? (Given)
      }{
         Array containing input variance data, when VAR = .TRUE..
      }
      \sstsubsection{
         BASE = DOUBLE PRECISION (Given)
      }{
         Base of logarithm to be used.  It must be a positive number.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Write)
      }{
         Array containing results of processing the input data.
      }
      \sstsubsection{
         OUTVAR( EL ) = ? (Write)
      }{
         Array containing results of processing the input variance
         data, when VAR = .TRUE..
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         data array.
      }
      \sstsubsection{
         NERRV = INTEGER (Returned)
      }{
         Number of numerical errors which occurred while processing the
         variance array, when VAR = .TRUE..
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         arrays supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_LSTAR
}{
   Write a section of a 2D array to a text file
}{
   \sstdescription{
      This routine takes an input 2-d array and lists out a specified
      section of that image, as defined by the x-and-y lower-and-upper
      bounds to a Fortran file. The file must either be already opened
      and specified by the input file descriptor, or be created in this
      routine and will be associated with the supplied parameter name.
      The first record in the file corresponds to the lowest index row.
   }
   \sstinvocation{
      CALL KPG1\_LSTAR( DIM1, DIM2, ARRAY, XLOW, YLOW, XHIGH, YHIGH,
                       OPENF, FDI, FILNAM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DIM1 = INTEGER (Given)
      }{
         The first dimension of the 2-d array.
      }
      \sstsubsection{
         DIM2 = INTEGER (Given)
      }{
         The second dimension of the 2-d array.
      }
      \sstsubsection{
         ARRAY( DIM1, DIM2 )  =  REAL (Given)
      }{
         The 2-d array to be listed.
      }
      \sstsubsection{
         XLOW = INTEGER (Given)
      }{
         x co-ord of lower left corner of sub-array to be listed out.
      }
      \sstsubsection{
         YLOW = INTEGER (Given)
      }{
         y co-ord of lower left corner of sub-array to be listed out.
      }
      \sstsubsection{
         XHIGH = INTEGER (Given)
      }{
         x co-ord of upper right corner of sub-array to be listed out.
      }
      \sstsubsection{
         YHIGH = INTEGER (Given)
      }{
         y co-ord of upper right corner of sub-array to be listed out.
      }
      \sstsubsection{
         OPENF =  LOGICAL (Given)
      }{
         If true the Fortran file is to be associated with \%FILNAM and
         opened. Otherwise the file is assumed to have been opened and
         has descriptor \%FD.
      }
      \sstsubsection{
         FDI = INTEGER (Given)
      }{
         The descriptor associated with the previously opened Fortran
         file.
      }
      \sstsubsection{
         FILNAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Parameter name of the file to be opened and to contain the
         listing output.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         Global status value
      }
   }
}
\sstroutine{
   KPG1\_LTGET
}{
   Obtain a locator to an array holding a colour table for the currently
   opened graphics device
}{
   \sstdescription{
      This routine returns an HDS locator for a 2-dimensional array
      holding the colour table to load into the currently open graphics
      device. The HDS object is searched for in an HDS container file in
      the users ADAM directory. The  file is called {\tt "}kappa.lut.sdf{\tt "} and
      contains a LUT for different devices. The file should have been
      created by KPG1\_LTSAV.

      Each lut in the file is a \_REAL array of shape (3,n) where
      n is the number of colours in the lut.

      Each array has a name which identifies the graphics device
      to which it refers.
   }
   \sstinvocation{
      CALL KPG1\_LTGET( PLOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PLOC = CHARACTER $*$ ( DAT\_\_SZLOC ) (Returned)
      }{
         The locator. returned equal to DAT\_\_NOLOC if the colour table
         cannot be found, or if an error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A graphics device must previously have been opened using PGPLOT.
      }
   }
}
\sstroutine{
   KPG1\_LTLOD
}{
   Load the colour table for the currently open graphics device
}{
   \sstdescription{
      This routine loads the colour table for the currently open graphics
      device from an HDS container file in the users ADAM directory. The
      file is called {\tt "}kappa.lut.sdf{\tt "} and contains a LUT for
      different devices. The file should have been created by KPG1\_LTSAV.
      If the file does not exist, the colour table is set to a greyscale.

      Each lut in the file is a \_REAL array of shape (3,n) where
      n is the number of colours in the lut.

      Each array has a name which identifies the graphics device
      to which it refers.
   }
   \sstinvocation{
      CALL KPG1\_LTLOD( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A graphics device must previously have been opened using PGPLOT.
      }
   }
}
\sstroutine{
   KPG1\_LTSAV
}{
   Save the colour table for the currently open graphics device
}{
   \sstdescription{
      This routine saves the colour table for the currently
      open graphics device in an HDS container file in the users ADAM
      directory. The file is called {\tt "}kappa\_lut.sdf{\tt "} and contains
      LUTs for different devices. Each LUT is a \_REAL array of
      shape (3,n) where n is the number of colours in the LUT. Each array
      has a name which identifies the graphics device to which it refers.
   }
   \sstinvocation{
      CALL KPG1\_LTSAV( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The HDS container file is created if it does not already exist.

         \sstitem
         A graphics device must previously have been opened using PGPLOT.
      }
   }
}
\sstroutine{
   KPG1\_LUDCx
}{
   Performs an LU decomposition of a square matrix
}{
   \sstdescription{
      This routine performs a decomposition of a square matrix into
      lower and upper triangular matrices using Crout{\tt '}s method with
      partial pivoting.  Implicit pivoting is also used to select
      the pivots.
   }
   \sstinvocation{
      CALL KPG1\_LUDCx( N, EL, ARRAY, PINDEX, SCALE, EVEN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         The number of rows and columns in the matrix to be decomposed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The size of the first dimension of the array as declared in the
         calling routine.  This should be at least equal to N.
      }
      \sstsubsection{
         ARRAY( EL, N ) = ? (Given and Returned)
      }{
         On input this is the array to be decomposed into LU form.
         On exit it is the LU decomposed form of the rowwise-permuted
         input ARRAY, with the diagonals being part of the upper
         triangular matrix.  The permutation is given by PINDEX.
      }
      \sstsubsection{
         SCALE( N ) = ? (Returned)
      }{
         Workspace to store the implicit scaling used to normalise the
         rows during implicit pivoting.
      }
      \sstsubsection{
         PINDEX( N ) = INTEGER (Returned)
      }{
         An index of the row permutations caused by the partial
         pivoting.
      }
      \sstsubsection{
         EVEN = LOGICAL (Returned)
      }{
         If EVEN is .TRUE., there was an even number of row
         interchanges during the decomposition.  If EVEN is .FALSE.,
         there was an odd number.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the data types real or double precision:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively, as
         appropriate.  The matrix and the workspace should have this data
         type as well.
      }
   }
}
\sstroutine{
   KPG1\_LUDCx
}{
   Performs an LU decomposition of a square matrix
}{
   \sstdescription{
      This routine performs a decomposition of a square matrix into
      lower and upper triangular matrices using Crout{\tt '}s method with
      partial pivoting.  Implicit pivoting is also used to select
      the pivots.
   }
   \sstinvocation{
      CALL KPG1\_LUDCx( N, EL, ARRAY, PINDEX, SCALE, EVEN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         The number of rows and columns in the matrix to be decomposed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The size of the first dimension of the array as declared in the
         calling routine.  This should be at least equal to N.
      }
      \sstsubsection{
         ARRAY( EL, N ) = ? (Given and Returned)
      }{
         On input this is the array to be decomposed into LU form.
         On exit it is the LU decomposed form of the rowwise-permuted
         input ARRAY, with the diagonals being part of the upper
         triangular matrix.  The permutation is given by PINDEX.
      }
      \sstsubsection{
         SCALE( N ) = ? (Returned)
      }{
         Workspace to store the implicit scaling used to normalise the
         rows during implicit pivoting.
      }
      \sstsubsection{
         PINDEX( N ) = INTEGER (Returned)
      }{
         An index of the row permutations caused by the partial
         pivoting.
      }
      \sstsubsection{
         EVEN = LOGICAL (Returned)
      }{
         If EVEN is .TRUE., there was an even number of row
         interchanges during the decomposition.  If EVEN is .FALSE.,
         there was an odd number.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the data types real or double precision:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively, as
         appropriate.  The matrix and the workspace should have this data
         type as well.
      }
   }
}
\sstroutine{
   KPG1\_LUTIN
}{
   Transfers a lookup table between arrays that have different
   numbers of colour indices
}{
   \sstdescription{
      This routine transfers a lookup table between arrays that may
      have different numbers of colour indices.  When they are unequal
      the lookup table is expanded or contracted to fit the destination
      array.  This may be achieved either by linear interpolation or by
      the nearest-neighbour method.  (There are different sizes
      presumably because the lookup table was created on a device with
      a differently sized colour table.)  If the arrays are of equal
      size the lookup table is merely copied between them.
   }
   \sstinvocation{
      CALL KPG1\_LUTIN( INEL, INARR, OUTEL, NN, OUTARR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INEL = INTEGER (Given)
      }{
         The number of colour indices in the lookup table.
      }
      \sstsubsection{
         INARR( 3, 0:INEL-1 ) = REAL (Given)
      }{
         The source lookup table.  The first dimension is RGB.  Values
         should lie in the range 0.0--1.0.
      }
      \sstsubsection{
         OUTEL = INTEGER (Given)
      }{
         The number of colour indices available in the destination
         array.  This is usually the number of colour indices available
         on the chosen graphics device.
      }
      \sstsubsection{
         NN = LOGICAL (Given)
      }{
         If true, and the number of input and output colour indices are
         different, the nearest-neighbour method is used for assigning
         values in the output array.  Otherwise linear interpolation
         is used.  Nearest-neighbour preserves sharp edges in the
         lookup; linear interpolation is recommended for smoothly
         varying lookup tables.
      }
      \sstsubsection{
         OUTARR( 3, 0:OUTEL-1 ) = REAL (Returned)
      }{
         This is the array into which the table is put. The values will
         all lie in the range 0.0--1.0, even though the input may beyond
         this range. (Input values below 0.0 become 0.0 in OUTARR, and
         those above 1.0 become 1.0)
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status.
      }
   }
}
\sstroutine{
   KPG1\_LUTK2
}{
   Set up the pixel colour indices which form a LUT key
}{
   \sstdescription{
      This routine fills the COLS array with integer colour indices
      so that the array can be used as a colour table key. It can produce
      histogram or ramp keys.
   }
   \sstinvocation{
      CALL KPG1\_LUTK2( FORM, CAXIS, LBND1, UBND1, LBND2, UBND2,
                       HSTDAT, MAXPOP, LOG, COLS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FORM = INTEGER (Given)
      }{
         Indicates the form of key required: 0 - ramp, 1 - histogram.
      }
      \sstsubsection{
         CAXIS = INTEGER (Given)
      }{
         The index of the array axis corresponding to colour index (1 or 2).
      }
      \sstsubsection{
         LBND1 = INTEGER (Given)
      }{
         The lower bound on axis 1.
      }
      \sstsubsection{
         UBND1 = INTEGER (Given)
      }{
         The upper bound on axis 1.
      }
      \sstsubsection{
         LBND2 = INTEGER (Given)
      }{
         The lower bound on axis 2.
      }
      \sstsubsection{
         UBND2 = INTEGER (Given)
      }{
         The upper bound on axis 2.
      }
      \sstsubsection{
         HSTDAT( $*$ ) = INTEGER (Given)
      }{
         A histogram of colour index counts. The length of this vector
         should be equal to the length of axis CAXIS.
      }
      \sstsubsection{
         MAXPOP = INTEGER (Given)
      }{
         The maximum population in any cell of the histogram.
      }
      \sstsubsection{
         LOG = LOGICAL (Given)
      }{
         If TRUE the histogram displays Log(count).
      }
      \sstsubsection{
         COLS( LBND1:UBND1, LBND2:UBND2 ) = INTEGER (Returned)
      }{
         The returned array of colour indices.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 2001 Central Laboratory of the Research Councils
   }
}
\sstroutine{
   KPG1\_LUTK3
}{
   Produce a GRAPH colour table key for KPG1\_LUTKY
}{
   \sstdescription{
      This routine produces a colour table key consisting of 1 or 3 line
      plots (1 if the colour table is a greyscale, and 3 if it is not).
      The line plots are drawn using the supplied Plot.
   }
   \sstinvocation{
      CALL KPG1\_LUTK3( IPLOT, PARAM, APP, LP, UP, X, RGB, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPLOT = INTEGER (Given)
      }{
         The Plot to use.
      }
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the style parameter to use (eg STYLE, KEYSTYLE, etc).
         The appearance of the 3 curves can be set using attribute
         qualifiers (R), (G), and (B) (eg {\tt "}width(r)=10{\tt "} ).
      }
      \sstsubsection{
         APP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The calling application, in the form {\tt "}KAPPA\_LUTVIEW{\tt "}.
      }
      \sstsubsection{
         LP = INTEGER (Given)
      }{
         The lowest PGPLOT colour index to copy.
      }
      \sstsubsection{
         UP = INTEGER (Given)
      }{
         The highest PGPLOT colour index to copy.
      }
      \sstsubsection{
         X( LP:UP, 2 ) = DOUBLE PRECISION (Returned)
      }{
         Work space to hold the X values
      }
      \sstsubsection{
         RGB( LP:UP, 3 ) = DOUBLE PRECISION (Returned)
      }{
         Work space to hold the RGB intensities.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 2001 Central Laboratory of the Research Councils
   }
}
\sstroutine{
   KPG1\_LUTK4
}{
   Produce an AST Mapping from pen number to RGB intensity
}{
   \sstdescription{
      This routine produces an AST Mapping which maps 1-dimensional pen
      number into 3-dimensional RGB intensity within the current PGPLOT
      graphics device.
   }
   \sstinvocation{
      CALL KPG1\_LUTK4( LP, UP, WORK, MAP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LP = INTEGER (Given)
      }{
         The lowest PGPLOT colour index to use.
      }
      \sstsubsection{
         UP = INTEGER (Given)
      }{
         The highest PGPLOT colour index to use.
      }
      \sstsubsection{
         WORK( LP:UP, 3 ) = DOUBLE PRECISION (Returned)
      }{
         Work space.
      }
      \sstsubsection{
         MAP = INTEGER (Returned)
      }{
         The Mapping pointer.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 2001 Central Laboratory of the Research Councils
   }
}
\sstroutine{
   KPG1\_LUTKY
}{
   Draw a key showing a colour table
}{
   \sstdescription{
      The key consists of a ramp of colour covering the specified range
      of colour indices, with annotated axes. Axis 1 is always the data
      value axis (whether it is drawn vertically or horizontally). The
      whole plot (including annotation) is scaled to fit inside the
      picture specified by IPIC.
   }
   \sstinvocation{
      CALL KPG1\_LUTKY( IPIC, PARAM, HIGH, LOW, LABEL, APP, LP, UP, F,
                       GAP1, GAP2, JUST, NEL, COLDAT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPIC = INTEGER (Given)
      }{
         An AGI identifier for a picture in which the key is to be
         produced.
      }
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the style parameter to use (eg STYLE, KEYSTYLE, etc).
      }
      \sstsubsection{
         HIGH = REAL (Given)
      }{
         The X axis value (i.e. pixel value or pen number) corresponding to
         the colour index UP.
      }
      \sstsubsection{
         LOW = REAL (Given)
      }{
         The X axis value (i.e. pixel value or pen number) corresponding to
         the colour index LP.
      }
      \sstsubsection{
         LABEL = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The default label to put against the data values.
      }
      \sstsubsection{
         APP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The calling application, in the form {\tt "}KAPPA\_LUTVIEW{\tt "}.
      }
      \sstsubsection{
         LP = INTEGER (Given)
      }{
         The smallest colour index to include in the display.
      }
      \sstsubsection{
         UP = INTEGER (Given)
      }{
         The largest colour index to include in the display.
      }
      \sstsubsection{
         F = REAL (Given)
      }{
         An amount by which to extend the margins left for annotation,
         expressed as a factor of the height or width of the plotting
         area. For instance, a value of 0.1 could be given to fit the
         annotation {\tt "}comfortably{\tt "} into the Plot. A value of 0.0 will
         result in the annotation being hard up against the edge of the
         plot.
      }
      \sstsubsection{
         GAP1 = REAL (Given)
      }{
         A gap, in millimetres, to place between the bottom or right edge
         of the supplied picture, and the nearest edge of the colour ramp.
      }
      \sstsubsection{
         GAP2 = REAL (Given)
      }{
         A gap, in millimetres, to place between the top or left edge
         of the supplied picture, and the nearest edge of the colour ramp.
      }
      \sstsubsection{
         JUST = CHARACTER$*$2 (Given)
      }{
         Indicates the justification of the new plot within the specified
         area.  {\tt '}BL{\tt '}, {\tt '}BC{\tt '}, {\tt '}BR{\tt '}, {\tt '}CL{\tt '}, {\tt '}CC{\tt '}, {\tt '}CR{\tt '}, {\tt '}TL{\tt '}, {\tt '}TC{\tt '} or {\tt '}TR{\tt '},
         where B is Bottom, C is Centre, T is Top, L is Left and R is
         Right. Must be upper case. Unrecognised values are treated as {\tt "}C{\tt "}.
      }
      \sstsubsection{
         NEL = INTEGER (Given)
      }{
         The size of the vector COLDAT. If this is zero, COLDAT is not
         accessed, and requested for keys in the form of a histogram
         are ignored (that is, keys are always produced in the form of a
         ramp).
      }
      \sstsubsection{
         COLDAT( NEL ) = INTEGER (Given)
      }{
         A vector of colour indices, one for each displayed data pixel.
         Only accessed if NEL is greater than zero and the STYLE
         parameter indicates that the key is to drawn in the form of a
         histogram
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1999 Central Laboratory of the Research Councils
   }
}
\sstroutine{
   KPG1\_MACOL
}{
   Obtain a marker colour
}{
   \sstdescription{
      This routine obtains a colour index to be used to mark features
      in an image display.  A string is obtained from the parameter
      system.  The interpretation of this string provides a number of
      ways to specify the colour index requested.  The options are:

        {\tt '}MAX{\tt '}          - The maximum (non-reserved) colour index, i.e.
                         the highest colour index used for the display
                         of an image.
        {\tt '}MIN{\tt '}          - The minimum non-reserved colour index, i.e. the
                         lowest colour index used for the display of an
                         image.
        An integer     - The actual colour index. It is constrained
                         between 0 and the highest colour index.
        A named colour - Uses the named colour from the palette, and if
                         it is not present, the nearest colour from the
                         palette is selected.
   }
   \sstinvocation{
      CALL KPG1\_MACOL( PNCOL, LP, UP, COLIND, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNCOL = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the ADAM parameter to obtain the marker colour.
         It should have type LITERAL.
      }
      \sstsubsection{
         LP = INTEGER (Given)
      }{
         The lowest non-reserved colour index.
      }
      \sstsubsection{
         UP = INTEGER (Given)
      }{
         The highest non-reserved colour index.
      }
      \sstsubsection{
         COLIND = INTEGER (Returned)
      }{
         The colour index of the selected colour.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         A GKS image-display workstation must be open and active.
      }
   }
}
\sstroutine{
   KPG1\_MANIB
}{
   Copy a data array with axis permutation and expansion
}{
   \sstdescription{
      An input array is copied to an output array under control of a
      supplied AXES vector.  Axes of the output array may be in a
      different order to those of the input array, and it may be
      required to expand along a new dimension or collapse along
      an existing combination (being replaced by the mean of all
      non-bad values).
   }
   \sstinvocation{
      CALL KPG1\_MANIB( NDIMI, DIMI, IN, NDIMO, DIMO, AXES, COLOFF,
                         EXPOFF, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input array.
      }
      \sstsubsection{
         DIMI( NDIMI ) = INTEGER (Given)
      }{
         The shape of the input array.
      }
      \sstsubsection{
         IN( $*$ ) = BYTE (Given)
      }{
         The input data array, vectorised.  The number of elements is
         given by the product of the elements of DIMI.
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output array (the number of elements
         in AXES).
      }
      \sstsubsection{
         DIMO( NDIMO ) = INTEGER (Given)
      }{
         The dimensions of the output array.  Information about the
         extent of the expanded dimesions, as well as information
         implicit in DIMI and AXES, is held here.
      }
      \sstsubsection{
         AXES( NDIMO ) = INTEGER (Given)
      }{
         An array determining how the output array is copied from the
         input array.  The I{\tt '}th element determines the source of the
         I{\tt '}th dimension of the output array.  If it is zero, a new
         dimension will grow there.  Otherwise, it gives the index of
         a dimension of the input array to copy.
      }
      \sstsubsection{
         COLOFF( $*$ ) = INTEGER (Returned)
      }{
         Workspace.  This array must have at least as many elements
         as the product of all the dimensions of the input array along
         which it is to be collapsed; that is the product of each
         element of DIMI whose index does not appear in AXES.
      }
      \sstsubsection{
         EXPOFF( $*$ ) = INTEGER (Returned)
      }{
         Workspace.  This array must have at least as many elements
         as the product of all the newly expanded dimensions in the
         output array; that is the product of each element of DIMO
         for which the corresponding element of AXES is zero.
      }
      \sstsubsection{
         OUT( $*$ ) = BYTE (Returned)
      }{
         The output array, vectorised.  The number of elements written
         is given by the product of the elements of NDIMO.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The assumption that NDF\_\_MXDIM = 7 is hard coded into this
         routine.

         \sstitem
         A few arithmetic operations could be saved, at the expense of
         the code{\tt '}s clarity,  by calculating the various array offsets
         at the same time as the next position vectors at various places
         in this routine.  Since this routine is unlikely to be a
         computational bottleneck I have favoured clarity over optimal
         performance.
      }
   }
}
\sstroutine{
   KPG1\_MANID
}{
   Copy a data array with axis permutation and expansion
}{
   \sstdescription{
      An input array is copied to an output array under control of a
      supplied AXES vector.  Axes of the output array may be in a
      different order to those of the input array, and it may be
      required to expand along a new dimension or collapse along
      an existing combination (being replaced by the mean of all
      non-bad values).
   }
   \sstinvocation{
      CALL KPG1\_MANID( NDIMI, DIMI, IN, NDIMO, DIMO, AXES, COLOFF,
                         EXPOFF, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input array.
      }
      \sstsubsection{
         DIMI( NDIMI ) = INTEGER (Given)
      }{
         The shape of the input array.
      }
      \sstsubsection{
         IN( $*$ ) = DOUBLE PRECISION (Given)
      }{
         The input data array, vectorised.  The number of elements is
         given by the product of the elements of DIMI.
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output array (the number of elements
         in AXES).
      }
      \sstsubsection{
         DIMO( NDIMO ) = INTEGER (Given)
      }{
         The dimensions of the output array.  Information about the
         extent of the expanded dimesions, as well as information
         implicit in DIMI and AXES, is held here.
      }
      \sstsubsection{
         AXES( NDIMO ) = INTEGER (Given)
      }{
         An array determining how the output array is copied from the
         input array.  The I{\tt '}th element determines the source of the
         I{\tt '}th dimension of the output array.  If it is zero, a new
         dimension will grow there.  Otherwise, it gives the index of
         a dimension of the input array to copy.
      }
      \sstsubsection{
         COLOFF( $*$ ) = INTEGER (Returned)
      }{
         Workspace.  This array must have at least as many elements
         as the product of all the dimensions of the input array along
         which it is to be collapsed; that is the product of each
         element of DIMI whose index does not appear in AXES.
      }
      \sstsubsection{
         EXPOFF( $*$ ) = INTEGER (Returned)
      }{
         Workspace.  This array must have at least as many elements
         as the product of all the newly expanded dimensions in the
         output array; that is the product of each element of DIMO
         for which the corresponding element of AXES is zero.
      }
      \sstsubsection{
         OUT( $*$ ) = DOUBLE PRECISION (Returned)
      }{
         The output array, vectorised.  The number of elements written
         is given by the product of the elements of NDIMO.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The assumption that NDF\_\_MXDIM = 7 is hard coded into this
         routine.

         \sstitem
         A few arithmetic operations could be saved, at the expense of
         the code{\tt '}s clarity,  by calculating the various array offsets
         at the same time as the next position vectors at various places
         in this routine.  Since this routine is unlikely to be a
         computational bottleneck I have favoured clarity over optimal
         performance.
      }
   }
}
\sstroutine{
   KPG1\_MANII
}{
   Copy a data array with axis permutation and expansion
}{
   \sstdescription{
      An input array is copied to an output array under control of a
      supplied AXES vector.  Axes of the output array may be in a
      different order to those of the input array, and it may be
      required to expand along a new dimension or collapse along
      an existing combination (being replaced by the mean of all
      non-bad values).
   }
   \sstinvocation{
      CALL KPG1\_MANII( NDIMI, DIMI, IN, NDIMO, DIMO, AXES, COLOFF,
                         EXPOFF, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input array.
      }
      \sstsubsection{
         DIMI( NDIMI ) = INTEGER (Given)
      }{
         The shape of the input array.
      }
      \sstsubsection{
         IN( $*$ ) = INTEGER (Given)
      }{
         The input data array, vectorised.  The number of elements is
         given by the product of the elements of DIMI.
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output array (the number of elements
         in AXES).
      }
      \sstsubsection{
         DIMO( NDIMO ) = INTEGER (Given)
      }{
         The dimensions of the output array.  Information about the
         extent of the expanded dimesions, as well as information
         implicit in DIMI and AXES, is held here.
      }
      \sstsubsection{
         AXES( NDIMO ) = INTEGER (Given)
      }{
         An array determining how the output array is copied from the
         input array.  The I{\tt '}th element determines the source of the
         I{\tt '}th dimension of the output array.  If it is zero, a new
         dimension will grow there.  Otherwise, it gives the index of
         a dimension of the input array to copy.
      }
      \sstsubsection{
         COLOFF( $*$ ) = INTEGER (Returned)
      }{
         Workspace.  This array must have at least as many elements
         as the product of all the dimensions of the input array along
         which it is to be collapsed; that is the product of each
         element of DIMI whose index does not appear in AXES.
      }
      \sstsubsection{
         EXPOFF( $*$ ) = INTEGER (Returned)
      }{
         Workspace.  This array must have at least as many elements
         as the product of all the newly expanded dimensions in the
         output array; that is the product of each element of DIMO
         for which the corresponding element of AXES is zero.
      }
      \sstsubsection{
         OUT( $*$ ) = INTEGER (Returned)
      }{
         The output array, vectorised.  The number of elements written
         is given by the product of the elements of NDIMO.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The assumption that NDF\_\_MXDIM = 7 is hard coded into this
         routine.

         \sstitem
         A few arithmetic operations could be saved, at the expense of
         the code{\tt '}s clarity,  by calculating the various array offsets
         at the same time as the next position vectors at various places
         in this routine.  Since this routine is unlikely to be a
         computational bottleneck I have favoured clarity over optimal
         performance.
      }
   }
}
\sstroutine{
   KPG1\_MANIR
}{
   Copy a data array with axis permutation and expansion
}{
   \sstdescription{
      An input array is copied to an output array under control of a
      supplied AXES vector.  Axes of the output array may be in a
      different order to those of the input array, and it may be
      required to expand along a new dimension or collapse along
      an existing combination (being replaced by the mean of all
      non-bad values).
   }
   \sstinvocation{
      CALL KPG1\_MANIR( NDIMI, DIMI, IN, NDIMO, DIMO, AXES, COLOFF,
                         EXPOFF, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input array.
      }
      \sstsubsection{
         DIMI( NDIMI ) = INTEGER (Given)
      }{
         The shape of the input array.
      }
      \sstsubsection{
         IN( $*$ ) = REAL (Given)
      }{
         The input data array, vectorised.  The number of elements is
         given by the product of the elements of DIMI.
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output array (the number of elements
         in AXES).
      }
      \sstsubsection{
         DIMO( NDIMO ) = INTEGER (Given)
      }{
         The dimensions of the output array.  Information about the
         extent of the expanded dimesions, as well as information
         implicit in DIMI and AXES, is held here.
      }
      \sstsubsection{
         AXES( NDIMO ) = INTEGER (Given)
      }{
         An array determining how the output array is copied from the
         input array.  The I{\tt '}th element determines the source of the
         I{\tt '}th dimension of the output array.  If it is zero, a new
         dimension will grow there.  Otherwise, it gives the index of
         a dimension of the input array to copy.
      }
      \sstsubsection{
         COLOFF( $*$ ) = INTEGER (Returned)
      }{
         Workspace.  This array must have at least as many elements
         as the product of all the dimensions of the input array along
         which it is to be collapsed; that is the product of each
         element of DIMI whose index does not appear in AXES.
      }
      \sstsubsection{
         EXPOFF( $*$ ) = INTEGER (Returned)
      }{
         Workspace.  This array must have at least as many elements
         as the product of all the newly expanded dimensions in the
         output array; that is the product of each element of DIMO
         for which the corresponding element of AXES is zero.
      }
      \sstsubsection{
         OUT( $*$ ) = REAL (Returned)
      }{
         The output array, vectorised.  The number of elements written
         is given by the product of the elements of NDIMO.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The assumption that NDF\_\_MXDIM = 7 is hard coded into this
         routine.

         \sstitem
         A few arithmetic operations could be saved, at the expense of
         the code{\tt '}s clarity,  by calculating the various array offsets
         at the same time as the next position vectors at various places
         in this routine.  Since this routine is unlikely to be a
         computational bottleneck I have favoured clarity over optimal
         performance.
      }
   }
}
\sstroutine{
   KPG1\_MANIUB
}{
   Copy a data array with axis permutation and expansion
}{
   \sstdescription{
      An input array is copied to an output array under control of a
      supplied AXES vector.  Axes of the output array may be in a
      different order to those of the input array, and it may be
      required to expand along a new dimension or collapse along
      an existing combination (being replaced by the mean of all
      non-bad values).
   }
   \sstinvocation{
      CALL KPG1\_MANIUB( NDIMI, DIMI, IN, NDIMO, DIMO, AXES, COLOFF,
                         EXPOFF, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input array.
      }
      \sstsubsection{
         DIMI( NDIMI ) = INTEGER (Given)
      }{
         The shape of the input array.
      }
      \sstsubsection{
         IN( $*$ ) = BYTE (Given)
      }{
         The input data array, vectorised.  The number of elements is
         given by the product of the elements of DIMI.
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output array (the number of elements
         in AXES).
      }
      \sstsubsection{
         DIMO( NDIMO ) = INTEGER (Given)
      }{
         The dimensions of the output array.  Information about the
         extent of the expanded dimesions, as well as information
         implicit in DIMI and AXES, is held here.
      }
      \sstsubsection{
         AXES( NDIMO ) = INTEGER (Given)
      }{
         An array determining how the output array is copied from the
         input array.  The I{\tt '}th element determines the source of the
         I{\tt '}th dimension of the output array.  If it is zero, a new
         dimension will grow there.  Otherwise, it gives the index of
         a dimension of the input array to copy.
      }
      \sstsubsection{
         COLOFF( $*$ ) = INTEGER (Returned)
      }{
         Workspace.  This array must have at least as many elements
         as the product of all the dimensions of the input array along
         which it is to be collapsed; that is the product of each
         element of DIMI whose index does not appear in AXES.
      }
      \sstsubsection{
         EXPOFF( $*$ ) = INTEGER (Returned)
      }{
         Workspace.  This array must have at least as many elements
         as the product of all the newly expanded dimensions in the
         output array; that is the product of each element of DIMO
         for which the corresponding element of AXES is zero.
      }
      \sstsubsection{
         OUT( $*$ ) = BYTE (Returned)
      }{
         The output array, vectorised.  The number of elements written
         is given by the product of the elements of NDIMO.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The assumption that NDF\_\_MXDIM = 7 is hard coded into this
         routine.

         \sstitem
         A few arithmetic operations could be saved, at the expense of
         the code{\tt '}s clarity,  by calculating the various array offsets
         at the same time as the next position vectors at various places
         in this routine.  Since this routine is unlikely to be a
         computational bottleneck I have favoured clarity over optimal
         performance.
      }
   }
}
\sstroutine{
   KPG1\_MANIUW
}{
   Copy a data array with axis permutation and expansion
}{
   \sstdescription{
      An input array is copied to an output array under control of a
      supplied AXES vector.  Axes of the output array may be in a
      different order to those of the input array, and it may be
      required to expand along a new dimension or collapse along
      an existing combination (being replaced by the mean of all
      non-bad values).
   }
   \sstinvocation{
      CALL KPG1\_MANIUW( NDIMI, DIMI, IN, NDIMO, DIMO, AXES, COLOFF,
                         EXPOFF, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input array.
      }
      \sstsubsection{
         DIMI( NDIMI ) = INTEGER (Given)
      }{
         The shape of the input array.
      }
      \sstsubsection{
         IN( $*$ ) = INTEGER$*$2 (Given)
      }{
         The input data array, vectorised.  The number of elements is
         given by the product of the elements of DIMI.
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output array (the number of elements
         in AXES).
      }
      \sstsubsection{
         DIMO( NDIMO ) = INTEGER (Given)
      }{
         The dimensions of the output array.  Information about the
         extent of the expanded dimesions, as well as information
         implicit in DIMI and AXES, is held here.
      }
      \sstsubsection{
         AXES( NDIMO ) = INTEGER (Given)
      }{
         An array determining how the output array is copied from the
         input array.  The I{\tt '}th element determines the source of the
         I{\tt '}th dimension of the output array.  If it is zero, a new
         dimension will grow there.  Otherwise, it gives the index of
         a dimension of the input array to copy.
      }
      \sstsubsection{
         COLOFF( $*$ ) = INTEGER (Returned)
      }{
         Workspace.  This array must have at least as many elements
         as the product of all the dimensions of the input array along
         which it is to be collapsed; that is the product of each
         element of DIMI whose index does not appear in AXES.
      }
      \sstsubsection{
         EXPOFF( $*$ ) = INTEGER (Returned)
      }{
         Workspace.  This array must have at least as many elements
         as the product of all the newly expanded dimensions in the
         output array; that is the product of each element of DIMO
         for which the corresponding element of AXES is zero.
      }
      \sstsubsection{
         OUT( $*$ ) = INTEGER$*$2 (Returned)
      }{
         The output array, vectorised.  The number of elements written
         is given by the product of the elements of NDIMO.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The assumption that NDF\_\_MXDIM = 7 is hard coded into this
         routine.

         \sstitem
         A few arithmetic operations could be saved, at the expense of
         the code{\tt '}s clarity,  by calculating the various array offsets
         at the same time as the next position vectors at various places
         in this routine.  Since this routine is unlikely to be a
         computational bottleneck I have favoured clarity over optimal
         performance.
      }
   }
}
\sstroutine{
   KPG1\_MANIW
}{
   Copy a data array with axis permutation and expansion
}{
   \sstdescription{
      An input array is copied to an output array under control of a
      supplied AXES vector.  Axes of the output array may be in a
      different order to those of the input array, and it may be
      required to expand along a new dimension or collapse along
      an existing combination (being replaced by the mean of all
      non-bad values).
   }
   \sstinvocation{
      CALL KPG1\_MANIW( NDIMI, DIMI, IN, NDIMO, DIMO, AXES, COLOFF,
                         EXPOFF, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input array.
      }
      \sstsubsection{
         DIMI( NDIMI ) = INTEGER (Given)
      }{
         The shape of the input array.
      }
      \sstsubsection{
         IN( $*$ ) = INTEGER$*$2 (Given)
      }{
         The input data array, vectorised.  The number of elements is
         given by the product of the elements of DIMI.
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output array (the number of elements
         in AXES).
      }
      \sstsubsection{
         DIMO( NDIMO ) = INTEGER (Given)
      }{
         The dimensions of the output array.  Information about the
         extent of the expanded dimesions, as well as information
         implicit in DIMI and AXES, is held here.
      }
      \sstsubsection{
         AXES( NDIMO ) = INTEGER (Given)
      }{
         An array determining how the output array is copied from the
         input array.  The I{\tt '}th element determines the source of the
         I{\tt '}th dimension of the output array.  If it is zero, a new
         dimension will grow there.  Otherwise, it gives the index of
         a dimension of the input array to copy.
      }
      \sstsubsection{
         COLOFF( $*$ ) = INTEGER (Returned)
      }{
         Workspace.  This array must have at least as many elements
         as the product of all the dimensions of the input array along
         which it is to be collapsed; that is the product of each
         element of DIMI whose index does not appear in AXES.
      }
      \sstsubsection{
         EXPOFF( $*$ ) = INTEGER (Returned)
      }{
         Workspace.  This array must have at least as many elements
         as the product of all the newly expanded dimensions in the
         output array; that is the product of each element of DIMO
         for which the corresponding element of AXES is zero.
      }
      \sstsubsection{
         OUT( $*$ ) = INTEGER$*$2 (Returned)
      }{
         The output array, vectorised.  The number of elements written
         is given by the product of the elements of NDIMO.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The assumption that NDF\_\_MXDIM = 7 is hard coded into this
         routine.

         \sstitem
         A few arithmetic operations could be saved, at the expense of
         the code{\tt '}s clarity,  by calculating the various array offsets
         at the same time as the next position vectors at various places
         in this routine.  Since this routine is unlikely to be a
         computational bottleneck I have favoured clarity over optimal
         performance.
      }
   }
}
\sstroutine{
   KPG1\_MAP
}{
   Obtain mapped access to an array component of an NDF
}{
   \sstdescription{
      This routine is a wrapper for NDF\_MAP which obtains mapped access
      to an array component of an NDF, returning a pointer to the mapped
      values and a count of the number of elements mapped. At the moment
      this wrapper routine is a dummy which does nothing else.
   }
   \sstinvocation{
      CALL KPG1\_MAP( INDF, COMP, TYPE, MMOD, PNTR, EL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         COMP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the NDF array component to be mapped: {\tt '}DATA{\tt '},
         {\tt '}QUALITY{\tt '} or {\tt '}VARIANCE{\tt '} (or {\tt '}ERROR{\tt '}).
      }
      \sstsubsection{
         TYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Numeric type to be used for access (e.g. {\tt '}\_REAL{\tt '}).
      }
      \sstsubsection{
         MMOD = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Mapping mode for access to the array: {\tt '}READ{\tt '}, {\tt '}UPDATE{\tt '} or
         {\tt '}WRITE{\tt '}, with an optional initialisation mode {\tt '}/BAD{\tt '} or
         {\tt '}/ZERO{\tt '} appended.
      }
      \sstsubsection{
         PNTR( $*$ ) = INTEGER (Returned)
      }{
         Pointer(s) to the mapped values (see the Notes section).
      }
      \sstsubsection{
         EL = INTEGER (Returned)
      }{
         Number of elements mapped.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_MDETx
}{
   Computes the determinant of a matrix
}{
   \sstdescription{
      This routine calculates the determinant of an arbitrary n-by-n
      matrix.  It LU decomposes the matrix and then forms the product
      of the diagonals by summing their logarithms to base 10.
      Logarithmic calculations are used to prevent overflows. A bad
      status is returned when the matrix is singular or the determinant
      is too large to store in a DOUBLE PRECISION-number representation.
   }
   \sstinvocation{
      CALL KPG1\_MDETX( N, EL, ARRAY, WORK1, WORK2, DET, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         The number of rows and columns in the matrix whose determinant
         is to be derived.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The size of the first dimension of the array as declared in the
         calling routine.  This should be at least equal to N.
      }
      \sstsubsection{
         ARRAY( EL, N ) = ? (Given and Returned)
      }{
         On input this is the matrix whose determinant is to be found.
         Since the LU decomposition is performed in situ, the input
         values are lost.  (On exit it is the LU decomposed form of the
         rowwise-permuted input ARRAY, with the diagonals being part of
         the upper triangular matrix.)
      }
      \sstsubsection{
         WORK1( N ) = INTEGER (Returned)
      }{
         Workspace for the LU decomposition.
      }
      \sstsubsection{
         WORK2( N ) = ? (Returned)
      }{
         Workspace for the LU decomposition.
      }
      \sstsubsection{
         DET = ? (Returned)
      }{
         The determinant of matrix ARRAY.  It is set to 1.0 when the
         matrix is singular.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the data types real or double precision:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively, as
         appropriate.  The matrix and the SECOND workspace should have
         this data type as well.
      }
   }
}
\sstroutine{
   KPG1\_MDETx
}{
   Computes the determinant of a matrix
}{
   \sstdescription{
      This routine calculates the determinant of an arbitrary n-by-n
      matrix.  It LU decomposes the matrix and then forms the product
      of the diagonals by summing their logarithms to base 10.
      Logarithmic calculations are used to prevent overflows. A bad
      status is returned when the matrix is singular or the determinant
      is too large to store in a REAL-number representation.
   }
   \sstinvocation{
      CALL KPG1\_MDETX( N, EL, ARRAY, WORK1, WORK2, DET, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         The number of rows and columns in the matrix whose determinant
         is to be derived.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The size of the first dimension of the array as declared in the
         calling routine.  This should be at least equal to N.
      }
      \sstsubsection{
         ARRAY( EL, N ) = ? (Given and Returned)
      }{
         On input this is the matrix whose determinant is to be found.
         Since the LU decomposition is performed in situ, the input
         values are lost.  (On exit it is the LU decomposed form of the
         rowwise-permuted input ARRAY, with the diagonals being part of
         the upper triangular matrix.)
      }
      \sstsubsection{
         WORK1( N ) = INTEGER (Returned)
      }{
         Workspace for the LU decomposition.
      }
      \sstsubsection{
         WORK2( N ) = ? (Returned)
      }{
         Workspace for the LU decomposition.
      }
      \sstsubsection{
         DET = ? (Returned)
      }{
         The determinant of matrix ARRAY.  It is set to 1.0 when the
         matrix is singular.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the data types real or double precision:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively, as
         appropriate.  The matrix and the SECOND workspace should have
         this data type as well.
      }
   }
}
\sstroutine{
   KPG1\_MEANx
}{
   Finds the mean of the good data values in an array
}{
   \sstdescription{
      Finds the mean of the good data values in a 1-D array.
   }
   \sstinvocation{
      CALL KPG1\_MEANx( N, DATA, MEAN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of elements in the array.
      }
      \sstsubsection{
         DATA( N ) = ? (Given)
      }{
         The data array.
      }
      \sstsubsection{
         MEAN = ? (Returned)
      }{
         The mean value.  Set to VAL\_\_BADB if no good data are found.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the standard numeric types.
         Replace {\tt "}x{\tt "} in the routine name by D, R, I, W, UW, B or UB as
         appropriate.    The array and mean arguments supplied to the
         routine must have the data type specified.

         \sstitem
         The summation is carried out in double precision.
      }
   }
}
\sstroutine{
   KPG1\_MEANx
}{
   Finds the mean of the good data values in an array
}{
   \sstdescription{
      Finds the mean of the good data values in a 1-D array.
   }
   \sstinvocation{
      CALL KPG1\_MEANx( N, DATA, MEAN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of elements in the array.
      }
      \sstsubsection{
         DATA( N ) = ? (Given)
      }{
         The data array.
      }
      \sstsubsection{
         MEAN = ? (Returned)
      }{
         The mean value.  Set to VAL\_\_BADD if no good data are found.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the standard numeric types.
         Replace {\tt "}x{\tt "} in the routine name by D, R, I, W, UW, B or UB as
         appropriate.    The array and mean arguments supplied to the
         routine must have the data type specified.

         \sstitem
         The summation is carried out in double precision.
      }
   }
}
\sstroutine{
   KPG1\_MEANx
}{
   Finds the mean of the good data values in an array
}{
   \sstdescription{
      Finds the mean of the good data values in a 1-D array.
   }
   \sstinvocation{
      CALL KPG1\_MEANx( N, DATA, MEAN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of elements in the array.
      }
      \sstsubsection{
         DATA( N ) = ? (Given)
      }{
         The data array.
      }
      \sstsubsection{
         MEAN = ? (Returned)
      }{
         The mean value.  Set to VAL\_\_BADI if no good data are found.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the standard numeric types.
         Replace {\tt "}x{\tt "} in the routine name by D, R, I, W, UW, B or UB as
         appropriate.    The array and mean arguments supplied to the
         routine must have the data type specified.

         \sstitem
         The summation is carried out in double precision.
      }
   }
}
\sstroutine{
   KPG1\_MEANx
}{
   Finds the mean of the good data values in an array
}{
   \sstdescription{
      Finds the mean of the good data values in a 1-D array.
   }
   \sstinvocation{
      CALL KPG1\_MEANx( N, DATA, MEAN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of elements in the array.
      }
      \sstsubsection{
         DATA( N ) = ? (Given)
      }{
         The data array.
      }
      \sstsubsection{
         MEAN = ? (Returned)
      }{
         The mean value.  Set to VAL\_\_BADR if no good data are found.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the standard numeric types.
         Replace {\tt "}x{\tt "} in the routine name by D, R, I, W, UW, B or UB as
         appropriate.    The array and mean arguments supplied to the
         routine must have the data type specified.

         \sstitem
         The summation is carried out in double precision.
      }
   }
}
\sstroutine{
   KPG1\_MEANx
}{
   Finds the mean of the good data values in an array
}{
   \sstdescription{
      Finds the mean of the good data values in a 1-D array.
   }
   \sstinvocation{
      CALL KPG1\_MEANx( N, DATA, MEAN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of elements in the array.
      }
      \sstsubsection{
         DATA( N ) = ? (Given)
      }{
         The data array.
      }
      \sstsubsection{
         MEAN = ? (Returned)
      }{
         The mean value.  Set to VAL\_\_BADUB if no good data are found.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the standard numeric types.
         Replace {\tt "}x{\tt "} in the routine name by D, R, I, W, UW, B or UB as
         appropriate.    The array and mean arguments supplied to the
         routine must have the data type specified.

         \sstitem
         The summation is carried out in double precision.
      }
   }
}
\sstroutine{
   KPG1\_MEANx
}{
   Finds the mean of the good data values in an array
}{
   \sstdescription{
      Finds the mean of the good data values in a 1-D array.
   }
   \sstinvocation{
      CALL KPG1\_MEANx( N, DATA, MEAN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of elements in the array.
      }
      \sstsubsection{
         DATA( N ) = ? (Given)
      }{
         The data array.
      }
      \sstsubsection{
         MEAN = ? (Returned)
      }{
         The mean value.  Set to VAL\_\_BADUW if no good data are found.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the standard numeric types.
         Replace {\tt "}x{\tt "} in the routine name by D, R, I, W, UW, B or UB as
         appropriate.    The array and mean arguments supplied to the
         routine must have the data type specified.

         \sstitem
         The summation is carried out in double precision.
      }
   }
}
\sstroutine{
   KPG1\_MEANx
}{
   Finds the mean of the good data values in an array
}{
   \sstdescription{
      Finds the mean of the good data values in a 1-D array.
   }
   \sstinvocation{
      CALL KPG1\_MEANx( N, DATA, MEAN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of elements in the array.
      }
      \sstsubsection{
         DATA( N ) = ? (Given)
      }{
         The data array.
      }
      \sstsubsection{
         MEAN = ? (Returned)
      }{
         The mean value.  Set to VAL\_\_BADW if no good data are found.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the standard numeric types.
         Replace {\tt "}x{\tt "} in the routine name by D, R, I, W, UW, B or UB as
         appropriate.    The array and mean arguments supplied to the
         routine must have the data type specified.

         \sstitem
         The summation is carried out in double precision.
      }
   }
}
\sstroutine{
   KPG1\_MEDUB
}{
   Derives the unweighted median of a vector
}{
   \sstdescription{
      This routine derives the unweighted median of an array.  If there
      are an even number of elements, the median is computed from the
      mean of the two elements that straddle the median.
   }
   \sstinvocation{
      CALL KPG1\_MEDUB( BAD, EL, ARRAY, MEDIAN, NELUSE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If BAD is .TRUE. there may be bad pixels present in the vector
         and so should be tested.  If BAD is .FALSE. there is no testing
         for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements within the array to sort.
      }
      \sstsubsection{
         ARRAY( EL ) = BYTE (Given and Returned)
      }{
         The array whose median is to be found.  On exit the array is
         partially sorted.
      }
      \sstsubsection{
         MEDIAN = BYTE (Returned)
      }{
         The median of the array.
      }
      \sstsubsection{
         NELUSE = INTEGER (Returned)
      }{
         The number of elements actually used after bad values have been
         excluded.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type.
      }
   }
}
\sstroutine{
   KPG1\_MEDUD
}{
   Derives the unweighted median of a vector
}{
   \sstdescription{
      This routine derives the unweighted median of an array.  If there
      are an even number of elements, the median is computed from the
      mean of the two elements that straddle the median.
   }
   \sstinvocation{
      CALL KPG1\_MEDUD( BAD, EL, ARRAY, MEDIAN, NELUSE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If BAD is .TRUE. there may be bad pixels present in the vector
         and so should be tested.  If BAD is .FALSE. there is no testing
         for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements within the array to sort.
      }
      \sstsubsection{
         ARRAY( EL ) = DOUBLE PRECISION (Given and Returned)
      }{
         The array whose median is to be found.  On exit the array is
         partially sorted.
      }
      \sstsubsection{
         MEDIAN = DOUBLE PRECISION (Returned)
      }{
         The median of the array.
      }
      \sstsubsection{
         NELUSE = INTEGER (Returned)
      }{
         The number of elements actually used after bad values have been
         excluded.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type.
      }
   }
}
\sstroutine{
   KPG1\_MEDUI
}{
   Derives the unweighted median of a vector
}{
   \sstdescription{
      This routine derives the unweighted median of an array.  If there
      are an even number of elements, the median is computed from the
      mean of the two elements that straddle the median.
   }
   \sstinvocation{
      CALL KPG1\_MEDUI( BAD, EL, ARRAY, MEDIAN, NELUSE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If BAD is .TRUE. there may be bad pixels present in the vector
         and so should be tested.  If BAD is .FALSE. there is no testing
         for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements within the array to sort.
      }
      \sstsubsection{
         ARRAY( EL ) = INTEGER (Given and Returned)
      }{
         The array whose median is to be found.  On exit the array is
         partially sorted.
      }
      \sstsubsection{
         MEDIAN = INTEGER (Returned)
      }{
         The median of the array.
      }
      \sstsubsection{
         NELUSE = INTEGER (Returned)
      }{
         The number of elements actually used after bad values have been
         excluded.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type.
      }
   }
}
\sstroutine{
   KPG1\_MEDUR
}{
   Derives the unweighted median of a vector
}{
   \sstdescription{
      This routine derives the unweighted median of an array.  If there
      are an even number of elements, the median is computed from the
      mean of the two elements that straddle the median.
   }
   \sstinvocation{
      CALL KPG1\_MEDUR( BAD, EL, ARRAY, MEDIAN, NELUSE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If BAD is .TRUE. there may be bad pixels present in the vector
         and so should be tested.  If BAD is .FALSE. there is no testing
         for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements within the array to sort.
      }
      \sstsubsection{
         ARRAY( EL ) = REAL (Given and Returned)
      }{
         The array whose median is to be found.  On exit the array is
         partially sorted.
      }
      \sstsubsection{
         MEDIAN = REAL (Returned)
      }{
         The median of the array.
      }
      \sstsubsection{
         NELUSE = INTEGER (Returned)
      }{
         The number of elements actually used after bad values have been
         excluded.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type.
      }
   }
}
\sstroutine{
   KPG1\_MEDUUB
}{
   Derives the unweighted median of a vector
}{
   \sstdescription{
      This routine derives the unweighted median of an array.  If there
      are an even number of elements, the median is computed from the
      mean of the two elements that straddle the median.
   }
   \sstinvocation{
      CALL KPG1\_MEDUUB( BAD, EL, ARRAY, MEDIAN, NELUSE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If BAD is .TRUE. there may be bad pixels present in the vector
         and so should be tested.  If BAD is .FALSE. there is no testing
         for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements within the array to sort.
      }
      \sstsubsection{
         ARRAY( EL ) = BYTE (Given and Returned)
      }{
         The array whose median is to be found.  On exit the array is
         partially sorted.
      }
      \sstsubsection{
         MEDIAN = BYTE (Returned)
      }{
         The median of the array.
      }
      \sstsubsection{
         NELUSE = INTEGER (Returned)
      }{
         The number of elements actually used after bad values have been
         excluded.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type.
      }
   }
}
\sstroutine{
   KPG1\_MEDUUW
}{
   Derives the unweighted median of a vector
}{
   \sstdescription{
      This routine derives the unweighted median of an array.  If there
      are an even number of elements, the median is computed from the
      mean of the two elements that straddle the median.
   }
   \sstinvocation{
      CALL KPG1\_MEDUUW( BAD, EL, ARRAY, MEDIAN, NELUSE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If BAD is .TRUE. there may be bad pixels present in the vector
         and so should be tested.  If BAD is .FALSE. there is no testing
         for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements within the array to sort.
      }
      \sstsubsection{
         ARRAY( EL ) = INTEGER$*$2 (Given and Returned)
      }{
         The array whose median is to be found.  On exit the array is
         partially sorted.
      }
      \sstsubsection{
         MEDIAN = INTEGER$*$2 (Returned)
      }{
         The median of the array.
      }
      \sstsubsection{
         NELUSE = INTEGER (Returned)
      }{
         The number of elements actually used after bad values have been
         excluded.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type.
      }
   }
}
\sstroutine{
   KPG1\_MEDUW
}{
   Derives the unweighted median of a vector
}{
   \sstdescription{
      This routine derives the unweighted median of an array.  If there
      are an even number of elements, the median is computed from the
      mean of the two elements that straddle the median.
   }
   \sstinvocation{
      CALL KPG1\_MEDUW( BAD, EL, ARRAY, MEDIAN, NELUSE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If BAD is .TRUE. there may be bad pixels present in the vector
         and so should be tested.  If BAD is .FALSE. there is no testing
         for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements within the array to sort.
      }
      \sstsubsection{
         ARRAY( EL ) = INTEGER$*$2 (Given and Returned)
      }{
         The array whose median is to be found.  On exit the array is
         partially sorted.
      }
      \sstsubsection{
         MEDIAN = INTEGER$*$2 (Returned)
      }{
         The median of the array.
      }
      \sstsubsection{
         NELUSE = INTEGER (Returned)
      }{
         The number of elements actually used after bad values have been
         excluded.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type.
      }
   }
}
\sstroutine{
   KPG1\_MIXVx
}{
   Obtains from a parameter character values from either a menu of
   options or within a numeric range
}{
   \sstdescription{
      This routine obtains a group of character values from a
      parameter.  Each value must be either:

         o  one of a supplied list of acceptable values, with
            unambiguous abbreviations accepted; or

         o  a numeric character string equivalent to a number, and the
            number must lie within a supplied range of acceptable
            values.
   }
   \sstinvocation{
      CALL KPG1\_MIXVx( PARAM, MAXVAL, VMIN, VMAX, OPTS, VALUES, ACTVAL,
                      STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter. A GRP group expression should be
         supplied for the parameter.
      }
      \sstsubsection{
         MAXVAL = INTEGER (Given)
      }{
         The maximum number of values required.  A PAR\_\_ERROR status is
         returned when the number of values requested is less than one.
      }
      \sstsubsection{
         VMIN = BYTE (Given)
      }{
         The value immediately above a range wherein the obtained
         numeric values cannot lie.  Thus if VMAX is greater than VMIN,
         VMIN is the minimum numeric value allowed for the obtained
         values.  However, should VMAX be less than VMIN, all numeric
         values are acceptable except those between VMAX and VMIN
         exclusive.
      }
      \sstsubsection{
         VMAX = BYTE (Given)
      }{
         The value immediately below a range wherein the obtained
         numeric values cannot lie.  Thus if VMAX is greater than VMIN,
         VMAX is the maximum numeric value allowed for the obtained
         values.  However, should VMAX be less than VMIN, all numeric
         values are acceptable except those between VMAX and VMIN
         exclusive.
      }
      \sstsubsection{
         OPTS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The list of acceptable options for each value obtained from the
         parameter.  Items should be separated by commas.  The list is
         case-insensitive.
      }
      \sstsubsection{
         VALUES( MAXVAL ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The selected values that are either options from the list or
         the character form of numeric values that satisfy the range
         constraint.  The former values are in uppercase and in full,
         even if an abbreviation has been given for the actual
         parameter.  Note that all values must satisfy the constraints.
         The values will only be valid if STATUS is not set to an error
         value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numerical data type: replace {\tt "}x{\tt "} in
         the routine name by D or R as appropriate.  The data range
         arguments supplied to the routine must have the data type
         specified.

         \sstitem
         There are two stages to identify or validate each character
         value obtained from the parameter. In the first the value is
         converted to the required data type. If this is successful, the
         derived numeric value is compared with the range of acceptable
         values defined by VMIN and VMAX.  A value satisfying these
         constraints is returned in the VALUES. The second stage searches
         for a match of the character value with an item in the menu.

         \sstitem
         This routine adheres to the following rules.
            o  All comparisons are performed in uppercase.  Leading blanks
            are ignored.
            o  A match is found when the value equals the full name of an
            option.  This enables an option to be the prefix of another
            item without it being regarded as ambiguous.  For example,
            {\tt "}10,100,200{\tt "} would be an acceptable list of options.
            o  If there is no exact match, an abbreviation is acceptable.
            A comparison is made of the value with each option for the
            number of characters in the value.  The option that best fits
            the value is declared a match, subject to two provisos.
            Firstly, there must be no more than one character different
            between the value and the start of the option.  (This allows
            for a mistyped character.)  Secondly, there must be only one
            best-fitting option.  Whenever these criteria are not
            satisfied, the user is told of the error, and is presented
            with the list of options, before being prompted for new
            values.  This is not achieved through the MIN/MAX system.
      }
   }
}
\sstroutine{
   KPG1\_MIXVx
}{
   Obtains from a parameter character values from either a menu of
   options or within a numeric range
}{
   \sstdescription{
      This routine obtains a group of character values from a
      parameter.  Each value must be either:

         o  one of a supplied list of acceptable values, with
            unambiguous abbreviations accepted; or

         o  a numeric character string equivalent to a number, and the
            number must lie within a supplied range of acceptable
            values.
   }
   \sstinvocation{
      CALL KPG1\_MIXVx( PARAM, MAXVAL, VMIN, VMAX, OPTS, VALUES, ACTVAL,
                      STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter. A GRP group expression should be
         supplied for the parameter.
      }
      \sstsubsection{
         MAXVAL = INTEGER (Given)
      }{
         The maximum number of values required.  A PAR\_\_ERROR status is
         returned when the number of values requested is less than one.
      }
      \sstsubsection{
         VMIN = DOUBLE PRECISION (Given)
      }{
         The value immediately above a range wherein the obtained
         numeric values cannot lie.  Thus if VMAX is greater than VMIN,
         VMIN is the minimum numeric value allowed for the obtained
         values.  However, should VMAX be less than VMIN, all numeric
         values are acceptable except those between VMAX and VMIN
         exclusive.
      }
      \sstsubsection{
         VMAX = DOUBLE PRECISION (Given)
      }{
         The value immediately below a range wherein the obtained
         numeric values cannot lie.  Thus if VMAX is greater than VMIN,
         VMAX is the maximum numeric value allowed for the obtained
         values.  However, should VMAX be less than VMIN, all numeric
         values are acceptable except those between VMAX and VMIN
         exclusive.
      }
      \sstsubsection{
         OPTS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The list of acceptable options for each value obtained from the
         parameter.  Items should be separated by commas.  The list is
         case-insensitive.
      }
      \sstsubsection{
         VALUES( MAXVAL ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The selected values that are either options from the list or
         the character form of numeric values that satisfy the range
         constraint.  The former values are in uppercase and in full,
         even if an abbreviation has been given for the actual
         parameter.  Note that all values must satisfy the constraints.
         The values will only be valid if STATUS is not set to an error
         value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numerical data type: replace {\tt "}x{\tt "} in
         the routine name by D or R as appropriate.  The data range
         arguments supplied to the routine must have the data type
         specified.

         \sstitem
         There are two stages to identify or validate each character
         value obtained from the parameter. In the first the value is
         converted to the required data type. If this is successful, the
         derived numeric value is compared with the range of acceptable
         values defined by VMIN and VMAX.  A value satisfying these
         constraints is returned in the VALUES. The second stage searches
         for a match of the character value with an item in the menu.

         \sstitem
         This routine adheres to the following rules.
            o  All comparisons are performed in uppercase.  Leading blanks
            are ignored.
            o  A match is found when the value equals the full name of an
            option.  This enables an option to be the prefix of another
            item without it being regarded as ambiguous.  For example,
            {\tt "}10,100,200{\tt "} would be an acceptable list of options.
            o  If there is no exact match, an abbreviation is acceptable.
            A comparison is made of the value with each option for the
            number of characters in the value.  The option that best fits
            the value is declared a match, subject to two provisos.
            Firstly, there must be no more than one character different
            between the value and the start of the option.  (This allows
            for a mistyped character.)  Secondly, there must be only one
            best-fitting option.  Whenever these criteria are not
            satisfied, the user is told of the error, and is presented
            with the list of options, before being prompted for new
            values.  This is not achieved through the MIN/MAX system.
      }
   }
}
\sstroutine{
   KPG1\_MIXVx
}{
   Obtains from a parameter character values from either a menu of
   options or within a numeric range
}{
   \sstdescription{
      This routine obtains a group of character values from a
      parameter.  Each value must be either:

         o  one of a supplied list of acceptable values, with
            unambiguous abbreviations accepted; or

         o  a numeric character string equivalent to a number, and the
            number must lie within a supplied range of acceptable
            values.
   }
   \sstinvocation{
      CALL KPG1\_MIXVx( PARAM, MAXVAL, VMIN, VMAX, OPTS, VALUES, ACTVAL,
                      STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter. A GRP group expression should be
         supplied for the parameter.
      }
      \sstsubsection{
         MAXVAL = INTEGER (Given)
      }{
         The maximum number of values required.  A PAR\_\_ERROR status is
         returned when the number of values requested is less than one.
      }
      \sstsubsection{
         VMIN = INTEGER (Given)
      }{
         The value immediately above a range wherein the obtained
         numeric values cannot lie.  Thus if VMAX is greater than VMIN,
         VMIN is the minimum numeric value allowed for the obtained
         values.  However, should VMAX be less than VMIN, all numeric
         values are acceptable except those between VMAX and VMIN
         exclusive.
      }
      \sstsubsection{
         VMAX = INTEGER (Given)
      }{
         The value immediately below a range wherein the obtained
         numeric values cannot lie.  Thus if VMAX is greater than VMIN,
         VMAX is the maximum numeric value allowed for the obtained
         values.  However, should VMAX be less than VMIN, all numeric
         values are acceptable except those between VMAX and VMIN
         exclusive.
      }
      \sstsubsection{
         OPTS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The list of acceptable options for each value obtained from the
         parameter.  Items should be separated by commas.  The list is
         case-insensitive.
      }
      \sstsubsection{
         VALUES( MAXVAL ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The selected values that are either options from the list or
         the character form of numeric values that satisfy the range
         constraint.  The former values are in uppercase and in full,
         even if an abbreviation has been given for the actual
         parameter.  Note that all values must satisfy the constraints.
         The values will only be valid if STATUS is not set to an error
         value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numerical data type: replace {\tt "}x{\tt "} in
         the routine name by D or R as appropriate.  The data range
         arguments supplied to the routine must have the data type
         specified.

         \sstitem
         There are two stages to identify or validate each character
         value obtained from the parameter. In the first the value is
         converted to the required data type. If this is successful, the
         derived numeric value is compared with the range of acceptable
         values defined by VMIN and VMAX.  A value satisfying these
         constraints is returned in the VALUES. The second stage searches
         for a match of the character value with an item in the menu.

         \sstitem
         This routine adheres to the following rules.
            o  All comparisons are performed in uppercase.  Leading blanks
            are ignored.
            o  A match is found when the value equals the full name of an
            option.  This enables an option to be the prefix of another
            item without it being regarded as ambiguous.  For example,
            {\tt "}10,100,200{\tt "} would be an acceptable list of options.
            o  If there is no exact match, an abbreviation is acceptable.
            A comparison is made of the value with each option for the
            number of characters in the value.  The option that best fits
            the value is declared a match, subject to two provisos.
            Firstly, there must be no more than one character different
            between the value and the start of the option.  (This allows
            for a mistyped character.)  Secondly, there must be only one
            best-fitting option.  Whenever these criteria are not
            satisfied, the user is told of the error, and is presented
            with the list of options, before being prompted for new
            values.  This is not achieved through the MIN/MAX system.
      }
   }
}
\sstroutine{
   KPG1\_MIXVx
}{
   Obtains from a parameter character values from either a menu of
   options or within a numeric range
}{
   \sstdescription{
      This routine obtains a group of character values from a
      parameter.  Each value must be either:

         o  one of a supplied list of acceptable values, with
            unambiguous abbreviations accepted; or

         o  a numeric character string equivalent to a number, and the
            number must lie within a supplied range of acceptable
            values.
   }
   \sstinvocation{
      CALL KPG1\_MIXVx( PARAM, MAXVAL, VMIN, VMAX, OPTS, VALUES, ACTVAL,
                      STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter. A GRP group expression should be
         supplied for the parameter.
      }
      \sstsubsection{
         MAXVAL = INTEGER (Given)
      }{
         The maximum number of values required.  A PAR\_\_ERROR status is
         returned when the number of values requested is less than one.
      }
      \sstsubsection{
         VMIN = REAL (Given)
      }{
         The value immediately above a range wherein the obtained
         numeric values cannot lie.  Thus if VMAX is greater than VMIN,
         VMIN is the minimum numeric value allowed for the obtained
         values.  However, should VMAX be less than VMIN, all numeric
         values are acceptable except those between VMAX and VMIN
         exclusive.
      }
      \sstsubsection{
         VMAX = REAL (Given)
      }{
         The value immediately below a range wherein the obtained
         numeric values cannot lie.  Thus if VMAX is greater than VMIN,
         VMAX is the maximum numeric value allowed for the obtained
         values.  However, should VMAX be less than VMIN, all numeric
         values are acceptable except those between VMAX and VMIN
         exclusive.
      }
      \sstsubsection{
         OPTS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The list of acceptable options for each value obtained from the
         parameter.  Items should be separated by commas.  The list is
         case-insensitive.
      }
      \sstsubsection{
         VALUES( MAXVAL ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The selected values that are either options from the list or
         the character form of numeric values that satisfy the range
         constraint.  The former values are in uppercase and in full,
         even if an abbreviation has been given for the actual
         parameter.  Note that all values must satisfy the constraints.
         The values will only be valid if STATUS is not set to an error
         value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numerical data type: replace {\tt "}x{\tt "} in
         the routine name by D or R as appropriate.  The data range
         arguments supplied to the routine must have the data type
         specified.

         \sstitem
         There are two stages to identify or validate each character
         value obtained from the parameter. In the first the value is
         converted to the required data type. If this is successful, the
         derived numeric value is compared with the range of acceptable
         values defined by VMIN and VMAX.  A value satisfying these
         constraints is returned in the VALUES. The second stage searches
         for a match of the character value with an item in the menu.

         \sstitem
         This routine adheres to the following rules.
            o  All comparisons are performed in uppercase.  Leading blanks
            are ignored.
            o  A match is found when the value equals the full name of an
            option.  This enables an option to be the prefix of another
            item without it being regarded as ambiguous.  For example,
            {\tt "}10,100,200{\tt "} would be an acceptable list of options.
            o  If there is no exact match, an abbreviation is acceptable.
            A comparison is made of the value with each option for the
            number of characters in the value.  The option that best fits
            the value is declared a match, subject to two provisos.
            Firstly, there must be no more than one character different
            between the value and the start of the option.  (This allows
            for a mistyped character.)  Secondly, there must be only one
            best-fitting option.  Whenever these criteria are not
            satisfied, the user is told of the error, and is presented
            with the list of options, before being prompted for new
            values.  This is not achieved through the MIN/MAX system.
      }
   }
}
\sstroutine{
   KPG1\_MIXVx
}{
   Obtains from a parameter character values from either a menu of
   options or within a numeric range
}{
   \sstdescription{
      This routine obtains a group of character values from a
      parameter.  Each value must be either:

         o  one of a supplied list of acceptable values, with
            unambiguous abbreviations accepted; or

         o  a numeric character string equivalent to a number, and the
            number must lie within a supplied range of acceptable
            values.
   }
   \sstinvocation{
      CALL KPG1\_MIXVx( PARAM, MAXVAL, VMIN, VMAX, OPTS, VALUES, ACTVAL,
                      STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter. A GRP group expression should be
         supplied for the parameter.
      }
      \sstsubsection{
         MAXVAL = INTEGER (Given)
      }{
         The maximum number of values required.  A PAR\_\_ERROR status is
         returned when the number of values requested is less than one.
      }
      \sstsubsection{
         VMIN = BYTE (Given)
      }{
         The value immediately above a range wherein the obtained
         numeric values cannot lie.  Thus if VMAX is greater than VMIN,
         VMIN is the minimum numeric value allowed for the obtained
         values.  However, should VMAX be less than VMIN, all numeric
         values are acceptable except those between VMAX and VMIN
         exclusive.
      }
      \sstsubsection{
         VMAX = BYTE (Given)
      }{
         The value immediately below a range wherein the obtained
         numeric values cannot lie.  Thus if VMAX is greater than VMIN,
         VMAX is the maximum numeric value allowed for the obtained
         values.  However, should VMAX be less than VMIN, all numeric
         values are acceptable except those between VMAX and VMIN
         exclusive.
      }
      \sstsubsection{
         OPTS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The list of acceptable options for each value obtained from the
         parameter.  Items should be separated by commas.  The list is
         case-insensitive.
      }
      \sstsubsection{
         VALUES( MAXVAL ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The selected values that are either options from the list or
         the character form of numeric values that satisfy the range
         constraint.  The former values are in uppercase and in full,
         even if an abbreviation has been given for the actual
         parameter.  Note that all values must satisfy the constraints.
         The values will only be valid if STATUS is not set to an error
         value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numerical data type: replace {\tt "}x{\tt "} in
         the routine name by D or R as appropriate.  The data range
         arguments supplied to the routine must have the data type
         specified.

         \sstitem
         There are two stages to identify or validate each character
         value obtained from the parameter. In the first the value is
         converted to the required data type. If this is successful, the
         derived numeric value is compared with the range of acceptable
         values defined by VMIN and VMAX.  A value satisfying these
         constraints is returned in the VALUES. The second stage searches
         for a match of the character value with an item in the menu.

         \sstitem
         This routine adheres to the following rules.
            o  All comparisons are performed in uppercase.  Leading blanks
            are ignored.
            o  A match is found when the value equals the full name of an
            option.  This enables an option to be the prefix of another
            item without it being regarded as ambiguous.  For example,
            {\tt "}10,100,200{\tt "} would be an acceptable list of options.
            o  If there is no exact match, an abbreviation is acceptable.
            A comparison is made of the value with each option for the
            number of characters in the value.  The option that best fits
            the value is declared a match, subject to two provisos.
            Firstly, there must be no more than one character different
            between the value and the start of the option.  (This allows
            for a mistyped character.)  Secondly, there must be only one
            best-fitting option.  Whenever these criteria are not
            satisfied, the user is told of the error, and is presented
            with the list of options, before being prompted for new
            values.  This is not achieved through the MIN/MAX system.
      }
   }
}
\sstroutine{
   KPG1\_MIXVx
}{
   Obtains from a parameter character values from either a menu of
   options or within a numeric range
}{
   \sstdescription{
      This routine obtains a group of character values from a
      parameter.  Each value must be either:

         o  one of a supplied list of acceptable values, with
            unambiguous abbreviations accepted; or

         o  a numeric character string equivalent to a number, and the
            number must lie within a supplied range of acceptable
            values.
   }
   \sstinvocation{
      CALL KPG1\_MIXVx( PARAM, MAXVAL, VMIN, VMAX, OPTS, VALUES, ACTVAL,
                      STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter. A GRP group expression should be
         supplied for the parameter.
      }
      \sstsubsection{
         MAXVAL = INTEGER (Given)
      }{
         The maximum number of values required.  A PAR\_\_ERROR status is
         returned when the number of values requested is less than one.
      }
      \sstsubsection{
         VMIN = INTEGER$*$2 (Given)
      }{
         The value immediately above a range wherein the obtained
         numeric values cannot lie.  Thus if VMAX is greater than VMIN,
         VMIN is the minimum numeric value allowed for the obtained
         values.  However, should VMAX be less than VMIN, all numeric
         values are acceptable except those between VMAX and VMIN
         exclusive.
      }
      \sstsubsection{
         VMAX = INTEGER$*$2 (Given)
      }{
         The value immediately below a range wherein the obtained
         numeric values cannot lie.  Thus if VMAX is greater than VMIN,
         VMAX is the maximum numeric value allowed for the obtained
         values.  However, should VMAX be less than VMIN, all numeric
         values are acceptable except those between VMAX and VMIN
         exclusive.
      }
      \sstsubsection{
         OPTS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The list of acceptable options for each value obtained from the
         parameter.  Items should be separated by commas.  The list is
         case-insensitive.
      }
      \sstsubsection{
         VALUES( MAXVAL ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The selected values that are either options from the list or
         the character form of numeric values that satisfy the range
         constraint.  The former values are in uppercase and in full,
         even if an abbreviation has been given for the actual
         parameter.  Note that all values must satisfy the constraints.
         The values will only be valid if STATUS is not set to an error
         value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numerical data type: replace {\tt "}x{\tt "} in
         the routine name by D or R as appropriate.  The data range
         arguments supplied to the routine must have the data type
         specified.

         \sstitem
         There are two stages to identify or validate each character
         value obtained from the parameter. In the first the value is
         converted to the required data type. If this is successful, the
         derived numeric value is compared with the range of acceptable
         values defined by VMIN and VMAX.  A value satisfying these
         constraints is returned in the VALUES. The second stage searches
         for a match of the character value with an item in the menu.

         \sstitem
         This routine adheres to the following rules.
            o  All comparisons are performed in uppercase.  Leading blanks
            are ignored.
            o  A match is found when the value equals the full name of an
            option.  This enables an option to be the prefix of another
            item without it being regarded as ambiguous.  For example,
            {\tt "}10,100,200{\tt "} would be an acceptable list of options.
            o  If there is no exact match, an abbreviation is acceptable.
            A comparison is made of the value with each option for the
            number of characters in the value.  The option that best fits
            the value is declared a match, subject to two provisos.
            Firstly, there must be no more than one character different
            between the value and the start of the option.  (This allows
            for a mistyped character.)  Secondly, there must be only one
            best-fitting option.  Whenever these criteria are not
            satisfied, the user is told of the error, and is presented
            with the list of options, before being prompted for new
            values.  This is not achieved through the MIN/MAX system.
      }
   }
}
\sstroutine{
   KPG1\_MIXVx
}{
   Obtains from a parameter character values from either a menu of
   options or within a numeric range
}{
   \sstdescription{
      This routine obtains a group of character values from a
      parameter.  Each value must be either:

         o  one of a supplied list of acceptable values, with
            unambiguous abbreviations accepted; or

         o  a numeric character string equivalent to a number, and the
            number must lie within a supplied range of acceptable
            values.
   }
   \sstinvocation{
      CALL KPG1\_MIXVx( PARAM, MAXVAL, VMIN, VMAX, OPTS, VALUES, ACTVAL,
                      STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter. A GRP group expression should be
         supplied for the parameter.
      }
      \sstsubsection{
         MAXVAL = INTEGER (Given)
      }{
         The maximum number of values required.  A PAR\_\_ERROR status is
         returned when the number of values requested is less than one.
      }
      \sstsubsection{
         VMIN = INTEGER$*$2 (Given)
      }{
         The value immediately above a range wherein the obtained
         numeric values cannot lie.  Thus if VMAX is greater than VMIN,
         VMIN is the minimum numeric value allowed for the obtained
         values.  However, should VMAX be less than VMIN, all numeric
         values are acceptable except those between VMAX and VMIN
         exclusive.
      }
      \sstsubsection{
         VMAX = INTEGER$*$2 (Given)
      }{
         The value immediately below a range wherein the obtained
         numeric values cannot lie.  Thus if VMAX is greater than VMIN,
         VMAX is the maximum numeric value allowed for the obtained
         values.  However, should VMAX be less than VMIN, all numeric
         values are acceptable except those between VMAX and VMIN
         exclusive.
      }
      \sstsubsection{
         OPTS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The list of acceptable options for each value obtained from the
         parameter.  Items should be separated by commas.  The list is
         case-insensitive.
      }
      \sstsubsection{
         VALUES( MAXVAL ) = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The selected values that are either options from the list or
         the character form of numeric values that satisfy the range
         constraint.  The former values are in uppercase and in full,
         even if an abbreviation has been given for the actual
         parameter.  Note that all values must satisfy the constraints.
         The values will only be valid if STATUS is not set to an error
         value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numerical data type: replace {\tt "}x{\tt "} in
         the routine name by D or R as appropriate.  The data range
         arguments supplied to the routine must have the data type
         specified.

         \sstitem
         There are two stages to identify or validate each character
         value obtained from the parameter. In the first the value is
         converted to the required data type. If this is successful, the
         derived numeric value is compared with the range of acceptable
         values defined by VMIN and VMAX.  A value satisfying these
         constraints is returned in the VALUES. The second stage searches
         for a match of the character value with an item in the menu.

         \sstitem
         This routine adheres to the following rules.
            o  All comparisons are performed in uppercase.  Leading blanks
            are ignored.
            o  A match is found when the value equals the full name of an
            option.  This enables an option to be the prefix of another
            item without it being regarded as ambiguous.  For example,
            {\tt "}10,100,200{\tt "} would be an acceptable list of options.
            o  If there is no exact match, an abbreviation is acceptable.
            A comparison is made of the value with each option for the
            number of characters in the value.  The option that best fits
            the value is declared a match, subject to two provisos.
            Firstly, there must be no more than one character different
            between the value and the start of the option.  (This allows
            for a mistyped character.)  Secondly, there must be only one
            best-fitting option.  Whenever these criteria are not
            satisfied, the user is told of the error, and is presented
            with the list of options, before being prompted for new
            values.  This is not achieved through the MIN/MAX system.
      }
   }
}
\sstroutine{
   KPG1\_MKPOS
}{
   Mark a position on a graphics device
}{
   \sstdescription{
      This routine marks a position on a graphics device in various ways.
   }
   \sstinvocation{
      CALL KPG1\_MKPOS( NAX, POS, IPLOT, CURR, MODE, MARKER, GEO, DONE,
                       CLOSE, TEXT, JUST, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NAX = INTEGER (Given)
      }{
         The number of co-ordinate values supplied in POS. This should be
         equal to the number of axes in the Frame specified by CURR.
      }
      \sstsubsection{
         POS( NAX ) = DOUBLE PRECISION (Given)
      }{
         The co-ordinates of the position, in the Frame specified by CURR.
         No marker is drawn if a AST\_\_BAD or VAL\_\_BADD value is supplied
         Ignored if DONE is .TRUE., and MODE is {\tt "}POLY{\tt "}, {\tt "}CHAIN{\tt "} or {\tt "}BOX{\tt "}.
      }
      \sstsubsection{
         IPLOT = INTEGER (Given)
      }{
         An AST pointer to a Plot. The same Plot should be supplied for
         all points in a polygon, chain, or set of boxes.
      }
      \sstsubsection{
         CURR = LOGICAL (Given)
      }{
         If .TRUE., then position supplied in POS refers to the Current
         Frame in IPLOT. Otherwise it refers to the Base Frame (which
         should be the GRAPHICS Frame).
      }
      \sstsubsection{
         MODE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The type of marker to produce (case sensitive, no abbreviations):

         \sstitemlist{

            \sstitem
            {\tt "}NONE{\tt "} -- An immediate return is made without any graphics
            being drawn.

            \sstitem
            {\tt "}MARK{\tt "} -- Each position is marked by the symbol specified
            by argument MARKER.

            \sstitem
            {\tt "}POLY{\tt "} -- Causes each position to be joined by a line to the
            previous position marked.  These lines may be geodesic (in the
            Current Frame of the Plot) or straight (on the screen), as specified
            by argument GEO.

            \sstitem
            {\tt "}CHAIN{\tt "} -- This is a combination of {\tt "}Mark{\tt "} and {\tt "}Poly{\tt "}. Each
            position is marked by a symbol and joined by a line to the previous
            position. Arguments MARKER, GEO, and CLOSE are used to specify
            the symbols and lines to use.

            \sstitem
            {\tt "}BOX{\tt "} -- An empty rectangle with edges parallel to the axes is
            drawn extending between the supplied position and the previous
            position.

            \sstitem
            {\tt "}VLINE{\tt "} -- A vertical line is drawn through the position
            covering the entire height of the Plot.

            \sstitem
            {\tt "}HLINE{\tt "} -- A horizontal line is drawn through the position
            covering the entire height of the Plot.

            \sstitem
            {\tt "}CROSS{\tt "} -- A full-screen cross-hair is drawn at the position, i.e.
            a combination of Vline and Hline.

            \sstitem
            {\tt "}TEXT{\tt "} -- The text string specified by argument TEXT is
            displayed, horizontally, and centred on the supplied position.

            \sstitem
            {\tt "}BLANK{\tt "} -- Nothing is drawn.
         }
      }
      \sstsubsection{
         MARKER = INTEGER (Given)
      }{
         The PGPLOT marker type to use if MODE is {\tt "}MARKER{\tt "} or {\tt "}CHAIN{\tt "}.
      }
      \sstsubsection{
         GEO = LOGICAL (Given)
      }{
         Should polygon and chain line segments be drawn as geodesic curves
         within the Current Frame of the Plot? If not they are drawn as simple
         straight lines within the Base Frame (GRAPHICS). The same value
         should be supplied for all points in a polygon or chain.
      }
      \sstsubsection{
         DONE = LOGICAL (Given)
      }{
         Should be supplied .TRUE. when a polygon, chain or set of boxes has
         been completed. The contents of POS will be ignored in this case.
         DONE is ignored if MODE is not {\tt "}PLOT{\tt "}, {\tt "}CHAIN{\tt "} or {\tt "}BOX{\tt "}.
      }
      \sstsubsection{
         CLOSE = LOGICAL (Given)
      }{
         If .TRUE., polygons and chains are closed by joining the first
         position to the last position (when DONE is supplied .TRUE.).
      }
      \sstsubsection{
         TEXT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The text to display if MODE is {\tt "}TEXT{\tt "}. Trailing spaces are
         ignored.
      }
      \sstsubsection{
         JUST = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A string specifying the justification to be used when displaying
         the text supplied in TEXT (ignored if MODE is not {\tt "}Text{\tt "}). This
         should be a string of two characters; the first should be {\tt "}B{\tt "},
         {\tt "}C{\tt "} or {\tt "}T{\tt "}, meaning bottom, centre or top. The second should be
         {\tt "}L{\tt "}, {\tt "}C{\tt "} or {\tt "}R{\tt "}, meaning left, centre or right. The text is
         displayed so that the position supplied in POS is at the
         specified point within the displayed text string.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_MXMNx
}{
   Returns the maximum and minimum values of an array within
   thresholds
}{
   \sstdescription{
      This routine returns the maximum and minimum values of an input
      array, where it found the maximum and minimum, and the number of
      good and bad pixels in the array.  The extreme values can be
      constrained to lie between two thresholds, where values outside
      the thresholds are ignored.  So for example this routine might be
      used to find the smallest positive value or the largest negative
      value.

      An error report is made if all the values are bad or lie outside
      of the thresholds.
   }
   \sstinvocation{
       CALL KPG1\_MXMNx( BAD, EL, ARRAY, THRESH, NINVAL, MAXMUM,
      :                 MINMUM, MAXPOS, MINPOS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If .TRUE., there may be bad pixels present in the array.  If
         .FALSE., it is safe not to check for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         Input array of data.
      }
      \sstsubsection{
         THRESH( 2 ) = ? (Given)
      }{
         The thresholds between which the extreme values are to be
         found (lower then upper).  Values equal to the thresholds are
         excluded.  To find the extreme values across the full range,
         set the thresholds to VAL\_\_MINx and VAL\_\_MAXx or use routine
         KPG\_MXMNx.
      }
      \sstsubsection{
         NINVAL = INTEGER (Returned)
      }{
         Number of bad pixels in the array.
      }
      \sstsubsection{
         MAXMUM = ? (Returned)
      }{
         Maximum value found in the array.
      }
      \sstsubsection{
         MINMUM = ? (Returned)
      }{
         Minimum value found in the array.
      }
      \sstsubsection{
         MAXPOS = INTEGER (Returned)
      }{
         Index of the pixel where the maximum value is (first) found.
      }
      \sstsubsection{
         MINPOS = INTEGER (Returned)
      }{
         Index of the pixel where the minimum value is (first) found.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY, THRESH, MAXMUM, and MINMUM arguments supplied to the
         routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_MXMNx
}{
   Returns the maximum and minimum values of an array within
   thresholds
}{
   \sstdescription{
      This routine returns the maximum and minimum values of an input
      array, where it found the maximum and minimum, and the number of
      good and bad pixels in the array.  The extreme values can be
      constrained to lie between two thresholds, where values outside
      the thresholds are ignored.  So for example this routine might be
      used to find the smallest positive value or the largest negative
      value.

      An error report is made if all the values are bad or lie outside
      of the thresholds.
   }
   \sstinvocation{
       CALL KPG1\_MXMNx( BAD, EL, ARRAY, THRESH, NINVAL, MAXMUM,
      :                 MINMUM, MAXPOS, MINPOS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If .TRUE., there may be bad pixels present in the array.  If
         .FALSE., it is safe not to check for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         Input array of data.
      }
      \sstsubsection{
         THRESH( 2 ) = ? (Given)
      }{
         The thresholds between which the extreme values are to be
         found (lower then upper).  Values equal to the thresholds are
         excluded.  To find the extreme values across the full range,
         set the thresholds to VAL\_\_MINx and VAL\_\_MAXx or use routine
         KPG\_MXMNx.
      }
      \sstsubsection{
         NINVAL = INTEGER (Returned)
      }{
         Number of bad pixels in the array.
      }
      \sstsubsection{
         MAXMUM = ? (Returned)
      }{
         Maximum value found in the array.
      }
      \sstsubsection{
         MINMUM = ? (Returned)
      }{
         Minimum value found in the array.
      }
      \sstsubsection{
         MAXPOS = INTEGER (Returned)
      }{
         Index of the pixel where the maximum value is (first) found.
      }
      \sstsubsection{
         MINPOS = INTEGER (Returned)
      }{
         Index of the pixel where the minimum value is (first) found.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY, THRESH, MAXMUM, and MINMUM arguments supplied to the
         routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_MXMNx
}{
   Returns the maximum and minimum values of an array within
   thresholds
}{
   \sstdescription{
      This routine returns the maximum and minimum values of an input
      array, where it found the maximum and minimum, and the number of
      good and bad pixels in the array.  The extreme values can be
      constrained to lie between two thresholds, where values outside
      the thresholds are ignored.  So for example this routine might be
      used to find the smallest positive value or the largest negative
      value.

      An error report is made if all the values are bad or lie outside
      of the thresholds.
   }
   \sstinvocation{
       CALL KPG1\_MXMNx( BAD, EL, ARRAY, THRESH, NINVAL, MAXMUM,
      :                 MINMUM, MAXPOS, MINPOS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If .TRUE., there may be bad pixels present in the array.  If
         .FALSE., it is safe not to check for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         Input array of data.
      }
      \sstsubsection{
         THRESH( 2 ) = ? (Given)
      }{
         The thresholds between which the extreme values are to be
         found (lower then upper).  Values equal to the thresholds are
         excluded.  To find the extreme values across the full range,
         set the thresholds to VAL\_\_MINx and VAL\_\_MAXx or use routine
         KPG\_MXMNx.
      }
      \sstsubsection{
         NINVAL = INTEGER (Returned)
      }{
         Number of bad pixels in the array.
      }
      \sstsubsection{
         MAXMUM = ? (Returned)
      }{
         Maximum value found in the array.
      }
      \sstsubsection{
         MINMUM = ? (Returned)
      }{
         Minimum value found in the array.
      }
      \sstsubsection{
         MAXPOS = INTEGER (Returned)
      }{
         Index of the pixel where the maximum value is (first) found.
      }
      \sstsubsection{
         MINPOS = INTEGER (Returned)
      }{
         Index of the pixel where the minimum value is (first) found.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY, THRESH, MAXMUM, and MINMUM arguments supplied to the
         routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_MXMNx
}{
   Returns the maximum and minimum values of an array within
   thresholds
}{
   \sstdescription{
      This routine returns the maximum and minimum values of an input
      array, where it found the maximum and minimum, and the number of
      good and bad pixels in the array.  The extreme values can be
      constrained to lie between two thresholds, where values outside
      the thresholds are ignored.  So for example this routine might be
      used to find the smallest positive value or the largest negative
      value.

      An error report is made if all the values are bad or lie outside
      of the thresholds.
   }
   \sstinvocation{
       CALL KPG1\_MXMNx( BAD, EL, ARRAY, THRESH, NINVAL, MAXMUM,
      :                 MINMUM, MAXPOS, MINPOS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If .TRUE., there may be bad pixels present in the array.  If
         .FALSE., it is safe not to check for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         Input array of data.
      }
      \sstsubsection{
         THRESH( 2 ) = ? (Given)
      }{
         The thresholds between which the extreme values are to be
         found (lower then upper).  Values equal to the thresholds are
         excluded.  To find the extreme values across the full range,
         set the thresholds to VAL\_\_MINx and VAL\_\_MAXx or use routine
         KPG\_MXMNx.
      }
      \sstsubsection{
         NINVAL = INTEGER (Returned)
      }{
         Number of bad pixels in the array.
      }
      \sstsubsection{
         MAXMUM = ? (Returned)
      }{
         Maximum value found in the array.
      }
      \sstsubsection{
         MINMUM = ? (Returned)
      }{
         Minimum value found in the array.
      }
      \sstsubsection{
         MAXPOS = INTEGER (Returned)
      }{
         Index of the pixel where the maximum value is (first) found.
      }
      \sstsubsection{
         MINPOS = INTEGER (Returned)
      }{
         Index of the pixel where the minimum value is (first) found.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY, THRESH, MAXMUM, and MINMUM arguments supplied to the
         routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_MXMNx
}{
   Returns the maximum and minimum values of an array within
   thresholds
}{
   \sstdescription{
      This routine returns the maximum and minimum values of an input
      array, where it found the maximum and minimum, and the number of
      good and bad pixels in the array.  The extreme values can be
      constrained to lie between two thresholds, where values outside
      the thresholds are ignored.  So for example this routine might be
      used to find the smallest positive value or the largest negative
      value.

      An error report is made if all the values are bad or lie outside
      of the thresholds.
   }
   \sstinvocation{
       CALL KPG1\_MXMNx( BAD, EL, ARRAY, THRESH, NINVAL, MAXMUM,
      :                 MINMUM, MAXPOS, MINPOS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If .TRUE., there may be bad pixels present in the array.  If
         .FALSE., it is safe not to check for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         Input array of data.
      }
      \sstsubsection{
         THRESH( 2 ) = ? (Given)
      }{
         The thresholds between which the extreme values are to be
         found (lower then upper).  Values equal to the thresholds are
         excluded.  To find the extreme values across the full range,
         set the thresholds to VAL\_\_MINx and VAL\_\_MAXx or use routine
         KPG\_MXMNx.
      }
      \sstsubsection{
         NINVAL = INTEGER (Returned)
      }{
         Number of bad pixels in the array.
      }
      \sstsubsection{
         MAXMUM = ? (Returned)
      }{
         Maximum value found in the array.
      }
      \sstsubsection{
         MINMUM = ? (Returned)
      }{
         Minimum value found in the array.
      }
      \sstsubsection{
         MAXPOS = INTEGER (Returned)
      }{
         Index of the pixel where the maximum value is (first) found.
      }
      \sstsubsection{
         MINPOS = INTEGER (Returned)
      }{
         Index of the pixel where the minimum value is (first) found.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY, THRESH, MAXMUM, and MINMUM arguments supplied to the
         routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_MXMNx
}{
   Returns the maximum and minimum values of an array within
   thresholds
}{
   \sstdescription{
      This routine returns the maximum and minimum values of an input
      array, where it found the maximum and minimum, and the number of
      good and bad pixels in the array.  The extreme values can be
      constrained to lie between two thresholds, where values outside
      the thresholds are ignored.  So for example this routine might be
      used to find the smallest positive value or the largest negative
      value.

      An error report is made if all the values are bad or lie outside
      of the thresholds.
   }
   \sstinvocation{
       CALL KPG1\_MXMNx( BAD, EL, ARRAY, THRESH, NINVAL, MAXMUM,
      :                 MINMUM, MAXPOS, MINPOS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If .TRUE., there may be bad pixels present in the array.  If
         .FALSE., it is safe not to check for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         Input array of data.
      }
      \sstsubsection{
         THRESH( 2 ) = ? (Given)
      }{
         The thresholds between which the extreme values are to be
         found (lower then upper).  Values equal to the thresholds are
         excluded.  To find the extreme values across the full range,
         set the thresholds to VAL\_\_MINx and VAL\_\_MAXx or use routine
         KPG\_MXMNx.
      }
      \sstsubsection{
         NINVAL = INTEGER (Returned)
      }{
         Number of bad pixels in the array.
      }
      \sstsubsection{
         MAXMUM = ? (Returned)
      }{
         Maximum value found in the array.
      }
      \sstsubsection{
         MINMUM = ? (Returned)
      }{
         Minimum value found in the array.
      }
      \sstsubsection{
         MAXPOS = INTEGER (Returned)
      }{
         Index of the pixel where the maximum value is (first) found.
      }
      \sstsubsection{
         MINPOS = INTEGER (Returned)
      }{
         Index of the pixel where the minimum value is (first) found.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY, THRESH, MAXMUM, and MINMUM arguments supplied to the
         routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_MXMNx
}{
   Returns the maximum and minimum values of an array within
   thresholds
}{
   \sstdescription{
      This routine returns the maximum and minimum values of an input
      array, where it found the maximum and minimum, and the number of
      good and bad pixels in the array.  The extreme values can be
      constrained to lie between two thresholds, where values outside
      the thresholds are ignored.  So for example this routine might be
      used to find the smallest positive value or the largest negative
      value.

      An error report is made if all the values are bad or lie outside
      of the thresholds.
   }
   \sstinvocation{
       CALL KPG1\_MXMNx( BAD, EL, ARRAY, THRESH, NINVAL, MAXMUM,
      :                 MINMUM, MAXPOS, MINPOS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If .TRUE., there may be bad pixels present in the array.  If
         .FALSE., it is safe not to check for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         Input array of data.
      }
      \sstsubsection{
         THRESH( 2 ) = ? (Given)
      }{
         The thresholds between which the extreme values are to be
         found (lower then upper).  Values equal to the thresholds are
         excluded.  To find the extreme values across the full range,
         set the thresholds to VAL\_\_MINx and VAL\_\_MAXx or use routine
         KPG\_MXMNx.
      }
      \sstsubsection{
         NINVAL = INTEGER (Returned)
      }{
         Number of bad pixels in the array.
      }
      \sstsubsection{
         MAXMUM = ? (Returned)
      }{
         Maximum value found in the array.
      }
      \sstsubsection{
         MINMUM = ? (Returned)
      }{
         Minimum value found in the array.
      }
      \sstsubsection{
         MAXPOS = INTEGER (Returned)
      }{
         Index of the pixel where the maximum value is (first) found.
      }
      \sstsubsection{
         MINPOS = INTEGER (Returned)
      }{
         Index of the pixel where the minimum value is (first) found.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY, THRESH, MAXMUM, and MINMUM arguments supplied to the
         routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_MODEx
}{
   To estimate the mean of a number of normally distributed data
   values, some of which may be corrupt
}{
   \sstdescription{
      The routine is based on maximising the likelihood function for a
      statistical model in which any of the data points has a constant
      probability of being corrupt.  A weighted mean is chosen
      according to the deviation of each data point from the current
      estimate of the mean.  The weights are derived from the relative
      probabilities of being valid or corrupt.  A sequence of these
      iterations converges to a stationary point in the likelihood
      function.  The routine approximates to a k-sigma clipping
      algorithm for a large number of data points and to a
      mode-estimating algorithm for fewer data points.
   }
   \sstinvocation{
       CALL KPG1\_MODEx(  X, NX, PBAD, NITER, TOLL, XMODE, SIGMA,
      :                  STATUS )
   }
   \sstarguments{
      \sstsubsection{
         X( NX ) = ? (Given)
      }{
         An array of data values.
      }
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         The number of data values.
      }
      \sstsubsection{
         PBAD = REAL (Given)
      }{
         An estimate of the probability that any one data point will be
         corrupt.  (This value is not critical.)
      }
      \sstsubsection{
         NITER = INTEGER (Given)
      }{
         The maximum number of iterations required.
      }
      \sstsubsection{
         TOLL = REAL (Given)
      }{
         The absolute accuracy required in the estimate of the
         mean.  Iterations cease when two successive estimates
         differ by less than this amount.
      }
      \sstsubsection{
         XMODE = REAL (Returned)
      }{
         The estimate of the uncorrupted mean.
      }
      \sstsubsection{
         SIGMA = REAL (Returned)
      }{
         An estimate of the uncorrupted standard deviation of the data
         points.
      }
      \sstsubsection{
         STATUS = INTEGER (Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each numeric data type: replace {\tt "}x{\tt "} in the
      routine name by D, R, I, W, UW, B, UB as appropriate.  The array
      supplied to the routine must have the data type specified.
   }
}
\sstroutine{
   KPG1\_MODEx
}{
   To estimate the mean of a number of normally distributed data
   values, some of which may be corrupt
}{
   \sstdescription{
      The routine is based on maximising the likelihood function for a
      statistical model in which any of the data points has a constant
      probability of being corrupt.  A weighted mean is chosen
      according to the deviation of each data point from the current
      estimate of the mean.  The weights are derived from the relative
      probabilities of being valid or corrupt.  A sequence of these
      iterations converges to a stationary point in the likelihood
      function.  The routine approximates to a k-sigma clipping
      algorithm for a large number of data points and to a
      mode-estimating algorithm for fewer data points.
   }
   \sstinvocation{
       CALL KPG1\_MODEx(  X, NX, PBAD, NITER, TOLL, XMODE, SIGMA,
      :                  STATUS )
   }
   \sstarguments{
      \sstsubsection{
         X( NX ) = ? (Given)
      }{
         An array of data values.
      }
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         The number of data values.
      }
      \sstsubsection{
         PBAD = REAL (Given)
      }{
         An estimate of the probability that any one data point will be
         corrupt.  (This value is not critical.)
      }
      \sstsubsection{
         NITER = INTEGER (Given)
      }{
         The maximum number of iterations required.
      }
      \sstsubsection{
         TOLL = REAL (Given)
      }{
         The absolute accuracy required in the estimate of the
         mean.  Iterations cease when two successive estimates
         differ by less than this amount.
      }
      \sstsubsection{
         XMODE = REAL (Returned)
      }{
         The estimate of the uncorrupted mean.
      }
      \sstsubsection{
         SIGMA = REAL (Returned)
      }{
         An estimate of the uncorrupted standard deviation of the data
         points.
      }
      \sstsubsection{
         STATUS = INTEGER (Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each numeric data type: replace {\tt "}x{\tt "} in the
      routine name by D, R, I, W, UW, B, UB as appropriate.  The array
      supplied to the routine must have the data type specified.
   }
}
\sstroutine{
   KPG1\_MODEx
}{
   To estimate the mean of a number of normally distributed data
   values, some of which may be corrupt
}{
   \sstdescription{
      The routine is based on maximising the likelihood function for a
      statistical model in which any of the data points has a constant
      probability of being corrupt.  A weighted mean is chosen
      according to the deviation of each data point from the current
      estimate of the mean.  The weights are derived from the relative
      probabilities of being valid or corrupt.  A sequence of these
      iterations converges to a stationary point in the likelihood
      function.  The routine approximates to a k-sigma clipping
      algorithm for a large number of data points and to a
      mode-estimating algorithm for fewer data points.
   }
   \sstinvocation{
       CALL KPG1\_MODEx(  X, NX, PBAD, NITER, TOLL, XMODE, SIGMA,
      :                  STATUS )
   }
   \sstarguments{
      \sstsubsection{
         X( NX ) = ? (Given)
      }{
         An array of data values.
      }
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         The number of data values.
      }
      \sstsubsection{
         PBAD = REAL (Given)
      }{
         An estimate of the probability that any one data point will be
         corrupt.  (This value is not critical.)
      }
      \sstsubsection{
         NITER = INTEGER (Given)
      }{
         The maximum number of iterations required.
      }
      \sstsubsection{
         TOLL = REAL (Given)
      }{
         The absolute accuracy required in the estimate of the
         mean.  Iterations cease when two successive estimates
         differ by less than this amount.
      }
      \sstsubsection{
         XMODE = REAL (Returned)
      }{
         The estimate of the uncorrupted mean.
      }
      \sstsubsection{
         SIGMA = REAL (Returned)
      }{
         An estimate of the uncorrupted standard deviation of the data
         points.
      }
      \sstsubsection{
         STATUS = INTEGER (Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each numeric data type: replace {\tt "}x{\tt "} in the
      routine name by D, R, I, W, UW, B, UB as appropriate.  The array
      supplied to the routine must have the data type specified.
   }
}
\sstroutine{
   KPG1\_MODEx
}{
   To estimate the mean of a number of normally distributed data
   values, some of which may be corrupt
}{
   \sstdescription{
      The routine is based on maximising the likelihood function for a
      statistical model in which any of the data points has a constant
      probability of being corrupt.  A weighted mean is chosen
      according to the deviation of each data point from the current
      estimate of the mean.  The weights are derived from the relative
      probabilities of being valid or corrupt.  A sequence of these
      iterations converges to a stationary point in the likelihood
      function.  The routine approximates to a k-sigma clipping
      algorithm for a large number of data points and to a
      mode-estimating algorithm for fewer data points.
   }
   \sstinvocation{
       CALL KPG1\_MODEx(  X, NX, PBAD, NITER, TOLL, XMODE, SIGMA,
      :                  STATUS )
   }
   \sstarguments{
      \sstsubsection{
         X( NX ) = ? (Given)
      }{
         An array of data values.
      }
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         The number of data values.
      }
      \sstsubsection{
         PBAD = REAL (Given)
      }{
         An estimate of the probability that any one data point will be
         corrupt.  (This value is not critical.)
      }
      \sstsubsection{
         NITER = INTEGER (Given)
      }{
         The maximum number of iterations required.
      }
      \sstsubsection{
         TOLL = REAL (Given)
      }{
         The absolute accuracy required in the estimate of the
         mean.  Iterations cease when two successive estimates
         differ by less than this amount.
      }
      \sstsubsection{
         XMODE = REAL (Returned)
      }{
         The estimate of the uncorrupted mean.
      }
      \sstsubsection{
         SIGMA = REAL (Returned)
      }{
         An estimate of the uncorrupted standard deviation of the data
         points.
      }
      \sstsubsection{
         STATUS = INTEGER (Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each numeric data type: replace {\tt "}x{\tt "} in the
      routine name by D, R, I, W, UW, B, UB as appropriate.  The array
      supplied to the routine must have the data type specified.
   }
}
\sstroutine{
   KPG1\_MODEx
}{
   To estimate the mean of a number of normally distributed data
   values, some of which may be corrupt
}{
   \sstdescription{
      The routine is based on maximising the likelihood function for a
      statistical model in which any of the data points has a constant
      probability of being corrupt.  A weighted mean is chosen
      according to the deviation of each data point from the current
      estimate of the mean.  The weights are derived from the relative
      probabilities of being valid or corrupt.  A sequence of these
      iterations converges to a stationary point in the likelihood
      function.  The routine approximates to a k-sigma clipping
      algorithm for a large number of data points and to a
      mode-estimating algorithm for fewer data points.
   }
   \sstinvocation{
       CALL KPG1\_MODEx(  X, NX, PBAD, NITER, TOLL, XMODE, SIGMA,
      :                  STATUS )
   }
   \sstarguments{
      \sstsubsection{
         X( NX ) = ? (Given)
      }{
         An array of data values.
      }
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         The number of data values.
      }
      \sstsubsection{
         PBAD = REAL (Given)
      }{
         An estimate of the probability that any one data point will be
         corrupt.  (This value is not critical.)
      }
      \sstsubsection{
         NITER = INTEGER (Given)
      }{
         The maximum number of iterations required.
      }
      \sstsubsection{
         TOLL = REAL (Given)
      }{
         The absolute accuracy required in the estimate of the
         mean.  Iterations cease when two successive estimates
         differ by less than this amount.
      }
      \sstsubsection{
         XMODE = REAL (Returned)
      }{
         The estimate of the uncorrupted mean.
      }
      \sstsubsection{
         SIGMA = REAL (Returned)
      }{
         An estimate of the uncorrupted standard deviation of the data
         points.
      }
      \sstsubsection{
         STATUS = INTEGER (Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each numeric data type: replace {\tt "}x{\tt "} in the
      routine name by D, R, I, W, UW, B, UB as appropriate.  The array
      supplied to the routine must have the data type specified.
   }
}
\sstroutine{
   KPG1\_MODEx
}{
   To estimate the mean of a number of normally distributed data
   values, some of which may be corrupt
}{
   \sstdescription{
      The routine is based on maximising the likelihood function for a
      statistical model in which any of the data points has a constant
      probability of being corrupt.  A weighted mean is chosen
      according to the deviation of each data point from the current
      estimate of the mean.  The weights are derived from the relative
      probabilities of being valid or corrupt.  A sequence of these
      iterations converges to a stationary point in the likelihood
      function.  The routine approximates to a k-sigma clipping
      algorithm for a large number of data points and to a
      mode-estimating algorithm for fewer data points.
   }
   \sstinvocation{
       CALL KPG1\_MODEx(  X, NX, PBAD, NITER, TOLL, XMODE, SIGMA,
      :                  STATUS )
   }
   \sstarguments{
      \sstsubsection{
         X( NX ) = ? (Given)
      }{
         An array of data values.
      }
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         The number of data values.
      }
      \sstsubsection{
         PBAD = REAL (Given)
      }{
         An estimate of the probability that any one data point will be
         corrupt.  (This value is not critical.)
      }
      \sstsubsection{
         NITER = INTEGER (Given)
      }{
         The maximum number of iterations required.
      }
      \sstsubsection{
         TOLL = REAL (Given)
      }{
         The absolute accuracy required in the estimate of the
         mean.  Iterations cease when two successive estimates
         differ by less than this amount.
      }
      \sstsubsection{
         XMODE = REAL (Returned)
      }{
         The estimate of the uncorrupted mean.
      }
      \sstsubsection{
         SIGMA = REAL (Returned)
      }{
         An estimate of the uncorrupted standard deviation of the data
         points.
      }
      \sstsubsection{
         STATUS = INTEGER (Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each numeric data type: replace {\tt "}x{\tt "} in the
      routine name by D, R, I, W, UW, B, UB as appropriate.  The array
      supplied to the routine must have the data type specified.
   }
}
\sstroutine{
   KPG1\_MODEx
}{
   To estimate the mean of a number of normally distributed data
   values, some of which may be corrupt
}{
   \sstdescription{
      The routine is based on maximising the likelihood function for a
      statistical model in which any of the data points has a constant
      probability of being corrupt.  A weighted mean is chosen
      according to the deviation of each data point from the current
      estimate of the mean.  The weights are derived from the relative
      probabilities of being valid or corrupt.  A sequence of these
      iterations converges to a stationary point in the likelihood
      function.  The routine approximates to a k-sigma clipping
      algorithm for a large number of data points and to a
      mode-estimating algorithm for fewer data points.
   }
   \sstinvocation{
       CALL KPG1\_MODEx(  X, NX, PBAD, NITER, TOLL, XMODE, SIGMA,
      :                  STATUS )
   }
   \sstarguments{
      \sstsubsection{
         X( NX ) = ? (Given)
      }{
         An array of data values.
      }
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         The number of data values.
      }
      \sstsubsection{
         PBAD = REAL (Given)
      }{
         An estimate of the probability that any one data point will be
         corrupt.  (This value is not critical.)
      }
      \sstsubsection{
         NITER = INTEGER (Given)
      }{
         The maximum number of iterations required.
      }
      \sstsubsection{
         TOLL = REAL (Given)
      }{
         The absolute accuracy required in the estimate of the
         mean.  Iterations cease when two successive estimates
         differ by less than this amount.
      }
      \sstsubsection{
         XMODE = REAL (Returned)
      }{
         The estimate of the uncorrupted mean.
      }
      \sstsubsection{
         SIGMA = REAL (Returned)
      }{
         An estimate of the uncorrupted standard deviation of the data
         points.
      }
      \sstsubsection{
         STATUS = INTEGER (Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each numeric data type: replace {\tt "}x{\tt "} in the
      routine name by D, R, I, W, UW, B, UB as appropriate.  The array
      supplied to the routine must have the data type specified.
   }
}
\sstroutine{
   KPG1\_MONOx
}{
   Determines whether an array{\tt '}s values increase or decrease
   monotonically
}{
   \sstdescription{
      This routine determines whether or not a vector of values
      increase or decrease monotonically.  This is most useful
      for axes.
   }
   \sstinvocation{
      CALL KPG1\_MONOx( BAD, EL, ARRAY, MONOTO, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If BAD=.TRUE., there may be bad values present in the
         array, and it instructs this routine to test for the
         presence of bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         The array to be tested.
      }
      \sstsubsection{
         MONOTO = LOGICAL (Returned)
      }{
         If MONOTO is .TRUE., the array values are monotonic.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the each of the numeric data types.
         replace {\tt "}x{\tt "} in the routine name by B, D, I, R, W, UB, or UB as
         as appropriate.  The array should have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_MONOx
}{
   Determines whether an array{\tt '}s values increase or decrease
   monotonically
}{
   \sstdescription{
      This routine determines whether or not a vector of values
      increase or decrease monotonically.  This is most useful
      for axes.
   }
   \sstinvocation{
      CALL KPG1\_MONOx( BAD, EL, ARRAY, MONOTO, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If BAD=.TRUE., there may be bad values present in the
         array, and it instructs this routine to test for the
         presence of bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         The array to be tested.
      }
      \sstsubsection{
         MONOTO = LOGICAL (Returned)
      }{
         If MONOTO is .TRUE., the array values are monotonic.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the each of the numeric data types.
         replace {\tt "}x{\tt "} in the routine name by B, D, I, R, W, UB, or UB as
         as appropriate.  The array should have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_MTHEx
}{
   Evaluate a mathematical expression for a set of data and variance
   arrays
}{
   \sstdescription{
      The routine evaluates a general mathematical expression giving
      the values in an output data array in terms of values in a set of
      input data arrays, each of the same size. The expression to be
      evaluated is specified by means of a mapping identifier obtained
      from the TRANSFORM system (see SUN/61). A set of input variance
      arrays is also supplied, and this routine uses these to obtain
      estimates of the variance in the evaluated results. These output
      variance estimates are obtained numerically by perturbing the
      input data values by appropriate amounts.
   }
   \sstinvocation{
      CALL KPG1\_MTHEx( BAD, EL, N, DAT, VFLAG, VAR, IMAP, QUICK,
                       MXBAT, WRK, RES, VRES, BADDR, BADVR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether it is necessary to check for bad values in the input
         data or variance arrays.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of elements in each input data array.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of input data arrays.
      }
      \sstsubsection{
         DAT( EL, N ) = ? (Given)
      }{
         Array containing each separate input data array stored in a
         separate row.
      }
      \sstsubsection{
         VFLAG( N ) = LOGICAL (Given)
      }{
         A set of logical flags indicating which of the input data
         arrays stored in the DAT array have associated variance values
         (stored in the VAR array). If the VFLAG value for a data array
         is .TRUE., then variance values exist, otherwise there is no
         associated variance array so a variance of zero will be
         assumed.
      }
      \sstsubsection{
         VAR( EL, $*$ ) = ? (Given)
      }{
         Array containing variance estimates for the input data arrays.
         These values are stored in the rows of this array in the same
         order as the associated data values, but the total number of
         rows may be smaller than N due to the absence of values for
         those data arrays with a VFLAG value of .FALSE..  The declared
         second dimension size of the VAR array must be at least equal
         to the number of .TRUE. values in the VFLAG array.
      }
      \sstsubsection{
         IMAP = INTEGER (Given)
      }{
         A TRANSFORM system identifier for an \{N--$>$1\} compiled mapping
         which defines the mathematical expression to be evaluated.
      }
      \sstsubsection{
         QUICK = LOGICAL (Given)
      }{
         If this argument is set to .TRUE., then output variance
         estimates will be made by perturbing each input data array in
         turn, but in the positive direction only. If it is set to
         .FALSE., then each input data array will be perturbed in both
         directions and the maximum resulting output perturbation will
         be used to estimate the output variance. The former approach
         has the advantage of speed, but the latter gives more accurate
         results, especially for highly non-linear functions.
      }
      \sstsubsection{
         MXBAT = INTEGER (Given)
      }{
         A positive integer defining the size of workspace supplied.
         The input data arrays will be processed in {\tt "}batches{\tt "}, each of
         which does not contain more than this number of elements. If
         this value is too low, then excessive time will be spent in
         looping and subroutine calls. If it is too high, then
         excessive page faulting may occur. A value of about 256 is
         normally adequate.
      }
      \sstsubsection{
         WRK( MXBAT $*$ ( N $+$ 3 ) ) = ? (Returned)
      }{
         This array must be supplied as workspace.
      }
      \sstsubsection{
         RES( EL ) = ? (Returned)
      }{
         The output data array, containing the results of evaluating the
         mathematical expression.
      }
      \sstsubsection{
         VRES( EL ) = ? (Returned)
      }{
         The output variance estimates to accompany the results held in
         the RES array.
      }
      \sstsubsection{
         BADDR = LOGICAL (Returned)
      }{
         Whether the returned array of results (RES) may contain bad
         values.
      }
      \sstsubsection{
         BADVR = LOGICAL (Returned)
      }{
         Whether the returned array of variance estimates (VRES) may
         contain bad values.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for processing both real and double
         precision data; replace {\tt "}x{\tt "} in the routine name by R or D as
         appropriate.  The data types of the DAT, VAR, WRK, RES and RESV
         arrays should match the routine used.

         \sstitem
         The algorithm used to estimate the output variance is
         general-purpose and will cope with any reasonable mathematical
         expression.  However, note that it is likely to be less efficient
         than an algorithm written especially to estimate the variance for
         any particular expression whose form is known in advance.
      }
   }
   \sstdiytopic{
      Timing
   }{
      The time taken is approximately proportional to (i) N$+$1, where N
      is the number of input data arrays which have associated variance
      values, (ii) the size of each array and (iii) the time taken to
      evaluate the mathematical expression for each array element. In
      general, this last value will also tend to increase in
      approximate proportion to the number of input data arrays.
   }
}
\sstroutine{
   KPG1\_MTHEx
}{
   Evaluate a mathematical expression for a set of data and variance
   arrays
}{
   \sstdescription{
      The routine evaluates a general mathematical expression giving
      the values in an output data array in terms of values in a set of
      input data arrays, each of the same size. The expression to be
      evaluated is specified by means of a mapping identifier obtained
      from the TRANSFORM system (see SUN/61). A set of input variance
      arrays is also supplied, and this routine uses these to obtain
      estimates of the variance in the evaluated results. These output
      variance estimates are obtained numerically by perturbing the
      input data values by appropriate amounts.
   }
   \sstinvocation{
      CALL KPG1\_MTHEx( BAD, EL, N, DAT, VFLAG, VAR, IMAP, QUICK,
                       MXBAT, WRK, RES, VRES, BADDR, BADVR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether it is necessary to check for bad values in the input
         data or variance arrays.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of elements in each input data array.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of input data arrays.
      }
      \sstsubsection{
         DAT( EL, N ) = ? (Given)
      }{
         Array containing each separate input data array stored in a
         separate row.
      }
      \sstsubsection{
         VFLAG( N ) = LOGICAL (Given)
      }{
         A set of logical flags indicating which of the input data
         arrays stored in the DAT array have associated variance values
         (stored in the VAR array). If the VFLAG value for a data array
         is .TRUE., then variance values exist, otherwise there is no
         associated variance array so a variance of zero will be
         assumed.
      }
      \sstsubsection{
         VAR( EL, $*$ ) = ? (Given)
      }{
         Array containing variance estimates for the input data arrays.
         These values are stored in the rows of this array in the same
         order as the associated data values, but the total number of
         rows may be smaller than N due to the absence of values for
         those data arrays with a VFLAG value of .FALSE..  The declared
         second dimension size of the VAR array must be at least equal
         to the number of .TRUE. values in the VFLAG array.
      }
      \sstsubsection{
         IMAP = INTEGER (Given)
      }{
         A TRANSFORM system identifier for an \{N--$>$1\} compiled mapping
         which defines the mathematical expression to be evaluated.
      }
      \sstsubsection{
         QUICK = LOGICAL (Given)
      }{
         If this argument is set to .TRUE., then output variance
         estimates will be made by perturbing each input data array in
         turn, but in the positive direction only. If it is set to
         .FALSE., then each input data array will be perturbed in both
         directions and the maximum resulting output perturbation will
         be used to estimate the output variance. The former approach
         has the advantage of speed, but the latter gives more accurate
         results, especially for highly non-linear functions.
      }
      \sstsubsection{
         MXBAT = INTEGER (Given)
      }{
         A positive integer defining the size of workspace supplied.
         The input data arrays will be processed in {\tt "}batches{\tt "}, each of
         which does not contain more than this number of elements. If
         this value is too low, then excessive time will be spent in
         looping and subroutine calls. If it is too high, then
         excessive page faulting may occur. A value of about 256 is
         normally adequate.
      }
      \sstsubsection{
         WRK( MXBAT $*$ ( N $+$ 3 ) ) = ? (Returned)
      }{
         This array must be supplied as workspace.
      }
      \sstsubsection{
         RES( EL ) = ? (Returned)
      }{
         The output data array, containing the results of evaluating the
         mathematical expression.
      }
      \sstsubsection{
         VRES( EL ) = ? (Returned)
      }{
         The output variance estimates to accompany the results held in
         the RES array.
      }
      \sstsubsection{
         BADDR = LOGICAL (Returned)
      }{
         Whether the returned array of results (RES) may contain bad
         values.
      }
      \sstsubsection{
         BADVR = LOGICAL (Returned)
      }{
         Whether the returned array of variance estimates (VRES) may
         contain bad values.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for processing both real and double
         precision data; replace {\tt "}x{\tt "} in the routine name by R or D as
         appropriate.  The data types of the DAT, VAR, WRK, RES and RESV
         arrays should match the routine used.

         \sstitem
         The algorithm used to estimate the output variance is
         general-purpose and will cope with any reasonable mathematical
         expression.  However, note that it is likely to be less efficient
         than an algorithm written especially to estimate the variance for
         any particular expression whose form is known in advance.
      }
   }
   \sstdiytopic{
      Timing
   }{
      The time taken is approximately proportional to (i) N$+$1, where N
      is the number of input data arrays which have associated variance
      values, (ii) the size of each array and (iii) the time taken to
      evaluate the mathematical expression for each array element. In
      general, this last value will also tend to increase in
      approximate proportion to the number of input data arrays.
   }
}
\sstroutine{
   KPG1\_MULx
}{
   Multiply two vectorised arrays with optional variance information
}{
   \sstdescription{
      The routine forms the product of two vectorised arrays, with
      optional variance information. Bad value checking is also
      performed if required.
   }
   \sstinvocation{
      CALL KPG1\_MULx( BAD, VAR, EL, A, VA, B, VB, C, VC, NERR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether it is necessary to check for bad values in the input
         arrays. The routine will execute more rapidly if this checking
         can be omitted.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         Whether associated variance information is to be processed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         A( EL ) = ? (Given)
      }{
         First array of data to be multiplied.
      }
      \sstsubsection{
         VA( EL ) = ? (Given)
      }{
         Variance values associated with the array A. Not used if VAR
         is set to .FALSE..
      }
      \sstsubsection{
         B( EL ) = ? (Given)
      }{
         Second array of data to be multipled.
      }
      \sstsubsection{
         VB( EL ) = ? (Given)
      }{
         Variance values associated with the array B. Not used if VAR
         is set to .FALSE..
      }
      \sstsubsection{
         C( EL ) = ? (Returned)
      }{
         Result of multiplying arrays A and B.
      }
      \sstsubsection{
         VC( EL ) = ? (Returned)
      }{
         Variance values associated with the array C. Not used if VAR
         is set to .FALSE..
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred during the
         calculations.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the data types integer, real
         and double precision: replace {\tt "}x{\tt "} in the routine name by I, R or
         D as appropriate. The arrays passed to this routine should all
         have the specified data type.

         \sstitem
         This routine will handle numerical overflow. If overflow
         occurs, then affected output array elements will be set to the
         {\tt "}bad{\tt "} value. A count of the numerical errors which occur is
         returned via the NERR argument.
      }
   }
}
\sstroutine{
   KPG1\_MULx
}{
   Multiply two vectorised arrays with optional variance information
}{
   \sstdescription{
      The routine forms the product of two vectorised arrays, with
      optional variance information. Bad value checking is also
      performed if required.
   }
   \sstinvocation{
      CALL KPG1\_MULx( BAD, VAR, EL, A, VA, B, VB, C, VC, NERR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether it is necessary to check for bad values in the input
         arrays. The routine will execute more rapidly if this checking
         can be omitted.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         Whether associated variance information is to be processed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         A( EL ) = ? (Given)
      }{
         First array of data to be multiplied.
      }
      \sstsubsection{
         VA( EL ) = ? (Given)
      }{
         Variance values associated with the array A. Not used if VAR
         is set to .FALSE..
      }
      \sstsubsection{
         B( EL ) = ? (Given)
      }{
         Second array of data to be multipled.
      }
      \sstsubsection{
         VB( EL ) = ? (Given)
      }{
         Variance values associated with the array B. Not used if VAR
         is set to .FALSE..
      }
      \sstsubsection{
         C( EL ) = ? (Returned)
      }{
         Result of multiplying arrays A and B.
      }
      \sstsubsection{
         VC( EL ) = ? (Returned)
      }{
         Variance values associated with the array C. Not used if VAR
         is set to .FALSE..
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred during the
         calculations.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the data types integer, real
         and double precision: replace {\tt "}x{\tt "} in the routine name by I, R or
         D as appropriate. The arrays passed to this routine should all
         have the specified data type.

         \sstitem
         This routine will handle numerical overflow. If overflow
         occurs, then affected output array elements will be set to the
         {\tt "}bad{\tt "} value. A count of the numerical errors which occur is
         returned via the NERR argument.
      }
   }
}
\sstroutine{
   KPG1\_MULx
}{
   Multiply two vectorised arrays with optional variance information
}{
   \sstdescription{
      The routine forms the product of two vectorised arrays, with
      optional variance information. Bad value checking is also
      performed if required.
   }
   \sstinvocation{
      CALL KPG1\_MULx( BAD, VAR, EL, A, VA, B, VB, C, VC, NERR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether it is necessary to check for bad values in the input
         arrays. The routine will execute more rapidly if this checking
         can be omitted.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         Whether associated variance information is to be processed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         A( EL ) = ? (Given)
      }{
         First array of data to be multiplied.
      }
      \sstsubsection{
         VA( EL ) = ? (Given)
      }{
         Variance values associated with the array A. Not used if VAR
         is set to .FALSE..
      }
      \sstsubsection{
         B( EL ) = ? (Given)
      }{
         Second array of data to be multipled.
      }
      \sstsubsection{
         VB( EL ) = ? (Given)
      }{
         Variance values associated with the array B. Not used if VAR
         is set to .FALSE..
      }
      \sstsubsection{
         C( EL ) = ? (Returned)
      }{
         Result of multiplying arrays A and B.
      }
      \sstsubsection{
         VC( EL ) = ? (Returned)
      }{
         Variance values associated with the array C. Not used if VAR
         is set to .FALSE..
      }
      \sstsubsection{
         NERR = INTEGER (Returned)
      }{
         Number of numerical errors which occurred during the
         calculations.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each of the data types integer, real
         and double precision: replace {\tt "}x{\tt "} in the routine name by I, R or
         D as appropriate. The arrays passed to this routine should all
         have the specified data type.

         \sstitem
         This routine will handle numerical overflow. If overflow
         occurs, then affected output array elements will be set to the
         {\tt "}bad{\tt "} value. A count of the numerical errors which occur is
         returned via the NERR argument.
      }
   }
}
\sstroutine{
   KPG1\_MXMEx
}{
   Returns the maximum and minimum values between thresholds of an
   array including its errors
}{
   \sstdescription{
      This routine returns the maximum and minimum values of an input
      array when combined with its associated error array.  The extreme
      values can be constrained to lie between two thresholds, where
      values outside the thresholds are ignored.  So for example this
      routine might be used to find the smallest positive value or the
      largest negative value.  The number of multiples of each error
      that should be added to and subtracted from the primary array to
      find the extreme values is adjustable.  The routine also returns
      where it found the maximum and minimum, and the number of elements
      where either or both of the array values is bad.

      An error report is made if all the values are bad or lie outside
      of the thresholds.
   }
   \sstinvocation{
      CALL KPG1\_MXMEx( BAD, EL, ARRAY, ERROR, NSIGMA, THRESH, NINVAL,
                       MAXMUM, MINMUM, MAXPOS, MINPOS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If .TRUE., there may be bad pixels present in the array.  If
         .FALSE., it is safe not to check for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         Input array of data.
      }
      \sstsubsection{
         ERROR( EL ) = ? (Given)
      }{
         Error array associated with the data array.
      }
      \sstsubsection{
         NSIGMA = REAL (Given)
      }{
         Number of multiples of the error.
      }
      \sstsubsection{
         THRESH( 2 ) = ? (Given)
      }{
         The thresholds between which the extreme values are to be
         found (lower then upper).  Values equal to the thresholds are
         excluded.  To find the extreme values across the full range,
         set the thresholds to VAL\_\_MINx and VAL\_\_MAXx.
      }
      \sstsubsection{
         NINVAL = INTEGER (Returned)
      }{
         Number of bad pixels in the array.
      }
      \sstsubsection{
         MAXMUM = ? (Returned)
      }{
         Maximum value found in the array.
      }
      \sstsubsection{
         MINMUM = ? (Returned)
      }{
         Minimum value found in the array.
      }
      \sstsubsection{
         MAXPOS = INTEGER (Returned)
      }{
         Index of the pixel where the maximum value is (first) found.
      }
      \sstsubsection{
         MINPOS = INTEGER (Returned)
      }{
         Index of the pixel where the minimum value is (first) found.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY, ERROR, THRESH, MAXMUM, and MINMUM arguments supplied to
         the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_MXMEx
}{
   Returns the maximum and minimum values between thresholds of an
   array including its errors
}{
   \sstdescription{
      This routine returns the maximum and minimum values of an input
      array when combined with its associated error array.  The extreme
      values can be constrained to lie between two thresholds, where
      values outside the thresholds are ignored.  So for example this
      routine might be used to find the smallest positive value or the
      largest negative value.  The number of multiples of each error
      that should be added to and subtracted from the primary array to
      find the extreme values is adjustable.  The routine also returns
      where it found the maximum and minimum, and the number of elements
      where either or both of the array values is bad.

      An error report is made if all the values are bad or lie outside
      of the thresholds.
   }
   \sstinvocation{
      CALL KPG1\_MXMEx( BAD, EL, ARRAY, ERROR, NSIGMA, THRESH, NINVAL,
                       MAXMUM, MINMUM, MAXPOS, MINPOS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If .TRUE., there may be bad pixels present in the array.  If
         .FALSE., it is safe not to check for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         Input array of data.
      }
      \sstsubsection{
         ERROR( EL ) = ? (Given)
      }{
         Error array associated with the data array.
      }
      \sstsubsection{
         NSIGMA = REAL (Given)
      }{
         Number of multiples of the error.
      }
      \sstsubsection{
         THRESH( 2 ) = ? (Given)
      }{
         The thresholds between which the extreme values are to be
         found (lower then upper).  Values equal to the thresholds are
         excluded.  To find the extreme values across the full range,
         set the thresholds to VAL\_\_MINx and VAL\_\_MAXx.
      }
      \sstsubsection{
         NINVAL = INTEGER (Returned)
      }{
         Number of bad pixels in the array.
      }
      \sstsubsection{
         MAXMUM = ? (Returned)
      }{
         Maximum value found in the array.
      }
      \sstsubsection{
         MINMUM = ? (Returned)
      }{
         Minimum value found in the array.
      }
      \sstsubsection{
         MAXPOS = INTEGER (Returned)
      }{
         Index of the pixel where the maximum value is (first) found.
      }
      \sstsubsection{
         MINPOS = INTEGER (Returned)
      }{
         Index of the pixel where the minimum value is (first) found.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY, ERROR, THRESH, MAXMUM, and MINMUM arguments supplied to
         the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_MXMEx
}{
   Returns the maximum and minimum values between thresholds of an
   array including its errors
}{
   \sstdescription{
      This routine returns the maximum and minimum values of an input
      array when combined with its associated error array.  The extreme
      values can be constrained to lie between two thresholds, where
      values outside the thresholds are ignored.  So for example this
      routine might be used to find the smallest positive value or the
      largest negative value.  The number of multiples of each error
      that should be added to and subtracted from the primary array to
      find the extreme values is adjustable.  The routine also returns
      where it found the maximum and minimum, and the number of elements
      where either or both of the array values is bad.

      An error report is made if all the values are bad or lie outside
      of the thresholds.
   }
   \sstinvocation{
      CALL KPG1\_MXMEx( BAD, EL, ARRAY, ERROR, NSIGMA, THRESH, NINVAL,
                       MAXMUM, MINMUM, MAXPOS, MINPOS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If .TRUE., there may be bad pixels present in the array.  If
         .FALSE., it is safe not to check for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         Input array of data.
      }
      \sstsubsection{
         ERROR( EL ) = ? (Given)
      }{
         Error array associated with the data array.
      }
      \sstsubsection{
         NSIGMA = REAL (Given)
      }{
         Number of multiples of the error.
      }
      \sstsubsection{
         THRESH( 2 ) = ? (Given)
      }{
         The thresholds between which the extreme values are to be
         found (lower then upper).  Values equal to the thresholds are
         excluded.  To find the extreme values across the full range,
         set the thresholds to VAL\_\_MINx and VAL\_\_MAXx.
      }
      \sstsubsection{
         NINVAL = INTEGER (Returned)
      }{
         Number of bad pixels in the array.
      }
      \sstsubsection{
         MAXMUM = ? (Returned)
      }{
         Maximum value found in the array.
      }
      \sstsubsection{
         MINMUM = ? (Returned)
      }{
         Minimum value found in the array.
      }
      \sstsubsection{
         MAXPOS = INTEGER (Returned)
      }{
         Index of the pixel where the maximum value is (first) found.
      }
      \sstsubsection{
         MINPOS = INTEGER (Returned)
      }{
         Index of the pixel where the minimum value is (first) found.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY, ERROR, THRESH, MAXMUM, and MINMUM arguments supplied to
         the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_MXMEx
}{
   Returns the maximum and minimum values between thresholds of an
   array including its errors
}{
   \sstdescription{
      This routine returns the maximum and minimum values of an input
      array when combined with its associated error array.  The extreme
      values can be constrained to lie between two thresholds, where
      values outside the thresholds are ignored.  So for example this
      routine might be used to find the smallest positive value or the
      largest negative value.  The number of multiples of each error
      that should be added to and subtracted from the primary array to
      find the extreme values is adjustable.  The routine also returns
      where it found the maximum and minimum, and the number of elements
      where either or both of the array values is bad.

      An error report is made if all the values are bad or lie outside
      of the thresholds.
   }
   \sstinvocation{
      CALL KPG1\_MXMEx( BAD, EL, ARRAY, ERROR, NSIGMA, THRESH, NINVAL,
                       MAXMUM, MINMUM, MAXPOS, MINPOS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If .TRUE., there may be bad pixels present in the array.  If
         .FALSE., it is safe not to check for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         Input array of data.
      }
      \sstsubsection{
         ERROR( EL ) = ? (Given)
      }{
         Error array associated with the data array.
      }
      \sstsubsection{
         NSIGMA = REAL (Given)
      }{
         Number of multiples of the error.
      }
      \sstsubsection{
         THRESH( 2 ) = ? (Given)
      }{
         The thresholds between which the extreme values are to be
         found (lower then upper).  Values equal to the thresholds are
         excluded.  To find the extreme values across the full range,
         set the thresholds to VAL\_\_MINx and VAL\_\_MAXx.
      }
      \sstsubsection{
         NINVAL = INTEGER (Returned)
      }{
         Number of bad pixels in the array.
      }
      \sstsubsection{
         MAXMUM = ? (Returned)
      }{
         Maximum value found in the array.
      }
      \sstsubsection{
         MINMUM = ? (Returned)
      }{
         Minimum value found in the array.
      }
      \sstsubsection{
         MAXPOS = INTEGER (Returned)
      }{
         Index of the pixel where the maximum value is (first) found.
      }
      \sstsubsection{
         MINPOS = INTEGER (Returned)
      }{
         Index of the pixel where the minimum value is (first) found.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY, ERROR, THRESH, MAXMUM, and MINMUM arguments supplied to
         the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_MXMEx
}{
   Returns the maximum and minimum values between thresholds of an
   array including its errors
}{
   \sstdescription{
      This routine returns the maximum and minimum values of an input
      array when combined with its associated error array.  The extreme
      values can be constrained to lie between two thresholds, where
      values outside the thresholds are ignored.  So for example this
      routine might be used to find the smallest positive value or the
      largest negative value.  The number of multiples of each error
      that should be added to and subtracted from the primary array to
      find the extreme values is adjustable.  The routine also returns
      where it found the maximum and minimum, and the number of elements
      where either or both of the array values is bad.

      An error report is made if all the values are bad or lie outside
      of the thresholds.
   }
   \sstinvocation{
      CALL KPG1\_MXMEx( BAD, EL, ARRAY, ERROR, NSIGMA, THRESH, NINVAL,
                       MAXMUM, MINMUM, MAXPOS, MINPOS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If .TRUE., there may be bad pixels present in the array.  If
         .FALSE., it is safe not to check for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         Input array of data.
      }
      \sstsubsection{
         ERROR( EL ) = ? (Given)
      }{
         Error array associated with the data array.
      }
      \sstsubsection{
         NSIGMA = REAL (Given)
      }{
         Number of multiples of the error.
      }
      \sstsubsection{
         THRESH( 2 ) = ? (Given)
      }{
         The thresholds between which the extreme values are to be
         found (lower then upper).  Values equal to the thresholds are
         excluded.  To find the extreme values across the full range,
         set the thresholds to VAL\_\_MINx and VAL\_\_MAXx.
      }
      \sstsubsection{
         NINVAL = INTEGER (Returned)
      }{
         Number of bad pixels in the array.
      }
      \sstsubsection{
         MAXMUM = ? (Returned)
      }{
         Maximum value found in the array.
      }
      \sstsubsection{
         MINMUM = ? (Returned)
      }{
         Minimum value found in the array.
      }
      \sstsubsection{
         MAXPOS = INTEGER (Returned)
      }{
         Index of the pixel where the maximum value is (first) found.
      }
      \sstsubsection{
         MINPOS = INTEGER (Returned)
      }{
         Index of the pixel where the minimum value is (first) found.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY, ERROR, THRESH, MAXMUM, and MINMUM arguments supplied to
         the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_MXMEx
}{
   Returns the maximum and minimum values between thresholds of an
   array including its errors
}{
   \sstdescription{
      This routine returns the maximum and minimum values of an input
      array when combined with its associated error array.  The extreme
      values can be constrained to lie between two thresholds, where
      values outside the thresholds are ignored.  So for example this
      routine might be used to find the smallest positive value or the
      largest negative value.  The number of multiples of each error
      that should be added to and subtracted from the primary array to
      find the extreme values is adjustable.  The routine also returns
      where it found the maximum and minimum, and the number of elements
      where either or both of the array values is bad.

      An error report is made if all the values are bad or lie outside
      of the thresholds.
   }
   \sstinvocation{
      CALL KPG1\_MXMEx( BAD, EL, ARRAY, ERROR, NSIGMA, THRESH, NINVAL,
                       MAXMUM, MINMUM, MAXPOS, MINPOS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If .TRUE., there may be bad pixels present in the array.  If
         .FALSE., it is safe not to check for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         Input array of data.
      }
      \sstsubsection{
         ERROR( EL ) = ? (Given)
      }{
         Error array associated with the data array.
      }
      \sstsubsection{
         NSIGMA = REAL (Given)
      }{
         Number of multiples of the error.
      }
      \sstsubsection{
         THRESH( 2 ) = ? (Given)
      }{
         The thresholds between which the extreme values are to be
         found (lower then upper).  Values equal to the thresholds are
         excluded.  To find the extreme values across the full range,
         set the thresholds to VAL\_\_MINx and VAL\_\_MAXx.
      }
      \sstsubsection{
         NINVAL = INTEGER (Returned)
      }{
         Number of bad pixels in the array.
      }
      \sstsubsection{
         MAXMUM = ? (Returned)
      }{
         Maximum value found in the array.
      }
      \sstsubsection{
         MINMUM = ? (Returned)
      }{
         Minimum value found in the array.
      }
      \sstsubsection{
         MAXPOS = INTEGER (Returned)
      }{
         Index of the pixel where the maximum value is (first) found.
      }
      \sstsubsection{
         MINPOS = INTEGER (Returned)
      }{
         Index of the pixel where the minimum value is (first) found.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY, ERROR, THRESH, MAXMUM, and MINMUM arguments supplied to
         the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_MXMEx
}{
   Returns the maximum and minimum values between thresholds of an
   array including its errors
}{
   \sstdescription{
      This routine returns the maximum and minimum values of an input
      array when combined with its associated error array.  The extreme
      values can be constrained to lie between two thresholds, where
      values outside the thresholds are ignored.  So for example this
      routine might be used to find the smallest positive value or the
      largest negative value.  The number of multiples of each error
      that should be added to and subtracted from the primary array to
      find the extreme values is adjustable.  The routine also returns
      where it found the maximum and minimum, and the number of elements
      where either or both of the array values is bad.

      An error report is made if all the values are bad or lie outside
      of the thresholds.
   }
   \sstinvocation{
      CALL KPG1\_MXMEx( BAD, EL, ARRAY, ERROR, NSIGMA, THRESH, NINVAL,
                       MAXMUM, MINMUM, MAXPOS, MINPOS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If .TRUE., there may be bad pixels present in the array.  If
         .FALSE., it is safe not to check for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         Input array of data.
      }
      \sstsubsection{
         ERROR( EL ) = ? (Given)
      }{
         Error array associated with the data array.
      }
      \sstsubsection{
         NSIGMA = REAL (Given)
      }{
         Number of multiples of the error.
      }
      \sstsubsection{
         THRESH( 2 ) = ? (Given)
      }{
         The thresholds between which the extreme values are to be
         found (lower then upper).  Values equal to the thresholds are
         excluded.  To find the extreme values across the full range,
         set the thresholds to VAL\_\_MINx and VAL\_\_MAXx.
      }
      \sstsubsection{
         NINVAL = INTEGER (Returned)
      }{
         Number of bad pixels in the array.
      }
      \sstsubsection{
         MAXMUM = ? (Returned)
      }{
         Maximum value found in the array.
      }
      \sstsubsection{
         MINMUM = ? (Returned)
      }{
         Minimum value found in the array.
      }
      \sstsubsection{
         MAXPOS = INTEGER (Returned)
      }{
         Index of the pixel where the maximum value is (first) found.
      }
      \sstsubsection{
         MINPOS = INTEGER (Returned)
      }{
         Index of the pixel where the minimum value is (first) found.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY, ERROR, THRESH, MAXMUM, and MINMUM arguments supplied to
         the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_MXMNx
}{
   Returns the maximum and minimum values of an array
}{
   \sstdescription{
      This routine returns the maximum and minimum values of an input
      array, where it found the maximum and minimum, and the number of
      good and bad pixels in the array.
   }
   \sstinvocation{
       CALL KPG1\_MXMNx( BAD, EL, ARRAY, NINVAL, MAXMUM,
      :                 MINMUM, MAXPOS, MINPOS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true there may be bad pixels present in the array.  If false
         it is safe not to check for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         Input array of data.
      }
      \sstsubsection{
         NINVAL = INTEGER (Returned)
      }{
         Number of bad pixels in the array.
      }
      \sstsubsection{
         MAXMUM = ? (Returned)
      }{
         Maximum value found in the array.
      }
      \sstsubsection{
         MINMUM = ? (Returned)
      }{
         Minimum value found in the array.
      }
      \sstsubsection{
         MAXPOS = INTEGER (Returned)
      }{
         Index of the pixel where the maximum value is (first) found.
      }
      \sstsubsection{
         MINPOS = INTEGER (Returned)
      }{
         Index of the pixel where the minimum value is (first) found.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY, MAXMUM, and MINMUM arguments supplied to the routine must
         have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_MXMNx
}{
   Returns the maximum and minimum values of an array
}{
   \sstdescription{
      This routine returns the maximum and minimum values of an input
      array, where it found the maximum and minimum, and the number of
      good and bad pixels in the array.
   }
   \sstinvocation{
       CALL KPG1\_MXMNx( BAD, EL, ARRAY, NINVAL, MAXMUM,
      :                 MINMUM, MAXPOS, MINPOS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true there may be bad pixels present in the array.  If false
         it is safe not to check for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         Input array of data.
      }
      \sstsubsection{
         NINVAL = INTEGER (Returned)
      }{
         Number of bad pixels in the array.
      }
      \sstsubsection{
         MAXMUM = ? (Returned)
      }{
         Maximum value found in the array.
      }
      \sstsubsection{
         MINMUM = ? (Returned)
      }{
         Minimum value found in the array.
      }
      \sstsubsection{
         MAXPOS = INTEGER (Returned)
      }{
         Index of the pixel where the maximum value is (first) found.
      }
      \sstsubsection{
         MINPOS = INTEGER (Returned)
      }{
         Index of the pixel where the minimum value is (first) found.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY, MAXMUM, and MINMUM arguments supplied to the routine must
         have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_MXMNx
}{
   Returns the maximum and minimum values of an array
}{
   \sstdescription{
      This routine returns the maximum and minimum values of an input
      array, where it found the maximum and minimum, and the number of
      good and bad pixels in the array.
   }
   \sstinvocation{
       CALL KPG1\_MXMNx( BAD, EL, ARRAY, NINVAL, MAXMUM,
      :                 MINMUM, MAXPOS, MINPOS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true there may be bad pixels present in the array.  If false
         it is safe not to check for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         Input array of data.
      }
      \sstsubsection{
         NINVAL = INTEGER (Returned)
      }{
         Number of bad pixels in the array.
      }
      \sstsubsection{
         MAXMUM = ? (Returned)
      }{
         Maximum value found in the array.
      }
      \sstsubsection{
         MINMUM = ? (Returned)
      }{
         Minimum value found in the array.
      }
      \sstsubsection{
         MAXPOS = INTEGER (Returned)
      }{
         Index of the pixel where the maximum value is (first) found.
      }
      \sstsubsection{
         MINPOS = INTEGER (Returned)
      }{
         Index of the pixel where the minimum value is (first) found.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY, MAXMUM, and MINMUM arguments supplied to the routine must
         have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_MXMNx
}{
   Returns the maximum and minimum values of an array
}{
   \sstdescription{
      This routine returns the maximum and minimum values of an input
      array, where it found the maximum and minimum, and the number of
      good and bad pixels in the array.
   }
   \sstinvocation{
       CALL KPG1\_MXMNx( BAD, EL, ARRAY, NINVAL, MAXMUM,
      :                 MINMUM, MAXPOS, MINPOS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true there may be bad pixels present in the array.  If false
         it is safe not to check for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         Input array of data.
      }
      \sstsubsection{
         NINVAL = INTEGER (Returned)
      }{
         Number of bad pixels in the array.
      }
      \sstsubsection{
         MAXMUM = ? (Returned)
      }{
         Maximum value found in the array.
      }
      \sstsubsection{
         MINMUM = ? (Returned)
      }{
         Minimum value found in the array.
      }
      \sstsubsection{
         MAXPOS = INTEGER (Returned)
      }{
         Index of the pixel where the maximum value is (first) found.
      }
      \sstsubsection{
         MINPOS = INTEGER (Returned)
      }{
         Index of the pixel where the minimum value is (first) found.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY, MAXMUM, and MINMUM arguments supplied to the routine must
         have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_MXMNx
}{
   Returns the maximum and minimum values of an array
}{
   \sstdescription{
      This routine returns the maximum and minimum values of an input
      array, where it found the maximum and minimum, and the number of
      good and bad pixels in the array.
   }
   \sstinvocation{
       CALL KPG1\_MXMNx( BAD, EL, ARRAY, NINVAL, MAXMUM,
      :                 MINMUM, MAXPOS, MINPOS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true there may be bad pixels present in the array.  If false
         it is safe not to check for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         Input array of data.
      }
      \sstsubsection{
         NINVAL = INTEGER (Returned)
      }{
         Number of bad pixels in the array.
      }
      \sstsubsection{
         MAXMUM = ? (Returned)
      }{
         Maximum value found in the array.
      }
      \sstsubsection{
         MINMUM = ? (Returned)
      }{
         Minimum value found in the array.
      }
      \sstsubsection{
         MAXPOS = INTEGER (Returned)
      }{
         Index of the pixel where the maximum value is (first) found.
      }
      \sstsubsection{
         MINPOS = INTEGER (Returned)
      }{
         Index of the pixel where the minimum value is (first) found.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY, MAXMUM, and MINMUM arguments supplied to the routine must
         have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_MXMNx
}{
   Returns the maximum and minimum values of an array
}{
   \sstdescription{
      This routine returns the maximum and minimum values of an input
      array, where it found the maximum and minimum, and the number of
      good and bad pixels in the array.
   }
   \sstinvocation{
       CALL KPG1\_MXMNx( BAD, EL, ARRAY, NINVAL, MAXMUM,
      :                 MINMUM, MAXPOS, MINPOS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true there may be bad pixels present in the array.  If false
         it is safe not to check for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         Input array of data.
      }
      \sstsubsection{
         NINVAL = INTEGER (Returned)
      }{
         Number of bad pixels in the array.
      }
      \sstsubsection{
         MAXMUM = ? (Returned)
      }{
         Maximum value found in the array.
      }
      \sstsubsection{
         MINMUM = ? (Returned)
      }{
         Minimum value found in the array.
      }
      \sstsubsection{
         MAXPOS = INTEGER (Returned)
      }{
         Index of the pixel where the maximum value is (first) found.
      }
      \sstsubsection{
         MINPOS = INTEGER (Returned)
      }{
         Index of the pixel where the minimum value is (first) found.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY, MAXMUM, and MINMUM arguments supplied to the routine must
         have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_MXMNx
}{
   Returns the maximum and minimum values of an array
}{
   \sstdescription{
      This routine returns the maximum and minimum values of an input
      array, where it found the maximum and minimum, and the number of
      good and bad pixels in the array.
   }
   \sstinvocation{
       CALL KPG1\_MXMNx( BAD, EL, ARRAY, NINVAL, MAXMUM,
      :                 MINMUM, MAXPOS, MINPOS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true there may be bad pixels present in the array.  If false
         it is safe not to check for bad values.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         Input array of data.
      }
      \sstsubsection{
         NINVAL = INTEGER (Returned)
      }{
         Number of bad pixels in the array.
      }
      \sstsubsection{
         MAXMUM = ? (Returned)
      }{
         Maximum value found in the array.
      }
      \sstsubsection{
         MINMUM = ? (Returned)
      }{
         Minimum value found in the array.
      }
      \sstsubsection{
         MAXPOS = INTEGER (Returned)
      }{
         Index of the pixel where the maximum value is (first) found.
      }
      \sstsubsection{
         MINPOS = INTEGER (Returned)
      }{
         Index of the pixel where the minimum value is (first) found.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY, MAXMUM, and MINMUM arguments supplied to the routine must
         have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_NACVT
}{
   Convert an HDS object hierarchy to native data representation
}{
   \sstdescription{
      The routine recursively descends an HDS object hierarchy,
      converting any primitive objects within it to have the
      appropriate native data representation, as provided by the host
      machine. This will minimise subsequent access time for this
      machine.
   }
   \sstinvocation{
      CALL KPG1\_NACVT( LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER $*$ ( DAT\_\_SZLOC ) (Given and Returned)
      }{
         Locator for the object or structure whose contents are to be
         converted. If the object is primitive, then this locator may
         be replaced by a new one on output (as the object may need to
         be erased and re-created).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_NAG2R
}{
   Converts an NAG Hermitian Fourier transform array into an array
   usable by FFTPACK routine KPG1\_RFFTB
}{
   \sstdescription{
      This subroutine modifies the supplied array of Fourier co-efficients
      (as produced by NAG subroutine C06FAE) so that an inverse FFT can be
      performed on them using FFTPACK routine KPG1\_RFFTB. The resulting
      inverse will have the same normalisation as the original data
      transformed using KPG1\_RFFTF.

      This function is equivalent to PDA\_NAG2R except that it uses work
      space for greater speed.
   }
   \sstinvocation{
      CALL KPG1\_NAG2R( NP, R, WORK )
   }
   \sstarguments{
      \sstsubsection{
         NP = INTEGER (Given)
      }{
         The size of the array.
      }
      \sstsubsection{
         R( NP ) = REAL (Given and Returned)
      }{
         The array holding the Fourier co-efficients. Supplied in NAG
         format and returned in FFTPACK format.
      }
      \sstsubsection{
         WORK( NP ) = REAL (Given and Returned)
      }{
         Work space.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A call to KPG1\_R2NAG followed by a call to KPG1\_NAG2R will result in
         the original data being divided by NP.
      }
   }
}
\sstroutine{
   KPG1\_NAGTC
}{
   Swaps argument order when getting a mapped character array from
   an HDS object
}{
   \sstdescription{
      This is just a dummy routine to swap the argument order when
      obtaining the value of a mapped character array from an HDS
      object.  It is needed for Unix systems.
   }
   \sstinvocation{
      CALL KPG1\_NAGTC( CVALUE, LOC, NDIM, DIM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         CVALUE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The character value.
      }
      \sstsubsection{
         LOC = CHARACTER $*$ (DAT\_\_SZLOC) (Given)
      }{
         The locator of the object whose value is required.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of dimensions.
      }
      \sstsubsection{
         DIM( $*$ ) = INTEGER (Given)
      }{
         The dimensions of the character object.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_NAPTC
}{
   Swaps argument order when putting a mapped character array into
   an HDS object
}{
   \sstdescription{
      This is just a dummy routine to swap the argument order when
      putting the value of a mapped character array into HDS object.  It
      is needed for Unix systems.
   }
   \sstinvocation{
      CALL KPG1\_NAPTC( CVALUE, LOC, NDIM, DIM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         CVALUE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The character value.
      }
      \sstsubsection{
         LOC = CHARACTER $*$ (DAT\_\_SZLOC) (Given)
      }{
         The locator of the object to have value CVALUE.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The number of dimensions.
      }
      \sstsubsection{
         DIM( $*$ ) = INTEGER (Given)
      }{
         The dimensions of the character object.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_NBADD
}{
   Finds the number of bad values in an array
}{
   \sstdescription{
      Finds the number of bad values in a 1-D array.
   }
   \sstinvocation{
      CALL KPG1\_NBADD( N, DATA, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of elements in the array.
      }
      \sstsubsection{
         DATA( N ) = ? (Given)
      }{
         The data array.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the data.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_NCAXS
}{
   Draws NCAR annotated axes in the current SGS zone
}{
   \sstdescription{
      This subroutine uses NCAR and SNX to plot labelled and
      annotated axes with a title within the current SGS zone.

      NCAR has unfortunate defaults for many of its plotting parameters.
      These have been changed to obtain a clearer plot on a variety of
      devices. The changes are:
        a) increase the width of the enumerations, labels and title;
        b) disable the rotation and squashing of the axis ticks;
        c) increase the size of axis tick marks; and
        d) increase the maximum label length to 50 characters.

      There are options controlled by input arguments:
        e) specify the location of the grid (say to allow for larger
           text size for the title;
        f) plot the tick marks outside the grid so they do not cross
           the graph (useful for contour plots);
        g) start and end the axes at the start and end pixels rather
           than at major tick marks (also useful for contour plots);
        h) control the maximum number of major tick marks to prevent
           shrinkage,
        i) control the number of minor ticks per major tick;
        j) have either or both axes logarithmic; and
        k) plot with thick lines.

      Also the terminator of character strings is a dollar.  This is
      changed to a $<$NUL$>$.

      Note before using the routine an SGS device must be opened, a
      call to SNX\_AGWV made and an SGS zone selected or created.  For
      image displays and contour plots the zone will normally have the
      aspect ratio of the array (of data values that are to be
      presented) to get square pixels.
   }
   \sstinvocation{
      CALL KPG1\_NCAXS( XLOW, YLOW, XHIGH, YHIGH, GRID, TITLE, ABSLAB,
                       ORDLAB, XLOG, YLOG, MINTIC, MAJTIC, OUTTIC,
                       THICK, NICE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         XLOW = REAL (Given)
      }{
         Co-ordinate of start of x axis.
      }
      \sstsubsection{
         YLOW = REAL (Given)
      }{
         Co-ordinate of start of y axis.
      }
      \sstsubsection{
         XHIGH = REAL (Given)
      }{
         Co-ordinate of end of x axis.
      }
      \sstsubsection{
         YHIGH = REAL (Given)
      }{
         Co-ordinate of end of y axis.
      }
      \sstsubsection{
         GRID( 4 ) = REAL (Given)
      }{
         The grid location in the order left, right, bottom, top.  A
         negative value gives the corresponding default: 0.15, 0.95,
         0.15, 0.95 respectively.  All values should lie in the range
         0.0 to 1.0 with left less than right and top greater than
         bottom, however, in practice left and bottom should be in the
         range 0.15 to 0.2, and top and right in the range 0.9 to 0.95.
      }
      \sstsubsection{
         TITLE = CHARARACTER $*$ ( $*$ ) (Given)
      }{
         Title for the plot.
      }
      \sstsubsection{
         ABSLAB = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Label for the abscissa, in which NCAR fancy fonts may be
         embedded.
      }
      \sstsubsection{
         ORDLAB = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Label for the ordinate, in which NCAR fancy fonts may be
         embedded.
      }
      \sstsubsection{
         XLOG = LOGICAL (Given)
      }{
         If .TRUE ., the x axis is logarithmic.
      }
      \sstsubsection{
         YLOG = LOGICAL (Given)
      }{
         If .TRUE ., the y axis is logarithmic.
      }
      \sstsubsection{
         MINTIC( 2 ) = REAL (Given)
      }{
         The number of minor tick marks between each major tick mark
         for the x and y axes.  A negative value forces the graphics
         package to compute appropriate values.
      }
      \sstsubsection{
         MAJTIC( 2 ) = REAL (Given)
      }{
         The parameter controlling the numbers of major tick marks for
         the x and y axes.  (Number used is between MAJTIC$+$2 and
         5$*$MAJTIC/2$+$4.) A negative value forces the graphics package to
         compute appropriate values.
      }
      \sstsubsection{
         OUTTIC = LOGICAL (Given)
      }{
         If true the axis tick marks are drawn outside the box.
      }
      \sstsubsection{
         THICK = REAL (Given)
      }{
         The line thickness in units of the default.
      }
      \sstsubsection{
         NICE = LOGICAL (Given)
      }{
         If .TRUE., a major tick mark will appear at the ends of each
         axis.
      }
      \sstsubsection{
         STATUS = INTEGER (Given \& Returned)
      }{
         This is the global status, if this variable has an error value
         on entry then an immediate return will occur.
      }
   }
}
\sstroutine{
   KPG1\_NDFNM
}{
   Return the name of an NDF without a directory path (Unix only)
}{
   \sstdescription{
      Gets the full path to the supplied NDF, then removes any directory
      path from the start, and return the resulting string.

      Note, Unix file names are assumed.
   }
   \sstinvocation{
      CALL KPG1\_NDFNM( INDF, NAME, NMLEN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         The NDF.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The NDF name without directory path.
      }
      \sstsubsection{
         NMLEN = INTEGER (Returned)
      }{
         The used length of NAME.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_NMCOL
}{
   Finds the RGB intensities of a named colour
}{
   \sstdescription{
      Given the name of a colour this routine searches the standard
      colour set for it, and if it exists returns its R-G-B intensities.
      An error is returned if the named colour is not in the colour set.
      All comparisons are performed in uppercase with the blanks
      removed.
   }
   \sstinvocation{
      CALL KPG1\_NMCOL( NAME, R, G, B, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the nearest colour in the named colour set to the
         input RGB colour.  Note at least eighteen characters are
         required to avoid truncation.
      }
      \sstsubsection{
         R = REAL (Returned)
      }{
         The red intensity of the named colour to be identified.  It is
         in the range 0.0 to 1.0.
      }
      \sstsubsection{
         G = REAL (Returned)
      }{
         The green intensity of the named colour to be identified.  It
         is in the range 0.0 to 1.0.
      }
      \sstsubsection{
         B = REAL (Returned)
      }{
         The blue intensity of the named colour to be identified.  It is
         in the range 0.0 to 1.0.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_NOISx
}{
   Adds random Normal noise to a 1-d array
}{
   \sstdescription{
      This routine takes a 1-d array and adds noise randomly to each
      element in the array.  The random number at each element is drawn
      from a Normal distribution whose spread is given by the
      corresponding variance array at that element.
   }
   \sstinvocation{
      CALL KPG1\_NOISx( BAD, EL, VARNCE, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = INTEGER (Given)
      }{
         If true there may be bad pixels in input arrays, and so there
         will be bad-pixel testing.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the arrays.
      }
      \sstsubsection{
         VARNCE( EL ) = ? (Given)
      }{
         The Normal variance array corresponding to the data array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given and Returned)
      }{
         The data array to which random errors are to be applied.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW or W as appropriate.  The
         arrays supplied to the routine must have the data type specified.

         \sstitem
         All arithmetic is performed in double precision.
      }
   }
}
\sstroutine{
   KPG1\_NOISx
}{
   Adds random Normal noise to a 1-d array
}{
   \sstdescription{
      This routine takes a 1-d array and adds noise randomly to each
      element in the array.  The random number at each element is drawn
      from a Normal distribution whose spread is given by the
      corresponding variance array at that element.
   }
   \sstinvocation{
      CALL KPG1\_NOISx( BAD, EL, VARNCE, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = INTEGER (Given)
      }{
         If true there may be bad pixels in input arrays, and so there
         will be bad-pixel testing.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the arrays.
      }
      \sstsubsection{
         VARNCE( EL ) = ? (Given)
      }{
         The Normal variance array corresponding to the data array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given and Returned)
      }{
         The data array to which random errors are to be applied.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW or W as appropriate.  The
         arrays supplied to the routine must have the data type specified.

         \sstitem
         All arithmetic is performed in double precision.
      }
   }
}
\sstroutine{
   KPG1\_NOISx
}{
   Adds random Normal noise to a 1-d array
}{
   \sstdescription{
      This routine takes a 1-d array and adds noise randomly to each
      element in the array.  The random number at each element is drawn
      from a Normal distribution whose spread is given by the
      corresponding variance array at that element.
   }
   \sstinvocation{
      CALL KPG1\_NOISx( BAD, EL, VARNCE, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = INTEGER (Given)
      }{
         If true there may be bad pixels in input arrays, and so there
         will be bad-pixel testing.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the arrays.
      }
      \sstsubsection{
         VARNCE( EL ) = ? (Given)
      }{
         The Normal variance array corresponding to the data array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given and Returned)
      }{
         The data array to which random errors are to be applied.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW or W as appropriate.  The
         arrays supplied to the routine must have the data type specified.

         \sstitem
         All arithmetic is performed in double precision.
      }
   }
}
\sstroutine{
   KPG1\_NOISx
}{
   Adds random Normal noise to a 1-d array
}{
   \sstdescription{
      This routine takes a 1-d array and adds noise randomly to each
      element in the array.  The random number at each element is drawn
      from a Normal distribution whose spread is given by the
      corresponding variance array at that element.
   }
   \sstinvocation{
      CALL KPG1\_NOISx( BAD, EL, VARNCE, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = INTEGER (Given)
      }{
         If true there may be bad pixels in input arrays, and so there
         will be bad-pixel testing.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the arrays.
      }
      \sstsubsection{
         VARNCE( EL ) = ? (Given)
      }{
         The Normal variance array corresponding to the data array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given and Returned)
      }{
         The data array to which random errors are to be applied.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW or W as appropriate.  The
         arrays supplied to the routine must have the data type specified.

         \sstitem
         All arithmetic is performed in double precision.
      }
   }
}
\sstroutine{
   KPG1\_NOISx
}{
   Adds random Normal noise to a 1-d array
}{
   \sstdescription{
      This routine takes a 1-d array and adds noise randomly to each
      element in the array.  The random number at each element is drawn
      from a Normal distribution whose spread is given by the
      corresponding variance array at that element.
   }
   \sstinvocation{
      CALL KPG1\_NOISx( BAD, EL, VARNCE, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = INTEGER (Given)
      }{
         If true there may be bad pixels in input arrays, and so there
         will be bad-pixel testing.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the arrays.
      }
      \sstsubsection{
         VARNCE( EL ) = ? (Given)
      }{
         The Normal variance array corresponding to the data array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given and Returned)
      }{
         The data array to which random errors are to be applied.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW or W as appropriate.  The
         arrays supplied to the routine must have the data type specified.

         \sstitem
         All arithmetic is performed in double precision.
      }
   }
}
\sstroutine{
   KPG1\_NOISx
}{
   Adds random Normal noise to a 1-d array
}{
   \sstdescription{
      This routine takes a 1-d array and adds noise randomly to each
      element in the array.  The random number at each element is drawn
      from a Normal distribution whose spread is given by the
      corresponding variance array at that element.
   }
   \sstinvocation{
      CALL KPG1\_NOISx( BAD, EL, VARNCE, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = INTEGER (Given)
      }{
         If true there may be bad pixels in input arrays, and so there
         will be bad-pixel testing.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the arrays.
      }
      \sstsubsection{
         VARNCE( EL ) = ? (Given)
      }{
         The Normal variance array corresponding to the data array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given and Returned)
      }{
         The data array to which random errors are to be applied.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW or W as appropriate.  The
         arrays supplied to the routine must have the data type specified.

         \sstitem
         All arithmetic is performed in double precision.
      }
   }
}
\sstroutine{
   KPG1\_NOISx
}{
   Adds random Normal noise to a 1-d array
}{
   \sstdescription{
      This routine takes a 1-d array and adds noise randomly to each
      element in the array.  The random number at each element is drawn
      from a Normal distribution whose spread is given by the
      corresponding variance array at that element.
   }
   \sstinvocation{
      CALL KPG1\_NOISx( BAD, EL, VARNCE, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = INTEGER (Given)
      }{
         If true there may be bad pixels in input arrays, and so there
         will be bad-pixel testing.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the arrays.
      }
      \sstsubsection{
         VARNCE( EL ) = ? (Given)
      }{
         The Normal variance array corresponding to the data array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given and Returned)
      }{
         The data array to which random errors are to be applied.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW or W as appropriate.  The
         arrays supplied to the routine must have the data type specified.

         \sstitem
         All arithmetic is performed in double precision.
      }
   }
}
\sstroutine{
   KPG\_NTHMx
}{
   Returns the n smallest values in a BYTE array
}{
   \sstdescription{
      This routine takes an BYTE array and returns a stack
      containing the n smallest values in that array.

      Bad pixels are processed by the magic-value method.
   }
   \sstinvocation{
      CALL KPG1\_NTHMB( BAD, ARRAY, DIMS, N, STACK, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true bad-pixel testing will be performed.  It should be true
         if there may be bad pixels present.
      }
      \sstsubsection{
         ARRAY ( DIMS )  =  ? (Given)
      }{
         Input array of data values.
      }
      \sstsubsection{
         DIMS  =  INTEGER  (Given)
      }{
         Dimension of the input array.
      }
      \sstsubsection{
         N  =  INTEGER  (Given)
      }{
         The number of values to be stored in stack, i.e. specifies
         n in {\tt "}n-th smallest value.{\tt "}
      }
      \sstsubsection{
         STACK ( N )  =  ? (Returned)
      }{
         Ordered n smallest values in the input array. The first element
         is the n-th smallest, the second is the (n-1)-th smallest and
         so on until the n-th element is the minimum value.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   KPG\_NTHMx
}{
   Returns the n smallest values in a DOUBLE PRECISION array
}{
   \sstdescription{
      This routine takes an DOUBLE PRECISION array and returns a stack
      containing the n smallest values in that array.

      Bad pixels are processed by the magic-value method.
   }
   \sstinvocation{
      CALL KPG1\_NTHMD( BAD, ARRAY, DIMS, N, STACK, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true bad-pixel testing will be performed.  It should be true
         if there may be bad pixels present.
      }
      \sstsubsection{
         ARRAY ( DIMS )  =  ? (Given)
      }{
         Input array of data values.
      }
      \sstsubsection{
         DIMS  =  INTEGER  (Given)
      }{
         Dimension of the input array.
      }
      \sstsubsection{
         N  =  INTEGER  (Given)
      }{
         The number of values to be stored in stack, i.e. specifies
         n in {\tt "}n-th smallest value.{\tt "}
      }
      \sstsubsection{
         STACK ( N )  =  ? (Returned)
      }{
         Ordered n smallest values in the input array. The first element
         is the n-th smallest, the second is the (n-1)-th smallest and
         so on until the n-th element is the minimum value.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   KPG\_NTHMx
}{
   Returns the n smallest values in a INTEGER array
}{
   \sstdescription{
      This routine takes an INTEGER array and returns a stack
      containing the n smallest values in that array.

      Bad pixels are processed by the magic-value method.
   }
   \sstinvocation{
      CALL KPG1\_NTHMI( BAD, ARRAY, DIMS, N, STACK, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true bad-pixel testing will be performed.  It should be true
         if there may be bad pixels present.
      }
      \sstsubsection{
         ARRAY ( DIMS )  =  ? (Given)
      }{
         Input array of data values.
      }
      \sstsubsection{
         DIMS  =  INTEGER  (Given)
      }{
         Dimension of the input array.
      }
      \sstsubsection{
         N  =  INTEGER  (Given)
      }{
         The number of values to be stored in stack, i.e. specifies
         n in {\tt "}n-th smallest value.{\tt "}
      }
      \sstsubsection{
         STACK ( N )  =  ? (Returned)
      }{
         Ordered n smallest values in the input array. The first element
         is the n-th smallest, the second is the (n-1)-th smallest and
         so on until the n-th element is the minimum value.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   KPG\_NTHMx
}{
   Returns the n smallest values in a REAL array
}{
   \sstdescription{
      This routine takes an REAL array and returns a stack
      containing the n smallest values in that array.

      Bad pixels are processed by the magic-value method.
   }
   \sstinvocation{
      CALL KPG1\_NTHMR( BAD, ARRAY, DIMS, N, STACK, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true bad-pixel testing will be performed.  It should be true
         if there may be bad pixels present.
      }
      \sstsubsection{
         ARRAY ( DIMS )  =  ? (Given)
      }{
         Input array of data values.
      }
      \sstsubsection{
         DIMS  =  INTEGER  (Given)
      }{
         Dimension of the input array.
      }
      \sstsubsection{
         N  =  INTEGER  (Given)
      }{
         The number of values to be stored in stack, i.e. specifies
         n in {\tt "}n-th smallest value.{\tt "}
      }
      \sstsubsection{
         STACK ( N )  =  ? (Returned)
      }{
         Ordered n smallest values in the input array. The first element
         is the n-th smallest, the second is the (n-1)-th smallest and
         so on until the n-th element is the minimum value.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   KPG\_NTHMx
}{
   Returns the n smallest values in a UNSIGNED BYTE array
}{
   \sstdescription{
      This routine takes an UNSIGNED BYTE array and returns a stack
      containing the n smallest values in that array.

      Bad pixels are processed by the magic-value method.
   }
   \sstinvocation{
      CALL KPG1\_NTHMUB( BAD, ARRAY, DIMS, N, STACK, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true bad-pixel testing will be performed.  It should be true
         if there may be bad pixels present.
      }
      \sstsubsection{
         ARRAY ( DIMS )  =  ? (Given)
      }{
         Input array of data values.
      }
      \sstsubsection{
         DIMS  =  INTEGER  (Given)
      }{
         Dimension of the input array.
      }
      \sstsubsection{
         N  =  INTEGER  (Given)
      }{
         The number of values to be stored in stack, i.e. specifies
         n in {\tt "}n-th smallest value.{\tt "}
      }
      \sstsubsection{
         STACK ( N )  =  ? (Returned)
      }{
         Ordered n smallest values in the input array. The first element
         is the n-th smallest, the second is the (n-1)-th smallest and
         so on until the n-th element is the minimum value.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   KPG\_NTHMx
}{
   Returns the n smallest values in a UNSIGNED WORD array
}{
   \sstdescription{
      This routine takes an UNSIGNED WORD array and returns a stack
      containing the n smallest values in that array.

      Bad pixels are processed by the magic-value method.
   }
   \sstinvocation{
      CALL KPG1\_NTHMUW( BAD, ARRAY, DIMS, N, STACK, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true bad-pixel testing will be performed.  It should be true
         if there may be bad pixels present.
      }
      \sstsubsection{
         ARRAY ( DIMS )  =  ? (Given)
      }{
         Input array of data values.
      }
      \sstsubsection{
         DIMS  =  INTEGER  (Given)
      }{
         Dimension of the input array.
      }
      \sstsubsection{
         N  =  INTEGER  (Given)
      }{
         The number of values to be stored in stack, i.e. specifies
         n in {\tt "}n-th smallest value.{\tt "}
      }
      \sstsubsection{
         STACK ( N )  =  ? (Returned)
      }{
         Ordered n smallest values in the input array. The first element
         is the n-th smallest, the second is the (n-1)-th smallest and
         so on until the n-th element is the minimum value.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   KPG\_NTHMx
}{
   Returns the n smallest values in a WORD array
}{
   \sstdescription{
      This routine takes an WORD array and returns a stack
      containing the n smallest values in that array.

      Bad pixels are processed by the magic-value method.
   }
   \sstinvocation{
      CALL KPG1\_NTHMW( BAD, ARRAY, DIMS, N, STACK, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true bad-pixel testing will be performed.  It should be true
         if there may be bad pixels present.
      }
      \sstsubsection{
         ARRAY ( DIMS )  =  ? (Given)
      }{
         Input array of data values.
      }
      \sstsubsection{
         DIMS  =  INTEGER  (Given)
      }{
         Dimension of the input array.
      }
      \sstsubsection{
         N  =  INTEGER  (Given)
      }{
         The number of values to be stored in stack, i.e. specifies
         n in {\tt "}n-th smallest value.{\tt "}
      }
      \sstsubsection{
         STACK ( N )  =  ? (Returned)
      }{
         Ordered n smallest values in the input array. The first element
         is the n-th smallest, the second is the (n-1)-th smallest and
         so on until the n-th element is the minimum value.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given)
      }{
         Global status value.
      }
   }
}
\sstroutine{
   KPG1\_NUMBx
}{
   Counts the number of elements with values or absolute values
   above or below a limit
}{
   \sstdescription{
      This routine returns the number of points in the input array
      that have a value or absolute value greater than or less than
      the input value.
   }
   \sstinvocation{
      CALL KPG1\_NUMBx( BAD, VABS, ABOVE, EL, INARR, VALUE, NUMBER,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true testing for bad pixels will be made.  This should not
         be set to false unless there definitely no bad values within
         the input array.
      }
      \sstsubsection{
         VABS = LOGICAL (Given)
      }{
         If true the comparison is performed with the absolute value
         of each array element.
      }
      \sstsubsection{
         ABOVE = LOGICAL (Given)
      }{
         If true the criterion tests for array values greater than the
         limit; if false the criterion tests for array values less than
         the limit.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The input data array
      }
      \sstsubsection{
         VALUE = ? (Given)
      }{
         Value to test each array value against.
      }
      \sstsubsection{
         NUMBER = INTEGER (Returned)
      }{
         The number of elements of the input array greater than the
         specified value when VABS = FALSE, or the number of elements
         of the input array whose absolute values are greater than the
         specified value when VABS = TRUE.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         array and comparison value supplied to the routine must have the
         data type specified.
      }
   }
}
\sstroutine{
   KPG1\_NUMBx
}{
   Counts the number of elements with values or absolute values
   above or below a limit
}{
   \sstdescription{
      This routine returns the number of points in the input array
      that have a value or absolute value greater than or less than
      the input value.
   }
   \sstinvocation{
      CALL KPG1\_NUMBx( BAD, VABS, ABOVE, EL, INARR, VALUE, NUMBER,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true testing for bad pixels will be made.  This should not
         be set to false unless there definitely no bad values within
         the input array.
      }
      \sstsubsection{
         VABS = LOGICAL (Given)
      }{
         If true the comparison is performed with the absolute value
         of each array element.
      }
      \sstsubsection{
         ABOVE = LOGICAL (Given)
      }{
         If true the criterion tests for array values greater than the
         limit; if false the criterion tests for array values less than
         the limit.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The input data array
      }
      \sstsubsection{
         VALUE = ? (Given)
      }{
         Value to test each array value against.
      }
      \sstsubsection{
         NUMBER = INTEGER (Returned)
      }{
         The number of elements of the input array greater than the
         specified value when VABS = FALSE, or the number of elements
         of the input array whose absolute values are greater than the
         specified value when VABS = TRUE.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         array and comparison value supplied to the routine must have the
         data type specified.
      }
   }
}
\sstroutine{
   KPG1\_NUMBx
}{
   Counts the number of elements with values or absolute values
   above or below a limit
}{
   \sstdescription{
      This routine returns the number of points in the input array
      that have a value or absolute value greater than or less than
      the input value.
   }
   \sstinvocation{
      CALL KPG1\_NUMBx( BAD, VABS, ABOVE, EL, INARR, VALUE, NUMBER,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true testing for bad pixels will be made.  This should not
         be set to false unless there definitely no bad values within
         the input array.
      }
      \sstsubsection{
         VABS = LOGICAL (Given)
      }{
         If true the comparison is performed with the absolute value
         of each array element.
      }
      \sstsubsection{
         ABOVE = LOGICAL (Given)
      }{
         If true the criterion tests for array values greater than the
         limit; if false the criterion tests for array values less than
         the limit.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The input data array
      }
      \sstsubsection{
         VALUE = ? (Given)
      }{
         Value to test each array value against.
      }
      \sstsubsection{
         NUMBER = INTEGER (Returned)
      }{
         The number of elements of the input array greater than the
         specified value when VABS = FALSE, or the number of elements
         of the input array whose absolute values are greater than the
         specified value when VABS = TRUE.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         array and comparison value supplied to the routine must have the
         data type specified.
      }
   }
}
\sstroutine{
   KPG1\_NUMBx
}{
   Counts the number of elements with values or absolute values
   above or below a limit
}{
   \sstdescription{
      This routine returns the number of points in the input array
      that have a value or absolute value greater than or less than
      the input value.
   }
   \sstinvocation{
      CALL KPG1\_NUMBx( BAD, VABS, ABOVE, EL, INARR, VALUE, NUMBER,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true testing for bad pixels will be made.  This should not
         be set to false unless there definitely no bad values within
         the input array.
      }
      \sstsubsection{
         VABS = LOGICAL (Given)
      }{
         If true the comparison is performed with the absolute value
         of each array element.
      }
      \sstsubsection{
         ABOVE = LOGICAL (Given)
      }{
         If true the criterion tests for array values greater than the
         limit; if false the criterion tests for array values less than
         the limit.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The input data array
      }
      \sstsubsection{
         VALUE = ? (Given)
      }{
         Value to test each array value against.
      }
      \sstsubsection{
         NUMBER = INTEGER (Returned)
      }{
         The number of elements of the input array greater than the
         specified value when VABS = FALSE, or the number of elements
         of the input array whose absolute values are greater than the
         specified value when VABS = TRUE.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         array and comparison value supplied to the routine must have the
         data type specified.
      }
   }
}
\sstroutine{
   KPG1\_NUMBx
}{
   Counts the number of elements with values or absolute values
   above or below a limit
}{
   \sstdescription{
      This routine returns the number of points in the input array
      that have a value or absolute value greater than or less than
      the input value.
   }
   \sstinvocation{
      CALL KPG1\_NUMBx( BAD, VABS, ABOVE, EL, INARR, VALUE, NUMBER,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true testing for bad pixels will be made.  This should not
         be set to false unless there definitely no bad values within
         the input array.
      }
      \sstsubsection{
         VABS = LOGICAL (Given)
      }{
         If true the comparison is performed with the absolute value
         of each array element.
      }
      \sstsubsection{
         ABOVE = LOGICAL (Given)
      }{
         If true the criterion tests for array values greater than the
         limit; if false the criterion tests for array values less than
         the limit.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The input data array
      }
      \sstsubsection{
         VALUE = ? (Given)
      }{
         Value to test each array value against.
      }
      \sstsubsection{
         NUMBER = INTEGER (Returned)
      }{
         The number of elements of the input array greater than the
         specified value when VABS = FALSE, or the number of elements
         of the input array whose absolute values are greater than the
         specified value when VABS = TRUE.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         array and comparison value supplied to the routine must have the
         data type specified.
      }
   }
}
\sstroutine{
   KPG1\_NUMBx
}{
   Counts the number of elements with values or absolute values
   above or below a limit
}{
   \sstdescription{
      This routine returns the number of points in the input array
      that have a value or absolute value greater than or less than
      the input value.
   }
   \sstinvocation{
      CALL KPG1\_NUMBx( BAD, VABS, ABOVE, EL, INARR, VALUE, NUMBER,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true testing for bad pixels will be made.  This should not
         be set to false unless there definitely no bad values within
         the input array.
      }
      \sstsubsection{
         VABS = LOGICAL (Given)
      }{
         If true the comparison is performed with the absolute value
         of each array element.
      }
      \sstsubsection{
         ABOVE = LOGICAL (Given)
      }{
         If true the criterion tests for array values greater than the
         limit; if false the criterion tests for array values less than
         the limit.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The input data array
      }
      \sstsubsection{
         VALUE = ? (Given)
      }{
         Value to test each array value against.
      }
      \sstsubsection{
         NUMBER = INTEGER (Returned)
      }{
         The number of elements of the input array greater than the
         specified value when VABS = FALSE, or the number of elements
         of the input array whose absolute values are greater than the
         specified value when VABS = TRUE.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         array and comparison value supplied to the routine must have the
         data type specified.
      }
   }
}
\sstroutine{
   KPG1\_NUMBx
}{
   Counts the number of elements with values or absolute values
   above or below a limit
}{
   \sstdescription{
      This routine returns the number of points in the input array
      that have a value or absolute value greater than or less than
      the input value.
   }
   \sstinvocation{
      CALL KPG1\_NUMBx( BAD, VABS, ABOVE, EL, INARR, VALUE, NUMBER,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true testing for bad pixels will be made.  This should not
         be set to false unless there definitely no bad values within
         the input array.
      }
      \sstsubsection{
         VABS = LOGICAL (Given)
      }{
         If true the comparison is performed with the absolute value
         of each array element.
      }
      \sstsubsection{
         ABOVE = LOGICAL (Given)
      }{
         If true the criterion tests for array values greater than the
         limit; if false the criterion tests for array values less than
         the limit.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the input array.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The input data array
      }
      \sstsubsection{
         VALUE = ? (Given)
      }{
         Value to test each array value against.
      }
      \sstsubsection{
         NUMBER = INTEGER (Returned)
      }{
         The number of elements of the input array greater than the
         specified value when VABS = FALSE, or the number of elements
         of the input array whose absolute values are greater than the
         specified value when VABS = TRUE.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         array and comparison value supplied to the routine must have the
         data type specified.
      }
   }
}
\sstroutine{
   KPG1\_NUMFL
}{
   This counts the number of lines in a text file
}{
   \sstdescription{
      This routine counts the number of non-comment, comment, and blank
      lines in a text file.  Comment lines are those beginning, with
      any of the characters passed in the COMENT argument (normally !
      and \#).  Here {\tt '}beginning{\tt '} means the first non-blank character.
   }
   \sstinvocation{
      CALL KPG1\_NUMFL( FD, COMENT, NLINES, NCOMS, NBLANK, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         Fortran file identifier.
      }
      \sstsubsection{
         COMENT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A comma-separated list of comment characters.  If any line of
         the file begins with one of these, the line is treated as a
         comment line.
      }
      \sstsubsection{
         NLINES = INTEGER (Given)
      }{
         The number of non-comment lines in the file.
      }
      \sstsubsection{
         NCOMS = INTEGER (Given)
      }{
         The number of comment lines in the file.
      }
      \sstsubsection{
         NCOMS = INTEGER (Given)
      }{
         The number of blank lines in the file.
      }
      \sstsubsection{
         STATUS = INTEGER (\{status\_access\_mode\})
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The file is rewound, but not closed on exit.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         The Fortran text file must already be opened.
      }
   }
}
\sstroutine{
   KPG1\_ORVAR
}{
   To return the variances and covariances of the order statistics
   from n to 1, assuming an initially normal distribution
}{
   \sstdescription{
      The routine returns the variances and covariances of the order
      statistics, assuming an initial (pre-ordered) normal distribution
      of mean 0 and standard deviation 1. The routine returns all
      variance/covariances in an array with the terms vectorised - that
      is following on after each row. This uses the symmetric nature of
      the matrix to compress the data storage, but remember to double
      the covariance components if summing in quadrature. The variances
      \sstitemlist{

         \sstitem
         covariances are returned for all statistics from n to 1. The
         special case of n = 1 returns the variance of 2/pi (median).
      }
   }
   \sstinvocation{
      CALL KPG1\_ORVAR( NSET, NBIG, PP, VEC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NSET = INTEGER (Given)
      }{
         Number of members in ordered set.
      }
      \sstsubsection{
         NBIG = INTEGER (Given)
      }{
         Maximum number of entries in covariance array row.
         equal to NSET$*$(NSET$+$1)/2).
      }
      \sstsubsection{
         PP( NSET ) = DOUBLE PRECISION (Given)
      }{
         Workspace for storing expected values of order statistics.
      }
      \sstsubsection{
         VEC( NBIG, NSET ) = DOUBLE PRECISION (Returned)
      }{
         The upper triangles of the nset by nset variance-covariance
         matrix packed by columns. Each triangle is packed into a
         single row. For each row element Vij is stored in
         VEC(i$+$j$*$(j-1)/2), for 1$<$=i$<$=j$<$=nset.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Data is returned as above to save on repeated calls (which are
         too slow). To get the actual variance of the data of order n you
         need to sum all the variances and twice the covariances and use
         these to modify the actual variance of the (unordered) data.

         \sstitem
         It is assumed that NSET cannot be any larger than MXVAL.
      }
   }
}
\sstroutine{
   KPG1\_PACOL
}{
   Obtain a marker colour
}{
   \sstdescription{
      This routine obtains a colour index. A string is obtained from the
      parameter system.  The interpretation of this string provides a number
      of ways to specify the colour index requested.  The options are:

        {\tt '}MAX{\tt '}          - The maximum (non-reserved) colour index, i.e.
                         the highest colour index used for the display
                         of an image.
        {\tt '}MIN{\tt '}          - The minimum non-reserved colour index, i.e. the
                         lowest colour index used for the display of an
                         image.
        An integer     - The actual colour index. It is constrained
                         between 0 and the highest colour index.
        A named colour - Uses the named colour from the palette, and if
                         it is not present, the nearest colour from the
                         palette is selected.
   }
   \sstinvocation{
      CALL KPG1\_PACOL( PNCOL, LP, UP, COLIND, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNCOL = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the ADAM parameter to obtain the marker colour.
         It should have type LITERAL.
      }
      \sstsubsection{
         LP = INTEGER (Given)
      }{
         The lowest non-reserved colour index.
      }
      \sstsubsection{
         UP = INTEGER (Given)
      }{
         The highest non-reserved colour index.
      }
      \sstsubsection{
         COLIND = INTEGER (Returned)
      }{
         The colour index of the selected colour.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         A PGPLOT image-display workstation must be open and active.
      }
   }
}
\sstroutine{
   KPG1\_PALCI
}{
   Finds the nearest colour in the palette to a named colour
}{
   \sstdescription{
      This routine finds the colour index within the palette of a
      named colour.  The required colour must be in the standard colour
      set, and SAI\_\_ERROR status is returned if it is not.  If the
      named colour is not present the index of the colour nearest to
      the requested colour is returned.  A city-block metric is used.
   }
   \sstinvocation{
      CALL KPG1\_PALCI( COLOUR, COLIND, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         COLOUR = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the colour whose colour index is required.
         Note at least eighteen characters are required to avoid
         truncation.  The name may be abbreviated.  If there is any
         ambiguity, the first match (in alphabetical order) is selected.
      }
      \sstsubsection{
         COLIND = INTEGER (Returned)
      }{
         The colour index within the palette of the colour or its
         nearest equivalent.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         A GKS image-display workstation must be open and active.
      }
   }
}
\sstroutine{
   KPG1\_PASTx
}{
   Pastes an array onto another
}{
   \sstdescription{
      This routine `pastes{\tt '} an array onto another array.  Values of
      the underlying array are replaced by values in the pasted
      array, except that bad values may also be made transparent,
      in other words the original base array appears through the bad
      values.  Origin information is used to situate the paste
      operation.
   }
   \sstinvocation{
      CALL KPG1\_PASTx( TRANSP, BAD, OFFSET, IDIMS, ELI,
                       INARR, ODIMS, ELO, BASE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TRANSP = LOGICAL (Given)
      }{
         Whether bad pixels are transparent or not.  If true, bad pixels
         in the pasted array will not be pasted into the revised array.
         This is ignored if BAD is false.
      }
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true then there may be bad values in the pasted array.  If
         false then there are definitely no bad values in the pasted
         array.
      }
      \sstsubsection{
         OFFSET( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The offset in each dimension of the pasted array{\tt '}s origin with
         respect to the origin of the base array.
      }
      \sstsubsection{
         IDIMS( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The dimensions of the array to be pasted.  Unused dimensions
         up to NDF\_\_MXDIM should be set to one.
      }
      \sstsubsection{
         ELI = INTEGER (Given)
      }{
         The number of elements in the array to be pasted.
      }
      \sstsubsection{
         INARR( ELI ) = ? (Given)
      }{
         The array that will be pasted onto the base array.
      }
      \sstsubsection{
         ODIMS( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The dimensions of the base array.  Unused dimensions up to
         NDF\_\_MXDIM should be set to one.
      }
      \sstsubsection{
         ELO = INTEGER (Given)
      }{
         The number of elements in the base array.
      }
      \sstsubsection{
         BASE( ELO ) = ? (Given and Returned)
      }{
         The base array onto which the input array will be pasted.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine works in n-D, where n is 1 to 7.  Even if the
         array has actually less dimensions there is negligible loss of
         efficiency to supply dummy (=1) higher dimensions.

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         base and paste arrays supplied to the routine must have the data
         type specified.
      }
   }
}
\sstroutine{
   KPG1\_PASTx
}{
   Pastes an array onto another
}{
   \sstdescription{
      This routine `pastes{\tt '} an array onto another array.  Values of
      the underlying array are replaced by values in the pasted
      array, except that bad values may also be made transparent,
      in other words the original base array appears through the bad
      values.  Origin information is used to situate the paste
      operation.
   }
   \sstinvocation{
      CALL KPG1\_PASTx( TRANSP, BAD, OFFSET, IDIMS, ELI,
                       INARR, ODIMS, ELO, BASE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TRANSP = LOGICAL (Given)
      }{
         Whether bad pixels are transparent or not.  If true, bad pixels
         in the pasted array will not be pasted into the revised array.
         This is ignored if BAD is false.
      }
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true then there may be bad values in the pasted array.  If
         false then there are definitely no bad values in the pasted
         array.
      }
      \sstsubsection{
         OFFSET( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The offset in each dimension of the pasted array{\tt '}s origin with
         respect to the origin of the base array.
      }
      \sstsubsection{
         IDIMS( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The dimensions of the array to be pasted.  Unused dimensions
         up to NDF\_\_MXDIM should be set to one.
      }
      \sstsubsection{
         ELI = INTEGER (Given)
      }{
         The number of elements in the array to be pasted.
      }
      \sstsubsection{
         INARR( ELI ) = ? (Given)
      }{
         The array that will be pasted onto the base array.
      }
      \sstsubsection{
         ODIMS( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The dimensions of the base array.  Unused dimensions up to
         NDF\_\_MXDIM should be set to one.
      }
      \sstsubsection{
         ELO = INTEGER (Given)
      }{
         The number of elements in the base array.
      }
      \sstsubsection{
         BASE( ELO ) = ? (Given and Returned)
      }{
         The base array onto which the input array will be pasted.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine works in n-D, where n is 1 to 7.  Even if the
         array has actually less dimensions there is negligible loss of
         efficiency to supply dummy (=1) higher dimensions.

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         base and paste arrays supplied to the routine must have the data
         type specified.
      }
   }
}
\sstroutine{
   KPG1\_PASTx
}{
   Pastes an array onto another
}{
   \sstdescription{
      This routine `pastes{\tt '} an array onto another array.  Values of
      the underlying array are replaced by values in the pasted
      array, except that bad values may also be made transparent,
      in other words the original base array appears through the bad
      values.  Origin information is used to situate the paste
      operation.
   }
   \sstinvocation{
      CALL KPG1\_PASTx( TRANSP, BAD, OFFSET, IDIMS, ELI,
                       INARR, ODIMS, ELO, BASE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TRANSP = LOGICAL (Given)
      }{
         Whether bad pixels are transparent or not.  If true, bad pixels
         in the pasted array will not be pasted into the revised array.
         This is ignored if BAD is false.
      }
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true then there may be bad values in the pasted array.  If
         false then there are definitely no bad values in the pasted
         array.
      }
      \sstsubsection{
         OFFSET( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The offset in each dimension of the pasted array{\tt '}s origin with
         respect to the origin of the base array.
      }
      \sstsubsection{
         IDIMS( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The dimensions of the array to be pasted.  Unused dimensions
         up to NDF\_\_MXDIM should be set to one.
      }
      \sstsubsection{
         ELI = INTEGER (Given)
      }{
         The number of elements in the array to be pasted.
      }
      \sstsubsection{
         INARR( ELI ) = ? (Given)
      }{
         The array that will be pasted onto the base array.
      }
      \sstsubsection{
         ODIMS( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The dimensions of the base array.  Unused dimensions up to
         NDF\_\_MXDIM should be set to one.
      }
      \sstsubsection{
         ELO = INTEGER (Given)
      }{
         The number of elements in the base array.
      }
      \sstsubsection{
         BASE( ELO ) = ? (Given and Returned)
      }{
         The base array onto which the input array will be pasted.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine works in n-D, where n is 1 to 7.  Even if the
         array has actually less dimensions there is negligible loss of
         efficiency to supply dummy (=1) higher dimensions.

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         base and paste arrays supplied to the routine must have the data
         type specified.
      }
   }
}
\sstroutine{
   KPG1\_PASTx
}{
   Pastes an array onto another
}{
   \sstdescription{
      This routine `pastes{\tt '} an array onto another array.  Values of
      the underlying array are replaced by values in the pasted
      array, except that bad values may also be made transparent,
      in other words the original base array appears through the bad
      values.  Origin information is used to situate the paste
      operation.
   }
   \sstinvocation{
      CALL KPG1\_PASTx( TRANSP, BAD, OFFSET, IDIMS, ELI,
                       INARR, ODIMS, ELO, BASE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TRANSP = LOGICAL (Given)
      }{
         Whether bad pixels are transparent or not.  If true, bad pixels
         in the pasted array will not be pasted into the revised array.
         This is ignored if BAD is false.
      }
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true then there may be bad values in the pasted array.  If
         false then there are definitely no bad values in the pasted
         array.
      }
      \sstsubsection{
         OFFSET( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The offset in each dimension of the pasted array{\tt '}s origin with
         respect to the origin of the base array.
      }
      \sstsubsection{
         IDIMS( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The dimensions of the array to be pasted.  Unused dimensions
         up to NDF\_\_MXDIM should be set to one.
      }
      \sstsubsection{
         ELI = INTEGER (Given)
      }{
         The number of elements in the array to be pasted.
      }
      \sstsubsection{
         INARR( ELI ) = ? (Given)
      }{
         The array that will be pasted onto the base array.
      }
      \sstsubsection{
         ODIMS( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The dimensions of the base array.  Unused dimensions up to
         NDF\_\_MXDIM should be set to one.
      }
      \sstsubsection{
         ELO = INTEGER (Given)
      }{
         The number of elements in the base array.
      }
      \sstsubsection{
         BASE( ELO ) = ? (Given and Returned)
      }{
         The base array onto which the input array will be pasted.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine works in n-D, where n is 1 to 7.  Even if the
         array has actually less dimensions there is negligible loss of
         efficiency to supply dummy (=1) higher dimensions.

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         base and paste arrays supplied to the routine must have the data
         type specified.
      }
   }
}
\sstroutine{
   KPG1\_PASTx
}{
   Pastes an array onto another
}{
   \sstdescription{
      This routine `pastes{\tt '} an array onto another array.  Values of
      the underlying array are replaced by values in the pasted
      array, except that bad values may also be made transparent,
      in other words the original base array appears through the bad
      values.  Origin information is used to situate the paste
      operation.
   }
   \sstinvocation{
      CALL KPG1\_PASTx( TRANSP, BAD, OFFSET, IDIMS, ELI,
                       INARR, ODIMS, ELO, BASE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TRANSP = LOGICAL (Given)
      }{
         Whether bad pixels are transparent or not.  If true, bad pixels
         in the pasted array will not be pasted into the revised array.
         This is ignored if BAD is false.
      }
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true then there may be bad values in the pasted array.  If
         false then there are definitely no bad values in the pasted
         array.
      }
      \sstsubsection{
         OFFSET( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The offset in each dimension of the pasted array{\tt '}s origin with
         respect to the origin of the base array.
      }
      \sstsubsection{
         IDIMS( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The dimensions of the array to be pasted.  Unused dimensions
         up to NDF\_\_MXDIM should be set to one.
      }
      \sstsubsection{
         ELI = INTEGER (Given)
      }{
         The number of elements in the array to be pasted.
      }
      \sstsubsection{
         INARR( ELI ) = ? (Given)
      }{
         The array that will be pasted onto the base array.
      }
      \sstsubsection{
         ODIMS( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The dimensions of the base array.  Unused dimensions up to
         NDF\_\_MXDIM should be set to one.
      }
      \sstsubsection{
         ELO = INTEGER (Given)
      }{
         The number of elements in the base array.
      }
      \sstsubsection{
         BASE( ELO ) = ? (Given and Returned)
      }{
         The base array onto which the input array will be pasted.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine works in n-D, where n is 1 to 7.  Even if the
         array has actually less dimensions there is negligible loss of
         efficiency to supply dummy (=1) higher dimensions.

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         base and paste arrays supplied to the routine must have the data
         type specified.
      }
   }
}
\sstroutine{
   KPG1\_PASTx
}{
   Pastes an array onto another
}{
   \sstdescription{
      This routine `pastes{\tt '} an array onto another array.  Values of
      the underlying array are replaced by values in the pasted
      array, except that bad values may also be made transparent,
      in other words the original base array appears through the bad
      values.  Origin information is used to situate the paste
      operation.
   }
   \sstinvocation{
      CALL KPG1\_PASTx( TRANSP, BAD, OFFSET, IDIMS, ELI,
                       INARR, ODIMS, ELO, BASE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TRANSP = LOGICAL (Given)
      }{
         Whether bad pixels are transparent or not.  If true, bad pixels
         in the pasted array will not be pasted into the revised array.
         This is ignored if BAD is false.
      }
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true then there may be bad values in the pasted array.  If
         false then there are definitely no bad values in the pasted
         array.
      }
      \sstsubsection{
         OFFSET( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The offset in each dimension of the pasted array{\tt '}s origin with
         respect to the origin of the base array.
      }
      \sstsubsection{
         IDIMS( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The dimensions of the array to be pasted.  Unused dimensions
         up to NDF\_\_MXDIM should be set to one.
      }
      \sstsubsection{
         ELI = INTEGER (Given)
      }{
         The number of elements in the array to be pasted.
      }
      \sstsubsection{
         INARR( ELI ) = ? (Given)
      }{
         The array that will be pasted onto the base array.
      }
      \sstsubsection{
         ODIMS( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The dimensions of the base array.  Unused dimensions up to
         NDF\_\_MXDIM should be set to one.
      }
      \sstsubsection{
         ELO = INTEGER (Given)
      }{
         The number of elements in the base array.
      }
      \sstsubsection{
         BASE( ELO ) = ? (Given and Returned)
      }{
         The base array onto which the input array will be pasted.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine works in n-D, where n is 1 to 7.  Even if the
         array has actually less dimensions there is negligible loss of
         efficiency to supply dummy (=1) higher dimensions.

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         base and paste arrays supplied to the routine must have the data
         type specified.
      }
   }
}
\sstroutine{
   KPG1\_PASTx
}{
   Pastes an array onto another
}{
   \sstdescription{
      This routine `pastes{\tt '} an array onto another array.  Values of
      the underlying array are replaced by values in the pasted
      array, except that bad values may also be made transparent,
      in other words the original base array appears through the bad
      values.  Origin information is used to situate the paste
      operation.
   }
   \sstinvocation{
      CALL KPG1\_PASTx( TRANSP, BAD, OFFSET, IDIMS, ELI,
                       INARR, ODIMS, ELO, BASE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TRANSP = LOGICAL (Given)
      }{
         Whether bad pixels are transparent or not.  If true, bad pixels
         in the pasted array will not be pasted into the revised array.
         This is ignored if BAD is false.
      }
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         If true then there may be bad values in the pasted array.  If
         false then there are definitely no bad values in the pasted
         array.
      }
      \sstsubsection{
         OFFSET( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The offset in each dimension of the pasted array{\tt '}s origin with
         respect to the origin of the base array.
      }
      \sstsubsection{
         IDIMS( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The dimensions of the array to be pasted.  Unused dimensions
         up to NDF\_\_MXDIM should be set to one.
      }
      \sstsubsection{
         ELI = INTEGER (Given)
      }{
         The number of elements in the array to be pasted.
      }
      \sstsubsection{
         INARR( ELI ) = ? (Given)
      }{
         The array that will be pasted onto the base array.
      }
      \sstsubsection{
         ODIMS( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The dimensions of the base array.  Unused dimensions up to
         NDF\_\_MXDIM should be set to one.
      }
      \sstsubsection{
         ELO = INTEGER (Given)
      }{
         The number of elements in the base array.
      }
      \sstsubsection{
         BASE( ELO ) = ? (Given and Returned)
      }{
         The base array onto which the input array will be pasted.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine works in n-D, where n is 1 to 7.  Even if the
         array has actually less dimensions there is negligible loss of
         efficiency to supply dummy (=1) higher dimensions.

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         base and paste arrays supplied to the routine must have the data
         type specified.
      }
   }
}
\sstroutine{
   KPG1\_PGCLR
}{
   Clear current PGPLOT viewport
}{
   \sstdescription{
      This routine clears the current PGPLOT viewport if possible. If it
      is not possible (eg for a printer) it does nothing.
   }
   \sstinvocation{
      CALL KPG1\_PGCLR( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         A PGPLOT image-display workstation must be open and active.
      }
   }
}
\sstroutine{
   KPG1\_PGCLS
}{
   Close down the AGI database and PGPLOT workstation
}{
   \sstdescription{
      This routine closes the graphics data base and PGPLOT workstation
      previously opened by KPG1\_PGOPN.
   }
   \sstinvocation{
      CALL KPG1\_PGCLS( PNAME, SAVCUR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use.
      }
      \sstsubsection{
         SAVCUR = LOGICAL (Given)
      }{
         If .TRUE., then the current AGI picture is retained as the
         current picture. If .FALSE., the picture which was current when
         the database was opened is re-instated.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine attempts to execute even if an error has already
         occurred (but the pallette will not be saved if an error has
         already occurred).
      }
   }
}
\sstroutine{
   KPG1\_PGCOL
}{
   Obtain a marker colour, given a colour specification
}{
   \sstdescription{
      This routine obtains a PGPLOT colour index to be used in an image
      display from a supplied string. The interpretation of this string
      provides a number of ways to specify the colour index requested.
      The options are:

        {\tt '}MAX{\tt '}          - The maximum (non-reserved) colour index, i.e.
                         the highest colour index used for the display
                         of an image.
        {\tt '}MIN{\tt '}          - The minimum non-reserved colour index, i.e. the
                         lowest colour index used for the display of an
                         image.
        An integer     - The actual colour index. It is constrained
                         between 0 and the highest colour index.
        A named colour - Uses the named colour from the palette, and if
                         it is not present, the nearest colour from the
                         palette is selected.

      An error is reported if the string does not conform to any of these
      formats.
   }
   \sstinvocation{
      CALL KPG1\_PGCOL( COL, LP, UP, COLIND, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         COL = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The string specifying the required colour.
      }
      \sstsubsection{
         LP = INTEGER (Given)
      }{
         The lowest non-reserved colour index.
      }
      \sstsubsection{
         UP = INTEGER (Given)
      }{
         The highest non-reserved colour index.
      }
      \sstsubsection{
         COLIND = INTEGER (Returned)
      }{
         The colour index of the selected colour.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         A PGPLOT image-display workstation must be open and active.
      }
   }
}
\sstroutine{
   KPG1\_PGCUR
}{
   Use the cursor to get a set of points
}{
   \sstdescription{
      This routine uses the PGPLOT cursor to get a set of positions in the
      world co-ordinate system of the current PGPLOT window. If a position
      is given outside the box specified by X1, X2, Y1, Y2, then a
      warning is issued and the position is ignored. The allowable box
      can extend outside the PGPLOT viewport (extrapolated world
      co-ordinates are returned for positions outside the viewport).

      The routine returns when any one of the following occurs:

      1) The maximum number of positions have been given (see MAXPNT).
      2) The right mouse button, {\tt "}X{\tt "} or {\tt "}.{\tt "} is pressed (but only if
         KEYS contains {\tt "}X{\tt "} or {\tt "}.{\tt "}). The cursor position is not returned.
      3) The key/button specified by EXACT is pressed. The cursor position
         IS returned.
   }
   \sstinvocation{
      CALL KPG1\_PGCUR( INFO, MESS, NACT, ACTDES, KEYS, X1, X2, Y1, Y2,
                       EXACT, X0, Y0, MAXPNT, RBMODE, LINE, BOX, MARK,
                       IPLOT, X, Y, ACT, NPNT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INFO = LOGICAL (Given)
      }{
         Display information describing the available actions before
         getting the first position?
      }
      \sstsubsection{
         MESS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The purpose for using the cursor. Eg {\tt "}select 2 points{\tt "}. May be
         blank.
      }
      \sstsubsection{
         NACT = INTEGER (Given)
      }{
         The number of available actions. Ignored if INFO is .FALSE.
      }
      \sstsubsection{
         ACTDES( NACT ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Short descriptions of each action. Ignored if INFO is .FALSE.
         Examples: {\tt "}select a point{\tt "}, {\tt "}exit{\tt "}, {\tt "}mark a star{\tt "}. etc.
      }
      \sstsubsection{
         KEYS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A string of NACT unique characters. These are the keyboard keys
         which must be pressed to select the corresponding action. Note, case
         is insignificant, but trailing spaces are significant. The left,
         middle and right mouse buttons are represented by the upper case
         characters A, D and X respectively (this is imposed by PGPLOT). A
         dot ({\tt "}.{\tt "}) is considered equivalent to an X (i.e. the right mouse
         button). In addition, due to problems in the GKS version of PGPLOT,
         a space ({\tt "} {\tt "}) is considered equivalent to an A (i.e. left mouse
         button).

         The {\tt "}X{\tt "} and {\tt "}.{\tt "} keys (or equivalently the right mouse button) are
         special in that (if they are included in KEYS) they cause the routine
         to exit without adding the cursor position to the list of returned
         positions. If KEYS includes neither {\tt "}X{\tt "} nor {\tt "}.{\tt "}, then presses of
         {\tt "}X{\tt "}, {\tt "}.{\tt "} or the right mouse button are ignored.
      }
      \sstsubsection{
         X1 = REAL (Given)
      }{
         World co-ord X at lower left corner of region in which positons
         may be entered.
      }
      \sstsubsection{
         X2 = REAL (Given)
      }{
         World co-ord X at upper right corner of region in which positons
         may be entered. If X1 and X2 are equal then no restrictions are
         placed on the region in which positions may be given.
      }
      \sstsubsection{
         Y1 = REAL (Given)
      }{
         World co-ord Y at lower left corner of region in which positons
         may be entered.
      }
      \sstsubsection{
         Y2 = REAL (Given)
      }{
         World co-ord Y at upper right corner of region in which positons
         may be entered. If Y1 and Y2 are equal then no restrictions are
         placed on the region in which positions may be given.
      }
      \sstsubsection{
         EXACT = REAL (Given)
      }{
         The index of an exit action. If the corresponding key/button press
         is made, then the cursor position is added to the list of returned
         positions and the routine then exits. Zero can be supplied if this
         facility is not required. Note, if KEYS contains {\tt "}X{\tt "} or {\tt "}.{\tt "} then
         the routine also exits (WITHOUT adding the cursor position to the
         returned list) if {\tt "}X{\tt "}, {\tt "}.{\tt "} or the right mouse button is pressed.
      }
      \sstsubsection{
         X0 = REAL (Given )
      }{
         The X world co-ordinate of the initial cursor position.
         Ignored if VAL\_\_BADR.
      }
      \sstsubsection{
         Y0 = REAL (Given )
      }{
         The Y world co-ordinate of the initial cursor position.
         Ignored if VAL\_\_BADR.
      }
      \sstsubsection{
         MAXPNT = INTEGER (Given)
      }{
         The maximum number of positions which can be given by the user
         before exiting.
      }
      \sstsubsection{
         RBMODE = INTEGER (Given)
      }{
         The form of the rubber band which connects the cursor to the
         previous position. Rubber bands are not available when using the
         GKS version of PGPLOT:
            0 - do not use a rubber band.
            1 - use a straight-line rubber band.
            2 - use a horizontal box rubber band.
      }
      \sstsubsection{
         LINE = INTEGER (Given)
      }{
         Specifies lines to be drawn as follows:
         \sstitemlist{

            \sstitem
               1: Join adjacent points and do not close the polygon.
                0: Do not draw any lines.
                1: Join adjacent points and close the polygon.
                2: Draw a vertical line between y1 and y2 (or the height of
                   the window if y1=y2).
                3: Draw a horizontal line between x1 and x2 (or the width of
                   the window if x1=x2).
            The plotting attributes are specified by the CURVES(...) attributes
            of the supplied Plot (see IPLOT).
         }
      }
      \sstsubsection{
         BOX = INTEGER (Given)
      }{
         If non-zero then a horizontal box is drawn between each position.
         The plotting attributes are specified by the BORDER(...) attributes
         of the supplied Plot (see IPLOT).
      }
      \sstsubsection{
         MARK = INTEGER (Given)
      }{
         If -31 or larger, then a marker is drawn at each position. The
         type of marker is given by the specific value (see PGPLOT routine
         PGPT). The plotting attributes are specified by the MARKERS(...)
         attributes of the supplied Plot (see IPLOT).
      }
      \sstsubsection{
         IPLOT = INTEGER (Given)
      }{
         Defines the plotting styles for any graphics (see LINE, BOX and
         MARK). If AST\_\_NULL is supplied, ther current PGPLOT attributes
         are used for all graphics.
      }
      \sstsubsection{
         X( MAXPNT ) = REAL (Returned)
      }{
         Elements 1 to NPNT hold the selected X positions.
      }
      \sstsubsection{
         Y( MAXPNT ) = REAL (Returned)
      }{
         Elements 1 to NPNT hold the selected X positions.
      }
      \sstsubsection{
         ACT( MAXPNT ) = INTEGER (Returned)
      }{
         Elements 1 to NPNT hold the indices of the actions for each
         selected point. In range 1 to NACT.
      }
      \sstsubsection{
         NPNT = INTEGER (Returned)
      }{
         The number of positions given by the user (this includes the
         position at which the action specified by EXACT was pressed -
         if it was. It does not include the position at which {\tt "}X{\tt "}, {\tt "}.{\tt "} or
         the right mouse button was pressed).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_PGCUT
}{
   Cut a section out of the current PGPLOT window
}{
   \sstdescription{
      This routine sets the PGPLOT viewport so that it covers a specified
      section of the current PGPLOT window. The world co-ordinate bounds
      of the corresponding window are set to the supplied bounds.
   }
   \sstinvocation{
      CALL  KPG1\_PGCUT( X1, X2, Y1, Y2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         X1 = REAL (Given)
      }{
         The X world co-ordinate at the bottom left corner of the section
         of the viewport to be cut.
      }
      \sstsubsection{
         X2 = REAL (Given)
      }{
         The X world co-ordinate at the top right corner of the section
         of the viewport to be cut.
      }
      \sstsubsection{
         Y1 = REAL (Given)
      }{
         The Y world co-ordinate at the bottom left corner of the section
         of the viewport to be cut.
      }
      \sstsubsection{
         Y2 = REAL (Given)
      }{
         The Y world co-ordinate at the top right corner of the section
         of the viewport to be cut.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_PGESC
}{
   Remove PGPLOT escape sequences from a text string
}{
   \sstdescription{
      This routine removes PGPLOT escape sequences form a text string.
      Any {\tt "}$\backslash${\tt "} characters in the string are removed, together with the
      character following each {\tt "}$\backslash${\tt "}.
   }
   \sstinvocation{
      CALL  KPG1\_PGESC( TEXT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TEXT = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The text string.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_PGLOC
}{
   Locate a component of an HDS structure relating to the currently
   opened PGPLOT device
}{
   \sstdescription{
      LOC1 is an locator for an HDS structure which contains components
      relating to one or more PGPLOT devices. These components, for
      instance, may contain the colour palette or colour table to be used
      with the corresponding PGPLOT device. This routine searches the
      structure for a component relating to the currently opened PGPLOT
      device, and returns a locator for it if found. If not found, and
      if the currently opened PGPLOT device is a GWM window, a search is
      made for a component relating to a GWM window with a different name.
      If no such device is found, (or if an error occurs) DAT\_\_NOLOC is
      returned.

      For instance, if the currently opened graphics device is {\tt "}x2windows{\tt "}
      (i.e. {\tt "}xwindows2/GWM{\tt "}), a search is made first for a component called
      AGI\_3801\_2. If this is not found, a search is made for a component
      with a name corresponding to any /GWM device (e.g. AGI\_3800\_1 which
      corresponds to {\tt "}xwindows/GWM{\tt "}, or one of the other xwindows sevices).

      The component names used are the same as the names uses for the device
      within the AGI database (e.g. {\tt "}AGI\_3801\_2{\tt "}, etc).
   }
   \sstinvocation{
      CALL KPG1\_PGLOC( LOC1, LOC2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC1 = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A locator for the object to be searched.
      }
      \sstsubsection{
         LOC2 = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         A locator for the found component.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A PGPLOT device must previously have been opened using AGI.
      }
   }
}
\sstroutine{
   KPG1\_PGLUT
}{
   Use an array of colour representations to set up the PGPLOT colour
   table
}{
   \sstdescription{
      This routine stores new colour representations for a range of PGPLOT
      colour indices. A list of NCOL colour representations is supplied.
      These are normalized so that the highest value produces full colour
      intensity. The first colour (1) is assigned to PGPLOT colour index LO,
      and the last (NCOL) is assigned to PGPLOT colour index HI. The colour
      representations for the PGPLOT colour indices between LO and HI
      are formed by interpolation amonst the supplied NCOL colours, using
      either nearest-neighbour or linear interpolation.
   }
   \sstinvocation{
      CALL KPG1\_PGLUT( NCOL, COLS, LO, HI, NN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NCOL = INTEGER (Given)
      }{
         The number of colour indices in the supplied colour table.
      }
      \sstsubsection{
         COLS( 3, NCOL ) = REAL (Given)
      }{
         The lookup table.  The first dimension is RGB.  Values
         should lie in the range 0.0--1.0.
      }
      \sstsubsection{
         LO = INTEGER (Given)
      }{
         The lowest PGPLOT colour index to use.
      }
      \sstsubsection{
         HI  = INTEGER (Given)
      }{
         The highest PGPLOT colour index to use.
      }
      \sstsubsection{
         NN = LOGICAL (Given)
      }{
         If true, and the number of input and output colour indices are
         different, the nearest-neighbour method is used for assigning
         values in the output array.  Otherwise linear interpolation
         is used.  Nearest-neighbour preserves sharp edges in the
         lookup; linear interpolation is recommended for smoothly
         varying lookup tables.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status.
      }
   }
}
\sstroutine{
   KPG1\_PGOPN
}{
   Open the AGI database and activate a PGPLOT workstation
}{
   \sstdescription{
      This routine opens the graphics data abse and actiavtes a PGPLOT
      workstation selected using the specified parameter. Ther user{\tt '}s
      pallette and colour table is then re-instated, over-riding the
      those established by PGPLOT.

      The device should normally be shut down using KPG1\_PGCLS.
   }
   \sstinvocation{
      CALL KPG1\_PGOPN( PNAME, MODE, IPIC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The nameof the parameter to use.
      }
      \sstsubsection{
         MODE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The AGI access mode; {\tt "}WRITE{\tt "} or {\tt "}UPDATE{\tt "}. Write causes the
         current picture to be cleared (the contents of the database are
         unaffected).
      }
      \sstsubsection{
         IPIC = INTEGER (Returned)
      }{
         AN AGI identifier for the current picture.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_PGPIX
}{
   Display an image using PGPLOT
}{
   \sstdescription{
      This routine uses PGPIXL to display an array of colour indices
      as a rectangular image. The area occupied by the array of colour
      indices is specified within a nominated Domain. Two opposite
      corners of this area are transformed into the Base Frame
      of the Plot (which should correspond to the current PGPLOT world
      co-ordinate sysytem), and the array of colour indices is drawn
      between these two transformed positions.
   }
   \sstinvocation{
      CALL  KPG1\_PGPIX( IPLOT, DOMAIN, LBND, UBND, NX, NY, COLI, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPLOT = INTEGER (Given)
      }{
         A pointer to an AST Plot. The Base Frame in this Plot should
         correspond to the world co-ordinates in the current PGPLOT window.
      }
      \sstsubsection{
         DOMAIN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The Domain in which the coordinates supplied in BOX are defined.
      }
      \sstsubsection{
         LBND( 2 ) = REAL (Given)
      }{
         The lower bounds of the area covered by the supplied array of
         colour indices, in the Domain given by DOMAIN.
      }
      \sstsubsection{
         UBND( 2 ) = REAL (Given)
      }{
         The upper bounds of the area covered by the supplied array of
         colour indices, in the Domain given by DOMAIN.
      }
      \sstsubsection{
         NX = INTEGER
      }{
         Number of columns in the array of colour indices.
      }
      \sstsubsection{
         NY = INTEGER
      }{
         Number of rows in the array of colour indices.
      }
      \sstsubsection{
         COLI( NX, NY ) = INTEGER (Given)
      }{
         The array of colour indices.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_PGSHT
}{
   Set the PGPLOT character size in world coordinates
}{
   \sstdescription{
      This routine sets the PGPLOT character size to a specified value in
      world coordinates. It mimics SGS\_SHTX in so far as this is possible.

      Note SGS and PGPLOT behave differently if the scales on the X and Y
      axes are not equal. SGS keeps the character size constant in world
      oordinates, so absolute character size will be different for vertical
      and horizontal text. On the other hand, PGPLOT keeps the absolute
      character size fixed, resulting in the characters size in world
      coordinates varying for horizontal and vertical text. This routine
      sets the size for horizontal text. If the axis scales are not equal,
      vertical text will have have a different size (in world coordinates).
   }
   \sstinvocation{
      CALL  KPG1\_PGSHT( HGT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         HGT = REAL (Given)
      }{
         The required character height, in world coordinates.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_PGSTY
}{
   Establish values for graphics attributes
}{
   \sstdescription{
      This routine establishes current PGPLOT attributes so that they
      correspond to the values for a named graphics element stored in the
      supplied Plot (see SUN/210). Only attributes which have values
      explicitly set in the Plot are changed. If no value has been set
      for a Plot attribute, the corresponding PGPLOT attribute is left
      unchanged.

      If SET is supplied .TRUE., then the PGPLOT attributes for the
      specified graphics element are extracted from the supplied Plot and
      made active. The previously active values are returned in ATTRS. If
      SET is supplied .FALSE., the values supplied in ATTRS are made current
      (in this case ATTRS is returned unchanged).
   }
   \sstinvocation{
      CALL KPG1\_PGSTY( IPLOT, ELEM, SET, ATTRS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPLOT = INTEGER (Given)
      }{
         An AST pointer to a Plot.
      }
      \sstsubsection{
         ELEM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of an AST graphics element.
      }
      \sstsubsection{
         SET = LOGICAL (Given)
      }{
         Should the Plot values be made curent? Otherwise the values in
         ATTRS are made current.
      }
      \sstsubsection{
         ATTS( $*$ ) = REAL (Given and Returned)
      }{
         On entry, the attribute values to set if SET is .FALSE., These
         should have been obtained from a previous call to this routine.
         On exit, the attribute values current on entry to this routine
         are returned (unless SET is .FALSE. in which case the supplied values
         are returned unchanged). This array should have at least 5 elements.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_PGTXT
}{
   Draw text using PGPLOT and return concatenation point
}{
   \sstdescription{
      This routine plots the supplied text at a given angle using
      PGPLOT, putting the bottom left corner of the text at the
      supplied position. The position at which another string must be
      drawn to concatenate it with the string just drawn is returned.
   }
   \sstinvocation{
      CALL KPG1\_PGTXT( ANGLE, TEXT, X, Y, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         ANGLE = INTEGER (Given)
      }{
         The angle, in degrees, that the baseline is to make with the
         horizontal, increasing anti-clockwise (0.0 is horizontal).
      }
      \sstsubsection{
         TEXT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The text to draw. The returned values of X and Y leave room for
         any trailing spaces, UNLESS THE ENTIRE STRING IS BLANK, IN WHICH
      }
   }
   \sstdiytopic{
      $*$       CASE X AND Y ARE RETURNED UNCHANGED.
   }{
         X = REAL (Given and Returned)
            The X position for the bottom left corner of the string.
            On exit, it is the X position at the bottom of the a string
            to be concatenated to the one just drawn.
         Y = REAL (Given and Returned)
            The Y position for the bottom left corner of the string.
            On exit, it is the Y position at the bottom of the a string
            to be concatenated to the one just drawn.
         STATUS = INTEGER (Given and Returned)
            The global status.

      Authors:
         DSB: David S. Berry (STARLINK)

      History:
         17-MAR-1998 (DSB):
            Original version.

      Bugs:
   }
}
\sstroutine{
   KPG1\_PL2GE
}{
   Reads 2-dimensional polynomial information from a POLYNOMIAL
   structure
}{
   \sstdescription{
      This routine reads information describing a 2-dimensional
      polynomial surface from a standard Starlink POLYNOMIAL structure,
      as defined in SGP/38.  All floating-point information within the
      structure is returned as DOUBLE PRECISION.

      It is assumed the calling program needs a 1-dimensional array of
      coefficients, where COEFF( (IX-1)$*$NYPAR $+$ IY ) contains the
      coefficient for the (IX,IY)th term (with NYPAR being the total
      number of Y terms).  Such a 1-dimensional array is used by the
      NAG routines and defined in the NAG manual (see Chapter E02 on
      {\tt "}Curve and Surface fitting{\tt "}).

      This routine will convert read the 2-dimensional coefficient
      array from the POLYNOMIAL structure (in the format described in
      SGP/38) and load a flipped version of this into the required
      1-dimensional array.  If there is a variance array present, the
      VARPRE flag is set .TRUE., and the variances returned in VARIAN.

      The routine will also read the TMIN and TMAX arrays from the
      structure and return XMIN, XMAX, YMIN and YMAX.  Note that these
      items are compulsory when VARNT={\tt '}CHEBYSHEV{\tt '} but optional when
      VARNT={\tt '}SIMPLE{\tt '}.  In the latter case an attempt will be made to
      read TMIN and TMAX from the structure, but their absence will not
      be regarded as an error.  The returned parameter LIMITS will
      indicate if these items have been read successfully.
   }
   \sstinvocation{
      CALL KPG1\_PL2GE( LOC, MXPAR, VARNT, NXPAR, NYPAR, LIMITS, XMIN,
                       XMAX, YMIN, YMAX, COEFF, VARPRE, VARIAN, WORK,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER$*$( DAT\_\_SZLOC ) (Given)
      }{
         Locator to the existing POLYNOMIAL structure.
      }
      \sstsubsection{
         MXPAR = INTEGER (Given)
      }{
         The maximum number of parameters in either x or y.  The
         declared size of the coefficient arrays given to this routine
         is assumed to be MXPAR $*$ MXPAR (see below).
      }
      \sstsubsection{
         VARNT = CHARACTER$*$($*$) (Returned)
      }{
         Variant of the polynomial ({\tt '}CHEBYSHEV{\tt '} or {\tt '}SIMPLE{\tt '}).  This
         item should be at least CHARACTER$*$9.
      }
      \sstsubsection{
         NXPAR = INTEGER (Returned)
      }{
         Number of x parameters (= order of polynomial in x direction $+$
         1)
      }
      \sstsubsection{
         NYPAR = INTEGER (Returned)
      }{
         Number of y parameters (= order of polynomial in Y direction $+$ 1)
      }
      \sstsubsection{
         LIMITS = LOGICAL (Returned)
      }{
         When VARNT={\tt '}SIMPLE{\tt '} this logical flag indicates whether any
         TMIN and TMAX limits have been read from the polynomial
         structure and returned in the next 4 arguments (in which case
         LIMITS will be .TRUE.).
      }
      \sstsubsection{
         XMIN = DOUBLE PRECISION (Returned)
      }{
         Minimum value along x axis for which polynomial is valid.
      }
      \sstsubsection{
         XMAX = DOUBLE PRECISION (Returned)
      }{
         Maximum value along x axis for which polynomial is valid.
      }
      \sstsubsection{
         YMIN = DOUBLE PRECISION (Returned)
      }{
         Minimum value along y axis for which polynomial is valid.
      }
      \sstsubsection{
         YMAX = DOUBLE PRECISION (Returned)
      }{
         Maximum value along y axis for which polynomial is valid.
      }
      \sstsubsection{
         COEFF( MXPAR $*$ MXPAR ) = DOUBLE PRECISION (Returned)
      }{
         Array of polynomial coefficients, in the format used by NAG
         routines (see KPS1\_FSPF2).
      }
      \sstsubsection{
         VARPRE = LOGICAL (Returned)
      }{
         Whether or not there are coefficient variances present in the
         POLYNOMIAL structure.
      }
      \sstsubsection{
         VARIAN( MXPAR $*$ MXPAR ) = DOUBLE PRECISION (Returned)
      }{
         Array of polynomial coefficient variances, in the format used
         by NAG routines.  The values are only assigned when VARPRE is
         .TRUE..
      }
      \sstsubsection{
         WORK( MXPAR, MXPAR ) = DOUBLE PRECISION (Returned)
      }{
         Work array containing the 2-dimensional array of coefficients as read from the
         POLYNOMIAL structure.
      }
      \sstsubsection{
         STATUS =  INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Uses the magic-value method for bad or undefined pixels.
      }
   }
}
\sstroutine{
   KPG1\_PL2PU
}{
   Writes 2-dimensional polynomial information to a POLYNOMIAL
   structure
}{
   \sstdescription{
      This routine writes information describing a 2-dimensional
      polynomial surface to a standard Starlink POLYNOMIAL structure,
      as defined in SGP/38.  An empty POLYNOMIAL structure should
      already have been created.  All floating point components within
      the structure are written as DOUBLE PRECISION.

      It is assumed the calling program has a 1-dimensional array of
      coefficients, where COEFF( (IX-1)$*$NYPAR $+$ IY ) contains the
      coefficient for the (IX,IY)th term (with NYPAR being the total
      number of Y terms).  Such a 1-dimensional array is used by the
      NAG routines and defined in the NAG manual (see Chapter E02 on
      {\tt "}Curve and Surface fitting{\tt "}).

      This routine will convert the coefficient array to 2-dimensional,
      flip it around and store it in the POLYNOMIAL structure so that
      DATA\_ARRAY(IX,IY) contains the coefficient for the (IX,IY)th term
      (see SGP/38).

      The routine will also load the TMIN and TMAX arrays with XMIN,
      XMAX, YMIN and YMAX.  Note that these are compulsory when
      VARNT={\tt '}CHEBYSHEV{\tt '} but optional when VARNT={\tt '}SIMPLE{\tt '}.  In the latter
      case the logical parameter LIMITS will be used to decide whether
      to write the limits.
   }
   \sstinvocation{
      CALL KPG1\_PL2PU( LOC, VARNT, NXPAR, NYPAR, LIMITS, XMIN, XMAX,
                       YMIN, YMAX, COEFF, VARIAN, WORK, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER $*$ ( DAT\_\_SZLOC ) (Given)
      }{
         Locator to existing but empty POLYNOMIAL structure.
      }
      \sstsubsection{
         VARNT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Variant of the polynomial ({\tt '}CHEBYSHEV{\tt '} or {\tt '}SIMPLE{\tt '}).  (This is
         written but not checked).
      }
      \sstsubsection{
         NXPAR = INTEGER (Given)
      }{
         Number of x parameters (= order of polynomial in x direction $+$
         1)
      }
      \sstsubsection{
         NYPAR  = INTEGER (Given)
      }{
         Number of y parameters (= order of polynomial in y direction $+$
         1)
      }
      \sstsubsection{
         LIMITS = LOGICAL (Given)
      }{
         When VARNT={\tt '}SIMPLE{\tt '} this logical flag may be used to control
         whether the TMIN and TMAX limits are written to the polynomial
         structure (based on the next 4 arguments).  Setting
         LIMITS=.TRUE. will cause the limits to be written.  This
         parameter is ignored when VARNT={\tt '}CHEBYSHEV{\tt '}, as the limits
         then are compulsory.
      }
      \sstsubsection{
         XMIN = DOUBLE PRECISION (Given)
      }{
         Minimum value along x axis for which polynomial is valid.
      }
      \sstsubsection{
         XMAX = DOUBLE PRECISION (Given)
      }{
         Maximum value along x axis for which polynomial is valid.
      }
      \sstsubsection{
         YMIN = DOUBLE PRECISION (Given)
      }{
         Minimum value along y axis for which polynomial is valid.
      }
      \sstsubsection{
         YMAX = DOUBLE PRECISION (Given)
      }{
         Maximum value along y axis for which polynomial is valid.
      }
      \sstsubsection{
         COEFF( NXPAR $*$ NYPAR ) = DOUBLE PRECISION (Given)
      }{
         Array of polynomial coefficients, in the format used by NAG
         routines.
      }
      \sstsubsection{
         VARIAN( NXPAR $*$ NYPAR ) = DOUBLE PRECISION (Given)
      }{
         Array of variances of polynomial coefficients, in the format
         used by NAG routines.
      }
      \sstsubsection{
         WORK( NXPAR, NYPAR ) = DOUBLE PRECISION (Returned)
      }{
         Work array used to flip the polynomial coefficients.  On exit
         it will contain the 2-dimensional array of coefficients
         written to the POLYNOMIAL structure.
      }
      \sstsubsection{
         STATUS =  INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Uses the magic-value method for bad or undefined pixels.
      }
   }
}
\sstroutine{
   KPG1\_PLCIP
}{
   Finds the nearest colour in the palette to a named colour
   (PGPLOT version of KPG1\_PALCI)
}{
   \sstdescription{
      This routine finds the PGPLOT colour index within the palette of a
      named colour.  The required colour must be in the standard colour
      set, and SAI\_\_ERROR status is returned if it is not.  If the
      named colour is not present the index of the colour nearest to
      the requested colour is returned.  A city-block metric is used.

      A close colour is only accepted if the close colour is not equal to
      the background colour. This avoids pens becoming invisible.
   }
   \sstinvocation{
      CALL KPG1\_PLCIP( COLOUR, COLIND, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         COLOUR = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the colour whose colour index is required.
         Note at least eighteen characters are required to avoid
         truncation.  The name may be abbreviated.  If there is any
         ambiguity, the first match (in alphabetical order) is selected.
      }
      \sstsubsection{
         COLIND = INTEGER (Returned)
      }{
         The colour index within the palette of the colour or its
         nearest equivalent.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         A PGPLOT image-display workstation must be open and active.
      }
   }
}
\sstroutine{
   KPG1\_PLGET
}{
   Get the colour palette for the currently open graphics device from
   a supplied array
}{
   \sstdescription{
      This routine gets the colour palette from a supplied array and
      loads it into the colour table of the currently open graphics device.
   }
   \sstinvocation{
      CALL KPG1\_PLGET( CI1, CI2, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         CI1 = INTEGER (Given)
      }{
         The lowest colour index to change.
      }
      \sstsubsection{
         CI2 = INTEGER (Given)
      }{
         The highest colour index to change.
      }
      \sstsubsection{
         ARRAY( 3, 0 : CI2 ) = REAL (Given)
      }{
         The array containing the colour palette to load.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A graphics device must previously have been opened using PGPLOT.
      }
   }
}
\sstroutine{
   KPG1\_PLLOD
}{
   Load the colour palette for the currently open graphics device
}{
   \sstdescription{
      This routine loads the colour palette for the currently open graphics
      device from an HDS container file in the users ADAM directory. The
      file is called {\tt "}kappa.palette.sdf{\tt "} and contains a palette for
      different devices. The file should have been created by KPG1\_PLSAV.
      If the file does not exist, the current colour table is left unchanged.

      Each palette in the file is a \_REAL array of shape (3,n) where
      n is the number of colours in the palette. The first colour (index 1
      in the array) is the background colour and is usually refered to as
      colour index zero. Therefore the highest colour index in the array is
      (n-1). Each array has a name which identifies the graphics device
      to which it refers. Each array has a name which identifies the
      graphics device to which it refers.
   }
   \sstinvocation{
      CALL KPG1\_PLLOD( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A graphics device must previously have been opened using PGPLOT.
      }
   }
}
\sstroutine{
   KPG1\_PLOTA
}{
   Open the graphics device and see if there is an existing DATA
   picture with which the new DATA picture could be aligned
}{
   \sstdescription{
      This routine opens a graphics device, clearing it or not as
      specified by the user. If it is not cleared an attempt is made to
      find a DATA picture within the current picture. If found it becomes
      the current AGI picture, the corresponding PGPLOT viewport is
      established as the current PGPLOT viewport, and an AST Plot is
      returned for it in which the Base (GRAPHICS) Frame corresponds to
      PGPLOT world co-ordinates. If no DATA picture is found, or if the
      device was not cleared on opening, the current AGI picture and
      PGPLOT viewport are unchanged on exit and no Plot is returned.

      Various environment parameters are used to obtain options, etc. The
      names of these parameters are hard-wired into this subroutine in
      order to ensure conformity between application.
   }
   \sstinvocation{
      CALL KPG1\_PLOTA( IWCS, STAT, DOMAIN, IPIC0, IPICD, IPLOT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         An AST pointer to a FrameSet. This may be AST\_\_NULL. The Current
         and Base Frames are unchanged on exit. If an existing DATA picture
         was created by a non-AST application it will not have a Plot
         stored with it. A default Plot will be created in this case,
         containing 2 Frames; a GRAPHICS Frame corresponding to millimetres
         from the bottom left corner of the view surface, and a Frame
         corresponding to AGI world co-ordinates. The AGI database does not
         contain any information describing world co-ordinates and so such
         information must be supplied by the calling application, on some
         assumption such as {\tt "}AGI world co-ordinates are PIXEL co-ordinates{\tt "}.
         This information is provided through a FrameSet (IWCS) and a Domain
         name (DOMAIN). DOMAIN specifies the Domain in which AGI world
         co-ordinates are assumed to live. A FrameSet may then be supplied
         using argument IWCS containing a Frame with the same Domain which
         will be used to describe AGI world co-ordinates in the returned
         Plot (a default 2-D Frame with the specified Domain is used if no
         FrameSet is supplied or if it does not contain a Frame with the
         specified Domain). If DOMAIN is supplied Blank, a default 2-D Frame
         with Domain AGI\_WORLD will be used to describe AGI world co-ordinates.

         If the existing DATA picture was created by an AST application,
         it will have a Plot stored with it which means that AGI world
         co-ordinates will be ignored. Consequently, the values supplied
         for IWCS and DOMAIN will also be ignored.
      }
      \sstsubsection{
         STAT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Determines whether or not the new DATA picture creted by the
         calling application is to be aligned with an existing DATA
         picture:

         {\tt '}NEW{\tt '}: no attempt is made to align the new DATA picture with an
                existing DATA picture, even if the CLEAR parameter is
                given a FALSE value.
         {\tt '}OLD{\tt '}: the new DATA picture is always aligned with an existing
                DATA picture. The CLEAR parameter is not accessed (it is
                assumed to have a FALSE value) and an error is reported
                if no DATA picture is available.
         {\tt '}UNKNOWN{\tt '}: If CLEAR is given a FALSE value then the new DATA
                picture is aligned with any existing DATA picture, but no
                error is reported if no DATA picture exists.
      }
      \sstsubsection{
         DOMAIN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The Domain for AGI world co-ordinates. Only used if a FrameSet is
         supplied (IWCS). If a blank value is supplied then {\tt "}AGI\_WORLD{\tt "}
         will be used. See description of argument IWCS above for more
         details.
      }
      \sstsubsection{
         IPIC0 = INTEGER (Returned)
      }{
         An AGI identifier for the original current picture.
      }
      \sstsubsection{
         IPICD = INTEGER (Returned)
      }{
         An AGI identifier for the existing DATA picture. Returned equal
         to -1 if there is no existing DATA picture or if the device was
         cleared on opening.
      }
      \sstsubsection{
         IPLOT = INTEGER (Returned)
      }{
         An AST pointer to a Plot associated with an existing DATA picture.
         Returned equal to AST\_\_NULL if an error occurs, or if there is no
         existing DATA picture, or if the device was cleared on opening.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Close down AGI and PGPLOT using KPG1\_PGCLS.
      }
   }
   \sstdiytopic{
      Parameters
   }{
      CLEAR = \_LOGICAL (Read)
         TRUE if the graphics device is to be cleared on opening. See
         argument STAT.
      DEVICE = DEVICE (Read)
         The plotting device.
   }
}
\sstroutine{
   KPG1\_PLOT
}{
   Prepare for graphics output
}{
   \sstdescription{
      This routine opens a graphics device and prepares for graphical
      output using PGPLOT within a new DATA picture. Optional ancillary
      pictures around the DATA picture may also be created. A FRAME
      picture enclosing the DATA picture and any ancillary pictures is
      created if any ancillary pictures or non-zero margins were requested.

      An AST Plot is returned which allows plotting within the DATA
      picture. The Base (GRAPHICS) Frame in this Plot corresponds to
      millimetres from the botttom left corner of the view surface.
      The Current Frame in the Plot is inherited from the supplied FrameSet
      (IWCS).

      If there is an existing DATA picture on the device, then the new DATA
      picture can optionally be aligned with the existing DATA picture. In
      this case, the returned Plot is formed by adding any supplied FrameSet
      (IWCS) into the Plot stored with the existing DATA picture in the AGI
      database (a default Plot is used if the database does not contain a
      Plot). The FrameSet is added into the Plot by aligning them in the
      Current Frame of the FrameSet if possible. If this is not possible,
      they are aligned in the world co-ordinate system of the picture
      (stored in the AGI database). The Domain of the AGI world
      co-ordinate system is not stored in the database and must be
      supplied by the calling application using argument DOMAIN (this will
      usually be {\tt "}PIXEL{\tt "}). If alignment is not possible in AGI world
      co-ordinates, then they are aligned in the GRID domain. If this is
      not possible, they are aligned in any suitable Frame.

      On exit, the current PGPLOT viewport corresponds to area occupied by
      the new DATA picture. The bounds of the PGPLOT window produce a
      world co-ordinate system within the viewport corresponding to the
      Base Frame in the returned Plot (i.e. millimetres from the bottom left
      corner of the view surface - NOT pixel coordinates). Note, this is
      different to the world co-ordinate system stored in the AGI database
      with the new DATA picture.

      If the returned Plot contains an AXIS Frame in which the axes are
      scaled and shifted versions of the axes of the AGI world co-ordinate
      Frame (specified by argument DOMAIN), then a TRANSFORM structure is
      stored with the new DATA picture which defines AGI Data co-ordinates.
      This is purely for the benefit of non-AST based applications which
      may use AGI Data co-ordinates (AST-based applications should always
      use the Plot stored with the picture in preference to the TRANSFORM
      structure stored in the AGI database).

      Various environment parameters are used to obtain options, etc. The
      names of these parameters are hard-wired into this subroutine in
      order to ensure conformity between application.
   }
   \sstinvocation{
      CALL KPG1\_PLOT( IWCS, STAT, APP, DATREF, MARGIN, NP, PNAME, PSIDE,
                      PSIZE, ASPECT, DOMAIN, BOX, IPICD, IPICF, IPIC,
                      IPLOT, NFRM, ALIGN, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         An AST pointer to a FrameSet. This may be AST\_\_NULL. The Current
         and Base Frames are unchanged on exit.
      }
      \sstsubsection{
         STAT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Determines whether or not the new DATA picture should be aligned
         with an existing DATA picture.
         {\tt '}NEW{\tt '}: no attempt is made to align the new DATA picture with an
                existing DATA picture, even if the CLEAR parameter is
                given a FALSE value.
         {\tt '}OLD{\tt '}: the new DATA picture is always aligned with an existing
                DATA picture. The CLEAR parameter is not accessed (it is
                assumed to have a FALSE value) and an error is reported
                if no DATA picture is available.
         {\tt '}UNKNOWN{\tt '}: If CLEAR is given a FALSE value then the new DATA
                picture is aligned with any existing DATA picture, but no
                error is reported if no DATA picture exists.
      }
      \sstsubsection{
         APP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the calling application, in the form
         $<$package$>$\_$<$application$>$ (eg {\tt "}KAPPA\_DISPLAY{\tt "}, {\tt "}POLPACK\_POLPLOT{\tt "},
         etc). The supplied string is stored as a comment with all new AGI
         pictures.
      }
      \sstsubsection{
         DATREF = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A string describing the source of the data being displayed,
         which will be stored in the AGI database with the new DATA
         picture. It is ignore if blank.
      }
      \sstsubsection{
         MARGIN( 4 ) = REAL (Given)
      }{
         The width of the borders to leave round the new DATA picture, given
         as fractions of the corresponding dimension of the DATA picture.
         These should be supplied in the order bottom, right, top, left.
      }
      \sstsubsection{
         NP = INTEGER (Given)
      }{
         The number of extra pictures to be included in the FRAME pictures
         (the DATA picture itself is not included in this list). Margins are
         left round the DATA picture with widths given by MARGIN. Any extra
         pictures are placed outside these margins, in positions described by
         PSIDE and PSIZE.
      }
      \sstsubsection{
         PNAME( NP ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The names to store in the AGI database with the NP extra pictures.
      }
      \sstsubsection{
         PSIDE( NP ) = CHARACTER $*$ 1 (Given)
      }{
         Each element of this array should be one of L, R, T or B. It
         indicates which side of the FRAME picture an extra picture is to be
         placed. For Left and Right, the extra picture occupies the full
         height of the DATA picture, margins, and any previously created
         extra pictures. The picture is placed at the far Left or Right of
         all previously created pictures. For Top or Bottom, the extra picture
         occupies the full width of the DATA picture, margins, and any
         previously created extra pictures. The picture is placed at the top or
         bottom of all previously created pictures. Ignored if NP is zero.
      }
      \sstsubsection{
         PSIZE( NP ) = REAL (Given)
      }{
         The size of each extra picture. For Left and Right pictures, this is
         the width of the picture, and the value is given as a fraction
         of the width of the DATA picture. For Top and Bottom pictures, it is
         the height of the picture, and it is given as a fraction of the
         height of the DATA picture. Ignored if NP is zero.
      }
      \sstsubsection{
         ASPECT = REAL (Given)
      }{
         The aspect ratio for the DATA picture. This is the height of the
         DATA picture (in millimetres)  divided by the width of the DATA
         picture (also in millimetres). The new DATA picture is created with
         this aspect ratio unless the FILL parameter is given a TRUE value,
         in which case the aspect ratio is adjusted to get the largest DATA
         picture which can be created within the current picture. If a value
         of zero is supplied, then the largest DATA picture is used
         irrespective of FILL (which is then not accessed).
      }
      \sstsubsection{
         DOMAIN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The Domain name corresponding to the AGI world co-ordinates. If a
         blank value is supplied then {\tt "}AGI\_WORLD{\tt "} will be used.
      }
      \sstsubsection{
         BOX( 4 ) = DOUBLE PRECISION (Given)
      }{
         The coordinates to be assigned to the bottom left, and top right
         corners of the DATA picture in the AGI database (the coordinate
         system in defined by argument DOMAIN). Only used if the new DATA
         picture is NOT being aligned with an existing DATA picture. Supplied
         in the order XLEFT, YBOTTOM, XRIGHT, YTOP. Note, the supplied
         bounds are stored in the AGI database, but do not effect the PGPLOT
         window on exit, which always has a world co-ordinate system of
         millimetres from the bottom left corner of the view surface. If
         the supplied box has zero area, then world coordinates for the
         DATA picture in the AGI database will be centimetres from the
         bottom left corner of the DATA picture.
      }
      \sstsubsection{
         IPICD = INTEGER (Returned)
      }{
         An AGI identifier for the new DATA picture.
      }
      \sstsubsection{
         IPICF = INTEGER (Returned)
      }{
         An AGI identifier for the new FRAME picture. World coordinate system
         is inherited from the current picture on entry. If no FRAME picture
         is created then an identifier for the current picture on entry is
         returned.
      }
      \sstsubsection{
         IPIC( NP ) = INTEGER (Returned)
      }{
         An array of AGI identifiers corresponding to the extra pictures
         requested in ZSIDE and PSIZE. The world coordinate system for each
         picture is inherited from the FRAME picture. The actual size of a
         picture may be less than the requested size if there is insufficient
         room left in the FRAME picture to give it its requested size.
         Identifiers for pictures which would have zero size (i.e. fall
         completely outside the FRAME picture) are returned equal to -1, but
         no error is reported.
      }
      \sstsubsection{
         IPLOT = INTEGER (Returned)
      }{
         An AST pointer to the new Plot. Returned equal to AST\_\_NULL if
         an error occurs.
      }
      \sstsubsection{
         NFRM = INTEGER (Returned)
      }{
         A  Frame with index I in the supplied FrameSet (IWCS) will have index
         ( I $+$ NFRM ) in the returned Plot (IPLOT). Returned equal to zero
         if an error occurs.
      }
      \sstsubsection{
         ALIGN = LOGICAL (Returned)
      }{
         Was the new DATA picture aligned with an existing DATA picture?
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Picture identifiers are returned equal to -1 if an error occurs,
         or if any pictures cannot be created.

         \sstitem
         Close down AGI and PGPLOT using:
               CALL KPG1\_PGCLS( {\tt '}DEVICE{\tt '}, .FALSE., STATUS )
      }
   }
   \sstdiytopic{
      Parameters
   }{
      CLEAR = \_LOGICAL (Read)
         TRUE if the graphics device is to be cleared on opening. See
         argument STAT.
      DEVICE = DEVICE (Read)
         The plotting device.
      FILL = \_LOGICAL (Read)
         TRUE if the supplied aspect ratio is to be ignored, creating the
         largest possible DATA picture within the current picture.  When
         FILL is FALSE, the DATA picture is created with the supplied
         aspect ratio. Only used when creating a new DATA picture.
      STYLE = GROUP (Read)
         A description of the plotting style required. This the name of a
         text file containing an AST attribute setting on each line, of
         form {\tt "}name=value{\tt "}, where {\tt "}name{\tt "} is an AST Plot attribute name
         (or synonym recognised by this application - see KPG1\_ASPSY), and
         {\tt "}value{\tt "} is the value to assign to the attribute.
   }
}
\sstroutine{
   KPG1\_PLOTN
}{
   Create a new DATA picture and ensure there is an AST Plot for it
}{
   \sstdescription{
      This routine createa an AST Plot describing a given DATA picture.
      If a FrameSet is supplied (IWCS), then it is merged with the
      Plot. An error is reported if the FrameSet and Plot cannot be
      aligned.

      On exit, the current PGPLOT viewport corresponds to area occupied by
      the DATA picture. The bounds of the PGPLOT window produce a world
      co-ordinate system within the viewport corresponding to the Base
      Frame in the returned Plot (i.e. millimetres from the bottom left
      corner of the view surface - NOT pixel coordinates). Note, this is
      different to the world co-ordinate system stored in the AGI database
      with the DATA picture.
   }
   \sstinvocation{
      CALL KPG1\_PLOTN( IWCS, DOMAIN, IPICD, IPLOT, NFRM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         An AST pointer to a FrameSet. This may be AST\_\_NULL. The Current
         and Base Frames are unchanged on exit.
      }
      \sstsubsection{
         DOMAIN = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The Domain in which AGI world co-ordinates within the specified
         DATA picture live. Alignment of the Plot and FrameSet will be
         attampted in this Domain if it is not possible in the Current
         Frame of the FrameSet.
      }
      \sstsubsection{
         IPICD = INTEGER (Given)
      }{
         An AGI identifier for the DATA picture.
      }
      \sstsubsection{
         QUIET = LOGICAL (Given)
      }{
         Suppress message identifying the Domain in which alignment occurs?
      }
      \sstsubsection{
         IPLOT = INTEGER (Returned)
      }{
         An AST pointer to the new Plot. Returned equal to AST\_\_NULL if
         an error occurs.
      }
      \sstsubsection{
         NFRM = INTEGER (Returned)
      }{
         A  Frame with index I in the supplied FrameSet (IWCS) will have index
         ( I $+$ NFRM ) in the returned Plot (IPLOT). Returned equal to zero
         if an error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_PLOTP
}{
   Create a new DATA picture, with optionally ancillary pictures
}{
   \sstdescription{
      This routine createa a new DATA picture, together with optional
      ancillary pictures around the DATA picture. The new DATA picture
      can be aligned with an existing DATA picture. A FRAME picture
      enclosing the DATA picture and any ancillary pictures is created
      if any ancillary pictures or non-zero margins were requested.

      On exit, the current PGPLOT viewport corresponds to area occupied
      by the new DATA picture. The bounds of the PGPLOT window produce a
      world co-ordinate system within the viewport corresponding to
      millimetres from the bottom left corner of the view surface. Note,
      this is different to the world co-ordinate system stored in the AGI
      database with the new DATA picture.

      Various environment parameters are used to obtain options, etc. The
      names of these parameters are hard-wired into this subroutine in
      order to ensure conformity between application.
   }
   \sstinvocation{
      CALL KPG1\_PLOTP( IPICD, APP, MARGIN, NP, PNAME, PSIDE, PSIZE,
                       ASPECT, BOX, IPICD0, IPICF, IPIC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPICD = INTEGER (Given)
      }{
         The AGI identifier for an existing DATA picture. If this is
         supplied equal to -1, the size and extent of the new DATA picture
         are determined by BOX. Otherwise, the size and extent of the new
         DATA picture are set equal to the existing DATA picture.
      }
      \sstsubsection{
         APP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the calling application in the form
         $<$package$>$\_$<$application$>$ (eg {\tt "}KAPPA\_DISPLAY{\tt "}).
      }
      \sstsubsection{
         MARGIN( 4 ) = REAL (Given)
      }{
         The width of the borders to leave round the new DATA picture, given
         as fractions of the corresponding dimension of the DATA picture.
         These should be supplied in the order bottom, right, top, left.
      }
      \sstsubsection{
         NP = INTEGER (Given)
      }{
         The number of extra pictures to be included in the FRAME pictures
         (the DATA picture itself is not included in this list). Margins are
         left round the DATA picture with widths given by MARGIN. Any extra
         pictures are placed outside these margins, in positions described by
         PSIDE and PSIZE.
      }
      \sstsubsection{
         PNAME( NP ) = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The names to store in the AGI database with the NP extra pictures.
      }
      \sstsubsection{
         PSIDE( NP ) = CHARACTER $*$ 1 (Given)
      }{
         Each element of this array should be one of L, R, T or B. It
         indicates which side of the FRAME picture an extra picture is to be
         placed. For Left and Right, the extra picture occupies the full
         height of the DATA picture, margins, and any previously created
         extra pictures. The picture is placed at the far Left or Right of
         all previously created pictures. For Top or Bottom, the extra picture
         occupies the full width of the DATA picture, margins, and any
         previously created extra pictures. The picture is placed at the top or
         bottom of all previously created pictures. Ignored if NP is zero.
      }
      \sstsubsection{
         PSIZE( NP ) = REAL (Given)
      }{
         The size of each extra picture. For Left and Right pictures, this is
         the width of the picture, and the value is given as a fraction
         of the width of the DATA picture. For Top and Bottom pictures, it is
         the height of the picture, and it is given as a fraction of the
         height of the DATA picture. Ignored if NP is zero.
      }
      \sstsubsection{
         ASPECT = REAL (Given)
      }{
         The aspect ratio for the DATA picture. This is the height of the
         DATA picture (in millimetres)  divided by the width of the DATA
         picture (also in millimetres). The new DATA picture is created with
         this aspect ratio unless the FILL parameter is given a TRUE value,
         in which case the aspect ratio is adjusted to get the largest DATA
         picture which can be created within the current picture. If a value
         of zero is supplied, then the largest DATA picture is used
         irrespective of FILL (which is then not accessed).
      }
      \sstsubsection{
         BOX( 4 ) = DOUBLE PRECISION (Given)
      }{
         The coordinates to be assigned to the bottom left, and top right
         corners of the DATA picture in the AGI database (the coordinate
         system in defined by argument DOMAIN). Only used if the new DATA
         picture is NOT being aligned with an existing DATA picture. Supplied
         in the order XLEFT, YBOTTOM, XRIGHT, YTOP. Note, the supplied
         bounds are stored in the AGI database, but do not effect the PGPLOT
         window on exit, which always has a world co-ordinate system of
         millimetres from the bottom left corner of the view surface. If
         the supplied box has zero area, then world coordinates for the
         DATA picture in the AGI database will be centimetres from the
         bottom left corner of the DATA picture.
      }
      \sstsubsection{
         IPICD0 = INTEGER (Returned)
      }{
         An AGI identifier for the new DATA picture.
      }
      \sstsubsection{
         IPICF = INTEGER (Returned)
      }{
         An AGI identifier for the new FRAME picture. World coordinate system
         is inherited from the current picture on entry. If no FRAME picture
         is created then an identifier for the current picture on entry is
         returned.
      }
      \sstsubsection{
         IPIC( NP ) = INTEGER (Returned)
      }{
         An array of AGI identifiers corresponding to the extra pictures
         requested in ZSIDE and PSIZE. The world coordinate system for each
         picture is inherited from the FRAME picture. The actual size of a
         picture may be less than the requested size if there is insufficient
         room left in the FRAME picture to give it its requested size.
         Identifiers for pictures which would have zero size (i.e. fall
         completely outside the FRAME picture) are returned equal to -1, but
         no error is reported.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         Picture identifiers are returned equal to -1 if the picture cannot
         be created (eg due to lack of room within the current picture).
      }
   }
   \sstdiytopic{
      Parameters
   }{
      FILL = \_LOGICAL (Read)
         TRUE if the supplied aspect ratio is to be ignored, creating the
         largest possible DATA picture within the current picture.  When
         FILL is FALSE, the DATA picture is created with the supplied
         aspect ratio. Only used when creating a new DATA picture.
   }
}
\sstroutine{
   KPG1\_PLOT
}{
   Save an AST Plot with an AGI DATA picture
}{
   \sstdescription{
      This routine saves a specified Plot and data reference in the AGI
      database with a specified DATA picture. A specified Frame can be
      made current before saving the Plot.

      If the supplied Plot contains a {\tt "}AGI Data{\tt "} Frame with the
      Domain given by DDOM in which the axes are scaled and shifted
      versions of the axes of the AGI world co-ordinate Frame
      (specified by argument WDOM), then a TRANSFORM structure defining
      AGI Data co-ordinates is stored with the DATA picture. This is purely
      for the benefit of non-AST based applications which may use AGI Data
      co-ordinates (AST-based applications should always use the Plot
      stored with the picture in preference to the TRANSFORM structure
      stored in the AGI database).
   }
   \sstinvocation{
      CALL KPG1\_PLOTS( IPLOT, IPICD, DATREF, ICURR, WDOM, DDOM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IPLOT = INTEGER (Given)
      }{
         An AST pointer to the Plot. The current Frame is unchanged on
         exit (even if a Frame is specified using ICURR).
      }
      \sstsubsection{
         IPICD = INTEGER (Given)
      }{
         An AGI identifier for the DATA picture.
      }
      \sstsubsection{
         DATREF = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A data reference to store with the picture.
      }
      \sstsubsection{
         ICURR = INTEGER (Returned)
      }{
         The index of a Frame to make current before storing the Plot. The
         supplied current Frame is used if ICURR is AST\_\_NOFRAME.
      }
      \sstsubsection{
         WDOM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The Domain name of the Frame correspondoing to AGI world
         co-ordinates.
      }
      \sstsubsection{
         DDOM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Domain name of the co-ordinate Frame within IPLOT corresponding
         to AGI data co-ordinates. {\tt "}AXIS{\tt "} is used if a blank value
         is supplied.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_PLPUT
}{
   Put a section of the current colour palette into the supplied array
}{
   \sstdescription{
      This routine puts a specified section of the colour palette for the
      currently opened graphics device into the supplied array. Other
      elements of the array are left unchanged.
   }
   \sstinvocation{
      CALL KPG1\_PLPUT( CI1, CI2, LBND, UBND, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         CI1 = INTEGER (Given)
      }{
         The lowest colour index to change in the array.
      }
      \sstsubsection{
         CI2 = INTEGER (Given)
      }{
         The highest colour index to change in the array.
      }
      \sstsubsection{
         LBND = INTEGER (Given)
      }{
         The lower bound of the second axis of ARRAY.
      }
      \sstsubsection{
         UBND = INTEGER (Given)
      }{
         The upper bound of the second axis of ARRAY.
      }
      \sstsubsection{
         ARRAY( 3, LBND : UBND ) = REAL (Given and Returned)
      }{
         The array to recieved the palette.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         A graphics device must previously have been opened using PGPLOT.
      }
   }
}
\sstroutine{
   KPG1\_PLSAV
}{
   Save the colour palette for the currently open graphics device
}{
   \sstdescription{
      This routine saves a section of the colour palette for the currently
      open graphics device in an HDS container file in the users ADAM
      directory. The file is called {\tt "}kappa\_palette.sdf{\tt "} and contains
      palettes for different devices. Each palette is a \_REAL array of
      shape (3,n) where n is the number of colours in the palette. The
      first colour (i.e. the first element in the array) is the background
      colour and is refered to as colour index zero. Therefore the highest
      colour index in the array is (n-1). Each array has a name which
      identifies the graphics device to which it refers.

      If a palette already exists for the device in the HDS container file,
      then the values stored in the HDS palette for the range of colour
      indices specified by CI1 and CI2 are modified to reflect the current
      colour table, and values in the HDS palette for other colour
      indices are left unchanged. If no HDS palette already exists, then an
      entire palette array is created and initally filled with values of
      \sstitemlist{

         \sstitem
         1. These indicate that no value has yet been specified for the
         colour index, and allows the default value to be used. This default
         may depend on the graphics device. For instance, the default for
         pen 1 will be white on an Xwindow but black on a printer.
      }
   }
   \sstinvocation{
      CALL KPG1\_PLSAV( CI1, CI2, RESET, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         CI1 = INTEGER (Given)
      }{
         The lowest colour index to save. Greater than or equal to zero.
         Zero is the background colour.
      }
      \sstsubsection{
         CI2 = INTEGER (Given)
      }{
         The highest colour index to save. If a value less than CI1 is given,
         then the highest available colour index is used.
      }
      \sstsubsection{
         RESET = LOGICAL (Given)
      }{
         Should all pens outside the range given by CI1 and CI2 be reset to
         their default (unspecified) values in the HDS palette? If not, their
         current values are retained.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The HDS container file is created if it does not already exist.

         \sstitem
         A graphics device must previously have been opened using SGS/GKS.
      }
   }
}
\sstroutine{
   KPG1\_PLTLN
}{
   Produces a graphical representation of a set of points in 2-D
}{
   \sstdescription{
      This routine produces a graphical representation of a set of points
      in 2-D space (e.g. a data value and a position, or two data values).
      Errors in both data values may be represented by error bars. No
      annotated asxes are drawn. The calling routine should do this if
      required by passing the supplied Plot (IPLOT) to routine KPG1\_ASGRD.

      PGPLOT should be active, and the viewport should correspond to the
      DATA picture in which the plot is to be drawn. PGPLOT world co-ordinates
      within the viewport should be GRAPHICS co-ordinates (millimetres from the
      bottom left corner of the view surface).

      The Plotting style is accessed using the environment parameter
      specified by PARAM, and may include the following synonyms for graphical
      elements:
         {\tt "}Err(Bars){\tt "} - Specifies colour, etc for error bars. Size(errbars)
                       scales the size of the serifs used if ERSHAP=1 (i.e.
                       a size value of 1.0 produces a default size).
         {\tt "}Sym(bols){\tt "} - Specifies colour, etc for markers (used in modes 3
                       and 5).
         {\tt "}Lin(es){\tt "} - Specifies colour, etc for lines (used in modes 1, 2,
                     4 and 5).
   }
   \sstinvocation{
      CALL KPG1\_PLTLN( N, ILO, IHI, X, Y, XERROR, YERROR, XBAR, YBAR,
                       XSTEP, PARAM, IPLOT, MODE, MTYPE, ERSHAP, FREQ,
                       APP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of points to be plotted.
      }
      \sstsubsection{
         ILO = INTEGER (Given)
      }{
         The index of the first grid point to be used.
      }
      \sstsubsection{
         IHI = INTEGER (Given)
      }{
         The index of the last grid point to be used.
      }
      \sstsubsection{
         X( N ) = DOUBLE PRECISION (Given)
      }{
         The X value at each point, in PGPLOT world co-ordinate (i.e.
         millimetres from the bottom left corner of the view surface).
      }
      \sstsubsection{
         Y( N ) = DOUBLE PRECISION (Given)
      }{
         The Y value at each point, in PGPLOT world co-ordinate (i.e.
         millimetres from the bottom left corner of the view surface).
      }
      \sstsubsection{
         XERROR = LOGICAL (Given)
      }{
         Display X error bars?
      }
      \sstsubsection{
         YERROR = LOGICAL (Given)
      }{
         Display Y error bars?
      }
      \sstsubsection{
         XBAR( N, 2 ) = DOUBLE PRECISION (Given)
      }{
         Row 1 contains the lower limit and row 2 contains the upper limit
         for each horizontal error bar, in PGPLOT world co-ordinate (i.e.
         millimetres from the bottom left corner of the view surface). Only
         accessed if XERROR is .TRUE.
      }
      \sstsubsection{
         YBAR( N, 2 ) = DOUBLE PRECISION (Given)
      }{
         Row 1 contains the lower limit and row 2 contains the upper limit
         for each vertical error bar, in PGPLOT world co-ordinate (i.e.
         millimetres from the bottom left corner of the view surface). Only
         accessed if YERROR is .TRUE.
      }
      \sstsubsection{
         XSTEP( N, 2 ) = DOUBLE PRECISION (Given)
      }{
         Row 1 contains the lower limit and row 2 contains the upper limit
         for each horizontal step, in PGPLOT world co-ordinate (i.e.
         millimetres from the bottom left corner of the view surface). Only
         accessed if MODE is 4.
      }
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the style parameter to be used when obtaining the
         plotting style.
      }
      \sstsubsection{
         IPLOT = INTEGER (Given)
      }{
         An AST Plot which can be used to do the drawing. The Base Frame
         should be GRAPHICS co-ordinates (millimetres from the bottom
         left corner of the PGPLOT view surface). The Current Frame should
         be the Frame in which annotation is required.
      }
      \sstsubsection{
         MODE = INTEGER (Given)
      }{
         Determines the way in which the data points are represented:
            1 - A {\tt "}staircase{\tt "} histogram, in which each horizontal line is
                centred on the X position.
            2 - The points are joined by straight lines.
            3 - A marker is placed at each point (see MTYPE).
            4 - Mark each point with a horizontal line of width given by
                XW.
            5 - A {\tt "}chain{\tt "} in which each point is marker by a marker and also
                join by straight lines to its neighbouring points.
      }
      \sstsubsection{
         MTYPE = INTEGER (Given)
      }{
         The PGPLOT marker type to use if MODE is 3 or 5.
      }
      \sstsubsection{
         ERSHAP = INTEGER (Given)
      }{
         Determines the way in which error bars are drawn:
            1 - X and Y errors are represented by horizontal and vertical
                lines respectively. Serifs are drawn at the ends of each
                line. The size of these sreifs is controlled by the
                size(errbar) plotting attribute.
            2 - A cross is drawn joining the corners of the box
                encompassing the X and Y errors.
            3 - A Diamond is drawn joining the ends of the horizontal and
                vertical error bars which would have been drawn if ERSHAP
                had been 1.
         These will all produce the same result (i.e. a single straight
         line) if errors are available only on one axis (see XERROR and
         YERROR). Not accessed if XERROR and YERROR are both .FALSE.
      }
      \sstsubsection{
         FREQ = INTEGER (Given)
      }{
         The frequency at which errors are to be plotted. A value of 1
         means {\tt "}plot errors for every point{\tt "}, 2 means {\tt "}plot errors for
         every second point{\tt "}, etc. Not accessed if XERROR and YERROR are
         both .FALSE.
      }
      \sstsubsection{
         APP = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the calling application in the form
         $<$package$>$\_$<$application$>$ (eg {\tt "}KAPPA\_DISPLAY{\tt "}).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_POISx
}{
   Takes values and returns them with Poisson noise added
}{
   \sstdescription{
      This routine adds or subtracts pseudo-random Poissonian (shot)
      noise to a series of values.  It uses a Box-Mueller algorithm to
      generate a fairly good normal distribution.
   }
   \sstinvocation{
      CALL KPG1\_POISx( EL, VALUES, SEED, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of values to which to add Poisson noise.
      }
      \sstsubsection{
         VALUES( EL )  =  ? (Given and Returned)
      }{
         On input these are the value to which noise is to be applied.
         On return the values have the noise applied.
      }
      \sstsubsection{
         SEED  =  REAL (Given \& Returned)
      }{
         The seed for random number generator; updated by the
         random-number generator.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         array supplied to the routine must have the data type specified.

         \sstitem
         There is no checking for overflows.

         \sstitem
         Bad values remain bad in the returned array.
      }
   }
}
\sstroutine{
   KPG1\_POISx
}{
   Takes values and returns them with Poisson noise added
}{
   \sstdescription{
      This routine adds or subtracts pseudo-random Poissonian (shot)
      noise to a series of values.  It uses a Box-Mueller algorithm to
      generate a fairly good normal distribution.
   }
   \sstinvocation{
      CALL KPG1\_POISx( EL, VALUES, SEED, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of values to which to add Poisson noise.
      }
      \sstsubsection{
         VALUES( EL )  =  ? (Given and Returned)
      }{
         On input these are the value to which noise is to be applied.
         On return the values have the noise applied.
      }
      \sstsubsection{
         SEED  =  REAL (Given \& Returned)
      }{
         The seed for random number generator; updated by the
         random-number generator.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         array supplied to the routine must have the data type specified.

         \sstitem
         There is no checking for overflows.

         \sstitem
         Bad values remain bad in the returned array.
      }
   }
}
\sstroutine{
   KPG1\_POISx
}{
   Takes values and returns them with Poisson noise added
}{
   \sstdescription{
      This routine adds or subtracts pseudo-random Poissonian (shot)
      noise to a series of values.  It uses a Box-Mueller algorithm to
      generate a fairly good normal distribution.
   }
   \sstinvocation{
      CALL KPG1\_POISx( EL, VALUES, SEED, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of values to which to add Poisson noise.
      }
      \sstsubsection{
         VALUES( EL )  =  ? (Given and Returned)
      }{
         On input these are the value to which noise is to be applied.
         On return the values have the noise applied.
      }
      \sstsubsection{
         SEED  =  REAL (Given \& Returned)
      }{
         The seed for random number generator; updated by the
         random-number generator.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         array supplied to the routine must have the data type specified.

         \sstitem
         There is no checking for overflows.

         \sstitem
         Bad values remain bad in the returned array.
      }
   }
}
\sstroutine{
   KPG1\_POISx
}{
   Takes values and returns them with Poisson noise added
}{
   \sstdescription{
      This routine adds or subtracts pseudo-random Poissonian (shot)
      noise to a series of values.  It uses a Box-Mueller algorithm to
      generate a fairly good normal distribution.
   }
   \sstinvocation{
      CALL KPG1\_POISx( EL, VALUES, SEED, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of values to which to add Poisson noise.
      }
      \sstsubsection{
         VALUES( EL )  =  ? (Given and Returned)
      }{
         On input these are the value to which noise is to be applied.
         On return the values have the noise applied.
      }
      \sstsubsection{
         SEED  =  REAL (Given \& Returned)
      }{
         The seed for random number generator; updated by the
         random-number generator.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         array supplied to the routine must have the data type specified.

         \sstitem
         There is no checking for overflows.

         \sstitem
         Bad values remain bad in the returned array.
      }
   }
}
\sstroutine{
   KPG1\_POISx
}{
   Takes values and returns them with Poisson noise added
}{
   \sstdescription{
      This routine adds or subtracts pseudo-random Poissonian (shot)
      noise to a series of values.  It uses a Box-Mueller algorithm to
      generate a fairly good normal distribution.
   }
   \sstinvocation{
      CALL KPG1\_POISx( EL, VALUES, SEED, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of values to which to add Poisson noise.
      }
      \sstsubsection{
         VALUES( EL )  =  ? (Given and Returned)
      }{
         On input these are the value to which noise is to be applied.
         On return the values have the noise applied.
      }
      \sstsubsection{
         SEED  =  REAL (Given \& Returned)
      }{
         The seed for random number generator; updated by the
         random-number generator.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         array supplied to the routine must have the data type specified.

         \sstitem
         There is no checking for overflows.

         \sstitem
         Bad values remain bad in the returned array.
      }
   }
}
\sstroutine{
   KPG1\_POISx
}{
   Takes values and returns them with Poisson noise added
}{
   \sstdescription{
      This routine adds or subtracts pseudo-random Poissonian (shot)
      noise to a series of values.  It uses a Box-Mueller algorithm to
      generate a fairly good normal distribution.
   }
   \sstinvocation{
      CALL KPG1\_POISx( EL, VALUES, SEED, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of values to which to add Poisson noise.
      }
      \sstsubsection{
         VALUES( EL )  =  ? (Given and Returned)
      }{
         On input these are the value to which noise is to be applied.
         On return the values have the noise applied.
      }
      \sstsubsection{
         SEED  =  REAL (Given \& Returned)
      }{
         The seed for random number generator; updated by the
         random-number generator.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         array supplied to the routine must have the data type specified.

         \sstitem
         There is no checking for overflows.

         \sstitem
         Bad values remain bad in the returned array.
      }
   }
}
\sstroutine{
   KPG1\_POISx
}{
   Takes values and returns them with Poisson noise added
}{
   \sstdescription{
      This routine adds or subtracts pseudo-random Poissonian (shot)
      noise to a series of values.  It uses a Box-Mueller algorithm to
      generate a fairly good normal distribution.
   }
   \sstinvocation{
      CALL KPG1\_POISx( EL, VALUES, SEED, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of values to which to add Poisson noise.
      }
      \sstsubsection{
         VALUES( EL )  =  ? (Given and Returned)
      }{
         On input these are the value to which noise is to be applied.
         On return the values have the noise applied.
      }
      \sstsubsection{
         SEED  =  REAL (Given \& Returned)
      }{
         The seed for random number generator; updated by the
         random-number generator.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         array supplied to the routine must have the data type specified.

         \sstitem
         There is no checking for overflows.

         \sstitem
         Bad values remain bad in the returned array.
      }
   }
}
\sstroutine{
   KPG1\_POWD
}{
   Raise each element of a vectorised array to a specified power
}{
   \sstdescription{
      The routine raises each element of a vectorised array to a specified
      power. Any associated variance values are also modified appropriately.
      For general non-integer powers the result is calculated as
      EXP(power$*$LOG(data)). This enables bad output pixels to be detected by
      checking the magnitude of LOG(data). For integer powers, the result
      is calcualted using the Fortran {\tt "}$*$$*${\tt "} operator, which is more
      efficient.
   }
   \sstinvocation{
      CALL KPG1\_POWD( BAD, VAR, POWER, EL, DIN, VIN, DOUT, VOUT, NBAD,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input arrays.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         Have associated variances been supplied?
      }
      \sstsubsection{
         POWER = DOUBLE PRECISION (Given)
      }{
         The required power.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         DIN( EL ) = DOUBLE PRECISION (Given)
      }{
         Input data array.
      }
      \sstsubsection{
         VIN( EL ) = DOUBLE PRECISION (Given)
      }{
         Input variance array. Only accessed if VAR is .TRUE.
      }
      \sstsubsection{
         DOUT( EL ) = DOUBLE PRECISION (Given)
      }{
         Output data array.
      }
      \sstsubsection{
         VOUT( EL ) = DOUBLE PRECISION (Given)
      }{
         Output variance array. Only accessed if VAR is .TRUE.
      }
      \sstsubsection{
         NBAD( 2 ) = INTEGER (Returned)
      }{
         Element 1 has the number of bad values stored in DOUT, and element
         2 has the number of bad values stored in VOUT.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_POWR
}{
   Raise each element of a vectorised array to a specified power
}{
   \sstdescription{
      The routine raises each element of a vectorised array to a specified
      power. Any associated variance values are also modified appropriately.
      For general non-integer powers the result is calculated as
      EXP(power$*$LOG(data)). This enables bad output pixels to be detected by
      checking the magnitude of LOG(data). For integer powers, the result
      is calcualted using the Fortran {\tt "}$*$$*${\tt "} operator, which is more
      efficient.
   }
   \sstinvocation{
      CALL KPG1\_POWR( BAD, VAR, POWER, EL, DIN, VIN, DOUT, VOUT, NBAD,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input arrays.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         Have associated variances been supplied?
      }
      \sstsubsection{
         POWER = DOUBLE PRECISION (Given)
      }{
         The required power.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         DIN( EL ) = REAL (Given)
      }{
         Input data array.
      }
      \sstsubsection{
         VIN( EL ) = REAL (Given)
      }{
         Input variance array. Only accessed if VAR is .TRUE.
      }
      \sstsubsection{
         DOUT( EL ) = REAL (Given)
      }{
         Output data array.
      }
      \sstsubsection{
         VOUT( EL ) = REAL (Given)
      }{
         Output variance array. Only accessed if VAR is .TRUE.
      }
      \sstsubsection{
         NBAD( 2 ) = INTEGER (Returned)
      }{
         Element 1 has the number of bad values stored in DOUT, and element
         2 has the number of bad values stored in VOUT.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_PQVID
}{
   Tests whether the current graphics device has suitable
   image-display characteristics
}{
   \sstdescription{
      This routine determines whether the current graphics device is an
      image display with suitable characteristics.  The checks are
      performed in the following order: the class of the device is
      checked against a supplied list of acceptable classes; the
      presence of certain attributes, given in a supplied list are
      checked in the order colour, input and open with reset; and
      finally a minimum number of colour indices must be exceeded.
   }
   \sstinvocation{
      CALL KPG1\_PQVID( PNDEV, CLASS, CRITER, MININT, UP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNDEV = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The ADAM parameter associated with the current graphics
         workstation.  It is used to generate error messages.
      }
      \sstsubsection{
         CLASS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A list of acceptable workstation classes as defined by GNS,
         each separated by a comma.  See SUN/57 for a list. Note, as
         GNS does not yet support PGPLOT, no checks are mode on GNS
         class when using PGPLOT. Class checks are ignored if a blank
         string is supplied.
      }
      \sstsubsection{
         CRITER = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A list of criteria that the workstation must pass in order to
         be an acceptable image display.  The options are: {\tt '}COLOUR{\tt '} if
         colour must be available, {\tt '}CURSOR{\tt '} if a cursor must be
         available on the workstation. Non-standard criteria will be
         ignored.
      }
      \sstsubsection{
         MININT = INTEGER (Given)
      }{
         Minimum number of intensities or colour indices required.  The
         routine ensures that there are at least the specified number.
      }
      \sstsubsection{
         UP = INTEGER (Returned)
      }{
         The highest available colour index available.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         A PGPLOT workstation must be open.
      }
   }
}
\sstroutine{
   KPG1\_PRCUR
}{
   Prepares the graphics cursor to select points
}{
   \sstdescription{
      This determines whether a cursor with a suitable number of choices
      is available on the current graphics device.  Messages are given
      describing which buttons to press depending on the device and
      number of choices required.  Different messages are reported for
      a terminal and an image display.  A workstation when more than one
      choice is needed, is classified as a terminal by this routine; and
      it is classified as an image-display when only one choice is
      needed.  In the former case pressing the left-hand and right-hasnd
      mouse buttons will still give the first choice and the exit
      respectively.

      The messages has parameters CHOICETERMn or CHOICEIDn, where n is
      number of the message starting from 1.
   }
   \sstinvocation{
      CALL KPG1\_PRCUR( MNCHOI, TERMES, NTERMS, IMGMES, NIMGMS, BUTTNS,
                       CURSOR, IMGDIS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         MNCHOI = INTEGER (Given)
      }{
         The minimum number of choices required by the calling
         application.  It must be positive.
      }
      \sstsubsection{
         TERMES( NTERMS ) = CHARACTER (Given)
      }{
         Description of which terminal buttons to press to obtain the
         various choices, to be reported to the user if the device is
         a terminal or a workstation but MNCHOI is greater than 2.
      }
      \sstsubsection{
         NTERMS = INTEGER (Given)
      }{
         Number of lines describing the action of the terminal choices.
      }
      \sstsubsection{
         IMGMES( NIMGMS ) = CHARACTER (Given)
      }{
         Description of the action of the mouse or trackerball buttons
         to be reported to the user if the device is nominally an image
         display or workstation
      }
      \sstsubsection{
         NIMGMS = INTEGER (Given)
      }{
         Number of lines describing the action of the image-display
         choices.
      }
      \sstsubsection{
         BUTTNS = CHARACTER (Given)
      }{
         The terminal buttons to be pressed to obtain the different
         choices, e.g. {\tt '}1A.{\tt '} would mean {\tt '}1{\tt '} would give the first
         choice, {\tt '}A{\tt '} would the second and {\tt '}.{\tt '} to exit.  A fullstop is
         the recommended Starlink method for terminating such an
         interaction.  The last character is assumed to be the exit
         choice in cases where this string is longer than the number of
         choices plus one (the exit).  There must be at least \%MNCHOI$+$1
         characters.  This string is ignored if the device is an image
         display, however for a workstation give at least one choice
         and the exit, e.g. {\tt '} .{\tt '}.
      }
      \sstsubsection{
         CURSOR = LOGICAL (Returned)
      }{
         If true there is a suitable cursor and number of choices.
      }
      \sstsubsection{
         IMGDIS = LOGICAL (Returned)
      }{
         If true the choice device is an image-display mouse or
         trackerball.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      A SGS (GKS) workstation must be active.
   }
}
\sstroutine{
   KPG1\_PRCVT
}{
   Convert an HDS primitive to a native data representation
}{
   \sstdescription{
      The routine converts a primitive HDS object so that it is stored
      using the appropriate native data representation provided by the
      host machine.
   }
   \sstinvocation{
      CALL KPG1\_PRCVT( LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER $*$ ( DAT\_\_SZLOC ) (Given and Returned)
      }{
         Locator for the object to be converted. This may be modified
         on exit (as the original object may have to be erased and
         re-created).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      This routine returns without action if the object supplied is not
      primitive, or if it does not need conversion (i.e. if it has
      already been converted or was created on the current machine). In
      this case the LOC argument will be returned unchanged.
   }
}
\sstroutine{
   KPG1\_PRNTH
}{
   Locates the outer-most pair of parenthesis in a string
}{
   \sstdescription{
      The routine returns the indices of the first opening parenthesis and
      the last closing parenthesis in the supplied string. Both are
      returned equal to zero if either parenthesis is not found.
   }
   \sstinvocation{
      CALL KPG1\_PRNTH( STRING, OP, CL STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STRING = CHARACTER $*$ ( $*$ ) (Given)
      }{
         String to be searched.
      }
      \sstsubsection{
         OP = INTEGER (Returned)
      }{
         Position within STRING at which the first occurence of {\tt "}({\tt "} is
         located.
      }
      \sstsubsection{
         CL = INTEGER (Returned)
      }{
         Position within STRING at which the last occurence of {\tt "}){\tt "} is
         located.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_PROWx
}{
   Put values into a row of a 2-dimensional array
}{
   \sstdescription{
      The routine enters values into a specified row of a 2-dimensional
      array, the values being supplied in a separate 1-dimensional array
      whose size matches the row size.
   }
   \sstinvocation{
      CALL KPG1\_PROWx( EL, ROW, IROW, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of elements in a single row of the 2-d array.
      }
      \sstsubsection{
         ROW( EL ) = ? (Given)
      }{
         Array of values to be inserted into the row.
      }
      \sstsubsection{
         IROW = INTEGER (Given)
      }{
         The row number in the 2-d array into which the values are to be
         inserted.
      }
      \sstsubsection{
         ARRAY( EL, $*$ ) = ? (Given and Returned)
      }{
         The 2-d array which is to recieve the new values. The declared
         second dimension size of this array must not be less than
         IROW. The values in other rows of this array are not altered.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type. Replace {\tt "}x{\tt "} in
         the routine name by B, UB, W, UW, I, R or D as appropriate. The
         data type of the ROW and ARRAY arrays should match the routine
         being used.
      }
   }
}
\sstroutine{
   KPG1\_PROWx
}{
   Put values into a row of a 2-dimensional array
}{
   \sstdescription{
      The routine enters values into a specified row of a 2-dimensional
      array, the values being supplied in a separate 1-dimensional array
      whose size matches the row size.
   }
   \sstinvocation{
      CALL KPG1\_PROWx( EL, ROW, IROW, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of elements in a single row of the 2-d array.
      }
      \sstsubsection{
         ROW( EL ) = ? (Given)
      }{
         Array of values to be inserted into the row.
      }
      \sstsubsection{
         IROW = INTEGER (Given)
      }{
         The row number in the 2-d array into which the values are to be
         inserted.
      }
      \sstsubsection{
         ARRAY( EL, $*$ ) = ? (Given and Returned)
      }{
         The 2-d array which is to recieve the new values. The declared
         second dimension size of this array must not be less than
         IROW. The values in other rows of this array are not altered.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type. Replace {\tt "}x{\tt "} in
         the routine name by B, UB, W, UW, I, R or D as appropriate. The
         data type of the ROW and ARRAY arrays should match the routine
         being used.
      }
   }
}
\sstroutine{
   KPG1\_PRSAx
}{
   Extracts a list of numerical values from a string
}{
   \sstdescription{
      A supplied string is search for words (separated by spaces, tabs
      or commas), which are extracted and converted to the required
      numerical data type.  The numerical values and their number are
      returned.
   }
   \sstinvocation{
      CALL KPG1\_PRSAD( BUFFER, MAXVAL, VALUES, NVAL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BUFFER = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The string containing a list of numerical values.
      }
      \sstsubsection{
         MAXVAL = INTEGER (Given)
      }{
         The maximum number of values that can be read from the buffer
         and stored.
      }
      \sstsubsection{
         VALUES( MAXVAL ) = ? (Returned)
      }{
         The numeric values extracted from the string.
      }
      \sstsubsection{
         NVAL = INTEGER (Returned)
      }{
         The actual number of values extracted from the string.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "}
            in the routine name by D, R, I, W, UW, B or UB as appropriate.
      }
   }
}
\sstroutine{
   KPG1\_PRSAx
}{
   Extracts a list of numerical values from a string
}{
   \sstdescription{
      A supplied string is search for words (separated by spaces, tabs
      or commas), which are extracted and converted to the required
      numerical data type.  The numerical values and their number are
      returned.
   }
   \sstinvocation{
      CALL KPG1\_PRSAI( BUFFER, MAXVAL, VALUES, NVAL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BUFFER = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The string containing a list of numerical values.
      }
      \sstsubsection{
         MAXVAL = INTEGER (Given)
      }{
         The maximum number of values that can be read from the buffer
         and stored.
      }
      \sstsubsection{
         VALUES( MAXVAL ) = ? (Returned)
      }{
         The numeric values extracted from the string.
      }
      \sstsubsection{
         NVAL = INTEGER (Returned)
      }{
         The actual number of values extracted from the string.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "}
            in the routine name by D, R, I, W, UW, B or UB as appropriate.
      }
   }
}
\sstroutine{
   KPG1\_PRSAx
}{
   Extracts a list of numerical values from a string
}{
   \sstdescription{
      A supplied string is search for words (separated by spaces, tabs
      or commas), which are extracted and converted to the required
      numerical data type.  The numerical values and their number are
      returned.
   }
   \sstinvocation{
      CALL KPG1\_PRSAR( BUFFER, MAXVAL, VALUES, NVAL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BUFFER = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The string containing a list of numerical values.
      }
      \sstsubsection{
         MAXVAL = INTEGER (Given)
      }{
         The maximum number of values that can be read from the buffer
         and stored.
      }
      \sstsubsection{
         VALUES( MAXVAL ) = ? (Returned)
      }{
         The numeric values extracted from the string.
      }
      \sstsubsection{
         NVAL = INTEGER (Returned)
      }{
         The actual number of values extracted from the string.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "}
            in the routine name by D, R, I, W, UW, B or UB as appropriate.
      }
   }
}
\sstroutine{
   KPG1\_PSEED
}{
   Set the PDA Random number seed
}{
   \sstdescription{
      This routine sets the seed for the PDA random number routines to a
      non-repeatable value, and must be called prior to using any PDA
      random number routine. The seed is only set once in each process,
      and is set to a number which combines the process id and the
      current time.

      The process id is included because the {\tt "}time{\tt "} system call
      (implemented by PSX\_TIME) returns the time in seconds. On modern
      machines it is possible for an application to be called several times
      each second, resulting in the same seed being used each time if the
      seed is based only on the time.
   }
   \sstinvocation{
      CALL KPG1\_PSEED( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_PSFSx
}{
   Finds the approximate size of a 2-dimensional PSF
}{
   \sstdescription{
      Marginal profiles are formed of the absolute PSF values along
      both axes.  For each axis the maximum and minimum values in the
      corresponding profile are found.  The first and last point at
      which each profile reaches a specified fraction of its total
      range is found, and the difference returned as the corresponding
      PSF size.  N.B., it is assumed that the input PSF contains no bad
      pixels.
   }
   \sstinvocation{
      CALL KPG1\_PSFSx( PSF, NPIX, NLIN, WORK, NPW, NLW, FRACT, ILEVEL,
                       XSIZE, YSIZE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PSF( NPIX, NLIN ) = ? (Given)
      }{
         The PSF image.
      }
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         Number of pixels per line in the PSF image.
      }
      \sstsubsection{
         NLIN = INTEGER (Given)
      }{
         Number of lines in the PSF image.
      }
      \sstsubsection{
         WORK( NPW, NLW ) = ? (Given)
      }{
         Work space.
      }
      \sstsubsection{
         NPW = INTEGER (Given)
      }{
         Number of elements per line in the work array.  This should be
         at least equal to the maximum of NPIX and NLIN.
      }
      \sstsubsection{
         NLW = INTEGER (Given)
      }{
         Number of lines in the work array.  This should be at least 2.
      }
      \sstsubsection{
         ILEVEL = INTEGER (Given)
      }{
         The user information level.  If ILEVEL is 2 or more, then the
         user is told what the calculated sizes are.
      }
      \sstsubsection{
         FRACT = REAL (Given)
      }{
         The fraction of the PSF peak amplitude at which the PSF size
         is determined.  It should be positive and less than 0.5.  If
         it is outside this range one sixteenth is used.
      }
      \sstsubsection{
         XSIZE = INTEGER (Returned)
      }{
         The width in x of the PSF, in units of pixels.
      }
      \sstsubsection{
         YSIZE = INTEGER (Returned)
      }{
         The width in y of the PSF, in units of lines.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for processing single- and double-precision
         arrays; replace {\tt "}x{\tt "} in the routine name by R or D as appropriate.
         The data type of the PSF and WORK arguments must match the
         routine used.
      }
   }
}
\sstroutine{
   KPG1\_PSFSx
}{
   Finds the approximate size of a 2-dimensional PSF
}{
   \sstdescription{
      Marginal profiles are formed of the absolute PSF values along
      both axes.  For each axis the maximum and minimum values in the
      corresponding profile are found.  The first and last point at
      which each profile reaches a specified fraction of its total
      range is found, and the difference returned as the corresponding
      PSF size.  N.B., it is assumed that the input PSF contains no bad
      pixels.
   }
   \sstinvocation{
      CALL KPG1\_PSFSx( PSF, NPIX, NLIN, WORK, NPW, NLW, FRACT, ILEVEL,
                       XSIZE, YSIZE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PSF( NPIX, NLIN ) = ? (Given)
      }{
         The PSF image.
      }
      \sstsubsection{
         NPIX = INTEGER (Given)
      }{
         Number of pixels per line in the PSF image.
      }
      \sstsubsection{
         NLIN = INTEGER (Given)
      }{
         Number of lines in the PSF image.
      }
      \sstsubsection{
         WORK( NPW, NLW ) = ? (Given)
      }{
         Work space.
      }
      \sstsubsection{
         NPW = INTEGER (Given)
      }{
         Number of elements per line in the work array.  This should be
         at least equal to the maximum of NPIX and NLIN.
      }
      \sstsubsection{
         NLW = INTEGER (Given)
      }{
         Number of lines in the work array.  This should be at least 2.
      }
      \sstsubsection{
         ILEVEL = INTEGER (Given)
      }{
         The user information level.  If ILEVEL is 2 or more, then the
         user is told what the calculated sizes are.
      }
      \sstsubsection{
         FRACT = REAL (Given)
      }{
         The fraction of the PSF peak amplitude at which the PSF size
         is determined.  It should be positive and less than 0.5.  If
         it is outside this range one sixteenth is used.
      }
      \sstsubsection{
         XSIZE = INTEGER (Returned)
      }{
         The width in x of the PSF, in units of pixels.
      }
      \sstsubsection{
         YSIZE = INTEGER (Returned)
      }{
         The width in y of the PSF, in units of lines.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for processing single- and double-precision
         arrays; replace {\tt "}x{\tt "} in the routine name by R or D as appropriate.
         The data type of the PSF and WORK arguments must match the
         routine used.
      }
   }
}
\sstroutine{
   KPG1\_PVERS
}{
   Parse a package version string
}{
   \sstdescription{
      This routine splits the supplied package version string (e.g.
      {\tt "}V0.13-6{\tt "}) into 3 integers corresponding to the major version
      number, minor version number and revision number. The leading {\tt "}V{\tt "}
      can be omitted, and trailing fields can be ommitted (they default
      to zero).
   }
   \sstinvocation{
      CALL KPG1\_PVERS( TEXT, MAJ, MIN, REV, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TEXT = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The version string. Blanks are removed and it is converted to
         upper case on exit.
      }
      \sstsubsection{
         MAJ = INTEGER (Returned)
      }{
         The major version number.
      }
      \sstsubsection{
         MIN = INTEGER (Returned)
      }{
         The minor version number.
      }
      \sstsubsection{
         REV = INTEGER (Returned)
      }{
         The revision number.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_PX2AX
}{
   Convert a pixel{\tt '}s indices into axis coordinates
}{
   \sstdescription{
      This routine converts the pixel indices of an NDF pixel into the
      axis coordinate values of the pixel{\tt '}s centre. If an axis
      coordinate system is not defined for the NDF, then the pixel
      coordinate system will be used instead.
   }
   \sstinvocation{
      CALL KPG1\_PX2AX( NDIM, PX, INDF, AX, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of NDF dimensions.
      }
      \sstsubsection{
         PX( NDIM ) = INTEGER (Given)
      }{
         Indices of the NDF{\tt '}s pixel.
      }
      \sstsubsection{
         INDF = INTEGER (Given)
      }{
         NDF identifier.
      }
      \sstsubsection{
         AX( NDIM ) = DOUBLE PRECISION (Returned)
      }{
         Axis coordinate values for the pixel{\tt '}s centre.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      This routine is simplified by handling only a single pixel. It
      will not be efficient enough to handle arrays of pixels.
   }
}
\sstroutine{
   KPG1\_PXDPx
}{
   Expands an n-dimensional array by pixel duplication
}{
   \sstdescription{
      This routine expands an input array by pixel duplication along
      each dimension.  The duplication factors may be different for
      each dimension.
   }
   \sstinvocation{
      CALL KPG1\_PXDPx( IDIMS, INARR, EXPAND, ODIMS, OUTARR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IDIMS( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The dimensions of the input array.  Unused dimensions
         up to NDF\_\_MXDIM should be set to one.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input data array that is to be enlarged by duplication.
      }
      \sstsubsection{
         EXPAND( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The linear expansion factor applied along each dimension.
         Factors for unused dimensions up to NDF\_\_MXDIM should be set
         to one.
      }
      \sstsubsection{
         ODIMS( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The dimensions of the expanded array.  Unused dimensions up to
         NDF\_\_MXDIM should be set to one.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Returned)
      }{
         The expanded array.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine works in n-D, where n is 1 to 7.  Even if the
         array has actually less dimensions there is negligible loss of
         efficiency to supply dummy (=1) higher dimensions.

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         base and paste arrays supplied to the routine must have the data
         type specified.
      }
   }
}
\sstroutine{
   KPG1\_PXDPx
}{
   Expands an n-dimensional array by pixel duplication
}{
   \sstdescription{
      This routine expands an input array by pixel duplication along
      each dimension.  The duplication factors may be different for
      each dimension.
   }
   \sstinvocation{
      CALL KPG1\_PXDPx( IDIMS, INARR, EXPAND, ODIMS, OUTARR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IDIMS( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The dimensions of the input array.  Unused dimensions
         up to NDF\_\_MXDIM should be set to one.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input data array that is to be enlarged by duplication.
      }
      \sstsubsection{
         EXPAND( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The linear expansion factor applied along each dimension.
         Factors for unused dimensions up to NDF\_\_MXDIM should be set
         to one.
      }
      \sstsubsection{
         ODIMS( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The dimensions of the expanded array.  Unused dimensions up to
         NDF\_\_MXDIM should be set to one.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Returned)
      }{
         The expanded array.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine works in n-D, where n is 1 to 7.  Even if the
         array has actually less dimensions there is negligible loss of
         efficiency to supply dummy (=1) higher dimensions.

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         base and paste arrays supplied to the routine must have the data
         type specified.
      }
   }
}
\sstroutine{
   KPG1\_PXDPx
}{
   Expands an n-dimensional array by pixel duplication
}{
   \sstdescription{
      This routine expands an input array by pixel duplication along
      each dimension.  The duplication factors may be different for
      each dimension.
   }
   \sstinvocation{
      CALL KPG1\_PXDPx( IDIMS, INARR, EXPAND, ODIMS, OUTARR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IDIMS( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The dimensions of the input array.  Unused dimensions
         up to NDF\_\_MXDIM should be set to one.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input data array that is to be enlarged by duplication.
      }
      \sstsubsection{
         EXPAND( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The linear expansion factor applied along each dimension.
         Factors for unused dimensions up to NDF\_\_MXDIM should be set
         to one.
      }
      \sstsubsection{
         ODIMS( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The dimensions of the expanded array.  Unused dimensions up to
         NDF\_\_MXDIM should be set to one.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Returned)
      }{
         The expanded array.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine works in n-D, where n is 1 to 7.  Even if the
         array has actually less dimensions there is negligible loss of
         efficiency to supply dummy (=1) higher dimensions.

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         base and paste arrays supplied to the routine must have the data
         type specified.
      }
   }
}
\sstroutine{
   KPG1\_PXDPx
}{
   Expands an n-dimensional array by pixel duplication
}{
   \sstdescription{
      This routine expands an input array by pixel duplication along
      each dimension.  The duplication factors may be different for
      each dimension.
   }
   \sstinvocation{
      CALL KPG1\_PXDPx( IDIMS, INARR, EXPAND, ODIMS, OUTARR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IDIMS( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The dimensions of the input array.  Unused dimensions
         up to NDF\_\_MXDIM should be set to one.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input data array that is to be enlarged by duplication.
      }
      \sstsubsection{
         EXPAND( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The linear expansion factor applied along each dimension.
         Factors for unused dimensions up to NDF\_\_MXDIM should be set
         to one.
      }
      \sstsubsection{
         ODIMS( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The dimensions of the expanded array.  Unused dimensions up to
         NDF\_\_MXDIM should be set to one.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Returned)
      }{
         The expanded array.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine works in n-D, where n is 1 to 7.  Even if the
         array has actually less dimensions there is negligible loss of
         efficiency to supply dummy (=1) higher dimensions.

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         base and paste arrays supplied to the routine must have the data
         type specified.
      }
   }
}
\sstroutine{
   KPG1\_PXDPx
}{
   Expands an n-dimensional array by pixel duplication
}{
   \sstdescription{
      This routine expands an input array by pixel duplication along
      each dimension.  The duplication factors may be different for
      each dimension.
   }
   \sstinvocation{
      CALL KPG1\_PXDPx( IDIMS, INARR, EXPAND, ODIMS, OUTARR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IDIMS( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The dimensions of the input array.  Unused dimensions
         up to NDF\_\_MXDIM should be set to one.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input data array that is to be enlarged by duplication.
      }
      \sstsubsection{
         EXPAND( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The linear expansion factor applied along each dimension.
         Factors for unused dimensions up to NDF\_\_MXDIM should be set
         to one.
      }
      \sstsubsection{
         ODIMS( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The dimensions of the expanded array.  Unused dimensions up to
         NDF\_\_MXDIM should be set to one.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Returned)
      }{
         The expanded array.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine works in n-D, where n is 1 to 7.  Even if the
         array has actually less dimensions there is negligible loss of
         efficiency to supply dummy (=1) higher dimensions.

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         base and paste arrays supplied to the routine must have the data
         type specified.
      }
   }
}
\sstroutine{
   KPG1\_PXDPx
}{
   Expands an n-dimensional array by pixel duplication
}{
   \sstdescription{
      This routine expands an input array by pixel duplication along
      each dimension.  The duplication factors may be different for
      each dimension.
   }
   \sstinvocation{
      CALL KPG1\_PXDPx( IDIMS, INARR, EXPAND, ODIMS, OUTARR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IDIMS( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The dimensions of the input array.  Unused dimensions
         up to NDF\_\_MXDIM should be set to one.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input data array that is to be enlarged by duplication.
      }
      \sstsubsection{
         EXPAND( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The linear expansion factor applied along each dimension.
         Factors for unused dimensions up to NDF\_\_MXDIM should be set
         to one.
      }
      \sstsubsection{
         ODIMS( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The dimensions of the expanded array.  Unused dimensions up to
         NDF\_\_MXDIM should be set to one.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Returned)
      }{
         The expanded array.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine works in n-D, where n is 1 to 7.  Even if the
         array has actually less dimensions there is negligible loss of
         efficiency to supply dummy (=1) higher dimensions.

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         base and paste arrays supplied to the routine must have the data
         type specified.
      }
   }
}
\sstroutine{
   KPG1\_PXDPx
}{
   Expands an n-dimensional array by pixel duplication
}{
   \sstdescription{
      This routine expands an input array by pixel duplication along
      each dimension.  The duplication factors may be different for
      each dimension.
   }
   \sstinvocation{
      CALL KPG1\_PXDPx( IDIMS, INARR, EXPAND, ODIMS, OUTARR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IDIMS( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The dimensions of the input array.  Unused dimensions
         up to NDF\_\_MXDIM should be set to one.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input data array that is to be enlarged by duplication.
      }
      \sstsubsection{
         EXPAND( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The linear expansion factor applied along each dimension.
         Factors for unused dimensions up to NDF\_\_MXDIM should be set
         to one.
      }
      \sstsubsection{
         ODIMS( NDF\_\_MXDIM ) = INTEGER (Given)
      }{
         The dimensions of the expanded array.  Unused dimensions up to
         NDF\_\_MXDIM should be set to one.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Returned)
      }{
         The expanded array.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned)
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine works in n-D, where n is 1 to 7.  Even if the
         array has actually less dimensions there is negligible loss of
         efficiency to supply dummy (=1) higher dimensions.

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         base and paste arrays supplied to the routine must have the data
         type specified.
      }
   }
}
\sstroutine{
   KPG1\_QCOL
}{
   Tests whether the current graphics device supports colour
}{
   \sstdescription{
      This routine determines whether the current GKS graphics device
      supports colour.
   }
   \sstinvocation{
      CALL KPG1\_QCOL( COLOUR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         COLOUR = LOGICAL (Returned)
      }{
         If true the device supports colour.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         An SGS workstation must be open.
      }
   }
}
\sstroutine{
   KPG1\_QIDAT
}{
   Inquires the number of colour indices and pixel dimensions of
   the current workstation
}{
   \sstdescription{
      This routine makes inquires of a graphics system to determine
      the maximum number of greyscale intensities, and the maximum
      display-surface in pixels.
   }
   \sstinvocation{
      CALL KPG1\_QIDAT( PNDEV, PKG, NINTS, LX, LY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNDEV = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The ADAM parameter associated with the current graphics
         workstation.  It is used to generate error messages.
      }
      \sstsubsection{
         PKG = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The graphics system.  It must be {\tt '}SGS{\tt '} or {\tt '}GKS{\tt '}.
      }
      \sstsubsection{
         NINTS = INTEGER (Returned)
      }{
         The maximum number of intensities or colour indices available
         on the current workstation.  It is initialised to 1.
      }
      \sstsubsection{
         LX = INTEGER (Returned)
      }{
         The maximum display-surface size in the x direction, given
         as device (raster) pixels.  It is initialised to 1.
      }
      \sstsubsection{
         LY = INTEGER (Returned)
      }{
         The maximum display-surface size in the y direction, given
         as device (raster) pixels.  It is initialised to 1.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine calls a GKS inquiry to find the size of
         the display surface.  The name of this routine changed between
         GKS 7.2 and GKS 7.4 from GDMDS to GQDSP.  Therefore this
         routine has two variants. This is the GKS 7.4 version.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         An SGS workstation must be open.

         \sstitem
         An error is reported if the device is not of the raster type.
         Thus the device should first be checked to be a valid workstation,
         i.e. is a raster device, or appropriate error handling added to
         the calling routine.
      }
   }
}
\sstroutine{
   KPG1\_QNCOL
}{
   Inquires the number of intensity-table entries of the current
   graphics device
}{
   \sstdescription{
      This routine determines how many {\tt "}colour table{\tt "} entries or
      intensities the current GKS graphics device has.  This includes
      devices that do not support colour.
   }
   \sstinvocation{
      CALL KPG1\_QNCOL( NUMENT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NUMENT = INTEGER (Returned)
      }{
         The number of entries in the intensity table.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         An SGS workstation must be open.
      }
   }
}
\sstroutine{
   KPG1\_QNTLx
}{
   Finds a quantile in a (possibly weighted) set of data
}{
   \sstdescription{
      The routine calculates the value of a specified quantile in a set
      of data values, which may be weighted.  In concept (although not
      in practice) it sorts the supplied data values into ascending
      order along with their associated positive weights, if supplied.
      It then finds a quantile Q such that the sum of the weights
      associated with all data values less than Q is a specified
      fraction FRACT of the sum of all the weights supplied.  If no
      weights are supplied, then each data value is assigned unit
      weight.  There are two main applications of this algorithm:

      a) To find specified quantiles of a distribution of data values
      for statistical purposes.  In this case, the weights may
      optionally be used to represent the number of times each data
      value occurs.  In such cases, it may be useful to regard the
      distribution as continuous, and therefore to interpolate linearly
      between data values when obtaining the result.

      b) Alternatively, the values may represent residuals from some
      fitted function.  In this case, by setting FRACT to 0.5, the
      {\tt "}weighted median residual{\tt "} may be found.  This has the property
      that if it is subtracted from all the original residuals, then
      the weighted sum of the absolute values of the corrected
      residuals will be minimised.  Thus, it may be used as the basis
      for iteratively finding an `L1{\tt '} fit.  In such cases, the required
      result will be equal to one of the data values (or may lie
      mid-way between two of them) and interpolation between values is
      not normally required.
   }
   \sstinvocation{
      CALL KPG1\_QNTLx( USEWT, INTERP, FRACT, EL, X, W, IP, Q, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         USEWT = LOGICAL (Given)
      }{
         Whether or not the data have associated weights.
      }
      \sstsubsection{
         INTERP = LOGICAL (Given)
      }{
         Whether or not interpolation between data values should be
         performed when obtaining the result.
      }
      \sstsubsection{
         FRACT = ? (Given)
      }{
         The fraction specifying the required quantile, in the range
         0.0 to 1.0.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of data values.
      }
      \sstsubsection{
         X( $*$ ) = ? (Given)
      }{
         Array of data values.
      }
      \sstsubsection{
         W( $*$ ) = ? (Given)
      }{
         Array of associated positive weights (if required). This
         argument will only be referenced if USEWT is .TRUE..
      }
      \sstsubsection{
         IP( EL ) = INTEGER (Given and Returned)
      }{
         On entry, an array of pointers identifying which elements of X
         (and W if supplied) are to be considered. On exit, these
         pointers will have been permuted to access the specified data
         elements in an order which is more nearly sorted than before
         (although in general it will not represent a complete sort of
         the data).
      }
      \sstsubsection{
         Q = ? (Returned)
      }{
         The value of the requested quantile.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There are versions of this routine for processing both REAL
         and DOUBLE PRECISION data; replace the {\tt "}x{\tt "} in the routine name by
         R or D as appropriate. The types of the FACT, X, W and Q
         arguments should match the routine being used.

         \sstitem
         This routine is optimised for use when the number of data
         values is large. In general, only a partial sort of the data will
         be performed, so this routine will perform better than most other
         methods of finding quantiles, which typically require a complete
         sort.

         \sstitem
         The order in which the input pointers are supplied in the
         array IP is arbitrary, but there will often be an efficiency
         advantage in supplying them so that they access the data in
         nearly-sorted order. Thus, re-supplying the array of pointers
         generated by a previous invocation of this routine (for the same
         or similar data) may be worthwhile.
      }
   }
   \sstdiytopic{
      Timing
   }{
      Details of the asymptotic time required to execute the original
      SELECT algorithm are not altogether clear from the published
      papers.  It appears that this algorithm may have better average
      performance than other methods and the time required may
      approximate to EL $*$ LOG( MIN( K, EL - K $+$ 1 ) ) where K is the
      rank of the largest data value which is smaller than the quantile
      being sought.  However, Sedgewick (see References) indicates that
      such algorithms should, in general, complete in time proportional
      to EL, so the above formula may be incorrect.  When using
      weighted data, the time will be multiplied by a further factor
      reflecting the non-linearity of the cumulative weight versus rank
      function and the difficulty of inverting it.
   }
   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         Comm. of the ACM, vol 18, no. 3 (March 1975), p165.

         \sstitem
         Also see page 173.

         \sstitem
         In addition, see the algorithm assessment by T. Brown in
         Collected Algorithms of the ACM, (algorithm no. 489).

         \sstitem
         Sedgwick, R., 1988, {\tt "}Algorithms{\tt "} (Addison-Wesley).
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1992 Science \& Engineering Research Council
   }
}
\sstroutine{
   KPG1\_QNTLx
}{
   Finds a quantile in a (possibly weighted) set of data
}{
   \sstdescription{
      The routine calculates the value of a specified quantile in a set
      of data values, which may be weighted.  In concept (although not
      in practice) it sorts the supplied data values into ascending
      order along with their associated positive weights, if supplied.
      It then finds a quantile Q such that the sum of the weights
      associated with all data values less than Q is a specified
      fraction FRACT of the sum of all the weights supplied.  If no
      weights are supplied, then each data value is assigned unit
      weight.  There are two main applications of this algorithm:

      a) To find specified quantiles of a distribution of data values
      for statistical purposes.  In this case, the weights may
      optionally be used to represent the number of times each data
      value occurs.  In such cases, it may be useful to regard the
      distribution as continuous, and therefore to interpolate linearly
      between data values when obtaining the result.

      b) Alternatively, the values may represent residuals from some
      fitted function.  In this case, by setting FRACT to 0.5, the
      {\tt "}weighted median residual{\tt "} may be found.  This has the property
      that if it is subtracted from all the original residuals, then
      the weighted sum of the absolute values of the corrected
      residuals will be minimised.  Thus, it may be used as the basis
      for iteratively finding an `L1{\tt '} fit.  In such cases, the required
      result will be equal to one of the data values (or may lie
      mid-way between two of them) and interpolation between values is
      not normally required.
   }
   \sstinvocation{
      CALL KPG1\_QNTLx( USEWT, INTERP, FRACT, EL, X, W, IP, Q, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         USEWT = LOGICAL (Given)
      }{
         Whether or not the data have associated weights.
      }
      \sstsubsection{
         INTERP = LOGICAL (Given)
      }{
         Whether or not interpolation between data values should be
         performed when obtaining the result.
      }
      \sstsubsection{
         FRACT = ? (Given)
      }{
         The fraction specifying the required quantile, in the range
         0.0 to 1.0.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of data values.
      }
      \sstsubsection{
         X( $*$ ) = ? (Given)
      }{
         Array of data values.
      }
      \sstsubsection{
         W( $*$ ) = ? (Given)
      }{
         Array of associated positive weights (if required). This
         argument will only be referenced if USEWT is .TRUE..
      }
      \sstsubsection{
         IP( EL ) = INTEGER (Given and Returned)
      }{
         On entry, an array of pointers identifying which elements of X
         (and W if supplied) are to be considered. On exit, these
         pointers will have been permuted to access the specified data
         elements in an order which is more nearly sorted than before
         (although in general it will not represent a complete sort of
         the data).
      }
      \sstsubsection{
         Q = ? (Returned)
      }{
         The value of the requested quantile.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There are versions of this routine for processing both REAL
         and DOUBLE PRECISION data; replace the {\tt "}x{\tt "} in the routine name by
         R or D as appropriate. The types of the FACT, X, W and Q
         arguments should match the routine being used.

         \sstitem
         This routine is optimised for use when the number of data
         values is large. In general, only a partial sort of the data will
         be performed, so this routine will perform better than most other
         methods of finding quantiles, which typically require a complete
         sort.

         \sstitem
         The order in which the input pointers are supplied in the
         array IP is arbitrary, but there will often be an efficiency
         advantage in supplying them so that they access the data in
         nearly-sorted order. Thus, re-supplying the array of pointers
         generated by a previous invocation of this routine (for the same
         or similar data) may be worthwhile.
      }
   }
   \sstdiytopic{
      Timing
   }{
      Details of the asymptotic time required to execute the original
      SELECT algorithm are not altogether clear from the published
      papers.  It appears that this algorithm may have better average
      performance than other methods and the time required may
      approximate to EL $*$ LOG( MIN( K, EL - K $+$ 1 ) ) where K is the
      rank of the largest data value which is smaller than the quantile
      being sought.  However, Sedgewick (see References) indicates that
      such algorithms should, in general, complete in time proportional
      to EL, so the above formula may be incorrect.  When using
      weighted data, the time will be multiplied by a further factor
      reflecting the non-linearity of the cumulative weight versus rank
      function and the difficulty of inverting it.
   }
   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         Comm. of the ACM, vol 18, no. 3 (March 1975), p165.

         \sstitem
         Also see page 173.

         \sstitem
         In addition, see the algorithm assessment by T. Brown in
         Collected Algorithms of the ACM, (algorithm no. 489).

         \sstitem
         Sedgwick, R., 1988, {\tt "}Algorithms{\tt "} (Addison-Wesley).
      }
   }
   \sstdiytopic{
      Copyright
   }{
      Copyright (C) 1992 Science \& Engineering Research Council
   }
}
\sstroutine{
   KPG1\_QSRTX
}{
   Sorts a vector via the Quicksort algorithm
}{
   \sstdescription{
      This routine sorts a vector in situ between an upper and lower
      bounds using the Quicksort algorithm.
   }
   \sstinvocation{
      CALL KPG1\_QSRTx( EL, LOW, HIGH, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array that is to be sorted.
      }
      \sstsubsection{
         LOW = INTEGER (Given)
      }{
         The lower bound within the array, below which the array
         elements will not be sorted.  It should be less than the
         upper bound and must be within the array.  In the latter case
         an error will result and the routine will not sort the array.
      }
      \sstsubsection{
         HIGH = INTEGER (Given)
      }{
         The upper bound within the array, above which the array
         elements will not be sorted.  It should be greater than the
         lower bound and must be within the array.  In the latter case
         an error will result and the routine will not sort the array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given and Returned)
      }{
         The array to be sorted.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         Sedgwick, R., 1988, {\tt "}Algorithms{\tt "} (Addison-Wesley).
      }
   }
   \sstdiytopic{
      Timing
   }{
      For N elements to be sorted the timing goes as NlnN.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         There is a routine for each of the data types integer, real,
         double precision, and character: replace {\tt "}x{\tt "} in the routine nam
         by I, R, D, or C respectively as appropriate.

         \sstitem
         If the maximum bound is less than the minimum, the bounds are
         swapped.
      }
   }
}
\sstroutine{
   KPG1\_QSRTX
}{
   Sorts a vector via the Quicksort algorithm
}{
   \sstdescription{
      This routine sorts a vector in situ between an upper and lower
      bounds using the Quicksort algorithm.
   }
   \sstinvocation{
      CALL KPG1\_QSRTx( EL, LOW, HIGH, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array that is to be sorted.
      }
      \sstsubsection{
         LOW = INTEGER (Given)
      }{
         The lower bound within the array, below which the array
         elements will not be sorted.  It should be less than the
         upper bound and must be within the array.  In the latter case
         an error will result and the routine will not sort the array.
      }
      \sstsubsection{
         HIGH = INTEGER (Given)
      }{
         The upper bound within the array, above which the array
         elements will not be sorted.  It should be greater than the
         lower bound and must be within the array.  In the latter case
         an error will result and the routine will not sort the array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given and Returned)
      }{
         The array to be sorted.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         Sedgwick, R., 1988, {\tt "}Algorithms{\tt "} (Addison-Wesley).
      }
   }
   \sstdiytopic{
      Timing
   }{
      For N elements to be sorted the timing goes as NlnN.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         There is a routine for each of the data types integer, real,
         double precision, and character: replace {\tt "}x{\tt "} in the routine nam
         by I, R, D, or C respectively as appropriate.

         \sstitem
         If the maximum bound is less than the minimum, the bounds are
         swapped.
      }
   }
}
\sstroutine{
   KPG1\_QSRTX
}{
   Sorts a vector via the Quicksort algorithm
}{
   \sstdescription{
      This routine sorts a vector in situ between an upper and lower
      bounds using the Quicksort algorithm.
   }
   \sstinvocation{
      CALL KPG1\_QSRTx( EL, LOW, HIGH, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array that is to be sorted.
      }
      \sstsubsection{
         LOW = INTEGER (Given)
      }{
         The lower bound within the array, below which the array
         elements will not be sorted.  It should be less than the
         upper bound and must be within the array.  In the latter case
         an error will result and the routine will not sort the array.
      }
      \sstsubsection{
         HIGH = INTEGER (Given)
      }{
         The upper bound within the array, above which the array
         elements will not be sorted.  It should be greater than the
         lower bound and must be within the array.  In the latter case
         an error will result and the routine will not sort the array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given and Returned)
      }{
         The array to be sorted.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         Sedgwick, R., 1988, {\tt "}Algorithms{\tt "} (Addison-Wesley).
      }
   }
   \sstdiytopic{
      Timing
   }{
      For N elements to be sorted the timing goes as NlnN.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         There is a routine for each of the data types integer, real,
         double precision, and character: replace {\tt "}x{\tt "} in the routine nam
         by I, R, D, or C respectively as appropriate.

         \sstitem
         If the maximum bound is less than the minimum, the bounds are
         swapped.
      }
   }
}
\sstroutine{
   KPG1\_QSRTX
}{
   Sorts a vector via the Quicksort algorithm
}{
   \sstdescription{
      This routine sorts a vector in situ between an upper and lower
      bounds using the Quicksort algorithm.
   }
   \sstinvocation{
      CALL KPG1\_QSRTx( EL, LOW, HIGH, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array that is to be sorted.
      }
      \sstsubsection{
         LOW = INTEGER (Given)
      }{
         The lower bound within the array, below which the array
         elements will not be sorted.  It should be less than the
         upper bound and must be within the array.  In the latter case
         an error will result and the routine will not sort the array.
      }
      \sstsubsection{
         HIGH = INTEGER (Given)
      }{
         The upper bound within the array, above which the array
         elements will not be sorted.  It should be greater than the
         lower bound and must be within the array.  In the latter case
         an error will result and the routine will not sort the array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given and Returned)
      }{
         The array to be sorted.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         Sedgwick, R., 1988, {\tt "}Algorithms{\tt "} (Addison-Wesley).
      }
   }
   \sstdiytopic{
      Timing
   }{
      For N elements to be sorted the timing goes as NlnN.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         There is a routine for each of the data types integer, real,
         double precision, and character: replace {\tt "}x{\tt "} in the routine nam
         by I, R, D, or C respectively as appropriate.

         \sstitem
         If the maximum bound is less than the minimum, the bounds are
         swapped.
      }
   }
}
\sstroutine{
   KPG1\_QSRTX
}{
   Sorts a vector via the Quicksort algorithm
}{
   \sstdescription{
      This routine sorts a vector in situ between an upper and lower
      bounds using the Quicksort algorithm.
   }
   \sstinvocation{
      CALL KPG1\_QSRTx( EL, LOW, HIGH, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array that is to be sorted.
      }
      \sstsubsection{
         LOW = INTEGER (Given)
      }{
         The lower bound within the array, below which the array
         elements will not be sorted.  It should be less than the
         upper bound and must be within the array.  In the latter case
         an error will result and the routine will not sort the array.
      }
      \sstsubsection{
         HIGH = INTEGER (Given)
      }{
         The upper bound within the array, above which the array
         elements will not be sorted.  It should be greater than the
         lower bound and must be within the array.  In the latter case
         an error will result and the routine will not sort the array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given and Returned)
      }{
         The array to be sorted.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         Sedgwick, R., 1988, {\tt "}Algorithms{\tt "} (Addison-Wesley).
      }
   }
   \sstdiytopic{
      Timing
   }{
      For N elements to be sorted the timing goes as NlnN.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         There is a routine for each of the data types integer, real,
         double precision, and character: replace {\tt "}x{\tt "} in the routine nam
         by I, R, D, or C respectively as appropriate.

         \sstitem
         If the maximum bound is less than the minimum, the bounds are
         swapped.
      }
   }
}
\sstroutine{
   KPG1\_QSRTX
}{
   Sorts a vector via the Quicksort algorithm
}{
   \sstdescription{
      This routine sorts a vector in situ between an upper and lower
      bounds using the Quicksort algorithm.
   }
   \sstinvocation{
      CALL KPG1\_QSRTx( EL, LOW, HIGH, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array that is to be sorted.
      }
      \sstsubsection{
         LOW = INTEGER (Given)
      }{
         The lower bound within the array, below which the array
         elements will not be sorted.  It should be less than the
         upper bound and must be within the array.  In the latter case
         an error will result and the routine will not sort the array.
      }
      \sstsubsection{
         HIGH = INTEGER (Given)
      }{
         The upper bound within the array, above which the array
         elements will not be sorted.  It should be greater than the
         lower bound and must be within the array.  In the latter case
         an error will result and the routine will not sort the array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given and Returned)
      }{
         The array to be sorted.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         Sedgwick, R., 1988, {\tt "}Algorithms{\tt "} (Addison-Wesley).
      }
   }
   \sstdiytopic{
      Timing
   }{
      For N elements to be sorted the timing goes as NlnN.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         There is a routine for each of the data types integer, real,
         double precision, and character: replace {\tt "}x{\tt "} in the routine nam
         by I, R, D, or C respectively as appropriate.

         \sstitem
         If the maximum bound is less than the minimum, the bounds are
         swapped.
      }
   }
}
\sstroutine{
   KPG1\_QSRTX
}{
   Sorts a vector via the Quicksort algorithm
}{
   \sstdescription{
      This routine sorts a vector in situ between an upper and lower
      bounds using the Quicksort algorithm.
   }
   \sstinvocation{
      CALL KPG1\_QSRTx( EL, LOW, HIGH, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array that is to be sorted.
      }
      \sstsubsection{
         LOW = INTEGER (Given)
      }{
         The lower bound within the array, below which the array
         elements will not be sorted.  It should be less than the
         upper bound and must be within the array.  In the latter case
         an error will result and the routine will not sort the array.
      }
      \sstsubsection{
         HIGH = INTEGER (Given)
      }{
         The upper bound within the array, above which the array
         elements will not be sorted.  It should be greater than the
         lower bound and must be within the array.  In the latter case
         an error will result and the routine will not sort the array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given and Returned)
      }{
         The array to be sorted.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         Sedgwick, R., 1988, {\tt "}Algorithms{\tt "} (Addison-Wesley).
      }
   }
   \sstdiytopic{
      Timing
   }{
      For N elements to be sorted the timing goes as NlnN.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         There is a routine for each of the data types integer, real,
         double precision, and character: replace {\tt "}x{\tt "} in the routine nam
         by I, R, D, or C respectively as appropriate.

         \sstitem
         If the maximum bound is less than the minimum, the bounds are
         swapped.
      }
   }
}
\sstroutine{
   KPG1\_QSRTX
}{
   Sorts a vector via the Quicksort algorithm
}{
   \sstdescription{
      This routine sorts a vector in situ between an upper and lower
      bounds using the Quicksort algorithm.
   }
   \sstinvocation{
      CALL KPG1\_QSRTx( EL, LOW, HIGH, ARRAY, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array that is to be sorted.
      }
      \sstsubsection{
         LOW = INTEGER (Given)
      }{
         The lower bound within the array, below which the array
         elements will not be sorted.  It should be less than the
         upper bound and must be within the array.  In the latter case
         an error will result and the routine will not sort the array.
      }
      \sstsubsection{
         HIGH = INTEGER (Given)
      }{
         The upper bound within the array, above which the array
         elements will not be sorted.  It should be greater than the
         lower bound and must be within the array.  In the latter case
         an error will result and the routine will not sort the array.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given and Returned)
      }{
         The array to be sorted.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      References
   }{
      \sstitemlist{

         \sstitem
         Sedgwick, R., 1988, {\tt "}Algorithms{\tt "} (Addison-Wesley).
      }
   }
   \sstdiytopic{
      Timing
   }{
      For N elements to be sorted the timing goes as NlnN.
   }
   \sstimplementationstatus{
      \sstitemlist{

         \sstitem
         There is a routine for each of the data types integer, real,
         double precision, and character: replace {\tt "}x{\tt "} in the routine nam
         by I, R, D, or C respectively as appropriate.

         \sstitem
         If the maximum bound is less than the minimum, the bounds are
         swapped.
      }
   }
}
\sstroutine{
   KPG1\_QVID
}{
   Tests whether the current graphics device has suitable
   image-display characteristics
}{
   \sstdescription{
      This routine determines whether the current graphics device is an
      image display with suitable characteristics.  The checks are
      performed in the following order: the class of the device is
      checked against a supplied list of acceptable classes; the
      presence of certain attributes, given in a supplied list are
      checked in the order colour, input and open with reset; and
      finally a minimum number of colour indices must be exceeded.
   }
   \sstinvocation{
      CALL KPG1\_QVID( PNDEV, PKG, CLASS, CRITER, MININT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNDEV = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The ADAM parameter associated with the current graphics
         workstation.  It is used to generate error messages.
      }
      \sstsubsection{
         PKG = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The graphics system.  It must be {\tt '}SGS{\tt '} or {\tt '}GKS{\tt '}.
      }
      \sstsubsection{
         CLASS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A list of acceptable workstation classes as defined by GNS,
         each separated by a comma.  See SUN/57 for a list.
      }
      \sstsubsection{
         CRITER = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A list of criteria that the workstation must pass in order to
         be an acceptable image display.  The options are: {\tt '}COLOUR{\tt '} if
         colour must be available, {\tt '}CURSOR{\tt '} if a cursor must be
         available on the workstation, {\tt '}INPUT{\tt '} if the workstation must
         support input, and {\tt '}RESET{\tt '} if the workstation must be capable
         of being opened without reset.  Non-standard criteria will be
         ignored.
      }
      \sstsubsection{
         MININT = INTEGER (Given)
      }{
         Minimum number of intensities or colour indices required.  The
         routine ensures that there are at least the reserved number
         plus eight, except for workstations in the WINDOW\_OVERLAY
         class, when 1 is the minimum.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         An SGS workstation must be open.
      }
   }
}
\sstroutine{
   KPG1\_R2NAG
}{
   Converts an FFTPACK Hermitian Fourier transform array into
   the equivalent NAG array
}{
   \sstdescription{
      This subroutine re-orders and normalises the supplied array of
      Fourier co-efficients (as produced by FFTPACK subroutine KPG1\_RFFTF)
      so that the returned array looks like the equivalent array returned
      by NAG routine C06FAE.

      This function is equivalent to PDA\_R2NAG except that it uses work
      space for greater speed.

      The real and imaginary co-efficients produced by KPG1\_RFFTF are numerically
      larger than the corresponding C06FAE co-efficients by a factor of
      SQRT( NP ), and are ordered differently. Both routines return A0
      (the zeroth real term, i.e. the DC level in the array) in element 1.
      KPG1\_RFFTF then has corresponding real and imaginary terms in adjacent
      elements, whereas C06FAE has all the real terms together, followed by
      all the imaginary terms (in reverse order):

         KPG1\_RFFTF :  A0,    A1, B1,     A2, B2,     A3, B3,   ...
         C06FAE:       A0,    A1, A2, A3, ...,        ..., B3, B2, B1

      The zeroth imaginary term (B0) always has the value zero and so is
      not stored in the array. Care has to be taken about the parity of the
      array size. If it is even, then there is one more real term than
      there is imaginary terms (excluding A0), i.e. if NP = 10, then the
      co-efficients are stored as follows:

         KPG1\_RFFTF :  A0, A1, B1, A2, B2, A3, B3, A4, B4, A5
         C06FAE:       A0, A1, A2, A3, A4, A5, B4, B3, B2, B1

      If NP = 9, then the co-efficients are stored as follows:

         KPG1\_RFFTF :  A0, A1, B1, A2, B2, A3, B3, A4, B4
         C06FAE:       A0, A1, A2, A3, A4, B4, B3, B2, B1
   }
   \sstinvocation{
      CALL KPG1\_R2NAG( NP, R, WORK )
   }
   \sstarguments{
      \sstsubsection{
         NP = INTEGER (Given)
      }{
         The size of the array.
      }
      \sstsubsection{
         R( NP ) = REAL (Given and Returned)
      }{
         The array holding the Fourier co-efficients. Supplied in FFTPACK
         format, returned in NAG format.
      }
      \sstsubsection{
         WORK( NP ) = REAL (Given and Returned)
      }{
         Work space.
      }
   }
}
\sstroutine{
   KPG1\_RCATW
}{
   Attempt to read an AST Object from a catalogue
}{
   \sstdescription{
      This routine attempts to read an AST Object from the textual
      information stored with the supplied catalogue (see SUN/181).
      Reading of the textual information in the catalogue commences
      at the current line (i.e. access to the textual information is not
      reset before reading commences).

      AST Objects can be written to a catalogue using routine KPG1\_WCATW.
   }
   \sstinvocation{
      CALL KPG1\_RCATW( CI, IAST, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         CI = INTEGER (Given)
      }{
         A CAT identifier (see SUN/181) for the supplied catalogue.
      }
      \sstsubsection{
         IAST = INTEGER (Returned)
      }{
         An AST pointer to the returned Object. AST\_\_NULL is returned if
         an error occurs.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_RDAST
}{
   Read AST\_ data as text from an HDS object
}{
   \sstdescription{
      This is a service routine to be provided as a {\tt "}source{\tt "} routine
      for the AST\_CHANNEL function. It reads data from an HDS object
      (in response to reading from an AST\_ Channel) and delivers it to
      the AST\_ library for interpretation.

      This routine has only a STATUS argument, so it communicates with
      other KPG routines via global variables stored in the KPG\_AST common
      blocks. These are described below under {\tt "}Global Variables used as
      Arguments{\tt "}.
   }
   \sstinvocation{
      CALL KPG1\_RDAST
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Global Variables used as Arguments
   }{
      ASTLC = CHARACTER $*$ ( DAT\_\_SZLOC ) (Given)
         A locator for the HDS object which holds the data. This must
         be a 1-dimensional \_CHAR array, whose size and character
         string length will be determined via this locator.
      ASTLN = INTEGER (Given and Returned)
         This must initially be set to the value 1, to indicate that
         data will be read starting at the first element of the HDS
         array (note the routine will not operate correctly unless 1 is
         the initial value - you cannot start reading at another point
         in the array if you have previously read from a different
         array). On exit it will be incremented by the number of
         elements used to obtain data, so that it identifies the first
         element to be used on the next invocation.
      ASTPT = INTEGER (Given)
         A pointer to the contents of the HDS object, mapped in {\tt '}READ{\tt '}
         mode.
   }
}
\sstroutine{
   KPG1\_RDLST
}{
   Reads a set of positions from a CAT catalogue
}{
   \sstdescription{
      This routine reads a FrameSet, and a set of positions with
      associated integer identifiers from a CAT catalogue. The FrameSet
      should be stored as an AST Dump in the textual information associated
      with the catalogue. Such catalogues can be created using KPG1\_WRLST.
      If the catalogue does not contain a FrameSet, then a default
      FrameSet will be used if possible. If the catalogue contains
      floating point columns named RA and DEC, then the default FrameSet
      contains a single SkyFrame (Epoch and Equinox are set from the
      EPOCH and EQUINOX catalogue parameters - if they exist). Otherwise,
      if the catalogue contains floating point columns named X and Y, then
      the default FrameSet contains a single 2D Frame with axis symbols X
      and Y, and Domain GRID. If there is also a column named Z, then
      the Frame will be 3D, with a Z axis.

      Hoqwever the FrameSet is obtained, it is assumed that the columns
      containing the axis values have CAT names equal to the Symbol
      attribute of the corresponding AST Axis. The catalogue columns from
      which to read the axis values are chosen by matching column names
      with Axis Symbols (only columns containing floating point values are
      considered). Frames are checked in the following order: the Base
      Frame, the Current Frame, all other Frames in order of increasing
      Frame index. An error is reported if no Frame has a set of
      corresponding columns.

      It is assumed that position identifiers are stored in an integer column
      with name PIDENT. If no such column is found, the returned position
      identifiers start at 1 and increase monotonically.
   }
   \sstinvocation{
      CALL KPG1\_RDLST( PARAM, CURFRM, IWCS, NPOS, NAX, IPPOS, IPID, TITLE,
                       NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use.
      }
      \sstsubsection{
         CURFRM = LOGICAL (Given)
      }{
         If .TRUE. the positions read from the catalogue are Mapped
         into the Current Frame of the associated FrameSet before being
         returned. Otherwise, they are returned in the Base Frame.
      }
      \sstsubsection{
         IWCS = INTEGER (Returned)
      }{
         An AST pointer to the FrameSet read from the catalogue.
      }
      \sstsubsection{
         NPOS = INTEGER (Returned)
      }{
         The number of positions returned.
      }
      \sstsubsection{
         NAX = INTEGER (Returned)
      }{
         The number of axes in the Frame requested by CURFRM.
      }
      \sstsubsection{
         IPPOS = INTEGER (Returned)
      }{
         A pointer to a 2-dimensional DOUBLE PRECISION array holding the
         returned positions. Element (I,J) of this array gives axis J for
         position I. The first axis will have NPOS elements, and the
         second will have NAX elements. Should be released using PSX\_FREE
         when no longer needed.
      }
      \sstsubsection{
         IPID = INTEGER (Returned)
      }{
         A pointer to a 1-dimensional INTEGER array holding the integer
         identifiers for the returned positions. The array will have NPOS
         elements. Should be released using PSX\_FREE when no longer needed.
      }
      \sstsubsection{
         TITLE = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The value of the TITLE parameter in the supplied catalogue.
         Returned blank if there is no TITLE parameter.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The file spec of the catalogue containing the positions list.
         Not accessed if the declared length is 1.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_REPRT
}{
   Reports a MSG message to user and also optionally write it to a file
}{
   \sstdescription{
      This routine dislays the supplied message using MSG\_OUT (unless
      QUIET is .TRUE), and (if LOG is .TRUE.) writes out the same text
      to the file identified by FD.
   }
   \sstinvocation{
      CALL KPG1\_REPRT( MESS, QUIET, LOG, FD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         MESS = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The message, which may contain MSG tokens.
      }
      \sstsubsection{
         QUIET = LOGICAL (Given)
      }{
         Supress screen output?
      }
      \sstsubsection{
         LOG = LOGICAL (Given)
      }{
         Write the text to  a file?
      }
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         An FIO identifier for a file. If LOG is .TRUE., then the message
         is written to this file.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_RETRx
}{
   Retrieves a value from an array
}{
   \sstdescription{
      The value stored at a given index within the supplied array is
      returned.
   }
   \sstinvocation{
      CALL KPG1\_RETRx( EL, INDEX, DATA, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index within the array of the required value.
      }
      \sstsubsection{
         DATA( EL ) = ? (Given)
      }{
         The input array.
      }
      \sstsubsection{
         VALUE = ? (Returned)
      }{
         The returned value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW, or W as appropriate.  The
         VALUE and DATA arguments must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_RETRx
}{
   Retrieves a value from an array
}{
   \sstdescription{
      The value stored at a given index within the supplied array is
      returned.
   }
   \sstinvocation{
      CALL KPG1\_RETRx( EL, INDEX, DATA, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index within the array of the required value.
      }
      \sstsubsection{
         DATA( EL ) = ? (Given)
      }{
         The input array.
      }
      \sstsubsection{
         VALUE = ? (Returned)
      }{
         The returned value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW, or W as appropriate.  The
         VALUE and DATA arguments must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_RETRx
}{
   Retrieves a value from an array
}{
   \sstdescription{
      The value stored at a given index within the supplied array is
      returned.
   }
   \sstinvocation{
      CALL KPG1\_RETRx( EL, INDEX, DATA, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index within the array of the required value.
      }
      \sstsubsection{
         DATA( EL ) = ? (Given)
      }{
         The input array.
      }
      \sstsubsection{
         VALUE = ? (Returned)
      }{
         The returned value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW, or W as appropriate.  The
         VALUE and DATA arguments must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_RETRx
}{
   Retrieves a value from an array
}{
   \sstdescription{
      The value stored at a given index within the supplied array is
      returned.
   }
   \sstinvocation{
      CALL KPG1\_RETRx( EL, INDEX, DATA, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index within the array of the required value.
      }
      \sstsubsection{
         DATA( EL ) = ? (Given)
      }{
         The input array.
      }
      \sstsubsection{
         VALUE = ? (Returned)
      }{
         The returned value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW, or W as appropriate.  The
         VALUE and DATA arguments must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_RETRx
}{
   Retrieves a value from an array
}{
   \sstdescription{
      The value stored at a given index within the supplied array is
      returned.
   }
   \sstinvocation{
      CALL KPG1\_RETRx( EL, INDEX, DATA, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index within the array of the required value.
      }
      \sstsubsection{
         DATA( EL ) = ? (Given)
      }{
         The input array.
      }
      \sstsubsection{
         VALUE = ? (Returned)
      }{
         The returned value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW, or W as appropriate.  The
         VALUE and DATA arguments must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_RETRx
}{
   Retrieves a value from an array
}{
   \sstdescription{
      The value stored at a given index within the supplied array is
      returned.
   }
   \sstinvocation{
      CALL KPG1\_RETRx( EL, INDEX, DATA, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index within the array of the required value.
      }
      \sstsubsection{
         DATA( EL ) = ? (Given)
      }{
         The input array.
      }
      \sstsubsection{
         VALUE = ? (Returned)
      }{
         The returned value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW, or W as appropriate.  The
         VALUE and DATA arguments must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_RETRx
}{
   Retrieves a value from an array
}{
   \sstdescription{
      The value stored at a given index within the supplied array is
      returned.
   }
   \sstinvocation{
      CALL KPG1\_RETRx( EL, INDEX, DATA, VALUE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index within the array of the required value.
      }
      \sstsubsection{
         DATA( EL ) = ? (Given)
      }{
         The input array.
      }
      \sstsubsection{
         VALUE = ? (Returned)
      }{
         The returned value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW, or W as appropriate.  The
         VALUE and DATA arguments must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_RFCOx
}{
   Reads co-ordinate data from a text free-format file
}{
   \sstdescription{
      This routine reads co-ordinate information and from a text
      free-format file and converts it to floating-point values.  The
      file is like a relational catalogue with one record per related
      set of co-ordinates, however, exact column alignment is not
      necessary.  The converted input data are copied to an array.  The
      array uses a new line for each record of the file, its columns
      storing the given positional data in the order x, y, z etc.  If
      the end of file is not reached a flag is returned.
   }
   \sstinvocation{
       CALL KPG1\_RFCOx( FD, DIM1, DIM2, POSCOD, COUNT, CODATA, LBND,
      :                 UBND, CMPLET, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         Fortran file identifier.
      }
      \sstsubsection{
         DIM1 = INTEGER (Given)
      }{
         The first dimension of the output array.
      }
      \sstsubsection{
         DIM2 = INTEGER (Given)
      }{
         The second dimension of the output array.
      }
      \sstsubsection{
         POSCOD( DIM1 ) = INTEGER (Given)
      }{
         The column numbers of the co-ordinate information in order
         x, y, z, etc.  These must be positive.
      }
      \sstsubsection{
         COUNT = INTEGER (Given and Returned)
      }{
         The number of the line in the output array to be written first.
         If the file has been completely read this becomes the number
         of data sets stored in the array (i.e. one less).  It should
         be initialised externally the first time this routine is
         called, but not subsequently.
      }
      \sstsubsection{
         CODATA( DIM1, DIM2 ) = ? (Given and Returned)
      }{
         The array to store the co-ordinates read from the text file.
         It should be initialised externally the first time this routine
         is called, but not subsequently.
      }
      \sstsubsection{
         LBND( DIM1 ) = ? (Given and Returned)
      }{
         The lower bounds of the input data, i.e. the minimum value for
         each co-ordinate.  It should be initialised externally the
         first time this routine is called, but not subsequently.
      }
      \sstsubsection{
         UBND( DIM1 ) = ? (Given and Returned)
      }{
         The upper bounds of the input data, i.e. the maximum value for
         each co-ordinate.  It should be initialised externally the
         first time this routine is called, but not subsequently.
      }
      \sstsubsection{
         CMPLET = LOGICAL (Returned)
      }{
         If .TRUE., the text file has been completely read.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision data types:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively.  The
         routine arguments CODATA, LBND and UBND must have the data type
         specified.
         \_  The maximum permitted line length in the file is 256
         characters.  A line with a hash or shriek in column one is treated
         as a comment.

         \sstitem
         The file is not closed on exit.

         \sstitem
         The record number is not initialised and so this routine reads
         from the current line in the file.  Hence this routine can be
         called repeatedly as the the output array is expanded to
         accommodate the input data.

         \sstitem
         The numerical values can include embedded spaces following a
         $+$, -, D, or E.  See SLALIB (SUN/67) routines SLA\_DFLTIN and
         SLA\_FLOTIN for details of the conversion from free-format to
         floating-point value.  Missing columns that are not numeric
         cannot have these embedded spaces.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         The Fortran text file must already be opened.
      }
   }
}
\sstroutine{
   KPG1\_RFCOx
}{
   Reads co-ordinate data from a text free-format file
}{
   \sstdescription{
      This routine reads co-ordinate information and from a text
      free-format file and converts it to floating-point values.  The
      file is like a relational catalogue with one record per related
      set of co-ordinates, however, exact column alignment is not
      necessary.  The converted input data are copied to an array.  The
      array uses a new line for each record of the file, its columns
      storing the given positional data in the order x, y, z etc.  If
      the end of file is not reached a flag is returned.
   }
   \sstinvocation{
       CALL KPG1\_RFCOx( FD, DIM1, DIM2, POSCOD, COUNT, CODATA, LBND,
      :                 UBND, CMPLET, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         FD = INTEGER (Given)
      }{
         Fortran file identifier.
      }
      \sstsubsection{
         DIM1 = INTEGER (Given)
      }{
         The first dimension of the output array.
      }
      \sstsubsection{
         DIM2 = INTEGER (Given)
      }{
         The second dimension of the output array.
      }
      \sstsubsection{
         POSCOD( DIM1 ) = INTEGER (Given)
      }{
         The column numbers of the co-ordinate information in order
         x, y, z, etc.  These must be positive.
      }
      \sstsubsection{
         COUNT = INTEGER (Given and Returned)
      }{
         The number of the line in the output array to be written first.
         If the file has been completely read this becomes the number
         of data sets stored in the array (i.e. one less).  It should
         be initialised externally the first time this routine is
         called, but not subsequently.
      }
      \sstsubsection{
         CODATA( DIM1, DIM2 ) = ? (Given and Returned)
      }{
         The array to store the co-ordinates read from the text file.
         It should be initialised externally the first time this routine
         is called, but not subsequently.
      }
      \sstsubsection{
         LBND( DIM1 ) = ? (Given and Returned)
      }{
         The lower bounds of the input data, i.e. the minimum value for
         each co-ordinate.  It should be initialised externally the
         first time this routine is called, but not subsequently.
      }
      \sstsubsection{
         UBND( DIM1 ) = ? (Given and Returned)
      }{
         The upper bounds of the input data, i.e. the maximum value for
         each co-ordinate.  It should be initialised externally the
         first time this routine is called, but not subsequently.
      }
      \sstsubsection{
         CMPLET = LOGICAL (Returned)
      }{
         If .TRUE., the text file has been completely read.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision data types:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively.  The
         routine arguments CODATA, LBND and UBND must have the data type
         specified.
         \_  The maximum permitted line length in the file is 256
         characters.  A line with a hash or shriek in column one is treated
         as a comment.

         \sstitem
         The file is not closed on exit.

         \sstitem
         The record number is not initialised and so this routine reads
         from the current line in the file.  Hence this routine can be
         called repeatedly as the the output array is expanded to
         accommodate the input data.

         \sstitem
         The numerical values can include embedded spaces following a
         $+$, -, D, or E.  See SLALIB (SUN/67) routines SLA\_DFLTIN and
         SLA\_FLOTIN for details of the conversion from free-format to
         floating-point value.  Missing columns that are not numeric
         cannot have these embedded spaces.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         The Fortran text file must already be opened.
      }
   }
}
\sstroutine{
   KPG1\_RGLMT
}{
   Get the range limits of a range specification
}{
   \sstdescription{
      This routine returns begin and end limits of a range specified by
      a range word.
   }
   \sstinvocation{
      CALL KPG1\_RGLMT( SCT, RNGWRD, BERNG, BELG, EDRNG, EDLG, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SCT = CHARACTER$*$($*$) (Given)
      }{
         String which specifies a range with the range word specified
         by argument RNGWRD.
      }
      \sstsubsection{
         RNAWRD = CHARACTER$*$($*$) (Given)
      }{
         Gives a range word, such as {\tt "}TO{\tt "}, {\tt "}-{\tt "}, etc, which is used in
         range specification.
      }
      \sstsubsection{
         BERNG = INTEGER (Returned)
      }{
         Begin limit of the range.
      }
      \sstsubsection{
         BELG = LOGICAL (Returned)
      }{
         If the begin limit of the range has been omitted. it equals
         true, otherwise, false.
      }
      \sstsubsection{
         EDRNG = INTEGER (Returned)
      }{
         End limit of the range.
      }
      \sstsubsection{
         EDLG = LOGINCAL (Returned)
      }{
         If the end limit of the range has been omitted, it equals true,
         otherwise, false.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_RGNDF
}{
   Get a group of existing NDFs
}{
   \sstdescription{
      The supplied parameter is used to get a GRP group expression (see
      SUN/150 ) holding a list of existing NDFs (the syntax of the
      group expression is defined by the current default GRP control
      characters).  If the group expression is flagged, then the
      current parameter value is cancelled, the string supplied in TEXT
      is displayed (if it is not blank) and another group expression is
      obtained. The NDFs specified by the second group expression are
      added to the group holding the NDFs specified by the first group
      expression. The group continues to be expanded in this way until
      a group expression is obtained which is not flagged, or a null
      value is given, or the limit on the number of NDFs (MAXSIZ) is
      reached. If any of the specified NDFs do not exist, the user is
      warned, and re-prompted. If the final group contains more than
      MAXSIZ NDFs, then all but the first MAXSIZ NDFs are removed from
      the group. The user is warned if this happens. If MAXSIZ is
      supplied with the value zero no limit is imposed on the number of
      NDFs within the group.  If the final group contains less than the
      minimum no. of NDFs specified by argument MINSIZ, then the user is
      asked to supply more NDFs. All messages issued by this routine
      have a priority level of MSG\_\_NORM.
   }
   \sstinvocation{
      CALL KPG1\_RGNDF( PARAM, MAXSIZ, MINSIZ, TEXT, IGRP, SIZE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The parameter (of type LITERAL).
      }
      \sstsubsection{
         MAXSIZ = INTEGER (Given)
      }{
         The maximum number of NDFs which can be allowed in the
         returned group. If zero is supplied, no limit is imposed.
      }
      \sstsubsection{
         MINSIZ = INTEGER (Given)
      }{
         The minimum number of NDFs which can be allowed in the
         returned group. If zero is supplied, then the returned group
         may contain no NDFs.
      }
      \sstsubsection{
         TEXT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The text to display between issuing prompts for successive
         group expressions. If blank then no text is displayed.
      }
      \sstsubsection{
         IGRP = INTEGER (Returned)
      }{
         The GRP identifier for the returned group holding all the
         specified NDFs. The group should be deleted using GRP\_DELET
         when it is no longer needed. If an error occurs, the value
         GRP\_\_NOID is returned.
      }
      \sstsubsection{
         SIZE = INTEGER (Returned)
      }{
         The number of files in the output group. SIZE is returned equal
         to 1 if STATUS is returned not equal to SAI\_\_OK.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_RMAPx
}{
   Remaps an array{\tt '}s values according to an histogram key
}{
   \sstdescription{
      This routine remaps all the values in an array onto new values,
      according to a key.  The key locates element values with
      respect to an histogram that has been transformed from a linear
      one, i.e. has equal-sized bins.  For example, in histogram
      equalisation the bin width varies so as to give approximately
      equal numbers of values in each bin.
   }
   \sstinvocation{
      CALL KPG1\_RMAPx( EL, INARR, VALMAX, VALMIN, NUMBIN, MAP, OUTARR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The array to be remapped.
      }
      \sstsubsection{
         VALMAX = ? (Given)
      }{
         Maximum value data value used to form the linear histogram.
         Data values greater than this will be set bad in the output
         array.
      }
      \sstsubsection{
         VALMIN = ? (Given)
      }{
         Minimum value data value used to form the linear histogram.
         Data values less than this will be set bad in the output
         array.
      }
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         Number of bins used in histogram.  A moderately large number of
         bins is recommended so that there is little artifactual
         quantisation is introduced, say a few thousand except for
         byte data.
      }
      \sstsubsection{
         MAP( NUMBIN ) = INTEGER (Given)
      }{
         The key to the transform of the linear histogram.  MAP stores
         the new bin number for each of the linear bin numbers.  A bin
         number in the linear histogram is defined by the fractional
         position between the minimum and maximum data values times the
         number of bins.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         The array containing the remapped values.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays and the histogram limits supplied to this routine must
         have the data type specified.
      }
   }
   \sstdiytopic{
      References
   }{
      Gonzalez, R.C. and Wintz, P., 1977, {\tt "}Digital Image Processing{\tt "},
      Addison-Wesley, pp. 118--126.
   }
}
\sstroutine{
   KPG1\_RMAPx
}{
   Remaps an array{\tt '}s values according to an histogram key
}{
   \sstdescription{
      This routine remaps all the values in an array onto new values,
      according to a key.  The key locates element values with
      respect to an histogram that has been transformed from a linear
      one, i.e. has equal-sized bins.  For example, in histogram
      equalisation the bin width varies so as to give approximately
      equal numbers of values in each bin.
   }
   \sstinvocation{
      CALL KPG1\_RMAPx( EL, INARR, VALMAX, VALMIN, NUMBIN, MAP, OUTARR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The array to be remapped.
      }
      \sstsubsection{
         VALMAX = ? (Given)
      }{
         Maximum value data value used to form the linear histogram.
         Data values greater than this will be set bad in the output
         array.
      }
      \sstsubsection{
         VALMIN = ? (Given)
      }{
         Minimum value data value used to form the linear histogram.
         Data values less than this will be set bad in the output
         array.
      }
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         Number of bins used in histogram.  A moderately large number of
         bins is recommended so that there is little artifactual
         quantisation is introduced, say a few thousand except for
         byte data.
      }
      \sstsubsection{
         MAP( NUMBIN ) = INTEGER (Given)
      }{
         The key to the transform of the linear histogram.  MAP stores
         the new bin number for each of the linear bin numbers.  A bin
         number in the linear histogram is defined by the fractional
         position between the minimum and maximum data values times the
         number of bins.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         The array containing the remapped values.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays and the histogram limits supplied to this routine must
         have the data type specified.
      }
   }
   \sstdiytopic{
      References
   }{
      Gonzalez, R.C. and Wintz, P., 1977, {\tt "}Digital Image Processing{\tt "},
      Addison-Wesley, pp. 118--126.
   }
}
\sstroutine{
   KPG1\_RMAPx
}{
   Remaps an array{\tt '}s values according to an histogram key
}{
   \sstdescription{
      This routine remaps all the values in an array onto new values,
      according to a key.  The key locates element values with
      respect to an histogram that has been transformed from a linear
      one, i.e. has equal-sized bins.  For example, in histogram
      equalisation the bin width varies so as to give approximately
      equal numbers of values in each bin.
   }
   \sstinvocation{
      CALL KPG1\_RMAPx( EL, INARR, VALMAX, VALMIN, NUMBIN, MAP, OUTARR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The array to be remapped.
      }
      \sstsubsection{
         VALMAX = ? (Given)
      }{
         Maximum value data value used to form the linear histogram.
         Data values greater than this will be set bad in the output
         array.
      }
      \sstsubsection{
         VALMIN = ? (Given)
      }{
         Minimum value data value used to form the linear histogram.
         Data values less than this will be set bad in the output
         array.
      }
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         Number of bins used in histogram.  A moderately large number of
         bins is recommended so that there is little artifactual
         quantisation is introduced, say a few thousand except for
         byte data.
      }
      \sstsubsection{
         MAP( NUMBIN ) = INTEGER (Given)
      }{
         The key to the transform of the linear histogram.  MAP stores
         the new bin number for each of the linear bin numbers.  A bin
         number in the linear histogram is defined by the fractional
         position between the minimum and maximum data values times the
         number of bins.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         The array containing the remapped values.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays and the histogram limits supplied to this routine must
         have the data type specified.
      }
   }
   \sstdiytopic{
      References
   }{
      Gonzalez, R.C. and Wintz, P., 1977, {\tt "}Digital Image Processing{\tt "},
      Addison-Wesley, pp. 118--126.
   }
}
\sstroutine{
   KPG1\_RMAPx
}{
   Remaps an array{\tt '}s values according to an histogram key
}{
   \sstdescription{
      This routine remaps all the values in an array onto new values,
      according to a key.  The key locates element values with
      respect to an histogram that has been transformed from a linear
      one, i.e. has equal-sized bins.  For example, in histogram
      equalisation the bin width varies so as to give approximately
      equal numbers of values in each bin.
   }
   \sstinvocation{
      CALL KPG1\_RMAPx( EL, INARR, VALMAX, VALMIN, NUMBIN, MAP, OUTARR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The array to be remapped.
      }
      \sstsubsection{
         VALMAX = ? (Given)
      }{
         Maximum value data value used to form the linear histogram.
         Data values greater than this will be set bad in the output
         array.
      }
      \sstsubsection{
         VALMIN = ? (Given)
      }{
         Minimum value data value used to form the linear histogram.
         Data values less than this will be set bad in the output
         array.
      }
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         Number of bins used in histogram.  A moderately large number of
         bins is recommended so that there is little artifactual
         quantisation is introduced, say a few thousand except for
         byte data.
      }
      \sstsubsection{
         MAP( NUMBIN ) = INTEGER (Given)
      }{
         The key to the transform of the linear histogram.  MAP stores
         the new bin number for each of the linear bin numbers.  A bin
         number in the linear histogram is defined by the fractional
         position between the minimum and maximum data values times the
         number of bins.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         The array containing the remapped values.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays and the histogram limits supplied to this routine must
         have the data type specified.
      }
   }
   \sstdiytopic{
      References
   }{
      Gonzalez, R.C. and Wintz, P., 1977, {\tt "}Digital Image Processing{\tt "},
      Addison-Wesley, pp. 118--126.
   }
}
\sstroutine{
   KPG1\_RMAPx
}{
   Remaps an array{\tt '}s values according to an histogram key
}{
   \sstdescription{
      This routine remaps all the values in an array onto new values,
      according to a key.  The key locates element values with
      respect to an histogram that has been transformed from a linear
      one, i.e. has equal-sized bins.  For example, in histogram
      equalisation the bin width varies so as to give approximately
      equal numbers of values in each bin.
   }
   \sstinvocation{
      CALL KPG1\_RMAPx( EL, INARR, VALMAX, VALMIN, NUMBIN, MAP, OUTARR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The array to be remapped.
      }
      \sstsubsection{
         VALMAX = ? (Given)
      }{
         Maximum value data value used to form the linear histogram.
         Data values greater than this will be set bad in the output
         array.
      }
      \sstsubsection{
         VALMIN = ? (Given)
      }{
         Minimum value data value used to form the linear histogram.
         Data values less than this will be set bad in the output
         array.
      }
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         Number of bins used in histogram.  A moderately large number of
         bins is recommended so that there is little artifactual
         quantisation is introduced, say a few thousand except for
         byte data.
      }
      \sstsubsection{
         MAP( NUMBIN ) = INTEGER (Given)
      }{
         The key to the transform of the linear histogram.  MAP stores
         the new bin number for each of the linear bin numbers.  A bin
         number in the linear histogram is defined by the fractional
         position between the minimum and maximum data values times the
         number of bins.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         The array containing the remapped values.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays and the histogram limits supplied to this routine must
         have the data type specified.
      }
   }
   \sstdiytopic{
      References
   }{
      Gonzalez, R.C. and Wintz, P., 1977, {\tt "}Digital Image Processing{\tt "},
      Addison-Wesley, pp. 118--126.
   }
}
\sstroutine{
   KPG1\_RMAPx
}{
   Remaps an array{\tt '}s values according to an histogram key
}{
   \sstdescription{
      This routine remaps all the values in an array onto new values,
      according to a key.  The key locates element values with
      respect to an histogram that has been transformed from a linear
      one, i.e. has equal-sized bins.  For example, in histogram
      equalisation the bin width varies so as to give approximately
      equal numbers of values in each bin.
   }
   \sstinvocation{
      CALL KPG1\_RMAPx( EL, INARR, VALMAX, VALMIN, NUMBIN, MAP, OUTARR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The array to be remapped.
      }
      \sstsubsection{
         VALMAX = ? (Given)
      }{
         Maximum value data value used to form the linear histogram.
         Data values greater than this will be set bad in the output
         array.
      }
      \sstsubsection{
         VALMIN = ? (Given)
      }{
         Minimum value data value used to form the linear histogram.
         Data values less than this will be set bad in the output
         array.
      }
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         Number of bins used in histogram.  A moderately large number of
         bins is recommended so that there is little artifactual
         quantisation is introduced, say a few thousand except for
         byte data.
      }
      \sstsubsection{
         MAP( NUMBIN ) = INTEGER (Given)
      }{
         The key to the transform of the linear histogram.  MAP stores
         the new bin number for each of the linear bin numbers.  A bin
         number in the linear histogram is defined by the fractional
         position between the minimum and maximum data values times the
         number of bins.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         The array containing the remapped values.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays and the histogram limits supplied to this routine must
         have the data type specified.
      }
   }
   \sstdiytopic{
      References
   }{
      Gonzalez, R.C. and Wintz, P., 1977, {\tt "}Digital Image Processing{\tt "},
      Addison-Wesley, pp. 118--126.
   }
}
\sstroutine{
   KPG1\_RMAPx
}{
   Remaps an array{\tt '}s values according to an histogram key
}{
   \sstdescription{
      This routine remaps all the values in an array onto new values,
      according to a key.  The key locates element values with
      respect to an histogram that has been transformed from a linear
      one, i.e. has equal-sized bins.  For example, in histogram
      equalisation the bin width varies so as to give approximately
      equal numbers of values in each bin.
   }
   \sstinvocation{
      CALL KPG1\_RMAPx( EL, INARR, VALMAX, VALMIN, NUMBIN, MAP, OUTARR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The dimension of the arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         The array to be remapped.
      }
      \sstsubsection{
         VALMAX = ? (Given)
      }{
         Maximum value data value used to form the linear histogram.
         Data values greater than this will be set bad in the output
         array.
      }
      \sstsubsection{
         VALMIN = ? (Given)
      }{
         Minimum value data value used to form the linear histogram.
         Data values less than this will be set bad in the output
         array.
      }
      \sstsubsection{
         NUMBIN = INTEGER (Given)
      }{
         Number of bins used in histogram.  A moderately large number of
         bins is recommended so that there is little artifactual
         quantisation is introduced, say a few thousand except for
         byte data.
      }
      \sstsubsection{
         MAP( NUMBIN ) = INTEGER (Given)
      }{
         The key to the transform of the linear histogram.  MAP stores
         the new bin number for each of the linear bin numbers.  A bin
         number in the linear histogram is defined by the fractional
         position between the minimum and maximum data values times the
         number of bins.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         The array containing the remapped values.
      }
      \sstsubsection{
         STATUS = INTEGER  (Given)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays and the histogram limits supplied to this routine must
         have the data type specified.
      }
   }
   \sstdiytopic{
      References
   }{
      Gonzalez, R.C. and Wintz, P., 1977, {\tt "}Digital Image Processing{\tt "},
      Addison-Wesley, pp. 118--126.
   }
}
\sstroutine{
   KPG1\_SATKC
}{
   Substitutes alphabetic (TRANSFORM) character tokens into a string
}{
   \sstdescription{
      This routine parses the expression in EXPRES looking for
      tokens of the name PREFIX//[A-Z].  If one is located an attempt
      to access a value for this tokens if made using the ADAM
      parameter PREFIX//[A-Z].  If a value is obtained then it is
      substituted into the string EXPRES.

      New character tokens (functions) may contain references to
      other character tokens which will be either prompted for, or,
      if it is a token which has already been given a value this will
      be substituted.
   }
   \sstinvocation{
      CALL KPG1\_SATKC( PREFIX, EXPRES, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PREFIX = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The prefix of the tokens.  Valid tokens are ones with any
         trailing single alphabetic character.
      }
      \sstsubsection{
         EXPRES = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         On entry this contains a TRANSFORM algebraic-like expression
         which may contain tokens which need to be substituted by other
         expressions (functions).  References to other functions within
         functions are allowed and prompts will be made until all
         tokens are absent from the expression, however, later uses of
         the same tokens will be replaced with the same value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_SATKD
}{
   Substitutes alphabetic (TRANSFORM) numeric tokens into a string
}{
   \sstdescription{
      This routine parses the expression in EXPRES looking for
      tokens of the name PREFIX//[A-Z].  If one is located an attempt
      to access a value for this tokens if made using the ADAM
      parameter PREFIX//[A-Z].  If a value is obtained then it is
      substituted into the string EXPRES.
   }
   \sstinvocation{
      CALL KPG1\_SATKD( PREFIX, EXPRES, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PREFIX = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The prefix of the tokens. Valid tokens are ones with any
         trailing single alphabetic character.
      }
      \sstsubsection{
         EXPRES = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         On entry this contains a TRANSFORM algebraic-like expression
         which may contain tokens which need to be substituted either
         for values (constants).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_SCLOF
}{
   Applies a simple scaling and base-line shift to the values
   contained in the input vector
}{
   \sstdescription{
      The input data values are multiplied by the given factor and
      the given offset is then added on, to form the output data.
   }
   \sstinvocation{
      CALL KPG1\_SCLOF( IN, EL, FACTOR, OFFSET, OUT, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IN( EL ) = REAL (Given)
      }{
         The input data vector.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the input and output vectors.
      }
      \sstsubsection{
         FACTOR = DOUBLE PRECISION (Given)
      }{
         The factor by which the input valus are scaled.
      }
      \sstsubsection{
         OFFSET = DOUBLE PRECISION (Given)
      }{
         The offset by which the data values are shifted.
      }
      \sstsubsection{
         OUT( EL ) = REAL (Given)
      }{
         The output data vector.
      }
      \sstsubsection{
         BAD = LOGICAL (Returned)
      }{
         True if any bad pixels found.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_SCRSZ
}{
   Interrogates the system to find the width and height of the screen
   on which it is running
}{
   \sstdescription{
      This routine interrogates the system to find the width and height of the screen
      on which it is running.  Should an error occur or the width is
      not positive, set to the default of 80 characters by 24 lines.
   }
   \sstinvocation{
      CALL KPG1\_SCRSZ( WIDTH, HEIGHT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         WIDTH = INTEGER (Returned)
      }{
         The width of the screen in characters.
      }
      \sstsubsection{
         HEIGHT = INTEGER (Returned)
      }{
         The height of the screen in lines.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This is the UNIX version.
      }
   }
}
\sstroutine{
   KPG1\_SDIMP
}{
   Obtains up to a number of significant dimensions of an NDF
}{
   \sstdescription{
      This routine finds the dimensions which are significant in an
      NDF, i.e. those with greater than one element.  The significant
      dimensions are recorded and returned.  If the number of
      significant dimensions found is less than a specified value, the
      insignificant dimensions pad out the array of dimension indices
      returned; and all the dimensions are returned in order of
      increasing dimensionality.  However, should the number of
      significant dimensions exceed the required number a bad status,
      SAI\_ERROR, is returned.  Likewise there is an error when there
      are no significant dimensions.
   }
   \sstinvocation{
      CALL KPG1\_SDIMP( NDF, NDIM, DIMV, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDF = INTEGER (Given)
      }{
         The NDF identifier.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The desired number of dimensions.
      }
      \sstsubsection{
         DIMV( NDIM ) = INTEGER (Returned)
      }{
         The significant dimensions i.e. the ones that are greater than
         one.  There is an execption when there are fewer than NDIM
         present in the NDF, whereupon this array includes in dimension
         order those that are insignificant too.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         The NDF must exist.
      }
   }
}
\sstroutine{
   KPG1\_SDTRN
}{
   Saves the current SGS zone as a data picture and a reference to
   the data object that was used to create it
}{
   \sstdescription{
      This routine takes the current zone and saves it with the
      specified label into the graphics database.  A data object that
      was used to generate the picture is stored by reference in the
      database, associated with the data picture.
   }
   \sstinvocation{
      CALL KPG1\_SDTRN( LABEL, NDF, PICID, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LABEL = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The label for the data picture.
      }
      \sstsubsection{
         NDF = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The NDF identifier of the data object.
      }
      \sstsubsection{
         PICID = INTEGER (Returned)
      }{
         The picture identifier of the data picture.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         The AGI SGS interface must be active.

         \sstitem
         The data object give by the parameter name should still be
         associated to prevent reprompting.
      }
   }
}
\sstroutine{
   KPG1\_SECSH
}{
   Shifts bounds of upper dimensions that have one element to index
   one
}{
   \sstdescription{
      This routine shifts the origin to the default of one of each
      dimension of an NDF greater than a nominated dimension and whose
      size is one.

      The routine is required in applications that require NDFs of a
      specific dimensionality and which also call NDF\_SECT.  This is
      because a user-defined section may be from an NDF of higher
      dimensionality, and a subsequent call to NDF\_SECT can result in
      an array of bad data, when the bounds of higher dimensions are
      not one.  It is intended to be used alongside KPG1\_SGDIM.
   }
   \sstinvocation{
      CALL KPG1\_SECSH( NDF, MXDIM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDF = INTEGER (Given)
      }{
         The NDF identifier.
      }
      \sstsubsection{
         MXDIM = INTEGER (Given)
      }{
         The dimension above which the shifts are to be made.  This
         should be the last significant bound for the required
         dimensionality of NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_SEED
}{
   Obtain a semi-random seed for random-number generation
}{
   \sstdescription{
      This function uses the computer time from an arbitrary date, plus
      the current process id., to generate a non-repeatable seed.
   }
   \sstinvocation{
      RESULT = KPG1\_SEED( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         KPG1\_SEED = REAL
      }{
         The non-repeatable seed for use in SLA\_RANDOM.  Note that
         it is not necessarily in the range 0 to 1.
      }
   }
}
\sstroutine{
   KPG1\_SGDIG
}{
   Determines the number of significant digits in a number
}{
   \sstdescription{
      This routine takes a string containing a numerical value, and
      counts the number of significant digits in the value.  Thus
      leading and trailing zeroes are excluded.
   }
   \sstinvocation{
      CALL KPG1\_SGDIG( STRING, NSDIG, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STRING = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The string containing the numerical value.  An error is
         returned if the value cannot be converted to a double-precision
         value without error.
      }
      \sstsubsection{
         NSDIG = INTEGER (Returned)
      }{
         The number of significant digits in the string if it is treated
         as a numerical value.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_SGDIM
}{
   Determines the number of significant dimensions in an NDF
}{
   \sstdescription{
      This routine finds the number of significant dimensions, i.e.
      those with greater than one element, in an NDF.  If the number
      found is not equal to a specified number a bad status, SAI\_ERROR,
      is returned.  Likewise should there be no significant dimensions.
      The significant dimensions are recorded and returned.
   }
   \sstinvocation{
      CALL KPG1\_SGDIM( NDF, NDIM, DIMV, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDF = INTEGER (Given)
      }{
         The NDF identifier.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         The desired number of dimensions.
      }
      \sstsubsection{
         DIMV( NDIM ) = INTEGER (Returned)
      }{
         The significant dimensions i.e. the ones that are greater than
         one.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         The NDF must exist.
      }
   }
}
\sstroutine{
   KPG1\_SHORT
}{
   Check whether a string matches a supplied abbreviation template
}{
   \sstdescription{
      This routine returns .TRUE. if the supplied test string matches
      the supplied abbreviation template. All characters in the template
      must be matched by the corresponding characters in the test string,
      with the exception that it is permissable for the test string to end
      anywhere following the first occurrence of the mark string (the
      mark string itself should not be matched in the test string). The
      template sub-string in front of the first mark string thus gives
      the minimum abbreviation which the test string can use.

      For instance, if MARK={\tt '}$*${\tt '} and TEMPLT={\tt '}VECT$*$ORS{\tt '}, then the test string
      matches if the first 4 characters are {\tt '}VECT{\tt '} and any remaining
      characters match {\tt '}ORS{\tt '}.
   }
   \sstinvocation{
      RESULT = KPG1\_SHORT( TEMPLT, TEST, MARK, CASE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         TEMPLT = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The abbreviation template. Trailing blanks are ignored.
      }
      \sstsubsection{
         TEST = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The test string. Trailing blanks are ignored.
      }
      \sstsubsection{
         MARK = CHARACTER $*$ ( $*$ ) (Given and Returned)
      }{
         The string which marks the end of the minimum abbreviation in
         TEMPLT. Trailing blanks are ignored.
      }
      \sstsubsection{
         CASE = LOGICAL (Given)
      }{
         Should the match be case sensitive?
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Function Value
   }{
      KPG1\_SHORT = LOGICAL
         Returned .TRUE. if and only if the supplied test string matches the
         template.
   }
}
\sstroutine{
   KPG1\_SLICE
}{
   Find and remove any NDF slice specification from a name
}{
   \sstdescription{
      A slice specification is taken to be anything between the first
      opening and the first closing parenthesis, so long as the closing
      parentheis is the last character in the name.
   }
   \sstinvocation{
      CALL KPG1\_SLICE( NAME, SLICE, START, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NAME = CHARACTER (Given and Returtned)
      }{
         The name to be checked.  On exit, any NDF slice specification
         contained in the name on entry, is removed.
      }
      \sstsubsection{
         SLICE = CHARACTER (Returned)
      }{
         The slice specification including opening and closing
         parenthesise.  If the input name contains no slice
         specification, then SLICE is returned blank.
      }
      \sstsubsection{
         START = INTEGER (Returned)
      }{
         The position (within the original name) of the opening
         parethesis.  If the name does not containa slice specification,
         then START is returned pointing to the first character beyond
         the end of the name.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_SNKTA
}{
   Write AST\_ data as text to a GRP group
}{
   \sstdescription{
      This is a service routine to be provided as a {\tt "}sink{\tt "} routine for
      the AST\_CHANNEL function. It takes data in the form of text (in
      response to writing an AST\_ object to a Channel) and delivers it
      to a GRP group for storage.

      This routine has only a STATUS argument, so it communicates with
      other KPG routines via global variables stored in the KPG\_AST
      common blocks. These are described below under {\tt "}Global Variables
      used as Arguments{\tt "}.
   }
   \sstinvocation{
      CALL KPG1\_SNKTA( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Global Variables used as Arguments
   }{
      ASTGRP = INTEGER (Given)
         A GRP identifier for the group which is to store the data.
      ASTTSZ = INTEGER (Given)
         The maximum length of text which should be stored in a single
         element of the group. This should be less than or equal to
         GRP\_\_SZNAM.
      ASTLN = INTEGER (Given and Returned)
         This must initially be set to the value 1, to indicate that
         data will be written starting at the first element of the
         group (note the routine will not operate correctly unless 1 is
         the initial value - you cannot start writing at another point
         in the group if you have previously written to a different
         group). On exit it will be incremented by the number of
         elements used to store data, so that it identifies the first
         element to be used on the next invocation.
   }
}
\sstroutine{
   KPG1\_SOLIN
}{
   Sets the GKS line type to solid for all polylines
}{
   \sstdescription{
      The routine sets the linetype of the current workstation to
      solid for all polylines by setting the aspect source flag
      to individual.
   }
   \sstinvocation{
      CALL KPG1\_SOLIN( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      A GKS workstation should be open and active.
   }
}
\sstroutine{
   KPG1\_SQSUx
}{
   Finds the sum of the squares of an array
}{
   \sstdescription{
      This routine sums the squares of a supplied array and return the
      sum.  This might used to sum the residuals for a minimisation.
      Bad values are ignored.
   }
   \sstinvocation{
      CALL KPG1\_SQSUx( EL, ARRAY, SUMSQ, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array to sum.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         The array whose sqaured values are to be summed.
      }
      \sstsubsection{
         SUMSQ = ? (Returned)
      }{
         The sum of the squared array values.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for integer, real, and double precision data
      types: replace {\tt "}x{\tt "} in the routine name by I, R, or D respectively.
      The ARRAY and SUMSQ arguments supplied to the routine must have
      the data type specified.
   }
}
\sstroutine{
   KPG1\_SQSUx
}{
   Finds the sum of the squares of an array
}{
   \sstdescription{
      This routine sums the squares of a supplied array and return the
      sum.  This might used to sum the residuals for a minimisation.
      Bad values are ignored.
   }
   \sstinvocation{
      CALL KPG1\_SQSUx( EL, ARRAY, SUMSQ, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array to sum.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         The array whose sqaured values are to be summed.
      }
      \sstsubsection{
         SUMSQ = ? (Returned)
      }{
         The sum of the squared array values.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for integer, real, and double precision data
      types: replace {\tt "}x{\tt "} in the routine name by I, R, or D respectively.
      The ARRAY and SUMSQ arguments supplied to the routine must have
      the data type specified.
   }
}
\sstroutine{
   KPG1\_SQSUx
}{
   Finds the sum of the squares of an array
}{
   \sstdescription{
      This routine sums the squares of a supplied array and return the
      sum.  This might used to sum the residuals for a minimisation.
      Bad values are ignored.
   }
   \sstinvocation{
      CALL KPG1\_SQSUx( EL, ARRAY, SUMSQ, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array to sum.
      }
      \sstsubsection{
         ARRAY( EL ) = ? (Given)
      }{
         The array whose sqaured values are to be summed.
      }
      \sstsubsection{
         SUMSQ = ? (Returned)
      }{
         The sum of the squared array values.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for integer, real, and double precision data
      types: replace {\tt "}x{\tt "} in the routine name by I, R, or D respectively.
      The ARRAY and SUMSQ arguments supplied to the routine must have
      the data type specified.
   }
}
\sstroutine{
   KPG1\_SRCTA
}{
   Read AST\_ data as text from a GRP group
}{
   \sstdescription{
      This is a service routine to be provided as a {\tt "}source{\tt "} routine
      for the AST\_CHANNEL function. It reads data from a GRP group
      (in response to reading from an AST\_ Channel) and delivers it to
      the AST\_ library for interpretation.

      This routine has only a STATUS argument, so it communicates with
      other KPG routines via global variables stored in the KPG\_AST common
      blocks. These are described below under {\tt "}Global Variables used as
      Arguments{\tt "}.
   }
   \sstinvocation{
      CALL KPG1\_SRCTA( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Global Variables used as Arguments
   }{
      ASTGRP = INTEGER (Given)
         A GRP identifier for the group which holds the data.
      ASTLN = INTEGER (Given and Returned)
         This must initially be set to the value 1, to indicate that
         data will be read starting at the first element of the group
         (note the routine will not operate correctly unless 1 is
         the initial value - you cannot start reading at another point
         in the group if you have previously read from a different
         group). On exit it will be incremented by the number of
         elements used to obtain data, so that it identifies the first
         element to be used on the next invocation.
      ASTTSZ = INTEGER (Given)
         The number of characters to use from each GRP element.
   }
}
\sstroutine{
   KPG1\_SSAZx
}{
   Applies a simple scaling and base-line shift to create the
   output vector
}{
   \sstdescription{
      Pixel indices are multiplied by the given factor and
      the given offset is then added on, to form the output data.
      The first pixel has a value equal to the offset.
   }
   \sstinvocation{
      CALL KPG1\_SSAZx( EL, FACTOR, OFFSET, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number elements in the returned array.
      }
      \sstsubsection{
         FACTOR = DOUBLE PRECISION (Given)
      }{
         The factor by which the array indices are scaled.
      }
      \sstsubsection{
         OFFSET = DOUBLE PRECISION (Given)
      }{
         The offset by which the array indices are shifted.
      }
      \sstsubsection{
         OUT( EL ) = ? (Returned)
      }{
         The output data vector.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the data types real or double precision:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively, as
         appropriate.  The returned array should be of the same type.

         \sstitem
         There is no exception handler if the evaluated value exceeds the
         machine floating-point range.
      }
   }
}
\sstroutine{
   KPG1\_SSAZx
}{
   Applies a simple scaling and base-line shift to create the
   output vector
}{
   \sstdescription{
      Pixel indices are multiplied by the given factor and
      the given offset is then added on, to form the output data.
      The first pixel has a value equal to the offset.
   }
   \sstinvocation{
      CALL KPG1\_SSAZx( EL, FACTOR, OFFSET, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number elements in the returned array.
      }
      \sstsubsection{
         FACTOR = DOUBLE PRECISION (Given)
      }{
         The factor by which the array indices are scaled.
      }
      \sstsubsection{
         OFFSET = DOUBLE PRECISION (Given)
      }{
         The offset by which the array indices are shifted.
      }
      \sstsubsection{
         OUT( EL ) = ? (Returned)
      }{
         The output data vector.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the data types real or double precision:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively, as
         appropriate.  The returned array should be of the same type.

         \sstitem
         There is no exception handler if the evaluated value exceeds the
         machine floating-point range.
      }
   }
}
\sstroutine{
   KPG1\_SSCOF
}{
   Applies a simple scaling and base-line shift to create the
   output vector
}{
   \sstdescription{
      Pixel indices are multiplied by the given factor and
      the given offset is then added on, to form the output data.
      The first pixel has value equal to the offset.
   }
   \sstinvocation{
      CALL KPG1\_SSCOF( EL, FACTOR, OFFSET, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number elements in the returned array.
      }
      \sstsubsection{
         FACTOR = DOUBLE PRECISION (Given)
      }{
         The factor by which the array indices are scaled.
      }
      \sstsubsection{
         OFFSET = DOUBLE PRECISION (Given)
      }{
         The offset by which the array indices are shifted.
      }
      \sstsubsection{
         OUT( EL ) = REAL (Given)
      }{
         The output data vector.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is no exception handler if the evaluated value exceeds the
      machine floating-pint range.
   }
}
\sstroutine{
   KPG1\_STATB
}{
   Compute simple statistics for an array
}{
   \sstdescription{
      This routine computes simple statistics for an array, namely: the
      number of valid pixels, the minimum and maximum pixel values (and
      their positions), the pixel sum, the mean, and the standard
      deviation. Iterative K-sigma clipping may also be optionally
      applied.
   }
   \sstinvocation{
      CALL KPG1\_STATB( BAD, EL, DATA, NCLIP, CLIP, NGOOD, IMIN, DMIN,
                       IMAX, DMAX, SUM, MEAN, STDEV, NGOODC, IMINC,
                       DMINC, IMAXC, DMAXC, SUMC, MEANC, STDEVC,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether checks for bad pixels should be performed on the array
         being analysed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of pixels in the array.
      }
      \sstsubsection{
         DATA( EL ) = BYTE (Given)
      }{
         Array to be analysed.
      }
      \sstsubsection{
         NCLIP = INTEGER (Given)
      }{
         Number of K-sigma clipping iterations to apply (may be zero).
      }
      \sstsubsection{
         CLIP( NCLIP ) = REAL (Given)
      }{
         Array of clipping limits for successive iterations, expressed
         as standard deviations.
      }
      \sstsubsection{
         NGOOD = INTEGER (Returned)
      }{
         Number of valid pixels in the array before clipping.
      }
      \sstsubsection{
         IMIN = INTEGER (Returned)
      }{
         Index where the pixel with the lowest value was (first) found
         before clipping.
      }
      \sstsubsection{
         DMIN = DOUBLE PRECISION (Returned)
      }{
         Minimum pixel value in the array before clipping.
      }
      \sstsubsection{
         IMAX = INTEGER (Returned)
      }{
         Index where the pixel with the highest value was (first) found
         before clipping.
      }
      \sstsubsection{
         DMAX = DOUBLE PRECISION (Returned)
      }{
         Maximum pixel value in the array before clipping.
      }
      \sstsubsection{
         SUM = DOUBLE PRECISION (Returned)
      }{
         Sum of the valid pixels before clipping.
      }
      \sstsubsection{
         MEAN = DOUBLE PRECISION (Returned)
      }{
         Mean of the valid pixels before clipping.
      }
      \sstsubsection{
         STDEV = DOUBLE PRECISION (Returned)
      }{
         Standard deviation of the valid pixels before clipping.
      }
      \sstsubsection{
         NGOODC = INTEGER (Returned)
      }{
         Number of valid pixels in the array after clipping.
      }
      \sstsubsection{
         IMINC = INTEGER (Returned)
      }{
         Index where the pixel with the lowest value was (first) found
         after clipping.
      }
      \sstsubsection{
         DMINC = DOUBLE PRECISION (Returned)
      }{
         Minimum pixel value in the array after clipping.
      }
      \sstsubsection{
         IMAXC = INTEGER (Returned)
      }{
         Index where the pixel with the highest value was (first) found
         after clipping.
      }
      \sstsubsection{
         DMAXC = DOUBLE PRECISION (Returned)
      }{
         Maximum pixel value in the array after clipping.
      }
      \sstsubsection{
         SUMC = DOUBLE PRECISION (Returned)
      }{
         Sum of the valid pixels after clipping.
      }
      \sstsubsection{
         MEANC = DOUBLE PRECISION (Returned)
      }{
         Mean of the valid pixels after clipping.
      }
      \sstsubsection{
         STDEVC = DOUBLE PRECISION (Returned)
      }{
         Standard deviation of the valid pixels after clipping.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If no clipping is performed (i.e. if NCLIP = 0) then the values
         of arguments which return results after clipping will be the same
         as for those returning results before clipping.

         \sstitem
         If NGOOD or NGOODC is zero, then the values of all the derived
         statistics will be undefined and will be set to the {\tt "}bad{\tt "} value
         appropriate to their data type (except for the pixel sum, which
         will be zero).
      }
   }
}
\sstroutine{
   KPG1\_STATD
}{
   Compute simple statistics for an array
}{
   \sstdescription{
      This routine computes simple statistics for an array, namely: the
      number of valid pixels, the minimum and maximum pixel values (and
      their positions), the pixel sum, the mean, and the standard
      deviation. Iterative K-sigma clipping may also be optionally
      applied.
   }
   \sstinvocation{
      CALL KPG1\_STATD( BAD, EL, DATA, NCLIP, CLIP, NGOOD, IMIN, DMIN,
                       IMAX, DMAX, SUM, MEAN, STDEV, NGOODC, IMINC,
                       DMINC, IMAXC, DMAXC, SUMC, MEANC, STDEVC,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether checks for bad pixels should be performed on the array
         being analysed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of pixels in the array.
      }
      \sstsubsection{
         DATA( EL ) = DOUBLE PRECISION (Given)
      }{
         Array to be analysed.
      }
      \sstsubsection{
         NCLIP = INTEGER (Given)
      }{
         Number of K-sigma clipping iterations to apply (may be zero).
      }
      \sstsubsection{
         CLIP( NCLIP ) = REAL (Given)
      }{
         Array of clipping limits for successive iterations, expressed
         as standard deviations.
      }
      \sstsubsection{
         NGOOD = INTEGER (Returned)
      }{
         Number of valid pixels in the array before clipping.
      }
      \sstsubsection{
         IMIN = INTEGER (Returned)
      }{
         Index where the pixel with the lowest value was (first) found
         before clipping.
      }
      \sstsubsection{
         DMIN = DOUBLE PRECISION (Returned)
      }{
         Minimum pixel value in the array before clipping.
      }
      \sstsubsection{
         IMAX = INTEGER (Returned)
      }{
         Index where the pixel with the highest value was (first) found
         before clipping.
      }
      \sstsubsection{
         DMAX = DOUBLE PRECISION (Returned)
      }{
         Maximum pixel value in the array before clipping.
      }
      \sstsubsection{
         SUM = DOUBLE PRECISION (Returned)
      }{
         Sum of the valid pixels before clipping.
      }
      \sstsubsection{
         MEAN = DOUBLE PRECISION (Returned)
      }{
         Mean of the valid pixels before clipping.
      }
      \sstsubsection{
         STDEV = DOUBLE PRECISION (Returned)
      }{
         Standard deviation of the valid pixels before clipping.
      }
      \sstsubsection{
         NGOODC = INTEGER (Returned)
      }{
         Number of valid pixels in the array after clipping.
      }
      \sstsubsection{
         IMINC = INTEGER (Returned)
      }{
         Index where the pixel with the lowest value was (first) found
         after clipping.
      }
      \sstsubsection{
         DMINC = DOUBLE PRECISION (Returned)
      }{
         Minimum pixel value in the array after clipping.
      }
      \sstsubsection{
         IMAXC = INTEGER (Returned)
      }{
         Index where the pixel with the highest value was (first) found
         after clipping.
      }
      \sstsubsection{
         DMAXC = DOUBLE PRECISION (Returned)
      }{
         Maximum pixel value in the array after clipping.
      }
      \sstsubsection{
         SUMC = DOUBLE PRECISION (Returned)
      }{
         Sum of the valid pixels after clipping.
      }
      \sstsubsection{
         MEANC = DOUBLE PRECISION (Returned)
      }{
         Mean of the valid pixels after clipping.
      }
      \sstsubsection{
         STDEVC = DOUBLE PRECISION (Returned)
      }{
         Standard deviation of the valid pixels after clipping.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If no clipping is performed (i.e. if NCLIP = 0) then the values
         of arguments which return results after clipping will be the same
         as for those returning results before clipping.

         \sstitem
         If NGOOD or NGOODC is zero, then the values of all the derived
         statistics will be undefined and will be set to the {\tt "}bad{\tt "} value
         appropriate to their data type (except for the pixel sum, which
         will be zero).
      }
   }
}
\sstroutine{
   KPG1\_STATI
}{
   Compute simple statistics for an array
}{
   \sstdescription{
      This routine computes simple statistics for an array, namely: the
      number of valid pixels, the minimum and maximum pixel values (and
      their positions), the pixel sum, the mean, and the standard
      deviation. Iterative K-sigma clipping may also be optionally
      applied.
   }
   \sstinvocation{
      CALL KPG1\_STATI( BAD, EL, DATA, NCLIP, CLIP, NGOOD, IMIN, DMIN,
                       IMAX, DMAX, SUM, MEAN, STDEV, NGOODC, IMINC,
                       DMINC, IMAXC, DMAXC, SUMC, MEANC, STDEVC,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether checks for bad pixels should be performed on the array
         being analysed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of pixels in the array.
      }
      \sstsubsection{
         DATA( EL ) = INTEGER (Given)
      }{
         Array to be analysed.
      }
      \sstsubsection{
         NCLIP = INTEGER (Given)
      }{
         Number of K-sigma clipping iterations to apply (may be zero).
      }
      \sstsubsection{
         CLIP( NCLIP ) = REAL (Given)
      }{
         Array of clipping limits for successive iterations, expressed
         as standard deviations.
      }
      \sstsubsection{
         NGOOD = INTEGER (Returned)
      }{
         Number of valid pixels in the array before clipping.
      }
      \sstsubsection{
         IMIN = INTEGER (Returned)
      }{
         Index where the pixel with the lowest value was (first) found
         before clipping.
      }
      \sstsubsection{
         DMIN = DOUBLE PRECISION (Returned)
      }{
         Minimum pixel value in the array before clipping.
      }
      \sstsubsection{
         IMAX = INTEGER (Returned)
      }{
         Index where the pixel with the highest value was (first) found
         before clipping.
      }
      \sstsubsection{
         DMAX = DOUBLE PRECISION (Returned)
      }{
         Maximum pixel value in the array before clipping.
      }
      \sstsubsection{
         SUM = DOUBLE PRECISION (Returned)
      }{
         Sum of the valid pixels before clipping.
      }
      \sstsubsection{
         MEAN = DOUBLE PRECISION (Returned)
      }{
         Mean of the valid pixels before clipping.
      }
      \sstsubsection{
         STDEV = DOUBLE PRECISION (Returned)
      }{
         Standard deviation of the valid pixels before clipping.
      }
      \sstsubsection{
         NGOODC = INTEGER (Returned)
      }{
         Number of valid pixels in the array after clipping.
      }
      \sstsubsection{
         IMINC = INTEGER (Returned)
      }{
         Index where the pixel with the lowest value was (first) found
         after clipping.
      }
      \sstsubsection{
         DMINC = DOUBLE PRECISION (Returned)
      }{
         Minimum pixel value in the array after clipping.
      }
      \sstsubsection{
         IMAXC = INTEGER (Returned)
      }{
         Index where the pixel with the highest value was (first) found
         after clipping.
      }
      \sstsubsection{
         DMAXC = DOUBLE PRECISION (Returned)
      }{
         Maximum pixel value in the array after clipping.
      }
      \sstsubsection{
         SUMC = DOUBLE PRECISION (Returned)
      }{
         Sum of the valid pixels after clipping.
      }
      \sstsubsection{
         MEANC = DOUBLE PRECISION (Returned)
      }{
         Mean of the valid pixels after clipping.
      }
      \sstsubsection{
         STDEVC = DOUBLE PRECISION (Returned)
      }{
         Standard deviation of the valid pixels after clipping.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If no clipping is performed (i.e. if NCLIP = 0) then the values
         of arguments which return results after clipping will be the same
         as for those returning results before clipping.

         \sstitem
         If NGOOD or NGOODC is zero, then the values of all the derived
         statistics will be undefined and will be set to the {\tt "}bad{\tt "} value
         appropriate to their data type (except for the pixel sum, which
         will be zero).
      }
   }
}
\sstroutine{
   KPG1\_STATR
}{
   Compute simple statistics for an array
}{
   \sstdescription{
      This routine computes simple statistics for an array, namely: the
      number of valid pixels, the minimum and maximum pixel values (and
      their positions), the pixel sum, the mean, and the standard
      deviation. Iterative K-sigma clipping may also be optionally
      applied.
   }
   \sstinvocation{
      CALL KPG1\_STATR( BAD, EL, DATA, NCLIP, CLIP, NGOOD, IMIN, DMIN,
                       IMAX, DMAX, SUM, MEAN, STDEV, NGOODC, IMINC,
                       DMINC, IMAXC, DMAXC, SUMC, MEANC, STDEVC,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether checks for bad pixels should be performed on the array
         being analysed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of pixels in the array.
      }
      \sstsubsection{
         DATA( EL ) = REAL (Given)
      }{
         Array to be analysed.
      }
      \sstsubsection{
         NCLIP = INTEGER (Given)
      }{
         Number of K-sigma clipping iterations to apply (may be zero).
      }
      \sstsubsection{
         CLIP( NCLIP ) = REAL (Given)
      }{
         Array of clipping limits for successive iterations, expressed
         as standard deviations.
      }
      \sstsubsection{
         NGOOD = INTEGER (Returned)
      }{
         Number of valid pixels in the array before clipping.
      }
      \sstsubsection{
         IMIN = INTEGER (Returned)
      }{
         Index where the pixel with the lowest value was (first) found
         before clipping.
      }
      \sstsubsection{
         DMIN = DOUBLE PRECISION (Returned)
      }{
         Minimum pixel value in the array before clipping.
      }
      \sstsubsection{
         IMAX = INTEGER (Returned)
      }{
         Index where the pixel with the highest value was (first) found
         before clipping.
      }
      \sstsubsection{
         DMAX = DOUBLE PRECISION (Returned)
      }{
         Maximum pixel value in the array before clipping.
      }
      \sstsubsection{
         SUM = DOUBLE PRECISION (Returned)
      }{
         Sum of the valid pixels before clipping.
      }
      \sstsubsection{
         MEAN = DOUBLE PRECISION (Returned)
      }{
         Mean of the valid pixels before clipping.
      }
      \sstsubsection{
         STDEV = DOUBLE PRECISION (Returned)
      }{
         Standard deviation of the valid pixels before clipping.
      }
      \sstsubsection{
         NGOODC = INTEGER (Returned)
      }{
         Number of valid pixels in the array after clipping.
      }
      \sstsubsection{
         IMINC = INTEGER (Returned)
      }{
         Index where the pixel with the lowest value was (first) found
         after clipping.
      }
      \sstsubsection{
         DMINC = DOUBLE PRECISION (Returned)
      }{
         Minimum pixel value in the array after clipping.
      }
      \sstsubsection{
         IMAXC = INTEGER (Returned)
      }{
         Index where the pixel with the highest value was (first) found
         after clipping.
      }
      \sstsubsection{
         DMAXC = DOUBLE PRECISION (Returned)
      }{
         Maximum pixel value in the array after clipping.
      }
      \sstsubsection{
         SUMC = DOUBLE PRECISION (Returned)
      }{
         Sum of the valid pixels after clipping.
      }
      \sstsubsection{
         MEANC = DOUBLE PRECISION (Returned)
      }{
         Mean of the valid pixels after clipping.
      }
      \sstsubsection{
         STDEVC = DOUBLE PRECISION (Returned)
      }{
         Standard deviation of the valid pixels after clipping.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If no clipping is performed (i.e. if NCLIP = 0) then the values
         of arguments which return results after clipping will be the same
         as for those returning results before clipping.

         \sstitem
         If NGOOD or NGOODC is zero, then the values of all the derived
         statistics will be undefined and will be set to the {\tt "}bad{\tt "} value
         appropriate to their data type (except for the pixel sum, which
         will be zero).
      }
   }
}
\sstroutine{
   KPG1\_STATUB
}{
   Compute simple statistics for an array
}{
   \sstdescription{
      This routine computes simple statistics for an array, namely: the
      number of valid pixels, the minimum and maximum pixel values (and
      their positions), the pixel sum, the mean, and the standard
      deviation. Iterative K-sigma clipping may also be optionally
      applied.
   }
   \sstinvocation{
      CALL KPG1\_STATUB( BAD, EL, DATA, NCLIP, CLIP, NGOOD, IMIN, DMIN,
                       IMAX, DMAX, SUM, MEAN, STDEV, NGOODC, IMINC,
                       DMINC, IMAXC, DMAXC, SUMC, MEANC, STDEVC,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether checks for bad pixels should be performed on the array
         being analysed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of pixels in the array.
      }
      \sstsubsection{
         DATA( EL ) = BYTE (Given)
      }{
         Array to be analysed.
      }
      \sstsubsection{
         NCLIP = INTEGER (Given)
      }{
         Number of K-sigma clipping iterations to apply (may be zero).
      }
      \sstsubsection{
         CLIP( NCLIP ) = REAL (Given)
      }{
         Array of clipping limits for successive iterations, expressed
         as standard deviations.
      }
      \sstsubsection{
         NGOOD = INTEGER (Returned)
      }{
         Number of valid pixels in the array before clipping.
      }
      \sstsubsection{
         IMIN = INTEGER (Returned)
      }{
         Index where the pixel with the lowest value was (first) found
         before clipping.
      }
      \sstsubsection{
         DMIN = DOUBLE PRECISION (Returned)
      }{
         Minimum pixel value in the array before clipping.
      }
      \sstsubsection{
         IMAX = INTEGER (Returned)
      }{
         Index where the pixel with the highest value was (first) found
         before clipping.
      }
      \sstsubsection{
         DMAX = DOUBLE PRECISION (Returned)
      }{
         Maximum pixel value in the array before clipping.
      }
      \sstsubsection{
         SUM = DOUBLE PRECISION (Returned)
      }{
         Sum of the valid pixels before clipping.
      }
      \sstsubsection{
         MEAN = DOUBLE PRECISION (Returned)
      }{
         Mean of the valid pixels before clipping.
      }
      \sstsubsection{
         STDEV = DOUBLE PRECISION (Returned)
      }{
         Standard deviation of the valid pixels before clipping.
      }
      \sstsubsection{
         NGOODC = INTEGER (Returned)
      }{
         Number of valid pixels in the array after clipping.
      }
      \sstsubsection{
         IMINC = INTEGER (Returned)
      }{
         Index where the pixel with the lowest value was (first) found
         after clipping.
      }
      \sstsubsection{
         DMINC = DOUBLE PRECISION (Returned)
      }{
         Minimum pixel value in the array after clipping.
      }
      \sstsubsection{
         IMAXC = INTEGER (Returned)
      }{
         Index where the pixel with the highest value was (first) found
         after clipping.
      }
      \sstsubsection{
         DMAXC = DOUBLE PRECISION (Returned)
      }{
         Maximum pixel value in the array after clipping.
      }
      \sstsubsection{
         SUMC = DOUBLE PRECISION (Returned)
      }{
         Sum of the valid pixels after clipping.
      }
      \sstsubsection{
         MEANC = DOUBLE PRECISION (Returned)
      }{
         Mean of the valid pixels after clipping.
      }
      \sstsubsection{
         STDEVC = DOUBLE PRECISION (Returned)
      }{
         Standard deviation of the valid pixels after clipping.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If no clipping is performed (i.e. if NCLIP = 0) then the values
         of arguments which return results after clipping will be the same
         as for those returning results before clipping.

         \sstitem
         If NGOOD or NGOODC is zero, then the values of all the derived
         statistics will be undefined and will be set to the {\tt "}bad{\tt "} value
         appropriate to their data type (except for the pixel sum, which
         will be zero).
      }
   }
}
\sstroutine{
   KPG1\_STATUW
}{
   Compute simple statistics for an array
}{
   \sstdescription{
      This routine computes simple statistics for an array, namely: the
      number of valid pixels, the minimum and maximum pixel values (and
      their positions), the pixel sum, the mean, and the standard
      deviation. Iterative K-sigma clipping may also be optionally
      applied.
   }
   \sstinvocation{
      CALL KPG1\_STATUW( BAD, EL, DATA, NCLIP, CLIP, NGOOD, IMIN, DMIN,
                       IMAX, DMAX, SUM, MEAN, STDEV, NGOODC, IMINC,
                       DMINC, IMAXC, DMAXC, SUMC, MEANC, STDEVC,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether checks for bad pixels should be performed on the array
         being analysed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of pixels in the array.
      }
      \sstsubsection{
         DATA( EL ) = INTEGER$*$2 (Given)
      }{
         Array to be analysed.
      }
      \sstsubsection{
         NCLIP = INTEGER (Given)
      }{
         Number of K-sigma clipping iterations to apply (may be zero).
      }
      \sstsubsection{
         CLIP( NCLIP ) = REAL (Given)
      }{
         Array of clipping limits for successive iterations, expressed
         as standard deviations.
      }
      \sstsubsection{
         NGOOD = INTEGER (Returned)
      }{
         Number of valid pixels in the array before clipping.
      }
      \sstsubsection{
         IMIN = INTEGER (Returned)
      }{
         Index where the pixel with the lowest value was (first) found
         before clipping.
      }
      \sstsubsection{
         DMIN = DOUBLE PRECISION (Returned)
      }{
         Minimum pixel value in the array before clipping.
      }
      \sstsubsection{
         IMAX = INTEGER (Returned)
      }{
         Index where the pixel with the highest value was (first) found
         before clipping.
      }
      \sstsubsection{
         DMAX = DOUBLE PRECISION (Returned)
      }{
         Maximum pixel value in the array before clipping.
      }
      \sstsubsection{
         SUM = DOUBLE PRECISION (Returned)
      }{
         Sum of the valid pixels before clipping.
      }
      \sstsubsection{
         MEAN = DOUBLE PRECISION (Returned)
      }{
         Mean of the valid pixels before clipping.
      }
      \sstsubsection{
         STDEV = DOUBLE PRECISION (Returned)
      }{
         Standard deviation of the valid pixels before clipping.
      }
      \sstsubsection{
         NGOODC = INTEGER (Returned)
      }{
         Number of valid pixels in the array after clipping.
      }
      \sstsubsection{
         IMINC = INTEGER (Returned)
      }{
         Index where the pixel with the lowest value was (first) found
         after clipping.
      }
      \sstsubsection{
         DMINC = DOUBLE PRECISION (Returned)
      }{
         Minimum pixel value in the array after clipping.
      }
      \sstsubsection{
         IMAXC = INTEGER (Returned)
      }{
         Index where the pixel with the highest value was (first) found
         after clipping.
      }
      \sstsubsection{
         DMAXC = DOUBLE PRECISION (Returned)
      }{
         Maximum pixel value in the array after clipping.
      }
      \sstsubsection{
         SUMC = DOUBLE PRECISION (Returned)
      }{
         Sum of the valid pixels after clipping.
      }
      \sstsubsection{
         MEANC = DOUBLE PRECISION (Returned)
      }{
         Mean of the valid pixels after clipping.
      }
      \sstsubsection{
         STDEVC = DOUBLE PRECISION (Returned)
      }{
         Standard deviation of the valid pixels after clipping.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If no clipping is performed (i.e. if NCLIP = 0) then the values
         of arguments which return results after clipping will be the same
         as for those returning results before clipping.

         \sstitem
         If NGOOD or NGOODC is zero, then the values of all the derived
         statistics will be undefined and will be set to the {\tt "}bad{\tt "} value
         appropriate to their data type (except for the pixel sum, which
         will be zero).
      }
   }
}
\sstroutine{
   KPG1\_STATW
}{
   Compute simple statistics for an array
}{
   \sstdescription{
      This routine computes simple statistics for an array, namely: the
      number of valid pixels, the minimum and maximum pixel values (and
      their positions), the pixel sum, the mean, and the standard
      deviation. Iterative K-sigma clipping may also be optionally
      applied.
   }
   \sstinvocation{
      CALL KPG1\_STATW( BAD, EL, DATA, NCLIP, CLIP, NGOOD, IMIN, DMIN,
                       IMAX, DMAX, SUM, MEAN, STDEV, NGOODC, IMINC,
                       DMINC, IMAXC, DMAXC, SUMC, MEANC, STDEVC,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether checks for bad pixels should be performed on the array
         being analysed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of pixels in the array.
      }
      \sstsubsection{
         DATA( EL ) = INTEGER$*$2 (Given)
      }{
         Array to be analysed.
      }
      \sstsubsection{
         NCLIP = INTEGER (Given)
      }{
         Number of K-sigma clipping iterations to apply (may be zero).
      }
      \sstsubsection{
         CLIP( NCLIP ) = REAL (Given)
      }{
         Array of clipping limits for successive iterations, expressed
         as standard deviations.
      }
      \sstsubsection{
         NGOOD = INTEGER (Returned)
      }{
         Number of valid pixels in the array before clipping.
      }
      \sstsubsection{
         IMIN = INTEGER (Returned)
      }{
         Index where the pixel with the lowest value was (first) found
         before clipping.
      }
      \sstsubsection{
         DMIN = DOUBLE PRECISION (Returned)
      }{
         Minimum pixel value in the array before clipping.
      }
      \sstsubsection{
         IMAX = INTEGER (Returned)
      }{
         Index where the pixel with the highest value was (first) found
         before clipping.
      }
      \sstsubsection{
         DMAX = DOUBLE PRECISION (Returned)
      }{
         Maximum pixel value in the array before clipping.
      }
      \sstsubsection{
         SUM = DOUBLE PRECISION (Returned)
      }{
         Sum of the valid pixels before clipping.
      }
      \sstsubsection{
         MEAN = DOUBLE PRECISION (Returned)
      }{
         Mean of the valid pixels before clipping.
      }
      \sstsubsection{
         STDEV = DOUBLE PRECISION (Returned)
      }{
         Standard deviation of the valid pixels before clipping.
      }
      \sstsubsection{
         NGOODC = INTEGER (Returned)
      }{
         Number of valid pixels in the array after clipping.
      }
      \sstsubsection{
         IMINC = INTEGER (Returned)
      }{
         Index where the pixel with the lowest value was (first) found
         after clipping.
      }
      \sstsubsection{
         DMINC = DOUBLE PRECISION (Returned)
      }{
         Minimum pixel value in the array after clipping.
      }
      \sstsubsection{
         IMAXC = INTEGER (Returned)
      }{
         Index where the pixel with the highest value was (first) found
         after clipping.
      }
      \sstsubsection{
         DMAXC = DOUBLE PRECISION (Returned)
      }{
         Maximum pixel value in the array after clipping.
      }
      \sstsubsection{
         SUMC = DOUBLE PRECISION (Returned)
      }{
         Sum of the valid pixels after clipping.
      }
      \sstsubsection{
         MEANC = DOUBLE PRECISION (Returned)
      }{
         Mean of the valid pixels after clipping.
      }
      \sstsubsection{
         STDEVC = DOUBLE PRECISION (Returned)
      }{
         Standard deviation of the valid pixels after clipping.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         If no clipping is performed (i.e. if NCLIP = 0) then the values
         of arguments which return results after clipping will be the same
         as for those returning results before clipping.

         \sstitem
         If NGOOD or NGOODC is zero, then the values of all the derived
         statistics will be undefined and will be set to the {\tt "}bad{\tt "} value
         appropriate to their data type (except for the pixel sum, which
         will be zero).
      }
   }
}
\sstroutine{
   KPG1\_STDSx
}{
   Display statistics generated by KPG1\_STATx and KPG1\_HSTAx
}{
   \sstdescription{
      This routine diplays the statistics of pixel data as generated by
      the routines KPG1\_STATx and KPG1\_HSTAx.
   }
   \sstinvocation{
      CALL KPG1\_STDSx( NDIM, EL, NGOOD, DMIN, MINP, MINC,
                       DMAX, MAXP, MAXC, SUM, MEAN, STDEV,
                       MEDIAN, MODE, NUMPER, PERCNT, PERVAL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of dimensions of the array whose ststistics are being
         displayed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Total number of pixels in the array.
      }
      \sstsubsection{
         NGOOD = INTEGER (Given)
      }{
         Number of valid pixels which contributed to the statistics.
      }
      \sstsubsection{
         DMIN = DOUBLE PRECISION (Given)
      }{
         Minimum pixel value.
      }
      \sstsubsection{
         MINP( NDIM ) = INTEGER (Given)
      }{
         Pixel indices at which the minimum pixel value was (first)
         found.
      }
      \sstsubsection{
         MINC( NDIM ) = DOUBLE PRECISION (Given)
      }{
         The co-ordinate values of the centre of the minimum pixel.
      }
      \sstsubsection{
         DMAX = DOUBLE PRECISION (Given)
      }{
         Maximum pixel value.
      }
      \sstsubsection{
         MAXP( NDIM ) = INTEGER (Given)
      }{
         Pixel indices at which the maximum pixel value was (first)
         found.
      }
      \sstsubsection{
         MAXC( NDIM ) = DOUBLE PRECISION (Given)
      }{
         The co-ordinate values of the centre of the maximum pixel.
      }
      \sstsubsection{
         SUM = DOUBLE PRECISION (Given)
      }{
         Pixel sum.
      }
      \sstsubsection{
         MEAN = DOUBLE PRECISION (Given)
      }{
         Pixel mean value.
      }
      \sstsubsection{
         STDEV = DOUBLE PRECISION (Given)
      }{
         Pixel standard deviation value.
      }
      \sstsubsection{
         MEDIAN = DOUBLE PRECISION (Given)
      }{
         Median value.
      }
      \sstsubsection{
         MODE = DOUBLE PRECISION (Given)
      }{
         Modal value.
      }
      \sstsubsection{
         NUMPER = INTEGER (Given)
      }{
         Number of percentiles values to report.
      }
      \sstsubsection{
         PERCNT( NUMPER ) = REAL (Given)
      }{
         The array of percentiles levels corresponding to the values
         given by PERVAL.  They should be in the range 0.0 to 100.0,
         and preferably in ascending order.  If there are none to
         report, set NUMPER to 1 and pass the bad value in PERCNT( 1 ).
      }
      \sstsubsection{
         PERVAL( NUMPER ) = DOUBLE PRECISION (Given)
      }{
         Percentile values corresponding to the percentile fractions
         in PERCNT.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for both real and double-precision
         statistics: replace {\tt "}x{\tt "} in the routine name by R or D as
         appropriate. Note that the two routines have identical argument
         lists (with floating-point qualitities in double precision) but
         differ in the precision with which the results are displayed.

         \sstitem
         If the value of NGOOD is not positive, then this routine will
         assume that all the derived statistics (except for the sum) are
         undefined and will not display them.

         \sstitem
         If a statistic is undefined, i.e. has the bad value, it is
         not reported.  In the case of arrays, the first value is checked.
         For the co-ordinates and pixel indices of the extreme values both
         of the first elements of these must be good to display these
         positions.
      }
   }
}
\sstroutine{
   KPG1\_STDSx
}{
   Display statistics generated by KPG1\_STATx and KPG1\_HSTAx
}{
   \sstdescription{
      This routine diplays the statistics of pixel data as generated by
      the routines KPG1\_STATx and KPG1\_HSTAx.
   }
   \sstinvocation{
      CALL KPG1\_STDSx( NDIM, EL, NGOOD, DMIN, MINP, MINC,
                       DMAX, MAXP, MAXC, SUM, MEAN, STDEV,
                       MEDIAN, MODE, NUMPER, PERCNT, PERVAL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of dimensions of the array whose ststistics are being
         displayed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Total number of pixels in the array.
      }
      \sstsubsection{
         NGOOD = INTEGER (Given)
      }{
         Number of valid pixels which contributed to the statistics.
      }
      \sstsubsection{
         DMIN = DOUBLE PRECISION (Given)
      }{
         Minimum pixel value.
      }
      \sstsubsection{
         MINP( NDIM ) = INTEGER (Given)
      }{
         Pixel indices at which the minimum pixel value was (first)
         found.
      }
      \sstsubsection{
         MINC( NDIM ) = DOUBLE PRECISION (Given)
      }{
         The co-ordinate values of the centre of the minimum pixel.
      }
      \sstsubsection{
         DMAX = DOUBLE PRECISION (Given)
      }{
         Maximum pixel value.
      }
      \sstsubsection{
         MAXP( NDIM ) = INTEGER (Given)
      }{
         Pixel indices at which the maximum pixel value was (first)
         found.
      }
      \sstsubsection{
         MAXC( NDIM ) = DOUBLE PRECISION (Given)
      }{
         The co-ordinate values of the centre of the maximum pixel.
      }
      \sstsubsection{
         SUM = DOUBLE PRECISION (Given)
      }{
         Pixel sum.
      }
      \sstsubsection{
         MEAN = DOUBLE PRECISION (Given)
      }{
         Pixel mean value.
      }
      \sstsubsection{
         STDEV = DOUBLE PRECISION (Given)
      }{
         Pixel standard deviation value.
      }
      \sstsubsection{
         MEDIAN = DOUBLE PRECISION (Given)
      }{
         Median value.
      }
      \sstsubsection{
         MODE = DOUBLE PRECISION (Given)
      }{
         Modal value.
      }
      \sstsubsection{
         NUMPER = INTEGER (Given)
      }{
         Number of percentiles values to report.
      }
      \sstsubsection{
         PERCNT( NUMPER ) = REAL (Given)
      }{
         The array of percentiles levels corresponding to the values
         given by PERVAL.  They should be in the range 0.0 to 100.0,
         and preferably in ascending order.  If there are none to
         report, set NUMPER to 1 and pass the bad value in PERCNT( 1 ).
      }
      \sstsubsection{
         PERVAL( NUMPER ) = DOUBLE PRECISION (Given)
      }{
         Percentile values corresponding to the percentile fractions
         in PERCNT.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for both real and double-precision
         statistics: replace {\tt "}x{\tt "} in the routine name by R or D as
         appropriate. Note that the two routines have identical argument
         lists (with floating-point qualitities in double precision) but
         differ in the precision with which the results are displayed.

         \sstitem
         If the value of NGOOD is not positive, then this routine will
         assume that all the derived statistics (except for the sum) are
         undefined and will not display them.

         \sstitem
         If a statistic is undefined, i.e. has the bad value, it is
         not reported.  In the case of arrays, the first value is checked.
         For the co-ordinates and pixel indices of the extreme values both
         of the first elements of these must be good to display these
         positions.
      }
   }
}
\sstroutine{
   KPG1\_STFLx
}{
   Write statistics generated by KPG1\_STATx and KPG1\_HSTAx to a
   text file
}{
   \sstdescription{
      This routine writes the statistics of pixel data as generated by
      the routines KPG1\_STATx and KPG1\_HSTAx to a text file.
   }
   \sstinvocation{
      CALL KPG1\_STFLx( NDIM, EL, NGOOD, DMIN, MINP, MINC,
                       DMAX, MAXP, MAXC, SUM, MEAN, STDEV,
                       MEDIAN, MODE, NUMPER, PERCNT, PERVAL,
                       IFIL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of dimensions of the array whose statistics are being
         displayed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Total number of pixels in the array.
      }
      \sstsubsection{
         NGOOD = INTEGER (Given)
      }{
         Number of valid pixels which contributed to the statistics.
      }
      \sstsubsection{
         DMIN = DOUBLE PRECISION (Given)
      }{
         Minimum pixel value.
      }
      \sstsubsection{
         MINP( NDIM ) = INTEGER (Given)
      }{
         Pixel indices at which the minimum pixel value was (first)
         found.
      }
      \sstsubsection{
         MINC( NDIM ) = DOUBLE PRECISION (Given)
      }{
         The co-ordinate values of the centre of the minimum pixel.
      }
      \sstsubsection{
         DMAX = DOUBLE PRECISION (Given)
      }{
         Maximum pixel value.
      }
      \sstsubsection{
         MAXP( NDIM ) = INTEGER (Given)
      }{
         Pixel indices at which the maximum pixel value was (first)
         found.
      }
      \sstsubsection{
         MAXC( NDIM ) = DOUBLE PRECISION (Given)
      }{
         The co-ordinate values of the centre of the maximum pixel.
      }
      \sstsubsection{
         SUM = DOUBLE PRECISION (Given)
      }{
         Pixel sum.
      }
      \sstsubsection{
         MEAN = DOUBLE PRECISION (Given)
      }{
         Pixel mean value.
      }
      \sstsubsection{
         STDEV = DOUBLE PRECISION (Given)
      }{
         Pixel standard deviation value.
      }
      \sstsubsection{
         MEDIAN = DOUBLE PRECISION (Given)
      }{
         Median value.
      }
      \sstsubsection{
         MODE = DOUBLE PRECISION (Given)
      }{
         Modal value.
      }
      \sstsubsection{
         NUMPER = INTEGER (Given)
      }{
         Number of percentiles values to report.
      }
      \sstsubsection{
         PERCNT( NUMPER ) = REAL (Given)
      }{
         The array of percentiles levels corresponding to the values
         given by PERVAL.  They should be in the range 0.0 to 100.0,
         and preferably in ascending order.  If there are none to
         report, set NUMPER to 1 and pass the bad value in PERCNT( 1 ).
      }
      \sstsubsection{
         PERVAL( NUMPER ) = DOUBLE PRECISION (Given)
      }{
         Percentile values corresponding to the percentile fractions
         in PERCNT.
      }
      \sstsubsection{
         IFIL = INTEGER (Given)
      }{
         FIO\_ file descriptor for the output file.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for both real and double-precision
         statistics: replace {\tt "}x{\tt "} in the routine name by R or D as
         appropriate. Note that the two routines have identical argument
         lists (with floating-point qualitities in double precision) but
         differ in the precision with which the results are displayed.

         \sstitem
         If the value of NGOOD is not positive, then this routine will
         assume that all the derived statistics (except for the sum) are
         undefined and will not display them.

         \sstitem
         If a statistic is undefined, i.e. has the bad value, it is
         not reported.  In the case of arrays, the first value is checked.
         For the co-ordinates and pixel indices of the extreme values both
         of the first elements of these must be good to display these
         positions.
      }
   }
}
\sstroutine{
   KPG1\_STFLx
}{
   Write statistics generated by KPG1\_STATx and KPG1\_HSTAx to a
   text file
}{
   \sstdescription{
      This routine writes the statistics of pixel data as generated by
      the routines KPG1\_STATx and KPG1\_HSTAx to a text file.
   }
   \sstinvocation{
      CALL KPG1\_STFLx( NDIM, EL, NGOOD, DMIN, MINP, MINC,
                       DMAX, MAXP, MAXC, SUM, MEAN, STDEV,
                       MEDIAN, MODE, NUMPER, PERCNT, PERVAL,
                       IFIL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of dimensions of the array whose statistics are being
         displayed.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Total number of pixels in the array.
      }
      \sstsubsection{
         NGOOD = INTEGER (Given)
      }{
         Number of valid pixels which contributed to the statistics.
      }
      \sstsubsection{
         DMIN = DOUBLE PRECISION (Given)
      }{
         Minimum pixel value.
      }
      \sstsubsection{
         MINP( NDIM ) = INTEGER (Given)
      }{
         Pixel indices at which the minimum pixel value was (first)
         found.
      }
      \sstsubsection{
         MINC( NDIM ) = DOUBLE PRECISION (Given)
      }{
         The co-ordinate values of the centre of the minimum pixel.
      }
      \sstsubsection{
         DMAX = DOUBLE PRECISION (Given)
      }{
         Maximum pixel value.
      }
      \sstsubsection{
         MAXP( NDIM ) = INTEGER (Given)
      }{
         Pixel indices at which the maximum pixel value was (first)
         found.
      }
      \sstsubsection{
         MAXC( NDIM ) = DOUBLE PRECISION (Given)
      }{
         The co-ordinate values of the centre of the maximum pixel.
      }
      \sstsubsection{
         SUM = DOUBLE PRECISION (Given)
      }{
         Pixel sum.
      }
      \sstsubsection{
         MEAN = DOUBLE PRECISION (Given)
      }{
         Pixel mean value.
      }
      \sstsubsection{
         STDEV = DOUBLE PRECISION (Given)
      }{
         Pixel standard deviation value.
      }
      \sstsubsection{
         MEDIAN = DOUBLE PRECISION (Given)
      }{
         Median value.
      }
      \sstsubsection{
         MODE = DOUBLE PRECISION (Given)
      }{
         Modal value.
      }
      \sstsubsection{
         NUMPER = INTEGER (Given)
      }{
         Number of percentiles values to report.
      }
      \sstsubsection{
         PERCNT( NUMPER ) = REAL (Given)
      }{
         The array of percentiles levels corresponding to the values
         given by PERVAL.  They should be in the range 0.0 to 100.0,
         and preferably in ascending order.  If there are none to
         report, set NUMPER to 1 and pass the bad value in PERCNT( 1 ).
      }
      \sstsubsection{
         PERVAL( NUMPER ) = DOUBLE PRECISION (Given)
      }{
         Percentile values corresponding to the percentile fractions
         in PERCNT.
      }
      \sstsubsection{
         IFIL = INTEGER (Given)
      }{
         FIO\_ file descriptor for the output file.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for both real and double-precision
         statistics: replace {\tt "}x{\tt "} in the routine name by R or D as
         appropriate. Note that the two routines have identical argument
         lists (with floating-point qualitities in double precision) but
         differ in the precision with which the results are displayed.

         \sstitem
         If the value of NGOOD is not positive, then this routine will
         assume that all the derived statistics (except for the sum) are
         undefined and will not display them.

         \sstitem
         If a statistic is undefined, i.e. has the bad value, it is
         not reported.  In the case of arrays, the first value is checked.
         For the co-ordinates and pixel indices of the extreme values both
         of the first elements of these must be good to display these
         positions.
      }
   }
}
\sstroutine{
   KPG1\_STORx
}{
   Stores a value in an array
}{
   \sstdescription{
      The supplied value is stored in the array at the given index.
   }
   \sstinvocation{
      CALL KPG1\_STORx( EL, INDEX, VALUE, DATA, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index at which to store the supplied value.
      }
      \sstsubsection{
         VALUE = ? (Given)
      }{
         The value to be stored in the array.
      }
      \sstsubsection{
         DATA( EL ) = ? (Given and Returned)
      }{
         The array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW, or W as appropriate.  The
         VALUE and DATA arguments must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_STORx
}{
   Stores a value in an array
}{
   \sstdescription{
      The supplied value is stored in the array at the given index.
   }
   \sstinvocation{
      CALL KPG1\_STORx( EL, INDEX, VALUE, DATA, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index at which to store the supplied value.
      }
      \sstsubsection{
         VALUE = ? (Given)
      }{
         The value to be stored in the array.
      }
      \sstsubsection{
         DATA( EL ) = ? (Given and Returned)
      }{
         The array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW, or W as appropriate.  The
         VALUE and DATA arguments must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_STORx
}{
   Stores a value in an array
}{
   \sstdescription{
      The supplied value is stored in the array at the given index.
   }
   \sstinvocation{
      CALL KPG1\_STORx( EL, INDEX, VALUE, DATA, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index at which to store the supplied value.
      }
      \sstsubsection{
         VALUE = ? (Given)
      }{
         The value to be stored in the array.
      }
      \sstsubsection{
         DATA( EL ) = ? (Given and Returned)
      }{
         The array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW, or W as appropriate.  The
         VALUE and DATA arguments must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_STORx
}{
   Stores a value in an array
}{
   \sstdescription{
      The supplied value is stored in the array at the given index.
   }
   \sstinvocation{
      CALL KPG1\_STORx( EL, INDEX, VALUE, DATA, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index at which to store the supplied value.
      }
      \sstsubsection{
         VALUE = ? (Given)
      }{
         The value to be stored in the array.
      }
      \sstsubsection{
         DATA( EL ) = ? (Given and Returned)
      }{
         The array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW, or W as appropriate.  The
         VALUE and DATA arguments must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_STORx
}{
   Stores a value in an array
}{
   \sstdescription{
      The supplied value is stored in the array at the given index.
   }
   \sstinvocation{
      CALL KPG1\_STORx( EL, INDEX, VALUE, DATA, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index at which to store the supplied value.
      }
      \sstsubsection{
         VALUE = ? (Given)
      }{
         The value to be stored in the array.
      }
      \sstsubsection{
         DATA( EL ) = ? (Given and Returned)
      }{
         The array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW, or W as appropriate.  The
         VALUE and DATA arguments must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_STORx
}{
   Stores a value in an array
}{
   \sstdescription{
      The supplied value is stored in the array at the given index.
   }
   \sstinvocation{
      CALL KPG1\_STORx( EL, INDEX, VALUE, DATA, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index at which to store the supplied value.
      }
      \sstsubsection{
         VALUE = ? (Given)
      }{
         The value to be stored in the array.
      }
      \sstsubsection{
         DATA( EL ) = ? (Given and Returned)
      }{
         The array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW, or W as appropriate.  The
         VALUE and DATA arguments must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_STORx
}{
   Stores a value in an array
}{
   \sstdescription{
      The supplied value is stored in the array at the given index.
   }
   \sstinvocation{
      CALL KPG1\_STORx( EL, INDEX, VALUE, DATA, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of elements in the array.
      }
      \sstsubsection{
         INDEX = INTEGER (Given)
      }{
         The index at which to store the supplied value.
      }
      \sstsubsection{
         VALUE = ? (Given)
      }{
         The value to be stored in the array.
      }
      \sstsubsection{
         DATA( EL ) = ? (Given and Returned)
      }{
         The array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for all numeric data types: replace {\tt "}x{\tt "} in
         the routine name by B, D, I, R, UB, UW, or W as appropriate.  The
         VALUE and DATA arguments must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_TDLIx
}{
   Applies a constant-determinant transformation to an array by
   linear interpolation
}{
   \sstdescription{
      This routine creates a new n-dimensional array from an input
      m-dimensional array by applying a constant-determininant
      transformation to all the elements of the output array.  Each
      output value is calculated by linear interpolation between the
      elements in the input array that surround each transformed
      co-ordinate.  The transformation must convert from output
      co-ordinates to input pixel indices.  The two arrays may have
      different numbers of dimensions. In addition a variance array may
      be created likewise.

      This operates with double-precision co-ordinates.  Use KPG1\_TRLIx
      for single precision.
   }
   \sstinvocation{
      CALL KPG1\_TDLIx( NDIMI, IDIMS, INARR, VAR, INVAR, TRID, FLUX,
                       AXES, OEL, NDIMO, OLBND, ODIMS, OUTARR, OUTVAR,
                       COIN, COOUT, INDICE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input arrays.  It must be greater
         than one.  To handle a one-dimensional array, give it a second
         dummy dimension of 1.
      }
      \sstsubsection{
         IDIMS( NDIMI ) = INTEGER (Given)
      }{
         The dimensions of the input n-D arrays.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-D data array.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If VAR is .TRUE. there is a variance array to create from an
         input variance array.
      }
      \sstsubsection{
         INVAR( $*$ ) = ? (Given)
      }{
         The input n-D variance array.  When VAR is .FALSE., this can
         contain an arbitrary number of elements.  When VAR is .TRUE.
         it must have the shape of the input data array.
      }
      \sstsubsection{
         FLUX = DOUBLE PRECISION (Given)
      }{
         The factor to multiply the values in the output arrays to
         preserve the flux.  This will be the determinant of the
         transformation.  Set this to 1.0 if no flux conservation is
         required.
      }
      \sstsubsection{
         AXES( $*$ ) = DOUBLE PRECISION (Given)
      }{
         The concatenated axis co-ordinates of the input array.  This
         array should therefore have a dimension at least as large as
         the sum of the input array{\tt '}s dimensions.
      }
      \sstsubsection{
         OEL = INTEGER (Given)
      }{
         The first dimension of the work arrays.  It should be at least
         ODIMS( 1 ).
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output arrays.
      }
      \sstsubsection{
         OLBND( NDIMO ) = INTEGER (Given)
      }{
         The lower bounds of the output n-D arrays.
      }
      \sstsubsection{
         ODIMS( NDIMO ) = INTEGER (Given)
      }{
         The dimensions of the output n-D arrays.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Returned)
      }{
         The transformed data array.
      }
      \sstsubsection{
         OUTVAR( $*$ ) = ? (Returned)
      }{
         The variance array of the transformed data.
      }
      \sstsubsection{
         COIN( OEL, NDIMI ) = DOUBLE PRECISION (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points
         in the input arrays.
      }
      \sstsubsection{
         COOUT( OEL, NDIMO ) = DOUBLE PRECISION (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points in
         the output arrays.
      }
      \sstsubsection{
         INDICE( OEL, NDIMI ) = DOUBLE PRECISION (Returned)
      }{
         Workspace used to store the floating-point pixel indices of a
         row of points in the input arrays.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by B, D, I, R, UB, UW, or W as
         appropriate.  The input and output data and variance arrays must
         have the data type specified.

         \sstitem
         There is no protection against overflows when the absolute data
         values are very large.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_TDLIx
}{
   Applies a constant-determinant transformation to an array by
   linear interpolation
}{
   \sstdescription{
      This routine creates a new n-dimensional array from an input
      m-dimensional array by applying a constant-determininant
      transformation to all the elements of the output array.  Each
      output value is calculated by linear interpolation between the
      elements in the input array that surround each transformed
      co-ordinate.  The transformation must convert from output
      co-ordinates to input pixel indices.  The two arrays may have
      different numbers of dimensions. In addition a variance array may
      be created likewise.

      This operates with double-precision co-ordinates.  Use KPG1\_TRLIx
      for single precision.
   }
   \sstinvocation{
      CALL KPG1\_TDLIx( NDIMI, IDIMS, INARR, VAR, INVAR, TRID, FLUX,
                       AXES, OEL, NDIMO, OLBND, ODIMS, OUTARR, OUTVAR,
                       COIN, COOUT, INDICE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input arrays.  It must be greater
         than one.  To handle a one-dimensional array, give it a second
         dummy dimension of 1.
      }
      \sstsubsection{
         IDIMS( NDIMI ) = INTEGER (Given)
      }{
         The dimensions of the input n-D arrays.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-D data array.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If VAR is .TRUE. there is a variance array to create from an
         input variance array.
      }
      \sstsubsection{
         INVAR( $*$ ) = ? (Given)
      }{
         The input n-D variance array.  When VAR is .FALSE., this can
         contain an arbitrary number of elements.  When VAR is .TRUE.
         it must have the shape of the input data array.
      }
      \sstsubsection{
         FLUX = DOUBLE PRECISION (Given)
      }{
         The factor to multiply the values in the output arrays to
         preserve the flux.  This will be the determinant of the
         transformation.  Set this to 1.0 if no flux conservation is
         required.
      }
      \sstsubsection{
         AXES( $*$ ) = DOUBLE PRECISION (Given)
      }{
         The concatenated axis co-ordinates of the input array.  This
         array should therefore have a dimension at least as large as
         the sum of the input array{\tt '}s dimensions.
      }
      \sstsubsection{
         OEL = INTEGER (Given)
      }{
         The first dimension of the work arrays.  It should be at least
         ODIMS( 1 ).
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output arrays.
      }
      \sstsubsection{
         OLBND( NDIMO ) = INTEGER (Given)
      }{
         The lower bounds of the output n-D arrays.
      }
      \sstsubsection{
         ODIMS( NDIMO ) = INTEGER (Given)
      }{
         The dimensions of the output n-D arrays.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Returned)
      }{
         The transformed data array.
      }
      \sstsubsection{
         OUTVAR( $*$ ) = ? (Returned)
      }{
         The variance array of the transformed data.
      }
      \sstsubsection{
         COIN( OEL, NDIMI ) = DOUBLE PRECISION (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points
         in the input arrays.
      }
      \sstsubsection{
         COOUT( OEL, NDIMO ) = DOUBLE PRECISION (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points in
         the output arrays.
      }
      \sstsubsection{
         INDICE( OEL, NDIMI ) = DOUBLE PRECISION (Returned)
      }{
         Workspace used to store the floating-point pixel indices of a
         row of points in the input arrays.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by B, D, I, R, UB, UW, or W as
         appropriate.  The input and output data and variance arrays must
         have the data type specified.

         \sstitem
         There is no protection against overflows when the absolute data
         values are very large.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_TDLIx
}{
   Applies a constant-determinant transformation to an array by
   linear interpolation
}{
   \sstdescription{
      This routine creates a new n-dimensional array from an input
      m-dimensional array by applying a constant-determininant
      transformation to all the elements of the output array.  Each
      output value is calculated by linear interpolation between the
      elements in the input array that surround each transformed
      co-ordinate.  The transformation must convert from output
      co-ordinates to input pixel indices.  The two arrays may have
      different numbers of dimensions. In addition a variance array may
      be created likewise.

      This operates with double-precision co-ordinates.  Use KPG1\_TRLIx
      for single precision.
   }
   \sstinvocation{
      CALL KPG1\_TDLIx( NDIMI, IDIMS, INARR, VAR, INVAR, TRID, FLUX,
                       AXES, OEL, NDIMO, OLBND, ODIMS, OUTARR, OUTVAR,
                       COIN, COOUT, INDICE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input arrays.  It must be greater
         than one.  To handle a one-dimensional array, give it a second
         dummy dimension of 1.
      }
      \sstsubsection{
         IDIMS( NDIMI ) = INTEGER (Given)
      }{
         The dimensions of the input n-D arrays.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-D data array.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If VAR is .TRUE. there is a variance array to create from an
         input variance array.
      }
      \sstsubsection{
         INVAR( $*$ ) = ? (Given)
      }{
         The input n-D variance array.  When VAR is .FALSE., this can
         contain an arbitrary number of elements.  When VAR is .TRUE.
         it must have the shape of the input data array.
      }
      \sstsubsection{
         FLUX = DOUBLE PRECISION (Given)
      }{
         The factor to multiply the values in the output arrays to
         preserve the flux.  This will be the determinant of the
         transformation.  Set this to 1.0 if no flux conservation is
         required.
      }
      \sstsubsection{
         AXES( $*$ ) = DOUBLE PRECISION (Given)
      }{
         The concatenated axis co-ordinates of the input array.  This
         array should therefore have a dimension at least as large as
         the sum of the input array{\tt '}s dimensions.
      }
      \sstsubsection{
         OEL = INTEGER (Given)
      }{
         The first dimension of the work arrays.  It should be at least
         ODIMS( 1 ).
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output arrays.
      }
      \sstsubsection{
         OLBND( NDIMO ) = INTEGER (Given)
      }{
         The lower bounds of the output n-D arrays.
      }
      \sstsubsection{
         ODIMS( NDIMO ) = INTEGER (Given)
      }{
         The dimensions of the output n-D arrays.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Returned)
      }{
         The transformed data array.
      }
      \sstsubsection{
         OUTVAR( $*$ ) = ? (Returned)
      }{
         The variance array of the transformed data.
      }
      \sstsubsection{
         COIN( OEL, NDIMI ) = DOUBLE PRECISION (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points
         in the input arrays.
      }
      \sstsubsection{
         COOUT( OEL, NDIMO ) = DOUBLE PRECISION (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points in
         the output arrays.
      }
      \sstsubsection{
         INDICE( OEL, NDIMI ) = DOUBLE PRECISION (Returned)
      }{
         Workspace used to store the floating-point pixel indices of a
         row of points in the input arrays.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by B, D, I, R, UB, UW, or W as
         appropriate.  The input and output data and variance arrays must
         have the data type specified.

         \sstitem
         There is no protection against overflows when the absolute data
         values are very large.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_TDLIx
}{
   Applies a constant-determinant transformation to an array by
   linear interpolation
}{
   \sstdescription{
      This routine creates a new n-dimensional array from an input
      m-dimensional array by applying a constant-determininant
      transformation to all the elements of the output array.  Each
      output value is calculated by linear interpolation between the
      elements in the input array that surround each transformed
      co-ordinate.  The transformation must convert from output
      co-ordinates to input pixel indices.  The two arrays may have
      different numbers of dimensions. In addition a variance array may
      be created likewise.

      This operates with double-precision co-ordinates.  Use KPG1\_TRLIx
      for single precision.
   }
   \sstinvocation{
      CALL KPG1\_TDLIx( NDIMI, IDIMS, INARR, VAR, INVAR, TRID, FLUX,
                       AXES, OEL, NDIMO, OLBND, ODIMS, OUTARR, OUTVAR,
                       COIN, COOUT, INDICE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input arrays.  It must be greater
         than one.  To handle a one-dimensional array, give it a second
         dummy dimension of 1.
      }
      \sstsubsection{
         IDIMS( NDIMI ) = INTEGER (Given)
      }{
         The dimensions of the input n-D arrays.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-D data array.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If VAR is .TRUE. there is a variance array to create from an
         input variance array.
      }
      \sstsubsection{
         INVAR( $*$ ) = ? (Given)
      }{
         The input n-D variance array.  When VAR is .FALSE., this can
         contain an arbitrary number of elements.  When VAR is .TRUE.
         it must have the shape of the input data array.
      }
      \sstsubsection{
         FLUX = DOUBLE PRECISION (Given)
      }{
         The factor to multiply the values in the output arrays to
         preserve the flux.  This will be the determinant of the
         transformation.  Set this to 1.0 if no flux conservation is
         required.
      }
      \sstsubsection{
         AXES( $*$ ) = DOUBLE PRECISION (Given)
      }{
         The concatenated axis co-ordinates of the input array.  This
         array should therefore have a dimension at least as large as
         the sum of the input array{\tt '}s dimensions.
      }
      \sstsubsection{
         OEL = INTEGER (Given)
      }{
         The first dimension of the work arrays.  It should be at least
         ODIMS( 1 ).
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output arrays.
      }
      \sstsubsection{
         OLBND( NDIMO ) = INTEGER (Given)
      }{
         The lower bounds of the output n-D arrays.
      }
      \sstsubsection{
         ODIMS( NDIMO ) = INTEGER (Given)
      }{
         The dimensions of the output n-D arrays.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Returned)
      }{
         The transformed data array.
      }
      \sstsubsection{
         OUTVAR( $*$ ) = ? (Returned)
      }{
         The variance array of the transformed data.
      }
      \sstsubsection{
         COIN( OEL, NDIMI ) = DOUBLE PRECISION (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points
         in the input arrays.
      }
      \sstsubsection{
         COOUT( OEL, NDIMO ) = DOUBLE PRECISION (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points in
         the output arrays.
      }
      \sstsubsection{
         INDICE( OEL, NDIMI ) = DOUBLE PRECISION (Returned)
      }{
         Workspace used to store the floating-point pixel indices of a
         row of points in the input arrays.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by B, D, I, R, UB, UW, or W as
         appropriate.  The input and output data and variance arrays must
         have the data type specified.

         \sstitem
         There is no protection against overflows when the absolute data
         values are very large.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_TDLIx
}{
   Applies a constant-determinant transformation to an array by
   linear interpolation
}{
   \sstdescription{
      This routine creates a new n-dimensional array from an input
      m-dimensional array by applying a constant-determininant
      transformation to all the elements of the output array.  Each
      output value is calculated by linear interpolation between the
      elements in the input array that surround each transformed
      co-ordinate.  The transformation must convert from output
      co-ordinates to input pixel indices.  The two arrays may have
      different numbers of dimensions. In addition a variance array may
      be created likewise.

      This operates with double-precision co-ordinates.  Use KPG1\_TRLIx
      for single precision.
   }
   \sstinvocation{
      CALL KPG1\_TDLIx( NDIMI, IDIMS, INARR, VAR, INVAR, TRID, FLUX,
                       AXES, OEL, NDIMO, OLBND, ODIMS, OUTARR, OUTVAR,
                       COIN, COOUT, INDICE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input arrays.  It must be greater
         than one.  To handle a one-dimensional array, give it a second
         dummy dimension of 1.
      }
      \sstsubsection{
         IDIMS( NDIMI ) = INTEGER (Given)
      }{
         The dimensions of the input n-D arrays.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-D data array.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If VAR is .TRUE. there is a variance array to create from an
         input variance array.
      }
      \sstsubsection{
         INVAR( $*$ ) = ? (Given)
      }{
         The input n-D variance array.  When VAR is .FALSE., this can
         contain an arbitrary number of elements.  When VAR is .TRUE.
         it must have the shape of the input data array.
      }
      \sstsubsection{
         FLUX = DOUBLE PRECISION (Given)
      }{
         The factor to multiply the values in the output arrays to
         preserve the flux.  This will be the determinant of the
         transformation.  Set this to 1.0 if no flux conservation is
         required.
      }
      \sstsubsection{
         AXES( $*$ ) = DOUBLE PRECISION (Given)
      }{
         The concatenated axis co-ordinates of the input array.  This
         array should therefore have a dimension at least as large as
         the sum of the input array{\tt '}s dimensions.
      }
      \sstsubsection{
         OEL = INTEGER (Given)
      }{
         The first dimension of the work arrays.  It should be at least
         ODIMS( 1 ).
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output arrays.
      }
      \sstsubsection{
         OLBND( NDIMO ) = INTEGER (Given)
      }{
         The lower bounds of the output n-D arrays.
      }
      \sstsubsection{
         ODIMS( NDIMO ) = INTEGER (Given)
      }{
         The dimensions of the output n-D arrays.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Returned)
      }{
         The transformed data array.
      }
      \sstsubsection{
         OUTVAR( $*$ ) = ? (Returned)
      }{
         The variance array of the transformed data.
      }
      \sstsubsection{
         COIN( OEL, NDIMI ) = DOUBLE PRECISION (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points
         in the input arrays.
      }
      \sstsubsection{
         COOUT( OEL, NDIMO ) = DOUBLE PRECISION (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points in
         the output arrays.
      }
      \sstsubsection{
         INDICE( OEL, NDIMI ) = DOUBLE PRECISION (Returned)
      }{
         Workspace used to store the floating-point pixel indices of a
         row of points in the input arrays.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by B, D, I, R, UB, UW, or W as
         appropriate.  The input and output data and variance arrays must
         have the data type specified.

         \sstitem
         There is no protection against overflows when the absolute data
         values are very large.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_TDLIx
}{
   Applies a constant-determinant transformation to an array by
   linear interpolation
}{
   \sstdescription{
      This routine creates a new n-dimensional array from an input
      m-dimensional array by applying a constant-determininant
      transformation to all the elements of the output array.  Each
      output value is calculated by linear interpolation between the
      elements in the input array that surround each transformed
      co-ordinate.  The transformation must convert from output
      co-ordinates to input pixel indices.  The two arrays may have
      different numbers of dimensions. In addition a variance array may
      be created likewise.

      This operates with double-precision co-ordinates.  Use KPG1\_TRLIx
      for single precision.
   }
   \sstinvocation{
      CALL KPG1\_TDLIx( NDIMI, IDIMS, INARR, VAR, INVAR, TRID, FLUX,
                       AXES, OEL, NDIMO, OLBND, ODIMS, OUTARR, OUTVAR,
                       COIN, COOUT, INDICE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input arrays.  It must be greater
         than one.  To handle a one-dimensional array, give it a second
         dummy dimension of 1.
      }
      \sstsubsection{
         IDIMS( NDIMI ) = INTEGER (Given)
      }{
         The dimensions of the input n-D arrays.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-D data array.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If VAR is .TRUE. there is a variance array to create from an
         input variance array.
      }
      \sstsubsection{
         INVAR( $*$ ) = ? (Given)
      }{
         The input n-D variance array.  When VAR is .FALSE., this can
         contain an arbitrary number of elements.  When VAR is .TRUE.
         it must have the shape of the input data array.
      }
      \sstsubsection{
         FLUX = DOUBLE PRECISION (Given)
      }{
         The factor to multiply the values in the output arrays to
         preserve the flux.  This will be the determinant of the
         transformation.  Set this to 1.0 if no flux conservation is
         required.
      }
      \sstsubsection{
         AXES( $*$ ) = DOUBLE PRECISION (Given)
      }{
         The concatenated axis co-ordinates of the input array.  This
         array should therefore have a dimension at least as large as
         the sum of the input array{\tt '}s dimensions.
      }
      \sstsubsection{
         OEL = INTEGER (Given)
      }{
         The first dimension of the work arrays.  It should be at least
         ODIMS( 1 ).
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output arrays.
      }
      \sstsubsection{
         OLBND( NDIMO ) = INTEGER (Given)
      }{
         The lower bounds of the output n-D arrays.
      }
      \sstsubsection{
         ODIMS( NDIMO ) = INTEGER (Given)
      }{
         The dimensions of the output n-D arrays.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Returned)
      }{
         The transformed data array.
      }
      \sstsubsection{
         OUTVAR( $*$ ) = ? (Returned)
      }{
         The variance array of the transformed data.
      }
      \sstsubsection{
         COIN( OEL, NDIMI ) = DOUBLE PRECISION (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points
         in the input arrays.
      }
      \sstsubsection{
         COOUT( OEL, NDIMO ) = DOUBLE PRECISION (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points in
         the output arrays.
      }
      \sstsubsection{
         INDICE( OEL, NDIMI ) = DOUBLE PRECISION (Returned)
      }{
         Workspace used to store the floating-point pixel indices of a
         row of points in the input arrays.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by B, D, I, R, UB, UW, or W as
         appropriate.  The input and output data and variance arrays must
         have the data type specified.

         \sstitem
         There is no protection against overflows when the absolute data
         values are very large.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_TDLIx
}{
   Applies a constant-determinant transformation to an array by
   linear interpolation
}{
   \sstdescription{
      This routine creates a new n-dimensional array from an input
      m-dimensional array by applying a constant-determininant
      transformation to all the elements of the output array.  Each
      output value is calculated by linear interpolation between the
      elements in the input array that surround each transformed
      co-ordinate.  The transformation must convert from output
      co-ordinates to input pixel indices.  The two arrays may have
      different numbers of dimensions. In addition a variance array may
      be created likewise.

      This operates with double-precision co-ordinates.  Use KPG1\_TRLIx
      for single precision.
   }
   \sstinvocation{
      CALL KPG1\_TDLIx( NDIMI, IDIMS, INARR, VAR, INVAR, TRID, FLUX,
                       AXES, OEL, NDIMO, OLBND, ODIMS, OUTARR, OUTVAR,
                       COIN, COOUT, INDICE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input arrays.  It must be greater
         than one.  To handle a one-dimensional array, give it a second
         dummy dimension of 1.
      }
      \sstsubsection{
         IDIMS( NDIMI ) = INTEGER (Given)
      }{
         The dimensions of the input n-D arrays.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-D data array.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If VAR is .TRUE. there is a variance array to create from an
         input variance array.
      }
      \sstsubsection{
         INVAR( $*$ ) = ? (Given)
      }{
         The input n-D variance array.  When VAR is .FALSE., this can
         contain an arbitrary number of elements.  When VAR is .TRUE.
         it must have the shape of the input data array.
      }
      \sstsubsection{
         FLUX = DOUBLE PRECISION (Given)
      }{
         The factor to multiply the values in the output arrays to
         preserve the flux.  This will be the determinant of the
         transformation.  Set this to 1.0 if no flux conservation is
         required.
      }
      \sstsubsection{
         AXES( $*$ ) = DOUBLE PRECISION (Given)
      }{
         The concatenated axis co-ordinates of the input array.  This
         array should therefore have a dimension at least as large as
         the sum of the input array{\tt '}s dimensions.
      }
      \sstsubsection{
         OEL = INTEGER (Given)
      }{
         The first dimension of the work arrays.  It should be at least
         ODIMS( 1 ).
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output arrays.
      }
      \sstsubsection{
         OLBND( NDIMO ) = INTEGER (Given)
      }{
         The lower bounds of the output n-D arrays.
      }
      \sstsubsection{
         ODIMS( NDIMO ) = INTEGER (Given)
      }{
         The dimensions of the output n-D arrays.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Returned)
      }{
         The transformed data array.
      }
      \sstsubsection{
         OUTVAR( $*$ ) = ? (Returned)
      }{
         The variance array of the transformed data.
      }
      \sstsubsection{
         COIN( OEL, NDIMI ) = DOUBLE PRECISION (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points
         in the input arrays.
      }
      \sstsubsection{
         COOUT( OEL, NDIMO ) = DOUBLE PRECISION (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points in
         the output arrays.
      }
      \sstsubsection{
         INDICE( OEL, NDIMI ) = DOUBLE PRECISION (Returned)
      }{
         Workspace used to store the floating-point pixel indices of a
         row of points in the input arrays.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by B, D, I, R, UB, UW, or W as
         appropriate.  The input and output data and variance arrays must
         have the data type specified.

         \sstitem
         There is no protection against overflows when the absolute data
         values are very large.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_THRSB
}{
   Sets pixels in array to defined new values outside limits
}{
   \sstdescription{
      This routine takes an array and sets all values above a defined
      upper threshold to a new defined value, and sets all those below a
      defined lower threshold to another defined value.  In practice,
      all values outside the two thresholds may be set to zero or
      the bad value, for example.

      If the lower threshold is greater than or equal to the uper
      threshold, the values between the thresholds are set to the
      supplied lower replacement value, and the upper replacement value
      is ignored. In this case the number of replaced pixels is returned
      in NREPLO, and NREPHI is returned as -1.
   }
   \sstinvocation{
      CALL KPG1\_THRSB( BAD, EL, INARR, THRLO, THRHI, NEWLO, NEWHI,
                       OUTARR, NREPLO, NREPHI, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         The bad-pixel flag.  If it is .TRUE., tests are made for bad
         array values.  When .FALSE., no tests are made for bad values,
         and any encountered are treated literally.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Dimension of the input and output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         Input data to be thresholded.
      }
      \sstsubsection{
         THRLO = ? (Given)
      }{
         Upper threshold level.
      }
      \sstsubsection{
         THRHI = ? (Given)
      }{
         Lower threshold level.
      }
      \sstsubsection{
         NEWLO = ? (Given)
      }{
         Value to which pixels below THRLO will be set.
      }
      \sstsubsection{
         NEWHI = ? (Given)
      }{
         Value to which pixels above THRHI will be set.
      }
      \sstsubsection{
         NREPLO = ? (Returned)
      }{
         The number of values less than the lower threshold and
         substituted.
      }
      \sstsubsection{
         NREPHI = ? (Returned)
      }{
         The number of values greater than the upper threshold and
         substituted.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         Output thresholded data.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays and values supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_THRSD
}{
   Sets pixels in array to defined new values outside limits
}{
   \sstdescription{
      This routine takes an array and sets all values above a defined
      upper threshold to a new defined value, and sets all those below a
      defined lower threshold to another defined value.  In practice,
      all values outside the two thresholds may be set to zero or
      the bad value, for example.

      If the lower threshold is greater than or equal to the uper
      threshold, the values between the thresholds are set to the
      supplied lower replacement value, and the upper replacement value
      is ignored. In this case the number of replaced pixels is returned
      in NREPLO, and NREPHI is returned as -1.
   }
   \sstinvocation{
      CALL KPG1\_THRSD( BAD, EL, INARR, THRLO, THRHI, NEWLO, NEWHI,
                       OUTARR, NREPLO, NREPHI, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         The bad-pixel flag.  If it is .TRUE., tests are made for bad
         array values.  When .FALSE., no tests are made for bad values,
         and any encountered are treated literally.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Dimension of the input and output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         Input data to be thresholded.
      }
      \sstsubsection{
         THRLO = ? (Given)
      }{
         Upper threshold level.
      }
      \sstsubsection{
         THRHI = ? (Given)
      }{
         Lower threshold level.
      }
      \sstsubsection{
         NEWLO = ? (Given)
      }{
         Value to which pixels below THRLO will be set.
      }
      \sstsubsection{
         NEWHI = ? (Given)
      }{
         Value to which pixels above THRHI will be set.
      }
      \sstsubsection{
         NREPLO = ? (Returned)
      }{
         The number of values less than the lower threshold and
         substituted.
      }
      \sstsubsection{
         NREPHI = ? (Returned)
      }{
         The number of values greater than the upper threshold and
         substituted.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         Output thresholded data.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays and values supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_THRSI
}{
   Sets pixels in array to defined new values outside limits
}{
   \sstdescription{
      This routine takes an array and sets all values above a defined
      upper threshold to a new defined value, and sets all those below a
      defined lower threshold to another defined value.  In practice,
      all values outside the two thresholds may be set to zero or
      the bad value, for example.

      If the lower threshold is greater than or equal to the uper
      threshold, the values between the thresholds are set to the
      supplied lower replacement value, and the upper replacement value
      is ignored. In this case the number of replaced pixels is returned
      in NREPLO, and NREPHI is returned as -1.
   }
   \sstinvocation{
      CALL KPG1\_THRSI( BAD, EL, INARR, THRLO, THRHI, NEWLO, NEWHI,
                       OUTARR, NREPLO, NREPHI, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         The bad-pixel flag.  If it is .TRUE., tests are made for bad
         array values.  When .FALSE., no tests are made for bad values,
         and any encountered are treated literally.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Dimension of the input and output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         Input data to be thresholded.
      }
      \sstsubsection{
         THRLO = ? (Given)
      }{
         Upper threshold level.
      }
      \sstsubsection{
         THRHI = ? (Given)
      }{
         Lower threshold level.
      }
      \sstsubsection{
         NEWLO = ? (Given)
      }{
         Value to which pixels below THRLO will be set.
      }
      \sstsubsection{
         NEWHI = ? (Given)
      }{
         Value to which pixels above THRHI will be set.
      }
      \sstsubsection{
         NREPLO = ? (Returned)
      }{
         The number of values less than the lower threshold and
         substituted.
      }
      \sstsubsection{
         NREPHI = ? (Returned)
      }{
         The number of values greater than the upper threshold and
         substituted.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         Output thresholded data.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays and values supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_THRSR
}{
   Sets pixels in array to defined new values outside limits
}{
   \sstdescription{
      This routine takes an array and sets all values above a defined
      upper threshold to a new defined value, and sets all those below a
      defined lower threshold to another defined value.  In practice,
      all values outside the two thresholds may be set to zero or
      the bad value, for example.

      If the lower threshold is greater than or equal to the uper
      threshold, the values between the thresholds are set to the
      supplied lower replacement value, and the upper replacement value
      is ignored. In this case the number of replaced pixels is returned
      in NREPLO, and NREPHI is returned as -1.
   }
   \sstinvocation{
      CALL KPG1\_THRSR( BAD, EL, INARR, THRLO, THRHI, NEWLO, NEWHI,
                       OUTARR, NREPLO, NREPHI, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         The bad-pixel flag.  If it is .TRUE., tests are made for bad
         array values.  When .FALSE., no tests are made for bad values,
         and any encountered are treated literally.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Dimension of the input and output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         Input data to be thresholded.
      }
      \sstsubsection{
         THRLO = ? (Given)
      }{
         Upper threshold level.
      }
      \sstsubsection{
         THRHI = ? (Given)
      }{
         Lower threshold level.
      }
      \sstsubsection{
         NEWLO = ? (Given)
      }{
         Value to which pixels below THRLO will be set.
      }
      \sstsubsection{
         NEWHI = ? (Given)
      }{
         Value to which pixels above THRHI will be set.
      }
      \sstsubsection{
         NREPLO = ? (Returned)
      }{
         The number of values less than the lower threshold and
         substituted.
      }
      \sstsubsection{
         NREPHI = ? (Returned)
      }{
         The number of values greater than the upper threshold and
         substituted.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         Output thresholded data.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays and values supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_THRSUB
}{
   Sets pixels in array to defined new values outside limits
}{
   \sstdescription{
      This routine takes an array and sets all values above a defined
      upper threshold to a new defined value, and sets all those below a
      defined lower threshold to another defined value.  In practice,
      all values outside the two thresholds may be set to zero or
      the bad value, for example.

      If the lower threshold is greater than or equal to the uper
      threshold, the values between the thresholds are set to the
      supplied lower replacement value, and the upper replacement value
      is ignored. In this case the number of replaced pixels is returned
      in NREPLO, and NREPHI is returned as -1.
   }
   \sstinvocation{
      CALL KPG1\_THRSUB( BAD, EL, INARR, THRLO, THRHI, NEWLO, NEWHI,
                       OUTARR, NREPLO, NREPHI, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         The bad-pixel flag.  If it is .TRUE., tests are made for bad
         array values.  When .FALSE., no tests are made for bad values,
         and any encountered are treated literally.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Dimension of the input and output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         Input data to be thresholded.
      }
      \sstsubsection{
         THRLO = ? (Given)
      }{
         Upper threshold level.
      }
      \sstsubsection{
         THRHI = ? (Given)
      }{
         Lower threshold level.
      }
      \sstsubsection{
         NEWLO = ? (Given)
      }{
         Value to which pixels below THRLO will be set.
      }
      \sstsubsection{
         NEWHI = ? (Given)
      }{
         Value to which pixels above THRHI will be set.
      }
      \sstsubsection{
         NREPLO = ? (Returned)
      }{
         The number of values less than the lower threshold and
         substituted.
      }
      \sstsubsection{
         NREPHI = ? (Returned)
      }{
         The number of values greater than the upper threshold and
         substituted.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         Output thresholded data.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays and values supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_THRSUW
}{
   Sets pixels in array to defined new values outside limits
}{
   \sstdescription{
      This routine takes an array and sets all values above a defined
      upper threshold to a new defined value, and sets all those below a
      defined lower threshold to another defined value.  In practice,
      all values outside the two thresholds may be set to zero or
      the bad value, for example.

      If the lower threshold is greater than or equal to the uper
      threshold, the values between the thresholds are set to the
      supplied lower replacement value, and the upper replacement value
      is ignored. In this case the number of replaced pixels is returned
      in NREPLO, and NREPHI is returned as -1.
   }
   \sstinvocation{
      CALL KPG1\_THRSUW( BAD, EL, INARR, THRLO, THRHI, NEWLO, NEWHI,
                       OUTARR, NREPLO, NREPHI, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         The bad-pixel flag.  If it is .TRUE., tests are made for bad
         array values.  When .FALSE., no tests are made for bad values,
         and any encountered are treated literally.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Dimension of the input and output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         Input data to be thresholded.
      }
      \sstsubsection{
         THRLO = ? (Given)
      }{
         Upper threshold level.
      }
      \sstsubsection{
         THRHI = ? (Given)
      }{
         Lower threshold level.
      }
      \sstsubsection{
         NEWLO = ? (Given)
      }{
         Value to which pixels below THRLO will be set.
      }
      \sstsubsection{
         NEWHI = ? (Given)
      }{
         Value to which pixels above THRHI will be set.
      }
      \sstsubsection{
         NREPLO = ? (Returned)
      }{
         The number of values less than the lower threshold and
         substituted.
      }
      \sstsubsection{
         NREPHI = ? (Returned)
      }{
         The number of values greater than the upper threshold and
         substituted.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         Output thresholded data.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays and values supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_THRSW
}{
   Sets pixels in array to defined new values outside limits
}{
   \sstdescription{
      This routine takes an array and sets all values above a defined
      upper threshold to a new defined value, and sets all those below a
      defined lower threshold to another defined value.  In practice,
      all values outside the two thresholds may be set to zero or
      the bad value, for example.

      If the lower threshold is greater than or equal to the uper
      threshold, the values between the thresholds are set to the
      supplied lower replacement value, and the upper replacement value
      is ignored. In this case the number of replaced pixels is returned
      in NREPLO, and NREPHI is returned as -1.
   }
   \sstinvocation{
      CALL KPG1\_THRSW( BAD, EL, INARR, THRLO, THRHI, NEWLO, NEWHI,
                       OUTARR, NREPLO, NREPHI, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         The bad-pixel flag.  If it is .TRUE., tests are made for bad
         array values.  When .FALSE., no tests are made for bad values,
         and any encountered are treated literally.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Dimension of the input and output arrays.
      }
      \sstsubsection{
         INARR( EL ) = ? (Given)
      }{
         Input data to be thresholded.
      }
      \sstsubsection{
         THRLO = ? (Given)
      }{
         Upper threshold level.
      }
      \sstsubsection{
         THRHI = ? (Given)
      }{
         Lower threshold level.
      }
      \sstsubsection{
         NEWLO = ? (Given)
      }{
         Value to which pixels below THRLO will be set.
      }
      \sstsubsection{
         NEWHI = ? (Given)
      }{
         Value to which pixels above THRHI will be set.
      }
      \sstsubsection{
         NREPLO = ? (Returned)
      }{
         The number of values less than the lower threshold and
         substituted.
      }
      \sstsubsection{
         NREPHI = ? (Returned)
      }{
         The number of values greater than the upper threshold and
         substituted.
      }
      \sstsubsection{
         OUTARR( EL ) = ? (Returned)
      }{
         Output thresholded data.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         Global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         arrays and values supplied to the routine must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_TRALx
}{
   Finds the extreme co-ordinates of an n-d array after being
   transformed
}{
   \sstdescription{
      This routine applies a forward mapping to the co-ordinates
      of all pixel corners in an n-dimensional array in order to find
      the limits of the array after a transformation (forward mapping)
      has been applied.  It assumes equally spaced co-ordinates which
      will be true for pixel co-ordinates and many sets of data
      co-ordinates, but should be adequate even for unevenly spaced
      data co-ordinates.  It will only give poor results for strange
      transformations with singularities.
   }
   \sstinvocation{
      CALL KPG1\_TRALx( NDIMI, IDIMS, LBND, UBND, TRID, IEL, NDIMO, COIN, COOUT,
                       COMIN, COMAX, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input array.
      }
      \sstsubsection{
         IDIMS( NDIMI ) = INTEGER (Given)
      }{
         The dimensions of the associated input n-dimensional data
         array.
      }
      \sstsubsection{
         LBND( NDIMI ) = ? (Given)
      }{
         The co-ordinates of the lower bounds of the associated input
         n-dimensional array.
      }
      \sstsubsection{
         UBND( NDIMI ) = ? (Given)
      }{
         The co-ordinates of the upper bounds of the associated input
         n-dimensional array.
      }
      \sstsubsection{
         TRID = INTEGER (Given)
      }{
         The TRANSFORM identifier of the mapping.
      }
      \sstsubsection{
         IEL = INTEGER (Given)
      }{
         The first dimension of the work arrays.  It should be at least
         IDIMS( 1 ) $+$ 1.
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output array.
      }
      \sstsubsection{
         COIN( IEL, NDIMI ) = DOUBLE PRECISION (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points
         in the input array.
      }
      \sstsubsection{
         COOUT( IEL, NDIMO ) = DOUBLE PRECISION (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points in
         the output array.
      }
      \sstsubsection{
         COMIN( NDIMO ) = ? (Returned)
      }{
         The minimum co-ordinate along each dimension of the output
         array.
      }
      \sstsubsection{
         COMAX( NDIMO ) = ? (Returned)
      }{
         The maximum co-ordinate along each dimension of the output
         array.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
         input co-ordinate work arrays and the output limiting-co-ordinate
         arrays must have the data type specified.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_TRALx
}{
   Finds the extreme co-ordinates of an n-d array after being
   transformed
}{
   \sstdescription{
      This routine applies a forward mapping to the co-ordinates
      of all pixel corners in an n-dimensional array in order to find
      the limits of the array after a transformation (forward mapping)
      has been applied.  It assumes equally spaced co-ordinates which
      will be true for pixel co-ordinates and many sets of data
      co-ordinates, but should be adequate even for unevenly spaced
      data co-ordinates.  It will only give poor results for strange
      transformations with singularities.
   }
   \sstinvocation{
      CALL KPG1\_TRALx( NDIMI, IDIMS, LBND, UBND, TRID, IEL, NDIMO, COIN, COOUT,
                       COMIN, COMAX, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input array.
      }
      \sstsubsection{
         IDIMS( NDIMI ) = INTEGER (Given)
      }{
         The dimensions of the associated input n-dimensional data
         array.
      }
      \sstsubsection{
         LBND( NDIMI ) = ? (Given)
      }{
         The co-ordinates of the lower bounds of the associated input
         n-dimensional array.
      }
      \sstsubsection{
         UBND( NDIMI ) = ? (Given)
      }{
         The co-ordinates of the upper bounds of the associated input
         n-dimensional array.
      }
      \sstsubsection{
         TRID = INTEGER (Given)
      }{
         The TRANSFORM identifier of the mapping.
      }
      \sstsubsection{
         IEL = INTEGER (Given)
      }{
         The first dimension of the work arrays.  It should be at least
         IDIMS( 1 ) $+$ 1.
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output array.
      }
      \sstsubsection{
         COIN( IEL, NDIMI ) = DOUBLE PRECISION (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points
         in the input array.
      }
      \sstsubsection{
         COOUT( IEL, NDIMO ) = DOUBLE PRECISION (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points in
         the output array.
      }
      \sstsubsection{
         COMIN( NDIMO ) = ? (Returned)
      }{
         The minimum co-ordinate along each dimension of the output
         array.
      }
      \sstsubsection{
         COMAX( NDIMO ) = ? (Returned)
      }{
         The maximum co-ordinate along each dimension of the output
         array.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
         input co-ordinate work arrays and the output limiting-co-ordinate
         arrays must have the data type specified.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_TRBOx
}{
   Finds the extreme co-ordinates of an n-d array after being
   transformed
}{
   \sstdescription{
      This routine applies a forward mapping to the pixel co-ordinates
      of test points in an n-dimensional array in order to find the
      limits of the array after a transformation (forward mapping) has
      been applied.  The test points are the vertices and the midpoints
      between them.
   }
   \sstinvocation{
      CALL KPG1\_TRBOx( NDIMI, LBND, UBND, TRID, NDIMO, COMIN, COMAX,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input array.
      }
      \sstsubsection{
         LBND( NDIMI ) = ? (Given)
      }{
         The co-ordinates of the lower bounds of the input n-dimensional
         array.
      }
      \sstsubsection{
         UBND( NDIMI ) = ? (Given)
      }{
         The co-ordinates of the upper bounds of the input n-dimensional
         array.
      }
      \sstsubsection{
         TRID = INTEGER (Given)
      }{
         The TRANSFORM identifier of the mapping.
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output array.
      }
      \sstsubsection{
         COMIN( NDIMO ) = ? (Returned)
      }{
         The minimum co-ordinate along each dimension of the output
         array.
      }
      \sstsubsection{
         COMAX( NDIMO ) = ? (Returned)
      }{
         The maximum co-ordinate along each dimension of the output
         array.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
         input co-ordinate bounds and the output limiting-co-ordinate
         arrays must have the data type specified.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_TRBOx
}{
   Finds the extreme co-ordinates of an n-d array after being
   transformed
}{
   \sstdescription{
      This routine applies a forward mapping to the pixel co-ordinates
      of test points in an n-dimensional array in order to find the
      limits of the array after a transformation (forward mapping) has
      been applied.  The test points are the vertices and the midpoints
      between them.
   }
   \sstinvocation{
      CALL KPG1\_TRBOx( NDIMI, LBND, UBND, TRID, NDIMO, COMIN, COMAX,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input array.
      }
      \sstsubsection{
         LBND( NDIMI ) = ? (Given)
      }{
         The co-ordinates of the lower bounds of the input n-dimensional
         array.
      }
      \sstsubsection{
         UBND( NDIMI ) = ? (Given)
      }{
         The co-ordinates of the upper bounds of the input n-dimensional
         array.
      }
      \sstsubsection{
         TRID = INTEGER (Given)
      }{
         The TRANSFORM identifier of the mapping.
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output array.
      }
      \sstsubsection{
         COMIN( NDIMO ) = ? (Returned)
      }{
         The minimum co-ordinate along each dimension of the output
         array.
      }
      \sstsubsection{
         COMAX( NDIMO ) = ? (Returned)
      }{
         The maximum co-ordinate along each dimension of the output
         array.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
         input co-ordinate bounds and the output limiting-co-ordinate
         arrays must have the data type specified.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_TRIGD
}{
   Apply a trig function to each element of a vectorised array
}{
   \sstdescription{
      The routine applied a specified trig function to each element of a
      vectorised array. Any associated variance values are also modified
      appropriately.
   }
   \sstinvocation{
      CALL KPG1\_TRIGD( BAD, VAR, TRIGFN, EL, DIN, VIN, DOUT, VOUT, NBAD,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input arrays.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         Have associated variances been supplied?
      }
      \sstsubsection{
         TRIGFN = CHARACTER$*$($*$) (Given)
      }{
         The required trig function. This should be one of SIN, COS, TAN,
         SIND, COSD, TAND, ASIN, ACOS, ATAN, ASIND, ACOSD, ATAND.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         DIN( EL ) = DOUBLE PRECISION (Given)
      }{
         Input data array.
      }
      \sstsubsection{
         VIN( EL ) = DOUBLE PRECISION (Given)
      }{
         Input variance array. Only accessed if VAR is .TRUE.
      }
      \sstsubsection{
         DOUT( EL ) = DOUBLE PRECISION (Given)
      }{
         Output data array.
      }
      \sstsubsection{
         VOUT( EL ) = DOUBLE PRECISION (Given)
      }{
         Output variance array. Only accessed if VAR is .TRUE.
      }
      \sstsubsection{
         NBAD( 2 ) = INTEGER (Returned)
      }{
         Element 1 has the number of bad values stored in DOUT, and element
         2 has the number of bad values stored in VOUT.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_TRIGR
}{
   Apply a trig function to each element of a vectorised array
}{
   \sstdescription{
      The routine applied a specified trig function to each element of a
      vectorised array. Any associated variance values are also modified
      appropriately.
   }
   \sstinvocation{
      CALL KPG1\_TRIGR( BAD, VAR, TRIGFN, EL, DIN, VIN, DOUT, VOUT, NBAD,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Whether to check for bad values in the input arrays.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         Have associated variances been supplied?
      }
      \sstsubsection{
         TRIGFN = CHARACTER$*$($*$) (Given)
      }{
         The required trig function. This should be one of SIN, COS, TAN,
         SIND, COSD, TAND, ASIN, ACOS, ATAN, ASIND, ACOSD, ATAND.
      }
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         Number of array elements to process.
      }
      \sstsubsection{
         DIN( EL ) = REAL (Given)
      }{
         Input data array.
      }
      \sstsubsection{
         VIN( EL ) = REAL (Given)
      }{
         Input variance array. Only accessed if VAR is .TRUE.
      }
      \sstsubsection{
         DOUT( EL ) = REAL (Given)
      }{
         Output data array.
      }
      \sstsubsection{
         VOUT( EL ) = REAL (Given)
      }{
         Output variance array. Only accessed if VAR is .TRUE.
      }
      \sstsubsection{
         NBAD( 2 ) = INTEGER (Returned)
      }{
         Element 1 has the number of bad values stored in DOUT, and element
         2 has the number of bad values stored in VOUT.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_TRLIx
}{
   Applies a constant-determinant transformation to an array by
   linear interpolation
}{
   \sstdescription{
      This routine creates a new n-dimensional array from an input
      m-dimensional array by applying a constant-determininant
      transformation to all the elements of the output array.  Each
      output value is calculated by linear interpolation between the
      elements in the input array that surround each transformed
      co-ordinate.  The transformation must convert from output
      co-ordinates to input pixel indices.  The two arrays may have
      different numbers of dimensions. In addition a variance array may
      be created likewise.

      This routine operates with single-precision co-ordinates.  Use
      KPG1\_TDLIx for double precision.
   }
   \sstinvocation{
      CALL KPG1\_TRLIx( NDIMI, IDIMS, INARR, VAR, INVAR, TRID, FLUX,
                       AXES, OEL, NDIMO, OLBND, ODIMS, OUTARR, OUTVAR,
                       COIN, COOUT, INDICE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input arrays.  It must be greater
         than one.  To handle a one-dimensional array, give it a second
         dummy dimension of 1.
      }
      \sstsubsection{
         IDIMS( NDIMI ) = INTEGER (Given)
      }{
         The dimensions of the input n-D arrays.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-D data array.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If VAR is .TRUE. there is a variance array to create from an
         input variance array.
      }
      \sstsubsection{
         INVAR( $*$ ) = ? (Given)
      }{
         The input n-D variance array.  When VAR is .FALSE., this can
         contain an arbitrary number of elements.  When VAR is .TRUE.
         it must have the shape of the input data array.
      }
      \sstsubsection{
         FLUX = DOUBLE PRECISION (Given)
      }{
         The factor to multiply the values in the output arrays to
         preserve the flux.  This will be the determinant of the
         transformation.  Set this to 1.0 if no flux conservation is
         required.
      }
      \sstsubsection{
         AXES( $*$ ) = REAL (Given)
      }{
         The concatenated axis co-ordinates of the input array.  This
         array should therefore have a dimension at least as large as
         the sum of the input array{\tt '}s dimensions.
      }
      \sstsubsection{
         OEL = INTEGER (Given)
      }{
         The first dimension of the work arrays.  It should be at least
         ODIMS( 1 ).
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output arrays.
      }
      \sstsubsection{
         OLBND( NDIMO ) = INTEGER (Given)
      }{
         The lower bounds of the output n-D arrays.
      }
      \sstsubsection{
         ODIMS( NDIMO ) = INTEGER (Given)
      }{
         The dimensions of the output n-D arrays.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Returned)
      }{
         The transformed data array.
      }
      \sstsubsection{
         OUTVAR( $*$ ) = ? (Returned)
      }{
         The variance array of the transformed data.
      }
      \sstsubsection{
         COIN( OEL, NDIMI ) = REAL (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points
         in the input arrays.
      }
      \sstsubsection{
         COOUT( OEL, NDIMO ) = REAL (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points in
         the output arrays.
      }
      \sstsubsection{
         INDICE( OEL, NDIMI ) = REAL (Returned)
      }{
         Workspace used to store the floating-point pixel indices of a
         row of points in the input arrays.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by B, D, I, R, UB, UW, or W as
         appropriate.  The input and output data and variance arrays must
         have the data type specified.

         \sstitem
         There is no protection against overflows when the absolute data
         values are very large.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_TRLIx
}{
   Applies a constant-determinant transformation to an array by
   linear interpolation
}{
   \sstdescription{
      This routine creates a new n-dimensional array from an input
      m-dimensional array by applying a constant-determininant
      transformation to all the elements of the output array.  Each
      output value is calculated by linear interpolation between the
      elements in the input array that surround each transformed
      co-ordinate.  The transformation must convert from output
      co-ordinates to input pixel indices.  The two arrays may have
      different numbers of dimensions. In addition a variance array may
      be created likewise.

      This routine operates with single-precision co-ordinates.  Use
      KPG1\_TDLIx for double precision.
   }
   \sstinvocation{
      CALL KPG1\_TRLIx( NDIMI, IDIMS, INARR, VAR, INVAR, TRID, FLUX,
                       AXES, OEL, NDIMO, OLBND, ODIMS, OUTARR, OUTVAR,
                       COIN, COOUT, INDICE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input arrays.  It must be greater
         than one.  To handle a one-dimensional array, give it a second
         dummy dimension of 1.
      }
      \sstsubsection{
         IDIMS( NDIMI ) = INTEGER (Given)
      }{
         The dimensions of the input n-D arrays.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-D data array.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If VAR is .TRUE. there is a variance array to create from an
         input variance array.
      }
      \sstsubsection{
         INVAR( $*$ ) = ? (Given)
      }{
         The input n-D variance array.  When VAR is .FALSE., this can
         contain an arbitrary number of elements.  When VAR is .TRUE.
         it must have the shape of the input data array.
      }
      \sstsubsection{
         FLUX = DOUBLE PRECISION (Given)
      }{
         The factor to multiply the values in the output arrays to
         preserve the flux.  This will be the determinant of the
         transformation.  Set this to 1.0 if no flux conservation is
         required.
      }
      \sstsubsection{
         AXES( $*$ ) = REAL (Given)
      }{
         The concatenated axis co-ordinates of the input array.  This
         array should therefore have a dimension at least as large as
         the sum of the input array{\tt '}s dimensions.
      }
      \sstsubsection{
         OEL = INTEGER (Given)
      }{
         The first dimension of the work arrays.  It should be at least
         ODIMS( 1 ).
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output arrays.
      }
      \sstsubsection{
         OLBND( NDIMO ) = INTEGER (Given)
      }{
         The lower bounds of the output n-D arrays.
      }
      \sstsubsection{
         ODIMS( NDIMO ) = INTEGER (Given)
      }{
         The dimensions of the output n-D arrays.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Returned)
      }{
         The transformed data array.
      }
      \sstsubsection{
         OUTVAR( $*$ ) = ? (Returned)
      }{
         The variance array of the transformed data.
      }
      \sstsubsection{
         COIN( OEL, NDIMI ) = REAL (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points
         in the input arrays.
      }
      \sstsubsection{
         COOUT( OEL, NDIMO ) = REAL (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points in
         the output arrays.
      }
      \sstsubsection{
         INDICE( OEL, NDIMI ) = REAL (Returned)
      }{
         Workspace used to store the floating-point pixel indices of a
         row of points in the input arrays.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by B, D, I, R, UB, UW, or W as
         appropriate.  The input and output data and variance arrays must
         have the data type specified.

         \sstitem
         There is no protection against overflows when the absolute data
         values are very large.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_TRLIx
}{
   Applies a constant-determinant transformation to an array by
   linear interpolation
}{
   \sstdescription{
      This routine creates a new n-dimensional array from an input
      m-dimensional array by applying a constant-determininant
      transformation to all the elements of the output array.  Each
      output value is calculated by linear interpolation between the
      elements in the input array that surround each transformed
      co-ordinate.  The transformation must convert from output
      co-ordinates to input pixel indices.  The two arrays may have
      different numbers of dimensions. In addition a variance array may
      be created likewise.

      This routine operates with single-precision co-ordinates.  Use
      KPG1\_TDLIx for double precision.
   }
   \sstinvocation{
      CALL KPG1\_TRLIx( NDIMI, IDIMS, INARR, VAR, INVAR, TRID, FLUX,
                       AXES, OEL, NDIMO, OLBND, ODIMS, OUTARR, OUTVAR,
                       COIN, COOUT, INDICE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input arrays.  It must be greater
         than one.  To handle a one-dimensional array, give it a second
         dummy dimension of 1.
      }
      \sstsubsection{
         IDIMS( NDIMI ) = INTEGER (Given)
      }{
         The dimensions of the input n-D arrays.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-D data array.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If VAR is .TRUE. there is a variance array to create from an
         input variance array.
      }
      \sstsubsection{
         INVAR( $*$ ) = ? (Given)
      }{
         The input n-D variance array.  When VAR is .FALSE., this can
         contain an arbitrary number of elements.  When VAR is .TRUE.
         it must have the shape of the input data array.
      }
      \sstsubsection{
         FLUX = DOUBLE PRECISION (Given)
      }{
         The factor to multiply the values in the output arrays to
         preserve the flux.  This will be the determinant of the
         transformation.  Set this to 1.0 if no flux conservation is
         required.
      }
      \sstsubsection{
         AXES( $*$ ) = REAL (Given)
      }{
         The concatenated axis co-ordinates of the input array.  This
         array should therefore have a dimension at least as large as
         the sum of the input array{\tt '}s dimensions.
      }
      \sstsubsection{
         OEL = INTEGER (Given)
      }{
         The first dimension of the work arrays.  It should be at least
         ODIMS( 1 ).
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output arrays.
      }
      \sstsubsection{
         OLBND( NDIMO ) = INTEGER (Given)
      }{
         The lower bounds of the output n-D arrays.
      }
      \sstsubsection{
         ODIMS( NDIMO ) = INTEGER (Given)
      }{
         The dimensions of the output n-D arrays.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Returned)
      }{
         The transformed data array.
      }
      \sstsubsection{
         OUTVAR( $*$ ) = ? (Returned)
      }{
         The variance array of the transformed data.
      }
      \sstsubsection{
         COIN( OEL, NDIMI ) = REAL (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points
         in the input arrays.
      }
      \sstsubsection{
         COOUT( OEL, NDIMO ) = REAL (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points in
         the output arrays.
      }
      \sstsubsection{
         INDICE( OEL, NDIMI ) = REAL (Returned)
      }{
         Workspace used to store the floating-point pixel indices of a
         row of points in the input arrays.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by B, D, I, R, UB, UW, or W as
         appropriate.  The input and output data and variance arrays must
         have the data type specified.

         \sstitem
         There is no protection against overflows when the absolute data
         values are very large.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_TRLIx
}{
   Applies a constant-determinant transformation to an array by
   linear interpolation
}{
   \sstdescription{
      This routine creates a new n-dimensional array from an input
      m-dimensional array by applying a constant-determininant
      transformation to all the elements of the output array.  Each
      output value is calculated by linear interpolation between the
      elements in the input array that surround each transformed
      co-ordinate.  The transformation must convert from output
      co-ordinates to input pixel indices.  The two arrays may have
      different numbers of dimensions. In addition a variance array may
      be created likewise.

      This routine operates with single-precision co-ordinates.  Use
      KPG1\_TDLIx for double precision.
   }
   \sstinvocation{
      CALL KPG1\_TRLIx( NDIMI, IDIMS, INARR, VAR, INVAR, TRID, FLUX,
                       AXES, OEL, NDIMO, OLBND, ODIMS, OUTARR, OUTVAR,
                       COIN, COOUT, INDICE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input arrays.  It must be greater
         than one.  To handle a one-dimensional array, give it a second
         dummy dimension of 1.
      }
      \sstsubsection{
         IDIMS( NDIMI ) = INTEGER (Given)
      }{
         The dimensions of the input n-D arrays.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-D data array.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If VAR is .TRUE. there is a variance array to create from an
         input variance array.
      }
      \sstsubsection{
         INVAR( $*$ ) = ? (Given)
      }{
         The input n-D variance array.  When VAR is .FALSE., this can
         contain an arbitrary number of elements.  When VAR is .TRUE.
         it must have the shape of the input data array.
      }
      \sstsubsection{
         FLUX = DOUBLE PRECISION (Given)
      }{
         The factor to multiply the values in the output arrays to
         preserve the flux.  This will be the determinant of the
         transformation.  Set this to 1.0 if no flux conservation is
         required.
      }
      \sstsubsection{
         AXES( $*$ ) = REAL (Given)
      }{
         The concatenated axis co-ordinates of the input array.  This
         array should therefore have a dimension at least as large as
         the sum of the input array{\tt '}s dimensions.
      }
      \sstsubsection{
         OEL = INTEGER (Given)
      }{
         The first dimension of the work arrays.  It should be at least
         ODIMS( 1 ).
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output arrays.
      }
      \sstsubsection{
         OLBND( NDIMO ) = INTEGER (Given)
      }{
         The lower bounds of the output n-D arrays.
      }
      \sstsubsection{
         ODIMS( NDIMO ) = INTEGER (Given)
      }{
         The dimensions of the output n-D arrays.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Returned)
      }{
         The transformed data array.
      }
      \sstsubsection{
         OUTVAR( $*$ ) = ? (Returned)
      }{
         The variance array of the transformed data.
      }
      \sstsubsection{
         COIN( OEL, NDIMI ) = REAL (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points
         in the input arrays.
      }
      \sstsubsection{
         COOUT( OEL, NDIMO ) = REAL (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points in
         the output arrays.
      }
      \sstsubsection{
         INDICE( OEL, NDIMI ) = REAL (Returned)
      }{
         Workspace used to store the floating-point pixel indices of a
         row of points in the input arrays.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by B, D, I, R, UB, UW, or W as
         appropriate.  The input and output data and variance arrays must
         have the data type specified.

         \sstitem
         There is no protection against overflows when the absolute data
         values are very large.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_TRLIx
}{
   Applies a constant-determinant transformation to an array by
   linear interpolation
}{
   \sstdescription{
      This routine creates a new n-dimensional array from an input
      m-dimensional array by applying a constant-determininant
      transformation to all the elements of the output array.  Each
      output value is calculated by linear interpolation between the
      elements in the input array that surround each transformed
      co-ordinate.  The transformation must convert from output
      co-ordinates to input pixel indices.  The two arrays may have
      different numbers of dimensions. In addition a variance array may
      be created likewise.

      This routine operates with single-precision co-ordinates.  Use
      KPG1\_TDLIx for double precision.
   }
   \sstinvocation{
      CALL KPG1\_TRLIx( NDIMI, IDIMS, INARR, VAR, INVAR, TRID, FLUX,
                       AXES, OEL, NDIMO, OLBND, ODIMS, OUTARR, OUTVAR,
                       COIN, COOUT, INDICE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input arrays.  It must be greater
         than one.  To handle a one-dimensional array, give it a second
         dummy dimension of 1.
      }
      \sstsubsection{
         IDIMS( NDIMI ) = INTEGER (Given)
      }{
         The dimensions of the input n-D arrays.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-D data array.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If VAR is .TRUE. there is a variance array to create from an
         input variance array.
      }
      \sstsubsection{
         INVAR( $*$ ) = ? (Given)
      }{
         The input n-D variance array.  When VAR is .FALSE., this can
         contain an arbitrary number of elements.  When VAR is .TRUE.
         it must have the shape of the input data array.
      }
      \sstsubsection{
         FLUX = DOUBLE PRECISION (Given)
      }{
         The factor to multiply the values in the output arrays to
         preserve the flux.  This will be the determinant of the
         transformation.  Set this to 1.0 if no flux conservation is
         required.
      }
      \sstsubsection{
         AXES( $*$ ) = REAL (Given)
      }{
         The concatenated axis co-ordinates of the input array.  This
         array should therefore have a dimension at least as large as
         the sum of the input array{\tt '}s dimensions.
      }
      \sstsubsection{
         OEL = INTEGER (Given)
      }{
         The first dimension of the work arrays.  It should be at least
         ODIMS( 1 ).
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output arrays.
      }
      \sstsubsection{
         OLBND( NDIMO ) = INTEGER (Given)
      }{
         The lower bounds of the output n-D arrays.
      }
      \sstsubsection{
         ODIMS( NDIMO ) = INTEGER (Given)
      }{
         The dimensions of the output n-D arrays.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Returned)
      }{
         The transformed data array.
      }
      \sstsubsection{
         OUTVAR( $*$ ) = ? (Returned)
      }{
         The variance array of the transformed data.
      }
      \sstsubsection{
         COIN( OEL, NDIMI ) = REAL (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points
         in the input arrays.
      }
      \sstsubsection{
         COOUT( OEL, NDIMO ) = REAL (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points in
         the output arrays.
      }
      \sstsubsection{
         INDICE( OEL, NDIMI ) = REAL (Returned)
      }{
         Workspace used to store the floating-point pixel indices of a
         row of points in the input arrays.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by B, D, I, R, UB, UW, or W as
         appropriate.  The input and output data and variance arrays must
         have the data type specified.

         \sstitem
         There is no protection against overflows when the absolute data
         values are very large.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_TRLIx
}{
   Applies a constant-determinant transformation to an array by
   linear interpolation
}{
   \sstdescription{
      This routine creates a new n-dimensional array from an input
      m-dimensional array by applying a constant-determininant
      transformation to all the elements of the output array.  Each
      output value is calculated by linear interpolation between the
      elements in the input array that surround each transformed
      co-ordinate.  The transformation must convert from output
      co-ordinates to input pixel indices.  The two arrays may have
      different numbers of dimensions. In addition a variance array may
      be created likewise.

      This routine operates with single-precision co-ordinates.  Use
      KPG1\_TDLIx for double precision.
   }
   \sstinvocation{
      CALL KPG1\_TRLIx( NDIMI, IDIMS, INARR, VAR, INVAR, TRID, FLUX,
                       AXES, OEL, NDIMO, OLBND, ODIMS, OUTARR, OUTVAR,
                       COIN, COOUT, INDICE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input arrays.  It must be greater
         than one.  To handle a one-dimensional array, give it a second
         dummy dimension of 1.
      }
      \sstsubsection{
         IDIMS( NDIMI ) = INTEGER (Given)
      }{
         The dimensions of the input n-D arrays.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-D data array.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If VAR is .TRUE. there is a variance array to create from an
         input variance array.
      }
      \sstsubsection{
         INVAR( $*$ ) = ? (Given)
      }{
         The input n-D variance array.  When VAR is .FALSE., this can
         contain an arbitrary number of elements.  When VAR is .TRUE.
         it must have the shape of the input data array.
      }
      \sstsubsection{
         FLUX = DOUBLE PRECISION (Given)
      }{
         The factor to multiply the values in the output arrays to
         preserve the flux.  This will be the determinant of the
         transformation.  Set this to 1.0 if no flux conservation is
         required.
      }
      \sstsubsection{
         AXES( $*$ ) = REAL (Given)
      }{
         The concatenated axis co-ordinates of the input array.  This
         array should therefore have a dimension at least as large as
         the sum of the input array{\tt '}s dimensions.
      }
      \sstsubsection{
         OEL = INTEGER (Given)
      }{
         The first dimension of the work arrays.  It should be at least
         ODIMS( 1 ).
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output arrays.
      }
      \sstsubsection{
         OLBND( NDIMO ) = INTEGER (Given)
      }{
         The lower bounds of the output n-D arrays.
      }
      \sstsubsection{
         ODIMS( NDIMO ) = INTEGER (Given)
      }{
         The dimensions of the output n-D arrays.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Returned)
      }{
         The transformed data array.
      }
      \sstsubsection{
         OUTVAR( $*$ ) = ? (Returned)
      }{
         The variance array of the transformed data.
      }
      \sstsubsection{
         COIN( OEL, NDIMI ) = REAL (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points
         in the input arrays.
      }
      \sstsubsection{
         COOUT( OEL, NDIMO ) = REAL (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points in
         the output arrays.
      }
      \sstsubsection{
         INDICE( OEL, NDIMI ) = REAL (Returned)
      }{
         Workspace used to store the floating-point pixel indices of a
         row of points in the input arrays.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by B, D, I, R, UB, UW, or W as
         appropriate.  The input and output data and variance arrays must
         have the data type specified.

         \sstitem
         There is no protection against overflows when the absolute data
         values are very large.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_TRLIx
}{
   Applies a constant-determinant transformation to an array by
   linear interpolation
}{
   \sstdescription{
      This routine creates a new n-dimensional array from an input
      m-dimensional array by applying a constant-determininant
      transformation to all the elements of the output array.  Each
      output value is calculated by linear interpolation between the
      elements in the input array that surround each transformed
      co-ordinate.  The transformation must convert from output
      co-ordinates to input pixel indices.  The two arrays may have
      different numbers of dimensions. In addition a variance array may
      be created likewise.

      This routine operates with single-precision co-ordinates.  Use
      KPG1\_TDLIx for double precision.
   }
   \sstinvocation{
      CALL KPG1\_TRLIx( NDIMI, IDIMS, INARR, VAR, INVAR, TRID, FLUX,
                       AXES, OEL, NDIMO, OLBND, ODIMS, OUTARR, OUTVAR,
                       COIN, COOUT, INDICE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input arrays.  It must be greater
         than one.  To handle a one-dimensional array, give it a second
         dummy dimension of 1.
      }
      \sstsubsection{
         IDIMS( NDIMI ) = INTEGER (Given)
      }{
         The dimensions of the input n-D arrays.
      }
      \sstsubsection{
         INARR( $*$ ) = ? (Given)
      }{
         The input n-D data array.
      }
      \sstsubsection{
         VAR = LOGICAL (Given)
      }{
         If VAR is .TRUE. there is a variance array to create from an
         input variance array.
      }
      \sstsubsection{
         INVAR( $*$ ) = ? (Given)
      }{
         The input n-D variance array.  When VAR is .FALSE., this can
         contain an arbitrary number of elements.  When VAR is .TRUE.
         it must have the shape of the input data array.
      }
      \sstsubsection{
         FLUX = DOUBLE PRECISION (Given)
      }{
         The factor to multiply the values in the output arrays to
         preserve the flux.  This will be the determinant of the
         transformation.  Set this to 1.0 if no flux conservation is
         required.
      }
      \sstsubsection{
         AXES( $*$ ) = REAL (Given)
      }{
         The concatenated axis co-ordinates of the input array.  This
         array should therefore have a dimension at least as large as
         the sum of the input array{\tt '}s dimensions.
      }
      \sstsubsection{
         OEL = INTEGER (Given)
      }{
         The first dimension of the work arrays.  It should be at least
         ODIMS( 1 ).
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output arrays.
      }
      \sstsubsection{
         OLBND( NDIMO ) = INTEGER (Given)
      }{
         The lower bounds of the output n-D arrays.
      }
      \sstsubsection{
         ODIMS( NDIMO ) = INTEGER (Given)
      }{
         The dimensions of the output n-D arrays.
      }
      \sstsubsection{
         OUTARR( $*$ ) = ? (Returned)
      }{
         The transformed data array.
      }
      \sstsubsection{
         OUTVAR( $*$ ) = ? (Returned)
      }{
         The variance array of the transformed data.
      }
      \sstsubsection{
         COIN( OEL, NDIMI ) = REAL (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points
         in the input arrays.
      }
      \sstsubsection{
         COOUT( OEL, NDIMO ) = REAL (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points in
         the output arrays.
      }
      \sstsubsection{
         INDICE( OEL, NDIMI ) = REAL (Returned)
      }{
         Workspace used to store the floating-point pixel indices of a
         row of points in the input arrays.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by B, D, I, R, UB, UW, or W as
         appropriate.  The input and output data and variance arrays must
         have the data type specified.

         \sstitem
         There is no protection against overflows when the absolute data
         values are very large.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_TRPIx
}{
   Finds vectorised pixel indices after applying a transformation to
   an array{\tt '}s pixel co-ordinates
}{
   \sstdescription{
      This routine applies a transformation to the pixel co-ordinates
      of the elements of an (output) n-dimensional array of a specified
      shape.  It then determines the nearest-neighbour element in the
      transformed (input) m-dimensional array, as a vector index, which
      is returned.  This array of vector indices may then be used by
      another routine to fill the output array with values from the
      input array.
   }
   \sstinvocation{
      CALL KPG1\_TRPIx( NDIMI, IDIMS, TRID, AXES, OEL, NDIMO, OLBND,
                       ODIMS, COIN, COOUT, FRIND, INDICE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input array.
      }
      \sstsubsection{
         IDIMS( NDIMI ) = INTEGER (Given)
      }{
         The dimensions of the input n-D array.
      }
      \sstsubsection{
         TRID = INTEGER (Given)
      }{
         The TRANSFORM identifier of the mapping.
      }
      \sstsubsection{
         AXES( $*$ ) = ? (Given)
      }{
         The concatenated axis co-ordinates of the input array.  This
         array should therefore have a dimension at least as large as
         the sum of the input array{\tt '}s dimensions.
      }
      \sstsubsection{
         OEL = INTEGER (Given)
      }{
         The first dimension of the work arrays.  It should be at least
         ODIMS( 1 ).
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output array.
      }
      \sstsubsection{
         OLBND( NDIMO ) = INTEGER (Given)
      }{
         The lower bounds of the output n-D array.
      }
      \sstsubsection{
         ODIMS( NDIMO ) = INTEGER (Given)
      }{
         The dimensions of the output n-D array.
      }
      \sstsubsection{
         COIN( OEL, NDIMI ) = ? (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points
         in the input array.
      }
      \sstsubsection{
         COOUT( OEL, NDIMO ) = ? (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points in
         the output array.
      }
      \sstsubsection{
         FRIND( OEL, NDIMI ) = ? (Returned)
      }{
         Workspace used to store the floating-point pixel indices of a
         row of points in the input array.
      }
      \sstsubsection{
         INDICE( $*$ ) = INTEGER (Returned)
      }{
         The vector indices of the nearest-array element of the
         transformed positions of the output array.  This array should
         therefore have a dimension at least as large as the product of
         the output array{\tt '}s dimensions.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
         workspace and axis arrays must have the data type specified.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_TRPIx
}{
   Finds vectorised pixel indices after applying a transformation to
   an array{\tt '}s pixel co-ordinates
}{
   \sstdescription{
      This routine applies a transformation to the pixel co-ordinates
      of the elements of an (output) n-dimensional array of a specified
      shape.  It then determines the nearest-neighbour element in the
      transformed (input) m-dimensional array, as a vector index, which
      is returned.  This array of vector indices may then be used by
      another routine to fill the output array with values from the
      input array.
   }
   \sstinvocation{
      CALL KPG1\_TRPIx( NDIMI, IDIMS, TRID, AXES, OEL, NDIMO, OLBND,
                       ODIMS, COIN, COOUT, FRIND, INDICE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NDIMI = INTEGER (Given)
      }{
         The dimensionality of the input array.
      }
      \sstsubsection{
         IDIMS( NDIMI ) = INTEGER (Given)
      }{
         The dimensions of the input n-D array.
      }
      \sstsubsection{
         TRID = INTEGER (Given)
      }{
         The TRANSFORM identifier of the mapping.
      }
      \sstsubsection{
         AXES( $*$ ) = ? (Given)
      }{
         The concatenated axis co-ordinates of the input array.  This
         array should therefore have a dimension at least as large as
         the sum of the input array{\tt '}s dimensions.
      }
      \sstsubsection{
         OEL = INTEGER (Given)
      }{
         The first dimension of the work arrays.  It should be at least
         ODIMS( 1 ).
      }
      \sstsubsection{
         NDIMO = INTEGER (Given)
      }{
         The dimensionality of the output array.
      }
      \sstsubsection{
         OLBND( NDIMO ) = INTEGER (Given)
      }{
         The lower bounds of the output n-D array.
      }
      \sstsubsection{
         ODIMS( NDIMO ) = INTEGER (Given)
      }{
         The dimensions of the output n-D array.
      }
      \sstsubsection{
         COIN( OEL, NDIMI ) = ? (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points
         in the input array.
      }
      \sstsubsection{
         COOUT( OEL, NDIMO ) = ? (Returned)
      }{
         Workspace used to store the co-ordinates of a row of points in
         the output array.
      }
      \sstsubsection{
         FRIND( OEL, NDIMI ) = ? (Returned)
      }{
         Workspace used to store the floating-point pixel indices of a
         row of points in the input array.
      }
      \sstsubsection{
         INDICE( $*$ ) = INTEGER (Returned)
      }{
         The vector indices of the nearest-array element of the
         transformed positions of the output array.  This array should
         therefore have a dimension at least as large as the product of
         the output array{\tt '}s dimensions.
      }
      \sstsubsection{
         STATUS  =  INTEGER (Given and Returned).
      }{
         Global status value
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for the following numeric data types:
         replace {\tt "}x{\tt "} in the routine name by D or R as appropriate.  The
         workspace and axis arrays must have the data type specified.
      }
   }
   \sstbugs{
      \{note\_bugs\_here\}
   }
}
\sstroutine{
   KPG1\_TRSPx
}{
   Transposes a 2-d array
}{
   \sstdescription{
      Creates a new 2-d array containing a transposed copy of the supplied
      array.
   }
   \sstinvocation{
      CALL KPG1\_TRSPx( M, N, IN, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         M = INTEGER (Given)
      }{
         Number of columns in the input array and the number of lines
         in the output array.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of lines in the input array and the number of columns
         in the output array.
      }
      \sstsubsection{
         IN( M, N ) = ? (Given)
      }{
         The input array to be transposed.
      }
      \sstsubsection{
         OUT( N, M ) = ? (Returned)
      }{
         The transposed array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         arrays supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_TRSPx
}{
   Transposes a 2-d array
}{
   \sstdescription{
      Creates a new 2-d array containing a transposed copy of the supplied
      array.
   }
   \sstinvocation{
      CALL KPG1\_TRSPx( M, N, IN, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         M = INTEGER (Given)
      }{
         Number of columns in the input array and the number of lines
         in the output array.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of lines in the input array and the number of columns
         in the output array.
      }
      \sstsubsection{
         IN( M, N ) = ? (Given)
      }{
         The input array to be transposed.
      }
      \sstsubsection{
         OUT( N, M ) = ? (Returned)
      }{
         The transposed array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         arrays supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_TRSPx
}{
   Transposes a 2-d array
}{
   \sstdescription{
      Creates a new 2-d array containing a transposed copy of the supplied
      array.
   }
   \sstinvocation{
      CALL KPG1\_TRSPx( M, N, IN, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         M = INTEGER (Given)
      }{
         Number of columns in the input array and the number of lines
         in the output array.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of lines in the input array and the number of columns
         in the output array.
      }
      \sstsubsection{
         IN( M, N ) = ? (Given)
      }{
         The input array to be transposed.
      }
      \sstsubsection{
         OUT( N, M ) = ? (Returned)
      }{
         The transposed array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         arrays supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_TRSPx
}{
   Transposes a 2-d array
}{
   \sstdescription{
      Creates a new 2-d array containing a transposed copy of the supplied
      array.
   }
   \sstinvocation{
      CALL KPG1\_TRSPx( M, N, IN, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         M = INTEGER (Given)
      }{
         Number of columns in the input array and the number of lines
         in the output array.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of lines in the input array and the number of columns
         in the output array.
      }
      \sstsubsection{
         IN( M, N ) = ? (Given)
      }{
         The input array to be transposed.
      }
      \sstsubsection{
         OUT( N, M ) = ? (Returned)
      }{
         The transposed array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         arrays supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_TRSPx
}{
   Transposes a 2-d array
}{
   \sstdescription{
      Creates a new 2-d array containing a transposed copy of the supplied
      array.
   }
   \sstinvocation{
      CALL KPG1\_TRSPx( M, N, IN, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         M = INTEGER (Given)
      }{
         Number of columns in the input array and the number of lines
         in the output array.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of lines in the input array and the number of columns
         in the output array.
      }
      \sstsubsection{
         IN( M, N ) = ? (Given)
      }{
         The input array to be transposed.
      }
      \sstsubsection{
         OUT( N, M ) = ? (Returned)
      }{
         The transposed array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         arrays supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_TRSPx
}{
   Transposes a 2-d array
}{
   \sstdescription{
      Creates a new 2-d array containing a transposed copy of the supplied
      array.
   }
   \sstinvocation{
      CALL KPG1\_TRSPx( M, N, IN, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         M = INTEGER (Given)
      }{
         Number of columns in the input array and the number of lines
         in the output array.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of lines in the input array and the number of columns
         in the output array.
      }
      \sstsubsection{
         IN( M, N ) = ? (Given)
      }{
         The input array to be transposed.
      }
      \sstsubsection{
         OUT( N, M ) = ? (Returned)
      }{
         The transposed array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         arrays supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_TRSPx
}{
   Transposes a 2-d array
}{
   \sstdescription{
      Creates a new 2-d array containing a transposed copy of the supplied
      array.
   }
   \sstinvocation{
      CALL KPG1\_TRSPx( M, N, IN, OUT, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         M = INTEGER (Given)
      }{
         Number of columns in the input array and the number of lines
         in the output array.
      }
      \sstsubsection{
         N = INTEGER (Given)
      }{
         Number of lines in the input array and the number of columns
         in the output array.
      }
      \sstsubsection{
         IN( M, N ) = ? (Given)
      }{
         The input array to be transposed.
      }
      \sstsubsection{
         OUT( N, M ) = ? (Returned)
      }{
         The transposed array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         arrays supplied to the routine must have the data type specified.
      }
   }
}
\sstroutine{
   KPG1\_UNZ2x
}{
   Unzips a 2-dimensional co-ordinate array into two 1-dimensional
   arrays
}{
   \sstdescription{
      This routine takes an array of dimension 2 by EL elements and
      puts the two columns into separate arrays.
   }
   \sstinvocation{
      CALL KPG1\_UNZ2x( EL, IN, OUT1, OUT2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of lines in the input array, and elements in each of
         the output arrays.
      }
      \sstsubsection{
         IN( 2, EL ) = ? (Given)
      }{
         The array to be `unzipped{\tt '}.
      }
      \sstsubsection{
         OUT1( EL ) = ? (Returned)
      }{
         The vector to contain first column of the input array.
      }
      \sstsubsection{
         OUT2( EL ) = ? (Returned)
      }{
         The vector to contain second column of the input array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision data types:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively.  The
         routine arguments IN, OUT1, and OUT2 must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_UNZ2x
}{
   Unzips a 2-dimensional co-ordinate array into two 1-dimensional
   arrays
}{
   \sstdescription{
      This routine takes an array of dimension 2 by EL elements and
      puts the two columns into separate arrays.
   }
   \sstinvocation{
      CALL KPG1\_UNZ2x( EL, IN, OUT1, OUT2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         EL = INTEGER (Given)
      }{
         The number of lines in the input array, and elements in each of
         the output arrays.
      }
      \sstsubsection{
         IN( 2, EL ) = ? (Given)
      }{
         The array to be `unzipped{\tt '}.
      }
      \sstsubsection{
         OUT1( EL ) = ? (Returned)
      }{
         The vector to contain first column of the input array.
      }
      \sstsubsection{
         OUT2( EL ) = ? (Returned)
      }{
         The vector to contain second column of the input array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for real and double-precision data types:
         replace {\tt "}x{\tt "} in the routine name by R or D respectively.  The
         routine arguments IN, OUT1, and OUT2 must have the data type
         specified.
      }
   }
}
\sstroutine{
   KPG1\_VASVx
}{
   Assigns values to an output array from an input array using a list
   of indices
}{
   \sstdescription{
      This routine assigns values to an output vector from an input
      vector.  The values are selected using a list of indices
      in the input vector, there being one index per output value.
      A bad value or a value outside the bounds of the array in the
      list of indices causes a bad value to be assigned to the output
      array.
   }
   \sstinvocation{
      CALL KPG1\_VASVx( OEL, INDICE, IEL, INARR, OUTARR, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         OEL = INTEGER (Given)
      }{
         The dimension of the output vector and also the list of
         indices.
      }
      \sstsubsection{
         INDICE( OEL ) = INTEGER (Given)
      }{
         The indices in the input array that point to the values to be
         assigned to the output vector.
      }
      \sstsubsection{
         IEL = INTEGER (Given)
      }{
         The dimension of the input vector.
      }
      \sstsubsection{
         INARR( IEL ) = ? (Given)
      }{
         The vector containing values to be given to the output vector.
      }
      \sstsubsection{
         OUTARR( OEL ) = ? (Returned)
      }{
         The vector containing values copied from the input vector
         according to the list of indices.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         input and output vectors supplied to the routine must have the
         data type specified.
      }
   }
}
\sstroutine{
   KPG1\_VASVx
}{
   Assigns values to an output array from an input array using a list
   of indices
}{
   \sstdescription{
      This routine assigns values to an output vector from an input
      vector.  The values are selected using a list of indices
      in the input vector, there being one index per output value.
      A bad value or a value outside the bounds of the array in the
      list of indices causes a bad value to be assigned to the output
      array.
   }
   \sstinvocation{
      CALL KPG1\_VASVx( OEL, INDICE, IEL, INARR, OUTARR, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         OEL = INTEGER (Given)
      }{
         The dimension of the output vector and also the list of
         indices.
      }
      \sstsubsection{
         INDICE( OEL ) = INTEGER (Given)
      }{
         The indices in the input array that point to the values to be
         assigned to the output vector.
      }
      \sstsubsection{
         IEL = INTEGER (Given)
      }{
         The dimension of the input vector.
      }
      \sstsubsection{
         INARR( IEL ) = ? (Given)
      }{
         The vector containing values to be given to the output vector.
      }
      \sstsubsection{
         OUTARR( OEL ) = ? (Returned)
      }{
         The vector containing values copied from the input vector
         according to the list of indices.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         input and output vectors supplied to the routine must have the
         data type specified.
      }
   }
}
\sstroutine{
   KPG1\_VASVx
}{
   Assigns values to an output array from an input array using a list
   of indices
}{
   \sstdescription{
      This routine assigns values to an output vector from an input
      vector.  The values are selected using a list of indices
      in the input vector, there being one index per output value.
      A bad value or a value outside the bounds of the array in the
      list of indices causes a bad value to be assigned to the output
      array.
   }
   \sstinvocation{
      CALL KPG1\_VASVx( OEL, INDICE, IEL, INARR, OUTARR, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         OEL = INTEGER (Given)
      }{
         The dimension of the output vector and also the list of
         indices.
      }
      \sstsubsection{
         INDICE( OEL ) = INTEGER (Given)
      }{
         The indices in the input array that point to the values to be
         assigned to the output vector.
      }
      \sstsubsection{
         IEL = INTEGER (Given)
      }{
         The dimension of the input vector.
      }
      \sstsubsection{
         INARR( IEL ) = ? (Given)
      }{
         The vector containing values to be given to the output vector.
      }
      \sstsubsection{
         OUTARR( OEL ) = ? (Returned)
      }{
         The vector containing values copied from the input vector
         according to the list of indices.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         input and output vectors supplied to the routine must have the
         data type specified.
      }
   }
}
\sstroutine{
   KPG1\_VASVx
}{
   Assigns values to an output array from an input array using a list
   of indices
}{
   \sstdescription{
      This routine assigns values to an output vector from an input
      vector.  The values are selected using a list of indices
      in the input vector, there being one index per output value.
      A bad value or a value outside the bounds of the array in the
      list of indices causes a bad value to be assigned to the output
      array.
   }
   \sstinvocation{
      CALL KPG1\_VASVx( OEL, INDICE, IEL, INARR, OUTARR, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         OEL = INTEGER (Given)
      }{
         The dimension of the output vector and also the list of
         indices.
      }
      \sstsubsection{
         INDICE( OEL ) = INTEGER (Given)
      }{
         The indices in the input array that point to the values to be
         assigned to the output vector.
      }
      \sstsubsection{
         IEL = INTEGER (Given)
      }{
         The dimension of the input vector.
      }
      \sstsubsection{
         INARR( IEL ) = ? (Given)
      }{
         The vector containing values to be given to the output vector.
      }
      \sstsubsection{
         OUTARR( OEL ) = ? (Returned)
      }{
         The vector containing values copied from the input vector
         according to the list of indices.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         input and output vectors supplied to the routine must have the
         data type specified.
      }
   }
}
\sstroutine{
   KPG1\_VASVx
}{
   Assigns values to an output array from an input array using a list
   of indices
}{
   \sstdescription{
      This routine assigns values to an output vector from an input
      vector.  The values are selected using a list of indices
      in the input vector, there being one index per output value.
      A bad value or a value outside the bounds of the array in the
      list of indices causes a bad value to be assigned to the output
      array.
   }
   \sstinvocation{
      CALL KPG1\_VASVx( OEL, INDICE, IEL, INARR, OUTARR, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         OEL = INTEGER (Given)
      }{
         The dimension of the output vector and also the list of
         indices.
      }
      \sstsubsection{
         INDICE( OEL ) = INTEGER (Given)
      }{
         The indices in the input array that point to the values to be
         assigned to the output vector.
      }
      \sstsubsection{
         IEL = INTEGER (Given)
      }{
         The dimension of the input vector.
      }
      \sstsubsection{
         INARR( IEL ) = ? (Given)
      }{
         The vector containing values to be given to the output vector.
      }
      \sstsubsection{
         OUTARR( OEL ) = ? (Returned)
      }{
         The vector containing values copied from the input vector
         according to the list of indices.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         input and output vectors supplied to the routine must have the
         data type specified.
      }
   }
}
\sstroutine{
   KPG1\_VASVx
}{
   Assigns values to an output array from an input array using a list
   of indices
}{
   \sstdescription{
      This routine assigns values to an output vector from an input
      vector.  The values are selected using a list of indices
      in the input vector, there being one index per output value.
      A bad value or a value outside the bounds of the array in the
      list of indices causes a bad value to be assigned to the output
      array.
   }
   \sstinvocation{
      CALL KPG1\_VASVx( OEL, INDICE, IEL, INARR, OUTARR, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         OEL = INTEGER (Given)
      }{
         The dimension of the output vector and also the list of
         indices.
      }
      \sstsubsection{
         INDICE( OEL ) = INTEGER (Given)
      }{
         The indices in the input array that point to the values to be
         assigned to the output vector.
      }
      \sstsubsection{
         IEL = INTEGER (Given)
      }{
         The dimension of the input vector.
      }
      \sstsubsection{
         INARR( IEL ) = ? (Given)
      }{
         The vector containing values to be given to the output vector.
      }
      \sstsubsection{
         OUTARR( OEL ) = ? (Returned)
      }{
         The vector containing values copied from the input vector
         according to the list of indices.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         input and output vectors supplied to the routine must have the
         data type specified.
      }
   }
}
\sstroutine{
   KPG1\_VASVx
}{
   Assigns values to an output array from an input array using a list
   of indices
}{
   \sstdescription{
      This routine assigns values to an output vector from an input
      vector.  The values are selected using a list of indices
      in the input vector, there being one index per output value.
      A bad value or a value outside the bounds of the array in the
      list of indices causes a bad value to be assigned to the output
      array.
   }
   \sstinvocation{
      CALL KPG1\_VASVx( OEL, INDICE, IEL, INARR, OUTARR, NBAD, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         OEL = INTEGER (Given)
      }{
         The dimension of the output vector and also the list of
         indices.
      }
      \sstsubsection{
         INDICE( OEL ) = INTEGER (Given)
      }{
         The indices in the input array that point to the values to be
         assigned to the output vector.
      }
      \sstsubsection{
         IEL = INTEGER (Given)
      }{
         The dimension of the input vector.
      }
      \sstsubsection{
         INARR( IEL ) = ? (Given)
      }{
         The vector containing values to be given to the output vector.
      }
      \sstsubsection{
         OUTARR( OEL ) = ? (Returned)
      }{
         The vector containing values copied from the input vector
         according to the list of indices.
      }
      \sstsubsection{
         NBAD = INTEGER (Returned)
      }{
         The number of bad values in the output array.
      }
      \sstsubsection{
         STATUS = INTEGER (Given)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate. The
         input and output vectors supplied to the routine must have the
         data type specified.
      }
   }
}
\sstroutine{
   KPG1\_VEC2N
}{
   Convert vectorised array indices into N-dimensional form
}{
   \sstdescription{
      This routine converts pixel indices which refer to a pixel in a
      vectorised array into sets of indices which identify the same
      pixel when the array is regarded as N-dimensional, with specified
      lower and upper pixel-index bounds for each dimension.
   }
   \sstinvocation{
      CALL KPG1\_VEC2N( NVEC, VEC, NDIM, LBND, UBND, IDIM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         NVEC = INTEGER (Given)
      }{
         Number of vectorised array indices to convert.
      }
      \sstsubsection{
         VEC( NVEC ) = INTEGER (Given)
      }{
         Array of vectorised pixel indices to be converted.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of array dimensions.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Given)
      }{
         Lower pixel-index bounds for each array dimension.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         Upper pixel-index bounds for each array dimension.
      }
      \sstsubsection{
         IDIM( NDIM, NVEC ) = INTEGER (Returned)
      }{
         Returns a set of NDIM pixel-indices for each vectorised index
         supplied.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      The maximum number of dimensions which can be handled by this
      routine is equal to the symbolic constant NDF\_\_MXDIM.
   }
}
\sstroutine{
   KPG1\_VERB
}{
   Should the speified package report verbose messages?
}{
   \sstdescription{
      This routine returns a logical flag indicating if a specified
      applications package should report verbose information. This is the
      case if the environment variable $<$PACK$>$\_VERBOSE is defined (the value
      assigned to the environment variable is immaterial).
   }
   \sstinvocation{
      CALL KPG1\_VERB( VERB, PACK, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VERB = LOGICAL (Returned)
      }{
         Should the package run in verbose mode? Returned .FALSE, if an
         error has already occurred, or if this routine should fail for
         any reason.
      }
      \sstsubsection{
         PACK = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the package (eg {\tt "}KAPPA{\tt "}, {\tt "}POLPACK{\tt "}, etc).
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         This routine attempts to execute even if STATUS is set to an
         error on entry.
      }
   }
}
\sstroutine{
   KPG1\_MKCAT
}{
   Write an AST Object to a catalogue
}{
   \sstdescription{
      This routine stores a textual representation of the supplied AST Object
      within the supplied catalogue. The information is stored within COMMENT
      strings which are appended to the supplied catalogue{\tt '}s textual
      information. Lines of AST information which are too long to fit in a
      single COMMENT are split into several lines. Continuation lines are
      marked by having a {\tt "}$+${\tt "} in the first column. Each line of AST
      information is preceeded with the string {\tt "}!!{\tt "}, which is used to
      mark the end of any leading blanks etc added by AST when the string is
      read back.

      Note, at the moment CAT reports errors if textual information is
      added to a catalogue which contains no rows of data. For this reason,
      this routine should normally be called just before closing the
      catalogue, since this will normally ensure that the catalogue
      contains some data.
   }
   \sstinvocation{
      RESULT = KPG1\_WCATW( IAST, CI, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IAST = INTEGER (Given)
      }{
         An AST pointer to the Object.
      }
      \sstsubsection{
         CI = INTEGER (Given)
      }{
         A CAT identifier for the catalogue.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Function Value
   }{
      KPG1\_WCATW = INTEGER
         Returned equal to 1 if an Object was written to the catalogue,
         and zero otherwise.
   }
}
\sstroutine{
   KPG1\_WGNDF
}{
   Get a group of output NDF names
}{
   \sstdescription{
      The supplied parameter is used to get a GRP group expression (see
      SUN/150 ) holding a list of NDFs which are to be created by the
      calling application (the syntax of the group expression is
      defined by the current default GRP control characters).
      Modification elements within the group expression are based on
      the group identified by IGRP0. If the group expression is flagged,
      then the current parameter value is cancelled, the string
      supplied in TEXT is displayed (if it is not blank) and another
      group expression is obtained. The NDFs specified by the second
      group expression are added to the group holding the NDFs
      specified by the first group expression. The group continues to
      be expanded in this way until a group expression is obtained
      which is not flagged, or a null value is given, or the limit on
      the number of NDFs (MAXSIZ) is reached.  If the final group
      contains more than MAXSIZ NDFs, then all but the first MAXSIZ
      NDFs are removed from the group. The user is warned if this
      happens. If MAXSIZ is supplied with the value zero no limit is
      imposed on the number of NDFs within the group.  If the final
      group contains less than MINSIZ NDFs then the user is told to
      supply more, and is re-prompted for further NDF names. All
      messages issued by this routine have a priority level of
      MSG\_\_NORM.
   }
   \sstinvocation{
      CALL KPG1\_WGNDF( PARAM, IGRP0, MAXSIZ, MINSIZ, TEXT, IGRP, SIZE,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The parameter (of type LITERAL).
      }
      \sstsubsection{
         IGRP0 = INTEGER (Given)
      }{
         The NDG identifier for a group containing a set of NDF names
         to be used as the basis for any modification elements contained
         within the group expressions. If this is supplied equal to
         GRP\_\_NOID then modification elements are left un-expanded.
      }
      \sstsubsection{
         MAXSIZ = INTEGER (Given)
      }{
         The maximum number of NDFs which can be allowed in the
         returned group. If zero is supplied, no limit is imposed.
      }
      \sstsubsection{
         MINSIZ = INTEGER (Given)
      }{
         The minimum number of NDFs which can be allowed in the
         returned group. If zero is supplied, then the returned group
         may contain no NDFs.
      }
      \sstsubsection{
         TEXT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The text to display between issuing prompts for successive
         group expressions. If blank then no text is displayed.
      }
      \sstsubsection{
         IGRP = INTEGER (Returned)
      }{
         The NDG identifier for the returned group holding all the
         specified NDFs.
      }
      \sstsubsection{
         SIZE = INTEGER (Returned)
      }{
         The number of files in the output group. Returned equal to 1 if
         STATUS is not equal to SAI\_\_OK.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_WMODx
}{
   To estimate the mean of a number of normally distributed data
   values, some of which may be corrupt
}{
   \sstdescription{
      The routine is based on maximising the likelihood function for a
      statistical model in which any of the data points has a constant
      probability of being corrupt.  The data points have weights, to
      allow for different intrinisic errors.  A weighted mean is chosen
      according to the deviation of each data point from the current
      estimate of the mean.  The weights are derived from the relative
      probabilities of being valid or corrupt.  A sequence of these
      iterations converges to a stationary point in the likelihood
      function.  The routine approximates to a k-sigma clipping
      algorithm for a large number of data points and to a
      mode-estimating algorithm for fewer data points.
   }
   \sstinvocation{
       CALL KPG1\_WMODx( X, W, NX, PBAD, NITER, TOLL, XMODE, SIGMA,
      :                  STATUS )
   }
   \sstarguments{
      \sstsubsection{
         X( NX ) = ? (Given)
      }{
         An array of data values.
      }
      \sstsubsection{
         W( NX ) = REAL (Given)
      }{
         An array of data weights for each data value.  The weights are
         inversely proportional to the square of the relative errors on
         each data point.
      }
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         The number of data values.
      }
      \sstsubsection{
         PBAD = REAL (Given)
      }{
         An estimate of the probability that any one data point will be
         corrupt.  (This value is not critical.)
      }
      \sstsubsection{
         NITER = INTEGER (Given)
      }{
         The maximum number of iterations required.
      }
      \sstsubsection{
         TOLL = REAL (Given)
      }{
         The absolute accuracy required in the estimate of the
         mean.  Iterations cease when two successive estimates
         differ by less than this amount.
      }
      \sstsubsection{
         XMODE = REAL (Returned)
      }{
         The estimate of the uncorrupted mean.
      }
      \sstsubsection{
         SIGMA = REAL (Returned)
      }{
         An estimate of the uncorrupted normalised standard deviation of
         the data points.  An estimate of the standard deviation of any
         one point is:  SIGMA / SQRT( W ) where W is its weight.
      }
      \sstsubsection{
         STATUS = INTEGER (Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each numeric data type: replace {\tt "}x{\tt "} in the
      routine name by D, R, I, W, UW, B, UB as appropriate.  The array
      supplied to the routine must have the data type specified.
   }
}
\sstroutine{
   KPG1\_WMODx
}{
   To estimate the mean of a number of normally distributed data
   values, some of which may be corrupt
}{
   \sstdescription{
      The routine is based on maximising the likelihood function for a
      statistical model in which any of the data points has a constant
      probability of being corrupt.  The data points have weights, to
      allow for different intrinisic errors.  A weighted mean is chosen
      according to the deviation of each data point from the current
      estimate of the mean.  The weights are derived from the relative
      probabilities of being valid or corrupt.  A sequence of these
      iterations converges to a stationary point in the likelihood
      function.  The routine approximates to a k-sigma clipping
      algorithm for a large number of data points and to a
      mode-estimating algorithm for fewer data points.
   }
   \sstinvocation{
       CALL KPG1\_WMODx( X, W, NX, PBAD, NITER, TOLL, XMODE, SIGMA,
      :                  STATUS )
   }
   \sstarguments{
      \sstsubsection{
         X( NX ) = ? (Given)
      }{
         An array of data values.
      }
      \sstsubsection{
         W( NX ) = REAL (Given)
      }{
         An array of data weights for each data value.  The weights are
         inversely proportional to the square of the relative errors on
         each data point.
      }
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         The number of data values.
      }
      \sstsubsection{
         PBAD = REAL (Given)
      }{
         An estimate of the probability that any one data point will be
         corrupt.  (This value is not critical.)
      }
      \sstsubsection{
         NITER = INTEGER (Given)
      }{
         The maximum number of iterations required.
      }
      \sstsubsection{
         TOLL = REAL (Given)
      }{
         The absolute accuracy required in the estimate of the
         mean.  Iterations cease when two successive estimates
         differ by less than this amount.
      }
      \sstsubsection{
         XMODE = REAL (Returned)
      }{
         The estimate of the uncorrupted mean.
      }
      \sstsubsection{
         SIGMA = REAL (Returned)
      }{
         An estimate of the uncorrupted normalised standard deviation of
         the data points.  An estimate of the standard deviation of any
         one point is:  SIGMA / SQRT( W ) where W is its weight.
      }
      \sstsubsection{
         STATUS = INTEGER (Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each numeric data type: replace {\tt "}x{\tt "} in the
      routine name by D, R, I, W, UW, B, UB as appropriate.  The array
      supplied to the routine must have the data type specified.
   }
}
\sstroutine{
   KPG1\_WMODx
}{
   To estimate the mean of a number of normally distributed data
   values, some of which may be corrupt
}{
   \sstdescription{
      The routine is based on maximising the likelihood function for a
      statistical model in which any of the data points has a constant
      probability of being corrupt.  The data points have weights, to
      allow for different intrinisic errors.  A weighted mean is chosen
      according to the deviation of each data point from the current
      estimate of the mean.  The weights are derived from the relative
      probabilities of being valid or corrupt.  A sequence of these
      iterations converges to a stationary point in the likelihood
      function.  The routine approximates to a k-sigma clipping
      algorithm for a large number of data points and to a
      mode-estimating algorithm for fewer data points.
   }
   \sstinvocation{
       CALL KPG1\_WMODx( X, W, NX, PBAD, NITER, TOLL, XMODE, SIGMA,
      :                  STATUS )
   }
   \sstarguments{
      \sstsubsection{
         X( NX ) = ? (Given)
      }{
         An array of data values.
      }
      \sstsubsection{
         W( NX ) = REAL (Given)
      }{
         An array of data weights for each data value.  The weights are
         inversely proportional to the square of the relative errors on
         each data point.
      }
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         The number of data values.
      }
      \sstsubsection{
         PBAD = REAL (Given)
      }{
         An estimate of the probability that any one data point will be
         corrupt.  (This value is not critical.)
      }
      \sstsubsection{
         NITER = INTEGER (Given)
      }{
         The maximum number of iterations required.
      }
      \sstsubsection{
         TOLL = REAL (Given)
      }{
         The absolute accuracy required in the estimate of the
         mean.  Iterations cease when two successive estimates
         differ by less than this amount.
      }
      \sstsubsection{
         XMODE = REAL (Returned)
      }{
         The estimate of the uncorrupted mean.
      }
      \sstsubsection{
         SIGMA = REAL (Returned)
      }{
         An estimate of the uncorrupted normalised standard deviation of
         the data points.  An estimate of the standard deviation of any
         one point is:  SIGMA / SQRT( W ) where W is its weight.
      }
      \sstsubsection{
         STATUS = INTEGER (Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each numeric data type: replace {\tt "}x{\tt "} in the
      routine name by D, R, I, W, UW, B, UB as appropriate.  The array
      supplied to the routine must have the data type specified.
   }
}
\sstroutine{
   KPG1\_WMODx
}{
   To estimate the mean of a number of normally distributed data
   values, some of which may be corrupt
}{
   \sstdescription{
      The routine is based on maximising the likelihood function for a
      statistical model in which any of the data points has a constant
      probability of being corrupt.  The data points have weights, to
      allow for different intrinisic errors.  A weighted mean is chosen
      according to the deviation of each data point from the current
      estimate of the mean.  The weights are derived from the relative
      probabilities of being valid or corrupt.  A sequence of these
      iterations converges to a stationary point in the likelihood
      function.  The routine approximates to a k-sigma clipping
      algorithm for a large number of data points and to a
      mode-estimating algorithm for fewer data points.
   }
   \sstinvocation{
       CALL KPG1\_WMODx( X, W, NX, PBAD, NITER, TOLL, XMODE, SIGMA,
      :                  STATUS )
   }
   \sstarguments{
      \sstsubsection{
         X( NX ) = ? (Given)
      }{
         An array of data values.
      }
      \sstsubsection{
         W( NX ) = REAL (Given)
      }{
         An array of data weights for each data value.  The weights are
         inversely proportional to the square of the relative errors on
         each data point.
      }
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         The number of data values.
      }
      \sstsubsection{
         PBAD = REAL (Given)
      }{
         An estimate of the probability that any one data point will be
         corrupt.  (This value is not critical.)
      }
      \sstsubsection{
         NITER = INTEGER (Given)
      }{
         The maximum number of iterations required.
      }
      \sstsubsection{
         TOLL = REAL (Given)
      }{
         The absolute accuracy required in the estimate of the
         mean.  Iterations cease when two successive estimates
         differ by less than this amount.
      }
      \sstsubsection{
         XMODE = REAL (Returned)
      }{
         The estimate of the uncorrupted mean.
      }
      \sstsubsection{
         SIGMA = REAL (Returned)
      }{
         An estimate of the uncorrupted normalised standard deviation of
         the data points.  An estimate of the standard deviation of any
         one point is:  SIGMA / SQRT( W ) where W is its weight.
      }
      \sstsubsection{
         STATUS = INTEGER (Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each numeric data type: replace {\tt "}x{\tt "} in the
      routine name by D, R, I, W, UW, B, UB as appropriate.  The array
      supplied to the routine must have the data type specified.
   }
}
\sstroutine{
   KPG1\_WMODx
}{
   To estimate the mean of a number of normally distributed data
   values, some of which may be corrupt
}{
   \sstdescription{
      The routine is based on maximising the likelihood function for a
      statistical model in which any of the data points has a constant
      probability of being corrupt.  The data points have weights, to
      allow for different intrinisic errors.  A weighted mean is chosen
      according to the deviation of each data point from the current
      estimate of the mean.  The weights are derived from the relative
      probabilities of being valid or corrupt.  A sequence of these
      iterations converges to a stationary point in the likelihood
      function.  The routine approximates to a k-sigma clipping
      algorithm for a large number of data points and to a
      mode-estimating algorithm for fewer data points.
   }
   \sstinvocation{
       CALL KPG1\_WMODx( X, W, NX, PBAD, NITER, TOLL, XMODE, SIGMA,
      :                  STATUS )
   }
   \sstarguments{
      \sstsubsection{
         X( NX ) = ? (Given)
      }{
         An array of data values.
      }
      \sstsubsection{
         W( NX ) = REAL (Given)
      }{
         An array of data weights for each data value.  The weights are
         inversely proportional to the square of the relative errors on
         each data point.
      }
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         The number of data values.
      }
      \sstsubsection{
         PBAD = REAL (Given)
      }{
         An estimate of the probability that any one data point will be
         corrupt.  (This value is not critical.)
      }
      \sstsubsection{
         NITER = INTEGER (Given)
      }{
         The maximum number of iterations required.
      }
      \sstsubsection{
         TOLL = REAL (Given)
      }{
         The absolute accuracy required in the estimate of the
         mean.  Iterations cease when two successive estimates
         differ by less than this amount.
      }
      \sstsubsection{
         XMODE = REAL (Returned)
      }{
         The estimate of the uncorrupted mean.
      }
      \sstsubsection{
         SIGMA = REAL (Returned)
      }{
         An estimate of the uncorrupted normalised standard deviation of
         the data points.  An estimate of the standard deviation of any
         one point is:  SIGMA / SQRT( W ) where W is its weight.
      }
      \sstsubsection{
         STATUS = INTEGER (Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each numeric data type: replace {\tt "}x{\tt "} in the
      routine name by D, R, I, W, UW, B, UB as appropriate.  The array
      supplied to the routine must have the data type specified.
   }
}
\sstroutine{
   KPG1\_WMODx
}{
   To estimate the mean of a number of normally distributed data
   values, some of which may be corrupt
}{
   \sstdescription{
      The routine is based on maximising the likelihood function for a
      statistical model in which any of the data points has a constant
      probability of being corrupt.  The data points have weights, to
      allow for different intrinisic errors.  A weighted mean is chosen
      according to the deviation of each data point from the current
      estimate of the mean.  The weights are derived from the relative
      probabilities of being valid or corrupt.  A sequence of these
      iterations converges to a stationary point in the likelihood
      function.  The routine approximates to a k-sigma clipping
      algorithm for a large number of data points and to a
      mode-estimating algorithm for fewer data points.
   }
   \sstinvocation{
       CALL KPG1\_WMODx( X, W, NX, PBAD, NITER, TOLL, XMODE, SIGMA,
      :                  STATUS )
   }
   \sstarguments{
      \sstsubsection{
         X( NX ) = ? (Given)
      }{
         An array of data values.
      }
      \sstsubsection{
         W( NX ) = REAL (Given)
      }{
         An array of data weights for each data value.  The weights are
         inversely proportional to the square of the relative errors on
         each data point.
      }
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         The number of data values.
      }
      \sstsubsection{
         PBAD = REAL (Given)
      }{
         An estimate of the probability that any one data point will be
         corrupt.  (This value is not critical.)
      }
      \sstsubsection{
         NITER = INTEGER (Given)
      }{
         The maximum number of iterations required.
      }
      \sstsubsection{
         TOLL = REAL (Given)
      }{
         The absolute accuracy required in the estimate of the
         mean.  Iterations cease when two successive estimates
         differ by less than this amount.
      }
      \sstsubsection{
         XMODE = REAL (Returned)
      }{
         The estimate of the uncorrupted mean.
      }
      \sstsubsection{
         SIGMA = REAL (Returned)
      }{
         An estimate of the uncorrupted normalised standard deviation of
         the data points.  An estimate of the standard deviation of any
         one point is:  SIGMA / SQRT( W ) where W is its weight.
      }
      \sstsubsection{
         STATUS = INTEGER (Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each numeric data type: replace {\tt "}x{\tt "} in the
      routine name by D, R, I, W, UW, B, UB as appropriate.  The array
      supplied to the routine must have the data type specified.
   }
}
\sstroutine{
   KPG1\_WMODx
}{
   To estimate the mean of a number of normally distributed data
   values, some of which may be corrupt
}{
   \sstdescription{
      The routine is based on maximising the likelihood function for a
      statistical model in which any of the data points has a constant
      probability of being corrupt.  The data points have weights, to
      allow for different intrinisic errors.  A weighted mean is chosen
      according to the deviation of each data point from the current
      estimate of the mean.  The weights are derived from the relative
      probabilities of being valid or corrupt.  A sequence of these
      iterations converges to a stationary point in the likelihood
      function.  The routine approximates to a k-sigma clipping
      algorithm for a large number of data points and to a
      mode-estimating algorithm for fewer data points.
   }
   \sstinvocation{
       CALL KPG1\_WMODx( X, W, NX, PBAD, NITER, TOLL, XMODE, SIGMA,
      :                  STATUS )
   }
   \sstarguments{
      \sstsubsection{
         X( NX ) = ? (Given)
      }{
         An array of data values.
      }
      \sstsubsection{
         W( NX ) = REAL (Given)
      }{
         An array of data weights for each data value.  The weights are
         inversely proportional to the square of the relative errors on
         each data point.
      }
      \sstsubsection{
         NX = INTEGER (Given)
      }{
         The number of data values.
      }
      \sstsubsection{
         PBAD = REAL (Given)
      }{
         An estimate of the probability that any one data point will be
         corrupt.  (This value is not critical.)
      }
      \sstsubsection{
         NITER = INTEGER (Given)
      }{
         The maximum number of iterations required.
      }
      \sstsubsection{
         TOLL = REAL (Given)
      }{
         The absolute accuracy required in the estimate of the
         mean.  Iterations cease when two successive estimates
         differ by less than this amount.
      }
      \sstsubsection{
         XMODE = REAL (Returned)
      }{
         The estimate of the uncorrupted mean.
      }
      \sstsubsection{
         SIGMA = REAL (Returned)
      }{
         An estimate of the uncorrupted normalised standard deviation of
         the data points.  An estimate of the standard deviation of any
         one point is:  SIGMA / SQRT( W ) where W is its weight.
      }
      \sstsubsection{
         STATUS = INTEGER (Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      There is a routine for each numeric data type: replace {\tt "}x{\tt "} in the
      routine name by D, R, I, W, UW, B, UB as appropriate.  The array
      supplied to the routine must have the data type specified.
   }
}
\sstroutine{
   KPG1\_WRAST
}{
   Write AST\_ data as text to an HDS object
}{
   \sstdescription{
      This is a service routine to be provided as a {\tt "}sink{\tt "} routine for
      the AST\_CHANNEL function. It takes data in the form of text (in
      response to writing an AST\_ object to a Channel) and delivers it
      to an HDS object for storage.

      This routine has only a STATUS argument, so it communicates with
      other KPG routines via global variables stored in the KPG\_AST
      common blocks. These are described below under {\tt "}Global Variables
      used as Arguments{\tt "}.
   }
   \sstinvocation{
      CALL KPG1\_WRAST
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstdiytopic{
      Global Variables used as Arguments
   }{
      ASTLC = CHARACTER $*$ ( DAT\_\_SZLOC ) (Given)
         A locator for the HDS object which is to store the data. This
         must be a 1-dimensional \_CHAR array, whose initial size and
         character string length will be determined via this locator.
         Write access to the object must be available via this locator,
         but the locator itself is not altered by this routine.
      ASTLN = INTEGER (Given and Returned)
         This must initially be set to the value 1, to indicate that
         data will be written starting at the first element of the HDS
         array (note the routine will not operate correctly unless 1 is
         the initial value - you cannot start writing at another point
         in the array if you have previously written to a different
         array). On exit it will be incremented by the number of
         elements used to store data, so that it identifies the first
         element to be used on the next invocation.
      ASTPT = INTEGER (Given and Returned)
         A pointer to the contents of the HDS object, initially mapped
         in {\tt '}WRITE{\tt '} mode. This pointer may be modified by the routine
         (and re-mapped in {\tt '}UPDATE{\tt '} mode) if it needs to extend the
         size of the object to accommodate the data written.
   }
}
\sstroutine{
   KPG1\_WREAD
}{
   Read an AST Object from an HDS object
}{
   \sstdescription{
      This routine reads an AST Object from a component of the supplied
      HDS object. The component name is specified by the caller. The
      component must have a type of WCS, must be scalar, and must contain
      a single 1-D array component with name DATA and type \_CHAR.
      AST\_\_NULL is returned in IAST, and no error is reported if the
      named component does not exist.
   }
   \sstinvocation{
      CALL KPG1\_WREAD( LOC, NAME, IAST, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The locator to the HDS object.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the component within the HDS object to read.
         If a blank name is supplied, the object itself is used.
      }
      \sstsubsection{
         IAST = INTEGER (Returned)
      }{
         Pointer to the AST Object returned. Returned equal to AST\_\_NULL
         if no Object can be read.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_WRLS2
}{
   Puts a set of positions into a text file as a CAT catalogue
}{
   \sstdescription{
      This routine writes the supplied positions to a CAT catalogue
      (see SUN/181). A dump of the supplied FrameSet (if any) is included
      in the text file as a set of {\tt "}text{\tt "} lines. A column is created
      with name {\tt "}PIDENT{\tt "} to contain the integer identifiers. A column is
      also created for each axis of the Base Frame, with a name equal to
      the Symbol attribute of the Axis (AXIS\_$<$n$>$ is used if the Symbol is
      blank). The catalogue can be read using KPG1\_RDLST (and also XCATVIEW
      etc).
   }
   \sstinvocation{
      CALL KPG1\_WRLS2( PARAM, ARRDIM, NPOS, NAX, POS, IWCS, TITLE,
                       ID0, IDENTS, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use.
      }
      \sstsubsection{
         ARRDIM = INTEGER (Given)
      }{
         The size of the first dimension of the positions array. This must
         be larger than or equal to NPOS.
      }
      \sstsubsection{
         NPOS = INTEGER (Given)
      }{
         The number of positions to store in the file.
      }
      \sstsubsection{
         NAX = INTEGER (Given)
      }{
         The number of axes for each position.
      }
      \sstsubsection{
         POS( ARRDIM, NAX ) = DOUBLE PRECISION (Given)
      }{
         The positions to store in the file. POS( I, J ) should give the
         axis J value for position I. The positions should be in the Base
         Frame of the FrameSet supplied using argument IWCS.
      }
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         A pointer to an AST FrameSet to store with the positions.
      }
      \sstsubsection{
         TITLE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A title to store at the top of the text file.
      }
      \sstsubsection{
         ID0 = INTEGER (Given)
      }{
         The integer identifier value to associate with the first
         supplied position. Identifiers for subsequent positions increase
         by 1 for each position. If this is supplied less than or equal
         to zero, then its value is ignored and the identifiers supplied
         in array IDENTS are used instead.
      }
      \sstsubsection{
         IDENTS( NPOS ) = INTEGER (Given)
      }{
         The individual integer identifiers to associate with each
         position. Only accessed if ID0 is less than or equal to zero.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_WRLST
}{
   Writes a set of positions to a text file as a CAT catalogue
}{
   \sstdescription{
      This routine saves a set of positions in a text file as a CAT
      catalogue (see SUN/181). Information describing associated co-ordinate
      Frames can also be stored in the file as textual information, allowing
      subsequent applications to interpret the positions. Files written with
      this routine can be read using KPG1\_RDLST (and also XCATVIEW etc).

      The positions are stored in the file in a Frame selected by the
      user using hardwired parameters CATFRAME and CATEPOCH. This Frame
      defaults to a SKY Frame if present, otherwise a PIXEL Frame if present,
      otherwise the original Base Frame within the supplied FrameSet. The
      positions can be supplied within any of the Frames in the FrameSet
      and will be Mapped into the required Frame if necessary.
   }
   \sstinvocation{
      CALL KPG1\_WRLST( PARAM, ARRDIM, NPOS, NAX, POS, IFRM, IWCS, TITLE,
                       ID0, IDENTS, NULL, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use.
      }
      \sstsubsection{
         ARRDIM = INTEGER (Given)
      }{
         The size of the first dimension of the positions array. This must
         be larger than or equal to NPOS.
      }
      \sstsubsection{
         NPOS = INTEGER (Given)
      }{
         The number of positions to store in the file.
      }
      \sstsubsection{
         NAX = INTEGER (Given)
      }{
         The number of axes in the Frame specified by IFRM.
      }
      \sstsubsection{
         POS( ARRDIM, NAX ) = DOUBLE PRECISION (Given)
      }{
         The positions to store in the file. POS( I, J ) should give the
         axis J value for position I.
      }
      \sstsubsection{
         IFRM = INTEGER (Given)
      }{
         The index of the Frame within IWCS to which the supplied
         positions relate. Can be AST\_\_BASE or AST\_\_CURRENT.
      }
      \sstsubsection{
         IWCS = INTEGER (Given)
      }{
         A pointer to an AST FrameSet to store with the positions.
      }
      \sstsubsection{
         TITLE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A title to store at the top of the text file. Ignored if blank.
      }
      \sstsubsection{
         ID0 = INTEGER (Given)
      }{
         The integer identifier value to associate with the first
         supplied position. Identifiers for subsequent positions increase
         by 1 for each position. If this is supplied less than or equal
         to zero, then its value is ignored and the identifiers supplied
         in array IDENTS are used instead.
      }
      \sstsubsection{
         IDENTS( NPOS ) = INTEGER (Given)
      }{
         The individual integer identifiers to associate with each
         position. Only accessed if ID0 is less than or equal to zero.
      }
      \sstsubsection{
         NULL = LOGICAL (Given)
      }{
         Is the user allowed to supply a null value? If so, the error
         status will be annulled before returning.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_WTM3D
}{
   To form the weighted median of a list of ordered data values.
   Incrementing the contributing pixel buffers and estimating the
   variance change
}{
   \sstdescription{
      This routine finds a value which can be associated with the half-
      weight value. It sums all weights then finds a value for the
      half-weight. The comparison with the half-weight value proceeds
      in halves of the weights for each data point (half of the first
      weight, then the second half of the first weight and the first
      half of the second weight etc.) until the half weight is
      exceeded. The data values around this half weight position are
      then found and a linear interpolation of these values is the
      weighted median. This routine also uses the order statistic
      covariance array (for a population NENT big) to estimate the
      change in the variance from a optimal measurement from the
      given population, returning the adjusted variance.
   }
   \sstinvocation{
      CALL KPG1\_WTM3D( ORDDAT, WEIGHT, VAR, NENT, COVAR,
                       RESULT, RESVAR, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         ARR( NENT ) = DOUBLE PRECISION (Given)
      }{
         The list of ordered data for which the weighted median is
         required
      }
      \sstsubsection{
         WEIGHT( NENT ) = DOUBLE PRECISION (Given)
      }{
         The weights of the values.
      }
      \sstsubsection{
         VAR( NSET ) = DOUBLE PRECISION (Given)
      }{
         The variance of the unordered sample now ordered in ARR.
      }
      \sstsubsection{
         NENT = INTEGER (Given)
      }{
         The number of entries in the data array.
      }
      \sstsubsection{
         COVAR( $*$ ) = DOUBLE PRECISION (Given)
      }{
         The packed variance-covariance matrix of the order statistics
         from a normal distribution of size NENT.
      }
      \sstsubsection{
         RESULT = DOUBLE PRECISION (Returned)
      }{
         The weighted median
      }
      \sstsubsection{
         RESVAR = DOUBLE PRECISION (Returned)
      }{
         The variance of result.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         the routine should only be used at real or better precisions.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         The input data must be ordered increasing. No BAD values may be
         present.
      }
   }
}
\sstroutine{
   KPG1\_WTM3R
}{
   To form the weighted median of a list of ordered data values
}{
   \sstdescription{
      This routine finds a value which can be associated with the half-
      weight value. It sums all weights then finds a value for the
      half-weight. The comparison with the half-weight value proceeds
      in halves of the weights for each data point (half of the first
      weight, then the second half of the first weight and the first
      half of the second weight etc.) until the half weight is
      exceeded. The data values around this half weight position are
      then found and a linear interpolation of these values is the
      weighted median. This routine also uses the order statistic
      covariance array (for a population NENT big) to estimate the
      change in the variance from a optimal measurement from the
      given population, returning the adjusted variance.
   }
   \sstinvocation{
      CALL KPG1\_WTM3R( ORDDAT, WEIGHT, VAR, NENT, COVAR, RESULT, RESVAR,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         ORDDAT( NENT ) = REAL (Given)
      }{
         The list of ordered data for which the weighted median is
         required
      }
      \sstsubsection{
         WEIGHT( NENT ) = REAL (Given)
      }{
         The weights of the values.
      }
      \sstsubsection{
         VAR( NSET ) = REAL (Given)
      }{
         The variance of the unordered sample now ordered in ARR.
      }
      \sstsubsection{
         NENT = INTEGER (Given)
      }{
         The number of entries in the data array.
      }
      \sstsubsection{
         COVAR( $*$ ) = DOUBLE PRECISION (Given)
      }{
         The packed variance-covariance matrix of the order statistics
         from a normal distribution of size NENT.
      }
      \sstsubsection{
         RESULT = REAL (Returned)
      }{
         The weighted median
      }
      \sstsubsection{
         RESVAR = REAL (Returned)
      }{
         The variance of result.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         the routine should only be used at real or better precisions.
      }
   }
   \sstdiytopic{
      Prior Requirements
   }{
      \sstitemlist{

         \sstitem
         The input data must be ordered increasing. No BAD values may be
         present.
      }
   }
}
\sstroutine{
   KPG1\_WWRT
}{
   Write WCS information to an HDS object
}{
   \sstdescription{
      This routine stores a supplied AST Object in a new component of
      a supplied HDS object. The new component has type WCS and contains
      a single component named DATA, of type \_CHAR. DATA is a 1-D array
      holding lines of text which can be interpreted by a simple AST
      Channel.
   }
   \sstinvocation{
      CALL KPG1\_WWRT( IAST, NAME, LOC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         IAST = INTEGER (Given)
      }{
         A pointer to an AST Object.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the WCS component to add into the supplied HDS object.
      }
      \sstsubsection{
         LOC = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A locator for an HDS structure object. This object is modified by
         adding a component of type WCS, with name given by NAME.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_XYD2W
}{
   Converts linear data co-ordinates to world co-ordinates
}{
   \sstdescription{
      The co-efficients of the linear transformation from world
      co-ordinates to data co-ordinates are supplied in arguments SCALE
      and OFFSET.  The inverse of this transformation is used to
      transform each supplied position from data to world co-ordinates.
   }
   \sstinvocation{
      CALL KPG1\_XYD2W( SCALE, OFFSET, NPOINT, XP, YP, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         SCALE( 2 ) = DOUBLE PRECISION (Given)
      }{
         The scale factors in the linear relationships between axis
         co-ordinates and pixel co-ordinates.
      }
      \sstsubsection{
         OFFSET( 2 ) = DOUBLE PRECISION (Given)
      }{
         The offsets in the linear relationships between axis
         co-ordinates and pixel co-ordinates.
      }
      \sstsubsection{
         NPOINT = INTEGER (Given)
      }{
         The number of points specified.
      }
      \sstsubsection{
         XP( NPOINT ) = REAL (Given and Returned)
      }{
         Array holding the x co-ordinate of each point.
      }
      \sstsubsection{
         YP( NPOINT ) = REAL (Given and Returned)
      }{
         Array holding the y co-ordinate of each point.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         The supplied values of SCALE and OFFSET are such that:

      }
         DATA = SCALE( I ) $*$ PIXEL $+$ OFFSET( I )

      where PIXEL is a pixel co-ordinate for the I{\tt '}th dimension, and
      DATA is the corresponding axis co-ordinate.
   }
}
\sstroutine{
   KPG1\_XYZWx
}{
   Converts a 2-dimensional array into a list of x-y co-ordinates,
   values and weights
}{
   \sstdescription{
      This routine converts a 2-dimensional array into a list of x-y
      coordinates, data values and weights for each of the good pixels
      in the array.  The x-y co-ordinates come from the axis arrays
      supplied.  Bad pixels are ignored if BAD is .TRUE..  If VARWTS is
      .TRUE., weights are calculated from the reciprocal of the
      variance for each pixel, otherwise the weights are returned 1.0.
   }
   \sstinvocation{
      CALL KPG1\_XYZWx( DIM1, DIM2, ARRAY, XAXIS, YAXIS, BAD, VARWTS,
                       VAR, SIZE, X, Y, Z, W, NGOOD, XMIN, XMAX, YMIN,
                       YMAX, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DIM1 = INTEGER (Given)
      }{
         The first dimension of the 2-dimensional array.
      }
      \sstsubsection{
         DIM2 = INTEGER (Given)
      }{
         The second dimension of the 2-dimensional array.
      }
      \sstsubsection{
         ARRAY( DIM1, DIM2 ) = ? (Given)
      }{
         The input data array.
      }
      \sstsubsection{
         XAXIS( DIM1 ) = DOUBLE PRECISION (Given)
      }{
         X axis co-ordinates for the input data array.
      }
      \sstsubsection{
         YAXIS( DIM2 ) = DOUBLE PRECISION (Given)
      }{
         Y axis co-ordinates for the input data array.
      }
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Flag indicating whether bad values are likely to be present.
      }
      \sstsubsection{
         VARWTS = LOGICAL (Given)
      }{
         Flag indicating if the variance array contains valid data.
      }
      \sstsubsection{
         VAR( DIM1, DIM2 ) = ? (Given)
      }{
         An optional array containing the variance of the values
         in the input data array, used to generate a weight for each
         element.  It is only used if VARWTS is .TRUE..
      }
      \sstsubsection{
         SIZE = INTEGER (Given)
      }{
         The total number of pixels.
      }
      \sstsubsection{
         X( SIZE ) = DOUBLE PRECISION (Returned)
      }{
         The mean x positions for each pixel
      }
      \sstsubsection{
         Y( SIZE ) = DOUBLE PRECISION (Returned)
      }{
         The mean y positions for each pixel.
      }
      \sstsubsection{
         Z( SIZE ) = DOUBLE PRECISION (Returned)
      }{
         The data value for each pixel.
      }
      \sstsubsection{
         W( SIZE ) = DOUBLE PRECISION (Returned)
      }{
         The weight for each pixel.
      }
      \sstsubsection{
         NGOOD = INTEGER (Returned)
      }{
         The number of good pixels.
      }
      \sstsubsection{
         XMIN = DOUBLE PRECISION (Returned)
      }{
         Minimum x co-ordinate.
      }
      \sstsubsection{
         XMAX = DOUBLE PRECISION (Returned)
      }{
         Maximum x co-ordinate.
      }
      \sstsubsection{
         YMIN = DOUBLE PRECISION (Returned)
      }{
         Minimum y co-ordinate.
      }
      \sstsubsection{
         YMAX = DOUBLE PRECISION (Returned)
      }{
         Maximum y co-ordinate.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY and VAR arrays supplied to the routine must have the data
         type specified.

         \sstitem
         Uses the magic-value method for bad or undefined pixels.
      }
   }
}
\sstroutine{
   KPG1\_XYZWx
}{
   Converts a 2-dimensional array into a list of x-y co-ordinates,
   values and weights
}{
   \sstdescription{
      This routine converts a 2-dimensional array into a list of x-y
      coordinates, data values and weights for each of the good pixels
      in the array.  The x-y co-ordinates come from the axis arrays
      supplied.  Bad pixels are ignored if BAD is .TRUE..  If VARWTS is
      .TRUE., weights are calculated from the reciprocal of the
      variance for each pixel, otherwise the weights are returned 1.0.
   }
   \sstinvocation{
      CALL KPG1\_XYZWx( DIM1, DIM2, ARRAY, XAXIS, YAXIS, BAD, VARWTS,
                       VAR, SIZE, X, Y, Z, W, NGOOD, XMIN, XMAX, YMIN,
                       YMAX, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         DIM1 = INTEGER (Given)
      }{
         The first dimension of the 2-dimensional array.
      }
      \sstsubsection{
         DIM2 = INTEGER (Given)
      }{
         The second dimension of the 2-dimensional array.
      }
      \sstsubsection{
         ARRAY( DIM1, DIM2 ) = ? (Given)
      }{
         The input data array.
      }
      \sstsubsection{
         XAXIS( DIM1 ) = DOUBLE PRECISION (Given)
      }{
         X axis co-ordinates for the input data array.
      }
      \sstsubsection{
         YAXIS( DIM2 ) = DOUBLE PRECISION (Given)
      }{
         Y axis co-ordinates for the input data array.
      }
      \sstsubsection{
         BAD = LOGICAL (Given)
      }{
         Flag indicating whether bad values are likely to be present.
      }
      \sstsubsection{
         VARWTS = LOGICAL (Given)
      }{
         Flag indicating if the variance array contains valid data.
      }
      \sstsubsection{
         VAR( DIM1, DIM2 ) = ? (Given)
      }{
         An optional array containing the variance of the values
         in the input data array, used to generate a weight for each
         element.  It is only used if VARWTS is .TRUE..
      }
      \sstsubsection{
         SIZE = INTEGER (Given)
      }{
         The total number of pixels.
      }
      \sstsubsection{
         X( SIZE ) = DOUBLE PRECISION (Returned)
      }{
         The mean x positions for each pixel
      }
      \sstsubsection{
         Y( SIZE ) = DOUBLE PRECISION (Returned)
      }{
         The mean y positions for each pixel.
      }
      \sstsubsection{
         Z( SIZE ) = DOUBLE PRECISION (Returned)
      }{
         The data value for each pixel.
      }
      \sstsubsection{
         W( SIZE ) = DOUBLE PRECISION (Returned)
      }{
         The weight for each pixel.
      }
      \sstsubsection{
         NGOOD = INTEGER (Returned)
      }{
         The number of good pixels.
      }
      \sstsubsection{
         XMIN = DOUBLE PRECISION (Returned)
      }{
         Minimum x co-ordinate.
      }
      \sstsubsection{
         XMAX = DOUBLE PRECISION (Returned)
      }{
         Maximum x co-ordinate.
      }
      \sstsubsection{
         YMIN = DOUBLE PRECISION (Returned)
      }{
         Minimum y co-ordinate.
      }
      \sstsubsection{
         YMAX = DOUBLE PRECISION (Returned)
      }{
         Maximum y co-ordinate.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         Global status value.
      }
   }
   \sstnotes{
      \sstitemlist{

         \sstitem
         There is a routine for each numeric data type: replace {\tt "}x{\tt "} in
         the routine name by D, R, I, W, UW, B or UB as appropriate.  The
         ARRAY and VAR arrays supplied to the routine must have the data
         type specified.

         \sstitem
         Uses the magic-value method for bad or undefined pixels.
      }
   }
}
\sstroutine{
   KPG1\_ZONES
}{
   Creates zones for plotting with an existing DATA zone
}{
   \sstdescription{
      Given a current zone, and an existing DATA zone contained within
      the current zone, this routine creates three new zones, all
      contained within the current zone:

      1) Graph window zone - this is a zone corresponding to the NCAR
      {\tt "}graph window{\tt "} (i.e. the area which contains the data plot and
      any surrounding annotation, axes, etc).  It is created with the
      default SGS uniform co-ordinates system.  It is positioned so that
      the existing DATA zone is centred within it, leaving a margin for
      axes, annotation etc.  If the graph window zone would extend
      beyond the zone current on entry to this routine, then no graph
      window zone is created, and GOK is returned .FALSE..

      2) KEY zone - this is a zone in which a key may be produced.  It
      is position to the right of the existing DATA window, and is
      created with the given aspect ratio (see argument ASPKEY).  Its
      width is limited to be no more than half the maximum dimension of
      the DATA zone.  Its top-left corner is level with the top of the
      DATA zone and just outside the graph-window zone.  It is created
      with the default SGS uniform co-ordinates system.  If the zone
      would be less than 2 millimetres in size along either dimension
      then no zone is created and KOK is returned .FALSE..

      3) FRAME zone - this is a zone which just encompasses the existing
      DATA zone and all the zones succesSfully created by this routine.
      It is created with the default SGS uniform co-ordinates system.

      On exit, the current zone is the FRAME zone.
   }
   \sstinvocation{
      CALL KPG1\_ZONES( ZONED, ASPKEY, ZONEF, ZONEK, ZONEG, GOK, KOK,
                       STATUS )
   }
   \sstarguments{
      \sstsubsection{
         ZONED = INTEGER (Given)
      }{
         An identifier for the existing DATA zone.
      }
      \sstsubsection{
         ASPKEY = REAL (Given)
      }{
         The aspect ratio (width/height) required for the KEY zone (in
         which width and height are expressed in metres).
      }
      \sstsubsection{
         ZONEF = INTEGER (Returned)
      }{
         Identifier for the FRAME zone.
      }
      \sstsubsection{
         ZONEK = INTEGER (Returned)
      }{
         Identifier for the KEY zone.  Returned equal to zero if KOK is
         returned .FALSE..
      }
      \sstsubsection{
         ZONEG = INTEGER (Returned)
      }{
         Identifier for the graph window zone.  Returned equal to zero
         if GOK is returned .FALSE..
      }
      \sstsubsection{
         GOK = LOGICAL (Returned)
      }{
         Returned .TRUE. if a there was room within the current zone to
         create a graph-window zone.  Returned .FALSE. otherwise.
      }
      \sstsubsection{
         KOK = LOGICAL (Returned)
      }{
         Returned .TRUE. if a there was room within the current zone to
         create a KEY zone.  Returned .FALSE. otherwise.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   KPG1\_ZOPIC
}{
   Creates zones required to produce a plot with key and axes
}{
   \sstdescription{
      This routine creates the zones required for the various parts of a plot
      (FRAME, KEY, DATA and graph window).  If a DATA picture is
      contained within the current picture then it is used to define
      the zone in which to produce the data plot.  In this case, the
      bounds of the displayed DATA picture (in pixel co-ordinates) are
      returned in SXLO, etc.  Otherwise, the user is asked for a FRAME
      picture size and the DATA picture is created within it using the
      supplied values of SXLO, etc.  The current zone is unchanged on
      exit.  A picture corresponding to the new FRAME zone is stored in
      the AGI database.
   }
   \sstinvocation{
      CALL KPG1\_ZOPIC( PNXSIZ, PNYSIZ, COMMNT, ASPKEY, XLO, XHI, YLO,
                       YHI, KEY, AXES, ZONEF, ZONED, ZONEK, ZONEG,
                       PICIDF, XM, YM, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PNXSIZ = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use when obtaining the x size of
         a FRAME picture.  Only used if the current picture does not
         contain a DATA picture.
      }
      \sstsubsection{
         PNXSIZ = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The name of the parameter to use when obtaining the y size of
         a FRAME picture.  Only used if the current picture does not
         contain a DATA picture.
      }
      \sstsubsection{
         COMMNT = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A comment to store with the new FRAME picture.
      }
      \sstsubsection{
         ASPKEY = REAL (Given)
      }{
         The aspect ratio required for the KEY zone.
      }
      \sstsubsection{
         XLO = REAL (Given and Returned)
      }{
         On entry: The lower x bound of the data array available for
         plotting, in pixel co-ordinates.
         On exit: The returned value depends on whether or not a DATA
         picture was found within the current picture.  If a DATA
         picture was found, the returned value is the lower x bound of
         the DATA picture.  Otherwise the returned value is equal to
         the supplied value.
      }
      \sstsubsection{
         XHI = REAL (Given and Returned)
      }{
         The upper x bound of the DATA zone.  See XLO.
      }
      \sstsubsection{
         YLO = REAL (Given and Returned)
      }{
         The lower y bound of the DATA zone.  See XLO.
      }
      \sstsubsection{
         YHI = REAL (Given and Returned)
      }{
         The upper y bound of the DATA zone.  See XLO.
      }
      \sstsubsection{
         KEY = LOGICAL (Given and Returned)
      }{
         On entry: whether or not a key has been requested.
         On exit: set .FALSE. if a key was requested but there is
         insufficient room within the current zone to produce one.  A
         warning message is issued if this occurs.  Otherwise it
         retains its value on entry.
      }
      \sstsubsection{
         AXES = LOGICAL (Given and Returned)
      }{
         On entry: whether or not annotated axes have been requested.
         On exit: set .FALSE. if annotated axes were requested but
         there is insufficient room within the current zone to produce
         them.  A warning message is issued if this occurs.  Otherwise
         it retains its value on entry.
      }
      \sstsubsection{
         ZONEF = INTEGER (Returned)
      }{
         Identifier for the FRAME zone.
      }
      \sstsubsection{
         ZONED = INTEGER (Returned)
      }{
         Identifier for the DATA zone.
      }
      \sstsubsection{
         ZONEK = INTEGER (Returned)
      }{
         Identifier for the KEY zone.  Returned set to zero if KEY is
         returned .FALSE..
      }
      \sstsubsection{
         ZONEG = INTEGER (Returned)
      }{
         Identifier for the graph window zone.  Returned set to zero if
         AXES is returned .FALSE..
      }
      \sstsubsection{
         PICIDF = INTEGER (Returned)
      }{
         AGI identifier for the FRAME picture.
      }
      \sstsubsection{
         XM = REAL (Returned)
      }{
         The physical x dimension of the DATA zone in metres.
      }
      \sstsubsection{
         YM = REAL (Returned)
      }{
         The physical y dimension of the DATA zone in metres.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   LPG\_AGAIN
}{
   Decide if the application should be executed again
}{
   \sstdescription{
      This routine is used to allow multiple invocations of an application
      within an Starlink monolith to process a group of data files. The
      initialization routine LPG\_START should be called prior to this
      routine. This routine returns a logical flag indicating if the
      application should be invoked again. A typical way to use this
      routine within a monolith is as follows:

         CALL LPG\_START( STATUS )
         DO WHILE( LPG\_AGAIN( STATUS ) )
            IF( ACTION .EQ. {\tt '}ADD{\tt '} ) THEN
               CALL ADD( STATUS )
            ELSE IF( ACTION .EQ. {\tt '}SUB{\tt '} ) THEN
               CALL SUB( SATUS )
            ELSE IF...
            ...
            END IF
         END DO

      The application corresponding to the required action will always be
      invoked once. The applications should use the routines LPG\_ASSOC,
      LPG\_PROP, LPG\_CREAT and LPG\_CREP to get identifier for NDFs, in
      place of the usual routines from the NDF library. For catalogues,
      routines LPG\_CATASSOC and LPG\_CATCREAT should be used in place of
      CAT\_ASSOC and CAT\_CREAT.

      LPG\_AGAIN returns a .TRUE. value until a group of data files is
      exhausted, where-upon it deletes all its groups and returns a
      .FALSE. value.

      On the first invocation of the application, groups of data files are
      obtained whenever one of the above LPG routines is used to get an NDF
      or CAT identifier, and an identifier corresponding to the first name in
      each group is returned to the application. On subsequent invocation,
      the names in the groups obtained during the first invocation are used
      without obtaining new parameter values from the environment. The
      index of the returned data file within each group is increment by 1
      each time the application is invoked.

      If an application is invoked more than once, all other parameters
      retain the values they had at the end of the first invocation.
      Applications which use this scheme should avoid having parameters
      with {\tt "}VPATH=DYNAMIC{\tt "} in the interace file, since the dynamic
      default calculated on the first invocation will then be re-used for
      all subsequent invocations, which may be inappropriate. A better
      scheme is to have {\tt "}VPATH=DEFAULT{\tt "}, {\tt "}PPATH=DYNAMIC{\tt "} and {\tt "}DEFAULT=!{\tt "}.
      The code should then annull any PAR\_\_NULL status after accessing
      the parameter, and use the previously calculated dynamic default
      value for the parameter. With this scheme, the parameter value is
      {\tt "}!{\tt "} at the end of the first invocation, and so retains this value
      for all subsequent invocations, resulting in appropriate dynamic
      defaults being used.

      A situation in which the above suggestion doesn{\tt '}t work is if an
      application sometimes sets a dynamic default, and sometimes doesn{\tt '}t.
      In this case, you do not want to have VPATH=DEFAULT,DEFAULT=! because
      this would require the application to abort in the cases where there
      is no dynamic default available. It is probably better in these
      cases to have VPATH=PROMPT,PPATH=DYNAMIC and accept the fact that
      the user will be prompted for a parameter which was previously
      defaulted.

      Some applications test to see if a parameter was specified on the
      command line, and vary their behaviour accordingly. This is done by
      checking the state of the parameter before accessing it, a state of
      SUBPAR\_\_ACTIVE indicating that the parameter already has a value.
      This is OK on the first invocation, but not on subsequent
      invocations because the first invocation may have set a parameter
      value, resulting in subsequent invocations thinking that the
      parameter was given on the command line. To avoid this,
      applications should use LPG\_STATE in place of PAR\_STATE. LPG\_STATE
      remembers the state of the parameter on the first invocation, and
      returns that state, rather than the current parameter state, on
      subsequent invocations.
   }
   \sstinvocation{
      RESULT = LPG\_AGAIN( STATUS )
   }
   \sstarguments{
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
   \sstreturnedvalue{
      \sstsubsection{
         LPG\_AGAIN = LOGICAL
      }{
         .TRUE. if the application should be executed again.
      }
   }
}
\sstroutine{
   LPG\_ASSOC
}{
   Obtain an identifier for an existing NDF via the parameter system
}{
   \sstdescription{
      This routine should be called in place of NDF\_ASSOC within
      applications which process groups of NDFs.

      On the first invocation of the applicaton, a group of names of
      existing NDFs will be obtained from the environment using the
      specified parameter, and an NDF identifier for the first one
      will be returned. If more than one NDF was supplied for the
      parameter then the application may be invoked again (see
      LPG\_AGAIN), in which case this routine will return an identifier
      for the next NDF in the group supplied on the first invocation.

      If an application attempts to get a new NDF by cancelling the
      parameter (PAR\_CANCL), the returned NDF is NOT the next one in
      the group, but is obtained by prompting the user for a single NDF.

      The monolith routine should arrange to invoke the application
      repeatedly until one or more of its NDF parameters have been
      exhausted (i.e. all its values used). See NDF\_AGAIN.
   }
   \sstinvocation{
      CALL LPG\_ASSOC( PARAM, MODE, INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the parameter.
      }
      \sstsubsection{
         MODE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Type of NDF access required: {\tt '}READ{\tt '}, {\tt '}UPDATE{\tt '} or {\tt '}WRITE{\tt '}.
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   LPG\_CATASSOC
}{
   Obtain an identifier for an existing catalogue via the parameter
   system
}{
   \sstdescription{
      This routine should be called in place of CAT\_ASSOC within
      applications which process groups of catalogues.

      On the first invocation of the applicaton, a group of names of
      existing catalogues will be obtained from the environment using the
      specified parameter, and a CAT identifier for the first one
      will be returned. If more than one catalogue was supplied for the
      parameter then the application may be invoked again (see
      LPG\_AGAIN), in which case this routine will return an identifier
      for the next catalogue in the group supplied on the first invocation.

      If an application attempts to get a new catalogue by cancelling the
      parameter (PAR\_CANCL), the returned catalogue is NOT the next one in
      the group, but is obtained by prompting the user for a single catalogue.

      The monolith routine should arrange to invoke the application
      repeatedly until one or more of its catalogue parameters have been
      exhausted (i.e. all its values used). See CAT\_AGAIN.
   }
   \sstinvocation{
      CALL LPG\_CATASSOC( PARAM, MODE, CI, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the parameter.
      }
      \sstsubsection{
         MODE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Type of catalogue access required: {\tt '}READ{\tt '}, or {\tt '}WRITE{\tt '}.
      }
      \sstsubsection{
         CI = INTEGER (Returned)
      }{
         catalogue identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   LPG\_CATCREAT
}{
   Create a new catalogue via the parameter system
}{
   \sstdescription{
      This routine should be called in place of CAT\_CREAT within
      applications which process lists of catalogues.

      On the first invocation of the applicaton, a group of names for
      some new catalogues will be obtained from the environment using the
      specified parameter. The first name will be used to create an catalogue
      with the requested attributes, and an identifier for the new catalogue
      will be returned. If more than one name was supplied for the parameter
      then the application may be invoked again (see LPG\_AGAIN), in which
      case this routine will return an identifier for a new catalogue with the
      next name in the group supplied on the first invocation.

      If a modification element is included in the group expression
      supplied for the parameter on the first invocation of the
      application, the new catalogue names are based on the names of the
      first group of existing data files (catalogues or NDFs) to be
      accessed by the application.

      If an application attempts to get a new catalogue by cancelling the
      parameter (PAR\_CANCL), the name used to create the returned catalogue
      is NOT the next one in the group, but is obtained by prompting the
      user for a single new catalogue.

      The monolith routine should arrange to invoke the application
      repeatedly until one or more of its catalogue parameters have been
      exhausted (i.e. all its values used). See CAT\_AGAIN.
   }
   \sstinvocation{
      CALL LPG\_CATCREAT( PARAM, CI, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the parameter.
      }
      \sstsubsection{
         CI = INTEGER (Returned)
      }{
         catalogue identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   LPG\_CREA1
}{
   Create a single new simple NDF using a specified parameter
}{
   \sstdescription{
      This routine is equivalent to NDF\_CREAT except that it allows the
      NDF to be specified using a GRP group expression (for instance, its
      name may be given within a text file, etc). The first NDF in the
      group expression is returned. Any other names in the group
      expression are ignored. Any modification elements in the supplied
      group expression will be treated literally.
   }
   \sstinvocation{
      CALL LPG\_CREA1( PARAM, FTYPE, NDIM, LBND, UBND, INDF, NAME,
                      STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the ADAM parameter.
      }
      \sstsubsection{
         FTYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Full data type of the NDF{\tt '}s DATA component (e.g. {\tt '}\_DOUBLE{\tt '} or
         {\tt '}COMPLEX\_REAL{\tt '}).
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of NDF dimensions.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Given)
      }{
         Lower pixel-index bounds of the NDF.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         Upper pixel-index bounds of the NDF.
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The full file specification for the NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   LPG\_CREAT
}{
   Create a new simple NDF via the parameter system
}{
   \sstdescription{
      This routine should be called in place of NDF\_CREAT within
      applications which process lists of NDFs.

      On the first invocation of the applicaton, a group of names for
      some new NDFs will be obtained from the environment using the
      specified parameter. The first name will be used to create an NDF
      with the requested attributes, and an identifier for the new NDF will
      be returned. If more than one name was supplied for the parameter
      then the application may be invoked again (see LPG\_AGAIN), in which
      case this routine will return an identifier for a new NDF with the
      next name in the group supplied on the first invocation.

      If a modification element is included in the group expression
      supplied for the parameter on the first invocation of the
      application, the new NDF names are based on the names of the
      first group of existing data files (NDFs or catalogues) to be
      accessed by the application.

      If an application attempts to get a new NDF by cancelling the
      parameter (PAR\_CANCL), the name used to create the returned NDF is
      NOT the next one in the group, but is obtained by prompting the
      user for a single new NDF.

      The monolith routine should arrange to invoke the application
      repeatedly until one or more of its NDF parameters have been
      exhausted (i.e. all its values used). See NDF\_AGAIN.
   }
   \sstinvocation{
      CALL LPG\_CREAT( PARAM, FTYPE, NDIM, LBND, UBND, INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the parameter.
      }
      \sstsubsection{
         FTYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Full data type of the NDF{\tt '}s DATA component (e.g. {\tt '}\_DOUBLE{\tt '} or
         {\tt '}COMPLEX\_REAL{\tt '}).
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of NDF dimensions.
      }
      \sstsubsection{
         LBND( NDIM ) = INTEGER (Given)
      }{
         Lower pixel-index bounds of the NDF.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         Upper pixel-index bounds of the NDF.
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   LPG\_CREP1
}{
   Create a single new primitive NDF using a specified parameter
}{
   \sstdescription{
      This routine is equivalent to NDF\_CREP except that it allows the
      NDF to be specified using a GRP group expression (for instance, its
      name may be given within a text file, etc). The first NDF in the
      group expression is returned. Any other names in the group
      expression are ignored. Any modification elements in the supplied
      group expression will be treated literally.
   }
   \sstinvocation{
      CALL LPG\_CREP1( PARAM, FTYPE, NDIM, UBND, INDF, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the ADAM parameter.
      }
      \sstsubsection{
         FTYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Type of the NDF{\tt '}s DATA component (e.g. {\tt '}\_REAL{\tt '}). Note that
         complex types are not permitted when creating a primitive NDF.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of NDF dimensions.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         Upper pixel-index bounds of the NDF (the lower bound of each
         dimension is taken to be 1).
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The full file specification for the NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   LPG\_CREP
}{
   Create a new primitive NDF via the parameter system
}{
   \sstdescription{
      This routine should be called in place of NDF\_CREP within
      applications which process lists of NDFs.

      On the first invocation of the applicaton, a group of names for
      some new NDFs will be obtained from the environment using the
      specified parameter. The first name will be used to create an NDF
      with the requested attributes, and an identifier for the new NDF will
      be returned. If more than one name was supplied for the parameter
      then the application may be invoked again (see LPG\_AGAIN), in which
      case this routine will return an identifier for a new NDF with the
      next name in the group supplied on the first invocation.

      If a modification element is included in the group expression
      supplied for the parameter on the first invocation of the
      application, the new NDF names are based on the names of the
      first group of existing data files (NDFs or catalogues) to be
      accessed by the application.

      If an application attempts to get a new NDF by cancelling the
      parameter (PAR\_CANCL), the name used to create the returned NDF is
      NOT the next one in the group, but is obtained by prompting the
      user for a single new NDF.

      The monolith routine should arrange to invoke the application
      repeatedly until one or more of its NDF parameters have been
      exhausted (i.e. all its values used). See NDF\_AGAIN.
   }
   \sstinvocation{
      CALL LPG\_CREP( PARAM, FTYPE, NDIM, UBND, INDF, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the parameter.
      }
      \sstsubsection{
         FTYPE = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Type of the NDF{\tt '}s DATA component (e.g. {\tt '}\_REAL{\tt '}). Note that
         complex types are not permitted when creating a primitive NDF.
      }
      \sstsubsection{
         NDIM = INTEGER (Given)
      }{
         Number of NDF dimensions.
      }
      \sstsubsection{
         UBND( NDIM ) = INTEGER (Given)
      }{
         Upper pixel-index bounds of the NDF (the lower bound of each
         dimension is taken to be 1).
      }
      \sstsubsection{
         INDF = INTEGER (Returned)
      }{
         NDF identifier.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   LPG\_PROP1
}{
   Create a single new NDF by propagation using a specified parameter
}{
   \sstdescription{
      This routine is equivalent to NDF\_PROP except that it allows the
      NDF to be specified using a GRP group expression (for instance, its
      name may be given within a text file, etc). The first NDF in the
      group expression is returned. Any other names in the group
      expression are ignored. Modification elements use the name of the
      supplied NDF as the basis name.
   }
   \sstinvocation{
      CALL LPG\_PROP1( INDF1, CLIST, PARAM, INDF2, NAME, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF1 = INTEGER (Given)
      }{
         Identifier for an existing NDF (or NDF section) to act as a
         template.
      }
      \sstsubsection{
         CLIST = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A comma-separated list of the NDF components which are to be
         propagated to the new data structure. By default, the HISTORY,
         LABEL and TITLE components and all extensions are propagated.
         See the {\tt "}Component Propagation{\tt "} section for further details.
      }
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the ADAM parameter for the new NDF.
      }
      \sstsubsection{
         INDF2 = INTEGER (Returned)
      }{
         Identifier for the new NDF.
      }
      \sstsubsection{
         NAME = CHARACTER $*$ ( $*$ ) (Returned)
      }{
         The full file specification for the NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   LPG\_PROP
}{
   Propagate NDF information to create a new NDF via the
   parameter system
}{
   \sstdescription{
      This routine should be called in place of NDF\_PROP within
      applications which process groups of NDFs.

      On the first invocation of the applicaton, a group of names for
      some new NDFs will be obtained from the environment using the
      specified parameter. The first name will be used to create an NDF
      by propagation from INDF1, and an identifier for the new NDF will
      be returned. If more than one name was supplied for the parameter
      then the application may be invoked again (see LPG\_AGAIN), in which
      case this routine will return an identifier for a new NDF with the
      next name in the group supplied on the first invocation.

      If a modification element is included in the group expression
      supplied for the parameter on the first invocation of the
      application, the new NDF names are based on the names of the
      first group of existing data files (NDFs or catalogues) to be
      accessed by the application.

      If an application attempts to get a new NDF by cancelling the
      parameter (PAR\_CANCL), the name used to create the returned NDF is
      NOT the next one in the group, but is obtained by prompting the
      user for a single new NDF.

      The monolith routine should arrange to invoke the application
      repeatedly until one or more of its NDF parameters have been
      exhausted (i.e. all its values used). See NDF\_AGAIN.
   }
   \sstinvocation{
      CALL LPG\_PROP( INDF1, CLIST, PARAM, INDF2, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         INDF1 = INTEGER (Given)
      }{
         Identifier for an existing NDF (or NDF section) to act as a
         template.
      }
      \sstsubsection{
         CLIST = CHARACTER $*$ ( $*$ ) (Given)
      }{
         A comma-separated list of the NDF components which are to be
         propagated to the new data structure. By default, the HISTORY,
         LABEL and TITLE components and all extensions are propagated.
         See the {\tt "}Component Propagation{\tt "} section for further details.
      }
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         Name of the parameter for the new NDF.
      }
      \sstsubsection{
         INDF2 = INTEGER (Returned)
      }{
         Identifier for the new NDF.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   LPG\_REPLA
}{
   Indicate if input NDFs can be replaced
}{
   \sstdescription{
      Sets a flag indicating if LPG applications can use a single NDF as
      both input and output. If so, a temporary NDF is used to store
      the output. This NDF is then used to replace the existing input NDF once
      the application has completed. If REPLAC is .FALSE. (the default), an
      error is reported if an attempt is made to use a single NDF as both input
      and output.
   }
   \sstinvocation{
      CALL LPG\_REPLA( REPLAC, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         REPLAC = LOGICAL (Given)
      }{
         If .TRUE., a single NDF can be used as both input and output
         from an application. If .FALSE., an error will be reported if this
         is attempted.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}
\sstroutine{
   LPG\_START
}{
   Initialise the contents of the LPG common blocks
}{
   \sstdescription{
      Initialises the global variables used by LPG. See LPG\_AGAIN.
   }
   \sstinvocation{
      CALL LPG\_START( VERBO, DELAYO, DISABO, REPLA0, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         VERBO = LOGICAL (Given)
      }{
         If .TRUE. then the name of the data file being used for each
      }
   }
}
\sstroutine{
   LPG\_STATE
}{
   Return the original PAR state of a parameter
}{
   \sstdescription{
      On the first invocation of the application, this routines returns
      the current PAR state of specified parameter and stores it in
      common. On subsequent invocations, the stored state is returned
      rather than the current state.
   }
   \sstinvocation{
      CALL LPG\_STATE( PARAM, STATE, STATUS )
   }
   \sstarguments{
      \sstsubsection{
         PARAM = CHARACTER $*$ ( $*$ ) (Given)
      }{
         The parameter name.
      }
      \sstsubsection{
         STATE = INTEGER (Returned)
      }{
         The original PAR state of the parameter.
      }
      \sstsubsection{
         STATUS = INTEGER (Given and Returned)
      }{
         The global status.
      }
   }
}

\normalsize


\end{document}
